<!DOCTYPE html><html><head><title>Help for package hitandrun</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hitandrun}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bbReject'>
<p>Bounding box rejection sampler</p></a></li>
<li><a href='#createBoundBox'>
<p>Calculate a bounding box</p></a></li>
<li><a href='#createSeedPoint'>
<p>Generate a seed point</p></a></li>
<li><a href='#createTransform'>
<p>Create transformation matrices</p></a></li>
<li><a href='#eliminateRedundant'>
<p>Eliminate redundant linear constraints</p></a></li>
<li><a href='#findExtremePoints'>
<p>Find extreme points</p></a></li>
<li><a href='#findFace'>
<p>Find the closest face (constraint) to an interior point of a polytope.</p></a></li>
<li><a href='#findInteriorPoint'>
<p>Find an interior point</p></a></li>
<li><a href='#findVertices'>
<p>Find vertices of the polytope</p></a></li>
<li><a href='#har'>
<p>&quot;Hit and Run&quot; sampler</p></a></li>
<li><a href='#harConstraints'>
<p>Constraint formulation utility functions</p></a></li>
<li><a href='#hitandrun'>
<p>&quot;Hit and Run&quot; sampler</p></a></li>
<li><a href='#hitandrun-package'>
<p>&quot;Hit and Run&quot; sampling</p></a></li>
<li><a href='#hypersphere.sample'>
<p>Sample uniformly from an n-hypersphere</p></a></li>
<li><a href='#sab'>
<p>&quot;Shake and Bake&quot; sampler</p></a></li>
<li><a href='#shakeandbake'>
<p>&quot;Shake and Bake&quot; sampler</p></a></li>
<li><a href='#simplex.createConstraints'>
<p>Create constraints that define the (n-1)-simplex</p></a></li>
<li><a href='#simplex.createTransform'>
<p>Transform points on an (n-1)-simplex to n-dimensional space</p></a></li>
<li><a href='#simplex.sample'>
<p>Sample uniformly from a simplex</p></a></li>
<li><a href='#solution.basis'>
<p>Calculate the basis for the solution space of a system of linear equations</p></a></li>
<li><a href='#transformConstraints'>
<p>Apply a transformation to a set of linear constraints.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>"Hit and Run" and "Shake and Bake" for Sampling Uniformly from
Convex Shapes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5-6</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-26</td>
</tr>
<tr>
<td>Description:</td>
<td>The "Hit and Run" Markov Chain Monte Carlo method for sampling uniformly from convex shapes defined by linear constraints, and the "Shake and Bake" method for sampling from the boundary of such shapes. Includes specialized functions for sampling normalized weights with arbitrary linear constraints. Tervonen, T., van Valkenhoef, G., Basturk, N., and Postmus, D. (2012) &lt;<a href="https://doi.org/10.1016%2Fj.ejor.2012.08.026">doi:10.1016/j.ejor.2012.08.026</a>&gt;. van Valkenhoef, G., Tervonen, T., and Postmus, D. (2014) &lt;<a href="https://doi.org/10.1016%2Fj.ejor.2014.06.036">doi:10.1016/j.ejor.2014.06.036</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gertvv/hitandrun">https://github.com/gertvv/hitandrun</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>rcdd (&ge; 1.1), stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 0.8)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-27 11:31:10 UTC; gert</td>
</tr>
<tr>
<td>Author:</td>
<td>Gert van Valkenhoef [aut, cre, cph],
  Tommi Tervonen [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gert van Valkenhoef &lt;gert@gertvv.nl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-27 13:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bbReject'>
Bounding box rejection sampler
</h2><span id='topic+bbReject'></span>

<h3>Description</h3>

<p>Generates uniform random variates over a convex polytope defined by a set of linear constraints by generating uniform variates over a bounding box and rejecting those outside the polytope.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bbReject(lb, ub, constr, N, homogeneous=FALSE, transform=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bbReject_+3A_lb">lb</code></td>
<td>
<p>Lower bound for each dimension (not including homogeneous coordinate)</p>
</td></tr>
<tr><td><code id="bbReject_+3A_ub">ub</code></td>
<td>
<p>Upper bound for each dimension (not including homogeneous coordinate)</p>
</td></tr>
<tr><td><code id="bbReject_+3A_constr">constr</code></td>
<td>
<p>Constraint definition (see details)</p>
</td></tr>
<tr><td><code id="bbReject_+3A_n">N</code></td>
<td>
<p>Number of samples to generate</p>
</td></tr>
<tr><td><code id="bbReject_+3A_homogeneous">homogeneous</code></td>
<td>
<p>Whether constr and transform are given in homogeneous coordinate representation (see details)</p>
</td></tr>
<tr><td><code id="bbReject_+3A_transform">transform</code></td>
<td>
<p>Transformation matrix to apply to the generated samples (optional)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+har">har</a></code> for a description of the constraint definition and the homogeneous coordinate representation.
</p>


<h3>Value</h3>

<p>A list, containing:
</p>
<table>
<tr><td><code>samples</code></td>
<td>
<p>A matrix containing the generated samples as rows.</p>
</td></tr>
<tr><td><code>rejectionRate</code></td>
<td>
<p>The mean number of samples rejected for each accepted sample.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gert van Valkenhoef
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createBoundBox">createBoundBox</a></code>
</p>
<p><code><a href="#topic+harConstraints">harConstraints</a></code>
<code><a href="#topic+simplex.createTransform">simplex.createTransform</a></code>
<code><a href="#topic+simplex.createConstraints">simplex.createConstraints</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># constraints: x_1 &gt;= 0, x_2 &gt;= 0, x_1 + x_2 &lt;= 1
A &lt;- rbind(c(-1, 0), c(0, -1), c(1, 1))
b &lt;- c(0, 0, 1)
d &lt;- c("&lt;=", "&lt;=", "&lt;=")
constr &lt;- list(constr=A, rhs=b, dir=d)

# create a bounding box that contains the polytope
lb &lt;- c(0, 0)
ub &lt;- c(1, 1)

# sample 10,000 points
samples &lt;- bbReject(lb, ub, constr, 1E4)$samples

# Check dimension of result
stopifnot(dim(samples) == c(1E4, 2))

# Check that x_i &gt;= 0
stopifnot(samples &gt;= 0)

# Check that x_1 + x_2 &lt;= 1
stopifnot(samples[,1] + samples[,2] &lt;= 1)

plot(samples)

</code></pre>

<hr>
<h2 id='createBoundBox'>
Calculate a bounding box
</h2><span id='topic+createBoundBox'></span>

<h3>Description</h3>

<p>Calculate a bounding box around a polytope given by a set of linear constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createBoundBox(constr, homogeneous=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createBoundBox_+3A_constr">constr</code></td>
<td>
<p>Constraint definition</p>
</td></tr>
<tr><td><code id="createBoundBox_+3A_homogeneous">homogeneous</code></td>
<td>
<p>Whether constr is given in homogeneous coordinate representation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+har">har</a></code> for a description of the constraint definition and the homogeneous coordinate representation.
</p>
<p>This function uses <code><a href="#topic+findExtremePoints">findExtremePoints</a></code> to find extreme points along each dimension.
</p>


<h3>Value</h3>

<table>
<tr><td><code>lb</code></td>
<td>
<p>Lower bound for each dimension (not including homogeneous coordinate).</p>
</td></tr>
<tr><td><code>ub</code></td>
<td>
<p>Upper bound for each dimension (not including homogeneous coordinate).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gert van Valkenhoef
</p>


<h3>See Also</h3>

<p><code><a href="#topic+har">har</a></code>
</p>
<p><code><a href="#topic+findExtremePoints">findExtremePoints</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># constraints: x_1 &gt;= 0, x_2 &gt;= 0, x_1 + x_2 &lt;= 1
A &lt;- rbind(c(-1, 0), c(0, -1), c(1, 1))
b &lt;- c(0, 0, 1)
d &lt;- c("&lt;=", "&lt;=", "&lt;=")
constr &lt;- list(constr=A, rhs=b, dir=d)

bb &lt;- createBoundBox(constr)
stopifnot(bb$lb == c(0.0, 0.0))
stopifnot(bb$ub == c(1.0, 1.0))
</code></pre>

<hr>
<h2 id='createSeedPoint'>
Generate a seed point
</h2><span id='topic+createSeedPoint'></span>

<h3>Description</h3>

<p>Generate a seed point inside a polytope given by a set of linear constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createSeedPoint(constr, homogeneous=FALSE, randomize=FALSE, method="slacklp")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createSeedPoint_+3A_constr">constr</code></td>
<td>
<p>Constraint definition</p>
</td></tr>
<tr><td><code id="createSeedPoint_+3A_homogeneous">homogeneous</code></td>
<td>
<p>Whether constr is given in homogeneous coordinate representation</p>
</td></tr>
<tr><td><code id="createSeedPoint_+3A_randomize">randomize</code></td>
<td>
<p>If TRUE, randomize the starting point</p>
</td></tr>
<tr><td><code id="createSeedPoint_+3A_method">method</code></td>
<td>
<p>How to obtain the starting point: &quot;slacklp&quot; for a linear program that maximizes the minimum slack, or &quot;vertices&quot; for a weighted average of the vertices of the polytope</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+har">har</a></code> for a description of the constraint definition and the homogeneous coordinate representation.
</p>

<ul>
<li><p>The &quot;slacklp&quot; method solves a linear program that maximizes the minimum slack on the inequality constraints.
When randomized, the slack on each constraint is randomly rescaled before maximization.
</p>
</li>
<li><p>The &quot;vertices&quot; method enumerates all vertices of the polytope and then calculates the weighted arithmetic mean of this set of points. If &lsquo;randomize&rsquo; is set, the weights are randomly generated, otherwise they are all equal and the generated point is the centroid of the polytope.
</p>
</li></ul>



<h3>Value</h3>

<p>A coordinate vector in the appropriate coordinate system.
</p>


<h3>Author(s)</h3>

<p>Gert van Valkenhoef
</p>


<h3>See Also</h3>

<p><code><a href="#topic+har">har</a></code>
</p>
<p><code><a href="#topic+findExtremePoints">findExtremePoints</a></code>
<code><a href="#topic+findVertices">findVertices</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># constraints: x_1 &gt;= 0, x_2 &gt;= 0, x_1 + x_2 &lt;= 1
A &lt;- rbind(c(-1, 0), c(0, -1), c(1, 1))
b &lt;- c(0, 0, 1)
d &lt;- c("&lt;=", "&lt;=", "&lt;=")
constr &lt;- list(constr=A, rhs=b, dir=d)

x0 &lt;- createSeedPoint(constr)
stopifnot(x0 &gt;= 0)
stopifnot(sum(x0) &lt;= 1)
</code></pre>

<hr>
<h2 id='createTransform'>
Create transformation matrices
</h2><span id='topic+createTransform'></span>

<h3>Description</h3>

<p>This function takes a basis, consisting of an <code class="reqn">n \times m</code> change of basis matrix and an <code class="reqn">n</code>-vector representing the origin of the <code class="reqn">m</code>-space, and generates a matrix to transform points in the <code class="reqn">m</code>-space, given in homogeneous coordinates, to the <code class="reqn">n</code>-space.
</p>
<p>The inverse transform can also be generated, and conversion can be to homogeneous coordinates instead of Cartesian ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createTransform(basis, inverse=FALSE, keepHomogeneous=inverse)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createTransform_+3A_basis">basis</code></td>
<td>
<p>Basis (and origin) for the <code class="reqn">m</code>-space (see <code><a href="#topic+solution.basis">solution.basis</a></code>)</p>
</td></tr>
<tr><td><code id="createTransform_+3A_inverse">inverse</code></td>
<td>
<p>TRUE to convert from <code class="reqn">n</code>-space coordinates to <code class="reqn">m</code>-space coordinates</p>
</td></tr>
<tr><td><code id="createTransform_+3A_keephomogeneous">keepHomogeneous</code></td>
<td>
<p>TRUE to convert to homogeneous coordinates rather than Cartesian</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multiply a coordinate vector in homogeneous coordinates by pre-multiplying by the generated matrix (see examples).
</p>


<h3>Value</h3>

<p>A transformation matrix.
</p>


<h3>Author(s)</h3>

<p>Gert van Valkenhoef
</p>


<h3>See Also</h3>

<p><code><a href="#topic+solution.basis">solution.basis</a></code>
</p>

<hr>
<h2 id='eliminateRedundant'>
Eliminate redundant linear constraints
</h2><span id='topic+eliminateRedundant'></span>

<h3>Description</h3>

<p>Given a set of linear constraints, gives a subset of these constraints that are non-redundant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eliminateRedundant(constr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eliminateRedundant_+3A_constr">constr</code></td>
<td>
<p>Constraints</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no constraints are redundant, returns the same set of constraints.
</p>


<h3>Value</h3>

<p>A set of non-redundant constraints.
</p>


<h3>Author(s)</h3>

<p>Gert van Valkenhoef, Tommi Tervonen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+harConstraints">harConstraints</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>constr &lt;- list(
  constr = rbind(
    c(-1  ,  0),
    c( 0  , -1),
    c( 1  ,  1),
    c( 0.5, -1)),
  dir = c('&lt;=', '&lt;=', '=', '&lt;='),
  rhs = c(0, 0, 1, 0))

constr &lt;- eliminateRedundant(constr)

stopifnot(nrow(constr$constr) == 3) # eliminates one constraint
</code></pre>

<hr>
<h2 id='findExtremePoints'>
Find extreme points
</h2><span id='topic+findExtremePoints'></span>

<h3>Description</h3>

<p>Find extreme points of a polytope given by a set of linear constraints along each dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findExtremePoints(constr, homogeneous=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findExtremePoints_+3A_constr">constr</code></td>
<td>
<p>Constraint definition</p>
</td></tr>
<tr><td><code id="findExtremePoints_+3A_homogeneous">homogeneous</code></td>
<td>
<p>Whether constr is given in homogeneous coordinate representation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+har">har</a></code> for a description of the constraint definition and the homogeneous coordinate representation.
</p>
<p>For n-dimensional coordinate vectors, solves 2n LPs to find the extreme points along each dimension.
</p>


<h3>Value</h3>

<p>A matrix, in which each row is a coordinate vector in the appropriate coordinate system.
</p>


<h3>Author(s)</h3>

<p>Gert van Valkenhoef
</p>


<h3>See Also</h3>

<p><code><a href="#topic+har">har</a></code>
</p>
<p><code><a href="#topic+findInteriorPoint">findInteriorPoint</a></code>
<code><a href="#topic+findVertices">findVertices</a></code>
</p>
<p><code><a href="rcdd.html#topic+lpcdd">lpcdd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># constraints: x_1 &gt;= 0, x_2 &gt;= 0, x_1 + x_2 &lt;= 1
A &lt;- rbind(c(-1, 0), c(0, -1), c(1, 1))
b &lt;- c(0, 0, 1)
d &lt;- c("&lt;=", "&lt;=", "&lt;=")
constr &lt;- list(constr=A, rhs=b, dir=d)

findExtremePoints(constr, homogeneous=FALSE)
</code></pre>

<hr>
<h2 id='findFace'>
Find the closest face (constraint) to an interior point of a polytope.
</h2><span id='topic+findFace'></span>

<h3>Description</h3>

<p>Find the closest face (constraint) to an interior point of a polytope defined by a set of linear constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findFace(x, constr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findFace_+3A_x">x</code></td>
<td>
<p>An interior point</p>
</td></tr>
<tr><td><code id="findFace_+3A_constr">constr</code></td>
<td>
<p>Constraint definition</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+har">har</a></code> for a description of the constraint definition.
</p>


<h3>Value</h3>

<p>A face index.
</p>


<h3>Author(s)</h3>

<p>Gert van Valkenhoef
</p>


<h3>See Also</h3>

<p><code><a href="#topic+har">har</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># constraints: x_1 &gt;= 0, x_2 &gt;= 0, x_1 + x_2 &lt;= 1
A &lt;- rbind(c(-1, 0), c(0, -1), c(1, 1))
b &lt;- c(0, 0, 1)
d &lt;- c("&lt;=", "&lt;=", "&lt;=")
constr &lt;- list(constr=A, rhs=b, dir=d)

stopifnot(findFace(c(0.1, 0.2), constr) == 1)
stopifnot(findFace(c(0.2, 0.1), constr) == 2)
stopifnot(findFace(c(0.4, 0.4), constr) == 3)
</code></pre>

<hr>
<h2 id='findInteriorPoint'>
Find an interior point
</h2><span id='topic+findInteriorPoint'></span>

<h3>Description</h3>

<p>Find an interior point of a polytope given by a set of linear constraints along each dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findInteriorPoint(constr, homogeneous=FALSE, randomize=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findInteriorPoint_+3A_constr">constr</code></td>
<td>
<p>Constraint definition</p>
</td></tr>
<tr><td><code id="findInteriorPoint_+3A_homogeneous">homogeneous</code></td>
<td>
<p>Whether constr is given in homogeneous coordinate representation</p>
</td></tr>
<tr><td><code id="findInteriorPoint_+3A_randomize">randomize</code></td>
<td>
<p>Whether the point should be randomized</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+har">har</a></code> for a description of the constraint definition and the homogeneous coordinate representation.
</p>
<p>Solves a slack-maximizing LP to find an interior point of the polytope defined by the given constraints.
The randomized version randomly scales the slack on each (non-redundant) constraint.
</p>


<h3>Value</h3>

<p>A vector.
</p>


<h3>Author(s)</h3>

<p>Gert van Valkenhoef
</p>


<h3>See Also</h3>

<p><code><a href="#topic+har">har</a></code>
</p>
<p><code><a href="#topic+findExtremePoints">findExtremePoints</a></code>
<code><a href="#topic+findVertices">findVertices</a></code>
</p>
<p><code><a href="rcdd.html#topic+lpcdd">lpcdd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># constraints: x_1 &gt;= 0, x_2 &gt;= 0, x_1 + x_2 &lt;= 1
A &lt;- rbind(c(-1, 0), c(0, -1), c(1, 1))
b &lt;- c(0, 0, 1)
d &lt;- c("&lt;=", "&lt;=", "&lt;=")
constr &lt;- list(constr=A, rhs=b, dir=d)

findInteriorPoint(constr, homogeneous=FALSE)
</code></pre>

<hr>
<h2 id='findVertices'>
Find vertices of the polytope 
</h2><span id='topic+findVertices'></span>

<h3>Description</h3>

<p>Find the vertices of a polytope given by a set of linear constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findVertices(constr, homogeneous=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findVertices_+3A_constr">constr</code></td>
<td>
<p>Constraint definition</p>
</td></tr>
<tr><td><code id="findVertices_+3A_homogeneous">homogeneous</code></td>
<td>
<p>Whether constr is given in homogeneous coordinate representation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+har">har</a></code> for a description of the constraint definition and the homogeneous coordinate representation.
</p>
<p>Uses the Avis-Fukuda pivoting algorithm to enumerate the vertices of the polytope.
</p>


<h3>Value</h3>

<p>A matrix, in which each row is a vertex of the polytope.
</p>


<h3>Author(s)</h3>

<p>Gert van Valkenhoef
</p>


<h3>See Also</h3>

<p><code><a href="#topic+har">har</a></code>
</p>
<p><code><a href="#topic+findExtremePoints">findExtremePoints</a></code>
<code><a href="#topic+findInteriorPoint">findInteriorPoint</a></code>
</p>
<p><code><a href="rcdd.html#topic+scdd">scdd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># constraints: x_1 &gt;= 0, x_2 &gt;= 0, x_1 + x_2 &lt;= 1
A &lt;- rbind(c(-1, 0), c(0, -1), c(1, 1))
b &lt;- c(0, 0, 1)
d &lt;- c("&lt;=", "&lt;=", "&lt;=")
constr &lt;- list(constr=A, rhs=b, dir=d)

findVertices(constr, homogeneous=FALSE)
</code></pre>

<hr>
<h2 id='har'>
&quot;Hit and Run&quot; sampler
</h2><span id='topic+har'></span>

<h3>Description</h3>

<p>The &quot;Hit and Run&quot; method generates a Markov Chain whose stable state converges on the uniform distribution over a convex polytope defined by a set of linear constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>har(x0, constr, N, thin=1, homogeneous=FALSE, transform=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="har_+3A_x0">x0</code></td>
<td>
<p>Starting point (must be in the polytope)</p>
</td></tr>
<tr><td><code id="har_+3A_constr">constr</code></td>
<td>
<p>Constraint definition (see details)</p>
</td></tr>
<tr><td><code id="har_+3A_n">N</code></td>
<td>
<p>Number of iterations to run</p>
</td></tr>
<tr><td><code id="har_+3A_thin">thin</code></td>
<td>
<p>Thinning factor (keep every 'thin'-th sample)</p>
</td></tr>
<tr><td><code id="har_+3A_homogeneous">homogeneous</code></td>
<td>
<p>Whether x0, constr and transform are given in homogeneous coordinate representation (see details)</p>
</td></tr>
<tr><td><code id="har_+3A_transform">transform</code></td>
<td>
<p>Transformation matrix to apply to the generated samples (optional)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constraints, starting point and transformation matrix can be given in homogeneous coordinate representation (an extra component is added to each vector, equal to 1.0).
This enables affine transformations (such as translation) to be applied to the coordinate vectors by the constraint and transformation matrices.
Be aware that while non-affine (perspective) transformations are also possible, they will not in general preserve uniformity of the generated samples.
</p>
<p>Constraints are given as a list(constr=A, rhs=b, dir=d), where d should contain only &quot;&lt;=&quot;.
See <code><a href="#topic+hitandrun">hitandrun</a></code> for a &quot;Hit and Run&quot; sampler that also supports equality constraints.
The constraints define the polytope as usual for linear programming: <code class="reqn">Ax \leq b</code>.
In particular, it must be true that <code class="reqn">A x_0 \leq b</code>.
</p>


<h3>Value</h3>

<p>A list, containing:
</p>
<table>
<tr><td><code>samples</code></td>
<td>
<p>A matrix containing the generated samples as rows.</p>
</td></tr>
<tr><td><code>xN</code></td>
<td>
<p>The last generated sample, untransformed. Can be used as the starting point for a continuation of the chain.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>&quot;Hit and Run&quot; is a Markov Chain Monte Carlo (MCMC) method, so generated samples form a correlated time series. To get a uniform sample, you need <code class="reqn">O^*(n^3)</code> samples, where n is the dimension of the sampling space.
</p>


<h3>Author(s)</h3>

<p>Gert van Valkenhoef
</p>


<h3>References</h3>

<p>Smith, R. L. (1984) &quot;Efficient Monte Carlo Procedures for Generating Points Uniformly Distributed over Bounded Regions&quot;. <em>Operations Research</em> 32(6): 1296-1308. doi: <a href="https://doi.org/10.1287/opre.32.6.1296">10.1287/opre.32.6.1296</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+harConstraints">harConstraints</a></code>
<code><a href="#topic+hitandrun">hitandrun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># constraints: x_1 &gt;= 0, x_2 &gt;= 0, x_1 + x_2 &lt;= 1
A &lt;- rbind(c(-1, 0), c(0, -1), c(1, 1))
b &lt;- c(0, 0, 1)
d &lt;- c("&lt;=", "&lt;=", "&lt;=")
constr &lt;- list(constr=A, rhs=b, dir=d)

# take a point x0 within the polytope
x0 &lt;- c(0.25, 0.25)

# sample 10,000 points
samples &lt;- har(x0, constr, 1E4)$samples

# Check dimension of result
stopifnot(dim(samples) == c(1E4, 2))

# Check that x_i &gt;= 0
stopifnot(samples &gt;= 0)

# Check that x_1 + x_2 &lt;= 1
stopifnot(samples[,1] + samples[,2] &lt;= 1)

plot(samples)

</code></pre>

<hr>
<h2 id='harConstraints'>
Constraint formulation utility functions
</h2><span id='topic+harConstraints'></span><span id='topic+simplexConstraints'></span><span id='topic+lowerBoundConstraint'></span><span id='topic+upperBoundConstraint'></span><span id='topic+lowerRatioConstraint'></span><span id='topic+upperRatioConstraint'></span><span id='topic+exactRatioConstraint'></span><span id='topic+ordinalConstraint'></span><span id='topic+mergeConstraints'></span>

<h3>Description</h3>

<p>These utility functions generate linear constraints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplexConstraints(n)
lowerBoundConstraint(n, i, x)
upperBoundConstraint(n, i, x)
lowerRatioConstraint(n, i, j, x)
upperRatioConstraint(n, i, j, x)
exactRatioConstraint(n, i, j, x)
ordinalConstraint(n, i, j)
mergeConstraints(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="harConstraints_+3A_n">n</code></td>
<td>
<p>Number of dimensions (vector components)</p>
</td></tr>
<tr><td><code id="harConstraints_+3A_i">i</code></td>
<td>
<p>Index of first component</p>
</td></tr>
<tr><td><code id="harConstraints_+3A_j">j</code></td>
<td>
<p>Index of second component</p>
</td></tr>
<tr><td><code id="harConstraints_+3A_x">x</code></td>
<td>
<p>Scalar bound</p>
</td></tr>
<tr><td><code id="harConstraints_+3A_...">...</code></td>
<td>
<p>Constraint definitions, or a single list of constraint definitions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+har">har</a></code> for a description of the constraint format.
</p>
<p><code>simplexConstraints</code> encodes the n-simplex: <code class="reqn">\forall_k w_{k} \geq 0</code> and <code class="reqn">\sum_k w_k = 1</code>
</p>
<p><code>lowerBoundConstraint</code> encodes <code class="reqn">w_{i} \geq x</code>
</p>
<p><code>upperBoundConstraint</code> encodes <code class="reqn">w_{i} \leq x</code>
</p>
<p><code>lowerRatioConstraint</code> encodes <code class="reqn">w_{i} / w_{j} \geq x</code>
</p>
<p><code>upperRatioConstraint</code> encodes <code class="reqn">w_{i} / w_{j} \leq x</code>
</p>
<p><code>exactRatioConstraint</code> encodes <code class="reqn">w_{i} / w_{j} = x</code>
</p>
<p><code>ordinalConstraint</code> encodes <code class="reqn">w_{i} \geq w_{j}</code>
</p>
<p><code>mergeConstraints</code> merges the constraints it is given. Alternatively, the function takes a single list of constraint definitions which are to be merged.
</p>


<h3>Value</h3>

<p>A constraint definition (concatenation of the given constraint definitions).
</p>


<h3>Author(s)</h3>

<p>Gert van Valkenhoef
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eliminateRedundant">eliminateRedundant</a></code>
<code><a href="#topic+hitandrun">hitandrun</a></code>
<code><a href="#topic+har">har</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create an ordinal constraint
c1 &lt;- ordinalConstraint(2, 1, 2)
stopifnot(c1$constr == c(-1, 1))
stopifnot(c1$rhs == c(0))
stopifnot(c1$dir == c("&lt;="))

# create our own constraints
c2 &lt;- list(constr=t(c(-1, 0)), rhs=c(0), dir=c("&lt;="))
c3 &lt;- list(constr=t(c(1, 1)), rhs=c(1), dir=c("&lt;="))

# merge the constraints into a single definition
c &lt;- mergeConstraints(c1, c2, c3)
stopifnot(c$constr == rbind(c(-1, 1), c(-1, 0), c(1, 1)))
stopifnot(c$rhs == c(0, 0, 1))
stopifnot(c$dir == c("&lt;=", "&lt;=", "&lt;="))

# test the alternative (list) method
l &lt;- mergeConstraints(list(c1, c2, c3))
stopifnot(c$constr == l$constr)
stopifnot(c$rhs == l$rhs)
stopifnot(c$dir == l$dir)

# test iteratively merging
l &lt;- mergeConstraints(mergeConstraints(c1, c2), c3)
stopifnot(c$constr == l$constr)
stopifnot(c$rhs == l$rhs)
stopifnot(c$dir == l$dir)
</code></pre>

<hr>
<h2 id='hitandrun'>
&quot;Hit and Run&quot; sampler
</h2><span id='topic+hitandrun'></span><span id='topic+har.init'></span><span id='topic+har.run'></span>

<h3>Description</h3>

<p>The &quot;Hit and Run&quot; method generates a Markov Chain whose stable state converges on the uniform distribution over a convex polytope defined by a set of linear inequality constraints. <code>hitandrun</code> further uses the Moore-Penrose pseudo-inverse to eliminate an arbitrary set of linear equality constraints before applying the &quot;Hit and Run&quot; sampler.
</p>
<p><code>har.init</code> and <code>har.run</code> together provide a re-entrant version of <code>hitandrun</code> so that the Markov chain can be continued if convergence is not satisfactory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hitandrun(constr, n.samples=1E4,
    thin.fn = function(n) { ceiling(log(n + 1)/4 * n^3) }, thin = NULL,
    x0.randomize=FALSE, x0.method="slacklp", x0 = NULL, eliminate = TRUE)

har.init(constr,
    thin.fn = function(n) { ceiling(log(n + 1)/4 * n^3) }, thin = NULL,
    x0.randomize=FALSE, x0.method="slacklp", x0 = NULL, eliminate = TRUE)

har.run(state, n.samples)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hitandrun_+3A_constr">constr</code></td>
<td>
<p>Linear constraints that define the sampling space (see details)</p>
</td></tr>
<tr><td><code id="hitandrun_+3A_n.samples">n.samples</code></td>
<td>
<p>The desired number of samples to return. The sampler is run for <code>n.samples * thin</code> iterations</p>
</td></tr>
<tr><td><code id="hitandrun_+3A_thin.fn">thin.fn</code></td>
<td>
<p>Function that specifies a thinning factor depending on the dimension of the sampling space after equality constraints have been eliminated. Will only be invoked if <code>thin</code> is <code>NULL</code></p>
</td></tr>
<tr><td><code id="hitandrun_+3A_thin">thin</code></td>
<td>
<p>The thinning factor</p>
</td></tr>
<tr><td><code id="hitandrun_+3A_x0">x0</code></td>
<td>
<p>Seed point for the Markov Chain. The seed point is specified in the original space, and transformed to the sampling space automatically.</p>
</td></tr>
<tr><td><code id="hitandrun_+3A_x0.method">x0.method</code></td>
<td>
<p>Method to generate the seed point if <code>x0</code> is unspecified, see <code><a href="#topic+createSeedPoint">createSeedPoint</a></code></p>
</td></tr>
<tr><td><code id="hitandrun_+3A_x0.randomize">x0.randomize</code></td>
<td>
<p>Whether to generate a random seed point if <code>x0</code> is unspecified</p>
</td></tr>
<tr><td><code id="hitandrun_+3A_eliminate">eliminate</code></td>
<td>
<p>Whether to eliminate redundant constraints before constructing the transformation to the sampling space and (optionally) calculating the seed point.</p>
</td></tr>
<tr><td><code id="hitandrun_+3A_state">state</code></td>
<td>
<p>A state object, as generated by <code>har.init</code> (see value)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constraints are given as a list with the elements <code>constr</code>, <code>dir</code> and <code>rhs</code>. <code>dir</code> is a vector with values <code>'='</code> or <code>'&lt;='</code>. <code>constr</code> is a matrix and <code>rhs</code> a vector, which encode the standard linear programming constraint froms <code class="reqn">Ax = b</code> and <code class="reqn">Ax \leq b</code> (depending on <code>dir</code>). The lengths of <code>rhs</code> and <code>dir</code> must match the number of rows of <code>constr</code>.
</p>
<p><code>hitandrun</code> applies <code><a href="#topic+solution.basis">solution.basis</a></code> to generate a basis of the (translated) solution space of the linear constraints (if any). An affine transformation is generated using <code><a href="#topic+createTransform">createTransform</a></code> and applied to the constraints. Then, a seed point satisfying the inequality constraints is generated using <code><a href="#topic+createSeedPoint">createSeedPoint</a></code>. Finally, <code><a href="#topic+har">har</a></code> is used to generate the samples.
</p>


<h3>Value</h3>

<p>For <code>hitandrun</code>, a matrix containing the generated samples as rows.
</p>
<p>For <code>har.init</code>, a state object, containing:
</p>
<table>
<tr><td><code>basis</code></td>
<td>
<p>The basis for the sampling space. See <code><a href="#topic+solution.basis">solution.basis</a></code>.</p>
</td></tr>
<tr><td><code>transform</code></td>
<td>
<p>The sampling space transformation. See <code><a href="#topic+createTransform">createTransform</a></code>.</p>
</td></tr>
<tr><td><code>constr</code></td>
<td>
<p>The linear inequality constraints translated to the sampling space. See <code><a href="#topic+transformConstraints">transformConstraints</a></code>.</p>
</td></tr>
<tr><td><code>x0</code></td>
<td>
<p>The generated seed point. See <code><a href="#topic+createSeedPoint">createSeedPoint</a></code>.</p>
</td></tr>
<tr><td><code>thin</code></td>
<td>
<p>The thinning factor to be used.</p>
</td></tr>
</table>
<p>For <code>har.run</code>, a list containing:
</p>
<table>
<tr><td><code>samples</code></td>
<td>
<p>A matrix containing the generated samples as rows.</p>
</td></tr>
<tr><td><code>state</code></td>
<td>
<p>A state object that can be used to continue sampling from the Markov chain (i.e. <code>x0</code> has been modified).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>&quot;Hit and Run&quot; is a Markov Chain Monte Carlo (MCMC) method, so generated samples form a correlated time series. To get a uniform sample, you need <code class="reqn">O^*(n^3)</code> samples, where n is the dimension of the sampling space.
</p>


<h3>Author(s)</h3>

<p>Gert van Valkenhoef
</p>


<h3>See Also</h3>

<p><code><a href="#topic+harConstraints">harConstraints</a></code>
<code><a href="#topic+har">har</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample from the 3-simplex with the additional constraint that w_1/w_2 = 2
# Three inequality constraints, two equality constraints
constr &lt;- mergeConstraints(simplexConstraints(3), exactRatioConstraint(3, 1, 2, 2))
samples &lt;- hitandrun(constr, n.samples=1000)
stopifnot(dim(samples) == c(1000, 3))
stopifnot(all.equal(apply(samples, 1, sum), rep(1, 1000)))
stopifnot(all.equal(samples[,1]/samples[,2], rep(2, 1000)))

# Sample from the unit rectangle (no equality constraints)
constr &lt;- list(
  constr = rbind(c(1,0), c(0,1), c(-1,0), c(0,-1)),
  dir=rep('&lt;=', 4),
  rhs=c(1, 1, 0, 0))
state &lt;- har.init(constr)
result &lt;- har.run(state, n.samples=1000)
samples &lt;- result$samples
stopifnot(all(samples &gt;= 0 &amp; samples &lt;= 1))
# Continue sampling from the same chain:
result &lt;- har.run(result$state, n.samples=1000)
samples &lt;- rbind(samples, result$samples)
</code></pre>

<hr>
<h2 id='hitandrun-package'>
&quot;Hit and Run&quot; sampling
</h2><span id='topic+hitandrun-package'></span>

<h3>Description</h3>

<p>This package provides a &quot;Hit and Run&quot; sampler that generates a Markov chain whose stable state converges on the uniform distribution over a convex polytope.
The polytope is given by a set of inequality constraints in standard linear programming form (<code class="reqn">Ax \leq b</code>) and optionally a set of equality constraints.
In addition, there is a &quot;Shake and Bake&quot; sampler to generate points from the boundary of such a shape.
</p>
<p>Utilities are provided for sampling from subsets of the unit simplex (i.e. random variates that can be interpreted as weights satisfying certain constraints) and for specifying common constraints.
</p>


<h3>Details</h3>

<p><code><a href="#topic+hitandrun">hitandrun</a></code> and <code><a href="#topic+shakeandbake">shakeandbake</a></code> now provide the most general interface for sampling from spaces defined by arbitrary linear equality and inequality constraints. The functions described in the following provide lower level functionality on which it is built.
</p>
<p><code><a href="#topic+har">har</a></code> is the core &quot;Hit and Run&quot; sampler, <code><a href="#topic+sab">sab</a></code> is the core &quot;Shake and Bake&quot; sampler, <code><a href="#topic+bbReject">bbReject</a></code> is the bounding box rejection sampler, and <code><a href="#topic+simplex.sample">simplex.sample</a></code> samples uniformly from the unit simplex.
</p>
<p>See <code><a href="#topic+simplex.createTransform">simplex.createTransform</a></code> and <code><a href="#topic+simplex.createConstraints">simplex.createConstraints</a></code> for sampling from subsets of the unit simplex.
Utilities to specify common constraints are described in <code><a href="#topic+harConstraints">harConstraints</a></code>.
</p>
<p>When the sampling space is restricted by different linear equality constraints, use <code><a href="#topic+solution.basis">solution.basis</a></code>, <code><a href="#topic+createTransform">createTransform</a></code>, and <code><a href="#topic+transformConstraints">transformConstraints</a></code>.
This is a generalization of the methods for sampling from the simplex.
</p>


<h3>Note</h3>

<p>&quot;Hit and Run&quot; is a Markov Chain Monte Carlo (MCMC) method, so generated samples form a correlated time series. To get a uniform sample, you need <code class="reqn">O^*(n^3)</code> samples, where n is the dimension of the sampling space.
</p>


<h3>Author(s)</h3>

<p>Maintainer: Gert van Valkenhoef &lt;gert@gertvv.nl&gt;
</p>


<h3>References</h3>

<p>Tervonen, T., van Valkenhoef, G., Basturk, N., and Postmus, D. (2012) &quot;Hit-And-Run enables efficient weight generation for simulation-based multiple criteria decision analysis&quot;. <em>European Journal of Operational Research</em> 224(3) 552-559. doi: <a href="https://doi.org/10.1016/j.ejor.2012.08.026">10.1016/j.ejor.2012.08.026</a>
van Valkenhoef, G., Tervonen, T., and Postmus, D. (2014) &quot;Notes on 'Hit-And-Run enables efficient weight generation for simulation-based multiple criteria decision analysis'&quot;. <em>European Journal of Operational Research</em> (in press). doi: <a href="https://doi.org/10.1016/j.ejor.2014.06.036">10.1016/j.ejor.2014.06.036</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hitandrun">hitandrun</a></code>
<code><a href="#topic+har">har</a></code>
</p>
<p><code><a href="#topic+bbReject">bbReject</a></code>
<code><a href="#topic+simplex.sample">simplex.sample</a></code>
<code><a href="#topic+hypersphere.sample">hypersphere.sample</a></code>
</p>
<p><code><a href="#topic+solution.basis">solution.basis</a></code>
<code><a href="#topic+createTransform">createTransform</a></code>
<code><a href="#topic+transformConstraints">transformConstraints</a></code>
</p>
<p><code><a href="#topic+simplex.createTransform">simplex.createTransform</a></code>
<code><a href="#topic+simplex.createConstraints">simplex.createConstraints</a></code>
</p>
<p><code><a href="#topic+harConstraints">harConstraints</a></code>
</p>
<p><code><a href="#topic+createSeedPoint">createSeedPoint</a></code>
<code><a href="#topic+createBoundBox">createBoundBox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example: sample weight vectors where w_1 &gt;= w_2 and w_1 &gt;= w_3
n &lt;- 3 # length of weight vector
constr &lt;- mergeConstraints(
  ordinalConstraint(n, 1, 2),
  ordinalConstraint(n, 1, 3))
transform &lt;- simplex.createTransform(n)
constr &lt;- simplex.createConstraints(transform, constr)
seedPoint &lt;- createSeedPoint(constr, homogeneous=TRUE)
N &lt;- 1000
w &lt;- har(seedPoint, constr, N=N * (n-1)^3, thin=(n-1)^3,
  homogeneous=TRUE, transform=transform)$samples
stopifnot(all(w[,1] &gt;= w[,2]) &amp;&amp; all(w[,1] &gt;= w[,3]))
</code></pre>

<hr>
<h2 id='hypersphere.sample'>
Sample uniformly from an n-hypersphere
</h2><span id='topic+hypersphere.sample'></span>

<h3>Description</h3>

<p>Generates uniform random variates over an n-hypersphere
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypersphere.sample(n, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hypersphere.sample_+3A_n">n</code></td>
<td>
<p>Dimension of the hypersphere</p>
</td></tr>
<tr><td><code id="hypersphere.sample_+3A_n">N</code></td>
<td>
<p>Number of samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single n-dimensional sample from the hypersphere.
</p>


<h3>Author(s)</h3>

<p>Tommi Tervonen &lt;tommi@smaa.fi&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 3 # Dimension
N &lt;- 5 # Nr samples

sample &lt;- hypersphere.sample(n, N)

# Check summing to unity
vec.norm &lt;- function(x) { sum(x^2) }
stopifnot(all.equal(apply(sample, 1, vec.norm), rep(1, N)))
</code></pre>

<hr>
<h2 id='sab'>
&quot;Shake and Bake&quot; sampler
</h2><span id='topic+sab'></span>

<h3>Description</h3>

<p>The &quot;Shake and Bake&quot; method generates a Markov Chain whose stable state converges on the uniform distribution over the boundary of a convex polytope defined by a set of linear constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sab(x0, i0, constr, N, thin=1, homogeneous=FALSE, transform=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sab_+3A_x0">x0</code></td>
<td>
<p>Starting point (must be in the polytope)</p>
</td></tr>
<tr><td><code id="sab_+3A_i0">i0</code></td>
<td>
<p>Index of the closest face to the starting point</p>
</td></tr>
<tr><td><code id="sab_+3A_constr">constr</code></td>
<td>
<p>Constraint definition (see details)</p>
</td></tr>
<tr><td><code id="sab_+3A_n">N</code></td>
<td>
<p>Number of iterations to run</p>
</td></tr>
<tr><td><code id="sab_+3A_thin">thin</code></td>
<td>
<p>Thinning factor (keep every 'thin'-th sample)</p>
</td></tr>
<tr><td><code id="sab_+3A_homogeneous">homogeneous</code></td>
<td>
<p>Whether x0, constr and transform are given in homogeneous coordinate representation (see details)</p>
</td></tr>
<tr><td><code id="sab_+3A_transform">transform</code></td>
<td>
<p>Transformation matrix to apply to the generated samples (optional)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constraints, starting point and transformation matrix can be given in homogeneous coordinate representation (an extra component is added to each vector, equal to 1.0).
This enables affine transformations (such as translation) to be applied to the coordinate vectors by the constraint and transformation matrices.
Be aware that while non-affine (perspective) transformations are also possible, they will not in general preserve uniformity of the generated samples.
</p>
<p>Constraints are given as a list(constr=A, rhs=b, dir=d), where d should contain only &quot;&lt;=&quot;.
See <code><a href="#topic+shakeandbake">shakeandbake</a></code> for a &quot;Shake and Bake&quot; sampler that also supports equality constraints.
The constraints define the polytope as usual for linear programming: <code class="reqn">Ax \leq b</code>.
In particular, it must be true that <code class="reqn">A x_0 \leq b</code>.
Points are generated from the boundary of the polytope (where equality holds for one of the constraints), using the &quot;running&quot; shake and bake sampler, which samples the direction vector so that every move point is accepted (Boender et al. 1991).
</p>


<h3>Value</h3>

<p>A list, containing:
</p>
<table>
<tr><td><code>samples</code></td>
<td>
<p>A matrix containing the generated samples as rows.</p>
</td></tr>
<tr><td><code>faces</code></td>
<td>
<p>A vector containing the indices of the faces on which the samples lie.</p>
</td></tr>
<tr><td><code>xN</code></td>
<td>
<p>The last generated sample, untransformed. Can be used as the starting point for a continuation of the chain.</p>
</td></tr>
<tr><td><code>iN</code></td>
<td>
<p>Face on which the last generated sample lies.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>&quot;Shake and Bake&quot; is a Markov Chain Monte Carlo (MCMC) method, so generated samples form a correlated time series.
</p>


<h3>Author(s)</h3>

<p>Gert van Valkenhoef
</p>


<h3>References</h3>

<p>Boender, C. G. E., Caron, R. J., McDonald, J. F., Rinnooy Kan, A. H. G., Romeijn, H. E., Smith, R. L., Telgen, J., and Vorst, A. C. F. (1991) &quot;Shake-and-Bake Algorithms for Generating Uniform Points on the Boundary of Bounded Polyhedra&quot;. <em>Operations Research</em> 39(6):945-954. doi: <a href="https://doi.org/10.1287/opre.39.6.945">10.1287/opre.39.6.945</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+harConstraints">harConstraints</a></code>
<code><a href="#topic+shakeandbake">shakeandbake</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># constraints: x_1 &gt;= 0, x_2 &gt;= 0, x_1 + x_2 &lt;= 1
A &lt;- rbind(c(-1, 0), c(0, -1), c(1, 1))
b &lt;- c(0, 0, 1)
d &lt;- c("&lt;=", "&lt;=", "&lt;=")
constr &lt;- list(constr=A, rhs=b, dir=d)

# take a point x0 within the polytope
x0 &lt;- c(0.25, 0.25)

# sample 10,000 points
result &lt;- sab(x0, 1, constr, 1E4)
samples &lt;- result$samples

# Check dimension of result
stopifnot(dim(samples) == c(1E4, 2))

# Check that x_i &gt;= 0
stopifnot(samples &gt;= -1E-15)

# Check that x_1 + x_2 &lt;= 1
stopifnot(samples[,1] + samples[,2] &lt;= 1 + 1E-15)

# check that the results lie on the faces
faces &lt;- result$faces
stopifnot(all.equal(samples[faces==1,1], rep(0, sum(faces==1))))
stopifnot(all.equal(samples[faces==2,2], rep(0, sum(faces==2))))
stopifnot(all.equal(samples[faces==3,1] + samples[faces==3,2], rep(1, sum(faces==3))))

plot(samples)

</code></pre>

<hr>
<h2 id='shakeandbake'>
&quot;Shake and Bake&quot; sampler
</h2><span id='topic+shakeandbake'></span><span id='topic+sab.init'></span><span id='topic+sab.run'></span>

<h3>Description</h3>

<p>The &quot;Shake and Bake&quot; method generates a Markov Chain whose stable state converges on the uniform distribution over a the boundary of a convex polytope defined by a set of linear inequality constraints. <code>shakeandbake</code> further uses the Moore-Penrose pseudo-inverse to eliminate an arbitrary set of linear equality constraints before applying the &quot;Shake and Bake&quot; sampler.
</p>
<p><code>sab.init</code> and <code>sab.run</code> together provide a re-entrant version of <code>shakeandbake</code> so that the Markov chain can be continued if convergence is not satisfactory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shakeandbake(constr, n.samples=1E4,
    thin.fn = function(n) { ceiling(log(n + 1)/4 * n^3) }, thin = NULL,
    x0.randomize=FALSE, x0.method="slacklp", x0 = NULL, eliminate = TRUE)

sab.init(constr,
    thin.fn = function(n) { ceiling(log(n + 1)/4 * n^3) }, thin = NULL,
    x0.randomize=FALSE, x0.method="slacklp", x0 = NULL, eliminate = TRUE)

sab.run(state, n.samples)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shakeandbake_+3A_constr">constr</code></td>
<td>
<p>Linear constraints that define the sampling space (see details)</p>
</td></tr>
<tr><td><code id="shakeandbake_+3A_n.samples">n.samples</code></td>
<td>
<p>The desired number of samples to return. The sampler is run for <code>n.samples * thin</code> iterations</p>
</td></tr>
<tr><td><code id="shakeandbake_+3A_thin.fn">thin.fn</code></td>
<td>
<p>Function that specifies a thinning factor depending on the dimension of the sampling space after equality constraints have been eliminated. Will only be invoked if <code>thin</code> is <code>NULL</code></p>
</td></tr>
<tr><td><code id="shakeandbake_+3A_thin">thin</code></td>
<td>
<p>The thinning factor</p>
</td></tr>
<tr><td><code id="shakeandbake_+3A_x0">x0</code></td>
<td>
<p>Seed point for the Markov Chain. The seed point is specified in the original space, and transformed to the sampling space automatically.</p>
</td></tr>
<tr><td><code id="shakeandbake_+3A_x0.method">x0.method</code></td>
<td>
<p>Method to generate the seed point if <code>x0</code> is unspecified, see <code><a href="#topic+createSeedPoint">createSeedPoint</a></code></p>
</td></tr>
<tr><td><code id="shakeandbake_+3A_x0.randomize">x0.randomize</code></td>
<td>
<p>Whether to generate a random seed point if <code>x0</code> is unspecified</p>
</td></tr>
<tr><td><code id="shakeandbake_+3A_eliminate">eliminate</code></td>
<td>
<p>Whether to eliminate redundant constraints before constructing the transformation to the sampling space and (optionally) calculating the seed point.</p>
</td></tr>
<tr><td><code id="shakeandbake_+3A_state">state</code></td>
<td>
<p>A state object, as generated by <code>har.init</code> (see value)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constraints are given as a list with the elements <code>constr</code>, <code>dir</code> and <code>rhs</code>. <code>dir</code> is a vector with values <code>'='</code> or <code>'&lt;='</code>. <code>constr</code> is a matrix and <code>rhs</code> a vector, which encode the standard linear programming constraint froms <code class="reqn">Ax = b</code> and <code class="reqn">Ax \leq b</code> (depending on <code>dir</code>). The lengths of <code>rhs</code> and <code>dir</code> must match the number of rows of <code>constr</code>.
</p>
<p><code>shakeandbake</code> applies <code><a href="#topic+solution.basis">solution.basis</a></code> to generate a basis of the (translated) solution space of the linear constraints (if any). An affine transformation is generated using <code><a href="#topic+createTransform">createTransform</a></code> and applied to the constraints. Then, a seed point satisfying the inequality constraints is generated using <code><a href="#topic+createSeedPoint">createSeedPoint</a></code>. The closest face to this point is found using <code><a href="#topic+findFace">findFace</a></code>. Finally, <code><a href="#topic+sab">sab</a></code> is used to generate the samples.
</p>


<h3>Value</h3>

<p>For <code>shakeandbake</code>, a matrix containing the generated samples as rows.
</p>
<p>For <code>sab.init</code>, a state object, containing:
</p>
<table>
<tr><td><code>basis</code></td>
<td>
<p>The basis for the sampling space. See <code><a href="#topic+solution.basis">solution.basis</a></code>.</p>
</td></tr>
<tr><td><code>transform</code></td>
<td>
<p>The sampling space transformation. See <code><a href="#topic+createTransform">createTransform</a></code>.</p>
</td></tr>
<tr><td><code>constr</code></td>
<td>
<p>The linear inequality constraints translated to the sampling space. See <code><a href="#topic+transformConstraints">transformConstraints</a></code>.</p>
</td></tr>
<tr><td><code>x0</code></td>
<td>
<p>The generated seed point. See <code><a href="#topic+createSeedPoint">createSeedPoint</a></code>.</p>
</td></tr>
<tr><td><code>i0</code></td>
<td>
<p>The index of the closest face. See <code><a href="#topic+findFace">findFace</a></code>.</p>
</td></tr>
<tr><td><code>thin</code></td>
<td>
<p>The thinning factor to be used.</p>
</td></tr>
</table>
<p>For <code>sab.run</code>, a list containing:
</p>
<table>
<tr><td><code>samples</code></td>
<td>
<p>A matrix containing the generated samples as rows.</p>
</td></tr>
<tr><td><code>state</code></td>
<td>
<p>A state object that can be used to continue sampling from the Markov chain (i.e. <code>x0</code> and <code>i0</code> have been modified).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>&quot;Shake and Bake&quot; is a Markov Chain Monte Carlo (MCMC) method, so generated samples form a correlated time series.
</p>


<h3>Author(s)</h3>

<p>Gert van Valkenhoef
</p>


<h3>See Also</h3>

<p><code><a href="#topic+harConstraints">harConstraints</a></code>
<code><a href="#topic+sab">sab</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample from the 3-simplex with the additional constraint that w_1/w_2 = 2
# Three inequality constraints, two equality constraints
constr &lt;- mergeConstraints(simplexConstraints(3), exactRatioConstraint(3, 1, 2, 2))
samples &lt;- shakeandbake(constr, n.samples=1000)
stopifnot(dim(samples) == c(1000, 3))
stopifnot(all.equal(apply(samples, 1, sum), rep(1, 1000)))

sel &lt;- samples[,3] &gt; 0.5 # detect which side we're on
stopifnot(all.equal(samples[sel,], matrix(rep(c(0,0,1), each=sum(sel)), ncol=3)))
stopifnot(all.equal(samples[!sel,], matrix(rep(c(2/3,1/3,0), each=sum(sel)), ncol=3)))

# Sample from the unit rectangle (no equality constraints)
constr &lt;- list(
  constr = rbind(c(1,0), c(0,1), c(-1,0), c(0,-1)),
  dir=rep('&lt;=', 4),
  rhs=c(1, 1, 0, 0))
state &lt;- sab.init(constr)
result &lt;- sab.run(state, n.samples=1000)
faces &lt;- result$faces
samples &lt;- result$samples
stopifnot(all(samples &gt;= -1e-15 &amp; samples &lt;= 1 + 1e-15))

stopifnot(all.equal(samples[faces==1,1], rep(1, sum(faces==1))))
stopifnot(all.equal(samples[faces==2,2], rep(1, sum(faces==2))))
stopifnot(all.equal(samples[faces==3,1], rep(0, sum(faces==3))))
stopifnot(all.equal(samples[faces==4,2], rep(0, sum(faces==4))))

# Continue sampling from the same chain:
result &lt;- sab.run(result$state, n.samples=1000)
samples &lt;- rbind(samples, result$samples)
</code></pre>

<hr>
<h2 id='simplex.createConstraints'>
Create constraints that define the (n-1)-simplex
</h2><span id='topic+simplex.createConstraints'></span>

<h3>Description</h3>

<p>This function takes a transformation matrix from the plane coincident with the (n-1) simplex and (optionally) additional constraints defined in n-dimensional space, and generates a set of constraints defining the simplex and (optionally) the additional constraints in the (n-1)-dimensional homogeneous coordinate system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplex.createConstraints(transform, userConstr=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplex.createConstraints_+3A_transform">transform</code></td>
<td>
<p>Transformation matrix</p>
</td></tr>
<tr><td><code id="simplex.createConstraints_+3A_userconstr">userConstr</code></td>
<td>
<p>Additional constraints</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The transformation of the constraint matrix to (n-1)-dimensional homogeneous coordinates is a necessary preprocessing step for applying &quot;Hit and Run&quot; to subsets of the simplex defined by <code>userConstr</code>.
</p>


<h3>Value</h3>

<p>A set of constraints in the (n-1)-dimensional homogeneous coordinate system.
</p>


<h3>Author(s)</h3>

<p>Gert van Valkenhoef
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simplex.createTransform">simplex.createTransform</a></code>
<code><a href="#topic+har">har</a></code>
<code><a href="#topic+harConstraints">harConstraints</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 3
userConstr &lt;- mergeConstraints(
	ordinalConstraint(3, 1, 2), ordinalConstraint(3, 2, 3))

transform &lt;- simplex.createTransform(n)
constr &lt;- simplex.createConstraints(transform, userConstr)
seedPoint &lt;- createSeedPoint(constr, homogeneous=TRUE)

N &lt;- 10000
samples &lt;- har(seedPoint, constr, N, 1, homogeneous=TRUE, transform=transform)$samples

# Check dimension
stopifnot(dim(samples) == c(N, n))

# Check that w_i &gt;= w_i+1
stopifnot(sapply(1:(n-1), function(i) {
	all(samples[,i]&gt;=samples[,i+1])
}))

# Check that w_i &gt;= 0
stopifnot(samples &gt;= 0)

# Check that sum_i w_i = 1
E &lt;- 1E-12
stopifnot(apply(samples, 1, sum) &gt; 1 - E)
stopifnot(apply(samples, 1, sum) &lt; 1 + E)
</code></pre>

<hr>
<h2 id='simplex.createTransform'>
Transform points on an (n-1)-simplex to n-dimensional space
</h2><span id='topic+simplex.createTransform'></span>

<h3>Description</h3>

<p>This function generates a matrix to transform points in an (n-1) dimensional homogeneous coordinate representation of the (n-1) simplex to n-dimensional Cartesian coordinates.
</p>
<p>The inverse transform can also be generated, and conversion can be to homogeneous coordinates instead of Cartesion ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplex.createTransform(n, inverse=FALSE, keepHomogeneous=inverse)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplex.createTransform_+3A_n">n</code></td>
<td>
<p>Dimension of the space</p>
</td></tr>
<tr><td><code id="simplex.createTransform_+3A_inverse">inverse</code></td>
<td>
<p>TRUE to convert from n-space coordinates to (n-1)-simplex coordinates</p>
</td></tr>
<tr><td><code id="simplex.createTransform_+3A_keephomogeneous">keepHomogeneous</code></td>
<td>
<p>TRUE to convert to homogeneous coordinates rather than Cartesian</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multiply a coordinate vector in homogeneous coordinates by pre-multiplying by the generated matrix (see examples).
</p>


<h3>Value</h3>

<p>A transformation matrix.
</p>


<h3>Author(s)</h3>

<p>Gert van Valkenhoef
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simplex.createConstraints">simplex.createConstraints</a></code>
<code><a href="#topic+har">har</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E &lt;- 1E-12 # Allowed numerical error

# The origin in (n-1)-dimensional space should be the centroid of the simplex
# when transformed to n-dimensional space
transform &lt;- simplex.createTransform(3)
x &lt;- transform %*% c(0, 0, 1)
x
stopifnot(abs(x - c(1/3, 1/3, 1/3)) &lt; E)

# The same should hold for the inverse transformation
invTransform &lt;- simplex.createTransform(3, inverse=TRUE)
y &lt;- invTransform %*% c(1/3, 1/3, 1/3, 1)
y
stopifnot(abs(y - c(0, 0, 1)) &lt; E)

# Of course, an arbitrary weight vector should transform back to itself
transform &lt;- simplex.createTransform(3, keepHomogeneous=TRUE)
x &lt;- c(0.2, 0.5, 0.3, 1.0)
y &lt;- transform %*% invTransform %*% x
y
stopifnot(abs(y - x) &lt; E)

# And we can apply the tranform to a matrix:
a &lt;- cbind(x, x, x)
b &lt;- transform %*% invTransform %*% a
b
stopifnot(abs(b - a) &lt; E)
</code></pre>

<hr>
<h2 id='simplex.sample'>
Sample uniformly from a simplex
</h2><span id='topic+simplex.sample'></span>

<h3>Description</h3>

<p>Generates uniform random variates over the (n-1)-simplex in n-dimensional space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplex.sample(n, N, sort=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplex.sample_+3A_n">n</code></td>
<td>
<p>Dimension of the space</p>
</td></tr>
<tr><td><code id="simplex.sample_+3A_n">N</code></td>
<td>
<p>Number of samples to generate</p>
</td></tr>
<tr><td><code id="simplex.sample_+3A_sort">sort</code></td>
<td>
<p>Whether to sort the components in descending order</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The samples will be uniform over the (n-1)-simplex.
</p>


<h3>Value</h3>

<table>
<tr><td><code>samples</code></td>
<td>
<p>A matrix containing the generated samples as rows.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gert van Valkenhoef
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 3
N &lt;- 10000
samples &lt;- simplex.sample(n, N)$samples

# Check dimension
stopifnot(dim(samples) == c(N, n))

# Check that w_i &gt;= 0
stopifnot(samples &gt;= 0)

# Check that sum_i w_i = 1
E &lt;- 1E-12
stopifnot(apply(samples, 1, sum) &gt; 1 - E)
stopifnot(apply(samples, 1, sum) &lt; 1 + E)


## Now with descending order
samples &lt;- simplex.sample(n, N, sort=TRUE)$samples

# Check dimension
stopifnot(dim(samples) == c(N, n))

# Check that w_i &gt;= 0
stopifnot(samples &gt;= 0)

# Check that sum_i w_i = 1
E &lt;- 1E-12
stopifnot(apply(samples, 1, sum) &gt; 1 - E)
stopifnot(apply(samples, 1, sum) &lt; 1 + E)

# Check w_i &gt;= w_{i+1}
stopifnot(samples[,1] &gt;= samples[,2])
stopifnot(samples[,2] &gt;= samples[,3])
</code></pre>

<hr>
<h2 id='solution.basis'>
Calculate the basis for the solution space of a system of linear equations
</h2><span id='topic+solution.basis'></span>

<h3>Description</h3>

<p>Given a set of linear equality constraints, determine a translation and a basis for its solution space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solution.basis(constr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solution.basis_+3A_constr">constr</code></td>
<td>
<p>Linear equality constraints</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a system of linear equations, <code class="reqn">Ax = b</code>, the solution space is given by
</p>
<p style="text-align: center;"><code class="reqn">x = A^\dagger b + (I - A^\dagger A) y</code>
</p>

<p>where <code class="reqn">A^\dagger</code> is the Moore-Penrose pseudoinverse of <code class="reqn">A</code>.
The QR decomposition of <code class="reqn">I - A^\dagger A</code> enables us to determine the dimension of the solution space and derive a basis for that space.
</p>


<h3>Value</h3>

<p>A list, consisting of 
</p>
<table>
<tr><td><code>translate</code></td>
<td>
<p>A point in the solution space</p>
</td></tr>
<tr><td><code>basis</code></td>
<td>
<p>A basis rooted in that point</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gert van Valkenhoef
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createTransform">createTransform</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A 3-dimensional original space
n &lt;- 3

# x_1 + x_2 + x_3 = 1
eq.constr &lt;- list(constr = t(rep(1, n)), dir = '=', rhs = 1)
basis &lt;- solution.basis(eq.constr)
stopifnot(ncol(basis$basis) == 2) # Dimension reduced to 2
y &lt;- rbind(rnorm(100, 0, 100), rnorm(100, 0, 100))
x &lt;- basis$basis %*% y + basis$translate
stopifnot(all.equal(apply(x, 2, sum), rep(1, 100)))

# 2 x_2 = x_1; 2 x_3 = x_2
eq.constr &lt;- mergeConstraints(
  eq.constr,
  list(constr = c(-1, 2, 0), dir = '=', rhs = 0),
  list(constr = c(0, -1, 2), dir = '=', rhs = 0))
basis &lt;- solution.basis(eq.constr)
stopifnot(ncol(basis$basis) == 0) # Dimension reduced to 0
stopifnot(all.equal(basis$translate, c(4/7, 2/7, 1/7)))
</code></pre>

<hr>
<h2 id='transformConstraints'>
Apply a transformation to a set of linear constraints.
</h2><span id='topic+transformConstraints'></span>

<h3>Description</h3>

<p>Given a set of linear constraints and a transformation matrix, return the constraints in the transformed space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformConstraints(transform, constr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformConstraints_+3A_transform">transform</code></td>
<td>
<p>Transformation matrix</p>
</td></tr>
<tr><td><code id="transformConstraints_+3A_constr">constr</code></td>
<td>
<p>Constraints</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Transforming the constraint matrix is a necessary preprocessing step for applying &quot;Hit and Run&quot; to subsets of a space defined by linear equality constraints. See <code><a href="#topic+solution.basis">solution.basis</a></code> and <code><a href="#topic+createTransform">createTransform</a></code> for building the transformation matrix.
</p>


<h3>Value</h3>

<p>A set of constraints in the new basis.
</p>


<h3>Author(s)</h3>

<p>Gert van Valkenhoef
</p>


<h3>See Also</h3>

<p><code><a href="#topic+solution.basis">solution.basis</a></code>
<code><a href="#topic+createTransform">createTransform</a></code>
<code><a href="#topic+har">har</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample from the space where 2*x_1 = x_2 + x_3 and
# 0 &lt;= x_1, x_2, x_3 &lt;= 5
n &lt;- 3

eq.constr &lt;- list(
  constr = matrix(c(2, -1, -1), nrow=1, ncol=n),
  dir = '=',
  rhs = 0)

ineq.constr &lt;- list(
  constr = rbind(-diag(n), diag(n)),
  dir = rep('&lt;=', n * 2),
  rhs = c(rep(0, n), rep(5, n)))

basis &lt;- solution.basis(eq.constr)
transform &lt;- createTransform(basis)
constr &lt;- transformConstraints(transform, ineq.constr)
x0 &lt;- createSeedPoint(constr, homogeneous=TRUE)
x &lt;- har(x0, constr, 500, transform=transform, homogeneous=TRUE)$samples

stopifnot(all.equal(2 * x[,1], x[,2] + x[,3]))
stopifnot(all(x &gt;= 0))
stopifnot(all(x &lt;= 5))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
