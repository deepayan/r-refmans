<!DOCTYPE html><html><head><title>Help for package survivalmodels</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {survivalmodels}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#build_keras_net'><p>Build a Keras Multilayer Perceptron</p></a></li>
<li><a href='#build_pytorch_net'><p>Build a Pytorch Multilayer Perceptron</p></a></li>
<li><a href='#cindex'><p>Compute Concordance of survivalmodel Risk</p></a></li>
<li><a href='#coxtime'><p>Cox-Time Survival Neural Network</p></a></li>
<li><a href='#deephit'><p>DeepHit Survival Neural Network</p></a></li>
<li><a href='#deepsurv'><p>DeepSurv Survival Neural Network</p></a></li>
<li><a href='#get_keras_optimizer'><p>Get Keras Optimizer</p></a></li>
<li><a href='#get_pycox_activation'><p>Get Pytorch Activation Function</p></a></li>
<li><a href='#get_pycox_callbacks'><p>Get Torchtuples Callbacks</p></a></li>
<li><a href='#get_pycox_init'><p>Get Pytorch Weight Initialization Method</p></a></li>
<li><a href='#get_pycox_optim'><p>Get Pytorch Optimizer</p></a></li>
<li><a href='#install_keras'><p>Install Keras and Tensorflow</p></a></li>
<li><a href='#install_pycox'><p>Install Pycox With Reticulate</p></a></li>
<li><a href='#install_torch'><p>Install Torch With Reticulate</p></a></li>
<li><a href='#loghaz'><p>Logistic-Hazard Survival Neural Network</p></a></li>
<li><a href='#pchazard'><p>PC-Hazard Survival Neural Network</p></a></li>
<li><a href='#predict.pycox'><p>Predict Method for pycox Neural Networks</p></a></li>
<li><a href='#pycox_prepare_train_data'><p>Prepare Data for Pycox Model Training</p></a></li>
<li><a href='#requireNamespaces'><p>Vectorised Logical requireNamespace</p></a></li>
<li><a href='#set_seed'><p>Set seed in R numpy and torch</p></a></li>
<li><a href='#simsurvdata'><p>Simulate Survival Data</p></a></li>
<li><a href='#surv_to_risk'><p>Safely convert a survival matrix prediction to a relative risk</p></a></li>
<li><a href='#survivalmodels-package'><p>survivalmodels: Models for Survival Analysis</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Models for Survival Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.191</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementations of classical and machine learning models for survival analysis, including deep neural networks via 'keras' and 'tensorflow'. Each model includes a separated fit and predict interface with consistent prediction types for predicting risk or survival probabilities. Models are either implemented from 'Python' via 'reticulate' <a href="https://CRAN.R-project.org/package=reticulate">https://CRAN.R-project.org/package=reticulate</a>, from code in GitHub packages, or novel implementations using 'Rcpp' <a href="https://CRAN.R-project.org/package=Rcpp">https://CRAN.R-project.org/package=Rcpp</a>. Neural networks are implemented from the 'Python' package 'pycox' <a href="https://github.com/havakv/pycox">https://github.com/havakv/pycox</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RaphaelS1/survivalmodels/">https://github.com/RaphaelS1/survivalmodels/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/foucher-y/survivalmodels/issues">https://github.com/foucher-y/survivalmodels/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.5)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>keras (&ge; 2.11.0), pseudo, reticulate, survival</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-18 21:10:19 UTC; foucher-y</td>
</tr>
<tr>
<td>Author:</td>
<td>Raphael Sonabend <a href="https://orcid.org/0000-0001-9225-4654"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Yohann Foucher <a href="https://orcid.org/0000-0003-0330-7457"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yohann Foucher &lt;yohann.foucher@univ-poitiers.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-19 16:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='build_keras_net'>Build a Keras Multilayer Perceptron</h2><span id='topic+build_keras_net'></span>

<h3>Description</h3>

<p>Utility function to build a Keras MLP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_keras_net(
  n_in,
  n_out,
  nodes = c(32L, 32L),
  layer_pars = list(),
  activation = "linear",
  act_pars = list(),
  dropout = 0.1,
  batch_norm = TRUE,
  batch_pars = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_keras_net_+3A_n_in">n_in</code></td>
<td>
<p><code>(integer(1))</code><br /> Number of input features.</p>
</td></tr>
<tr><td><code id="build_keras_net_+3A_n_out">n_out</code></td>
<td>
<p><code>(integer(1))</code><br /> Number of targets.</p>
</td></tr>
<tr><td><code id="build_keras_net_+3A_nodes">nodes</code></td>
<td>
<p><code>(numeric())</code><br /> Hidden nodes in network, each element in vector represents number
of hidden nodes in respective layer.</p>
</td></tr>
<tr><td><code id="build_keras_net_+3A_layer_pars">layer_pars</code></td>
<td>
<p><code>(list())</code><br /> Arguments passed to <a href="keras.html#topic+layer_dense">keras::layer_dense</a>.</p>
</td></tr>
<tr><td><code id="build_keras_net_+3A_activation">activation</code></td>
<td>
<p><code>(character(1))</code><br /> Activation function passed to <a href="keras.html#topic+layer_activation">keras::layer_activation</a>.
Default is linear.</p>
</td></tr>
<tr><td><code id="build_keras_net_+3A_act_pars">act_pars</code></td>
<td>
<p><code>(list())</code><br /> Parameters for activation function, see
<a href="keras.html#topic+layer_activation">keras::layer_activation</a>.</p>
</td></tr>
<tr><td><code id="build_keras_net_+3A_dropout">dropout</code></td>
<td>
<p><code>(numeric(1))</code><br /> Optional dropout layer, if <code>NULL</code> then no dropout layer added
otherwise either same dropout will be added to all layers.</p>
</td></tr>
<tr><td><code id="build_keras_net_+3A_batch_norm">batch_norm</code></td>
<td>
<p><code>(logical(1))</code><br /> If <code>TRUE</code> (default) then batch normalisation is applied
to all layers.</p>
</td></tr>
<tr><td><code id="build_keras_net_+3A_batch_pars">batch_pars</code></td>
<td>
<p><code>(list())</code><br /> Parameters for batch normalisation, see
<a href="keras.html#topic+layer_batch_normalization">keras::layer_batch_normalization</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a helper for R users with less Python experience. Currently it is
limited to simple MLPs and with identical layers.
More advanced networks will require manual creation with <a href="https://CRAN.R-project.org/package=keras"><span class="pkg">keras</span></a>.
</p>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='build_pytorch_net'>Build a Pytorch Multilayer Perceptron</h2><span id='topic+build_pytorch_net'></span>

<h3>Description</h3>

<p>Utility function to build an MLP with a choice of activation function and weight
initialization with optional dropout and batch normalization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_pytorch_net(
  n_in,
  n_out,
  nodes = c(32, 32),
  activation = "relu",
  act_pars = list(),
  dropout = 0.1,
  bias = TRUE,
  batch_norm = TRUE,
  batch_pars = list(eps = 1e-05, momentum = 0.1, affine = TRUE),
  init = "uniform",
  init_pars = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_pytorch_net_+3A_n_in">n_in</code></td>
<td>
<p><code>(integer(1))</code><br /> Number of input features.</p>
</td></tr>
<tr><td><code id="build_pytorch_net_+3A_n_out">n_out</code></td>
<td>
<p><code>(integer(1))</code><br /> Number of targets.</p>
</td></tr>
<tr><td><code id="build_pytorch_net_+3A_nodes">nodes</code></td>
<td>
<p><code>(numeric())</code><br /> Hidden nodes in network, each element in vector represents number
of hidden nodes in respective layer.</p>
</td></tr>
<tr><td><code id="build_pytorch_net_+3A_activation">activation</code></td>
<td>
<p><code>(character(1)|list())</code><br /> Activation function, can either be a single
character and the same function is used in all layers, or a list of length <code>length(nodes)</code>. See
<a href="#topic+get_pycox_activation">get_pycox_activation</a> for options.</p>
</td></tr>
<tr><td><code id="build_pytorch_net_+3A_act_pars">act_pars</code></td>
<td>
<p><code>(list())</code><br /> Passed to <a href="#topic+get_pycox_activation">get_pycox_activation</a>.</p>
</td></tr>
<tr><td><code id="build_pytorch_net_+3A_dropout">dropout</code></td>
<td>
<p><code>(numeric())</code><br /> Optional dropout layer, if <code>NULL</code> then no dropout layer added
otherwise either a single numeric which will be added to all layers or a vector of differing
drop-out amounts.</p>
</td></tr>
<tr><td><code id="build_pytorch_net_+3A_bias">bias</code></td>
<td>
<p><code>(logical(1))</code><br /> If <code>TRUE</code> (default) then a bias parameter is added to all linear
layers.</p>
</td></tr>
<tr><td><code id="build_pytorch_net_+3A_batch_norm">batch_norm</code></td>
<td>
<p><code>(logical(1))</code><br /> If <code>TRUE</code> (default) then batch normalisation is applied
to all layers.</p>
</td></tr>
<tr><td><code id="build_pytorch_net_+3A_batch_pars">batch_pars</code></td>
<td>
<p><code>(list())</code><br /> Parameters for batch normalisation, see
<code>reticulate::py_help(torch$nn$BatchNorm1d)</code>.</p>
</td></tr>
<tr><td><code id="build_pytorch_net_+3A_init">init</code></td>
<td>
<p><code>(character(1))</code><br /> Weight initialization method. See
<a href="#topic+get_pycox_init">get_pycox_init</a> for options.</p>
</td></tr>
<tr><td><code id="build_pytorch_net_+3A_init_pars">init_pars</code></td>
<td>
<p><code>(list())</code><br /> Passed to <a href="#topic+get_pycox_init">get_pycox_init</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a helper for R users with less Python experience. Currently it is
limited to simple MLPs. More advanced networks will require manual creation with
<a href="https://CRAN.R-project.org/package=reticulate"><span class="pkg">reticulate</span></a>.
</p>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='cindex'>Compute Concordance of survivalmodel Risk</h2><span id='topic+cindex'></span>

<h3>Description</h3>

<p>A thin wrapper around <a href="survival.html#topic+concordance">survival::concordance</a> which essentially
just sets <code>reverse = TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cindex(risk, truth, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cindex_+3A_risk">risk</code></td>
<td>
<p>(<code>numeric()</code>) <br />
Vector of risk predictions from a <code>survivalmodel</code> model
(so high risk implies low survival time prediction).</p>
</td></tr>
<tr><td><code id="cindex_+3A_truth">truth</code></td>
<td>
<p>(<code>numeric()</code>) <br />
Vector of true survival times, must be same length as <code>risk</code>.</p>
</td></tr>
<tr><td><code id="cindex_+3A_...">...</code></td>
<td>
<p>(<code>ANY</code>) <br />
Further parameters passed to <a href="survival.html#topic+concordance">survival::concordance</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The numeric value of the index.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (!requireNamespace("survival", quietly = TRUE)) {
  set.seed(10)
  data &lt;- simsurvdata(20)
  fit &lt;- deepsurv(data = data[1:10, ])
  p &lt;- predict(fit, type = "risk", newdata = data[11:20, ])
  concordance(risk = p, truth = data[11:20, "time"])
}
</code></pre>

<hr>
<h2 id='coxtime'>Cox-Time Survival Neural Network</h2><span id='topic+coxtime'></span>

<h3>Description</h3>

<p>Cox-Time fits a neural network based on the Cox PH with
possibly time-dependent effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxtime(
  formula = NULL,
  data = NULL,
  reverse = FALSE,
  time_variable = "time",
  status_variable = "status",
  x = NULL,
  y = NULL,
  frac = 0,
  standardize_time = FALSE,
  log_duration = FALSE,
  with_mean = TRUE,
  with_std = TRUE,
  activation = "relu",
  num_nodes = c(32L, 32L),
  batch_norm = TRUE,
  dropout = NULL,
  device = NULL,
  shrink = 0,
  early_stopping = FALSE,
  best_weights = FALSE,
  min_delta = 0,
  patience = 10L,
  batch_size = 256L,
  epochs = 1L,
  verbose = FALSE,
  num_workers = 0L,
  shuffle = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxtime_+3A_formula">formula</code></td>
<td>
<p><code>(formula(1))</code><br />
Object specifying the model fit, left-hand-side of formula should describe a <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>
object.</p>
</td></tr>
<tr><td><code id="coxtime_+3A_data">data</code></td>
<td>
<p><code>(data.frame(1))</code><br />
Training data of <code>data.frame</code> like object, internally is coerced with <code><a href="stats.html#topic+model.matrix">stats::model.matrix()</a></code>.</p>
</td></tr>
<tr><td><code id="coxtime_+3A_reverse">reverse</code></td>
<td>
<p><code>(logical(1))</code><br />
If <code>TRUE</code> fits estimator on censoring distribution, otherwise (default) survival distribution.</p>
</td></tr>
<tr><td><code id="coxtime_+3A_time_variable">time_variable</code></td>
<td>
<p><code>(character(1))</code><br />
Alternative method to call the function. Name of the 'time' variable, required if <code>formula</code>.
or <code>x</code> and <code>Y</code> not given.</p>
</td></tr>
<tr><td><code id="coxtime_+3A_status_variable">status_variable</code></td>
<td>
<p><code>(character(1))</code><br />
Alternative method to call the function. Name of the 'status' variable, required if <code>formula</code>
or <code>x</code> and <code>Y</code> not given.</p>
</td></tr>
<tr><td><code id="coxtime_+3A_x">x</code></td>
<td>
<p><code>(data.frame(1))</code><br />
Alternative method to call the function. Required if <code style="white-space: pre;">&#8288;formula, time_variable&#8288;</code> and
<code>status_variable</code> not given. Data frame like object of features which is internally
coerced with <code>model.matrix</code>.</p>
</td></tr>
<tr><td><code id="coxtime_+3A_y">y</code></td>
<td>
<p><code style="white-space: pre;">&#8288;([survival::Surv()])&#8288;</code><br />
Alternative method to call the function. Required if <code style="white-space: pre;">&#8288;formula, time_variable&#8288;</code> and
<code>status_variable</code> not given. Survival outcome of right-censored observations.</p>
</td></tr>
<tr><td><code id="coxtime_+3A_frac">frac</code></td>
<td>
<p><code>(numeric(1))</code> <br />
Fraction of data to use for validation dataset, default is <code>0</code> and therefore no separate
validation dataset.</p>
</td></tr>
<tr><td><code id="coxtime_+3A_standardize_time">standardize_time</code></td>
<td>
<p><code>(logical(1))</code><br />
If <code>TRUE</code>, the time outcome is standardized.</p>
</td></tr>
<tr><td><code id="coxtime_+3A_log_duration">log_duration</code></td>
<td>
<p><code>(logical(1))</code><br />
If <code>TRUE</code> and <code>standardize_time</code> is <code>TRUE</code> then time variable is log transformed.</p>
</td></tr>
<tr><td><code id="coxtime_+3A_with_mean">with_mean</code></td>
<td>
<p><code>(logical(1))</code><br />
If <code>TRUE</code> (default) and <code>standardize_time</code> is <code>TRUE</code> then time variable is centered.</p>
</td></tr>
<tr><td><code id="coxtime_+3A_with_std">with_std</code></td>
<td>
<p><code>(logical(1))</code><br />
If <code>TRUE</code> (default) and <code>standardize_time</code> is <code>TRUE</code> then time variable is scaled to unit
variance.</p>
</td></tr>
<tr><td><code id="coxtime_+3A_activation">activation</code></td>
<td>
<p><code>(character(1))</code> <br />
See <a href="#topic+get_pycox_activation">get_pycox_activation</a>.</p>
</td></tr>
<tr><td><code id="coxtime_+3A_num_nodes">num_nodes</code>, <code id="coxtime_+3A_batch_norm">batch_norm</code>, <code id="coxtime_+3A_dropout">dropout</code></td>
<td>
<p><code>(integer()/logical(1)/numeric(1))</code> <br />
See <a href="#topic+build_pytorch_net">build_pytorch_net</a>.</p>
</td></tr>
<tr><td><code id="coxtime_+3A_device">device</code></td>
<td>
<p><code>(integer(1)|character(1))</code><br />
Passed to <code>pycox.models.Coxtime</code>, specifies device to compute models on.</p>
</td></tr>
<tr><td><code id="coxtime_+3A_shrink">shrink</code></td>
<td>
<p><code>(numeric(1))</code><br />
Passed to <code>pycox.models.Coxtime</code>, shrinkage parameter for regularization.</p>
</td></tr>
<tr><td><code id="coxtime_+3A_early_stopping">early_stopping</code>, <code id="coxtime_+3A_best_weights">best_weights</code>, <code id="coxtime_+3A_min_delta">min_delta</code>, <code id="coxtime_+3A_patience">patience</code></td>
<td>
<p><code style="white-space: pre;">&#8288;(logical(1)/logical(1)/numeric(1)/integer(1)&#8288;</code> <br />
See <a href="#topic+get_pycox_callbacks">get_pycox_callbacks</a>.</p>
</td></tr>
<tr><td><code id="coxtime_+3A_batch_size">batch_size</code></td>
<td>
<p><code>(integer(1))</code><br />
Passed to <code>pycox.models.Coxtime.fit</code>, elements in each batch.</p>
</td></tr>
<tr><td><code id="coxtime_+3A_epochs">epochs</code></td>
<td>
<p><code>(integer(1))</code><br />
Passed to <code>pycox.models.Coxtime.fit</code>, number of epochs.</p>
</td></tr>
<tr><td><code id="coxtime_+3A_verbose">verbose</code></td>
<td>
<p><code>(logical(1))</code><br />
Passed to <code>pycox.models.Coxtime.fit</code>, should information be displayed during
fitting.</p>
</td></tr>
<tr><td><code id="coxtime_+3A_num_workers">num_workers</code></td>
<td>
<p><code>(integer(1))</code><br />
Passed to <code>pycox.models.Coxtime.fit</code>, number of workers used in the
dataloader.</p>
</td></tr>
<tr><td><code id="coxtime_+3A_shuffle">shuffle</code></td>
<td>
<p><code>(logical(1))</code><br />
Passed to <code>pycox.models.Coxtime.fit</code>, should order of dataset be shuffled?</p>
</td></tr>
<tr><td><code id="coxtime_+3A_...">...</code></td>
<td>
<p><code>ANY</code> <br />
Passed to <a href="#topic+get_pycox_optim">get_pycox_optim</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implemented from the <code>pycox</code> Python package via <a href="https://CRAN.R-project.org/package=reticulate"><span class="pkg">reticulate</span></a>.
Calls <code>pycox.models.Coxtime</code>.
</p>


<h3>Value</h3>

<p>An object inheriting from class <code>coxtime</code>.
</p>
<p>An object of class <code>survivalmodel</code>.
</p>


<h3>References</h3>

<p>Kvamme, H., Borgan, Ø., &amp; Scheel, I. (2019).
Time-to-event prediction with neural networks and Cox regression.
Journal of Machine Learning Research, 20(129), 1–30.
</p>

<hr>
<h2 id='deephit'>DeepHit Survival Neural Network</h2><span id='topic+deephit'></span>

<h3>Description</h3>

<p>DeepHit fits a neural network based on the PMF of a discrete Cox model. This is
the single (non-competing) event implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deephit(
  formula = NULL,
  data = NULL,
  reverse = FALSE,
  time_variable = "time",
  status_variable = "status",
  x = NULL,
  y = NULL,
  frac = 0,
  cuts = 10,
  cutpoints = NULL,
  scheme = c("equidistant", "quantiles"),
  cut_min = 0,
  activation = "relu",
  custom_net = NULL,
  num_nodes = c(32L, 32L),
  batch_norm = TRUE,
  dropout = NULL,
  device = NULL,
  mod_alpha = 0.2,
  sigma = 0.1,
  early_stopping = FALSE,
  best_weights = FALSE,
  min_delta = 0,
  patience = 10L,
  batch_size = 256L,
  epochs = 1L,
  verbose = FALSE,
  num_workers = 0L,
  shuffle = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deephit_+3A_formula">formula</code></td>
<td>
<p><code>(formula(1))</code><br />
Object specifying the model fit, left-hand-side of formula should describe a <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>
object.</p>
</td></tr>
<tr><td><code id="deephit_+3A_data">data</code></td>
<td>
<p><code>(data.frame(1))</code><br />
Training data of <code>data.frame</code> like object, internally is coerced with <code><a href="stats.html#topic+model.matrix">stats::model.matrix()</a></code>.</p>
</td></tr>
<tr><td><code id="deephit_+3A_reverse">reverse</code></td>
<td>
<p><code>(logical(1))</code><br />
If <code>TRUE</code> fits estimator on censoring distribution, otherwise (default) survival distribution.</p>
</td></tr>
<tr><td><code id="deephit_+3A_time_variable">time_variable</code></td>
<td>
<p><code>(character(1))</code><br />
Alternative method to call the function. Name of the 'time' variable, required if <code>formula</code>.
or <code>x</code> and <code>Y</code> not given.</p>
</td></tr>
<tr><td><code id="deephit_+3A_status_variable">status_variable</code></td>
<td>
<p><code>(character(1))</code><br />
Alternative method to call the function. Name of the 'status' variable, required if <code>formula</code>
or <code>x</code> and <code>Y</code> not given.</p>
</td></tr>
<tr><td><code id="deephit_+3A_x">x</code></td>
<td>
<p><code>(data.frame(1))</code><br />
Alternative method to call the function. Required if <code style="white-space: pre;">&#8288;formula, time_variable&#8288;</code> and
<code>status_variable</code> not given. Data frame like object of features which is internally
coerced with <code>model.matrix</code>.</p>
</td></tr>
<tr><td><code id="deephit_+3A_y">y</code></td>
<td>
<p><code style="white-space: pre;">&#8288;([survival::Surv()])&#8288;</code><br />
Alternative method to call the function. Required if <code style="white-space: pre;">&#8288;formula, time_variable&#8288;</code> and
<code>status_variable</code> not given. Survival outcome of right-censored observations.</p>
</td></tr>
<tr><td><code id="deephit_+3A_frac">frac</code></td>
<td>
<p><code>(numeric(1))</code> <br />
Fraction of data to use for validation dataset, default is <code>0</code> and therefore no separate
validation dataset.</p>
</td></tr>
<tr><td><code id="deephit_+3A_cuts">cuts</code></td>
<td>
<p><code>(integer(1))</code><br />
If <code>discretise</code> is <code>TRUE</code> then determines number of cut-points for discretisation.</p>
</td></tr>
<tr><td><code id="deephit_+3A_cutpoints">cutpoints</code></td>
<td>
<p><code>(numeric())</code> <br />
Alternative to <code>cuts</code> if <code>discretise</code> is true, provide exact cutpoints for discretisation.
<code>cuts</code> is ignored if <code>cutpoints</code> is non-NULL.</p>
</td></tr>
<tr><td><code id="deephit_+3A_scheme">scheme</code></td>
<td>
<p><code>(character(1))</code><br />
Method of discretisation, either <code>"equidistant"</code> (default) or <code>"quantiles"</code>.
See <code>reticulate::py_help(pycox$models$LogisticHazard$label_transform)</code> for more detail.</p>
</td></tr>
<tr><td><code id="deephit_+3A_cut_min">cut_min</code></td>
<td>
<p><code>(integer(1))</code><br />
Starting duration for discretisation, see
<code>reticulate::py_help(pycox$models$LogisticHazard$label_transform)</code> for more detail.</p>
</td></tr>
<tr><td><code id="deephit_+3A_activation">activation</code></td>
<td>
<p><code>(character(1))</code> <br />
See <a href="#topic+get_pycox_activation">get_pycox_activation</a>.</p>
</td></tr>
<tr><td><code id="deephit_+3A_custom_net">custom_net</code></td>
<td>
<p><code>(torch.nn.modules.module.Module(1))</code><br />
Optional custom network built with <a href="#topic+build_pytorch_net">build_pytorch_net</a>, otherwise default architecture used.
Note that if building a custom network the number of output channels depends on <code>cuts</code> or
<code>cutpoints</code>.</p>
</td></tr>
<tr><td><code id="deephit_+3A_num_nodes">num_nodes</code>, <code id="deephit_+3A_batch_norm">batch_norm</code>, <code id="deephit_+3A_dropout">dropout</code></td>
<td>
<p><code>(integer()/logical(1)/numeric(1))</code> <br />
See <a href="#topic+build_pytorch_net">build_pytorch_net</a>.</p>
</td></tr>
<tr><td><code id="deephit_+3A_device">device</code></td>
<td>
<p><code>(integer(1)|character(1))</code><br />
Passed to <code>pycox.models.DeepHitSingle</code>, specifies device to compute models on.</p>
</td></tr>
<tr><td><code id="deephit_+3A_mod_alpha">mod_alpha</code></td>
<td>
<p><code>(numeric(1))</code><br />
Weighting in (0,1) for combining likelihood (L1) and rank loss (L2). See reference and
<code>py_help(pycox$models$DeepHitSingle)</code> for more detail.</p>
</td></tr>
<tr><td><code id="deephit_+3A_sigma">sigma</code></td>
<td>
<p><code>(numeric(1))</code><br />
From eta in rank loss (L2) of ref. See reference and
<code>py_help(pycox$models$DeepHitSingle)</code> for more detail.</p>
</td></tr>
<tr><td><code id="deephit_+3A_early_stopping">early_stopping</code>, <code id="deephit_+3A_best_weights">best_weights</code>, <code id="deephit_+3A_min_delta">min_delta</code>, <code id="deephit_+3A_patience">patience</code></td>
<td>
<p><code style="white-space: pre;">&#8288;(logical(1)/logical(1)/numeric(1)/integer(1)&#8288;</code> <br />
See <a href="#topic+get_pycox_callbacks">get_pycox_callbacks</a>.</p>
</td></tr>
<tr><td><code id="deephit_+3A_batch_size">batch_size</code></td>
<td>
<p><code>(integer(1))</code><br />
Passed to <code>pycox.models.DeepHitSingle.fit</code>, elements in each batch.</p>
</td></tr>
<tr><td><code id="deephit_+3A_epochs">epochs</code></td>
<td>
<p><code>(integer(1))</code><br />
Passed to <code>pycox.models.DeepHitSingle.fit</code>, number of epochs.</p>
</td></tr>
<tr><td><code id="deephit_+3A_verbose">verbose</code></td>
<td>
<p><code>(logical(1))</code><br />
Passed to <code>pycox.models.DeepHitSingle.fit</code>, should information be displayed during
fitting.</p>
</td></tr>
<tr><td><code id="deephit_+3A_num_workers">num_workers</code></td>
<td>
<p><code>(integer(1))</code><br />
Passed to <code>pycox.models.DeepHitSingle.fit</code>, number of workers used in the
dataloader.</p>
</td></tr>
<tr><td><code id="deephit_+3A_shuffle">shuffle</code></td>
<td>
<p><code>(logical(1))</code><br />
Passed to <code>pycox.models.DeepHitSingle.fit</code>, should order of dataset be shuffled?</p>
</td></tr>
<tr><td><code id="deephit_+3A_...">...</code></td>
<td>
<p><code>ANY</code> <br />
Passed to <a href="#topic+get_pycox_optim">get_pycox_optim</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implemented from the <code>pycox</code> Python package via <a href="https://CRAN.R-project.org/package=reticulate"><span class="pkg">reticulate</span></a>.
Calls <code>pycox.models.DeepHitSingle</code>.
</p>


<h3>Value</h3>

<p>An object inheriting from class <code>deephit</code>.
</p>
<p>An object of class <code>survivalmodel</code>.
</p>


<h3>References</h3>

<p>Changhee Lee, William R Zame, Jinsung Yoon, and Mihaela van der Schaar.
Deephit: A deep learning approach to survival analysis with competing risks.
In Thirty-Second AAAI Conference on Artificial Intelligence, 2018.
http://medianetlab.ee.ucla.edu/papers/AAAI_2018_DeepHit
</p>

<hr>
<h2 id='deepsurv'>DeepSurv Survival Neural Network</h2><span id='topic+deepsurv'></span>

<h3>Description</h3>

<p>DeepSurv neural fits a neural network based on the partial likelihood from
a Cox PH.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deepsurv(
  formula = NULL,
  data = NULL,
  reverse = FALSE,
  time_variable = "time",
  status_variable = "status",
  x = NULL,
  y = NULL,
  frac = 0,
  activation = "relu",
  num_nodes = c(32L, 32L),
  batch_norm = TRUE,
  dropout = NULL,
  device = NULL,
  early_stopping = FALSE,
  best_weights = FALSE,
  min_delta = 0,
  patience = 10L,
  batch_size = 256L,
  epochs = 1L,
  verbose = FALSE,
  num_workers = 0L,
  shuffle = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deepsurv_+3A_formula">formula</code></td>
<td>
<p><code>(formula(1))</code><br />
Object specifying the model fit, left-hand-side of formula should describe a <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>
object.</p>
</td></tr>
<tr><td><code id="deepsurv_+3A_data">data</code></td>
<td>
<p><code>(data.frame(1))</code><br />
Training data of <code>data.frame</code> like object, internally is coerced with <code><a href="stats.html#topic+model.matrix">stats::model.matrix()</a></code>.</p>
</td></tr>
<tr><td><code id="deepsurv_+3A_reverse">reverse</code></td>
<td>
<p><code>(logical(1))</code><br />
If <code>TRUE</code> fits estimator on censoring distribution, otherwise (default) survival distribution.</p>
</td></tr>
<tr><td><code id="deepsurv_+3A_time_variable">time_variable</code></td>
<td>
<p><code>(character(1))</code><br />
Alternative method to call the function. Name of the 'time' variable, required if <code>formula</code>.
or <code>x</code> and <code>Y</code> not given.</p>
</td></tr>
<tr><td><code id="deepsurv_+3A_status_variable">status_variable</code></td>
<td>
<p><code>(character(1))</code><br />
Alternative method to call the function. Name of the 'status' variable, required if <code>formula</code>
or <code>x</code> and <code>Y</code> not given.</p>
</td></tr>
<tr><td><code id="deepsurv_+3A_x">x</code></td>
<td>
<p><code>(data.frame(1))</code><br />
Alternative method to call the function. Required if <code style="white-space: pre;">&#8288;formula, time_variable&#8288;</code> and
<code>status_variable</code> not given. Data frame like object of features which is internally
coerced with <code>model.matrix</code>.</p>
</td></tr>
<tr><td><code id="deepsurv_+3A_y">y</code></td>
<td>
<p><code style="white-space: pre;">&#8288;([survival::Surv()])&#8288;</code><br />
Alternative method to call the function. Required if <code style="white-space: pre;">&#8288;formula, time_variable&#8288;</code> and
<code>status_variable</code> not given. Survival outcome of right-censored observations.</p>
</td></tr>
<tr><td><code id="deepsurv_+3A_frac">frac</code></td>
<td>
<p><code>(numeric(1))</code> <br />
Fraction of data to use for validation dataset, default is <code>0</code> and therefore no separate
validation dataset.</p>
</td></tr>
<tr><td><code id="deepsurv_+3A_activation">activation</code></td>
<td>
<p><code>(character(1))</code> <br />
See <a href="#topic+get_pycox_activation">get_pycox_activation</a>.</p>
</td></tr>
<tr><td><code id="deepsurv_+3A_num_nodes">num_nodes</code>, <code id="deepsurv_+3A_batch_norm">batch_norm</code>, <code id="deepsurv_+3A_dropout">dropout</code></td>
<td>
<p><code>(integer()/logical(1)/numeric(1))</code> <br />
See <a href="#topic+build_pytorch_net">build_pytorch_net</a>.</p>
</td></tr>
<tr><td><code id="deepsurv_+3A_device">device</code></td>
<td>
<p><code>(integer(1)|character(1))</code><br />
Passed to <code>pycox.models.CoxPH</code>, specifies device to compute models on.</p>
</td></tr>
<tr><td><code id="deepsurv_+3A_early_stopping">early_stopping</code>, <code id="deepsurv_+3A_best_weights">best_weights</code>, <code id="deepsurv_+3A_min_delta">min_delta</code>, <code id="deepsurv_+3A_patience">patience</code></td>
<td>
<p><code style="white-space: pre;">&#8288;(logical(1)/logical(1)/numeric(1)/integer(1)&#8288;</code> <br />
See <a href="#topic+get_pycox_callbacks">get_pycox_callbacks</a>.</p>
</td></tr>
<tr><td><code id="deepsurv_+3A_batch_size">batch_size</code></td>
<td>
<p><code>(integer(1))</code><br />
Passed to <code>pycox.models.CoxPH.fit</code>, elements in each batch.</p>
</td></tr>
<tr><td><code id="deepsurv_+3A_epochs">epochs</code></td>
<td>
<p><code>(integer(1))</code><br />
Passed to <code>pycox.models.CoxPH.fit</code>, number of epochs.</p>
</td></tr>
<tr><td><code id="deepsurv_+3A_verbose">verbose</code></td>
<td>
<p><code>(logical(1))</code><br />
Passed to <code>pycox.models.CoxPH.fit</code>, should information be displayed during
fitting.</p>
</td></tr>
<tr><td><code id="deepsurv_+3A_num_workers">num_workers</code></td>
<td>
<p><code>(integer(1))</code><br />
Passed to <code>pycox.models.CoxPH.fit</code>, number of workers used in the
dataloader.</p>
</td></tr>
<tr><td><code id="deepsurv_+3A_shuffle">shuffle</code></td>
<td>
<p><code>(logical(1))</code><br />
Passed to <code>pycox.models.CoxPH.fit</code>, should order of dataset be shuffled?</p>
</td></tr>
<tr><td><code id="deepsurv_+3A_...">...</code></td>
<td>
<p><code>ANY</code> <br />
Passed to <a href="#topic+get_pycox_optim">get_pycox_optim</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implemented from the <code>pycox</code> Python package via <a href="https://CRAN.R-project.org/package=reticulate"><span class="pkg">reticulate</span></a>.
Calls <code>pycox.models.CoxPH</code>.
</p>


<h3>Value</h3>

<p>An object inheriting from class <code>deepsurv</code>.
</p>
<p>An object of class <code>survivalmodel</code>.
</p>


<h3>References</h3>

<p>Katzman, J. L., Shaham, U., Cloninger, A., Bates, J., Jiang, T., &amp; Kluger, Y. (2018).
DeepSurv: personalized treatment recommender system using a Cox proportional hazards deep neural
network.
BMC Medical Research Methodology, 18(1), 24. https://doi.org/10.1186/s12874-018-0482-1
</p>

<hr>
<h2 id='get_keras_optimizer'>Get Keras Optimizer</h2><span id='topic+get_keras_optimizer'></span>

<h3>Description</h3>

<p>Utility function to construct optimiser from <a href="https://CRAN.R-project.org/package=keras"><span class="pkg">keras</span></a>, primarily for
internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_keras_optimizer(
  optimizer = "adam",
  lr = 0.001,
  beta_1 = 0.9,
  beta_2 = 0.999,
  epsilon = 1e-07,
  decay = NULL,
  clipnorm = NULL,
  clipvalue = NULL,
  momentum = 0,
  nesterov = FALSE,
  rho = 0.95,
  global_clipnorm = NULL,
  use_ema = FALSE,
  ema_momentum = 0.99,
  ema_overwrite_frequency = NULL,
  jit_compile = TRUE,
  initial_accumultator_value = 0.1,
  amsgrad = FALSE,
  lr_power = -0.5,
  l1_regularization_strength = 0,
  l2_regularization_strength = 0,
  l2_shrinkage_regularization_strength = 0,
  beta = 0,
  centered = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_keras_optimizer_+3A_optimizer">optimizer</code></td>
<td>
<p><code>(character(1))</code> <br /> Optimizer to construct, see details for those available.
Default is <code>"adam"</code>.</p>
</td></tr>
<tr><td><code id="get_keras_optimizer_+3A_lr">lr</code></td>
<td>
<p><code>(numeric(1))</code> <br /> Learning rate passed to all optimizers.</p>
</td></tr>
<tr><td><code id="get_keras_optimizer_+3A_beta_1">beta_1</code>, <code id="get_keras_optimizer_+3A_beta_2">beta_2</code></td>
<td>
<p><code>(numeric(1))</code> <br /> Passed to <code>adamax</code>, <code>adam</code>, and <code>nadam</code>.</p>
</td></tr>
<tr><td><code id="get_keras_optimizer_+3A_epsilon">epsilon</code></td>
<td>
<p><code>(numeric(1))</code> <br /> Passed to <code>adadelta</code>, <code>adagrad</code>, <code>adam</code>, <code>adamax</code>, <code>nadam</code>, <code>rmsprop</code></p>
</td></tr>
<tr><td><code id="get_keras_optimizer_+3A_decay">decay</code>, <code id="get_keras_optimizer_+3A_clipnorm">clipnorm</code>, <code id="get_keras_optimizer_+3A_clipvalue">clipvalue</code>, <code id="get_keras_optimizer_+3A_global_clipnorm">global_clipnorm</code></td>
<td>
<p><code>(numeric(1))</code> <br /> Passed to all optimizers.</p>
</td></tr>
<tr><td><code id="get_keras_optimizer_+3A_momentum">momentum</code></td>
<td>
<p><code>(numeric(1))</code> <br /> Passed to <code>rmsprop</code> and <code>sgd</code>.</p>
</td></tr>
<tr><td><code id="get_keras_optimizer_+3A_nesterov">nesterov</code></td>
<td>
<p><code>(logical(1))</code> <br /> Passed to <code>sgd</code>.</p>
</td></tr>
<tr><td><code id="get_keras_optimizer_+3A_rho">rho</code></td>
<td>
<p><code>(numeric(1))</code> <br /> Passed to <code>adadelta</code> and <code>rmsprop</code>.</p>
</td></tr>
<tr><td><code id="get_keras_optimizer_+3A_use_ema">use_ema</code>, <code id="get_keras_optimizer_+3A_jit_compile">jit_compile</code></td>
<td>
<p><code>(logical(1))</code> <br /> Passed to all optimizers.</p>
</td></tr>
<tr><td><code id="get_keras_optimizer_+3A_ema_momentum">ema_momentum</code>, <code id="get_keras_optimizer_+3A_ema_overwrite_frequency">ema_overwrite_frequency</code></td>
<td>
<p><code>(numeric(1))</code> <br /> Passed to all optimizers.</p>
</td></tr>
<tr><td><code id="get_keras_optimizer_+3A_initial_accumultator_value">initial_accumultator_value</code></td>
<td>
<p><code>(numeric(1))</code> <br /> Passed to <code>adagrad</code> and <code>ftrl</code>.</p>
</td></tr>
<tr><td><code id="get_keras_optimizer_+3A_amsgrad">amsgrad</code></td>
<td>
<p><code>(logical(1))</code> <br /> Passed to <code>adam</code> and <code>sgd</code>.</p>
</td></tr>
<tr><td><code id="get_keras_optimizer_+3A_lr_power">lr_power</code>, <code id="get_keras_optimizer_+3A_l1_regularization_strength">l1_regularization_strength</code>, <code id="get_keras_optimizer_+3A_l2_regularization_strength">l2_regularization_strength</code>, <code id="get_keras_optimizer_+3A_l2_shrinkage_regularization_strength">l2_shrinkage_regularization_strength</code>, <code id="get_keras_optimizer_+3A_beta">beta</code></td>
<td>
<p><code>(numeric(1))</code> <br /> Passed to <code>ftrl</code>.</p>
</td></tr>
<tr><td><code id="get_keras_optimizer_+3A_centered">centered</code></td>
<td>
<p><code>(logical(1))</code> <br /> Passed to <code>rmsprop</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implemented optimizers are
</p>

<ul>
<li> <p><code>"adadelta"</code> <br /> <a href="keras.html#topic+optimizer_adadelta">keras::optimizer_adadelta</a>
</p>
</li>
<li> <p><code>"adagrad"</code> <br /> <a href="keras.html#topic+optimizer_adagrad">keras::optimizer_adagrad</a>
</p>
</li>
<li> <p><code>"adam"</code> <br /> <a href="keras.html#topic+optimizer_adam">keras::optimizer_adam</a>
</p>
</li>
<li> <p><code>"adamax"</code> <br /> <a href="keras.html#topic+optimizer_adamax">keras::optimizer_adamax</a>
</p>
</li>
<li> <p><code>"ftrl"</code> <br /> <a href="keras.html#topic+optimizer_ftrl">keras::optimizer_ftrl</a>
</p>
</li>
<li> <p><code>"nadam"</code> <br /> <a href="keras.html#topic+optimizer_nadam">keras::optimizer_nadam</a>
</p>
</li>
<li> <p><code>"rmsprop"</code> <br /> <a href="keras.html#topic+optimizer_rmsprop">keras::optimizer_rmsprop</a>
</p>
</li>
<li> <p><code>"sgd"</code> <br /> <a href="keras.html#topic+optimizer_sgd">keras::optimizer_sgd</a>
</p>
</li></ul>



<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='get_pycox_activation'>Get Pytorch Activation Function</h2><span id='topic+get_pycox_activation'></span>

<h3>Description</h3>

<p>Helper function to return a class or constructed object for
pytorch activation function from <code>torch.nn.modules.activation</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pycox_activation(
  activation = "relu",
  construct = TRUE,
  alpha = 1,
  dim = NULL,
  lambd = 0.5,
  min_val = -1,
  max_val = 1,
  negative_slope = 0.01,
  num_parameters = 1L,
  init = 0.25,
  lower = 1/8,
  upper = 1/3,
  beta = 1,
  threshold = 20,
  value = 20
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pycox_activation_+3A_activation">activation</code></td>
<td>
<p><code>(character(1))</code><br /> Activation function method, see
details for list of implemented methods.</p>
</td></tr>
<tr><td><code id="get_pycox_activation_+3A_construct">construct</code></td>
<td>
<p><code>(logical(1))</code><br /> If <code>TRUE</code> (default) returns constructed
object, otherwise a class.</p>
</td></tr>
<tr><td><code id="get_pycox_activation_+3A_alpha">alpha</code></td>
<td>
<p><code>(numeric(1))</code><br /> Passed to <code>celu</code> and <code>elu</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_activation_+3A_dim">dim</code></td>
<td>
<p><code>(integer(1))</code><br /> Passed to <code>glu</code>, <code>logsoftmax</code>, <code>softmax</code>, and</p>
</td></tr>
<tr><td><code id="get_pycox_activation_+3A_lambd">lambd</code></td>
<td>
<p><code>(numeric(1))</code><br /> Passed to <code>hardshrink</code> and <code>softshrink</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_activation_+3A_min_val">min_val</code>, <code id="get_pycox_activation_+3A_max_val">max_val</code></td>
<td>
<p><code>(numeric(1))</code><br /> Passed to <code>hardtanh</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_activation_+3A_negative_slope">negative_slope</code></td>
<td>
<p><code>(numeric(1))</code><br /> Passed to <code>leakyrelu</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_activation_+3A_num_parameters">num_parameters</code></td>
<td>
<p><code>(integer(1))</code><br /> Passed to <code>prelu</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_activation_+3A_init">init</code></td>
<td>
<p><code>(numeric(1))</code><br /> Passed to <code>prelu</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_activation_+3A_lower">lower</code>, <code id="get_pycox_activation_+3A_upper">upper</code></td>
<td>
<p><code>(numeric(1))</code><br /> Passed to <code>rrelu</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_activation_+3A_beta">beta</code></td>
<td>
<p><code>(numeric(1))</code><br /> Passed to <code>softplus</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_activation_+3A_threshold">threshold</code></td>
<td>
<p><code>(numeric(1))</code><br /> Passed to <code>softplus</code> and <code>threshold</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_activation_+3A_value">value</code></td>
<td>
<p><code>(numeric(1))</code><br /> Passed to <code>threshold</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implemented methods (with help pages) are
</p>

<ul>
<li> <p><code>"celu"</code> <br /> <code>reticulate::py_help(torch$nn$modules$activation$CELU)</code>
</p>
</li>
<li> <p><code>"elu"</code> <br /> <code>reticulate::py_help(torch$nn$modules$activation$ELU)</code>
</p>
</li>
<li> <p><code>"gelu"</code> <br /> <code>reticulate::py_help(torch$nn$modules$activation$GELU)</code>
</p>
</li>
<li> <p><code>"glu"</code> <br /> <code>reticulate::py_help(torch$nn$modules$activation$GLU)</code>
</p>
</li>
<li> <p><code>"hardshrink"</code> <br /> <code>reticulate::py_help(torch$nn$modules$activation$Hardshrink)</code>
</p>
</li>
<li> <p><code>"hardsigmoid"</code> <br /> <code>reticulate::py_help(torch$nn$modules$activation$Hardsigmoid)</code>
</p>
</li>
<li> <p><code>"hardswish"</code> <br /> <code>reticulate::py_help(torch$nn$modules$activation$Hardswish)</code>
</p>
</li>
<li> <p><code>"hardtanh"</code> <br /> <code>reticulate::py_help(torch$nn$modules$activation$Hardtanh)</code>
</p>
</li>
<li> <p><code>"relu6"</code> <br /> <code>reticulate::py_help(torch$nn$modules$activation$ReLU6)</code>
</p>
</li>
<li> <p><code>"leakyrelu"</code> <br /> <code>reticulate::py_help(torch$nn$modules$activation$LeakyReLU)</code>
</p>
</li>
<li> <p><code>"logsigmoid"</code> <br /> <code>reticulate::py_help(torch$nn$modules$activation$LogSigmoid)</code>
</p>
</li>
<li> <p><code>"logsoftmax"</code> <br /> <code>reticulate::py_help(torch$nn$modules$activation$LogSoftmax)</code>
</p>
</li>
<li> <p><code>"prelu"</code> <br /> <code>reticulate::py_help(torch$nn$modules$activation$PReLU)</code>
</p>
</li>
<li> <p><code>"rrelu"</code> <br /> <code>reticulate::py_help(torch$nn$modules$activation$RReLU)</code>
</p>
</li>
<li> <p><code>"relu"</code> <br /> <code>reticulate::py_help(torch$nn$modules$activation$ReLU)</code>
</p>
</li>
<li> <p><code>"selu"</code> <br /> <code>reticulate::py_help(torch$nn$modules$activation$SELU)</code>
</p>
</li>
<li> <p><code>"sigmoid"</code> <br /> <code>reticulate::py_help(torch$nn$modules$activation$Sigmoid)</code>
</p>
</li>
<li> <p><code>"softmax"</code> <br /> <code>reticulate::py_help(torch$nn$modules$activation$Softmax)</code>
</p>
</li>
<li> <p><code>"softmax2d"</code> <br /> <code>reticulate::py_help(torch$nn$modules$activation$Softmax2d)</code>
</p>
</li>
<li> <p><code>"softmin"</code> <br /> <code>reticulate::py_help(torch$nn$modules$activation$Softmin)</code>
</p>
</li>
<li> <p><code>"softplus"</code> <br /> <code>reticulate::py_help(torch$nn$modules$activation$Softplus)</code>
</p>
</li>
<li> <p><code>"softshrink"</code> <br /> <code>reticulate::py_help(torch$nn$modules$activation$Softshrink)</code>
</p>
</li>
<li> <p><code>"softsign"</code> <br /> <code>reticulate::py_help(torch$nn$modules$activation$Softsign)</code>
</p>
</li>
<li> <p><code>"tanh"</code> <br /> <code>reticulate::py_help(torch$nn$modules$activation$Tanh)</code>
</p>
</li>
<li> <p><code>"tanhshrink"</code> <br /> <code>reticulate::py_help(torch$nn$modules$activation$Tanhshrink)</code>
</p>
</li>
<li> <p><code>"threshold"</code> <br /> <code>reticulate::py_help(torch$nn$modules$activation$Threshold)</code>
</p>
</li></ul>



<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='get_pycox_callbacks'>Get Torchtuples Callbacks</h2><span id='topic+get_pycox_callbacks'></span>

<h3>Description</h3>

<p>Helper function to return torchtuples callbacks from <code>torchtuples.callbacks</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pycox_callbacks(
  early_stopping = FALSE,
  best_weights = FALSE,
  min_delta = 0,
  patience = 10L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pycox_callbacks_+3A_early_stopping">early_stopping</code></td>
<td>
<p><code>(logical(1))</code> <br />
If <code>TRUE</code> then constructs <code style="white-space: pre;">&#8288;torchtuples.callbacks,EarlyStopping&#8288;</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_callbacks_+3A_best_weights">best_weights</code></td>
<td>
<p><code>(logical(1))</code><br />
If <code>TRUE</code> then returns <code>torchtuples.callbacks.BestWeights</code>. Ignored if <code>early_stopping</code>
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_callbacks_+3A_min_delta">min_delta</code></td>
<td>
<p><code>(numeric(1))</code><br />
Passed to <code>torchtuples.callbacks.EarlyStopping</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_callbacks_+3A_patience">patience</code></td>
<td>
<p><code>(integer(1))</code><br />
Passed to <code>torchtuples.callbacks.EarlyStopping</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='get_pycox_init'>Get Pytorch Weight Initialization Method</h2><span id='topic+get_pycox_init'></span>

<h3>Description</h3>

<p>Helper function to return a character string with a populated pytorch weight
initializer method from <code>torch.nn.init</code>. Used in <a href="#topic+build_pytorch_net">build_pytorch_net</a> to define a weighting
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pycox_init(
  init = "uniform",
  a = 0,
  b = 1,
  mean = 0,
  std = 1,
  val,
  gain = 1,
  mode = c("fan_in", "fan_out"),
  non_linearity = c("leaky_relu", "relu")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pycox_init_+3A_init">init</code></td>
<td>
<p><code>(character(1))</code><br /> Initialization method, see details for list of implemented
methods.</p>
</td></tr>
<tr><td><code id="get_pycox_init_+3A_a">a</code></td>
<td>
<p><code>(numeric(1))</code><br /> Passed to <code>uniform</code>, <code>kaiming_uniform</code>, and <code>kaiming_normal</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_init_+3A_b">b</code></td>
<td>
<p><code>(numeric(1))</code><br /> Passed to <code>uniform</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_init_+3A_mean">mean</code>, <code id="get_pycox_init_+3A_std">std</code></td>
<td>
<p><code>(numeric(1))</code><br /> Passed to <code>normal</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_init_+3A_val">val</code></td>
<td>
<p><code>(numeric(1))</code><br /> Passed to <code>constant</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_init_+3A_gain">gain</code></td>
<td>
<p><code>(numeric(1))</code><br /> Passed to <code>xavier_uniform</code>, <code>xavier_normal</code>, and <code>orthogonal</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_init_+3A_mode">mode</code></td>
<td>
<p><code>(character(1))</code><br /> Passed to <code>kaiming_uniform</code> and <code>kaiming_normal</code>, one of
<code>fan_in</code> (default) and <code>fan_out</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_init_+3A_non_linearity">non_linearity</code></td>
<td>
<p><code>(character(1))</code><br /> Passed to <code>kaiming_uniform</code> and <code>kaiming_normal</code>, one of
<code>leaky_relu</code> (default) and <code>relu</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implemented methods (with help pages) are
</p>

<ul>
<li> <p><code>"uniform"</code> <br /> <code>reticulate::py_help(torch$nn$init$uniform_)</code>
</p>
</li>
<li> <p><code>"normal"</code> <br /> <code>reticulate::py_help(torch$nn$init$normal_)</code>
</p>
</li>
<li> <p><code>"constant"</code> <br /> <code>reticulate::py_help(torch$nn$init$constant_)</code>
</p>
</li>
<li> <p><code>"xavier_uniform"</code> <br /> <code>reticulate::py_help(torch$nn$init$xavier_uniform_)</code>
</p>
</li>
<li> <p><code>"xavier_normal"</code> <br /> <code>reticulate::py_help(torch$nn$init$xavier_normal_)</code>
</p>
</li>
<li> <p><code>"kaiming_uniform"</code> <br /> <code>reticulate::py_help(torch$nn$init$kaiming_uniform_)</code>
</p>
</li>
<li> <p><code>"kaiming_normal"</code> <br /> <code>reticulate::py_help(torch$nn$init$kaiming_normal_)</code>
</p>
</li>
<li> <p><code>"orthogonal"</code> <br /> <code>reticulate::py_help(torch$nn$init$orthogonal_)</code>
</p>
</li></ul>



<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='get_pycox_optim'>Get Pytorch Optimizer</h2><span id='topic+get_pycox_optim'></span>

<h3>Description</h3>

<p>Helper function to return a constructed pytorch optimizer from <code>torch.optim</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pycox_optim(
  optimizer = "adam",
  net,
  rho = 0.9,
  eps = 1e-08,
  lr = 1,
  weight_decay = 0,
  learning_rate = 0.01,
  lr_decay = 0,
  betas = c(0.9, 0.999),
  amsgrad = FALSE,
  lambd = 1e-04,
  alpha = 0.75,
  t0 = 1e+06,
  momentum = 0,
  centered = TRUE,
  etas = c(0.5, 1.2),
  step_sizes = c(1e-06, 50),
  dampening = 0,
  nesterov = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pycox_optim_+3A_optimizer">optimizer</code></td>
<td>
<p><code>(character(1))</code><br /> Optimizer, see details for list of implemented methods.</p>
</td></tr>
<tr><td><code id="get_pycox_optim_+3A_net">net</code></td>
<td>
<p><code>(torch.nn.modules.module.Module)</code><br /> Network architecture, can be built from
<a href="#topic+build_pytorch_net">build_pytorch_net</a>.</p>
</td></tr>
<tr><td><code id="get_pycox_optim_+3A_rho">rho</code>, <code id="get_pycox_optim_+3A_lr">lr</code>, <code id="get_pycox_optim_+3A_lr_decay">lr_decay</code></td>
<td>
<p><code>(numeric(1))</code><br /> Passed to <code>adadelta</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_optim_+3A_eps">eps</code></td>
<td>
<p><code>(numeric(1))</code><br /> Passed to all methods except <code>asgd</code>, <code>rprop</code>, and <code>sgd</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_optim_+3A_weight_decay">weight_decay</code></td>
<td>
<p><code>(numeric(1))</code><br /> Passed to all methods except <code>rprop</code> and <code>sparse_adam</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_optim_+3A_learning_rate">learning_rate</code></td>
<td>
<p><code>(numeric(1))</code><br /> Passed to all methods except <code>adadelta</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_optim_+3A_betas">betas</code></td>
<td>
<p><code>(numeric(2))</code><br /> Passed to <code>adam</code>, <code>adamax</code>, <code>adamw</code>, and <code>sparse_adam</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_optim_+3A_amsgrad">amsgrad</code></td>
<td>
<p><code>(logical(1))</code><br /> Passed to <code>adam</code> and <code>adamw</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_optim_+3A_lambd">lambd</code>, <code id="get_pycox_optim_+3A_t0">t0</code></td>
<td>
<p><code>(numeric(1))</code><br /> Passed to <code>asgd</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_optim_+3A_alpha">alpha</code></td>
<td>
<p><code>(numeric(1))</code><br /> Passed to <code>asgd</code> and <code>rmsprop</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_optim_+3A_momentum">momentum</code></td>
<td>
<p><code>(numeric(1))</code><br /> Passed to <code>rmsprop</code> and <code>sgd</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_optim_+3A_centered">centered</code></td>
<td>
<p><code>(logical(1))</code><br /> Passed to <code>rmsprop</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_optim_+3A_etas">etas</code>, <code id="get_pycox_optim_+3A_step_sizes">step_sizes</code></td>
<td>
<p><code>(numeric(2))</code><br /> Passed to <code>rprop</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_optim_+3A_dampening">dampening</code></td>
<td>
<p><code>(numeric(1))</code><br /> Passed to <code>sgd</code>.</p>
</td></tr>
<tr><td><code id="get_pycox_optim_+3A_nesterov">nesterov</code></td>
<td>
<p><code>(logical(1))</code><br /> Passed to <code>sgd</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implemented methods (with help pages) are
</p>

<ul>
<li> <p><code>"adadelta"</code> <br /> <code>reticulate::py_help(torch$optim$Adadelta)</code>
</p>
</li>
<li> <p><code>"adagrad"</code> <br /> <code>reticulate::py_help(torch$optim$Adagrad)</code>
</p>
</li>
<li> <p><code>"adam"</code> <br /> <code>reticulate::py_help(torch$optim$Adam)</code>
</p>
</li>
<li> <p><code>"adamax"</code> <br /> <code>reticulate::py_help(torch$optim$Adamax)</code>
</p>
</li>
<li> <p><code>"adamw"</code> <br /> <code>reticulate::py_help(torch$optim$AdamW)</code>
</p>
</li>
<li> <p><code>"asgd"</code> <br /> <code>reticulate::py_help(torch$optim$ASGD)</code>
</p>
</li>
<li> <p><code>"rmsprop"</code> <br /> <code>reticulate::py_help(torch$optim$RMSprop)</code>
</p>
</li>
<li> <p><code>"rprop"</code> <br /> <code>reticulate::py_help(torch$optim$Rprop)</code>
</p>
</li>
<li> <p><code>"sgd"</code> <br /> <code>reticulate::py_help(torch$optim$SGD)</code>
</p>
</li>
<li> <p><code>"sparse_adam"</code> <br /> <code>reticulate::py_help(torch$optim$SparseAdam)</code>
</p>
</li></ul>



<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='install_keras'>Install Keras and Tensorflow</h2><span id='topic+install_keras'></span>

<h3>Description</h3>

<p>Stripped back version of <a href="keras.html#topic+install_keras">keras::install_keras</a>. Note the
default for <code>pip</code> is changed to <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>install_keras(
  method = "auto",
  conda = "auto",
  pip = TRUE,
  install_tensorflow = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="install_keras_+3A_method">method</code>, <code id="install_keras_+3A_conda">conda</code>, <code id="install_keras_+3A_pip">pip</code></td>
<td>
<p>See <a href="reticulate.html#topic+py_install">reticulate::py_install</a>.</p>
</td></tr>
<tr><td><code id="install_keras_+3A_install_tensorflow">install_tensorflow</code></td>
<td>
<p>If <code>TRUE</code> installs the dependency <code>tensorflow</code> package as well.</p>
</td></tr>
<tr><td><code id="install_keras_+3A_...">...</code></td>
<td>
<p>Passed to <a href="reticulate.html#topic+py_install">reticulate::py_install</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='install_pycox'>Install Pycox With Reticulate</h2><span id='topic+install_pycox'></span>

<h3>Description</h3>

<p>Installs the python 'pycox' package via reticulate.
Note the default for <code>pip</code> is changed to <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>install_pycox(
  method = "auto",
  conda = "auto",
  pip = TRUE,
  install_torch = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="install_pycox_+3A_method">method</code>, <code id="install_pycox_+3A_conda">conda</code>, <code id="install_pycox_+3A_pip">pip</code></td>
<td>
<p>See <a href="reticulate.html#topic+py_install">reticulate::py_install</a>.</p>
</td></tr>
<tr><td><code id="install_pycox_+3A_install_torch">install_torch</code></td>
<td>
<p>If <code>TRUE</code> installs the dependency <code>torch</code> package as
well.</p>
</td></tr>
<tr><td><code id="install_pycox_+3A_...">...</code></td>
<td>
<p>Passed to <a href="reticulate.html#topic+py_install">reticulate::py_install</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='install_torch'>Install Torch With Reticulate</h2><span id='topic+install_torch'></span>

<h3>Description</h3>

<p>Installs the python 'torch' package via reticulate. Note the
default for <code>pip</code> is changed to <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>install_torch(method = "auto", conda = "auto", pip = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="install_torch_+3A_method">method</code>, <code id="install_torch_+3A_conda">conda</code>, <code id="install_torch_+3A_pip">pip</code></td>
<td>
<p>See <a href="reticulate.html#topic+py_install">reticulate::py_install</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='loghaz'>Logistic-Hazard Survival Neural Network</h2><span id='topic+loghaz'></span>

<h3>Description</h3>

<p>Logistic-Hazard fits a discrete neural network based on a cross-entropy loss
and predictions of a discrete hazard function, also known as Nnet-Survival.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loghaz(
  formula = NULL,
  data = NULL,
  reverse = FALSE,
  time_variable = "time",
  status_variable = "status",
  x = NULL,
  y = NULL,
  frac = 0,
  cuts = 10,
  cutpoints = NULL,
  scheme = c("equidistant", "quantiles"),
  cut_min = 0,
  activation = "relu",
  custom_net = NULL,
  num_nodes = c(32L, 32L),
  batch_norm = TRUE,
  dropout = NULL,
  device = NULL,
  early_stopping = FALSE,
  best_weights = FALSE,
  min_delta = 0,
  patience = 10L,
  batch_size = 256L,
  epochs = 1L,
  verbose = FALSE,
  num_workers = 0L,
  shuffle = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loghaz_+3A_formula">formula</code></td>
<td>
<p><code>(formula(1))</code><br />
Object specifying the model fit, left-hand-side of formula should describe a <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>
object.</p>
</td></tr>
<tr><td><code id="loghaz_+3A_data">data</code></td>
<td>
<p><code>(data.frame(1))</code><br />
Training data of <code>data.frame</code> like object, internally is coerced with <code><a href="stats.html#topic+model.matrix">stats::model.matrix()</a></code>.</p>
</td></tr>
<tr><td><code id="loghaz_+3A_reverse">reverse</code></td>
<td>
<p><code>(logical(1))</code><br />
If <code>TRUE</code> fits estimator on censoring distribution, otherwise (default) survival distribution.</p>
</td></tr>
<tr><td><code id="loghaz_+3A_time_variable">time_variable</code></td>
<td>
<p><code>(character(1))</code><br />
Alternative method to call the function. Name of the 'time' variable, required if <code>formula</code>.
or <code>x</code> and <code>Y</code> not given.</p>
</td></tr>
<tr><td><code id="loghaz_+3A_status_variable">status_variable</code></td>
<td>
<p><code>(character(1))</code><br />
Alternative method to call the function. Name of the 'status' variable, required if <code>formula</code>
or <code>x</code> and <code>Y</code> not given.</p>
</td></tr>
<tr><td><code id="loghaz_+3A_x">x</code></td>
<td>
<p><code>(data.frame(1))</code><br />
Alternative method to call the function. Required if <code style="white-space: pre;">&#8288;formula, time_variable&#8288;</code> and
<code>status_variable</code> not given. Data frame like object of features which is internally
coerced with <code>model.matrix</code>.</p>
</td></tr>
<tr><td><code id="loghaz_+3A_y">y</code></td>
<td>
<p><code style="white-space: pre;">&#8288;([survival::Surv()])&#8288;</code><br />
Alternative method to call the function. Required if <code style="white-space: pre;">&#8288;formula, time_variable&#8288;</code> and
<code>status_variable</code> not given. Survival outcome of right-censored observations.</p>
</td></tr>
<tr><td><code id="loghaz_+3A_frac">frac</code></td>
<td>
<p><code>(numeric(1))</code> <br />
Fraction of data to use for validation dataset, default is <code>0</code> and therefore no separate
validation dataset.</p>
</td></tr>
<tr><td><code id="loghaz_+3A_cuts">cuts</code></td>
<td>
<p><code>(integer(1))</code><br />
If <code>discretise</code> is <code>TRUE</code> then determines number of cut-points for discretisation.</p>
</td></tr>
<tr><td><code id="loghaz_+3A_cutpoints">cutpoints</code></td>
<td>
<p><code>(numeric())</code> <br />
Alternative to <code>cuts</code> if <code>discretise</code> is true, provide exact cutpoints for discretisation.
<code>cuts</code> is ignored if <code>cutpoints</code> is non-NULL.</p>
</td></tr>
<tr><td><code id="loghaz_+3A_scheme">scheme</code></td>
<td>
<p><code>(character(1))</code><br />
Method of discretisation, either <code>"equidistant"</code> (default) or <code>"quantiles"</code>.
See <code>reticulate::py_help(pycox$models$LogisticHazard$label_transform)</code> for more detail.</p>
</td></tr>
<tr><td><code id="loghaz_+3A_cut_min">cut_min</code></td>
<td>
<p><code>(integer(1))</code><br />
Starting duration for discretisation, see
<code>reticulate::py_help(pycox$models$LogisticHazard$label_transform)</code> for more detail.</p>
</td></tr>
<tr><td><code id="loghaz_+3A_activation">activation</code></td>
<td>
<p><code>(character(1))</code> <br />
See <a href="#topic+get_pycox_activation">get_pycox_activation</a>.</p>
</td></tr>
<tr><td><code id="loghaz_+3A_custom_net">custom_net</code></td>
<td>
<p><code>(torch.nn.modules.module.Module(1))</code><br />
Optional custom network built with <a href="#topic+build_pytorch_net">build_pytorch_net</a>, otherwise default architecture used.
Note that if building a custom network the number of output channels depends on <code>cuts</code> or
<code>cutpoints</code>.</p>
</td></tr>
<tr><td><code id="loghaz_+3A_num_nodes">num_nodes</code>, <code id="loghaz_+3A_batch_norm">batch_norm</code>, <code id="loghaz_+3A_dropout">dropout</code></td>
<td>
<p><code>(integer()/logical(1)/numeric(1))</code> <br />
See <a href="#topic+build_pytorch_net">build_pytorch_net</a>.</p>
</td></tr>
<tr><td><code id="loghaz_+3A_device">device</code></td>
<td>
<p><code>(integer(1)|character(1))</code><br />
Passed to <code>pycox.models.LogisticHazard</code>, specifies device to compute models on.</p>
</td></tr>
<tr><td><code id="loghaz_+3A_early_stopping">early_stopping</code>, <code id="loghaz_+3A_best_weights">best_weights</code>, <code id="loghaz_+3A_min_delta">min_delta</code>, <code id="loghaz_+3A_patience">patience</code></td>
<td>
<p><code style="white-space: pre;">&#8288;(logical(1)/logical(1)/numeric(1)/integer(1)&#8288;</code> <br />
See <a href="#topic+get_pycox_callbacks">get_pycox_callbacks</a>.</p>
</td></tr>
<tr><td><code id="loghaz_+3A_batch_size">batch_size</code></td>
<td>
<p><code>(integer(1))</code><br />
Passed to <code>pycox.models.LogisticHazard.fit</code>, elements in each batch.</p>
</td></tr>
<tr><td><code id="loghaz_+3A_epochs">epochs</code></td>
<td>
<p><code>(integer(1))</code><br />
Passed to <code>pycox.models.LogisticHazard.fit</code>, number of epochs.</p>
</td></tr>
<tr><td><code id="loghaz_+3A_verbose">verbose</code></td>
<td>
<p><code>(logical(1))</code><br />
Passed to <code>pycox.models.LogisticHazard.fit</code>, should information be displayed during
fitting.</p>
</td></tr>
<tr><td><code id="loghaz_+3A_num_workers">num_workers</code></td>
<td>
<p><code>(integer(1))</code><br />
Passed to <code>pycox.models.LogisticHazard.fit</code>, number of workers used in the
dataloader.</p>
</td></tr>
<tr><td><code id="loghaz_+3A_shuffle">shuffle</code></td>
<td>
<p><code>(logical(1))</code><br />
Passed to <code>pycox.models.LogisticHazard.fit</code>, should order of dataset be shuffled?</p>
</td></tr>
<tr><td><code id="loghaz_+3A_...">...</code></td>
<td>
<p><code>ANY</code> <br />
Passed to <a href="#topic+get_pycox_optim">get_pycox_optim</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implemented from the <code>pycox</code> Python package via <a href="https://CRAN.R-project.org/package=reticulate"><span class="pkg">reticulate</span></a>.
Calls <code>pycox.models.LogisticHazard</code>.
</p>


<h3>Value</h3>

<p>An object inheriting from class <code>loghaz</code>.
</p>
<p>An object of class <code>survivalmodel</code>.
</p>


<h3>References</h3>

<p>Gensheimer, M. F., &amp; Narasimhan, B. (2018).
A Simple Discrete-Time Survival Model for Neural Networks, 1–17.
https://doi.org/arXiv:1805.00917v3
</p>
<p>Kvamme, H., &amp; Borgan, Ø. (2019).
Continuous and discrete-time survival prediction with neural networks.
https://doi.org/arXiv:1910.06724.
</p>

<hr>
<h2 id='pchazard'>PC-Hazard Survival Neural Network</h2><span id='topic+pchazard'></span>

<h3>Description</h3>

<p>Logistic-Hazard fits a discrete neural network based on a cross-entropy loss
and predictions of a discrete hazard function, also known as Nnet-Survival.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pchazard(
  formula = NULL,
  data = NULL,
  reverse = FALSE,
  time_variable = "time",
  status_variable = "status",
  x = NULL,
  y = NULL,
  frac = 0,
  cuts = 10,
  cutpoints = NULL,
  scheme = c("equidistant", "quantiles"),
  cut_min = 0,
  activation = "relu",
  custom_net = NULL,
  num_nodes = c(32L, 32L),
  batch_norm = TRUE,
  reduction = c("mean", "none", "sum"),
  dropout = NULL,
  device = NULL,
  early_stopping = FALSE,
  best_weights = FALSE,
  min_delta = 0,
  patience = 10L,
  batch_size = 256L,
  epochs = 1L,
  verbose = FALSE,
  num_workers = 0L,
  shuffle = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pchazard_+3A_formula">formula</code></td>
<td>
<p><code>(formula(1))</code><br />
Object specifying the model fit, left-hand-side of formula should describe a <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>
object.</p>
</td></tr>
<tr><td><code id="pchazard_+3A_data">data</code></td>
<td>
<p><code>(data.frame(1))</code><br />
Training data of <code>data.frame</code> like object, internally is coerced with <code><a href="stats.html#topic+model.matrix">stats::model.matrix()</a></code>.</p>
</td></tr>
<tr><td><code id="pchazard_+3A_reverse">reverse</code></td>
<td>
<p><code>(logical(1))</code><br />
If <code>TRUE</code> fits estimator on censoring distribution, otherwise (default) survival distribution.</p>
</td></tr>
<tr><td><code id="pchazard_+3A_time_variable">time_variable</code></td>
<td>
<p><code>(character(1))</code><br />
Alternative method to call the function. Name of the 'time' variable, required if <code>formula</code>.
or <code>x</code> and <code>Y</code> not given.</p>
</td></tr>
<tr><td><code id="pchazard_+3A_status_variable">status_variable</code></td>
<td>
<p><code>(character(1))</code><br />
Alternative method to call the function. Name of the 'status' variable, required if <code>formula</code>
or <code>x</code> and <code>Y</code> not given.</p>
</td></tr>
<tr><td><code id="pchazard_+3A_x">x</code></td>
<td>
<p><code>(data.frame(1))</code><br />
Alternative method to call the function. Required if <code style="white-space: pre;">&#8288;formula, time_variable&#8288;</code> and
<code>status_variable</code> not given. Data frame like object of features which is internally
coerced with <code>model.matrix</code>.</p>
</td></tr>
<tr><td><code id="pchazard_+3A_y">y</code></td>
<td>
<p><code style="white-space: pre;">&#8288;([survival::Surv()])&#8288;</code><br />
Alternative method to call the function. Required if <code style="white-space: pre;">&#8288;formula, time_variable&#8288;</code> and
<code>status_variable</code> not given. Survival outcome of right-censored observations.</p>
</td></tr>
<tr><td><code id="pchazard_+3A_frac">frac</code></td>
<td>
<p><code>(numeric(1))</code> <br />
Fraction of data to use for validation dataset, default is <code>0</code> and therefore no separate
validation dataset.</p>
</td></tr>
<tr><td><code id="pchazard_+3A_cuts">cuts</code></td>
<td>
<p><code>(integer(1))</code><br />
If <code>discretise</code> is <code>TRUE</code> then determines number of cut-points for discretisation.</p>
</td></tr>
<tr><td><code id="pchazard_+3A_cutpoints">cutpoints</code></td>
<td>
<p><code>(numeric())</code> <br />
Alternative to <code>cuts</code> if <code>discretise</code> is true, provide exact cutpoints for discretisation.
<code>cuts</code> is ignored if <code>cutpoints</code> is non-NULL.</p>
</td></tr>
<tr><td><code id="pchazard_+3A_scheme">scheme</code></td>
<td>
<p><code>(character(1))</code><br />
Method of discretisation, either <code>"equidistant"</code> (default) or <code>"quantiles"</code>.
See <code>reticulate::py_help(pycox$models$LogisticHazard$label_transform)</code> for more detail.</p>
</td></tr>
<tr><td><code id="pchazard_+3A_cut_min">cut_min</code></td>
<td>
<p><code>(integer(1))</code><br />
Starting duration for discretisation, see
<code>reticulate::py_help(pycox$models$LogisticHazard$label_transform)</code> for more detail.</p>
</td></tr>
<tr><td><code id="pchazard_+3A_activation">activation</code></td>
<td>
<p><code>(character(1))</code> <br />
See <a href="#topic+get_pycox_activation">get_pycox_activation</a>.</p>
</td></tr>
<tr><td><code id="pchazard_+3A_custom_net">custom_net</code></td>
<td>
<p><code>(torch.nn.modules.module.Module(1))</code><br />
Optional custom network built with <a href="#topic+build_pytorch_net">build_pytorch_net</a>, otherwise default architecture used.
Note that if building a custom network the number of output channels depends on <code>cuts</code> or
<code>cutpoints</code>.</p>
</td></tr>
<tr><td><code id="pchazard_+3A_num_nodes">num_nodes</code>, <code id="pchazard_+3A_batch_norm">batch_norm</code>, <code id="pchazard_+3A_dropout">dropout</code></td>
<td>
<p><code>(integer()/logical(1)/numeric(1))</code> <br />
See <a href="#topic+build_pytorch_net">build_pytorch_net</a>.</p>
</td></tr>
<tr><td><code id="pchazard_+3A_reduction">reduction</code></td>
<td>
<p><code>(character(1))</code><br />
How to reduce the loss, see to <code>reticulate::py_help(pycox$models$loss$NLLPCHazardLoss)</code>.</p>
</td></tr>
<tr><td><code id="pchazard_+3A_device">device</code></td>
<td>
<p><code>(integer(1)|character(1))</code><br />
Passed to <code>pycox.models.PCHazard</code>, specifies device to compute models on.</p>
</td></tr>
<tr><td><code id="pchazard_+3A_early_stopping">early_stopping</code>, <code id="pchazard_+3A_best_weights">best_weights</code>, <code id="pchazard_+3A_min_delta">min_delta</code>, <code id="pchazard_+3A_patience">patience</code></td>
<td>
<p><code style="white-space: pre;">&#8288;(logical(1)/logical(1)/numeric(1)/integer(1)&#8288;</code> <br />
See <a href="#topic+get_pycox_callbacks">get_pycox_callbacks</a>.</p>
</td></tr>
<tr><td><code id="pchazard_+3A_batch_size">batch_size</code></td>
<td>
<p><code>(integer(1))</code><br />
Passed to <code>pycox.models.PCHazard.fit</code>, elements in each batch.</p>
</td></tr>
<tr><td><code id="pchazard_+3A_epochs">epochs</code></td>
<td>
<p><code>(integer(1))</code><br />
Passed to <code>pycox.models.PCHazard.fit</code>, number of epochs.</p>
</td></tr>
<tr><td><code id="pchazard_+3A_verbose">verbose</code></td>
<td>
<p><code>(logical(1))</code><br />
Passed to <code>pycox.models.PCHazard.fit</code>, should information be displayed during
fitting.</p>
</td></tr>
<tr><td><code id="pchazard_+3A_num_workers">num_workers</code></td>
<td>
<p><code>(integer(1))</code><br />
Passed to <code>pycox.models.PCHazard.fit</code>, number of workers used in the
dataloader.</p>
</td></tr>
<tr><td><code id="pchazard_+3A_shuffle">shuffle</code></td>
<td>
<p><code>(logical(1))</code><br />
Passed to <code>pycox.models.PCHazard.fit</code>, should order of dataset be shuffled?</p>
</td></tr>
<tr><td><code id="pchazard_+3A_...">...</code></td>
<td>
<p><code>ANY</code> <br />
Passed to <a href="#topic+get_pycox_optim">get_pycox_optim</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implemented from the <code>pycox</code> Python package via <a href="https://CRAN.R-project.org/package=reticulate"><span class="pkg">reticulate</span></a>.
Calls <code>pycox.models.PCHazard</code>.
</p>


<h3>Value</h3>

<p>An object inheriting from class <code>pchazard</code>.
</p>
<p>An object of class <code>survivalmodel</code>.
</p>


<h3>References</h3>

<p>Kvamme, H., &amp; Borgan, Ø. (2019).
Continuous and discrete-time survival prediction with neural networks.
https://doi.org/arXiv:1910.06724.
</p>

<hr>
<h2 id='predict.pycox'>Predict Method for pycox Neural Networks</h2><span id='topic+predict.pycox'></span>

<h3>Description</h3>

<p>Predicted values from a fitted pycox ANN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pycox'
predict(
  object,
  newdata,
  batch_size = 256L,
  num_workers = 0L,
  interpolate = FALSE,
  inter_scheme = c("const_hazard", "const_pdf"),
  sub = 10L,
  type = c("survival", "risk", "all"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.pycox_+3A_object">object</code></td>
<td>
<p><code>(pycox(1))</code><br />
Object of class inheriting from <code>"pycox"</code>.</p>
</td></tr>
<tr><td><code id="predict.pycox_+3A_newdata">newdata</code></td>
<td>
<p><code>(data.frame(1))</code><br />
Testing data of <code>data.frame</code> like object, internally is coerced with <code><a href="stats.html#topic+model.matrix">stats::model.matrix()</a></code>.
If missing then training data from fitted object is used.</p>
</td></tr>
<tr><td><code id="predict.pycox_+3A_batch_size">batch_size</code></td>
<td>
<p><code>(integer(1))</code><br />
Passed to <code>pycox.models.X.fit</code>, elements in each batch.</p>
</td></tr>
<tr><td><code id="predict.pycox_+3A_num_workers">num_workers</code></td>
<td>
<p><code>(integer(1))</code><br />
Passed to <code>pycox.models.X.fit</code>, number of workers used in the dataloader.</p>
</td></tr>
<tr><td><code id="predict.pycox_+3A_interpolate">interpolate</code></td>
<td>
<p><code>(logical(1))</code><br />
For models <code>deephit</code> and <code>loghaz</code>, should predictions be linearly interpolated? Ignored
for other models.</p>
</td></tr>
<tr><td><code id="predict.pycox_+3A_inter_scheme">inter_scheme</code></td>
<td>
<p><code>(character(1))</code><br />
If <code>interpolate</code> is <code>TRUE</code> then the scheme for interpolation, see
<code>reticulate::py_help(py_help(pycox$models$DeepHitSingle$interpolate))</code> for further
details.</p>
</td></tr>
<tr><td><code id="predict.pycox_+3A_sub">sub</code></td>
<td>
<p><code>(integer(1))</code><br />
If <code>interpolate</code> is <code>TRUE</code> or model is <code>loghaz</code>, number of sub-divisions for interpolation.
See reticulate::py_help(py_help(pycox$models$DeepHitSingle$interpolate))' for further
details.</p>
</td></tr>
<tr><td><code id="predict.pycox_+3A_type">type</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Type of predicted value. Choices are survival probabilities over all time-points in training
data (<code>"survival"</code>) or a relative risk ranking (<code>"risk"</code>), which is the negative mean survival
time so higher rank implies higher risk of event, or both (<code>"all"</code>).</p>
</td></tr>
<tr><td><code id="predict.pycox_+3A_...">...</code></td>
<td>
<p><code>ANY</code> <br />
Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> if <code>type = "risk"</code>, a <code>matrix</code> if <code>type = "survival"</code> where
entries are survival probabilities with rows of observations and columns are time-points.
</p>

<hr>
<h2 id='pycox_prepare_train_data'>Prepare Data for Pycox Model Training</h2><span id='topic+pycox_prepare_train_data'></span>

<h3>Description</h3>

<p>Utility function to prepare data for training in a Pycox model.
Generally used internally only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pycox_prepare_train_data(
  x_train,
  y_train,
  frac = 0,
  standardize_time = FALSE,
  log_duration = FALSE,
  with_mean = TRUE,
  with_std = TRUE,
  discretise = FALSE,
  cuts = 10L,
  cutpoints = NULL,
  scheme = c("equidistant", "quantiles"),
  cut_min = 0L,
  model = c("coxtime", "deepsurv", "deephit", "loghaz", "pchazard")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pycox_prepare_train_data_+3A_x_train">x_train</code></td>
<td>
<p><code>(matrix(1))</code> <br /> Training covariates.</p>
</td></tr>
<tr><td><code id="pycox_prepare_train_data_+3A_y_train">y_train</code></td>
<td>
<p><code>(matrix(1))</code> <br /> Training outcomes.</p>
</td></tr>
<tr><td><code id="pycox_prepare_train_data_+3A_frac">frac</code></td>
<td>
<p><code>(numeric(1))</code><br /> Fraction of data to use for validation
dataset, default is <code>0</code> and therefore no separate validation dataset.</p>
</td></tr>
<tr><td><code id="pycox_prepare_train_data_+3A_standardize_time">standardize_time</code></td>
<td>
<p><code>(logical(1))</code><br /> If <code>TRUE</code>, the time outcome to be
standardized. For use with <a href="#topic+coxtime">coxtime</a>.</p>
</td></tr>
<tr><td><code id="pycox_prepare_train_data_+3A_log_duration">log_duration</code></td>
<td>
<p><code>(logical(1))</code><br /> If <code>TRUE</code> and <code>standardize_time</code> is
<code>TRUE</code> then time variable is log transformed.</p>
</td></tr>
<tr><td><code id="pycox_prepare_train_data_+3A_with_mean">with_mean</code></td>
<td>
<p><code>(logical(1))</code><br /> If <code>TRUE</code> (default) and
<code>standardize_time</code> is <code>TRUE</code> then time
variable is centered.</p>
</td></tr>
<tr><td><code id="pycox_prepare_train_data_+3A_with_std">with_std</code></td>
<td>
<p><code>(logical(1))</code><br /> If <code>TRUE</code> (default) and <code>standardize_time</code>
is <code>TRUE</code> then time
variable is scaled to unit variance.</p>
</td></tr>
<tr><td><code id="pycox_prepare_train_data_+3A_discretise">discretise</code></td>
<td>
<p><code>(logical(1))</code><br /> If <code>TRUE</code> then time is discretised. For
use with the models
<a href="#topic+deephit">deephit</a>, <a href="#topic+pchazard">pchazard</a>, and <a href="#topic+loghaz">loghaz</a>.</p>
</td></tr>
<tr><td><code id="pycox_prepare_train_data_+3A_cuts">cuts</code></td>
<td>
<p><code>(integer(1))</code><br /> If <code>discretise</code> is <code>TRUE</code> then determines
number of cut-points for discretisation.</p>
</td></tr>
<tr><td><code id="pycox_prepare_train_data_+3A_cutpoints">cutpoints</code></td>
<td>
<p><code>(numeric())</code> <br /> Alternative to <code>cuts</code> if <code>discretise</code> is
true, provide exact cutpoints for discretisation. <code>cuts</code> is ignored if
<code>cutpoints</code> is non-NULL.</p>
</td></tr>
<tr><td><code id="pycox_prepare_train_data_+3A_scheme">scheme</code></td>
<td>
<p><code>(character(1))</code><br /> Method of discretisation, either
<code>"equidistant"</code> (default) or <code>"quantiles"</code>. See
<code>reticulate::py_help(pycox$models$LogisticHazard$label_transform)</code>.</p>
</td></tr>
<tr><td><code id="pycox_prepare_train_data_+3A_cut_min">cut_min</code></td>
<td>
<p><code>(integer(1))</code><br /> Starting duration for discretisation, see
<code>reticulate::py_help(pycox$models$LogisticHazard$label_transform)</code>.</p>
</td></tr>
<tr><td><code id="pycox_prepare_train_data_+3A_model">model</code></td>
<td>
<p><code>(character(1))</code><br /> Corresponding pycox model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='requireNamespaces'>Vectorised Logical requireNamespace</h2><span id='topic+requireNamespaces'></span>

<h3>Description</h3>

<p>Helper function for internal use. Vectorises the <a href="base.html#topic+requireNamespace">requireNamespace</a> function and
returns <code>TRUE</code> if all packages, <code>x</code>, are available and <code>FALSE</code> otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>requireNamespaces(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="requireNamespaces_+3A_x">x</code></td>
<td>
<p><code>(character())</code> <br /> string naming the packages/name spaces to load.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='set_seed'>Set seed in R numpy and torch</h2><span id='topic+set_seed'></span>

<h3>Description</h3>

<p>To ensure consistent results, a seed has to be set in R
using <code>set.seed</code> as usual but also in  <code>numpy</code> and  <code>torch</code> via  <code>reticulate</code>.
Therefore this function simplifies the process into one funciton.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_seed(seed_R, seed_np = seed_R, seed_torch = seed_R)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_seed_+3A_seed_r">seed_R</code></td>
<td>
<p>(<code>integer(1)</code>) <br /> <code>seed</code> passed to <a href="base.html#topic+set.seed">set.seed</a>.</p>
</td></tr>
<tr><td><code id="set_seed_+3A_seed_np">seed_np</code></td>
<td>
<p>(<code>integer(1)</code>) <br /> <code>seed</code> passed to <code>numpy$random$seed</code>. Default is same as <code>seed_R</code>.</p>
</td></tr>
<tr><td><code id="set_seed_+3A_seed_torch">seed_torch</code></td>
<td>
<p>(<code>integer(1)</code>) <br /> <code>seed</code> passed to <code>numpy$random$seed</code>.
Default is same as <code>seed_R</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='simsurvdata'>Simulate Survival Data</h2><span id='topic+simsurvdata'></span>

<h3>Description</h3>

<p>Function for simulating survival data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simsurvdata(n = 100, trt = 2, age = 2, sex = 1.5, cens = 0.3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simsurvdata_+3A_n">n</code></td>
<td>
<p><code>(integer(1))</code> <br /> Number of samples</p>
</td></tr>
<tr><td><code id="simsurvdata_+3A_trt">trt</code>, <code id="simsurvdata_+3A_age">age</code>, <code id="simsurvdata_+3A_sex">sex</code></td>
<td>
<p><code>(numeric(1))</code> <br /> Coefficients for covariates.</p>
</td></tr>
<tr><td><code id="simsurvdata_+3A_cens">cens</code></td>
<td>
<p><code>(numeric(1))</code> <br /> Proportion of censoring to be generated, cut-off time is then
selected as the quantile that results in <code>cens</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently limited to three covariates, Weibull survival times, and Type I censoring.
This will be expanded to a flexible simulation function in future updates. For now the function
is primarily limited to helping function examples.
</p>


<h3>Value</h3>

<p><code><a href="base.html#topic+data.frame">data.frame()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simsurvdata()

</code></pre>

<hr>
<h2 id='surv_to_risk'>Safely convert a survival matrix prediction to a relative risk</h2><span id='topic+surv_to_risk'></span>

<h3>Description</h3>

<p>Many methods can be used to reduce a discrete survival
distribution prediction (i.e. matrix) to a relative risk / ranking
prediction. Here we define the predicted relative risk as the sum of
the predicted cumulative hazard function - which can be loosely interpreted
as the expected number of deaths for patients with similar characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surv_to_risk(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surv_to_risk_+3A_x">x</code></td>
<td>
<p>(<code>matrix()</code>) <br /> TxN survival matrix prediction where T is number
of time-points and N is number of predicted observations. Colum names
correspond to predicted time-points and should therefore be coercable to
numeric and increasing. Entries are survival predictions and should
be (non-strictly) decreasing in each row.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the expected number of deaths.
</p>


<h3>References</h3>

<p>Sonabend, R., Bender, A., &amp; Vollmer, S. (2021).
Evaluation of survival distribution predictions with discrimination
measures. http://arxiv.org/abs/2112.04828.
</p>

<hr>
<h2 id='survivalmodels-package'>survivalmodels: Models for Survival Analysis</h2><span id='topic+survivalmodels'></span><span id='topic+survivalmodels-package'></span>

<h3>Description</h3>

<p>survivalmodels implements classical and machine learning models for survival analysis that either
do not already exist in R or for more efficient implementations.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Yohann Foucher <a href="mailto:yohann.foucher@univ-poitiers.fr">yohann.foucher@univ-poitiers.fr</a> (<a href="https://orcid.org/0000-0003-0330-7457">ORCID</a>)
Authors:
</p>

<ul>
<li><p> Raphael Sonabend (<a href="https://orcid.org/0000-0001-9225-4654">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/RaphaelS1/survivalmodels/">https://github.com/RaphaelS1/survivalmodels/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/foucher-y/survivalmodels/issues">https://github.com/foucher-y/survivalmodels/issues</a>
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
