<!DOCTYPE html><html lang="en"><head><title>Help for package TestCor</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TestCor}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#TestCor-package'>
<p>FWER and FDR controlling procedures for multiple correlation tests</p></a></li>
<li><a href='#ApplyFdrCor'><p>Applies multiple testing procedures built to control (asymptotically) the FDR for correlation testing.</p></a></li>
<li><a href='#ApplyFwerCor'><p>Applies multiple testing procedures controlling (asymptotically) the FWER</p>
for tests on a correlation matrix.</a></li>
<li><a href='#ApplyFwerCor_oracle'><p>Applies an oracle version of MaxTinfty procedure described in Drton &amp; Perlman (2007) for correlation testing.</p></a></li>
<li><a href='#BHBootCor'><p>Benjamini &amp; Hochberg (1995)'s procedure for correlation testing with bootstrap evaluation of p-values.</p></a></li>
<li><a href='#BHCor'><p>Benjamini &amp; Hochberg (1995)'s procedure for correlation testing.</p></a></li>
<li><a href='#BonferroniCor'><p>Bonferroni multiple testing procedure for correlations.</p></a></li>
<li><a href='#BonferroniCor_SD'><p>Bonferroni multiple testing method for correlations</p>
with stepdown procedure.</a></li>
<li><a href='#BootRWCor'><p>Bootstrap multiple testing method of Romano &amp; Wolf (2005) for correlations.</p></a></li>
<li><a href='#BootRWCor_SD'><p>Boootstrap multiple testing method of Romano &amp; Wolf (2005) for correlations, with stepdown procedure.</p></a></li>
<li><a href='#covD2nd'><p>Returns the theoretical covariance of empirical correlations.</p></a></li>
<li><a href='#covDcor'><p>Returns the theoretical covariance of empirical correlations.</p></a></li>
<li><a href='#covDcorNorm'><p>Returns the theoretical covariance of test statistics for correlation testing.</p></a></li>
<li><a href='#eval_stat'><p>Evaluates the test statistics for tests on correlation matrix entries.</p></a></li>
<li><a href='#LCTboot'><p>Bootstrap procedure LCT-B proposed by Cai &amp; Liu (2016) for correlation testing.</p></a></li>
<li><a href='#LCTnorm'><p>Procedure LCT-N proposed by Cai &amp; Liu (2016) for correlation testing.</p></a></li>
<li><a href='#maxTinftyCor'><p>Multiple testing method of Drton &amp; Perlman (2007) for correlations.</p></a></li>
<li><a href='#maxTinftyCor_SD'><p>Multiple testing method of Drton &amp; Perlman (2007) for correlations, with stepdown procedure.</p></a></li>
<li><a href='#SidakCor'><p>Sidak multiple testing procedure for correlations.</p></a></li>
<li><a href='#SidakCor_SD'><p>Sidak multiple testing method for correlations</p>
with stepdown procedure.</a></li>
<li><a href='#SimuFdr'><p>Simulates Gaussian data with a given correlation matrix and applies a FDR controlling procedure on the correlations.</p></a></li>
<li><a href='#SimuFwer'><p>Simulates Gaussian data with a given correlation matrix and applies a FWER controlling procedure on the correlations.</p></a></li>
<li><a href='#SimuFwer_oracle'><p>Simulates Gaussian data with a given correlation matrix and applies oracle MaxTinfty on the correlations.</p></a></li>
<li><a href='#UncorrectedCor'><p>Uncorrected testing procedure for correlations.</p></a></li>
<li><a href='#unvectorize'><p>Returns an upper-triangle matrix, without the diagonal, containing the elements of a given vector.</p></a></li>
<li><a href='#vectorize'><p>Returns a vector containing the upper triangle of a matrix, without the diagonal.</p></a></li>
<li><a href='#whichCor'><p>Returns the indexes of an upper triangular matrix with logical entries.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>FWER and FDR Controlling Procedures for Multiple Correlation
Tests</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-09-18</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gannaz Irene &lt;irene.gannaz@insa-lyon.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>
       Different multiple testing procedures for correlation tests are implemented. These procedures were shown to theoretically control asymptotically the Family Wise Error Rate (Roux (2018) <a href="https://tel.archives-ouvertes.fr/tel-01971574v1">https://tel.archives-ouvertes.fr/tel-01971574v1</a>) or the False Discovery Rate (Cai &amp; Liu (2016) &lt;<a href="https://doi.org/10.1080%2F01621459.2014.999157">doi:10.1080/01621459.2014.999157</a>&gt;). The package gather four test statistics used in correlation testing, four FWER procedures with either single step or stepdown versions, and four FDR procedures.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, MASS, stats</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Gannaz Irene [aut, cre]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-10-15 08:17:20 UTC; igannaz</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-10-15 08:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='TestCor-package'>
FWER and FDR controlling procedures for multiple correlation tests
</h2><span id='topic+TestCor-package'></span><span id='topic+TestCor'></span>

<h3>Description</h3>

<p>The package compiles some multiple testing procedures which theoretically control asymptotically the FWER in the framework of correlation testing.
Four tests statistics can be considered: the empirical correlation, the Student statistics, the Fisher's z-transform and the usual Gaussian statistics considering random variables <code class="reqn">(X_i-mean(X_i))(X_j-mean(X_j))</code>.
Four methods are implemented: Bonferroni (1935)'s, Šidák (1967)'s, Romano &amp; Wolf (2005)'s bootstrap and (Drton &amp; Perlman (2007)'s procedure based on the asymptotic distributions of the test statistics, called MaxTinfty.
The package also includes some multiple testing procedures which are related to the control of the FDR : Cai &amp; Liu (2016)'s procedures called LCT-N and LCT-B -which have been proven to control the FDR for correlation tests- and Benjamini &amp; Hochberg (1995)'s -which has no theoretical results in correlation testing.
</p>


<h3>Details</h3>

<p>Consider <code class="reqn">\lbrace \bold{X}_\ell = (X_{1\ell},\dots X_{p\ell}),\; \ell=1,...,n\rbrace</code> a set of <code class="reqn">n</code> independent and identically distributed <code class="reqn">R^p</code>-valued random variables. Denote <code>data</code> the array containing <code class="reqn">\lbrace\mathbf{X_\ell},\; \ell=1,\dots,n\rbrace</code>, with observation indexes <code class="reqn">l</code> in row. The aim is to test simultaneously </p>
<p style="text-align: center;"><code class="reqn">(H_{0ij})~ Cor(X_i,X_j)=0 {~~against~~} (H_{1ij})~ Cor(X_i,X_j)\neq 0,~~ i,j=1,..., p,~ i&lt;j.</code>
</p>

<p>Four tests statistics are implemented: the empirical correlation, the Student statistics, the Fisher's z-transform and the usual test statistics on expectancy considering the product of random variables. They are available in function <code>eval_stat</code>.
Next, two main types of procedures are available:
</p>

<dl>
<dt>Asymptotically FWER controlling procedures:</dt><dd><p>Bonferroni (1935)'s method, Šidák (1967)'s procedure, Romano &amp; Wolf (2005)'s bootstrap procedure and Drton &amp; Perlman (2007)'s procedure. A description of these methods can be found in Chapter 5 of Roux (2018). To apply these procedures, function <code>ApplyFwerCor</code> can be used as follows:
</p>
<p><code>ApplyFwerCor(data,alpha,stat_test,method)</code>, with <code>alpha</code> the desired level of control for FDR and <code>stat_test</code>, <code>method</code> respectively the kind of test statistic and the FDR controlling method. The function returns the list of indexes <code class="reqn">\lbrace (i,j),  i &lt; j \rbrace</code> for which null hypothesis <code class="reqn">(H_{0ij})</code> is rejected.</p>
</dd>
<dt>Asymptotically FDR controlling procedures:</dt><dd><p>Cai &amp; Liu(2016)'s two procedures and Benjamini &amp; Hochberg (1995)'s procedure (with no theoretical proof for the latest). To apply these procedures, use function <code>ApplyFdrCor</code> as follows:
<code>ApplyFdrCor(data,alpha,stat_test,method)</code> with <code>alpha</code> the desired level of control for FWER and <code>stat_test</code>, <code>method</code> respectively the kind of test statistic and the FDR controlling method. The function returns the list of indexes <code class="reqn">\lbrace (i,j),  i &lt; j \rbrace</code> for which null hypothesis <code class="reqn">(H_{0ij})</code> is rejected. </p>
</dd>
</dl>

<p>Functions <code>SimuFwer</code> and <code>SimuFdr</code> provide simulations of Gaussian random variables for a given correlation matrix and return estimated FWER, FDR, Power and true discovery rate obtained applying one of the procedure above. Some example of results obtained can be found in Chapter 6 of Roux (2018). 
</p>


<h3>Author(s)</h3>

<p>Irene Gannaz
</p>
<p>Maintainer: Irene Gannaz &lt;irene.gannaz@insa-lyon.fr&gt;
</p>


<h3>References</h3>

<p>Benjamini, Y., &amp; Hochberg, Y. (1995). Controlling the false discovery rate: a practical and powerful approach to multiple testing. Journal of the royal statistical society. Series B (Methodological), 289-300, <a href="https://doi.org/10.1111/j.2517-6161.1995.tb02031.x">https://doi.org/10.1111/j.2517-6161.1995.tb02031.x</a>.
</p>
<p>Bonferroni, C. E. (1935). Il calcolo delle assicurazioni su gruppi di teste. Studi in onore del professore salvatore ortu carboni, 13-60. 
</p>
<p>Cai, T. T., &amp; Liu, W. (2016). Large-scale multiple testing of correlations. Journal of the American Statistical Association, 111(513), 229-240, <a href="https://doi.org/10.1080/01621459.2014.999157">https://doi.org/10.1080/01621459.2014.999157</a>.
</p>
<p>Drton, M., &amp; Perlman, M. D. (2007). Multiple testing and error control in Gaussian graphical model selection. Statistical Science, 22(3), 430-449, <a href="https://doi.org/10.1214/088342307000000113">https://doi.org/10.1214/088342307000000113</a>.
</p>
<p>Romano, J. P., &amp; Wolf, M. (2005). Exact and approximate stepdown methods for multiple hypothesis testing. Journal of the American Statistical Association, 100(469), 94-108, <a href="https://doi.org/10.1198/016214504000000539">https://doi.org/10.1198/016214504000000539</a>.
</p>
<p>Roux, M. (2018). Graph inference by multiple testing with application to Neuroimaging, Ph.D., Université Grenoble Alpes, France, <a href="https://tel.archives-ouvertes.fr/tel-01971574v1">https://tel.archives-ouvertes.fr/tel-01971574v1</a>.
</p>
<p>Šidák, Z. (1967). Rectangular confidence regions for the means of multivariate normal distributions. Journal of the American Statistical Association, 62(318), 626-633.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Parameters for simulations
Nsimu  &lt;- 100                # number of Monte-Carlo simulations
seqn   &lt;- seq(100,400,100)   # sample sizes
p      &lt;- 10                 # number of random variables considered
rho    &lt;- 0.3                # value of non-zero correlations
seed   &lt;- 156724
 
corr_theo &lt;- diag(1,p)       # the correlation matrix
corr_theo[1,2:p] &lt;- rho
corr_theo[2:p,1] &lt;- rho               

# Parameters for multiple testing procedure
stat_test &lt;- 'empirical'     # test statistics for correlation tests
method &lt;- 'BootRW'           # FWER controlling procedure
SD &lt;- FALSE                  # logical determining if stepdown is applied
alpha  &lt;- 0.05               # FWER threshold 
Nboot  &lt;- 100                # number of bootstrap or simulated samples

# Simulations and application of the chosen procedure
res &lt;- matrix(0,nrow=length(seqn),ncol=5)
for(i in 1:length(seqn)){
    temp &lt;- SimuFwer(corr_theo,n=seqn[i],Nsimu=Nsimu,alpha=alpha,stat_test=stat_test,
           method='BootRW',Nboot=Nboot,stepdown=SD,seed=seed)
    res[i,] &lt;- temp
}
rownames(res) &lt;- seqn
colnames(res) &lt;- names(temp)

# Display results
par(mfrow=c(1,2))
plot(seqn,res[,'fwer'],type='b',ylim=c(0,max(alpha*1.1,max(res[,'fwer']))),
    main='FWER',ylab='fwer',xlab='number of observations')
plot(seqn,res[,'sensitivity'],type='b',ylim=c(0,1.1),
    main='Power',ylab='sensitivity',xlab='number of observations')

</code></pre>

<hr>
<h2 id='ApplyFdrCor'>Applies multiple testing procedures built to control (asymptotically) the FDR for correlation testing.</h2><span id='topic+ApplyFdrCor'></span>

<h3>Description</h3>

<p>Applies multiple testing procedures built to control (asymptotically) the FDR for correlation testing.
Some have no theoretical proofs for tests on a correlation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ApplyFdrCor(
  data,
  alpha = 0.05,
  stat_test = "empirical",
  method = "LCTnorm",
  Nboot = 1000,
  vect = FALSE,
  arr.ind = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ApplyFdrCor_+3A_data">data</code></td>
<td>
<p>matrix of observations</p>
</td></tr>
<tr><td><code id="ApplyFdrCor_+3A_alpha">alpha</code></td>
<td>
<p>level of multiple testing</p>
</td></tr>
<tr><td><code id="ApplyFdrCor_+3A_stat_test">stat_test</code></td>
<td>

<dl>
<dt>'empirical'</dt><dd><p><code class="reqn">\sqrt{n}*abs(corr)</code></p>
</dd>
<dt>'fisher'</dt><dd><p><code class="reqn">\sqrt{n-3}*1/2*\log( (1+corr)/(1-corr) )</code></p>
</dd>
<dt>'student'</dt><dd><p><code class="reqn">\sqrt{n-2}*abs(corr)/\sqrt(1-corr^2)</code></p>
</dd>
<dt>'2nd.order'</dt><dd><p><code class="reqn">\sqrt{n}*mean(Y)/sd(Y)</code> with <code class="reqn">Y=(X_i-mean(X_i))(X_j-mean(X_j))</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="ApplyFdrCor_+3A_method">method</code></td>
<td>
<p>choice between 'LCTnorm' and 'LCTboot' developped by Cai &amp; Liu (2016), 
'BH', traditional Benjamini-Hochberg's procedure Benjamini &amp; Hochberg (1995)'s
and 'BHboot', Benjamini-Hochberg (1995)'s procedure with bootstrap evaluation of p-values</p>
</td></tr>
<tr><td><code id="ApplyFdrCor_+3A_nboot">Nboot</code></td>
<td>
<p>number of iterations for bootstrap p-values evaluation</p>
</td></tr>
<tr><td><code id="ApplyFdrCor_+3A_vect">vect</code></td>
<td>
<p>if TRUE returns a vector of TRUE/FALSE values, corresponding to <code>vectorize(cor(data))</code>;
if FALSE, returns an array containing rows and columns of significant correlations</p>
</td></tr>
<tr><td><code id="ApplyFdrCor_+3A_arr.ind">arr.ind</code></td>
<td>
<p>if TRUE, returns the indexes of the significant correlations, with repspect to level alpha</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns either </p>
<ul>
<li><p>logicals indicating if the corresponding correlation is significant, as a vector or a matrix depending on <code>vect</code>, </p>
</li>
<li><p>an array containing indexes <code class="reqn">\lbrace(i,j),\,i&lt;j\rbrace</code> for which correlation between variables <code class="reqn">i</code> and <code class="reqn">j</code> is significant, if <code>arr.ind=TRUE</code>.</p>
</li></ul>



<h3>References</h3>

<p>Benjamini, Y., &amp; Hochberg, Y. (1995). Controlling the false discovery rate: a practical and powerful approach to multiple testing. Journal of the royal statistical society. Series B (Methodological), 289-300.
</p>
<p>Cai, T. T., &amp; Liu, W. (2016). Large-scale multiple testing of correlations. Journal of the American Statistical Association, 111(513), 229-240.
</p>
<p>Roux, M. (2018). Graph inference by multiple testing with application to Neuroimaging, Ph.D., Université Grenoble Alpes, France, https://tel.archives-ouvertes.fr/tel-01971574v1.
</p>


<h3>See Also</h3>

<p>ApplyFwerCor
</p>
<p>LCTnorm, LCTboot, BHCor, BHBootCor
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
p &lt;- 10
corr_theo &lt;- diag(1,p)
corr_theo[1,3] &lt;- 0.5
corr_theo[3,1] &lt;- 0.5
data &lt;- MASS::mvrnorm(n,rep(0,p),corr_theo)
res &lt;- ApplyFdrCor(data,stat_test='empirical',method='LCTnorm')
# significant correlations, level alpha:
alpha &lt;- 0.05
whichCor(res&lt;alpha)
</code></pre>

<hr>
<h2 id='ApplyFwerCor'>Applies multiple testing procedures controlling (asymptotically) the FWER
for tests on a correlation matrix.</h2><span id='topic+ApplyFwerCor'></span>

<h3>Description</h3>

<p>Applies multiple testing procedures controlling (asymptotically) the FWER
for tests on a correlation matrix.
Methods are described in Chapter 5 of <cite>Roux (2018)</cite>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ApplyFwerCor(
  data,
  alpha = NULL,
  stat_test = "empirical",
  method = "Sidak",
  Nboot = 1000,
  stepdown = TRUE,
  vect = FALSE,
  logical = stepdown,
  arr.ind = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ApplyFwerCor_+3A_data">data</code></td>
<td>
<p>matrix of observations</p>
</td></tr>
<tr><td><code id="ApplyFwerCor_+3A_alpha">alpha</code></td>
<td>
<p>level of multiple testing (used if logical=TRUE)</p>
</td></tr>
<tr><td><code id="ApplyFwerCor_+3A_stat_test">stat_test</code></td>
<td>

<dl>
<dt>'empirical'</dt><dd><p><code class="reqn">\sqrt{n}*abs(corr)</code></p>
</dd>
<dt>'fisher'</dt><dd>   <p><code class="reqn">\sqrt{n-3}*1/2*\log( (1+corr)/(1-corr) )</code></p>
</dd>
<dt>'student'</dt><dd>  <p><code class="reqn">\sqrt{n-2}*abs(corr)/\sqrt(1-corr^2)</code></p>
</dd>
<dt>'2nd.order'</dt><dd> <p><code class="reqn">\sqrt{n}*mean(Y)/sd(Y)</code> with <code class="reqn">Y=(X_i-mean(X_i))(X_j-mean(X_j))</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="ApplyFwerCor_+3A_method">method</code></td>
<td>
<p>choice between 'Bonferroni', 'Sidak', 'BootRW', 'MaxTinfty'</p>
</td></tr>
<tr><td><code id="ApplyFwerCor_+3A_nboot">Nboot</code></td>
<td>
<p>number of iterations for Monte-Carlo of bootstrap quantile evaluation</p>
</td></tr>
<tr><td><code id="ApplyFwerCor_+3A_stepdown">stepdown</code></td>
<td>
<p>logical, if TRUE a stepdown procedure is applied</p>
</td></tr>
<tr><td><code id="ApplyFwerCor_+3A_vect">vect</code></td>
<td>
<p>if TRUE returns a vector of adjusted p-values, corresponding to <code>vectorize(cor(data))</code>;
if FALSE, returns an array containing the adjusted p-values for each entry of the correlation matrix</p>
</td></tr>
<tr><td><code id="ApplyFwerCor_+3A_logical">logical</code></td>
<td>
<p>if TRUE, returns either a vector or a matrix where each element is equal to TRUE if the corresponding null hypothesis is rejected, and to FALSE if it is not rejected
if <code>stepdown=TRUE</code> and <code>logical=FALSE</code>, returns a list of successive p-values.</p>
</td></tr>
<tr><td><code id="ApplyFwerCor_+3A_arr.ind">arr.ind</code></td>
<td>
<p>if TRUE, returns the indexes of the significant correlations, with repspect to level alpha</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns either </p>
<ul>
<li><p>the adjusted p-values, as a vector or a matrix, depending on <code>vect</code> </p>
</li>
<li><p>logicals indicating if the corresponding correlation is significant if <code>logical=TRUE</code>, as a vector or a matrix depending on <code>vect</code>, </p>
</li>
<li><p>an array containing indexes <code class="reqn">\lbrace(i,j),\,i&lt;j\rbrace</code> for which correlation between variables <code class="reqn">i</code> and <code class="reqn">j</code> is significant, if <code>arr.ind=TRUE</code>.</p>
</li></ul>



<h3>References</h3>

<p>Bonferroni, C. E. (1935). Il calcolo delle assicurazioni su gruppi di teste. Studi in onore del professore salvatore ortu carboni, 13-60.
</p>
<p>Drton, M., &amp; Perlman, M. D. (2007). Multiple testing and error control in Gaussian graphical model selection. Statistical Science, 22(3), 430-449.
</p>
<p>Romano, J. P., &amp; Wolf, M. (2005). Exact and approximate stepdown methods for multiple hypothesis testing. Journal of the American Statistical Association, 100(469), 94-108.
</p>
<p>Roux, M. (2018). Graph inference by multiple testing with application to Neuroimaging, Ph.D., Université Grenoble Alpes, France, https://tel.archives-ouvertes.fr/tel-01971574v1.
</p>
<p>Šidák, Z. (1967). Rectangular confidence regions for the means of multivariate normal distributions. Journal of the American Statistical Association, 62(318), 626-633.
</p>


<h3>See Also</h3>

<p>ApplyFwerCor_SD, ApplyFdrCor
</p>
<p>BonferroniCor, SidakCor, BootRWCor, maxTinftyCor
</p>
<p>BonferroniCor_SD, SidakCor_SD, BootRWCor_SD, maxTinftyCor_SD
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
p &lt;- 10
corr_theo &lt;- diag(1,p)
corr_theo[1,3] &lt;- 0.5
corr_theo[3,1] &lt;- 0.5
data &lt;- MASS::mvrnorm(n,rep(0,p),corr_theo)
# adjusted p-values
(res &lt;- ApplyFwerCor(data,stat_test='empirical',method='Bonferroni',stepdown=FALSE))
# significant correlations, level alpha:
alpha &lt;- 0.05
whichCor(res&lt;alpha)
</code></pre>

<hr>
<h2 id='ApplyFwerCor_oracle'>Applies an oracle version of MaxTinfty procedure described in Drton &amp; Perlman (2007) for correlation testing.</h2><span id='topic+ApplyFwerCor_oracle'></span>

<h3>Description</h3>

<p>Applies oracle MaxTinfty procedure described in Drton &amp; Perlman (2007) which controls asymptotically the FWER
for tests on a correlation matrix. It needs the true correlation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ApplyFwerCor_oracle(
  data,
  corr_theo,
  alpha = c(),
  stat_test = "empirical",
  method = "MaxTinfty",
  Nboot = 1000,
  stepdown = TRUE,
  vect = FALSE,
  logical = stepdown,
  arr.ind = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ApplyFwerCor_oracle_+3A_data">data</code></td>
<td>
<p>matrix of observations</p>
</td></tr>
<tr><td><code id="ApplyFwerCor_oracle_+3A_corr_theo">corr_theo</code></td>
<td>
<p>true matrix of correlations</p>
</td></tr>
<tr><td><code id="ApplyFwerCor_oracle_+3A_alpha">alpha</code></td>
<td>
<p>level of multiple testing (used if logical=TRUE)</p>
</td></tr>
<tr><td><code id="ApplyFwerCor_oracle_+3A_stat_test">stat_test</code></td>
<td>

<dl>
<dt>'empirical'</dt><dd><p><code class="reqn">\sqrt{n}*abs(corr)</code></p>
</dd>
<dt>'fisher'</dt><dd><p><code class="reqn">\sqrt{n-3}*1/2*\log( (1+corr)/(1-corr) )</code></p>
</dd>
<dt>'student'</dt><dd><p><code class="reqn">\sqrt{n-2}*abs(corr)/\sqrt(1-corr^2)</code></p>
</dd>
<dt>'2nd.order'</dt><dd><p><code class="reqn">\sqrt{n}*mean(Y)/sd(Y)</code> with <code class="reqn">Y=(X_i-mean(X_i))(X_j-mean(X_j))</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="ApplyFwerCor_oracle_+3A_method">method</code></td>
<td>
<p>only 'MaxTinfty' implemented</p>
</td></tr>
<tr><td><code id="ApplyFwerCor_oracle_+3A_nboot">Nboot</code></td>
<td>
<p>number of iterations for Monte-Carlo of bootstrap quantile evaluation</p>
</td></tr>
<tr><td><code id="ApplyFwerCor_oracle_+3A_stepdown">stepdown</code></td>
<td>
<p>logical, if TRUE a stepdown procedure is applied</p>
</td></tr>
<tr><td><code id="ApplyFwerCor_oracle_+3A_vect">vect</code></td>
<td>
<p>if TRUE returns a vector of adjusted p-values, corresponding to <code>vectorize(cor(data))</code>;
if FALSE, returns an array containing the adjusted p-values for each entry of the correlation matrix</p>
</td></tr>
<tr><td><code id="ApplyFwerCor_oracle_+3A_logical">logical</code></td>
<td>
<p>if TRUE, returns either a vector or a matrix where each element is equal to TRUE if the corresponding null hypothesis is rejected, and to FALSE if it is not rejected
if <code>stepdown=TRUE</code> and <code>logical=FALSE</code>, returns a list of successive p-values.</p>
</td></tr>
<tr><td><code id="ApplyFwerCor_oracle_+3A_arr.ind">arr.ind</code></td>
<td>
<p>if TRUE, returns the indexes of the significant correlations, with repspect to level alpha</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns either </p>
<ul>
<li><p>the adjusted p-values, as a vector or a matrix, depending on <code>vect</code> (unavailable with stepdown) </p>
</li>
<li><p>logicals indicating if the corresponding correlation is significant if <code>logical=TRUE</code>, as a vector or a matrix depending on <code>vect</code>, </p>
</li>
<li><p>an array containing indexes <code class="reqn">\lbrace(i,j),\,i&lt;j\rbrace</code> for which correlation between variables <code class="reqn">i</code> and <code class="reqn">j</code> is significant, if <code>arr.ind=TRUE</code>.</p>
</li></ul>

<p>Oracle estimation of the quantile is used, based on the true correlation matrix
</p>


<h3>References</h3>

<p>Drton, M., &amp; Perlman, M. D. (2007). Multiple testing and error control in Gaussian graphical model selection. Statistical Science, 22(3), 430-449.
</p>
<p>Roux, M. (2018). Graph inference by multiple testing with application to Neuroimaging, Ph.D., Université Grenoble Alpes, France, https://tel.archives-ouvertes.fr/tel-01971574v1.
</p>


<h3>See Also</h3>

<p>ApplyFwerCor
</p>
<p>maxTinftyCor, maxTinftyCor_SD
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
p &lt;- 10
corr_theo &lt;- diag(1,p)
corr_theo[1,3] &lt;- 0.5
corr_theo[3,1] &lt;- 0.5
data &lt;- MASS::mvrnorm(n,rep(0,p),corr_theo)
# adjusted p-values:
(res &lt;- ApplyFwerCor_oracle(data,corr_theo,stat_test='empirical',Nboot=1000,stepdown=FALSE))
# significant correlations, level alpha:
alpha &lt;- 0.05
whichCor(res&lt;alpha)
</code></pre>

<hr>
<h2 id='BHBootCor'>Benjamini &amp; Hochberg (1995)'s procedure for correlation testing with bootstrap evaluation of p-values.</h2><span id='topic+BHBootCor'></span>

<h3>Description</h3>

<p>Benjamini &amp; Hochberg (1995)'s procedure on the correlation matrix entries with bootstrap evaluation of p-values (no theoretical proof of control).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BHBootCor(
  data,
  alpha = 0.05,
  stat_test = "2nd.order",
  Nboot = 100,
  vect = FALSE,
  arr.ind = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BHBootCor_+3A_data">data</code></td>
<td>
<p>matrix of observations</p>
</td></tr>
<tr><td><code id="BHBootCor_+3A_alpha">alpha</code></td>
<td>
<p>level of multiple testing</p>
</td></tr>
<tr><td><code id="BHBootCor_+3A_stat_test">stat_test</code></td>
<td>

<dl>
<dt>'empirical'</dt><dd><p><code class="reqn">\sqrt{n}*abs(corr)</code></p>
</dd>
<dt>'fisher'</dt><dd>   <p><code class="reqn">\sqrt{n-3}*1/2*\log( (1+corr)/(1-corr) )</code></p>
</dd>
<dt>'student'</dt><dd>  <p><code class="reqn">\sqrt{n-2}*abs(corr)/\sqrt(1-corr^2)</code></p>
</dd>
<dt>'2nd.order'</dt><dd> <p><code class="reqn">\sqrt{n}*mean(Y)/sd(Y)</code> with <code class="reqn">Y=(X_i-mean(X_i))(X_j-mean(X_j))</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="BHBootCor_+3A_nboot">Nboot</code></td>
<td>
<p>number of iterations for bootstrap quantile evaluation</p>
</td></tr>
<tr><td><code id="BHBootCor_+3A_vect">vect</code></td>
<td>
<p>if TRUE returns a vector of TRUE/FALSE values, corresponding to <code>vectorize(cor(data))</code>;
if FALSE, returns an array containing TRUE/FALSE values for each entry of the correlation matrix</p>
</td></tr>
<tr><td><code id="BHBootCor_+3A_arr.ind">arr.ind</code></td>
<td>
<p>if TRUE, returns the indexes of the significant correlations, with respect to level alpha</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns </p>
<ul>
<li><p>a vector or a matrix of logicals, equal to TRUE if the corresponding element of the statistic vector is rejected, if <code>arr.ind=FALSE</code>, </p>
</li>
<li><p>an array containing indexes <code class="reqn">\lbrace(i,j),\,i&lt;j\rbrace</code> for which correlation between variables <code class="reqn">i</code> and <code class="reqn">j</code> is significant, if <code>arr.ind=TRUE</code>.</p>
</li></ul>



<h3>References</h3>

<p>Benjamini, Y., &amp; Hochberg, Y. (1995). Controlling the false discovery rate: a practical and powerful approach to multiple testing. Journal of the royal statistical society. Series B (Methodological), 289-300.
</p>


<h3>See Also</h3>

<p>ApplyFdrCor, BHCor
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
n &lt;- 100
p &lt;- 10
corr_theo &lt;- diag(1,p)
corr_theo[1,3] &lt;- 0.5
corr_theo[3,1] &lt;- 0.5
data &lt;- MASS::mvrnorm(n,rep(0,p),corr_theo)
alpha &lt;- 0.05
# significant correlations:
BHBootCor(data,alpha,stat_test='empirical',arr.ind=TRUE)
</code></pre>

<hr>
<h2 id='BHCor'>Benjamini &amp; Hochberg (1995)'s procedure for correlation testing.</h2><span id='topic+BHCor'></span>

<h3>Description</h3>

<p>Benjamini &amp; Hochberg (1995)'s procedure on the correlation matrix entries (no theoretical proof of control).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BHCor(
  data,
  alpha = 0.05,
  stat_test = "2nd.order",
  vect = FALSE,
  arr.ind = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BHCor_+3A_data">data</code></td>
<td>
<p>matrix of observations</p>
</td></tr>
<tr><td><code id="BHCor_+3A_alpha">alpha</code></td>
<td>
<p>level of multiple testing</p>
</td></tr>
<tr><td><code id="BHCor_+3A_stat_test">stat_test</code></td>
<td>

<dl>
<dt>'empirical'</dt><dd><p><code class="reqn">\sqrt{n}*abs(corr)</code></p>
</dd>
<dt>'fisher'</dt><dd>   <p><code class="reqn">\sqrt{n-3}*1/2*\log( (1+corr)/(1-corr) )</code></p>
</dd>
<dt>'student'</dt><dd>  <p><code class="reqn">\sqrt{n-2}*abs(corr)/\sqrt(1-corr^2)</code></p>
</dd>
<dt>'2nd.order'</dt><dd> <p><code class="reqn">\sqrt{n}*mean(Y)/sd(Y)</code> with <code class="reqn">Y=(X_i-mean(X_i))(X_j-mean(X_j))</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="BHCor_+3A_vect">vect</code></td>
<td>
<p>if TRUE returns a vector of TRUE/FALSE values, corresponding to vectorize(cor(data))
if FALSE, returns an array containing TRUE/FALSE values for each entry of the correlation matrix</p>
</td></tr>
<tr><td><code id="BHCor_+3A_arr.ind">arr.ind</code></td>
<td>
<p>if TRUE, returns the indexes of the significant correlations, with respect to level alpha</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns  </p>
<ul>
<li><p>logicals, equal to TRUE if the corresponding element of the statistic vector is rejected, as a vector or a matrix depending of the value of <code>vect</code>, </p>
</li>
<li><p>an array containing indexes <code class="reqn">\lbrace(i,j),\,i&lt;j\rbrace</code> for which correlation between variables <code class="reqn">i</code> and <code class="reqn">j</code> is significant, if <code>arr.ind=TRUE</code>.</p>
</li></ul>



<h3>References</h3>

<p>Benjamini, Y., &amp; Hochberg, Y. (1995). Controlling the false discovery rate: a practical and powerful approach to multiple testing. Journal of the royal statistical society. Series B (Methodological), 289-300.
</p>


<h3>See Also</h3>

<p>ApplyFdrCor, BHBootCor
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
n &lt;- 100
p &lt;- 10
corr_theo &lt;- diag(1,p)
corr_theo[1,3] &lt;- 0.5
corr_theo[3,1] &lt;- 0.5
data &lt;- MASS::mvrnorm(n,rep(0,p),corr_theo)
alpha &lt;- 0.05
# significant correlations:
BHCor(data,alpha,stat_test='empirical',arr.ind=TRUE)
</code></pre>

<hr>
<h2 id='BonferroniCor'>Bonferroni multiple testing procedure for correlations.</h2><span id='topic+BonferroniCor'></span>

<h3>Description</h3>

<p>Bonferroni multiple testing procedure for correlations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BonferroniCor(
  data,
  alpha = 0.05,
  stat_test = "empirical",
  vect = FALSE,
  logical = FALSE,
  arr.ind = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BonferroniCor_+3A_data">data</code></td>
<td>
<p>matrix of observations</p>
</td></tr>
<tr><td><code id="BonferroniCor_+3A_alpha">alpha</code></td>
<td>
<p>level of multiple testing (used if logical=TRUE)</p>
</td></tr>
<tr><td><code id="BonferroniCor_+3A_stat_test">stat_test</code></td>
<td>

<dl>
<dt>'empirical'</dt><dd><p><code class="reqn">\sqrt{n}*abs(corr)</code></p>
</dd>
<dt>'fisher'</dt><dd>   <p><code class="reqn">\sqrt{n-3}*1/2*\log( (1+corr)/(1-corr) )</code></p>
</dd>
<dt>'student'</dt><dd>  <p><code class="reqn">\sqrt{n-2}*abs(corr)/\sqrt(1-corr^2)</code></p>
</dd>
<dt>'2nd.order'</dt><dd> <p><code class="reqn">\sqrt{n}*mean(Y)/sd(Y)</code> with <code class="reqn">Y=(X_i-mean(X_i))(X_j-mean(X_j))</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="BonferroniCor_+3A_vect">vect</code></td>
<td>
<p>if TRUE returns a vector of adjusted p-values, corresponding to <code>vectorize(cor(data))</code>;
if FALSE, returns an array containing the adjusted p-values for each entry of the correlation matrix</p>
</td></tr>
<tr><td><code id="BonferroniCor_+3A_logical">logical</code></td>
<td>
<p>if TRUE, returns either a vector or a matrix where each element is equal to TRUE if the corresponding null hypothesis is rejected, and to FALSE if it is not rejected</p>
</td></tr>
<tr><td><code id="BonferroniCor_+3A_arr.ind">arr.ind</code></td>
<td>
<p>if TRUE, returns the indexes of the significant correlations, with respect to level alpha</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns  </p>
<ul>
<li><p>the adjusted p-values, as a vector or a matrix depending of the value of <code>vect</code>, </p>
</li>
<li><p>an array containing indexes <code class="reqn">\lbrace(i,j),\,i&lt;j\rbrace</code> for which correlation between variables <code class="reqn">i</code> and <code class="reqn">j</code> is significant, if <code>arr.ind=TRUE</code>.</p>
</li></ul>



<h3>References</h3>

<p>Bonferroni, C. E. (1935). Il calcolo delle assicurazioni su gruppi di teste. Studi in onore del professore salvatore ortu carboni, 13-60.
</p>
<p>Roux, M. (2018). Graph inference by multiple testing with application to Neuroimaging, Ph.D., Université Grenoble Alpes, France, https://tel.archives-ouvertes.fr/tel-01971574v1.
</p>


<h3>See Also</h3>

<p>ApplyFwerCor, BonferroniCor_SD
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
p &lt;- 10
corr_theo &lt;- diag(1,p)
corr_theo[1,3] &lt;- 0.5
corr_theo[3,1] &lt;- 0.5
corr_theo &lt;- diag(1,p)
data &lt;- MASS::mvrnorm(n,rep(0,p),corr_theo)
# adjusted p-values
res &lt;- BonferroniCor(data,stat_test='empirical')
round(res,2)
# significant correlations with level alpha:
alpha &lt;- 0.05
whichCor(res&lt;alpha)
# directly
BonferroniCor(data,alpha,stat_test='empirical',arr.ind=TRUE)
</code></pre>

<hr>
<h2 id='BonferroniCor_SD'>Bonferroni multiple testing method for correlations 
with stepdown procedure.</h2><span id='topic+BonferroniCor_SD'></span>

<h3>Description</h3>

<p>Bonferroni multiple testing method for correlations 
with stepdown procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BonferroniCor_SD(
  data,
  alpha = 0.05,
  stat_test = "empirical",
  vect = FALSE,
  logical = TRUE,
  arr.ind = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BonferroniCor_SD_+3A_data">data</code></td>
<td>
<p>matrix of observations</p>
</td></tr>
<tr><td><code id="BonferroniCor_SD_+3A_alpha">alpha</code></td>
<td>
<p>level of multiple testing</p>
</td></tr>
<tr><td><code id="BonferroniCor_SD_+3A_stat_test">stat_test</code></td>
<td>
<p>4 test statistics are available:
</p>

<dl>
<dt>'empirical'</dt><dd> <p><code class="reqn">\sqrt{n}*abs(corr)</code></p>
</dd>
<dt>'fisher'</dt><dd>   <p><code class="reqn">\sqrt{n-3}*1/2*\log( (1+corr)/(1-corr) )</code></p>
</dd>
<dt>'student'</dt><dd>  <p><code class="reqn">\sqrt{n-2}*abs(corr)/\sqrt(1-corr^2)</code></p>
</dd>
<dt>'2nd.order'</dt><dd> <p><code class="reqn">\sqrt{n}*mean(Y)/sd(Y)</code> with <code class="reqn">Y=(X_i-mean(X_i))(X_j-mean(X_j))</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="BonferroniCor_SD_+3A_vect">vect</code></td>
<td>
<p>if TRUE returns a vector of TRUE/FALSE values, corresponding to <code>vectorize(cor(data))</code>;
if FALSE, returns an array containing TRUE/FALSE values for each entry of the correlation matrix</p>
</td></tr>
<tr><td><code id="BonferroniCor_SD_+3A_logical">logical</code></td>
<td>
<p>if TRUE, returns either a vector or a matrix where each element is equal to TRUE if the corresponding null hypothesis is rejected, and to FALSE if it is not rejected
if FALSE, returns a list of successive p-values : element [[i+1]] of the list giving the p-values evaluated on the non-rejected hypothesis at step [[i]]; p-values are either as a vector or a list depending on <code>vect</code></p>
</td></tr>
<tr><td><code id="BonferroniCor_SD_+3A_arr.ind">arr.ind</code></td>
<td>
<p>if TRUE, returns the indexes of the significant correlations, with respect to level alpha</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns  </p>
<ul>
<li><p>logicals, equal to TRUE if the corresponding element of the statistic vector is rejected, as a vector or a matrix depending of the value of <code>vect</code>, </p>
</li>
<li><p>an array containing indexes <code class="reqn">\lbrace(i,j),\,i&lt;j\rbrace</code> for which correlation between variables <code class="reqn">i</code> and <code class="reqn">j</code> is significant, if <code>arr.ind=TRUE</code>.</p>
</li></ul>



<h3>References</h3>

<p>Bonferroni, C. E. (1935). Il calcolo delle assicurazioni su gruppi di teste. Studi in onore del professore salvatore ortu carboni, 13-60.
</p>
<p>Roux, M. (2018). Graph inference by multiple testing with application to Neuroimaging, Ph.D., Université Grenoble Alpes, France, https://tel.archives-ouvertes.fr/tel-01971574v1.
</p>


<h3>See Also</h3>

<p>ApplyFwerCor, BonferroniCor
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
n &lt;- 100
p &lt;- 10
corr_theo &lt;- diag(1,p)
corr_theo[1,3] &lt;- 0.5
corr_theo[3,1] &lt;- 0.5
data &lt;- MASS::mvrnorm(n,rep(0,p),corr_theo)
alpha &lt;- 0.05
# significant correlations:
BonferroniCor_SD(data,alpha,stat_test='empirical', arr.ind=TRUE)
# successive p-values
res &lt;- BonferroniCor_SD(data,stat_test='empirical', logical=FALSE)
lapply(res,FUN=function(x){round(x,2)})
# succesive rejections
lapply(res,FUN=function(x){whichCor(x&lt;alpha)})  
</code></pre>

<hr>
<h2 id='BootRWCor'>Bootstrap multiple testing method of Romano &amp; Wolf (2005) for correlations.</h2><span id='topic+BootRWCor'></span>

<h3>Description</h3>

<p>Multiple testing method based on the evaluation of quantile by bootstrap 
in the initial dataset (Romano &amp; Wolf (2005)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BootRWCor(
  data,
  alpha = 0.05,
  stat_test = "empirical",
  Nboot = 1000,
  vect = FALSE,
  logical = FALSE,
  arr.ind = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BootRWCor_+3A_data">data</code></td>
<td>
<p>matrix of observations</p>
</td></tr>
<tr><td><code id="BootRWCor_+3A_alpha">alpha</code></td>
<td>
<p>level of multiple testing (used if logical=TRUE)</p>
</td></tr>
<tr><td><code id="BootRWCor_+3A_stat_test">stat_test</code></td>
<td>

<dl>
<dt>'empirical'</dt><dd><p><code class="reqn">\sqrt{n}*abs(corr)</code></p>
</dd>
<dt>'fisher'</dt><dd>   <p><code class="reqn">\sqrt{n-3}*1/2*\log( (1+corr)/(1-corr) )</code></p>
</dd>
<dt>'student'</dt><dd>  <p><code class="reqn">\sqrt{n-2}*abs(corr)/\sqrt(1-corr^2)</code></p>
</dd>
<dt>'2nd.order'</dt><dd> <p><code class="reqn">\sqrt{n}*mean(Y)/sd(Y)</code> with <code class="reqn">Y=(X_i-mean(X_i))(X_j-mean(X_j))</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="BootRWCor_+3A_nboot">Nboot</code></td>
<td>
<p>number of iterations for Monte-Carlo quantile evaluation</p>
</td></tr>
<tr><td><code id="BootRWCor_+3A_vect">vect</code></td>
<td>
<p>if TRUE returns a vector of adjusted p-values, corresponding to <code>vectorize(cor(data))</code>;
if FALSE, returns an array containing the adjusted p-values for each entry of the correlation matrix</p>
</td></tr>
<tr><td><code id="BootRWCor_+3A_logical">logical</code></td>
<td>
<p>if TRUE, returns either a vector or a matrix where each element is equal to TRUE if the corresponding null hypothesis is rejected, and to FALSE if it is not rejected</p>
</td></tr>
<tr><td><code id="BootRWCor_+3A_arr.ind">arr.ind</code></td>
<td>
<p>if TRUE, returns the indexes of the significant correlations, with respect to level alpha</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns  </p>
<ul>
<li><p>the adjusted p-values, as a vector or a matrix depending of the value of <code>vect</code>, </p>
</li>
<li><p>an array containing indexes <code class="reqn">\lbrace(i,j),\,i&lt;j\rbrace</code> for which correlation between variables <code class="reqn">i</code> and <code class="reqn">j</code> is significant, if <code>arr.ind=TRUE</code>.</p>
</li></ul>



<h3>References</h3>

<p>Romano, J. P., &amp; Wolf, M. (2005). Exact and approximate stepdown methods for multiple hypothesis testing. Journal of the American Statistical Association, 100(469), 94-108.
</p>
<p>Roux, M. (2018). Graph inference by multiple testing with application to Neuroimaging, Ph.D., Université Grenoble Alpes, France, https://tel.archives-ouvertes.fr/tel-01971574v1.
</p>


<h3>See Also</h3>

<p>ApplyFwerCor, BootRWCor_SD
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
n &lt;- 100
p &lt;- 10
corr_theo &lt;- diag(1,p)
corr_theo[1,3] &lt;- 0.5
corr_theo[3,1] &lt;- 0.5
data &lt;- MASS::mvrnorm(n,rep(0,p),corr_theo)
# adjusted p-values
res &lt;- BootRWCor(data,stat_test='empirical',Nboot=1000)
round(res,2)
# significant correlations with level alpha:
alpha &lt;- 0.05
whichCor(res&lt;alpha)
# directly
BootRWCor(data,alpha,stat_test='empirical',Nboot=1000,arr.ind=TRUE)
</code></pre>

<hr>
<h2 id='BootRWCor_SD'>Boootstrap multiple testing method of Romano &amp; Wolf (2005) for correlations, with stepdown procedure.</h2><span id='topic+BootRWCor_SD'></span>

<h3>Description</h3>

<p>Multiple testing method based on the evaluation of quantile by bootstrap 
in the initial dataset (Romano &amp; Wolf (2005)),
with stepdown procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BootRWCor_SD(
  data,
  alpha = 0.05,
  stat_test = "empirical",
  Nboot = 1000,
  vect = FALSE,
  logical = TRUE,
  arr.ind = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BootRWCor_SD_+3A_data">data</code></td>
<td>
<p>matrix of observations</p>
</td></tr>
<tr><td><code id="BootRWCor_SD_+3A_alpha">alpha</code></td>
<td>
<p>level of multiple testing</p>
</td></tr>
<tr><td><code id="BootRWCor_SD_+3A_stat_test">stat_test</code></td>
<td>
<p>4 test statistics are available:
</p>

<dl>
<dt>'empirical'</dt><dd><p><code class="reqn">\sqrt{n}*abs(corr)</code></p>
</dd>
<dt>'fisher'</dt><dd>   <p><code class="reqn">\sqrt{n-3}*1/2*\log( (1+corr)/(1-corr) )</code></p>
</dd>
<dt>'student'</dt><dd>  <p><code class="reqn">\sqrt{n-2}*abs(corr)/\sqrt(1-corr^2)</code></p>
</dd>
<dt>'2nd.order'</dt><dd> <p><code class="reqn">\sqrt{n}*mean(Y)/sd(Y)</code> with <code class="reqn">Y=(X_i-mean(X_i))(X_j-mean(X_j))</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="BootRWCor_SD_+3A_nboot">Nboot</code></td>
<td>
<p>number of iterations for Bootstrap quantile evaluation</p>
</td></tr>
<tr><td><code id="BootRWCor_SD_+3A_vect">vect</code></td>
<td>
<p>if TRUE returns a vector of TRUE/FALSE values, corresponding to <code>vectorize(cor(data))</code>;
if FALSE, returns an array containing TRUE/FALSE values for each entry of the correlation matrix</p>
</td></tr>
<tr><td><code id="BootRWCor_SD_+3A_logical">logical</code></td>
<td>
<p>if TRUE, returns either a vector or a matrix where each element is equal to TRUE if the corresponding null hypothesis is rejected, and to FALSE if it is not rejected
if FALSE, returns a list of successive p-values : element [[i+1]] of the list giving the p-values evaluated on the non-rejected hypothesis at step [[i]]; p-values are either as a vector or a list depending on <code>vect</code></p>
</td></tr>
<tr><td><code id="BootRWCor_SD_+3A_arr.ind">arr.ind</code></td>
<td>
<p>if TRUE, returns the indexes of the significant correlations, with respect to level alpha</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns  </p>
<ul>
<li><p>logicals, equal to TRUE if the corresponding element of the statistic vector is rejected, as a vector or a matrix depending of the value of <code>vect</code>, </p>
</li>
<li><p>an array containing indexes <code class="reqn">\lbrace(i,j),\,i&lt;j\rbrace</code> for which correlation between variables <code class="reqn">i</code> and <code class="reqn">j</code> is significant, if <code>arr.ind=TRUE</code>.</p>
</li></ul>



<h3>References</h3>

<p>Romano, J. P., &amp; Wolf, M. (2005). Exact and approximate stepdown methods for multiple hypothesis testing. Journal of the American Statistical Association, 100(469), 94-108.
</p>
<p>Roux, M. (2018). Graph inference by multiple testing with application to Neuroimaging, Ph.D., Université Grenoble Alpes, France, https://tel.archives-ouvertes.fr/tel-01971574v1.
</p>


<h3>See Also</h3>

<p>ApplyFwerCor, BootRWCor
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
n &lt;- 100
p &lt;- 10
corr_theo &lt;- diag(1,p)
corr_theo[1,3] &lt;- 0.5
corr_theo[3,1] &lt;- 0.5
data &lt;- MASS::mvrnorm(n,rep(0,p),corr_theo)
alpha &lt;- 0.05
# significant correlations:
BootRWCor_SD(data,alpha,stat_test='empirical', arr.ind=TRUE)
# successive p-values
res &lt;- BootRWCor_SD(data,stat_test='empirical', logical=FALSE)
lapply(res,FUN=function(x){round(x,2)})
# succesive rejections
lapply(res,FUN=function(x){whichCor(x&lt;alpha)})  
</code></pre>

<hr>
<h2 id='covD2nd'>Returns the theoretical covariance of empirical correlations.</h2><span id='topic+covD2nd'></span>

<h3>Description</h3>

<p>Returns the theoretical covariance of empirical correlations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covD2nd(r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covD2nd_+3A_r">r</code></td>
<td>
<p>a correlation matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the theoretical covariance of 2nd order statistics, 
<code class="reqn">\sqrt{n}*mean(Y)/sd(Y)</code> with <code class="reqn">Y=(X_i-mean(X_i))(X_j-mean(X_j))</code>.
</p>


<h3>See Also</h3>

<p>covDcor
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 10
corr_theo &lt;- diag(1,p)
corr_theo[2:p,] &lt;- 0.3
corr_theo[,2:p] &lt;- 0.3
covD2nd(corr_theo)
</code></pre>

<hr>
<h2 id='covDcor'>Returns the theoretical covariance of empirical correlations.</h2><span id='topic+covDcor'></span>

<h3>Description</h3>

<p>Returns the theoretical covariance of empirical correlations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covDcor(r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covDcor_+3A_r">r</code></td>
<td>
<p>a correlation matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the theoretical covariance of empirical correlations.
</p>


<h3>References</h3>

<p>Aitkin, M. A. (1969). Some tests for correlation matrices. Biometrika, 443-446.
</p>


<h3>See Also</h3>

<p>covDcorNorm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 10
corr_theo &lt;- diag(1,p)
corr_theo[2:p,] &lt;- 0.3
corr_theo[,2:p] &lt;- 0.3
covDcor(corr_theo)
</code></pre>

<hr>
<h2 id='covDcorNorm'>Returns the theoretical covariance of test statistics for correlation testing.</h2><span id='topic+covDcorNorm'></span>

<h3>Description</h3>

<p>Returns the theoretical covariance of test statistics for correlation testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covDcorNorm(cor_mat, stat_test = "empirical")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covDcorNorm_+3A_cor_mat">cor_mat</code></td>
<td>
<p>A correlation matrix</p>
</td></tr>
<tr><td><code id="covDcorNorm_+3A_stat_test">stat_test</code></td>
<td>

<dl>
<dt>'empirical'</dt><dd><p><code class="reqn">\sqrt{n}*abs(corr)</code></p>
</dd>
<dt>'fisher'</dt><dd><p><code class="reqn">\sqrt{n-3}*1/2*\log( (1+corr)/(1-corr) )</code></p>
</dd>
<dt>'student'</dt><dd><p><code class="reqn">\sqrt{n-2}*abs(corr)/\sqrt(1-corr^2)</code></p>
</dd>
<dt>'2nd.order'</dt><dd><p><code class="reqn">\sqrt{n}*mean(Y)/sd(Y)</code> with <code class="reqn">Y=(X_i-mean(X_i))(X_j-mean(X_j))</code></p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the theoretical covariance of the test statistics.
</p>


<h3>See Also</h3>

<p>covDcor, covD2nd, eval_stat
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 10
corr_theo &lt;- diag(1,p)
corr_theo[2:p,] &lt;- 0.3
corr_theo[,2:p] &lt;- 0.3
covDcorNorm(corr_theo,stat_test='student')
</code></pre>

<hr>
<h2 id='eval_stat'>Evaluates the test statistics for tests on correlation matrix entries.</h2><span id='topic+eval_stat'></span>

<h3>Description</h3>

<p>Evaluates the test statistics for tests on correlation matrix entries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_stat(data, type = "empirical")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eval_stat_+3A_data">data</code></td>
<td>
<p>matrix of observations</p>
</td></tr>
<tr><td><code id="eval_stat_+3A_type">type</code></td>
<td>

<dl>
<dt>'empirical'</dt><dd><p><code class="reqn">\sqrt{n}*abs(corr)</code></p>
</dd>
<dt>'fisher'</dt><dd><p><code class="reqn">\sqrt{n-3}*1/2*\log( (1+corr)/(1-corr) )</code></p>
</dd>
<dt>'student'</dt><dd><p><code class="reqn">\sqrt{n-2}*abs(corr)/\sqrt(1-corr^2)</code></p>
</dd>
<dt>'2nd.order'</dt><dd><p><code class="reqn">\sqrt{n}*mean(Y)/sd(Y)</code> with <code class="reqn">Y=(X_i-mean(X_i))(X_j-mean(X_j))</code></p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the test statistics for correlation testing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
p &lt;- 10
corr_theo &lt;- diag(1,p)
data &lt;- MASS::mvrnorm(n,rep(0,p),corr_theo)
stat &lt;- eval_stat(data,'fisher')
</code></pre>

<hr>
<h2 id='LCTboot'>Bootstrap procedure LCT-B proposed by Cai &amp; Liu (2016) for correlation testing.</h2><span id='topic+LCTboot'></span>

<h3>Description</h3>

<p>Bootstrap procedure LCT-B proposed by Cai &amp; Liu (2016) for correlation testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LCTboot(
  data,
  alpha = 0.05,
  stat_test = "2nd.order",
  Nboot = 100,
  vect = FALSE,
  arr.ind = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LCTboot_+3A_data">data</code></td>
<td>
<p>matrix of observations</p>
</td></tr>
<tr><td><code id="LCTboot_+3A_alpha">alpha</code></td>
<td>
<p>level of multiple testing</p>
</td></tr>
<tr><td><code id="LCTboot_+3A_stat_test">stat_test</code></td>
<td>

<dl>
<dt>'empirical'</dt><dd><p><code class="reqn">\sqrt{n}*abs(corr)</code></p>
</dd>
<dt>'fisher'</dt><dd><p><code class="reqn">\sqrt{n-3}*1/2*\log( (1+corr)/(1-corr) )</code></p>
</dd>
<dt>'student'</dt><dd><p><code class="reqn">\sqrt{n-2}*abs(corr)/\sqrt(1-corr^2)</code></p>
</dd>
<dt>'2nd.order'</dt><dd><p><code class="reqn">\sqrt{n}*mean(Y)/sd(Y)</code> with <code class="reqn">Y=(X_i-mean(X_i))(X_j-mean(X_j))</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="LCTboot_+3A_nboot">Nboot</code></td>
<td>
<p>number of iterations for bootstrap quantile evaluation</p>
</td></tr>
<tr><td><code id="LCTboot_+3A_vect">vect</code></td>
<td>
<p>if TRUE returns a vector of TRUE/FALSE values, corresponding to <code>vectorize(cor(data))</code>;
if FALSE, returns an array containing TRUE/FALSE values for each entry of the correlation matrix</p>
</td></tr>
<tr><td><code id="LCTboot_+3A_arr.ind">arr.ind</code></td>
<td>
<p>if TRUE, returns the indexes of the significant correlations, with respect to level alpha</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns  </p>
<ul>
<li><p>logicals, equal to TRUE if the corresponding element of the statistic vector is rejected, as a vector or a matrix depending of the value of <code>vect</code>, </p>
</li>
<li><p>an array containing indexes <code class="reqn">\lbrace(i,j),\,i&lt;j\rbrace</code> for which correlation between variables <code class="reqn">i</code> and <code class="reqn">j</code> is significant, if <code>arr.ind=TRUE</code>.</p>
</li></ul>



<h3>References</h3>

<p>Cai, T. T., &amp; Liu, W. (2016). Large-scale multiple testing of correlations. Journal of the American Statistical Association, 111(513), 229-240.
</p>


<h3>See Also</h3>

<p>ApplyFdrCor, LCTNorm
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
n &lt;- 100
p &lt;- 10
corr_theo &lt;- diag(1,p)
corr_theo[1,3] &lt;- 0.5
corr_theo[3,1] &lt;- 0.5
data &lt;- MASS::mvrnorm(n,rep(0,p),corr_theo)
alpha &lt;- 0.05
# significant correlations:
LCTboot(data,alpha,stat_test='empirical',Nboot=100,arr.ind=TRUE)
</code></pre>

<hr>
<h2 id='LCTnorm'>Procedure LCT-N proposed by Cai &amp; Liu (2016) for correlation testing.</h2><span id='topic+LCTnorm'></span>

<h3>Description</h3>

<p>Procedure LCT-N proposed by Cai &amp; Liu (2016) for correlation testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LCTnorm(
  data,
  alpha = 0.05,
  stat_test = "2nd.order",
  vect = FALSE,
  arr.ind = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LCTnorm_+3A_data">data</code></td>
<td>
<p>matrix of observations</p>
</td></tr>
<tr><td><code id="LCTnorm_+3A_alpha">alpha</code></td>
<td>
<p>level of multiple testing</p>
</td></tr>
<tr><td><code id="LCTnorm_+3A_stat_test">stat_test</code></td>
<td>

<dl>
<dt>'empirical'</dt><dd><p><code class="reqn">\sqrt{n}*abs(corr)</code></p>
</dd>
<dt>'fisher'</dt><dd>   <p><code class="reqn">\sqrt{n-3}*1/2*\log( (1+corr)/(1-corr) )</code></p>
</dd>
<dt>'student'</dt><dd>  <p><code class="reqn">\sqrt{n-2}*abs(corr)/\sqrt(1-corr^2)</code></p>
</dd>
<dt>'2nd.order'</dt><dd> <p><code class="reqn">\sqrt{n}*mean(Y)/sd(Y)</code> with <code class="reqn">Y=(X_i-mean(X_i))(X_j-mean(X_j))</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="LCTnorm_+3A_vect">vect</code></td>
<td>
<p>if TRUE returns a vector of TRUE/FALSE values, corresponding to <code>vectorize(cor(data))</code>;
if FALSE, returns an array containing TRUE/FALSE values for each entry of the correlation matrix</p>
</td></tr>
<tr><td><code id="LCTnorm_+3A_arr.ind">arr.ind</code></td>
<td>
<p>if TRUE, returns the indexes of the significant correlations, with respect to level alpha</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns  </p>
<ul>
<li><p>logicals, equal to TRUE if the corresponding element of the statistic vector is rejected, as a vector or a matrix depending of the value of <code>vect</code>, </p>
</li>
<li><p>an array containing indexes <code class="reqn">\lbrace(i,j),\,i&lt;j\rbrace</code> for which correlation between variables <code class="reqn">i</code> and <code class="reqn">j</code> is significant, if <code>arr.ind=TRUE</code>.</p>
</li></ul>



<h3>References</h3>

<p>Cai, T. T., &amp; Liu, W. (2016). Large-scale multiple testing of correlations. Journal of the American Statistical Association, 111(513), 229-240.
</p>


<h3>See Also</h3>

<p>ApplyFdrCor, LCTboot
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
n &lt;- 100
p &lt;- 10
corr_theo &lt;- diag(1,p)
corr_theo[1,3] &lt;- 0.5
corr_theo[3,1] &lt;- 0.5
data &lt;- MASS::mvrnorm(n,rep(0,p),corr_theo)
alpha &lt;- 0.05
# significant correlations:
LCTnorm(data,alpha,stat_test='empirical',arr.ind=TRUE)
</code></pre>

<hr>
<h2 id='maxTinftyCor'>Multiple testing method of Drton &amp; Perlman (2007) for correlations.</h2><span id='topic+maxTinftyCor'></span>

<h3>Description</h3>

<p>Multiple testing method based on the evaluation of quantile by simulation of observations 
from the asymptotic distribution (Drton &amp; Perlman (2007)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxTinftyCor(
  data,
  alpha = 0.05,
  stat_test = "empirical",
  Nboot = 1000,
  OmegaChap = covDcorNorm(cor(data), stat_test),
  vect = FALSE,
  logical = FALSE,
  arr.ind = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maxTinftyCor_+3A_data">data</code></td>
<td>
<p>matrix of observations</p>
</td></tr>
<tr><td><code id="maxTinftyCor_+3A_alpha">alpha</code></td>
<td>
<p>level of multiple testing (used if logical=TRUE)</p>
</td></tr>
<tr><td><code id="maxTinftyCor_+3A_stat_test">stat_test</code></td>
<td>

<dl>
<dt>'empirical'</dt><dd><p><code class="reqn">\sqrt{n}*abs(corr)</code></p>
</dd>
<dt>'fisher'</dt><dd>   <p><code class="reqn">\sqrt{n-3}*1/2*\log( (1+corr)/(1-corr) )</code></p>
</dd>
<dt>'student'</dt><dd>  <p><code class="reqn">\sqrt{n-2}*abs(corr)/\sqrt(1-corr^2)</code></p>
</dd>
<dt>'2nd.order'</dt><dd> <p><code class="reqn">\sqrt{n}*mean(Y)/sd(Y)</code> with <code class="reqn">Y=(X_i-mean(X_i))(X_j-mean(X_j))</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="maxTinftyCor_+3A_nboot">Nboot</code></td>
<td>
<p>number of iterations for Monte-Carlo quantile evaluation</p>
</td></tr>
<tr><td><code id="maxTinftyCor_+3A_omegachap">OmegaChap</code></td>
<td>
<p>matrix of covariance of empirical correlations used for quantile evaluation;
optional, useful for oracle estimation and step-down</p>
</td></tr>
<tr><td><code id="maxTinftyCor_+3A_vect">vect</code></td>
<td>
<p>if TRUE returns a vector of adjusted p-values, corresponding to <code>vectorize(cor(data))</code>;
if FALSE, returns an array containing the adjusted p-values for each entry of the correlation matrix</p>
</td></tr>
<tr><td><code id="maxTinftyCor_+3A_logical">logical</code></td>
<td>
<p>if TRUE, returns either a vector or a matrix where each element is equal to TRUE if the corresponding null hypothesis is rejected, and to FALSE if it is not rejected</p>
</td></tr>
<tr><td><code id="maxTinftyCor_+3A_arr.ind">arr.ind</code></td>
<td>
<p>if TRUE, returns the indexes of the significant correlations, with respect to level alpha</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns  </p>
<ul>
<li><p>the adjusted p-values, as a vector or a matrix depending of the value of <code>vect</code>, </p>
</li>
<li><p>an array containing indexes <code class="reqn">\lbrace(i,j),\,i&lt;j\rbrace</code> for which correlation between variables <code class="reqn">i</code> and <code class="reqn">j</code> is significant, if <code>arr.ind=TRUE</code>.</p>
</li></ul>



<h3>References</h3>

<p>Drton, M., &amp; Perlman, M. D. (2007). Multiple testing and error control in Gaussian graphical model selection. Statistical Science, 22(3), 430-449.
</p>
<p>Roux, M. (2018). Graph inference by multiple testing with application to Neuroimaging, Ph.D., Université Grenoble Alpes, France, https://tel.archives-ouvertes.fr/tel-01971574v1.
</p>


<h3>See Also</h3>

<p>ApplyFwerCor, maxTinftyCor_SD
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
n &lt;- 100
p &lt;- 10
corr_theo &lt;- diag(1,p)
corr_theo[1,3] &lt;- 0.5
corr_theo[3,1] &lt;- 0.5
data &lt;- MASS::mvrnorm(n,rep(0,p),corr_theo)
# adjusted p-values
res &lt;- maxTinftyCor(data,stat_test='empirical',Nboot=1000)
round(res,2)
# significant correlations with level alpha:
alpha &lt;- 0.05
whichCor(res&lt;alpha)
# directly
res &lt;- maxTinftyCor(data,alpha,stat_test='empirical',Nboot=1000,arr.ind=TRUE)
</code></pre>

<hr>
<h2 id='maxTinftyCor_SD'>Multiple testing method of Drton &amp; Perlman (2007) for correlations, with stepdown procedure.</h2><span id='topic+maxTinftyCor_SD'></span>

<h3>Description</h3>

<p>Multiple testing method based on the evaluation of quantile by simulation of observations 
from the asymptotic distribution (Drton &amp; Perlman (2007)), 
with stepdown procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxTinftyCor_SD(
  data,
  alpha = 0.05,
  stat_test = "empirical",
  Nboot = 1000,
  OmegaChap = covDcorNorm(cor(data), stat_test),
  vect = FALSE,
  logical = TRUE,
  arr.ind = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maxTinftyCor_SD_+3A_data">data</code></td>
<td>
<p>matrix of observations</p>
</td></tr>
<tr><td><code id="maxTinftyCor_SD_+3A_alpha">alpha</code></td>
<td>
<p>level of multiple testing</p>
</td></tr>
<tr><td><code id="maxTinftyCor_SD_+3A_stat_test">stat_test</code></td>
<td>
<p>4 test statistics are available:
</p>

<dl>
<dt>'empirical'</dt><dd> <p><code class="reqn">\sqrt{n}*abs(corr)</code></p>
</dd>
<dt>'fisher'</dt><dd>   <p><code class="reqn">\sqrt{n-3}*1/2*\log( (1+corr)/(1-corr) )</code></p>
</dd>
<dt>'student'</dt><dd>  <p><code class="reqn">\sqrt{n-2}*abs(corr)/\sqrt(1-corr^2)</code></p>
</dd>
<dt>'2nd.order'</dt><dd> <p><code class="reqn">\sqrt{n}*mean(Y)/sd(Y)</code> with <code class="reqn">Y=(X_i-mean(X_i))(X_j-mean(X_j))</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="maxTinftyCor_SD_+3A_nboot">Nboot</code></td>
<td>
<p>number of iterations for Monte-Carlo quantile evaluation</p>
</td></tr>
<tr><td><code id="maxTinftyCor_SD_+3A_omegachap">OmegaChap</code></td>
<td>
<p>matrix of covariance of test statistics;
optional, useful for oracle estimation and step-down</p>
</td></tr>
<tr><td><code id="maxTinftyCor_SD_+3A_vect">vect</code></td>
<td>
<p>if TRUE returns a vector of TRUE/FALSE values, corresponding to <code>vectorize(cor(data))</code>;
if FALSE, returns an array containing TRUE/FALSE values for each entry of the correlation matrix</p>
</td></tr>
<tr><td><code id="maxTinftyCor_SD_+3A_logical">logical</code></td>
<td>
<p>if TRUE, returns either a vector or a matrix where each element is equal to TRUE if the corresponding null hypothesis is rejected, and to FALSE if it is not rejected
if FALSE, returns a list of successive p-values : element [[i+1]] of the list giving the p-values evaluated on the non-rejected hypothesis at step [[i]]; p-values are either as a vector or a list depending on <code>vect</code></p>
</td></tr>
<tr><td><code id="maxTinftyCor_SD_+3A_arr.ind">arr.ind</code></td>
<td>
<p>if TRUE, returns the indexes of the significant correlations, with respect to level alpha</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns  </p>
<ul>
<li><p>logicals, equal to TRUE if the corresponding element of the statistic vector is rejected, as a vector or a matrix depending of the value of <code>vect</code>, </p>
</li>
<li><p>an array containing indexes <code class="reqn">\lbrace(i,j),\,i&lt;j\rbrace</code> for which correlation between variables <code class="reqn">i</code> and <code class="reqn">j</code> is significant, if <code>arr.ind=TRUE</code>.</p>
</li></ul>



<h3>References</h3>

<p>Drton, M., &amp; Perlman, M. D. (2007). Multiple testing and error control in Gaussian graphical model selection. Statistical Science, 22(3), 430-449.
</p>
<p>Roux, M. (2018). Graph inference by multiple testing with application to Neuroimaging, Ph.D., Université Grenoble Alpes, France, https://tel.archives-ouvertes.fr/tel-01971574v1.
</p>


<h3>See Also</h3>

<p>ApplyFwerCor, maxTinftyCor
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
n &lt;- 100
p &lt;- 10
corr_theo &lt;- diag(1,p)
corr_theo[1,3] &lt;- 0.5
corr_theo[3,1] &lt;- 0.5
data &lt;- MASS::mvrnorm(n,rep(0,p),corr_theo)
alpha &lt;- 0.05
# significant correlations:
maxTinftyCor_SD(data,alpha,stat_test='empirical', arr.ind=TRUE)
# successive p-values
res &lt;- maxTinftyCor_SD(data,stat_test='empirical', logical=FALSE)
lapply(res,FUN=function(x){round(x,2)})
# succesive rejections
lapply(res,FUN=function(x){whichCor(x&lt;alpha)})  
</code></pre>

<hr>
<h2 id='SidakCor'>Sidak multiple testing procedure for correlations.</h2><span id='topic+SidakCor'></span>

<h3>Description</h3>

<p>Sidak multiple testing procedure for correlations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SidakCor(
  data,
  alpha = 0.05,
  stat_test = "empirical",
  vect = FALSE,
  logical = FALSE,
  arr.ind = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SidakCor_+3A_data">data</code></td>
<td>
<p>matrix of observations</p>
</td></tr>
<tr><td><code id="SidakCor_+3A_alpha">alpha</code></td>
<td>
<p>level of multiple testing (used if logical=TRUE)</p>
</td></tr>
<tr><td><code id="SidakCor_+3A_stat_test">stat_test</code></td>
<td>

<dl>
<dt>'empirical'</dt><dd><p><code class="reqn">\sqrt{n}*abs(corr)</code></p>
</dd>
<dt>'fisher'</dt><dd>   <p><code class="reqn">\sqrt{n-3}*1/2*\log( (1+corr)/(1-corr) )</code></p>
</dd>
<dt>'student'</dt><dd>  <p><code class="reqn">\sqrt{n-2}*abs(corr)/\sqrt(1-corr^2)</code></p>
</dd>
<dt>'2nd.order'</dt><dd> <p><code class="reqn">\sqrt{n}*mean(Y)/sd(Y)</code> with <code class="reqn">Y=(X_i-mean(X_i))(X_j-mean(X_j))</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="SidakCor_+3A_vect">vect</code></td>
<td>
<p>if TRUE returns a vector of adjusted p-values, corresponding to <code>vectorize(cor(data))</code>;
if FALSE, returns an array containing the adjusted p-values for each entry of the correlation matrix</p>
</td></tr>
<tr><td><code id="SidakCor_+3A_logical">logical</code></td>
<td>
<p>if TRUE, returns either a vector or a matrix where each element is equal to TRUE if the corresponding null hypothesis is rejected, and to FALSE if it is not rejected</p>
</td></tr>
<tr><td><code id="SidakCor_+3A_arr.ind">arr.ind</code></td>
<td>
<p>if TRUE, returns the indexes of the significant correlations, with respect to level alpha</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns  </p>
<ul>
<li><p>the adjusted p-values, as a vector or a matrix depending of the value of <code>vect</code>, </p>
</li>
<li><p>an array containing indexes <code class="reqn">\lbrace(i,j),\,i&lt;j\rbrace</code> for which correlation between variables <code class="reqn">i</code> and <code class="reqn">j</code> is significant, if <code>arr.ind=TRUE</code>.</p>
</li></ul>



<h3>References</h3>

<p>Roux, M. (2018). Graph inference by multiple testing with application to Neuroimaging, Ph.D., Université Grenoble Alpes, France, https://tel.archives-ouvertes.fr/tel-01971574v1.
</p>
<p>Šidák, Z. (1967). Rectangular confidence regions for the means of multivariate normal distributions. Journal of the American Statistical Association, 62(318), 626-633.
</p>


<h3>See Also</h3>

<p>ApplyFwerCor, SidakCor_SD
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
n &lt;- 100
p &lt;- 10
corr_theo &lt;- diag(1,p)
corr_theo[1,3] &lt;- 0.5
corr_theo[3,1] &lt;- 0.5
data &lt;- MASS::mvrnorm(n,rep(0,p),corr_theo)
# adjusted p-values
res &lt;- SidakCor(data,stat_test='empirical')
round(res,2)
# significant correlations with level alpha:
alpha &lt;- 0.05
whichCor(res&lt;alpha)
# directly
SidakCor(data,alpha,stat_test='empirical',arr.ind=TRUE)
</code></pre>

<hr>
<h2 id='SidakCor_SD'>Sidak multiple testing method for correlations
with stepdown procedure.</h2><span id='topic+SidakCor_SD'></span>

<h3>Description</h3>

<p>Sidak multiple testing method for correlations
with stepdown procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SidakCor_SD(
  data,
  alpha = 0.05,
  stat_test = "empirical",
  vect = FALSE,
  logical = TRUE,
  arr.ind = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SidakCor_SD_+3A_data">data</code></td>
<td>
<p>matrix of observations</p>
</td></tr>
<tr><td><code id="SidakCor_SD_+3A_alpha">alpha</code></td>
<td>
<p>level of multiple testing</p>
</td></tr>
<tr><td><code id="SidakCor_SD_+3A_stat_test">stat_test</code></td>
<td>
<p>4 test statistics are available:
</p>

<dl>
<dt>'empirical'</dt><dd> <p><code class="reqn">\sqrt{n}*abs(corr)</code></p>
</dd>
<dt>'fisher'</dt><dd> <p><code class="reqn">\sqrt{n-3}*1/2*\log( (1+corr)/(1-corr) )</code></p>
</dd>
<dt>'student'</dt><dd> <p><code class="reqn">\sqrt{n-2}*abs(corr)/\sqrt(1-corr^2)</code></p>
</dd>
<dt>'2nd.order'</dt><dd> <p><code class="reqn">\sqrt{n}*mean(Y)/sd(Y)</code> with <code class="reqn">Y=(X_i-mean(X_i))(X_j-mean(X_j))</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="SidakCor_SD_+3A_vect">vect</code></td>
<td>
<p>if TRUE returns a vector of TRUE/FALSE values, corresponding to <code>vectorize(cor(data))</code>;
if FALSE, returns an array containing TRUE/FALSE values for each entry of the correlation matrix</p>
</td></tr>
<tr><td><code id="SidakCor_SD_+3A_logical">logical</code></td>
<td>
<p>if TRUE, returns either a vector or a matrix where each element is equal to TRUE if the corresponding null hypothesis is rejected, and to FALSE if it is not rejected
if FALSE, returns a list of successive p-values : element [[i+1]] of the list giving the p-values evaluated on the non-rejected hypothesis at step [[i]]; p-values are either as a vector or a list depending on <code>vect</code></p>
</td></tr>
<tr><td><code id="SidakCor_SD_+3A_arr.ind">arr.ind</code></td>
<td>
<p>if TRUE, returns the indexes of the significant correlations, with respect to level alpha</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns  </p>
<ul>
<li><p>logicals, equal to TRUE if the corresponding element of the statistic vector is rejected, as a vector or a matrix depending of the value of <code>vect</code>, </p>
</li>
<li><p>an array containing indexes <code class="reqn">\lbrace(i,j),\,i&lt;j\rbrace</code> for which correlation between variables <code class="reqn">i</code> and <code class="reqn">j</code> is significant, if <code>arr.ind=TRUE</code>.</p>
</li></ul>



<h3>References</h3>

<p>Roux, M. (2018). Graph inference by multiple testing with application to Neuroimaging, Ph.D., Université Grenoble Alpes, France, https://tel.archives-ouvertes.fr/tel-01971574v1.
</p>
<p>Šidák, Z. (1967). Rectangular confidence regions for the means of multivariate normal distributions. Journal of the American Statistical Association, 62(318), 626-633.
</p>


<h3>See Also</h3>

<p>ApplyFwerCor, SidakCor
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
n &lt;- 100
p &lt;- 10
corr_theo &lt;- diag(1,p)
corr_theo[1,3] &lt;- 0.5
corr_theo[3,1] &lt;- 0.5
data &lt;- MASS::mvrnorm(n,rep(0,p),corr_theo)
alpha &lt;- 0.05
# significant correlations:
SidakCor_SD(data,alpha,stat_test='empirical', arr.ind=TRUE)
# successive p-values
res &lt;- SidakCor_SD(data,stat_test='empirical', logical=FALSE)
lapply(res,FUN=function(x){round(x,2)})
# succesive rejections
lapply(res,FUN=function(x){whichCor(x&lt;alpha)})  
</code></pre>

<hr>
<h2 id='SimuFdr'>Simulates Gaussian data with a given correlation matrix and applies a FDR controlling procedure on the correlations.</h2><span id='topic+SimuFdr'></span>

<h3>Description</h3>

<p>Simulates Gaussian data with a given correlation matrix and applies a FDR controlling procedure on the correlations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimuFdr(
  corr_theo,
  n = 100,
  Nsimu = 1,
  alpha = 0.05,
  stat_test = "empirical",
  method = "LCTnorm",
  Nboot = 1000,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SimuFdr_+3A_corr_theo">corr_theo</code></td>
<td>
<p>the correlation matrix of Gaussien data simulated</p>
</td></tr>
<tr><td><code id="SimuFdr_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="SimuFdr_+3A_nsimu">Nsimu</code></td>
<td>
<p>number of simulations</p>
</td></tr>
<tr><td><code id="SimuFdr_+3A_alpha">alpha</code></td>
<td>
<p>level of multiple testing</p>
</td></tr>
<tr><td><code id="SimuFdr_+3A_stat_test">stat_test</code></td>
<td>

<dl>
<dt>'empirical'</dt><dd><p><code class="reqn">\sqrt{n}*abs(corr)</code></p>
</dd>
<dt>'fisher'</dt><dd><p><code class="reqn">\sqrt{n-3}*1/2*\log( (1+corr)/(1-corr) )</code></p>
</dd>
<dt>'student'</dt><dd><p><code class="reqn">\sqrt{n-2}*abs(corr)/\sqrt(1-corr^2)</code></p>
</dd>
<dt>'gaussian'</dt><dd><p><code class="reqn">\sqrt{n}*mean(Y)/sd(Y)</code> with <code class="reqn">Y=(X_i-mean(X_i))(X_j-mean(X_j))</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="SimuFdr_+3A_method">method</code></td>
<td>
<p>choice between 'LCTnorm' and 'LCTboot', developped by Cai &amp; Liu (2016), 
'BH', traditional Benjamini-Hochberg (1995)'s procedure,
and 'BHboot', Benjamini-Hochberg (1995)'s procedure with bootstrap evaluation of pvalues</p>
</td></tr>
<tr><td><code id="SimuFdr_+3A_nboot">Nboot</code></td>
<td>
<p>number of iterations for Monte-Carlo of bootstrap quantile evaluation</p>
</td></tr>
<tr><td><code id="SimuFdr_+3A_seed">seed</code></td>
<td>
<p>seed for the Gaussian simulations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a line vector containing estimated values for fwer, fdr, sensitivity, specificity and accuracy.
</p>


<h3>References</h3>

<p>Benjamini, Y., &amp; Hochberg, Y. (1995). Controlling the false discovery rate: a practical and powerful approach to multiple testing. Journal of the royal statistical society. Series B (Methodological), 289-300.
</p>
<p>Cai, T. T., &amp; Liu, W. (2016). Large-scale multiple testing of correlations. Journal of the American Statistical Association, 111(513), 229-240.
</p>
<p>Roux, M. (2018). Graph inference by multiple testing with application to Neuroimaging, Ph.D., Université Grenoble Alpes, France, <a href="https://tel.archives-ouvertes.fr/tel-01971574v1">https://tel.archives-ouvertes.fr/tel-01971574v1</a>.
</p>


<h3>See Also</h3>

<p>ApplyFdrCor, SimuFwer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Nsimu &lt;- 1000
n &lt;- 100
p &lt;- 10
corr_theo &lt;- diag(1,p)
corr_theo[1,3] &lt;- 0.5
corr_theo[3,1] &lt;- 0.5
alpha &lt;- 0.05
SimuFdr(corr_theo,n,Nsimu,alpha,stat_test='empirical',method='LCTnorm')
</code></pre>

<hr>
<h2 id='SimuFwer'>Simulates Gaussian data with a given correlation matrix and applies a FWER controlling procedure on the correlations.</h2><span id='topic+SimuFwer'></span>

<h3>Description</h3>

<p>Simulates Gaussian data with a given correlation matrix and applies a FWER controlling procedure on the correlations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimuFwer(
  corr_theo,
  n = 100,
  Nsimu = 1,
  alpha = 0.05,
  stat_test = "empirical",
  method = "Sidak",
  Nboot = 1000,
  stepdown = TRUE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SimuFwer_+3A_corr_theo">corr_theo</code></td>
<td>
<p>the correlation matrix of Gaussien data simulated</p>
</td></tr>
<tr><td><code id="SimuFwer_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="SimuFwer_+3A_nsimu">Nsimu</code></td>
<td>
<p>number of simulations</p>
</td></tr>
<tr><td><code id="SimuFwer_+3A_alpha">alpha</code></td>
<td>
<p>level of multiple testing</p>
</td></tr>
<tr><td><code id="SimuFwer_+3A_stat_test">stat_test</code></td>
<td>

<dl>
<dt>'empirical'</dt><dd><p><code class="reqn">\sqrt{n}*abs(corr)</code></p>
</dd>
<dt>'fisher'</dt><dd><p><code class="reqn">\sqrt{n-3}*1/2*\log( (1+corr)/(1-corr) )</code></p>
</dd>
<dt>'student'</dt><dd><p><code class="reqn">\sqrt{n-2}*abs(corr)/\sqrt(1-corr^2)</code></p>
</dd>
<dt>'gaussian'</dt><dd><p><code class="reqn">\sqrt{n}*mean(Y)/sd(Y)</code> with <code class="reqn">Y=(X_i-mean(X_i))(X_j-mean(X_j))</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="SimuFwer_+3A_method">method</code></td>
<td>
<p>choice between 'Bonferroni', 'Sidak', 'BootRW', 'MaxTinfty'</p>
</td></tr>
<tr><td><code id="SimuFwer_+3A_nboot">Nboot</code></td>
<td>
<p>number of iterations for Monte-Carlo of bootstrap quantile evaluation</p>
</td></tr>
<tr><td><code id="SimuFwer_+3A_stepdown">stepdown</code></td>
<td>
<p>logical, if TRUE a stepdown procedure is applied</p>
</td></tr>
<tr><td><code id="SimuFwer_+3A_seed">seed</code></td>
<td>
<p>seed for the Gaussian simulations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a line vector containing estimated values for fwer, fdr, sensitivity, specificity and accuracy.
</p>


<h3>References</h3>

<p>Bonferroni, C. E. (1935). Il calcolo delle assicurazioni su gruppi di teste. Studi in onore del professore salvatore ortu carboni, 13-60.
</p>
<p>Drton, M., &amp; Perlman, M. D. (2007). Multiple testing and error control in Gaussian graphical model selection. Statistical Science, 22(3), 430-449.
</p>
<p>Romano, J. P., &amp; Wolf, M. (2005). Exact and approximate stepdown methods for multiple hypothesis testing. Journal of the American Statistical Association, 100(469), 94-108.
</p>
<p>Roux, M. (2018). Graph inference by multiple testing with application to Neuroimaging, Ph.D., Université Grenoble Alpes, France, https://tel.archives-ouvertes.fr/tel-01971574v1.
</p>
<p>Westfall, P.H. &amp; Young, S. (1993) Resampling-based multiple testing: Examples and methods for p-value adjustment, John Wiley &amp; Sons, vol. 279.
</p>


<h3>See Also</h3>

<p>ApplyFwerCor, SimuFwer_oracle, SimuFdr
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Nsimu &lt;- 1000 
n &lt;- 100
p &lt;- 10
corr_theo &lt;- diag(1,p)
corr_theo[1,3] &lt;- 0.5
corr_theo[3,1] &lt;- 0.5
alpha &lt;- 0.05
SimuFwer(corr_theo,n,Nsimu,alpha,stat_test='empirical',method='Bonferroni',stepdown=FALSE)
</code></pre>

<hr>
<h2 id='SimuFwer_oracle'>Simulates Gaussian data with a given correlation matrix and applies oracle MaxTinfty on the correlations.</h2><span id='topic+SimuFwer_oracle'></span>

<h3>Description</h3>

<p>Simulates Gaussian data with a given correlation matrix and applies oracle MaxTinfty (i.e. Drton &amp; Perlman (2007)'s procedure with the true correlation matrix) on the correlations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimuFwer_oracle(
  corr_theo,
  n = 100,
  Nsimu = 1,
  alpha = 0.05,
  stat_test = "empirical",
  method = "MaxTinfty",
  Nboot = 1000,
  stepdown = TRUE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SimuFwer_oracle_+3A_corr_theo">corr_theo</code></td>
<td>
<p>the correlation matrix of Gaussien data simulated</p>
</td></tr>
<tr><td><code id="SimuFwer_oracle_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="SimuFwer_oracle_+3A_nsimu">Nsimu</code></td>
<td>
<p>number of simulations</p>
</td></tr>
<tr><td><code id="SimuFwer_oracle_+3A_alpha">alpha</code></td>
<td>
<p>level of multiple testing</p>
</td></tr>
<tr><td><code id="SimuFwer_oracle_+3A_stat_test">stat_test</code></td>
<td>

<dl>
<dt>'empirical'</dt><dd><p><code class="reqn">\sqrt{n}*abs(corr)</code></p>
</dd>
<dt>'fisher'</dt><dd><p><code class="reqn">\sqrt{n-3}*1/2*\log( (1+corr)/(1-corr) )</code></p>
</dd>
<dt>'student'</dt><dd><p><code class="reqn">\sqrt{n-2}*abs(corr)/\sqrt(1-corr^2)</code></p>
</dd>
<dt>'gaussian'</dt><dd><p><code class="reqn">\sqrt{n}*mean(Y)/sd(Y)</code> with <code class="reqn">Y=(X_i-mean(X_i))(X_j-mean(X_j))</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="SimuFwer_oracle_+3A_method">method</code></td>
<td>
<p>only 'MaxTinfty' available</p>
</td></tr>
<tr><td><code id="SimuFwer_oracle_+3A_nboot">Nboot</code></td>
<td>
<p>number of iterations for Monte-Carlo of bootstrap quantile evaluation</p>
</td></tr>
<tr><td><code id="SimuFwer_oracle_+3A_stepdown">stepdown</code></td>
<td>
<p>logical, if TRUE a stepdown procedure is applied</p>
</td></tr>
<tr><td><code id="SimuFwer_oracle_+3A_seed">seed</code></td>
<td>
<p>seed for the Gaussian simulations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a line vector containing estimated values for fwer, fdr, sensitivity, specificity and accuracy.
</p>


<h3>References</h3>

<p>Drton, M., &amp; Perlman, M. D. (2007). Multiple testing and error control in Gaussian graphical model selection. Statistical Science, 22(3), 430-449.
</p>
<p>Roux, M. (2018). Graph inference by multiple testing with application to Neuroimaging, Ph.D., Université Grenoble Alpes, France, https://tel.archives-ouvertes.fr/tel-01971574v1.
</p>


<h3>See Also</h3>

<p>ApplyFwerCor_Oracle, SimuFwer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Nsimu &lt;- 1000
n &lt;- 50
p &lt;- 10
corr_theo &lt;- diag(1,p)
corr_theo[1,3] &lt;- 0.5
corr_theo[3,1] &lt;- 0.5
alpha &lt;- 0.05
SimuFwer_oracle(corr_theo,n,Nsimu,alpha,stat_test='empirical',stepdown=FALSE,Nboot=100)
</code></pre>

<hr>
<h2 id='UncorrectedCor'>Uncorrected testing procedure for correlations.</h2><span id='topic+UncorrectedCor'></span>

<h3>Description</h3>

<p>Uncorrected testing procedure for correlations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UncorrectedCor(
  data,
  alpha = 0.05,
  stat_test = "empirical",
  vect = FALSE,
  logical = FALSE,
  arr.ind = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UncorrectedCor_+3A_data">data</code></td>
<td>
<p>matrix of observations</p>
</td></tr>
<tr><td><code id="UncorrectedCor_+3A_alpha">alpha</code></td>
<td>
<p>level of multiple testing (used if logical=TRUE)</p>
</td></tr>
<tr><td><code id="UncorrectedCor_+3A_stat_test">stat_test</code></td>
<td>

<dl>
<dt>'empirical'</dt><dd><p><code class="reqn">\sqrt{n}*abs(corr)</code></p>
</dd>
<dt>'fisher'</dt><dd>   <p><code class="reqn">\sqrt{n-3}*1/2*\log( (1+corr)/(1-corr) )</code></p>
</dd>
<dt>'student'</dt><dd>  <p><code class="reqn">\sqrt{n-2}*abs(corr)/\sqrt(1-corr^2)</code></p>
</dd>
<dt>'2nd.order'</dt><dd> <p><code class="reqn">\sqrt{n}*mean(Y)/sd(Y)</code> with <code class="reqn">Y=(X_i-mean(X_i))(X_j-mean(X_j))</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="UncorrectedCor_+3A_vect">vect</code></td>
<td>
<p>if TRUE returns a vector of adjusted p-values, corresponding to <code>vectorize(cor(data))</code>;
if FALSE, returns an array containing the adjusted p-values for each entry of the correlation matrix</p>
</td></tr>
<tr><td><code id="UncorrectedCor_+3A_logical">logical</code></td>
<td>
<p>if TRUE, returns either a vector or a matrix where each element is equal to TRUE if the corresponding null hypothesis is rejected, and to FALSE if it is not rejected</p>
</td></tr>
<tr><td><code id="UncorrectedCor_+3A_arr.ind">arr.ind</code></td>
<td>
<p>if TRUE, returns the indexes of the significant correlations, with respect to level alpha</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns  </p>
<ul>
<li><p>the non-adjusted p-values, as a vector or a matrix depending of the value of <code>vect</code>, </p>
</li>
<li><p>an array containing indexes <code class="reqn">\lbrace(i,j),\,i&lt;j\rbrace</code> for which correlation between variables <code class="reqn">i</code> and <code class="reqn">j</code> is significant, if <code>arr.ind=TRUE</code>.</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
p &lt;- 10
corr_theo &lt;- diag(1,p)
corr_theo[1,3] &lt;- 0.5
corr_theo[3,1] &lt;- 0.5
data &lt;- MASS::mvrnorm(n,rep(0,p),corr_theo)
# p-values
res &lt;- UncorrectedCor(data,stat_test='empirical')
round(res,2)
# significant correlations with level alpha:
alpha &lt;- 0.05
whichCor(res&lt;alpha)
# directly
UncorrectedCor(data,alpha,stat_test='empirical',arr.ind=TRUE)
</code></pre>

<hr>
<h2 id='unvectorize'>Returns an upper-triangle matrix, without the diagonal, containing the elements of a given vector.</h2><span id='topic+unvectorize'></span>

<h3>Description</h3>

<p>Returns an upper-triangle matrix, without the diagonal, containing the elements of a given vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unvectorize(vect)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unvectorize_+3A_vect">vect</code></td>
<td>
<p>A vector containing the upper triangle of a matrix, without the diagonal</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an upper-triangle matrix where each entry is given by the vector containing the upper triangle of a matrix, without the diagonal.
</p>


<h3>See Also</h3>

<p>vectorize
</p>


<h3>Examples</h3>

<pre><code class='language-R'>unvectorize(1:10)
</code></pre>

<hr>
<h2 id='vectorize'>Returns a vector containing the upper triangle of a matrix, without the diagonal.</h2><span id='topic+vectorize'></span>

<h3>Description</h3>

<p>Returns a vector containing the upper triangle of a matrix, without the diagonal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vectorize(mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vectorize_+3A_mat">mat</code></td>
<td>
<p>a square matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector containing the upper triangle of a matrix, without the diagonal.
</p>


<h3>See Also</h3>

<p>unvectorize
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vectorize(matrix(1:9,3,3))
</code></pre>

<hr>
<h2 id='whichCor'>Returns the indexes of an upper triangular matrix with logical entries.</h2><span id='topic+whichCor'></span>

<h3>Description</h3>

<p>Returns the indexes of an upper triangular matrix with logical entries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whichCor(mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="whichCor_+3A_mat">mat</code></td>
<td>
<p>A matrix with logical entries in the upper triangular part</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the indexes of the upper triangular part where the entries are TRUE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
p &lt;- 10
corr_theo &lt;- diag(1,p)
corr_theo[1,3] &lt;- 0.5
corr_theo[3,1] &lt;- 0.5
data &lt;- MASS::mvrnorm(n,rep(0,p),corr_theo)
res &lt;- ApplyFwerCor(data,stat_test='empirical',method='Bonferroni',stepdown=FALSE)
# significant correlations, level alpha:
alpha &lt;- 0.05
whichCor(res&lt;alpha)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
