<!DOCTYPE html><html><head><title>Help for package PermAlgo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PermAlgo}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#PermAlgo-internal'><p>Internal PermAlgo objects</p></a></li>
<li><a href='#PermAlgo-package'><p>Generate Event Times Conditional On Time-Dependent Covariates</p></a></li>
<li><a href='#permalgorithm'><p>Generate Event Times Conditional On Time-Dependent Covariates</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Permutational Algorithm to Simulate Survival Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-05</td>
</tr>
<tr>
<td>Author:</td>
<td>Marie-Pierre Sylvestre, Thad Edens, Todd MacKenzie, Michal
        Abrahamowicz</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marie-Pierre Sylvestre
&lt;marie-pierre.sylvestre@umontreal.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>This version of the permutational algorithm generates a
        dataset in which event and censoring times are conditional on
        an user-specified list of covariates, some or all of which are
        time-dependent.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-06 16:28:05 UTC; 15148</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-06 17:00:02 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
</table>
<hr>
<h2 id='PermAlgo-internal'>Internal PermAlgo objects</h2><span id='topic+PermAlgo-internal'></span>

<h3>Description</h3>

<p>Internal PermAlgo objects.</p>


<h3>Details</h3>

<p>These are not to be called by the user.</p>

<hr>
<h2 id='PermAlgo-package'>Generate Event Times Conditional On Time-Dependent Covariates
</h2><span id='topic+PermAlgo-package'></span><span id='topic+PermAlgo'></span>

<h3>Description</h3>

<p>This version of the permutational algorithm generates a dataset in which
event and censoring times are conditional on an user-specified list of
covariates, some or all of which are time-dependent.  Event times and censoring
times also follow user-specified distributions. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> PermAlgo</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2010-08-24</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The package contains one function avialable to the user, <code>permalgorithm</code>. The gist of the algorithm is to perform a one-to-one matching of <code>n</code> observed times with <code>n</code> independently generated vectors of covariates values.  The matching is performed based on a permutation probability law derived from the partial likelihood of Cox's Proportional Hazards (PH) model.  
</p>


<h3>Author(s)</h3>

<p>Marie-Pierre Sylvestre, Thad Evans, Todd MacKenzie, Michal Abrahamowicz
</p>
<p>Maintainer: Marie-Pierre Sylvestre  &lt;marie-pierre.sylvestre.chum@ssss.gouv.qc.ca&gt;
</p>


<h3>References</h3>

<p>This algorithm is an extension of the permutational algorithm 
first introduced by Abrahamowicz, MacKenzie and Esdaile, and described in
details by MacKenzie and Abrahamowicz.  The current version of the permutational
algorithm is a flexible tool to generate event and censoring times that follow
user-specified distributions and that are conditional on user-specified
covariates.  It has been validated through simulations in Sylvestre and
Abrahamowicz.  Please reference the manuscript by Sylvestre and Abrahamowicz
cited below if the results of this program are used in any published
material.
</p>
<p>Sylvestre M.-P., Abrahamowicz M. (2008) Comparison of algorithms to generate
event times conditional on time-dependent covariates. <em>Statistics in
Medicine</em> <b>27(14)</b>:2618&ndash;34.
</p>
<p>Abrahamowicz M., MacKenzie T., Esdaile J.M. (1996) Time-dependent hazard ratio:
modelling and hypothesis testing with application in lupus nephritis. <em>JASA</em> 
<b>91</b>:1432&ndash;9.
</p>
<p>MacKenzie T., Abrahamowicz M. (2002) Marginal and hazard ratio specific random
data
generation: Applications to semi-parametric bootstrapping. <em>Statistics
and Computing</em> <b>12(3)</b>:245&ndash;252.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example - Generating adverse event conditional on use
# of prescription drugs

# Prepare the matrice of covariate (Xmat)
# Here we simulate daily exposures to 2 prescription drugs over a
# year. Drug prescriptions can start any day of follow-up, and their
# duration is a multiple of 7 days. There can be multiple prescriptions
# for each individuals over the year and interuptions of drug use in
# between.

# Additionaly, there is a time-independant binary covarite (sex).

n=500 # subjects
m=365 # days

# Generate the matrix of three covariate, in a 'long' format.
Xmat=matrix(ncol=3, nrow=n*m)

# time-independant binary covariate
Xmat[,1] &lt;- rep(rbinom(n, 1, 0.3), each=m)

# Function to generate an individual time-dependent exposure history
# e.g. generate prescriptions of different durations and doses.
TDhist &lt;- function(m){
  start &lt;- round(runif(1,1,m),0) # individual start date
  duration &lt;-  7 + 7*rpois(1,3) # in weeks
  dose &lt;-  round(runif(1,0,10),1) 
  vec &lt;- c(rep(0, start-1), rep(dose, duration))
  while (length(vec)&lt;=m){
    intermission &lt;- 21 + 7*rpois(1,3) # in weeks
    duration &lt;-  7 + 7*rpois(1,3) # in weeks
    dose &lt;-  round(runif(1,0,10),1)
    vec &lt;- append(vec, c(rep(0, intermission), rep(dose, duration)))}
  return(vec[1:m])}

# create TD var
Xmat[,2] &lt;- do.call("c", lapply(1:n, function(i) TDhist(m)))
Xmat[,3] &lt;- do.call("c", lapply(1:n, function(i) TDhist(m)))

# genereate vectors of event and censoring times prior to calling the
# function for the algorithm

eventRandom &lt;- round(rexp(n, 0.012)+1,0)
censorRandom &lt;- round(runif(n, 1,870),0)

# Generate the survival data conditional on the three covariates

data &lt;- permalgorithm(n, m, Xmat, XmatNames=c("sex", "Drug1", "Drug2"),
eventRandom = eventRandom, censorRandom=censorRandom, betas=c(log(2),
log(1.04), log(0.99)), groupByD=FALSE )

# could use survival library and check whether the data was generated
# properly using coxph(Surv(Start, Stop, Event) ~ sex + Drug1 + Drug2,
# data)

</code></pre>

<hr>
<h2 id='permalgorithm'>Generate Event Times Conditional On Time-Dependent Covariates</h2><span id='topic+permalgorithm'></span>

<h3>Description</h3>

<p>This version of the permutational algorithm generates a dataset in which event and censoring times are conditional on an user-specified list of covariates, some or all of which are time-dependent.  Event times and censoring times also follow user-specified distributions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>permalgorithm(numSubjects, maxTime, Xmat, XmatNames = NULL,
eventRandom = NULL, censorRandom = NULL, betas, groupByD = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permalgorithm_+3A_numsubjects">numSubjects</code></td>
<td>
<p>is the number of subjects generated.</p>
</td></tr>
<tr><td><code id="permalgorithm_+3A_maxtime">maxTime</code></td>
<td>
<p>is a non-zero integer represening the maximum length
of follow-up.</p>
</td></tr>
<tr><td><code id="permalgorithm_+3A_xmat">Xmat</code></td>
<td>
<p>is the matrix of covariates values in a counting process
format where every line represent one and only one time interval,
during which all covariate values for a given subject remains
constant. Consequently, <code>Xmat</code> should have
<code>numSubjects</code>*<code>maxTime</code> rows. Each column of <code>Xmat</code>
corresponds to a different covariates on which the event is conditionned. For fixed-in-time covariates, the same value should be
replicated in each of <code>maxTime</code> row for a given subject.</p>
</td></tr>
<tr><td><code id="permalgorithm_+3A_xmatnames">XmatNames</code></td>
<td>
<p>a an optional vector of character strings representing
the names of each of the covariates in <code>Xmat</code>.</p>
</td></tr>
<tr><td><code id="permalgorithm_+3A_eventrandom">eventRandom</code></td>
<td>
<p>represents individual event times. <code>eventRandom</code>
can be a vector of nonegative integer values or a random generating
function with argument n. In both cases, its values must be smaller or
equal to <code>maxTime</code>. If left unspecified, then the algorithm
generates event times based on an uniform distribtuion [1, maxTime].</p>
</td></tr>
<tr><td><code id="permalgorithm_+3A_censorrandom">censorRandom</code></td>
<td>
<p>represents individual censoring
times. <code>censorRandom</code> can be a vector of nonegative integer
values or a random generating function with argument n. In both cases,
its values must be smaller or equal to <code>maxTime</code>.  The default is
Uniform[1,maxTime].</p>
</td></tr>
<tr><td><code id="permalgorithm_+3A_betas">betas</code></td>
<td>
<p>is a vector of regression coefficients (log hazard) that represent the
magnitude of the relationship between each of the covariates and the
risk of an event. The length of <code>betas</code> should correspond to the
number of columns in <code>Xmat</code>.</p>
</td></tr>
<tr><td><code id="permalgorithm_+3A_groupbyd">groupByD</code></td>
<td>
<p>groupByD is an option that, when enabled, increases the
computational efficiency of the algorithm by replacing the individual
assignment of event times and censoring times by grouped
assignements. The side effect of this option is that it generates
datasets that are, on average, slightly less consistent with the model
described by <code>betas</code> that those generated  with the groupByD
option set to FALSE. Still, groupByD=TRUE may be  usefull to generate
large datasets where <code>maxTime</code> is much smaller than
<code>numSubjects</code> so that many ties are expected. Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gist of the algorithm is to perform a one-to-one matching of
<code>n</code> observed times with independently generated vectors of
covariates values.  The matching is performed based on a permutation
probability law derived from the partial likelihood of Cox's 
Proportional Hazards (PH) model.  
</p>
<p>The number of events obtained in the data.frame returned by the function
depends on both the distribution of event <code>enventRandom</code> and
censoring times <code>censorRandom</code>.  In the simplest case where the
distirbution of <code>eventRandom</code> is Uniform over follow-up U[1,m], and
the censoring is random, the number of observed events in the data.frame
returnd by the algorithm is determined by the upper bound of the Uniform
distribution of <code>censorRandom</code>.  For example, setting the
distribution of <code>censorRandom</code> to U[1,m] will lead to approximately
half of the subjects to experience an event during follow-up, while
setting the distribution of <code>censorRandom</code> to U[1,3/2] will lead to
approximately two thirds of the observed times to be events.
</p>
<p>Subjects without an event before or on <code>maxTime</code> and who are not
censored before <code>maxTime</code> are censored on <code>maxTime</code>
(administrative censoring).
</p>
<p>*** Warning *** Currently the algorithm only takes Xmat in matrix
format. Consequently, factor variables are not allowed. Instead, users need
to code them with binary indicators. 
</p>


<h3>Value</h3>

<p>A data.frame object with columns corresponding to
</p>
<table>
<tr><td><code>Id</code></td>
<td>
<p>Identifies the rows of the data.frame that corresponds to
each of the <code>n</code> individuals.</p>
</td></tr>
<tr><td><code>Event</code></td>
<td>
<p>Indicator of event.  <code>Event</code> = 1 when event occurs
and 0 otherwise.</p>
</td></tr>
<tr><td><code>Fup</code></td>
<td>
<p>Individual follow-up time.</p>
</td></tr>
<tr><td><code>Start</code></td>
<td>
<p>For counting process formulation.  Represents the start
of each time interval.</p>
</td></tr>
<tr><td><code>Stop</code></td>
<td>
<p>For counting process formulation.  Represents the end of
each time interval.</p>
</td></tr>
<tr><td><code>Xmat</code></td>
<td>
<p>The values of the covariates specified in  Xmat.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marie-Pierre Sylvestre, Thad Evans, Todd MacKenzie, Michal Abrahamowicz</p>


<h3>References</h3>

<p>This algorithm is an extension of the permutational algorithm 
first introduced by Abrahamowicz, MacKenzie and Esdaile, and described in
details by MacKenzie and Abrahamowicz.  The current version of the permutational
algorithm is a flexible tool to generate event and censoring times that follow
user-specified distributions and that are conditional on user-specified
covariates. This is especially useful whenever at least one of the
covariate is time-dependent so that conventional inversion methods are
difficult to implement.
</p>
<p>The algorithm has been validated through simulations in Sylvestre and
Abrahamowicz.  Please reference the manuscript by Sylvestre and Abrahamowicz,
cited below, if this program is used in any published material.
</p>
<p>Sylvestre M.-P., Abrahamowicz M. (2008) Comparison of algorithms to generate
event times conditional on time-dependent covariates. <em>Statistics in 
Medicine</em> <b>27(14)</b>:2618&ndash;34.
</p>
<p>Abrahamowicz M., MacKenzie T., Esdaile J.M. (1996) Time-dependent hazard ratio: 
modelling and hypothesis testing with application in lupus nephritis.
<em>JASA</em> <b>91</b>:1432&ndash;9.
</p>
<p>MacKenzie T., Abrahamowicz M. (2002) Marginal and hazard ratio specific random
data generation: Applications to semi-parametric bootstrapping.
<em>Statistics and Computing</em> <b>12(3)</b>:245&ndash;252.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1 - Generating adverse event conditional on use
# of prescription drugs

# Prepare the matrice of covariate (Xmat)
# Here we simulate daily exposures to 2 prescription drugs over a
# year. Drug prescriptions can start any day of follow-up, and their
# duration is a multiple of 7 days. There can be multiple prescriptions
# for each individuals over the year and interuptions of drug use in
# between.

# Additionaly, there is a time-independant binary covarite (sex).

n=500 # subjects
m=365 # days

# Generate the matrix of three covariate, in a 'long' format.
Xmat=matrix(ncol=3, nrow=n*m)

# time-independant binary covariate
Xmat[,1] &lt;- rep(rbinom(n, 1, 0.3), each=m)

# Function to generate an individual time-dependent exposure history
# e.g. generate prescriptions of different durations and doses.
TDhist &lt;- function(m){
  start &lt;- round(runif(1,1,m),0) # individual start date
  duration &lt;-  7 + 7*rpois(1,3) # in weeks
  dose &lt;-  round(runif(1,0,10),1) 
  vec &lt;- c(rep(0, start-1), rep(dose, duration))
  while (length(vec)&lt;=m){
    intermission &lt;- 21 + 7*rpois(1,3) # in weeks
    duration &lt;-  7 + 7*rpois(1,3) # in weeks
    dose &lt;-  round(runif(1,0,10),1)
    vec &lt;- append(vec, c(rep(0, intermission), rep(dose, duration)))}
  return(vec[1:m])}

# create TD var
Xmat[,2] &lt;- do.call("c", lapply(1:n, function(i) TDhist(m)))
Xmat[,3] &lt;- do.call("c", lapply(1:n, function(i) TDhist(m)))

# genereate vectors of event and censoring times prior to calling the
# function for the algorithm

eventRandom &lt;- round(rexp(n, 0.012)+1,0)
censorRandom &lt;- round(runif(n, 1,870),0)

# Generate the survival data conditional on the three covariates

data &lt;- permalgorithm(n, m, Xmat, XmatNames=c("sex", "Drug1", "Drug2"),
eventRandom = eventRandom, censorRandom=censorRandom, betas=c(log(2),
log(1.04), log(0.99)), groupByD=FALSE )

# could use survival library and check whether the data was generated
# properly using coxph(Surv(Start, Stop, Event) ~ sex + Drug1 + Drug2,
# data)


# Example 2 - Generating Myocardial Infarction (MI) conditional on
# biennial measures of systolic blood pressure (like in the
# Framingham data).

m = 16 # exams
n &lt;- 10000 # individuals

# Very crude way to generate the data,  meant as an example only!
sysBP &lt;- rnorm(n*m,  120, 15) 

# by not submitting event and censor time, one let the algorithm
# generate them from uniform distributions over the follow-up time.

data2 &lt;- permalgorithm(n, m, sysBP, XmatNames="sysBP", betas=log(1.01),
groupByD=FALSE )

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
