<!DOCTYPE html><html><head><title>Help for package pmcalibration</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pmcalibration}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pmcalibration-package'><p>pmcalibration: Calibration Curves for Clinical Prediction Models</p></a></li>
<li><a href='#boot'><p>Bootstrap resample a calibration curve object</p></a></li>
<li><a href='#cal_metrics'><p>Calculate calibration metrics from calibration curve</p></a></li>
<li><a href='#gam_cal'><p>fits a calibration curve via gam</p></a></li>
<li><a href='#get_cc'><p>Extract plot data from <code>pmcalibration</code> object</p></a></li>
<li><a href='#glm_cal'><p>fits a calibration curve via glm or Cox proportional hazards model</p></a></li>
<li><a href='#invlogit'><p>Inverse logit transformation</p></a></li>
<li><a href='#loess_cal'><p>calibration curve via <code>loess</code></p></a></li>
<li><a href='#logistic_cal'><p>Run logistic calibration</p></a></li>
<li><a href='#logit'><p>Logit transformation</p></a></li>
<li><a href='#lowess_cal'><p>calibration curve via <code>lowess</code></p></a></li>
<li><a href='#plot.pmcalibration'><p>Plot a calibration curve (<code>pmcalibration</code> object)</p></a></li>
<li><a href='#pmcalibration'><p>Create a calibration curve</p></a></li>
<li><a href='#predict_lowess'><p>Get predictions from <code>loewss</code> fit</p></a></li>
<li><a href='#print.logistic_cal'><p>Print a <code>logistic_cal</code> object</p></a></li>
<li><a href='#print.logistic_calsummary'><p>Print a logistic_cal summary</p></a></li>
<li><a href='#print.pmcalibration'><p>print a pmcalibration object</p></a></li>
<li><a href='#print.pmcalibrationsummary'><p>Print summary of pmcalibration object</p></a></li>
<li><a href='#reg_spline_X'><p>Make a design matrix for regression spline</p></a></li>
<li><a href='#run_boots'><p>Wrapper to run bootstrap resamples using <code>parallel</code></p></a></li>
<li><a href='#sim_dat'><p>Simulate a binary outcome with either a quadratic relationship or interaction</p></a></li>
<li><a href='#simb'><p>Simulation based inference with a calibration curve object</p></a></li>
<li><a href='#summary.logistic_cal'><p>Summarize a logistic_cal object</p></a></li>
<li><a href='#summary.pmcalibration'><p>Summarize a pmcalibration object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Calibration Curves for Clinical Prediction Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stephen Rhodes &lt;steverho89@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit calibrations curves for clinical prediction models and calculate several associated 
  metrics (Eavg, E50, E90, Emax). Ideally predicted probabilities from a prediction model 
  should align with observed probabilities. Calibration curves relate predicted probabilities 
  (or a transformation thereof) to observed outcomes via a flexible non-linear smoothing function. 
  'pmcalibration' allows users to choose between several smoothers (regression splines, generalized 
  additive models/GAMs, lowess, loess). Both binary and time-to-event outcomes are supported. 
  See Van Calster et al. (2016) &lt;<a href="https://doi.org/10.1016%2Fj.jclinepi.2015.12.005">doi:10.1016/j.jclinepi.2015.12.005</a>&gt;; 
  Austin and Steyerberg (2019) &lt;<a href="https://doi.org/10.1002%2Fsim.8281">doi:10.1002/sim.8281</a>&gt;; 
  Austin et al. (2020) &lt;<a href="https://doi.org/10.1002%2Fsim.8570">doi:10.1002/sim.8570</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/stephenrho/pmcalibration">https://github.com/stephenrho/pmcalibration</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stephenrho/pmcalibration/issues">https://github.com/stephenrho/pmcalibration/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Hmisc, MASS, checkmate, chk, mgcv, splines, graphics, stats,
methods, survival, pbapply, parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, data.table, ggplot2, rms, simsurv</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-06 00:19:48 UTC; stephenrhodes</td>
</tr>
<tr>
<td>Author:</td>
<td>Stephen Rhodes [aut, cre, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-06 17:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='pmcalibration-package'>pmcalibration: Calibration Curves for Clinical Prediction Models</h2><span id='topic+pmcalibration-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>Fit calibrations curves for clinical prediction models and calculate several associated metrics (Eavg, E50, E90, Emax). Ideally predicted probabilities from a prediction model should align with observed probabilities. Calibration curves relate predicted probabilities (or a transformation thereof) to observed outcomes via a flexible non-linear smoothing function. 'pmcalibration' allows users to choose between several smoothers (regression splines, generalized additive models/GAMs, lowess, loess). Both binary and time-to-event outcomes are supported. See Van Calster et al. (2016) <a href="https://doi.org/10.1016/j.jclinepi.2015.12.005">doi:10.1016/j.jclinepi.2015.12.005</a>; Austin and Steyerberg (2019) <a href="https://doi.org/10.1002/sim.8281">doi:10.1002/sim.8281</a>; Austin et al. (2020) <a href="https://doi.org/10.1002/sim.8570">doi:10.1002/sim.8570</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Stephen Rhodes <a href="mailto:steverho89@gmail.com">steverho89@gmail.com</a> [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/stephenrho/pmcalibration">https://github.com/stephenrho/pmcalibration</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/stephenrho/pmcalibration/issues">https://github.com/stephenrho/pmcalibration/issues</a>
</p>
</li></ul>


<hr>
<h2 id='boot'>Bootstrap resample a calibration curve object</h2><span id='topic+boot'></span><span id='topic+boot.glm_cal'></span><span id='topic+boot.gam_cal'></span><span id='topic+boot.lowess_cal'></span><span id='topic+boot.loess_cal'></span>

<h3>Description</h3>

<p>Bootstrap resample a calibration curve object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot(cal)

## S3 method for class 'glm_cal'
boot(cal)

## S3 method for class 'gam_cal'
boot(cal)

## S3 method for class 'lowess_cal'
boot(cal)

## S3 method for class 'loess_cal'
boot(cal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_+3A_cal">cal</code></td>
<td>
<p>an object created using one of the <code>cal</code> functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>bootstrap resamples of calibration metrics and values for plotting
</p>

<hr>
<h2 id='cal_metrics'>Calculate calibration metrics from calibration curve</h2><span id='topic+cal_metrics'></span>

<h3>Description</h3>

<p>Calculates metrics used for summarizing calibration curves. See Austin and Steyerberg (2019)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal_metrics(p, p_c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cal_metrics_+3A_p">p</code></td>
<td>
<p>predicted probabilities</p>
</td></tr>
<tr><td><code id="cal_metrics_+3A_p_c">p_c</code></td>
<td>
<p>probabilities from the calibration curve</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named vector of metrics based on absolute difference between predicted and calibration curve implied probabilities <code>d = abs(p - p_c)</code>
</p>

<ul>
<li><p>Eavg - average absolute difference (aka integrated calibration index or ICI)
</p>
</li>
<li><p>E50 - median absolute difference
</p>
</li>
<li><p>E90 - 90th percentile absolute difference
</p>
</li>
<li><p>Emax - maximum absolute difference
</p>
</li>
<li><p>ECI - average squared difference. Estimated calibration index (Van Hoorde et al. 2015)
</p>
</li></ul>



<h3>References</h3>

<p>Austin PC, Steyerberg EW. (2019) The Integrated Calibration Index (ICI) and related metrics for quantifying the calibration of logistic regression models. <em>Statistics in Medicine</em>. 38, pp. 1–15. https://doi.org/10.1002/sim.8281
</p>
<p>Van Hoorde, K., Van Huffel, S., Timmerman, D., Bourne, T., Van Calster, B. (2015). A spline-based tool to assess and visualize the calibration of multiclass risk predictions. <em>Journal of Biomedical Informatics</em>, 54, pp. 283-93
</p>
<p>Van Calster, B., Nieboer, D., Vergouwe, Y., De Cock, B., Pencina M., Steyerberg E.W. (2016). A calibration hierarchy for risk models was defined: from utopia to empirical data. <em>Journal of Clinical Epidemiology</em>, 74, pp. 167-176
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pmcalibration)

LP &lt;- rnorm(100) # linear predictor
p_c &lt;- invlogit(LP) # actual probabilities
p &lt;- invlogit(LP*1.3) # predicted probabilities that are miscalibrated

cal_metrics(p = p, p_c = p_c)
</code></pre>

<hr>
<h2 id='gam_cal'>fits a calibration curve via gam</h2><span id='topic+gam_cal'></span>

<h3>Description</h3>

<p>fits a calibration curve via gam
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gam_cal(
  y,
  p,
  x,
  xp,
  time = NULL,
  save_data = TRUE,
  save_mod = TRUE,
  pw = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gam_cal_+3A_y">y</code></td>
<td>
<p>binary or a time-to-event (<code>Surv</code>) outcome. For the former <code>family = binomial(link="logit")</code> and for the latter <code>family = mgcv::cox.ph()</code>.</p>
</td></tr>
<tr><td><code id="gam_cal_+3A_p">p</code></td>
<td>
<p>predicted probabilities</p>
</td></tr>
<tr><td><code id="gam_cal_+3A_x">x</code></td>
<td>
<p>predictor (could be transformation of <code>p</code>)</p>
</td></tr>
<tr><td><code id="gam_cal_+3A_xp">xp</code></td>
<td>
<p>values for plotting (same scale as <code>x</code>)</p>
</td></tr>
<tr><td><code id="gam_cal_+3A_time">time</code></td>
<td>
<p>time to calculate survival probabilities at (only relevant if <code>y</code> is a <code>Surv</code> object)</p>
</td></tr>
<tr><td><code id="gam_cal_+3A_save_data">save_data</code></td>
<td>
<p>whether to save the data elements in the returned object</p>
</td></tr>
<tr><td><code id="gam_cal_+3A_save_mod">save_mod</code></td>
<td>
<p>whether to save the model in the returned object</p>
</td></tr>
<tr><td><code id="gam_cal_+3A_pw">pw</code></td>
<td>
<p>save pointwise standard errors for plotting</p>
</td></tr>
<tr><td><code id="gam_cal_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>mgcv::gam</code> and <code>mgcv::s</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of class <code>gam_cal</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pmcalibration)
# simulate some data
n &lt;- 500
dat &lt;- sim_dat(N = n, a1 = .5, a3 = .2)
head(dat)
# predictions
p &lt;- with(dat, invlogit(.5 + x1 + x2 + x1*x2*.1))

gam_cal(y = dat$y, p = p, x = p, xp = NULL, k = 20, method="REML")
</code></pre>

<hr>
<h2 id='get_cc'>Extract plot data from <code>pmcalibration</code> object</h2><span id='topic+get_cc'></span>

<h3>Description</h3>

<p>Extract plot data from <code>pmcalibration</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cc(x, conf_level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cc_+3A_x">x</code></td>
<td>
<p><code>pmcalibration</code> object</p>
</td></tr>
<tr><td><code id="get_cc_+3A_conf_level">conf_level</code></td>
<td>
<p>width of the confidence interval (0.95 gives 95% CI). Ignored if call to <code>pmcalibration</code> didn't request confidence intervals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame for plotting with 4 columns
</p>

<ul>
<li><p><code>p</code> - values for the x-axis (predicted probabilities - note these are *not* from your data and are only used for plotting)
</p>
</li>
<li><p><code>p_c</code> - probability implied by the calibration curve given <code>p</code>
</p>
</li>
<li><p><code>lower</code> and <code>upper</code> - bounds of the confidence interval
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(pmcalibration)
# simulate some data with a binary outcome
n &lt;- 500
dat &lt;- sim_dat(N = n, a1 = .5, a3 = .2)
head(dat)
# predictions
p &lt;- with(dat, invlogit(.5 + x1 + x2 + x1*x2*.1))

# fit calibration curve
cal &lt;- pmcalibration(y = dat$y, p = p, smooth = "gam", k = 20, ci = "pw")

cplot &lt;- get_cc(cal, conf_level = .95)
head(cplot)

if (requireNamespace("ggplot2", quietly = TRUE)){
library(ggplot2)
ggplot(cplot, aes(x = p, y = p_c, ymin=lower, ymax=upper)) +
  geom_abline(intercept = 0, slope = 1, lty=2) +
  geom_line() +
  geom_ribbon(alpha = 1/4) +
  lims(x=c(0,1), y=c(0,1))
}
</code></pre>

<hr>
<h2 id='glm_cal'>fits a calibration curve via glm or Cox proportional hazards model</h2><span id='topic+glm_cal'></span>

<h3>Description</h3>

<p>fits a calibration curve via glm or Cox proportional hazards model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm_cal(
  y,
  p,
  x,
  xp,
  smooth,
  time = NULL,
  save_data = TRUE,
  save_mod = TRUE,
  pw = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glm_cal_+3A_y">y</code></td>
<td>
<p>binary or a time-to-event (<code>Surv</code>) outcome. Former is fit via <code>glm</code> and latter is fit via <code>survival::coxph</code>.</p>
</td></tr>
<tr><td><code id="glm_cal_+3A_p">p</code></td>
<td>
<p>predicted probabilities</p>
</td></tr>
<tr><td><code id="glm_cal_+3A_x">x</code></td>
<td>
<p>predictor (could be transformation of <code>p</code>)</p>
</td></tr>
<tr><td><code id="glm_cal_+3A_xp">xp</code></td>
<td>
<p>values for plotting (same scale as <code>x</code>)</p>
</td></tr>
<tr><td><code id="glm_cal_+3A_smooth">smooth</code></td>
<td>
<p>'rcs', 'ns', 'bs', or 'none'</p>
</td></tr>
<tr><td><code id="glm_cal_+3A_time">time</code></td>
<td>
<p>time to calculate survival probabilities at (only relevant if <code>y</code> is a <code>Surv</code> object)</p>
</td></tr>
<tr><td><code id="glm_cal_+3A_save_data">save_data</code></td>
<td>
<p>whether to save the data elements in the returned object</p>
</td></tr>
<tr><td><code id="glm_cal_+3A_save_mod">save_mod</code></td>
<td>
<p>whether to save the model in the returned object</p>
</td></tr>
<tr><td><code id="glm_cal_+3A_pw">pw</code></td>
<td>
<p>save pointwise standard errors for plotting</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of class <code>glm_cal</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pmcalibration)
# simulate some data
n &lt;- 500
dat &lt;- sim_dat(N = n, a1 = .5, a3 = .2)

# predictions
p &lt;- with(dat, invlogit(.5 + x1 + x2 + x1*x2*.1))

glm_cal(y = dat$y, p = p, x = p, xp = NULL, smooth="ns", df=5)
</code></pre>

<hr>
<h2 id='invlogit'>Inverse logit transformation</h2><span id='topic+invlogit'></span>

<h3>Description</h3>

<p>Inverse logit transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invlogit(eta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invlogit_+3A_eta">eta</code></td>
<td>
<p>vector of numeric values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>inverse logit transformed eta (exp(eta)/(1 + exp(eta)))
</p>

<hr>
<h2 id='loess_cal'>calibration curve via <code>loess</code></h2><span id='topic+loess_cal'></span>

<h3>Description</h3>

<p>calibration curve via <code>loess</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loess_cal(p, y, x, xp, save_data = TRUE, save_mod = TRUE, pw = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loess_cal_+3A_p">p</code></td>
<td>
<p>predicted probabilities</p>
</td></tr>
<tr><td><code id="loess_cal_+3A_y">y</code></td>
<td>
<p>binary outcome</p>
</td></tr>
<tr><td><code id="loess_cal_+3A_x">x</code></td>
<td>
<p>predictor (could be transformation of <code>p</code>)</p>
</td></tr>
<tr><td><code id="loess_cal_+3A_xp">xp</code></td>
<td>
<p>values for plotting (same scale as <code>x</code>)</p>
</td></tr>
<tr><td><code id="loess_cal_+3A_save_data">save_data</code></td>
<td>
<p>whether to save y, p, x, xp in the returned object</p>
</td></tr>
<tr><td><code id="loess_cal_+3A_save_mod">save_mod</code></td>
<td>
<p>whether to save the model in the returned object</p>
</td></tr>
<tr><td><code id="loess_cal_+3A_pw">pw</code></td>
<td>
<p>save pointwise standard errors for plotting</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of class <code>loess_cal</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pmcalibration)
# simulate some data
n &lt;- 500
dat &lt;- sim_dat(N = n, a1 = .5, a3 = .2)

# predictions
p &lt;- with(dat, invlogit(.5 + x1 + x2 + x1*x2*.1))

loess_cal(y = dat$y, p = p, x = p, xp = NULL)
</code></pre>

<hr>
<h2 id='logistic_cal'>Run logistic calibration</h2><span id='topic+logistic_cal'></span>

<h3>Description</h3>

<p>Assess 'weak' calibration (see, e.g., Van Calster et al. 2019) via calibration intercept
and calibration slope.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logistic_cal(y, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logistic_cal_+3A_y">y</code></td>
<td>
<p>binary outcome</p>
</td></tr>
<tr><td><code id="logistic_cal_+3A_p">p</code></td>
<td>
<p>predicted probabilities (these will be logit transformed)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>logistic_cal</code> containing <code>glm</code> results for calculating calibration intercept and calibration slope
</p>


<h3>References</h3>

<p>Van Calster, B., McLernon, D. J., Van Smeden, M., Wynants, L., &amp; Steyerberg, E. W. (2019). Calibration: the Achilles heel of predictive analytics. BMC medicine, 17(1), 1-7.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pmcalibration)
# simulate some data
n &lt;- 500
dat &lt;- sim_dat(N = n, a1 = .5, a3 = .2)

# predictions
p &lt;- with(dat, invlogit(.5 + x1 + x2 + x1*x2*.1))

logistic_cal(y = dat$y, p = p)
</code></pre>

<hr>
<h2 id='logit'>Logit transformation</h2><span id='topic+logit'></span>

<h3>Description</h3>

<p>Logit transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logit_+3A_mu">mu</code></td>
<td>
<p>vector of numeric values between 0 and 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logit transformed mu (log(mu/(1-mu)))
</p>

<hr>
<h2 id='lowess_cal'>calibration curve via <code>lowess</code></h2><span id='topic+lowess_cal'></span>

<h3>Description</h3>

<p>uses <code>lowess</code> with <code>iter</code> = 0; as done in the <code>rms</code> package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lowess_cal(p, y, x, xp, save_data = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lowess_cal_+3A_p">p</code></td>
<td>
<p>predicted probabilities</p>
</td></tr>
<tr><td><code id="lowess_cal_+3A_y">y</code></td>
<td>
<p>binary outcome</p>
</td></tr>
<tr><td><code id="lowess_cal_+3A_x">x</code></td>
<td>
<p>predictor (could be transformation of <code>p</code>)</p>
</td></tr>
<tr><td><code id="lowess_cal_+3A_xp">xp</code></td>
<td>
<p>values for plotting (same scale as <code>x</code>)</p>
</td></tr>
<tr><td><code id="lowess_cal_+3A_save_data">save_data</code></td>
<td>
<p>whether to save y, p, x, xp in the returned object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of class <code>lowess_cal</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pmcalibration)
# simulate some data
n &lt;- 500
dat &lt;- sim_dat(N = n, a1 = .5, a3 = .2)

# predictions
p &lt;- with(dat, invlogit(.5 + x1 + x2 + x1*x2*.1))

lowess_cal(y = dat$y, p = p, x = p, xp = NULL)
</code></pre>

<hr>
<h2 id='plot.pmcalibration'>Plot a calibration curve (<code>pmcalibration</code> object)</h2><span id='topic+plot.pmcalibration'></span>

<h3>Description</h3>

<p>This is for a quick and dirty calibration curve plot.
Alternatively you can use <code>get_cc()</code> to get the data required to plot the calibration curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pmcalibration'
plot(x, conf_level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pmcalibration_+3A_x">x</code></td>
<td>
<p>a <code>pmcalibration</code> calibration curve</p>
</td></tr>
<tr><td><code id="plot.pmcalibration_+3A_conf_level">conf_level</code></td>
<td>
<p>width of the confidence interval (0.95 gives 95% CI). Ignored if call to <code>pmcalibration</code> didn't request confidence intervals</p>
</td></tr>
<tr><td><code id="plot.pmcalibration_+3A_...">...</code></td>
<td>
<p>other args for <code>plot()</code> (<code>lim</code> and <code>lab</code> can be specified)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pmcalibration)
# simulate some data with a binary outcome
n &lt;- 500
dat &lt;- sim_dat(N = n, a1 = .5, a3 = .2)
head(dat)
# predictions
p &lt;- with(dat, invlogit(.5 + x1 + x2 + x1*x2*.1))

# fit calibration curve
cal &lt;- pmcalibration(y = dat$y, p = p, smooth = "gam", k = 20, ci = "pw")

plot(cal)
</code></pre>

<hr>
<h2 id='pmcalibration'>Create a calibration curve</h2><span id='topic+pmcalibration'></span>

<h3>Description</h3>

<p>Assess calibration of clinical prediction models (agreement between predicted and observed probabilities) via different smooths. Binary and time-to-event outcomes are supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmcalibration(
  y,
  p,
  smooth = c("none", "ns", "bs", "rcs", "gam", "lowess", "loess"),
  time = NULL,
  ci = c("sim", "boot", "pw", "none"),
  n = 1000,
  transf = NULL,
  eval = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmcalibration_+3A_y">y</code></td>
<td>
<p>a binary or a right-censored time-to-event outcome. Latter must be an object created via <code>survival::Surv</code>.</p>
</td></tr>
<tr><td><code id="pmcalibration_+3A_p">p</code></td>
<td>
<p>predicted probabilities from a clinical prediction model. For a time-to-event object <code>time</code> must be specified and <code>p</code> are predicted probabilities of the outcome happening by <code>time</code> units of time follow-up.</p>
</td></tr>
<tr><td><code id="pmcalibration_+3A_smooth">smooth</code></td>
<td>
<p>what smooth to use. Available options:
</p>

<ul>
<li><p>'rcs' = restricted cubic spline using <code>rms::rcs</code>. Optional arguments for this smooth are <code>nk</code> (number of knots; defaults to 5) and <code>knots</code> (knot positions; set by <code>Hmisc::rcs.eval</code> if not specified) 
</p>
</li>
<li><p>'ns' = natural spline using <code>splines::ns</code>. Optional arguments are <code>df</code> (default = 6), <code>knots</code>, <code>Boundary.knots</code> (see <code>?splines::ns</code>) 
</p>
</li>
<li><p>'bs' = B-spline using <code>splines::bs</code>. Optional arguments are <code>df</code> (default = 6), <code>knots</code>, <code>Boundary.knots</code> (see <code>?splines::bs</code>) 
</p>
</li>
<li><p>'gam' = generalized additive model via <code>mgcv::gam</code> and <code>mgcv::s</code>. Optional arguments are <code>bs</code>, <code>k</code>, <code>fx</code>, <code>method</code> (see <code>?mgcv::gam</code> and  <code>?mgcv::s</code>) 
</p>
</li>
<li><p>'lowess' = uses <code>lowess(x, y, iter = 0)</code> based on <code>rms::calibrate</code>. Only for binary outcomes.
</p>
</li>
<li><p>'loess' = uses <code>loess</code> with all defaults. Only for binary outcomes. 
</p>
</li>
<li><p>'none' = logistic or Cox regression with single predictor variable (for binary outcome performs logistic calibration when <code>transf = "logit"</code>). See <code><a href="#topic+logistic_cal">logistic_cal</a></code> 
</p>
</li></ul>

<p>'rcs', 'ns', 'bs', and 'none' are fit via <code>glm</code> or <code>survival::coxph</code> and 'gam' is fit via <code>mgcv::gam</code> with <code>family = Binomial(link="logit")</code> for a binary outcome or <code>mgcv::cox.ph</code> when <code>y</code> is time-to-event.</p>
</td></tr>
<tr><td><code id="pmcalibration_+3A_time">time</code></td>
<td>
<p>what follow up time do the predicted probabilities correspond to? Only used if <code>y</code> is a <code>Surv</code> object</p>
</td></tr>
<tr><td><code id="pmcalibration_+3A_ci">ci</code></td>
<td>
<p>what kind of confidence intervals to compute?
</p>

<ul>
<li><p>'sim' = simulation based inference. Note this is currently only available for binary outcomes. <code>n</code> samples are taken from a multivariate normal distribution with mean vector = coef(mod) and variance covariance = vcov(model).
</p>
</li>
<li><p>'boot' = bootstrap resampling with <code>n</code> replicates. <code>y</code> and <code>p</code> are sampled with replacement and the calibration curve is reestimated. If <code>knots</code> are specified the same knots are used for each resample (otherwise they are calculated using resampled <code>p</code> or transformation thereof)
</p>
</li>
<li><p>'pw' = pointwise confidence intervals calculated via the standard errors produced by relevant <code>predict</code> methods. Only for plotting curves; if selected, CIs are not produced for metrics (not available for smooth = 'lowess')
</p>
</li></ul>

<p>Calibration metrics are calculated using each simulation or boot sample. For both options percentile confidence intervals are returned.</p>
</td></tr>
<tr><td><code id="pmcalibration_+3A_n">n</code></td>
<td>
<p>number of simulations or bootstrap resamples</p>
</td></tr>
<tr><td><code id="pmcalibration_+3A_transf">transf</code></td>
<td>
<p>transformation to be applied to <code>p</code> prior to fitting calibration curve. Valid options are 'logit', 'cloglog', 'none', or a function (must retain order of <code>p</code>). If unspecified defaults to 'logit' for binary outcomes and 'cloglog' (complementary log-log) for time-to-event outcomes.</p>
</td></tr>
<tr><td><code id="pmcalibration_+3A_eval">eval</code></td>
<td>
<p>number of points (equally spaced between <code>min(p)</code> and <code>max(p)</code>) to evaluate for plotting (0 or NULL = no plotting). Can be a vector of probabilities.</p>
</td></tr>
<tr><td><code id="pmcalibration_+3A_...">...</code></td>
<td>
<p>additional arguments for particular smooths. For ci = 'boot' the user is able to run samples in parallel (using the <code>parallel</code> package) by specifying a <code>cores</code> argument</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>pmcalibration</code> object containing calibration metrics and values for plotting
</p>


<h3>References</h3>

<p>Austin P. C., Steyerberg E. W. (2019) The Integrated Calibration Index (ICI) and related metrics for quantifying the calibration of logistic regression models. <em>Statistics in Medicine</em>. 38, pp. 1–15. https://doi.org/10.1002/sim.8281
</p>
<p>Van Calster, B., Nieboer, D., Vergouwe, Y., De Cock, B., Pencina M., Steyerberg E.W. (2016). A calibration hierarchy for risk models was defined: from utopia to empirical data. <em>Journal of Clinical Epidemiology</em>, 74, pp. 167-176. https://doi.org/10.1016/j.jclinepi.2015.12.005
</p>
<p>Austin, P. C., Harrell Jr, F. E., &amp; van Klaveren, D. (2020). Graphical calibration curves and the integrated calibration index (ICI) for survival models. <em>Statistics in Medicine</em>, 39(21), 2714-2742. https://doi.org/10.1002/sim.8570
</p>


<h3>Examples</h3>

<pre><code class='language-R'># binary outcome -------------------------------------
library(pmcalibration)
# simulate some data
n &lt;- 500
dat &lt;- sim_dat(N = n, a1 = .5, a3 = .2)
head(dat)
# predictions
p &lt;- with(dat, invlogit(.5 + x1 + x2 + x1*x2*.1))

# fit calibration curve
cal &lt;- pmcalibration(y = dat$y, p = p, smooth = "gam", k = 20, ci = "pw")

summary(cal)

plot(cal)

# time to event outcome -------------------------------------
library(pmcalibration)
if (requireNamespace("survival", quietly = TRUE)){
library(survival)

data('transplant', package="survival")
transplant &lt;- na.omit(transplant)
transplant = subset(transplant, futime &gt; 0)
transplant$ltx &lt;- as.numeric(transplant$event == "ltx")

# get predictions from coxph model at time = 100
# note that as we are fitting and evaluating the model on the same data
# this is internal calibration (see vignette("internal-validation", package = "pmcalibration"))
cph &lt;- coxph(Surv(futime, ltx) ~ age + sex + abo + year, data = transplant)

time &lt;- 100
newd &lt;- transplant; newd$futime &lt;- time; newd$ltx &lt;- 1
p &lt;- 1 - exp(-predict(cph, type = "expected", newdata=newd))
y &lt;- with(transplant, Surv(futime, ltx))

cal &lt;- pmcalibration(y = y, p = p, smooth = "rcs", nk=5, ci = "pw", time = time)

summary(cal)

plot(cal)

}
</code></pre>

<hr>
<h2 id='predict_lowess'>Get predictions from <code>loewss</code> fit</h2><span id='topic+predict_lowess'></span>

<h3>Description</h3>

<p>Adapted from <code>rms:::calibrate.default</code>
Uses <code>approx</code> with <code>rule</code> = 2 so that x out of range of initial lowess fit returns min or max (see ?approx)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_lowess(fit, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_lowess_+3A_fit">fit</code></td>
<td>
<p>list produced by <code>lowess</code></p>
</td></tr>
<tr><td><code id="predict_lowess_+3A_x">x</code></td>
<td>
<p>values to produce predictions for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>predicted values
</p>

<hr>
<h2 id='print.logistic_cal'>Print a <code>logistic_cal</code> object</h2><span id='topic+print.logistic_cal'></span>

<h3>Description</h3>

<p>Print a <code>logistic_cal</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'logistic_cal'
print(x, digits = 2, conf_level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.logistic_cal_+3A_x">x</code></td>
<td>
<p>a <code>logistic_cal</code> object</p>
</td></tr>
<tr><td><code id="print.logistic_cal_+3A_digits">digits</code></td>
<td>
<p>number of digits to print</p>
</td></tr>
<tr><td><code id="print.logistic_cal_+3A_conf_level">conf_level</code></td>
<td>
<p>width of the confidence interval (0.95 gives 95% CI)</p>
</td></tr>
<tr><td><code id="print.logistic_cal_+3A_...">...</code></td>
<td>
<p>optional arguments passed to print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints a summary
</p>

<hr>
<h2 id='print.logistic_calsummary'>Print a logistic_cal summary</h2><span id='topic+print.logistic_calsummary'></span>

<h3>Description</h3>

<p>Print a logistic_cal summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'logistic_calsummary'
print(x, digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.logistic_calsummary_+3A_x">x</code></td>
<td>
<p>a <code>logistic_calsummary</code> object</p>
</td></tr>
<tr><td><code id="print.logistic_calsummary_+3A_digits">digits</code></td>
<td>
<p>number of digits to print</p>
</td></tr>
<tr><td><code id="print.logistic_calsummary_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints a summary
</p>

<hr>
<h2 id='print.pmcalibration'>print a pmcalibration object</h2><span id='topic+print.pmcalibration'></span>

<h3>Description</h3>

<p>print a pmcalibration object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pmcalibration'
print(x, digits = 2, conf_level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.pmcalibration_+3A_x">x</code></td>
<td>
<p>a <code>pmcalibration</code> object</p>
</td></tr>
<tr><td><code id="print.pmcalibration_+3A_digits">digits</code></td>
<td>
<p>number of digits to print</p>
</td></tr>
<tr><td><code id="print.pmcalibration_+3A_conf_level">conf_level</code></td>
<td>
<p>width of the confidence interval (0.95 gives 95% CI)</p>
</td></tr>
<tr><td><code id="print.pmcalibration_+3A_...">...</code></td>
<td>
<p>optional arguments passed to print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints a summary
</p>

<hr>
<h2 id='print.pmcalibrationsummary'>Print summary of pmcalibration object</h2><span id='topic+print.pmcalibrationsummary'></span>

<h3>Description</h3>

<p>Print summary of pmcalibration object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pmcalibrationsummary'
print(x, digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.pmcalibrationsummary_+3A_x">x</code></td>
<td>
<p>a <code>pmcalibrationsummary</code> object</p>
</td></tr>
<tr><td><code id="print.pmcalibrationsummary_+3A_digits">digits</code></td>
<td>
<p>number of digits to print</p>
</td></tr>
<tr><td><code id="print.pmcalibrationsummary_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible(x) - prints a summary
</p>

<hr>
<h2 id='reg_spline_X'>Make a design matrix for regression spline</h2><span id='topic+reg_spline_X'></span>

<h3>Description</h3>

<p>Make a design matrix for regression spline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reg_spline_X(x, xp, smooth, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reg_spline_X_+3A_x">x</code></td>
<td>
<p>values of the predictor</p>
</td></tr>
<tr><td><code id="reg_spline_X_+3A_xp">xp</code></td>
<td>
<p>values of the predictor for plotting the calibration curve</p>
</td></tr>
<tr><td><code id="reg_spline_X_+3A_smooth">smooth</code></td>
<td>
<p>spline to use (<code>rms::rcs</code>, <code>splines::ns</code>, <code>splines::bs</code> currently supported via 'rcs', 'ns', 'bs'). <code>smooth</code> = 'none' results in <code>x</code> as only predictor (i.e., no spline)</p>
</td></tr>
<tr><td><code id="reg_spline_X_+3A_...">...</code></td>
<td>
<p>additional arguments for specific splines ('nk' or 'knots' for 'rcs', 'df' or 'knots' for 'ns' or 'bs')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing
</p>

<ul>
<li><p><code>X</code> the design matrix for the data
</p>
</li>
<li><p><code>Xp</code> the design matrix for plotting
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
xp &lt;- seq(min(x), max(x), length.out=50)
reg_spline_X(x = x, xp = xp, smooth="rcs", nk=6)
</code></pre>

<hr>
<h2 id='run_boots'>Wrapper to run bootstrap resamples using <code>parallel</code></h2><span id='topic+run_boots'></span>

<h3>Description</h3>

<p>Wrapper to run bootstrap resamples using <code>parallel</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_boots(cal, R = 1000, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_boots_+3A_cal">cal</code></td>
<td>
<p>an object created with one of the <code>_cal</code> functions</p>
</td></tr>
<tr><td><code id="run_boots_+3A_r">R</code></td>
<td>
<p>number of resamples (default = 1000)</p>
</td></tr>
<tr><td><code id="run_boots_+3A_cores">cores</code></td>
<td>
<p>number of cores (for <code>parallel</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list created by one of the <code>boot.</code> functions
</p>

<hr>
<h2 id='sim_dat'>Simulate a binary outcome with either a quadratic relationship or interaction</h2><span id='topic+sim_dat'></span>

<h3>Description</h3>

<p>Function for simulating data either with a single 'predictor' variable with a quadratic relationship with logit(p)
or two predictors that interact (see references for examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_dat(N, a1, a2 = NULL, a3 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_dat_+3A_n">N</code></td>
<td>
<p>number of observations to simulate</p>
</td></tr>
<tr><td><code id="sim_dat_+3A_a1">a1</code></td>
<td>
<p>value of the intercept term (in logits). This must be provided along with either <code>a2</code> or <code>a3</code>.</p>
</td></tr>
<tr><td><code id="sim_dat_+3A_a2">a2</code></td>
<td>
<p>value of the quadratic coefficient. If specified the linear predictor is simulated as follows: <code>LP &lt;- a1 + x1 + a2*x1^2</code> where <code>x1</code> is sampled from a standard normal distribution.</p>
</td></tr>
<tr><td><code id="sim_dat_+3A_a3">a3</code></td>
<td>
<p>value of the interaction coefficient. If specified the linear predictor is simulated as follows: <code>LP &lt;- a1 + x1 + x2 + x1*x2*a3</code> where <code>x1</code> and <code>x2</code> are sampled from independent standard normal distributions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a simulated data set with <code>N</code> rows. Can be split into 'development' and 'validation' sets.
</p>


<h3>References</h3>

<p>Austin, P. C., &amp; Steyerberg, E. W. (2019). The Integrated Calibration Index (ICI) and related metrics for quantifying the calibration of logistic regression models. Statistics in medicine, 38(21), 4051-4065.
</p>
<p>Rhodes, S. (2022, November 4). Using restricted cubic splines to assess the calibration of clinical prediction models: Logit transform predicted probabilities first. https://doi.org/10.31219/osf.io/4n86q
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pmcalibration)
# simulate some data with a binary outcome
n &lt;- 500
dat &lt;- sim_dat(N = n, a1 = .5, a3 = .2)

head(dat) # LP = linear predictor

</code></pre>

<hr>
<h2 id='simb'>Simulation based inference with a calibration curve object</h2><span id='topic+simb'></span><span id='topic+simb.glm_cal'></span><span id='topic+simb.gam_cal'></span><span id='topic+simb.lowess_cal'></span><span id='topic+simb.loess_cal'></span>

<h3>Description</h3>

<p>Simulation based inference with a calibration curve object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simb(cal, R)

## S3 method for class 'glm_cal'
simb(cal, R = 1000)

## S3 method for class 'gam_cal'
simb(cal, R = 1000)

## S3 method for class 'lowess_cal'
simb(cal, R)

## S3 method for class 'loess_cal'
simb(cal, R)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simb_+3A_cal">cal</code></td>
<td>
<p>an object created using one of the <code>cal</code> functions</p>
</td></tr>
<tr><td><code id="simb_+3A_r">R</code></td>
<td>
<p>number of simulated replicates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>simulated calibration metrics and values for plotting
</p>

<hr>
<h2 id='summary.logistic_cal'>Summarize a logistic_cal object</h2><span id='topic+summary.logistic_cal'></span>

<h3>Description</h3>

<p>Summarize a logistic_cal object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'logistic_cal'
summary(object, conf_level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.logistic_cal_+3A_object">object</code></td>
<td>
<p>a <code>logistic_cal</code> object</p>
</td></tr>
<tr><td><code id="summary.logistic_cal_+3A_conf_level">conf_level</code></td>
<td>
<p>width of the confidence interval (0.95 gives 95% CI)</p>
</td></tr>
<tr><td><code id="summary.logistic_cal_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimates and conf_level*100 confidence intervals for calibration intercept and calibration slope.
The former is estimated from a <code>glm</code> (family = binomial(&quot;logit&quot;)) where the linear predictor (logit(p)) is included as an offset.
</p>

<hr>
<h2 id='summary.pmcalibration'>Summarize a pmcalibration object</h2><span id='topic+summary.pmcalibration'></span>

<h3>Description</h3>

<p>Summarize a pmcalibration object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pmcalibration'
summary(object, conf_level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.pmcalibration_+3A_object">object</code></td>
<td>
<p>object created with <code>pmcalibration</code></p>
</td></tr>
<tr><td><code id="summary.pmcalibration_+3A_conf_level">conf_level</code></td>
<td>
<p>width of the confidence interval (0.95 gives 95% CI). Ignored if call to <code>pmcalibration</code> didn't request confidence intervals</p>
</td></tr>
<tr><td><code id="summary.pmcalibration_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints a summary of calibration metrics. Returns a list of two tables: <code>metrics</code> and <code>plot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pmcalibration)
# simulate some data with a binary outcome
n &lt;- 500
dat &lt;- sim_dat(N = n, a1 = .5, a3 = .2)
head(dat)
# predictions
p &lt;- with(dat, invlogit(.5 + x1 + x2 + x1*x2*.1))

# fit calibration curve
cal &lt;- pmcalibration(y = dat$y, p = p, smooth = "gam", k = 20, ci = "pw")

summary(cal)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
