<!DOCTYPE html><html><head><title>Help for package c212</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {c212}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#c212-package'><p>Methods for the Detection of Safety Signals in Randomised Controlled Trials using Groupings.</p></a></li>
<li><a href='#c212.1a'><p>Implementation of the Berry and Berry Three-Level Hierarchical Model without Point-Mass.</p></a></li>
<li><a href='#c212.1a.interim'><p>A Two or Three-Level Hierarchical Body-system based Model for interim analysis without Point-Mass.</p></a></li>
<li><a href='#c212.BB'><p>Implementation of the Berry and Berry Three-Level Hierarchical Model.</p></a></li>
<li><a href='#c212.BB.interim'><p>A Two or Three-Level Hierarchical Body-system based Model for interim analysis with Point-Mass.</p></a></li>
<li><a href='#c212.BH'><p>Implementation of Benjamini-Hochberg procedure for False Discovery Rate control</p></a></li>
<li><a href='#c212.BH.adjust.pvals'><p>Benjamini-Hochberg procedure adjusted p-values</p></a></li>
<li><a href='#c212.bin.test'><p>Plot Raw Adverse Event Incidence Data</p></a></li>
<li><a href='#c212.BONF'><p>Implementation of Bonferroni correction for error control</p></a></li>
<li><a href='#c212.convergence.diag'><p>Convergence Diagnostics of the Simulation</p></a></li>
<li><a href='#c212.DFDR'><p>Implementation of the Double False Discovery Rate for controlling the False Discovery Rate.</p></a></li>
<li><a href='#c212.err.cntrl'><p>Implementaion of Group Bonferroni-Hochberg procedure for control of the False Discovery Rate</p></a></li>
<li><a href='#c212.FDR.data'><p>Fisher Test p-values for End of Trial Data Clinical Data</p></a></li>
<li><a href='#c212.fisher.test'><p>Fisher Exact Test</p></a></li>
<li><a href='#c212.GBH'><p>Implementaion of Group Bonferroni-Hochberg procedure for control of the False Discovery Rate</p></a></li>
<li><a href='#c212.gen.initial.values'><p>Generate a template simulation initial values.</p></a></li>
<li><a href='#c212.global.sim.params'><p>Generate a template for the individual model parameter simulation control parameters.</p></a></li>
<li><a href='#c212.hyper.params'><p>Generate a template for the individual model parameter simulation control parameters.</p></a></li>
<li><a href='#c212.interim.1a.hier2'><p>A Two-Level Hierarchical Body-system based Model for interim analysis without Point-Mass.</p></a></li>
<li><a href='#c212.interim.1a.hier3'><p>A Three-Level Hierarchical Body-system based Model for interim analysis without Point-Mass.</p></a></li>
<li><a href='#c212.interim.BB.hier2'><p>A Three-Level Hierarchical Body-system based Model for interim analysis with Point-Mass.</p></a></li>
<li><a href='#c212.interim.BB.hier3'><p>A Three-Level Hierarchical Body-system based Model for interim analysis with Point-Mass.</p></a></li>
<li><a href='#c212.interim.MLE'><p>Poisson Maximum Likelihood Estimator</p></a></li>
<li><a href='#c212.LSL'>
<p>Implementaion of the least-slope estimator estimator (LSL) for the proportion of true null hypotheses.</p></a></li>
<li><a href='#c212.monitor.samples'><p>Generate a template for choosing which samples to monitor.</p></a></li>
<li><a href='#c212.NOADJ'><p>Unadjusted test of multiple hypotheses.</p></a></li>
<li><a href='#c212.plot.eot.data'><p>Plot Adverse Event Incidence Data</p></a></li>
<li><a href='#c212.plot.interim.data.rd'><p>Plot Adverse Event Count Data for a Body-system by Interval</p></a></li>
<li><a href='#c212.plot.samples'><p>Plot Posterior Distribution</p></a></li>
<li><a href='#c212.pointmass.weights'><p>Generate a template for the point-mass weightings.</p></a></li>
<li><a href='#c212.print.convergence.summary'><p>Print a Summary of the Convergence Diagnostics of the Simulation</p></a></li>
<li><a href='#c212.print.summary.stats'><p>Print the Summary Statistics of Posterior Distributions</p></a></li>
<li><a href='#c212.ptheta'><p>Reports the posterior probability that theta (the increase in the log-odds) is greater than zero for each Adverse Event</p></a></li>
<li><a href='#c212.sim.control.params'><p>Generate a template for the individual model parameter simulation control parameters.</p></a></li>
<li><a href='#c212.ssBH'><p>Implementation of Subset Benjamini-Hochberg for False Discover Rate control</p></a></li>
<li><a href='#c212.summary.stats'><p>Summary Statistics for the Posterior Distributions in the model.</p></a></li>
<li><a href='#c212.trial.data'><p>End of Trial Data Clinical Data for Adverse Event Incidence</p></a></li>
<li><a href='#c212.trial.interval.data1'><p>Interim analysis trial data.</p></a></li>
<li><a href='#c212.trial.interval.data2'><p>Interim analysis trial data.</p></a></li>
<li><a href='#c212.TST'>
<p>Implementaion of the two-stage estimator (TST) for the proportion of true null hypotheses.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Methods for Detecting Safety Signals in Clinical Trials Using
Body-Systems (System Organ Classes)</td>
</tr>
<tr>
<td>Version:</td>
<td>0.98</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-09-04</td>
</tr>
<tr>
<td>Author:</td>
<td>Raymond Carragher <a href="https://orcid.org/0000-0002-0120-625X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Raymond Carragher &lt;rcarragh@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>coda</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for detecting safety signals in clinical trials using groupings of adverse events by body-system or system organ class. This work was supported by the Engineering and Physical Sciences Research Council (UK) (EPSRC) [award reference 1521741] and Frontier Science (Scotland) Ltd. The package title c212 is in reference to the original Engineering and Physical Sciences Research Council (UK) funded project which was named CASE 2/12.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-09-04 21:18:07 UTC; clb13102</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-09-08 12:40:20 UTC</td>
</tr>
</table>
<hr>
<h2 id='c212-package'>Methods for the Detection of Safety Signals in Randomised Controlled Trials using Groupings.</h2><span id='topic+c212-package'></span>

<h3>Description</h3>

<p>This package implements a number of methods for the detection of safety signals in Clinical Trials based on
groupings of adverse events by body-system or system organ class.
The methods include an implementation of the Three-Level Hierarchical model for
Clinical Trial Adverse Event Incidence Data of Berry and Berry (2004)
and an implementation of the same model without the Point Mass (Model 1a from Xia et al (2011)), extended Bayesian hierarchical methods
based on system organ class or body-system groupings for interim analyses.
The package also implements a number of methods for error control when testing multiple hypotheses, specifically control of the False
Discovery Rate (FDR). The FDR control methods implemented are the Benjamini-Hochberg procedure, the Double False Discovery Rate, the Group
Benjamini-Hochberg and subset Benjamini-Hochberg methods. Also included are the Bonferroni correction and the unadjusted testing procedure.</p>


<h3>Details</h3>

<p>The methods implemented use assumed groupings of adverse events by body-system or system organ class to 
detect differences in the occurrence of adverse events on trial arms. Methods based on Bayesian Hierarchical
models and  direct error controlling procedures are provided.
</p>
<p>The basic (Bayesian) hierarchical models are described in Berry and Berry (2004), Xia et al (2011) (Model 1a) and
Berry et al (2010). These methods are extended for interim analyses.
</p>
<p>The direct error controlling methods are designed to control the number of Type-I errors at an acceptable level
without compromising the power. If the Familywise Error Rate (FWER) is defined as the probability of making
one or more Type-I errors when analysing multiple hypotheses (the “family”), then an alternative to controlling the FWER is to control the
False Discovery Rate (FDR) - the expected proportion of false discoveries (Type-I errors) to the total number of discoveries. 
Essentially control of the FDR assumes that when many of the tested hypotheses are rejected it may be preferable to control the proportion
of errors rather than the probability of making even one error. This is expected to lead to a gain in power. 
Further FDR controlling methods which use the information available in groupings of hypotheses have been developed (Double False Discovery
Rate (Mehrotra and Adewale (2012)), Group Benjamini-Hochberg (Hu, Zhao and Zhou (2010))).
For the methods contained in this package control of the False Discovery Rate has been established for independent test statistics and some forms of positive dependency (positive regression dependency), apart from the case of the Group Benjamini-Hochberg procedure where the control is asymptotic. Further details can be found in the references.
</p>


<h3>Author(s)</h3>

<p>R. Carragher&lt;raymond.carragher@strath.ac.uk; rcarragh@gmail.com&gt;
</p>


<h3>References</h3>

<p>S. M. Berry and D. A. Berry (2004). Accounting for multiplicities in assessing drug safety: a three-
level hierarchical mixture model.
Biometrics, 60(2):418-26.
</p>
<p>H. Amy Xia, Haijun Ma, and Bradley P. Carlin (2011). Bayesian hierarchical modelling for
detecting safety signals in clinical trials. Journal of Biopharmaceutical Statistics, 21(5):1006–
1029.
</p>
<p>Scott M. Berry, Bradley P. Carlin, J. Jack Lee, and Peter M¨ller (2010). Bayesian adaptive
methods for clinical trials. CRC Press.
</p>
<p>Benjamini, Yoav and Hochberg, Yosef, (1995).
Controlling the False Discovery Rate: A Practical and Powerful Approach to Multiple Testing.
Journal of the Royal Statistical Society. Series B (Methodological), 57(1):289-300.
</p>
<p>D. V. Mehrotra and J. F. Heyse (2004). Use of the false discovery rate for evaluating clinical
safety data. Stat Methods Med Res, 13(3):227–38, 2004.
</p>
<p>Mehrotra, D. V. and Adewale, A. J. (2012). Flagging clinical adverse experiences: reducing false discoveries without materially compromising power for detecting true signals. Stat Med, 31(18):1918-30.
</p>
<p>Hu, J. X. and Zhao, H. and Zhou, H. H. (2010). False Discovery Rate Control With Groups. J Am Stat Assoc, 105(491):1215-1227.
</p>
<p>Y. Benjamini, A. M. Krieger, and D. Yekutieli (2006). Adaptive linear step-up procedures that
control the false discovery rate. Biometrika, 93(3):491–507.
</p>
<p>Benjamini Y, Hochberg Y. (2000). On the Adaptive Control of the False Discovery Rate in Multiple Testing
With Independent Statistics. Journal of Educational and Behavioral Statistics, 25(1):60–83.
</p>
<p>Yekutieli, Daniel (2008). False discovery rate control for non-positively regression dependent test statistics. Journal of Statistical Planning and Inference, 138(2):405-415.
</p>
<p>Matthews, John N. S. (2006) Introduction to Randomized Controlled Clinical Trials, Second Edition. Chapman &amp; Hall/CRC Texts in Statistical Science.
</p>

<hr>
<h2 id='c212.1a'>Implementation of the Berry and Berry Three-Level Hierarchical Model without Point-Mass.</h2><span id='topic+c212.1a'></span>

<h3>Description</h3>

<p>Implementaion of Berry and Berry model without the point-mass (Model 1a Xia et al (2011))</p>


<h3>Usage</h3>

<pre><code class='language-R'>	c212.1a(trial.data, sim_type = "SLICE", burnin = 10000, iter = 40000,
	nchains = 3,
	global.sim.params = data.frame(type = c("MH", "SLICE"),
	param = c("sigma_MH", "w"),
	value = c(0.35,1), control = c(0,6), stringsAsFactors = FALSE),
	sim.params = NULL,
	initial_values = NULL,
	hyper_params = list(mu.gamma.0.0 = 0, tau2.gamma.0.0 = 10,
	mu.theta.0.0 = 0, tau2.theta.0.0 = 10, alpha.gamma.0.0 = 3,
	beta.gamma.0.0 = 1, alpha.theta.0.0 = 3, beta.theta.0.0 = 1,
	alpha.gamma = 3, beta.gamma = 1,
	alpha.theta = 3, beta.theta = 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.1a_+3A_trial.data">trial.data</code></td>
<td>

<p>A file or data frame containing the trial data. It must contain must contain the columns <em>B</em> (body-system), <em>AE</em> (adverse event), <em>Group</em> (1 - control, 2 treatment), <em>Count</em> (total number of events), <em>Total</em> (total number of participants in the trial
arm).
</p>
</td></tr>
<tr><td><code id="c212.1a_+3A_sim_type">sim_type</code></td>
<td>

<p>The type of MCMC method to use for simulating from non-standard distributions. Allowed values are <em>&quot;MH&quot;</em>
and <em>&quot;SLICE&quot;</em> for Metropolis_Hastings and Slice sampling respectively.
</p>
</td></tr>
<tr><td><code id="c212.1a_+3A_burnin">burnin</code></td>
<td>

<p>The burnin period for the monte-carlo simulation. These are discarded from the returned samples.
</p>
</td></tr>
<tr><td><code id="c212.1a_+3A_iter">iter</code></td>
<td>

<p>The total number of iterations for which the monte-carlo simulation is run. This includes the burnin period.
The total number of samples returned is <em>iter - burnin</em>
</p>
</td></tr>
<tr><td><code id="c212.1a_+3A_nchains">nchains</code></td>
<td>

<p>The number of independent chains to run.
</p>
</td></tr>
<tr><td><code id="c212.1a_+3A_global.sim.params">global.sim.params</code></td>
<td>

<p>A data frame containing the parameters for the simulation type <em>sim_type</em>. For <em>&quot;MH&quot;</em> the parameter
is the variance of the normal distribution used to simulate the next candidate value centred on the current
value. For <em>&quot;SLICE&quot;</em> the parameters are the estimated width of the slice and a value limiting the search for the next sample.
</p>
</td></tr>
<tr><td><code id="c212.1a_+3A_sim.params">sim.params</code></td>
<td>

<p>A dataframe containing simulation parameters which override the global simulation parameters (<em>global.sim.params</em>) for particular model
parameters. <em>sim.params</em> must contain the following columns: type: the simulation type (&quot;MH&quot; or &quot;SLICE&quot;); variable: the model parameter 
for which the simulation parameters are being overridden; B: the body-system (if applicable); AE: the adverse event (if applicable);
param: the simulation parameter; value: the overridden value; control: the overridden control value.
</p>
<p>The function <em>c212.sim.control.params</em> generates a template for <em>sim.params</em> which can be edited by the user.
</p>
</td></tr>
<tr><td><code id="c212.1a_+3A_initial_values">initial_values</code></td>
<td>

<p>The initial values for starting the chains. If NULL (the default) is passed the function generates the initial
values for the chains. initial_values is a list with the following format:
</p>
<pre>
list(gamma, theta, mu.gamma, mu.theta, sigma2.gamma,
sigma2.theta, mu.gamma.0, mu.theta.0, tau2.gamma.0,
tau2.theta.0)
</pre>
<p>where each element of the list is either a dataframe or array.
The function <em>c212.gen.initial.values</em> can be used to generate a template for the list which can be updated by the user if required.
The formats of the list elements are as follows:
</p>
<p><em>gamma, theta</em>: dataframe with columns <em>B</em>, <em>AE</em>, <em>chain</em>, <em>value</em>
</p>
<p><em>mu.gamma, mu.theta, sigma2.gamma, sigma2.theta</em>: dataframe with columns <em>B</em>, <em>chain</em>, <em>value</em>
</p>
<p><em>mu.gamma.0, mu.theta.0, tau2.gamma.0, tau2.theta.0</em>: array of size <em>chain</em>.
</p>
</td></tr>
<tr><td><code id="c212.1a_+3A_hyper_params">hyper_params</code></td>
<td>

<p>The hyperparameters for the model. The default hyperparameters are those given in Berry and Berry 2004.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is fitted by a Gibbs sampler. The details of the complete conditional densities are given in Berry
and Berry (2004). The posterior distributions for <em>gamma</em> and <em>theta</em> are sampled with either a Metropolis-Hastings step or a
slice sampler.
</p>


<h3>Value</h3>

<p>The output from the simulation including all the sampled values is as follows:
</p>
<pre>
list(id, sim_type, chains, nBodySys, maxAEs, nAE, AE, B, burnin,
	iter, mu.gamma.0, mu.theta.0, tau2.gamma.0, tau2.theta.0,
	mu.gamma, mu.theta, sigma2.gamma, sigma2.theta, gamma,
	theta, gamma_acc, theta_acc)
</pre>
<p>where
</p>
<p><em>id</em> - a string identifying the version of the function
</p>
<p><em>sim_type</em> - an string identifying the sampling method used for non-standard distributions, either <em>&quot;MH&quot;</em> or <em>&quot;SLICE&quot;</em>
</p>
<p><em>chains</em> - the number of chains for which the simulation was run
</p>
<p><em>nBodySys</em> - the number of body-systems
</p>
<p><em>maxAEs</em> - the maximum number of AEs in a body-system
</p>
<p><em>nAE</em> - an array. The number of AEs in each body-system.
</p>
<p><em>AE</em> - an array of dimension <em>nBodySys</em>, <em>maxAEs</em>. The Adverse Events.
</p>
<p><em>B</em> - an array. The body-systems.
</p>
<p><em>burnin</em> - the burnin period for the simulation.
</p>
<p><em>iter</em> - the total number of iterations in the simulation.
</p>
<p><em>mu.gamma.0</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
</p>
<p><em>mu.theta.0</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
</p>
<p><em>tau2.gamma.0</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
</p>
<p><em>tau2.theta.0</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
</p>
<p><em>mu.gamma</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>mu.theta</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>sigma2.gamma</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>sigma2.theta</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>gamma</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>, <em>iter - burnin</em>
</p>
<p><em>theta</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>, <em>iter - burnin</em>
</p>
<p><em>gamma_acc</em> - the acceptance rate for the gamma samples if a Metropolis-Hastings method is used. An array of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>
</p>
<p><em>theta_acc</em> - the acceptance rate for the theta samples if a Metropolis-Hastings method is used. An array of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>
</p>


<h3>Note</h3>

<p>The function performs the simulation and returns the raw output. No checks for convergence are performed. 
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>References</h3>

<p>S. M. Berry and D. A. Berry (2004). Accounting for multiplicities in assessing drug safety: a three-
level hierarchical mixture model.
Biometrics, 60(2):418-26.
</p>
<p>H. Amy Xia, Haijun Ma, and Bradley P. Carlin (2011). Bayesian hierarchical modelling for
detecting safety signals in clinical trials. Journal of Biopharmaceutical Statistics, 21(5):1006–
1029.
</p>
<p>Scott M. Berry, Bradley P. Carlin, J. Jack Lee, and Peter M¨ller (2010). Bayesian adaptive
methods for clinical trials. CRC Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(c212.trial.data)
raw = c212.1a(c212.trial.data, burnin = 100, iter = 200)
## Not run: 
data(c212.trial.data)
raw = c212.1a(c212.trial.data)

raw$B
[1] "Bdy-sys_1" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5" "Bdy-sys_6"
[7] "Bdy-sys_7" "Bdy-sys_8"

mean(rm$theta[2, 3,1,])
[1] 1.306362


## End(Not run)
</code></pre>

<hr>
<h2 id='c212.1a.interim'>A Two or Three-Level Hierarchical Body-system based Model for interim analysis without Point-Mass.</h2><span id='topic+c212.1a.interim'></span>

<h3>Description</h3>

<p>Implementation of a Two or Three-Level Hierarchical Body-system based Model for interim analysis without Point-Mass.</p>


<h3>Usage</h3>

<pre><code class='language-R'>	c212.1a.interim(trial.data, sim_type = "SLICE", burnin = 10000,
		iter = 40000, nchains = 3,
		global.sim.params = NULL,
		sim.params = NULL,
		monitor = NULL,
		initial_values = NULL,
		hier = 3,
		level = 1,
		hyper_params = NULL,
		memory_model = "HIGH")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.1a.interim_+3A_trial.data">trial.data</code></td>
<td>

<p>A file or data frame containing the trial data. It must contain must contain the columns <em>I_index</em> (interval index), <em>B</em> (body-system), <em>AE</em> (adverse event), <em>Group</em> (1 - control, 2 treatment), <em>Count</em> (total number of events), <em>Total</em> (total number of participants in the trial
arm).
</p>
</td></tr>
<tr><td><code id="c212.1a.interim_+3A_sim_type">sim_type</code></td>
<td>

<p>The type of MCMC method to use for simulating from non-standard distributions. Allowed values are <em>&quot;MH&quot;</em>
and <em>&quot;SLICE&quot;</em> for Metropolis_Hastings and Slice sampling respectively.
</p>
</td></tr>
<tr><td><code id="c212.1a.interim_+3A_burnin">burnin</code></td>
<td>

<p>The burnin period for the monte-carlo simulation. These are discarded from the returned samples.
</p>
</td></tr>
<tr><td><code id="c212.1a.interim_+3A_iter">iter</code></td>
<td>

<p>The total number of iterations for which the monte-carlo simulation is run. This includes the burnin period.
The total number of samples returned is <em>iter - burnin</em>
</p>
</td></tr>
<tr><td><code id="c212.1a.interim_+3A_nchains">nchains</code></td>
<td>

<p>The number of independent chains to run.
</p>
</td></tr>
<tr><td><code id="c212.1a.interim_+3A_global.sim.params">global.sim.params</code></td>
<td>

<p>A data frame containing the parameters for the simulation type <em>sim_type</em>. For <em>&quot;MH&quot;</em> the parameter
is the variance of the normal distribution used to simulate the next candidate value centred on the current
value. For <em>&quot;SLICE&quot;</em> the parameters are the estimated width of the slice and a value limiting the search for the next sample.
Passing NULL uses the model defaults.
</p>
</td></tr>
<tr><td><code id="c212.1a.interim_+3A_sim.params">sim.params</code></td>
<td>

<p>A dataframe containing simulation parameters which override the global simulation parameters (<em>global.sim.params</em>) for particular model
parameters. <em>sim.params</em> must contain the following columns: type: the simulation type (&quot;MH&quot; or &quot;SLICE&quot;); variable: the model parameter 
for which the simulation parameters are being overridden; B: the body-system (if applicable); AE: the adverse event (if applicable);
param: the simulation parameter; value: the overridden value; control: the overridden control value.
Passing NULL uses the model defaults.
</p>
<p>The function <em>c212.sim.control.params</em> generates a template for <em>sim.params</em> which can be edited by the user.
</p>
</td></tr>
<tr><td><code id="c212.1a.interim_+3A_monitor">monitor</code></td>
<td>

<p>A dataframe indicating which sets of If NULL is passed default parameters are variables to monitor.
Passing NULL uses the model defaults.
</p>
</td></tr>
<tr><td><code id="c212.1a.interim_+3A_initial_values">initial_values</code></td>
<td>

<p>The initial values for starting the chains. If NULL (the default) is passed the function generates the initial
values for the chains. initial_values is a list with the following format:
</p>
<pre>
list(gamma, theta, mu.gamma, mu.theta, sigma2.gamma,
	sigma2.theta, mu.gamma.0, mu.theta.0, tau2.gamma.0,
	tau2.theta.0)
</pre>
<p>where each element of the list is either a dataframe or array.
The function <em>c212.gen.initial.values</em> can be used to generate a template for the list which can be updated by the user if required.
The formats of the list elements are as follows:
</p>
<p><em>gamma, theta</em>: dataframe with columns <em>B</em>, <em>AE</em>, <em>chain</em>, <em>value</em>
</p>
<p><em>mu.gamma, mu.theta, sigma2.gamma, sigma2.theta</em>: dataframe with columns <em>B</em>, <em>chain</em>, <em>value</em>
</p>
<p><em>mu.gamma.0, mu.theta.0, tau2.gamma.0, tau2.theta.0</em>: array of size <em>chain</em>.
</p>
</td></tr>
<tr><td><code id="c212.1a.interim_+3A_hier">hier</code></td>
<td>

<p>Model using a two or three level hierarchy. 2 - two-level hierarchy, 3 - three level hierarchy.
</p>
</td></tr>
<tr><td><code id="c212.1a.interim_+3A_level">level</code></td>
<td>

<p>The level of longitudinal dependency between the intervals. Allowed values are 0, 1, 2 for a three-level hierarchy and 0, 1 for a two-level hierarchy.
0 - independent intervals, 1 - common interval body-system means, 2 - weak dependency.
</p>
</td></tr>
<tr><td><code id="c212.1a.interim_+3A_hyper_params">hyper_params</code></td>
<td>

<p>The hyperparameters for the model. The default hyperparameters are based on those given in Berry and Berry 2004.
Passing NULL uses the model defaults.
</p>
</td></tr>
<tr><td><code id="c212.1a.interim_+3A_memory_model">memory_model</code></td>
<td>

<p>Allowed values are &quot;HIGH&quot; and &quot;LOW&quot;. &quot;HIGH&quot; means use as much memory as possible. &quot;LOW&quot; means use the minimum amount of memory.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The models are fitted by Gibbs samplers.
The posterior distributions for <em>gamma</em> and <em>theta</em> are sampled with either a Metropolis-Hastings step or a slice sampler.
</p>


<h3>Value</h3>

<p>The output from the simulation including all the sampled values for the three-level hierarchy is as follows:
</p>
<pre>
list(id, sim_type, chains, nIntervals, Intervals, nBodySys, maxBs,
	maxAEs, nAE, AE, B, burnin, iter, monitor,
	mu.gamma.0, mu.theta.0, tau2.gamma.0, tau2.theta.0,
	mu.gamma, mu.theta, sigma2.gamma, sigma2.theta, gamma,
	theta, gamma_acc, theta_acc)
</pre>
<p>The output from the simulation including all the sampled values for the two-level hierarchy is as follows:
</p>
<pre>
list(id, sim_type, chains, nIntervals, Intervals, nBodySys, maxBs,
	maxAEs, nAE, AE, B, burnin, iter, monitor,
	mu.gamma, mu.theta, sigma2.gamma, sigma2.theta, gamma,
	theta, gamma_acc, theta_acc)
</pre>
<p>where
</p>
<p><em>id</em> - a string identifying the version of the function
</p>
<p><em>sim_type</em> - an string identifying the sampling method used for non-standard distributions, either <em>&quot;MH&quot;</em> or <em>&quot;SLICE&quot;</em>
</p>
<p><em>chains</em> - the number of chains for which the simulation was run.
</p>
<p><em>nIntervals</em> - the number of intervals in the simulation
</p>
<p><em>Intervals</em> - an array. The intervals.
</p>
<p><em>nBodySys</em> - the number of body-systems
</p>
<p><em>maxBs</em> - the maximum number of body-systems in an interval
</p>
<p><em>maxAEs</em> - the maximum number of AEs in a body-system
</p>
<p><em>nAE</em> - an array. The number of AEs in each body-system.
</p>
<p><em>AE</em> - an array of dimension <em>nBodySys</em>, <em>maxAEs</em>. The Adverse Events.
</p>
<p><em>B</em> - an array. The body-systems.
</p>
<p><em>burnin</em> - burnin used for the simulation.
</p>
<p><em>iter</em> - the total number of iterations in the simulation.
</p>
<p><em>monitor</em> - the variables being monitored. A dataframe.
</p>
<p><em>mu.gamma.0</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
</p>
<p><em>mu.theta.0</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
</p>
<p><em>tau2.gamma.0</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
</p>
<p><em>tau2.theta.0</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
</p>
<p><em>mu.gamma</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>mu.theta</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>sigma2.gamma</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>sigma2.theta</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>gamma</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>, <em>iter - burnin</em>
</p>
<p><em>theta</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>, <em>iter - burnin</em>
</p>
<p><em>gamma_acc</em> - the acceptance rate for the gamma samples if a Metropolis-Hastings method is used. An array of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>
</p>
<p><em>theta_acc</em> - the acceptance rate for the theta samples if a Metropolis-Hastings method is used. An array of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>
</p>


<h3>Note</h3>

<p>The function performs the simulation and returns the raw output. No checks for convergence are performed. 
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(c212.trial.interval.data1)
raw = c212.1a.interim(c212.trial.interval.data1, burnin = 100, iter = 200)
## Not run: 
data(c212.trial.interval.data1)
raw = c212.1a.interim(c212.trial.interval.data1)

raw$B
    [,1]        [,2]         [,3]         [,4]         [,5]        
[1,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[2,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[3,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[4,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[5,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[6,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
     [,6]         [,7]         [,8]        [,9]        [,10]       [,11]      
[1,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[2,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[3,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[4,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[5,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[6,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
     [,12]       [,13]       [,14]       [,15]      
[1,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[2,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[3,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[4,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[5,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[6,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"

## End(Not run)
</code></pre>

<hr>
<h2 id='c212.BB'>Implementation of the Berry and Berry Three-Level Hierarchical Model.</h2><span id='topic+c212.BB'></span>

<h3>Description</h3>

<p>Implementaion of Berry and Berry model (2004), also model 1b from Xia et al (2011).</p>


<h3>Usage</h3>

<pre><code class='language-R'>	c212.BB(trial.data, burnin = 20000, iter = 60000, nchains = 3,
	theta_algorithm = "MH", sim_type = "SLICE",
	global.sim.params = data.frame(type = c("MH", "MH", "MH", "MH",
	"SLICE", "SLICE", "SLICE"),
	param = c("sigma_MH_alpha", "sigma_MH_beta", "sigma_MH_gamma",
	"sigma_MH_theta", "w_alpha", "w_beta", "w_gamma"),
	value = c(3, 3, 0.2, 0.2, 1, 1, 1), control = c(0, 0, 0, 0, 6, 6, 6),
	stringsAsFactors = FALSE),
	sim.params = NULL,
	initial_values = NULL,
	hyper_params = list(mu.gamma.0.0 = 0,
	tau2.gamma.0.0 = 10, mu.theta.0.0 = 0, tau2.theta.0.0 = 10,
	alpha.gamma.0.0 = 3, beta.gamma.0.0 = 1, alpha.theta.0.0 = 3,
	beta.theta.0.0 = 1, alpha.gamma = 3,
	beta.gamma = 1, alpha.theta = 3, beta.theta = 1,
	lambda.alpha = 1.0, lambda.beta = 1.0),
	global.pm.weight = 0.5,
	pm.weights = NULL,
	adapt_params = data.frame(min_w = 0.25, chains = 3, burnin = 20000,
	iter = 40000),
	adapt_phase=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.BB_+3A_trial.data">trial.data</code></td>
<td>

<p>A file or data frame containing the trial data. It must contain must contain the columns <em>B</em> (body-system), <em>AE</em> (adverse event), <em>Group</em> (1 - control, 2 treatment), <em>Count</em> (total number of events), <em>Total</em> (total number of participants).
</p>
</td></tr>
<tr><td><code id="c212.BB_+3A_burnin">burnin</code></td>
<td>

<p>The burnin period for the monte-carlo simulation. These are discarded from the returned samples.
</p>
</td></tr>
<tr><td><code id="c212.BB_+3A_iter">iter</code></td>
<td>

<p>The total number of iterations for which the monte-carlo simulation is run. This includes the burnin period.
The total number of samples returned is <em>iter - burnin</em>
</p>
</td></tr>
<tr><td><code id="c212.BB_+3A_nchains">nchains</code></td>
<td>

<p>The number of independent chains to run.
</p>
</td></tr>
<tr><td><code id="c212.BB_+3A_theta_algorithm">theta_algorithm</code></td>
<td>

<p>MCMC algorithm used to sample the theta variables. &quot;MH&quot; is the only currently supported stable algorithm.
</p>
</td></tr>
<tr><td><code id="c212.BB_+3A_sim_type">sim_type</code></td>
<td>

<p>The type of MCMC method to use for simulating from non-standard distributions apart from theta. Allowed values are <em>&quot;MH&quot;</em> and <em>&quot;SLICE&quot;</em> for Metropolis_Hastings and Slice sampling respectively.
</p>
</td></tr>
<tr><td><code id="c212.BB_+3A_global.sim.params">global.sim.params</code></td>
<td>

<p>A data frame containing the parameters for the simulation type <em>sim_type</em>. For <em>&quot;MH&quot;</em> the parameter
is the variance of the normal distribution used to simulate the next candidate value centred on the current
value. For <em>&quot;SLICE&quot;</em> the parameters are the estimated width of the slice and a value limiting the search for the next sample.
</p>
</td></tr>
<tr><td><code id="c212.BB_+3A_sim.params">sim.params</code></td>
<td>

<p>A dataframe containing simulation parameters which override the global simulation parameters (<em>global.sim.params</em>) for particular model
parameters. <em>sim.params</em> must contain the following columns: type: the simulation type (&quot;MH&quot; or &quot;SLICE&quot;); variable: the model parameter 
for which the simulation parameters are being overridden; B: the body-system (if applicable); AE: the adverse event (if applicable);
param: the simulation parameter; value: the overridden value; control: the overridden control value.
</p>
<p>The function <em>c212.sim.control.params</em> generates a template for <em>sim.params</em> which can be edited by the user.
</p>
</td></tr>
<tr><td><code id="c212.BB_+3A_initial_values">initial_values</code></td>
<td>

<p>The initial values for starting the chains. If NULL (the default) is passed the function generates the initial
values for the chains. initial_values is a list with the following format:
</p>
<pre>
list(gamma, theta, mu.gamma, mu.theta, sigma2.gamma,
	sigma2.theta, pi, mu.gamma.0, mu.theta.0,
	tau2.gamma.0, tau2.theta.0, alpha.pi, beta.pi)
</pre>
<p>The function <em>c212.gen.initial.values</em> can be used to generate a template for the list which can be updated by the user if required.
The formats of the list elements are as follows:
</p>
<p><em>gamma, theta</em>: dataframe with columns <em>B</em>, <em>AE</em>, <em>chain</em>, <em>value</em>
</p>
<p><em>mu.gamma, mu.theta, sigma2.gamma, sigma2.theta, pi</em>: dataframe with columns <em>B</em>, <em>chain</em>, <em>value</em>
</p>
<p><em>mu.gamma.0, mu.theta.0, tau2.gamma.0, tau2.theta.0, alpha.pi, beta.pi</em>: array of size <em>chain</em>.
</p>
</td></tr>
<tr><td><code id="c212.BB_+3A_hyper_params">hyper_params</code></td>
<td>

<p>The hyperparameters for the model. The default hyperparameters are those given in Berry and Berry 2004.
</p>
</td></tr>
<tr><td><code id="c212.BB_+3A_global.pm.weight">global.pm.weight</code></td>
<td>
<p>A global weighting for the proposal distribution used to sample theta.</p>
</td></tr>
<tr><td><code id="c212.BB_+3A_pm.weights">pm.weights</code></td>
<td>
<p>Override global.pm.weight for specific adverse events.</p>
</td></tr>
<tr><td><code id="c212.BB_+3A_adapt_params">adapt_params</code></td>
<td>

<p>Unused parameter.
</p>
</td></tr>
<tr><td><code id="c212.BB_+3A_adapt_phase">adapt_phase</code></td>
<td>

<p>Unused parameter.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is fitted by a Gibbs sampler. The details of the complete conditional densities are given in Berry
and Berry (2004).
</p>


<h3>Value</h3>

<p>The output from the simulation including all the sampled values is as follows:
</p>
<pre>
list(id, theta_alg, sim_type, chains, nBodySys, maxAEs, nAE, AE, B,
	burnin, iter, mu.gamma.0, mu.theta.0, tau2.gamma.0,
	tau2.theta.0, mu.gamma, mu.theta, sigma2.gamma, sigma2.theta,
	pi, alpha.pi, beta.pi, alpha.pi_acc, beta.pi_acc, gamma, theta,
	gamma_acc, theta_acc, theta_zero_prop, theta_zero_acc)
</pre>
<p>where
</p>
<p><em>id</em> - a string identifying the version of the function
</p>
<p><em>theta_alg</em> - an string identifying the algorithm used to sample theta
</p>
<p><em>sim_type</em> - an string identifying the sampling method used for non-standard distributions, either <em>&quot;MH&quot;</em> or <em>&quot;SLICE&quot;</em>
</p>
<p><em>chains</em> - the number of chains for which the simulation was run
</p>
<p><em>nBodySys</em> - the number of body-systems
</p>
<p><em>maxAEs</em> - the maximum number of AEs in a body-system
</p>
<p><em>nAE</em> - an array. The number of AEs in each body-system.
</p>
<p><em>AE</em> - an array of dimension <em>nBodySys</em>, <em>maxAEs</em>. The Adverse Events.
</p>
<p><em>B</em> - an array. The body-systems.
</p>
<p><em>mu.gamma.0</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
</p>
<p><em>mu.theta.0</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
</p>
<p><em>tau2.gamma.0</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
</p>
<p><em>tau2.theta.0</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
</p>
<p><em>mu.gamma</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>mu.theta</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>sigma2.gamma</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>sigma2.theta</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>pi</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
<em>alpha.pi</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
<em>beta.pi</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
</p>
<p><em>alpha.pi_acc</em> - the acceptance rate for the alpha.pi samples if a Metropolis-Hastings method is used. An array of dimension <em>chains</em>, <em>maxAEs</em>
</p>
<p><em>beta.pi_acc</em> - the acceptance rate for the beta.pi samples if a Metropolis-Hastings method is used. An array of dimension <em>chains</em>, <em>maxAEs</em>
</p>
<p><em>gamma</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>, <em>iter - burnin</em>
</p>
<p><em>theta</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>, <em>iter - burnin</em>
</p>
<p><em>gamma_acc</em> - the acceptance rate for the gamma samples if a Metropolis-Hastings method is used. An array of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>
</p>
<p><em>theta_acc</em> - the acceptance rate for the theta samples. An array of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>
</p>
<p><em>theta_zero_prop</em> - the number of zeros proposed in theta sampling. An array of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>
<em>theta_zero_acc</em> - the acceptance rate for zeros for the theta samples. An array of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>
</p>


<h3>Note</h3>

<p>The function performs the simulation and returns the raw output. No checks for convergence are performed. 
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>References</h3>

<p>S. M. Berry and D. A. Berry (2004). Accounting for multiplicities in assessing drug safety: a three-
level hierarchical mixture model.
Biometrics, 60(2):418-26.
</p>
<p>H. Amy Xia, Haijun Ma, and Bradley P. Carlin (2011). Bayesian hierarchical modelling for
detecting safety signals in clinical trials. Journal of Biopharmaceutical Statistics, 21(5):1006–
1029.
</p>
<p>Scott M. Berry, Bradley P. Carlin, J. Jack Lee, and Peter M¨ller (2010). Bayesian adaptive
methods for clinical trials. CRC Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(c212.trial.data)
raw = c212.BB(c212.trial.data, burnin = 100, iter = 200)

## Not run: 
data(c212.trial.data)
raw = c212.BB(c212.trial.data)

raw$B
[1] "Bdy-sys_1" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5" "Bdy-sys_6"
[7] "Bdy-sys_7" "Bdy-sys_8"

mean(raw$theta[2, 1,1,])
[1] 0.1088401

median(raw$theta[2, 1,1,])
[1] 0


## End(Not run)
</code></pre>

<hr>
<h2 id='c212.BB.interim'>A Two or Three-Level Hierarchical Body-system based Model for interim analysis with Point-Mass.</h2><span id='topic+c212.BB.interim'></span>

<h3>Description</h3>

<p>Implementation of a Two or Three-Level Hierarchical Body-system based Model for interim analysis with Point-Mass.</p>


<h3>Usage</h3>

<pre><code class='language-R'>	c212.BB.interim(trial.data, sim_type = "SLICE", burnin = 20000,
	iter = 60000, nchains = 5, theta_algorithm = "MH",
	global.sim.params = NULL,
	sim.params = NULL,
	monitor = NULL,
	initial_values = NULL,
	hier = 3,
	level = 1,
	hyper_params = NULL,
	global.pm.weight = 0.5,
	pm.weights = NULL,
	adapt_phase=1, memory_model = "HIGH")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.BB.interim_+3A_trial.data">trial.data</code></td>
<td>

<p>A file or data frame containing the trial data. It must contain must contain the columns <em>B</em> (body-system), <em>AE</em> (adverse event), <em>Group</em> (1 - control, 2 treatment), <em>Count</em> (total number of events), <em>Total</em> (total number of participants).
</p>
</td></tr>
<tr><td><code id="c212.BB.interim_+3A_burnin">burnin</code></td>
<td>

<p>The burnin period for the monte-carlo simulation. These are discarded from the returned samples.
</p>
</td></tr>
<tr><td><code id="c212.BB.interim_+3A_iter">iter</code></td>
<td>

<p>The total number of iterations for which the monte-carlo simulation is run. This includes the burnin period.
The total number of samples returned is <em>iter - burnin</em>
</p>
</td></tr>
<tr><td><code id="c212.BB.interim_+3A_nchains">nchains</code></td>
<td>

<p>The number of independent chains to run.
</p>
</td></tr>
<tr><td><code id="c212.BB.interim_+3A_theta_algorithm">theta_algorithm</code></td>
<td>

<p>MCMC algorithm used to sample the theta variables. &quot;MH&quot; is the only currently supported stable algorithm.
</p>
</td></tr>
<tr><td><code id="c212.BB.interim_+3A_sim_type">sim_type</code></td>
<td>

<p>The type of MCMC method to use for simulating from non-standard distributions apart from theta. Allowed values are <em>&quot;MH&quot;</em> and <em>&quot;SLICE&quot;</em> for Metropolis_Hastings and Slice sampling respectively.
</p>
</td></tr>
<tr><td><code id="c212.BB.interim_+3A_monitor">monitor</code></td>
<td>

<p>A dataframe indicating which sets of variables to monitor.
Passing NULL uses the model defaults.
</p>
</td></tr>
<tr><td><code id="c212.BB.interim_+3A_global.sim.params">global.sim.params</code></td>
<td>

<p>A data frame containing the parameters for the simulation type <em>sim_type</em>. For <em>&quot;MH&quot;</em> the parameter
is the variance of the normal distribution used to simulate the next candidate value centred on the current
value. For <em>&quot;SLICE&quot;</em> the parameters are the estimated width of the slice and a value limiting the search for the next sample.
Passing NULL uses the model defaults.
</p>
</td></tr>
<tr><td><code id="c212.BB.interim_+3A_sim.params">sim.params</code></td>
<td>

<p>A dataframe containing simulation parameters which override the global simulation parameters (<em>global.sim.params</em>) for particular model
parameters. <em>sim.params</em> must contain the following columns: type: the simulation type (&quot;MH&quot; or &quot;SLICE&quot;); variable: the model parameter 
for which the simulation parameters are being overridden; B: the body-system (if applicable); AE: the adverse event (if applicable);
param: the simulation parameter; value: the overridden value; control: the overridden control value.
</p>
<p>The function <em>c212.sim.control.params</em> generates a template for <em>sim.params</em> which can be edited by the user.
</p>
</td></tr>
<tr><td><code id="c212.BB.interim_+3A_initial_values">initial_values</code></td>
<td>

<p>The initial values for starting the chains. If NULL (the default) is passed the function generates the initial
values for the chains. initial_values is a list with the following format:
</p>
<pre>
list(gamma, theta, mu.gamma, mu.theta, sigma2.gamma,
	sigma2.theta, pi, mu.gamma.0, mu.theta.0,
	tau2.gamma.0, tau2.theta.0, alpha.pi, beta.pi)
</pre>
<p>The function <em>c212.gen.initial.values</em> can be used to generate a template for the list which can be updated by the user if required.
The formats of the list elements are as follows:
</p>
<p><em>gamma, theta</em>: dataframe with columns <em>B</em>, <em>AE</em>, <em>chain</em>, <em>value</em>
</p>
<p><em>mu.gamma, mu.theta, sigma2.gamma, sigma2.theta, pi</em>: dataframe with columns <em>B</em>, <em>chain</em>, <em>value</em>
</p>
<p><em>mu.gamma.0, mu.theta.0, tau2.gamma.0, tau2.theta.0, alpha.pi, beta.pi</em>: array of size <em>chain</em>.
</p>
</td></tr>
<tr><td><code id="c212.BB.interim_+3A_hier">hier</code></td>
<td>

<p>Model using a two or three level hierarchy. 2 - two-level hierarchy, 3 - three level hierarchy.
</p>
</td></tr>
<tr><td><code id="c212.BB.interim_+3A_level">level</code></td>
<td>

<p>The level of longitudinal dependency between the intervals. Allowed values are 0, 1, 2 for a three-level hierarchy and 0, 1 for a two-level hierarchy.
0 - independent intervals, 1 - common interval body-system means, 2 - weak dependency.
</p>
</td></tr>
<tr><td><code id="c212.BB.interim_+3A_hyper_params">hyper_params</code></td>
<td>

<p>The hyperparameters for the model. The default hyperparameters are those given in Berry and Berry 2004.
Passing NULL uses the model defaults.
</p>
</td></tr>
<tr><td><code id="c212.BB.interim_+3A_global.pm.weight">global.pm.weight</code></td>
<td>
<p>A global weighting for the proposal distribution used to sample theta.</p>
</td></tr>
<tr><td><code id="c212.BB.interim_+3A_pm.weights">pm.weights</code></td>
<td>
<p>Override global.pm.weight for specific adverse events.</p>
</td></tr>
<tr><td><code id="c212.BB.interim_+3A_adapt_phase">adapt_phase</code></td>
<td>

<p>Unused parameter.
</p>
</td></tr>
<tr><td><code id="c212.BB.interim_+3A_memory_model">memory_model</code></td>
<td>

<p>Allowed values are &quot;HIGH&quot; and &quot;LOW&quot;. &quot;HIGH&quot; means use as much memory as possible. &quot;LOW&quot; means use the minimum amount of memory.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is fitted by a Gibbs sampler. The details of the complete conditional densities are given in Berry
and Berry (2004).
</p>


<h3>Value</h3>

<p>The output from the simulation including all the sampled values for the three-level hierarchy is as follows:
</p>
<pre>
list(id, sim_type, chains, nIntervals, Intervals, nBodySys,
	maxBs, maxAEs, nAE, AE, B, burnin,
	iter, monitor, mu.gamma.0, mu.theta.0, tau2.gamma.0, tau2.theta.0,
	gamma, theta,  mu.gamma, mu.theta, sigma2.gamma, sigma2.theta, pi,
	alpha.pi, beta.pi,
	alpha.pi_acc, beta.pi_acc, gamma_acc, theta_acc)
</pre>
<p>The output from the simulation including all the sampled values for the two-level hierarchy is as follows:
</p>
<pre>
list(id, sim_type, chains, nIntervals, Intervals, nBodySys,
	maxBs, maxAEs, nAE, AE, B, burnin,
	iter, monitor,
	gamma, theta,
	mu.gamma, mu.theta, sigma2.gamma, sigma2.theta, pi,
	gamma_acc, theta_acc)
</pre>
<p>where
</p>
<p><em>id</em> - a string identifying the version of the function
</p>
<p><em>sim_type</em> - an string identifying the sampling method used for non-standard distributions, either <em>&quot;MH&quot;</em> or <em>&quot;SLICE&quot;</em>
</p>
<p><em>chains</em> - the number of chains for which the simulation was run
</p>
<p><em>nIntervals</em> - the number of intervals in the simulation
</p>
<p><em>Intervals</em> - an array. The intervals.
</p>
<p><em>nBodySys</em> - the number of body-systems
</p>
<p><em>maxBs</em> - the maximum number of body-systems in an interval
</p>
<p><em>maxAEs</em> - the maximum number of AEs in a body-system
</p>
<p><em>nAE</em> - an array. The number of AEs in each body-system.
</p>
<p><em>AE</em> - an array of dimension <em>nBodySys</em>, <em>maxAEs</em>. The Adverse Events.
</p>
<p><em>B</em> - an array. The body-systems.
</p>
<p><em>burnin</em> - burnin used for the simulation.
</p>
<p><em>iter</em> - the total number of iterations in the simulation.
</p>
<p><em>monitor</em> - the variables being monitored. A dataframe.
</p>
<p><em>mu.gamma.0</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
</p>
<p><em>mu.theta.0</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
</p>
<p><em>tau2.gamma.0</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
</p>
<p><em>tau2.theta.0</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
</p>
<p><em>mu.gamma</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>mu.theta</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>sigma2.gamma</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>sigma2.theta</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>pi</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
<em>alpha.pi</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
<em>beta.pi</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
</p>
<p><em>alpha.pi_acc</em> - the acceptance rate for the alpha.pi samples if a Metropolis-Hastings method is used. An array of dimension <em>chains</em>, <em>maxAEs</em>
</p>
<p><em>beta.pi_acc</em> - the acceptance rate for the beta.pi samples if a Metropolis-Hastings method is used. An array of dimension <em>chains</em>, <em>maxAEs</em>
</p>
<p><em>gamma</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>, <em>iter - burnin</em>
</p>
<p><em>theta</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>, <em>iter - burnin</em>
</p>
<p><em>gamma_acc</em> - the acceptance rate for the gamma samples if a Metropolis-Hastings method is used. An array of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>
</p>
<p><em>theta_acc</em> - the acceptance rate for the theta samples. An array of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>
</p>


<h3>Note</h3>

<p>The function performs the simulation and returns the raw output. No checks for convergence are performed. 
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(c212.trial.interval.data1)
raw = c212.BB.interim(c212.trial.interval.data1, level = 1, burnin = 100, iter = 200)

## Not run: 
data(c212.trial.interval.data1)
raw = c212.BB.interim(c212.trial.interval.data1, level = 1)

raw$B
     [,1]        [,2]         [,3]         [,4]         [,5]        
[1,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[2,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[3,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[4,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[5,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[6,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
     [,6]         [,7]         [,8]        [,9]        [,10]       [,11]      
[1,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[2,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[3,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[4,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[5,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[6,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
     [,12]       [,13]       [,14]       [,15]      
[1,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[2,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[3,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[4,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[5,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[6,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"


## End(Not run)
</code></pre>

<hr>
<h2 id='c212.BH'>Implementation of Benjamini-Hochberg procedure for False Discovery Rate control</h2><span id='topic+c212.BH'></span>

<h3>Description</h3>

<p>Implementaion of Benjamini-Hochberg procedure for False Discovery Rate control. The hypotheses' data can be
contained in a file or data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c212.BH(trial.data, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.BH_+3A_trial.data">trial.data</code></td>
<td>

<p>File or data frame containing the p-values for the hypotheses being tested. The data must include a column called <em>p</em> which contains
the p-values of the hypotheses.
</p>
</td></tr>
<tr><td><code id="c212.BH_+3A_alpha">alpha</code></td>
<td>

<p>The level for FDR control. E.g. 0.05.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The subset of hypotheses in <em>file</em> or <em>trial.data</em> deemed significant by the Benjamini-Hochberg procedure.
</p>


<h3>Note</h3>

<p>No check is made for duplicate rows in the input file or data frame.
</p>


<h3>Author(s)</h3>

<p>R. Carragher&lt;raymond.carragher@strath.ac.uk&gt;
</p>


<h3>References</h3>

<p>Benjamini, Yoav and Hochberg, Yosef, (1995).
Controlling the False Discovery Rate: A Practical and Powerful Approach to Multiple Testing.
Journal of the Royal Statistical Society. Series B (Methodological), 57(1):289-300.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
trial.data &lt;- data.frame(B = c(1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4),
j = c(1, 1, 2, 3, 4, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5),
AE = c("AE1", "AE2", "AE3", "AE4", "AE5", "AE6", "AE7", "AE8", "AE9", "AE10", "AE11",
"AE12", "AE13", "AE14", "AE15", "AE16", "AE17"),
p = c(0.135005, 0.010000, 0.001000, 0.005000, 0.153501, 0.020000, 0.0013, 0.0023,
0.011, 0.023000, 0.016, 0.0109, 0.559111, 0.751986, 0.308339, 0.837154, 0.325882))


c212.BH(trial.data, 0.05)


## Not run: 
   B j   AE      p
1  2 2  AE3 0.0010
2  3 2  AE7 0.0013
3  3 3  AE8 0.0023
4  2 3  AE4 0.0050
5  2 1  AE2 0.0100
6  3 7 AE12 0.0109
7  3 4  AE9 0.0110
8  3 6 AE11 0.0160
9  3 1  AE6 0.0200
10 3 5 AE10 0.0230

## End(Not run)

</code></pre>

<hr>
<h2 id='c212.BH.adjust.pvals'>Benjamini-Hochberg procedure adjusted p-values</h2><span id='topic+c212.BH.adjust.pvals'></span>

<h3>Description</h3>

<p>Benjamini-Hochberg procedure adjusted p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c212.BH.adjust.pvals(trial.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.BH.adjust.pvals_+3A_trial.data">trial.data</code></td>
<td>

<p>File or data frame containing the p-values for the hypotheses being tested. The data must include a column called <em>p</em> which contains
the p-values of the hypotheses.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the original data frame, ordered by <em>p</em>, with an additional column <em>p_adj</em>.
</p>


<h3>Note</h3>

<p>The adjusted p values may be directly compared to a value <em>alpha</em> to determine whether to declare a hypothesis significant under the Benjamini-Hochberg procedure at level <em>alpha</em>.
</p>


<h3>Note</h3>

<p>No check is made for duplicate rows in the input file or data frame.
</p>


<h3>Author(s)</h3>

<p>R. Carragher&lt;raymond.carragher@strath.ac.uk&gt;
</p>


<h3>References</h3>

<p>D. V. Mehrotra and J. F. Heyse (2004). Use of the false discovery rate for evaluating clinical
safety data. Stat Methods Med Res, 13(3):227–38, 2004.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
trial.data &lt;- data.frame(B = c(1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4),
j = c(1, 1, 2, 3, 4, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5),
AE = c("AE1", "AE2", "AE3", "AE4", "AE5", "AE6", "AE7", "AE8", "AE9", "AE10", "AE11",
"AE12", "AE13", "AE14", "AE15", "AE16", "AE17"),
p = c(0.135005, 0.010000, 0.001000, 0.005000, 0.153501, 0.020000, 0.0013, 0.0023,
0.011, 0.023000, 0.016, 0.0109, 0.559111, 0.751986, 0.308339, 0.837154, 0.325882))


adj &lt;- c212.BH.adjust.pvals(trial.data)


## Not run: 
adj:
====
   B j   AE        p      p_adj
1  2 2  AE3 0.001000 0.01105000
2  3 2  AE7 0.001300 0.01105000
3  3 3  AE8 0.002300 0.01303333
4  2 3  AE4 0.005000 0.02125000
5  2 1  AE2 0.010000 0.02671429
6  3 7 AE12 0.010900 0.02671429
7  3 4  AE9 0.011000 0.02671429
8  3 6 AE11 0.016000 0.03400000
9  3 1  AE6 0.020000 0.03777778
10 3 5 AE10 0.023000 0.03910000
11 1 1  AE1 0.135005 0.20864409
12 2 4  AE5 0.153501 0.21745975
13 4 3 AE15 0.308339 0.39571386
14 4 5 AE17 0.325882 0.39571386
15 4 1 AE13 0.559111 0.63365913
16 4 2 AE14 0.751986 0.79898513
17 4 4 AE16 0.837154 0.83715400

## End(Not run)

adj[adj$p_adj &lt;= 0.05, ]

## Not run: 
   B j   AE      p      p_adj
1  2 2  AE3 0.0010 0.01105000
2  3 2  AE7 0.0013 0.01105000
3  3 3  AE8 0.0023 0.01303333
4  2 3  AE4 0.0050 0.02125000
5  2 1  AE2 0.0100 0.02671429
6  3 7 AE12 0.0109 0.02671429
7  3 4  AE9 0.0110 0.02671429
8  3 6 AE11 0.0160 0.03400000
9  3 1  AE6 0.0200 0.03777778
10 3 5 AE10 0.0230 0.03910000

## End(Not run)


</code></pre>

<hr>
<h2 id='c212.bin.test'>Plot Raw Adverse Event Incidence Data</h2><span id='topic+c212.bin.test'></span>

<h3>Description</h3>

<p>Test the hypothesis that the proportions in two groups are the same.
adverse event. </p>


<h3>Usage</h3>

<pre><code class='language-R'>	c212.bin.test(trial.data, alternative = "two.sided", correct = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.bin.test_+3A_trial.data">trial.data</code></td>
<td>

<p>A file or data frame containing the trial data. The data frame must contain the columns <em>B</em> (body-system), <em>AE</em> (adverse event), <em>Group</em> (1 - control, 2 treatment), <em>Count</em> (total number of events), <em>Total</em> (total number of participants).
</p>
</td></tr>
<tr><td><code id="c212.bin.test_+3A_alternative">alternative</code></td>
<td>

<p>Alternative hypothesis may be &quot;two.sided&quot;, &quot;greater&quot; or &quot;less&quot;. The default is &quot;two.sided&quot;.
</p>
</td></tr>
<tr><td><code id="c212.bin.test_+3A_correct">correct</code></td>
<td>

<p>Apply a continuity correction.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Test the hypothesis that the proportions in two groups are the same.
</p>


<h3>Value</h3>

<p>Dataframe containing the results of the test. A copy of the input dataframe with an additional column <em>p</em> containing the
p-value from the test.
</p>


<h3>Note</h3>

<p>Wrapper for the R function 'prop.test' in package 'stats'.
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(c212.trial.data)
pr = c212.bin.test(c212.trial.data)
head(pr)

## Not run: 
          B j       AE            p
1 Bdy-sys_1 1 Adv-Ev_1 2.893605e-01
2 Bdy-sys_2 1 Adv-Ev_2 5.711463e-03
3 Bdy-sys_2 2 Adv-Ev_3 1.655715e-02
4 Bdy-sys_2 3 Adv-Ev_4 6.497695e-01
5 Bdy-sys_2 4 Adv-Ev_5 7.433433e-01
6 Bdy-sys_3 1 Adv-Ev_6 8.419469e-08


## End(Not run)
</code></pre>

<hr>
<h2 id='c212.BONF'>Implementation of Bonferroni correction for error control</h2><span id='topic+c212.BONF'></span>

<h3>Description</h3>

<p>The Bonferroni correction controls the Familywise Error Rate.</p>


<h3>Usage</h3>

<pre><code class='language-R'>c212.BONF(trial.data, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.BONF_+3A_trial.data">trial.data</code></td>
<td>

<p>File or data frame containing the p-values for the hypotheses being tested. The data must include a column called <em>p</em> which contains
the p-values of the hypotheses.
</p>
</td></tr>
<tr><td><code id="c212.BONF_+3A_alpha">alpha</code></td>
<td>

<p>The value for error control, e.g. 0.05.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The subset of hypotheses in <em>file</em> or <em>trial.data</em> deemed significant.
</p>


<h3>Note</h3>

<p>No check is made for duplicate rows in the input file or data frame.
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>References</h3>

<p>Matthews, John N. S. (2006) Introduction to Randomized Controlled Clinical Trials, Second Edition. Chapman &amp; Hall/CRC Texts in Statistical Science.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trial.data &lt;- data.frame(B = c(1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4),
j = c(1, 1, 2, 3, 4, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5),
AE = c("AE1", "AE2", "AE3", "AE4", "AE5", "AE6", "AE7", "AE8", "AE9", "AE10", "AE11",
"AE12", "AE13", "AE14", "AE15", "AE16", "AE17"),
p = c(0.135005, 0.010000, 0.001000, 0.005000, 0.153501, 0.020000, 0.0013, 0.0023, 0.011,
0.023000, 0.016, 0.0109, 0.559111, 0.751986, 0.308339, 0.837154, 0.325882))


c212.BONF(trial.data, 0.05)


## Not run: 
  B j  AE      p
1 2 2 AE3 0.0010
2 3 2 AE7 0.0013
3 3 3 AE8 0.0023

## End(Not run)
</code></pre>

<hr>
<h2 id='c212.convergence.diag'>Convergence Diagnostics of the Simulation</h2><span id='topic+c212.convergence.diag'></span>

<h3>Description</h3>

<p>The function applies either Gelman-Rubin or the Geweke diagnostic to the raw output of model simulation (e.g. c212.BB).
It returns the convergence diagnostics and, if applicable, the acceptance rates for the sampling distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	c212.convergence.diag(raw, debug_diagnostic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.convergence.diag_+3A_raw">raw</code></td>
<td>

<p>The output from a model simulation.
</p>
</td></tr>
<tr><td><code id="c212.convergence.diag_+3A_debug_diagnostic">debug_diagnostic</code></td>
<td>

<p>Unused parameter.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>parameter is time consuming. This function applies one of two convergence diagnostics to the raw output of a model simulation
in order to allow convergence to be assessed. The two diagnostics are:
</p>
<p>i) Gelman-Rubin diagnostic - used when there is more than one chain. A value close to 1 is consistent with
an MCMC simulation which has converged. The &lsquo;coda&rsquo; diagnostic returns a point estimate and upper confidence
limits.
</p>
<p>ii) Geweke diagnostic - used when there is a single chain. A Z-score which is consistent with a standard normal
distribution is expected from an MCMC simulation which has converged.
</p>
<p>The raw sample data is converted to &lsquo;coda&rsquo; format (mcmc objects) and the &lsquo;coda&rsquo; methods gelman.diag and
geweke.diag are used to perform the checks.
</p>


<h3>Value</h3>

<p>Returns a list of the diagnostics for each sampled variable. Each individual element of the list is a
data.frame containing at least the columns <em>type</em>, which is the type of diagnostic
(&lsquo;Gelman-Rubin&rsquo; or &lsquo;Geweke&rsquo;), <em>stat</em>, which is the value of the dignostic, and <em>upper_ci</em> which is
the upper confidence interval for the Gelman-Rubin diagnostic. For the Geweke diagnostic <em>upper_ci</em>
contains the value NA. Depending on the simulation performed the return from <em>c212.convergence.diag</em> will contain different
variables. The return for a simulation from <em>c212.1a</em> is as follows:
</p>
<pre>
list(sim_type, gamma.conv.diag, theta.conv.diag, mu.gamma.conv.diag,
                       mu.theta.conv.diag, sigma2.gamma.conv.diag,
                       sigma2.theta.conv.diag, mu.gamma.0.conv.diag,
                       mu.theta.0.conv.diag, tau2.gamma.0.conv.diag,
                       tau2.theta.0.conv.diag)
</pre>
<p>Additional columns which may be used to identify the individual samples are <em>B</em>, the body-system, and
<em>AE</em>, the Adverse Event and <em>interval</em>.
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(c212.trial.data)
raw = c212.BB(c212.trial.data, burnin = 100, iter = 200)
conv = c212.convergence.diag(raw)

## Not run: 
data(c212.trial.data)
raw = c212.BB(c212.trial.data)
conv = c212.convergence.diag(raw)

## End(Not run)
</code></pre>

<hr>
<h2 id='c212.DFDR'>Implementation of the Double False Discovery Rate for controlling the False Discovery Rate.</h2><span id='topic+c212.DFDR'></span>

<h3>Description</h3>

<p>The Double False Discovery Rate is designed to take advantage of possible groupings which may exist within 
sets of hypotheses. It applies the BH-procedure twice. Once at the group level, to identify sets of hypotheses
which may contain significant hypotheses. It then groups these hypotheses together to form a single family and
applies the BH-procedure again to declare hypotheses significant.</p>


<h3>Usage</h3>

<pre><code class='language-R'>c212.DFDR(trial.data, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.DFDR_+3A_trial.data">trial.data</code></td>
<td>

<p>File or data frame containing the p-values for the hypotheses being tested. 
The data must contain the following columns: <em>B</em>: the index or name of the groupings; <em>p</em>: the p-values of the hypotheses.
</p>
</td></tr>
<tr><td><code id="c212.DFDR_+3A_alpha">alpha</code></td>
<td>

<p>The level for FDR control. E.g. 0.05.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The subset of hypotheses in <em>file</em> or <em>trial.data</em> deemed significant by the Double False Discovery Rate process.
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>References</h3>

<p>Mehrotra, D. V. and Adewale, A. J. (2012). Flagging clinical adverse experiences: reducing false discoveries without materially compromising power for detecting true signals. Stat Med, 31(18):1918-30.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trial.data &lt;- data.frame(B = c(1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4),
AE = c("AE1", "AE2", "AE3", "AE4", "AE5", "AE6", "AE7", "AE8", "AE9", "AE10", "AE11",
"AE12", "AE13", "AE14", "AE15", "AE16", "AE17"),
p = c(0.135005, 0.010000, 0.001000, 0.005000, 0.153501, 0.020000, 0.0013, 0.0023,
0.011, 0.023000, 0.016, 0.0109, 0.559111, 0.751986, 0.308339, 0.837154, 0.325882))


c212.DFDR(trial.data, 0.05)


## Not run: 
   B j   AE      p
1  2 2  AE3 0.0010
2  3 2  AE7 0.0013
3  3 3  AE8 0.0023
4  2 3  AE4 0.0050
5  2 1  AE2 0.0100
6  3 7 AE12 0.0109
7  3 4  AE9 0.0110
8  3 6 AE11 0.0160
9  3 1  AE6 0.0200
10 3 5 AE10 0.0230

## End(Not run)
</code></pre>

<hr>
<h2 id='c212.err.cntrl'>Implementaion of Group Bonferroni-Hochberg procedure for control of the False Discovery Rate</h2><span id='topic+c212.err.cntrl'></span>

<h3>Description</h3>

<p>Common interface to the error controlling methods: Unadjutsed hypothesis testing (NOADJ), Bonferroni correction (BONF), Benjamini-Hochberg procedure (BH),
Group Benjamini-Hochberg (GBH),
Double False Discover Rate (DFDR), subset Benjamini-Hochberg (ssBH).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c212.err.cntrl(trial.data, alpha = 0.05, method = "NOADJ",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.err.cntrl_+3A_trial.data">trial.data</code></td>
<td>

<p>File or data frame containing the p-values for the hypotheses being tested. 
The data must contain the following columns: <em>B</em>: the index or name of the groupings; <em>p</em>: the p-values of the hypotheses.
</p>
</td></tr>
<tr><td><code id="c212.err.cntrl_+3A_alpha">alpha</code></td>
<td>

<p>The level for error control. E.g. 0.05.
</p>
</td></tr>
<tr><td><code id="c212.err.cntrl_+3A_method">method</code></td>
<td>

<p>The error control procedure to be applied:
&quot;NOAD&quot; - unadjusted testing,
&quot;BONF&quot; - Bonferroni correction
&quot;BH&quot; -  Benjamini-Hochberg procedure
&quot;GBH&quot; - Group Benjamini-Hochberg
&quot;DFDR&quot; - Double False Discover Rate
&quot;ssBH&quot; - subset Benjamini-Hochberg.
</p>
</td></tr>
<tr><td><code id="c212.err.cntrl_+3A_...">...</code></td>
<td>

<p>Additional optional parameter for the GBH method: <em>pi0</em>. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The subset of hypotheses in <em>file</em> or <em>trial.data</em> deemed significant by the Group Benjamini-Hochberg process.
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trial.data &lt;- data.frame(B = c(1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4),
j = c(1, 1, 2, 3, 4, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5),
AE = c("AE1", "AE2", "AE3", "AE4", "AE5", "AE6", "AE7", "AE8", "AE9", "AE10", "AE11",
"AE12", "AE13", "AE14", "AE15", "AE16", "AE17"),
p = c(0.135005, 0.010000, 0.001000, 0.005000, 0.153501, 0.020000, 0.0013, 0.0023,
0.011, 0.023000, 0.016, 0.0109, 0.559111, 0.751986, 0.308339, 0.837154, 0.325882))


c212.err.cntrl(trial.data = trial.data, alpha = 0.05, method = "GBH")

## Not run: 
   B j   AE        p   p_weighted
1  3 1  AE6 0.020000 0.0000000000
2  3 2  AE7 0.001300 0.0000000000
3  3 3  AE8 0.002300 0.0000000000
4  3 4  AE9 0.011000 0.0000000000
5  3 5 AE10 0.023000 0.0000000000
6  3 6 AE11 0.016000 0.0000000000
7  3 7 AE12 0.010900 0.0000000000
8  2 2  AE3 0.001000 0.0003333333
9  2 3  AE4 0.005000 0.0016666667
10 2 1  AE2 0.010000 0.0033333333
11 2 4  AE5 0.153501 0.0511670000

## End(Not run)
</code></pre>

<hr>
<h2 id='c212.FDR.data'>Fisher Test p-values for End of Trial Data Clinical Data</h2><span id='topic+c212.FDR.data'></span>

<h3>Description</h3>

<p>This data set the p-values for a comparison between adverse events on each arm of a clinical trial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(c212.FDR.data)</code></pre>


<h3>Format</h3>

<p>A dataframe with columns <em>B</em> - body-system, <em>AE</em> - adverse event, <em>p</em> - p-value for two-sided Fisher exact test.
The dataframe contains 45 observations.</p>

<hr>
<h2 id='c212.fisher.test'>Fisher Exact Test</h2><span id='topic+c212.fisher.test'></span>

<h3>Description</h3>

<p>Perform a Fisher exact test on clinical trial data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	c212.fisher.test(trial.data, alternative = "two.sided")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.fisher.test_+3A_trial.data">trial.data</code></td>
<td>

<p>A file or data frame containing the trial data. The data frame must contain the columns <em>B</em> (body-system), <em>AE</em> (adverse event), <em>Group</em> (1 - control, 2 treatment), <em>Count</em> (total number of events), <em>Total</em> (total number of participants).
</p>
</td></tr>
<tr><td><code id="c212.fisher.test_+3A_alternative">alternative</code></td>
<td>

<p>Alternative hypothesis may be &quot;two.sided&quot;, &quot;greater&quot; or &quot;less&quot;. The default is &quot;two.sided&quot;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Perform a Fisher exact test on clinical trial data.
</p>


<h3>Value</h3>

<p>Dataframe containing the results of the test. A copy of the input dataframe with an additional column <em>p</em> containing the
p-value from the test.
</p>


<h3>Note</h3>

<p>Wrapper for the R function 'fisher.test' in package 'stats'.</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(c212.trial.data)
f = c212.fisher.test(c212.trial.data)

## Not run: 
data(c212.trial.data)
f = c212.fisher.test(c212.trial.data)
head(f)
          B j       AE            p
1 Bdy-sys_1 1 Adv-Ev_1 2.892876e-01
2 Bdy-sys_2 1 Adv-Ev_2 5.333164e-03
3 Bdy-sys_2 2 Adv-Ev_3 1.601311e-02
4 Bdy-sys_2 3 Adv-Ev_4 6.502108e-01
5 Bdy-sys_2 4 Adv-Ev_5 7.437946e-01
6 Bdy-sys_3 1 Adv-Ev_6 3.746249e-08


## End(Not run)
</code></pre>

<hr>
<h2 id='c212.GBH'>Implementaion of Group Bonferroni-Hochberg procedure for control of the False Discovery Rate</h2><span id='topic+c212.GBH'></span>

<h3>Description</h3>

<p>The Group Benjamini-Hochberg procedure for control of the False Discovery Rate is designed to take advantage of possible groupings which may exist within 
sets of hypotheses. The procedure estimates the number of true null hypotheses in each grouping and uses this to weight the p-values which are then compared to a weighted level for control. The procedure asymptotically
controls the False Discovery Rate at the required level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c212.GBH(trial.data, pi0 = "TST", alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.GBH_+3A_trial.data">trial.data</code></td>
<td>

<p>File or data frame containing the p-values for the hypotheses being tested. 
The data must contain the following columns: <em>B</em>: the index or name of the groupings; <em>p</em>: the p-values of the hypotheses.
</p>
</td></tr>
<tr><td><code id="c212.GBH_+3A_pi0">pi0</code></td>
<td>

<p>The estimator to use for the estimation of the number of true null hypotheses in each group. Valid values are
<em>&quot;TST&quot;</em> and <em>&quot;LSL&quot;</em>.
</p>
</td></tr>
<tr><td><code id="c212.GBH_+3A_alpha">alpha</code></td>
<td>

<p>The level for FDR control. E.g. 0.05.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The subset of hypotheses in <em>file</em> or <em>trial.data</em> deemed significant by the Group Benjamini-Hochberg process.
</p>


<h3>Note</h3>

<p>The estimator &quot;<em>TST</em>&quot; is the two-stage estimator of Benjamini, Krieger, and Yekutieli. 
The estimator  &quot;<em>LSL</em>&quot; is the least-slope estimator of Benjamini and Hochberg.
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>References</h3>

<p>Hu, J. X. and Zhao, H. and Zhou, H. H. (2010). False Discovery Rate Control With Groups. J Am Stat Assoc, 105(491):1215-1227.
</p>
<p>Y. Benjamini, A. M. Krieger, and D. Yekutieli (2006). Adaptive linear step-up procedures that
control the false discovery rate. Biometrika, 93(3):491–507.
</p>
<p>Benjamini Y, Hochberg Y. (2000). On the Adaptive Control of the False Discovery Rate in Multiple Testing
With Independent Statistics. Journal of Educational and Behavioral Statistics, 25(1):60–83.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trial.data &lt;- data.frame(B = c(1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4),
j = c(1, 1, 2, 3, 4, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5),
AE = c("AE1", "AE2", "AE3", "AE4", "AE5", "AE6", "AE7", "AE8", "AE9", "AE10", "AE11",
"AE12", "AE13", "AE14", "AE15", "AE16", "AE17"),
p = c(0.135005, 0.010000, 0.001000, 0.005000, 0.153501, 0.020000, 0.0013, 0.0023,
0.011, 0.023000, 0.016, 0.0109, 0.559111, 0.751986, 0.308339, 0.837154, 0.325882))


c212.GBH(trial.data, pi0 = "TST", 0.05)

## Not run: 
   B j   AE        p   p_weighted
1  3 1  AE6 0.020000 0.0000000000
2  3 2  AE7 0.001300 0.0000000000
3  3 3  AE8 0.002300 0.0000000000
4  3 4  AE9 0.011000 0.0000000000
5  3 5 AE10 0.023000 0.0000000000
6  3 6 AE11 0.016000 0.0000000000
7  3 7 AE12 0.010900 0.0000000000
8  2 2  AE3 0.001000 0.0003333333
9  2 3  AE4 0.005000 0.0016666667
10 2 1  AE2 0.010000 0.0033333333
11 2 4  AE5 0.153501 0.0511670000

## End(Not run)
</code></pre>

<hr>
<h2 id='c212.gen.initial.values'>Generate a template simulation initial values.</h2><span id='topic+c212.gen.initial.values'></span>

<h3>Description</h3>

<p>This function generates a template for the initial values to be used to start the simulation. They can be updated by the caller and passed to the simulation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	c212.gen.initial.values(trial.data, nchains = 3,
						model = "1a", hier = 3, level = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.gen.initial.values_+3A_trial.data">trial.data</code></td>
<td>

<p>A file or data frame containing the trial data, either for end of trial or interim analysis.
</p>
</td></tr>
<tr><td><code id="c212.gen.initial.values_+3A_nchains">nchains</code></td>
<td>

<p>The number of chains in the simulation.
</p>
</td></tr>
<tr><td><code id="c212.gen.initial.values_+3A_model">model</code></td>
<td>

<p>The model type: &quot;BB&quot; for point-mass models, &quot;1a&quot; for non-point-mass models.
</p>
</td></tr>
<tr><td><code id="c212.gen.initial.values_+3A_hier">hier</code></td>
<td>

<p>Allowed values are 2, 3 indicating two or three level hierarchies.
</p>
</td></tr>
<tr><td><code id="c212.gen.initial.values_+3A_level">level</code></td>
<td>

<p>The dependency level in the model: 0, 1, 2.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing the template of initial values.
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(c212.trial.data)
init.vals &lt;- c212.gen.initial.values(c212.trial.data)
print(init.vals$mu.gamma.0)
## Not run: 
data(c212.trial.data)
init.vals &lt;- c212.gen.initial.values(c212.trial.data)
print(init.vals$mu.gamma.0)

## End(Not run)
</code></pre>

<hr>
<h2 id='c212.global.sim.params'>Generate a template for the individual model parameter simulation control parameters.</h2><span id='topic+c212.global.sim.params'></span>

<h3>Description</h3>

<p>This function generates the default global simulation parameters used by the model simulation functions (e.g. c212.BB).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	c212.global.sim.params(trial.data, model = "BB", hier = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.global.sim.params_+3A_trial.data">trial.data</code></td>
<td>

<p>A file or data frame containing the trial data, either for end of trial or interim analysis.
</p>
</td></tr>
<tr><td><code id="c212.global.sim.params_+3A_model">model</code></td>
<td>

<p>Allowed values are &quot;BB&quot; and &quot;1a&quot; for point-mass and non-point-mass models respectively.
</p>
</td></tr>
<tr><td><code id="c212.global.sim.params_+3A_hier">hier</code></td>
<td>

<p>Generate parameters for a two level or three level hierarchy. Allowed values are 2 and 3 respectively.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing the global simulation parameters.
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(c212.trial.data)
global.sim.prams &lt;- c212.global.sim.params(c212.trial.data)
## Not run: 
data(c212.trial.data)
global.sim.prams &lt;- c212.global.sim.params(c212.trial.data)

## End(Not run)
</code></pre>

<hr>
<h2 id='c212.hyper.params'>Generate a template for the individual model parameter simulation control parameters.</h2><span id='topic+c212.hyper.params'></span>

<h3>Description</h3>

<p>This function generates the default model hyper-parameters used by the model simulation functions (e.g. c212.BB).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	c212.hyper.params(trial.data, model = "BB", hier = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.hyper.params_+3A_trial.data">trial.data</code></td>
<td>

<p>A file or data frame containing the trial data, either for end of trial or interim analysis.
</p>
</td></tr>
<tr><td><code id="c212.hyper.params_+3A_model">model</code></td>
<td>

<p>Allowed values are &quot;BB&quot; and &quot;1a&quot; for point-mass and non-point-mass models respectively.
</p>
</td></tr>
<tr><td><code id="c212.hyper.params_+3A_hier">hier</code></td>
<td>

<p>Generate parameters for a two level or three level hierarchy. Allowed values are 2 and 3 respectively.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the model hyper-parameters.
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(c212.trial.data)
h.p &lt;- c212.hyper.params(c212.trial.data)
## Not run: 
data(c212.trial.data)
h.p &lt;- c212.hyper.params(c212.trial.data)
print(h.p)

## End(Not run)
</code></pre>

<hr>
<h2 id='c212.interim.1a.hier2'>A Two-Level Hierarchical Body-system based Model for interim analysis without Point-Mass.</h2><span id='topic+c212.interim.1a.hier2'></span>

<h3>Description</h3>

<p>Implementation of a Two-Level Hierarchical Body-system based Model for interim analysis without Point-Mass.</p>


<h3>Usage</h3>

<pre><code class='language-R'>	c212.interim.1a.hier2(trial.data, sim_type = "SLICE", burnin = 10000,
	iter = 40000, nchains = 3,
	global.sim.params = data.frame(type = c("MH", "SLICE"),
	param = c("sigma_MH", "w"), value = c(0.2,1), control = c(0,6),
	stringsAsFactors = FALSE),
	sim.params = NULL,
	monitor = data.frame(variable = c("theta", "gamma", "mu.gamma",
	"mu.theta", "sigma2.theta", "sigma2.gamma"),
	monitor = c(1, 1, 1, 1, 1, 1),
	stringsAsFactors = FALSE),
	initial_values = NULL,
	level = 1,
	hyper_params = list(mu.gamma.0 = 0, tau2.gamma.0 = 10, mu.theta.0 = 0,
	tau2.theta.0 = 10, alpha.gamma = 3, beta.gamma = 1,
	alpha.theta = 3, beta.theta = 1),
	memory_model = "HIGH")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.interim.1a.hier2_+3A_trial.data">trial.data</code></td>
<td>

<p>A file or data frame containing the trial data. It must contain must contain the columns <em>I_index</em> (interval index), <em>B</em> (body-system), <em>AE</em> (adverse event), <em>Group</em> (1 - control, 2 treatment), <em>Count</em> (total number of events), <em>Total</em> (total number of participants in the trial
arm).
</p>
</td></tr>
<tr><td><code id="c212.interim.1a.hier2_+3A_sim_type">sim_type</code></td>
<td>

<p>The type of MCMC method to use for simulating from non-standard distributions. Allowed values are <em>&quot;MH&quot;</em>
and <em>&quot;SLICE&quot;</em> for Metropolis_Hastings and Slice sampling respectively.
</p>
</td></tr>
<tr><td><code id="c212.interim.1a.hier2_+3A_burnin">burnin</code></td>
<td>

<p>The burnin period for the monte-carlo simulation. These are discarded from the returned samples.
</p>
</td></tr>
<tr><td><code id="c212.interim.1a.hier2_+3A_iter">iter</code></td>
<td>
<p> The total number of iterations for which the monte-carlo simulation is run. This includes the burnin period.
The total number of samples returned is <em>iter - burnin</em>
</p>
</td></tr>
<tr><td><code id="c212.interim.1a.hier2_+3A_nchains">nchains</code></td>
<td>

<p>The number of independent chains to run.
</p>
</td></tr>
<tr><td><code id="c212.interim.1a.hier2_+3A_global.sim.params">global.sim.params</code></td>
<td>

<p>A data frame containing the parameters for the simulation type <em>sim_type</em>. For <em>&quot;MH&quot;</em> the parameter
is the variance of the normal distribution used to simulate the next candidate value centred on the current
value. For <em>&quot;SLICE&quot;</em> the parameters are the estimated width of the slice and a value limiting the search for the next sample.
</p>
</td></tr>
<tr><td><code id="c212.interim.1a.hier2_+3A_sim.params">sim.params</code></td>
<td>

<p>A dataframe containing simulation parameters which override the global simulation parameters (<em>global.sim.params</em>) for particular model
parameters. <em>sim.params</em> must contain the following columns: type: the simulation type (&quot;MH&quot; or &quot;SLICE&quot;); variable: the model parameter 
for which the simulation parameters are being overridden; B: the body-system (if applicable); AE: the adverse event (if applicable);
param: the simulation parameter; value: the overridden value; control: the overridden control value.
</p>
<p>The function <em>c212.sim.control.params</em> generates a template for <em>sim.params</em> which can be edited by the user.
</p>
</td></tr>
<tr><td><code id="c212.interim.1a.hier2_+3A_monitor">monitor</code></td>
<td>

<p>A dataframe indicating which sets of variables to monitor.
</p>
</td></tr>
<tr><td><code id="c212.interim.1a.hier2_+3A_initial_values">initial_values</code></td>
<td>

<p>The initial values for starting the chains. If NULL (the default) is passed the function generates the initial
values for the chains. initial_values is a list with the following format:
</p>
<pre>
list(gamma, theta, mu.gamma, mu.theta, sigma2.gamma,
		sigma2.theta)
</pre>
<p>where each element of the list is either a dataframe or array.
The function <em>c212.gen.initial.values</em> can be used to generate a template for the list which can be updated by the user if required.
The formats of the list elements are as follows:
</p>
<p><em>gamma, theta</em>: dataframe with columns <em>B</em>, <em>AE</em>, <em>chain</em>, <em>value</em>
</p>
<p><em>mu.gamma, mu.theta, sigma2.gamma, sigma2.theta</em>: dataframe with columns <em>B</em>, <em>chain</em>, <em>value</em>
</p>
</td></tr>
<tr><td><code id="c212.interim.1a.hier2_+3A_level">level</code></td>
<td>

<p>The level of longitudinal dependency between the intervals. 0 - independent intervals, 1 - common interval body-system means.
</p>
</td></tr>
<tr><td><code id="c212.interim.1a.hier2_+3A_hyper_params">hyper_params</code></td>
<td>

<p>The hyperparameters for the model. The default hyperparameters are those given in Berry and Berry 2004.
</p>
</td></tr>
<tr><td><code id="c212.interim.1a.hier2_+3A_memory_model">memory_model</code></td>
<td>

<p>Allowed values are &quot;HIGH&quot; and &quot;LOW&quot;. &quot;HIGH&quot; means use as much memory as possible. &quot;LOW&quot; means use the minimum amount of memory.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is fitted by a Gibbs sampler.
The posterior distributions for <em>gamma</em> and <em>theta</em> are sampled with either a Metropolis-Hastings step or a slice sampler.
</p>


<h3>Value</h3>

<p>The output from the simulation including all the sampled values is as follows:
</p>
<pre>
list(id, sim_type, chains, nIntervals, Intervals, nBodySys, maxBs,
	maxAEs, nAE, AE, B, burnin, iter, monitor,
	mu.gamma, mu.theta, sigma2.gamma, sigma2.theta, gamma,
	theta, gamma_acc, theta_acc)
</pre>
<p>where
</p>
<p><em>id</em> - a string identifying the version of the function
</p>
<p><em>sim_type</em> - an string identifying the sampling method used for non-standard distributions, either <em>&quot;MH&quot;</em> or <em>&quot;SLICE&quot;</em>
</p>
<p><em>chains</em> - the number of chains for which the simulation was run.
</p>
<p><em>nIntervals</em> - the number of intervals in the simulation
</p>
<p><em>Intervals</em> - an array. The intervals.
</p>
<p><em>nBodySys</em> - the number of body-systems
</p>
<p><em>maxBs</em> - the maximum number of body-systems in an interval
</p>
<p><em>maxAEs</em> - the maximum number of AEs in a body-system
</p>
<p><em>nAE</em> - an array. The number of AEs in each body-system.
</p>
<p><em>AE</em> - an array of dimension <em>nBodySys</em>, <em>maxAEs</em>. The Adverse Events.
</p>
<p><em>B</em> - an array. The body-systems.
</p>
<p><em>burnin</em> - burnin used for the simulation.
</p>
<p><em>iter</em> - the total number of iterations in the simulation.
</p>
<p><em>monitor</em> - the variables being monitored. A dataframe.
</p>
<p><em>mu.gamma</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>mu.theta</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>sigma2.gamma</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>sigma2.theta</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>gamma</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>, <em>iter - burnin</em>
</p>
<p><em>theta</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>, <em>iter - burnin</em>
</p>
<p><em>gamma_acc</em> - the acceptance rate for the gamma samples if a Metropolis-Hastings method is used. An array of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>
</p>
<p><em>theta_acc</em> - the acceptance rate for the theta samples if a Metropolis-Hastings method is used. An array of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>
</p>


<h3>Note</h3>

<p>The function performs the simulation and returns the raw output. No checks for convergence are performed. 
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(c212.trial.interval.data1)
raw = c212.interim.1a.hier2(c212.trial.interval.data1, level = 1, burnin = 100, iter = 200)
## Not run: 
data(c212.trial.interval.data1)
raw = c212.interim.1a.hier2(c212.trial.interval.data1, level = 1)

raw$B
    [,1]        [,2]         [,3]         [,4]         [,5]        
[1,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[2,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[3,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[4,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[5,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[6,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
     [,6]         [,7]         [,8]        [,9]        [,10]       [,11]      
[1,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[2,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[3,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[4,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[5,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[6,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
     [,12]       [,13]       [,14]       [,15]      
[1,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[2,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[3,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[4,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[5,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[6,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"

## End(Not run)
</code></pre>

<hr>
<h2 id='c212.interim.1a.hier3'>A Three-Level Hierarchical Body-system based Model for interim analysis without Point-Mass.</h2><span id='topic+c212.interim.1a.hier3'></span>

<h3>Description</h3>

<p>Implementation of a Three-Level Hierarchical Body-system based Model for interim analysis without Point-Mass.</p>


<h3>Usage</h3>

<pre><code class='language-R'>	c212.interim.1a.hier3(trial.data, sim_type = "SLICE", burnin = 10000,
	iter = 40000, nchains = 3,
	global.sim.params = data.frame(type = c("MH", "SLICE"),
	param = c("sigma_MH", "w"), value = c(0.2,1), control = c(0,6),
	stringsAsFactors = FALSE),
	sim.params = NULL,
	monitor = data.frame(variable = c("theta", "gamma", "mu.gamma",
	"mu.theta", "sigma2.theta", "sigma2.gamma",
	"mu.theta.0", "mu.gamma.0", "tau2.theta.0", "tau2.gamma.0"),
	monitor = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
	stringsAsFactors = FALSE),
	initial_values = NULL,
	level = 1,
	hyper_params = list(mu.gamma.0.0 = 0, tau2.gamma.0.0 = 10,
	mu.theta.0.0 = 0, tau2.theta.0.0 = 10, alpha.gamma.0.0 = 3,
	beta.gamma.0.0 = 1, alpha.theta.0.0 = 3, beta.theta.0.0 = 1,
	alpha.gamma = 3, beta.gamma = 1,
	alpha.theta = 3, beta.theta = 1),
	memory_model = "HIGH")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.interim.1a.hier3_+3A_trial.data">trial.data</code></td>
<td>

<p>A file or data frame containing the trial data. It must contain must contain the columns <em>I_index</em> (interval index), <em>B</em> (body-system), <em>AE</em> (adverse event), <em>Group</em> (1 - control, 2 treatment), <em>Count</em> (total number of events), <em>Total</em> (total number of participants in the trial
arm).
</p>
</td></tr>
<tr><td><code id="c212.interim.1a.hier3_+3A_sim_type">sim_type</code></td>
<td>

<p>The type of MCMC method to use for simulating from non-standard distributions. Allowed values are <em>&quot;MH&quot;</em>
and <em>&quot;SLICE&quot;</em> for Metropolis_Hastings and Slice sampling respectively.
</p>
</td></tr>
<tr><td><code id="c212.interim.1a.hier3_+3A_burnin">burnin</code></td>
<td>

<p>The burnin period for the monte-carlo simulation. These are discarded from the returned samples.
</p>
</td></tr>
<tr><td><code id="c212.interim.1a.hier3_+3A_iter">iter</code></td>
<td>

<p>The total number of iterations for which the monte-carlo simulation is run. This includes the burnin period.
The total number of samples returned is <em>iter - burnin</em>
</p>
</td></tr>
<tr><td><code id="c212.interim.1a.hier3_+3A_nchains">nchains</code></td>
<td>

<p>The number of independent chains to run.
</p>
</td></tr>
<tr><td><code id="c212.interim.1a.hier3_+3A_global.sim.params">global.sim.params</code></td>
<td>

<p>A data frame containing the parameters for the simulation type <em>sim_type</em>. For <em>&quot;MH&quot;</em> the parameter
is the variance of the normal distribution used to simulate the next candidate value centred on the current
value. For <em>&quot;SLICE&quot;</em> the parameters are the estimated width of the slice and a value limiting the search for the next sample.
</p>
</td></tr>
<tr><td><code id="c212.interim.1a.hier3_+3A_sim.params">sim.params</code></td>
<td>

<p>A dataframe containing simulation parameters which override the global simulation parameters (<em>global.sim.params</em>) for particular model
parameters. <em>sim.params</em> must contain the following columns: type: the simulation type (&quot;MH&quot; or &quot;SLICE&quot;); variable: the model parameter 
for which the simulation parameters are being overridden; B: the body-system (if applicable); AE: the adverse event (if applicable);
param: the simulation parameter; value: the overridden value; control: the overridden control value.
</p>
<p>The function <em>c212.sim.control.params</em> generates a template for <em>sim.params</em> which can be edited by the user.
</p>
</td></tr>
<tr><td><code id="c212.interim.1a.hier3_+3A_monitor">monitor</code></td>
<td>

<p>A dataframe indicating which sets of variables to monitor.
</p>
</td></tr>
<tr><td><code id="c212.interim.1a.hier3_+3A_initial_values">initial_values</code></td>
<td>

<p>The initial values for starting the chains. If NULL (the default) is passed the function generates the initial
values for the chains. initial_values is a list with the following format:
</p>
<pre>
list(gamma, theta, mu.gamma, mu.theta, sigma2.gamma,
	sigma2.theta, mu.gamma.0, mu.theta.0, tau2.gamma.0,
	tau2.theta.0)
</pre>
<p>where each element of the list is either a dataframe or array.
The function <em>c212.gen.initial.values</em> can be used to generate a template for the list which can be updated by the user if required.
The formats of the list elements are as follows:
</p>
<p><em>gamma, theta</em>: dataframe with columns <em>B</em>, <em>AE</em>, <em>chain</em>, <em>value</em>
</p>
<p><em>mu.gamma, mu.theta, sigma2.gamma, sigma2.theta</em>: dataframe with columns <em>B</em>, <em>chain</em>, <em>value</em>
</p>
<p><em>mu.gamma.0, mu.theta.0, tau2.gamma.0, tau2.theta.0</em>: array of size <em>chain</em>.
</p>
</td></tr>
<tr><td><code id="c212.interim.1a.hier3_+3A_level">level</code></td>
<td>

<p>The level of longitudinal dependency between the intervals. 0 - independent intervals, 1 - common interval body-system means, 2 - weak
dependency.
</p>
</td></tr>
<tr><td><code id="c212.interim.1a.hier3_+3A_hyper_params">hyper_params</code></td>
<td>

<p>The hyperparameters for the model. The default hyperparameters are those given in Berry and Berry 2004.
</p>
</td></tr>
<tr><td><code id="c212.interim.1a.hier3_+3A_memory_model">memory_model</code></td>
<td>

<p>Allowed values are &quot;HIGH&quot; and &quot;LOW&quot;. &quot;HIGH&quot; means use as much memory as possible. &quot;LOW&quot; means use the minimum amount of memory.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is fitted by a Gibbs sampler.
The posterior distributions for <em>gamma</em> and <em>theta</em> are sampled with either a Metropolis-Hastings step or a slice sampler.
</p>


<h3>Value</h3>

<p>The output from the simulation including all the sampled values is as follows:
</p>
<pre>
list(id, sim_type, chains, nIntervals, Intervals, nBodySys, maxBs,
	maxAEs, nAE, AE, B, burnin, iter, monitor,
	mu.gamma.0, mu.theta.0, tau2.gamma.0, tau2.theta.0,
	mu.gamma, mu.theta, sigma2.gamma, sigma2.theta, gamma,
	theta, gamma_acc, theta_acc)
</pre>
<p>where
</p>
<p><em>id</em> - a string identifying the version of the function
</p>
<p><em>sim_type</em> - an string identifying the sampling method used for non-standard distributions, either <em>&quot;MH&quot;</em> or <em>&quot;SLICE&quot;</em>
</p>
<p><em>chains</em> - the number of chains for which the simulation was run.
</p>
<p><em>nIntervals</em> - the number of intervals in the simulation
</p>
<p><em>Intervals</em> - an array. The intervals.
</p>
<p><em>nBodySys</em> - the number of body-systems
</p>
<p><em>maxBs</em> - the maximum number of body-systems in an interval
</p>
<p><em>maxAEs</em> - the maximum number of AEs in a body-system
</p>
<p><em>nAE</em> - an array. The number of AEs in each body-system.
</p>
<p><em>AE</em> - an array of dimension <em>nBodySys</em>, <em>maxAEs</em>. The Adverse Events.
</p>
<p><em>B</em> - an array. The body-systems.
</p>
<p><em>burnin</em> - burnin used for the simulation.
</p>
<p><em>iter</em> - the total number of iterations in the simulation.
</p>
<p><em>monitor</em> - the variables being monitored. A dataframe.
</p>
<p><em>mu.gamma.0</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
</p>
<p><em>mu.theta.0</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
</p>
<p><em>tau2.gamma.0</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
</p>
<p><em>tau2.theta.0</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
</p>
<p><em>mu.gamma</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>mu.theta</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>sigma2.gamma</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>sigma2.theta</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>gamma</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>, <em>iter - burnin</em>
</p>
<p><em>theta</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>, <em>iter - burnin</em>
</p>
<p><em>gamma_acc</em> - the acceptance rate for the gamma samples if a Metropolis-Hastings method is used. An array of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>
</p>
<p><em>theta_acc</em> - the acceptance rate for the theta samples if a Metropolis-Hastings method is used. An array of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>
</p>


<h3>Note</h3>

<p>The function performs the simulation and returns the raw output. No checks for convergence are performed. 
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(c212.trial.interval.data1)
raw = c212.interim.1a.hier3(c212.trial.interval.data1, level = 1, burnin = 100, iter = 200)
## Not run: 
data(c212.trial.interval.data1)
raw = c212.interim.1a.hier3(c212.trial.interval.data1, level = 1)

raw$B
    [,1]        [,2]         [,3]         [,4]         [,5]        
[1,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[2,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[3,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[4,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[5,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[6,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
     [,6]         [,7]         [,8]        [,9]        [,10]       [,11]      
[1,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[2,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[3,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[4,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[5,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[6,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
     [,12]       [,13]       [,14]       [,15]      
[1,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[2,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[3,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[4,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[5,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[6,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"

## End(Not run)
</code></pre>

<hr>
<h2 id='c212.interim.BB.hier2'>A Three-Level Hierarchical Body-system based Model for interim analysis with Point-Mass.</h2><span id='topic+c212.interim.BB.hier2'></span>

<h3>Description</h3>

<p>Implementation of a Three-Level Hierarchical Body-system based Model for interim analysis with Point-Mass.</p>


<h3>Usage</h3>

<pre><code class='language-R'>	c212.interim.BB.hier2(trial.data, sim_type = "SLICE", burnin = 20000,
	iter = 60000, nchains = 5, theta_algorithm = "MH",
	global.sim.params = data.frame(type = c("MH", "MH", "MH", "MH",
	"SLICE", "SLICE", "SLICE"),
	param = c("sigma_MH_alpha", "sigma_MH_beta", "sigma_MH_gamma",
	"sigma_MH_theta", "w_alpha", "w_beta", "w_gamma"),
	value = c(3, 3, 0.2, 0.5, 1, 1, 1), control = c(0, 0, 0, 0, 6, 6, 6),
	stringsAsFactors = FALSE),
	sim.params = NULL,
	monitor = data.frame(variable = c("theta", "gamma", "mu.gamma",
	"mu.theta", "sigma2.theta", "sigma2.gamma", "pi"),
	monitor = c(1, 1, 1, 1, 1, 1, 1), stringsAsFactors = FALSE),
	initial_values = NULL, level = 1,
	hyper_params = list(mu.gamma.0 = 0, tau2.gamma.0 = 10, mu.theta.0 = 0,
	tau2.theta.0 = 10, alpha.gamma = 3, beta.gamma = 1, alpha.theta = 3,
	beta.theta = 1, alpha.pi = 1.1, beta.pi = 1.1),
	global.pm.weight = 0.5,
	pm.weights = NULL,
	adapt_phase=1, memory_model = "HIGH")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.interim.BB.hier2_+3A_trial.data">trial.data</code></td>
<td>

<p>A file or data frame containing the trial data. It must contain must contain the columns <em>B</em> (body-system), <em>AE</em> (adverse event), <em>Group</em> (1 - control, 2 treatment), <em>Count</em> (total number of events), <em>Total</em> (total number of participants).
</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier2_+3A_burnin">burnin</code></td>
<td>

<p>The burnin period for the monte-carlo simulation. These are discarded from the returned samples.
</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier2_+3A_iter">iter</code></td>
<td>

<p>The total number of iterations for which the monte-carlo simulation is run. This includes the burnin period.
The total number of samples returned is <em>iter - burnin</em>
</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier2_+3A_nchains">nchains</code></td>
<td>

<p>The number of independent chains to run.
</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier2_+3A_theta_algorithm">theta_algorithm</code></td>
<td>

<p>MCMC algorithm used to sample the theta variables. &quot;MH&quot; is the only currently supported stable algorithm.
</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier2_+3A_sim_type">sim_type</code></td>
<td>

<p>The type of MCMC method to use for simulating from non-standard distributions apart from theta. Allowed values are <em>&quot;MH&quot;</em> and <em>&quot;SLICE&quot;</em> for Metropolis_Hastings and Slice sampling respectively.
</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier2_+3A_monitor">monitor</code></td>
<td>

<p>A dataframe indicating which sets of variables to monitor.
</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier2_+3A_global.sim.params">global.sim.params</code></td>
<td>

<p>A data frame containing the parameters for the simulation type <em>sim_type</em>. For <em>&quot;MH&quot;</em> the parameter
is the variance of the normal distribution used to simulate the next candidate value centred on the current
value. For <em>&quot;SLICE&quot;</em> the parameters are the estimated width of the slice and a value limiting the search for the next sample.
</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier2_+3A_sim.params">sim.params</code></td>
<td>

<p>A dataframe containing simulation parameters which override the global simulation parameters (<em>global.sim.params</em>) for particular model
parameters. <em>sim.params</em> must contain the following columns: type: the simulation type (&quot;MH&quot; or &quot;SLICE&quot;); variable: the model parameter 
for which the simulation parameters are being overridden; B: the body-system (if applicable); AE: the adverse event (if applicable);
param: the simulation parameter; value: the overridden value; control: the overridden control value.
</p>
<p>The function <em>c212.sim.control.params</em> generates a template for <em>sim.params</em> which can be edited by the user.
</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier2_+3A_initial_values">initial_values</code></td>
<td>

<p>The initial values for starting the chains. If NULL (the default) is passed the function generates the initial
values for the chains. initial_values is a list with the following format:
</p>
<pre>
list(gamma, theta, mu.gamma, mu.theta, sigma2.gamma,
	sigma2.theta, pi, mu.gamma.0, mu.theta.0,
	tau2.gamma.0, tau2.theta.0, alpha.pi, beta.pi)
</pre>
<p>The function <em>c212.gen.initial.values</em> can be used to generate a template for the list which can be updated by the user if required.
The formats of the list elements are as follows:
</p>
<p><em>gamma, theta</em>: dataframe with columns <em>B</em>, <em>AE</em>, <em>chain</em>, <em>value</em>
</p>
<p><em>mu.gamma, mu.theta, sigma2.gamma, sigma2.theta, pi</em>: dataframe with columns <em>B</em>, <em>chain</em>, <em>value</em>
</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier2_+3A_level">level</code></td>
<td>

<p>Allowed values are 0, 1. Respectively these indicate independent intervals, common body-system means across the intervals.
</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier2_+3A_hyper_params">hyper_params</code></td>
<td>

<p>The hyperparameters for the model. The default hyperparameters are those given in Berry and Berry 2004.
</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier2_+3A_global.pm.weight">global.pm.weight</code></td>
<td>
<p>A global weighting for the proposal distribution used to sample theta.</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier2_+3A_pm.weights">pm.weights</code></td>
<td>
<p>Override global.pm.weight for specific adverse events.</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier2_+3A_adapt_phase">adapt_phase</code></td>
<td>

<p>Unused parameter.
</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier2_+3A_memory_model">memory_model</code></td>
<td>

<p>Allowed values are &quot;HIGH&quot; and &quot;LOW&quot;. &quot;HIGH&quot; means use as much memory as possible. &quot;LOW&quot; means use the minimum amount of memory.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is fitted by a Gibbs sampler. The details of the complete conditional densities are given in Berry
and Berry (2004).
</p>


<h3>Value</h3>

<p>The output from the simulation including all the sampled values is as follows:
</p>
<pre>
list(id, theta_alg, sim_type, chains, nIntervals, Intervals, nBodySys,
	maxBs, maxAEs, nAE, AE, B, burnin,
	iter, monitor,
	mu.gamma, mu.theta, sigma2.gamma, sigma2.theta, pi,
	gamma, theta, gamma_acc, theta_acc)
</pre>
<p>where
</p>
<p><em>id</em> - a string identifying the version of the function
</p>
<p><em>theta_alg</em> - an string identifying the algorithm used to sample theta
</p>
<p><em>sim_type</em> - an string identifying the sampling method used for non-standard distributions, either <em>&quot;MH&quot;</em> or <em>&quot;SLICE&quot;</em>
</p>
<p><em>chains</em> - the number of chains for which the simulation was run
</p>
<p><em>nIntervals</em> - the number of intervals in the simulation
</p>
<p><em>Intervals</em> - an array. The intervals.
</p>
<p><em>nBodySys</em> - the number of body-systems
</p>
<p><em>maxBs</em> - the maximum number of body-systems in an interval
</p>
<p><em>maxAEs</em> - the maximum number of AEs in a body-system
</p>
<p><em>nAE</em> - an array. The number of AEs in each body-system.
</p>
<p><em>AE</em> - an array of dimension <em>nBodySys</em>, <em>maxAEs</em>. The Adverse Events.
</p>
<p><em>B</em> - an array. The body-systems.
</p>
<p><em>burnin</em> - burnin used for the simulation.
</p>
<p><em>iter</em> - the total number of iterations in the simulation.
</p>
<p><em>monitor</em> - the variables being monitored. A dataframe.
</p>
<p><em>mu.gamma</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>mu.theta</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>sigma2.gamma</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>sigma2.theta</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>pi</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>gamma</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>, <em>iter - burnin</em>
</p>
<p><em>theta</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>, <em>iter - burnin</em>
</p>
<p><em>gamma_acc</em> - the acceptance rate for the gamma samples if a Metropolis-Hastings method is used. An array of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>
</p>
<p><em>theta_acc</em> - the acceptance rate for the theta samples. An array of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>
</p>


<h3>Note</h3>

<p>The function performs the simulation and returns the raw output. No checks for convergence are performed. 
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(c212.trial.interval.data1)
raw = c212.interim.1a.hier2(c212.trial.interval.data1, level = 1, burnin = 100, iter = 200)

## Not run: 
data(c212.trial.interval.data1)
raw = c212.interim.1a.hier2(c212.trial.interval.data1, level = 1)

raw$B
     [,1]        [,2]         [,3]         [,4]         [,5]        
[1,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[2,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[3,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[4,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[5,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[6,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
     [,6]         [,7]         [,8]        [,9]        [,10]       [,11]      
[1,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[2,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[3,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[4,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[5,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[6,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
     [,12]       [,13]       [,14]       [,15]      
[1,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[2,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[3,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[4,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[5,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[6,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"


## End(Not run)
</code></pre>

<hr>
<h2 id='c212.interim.BB.hier3'>A Three-Level Hierarchical Body-system based Model for interim analysis with Point-Mass.</h2><span id='topic+c212.interim.BB.hier3'></span>

<h3>Description</h3>

<p>Implementation of a Three-Level Hierarchical Body-system based Model for interim analysis with Point-Mass.</p>


<h3>Usage</h3>

<pre><code class='language-R'>	c212.interim.BB.hier3(trial.data, sim_type = "SLICE", burnin = 20000,
	iter = 60000, nchains = 5, theta_algorithm = "MH",
	global.sim.params = data.frame(type = c("MH", "MH", "MH", "MH",
	"SLICE", "SLICE", "SLICE"),
	param = c("sigma_MH_alpha", "sigma_MH_beta", "sigma_MH_gamma",
	"sigma_MH_theta", "w_alpha", "w_beta", "w_gamma"),
	value = c(3, 3, 0.2, 0.25, 1, 1, 1), control = c(0, 0, 0, 0, 6, 6, 6),
	stringsAsFactors = FALSE),
	sim.params = NULL,
	monitor = data.frame(variable = c("theta", "gamma", "mu.gamma", "mu.theta",
	"sigma2.theta", "sigma2.gamma",
	"mu.theta.0", "mu.gamma.0", "tau2.theta.0", "tau2.gamma.0",
	"pi", "alpha.pi", "beta.pi"),
	monitor = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
	stringsAsFactors = FALSE),
	initial_values = NULL, level = 1, hyper_params = list(mu.gamma.0.0 = 0,
	tau2.gamma.0.0 = 10, mu.theta.0.0 = 0, tau2.theta.0.0 = 10,
	alpha.gamma.0.0 = 3, beta.gamma.0.0 = 1, alpha.theta.0.0 = 3,
	beta.theta.0.0 = 1, alpha.gamma = 3,
	beta.gamma = 1, alpha.theta = 3, beta.theta = 1,
	lambda.alpha = 1.0, lambda.beta = 1.0),
	global.pm.weight = 0.5,
	pm.weights = NULL,
	adapt_phase=1, memory_model = "HIGH")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.interim.BB.hier3_+3A_trial.data">trial.data</code></td>
<td>

<p>A file or data frame containing the trial data. It must contain must contain the columns <em>B</em> (body-system), <em>AE</em> (adverse event), <em>Group</em> (1 - control, 2 treatment), <em>Count</em> (total number of events), <em>Total</em> (total number of participants).
</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier3_+3A_burnin">burnin</code></td>
<td>

<p>The burnin period for the monte-carlo simulation. These are discarded from the returned samples.
</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier3_+3A_iter">iter</code></td>
<td>

<p>The total number of iterations for which the monte-carlo simulation is run. This includes the burnin period.
The total number of samples returned is <em>iter - burnin</em>
</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier3_+3A_nchains">nchains</code></td>
<td>

<p>The number of independent chains to run.
</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier3_+3A_theta_algorithm">theta_algorithm</code></td>
<td>

<p>MCMC algorithm used to sample the theta variables. &quot;MH&quot; is the only currently supported stable algorithm.
</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier3_+3A_sim_type">sim_type</code></td>
<td>

<p>The type of MCMC method to use for simulating from non-standard distributions apart from theta. Allowed values are <em>&quot;MH&quot;</em> and <em>&quot;SLICE&quot;</em> for Metropolis_Hastings and Slice sampling respectively.
</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier3_+3A_monitor">monitor</code></td>
<td>

<p>A dataframe indicating which sets of variables to monitor.
</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier3_+3A_global.sim.params">global.sim.params</code></td>
<td>

<p>A data frame containing the parameters for the simulation type <em>sim_type</em>. For <em>&quot;MH&quot;</em> the parameter
is the variance of the normal distribution used to simulate the next candidate value centred on the current
value. For <em>&quot;SLICE&quot;</em> the parameters are the estimated width of the slice and a value limiting the search for the next sample.
</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier3_+3A_sim.params">sim.params</code></td>
<td>

<p>A dataframe containing simulation parameters which override the global simulation parameters (<em>global.sim.params</em>) for particular model
parameters. <em>sim.params</em> must contain the following columns: type: the simulation type (&quot;MH&quot; or &quot;SLICE&quot;); variable: the model parameter 
for which the simulation parameters are being overridden; B: the body-system (if applicable); AE: the adverse event (if applicable);
param: the simulation parameter; value: the overridden value; control: the overridden control value.
</p>
<p>The function <em>c212.sim.control.params</em> generates a template for <em>sim.params</em> which can be edited by the user.
</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier3_+3A_initial_values">initial_values</code></td>
<td>

<p>The initial values for starting the chains. If NULL (the default) is passed the function generates the initial
values for the chains. initial_values is a list with the following format:
</p>
<pre>
list(gamma, theta, mu.gamma, mu.theta, sigma2.gamma,
	sigma2.theta, pi, mu.gamma.0, mu.theta.0,
	tau2.gamma.0, tau2.theta.0, alpha.pi, beta.pi)
</pre>
<p>The function <em>c212.gen.initial.values</em> can be used to generate a template for the list which can be updated by the user if required.
The formats of the list elements are as follows:
</p>
<p><em>gamma, theta</em>: dataframe with columns <em>B</em>, <em>AE</em>, <em>chain</em>, <em>value</em>
</p>
<p><em>mu.gamma, mu.theta, sigma2.gamma, sigma2.theta, pi</em>: dataframe with columns <em>B</em>, <em>chain</em>, <em>value</em>
</p>
<p><em>mu.gamma.0, mu.theta.0, tau2.gamma.0, tau2.theta.0, alpha.pi, beta.pi</em>: array of size <em>chain</em>.
</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier3_+3A_level">level</code></td>
<td>

<p>Allowed values are 0, 1, 2. Respectively these indicate independent intervals, common body-system means across the intervals and weak relationships between the intervals.
</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier3_+3A_hyper_params">hyper_params</code></td>
<td>

<p>The hyperparameters for the model. The default hyperparameters are those given in Berry and Berry 2004.
</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier3_+3A_global.pm.weight">global.pm.weight</code></td>
<td>
<p>A global weighting for the proposal distribution used to sample theta.</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier3_+3A_pm.weights">pm.weights</code></td>
<td>
<p>Override global.pm.weight for specific adverse events.</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier3_+3A_adapt_phase">adapt_phase</code></td>
<td>

<p>Unused parameter.
</p>
</td></tr>
<tr><td><code id="c212.interim.BB.hier3_+3A_memory_model">memory_model</code></td>
<td>

<p>Allowed values are &quot;HIGH&quot; and &quot;LOW&quot;. &quot;HIGH&quot; means use as much memory as possible. &quot;LOW&quot; means use the minimum amount of memory.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is fitted by a Gibbs sampler. The details of the complete conditional densities are given in Berry
and Berry (2004).
</p>


<h3>Value</h3>

<p>The output from the simulation including all the sampled values is as follows:
</p>
<pre>
list(id, theta_alg, sim_type, chains, nIntervals, Intervals, nBodySys,
	maxBs, maxAEs, nAE, AE, B, burnin,
	iter, monitor, mu.gamma.0, mu.theta.0, tau2.gamma.0, tau2.theta.0,
	mu.gamma, mu.theta, sigma2.gamma, sigma2.theta, pi, alpha.pi, beta.pi,
	alpha.pi_acc, beta.pi_acc, gamma, theta, gamma_acc, theta_acc)
</pre>
<p>where
</p>
<p><em>id</em> - a string identifying the version of the function
</p>
<p><em>theta_alg</em> - an string identifying the algorithm used to sample theta
</p>
<p><em>sim_type</em> - an string identifying the sampling method used for non-standard distributions, either <em>&quot;MH&quot;</em> or <em>&quot;SLICE&quot;</em>
</p>
<p><em>chains</em> - the number of chains for which the simulation was run
</p>
<p><em>nIntervals</em> - the number of intervals in the simulation
</p>
<p><em>Intervals</em> - an array. The intervals.
</p>
<p><em>nBodySys</em> - the number of body-systems
</p>
<p><em>maxBs</em> - the maximum number of body-systems in an interval
</p>
<p><em>maxAEs</em> - the maximum number of AEs in a body-system
</p>
<p><em>nAE</em> - an array. The number of AEs in each body-system.
</p>
<p><em>AE</em> - an array of dimension <em>nBodySys</em>, <em>maxAEs</em>. The Adverse Events.
</p>
<p><em>B</em> - an array. The body-systems.
</p>
<p><em>burnin</em> - burnin used for the simulation.
</p>
<p><em>iter</em> - the total number of iterations in the simulation.
</p>
<p><em>monitor</em> - the variables being monitored. A dataframe.
</p>
<p><em>mu.gamma.0</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
</p>
<p><em>mu.theta.0</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
</p>
<p><em>tau2.gamma.0</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
</p>
<p><em>tau2.theta.0</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
</p>
<p><em>mu.gamma</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>mu.theta</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>sigma2.gamma</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>sigma2.theta</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
</p>
<p><em>pi</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em> <em>iter - burnin</em>
<em>alpha.pi</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
<em>beta.pi</em> - array of samples of dimension <em>chains</em>, <em>iter - burnin</em>
</p>
<p><em>alpha.pi_acc</em> - the acceptance rate for the alpha.pi samples if a Metropolis-Hastings method is used. An array of dimension <em>chains</em>, <em>maxAEs</em>
</p>
<p><em>beta.pi_acc</em> - the acceptance rate for the beta.pi samples if a Metropolis-Hastings method is used. An array of dimension <em>chains</em>, <em>maxAEs</em>
</p>
<p><em>gamma</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>, <em>iter - burnin</em>
</p>
<p><em>theta</em> - array of samples of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>, <em>iter - burnin</em>
</p>
<p><em>gamma_acc</em> - the acceptance rate for the gamma samples if a Metropolis-Hastings method is used. An array of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>
</p>
<p><em>theta_acc</em> - the acceptance rate for the theta samples. An array of dimension <em>chains</em>, <em>nBodySys</em>, <em>maxAEs</em>
</p>


<h3>Note</h3>

<p>The function performs the simulation and returns the raw output. No checks for convergence are performed. 
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(c212.trial.interval.data1)
raw = c212.interim.BB.hier3(c212.trial.interval.data1, level = 1, burnin = 100, iter = 200)

## Not run: 
data(c212.trial.interval.data1)
raw = c212.interim.BB.hier3(c212.trial.interval.data1, level = 1)

raw$B
     [,1]        [,2]         [,3]         [,4]         [,5]        
[1,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[2,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[3,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[4,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[5,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
[6,] "Bdy-sys_1" "Bdy-sys_10" "Bdy-sys_11" "Bdy-sys_12" "Bdy-sys_13"
     [,6]         [,7]         [,8]        [,9]        [,10]       [,11]      
[1,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[2,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[3,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[4,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[5,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
[6,] "Bdy-sys_14" "Bdy-sys_15" "Bdy-sys_2" "Bdy-sys_3" "Bdy-sys_4" "Bdy-sys_5"
     [,12]       [,13]       [,14]       [,15]      
[1,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[2,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[3,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[4,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[5,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"
[6,] "Bdy-sys_6" "Bdy-sys_7" "Bdy-sys_8" "Bdy-sys_9"


## End(Not run)
</code></pre>

<hr>
<h2 id='c212.interim.MLE'>Poisson Maximum Likelihood Estimator</h2><span id='topic+c212.interim.MLE'></span>

<h3>Description</h3>

<p>Calculate the Poisson Maximum Likelihood Estimator for interim analysis data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	c212.interim.MLE(trial.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.interim.MLE_+3A_trial.data">trial.data</code></td>
<td>

<p>A file or data frame containing the trial data. It must contain must contain the columns <em>I_index</em> (interval index), <em>B</em> (body-system), <em>AE</em> (adverse event), <em>Group</em> (1 - control, 2 treatment), <em>Count</em> (total number of events), <em>Total</em> (total number of participants in the trial
arm).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The maximum likelihood estimators and summary statistics.
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(c212.trial.interval.data1)
data &lt;- c212.trial.interval.data1[ c212.trial.interval.data1$Interval == "0.0-180.0",]
raw = c212.interim.MLE(data)
## Not run: 
data(c212.trial.interval.data1)
raw = c212.interim.MLE(c212.trial.interval.data1)


## End(Not run)
</code></pre>

<hr>
<h2 id='c212.LSL'>
Implementaion of the least-slope estimator estimator (LSL) for the proportion of true null hypotheses.
</h2><span id='topic+c212.LSL'></span>

<h3>Description</h3>

<p>The least-slope estimator estimator (LSL) is one of a number of estimators of the proportion of true null hypotheses. This implementation assumes a grouped structure for the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c212.LSL(trial.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.LSL_+3A_trial.data">trial.data</code></td>
<td>

<p>Data frame containing the p-values for the hypotheses being tested. The data must contain the following columns: <em>B</em>: the index or name of the groupings; <em>p</em>: the p-values of the hypotheses.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An estimate of the proportion of true null hypotheses.
</p>


<h3>Note</h3>

<p>The implementation is that described in Hu, J. X. and Zhao, H. and Zhou, H. H. (2010).
</p>


<h3>Author(s)</h3>

<p>R. Carragher&lt;raymond.carragher@strath.ac.uk&gt;
</p>


<h3>References</h3>

<p>Hu, J. X. and Zhao, H. and Zhou, H. H. (2010). False Discovery Rate Control With Groups. J Am Stat Assoc, 105(491):1215-1227.
</p>
<p>Benjamini Y, Hochberg Y. (2000). On the Adaptive Control of the False Discovery Rate in Multiple Testing
With Independent Statistics. Journal of Educational and Behavioral Statistics, 25(1):60–83.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(c212.FDR.data)
lsl &lt;- c212.LSL(c212.FDR.data)
print(lsl)
## Not run: 
          B       pi0
1 Bdy-sys_5 1.0000000
2 Bdy-sys_6 1.0000000
3 Bdy-sys_7 1.0000000
4 Bdy-sys_8 1.0000000
5 Bdy-sys_2 1.0000000
6 Bdy-sys_3 0.2857143
7 Bdy-sys_4 1.0000000
8 Bdy-sys_1 1.0000000

## End(Not run)
</code></pre>

<hr>
<h2 id='c212.monitor.samples'>Generate a template for choosing which samples to monitor.</h2><span id='topic+c212.monitor.samples'></span>

<h3>Description</h3>

<p>This function generate a template for choosing which samples to monitor based on the model and hierarchy. As some of the MCMC model 
simulations require large amounts of memory choosing not to monitor samples reduced the overall memory footprint.</p>


<h3>Usage</h3>

<pre><code class='language-R'>	c212.monitor.samples(model = "1a", hier = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.monitor.samples_+3A_model">model</code></td>
<td>

<p>Allowed values are &quot;1a&quot; and &quot;BB&quot;. &quot;BB&quot; models include a point-mass. 
</p>
</td></tr>
<tr><td><code id="c212.monitor.samples_+3A_hier">hier</code></td>
<td>

<p>Allowed values are 2 and 3. Generate a template for a 2 or 3 level hierarchy.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing two columns:
</p>
<p><em>variable</em>: the name of a class of variables e.g. &quot;theta&quot;
<em>monitor</em>: 0 - don't monitor, 1 - monitor.
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c212.monitor.samples("1a", hier = 3)
## Not run: 
c212.monitor.samples("1a", hier = 3)
       variable monitor
1         theta       1
2         gamma       0
3      mu.gamma       0
4      mu.theta       0
5  sigma2.theta       0
6  sigma2.gamma       0
7    mu.theta.0       0
8    mu.gamma.0       0
9  tau2.theta.0       0
10 tau2.gamma.0       0

## End(Not run)
</code></pre>

<hr>
<h2 id='c212.NOADJ'>Unadjusted test of multiple hypotheses.</h2><span id='topic+c212.NOADJ'></span>

<h3>Description</h3>

<p>Unadjusted test of multiple hypotheses.</p>


<h3>Usage</h3>

<pre><code class='language-R'>c212.NOADJ(trial.data, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.NOADJ_+3A_trial.data">trial.data</code></td>
<td>

<p>File or data frame containing the p-values for the hypotheses being tested. The data must include a column called <em>p</em> which contains
the p-values of the hypotheses.
</p>
</td></tr>
<tr><td><code id="c212.NOADJ_+3A_alpha">alpha</code></td>
<td>

<p>The level for FDR control. E.g. 0.05.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The subset of hypotheses in <em>file</em> or <em>trial.data</em> deemed significant at level <em>alpha</em>.
</p>


<h3>Note</h3>

<p>No check is made for duplicate rows in the input file or data frame.
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
trial.data &lt;- data.frame(B = c(1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4),
j = c(1, 1, 2, 3, 4, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5),
AE = c("AE1", "AE2", "AE3", "AE4", "AE5", "AE6", "AE7", "AE8", "AE9", "AE10", "AE11",
"AE12", "AE13", "AE14", "AE15", "AE16", "AE17"),
p = c(0.135005, 0.010000, 0.001000, 0.005000, 0.153501, 0.020000, 0.0013, 0.0023,
0.011, 0.023000, 0.016, 0.0109, 0.559111, 0.751986, 0.308339, 0.837154, 0.325882))

c212.NOADJ(trial.data, alpha=0.05)

## Not run: 
   B j   AE      p
1  2 2  AE3 0.0010
2  3 2  AE7 0.0013
3  3 3  AE8 0.0023
4  2 3  AE4 0.0050
5  2 1  AE2 0.0100
6  3 7 AE12 0.0109
7  3 4  AE9 0.0110
8  3 6 AE11 0.0160
9  3 1  AE6 0.0200
10 3 5 AE10 0.0230


## End(Not run)
</code></pre>

<hr>
<h2 id='c212.plot.eot.data'>Plot Adverse Event Incidence Data</h2><span id='topic+c212.plot.eot.data'></span>

<h3>Description</h3>

<p>This function plots a graph of the total adverse event incidence counts by body-system and by individual
adverse event for end of trial data. </p>


<h3>Usage</h3>

<pre><code class='language-R'>	c212.plot.eot.data(trial.data, legend = TRUE, interactive = FALSE,
		cex = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.plot.eot.data_+3A_trial.data">trial.data</code></td>
<td>

<p>A file or data frame containing the trial data. The data frame must contain the columns <em>B</em> (body-system), <em>AE</em> (adverse event), <em>Group</em> (1 - control, 2 treatment), <em>Count</em> (total number of events), <em>Total</em> (total number of participants).
</p>
</td></tr>
<tr><td><code id="c212.plot.eot.data_+3A_legend">legend</code></td>
<td>

<p>Boolean. If TRUE print a legend.
</p>
</td></tr>
<tr><td><code id="c212.plot.eot.data_+3A_interactive">interactive</code></td>
<td>

<p>Boolean. If TRUE allow the user to identify individual adverse events on the individual adverse events graph.
</p>
</td></tr>
<tr><td><code id="c212.plot.eot.data_+3A_cex">cex</code></td>
<td>

<p>Font size of the labels on the Adverse Event counts graph.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two graphs are displayed on the same panel. The top graph is of AE Incidence Counts by Body-System. The
lower graphs is of the Individual AE Incidence Counts.
</p>


<h3>Value</h3>

<p>Nothing is returned.
</p>


<h3>Note</h3>

<p>The legend may obscure a portion of the graph. In this case the legend may be suppressed by choosing <em>legend = FALSE</em> when calling the function.
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(c212.trial.data)
c212.plot.eot.data(c212.trial.data)

## End(Not run)
</code></pre>

<hr>
<h2 id='c212.plot.interim.data.rd'>Plot Adverse Event Count Data for a Body-system by Interval</h2><span id='topic+c212.plot.interim.data'></span>

<h3>Description</h3>

<p>Plot adverse event interval data for a body-system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	c212.plot.interim.data(trial.data, body_sys, cex = 0.8, title = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.plot.interim.data.rd_+3A_trial.data">trial.data</code></td>
<td>

<p>A file or data frame containing the trial data. The data frame must contain the columns <em>I_index</em> (interval), <em>B</em> (body-system), <em>AE</em> (adverse event), <em>Group</em> (1 - control, 2 treatment), <em>Count</em> (total number of events), <em>Exposure</em> (total time of participants spent in the interval).
</p>
</td></tr>
<tr><td><code id="c212.plot.interim.data.rd_+3A_body_sys">body_sys</code></td>
<td>

<p>The body-system for which to plot the events.
</p>
</td></tr>
<tr><td><code id="c212.plot.interim.data.rd_+3A_cex">cex</code></td>
<td>

<p>Font size of the labels on the Adverse Event counts graph.
</p>
</td></tr>
<tr><td><code id="c212.plot.interim.data.rd_+3A_title">title</code></td>
<td>

<p>Main title of the graph.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots a graph of the count of adverse events which have occurred in an interval for a particular body-system by interval.
</p>


<h3>Value</h3>

<p>Nothing is returned.
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(c212.trial.interval.data1)
c212.plot.interim.data(c212.trial.interval.data1, "Bdy-sys_3")

## End(Not run)
</code></pre>

<hr>
<h2 id='c212.plot.samples'>Plot Posterior Distribution</h2><span id='topic+c212.plot.samples'></span>

<h3>Description</h3>

<p>This function plots a graph of the sampled posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	c212.plot.samples(samples, title)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.plot.samples_+3A_samples">samples</code></td>
<td>

<p>An array of samples indexed by <em>chain</em>.
</p>
</td></tr>
<tr><td><code id="c212.plot.samples_+3A_title">title</code></td>
<td>

<p>The graph title.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two graphs are displayed on the same panel. The left graph is the traceplot of the chains. The right graph is
a plot of the distribution.
</p>


<h3>Value</h3>

<p>Nothing is returned.
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(c212.trial.data)
raw = c212.1a(c212.trial.data)
sample = raw$theta[,2,2,]
c212.plot.samples(sample, sprintf("%s: %s %s", "theta", raw$B[2], raw$AE[2]))

## End(Not run)
</code></pre>

<hr>
<h2 id='c212.pointmass.weights'>Generate a template for the point-mass weightings.</h2><span id='topic+c212.pointmass.weights'></span>

<h3>Description</h3>

<p>This function generate a template for weights for the proposal distribution used to sample <em>theta</em> variables in models which 
use a point-mass.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	c212.pointmass.weights(trial.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.pointmass.weights_+3A_trial.data">trial.data</code></td>
<td>

<p>A file or data frame containing the trial data, either for end of trial or interim analysis.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing the weightings template for each Body-system, adverse event and, if required, interval.
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(c212.trial.data)
pmw &lt;- c212.pointmass.weights(c212.trial.data)
head(pmw)
## Not run: 
data(c212.trial.data)
pmw &lt;- c212.pointmass.weights(c212.trial.data)
head(pmw)
          B        AE weight_pm
1 Bdy-sys_2  Adv-Ev_5       0.5
2 Bdy-sys_5 Adv-Ev_24       0.5
3 Bdy-sys_6 Adv-Ev_31       0.5
4 Bdy-sys_8 Adv-Ev_42       0.5
5 Bdy-sys_7 Adv-Ev_39       0.5
6 Bdy-sys_6 Adv-Ev_34       0.5

## End(Not run)
</code></pre>

<hr>
<h2 id='c212.print.convergence.summary'>Print a Summary of the Convergence Diagnostics of the Simulation</h2><span id='topic+c212.print.convergence.summary'></span>

<h3>Description</h3>

<p>The function prints the maximum and minimum values of either Gelman-Rubin diagnostic or the Geweke diagnostic
for each group of samples, e.g. theta, gamma, mu.gamma etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	c212.print.convergence.summary(conv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.print.convergence.summary_+3A_conv">conv</code></td>
<td>

<p>The output from a call to <em>c212.convergence.diag</em>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Note</h3>

<p>The Geweke statistic is a Z-score calculated from a single chain. Due to the large number of variables sampled
it is possible that a certain number will be deemed significant (at the 5% level) even though the simulation
may have converged.
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(c212.trial.data)
raw = c212.BB(c212.trial.data, burnin = 100, iter = 200)
conv = c212.convergence.diag(raw)
c212.print.convergence.summary(conv)
## Not run: 
data(c212.trial.data)
raw = c212.BB(c212.trial.data)
conv = c212.convergence.diag(raw)
c212.print.convergence.summary(conv)

## End(Not run)
</code></pre>

<hr>
<h2 id='c212.print.summary.stats'>Print the Summary Statistics of Posterior Distributions</h2><span id='topic+c212.print.summary.stats'></span>

<h3>Description</h3>

<p>The function prints the variable names, the mean, the 95
MCMC standard error for the simulated sample.</p>


<h3>Usage</h3>

<pre><code class='language-R'>	c212.print.summary.stats(summ)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.print.summary.stats_+3A_summ">summ</code></td>
<td>

<p>The output from a call to <em>c212.summary.stats</em>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(c212.trial.data)
raw = c212.BB(c212.trial.data, burnin = 100, iter = 200)
summ = c212.summary.stats(raw)
c212.print.summary.stats(summ)
## Not run: 
data(c212.trial.data)
raw = c212.BB(c212.trial.data, burnin = 100, iter = 200)
summ = c212.summary.stats(raw)
c212.print.summary.stats(summ)

## End(Not run)
</code></pre>

<hr>
<h2 id='c212.ptheta'>Reports the posterior probability that theta (the increase in the log-odds) is greater than zero for each Adverse Event</h2><span id='topic+c212.ptheta'></span>

<h3>Description</h3>

<p>This function reports the posterior probability that theta is positive, i.e. that there is an increase in log
odds of an adverse event being associated with treatment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	c212.ptheta(raw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.ptheta_+3A_raw">raw</code></td>
<td>

<p>The output from a call to c212.BB.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the columns: <em>interval</em> if analysing interim data, <em>B</em>: body system, <em>AE</em>: adverse event and <em>ptheta</em>, the posterior probability that theta is positive.
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(c212.trial.data)
raw = c212.BB(c212.trial.data, burnin = 100, iter = 200)
p = c212.ptheta(raw)
head(p)

## Not run: 
data(c212.trial.data)
raw = c212.BB(c212.trial.data)

## End(Not run)

## Not run: 
p = c212.ptheta(raw)

head(p)
          B       AE    ptheta
1 Bdy-sys_1 Adv-Ev_1 0.2560500
2 Bdy-sys_2 Adv-Ev_2 0.9426417
3 Bdy-sys_2 Adv-Ev_3 0.8751500
4 Bdy-sys_2 Adv-Ev_4 0.1154917
5 Bdy-sys_2 Adv-Ev_5 0.2317417
6 Bdy-sys_3 Adv-Ev_6 1.0000000

## End(Not run)
</code></pre>

<hr>
<h2 id='c212.sim.control.params'>Generate a template for the individual model parameter simulation control parameters.</h2><span id='topic+c212.sim.control.params'></span>

<h3>Description</h3>

<p>This function generates a template for overriding the global simulation parameters used by the model simulation functions (e.g. c212.BB).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	c212.sim.control.params(trial.data, model = "1a")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.sim.control.params_+3A_trial.data">trial.data</code></td>
<td>

<p>A file or data frame containing the trial data, either for end of trial or interim analysis.
</p>
</td></tr>
<tr><td><code id="c212.sim.control.params_+3A_model">model</code></td>
<td>

<p>Allowed values are &quot;BB&quot; and &quot;1a&quot; for point-mass and non-point-mass models respectively.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing the simulation parameters template.
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(c212.trial.data)
s.p &lt;- c212.sim.control.params(c212.trial.data)
head(s.p)
## Not run: 
data(c212.trial.data)
s.p &lt;- c212.sim.control.params(c212.trial.data)
head(s.p)

   type variable         B        AE param value control
1 SLICE    gamma Bdy-sys_2  Adv-Ev_5     w     1       6
2 SLICE    gamma Bdy-sys_5 Adv-Ev_24     w     1       6
3 SLICE    gamma Bdy-sys_6 Adv-Ev_31     w     1       6
4 SLICE    gamma Bdy-sys_8 Adv-Ev_42     w     1       6
5 SLICE    gamma Bdy-sys_7 Adv-Ev_39     w     1       6
6 SLICE    gamma Bdy-sys_6 Adv-Ev_34     w     1       6


## End(Not run)
</code></pre>

<hr>
<h2 id='c212.ssBH'>Implementation of Subset Benjamini-Hochberg for False Discover Rate control</h2><span id='topic+c212.ssBH'></span>

<h3>Description</h3>

<p>The Subset Benjamini-Hochberg allows for the use of subsets to allow the extension of the Benjamini-Hochberg
procedure to types of non-positively dependent regression statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c212.ssBH(trial.data, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.ssBH_+3A_trial.data">trial.data</code></td>
<td>
<p>File or data frame containing the p-values for the hypotheses being tested. 
The data must contain the following columns: <em>B</em>: the index of the groupings; <em>p</em>: the p-values of the hypotheses.</p>
</td></tr>
<tr><td><code id="c212.ssBH_+3A_alpha">alpha</code></td>
<td>

<p>The level for FDR control. E.g. 0.05.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The subset of hypotheses in <em>file</em> or <em>trial.data</em> deemed significant by the Subset Benjamini-Hochberg process.
</p>


<h3>Note</h3>

<p>This process is at most as powerful as the Benjamini-Hochberg procedure.
The subsets do not have to be disjoint.
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>References</h3>

<p>Yekutieli, Daniel (2008). False discovery rate control for non-positively regression dependent test statistics. Journal of Statistical Planning and Inference, 138(2):405-415.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trial.data &lt;- data.frame(B = c(1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4),
j = c(1, 1, 2, 3, 4, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5),
AE = c("AE1", "AE2", "AE3", "AE4", "AE5", "AE6", "AE7", "AE8", "AE9", "AE10", "AE11",
"AE12", "AE13", "AE14", "AE15", "AE16", "AE17"),
p = c(0.135005, 0.010000, 0.001000, 0.005000, 0.153501, 0.020000, 0.0013, 0.0023,
0.011, 0.023000, 0.016, 0.0109, 0.559111, 0.751986, 0.308339, 0.837154, 0.325882))

c212.ssBH(trial.data, alpha=0.05)

## Not run: 
  B j   AE      p
1 2 2  AE3 0.0010
2 2 3  AE4 0.0050
3 3 2  AE7 0.0013
4 3 3  AE8 0.0023
5 3 7 AE12 0.0109
6 3 4  AE9 0.0110

## End(Not run)
</code></pre>

<hr>
<h2 id='c212.summary.stats'>Summary Statistics for the Posterior Distributions in the model.</h2><span id='topic+c212.summary.stats'></span>

<h3>Description</h3>

<p>Returns the Summary Statistics for the Posterior Distributions in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	c212.summary.stats(raw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.summary.stats_+3A_raw">raw</code></td>
<td>

<p>The output from a model simulation (e.g. c212.BB).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function reports the mean, upper and lower bounds of the 95
standard deviation and MCMC standard error.
</p>


<h3>Value</h3>

<p>Returns a list of the summary statistics for each sampled variable.
Each element of the list is a data.frame containing at least the columns <em>mean</em>, <em>hpi_lower</em>,
<em>hpi_upper</em>, <em>SD</em> and <em>SE</em>.
For the simulation return by <em>c212.1a</em> the output is as follows:
</p>
<pre>
list(theta.summary, gamma.summary, mu.gamma.summary,
								mu.theta.summary = mu.theta_summ,
								sigma2.gamma.summary, sigma2.theta.summary,
								mu.gamma.0.summary, mu.theta.0.summary,
								tau2.gamma.0.summary, tau2.theta.0.summary)
</pre>
<p>Additional columns which may be used to identify the individual variables are <em>B</em>, the body-system, and
<em>AE</em>, the Adverse Event and <em>interval</em>.
</p>


<h3>Note</h3>

<p>The MCMC error is found using the 'coda' summary function.
</p>


<h3>Author(s)</h3>

<p>R. Carragher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(c212.trial.data)
raw = c212.BB(c212.trial.data, burnin = 100, iter = 200)
summ = c212.summary.stats(raw)
## Not run: 
data(c212.trial.data)
raw = c212.BB(c212.trial.data)
summ = c212.summary.stats(raw)

## End(Not run)
</code></pre>

<hr>
<h2 id='c212.trial.data'>End of Trial Data Clinical Data for Adverse Event Incidence</h2><span id='topic+c212.trial.data'></span>

<h3>Description</h3>

<p>This data set contains the counts of adverse event incidence for the trial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(c212.trial.data)</code></pre>


<h3>Format</h3>

<p>A dataframe with columns <em>B</em> - body-system, <em>AE</em> - adverse event, <em>Group</em> - 1 for control, 2 for treatment, <em>Count</em> - total adverse event incidence, <em>Total</em> - total patients on the trial arm.
The dataframe contains 90 observations.</p>

<hr>
<h2 id='c212.trial.interval.data1'>Interim analysis trial data.</h2><span id='topic+c212.trial.interval.data1'></span>

<h3>Description</h3>

<p>This data set contains count of the adverse events over the first two intervals of a clinical trial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(c212.trial.interval.data1)</code></pre>


<h3>Format</h3>

<p>A dataframe with columns <em>interval</em>, <em>I_index</em> - the interval order, <em>B</em> - body-system, <em>AE</em> - adverse event, <em>Group</em> - 1 for control, 2 for treatment, <em>Count</em> - total adverse events that occurred in the interval, <em>Exposure</em> - the total time all at risk subjects spent in the interval.
The dataframe contains 1860 observations.</p>

<hr>
<h2 id='c212.trial.interval.data2'>Interim analysis trial data.</h2><span id='topic+c212.trial.interval.data2'></span>

<h3>Description</h3>

<p>This data set contains count of the adverse events over all intervals of a clinical trial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(c212.trial.interval.data2)</code></pre>


<h3>Format</h3>

<p>A dataframe with columns <em>interval</em>, <em>I_index</em> - the interval order, <em>B</em> - body-system, <em>AE</em> - adverse event, <em>Group</em> - 1 for control, 2 for treatment, <em>Count</em> - total adverse events that occurred in the interval, <em>Exposure</em> - the total time all at risk subjects spent in the interval.
The dataframe contains 3100 observations.</p>

<hr>
<h2 id='c212.TST'>
Implementaion of the two-stage estimator (TST) for the proportion of true null hypotheses.
</h2><span id='topic+c212.TST'></span>

<h3>Description</h3>

<p>The two-stage estimator (TST) is one of a number of estimators of the proportion of true null hypotheses. It
uses the Benjamini-Hochberg procedure at a reduced level to make the estimate. This implementation assumes
a grouped structure for the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c212.TST(trial.data, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c212.TST_+3A_trial.data">trial.data</code></td>
<td>

<p>Data frame containing the p-values for the hypotheses being tested. The data must contain the following columns: <em>B</em>: the index or name of the groupings; <em>p</em>: the p-values of the hypotheses.
</p>
</td></tr>
<tr><td><code id="c212.TST_+3A_alpha">alpha</code></td>
<td>

<p>The level for FDR control. E.g. 0.05.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An estimate of the proportion of true null hypotheses.
</p>


<h3>Note</h3>

<p>The implementation is that described in Hu, J. X. and Zhao, H. and Zhou, H. H. (2010).
</p>


<h3>Author(s)</h3>

<p>R. Carragher&lt;raymond.carragher@strath.ac.uk&gt;
</p>


<h3>References</h3>

<p>Hu, J. X. and Zhao, H. and Zhou, H. H. (2010). False Discovery Rate Control With Groups. J Am Stat Assoc, 105(491):1215-1227.
</p>
<p>Y. Benjamini, A. M. Krieger, and D. Yekutieli (2006). Adaptive linear step-up procedures that
control the false discovery rate. Biometrika, 93(3):491–507.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(c212.FDR.data)
c212.TST(c212.FDR.data)
## Not run: 
          B pi0
1 Bdy-sys_5 1.0
2 Bdy-sys_6 1.0
3 Bdy-sys_7 1.0
4 Bdy-sys_8 1.0
5 Bdy-sys_2 0.5
6 Bdy-sys_3 0.0
7 Bdy-sys_4 1.0
8 Bdy-sys_1 1.0

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
