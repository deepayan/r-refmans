<!DOCTYPE html><html lang="en"><head><title>Help for package fasterRaster</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fasterRaster}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fasterRaster'><p>&quot;fasterRaster&quot;: Faster raster and spatial vector processing using &quot;GRASS GIS&quot;</p></a></li>
<li><a href='#.backdoor'><p>Setup fasterRaster for ABS</p></a></li>
<li><a href='#.copyGSpatial+2CGRaster-method'><p>Make a copy of an object in GRASS</p></a></li>
<li><a href='#.exists+2CGRaster-method'><p>Does the &quot;GRASS&quot; representation of a GRaster or GVector exist?</p></a></li>
<li><a href='#.ext'><p>Function to get extent from a &quot;sources&quot; name of a raster or vector</p></a></li>
<li><a href='#.g.proj'><p>Call GRASS <code>g.proj</code> module</p></a></li>
<li><a href='#.g.region'><p>Call GRASS <code>g.region</code> module</p></a></li>
<li><a href='#.geomtype'><p>Get geometry type from the sources() name of a vector</p></a></li>
<li><a href='#.layerIndex'><p>Get index of raster layers</p></a></li>
<li><a href='#.location+2CGLocation-method'><p>GRASS &quot;location&quot; of an object or the active session</p></a></li>
<li><a href='#.locationCreate+2Ccharacter-method'><p>Connect to &quot;GRASS&quot;</p></a></li>
<li><a href='#.locationFind+2Cmissing-method'><p>Match CRS of a GSpatial object and an existing &quot;GRASS&quot; location</p></a></li>
<li><a href='#.locationRestore+2Ccharacter-method'><p>Revert to a previously-created &quot;GRASS&quot; &quot;location&quot;</p></a></li>
<li><a href='#.locations'><p>Meta-data on active GRASS locations</p></a></li>
<li><a href='#.ls'><p>List objects in the active GRASS session</p></a></li>
<li><a href='#.makeGRaster'><p>Create a GRaster</p></a></li>
<li><a href='#.makeGVector'><p>Create a GVector</p></a></li>
<li><a href='#.makeSourceName'><p>Make unique GRASS name for rasters, vectors, etc.</p></a></li>
<li><a href='#.mapset+2CGLocation-method'><p>GRASS &quot;mapset&quot; of an object or the active session</p></a></li>
<li><a href='#.maxVal'><p>Get maximum value from GRaster metadata</p></a></li>
<li><a href='#.message'><p>Display warning or message</p></a></li>
<li><a href='#.minVal'><p>Get minimum value from GRaster metadata</p></a></li>
<li><a href='#.nlevels'><p>Count number of levels from a data.frame/table, list, or SpatRaster</p></a></li>
<li><a href='#.plot'><p>Plot using a G-object's <code>sources()</code> name</p></a></li>
<li><a href='#.projection'><p>Get &quot;GRASS&quot; projection of raster or vector</p></a></li>
<li><a href='#.quiet'><p>Returns .quiet() or NULL for &quot;flags&quot; argument to GRASS modules</p></a></li>
<li><a href='#.rastInfo'><p>Metadata on rasters and vectors in GRASS</p></a></li>
<li><a href='#.region+2Cmissing-method'><p>Report or change the extent, dimensions, and/or resolution of a region GRASS</p></a></li>
<li><a href='#.rename'><p>Rename a raster or vector in an existing GRASS session</p></a></li>
<li><a href='#.rm'><p>Delete objects in the active GRASS session</p></a></li>
<li><a href='#.vAsDataTable'><p>Convert a GRASS vector's attribute table to a data.table</p></a></li>
<li><a href='#.vAttachDatabase'><p>Add a database table to a GRASS attribute table</p></a></li>
<li><a href='#.vCats'><p>Category column values of a GRASS vector</p></a></li>
<li><a href='#.vDetachDatabase'><p>Add a database table to a GRASS attribute table</p></a></li>
<li><a href='#.vectInfo'><p>Metadata on a vector in GRASS</p></a></li>
<li><a href='#.vHasDatabase'><p>Tests if a GRASS vector is linked to an attribute table</p></a></li>
<li><a href='#.vIncrementCats'><p>Increment category values of a &quot;GRASS&quot; vector</p></a></li>
<li><a href='#.vNames'><p>Names of columns of a GRASS vector's attribute table</p></a></li>
<li><a href='#.vRecat'><p>Re-make vector &quot;category&quot; (cat) values</p></a></li>
<li><a href='#.vValidCats'><p>Are the category values of a vector valid?</p></a></li>
<li><a href='#.workDir+2CGLocation-method'><p>Get a GLocation's working directory</p></a></li>
<li><a href='#.zonal'><p>Internal function for zonal()</p></a></li>
<li><a href='#.zonalByVector'><p>Internal function for zonal() when y is a GVector</p></a></li>
<li><a href='#+5B'><p>Subset geometries of a GVector</p></a></li>
<li><a href='#+5B+5B'><p>Subset layers from a GRaster, or specific columns from a GVector</p></a></li>
<li><a href='#+5B+5B+26lt+3B-'><p>Replace layers of a GRaster</p></a></li>
<li><a href='#+5B+26lt+3B-'><p>Replace values of a GRaster</p></a></li>
<li><a href='#+24'><p>Subset a GRaster layer, or return values from a column of a GVector's table</p></a></li>
<li><a href='#+24+26lt+3B-'><p>Replace a raster layer or a column from a vector's data table</p></a></li>
<li><a href='#activeCat+2CGRaster-method'><p>Get or set the column with category labels in a categorical raster</p></a></li>
<li><a href='#add+26lt+3B-'><p>&quot;Stack&quot; a GRaster</p></a></li>
<li><a href='#addCats+2CGRaster-method'><p>Add rows or columns to the &quot;levels&quot; table of a categorical raster</p></a></li>
<li><a href='#addons'><p>Test if addons directory exists and if an addon is installed</p></a></li>
<li><a href='#addTable+26lt+3B-+2CGVector+2Cdata.frame-method'><p>Attach or detach GVector's data table</p></a></li>
<li><a href='#aggregate+2CGRaster-method'><p>Aggregate raster cells into larger cells or combine geometries of a vector</p></a></li>
<li><a href='#app+2CGRaster-method'><p>Apply a function to a set of rasters</p></a></li>
<li><a href='#appFunsTable'><p>Functions that can be used in app()</p></a></li>
<li><a href='#Arith+2CGRaster+2Clogical-method'><p>Arithmetic operations on GRasters</p></a></li>
<li><a href='#as.contour+2CGRaster-method'><p>Contour lines from a &quot;GRaster&quot;</p></a></li>
<li><a href='#as.data.frame+2CGVector-method'><p>Convert GVector to a data frame</p></a></li>
<li><a href='#as.int+2CGRaster-method'><p>Coerce raster to integer, float, or double precision</p></a></li>
<li><a href='#as.lines+2CGRaster-method'><p>Convert a raster to a lines vector</p></a></li>
<li><a href='#as.points+2CGRaster-method'><p>Convert a GRaster, or lines or polygons GVector to a points vector</p></a></li>
<li><a href='#as.polygons+2CGRaster-method'><p>Convert a raster to a polygons vector</p></a></li>
<li><a href='#bioclims+2CGRaster-method'><p>BIOCLIM rasters</p></a></li>
<li><a href='#breakPolys+2CGVector-method'><p>Fix issues with geometries of a vector</p></a></li>
<li><a href='#buffer+2CGRaster-method'><p>Increase/decrease the size of a vector or around non-NA cells of a raster</p></a></li>
<li><a href='#c+2CGRaster-method'><p>&quot;Stack&quot; GRasters</p></a></li>
<li><a href='#catNames+2CGRaster-method'><p>Names of columns of the levels table of a categorical raster</p></a></li>
<li><a href='#cellSize+2CGRaster-method'><p>Area of GRaster cells</p></a></li>
<li><a href='#centroids+2CGVector-method'><p>Centroid(s) of a vector</p></a></li>
<li><a href='#classify+2CGRaster-method'><p>Classify GRaster cell values</p></a></li>
<li><a href='#clump+2CGRaster-method'><p>Group adjacent cells with similar values</p></a></li>
<li><a href='#clusterPoints+2CGVector-method'><p>Identify clusters of points</p></a></li>
<li><a href='#colbind+2CGVector-method'><p>Add columns to the data table of a GVector</p></a></li>
<li><a href='#combineLevels+2CGRaster-method'><p>Combine levels table from multiple categorical GRasters</p></a></li>
<li><a href='#Compare+2CGRaster+2CGRaster-method'><p>Compare-methods operations on GRasters and GRegions</p></a></li>
<li><a href='#compareGeom+2CGRaster+2CGRaster-method'><p>Determine if GRasters and/or GVectors are geographically comparable</p></a></li>
<li><a href='#complete.cases+2CGRaster-method'><p>Rows of a GRaster or GVector's table that have no NAs or that have NAs</p></a></li>
<li><a href='#compositeRGB+2CGRaster-method'><p>Combine red, green, and blue color bands to make a composite GRaster</p></a></li>
<li><a href='#concats+2CGRaster-method'><p>Combine values/categories of multiple GRasters into a single GRaster</p></a></li>
<li><a href='#connectors+2CGVector+2CGVector-method'><p>Create lines connecting nearest features of two GVectors</p></a></li>
<li><a href='#convHull+2CGVector-method'><p>Minimum convex hull around a spatial vector</p></a></li>
<li><a href='#crds+2CGRaster-method'><p>Coordinates of a vector&quot;s features or a raster&quot;s cell centers</p></a></li>
<li><a href='#crop+2CGRaster-method'><p>Remove parts of a GRaster or GVector</p></a></li>
<li><a href='#crs+2Cmissing-method'><p>Coordinate reference system of a GRaster or GVector</p></a></li>
<li><a href='#datatype+2CGRaster-method'><p>Get the datatype of a GRaster or of GVector columns</p></a></li>
<li><a href='#delaunay+2CGVector-method'><p>Delaunay triangulation for points</p></a></li>
<li><a href='#denoise+2CGRaster-method'><p>Remove or retain &quot;noise&quot; in a raster using PCA</p></a></li>
<li><a href='#dim+2CGRegion-method'><p>Number of rows, columns, depths, cells, and layers</p></a></li>
<li><a href='#disagg+2CGVector-method'><p>Coerce as multipart GVector to a singlepart GVector</p></a></li>
<li><a href='#distance+2CGRaster+2Cmissing-method'><p>Geographic distance</p></a></li>
<li><a href='#droplevels+2CGRaster-method'><p>Remove rows from the &quot;levels&quot; table of a categorical raster</p></a></li>
<li><a href='#dropRows+2Cdata.table-method'><p>Remove rows in a data.table, data.frame, or matrix.</p></a></li>
<li><a href='#erase+2CGVector+2CGVector-method'><p>Select parts of a polygon GVector erase shared by another polygon GVector</p></a></li>
<li><a href='#expanse+2CGVector-method'><p>Area of polygons or length of lines</p></a></li>
<li><a href='#ext+2Cmissing-method'><p>Spatial bounds of a GRaster or GVector</p></a></li>
<li><a href='#extend+2CGRaster+2Cnumeric-method'><p>Add rows and columns around a writeRaster</p></a></li>
<li><a href='#extract+2CGRaster+2CGVector-method'><p>Extract values from a GRaster at locations in a points GVector</p></a></li>
<li><a href='#fast'><p>Create a GRaster or GVector</p></a></li>
<li><a href='#fastData'><p>Get one of the example rasters or spatial vectors</p></a></li>
<li><a href='#faster'><p>Set or get options shared across fasterRaster functions</p></a></li>
<li><a href='#fillHoles+2CGVector-method'><p>Fill holes in a GVector</p></a></li>
<li><a href='#fillNAs+2CGRaster-method'><p>Fill NA cells in a raster using interpolation</p></a></li>
<li><a href='#flow+2CGRaster-method'><p>Identify watershed basins and direction and accumulation of flow</p></a></li>
<li><a href='#flowPath+2CGRaster-method'><p>Path of water flow across a landscape</p></a></li>
<li><a href='#focal+2CGRaster-method'><p>Calculate cell values based on values of nearby cells</p></a></li>
<li><a href='#fractalRast+2CGRaster-method'><p>Create fractal raster</p></a></li>
<li><a href='#fragmentation+2CSpatRaster-method'><p>Landscape fragmentation class following Riitters et al. (2020)</p></a></li>
<li><a href='#freq+2CGRaster-method'><p>Frequencies of cell values in a raster</p></a></li>
<li><a href='#geomorphons+2CGRaster-method'><p>Identify terrain feature types</p></a></li>
<li><a href='#geomtype+2CGVector-method'><p>Geometry of a GVector (points, lines, or polygons)</p></a></li>
<li><a href='#global+2CGRaster-method'><p>Summary statistics for GRasters</p></a></li>
<li><a href='#GLocation-class'><p>Classes for fasterRaster sessions, regions, rasters, and vectors</p></a></li>
<li><a href='#grassGUI+2Cmissing-method'><p>Start the GRASS GUI (potentially dangerous!)</p></a></li>
<li><a href='#grassHelp'><p>Open the help page for a GRASS module</p></a></li>
<li><a href='#grassInfo'><p>GRASS citation, version, and copyright information</p></a></li>
<li><a href='#grassStarted'><p>Has &quot;GRASS&quot; been started or not?</p></a></li>
<li><a href='#grid+2CGRaster-method'><p>Create a grid GVector</p></a></li>
<li><a href='#head+2CGVector-method'><p>Return first or last part of the data frame of a GVector</p></a></li>
<li><a href='#hexagons+2CGRaster-method'><p>Create a hexagonal grid</p></a></li>
<li><a href='#hillshade+2CGRaster-method'><p>Hillshading</p></a></li>
<li><a href='#hist+2CGRaster-method'><p>Plot a histogram of raster values</p></a></li>
<li><a href='#horizonHeight+2CGRaster-method'><p>Horizon height</p></a></li>
<li><a href='#init+2CGRaster-method'><p>GRaster with values equal to row, column, coordinate, regular, or &quot;chess&quot;</p></a></li>
<li><a href='#interpIDW+2CGVector+2CGRaster-method'><p>Interpolate values at points to a GRaster using inverse-distance weighting</p></a></li>
<li><a href='#interpSplines+2CGVector+2CGRaster-method'><p>Interpolate values at points to a GRaster using splines</p></a></li>
<li><a href='#intersect+2CGVector+2CGVector-method'><p>Intersection of two GVectors</p></a></li>
<li><a href='#is.2d+2CGSpatial-method'><p>Test if a GRaster or GVector is 2- or 3-dimensional</p></a></li>
<li><a href='#is.int+2CGRaster-method'><p>Data type of a raster</p></a></li>
<li><a href='#is.lonlat+2Ccharacter-method'><p>Test if a coordinate reference system is unprojected</p></a></li>
<li><a href='#is.na+2CGRaster-method'><p>Mathematical operations on each layer of a GRasters</p></a></li>
<li><a href='#kernel+2CGVector-method'><p>Kernel density estimator of points</p></a></li>
<li><a href='#layerCor+2CGRaster-method'><p>Correlation between GRasters</p></a></li>
<li><a href='#levels+2CGRaster-method'><p>Set and get categories for categorical rasters</p></a></li>
<li><a href='#Logic+2CGRaster+2CGRaster-method'><p>Logic-methods operations on GRasters</p></a></li>
<li><a href='#longlat+2CGRaster-method'><p>Create longitude/latitude rasters</p></a></li>
<li><a href='#madChelsa'><p>Rasters of bioclimatic variables for an eastern portion of Madagascar</p></a></li>
<li><a href='#madCoast'><p>Shapefile of a portion of the coastline of Madagascar</p></a></li>
<li><a href='#madCoast0'><p>Spatial vector of a portion of the coastline of Madagascar</p></a></li>
<li><a href='#madCoast4'><p>Spatial vector of a portion of the coastline of Madagascar</p></a></li>
<li><a href='#madCover'><p>Raster of land cover for an eastern portion of Madagascar</p></a></li>
<li><a href='#madCoverCats'><p>Table of land cover classes for an eastern portion of Madagascar</p></a></li>
<li><a href='#madDypsis'><p>Spatial points vector of records of Dypsis in eastern Madagascar</p></a></li>
<li><a href='#madElev'><p>Elevation raster for an eastern portion of Madagascar</p></a></li>
<li><a href='#madForest2000'><p>Forest cover in year 2000 for a portion of Madagascar</p></a></li>
<li><a href='#madForest2014'><p>Forest cover in year 2014 for a portion of Madagascar</p></a></li>
<li><a href='#madLANDSAT'><p>Rasters of surface reflectance for an eastern portion of Madagascar</p></a></li>
<li><a href='#madPpt'><p>Rasters of average monthly precipitation for an eastern portion of Madagascar</p></a></li>
<li><a href='#madRivers'><p>Major rivers in a selected portion of Madagascar</p></a></li>
<li><a href='#madTmax'><p>Rasters of average monthly maximum temperature for an eastern portion of Madagascar</p></a></li>
<li><a href='#madTmin'><p>Rasters of average monthly minimum temperature for an eastern portion of Madagascar</p></a></li>
<li><a href='#mask+2CGRaster+2CGRaster-method'><p>Mask values in a raster</p></a></li>
<li><a href='#maskNA+2CGRaster-method'><p>Mask all non-NA cells or all NA cells</p></a></li>
<li><a href='#match+2CGRaster-method'><p>Find which cells of a GRaster match certain values</p></a></li>
<li><a href='#mean+2CGRaster-method'><p>Mathematical operations on two or more GRasters</p></a></li>
<li><a href='#merge+2CGRaster+2CGRaster-method'><p>Combine two or more rasters with different extents and fill in NAs</p></a></li>
<li><a href='#minmax+2CGRaster-method'><p>Minimum and maximum values or categories of a GRaster</p></a></li>
<li><a href='#missingCats+2CGRaster-method'><p>Values in a categorical raster with no assigned category</p></a></li>
<li><a href='#mow'><p>Remove rasters and vectors from the GRASS cache</p></a></li>
<li><a href='#nacell+2CGRaster-method'><p>Number of NA or non-NA cells in a raster</p></a></li>
<li><a href='#names+2CGRaster-method'><p>Name(s) of a GRaster or columns of a GVector's data table</p></a></li>
<li><a href='#ngeom+2CGVector-method'><p>Number of geometries and subgeometries in a vector</p></a></li>
<li><a href='#nlevels+2CGRaster-method'><p>Number of categories in a categorical raster</p></a></li>
<li><a href='#pairs+2CGRaster-method'><p>Scatterplot of values in each GRaster layer against the others</p></a></li>
<li><a href='#pcs'><p>Retrieve a principal components model from a PCA GRaster</p></a></li>
<li><a href='#plot+2CGRaster+2Cmissing-method'><p>Display a raster or vector</p></a></li>
<li><a href='#plotRGB+2CGRaster-method'><p>Create red-green-blue plot from a raster with RGB layers</p></a></li>
<li><a href='#predict+2CGRaster-method'><p>Make predictions from a linear or generalized linear model to a GRaster</p></a></li>
<li><a href='#princomp+2CGRaster-method'><p>Apply a principal component analysis (PCA) to layers of a GRaster</p></a></li>
<li><a href='#print.rastInfo'><p>Display a fasterRaster object</p></a></li>
<li><a href='#project+2CGRaster-method'><p>Change the coordinate reference system of a GRaster or GVector</p></a></li>
<li><a href='#rast+2CGRaster-method'><p>Convert a GRaster to a SpatRaster</p></a></li>
<li><a href='#rasterize+2CGVector+2CGRaster-method'><p>Convert a GVector to a GRaster</p></a></li>
<li><a href='#rbind+2CGVector-method'><p>Combine one or more GVectors</p></a></li>
<li><a href='#regress+2CGRaster+2Cmissing-method'><p>Regression intercept, slope, r2, and t-value across each set of cells</p></a></li>
<li><a href='#reorient+2CGRaster-method'><p>Convert degrees between 'north-orientation' and 'east orientation'</p></a></li>
<li><a href='#replaceNAs+2Cdata.frame-method'><p>Replace NAs in a data.table or data.frame column, or in a vector</p></a></li>
<li><a href='#res+2Cmissing-method'><p>Spatial resolution</p></a></li>
<li><a href='#resample+2CGRaster+2CGRaster-method'><p>Change the cell size of a GRaster</p></a></li>
<li><a href='#rnormRast+2CGRaster-method'><p>Create a raster with random values drawn from a normal distribution</p></a></li>
<li><a href='#rSpatialDepRast+2CGRaster-method'><p>Create a random raster with or without spatial dependence</p></a></li>
<li><a href='#ruggedness+2CGRaster-method'><p>Terrain ruggedness index</p></a></li>
<li><a href='#runifRast+2CGRaster-method'><p>Create a raster with random values drawn from a uniform distribution</p></a></li>
<li><a href='#rvoronoi+2CGRaster-method'><p>Create a randomly-positioned tesselation</p></a></li>
<li><a href='#sampleRast+2CGRaster-method'><p>Randomly sample cells from a GRaster</p></a></li>
<li><a href='#scale+2CGRaster-method'><p>Center and scale a GRaster, or the opposite</p></a></li>
<li><a href='#segregate+2CGRaster-method'><p>Create one GRaster layer per unique value in a GRaster</p></a></li>
<li><a href='#selectRange+2CGRaster-method'><p>Select values from rasters in a stack based on values in another raster</p></a></li>
<li><a href='#seqToSQL'><p>Format a numeric series into an SQL value call</p></a></li>
<li><a href='#simplifyGeom+2CGVector-method'><p>Simplify the geometry of a vector</p></a></li>
<li><a href='#sineRast+2CGRaster-method'><p>Sine wave rasters</p></a></li>
<li><a href='#smoothGeom+2CGVector-method'><p>Smooth the geometry of a vector</p></a></li>
<li><a href='#sources+2CGRaster-method'><p>Name of a raster or vector in a GRASS session</p></a></li>
<li><a href='#spatSample+2CGRaster-method'><p>Sample random points from a GRaster or GVector</p></a></li>
<li><a href='#streams+2CGRaster-method'><p>Create stream network</p></a></li>
<li><a href='#stretch+2CGRaster-method'><p>Rescale values in a GRaster</p></a></li>
<li><a href='#subset+2CGRaster-method'><p>Subset layers from a GRaster, or specific rows from a GVector</p></a></li>
<li><a href='#subst+2CGRaster-method'><p>Replace a specific value(s) in a GRaster</p></a></li>
<li><a href='#sun'><p>Solar radiance and irradiance</p></a></li>
<li><a href='#terrain+2CGRaster-method'><p>Slope, aspect, curvature, and partial slopes</p></a></li>
<li><a href='#thinLines+2CGRaster-method'><p>Reduce linear features on a raster so linear features are 1 cell wide</p></a></li>
<li><a href='#thinPoints+2CGVector+2CGRaster-method'><p>Reduce number of points in same raster cell</p></a></li>
<li><a href='#tiles+2CGRaster-method'><p>Divide a GRaster into spatially exclusive subsets</p></a></li>
<li><a href='#topology+2CGSpatial-method'><p>Topology (2- or 3-dimensions) of a GRaster or GVector</p></a></li>
<li><a href='#trim+2CGRaster-method'><p>Remove rows and columns from a raster that are all NA</p></a></li>
<li><a href='#union+2CGVector+2CGVector-method'><p>Combine two GVectors</p></a></li>
<li><a href='#update+2CGRaster-method'><p>Refresh metadata in a GRaster or GVector</p></a></li>
<li><a href='#vect+2CGVector-method'><p>Convert a GVector to a SpatVector or sf vector</p></a></li>
<li><a href='#vegIndex+2CGRaster-method'><p>Vegetation indices from surface reflectance</p></a></li>
<li><a href='#vegIndices'><p>Table of vegetation indices that can be calculated from remote sensing surface reflectance data using <code>vegIndex()</code>. A near-comprehensive table of indices can be found on the <a href="https://www.indexdatabase.de">Index Database: A Database for Remote Sensing Indices</a>.</p></a></li>
<li><a href='#voronoi+2CGVector-method'><p>Voronoi tessellation</p></a></li>
<li><a href='#wetness+2CGRaster-method'><p>Topographic wetness index</p></a></li>
<li><a href='#writeRaster+2CGRaster+2Ccharacter-method'><p>Save a GRaster to disk</p></a></li>
<li><a href='#writeVector+2CGVector+2Ccharacter-method'><p>Save a GVector to disk</p></a></li>
<li><a href='#xor+2CGVector+2CGVector-method'><p>Select parts of polygons not shared between two GVectors</p></a></li>
<li><a href='#zonal+2CGRaster+2CANY-method'><p>Statistics on cells of a GRaster stratified by cells of another raster</p></a></li>
<li><a href='#zonalGeog+2CGRaster-method'><p>Geographic statistics for sets of cells with the same values</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Faster Raster and Spatial Vector Processing Using 'GRASS GIS'</td>
</tr>
<tr>
<td>Version:</td>
<td>8.4.0.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-25</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adam B. Smith &lt;adam.smith@mobot.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Processing of large-in-memory/large-on disk rasters and spatial
	vectors using 'GRASS GIS' <a href="https://grass.osgeo.org/">https://grass.osgeo.org/</a>. Most functions in
	the 'terra' package are	recreated. Processing of medium-sized and smaller
	spatial objects will nearly always be faster using 'terra' or 'sf', but
	for large-in-memory/large-on-disk objects, 'fasterRaster' may be faster.
	To use most of the functions, you must have the stand-alone version (not
	the 'OSGeoW4' installer version) of 'GRASS GIS' 8.0 or higher.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.14.8), DT, graphics, grDevices, methods,
omnibus (&ge; 1.2.11), rgrass (&ge; 0.3-9), rpanel, sf, shiny,
terra (&ge; 1.7), utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GRASS (&gt;= 8)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/adamlilith/fasterRaster">https://github.com/adamlilith/fasterRaster</a>,
<a href="https://adamlilith.github.io/fasterRaster/">https://adamlilith.github.io/fasterRaster/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/adamlilith/fasterRaster/issues">https://github.com/adamlilith/fasterRaster/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-25 19:06:30 UTC; asmith</td>
</tr>
<tr>
<td>Author:</td>
<td>Adam B. Smith <a href="https://orcid.org/0000-0002-6420-1659"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-25 19:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='fasterRaster'>&quot;fasterRaster&quot;: Faster raster and spatial vector processing using &quot;GRASS GIS&quot;</h2><span id='topic+fasterRaster-package'></span><span id='topic+fasterRaster'></span>

<h3>Description</h3>

<p><strong>fasterRaster</strong>: Processing of large-in-memory/-on disk rasters and spatial vectors in using <strong>GRASS GIS</strong>. Most functions in the <strong>terra</strong> and <strong>sf</strong> packages are recreated. Processing of medium-sized and smaller spatial objects will nearly always be faster using <strong>terra</strong> or <strong>sf</strong>. To use most of the functions you must have the stand-alone version of <strong>GRASS GIS</strong> version 8.3 or higher (not the <strong>OSGeoW4</strong> installer version). Note that due to differences in how <strong>GRASS</strong>, <strong>terra</strong>, and <strong>sf</strong> were implemented, results will not always be strictly comparable between functions for the same operation.
</p>


<h4>Most useful tutorials and functions:</h4>


<ul>
<li><p> The quick-start guide to getting started with <strong>fasterRaster</strong>: <code>vignette("fasterRaster", package = "fasterRaster")</code>:
</p>
</li>
<li><p> Types of <code>GRaster</code>s: <code>vignette("GRasters", package = "fasterRaster")</code>
</p>
</li>
<li><p> How to speed up <strong>fasterRaster</strong>: <code>vignette("faster_fasterRaster", package = "fasterRaster")</code>
</p>
</li>
<li><p> Using functions that depend on <strong>GRASS</strong> addons: <code>vignette("addons", package = "fasterRaster")</code>
</p>
</li>
<li> <p><code><a href="#topic+faster">faster()</a></code>: Set the directory where <strong>GRASS</strong> is installed on your system, and set or get other package-wide options. This function must be run once before using most <strong>fasterRaster</strong> functions.
</p>
</li>
<li> <p><code><a href="#topic+fast">fast()</a></code>: Convert a <code>SpatRaster</code>, <code>SpatVector</code>, or <code>sf</code> vector to <strong>fasterRaster</strong>'s raster format (<code>GRaster</code>s) or vector format (<code>GVector</code>s), or load one from a file
</p>
</li>
<li> <p><code><a href="#topic+rast">rast()</a></code>, <code><a href="#topic+vect">vect()</a></code>, and <code><a href="#topic+st_as_sf">st_as_sf()</a></code>: Convert <code>GRaster</code>s and <code>GVector</code>s to <code>SpatRaster</code>s, <code>SpatVector</code>s, or <code>sf</code> vectors
</p>
</li>
<li> <p><code><a href="#topic+writeRaster">writeRaster()</a></code> and <code><a href="#topic+writeVector">writeVector()</a></code>: Save <code>GRaster</code>s or <code>GVector</code>s to disk
</p>
</li>
<li> <p><code><a href="#topic+addons">addons()</a></code>: Test if the <code>addons</code> directory is correct and if a particular addon <strong>GRASS</strong> module is installed.
</p>
</li></ul>




<h4>Properties of <code>GRasters</code></h4>


<ul>
<li> <p><code><a href="#topic+crs">crs()</a></code>: Coordinate reference system
</p>
</li>
<li> <p><code><a href="#topic+coordRef">coordRef()</a></code>: Coordinate reference system
</p>
</li>
<li> <p><code><a href="#topic+datatype">datatype()</a></code>: Data type
</p>
</li>
<li> <p><code><a href="#topic+dim">dim()</a></code> and <code><a href="#topic+dim3d">dim3d()</a></code>: Number of rows, columns, and depths
</p>
</li>
<li> <p><code><a href="#topic+ext">ext()</a></code>, <code><a href="#topic+N">N()</a></code>, <code><a href="#topic+S">S()</a></code>, <code><a href="#topic+E">E()</a></code>, <code><a href="#topic+W">W()</a></code>, <code><a href="#topic+top">top()</a></code>, and <code><a href="#topic+bottom">bottom()</a></code>: Spatial extent
</p>
</li>
<li> <p><code><a href="#topic+freq">freq()</a></code>: Frequencies of cell values in a raster
</p>
</li>
<li> <p><code><a href="#topic+is.2d">is.2d()</a></code> and <code><a href="#topic+is.3d">is.3d()</a></code>: Is an object 2- or 3-dimensional?
</p>
</li>
<li> <p><code><a href="#topic+is.int">is.int()</a></code>, <code><a href="#topic+is.cell">is.cell()</a></code>, <code><a href="#topic+is.float">is.float()</a></code>, <code><a href="#topic+is.doub">is.doub()</a></code>: <code>GRaster</code> data type (integer/float/double)
</p>
</li>
<li> <p><code><a href="#topic+is.factor">is.factor()</a></code>: Does a raster represent categorical data?
</p>
</li>
<li> <p><code><a href="#topic+is.lonlat">is.lonlat()</a></code>: Is an object projected (e.g., in WGS84)?
</p>
</li>
<li> <p><code><a href="#topic+levels">levels()</a></code>: Names of levels in a categorical <code>GRaster</code>
</p>
</li>
<li> <p><code><a href="#topic+minmax">minmax()</a></code>: Minimum and maximum values across all non-<code>NA</code> cells
</p>
</li>
<li> <p><code><a href="#topic+names">names()</a></code>: <code>GRaster</code> names
</p>
</li>
<li> <p><code><a href="#topic+ncol">ncol()</a></code>: Number of columns
</p>
</li>
<li> <p><code><a href="#topic+nacell">nacell()</a></code>: Number of <code>NA</code> cells
</p>
</li>
<li> <p><code><a href="#topic+ncell">ncell()</a></code>: Number of cells
</p>
</li>
<li> <p><code><a href="#topic+ncell3d">ncell3d()</a></code>: Number of cells of a 3D <code>GRaster</code>
</p>
</li>
<li> <p><code><a href="#topic+ndepth">ndepth()</a></code>: Number of depths of a 3D <code>GRaster</code>
</p>
</li>
<li> <p><code><a href="#topic+nlyr">nlyr()</a></code>: Number of layers
</p>
</li>
<li> <p><code><a href="#topic+nonnacell">nonnacell()</a></code>: Number of non-<code>NA</code> cells
</p>
</li>
<li> <p><code><a href="#topic+nrow">nrow()</a></code>: Number of rows
</p>
</li>
<li> <p><code><a href="#topic+nlevels">nlevels()</a></code>: Number of categories
</p>
</li>
<li> <p><code><a href="#topic+res">res()</a></code>, <code><a href="#topic+res3d">res3d()</a></code>, <code><a href="#topic+xres">xres()</a></code>, <code><a href="#topic+yres">yres()</a></code>, and <code><a href="#topic+zres">zres()</a></code>: Spatial resolution
</p>
</li>
<li> <p><code><a href="#topic+sources">sources()</a></code>: Name of the raster file in the <strong>GRASS</strong> cache
</p>
</li>
<li> <p><code><a href="#topic+topology">topology()</a></code>: Dimensionally (2D or 3D)
</p>
</li>
<li> <p><code><a href="#topic+zext">zext()</a></code>: Vertical extent
</p>
</li>
<li> <p><code><a href="#topic+zres">zres()</a></code>: Vertical resolution
</p>
</li></ul>




<h4>Functions that operate on or create <code>GRasters</code></h4>


<ul>
<li> <p><a href="base.html#topic+Arithmetic">Arithmetic</a>: Mathematical operations on <code>GRaster</code>s: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>, <code>%%</code> (modulus), <code>%/%</code> (integer division)
</p>
</li>
<li> <p><a href="#topic+Compare-methods">Logical comparisons</a>: <code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code>, <code>&gt;=</code>, and <code>&gt;</code>, plus <code><a href="#topic++25in+25">%in%</a></code> and <code><a href="#topic++25notin+25">%notin%</a></code> (for categorical rasters only)
</p>
</li>
<li> <p><a href="#topic+Logic-methods">Logical operators</a>: <code>|</code>and <code>&amp;</code>
</p>
</li></ul>

<p>Mathematical functions that are applied to each layer of a <code>GRaster</code>:
</p>

<ul>
<li><p> Working with <code>NA</code>s: <code><a href="#topic+is.na">is.na()</a></code>, <code><a href="#topic+not.na">not.na()</a></code>, and <code><a href="#topic+maskNA">maskNA()</a></code>
</p>
</li>
<li><p> Trigonometry: <code><a href="#topic+sin">sin()</a></code>, <code><a href="#topic+cos">cos()</a></code>, <code><a href="#topic+tan">tan()</a></code>, <code><a href="#topic+asin">asin()</a></code>, <code><a href="#topic+acos">acos()</a></code>, <code><a href="#topic+atan">atan()</a></code>, <code><a href="#topic+atan2">atan2()</a></code>
</p>
</li>
<li><p> Logarithms and powers: <code><a href="#topic+exp">exp()</a></code>, <code><a href="#topic+log">log()</a></code>, <code><a href="#topic+ln">ln()</a></code>, <code><a href="#topic+log1p">log1p()</a></code>, <code><a href="#topic+log2">log2()</a></code>, <code><a href="#topic+log10">log10()</a></code>, <code><a href="#topic+sqrt">sqrt()</a></code>
</p>
</li>
<li><p> Rounding: <code><a href="#topic+round">round()</a></code>, <code><a href="#topic+floor">floor()</a></code>, <code><a href="#topic+ceiling">ceiling()</a></code>, <code><a href="#topic+trunc">trunc()</a></code>
</p>
</li>
<li><p> Signs: <code><a href="#topic+abs">abs()</a></code>
</p>
</li></ul>

<p>Mathematical functions that are applied across layers of multi-layered <code>GRaster</code>s:
</p>

<ul>
<li><p> Numeration: <code><a href="#topic+sum">sum()</a></code>, <code><a href="#topic+count">count()</a></code>
</p>
</li>
<li><p> Central tendency: <code><a href="#topic+mean">mean()</a></code>, <code><a href="#topic+mmode">mmode()</a></code>, <code><a href="#topic+median">median()</a></code>
</p>
</li>
<li><p> Dispersion: <code><a href="#topic+stdev">stdev()</a></code>, <code><a href="#topic+var">var()</a></code>, <code><a href="#topic+varpop">varpop()</a></code>, <code><a href="#topic+nunique">nunique()</a></code>, <code><a href="#topic+range">range()</a></code>, <code><a href="#topic+quantile">quantile()</a></code>, <code><a href="#topic+skewness">skewness()</a></code>, <code><a href="#topic+kurtosis">kurtosis()</a></code>
</p>
</li>
<li><p> Extremes: <code><a href="#topic+min">min()</a></code>, <code><a href="#topic+max">max()</a></code>, <code><a href="#topic+which.min">which.min()</a></code>, <code><a href="#topic+which.max">which.max()</a></code>
</p>
</li>
<li> <p><code>NA</code>s: <code><a href="#topic+allNA">allNA()</a></code>, <code><a href="#topic+anyNA">anyNA()</a></code>
</p>
</li></ul>

<p>Subsetting, assigning, and replacing <code>GRaster</code> layers
</p>

<ul>
<li> <p><a href="#topic++24">$</a>, <code><a href="#topic++5B+5B">[[</a></code>, or <code><a href="#topic+subset">subset()</a></code>: Subset or remove specific layers of a <code>GRaster</code>
</p>
</li>
<li> <p><code><a href="#topic++5B+3C-">[&lt;-</a></code>: Replace values of cells of a <code>GRaster</code>
</p>
</li>
<li> <p><code><a href="#topic++5B+5B+3C-">[[&lt;-</a></code>: Replace specific layers of a <code>GRaster</code>
</p>
</li>
<li> <p><code><a href="#topic+add+3C-">add&lt;-</a></code>: Replace specific layers of a <code>GRaster</code>
</p>
</li></ul>

<p>Operations on <code>GRaster</code>s
</p>

<ul>
<li> <p><code><a href="#topic+as.int">as.int()</a></code>, <code><a href="#topic+as.float">as.float()</a></code>, <code><a href="#topic+as.doub">as.doub()</a></code>: Change data type (integer/float/double)
</p>
</li>
<li> <p><code><a href="#topic+as.lines">as.lines()</a></code>: Convert a <code>GRaster</code> to a &quot;lines&quot; vector
</p>
</li>
<li> <p><code><a href="#topic+as.points">as.points()</a></code>: Convert a <code>GRaster</code> to a &quot;points&quot; vector
</p>
</li>
<li> <p><code><a href="#topic+as.polygons">as.polygons()</a></code>: Convert a <code>GRaster</code> to a &quot;polygons&quot; vector
</p>
</li>
<li> <p><code><a href="#topic+aggregate">aggregate()</a></code>: Aggregate values of <code>GRaster</code> cells into larger cells
</p>
</li>
<li> <p><code><a href="#topic+bioclims">bioclims()</a></code>: BIOCLIM rasters (classic set and extended set)
</p>
</li>
<li> <p><code><a href="#topic+buffer">buffer()</a></code>: Create a buffer around non-<code>NA</code> cells
</p>
</li>
<li> <p><code><a href="#topic+app">app()</a></code>: Apply a user-defined function to multiple layers of a <code>GRaster</code> (with helper functions <code><a href="#topic+appFuns">appFuns()</a></code> and <code><a href="#topic+appCheck">appCheck()</a></code>)
</p>
</li>
<li> <p><code><a href="#topic+c">c()</a></code>: &quot;Stack&quot; two or more rasters
</p>
</li>
<li> <p><code><a href="#topic+cellSize">cellSize()</a></code>: Cell area
</p>
</li>
<li> <p><code><a href="#topic+classify">classify()</a></code>: Partition cell values into strata
</p>
</li>
<li> <p><code><a href="#topic+clump">clump()</a></code>: Group adjacent cells with similar values
</p>
</li>
<li> <p><code><a href="#topic+combineLevels">combineLevels()</a></code>: Combine the &quot;levels&quot; tables of two or more categorical <code>GRaster</code>s
</p>
</li>
<li> <p><code><a href="#topic+concats">concats()</a></code>: Combine values from two or more categorical and/or integer rasters by concatenating them
</p>
</li>
<li> <p><code><a href="#topic+crop">crop()</a></code>: Remove parts of a <code>GRaster</code>
</p>
</li>
<li> <p><code><a href="#topic+denoise">denoise()</a></code>: Remove &quot;noise&quot; from a <code>GRaster</code> using a principal components analysis (PCA)
</p>
</li>
<li> <p><code><a href="#topic+distance">distance()</a></code>: Distance to non-<code>NA</code> cells, or vice versa
</p>
</li>
<li> <p><code><a href="#topic+extend">extend()</a></code>: Add rows and columns to a <code>GRaster</code>
</p>
</li>
<li> <p><code><a href="#topic+extract">extract()</a></code>: Extract values from a <code>GRaster</code> at locations of a <code>GVector</code>
</p>
</li>
<li> <p><code><a href="#topic+fillNAs">fillNAs()</a></code>: Fill <code>NA</code> cells
</p>
</li>
<li> <p><code><a href="#topic+focal">focal()</a></code>: Calculate cell values based on values of nearby cells
</p>
</li>
<li> <p><code><a href="#topic+fragmentation">fragmentation()</a></code>: Landscape fragmentation class from Riitters et al. (2020)
</p>
</li>
<li> <p><code><a href="#topic+global">global()</a></code>: Summary statistics across cells of each <code>GRaster</code> layer
</p>
</li>
<li> <p><code><a href="#topic+hist">hist()</a></code>: Histogram of <code>GRaster</code> values
</p>
</li>
<li> <p><code><a href="#topic+interpIDW">interpIDW()</a></code>: Interpolate values at points to a <code>GRaster</code>
</p>
</li>
<li> <p><code><a href="#topic+kernel">kernel()</a></code>: Kernel density estimator of points
</p>
</li>
<li> <p><code><a href="#topic+layerCor">layerCor()</a></code>: Correlation or covariance between two or more <code>GRaster</code> layers
</p>
</li>
<li> <p><code><a href="#topic+mask">mask()</a></code>: Remove values in a <code>GRaster</code> based on values in another <code>GRaster</code> or vector
</p>
</li>
<li> <p><code><a href="#topic+maskNA">maskNA()</a></code>: Mask all non-NA cells or all NA cells
</p>
</li>
<li> <p><code><a href="#topic+match">match()</a></code>, <code><a href="#topic++25in+25">%in%</a></code>, and <code><a href="#topic++25notin+25">%notin%</a></code>: Find which cells of a <code>GRaster</code> match or do not match certain values
</p>
</li>
<li> <p><code><a href="#topic+merge">merge()</a></code>: Combine two or more rasters with different extents and fill in <code>NA</code>s
</p>
</li>
<li> <p><code><a href="#topic+names+3C-">names&lt;-</a></code>: Assign names to a <code>GRaster</code>
</p>
</li>
<li> <p><code><a href="#topic+noise">noise()</a></code>: Remove coarse-scale trends from a <code>GRaster</code>, leaving just fine-scale &quot;noise&quot;
</p>
</li>
<li> <p><code><a href="#topic+pairs">pairs()</a></code>: Plot correlations between <code>GRaster</code> layers
</p>
</li>
<li> <p><code><a href="#topic+pcs">pcs()</a></code>: Retrieve a principal components model from a PCA <code>GRaster</code> generated using <code>princomp()</code>
</p>
</li>
<li> <p><code><a href="#topic+plot">plot()</a></code>: Display a <code>GRaster</code>
</p>
</li>
<li> <p><code><a href="#topic+project">project()</a></code>: Change coordinate reference system and cell size
</p>
</li>
<li> <p><code><a href="#topic+predict">predict()</a></code>: Make predictions to a <code>GRaster</code> from a linear model or generalized linear model
</p>
</li>
<li> <p><code><a href="#topic+princomp">princomp()</a></code>: Apply a principal components analysis (PCA) to a <code>GRaster</code>
</p>
</li>
<li> <p><code><a href="#topic+regress">regress()</a></code>: Regression intercept, slope, r2, and t-value across each set of cells
</p>
</li>
<li> <p><code><a href="#topic+resample">resample()</a></code>: Change cell size
</p>
</li>
<li> <p><code><a href="#topic+reorient">reorient()</a></code>: Convert degrees between 'north-orientation' and 'east orientation'
</p>
</li>
<li> <p><code><a href="#topic+sampleRast">sampleRast()</a></code>: Randomly sample cells from a <code>GRaster</code>
</p>
</li>
<li> <p><code><a href="#topic+scale">scale()</a></code>, <code><a href="#topic+scalepop">scalepop()</a></code>, and <code><a href="#topic+unscale">unscale()</a></code>: Subtract means and divide by standard deviations, or inverse of that
</p>
</li>
<li> <p><code><a href="#topic+selectRange">selectRange()</a></code>: Select values from rasters in a stack based on values in another <code>GRaster</code>
</p>
</li>
<li> <p><code><a href="#topic+spatSample">spatSample()</a></code>: Randomly points from a <code>GRaster</code>
</p>
</li>
<li> <p><code><a href="#topic+stretch">stretch()</a></code>: Rescale values in a GRaster
</p>
</li>
<li> <p><code><a href="#topic+subst">subst()</a></code>: Re-assign cell values
</p>
</li>
<li> <p><code><a href="#topic+thinLines">thinLines()</a></code>: Reduce linear features on a <code>GRaster</code> so linear features are 1 cell wide
</p>
</li>
<li> <p><code><a href="#topic+tiles">tiles()</a></code>: Divide a <code>GRaster</code> into spatially exclusive subsets (though with possible overlap)
</p>
</li>
<li> <p><code><a href="#topic+trim">trim()</a></code>: Remove rows and columns from a <code>GRaster</code> that are all <code>NA</code>
</p>
</li>
<li> <p><code><a href="#topic+zonal">zonal()</a></code>: Statistics (mean, sum, etc.) on areas of a <code>GRaster</code> defined by sets of cells with the same values in another <code>GRaster</code>, or by geometries in a <code>GVector</code>
</p>
</li>
<li> <p><code><a href="#topic+zonalGeog">zonalGeog()</a></code>: Geographic statistics (area, perimeter, fractal dimension, etc.) for sets of cells with the same values
</p>
</li></ul>




<h4>Creating <code>GRaster</code>s <em>de novo</em></h4>


<ul>
<li> <p><code><a href="#topic+fractalRast">fractalRast()</a></code>: Create a fractal <code>GRaster</code>
</p>
</li>
<li> <p><code><a href="#topic+init">init()</a></code>: GRaster with values equal to row, column, coordinate, regular, or &quot;chess&quot;
</p>
</li>
<li> <p><code><a href="#topic+longlat">longlat()</a></code>: Create longitude/latitude rasters
</p>
</li>
<li> <p><code><a href="#topic+rnormRast">rnormRast()</a></code>: A random <code>GRaster</code> with values drawn from a normal distribution
</p>
</li>
<li> <p><code><a href="#topic+rSpatialDepRast">rSpatialDepRast()</a></code>: Create a random <code>GRaster</code> with or without spatial dependence
</p>
</li>
<li> <p><code><a href="#topic+runifRast">runifRast()</a></code>: A random <code>GRaster</code> with values drawn from a uniform distribution
</p>
</li>
<li> <p><code><a href="#topic+sineRast">sineRast()</a></code>: Sine wave rasters
</p>
</li></ul>




<h4>Analysis of terrain and hydrology</h4>


<ul>
<li> <p><code><a href="#topic+as.contour">as.contour()</a></code>: Contour lines from a <code>GRaster</code>
</p>
</li>
<li> <p><code><a href="#topic+flow">flow()</a></code>: Identify watershed basins and direction and accumulation of flow
</p>
</li>
<li> <p><code><a href="#topic+flowPath">flowPath()</a></code>: Path of water flow across a landscape
</p>
</li>
<li> <p><code><a href="#topic+geomorphons">geomorphons()</a></code>: Identify terrain feature types
</p>
</li>
<li> <p><code><a href="#topic+hillshade">hillshade()</a></code>: Create a hillshade <code>GRaster</code>
</p>
</li>
<li> <p><code><a href="#topic+horizonHeight">horizonHeight()</a></code>: Horizon height
</p>
</li>
<li> <p><code><a href="#topic+sun">sun()</a></code>: Solar radiance and irradiance
</p>
</li>
<li> <p><code><a href="#topic+ruggedness">ruggedness()</a></code>: Terrain Ruggedness Index
</p>
</li>
<li> <p><code><a href="#topic+streams">streams()</a></code>: Create stream network
</p>
</li>
<li> <p><code><a href="#topic+terrain">terrain()</a></code>: Slope, aspect, curvature, and partial slopes
</p>
</li>
<li> <p><code><a href="#topic+wetness">wetness()</a></code>: Topographic wetness index
</p>
</li></ul>




<h4>Operations on categorical (factor) <code>GRaster</code>s</h4>


<ul>
<li> <p><code><a href="#topic++25in+25">%in%</a></code>, and <code><a href="#topic++25notin+25">%notin%</a></code>: Mask cells that match or do not match a given category
</p>
</li>
<li> <p><code><a href="#topic+activeCat">activeCat()</a></code> and <code><a href="#topic+activeCats">activeCats()</a></code>: Column(s) that defines category labels
<code><a href="#topic+activeCat+3C-">activeCat&lt;-</a></code>: Set column that defines category labels
</p>
</li>
<li> <p><code><a href="#topic+addCats">addCats()</a></code>: Add new columns to a &quot;levels&quot; table
<code><a href="#topic+addCats+3C-">addCats&lt;-</a></code>: Add new rows (levels) to a &quot;levels&quot; table
</p>
</li>
<li> <p><code><a href="#topic+categories">categories()</a></code>: Set &quot;levels&quot; table for specific layers of a categorical raster
</p>
</li>
<li> <p><code><a href="#topic+catNames">catNames()</a></code>: Column names of each &quot;levels&quot; table
</p>
</li>
<li> <p><code><a href="#topic+cats">cats()</a></code>: &quot;Levels&quot; table of a categorical raster
</p>
</li>
<li> <p><code><a href="#topic+combineLevels">combineLevels()</a></code>: Combine the &quot;levels&quot; tables of two or more categorical <code>GRaster</code>s
</p>
</li>
<li> <p><code><a href="#topic+complete.cases">complete.cases()</a></code>: Find rows of a categorical <code>GRaster</code>'s &quot;levels&quot; table that have no <code>NA</code>s in them
</p>
</li>
<li> <p><code><a href="#topic+concats">concats()</a></code>: Combine categories from two or more categorical rasters by concatenating them
</p>
</li>
<li> <p><code><a href="#topic+droplevels">droplevels()</a></code>: Remove one or more levels
</p>
</li>
<li> <p><code><a href="#topic+freq">freq()</a></code>: Frequency of each category across cells of a raster
</p>
</li>
<li> <p><code><a href="#topic+is.factor">is.factor()</a></code>: Is a raster categorical?
</p>
</li>
<li> <p><code><a href="#topic+levels">levels()</a></code>: &quot;Levels&quot; table of a categorical raster
</p>
</li>
<li> <p><code><a href="#topic+levels+3C-">levels&lt;-</a></code>: Set &quot;levels&quot; table of a categorical raster
</p>
</li>
<li> <p><code><a href="#topic+match">match()</a></code>, <code><a href="#topic++25in+25">%in%</a></code>, and <code><a href="#topic++25notin+25">%notin%</a></code>: Find which cells of a <code>GRaster</code> match or do not match certain category labels
</p>
</li>
<li> <p><code><a href="#topic+minmax">minmax()</a></code>: &quot;Lowest&quot; and &quot;highest&quot; category values of categorical rasters (when argument <code>levels = TRUE</code>)
</p>
</li>
<li> <p><code><a href="#topic+missing.cases">missing.cases()</a></code>: Find rows of a categorical <code>GRaster</code>'s &quot;levels&quot; table that have at least one <code>NA</code> in them
</p>
</li>
<li> <p><code><a href="#topic+missingCats">missingCats()</a></code>: Values that have no category assigned to them
</p>
</li>
<li> <p><code><a href="#topic+nlevels">nlevels()</a></code>: Number of levels
</p>
</li>
<li> <p><code><a href="#topic+segregate">segregate()</a></code>: Create one GRaster layer per unique value in a GRaster
</p>
</li>
<li> <p><code><a href="#topic+subst">subst()</a></code>: Re-assign category levels
</p>
</li>
<li> <p><code><a href="#topic+zonalGeog">zonalGeog()</a></code>: Geographic statistics (area, perimeter, fractal dimension, etc.) for sets of cells with the same values
</p>
</li></ul>




<h4>Analysis of remote sensing rasters</h4>


<ul>
<li> <p><code><a href="#topic+compositeRGB">compositeRGB()</a></code>: Combine red, green, and blue color bands to make a composite <code>GRaster</code>
</p>
</li>
<li> <p><code><a href="#topic+plotRGB">plotRGB()</a></code>: Display a multispectral <code>GRaster</code> using red, blue, green, and alpha channels
</p>
</li>
<li> <p><code><a href="#topic+vegIndex">vegIndex()</a></code>: Vegetation indices from surface reflectance
</p>
</li></ul>




<h4>Functions that operate on <strong>terra</strong> <code>SpatRaster</code>s</h4>


<ul>
<li> <p><code><a href="#topic+bioclims">bioclims()</a></code>: BIOCLIM rasters (classic set and extended set)
</p>
</li>
<li> <p><code><a href="#topic+fragmentation">fragmentation()</a></code>: Landscape fragmentation class from Riitters et al. (2020)
</p>
</li></ul>




<h4>Properties of <code>GVector</code>s</h4>


<ul>
<li> <p><code><a href="#topic+crs">crs()</a></code>: Coordinate reference system
</p>
</li>
<li> <p><code><a href="#topic+coordRef">coordRef()</a></code>: Coordinate reference system
</p>
</li>
<li> <p><code><a href="#topic+datatype">datatype()</a></code>: Data type of fields
</p>
</li>
<li> <p><code><a href="#topic+dim">dim()</a></code>: Number of geometries and columns
</p>
</li>
<li> <p><code><a href="#topic+expanse">expanse()</a></code>: Area of polygons or length of lines
</p>
</li>
<li> <p><code><a href="#topic+ext">ext()</a></code>, <code><a href="#topic+N">N()</a></code>, <code><a href="#topic+S">S()</a></code>, <code><a href="#topic+E">E()</a></code>, <code><a href="#topic+W">W()</a></code>, <code><a href="#topic+top">top()</a></code>, and <code><a href="#topic+bottom">bottom()</a></code>: Spatial extent
</p>
</li>
<li> <p><code><a href="#topic+geomtype">geomtype()</a></code>: Type of vector (points, lines, polygons)
</p>
</li>
<li> <p><code><a href="#topic+is.2d">is.2d()</a></code> and <code><a href="#topic+is.3d">is.3d()</a></code>: Is an object 2- or 3-dimensional?
</p>
</li>
<li> <p><code><a href="#topic+is.lonlat">is.lonlat()</a></code>: Is an object projected (e.g., in WGS84)?
</p>
</li>
<li> <p><code><a href="#topic+is.points">is.points()</a></code>, <code><a href="#topic+is.lines">is.lines()</a></code>, <code><a href="#topic+is.polygons">is.polygons()</a></code>: Does a <code>GVector</code> represent points, lines, or polygons?
</p>
</li>
<li> <p><code><a href="#topic+names">names()</a></code>: Names of <code>GVector</code> fields
</p>
</li>
<li> <p><code><a href="#topic+ncol">ncol()</a></code>: Number of fields
</p>
</li>
<li> <p><code><a href="#topic+ngeom">ngeom()</a></code>: Number of geometries (points, lines, polygons)
</p>
</li>
<li> <p><code><a href="#topic+nrow">nrow()</a></code>: Number of rows in a vector data table
</p>
</li>
<li> <p><code><a href="#topic+nsubgeom">nsubgeom()</a></code>: Number of sub-geometries (points, lines, polygons that make up single- and multipart geometries)
</p>
</li>
<li> <p><code><a href="#topic+sources">sources()</a></code>: Name of the vector file in the <strong>GRASS</strong> cache
</p>
</li>
<li> <p><code><a href="#topic+topology">topology()</a></code>: Dimensionally (2D or 3D)
</p>
</li>
<li> <p><code><a href="#topic+zext">zext()</a></code>: Vertical extent
</p>
</li></ul>




<h4>Subsetting and assigning geometries or rows and columns of <code>GVector</code>s</h4>


<ul>
<li> <p><a href="#topic++24">$</a> or <code><a href="#topic++5B+5B">[[</a></code>: Subset columns of a <code>GVector</code>'s data table
</p>
</li>
<li> <p><code><a href="#topic++5B">[</a></code> or <code><a href="#topic+subset">subset()</a></code>: Subset geometries of a <code>GVector</code>
</p>
</li>
<li> <p><code><a href="#topic++24+3C-">$&lt;-</a></code>: Replace specific columns of a <code>GVector</code>'s data table or add columns
</p>
</li>
<li> <p><code><a href="#topic+addTable+3C-">addTable&lt;-</a></code>: Add a data table to a <code>GVector</code>
</p>
</li>
<li> <p><code><a href="#topic+dropTable">dropTable()</a></code>: Remove a <code>GVector</code>s data table
</p>
</li></ul>




<h4>Operations on <code>GVector</code>s</h4>


<ul>
<li> <p><code><a href="#topic+aggregate">aggregate()</a></code>: Combine <code>GVector</code> geometries
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame">as.data.frame()</a></code>: Convert a <code>GVector</code>'s attribute table to a <code>data.frame</code>
</p>
</li>
<li> <p><code><a href="#topic+as.data.table">as.data.table()</a></code>: Convert a <code>GVector</code>'s attribute table to a <code>data.table</code>
</p>
</li>
<li> <p><code><a href="#topic+as.points">as.points()</a></code>: Extract vertex coordinates from a &quot;lines&quot; or &quot;polygons&quot; <code>GVector</code>
</p>
</li>
<li> <p><code><a href="#topic+buffer">buffer()</a></code>: Create a polygon around/inside a <code>GVector</code>
</p>
</li>
<li> <p><code><a href="#topic+clusterPoints">clusterPoints()</a></code>: Identify clusters of points
</p>
</li>
<li> <p><code><a href="#topic+centroids">centroids()</a></code>: Centroid(s) of a <code>GVector</code>
</p>
</li>
<li> <p><code><a href="#topic+colbind">colbind()</a></code>: Add columns to the data table of a <code>GVector</code>
</p>
</li>
<li> <p><code><a href="#topic+complete.cases">complete.cases()</a></code>: Find rows of a <code>GVector</code>'s data table that have no <code>NA</code>s in them
</p>
</li>
<li> <p><code><a href="#topic+connectors">connectors()</a></code>: Create lines connecting nearest features of two <code>GVector</code>s
</p>
</li>
<li> <p><code><a href="#topic+convHull">convHull()</a></code>: Minimum convex hull
</p>
</li>
<li> <p><code><a href="#topic+crds">crds()</a></code>: Extract coordinates of a <code>GVector</code>
</p>
</li>
<li> <p><code><a href="#topic+crop">crop()</a></code>: Remove parts of a <code>GVector</code>
</p>
</li>
<li> <p><code><a href="#topic+delaunay">delaunay()</a></code>: Delaunay triangulation
</p>
</li>
<li> <p><code><a href="#topic+disagg">disagg()</a></code>: Separate multipart geometries into singlepart geometries
</p>
</li>
<li> <p><code><a href="#topic+distance">distance()</a></code>: Distance between geometries in two <code>GVector</code>, or from a <code>GVector</code> to cells of a <code>GRaster</code>
</p>
</li>
<li> <p><code><a href="#topic+erase">erase()</a></code> or <code>-</code>: Remove part of a <code>GVector</code> that overlaps with another
</p>
</li>
<li> <p><code><a href="#topic+expanse">expanse()</a></code>: Area of polygons or length of lines
</p>
</li>
<li> <p><code><a href="#topic+extract">extract()</a></code>: Extract values from a <code>GVector</code> at specific points
</p>
</li>
<li> <p><code><a href="#topic+grid">grid()</a></code>: Create a grid <code>GVector</code>
</p>
</li>
<li> <p><code><a href="#topic+head">head()</a></code>: First rows of a <code>GVector</code>'s data table
</p>
</li>
<li> <p><code><a href="#topic+hexagons">hexagons()</a></code>: Create a hexagonal grid
</p>
</li>
<li> <p><code><a href="#topic+interpIDW">interpIDW()</a></code>: Interpolate values at points to a <code>GRaster</code> using inverse-distance weighting
</p>
</li>
<li> <p><code><a href="#topic+interpSplines">interpSplines()</a></code>: Interpolate values at points to a <code>GRaster</code> using splines
</p>
</li>
<li> <p><code><a href="#topic+intersect">intersect()</a></code> or <code>*</code>: Intersection of two <code>GVectors</code>
</p>
</li>
<li> <p><code><a href="#topic+kernel">kernel()</a></code>: Kernel density estimator of points
</p>
</li>
<li> <p><code><a href="#topic+missing.cases">missing.cases()</a></code>: Find rows of a <code>GVector</code>'s data table that have at least <code>NA</code> in them
</p>
</li>
<li> <p><code><a href="#topic+names+3C-">names&lt;-</a></code>: Assign names to columns of a <code>GVector</code>s data table
</p>
</li>
<li> <p><code><a href="#topic+project">project()</a></code>: Change coordinate reference system
</p>
</li>
<li> <p><code><a href="#topic+rasterize">rasterize()</a></code>: Convert a <code>GVector</code> to a <code>GRaster</code>
</p>
</li>
<li> <p><code><a href="#topic+rbind">rbind()</a></code>: Combine <code>GVectors</code>
</p>
</li>
<li> <p><code><a href="#topic+simplifyGeom">simplifyGeom()</a></code>: Remove vertices
</p>
</li>
<li> <p><code><a href="#topic+smoothGeom">smoothGeom()</a></code>: Remove &quot;angular&quot; aspects of features
</p>
</li>
<li> <p><code><a href="#topic+st_as_sf">st_as_sf()</a></code>: Convert a <code>GVector</code> to a <code>sf</code> vector
</p>
</li>
<li> <p><code><a href="#topic+st_buffer">st_buffer()</a></code>: Create a polygon around/inside a <code>GVector</code>
</p>
</li>
<li> <p><code><a href="#topic+tail">tail()</a></code>: Last rows of a <code>GVector</code>'s data table
</p>
</li>
<li> <p><code><a href="#topic+thinPoints">thinPoints()</a></code>: Reduce number of points in same raster cell
</p>
</li>
<li> <p><code><a href="#topic+union">union()</a></code> or <code>+</code>: Combine two <code>GVector</code>s
</p>
</li>
<li> <p><code><a href="#topic+voronoi">voronoi()</a></code>: Voronoi tessellation
</p>
</li>
<li> <p><code><a href="#topic+xor">xor()</a></code> or <code>/</code>: Select parts of polygons not shared by two <code>GVector</code>s
</p>
</li></ul>




<h4>Creating <code>GVector</code>s <em>de novo</em></h4>


<ul>
<li> <p><code><a href="#topic+rvoronoi">rvoronoi()</a></code>: Random Voronoi tesselation
</p>
</li></ul>




<h4>Fixing issues with <code>GVector</code>s</h4>

<p>(See also <em>Details</em> <code><a href="#topic+fast">fast()</a></code>.)
</p>

<ul>
<li> <p><code><a href="#topic+breakPolys">breakPolys()</a></code>: Break topologically clean areas
</p>
</li>
<li> <p><code><a href="#topic+fillHoles">fillHoles()</a></code>: Fill &quot;holes&quot; of a <code>GVector</code>
</p>
</li>
<li> <p><code><a href="#topic+fixBridges">fixBridges()</a></code>: Change &quot;bridges&quot; to &quot;islands&quot;
</p>
</li>
<li> <p><code><a href="#topic+fixDangles">fixDangles()</a></code>: Change &quot;dangles&quot; hanging off boundaries to lines
</p>
</li>
<li> <p><code><a href="#topic+fixLines">fixLines()</a></code>: Break lines at intersections and lines that form closed loops
</p>
</li>
<li> <p><code><a href="#topic+remove0">remove0()</a></code>: Remove all boundaries and lines with a length of 0
</p>
</li>
<li> <p><code><a href="#topic+removeAngles">removeAngles()</a></code>: Collapse lines that diverge at an angle that is computationally equivalent to 0
</p>
</li>
<li> <p><code><a href="#topic+removeBridges">removeBridges()</a></code>: Remove &quot;bridges&quot; to &quot;islands&quot;
</p>
</li>
<li> <p><code><a href="#topic+removeDangles">removeDangles()</a></code>: Remove &quot;dangling&quot; lines
</p>
</li>
<li> <p><code><a href="#topic+removeDupCentroids">removeDupCentroids()</a></code>: Remove duplicated area centroids
</p>
</li>
<li> <p><code><a href="#topic+removeDups">removeDups()</a></code>: Remove duplicated features and area centroids
</p>
</li>
<li> <p><code><a href="#topic+removeSmallPolys">removeSmallPolys()</a></code>: Remove small polygons
</p>
</li>
<li> <p><code><a href="#topic+snap">snap()</a></code>: Snap lines/boundaries to each other
</p>
</li></ul>




<h4>Converting between data types</h4>


<ul>
<li> <p><code><a href="#topic+as.contour">as.contour()</a></code>: Convert a <code>GRaster</code> to a <code>GVector</code> representing contour lines
</p>
</li>
<li> <p><code><a href="#topic+as.doub">as.doub()</a></code>: Convert a <code>GRaster</code> to a double-floating point raster (<strong>GRASS</strong> data type <code>DCELL</code>)
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame">as.data.frame()</a></code>: Convert <code>GVector</code> to a <code>data.frame</code>
</p>
</li>
<li> <p><code><a href="#topic+as.data.table">as.data.table()</a></code>: Convert <code>GVector</code> to a <code>data.table</code>
</p>
</li>
<li> <p><code><a href="#topic+as.float">as.float()</a></code>: Convert a <code>GRaster</code> to a floating-point raster (<strong>GRASS</strong> data type <code>FCELL</code>)
</p>
</li>
<li> <p><code><a href="#topic+as.int">as.int()</a></code>: Convert a <code>GRaster</code> to an integer raster (<strong>GRASS</strong> data type <code>CELL</code>)
</p>
</li>
<li> <p><code><a href="#topic+as.points">as.points()</a></code>, <code><a href="#topic+as.lines">as.lines()</a></code>, and <code><a href="#topic+as.polygons">as.polygons()</a></code>: Convert a <code>GRaster</code> to a <code>GVector</code>
</p>
</li>
<li> <p><code><a href="#topic+categories">categories()</a></code> and <code><a href="#topic+levels+3C-">levels&lt;-</a></code>: Convert an integer raster to a categorical (&quot;factor&quot;) raster.
</p>
</li>
<li> <p><code><a href="#topic+fast">fast()</a></code>: Convert a <code>SpatRaster</code> to a <code>GRaster</code>; a <code>SpatVector</code>, <code>sf</code> vector, numeric vector, <code>matrix</code>, <code>data.frame</code>, or <code>data.table</code> to a <code>GVector</code>; or load a vector or raster from a file
</p>
</li>
<li> <p><code><a href="#topic+rast">rast()</a></code>: Convert a <code>GRaster</code> to a <code>SpatRaster</code>
</p>
</li>
<li> <p><code><a href="#topic+rasterize">rasterize()</a></code>: Convert a <code>GVector</code> to a <code>GRaster</code>
</p>
</li>
<li> <p><code><a href="#topic+st_as_sf">st_as_sf()</a></code>: Convert a <code>GVector</code> to a <code>sf</code> vector
</p>
</li>
<li> <p><code><a href="#topic+vect">vect()</a></code>: Convert a <code>GVector</code> to a <code>SpatVector</code>
</p>
</li></ul>




<h4>General purpose functions</h4>


<ul>
<li> <p><code><a href="#topic+compareGeom">compareGeom()</a></code>: Determine if geographic metadata is same between <code>GRaster</code>s and/or <code>GVector</code>s
</p>
</li>
<li> <p><code><a href="#topic+dropRows">dropRows()</a></code>: Remove rows from a <code>data.frame</code> or <code>data.table</code>
</p>
</li>
<li> <p><code><a href="#topic+grassGUI">grassGUI()</a></code>: Start the <strong>GRASS</strong> GUI (not recommended for most users!!!)
</p>
</li>
<li> <p><code><a href="#topic+grassHelp">grassHelp()</a></code>: Open the help page for a <strong>GRASS</strong> module.
</p>
</li>
<li> <p><code><a href="#topic+grassInfo">grassInfo()</a></code>: <strong>GRASS</strong> version and citation
</p>
</li>
<li> <p><code><a href="#topic+grassStarted">grassStarted()</a></code>: Has a connection <strong>GRASS</strong> been made within the current <strong>R</strong> session?
</p>
</li>
<li> <p><code><a href="#topic+mow">mow()</a></code>: Remove unused rasters and vectors from the <strong>GRASS</strong> cache
</p>
</li>
<li> <p><code><a href="#topic+reorient">reorient()</a></code>: Convert degrees between 'north-orientation' and 'east orientation'
</p>
</li>
<li> <p><code><a href="#topic+replaceNAs">replaceNAs()</a></code>: Replace <code>NA</code>s in columns of a <code>data.table</code> or <code>data.frame</code>, or in a vector
</p>
</li>
<li> <p><code><a href="#topic+seqToSQL">seqToSQL()</a></code>: Format a numeric series into an SQL value call
</p>
</li>
<li> <p><code><a href="#topic+update">update()</a></code>: Refresh metadata in a <code>GRaster</code> or <code>GVector</code> object
</p>
</li></ul>




<h4>Data objects</h4>


<ul>
<li> <p><code><a href="#topic+fastData">fastData()</a></code>: Helper function to quickly obtain example rasters and vectors
</p>
</li>
<li> <p><a href="#topic+appFunsTable">appFunsTable</a> (see also <code><a href="#topic+appFuns">appFuns()</a></code>): Functions usable by the <code><a href="#topic+app">app()</a></code> function
</p>
</li>
<li> <p><a href="#topic+madChelsa">madChelsa</a>: Climate rasters for of a portion of eastern Madagascar
</p>
</li>
<li> <p><a href="#topic+madCoast0">madCoast0</a>, <a href="#topic+madCoast4">madCoast4</a>, and <a href="#topic+madCoast">madCoast</a>: Borders of an eastern portion of Madagascar
</p>
</li>
<li> <p><a href="#topic+madCover">madCover</a>: Land cover raster
</p>
</li>
<li> <p><a href="#topic+madCoverCats">madCoverCats</a>: Table of land cover classes
</p>
</li>
<li> <p><a href="#topic+madDypsis">madDypsis</a>: Specimens records of species in the genus <em>Dypsis</em>
</p>
</li>
<li> <p><a href="#topic+madElev">madElev</a>: Elevation raster
</p>
</li>
<li> <p><a href="#topic+madForest2000">madForest2000</a> and <a href="#topic+madForest2014">madForest2014</a>: Forest cover in 2000 and 2014
</p>
</li>
<li> <p><a href="#topic+madLANDSAT">madLANDSAT</a>: Surface reflectance in 2023
</p>
</li>
<li> <p><a href="#topic+madPpt">madPpt</a>, <a href="#topic+madTmin">madTmin</a>, <a href="#topic+madTmax">madTmax</a>: Rasters of mean monthly precipitation, and minimum and maximum temperature
</p>
</li>
<li> <p><a href="#topic+madRivers">madRivers</a>: Rivers vector
</p>
</li>
<li> <p><a href="#topic+vegIndices">vegIndices</a>: Vegetation indices that can be calculated using <code><a href="#topic+vegIndex">vegIndex()</a></code>
</p>
</li></ul>




<h4>Esoteric tutorials and arcane notes</h4>


<ul>
<li><p> Comparisons between <code>GRegion</code>s can be performed using the <code>==</code> and <code>!=</code> operators.
</p>
</li>
<li><p> Vignette on <strong>GRASS</strong> &quot;projects/locations&quot; and &quot;mapsets&quot;: <code>vignette("projects_mapsets", package = "fasterRaster")</code>
</p>
</li>
<li><p> Vignette on <strong>GRASS</strong> &quot;regions&quot;: <code>vignette("regions", package = "fasterRaster")</code>
</p>
</li>
<li><p> Vignette on <strong>GRASS</strong> 3-dimensional <code>GRaster</code>s and <code>GVector</code>s: <code>vignette("three_d_objects", package = "fasterRaster")</code>
</p>
</li>
<li><p> Vignette on <strong>fasterRaster</strong> hidden functions: <code>vignette("hidden_functions", package = "fasterRaster")</code>
</p>
</li></ul>




<h4>Classes</h4>


<ul>
<li> <p><code><a href="#topic+GLocation">GLocation</a></code>: Fundamental class; points to a &quot;location/project&quot; in <strong>GRASS</strong>
</p>
</li>
<li> <p><code><a href="#topic+GSpatial">GSpatial</a></code>: Basic class of any spatial object
</p>
</li>
<li> <p><code><a href="#topic+GRegion">GRegion</a></code>: Points to a &quot;region&quot; of a &quot;location/project&quot; in <strong>GRASS</strong>
</p>
</li>
<li> <p><code><a href="#topic+GRaster">GRaster</a></code>: Raster class
</p>
</li>
<li> <p><code><a href="#topic+GVector">GVector</a></code>: Spatial vector class
</p>
</li></ul>




<h3>Author(s)</h3>

<p>Adam B. Smith
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/adamlilith/fasterRaster">https://github.com/adamlilith/fasterRaster</a>
</p>
</li>
<li> <p><a href="https://adamlilith.github.io/fasterRaster/">https://adamlilith.github.io/fasterRaster/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/adamlilith/fasterRaster/issues">https://github.com/adamlilith/fasterRaster/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.backdoor'>Setup fasterRaster for ABS</h2><span id='topic+.backdoor'></span>

<h3>Description</h3>

<p>This is a secret function to be used for faster development of <strong>fasterRaster</strong>. It calls <code><a href="#topic+faster">faster()</a></code> to set the install directory for <strong>GRASS</strong>, increases default memory, and number of cores. The function assumes development is on a Windows machine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.backdoor(ver = "84")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".backdoor_+3A_ver">ver</code></td>
<td>
<p>Character: <strong>GRASS</strong>: e.g., &quot;83&quot; or &quot;84&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> (invisibly).
</p>

<hr>
<h2 id='.copyGSpatial+2CGRaster-method'>Make a copy of an object in GRASS</h2><span id='topic+.copyGSpatial+2CGRaster-method'></span><span id='topic+.copyGSpatial'></span><span id='topic+.copyGSpatial+2CGVector-method'></span><span id='topic+.copyGSpatial+2Ccharacter-method'></span><span id='topic+.copyGRaster'></span><span id='topic+.copyGVector'></span>

<h3>Description</h3>

<p>Create a copy of a <code>GRaster</code> or <code>GVector</code> in <strong>GRASS</strong>.  This function is used internally and is of little use to most users.  This only creates a copy of the object in the <strong>GRASS</strong> session&ndash;to make a <code>GRaster</code> or <code>GVector</code>, <code><a href="#topic+.makeGRaster">.makeGRaster()</a></code> or <code><a href="#topic+.makeGVector">.makeGVector()</a></code> need to be called after making the copy. Note that if the object is multi-layered, then a copy is made of each layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
.copyGSpatial(x, reshapeRegion = TRUE)

## S4 method for signature 'GVector'
.copyGSpatial(x)

## S4 method for signature 'character'
.copyGSpatial(x, type = NULL, topo = NULL, reshapeRegion = TRUE)

.copyGRaster(x, topo = "2D", reshapeRegion = TRUE)

.copyGVector(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".copyGSpatial+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code> or the <code><a href="#topic+sources">sources()</a></code> name of one.</p>
</td></tr>
<tr><td><code id=".copyGSpatial+2B2CGRaster-method_+3A_reshaperegion">reshapeRegion</code></td>
<td>
<p>Logical. If <code>TRUE</code>, <code>x</code> must be a <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id=".copyGSpatial+2B2CGRaster-method_+3A_type">type</code></td>
<td>
<p>Character or <code>NULL</code> (default): Either &quot;raster&quot; or &quot;vector&quot;. If a character, there must be one per value in <code>x</code>. If <code>NULL</code>, will attempt to auto-detect (takes longer).</p>
</td></tr>
<tr><td><code id=".copyGSpatial+2B2CGRaster-method_+3A_topo">topo</code></td>
<td>
<p>&quot;2D&quot; or &quot;3D&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector representing the <code><a href="#topic+sources">sources()</a></code> names of the copied object(s), plus makes a copy of the given object(s) in <strong>GRASS</strong>.
</p>
<p><code><a href="#topic+sources">sources()</a></code> names of copied rasters.
</p>

<hr>
<h2 id='.exists+2CGRaster-method'>Does the &quot;GRASS&quot; representation of a GRaster or GVector exist?</h2><span id='topic+.exists+2CGRaster-method'></span><span id='topic+.exists'></span><span id='topic+.exists+2CGVector-method'></span><span id='topic+.exists+2Ccharacter-method'></span>

<h3>Description</h3>

<p><code>GRaster</code>s and <code>GVector</code>s are <strong>R</strong> objects that contain a pointer to a raster or vector in <strong>GRASS</strong>. Thus, for a <code>GRaster</code> or <code>GVector</code> to be functional, the <strong>GRASS</strong> file must exist. This function indicates if that is so.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
.exists(x)

## S4 method for signature 'GVector'
.exists(x)

## S4 method for signature 'character'
.exists(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".exists+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>, <code>GVector</code>, or the <code><a href="#topic+sources">sources()</a></code> name of one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical.
</p>

<hr>
<h2 id='.ext'>Function to get extent from a &quot;sources&quot; name of a raster or vector</h2><span id='topic+.ext'></span>

<h3>Description</h3>

<p>Function to get extent from a &quot;sources&quot; name of a raster or vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.ext(x, rastOrVect = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".ext_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>, <code>GSpatial</code>, or a character (<code><a href="#topic+sources">sources()</a></code> name of a <code>GRaster</code> or <code>GVector</code>).</p>
</td></tr>
<tr><td><code id=".ext_+3A_rastorvect">rastOrVect</code></td>
<td>
<p>Either <code>NULL</code> (class taken from <code>x</code>, but <code>x</code> cannot be a character), or &quot;<code>raster</code>&quot; or &quot;<code>vector</code>&quot; (partial matching is used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector.
</p>

<hr>
<h2 id='.g.proj'>Call GRASS <code>g.proj</code> module</h2><span id='topic+.g.proj'></span>

<h3>Description</h3>

<p>This function calls the <strong>GRASS</strong> module <code>g.region</code> to display information on the projection of the current <strong>GRASS</strong> &quot;project&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.g.proj()
</code></pre>


<h3>Value</h3>

<p>Displays current projection information for the active &quot;project/location&quot; in <strong>GRASS</strong>.
</p>

<hr>
<h2 id='.g.region'>Call GRASS <code>g.region</code> module</h2><span id='topic+.g.region'></span>

<h3>Description</h3>

<p>This function calls the <strong>GRASS</strong> module <code>g.region</code> to display information on the region of the current <strong>GRASS</strong> &quot;project&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.g.region()
</code></pre>


<h3>Value</h3>

<p>Displays current region information for the active &quot;project/location&quot; in <strong>GRASS</strong>.
</p>

<hr>
<h2 id='.geomtype'>Get geometry type from the sources() name of a vector</h2><span id='topic+.geomtype'></span>

<h3>Description</h3>

<p>Get geometry type from the sources() name of a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.geomtype(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".geomtype_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code> or the <code><a href="#topic+sources">sources()</a></code> name of one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character (&quot;point&quot;, &quot;line&quot;, or &quot;area&quot;; i.e., in <strong>GRASS</strong> nomenclature).
</p>

<hr>
<h2 id='.layerIndex'>Get index of raster layers</h2><span id='topic+.layerIndex'></span>

<h3>Description</h3>

<p>Get index of raster layers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.layerIndex(layer, x, recycle = TRUE, negate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".layerIndex_+3A_layer">layer</code></td>
<td>
<p>Integer, numeric, logical, or character: Refers to one or more layers.</p>
</td></tr>
<tr><td><code id=".layerIndex_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id=".layerIndex_+3A_recycle">recycle</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), and <code>layer</code> is logical and smaller in number than the number of layers, then recycle the vector of <code>layer</code>.</p>
</td></tr>
<tr><td><code id=".layerIndex_+3A_negate">negate</code></td>
<td>
<p>Logical: If <code>TRUE</code>, return indices of all layers <em>not</em> identified in <code>layer</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector.
</p>

<hr>
<h2 id='.location+2CGLocation-method'>GRASS &quot;location&quot; of an object or the active session</h2><span id='topic+.location+2CGLocation-method'></span><span id='topic+.location'></span><span id='topic+.location+2Cmissing-method'></span><span id='topic+.locationDelete'></span>

<h3>Description</h3>

<p><strong>GRASS</strong> &quot;projects&quot; or &quot;locations&quot; are sets of one or more rasters and/or vectors with the same coordinate reference systems, and may or may not represent the same actual location on Earth. <strong>GRASS</strong> &quot;mapsets&quot; are like sub-folders of locations, and are collections of rasters and/or vectors typically related to the same general project. Typical users will not need to make changes to the default location (called &quot;location&quot;) or mapset (called &quot;PERMANENT&quot;). See <code>vignette("projects_mapsets", package = "fasterRaster")</code>.
</p>
<p>This function deletes a <strong>GRASS</strong> &quot;project&quot;/&quot;location&quot;, rasters, and vectors therein. This function should be used cautiously and is mainly of use to developers. See <code>vignette("projects_mapsets", package = "fasterRaster")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GLocation'
.location(x)

## S4 method for signature 'missing'
.location(x)

.locationDelete(location, mapset = NULL, workDir = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".location+2B2CGLocation-method_+3A_x">x</code></td>
<td>
<p>Either:
</p>

<ul>
<li><p> Missing: Reports location of currently active project/location.
</p>
</li>
<li><p> A <code>GLocation</code> object or an object that contains the <code>GLocation</code> class (i.e., a <code>GSpatial</code> object: a <code>GRaster</code> or <code>GVector</code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id=".location+2B2CGLocation-method_+3A_location">location</code></td>
<td>
<p>Character: Name of the <strong>GRASS</strong> &quot;location&quot;.</p>
</td></tr>
<tr><td><code id=".location+2B2CGLocation-method_+3A_mapset">mapset</code></td>
<td>
<p>Character or <code>NULL</code> (default): Name of the mapset to delete. If <code>NULL</code>, then all mapsets in the given &quot;location&quot; will be deleted.</p>
</td></tr>
<tr><td><code id=".location+2B2CGLocation-method_+3A_workdir">workDir</code></td>
<td>
<p>Character: Either <code>NULL</code> (default) or a character string of the directory in which the location to be removed resides. If <code>NULL</code>, then the working directory will be obtained from <code>faster("workDir")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string.
</p>
<p>If successful, <code>TRUE</code> (invisibly). If not, then <code>FALSE</code> (also invisibly), plus a warning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.mapset">.mapset()</a></code>
</p>

<hr>
<h2 id='.locationCreate+2Ccharacter-method'>Connect to &quot;GRASS&quot;</h2><span id='topic+.locationCreate+2Ccharacter-method'></span><span id='topic+.locationCreate'></span><span id='topic+.locationCreate+2CSpatRaster-method'></span><span id='topic+.locationCreate+2CSpatVector-method'></span><span id='topic+.locationCreate+2Csf-method'></span>

<h3>Description</h3>

<p>This function initializes a <strong>GRASS</strong> &quot;project&quot; (previously known in <strong>GRASS</strong> as a &quot;location&quot;; see <code>vignette("projects_mapsets", package = "fasterRaster")</code>). You need to run this function (often just once) before you use most functions in <strong>fasterRaster</strong>. This function is of use to developers, not most users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character'
.locationCreate(x, location = NULL, overwrite = FALSE, warn = TRUE)

## S4 method for signature 'SpatRaster'
.locationCreate(x, location = NULL, overwrite = FALSE, warn = TRUE)

## S4 method for signature 'SpatVector'
.locationCreate(x, location = NULL, overwrite = FALSE, warn = TRUE)

## S4 method for signature 'sf'
.locationCreate(x, location = NULL, overwrite = FALSE, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".locationCreate+2B2Ccharacter-method_+3A_x">x</code></td>
<td>
<p>Any object from which a coordinate reference system (CRS) can be acquired. Ergo, any of:
</p>

<ul>
<li><p> A <code>SpatRaster</code>, <code>SpatVector</code>, <code>SpatExtent</code>, <code>stars</code>, or <code>sf</code> object
</p>
</li>
<li><p> A <code>crs</code> object (i.e., from <code><a href="sf.html#topic+st_crs">sf::st_crs()</a></code>).
</p>
</li>
<li><p> A CRS (coordinate reference system) WKT string. Some PROJ4 strings <em>might</em> work, too.
</p>
</li></ul>
</td></tr>
<tr><td><code id=".locationCreate+2B2Ccharacter-method_+3A_location">location</code></td>
<td>
<p>Character or <code>NULL</code> (default): Name of the location.</p>
</td></tr>
<tr><td><code id=".locationCreate+2B2Ccharacter-method_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical: If <code>FALSE</code> (default), and a <strong>GRASS</strong> &quot;coordinate reference frame&quot; with the given name has already been created, then the function will fail. If <code>TRUE</code>, then the existing <strong>GRASS</strong> &quot;coordinate reference frame&quot; of the same name will be overwritten. <em>NOTE</em>: This will <strong>not</strong> remove any <strong>R</strong> objects associated with rasters or vectors in the &quot;location&quot;, but they will no longer work because the objects they point to will be overwritten.</p>
</td></tr>
<tr><td><code id=".locationCreate+2B2Ccharacter-method_+3A_warn">warn</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default) and <code>overwrite</code> is <code>TRUE</code>, then display a warning.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+GLocation">GLocation</a> object (invisibly).
</p>

<hr>
<h2 id='.locationFind+2Cmissing-method'>Match CRS of a GSpatial object and an existing &quot;GRASS&quot; location</h2><span id='topic+.locationFind+2Cmissing-method'></span><span id='topic+.locationFind+2CGLocation-method'></span><span id='topic+.locationFind+2CSpatRaster-method'></span><span id='topic+.locationFind+2CSpatVector-method'></span><span id='topic+.locationFind+2Csf-method'></span><span id='topic+.locationFind+2Ccharacter-method'></span>

<h3>Description</h3>

<p>The function searches the set of available <strong>GRASS</strong> &quot;projects&quot; (previously known as &quot;locations&quot;) for one that has a coordinate reference system matching a <code>GSpatial</code> object. If none are found, or if no connection with <strong>GRASS</strong> has yet been made, then it returns <code>NULL</code>. Otherwise, it returns either the index or the name of the matching location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'missing'
.locationFind(x, return = "name")

## S4 method for signature 'GLocation'
.locationFind(x, return = "name", match = "name")

## S4 method for signature 'SpatRaster'
.locationFind(x, return = "name", match = "name")

## S4 method for signature 'SpatVector'
.locationFind(x, return = "name", match = "name")

## S4 method for signature 'sf'
.locationFind(x, return = "name", match = "name")

## S4 method for signature 'character'
.locationFind(x, return = "name", match = "name")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".locationFind+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>Either:
</p>

<ul>
<li><p> Missing: Returns names and coordinate reference system strings of all &quot;locations&quot;.
</p>
</li>
<li><p> A character representing a coordinate reference system in WKT format
</p>
</li>
<li><p> A <code>SpatRaster</code>, <code>SpatVector</code>, or <code>sf</code> vector with a coordinate reference system
</p>
</li>
<li><p> A <code>GSpatial</code> object (usually a <code>GRaster</code> or <code>GVector</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id=".locationFind+2B2Cmissing-method_+3A_return">return</code></td>
<td>
<p>Either:
</p>

<ul>
<li> <p><code>"name"</code> (default): Returns the name of the &quot;location&quot; with a coordinate reference system the same as <code>x</code>.
</p>
</li>
<li> <p><code>"index"</code>: Returns the index of this &quot;location&quot; in <code>.fasterRaster$locations</code> of the <code>.fasterRaster</code> environment.
</p>
</li>
<li> <p><code>"crs"</code>: Returns the coordinate reference system of this &quot;project/location&quot;.
</p>
</li></ul>
</td></tr>
<tr><td><code id=".locationFind+2B2Cmissing-method_+3A_match">match</code></td>
<td>
<p>Character: Method used to find the location. If <code>match</code> is &quot;<code>name</code>&quot;&quot; (default), then the name of the location is used. If <code>match</code> is &quot;<code>crs</code>&quot;, then the coordinate reference system of each location is checked for a match.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character, integer, or <code>NULL</code> (if no match is found).
</p>

<hr>
<h2 id='.locationRestore+2Ccharacter-method'>Revert to a previously-created &quot;GRASS&quot; &quot;location&quot;</h2><span id='topic+.locationRestore+2Ccharacter-method'></span><span id='topic+.locationRestore'></span><span id='topic+.locationRestore+2Cinteger-method'></span><span id='topic+.locationRestore+2Cnumeric-method'></span><span id='topic+.locationRestore+2CGSpatial-method'></span>

<h3>Description</h3>

<p>This function resets the connection to a previously-created <strong>GRASS</strong> &quot;location&quot;. The session must have been already created using <code><a href="#topic+fast">fast()</a></code> in the current <strong>R</strong> session. This function is typically only of use to developers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character'
.locationRestore(x)

## S4 method for signature 'integer'
.locationRestore(x)

## S4 method for signature 'numeric'
.locationRestore(x)

## S4 method for signature 'GSpatial'
.locationRestore(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".locationRestore+2B2Ccharacter-method_+3A_x">x</code></td>
<td>
<p>Either:
</p>

<ul>
<li><p> A character: Name of the &quot;location&quot; in <strong>GRASS</strong>.
</p>
</li>
<li><p> An integer: Index of the &quot;location&quot; in <code>.fasterRaster$locations</code>.
</p>
</li>
<li><p> A <code>GSpatial</code> object (usually a <code>GRaster</code> or <code>GVector</code>).
</p>
</li></ul>

<p>Any of these can be found using <code>.locationFind()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>GLocation</code> (invisibly) if successful. An error will likely result if not.
</p>

<hr>
<h2 id='.locations'>Meta-data on active GRASS locations</h2><span id='topic+.locations'></span>

<h3>Description</h3>

<p><strong>GRASS</strong> uses &quot;locations&quot;to store sets of rasters and vectors with the same coordinate reference system (CRS). These rasters and vectors may or may not be in the same actual location on Earth&ndash;they just have the same CRS. This function returns information on all of the <strong>GRASS</strong> &quot;locations&quot; that have been initialized. It is mainly useful for developers.
</p>
<p>NB: <strong>fasterRaster</strong> always uses the &quot;PERMANENT&quot; mapset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.locations(warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".locations_+3A_warn">warn</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), display a warning if no <strong>GRASS</strong> &quot;locations&quot; have been created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>list</code>. The names are the &quot;location's&quot; names and the values are the coordinate reference strings.
</p>

<hr>
<h2 id='.ls'>List objects in the active GRASS session</h2><span id='topic+.ls'></span>

<h3>Description</h3>

<p>Display the <code>sources</code> (see <code>sources()</code>) of all rasters and/or vectors that have been exported to or created in the active <strong>GRASS</strong> session&quot;s location and mapset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.ls(type = c("rasters", "vectors", "rasters3d", "groups"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".ls_+3A_type">type</code></td>
<td>
<p>The type of spatial objects to display. This can include <code>"rasters"</code> (all rasters), <code>"vectors"</code> (all spatial vectors), <code>"rasters3d"</code> (3D-rasters), and/or <code>"groups"</code> (groups). Partial matching is supported. If missing, all objects are displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of names of <strong>GRASS</strong> objects.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+ls">ls()</a></code>
</p>

<hr>
<h2 id='.makeGRaster'>Create a GRaster</h2><span id='topic+.makeGRaster'></span>

<h3>Description</h3>

<p>Create a <code>GRaster</code> from a raster existing in the current <strong>GRASS</strong> session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.makeGRaster(src, names = "raster", levels = "", ac = NULL, fail = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".makeGRaster_+3A_src">src</code></td>
<td>
<p>Character (name of the raster in **GRASS) or a <code>rastInfo</code> object.</p>
</td></tr>
<tr><td><code id=".makeGRaster_+3A_names">names</code></td>
<td>
<p>Character: Name of the raster.</p>
</td></tr>
<tr><td><code id=".makeGRaster_+3A_levels">levels</code></td>
<td>
<p><code>NULL</code> (default), a <code>data.frame</code>, <code>data.table</code>, an empty string (<code>""</code>), or a list of <code>data.frame</code>s, <code>data.table</code>s, and/or empty strings: These become the raster's <code><a href="#topic+levels">levels()</a></code>. If <code>""</code>, then no levels are defined.</p>
</td></tr>
<tr><td><code id=".makeGRaster_+3A_ac">ac</code></td>
<td>
<p>Vector of numeric/integer values &gt;=1, or <code>NULL</code> (default): Active category column (offset by 1, so 1 really means the second column, 2 means the third, etc.). A value of <code>NULL</code> uses an automated procedure to figure it out.</p>
</td></tr>
<tr><td><code id=".makeGRaster_+3A_fail">fail</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), and the raster either has a 0 east-west or north-south extent, then exit the function with an error. If <code>fail</code> is <code>FALSE</code>, then display a warning and return <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.makeGVector">.makeGVector()</a></code>
</p>

<hr>
<h2 id='.makeGVector'>Create a GVector</h2><span id='topic+.makeGVector'></span>

<h3>Description</h3>

<p>Create a <code>GVector</code> from a vector existing in the current <strong>GRASS</strong> session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.makeGVector(
  src,
  table = NULL,
  build = TRUE,
  extensive = FALSE,
  cats = NULL,
  fail = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".makeGVector_+3A_src">src</code></td>
<td>
<p>Character: The name of the vector in <strong>GRASS</strong>.</p>
</td></tr>
<tr><td><code id=".makeGVector_+3A_table">table</code></td>
<td>
<p>A <code>data.table</code>, <code>data.frame</code>, <code>GVector</code> with a table, or character. This can be <code>data.table(NULL)</code> or <code>data.frame(NULL)</code> if there is no table associated with the vector. If a character, this is interpreted as the name of the table in <strong>GRASS</strong>.</p>
</td></tr>
<tr><td><code id=".makeGVector_+3A_build">build</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), build topology using <strong>GRASS</strong> module <code>v.build</code>.</p>
</td></tr>
<tr><td><code id=".makeGVector_+3A_extensive">extensive</code></td>
<td>
<p>Logical: If <code>TRUE</code>, do extensive topological checks using <code>v.build</code>. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id=".makeGVector_+3A_cats">cats</code></td>
<td>
<p><code>NULL</code> (default) or an integer vector: Values of the &quot;cats&quot; (categories) of the vector in <strong>GRASS</strong>. This is useful <em>only</em> for speeding up the <code>GVector</code> creation process when the &quot;cats&quot; have already been ascertained.</p>
</td></tr>
<tr><td><code id=".makeGVector_+3A_fail">fail</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), and the vector either has a 0 east-west or north-south extent, then exit the function with an error. If <code>fail</code> is <code>FALSE</code>, then display a warning and return <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GVector</code> (or <code>NULL</code> if <code>fail</code> is <code>TRUE</code> and the <code>GVector</code> would be invalid).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.makeGRaster">.makeGRaster()</a></code>
</p>

<hr>
<h2 id='.makeSourceName'>Make unique GRASS name for rasters, vectors, etc.</h2><span id='topic+.makeSourceName'></span>

<h3>Description</h3>

<p>Make unique GRASS name for rasters, vectors, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.makeSourceName(x = NULL, type = NULL, n = 1L, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".makeSourceName_+3A_x">x</code></td>
<td>
<p>Character or <code>NULL</code>: Descriptive string. <strong>Developers, please note</strong>: To assist with debugging, <strong>GRASS</strong> objects created by a <strong>GRASS</strong> module have the module named in this argument (with underscores). Example: &quot;v_in_ogr&quot; or &quot;r_resample&quot;.</p>
</td></tr>
<tr><td><code id=".makeSourceName_+3A_type">type</code></td>
<td>
<p>Character: <code>raster</code>, <code>raster3D</code>, <code>vector</code>, or <code>table</code>.</p>
</td></tr>
<tr><td><code id=".makeSourceName_+3A_n">n</code></td>
<td>
<p>Numeric integer: Number of names to make</p>
</td></tr>
<tr><td><code id=".makeSourceName_+3A_name">name</code></td>
<td>
<p><code>NULL</code> (default) or <code>character</code>: Name of the output, attached as an attribute.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector.
</p>

<hr>
<h2 id='.mapset+2CGLocation-method'>GRASS &quot;mapset&quot; of an object or the active session</h2><span id='topic+.mapset+2CGLocation-method'></span><span id='topic+.mapset'></span><span id='topic+.mapset+2Cmissing-method'></span>

<h3>Description</h3>

<p><strong>GRASS</strong> &quot;locations&quot; are sets of one or more rasters and/or vectors with the same coordinate reference systems, and may or may not represent the same actual location on Earth. <strong>GRASS</strong> &quot;mapsets&quot; are like subfolders of locations, and are collections of rasters and/or vectors typically related to the same general project. This function returns the mapset of an object or the current mapset. This said, <strong>fasterRaster</strong> always uses the &quot;PERMANENT&quot; mapset, so there is very little reason to use this function as-is. See <code>vignette("projects_mapsets", package = "fasterRaster")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GLocation'
.mapset(x)

## S4 method for signature 'missing'
.mapset(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".mapset+2B2CGLocation-method_+3A_x">x</code></td>
<td>
<p>A Either:
</p>

<ul>
<li><p> Missing: Reports mapset of currently active <strong>GRASS</strong> &quot;projects&quot;/&quot;locations&quot;.
</p>
</li>
<li><p> A <code>GLocation</code> object or an object that contains the <code>GLocation</code> class (i.e., a <code>GSpatial</code> object: a <code>GRaster</code> or <code>GVector</code>): Reports the CRS of the object.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string.
</p>


<h3>See Also</h3>

<p><strong>GRASS</strong> <a href="https://grass.osgeo.org/grass82/manuals/grass_database.html">locations and mapsets</a>
</p>

<hr>
<h2 id='.maxVal'>Get maximum value from GRaster metadata</h2><span id='topic+.maxVal'></span>

<h3>Description</h3>

<p>Get maximum value from GRaster metadata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.maxVal(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".maxVal_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='.message'>Display warning or message</h2><span id='topic+.message'></span>

<h3>Description</h3>

<p>Display a warning or message if the given warning has not been displayed since <strong>fasterRaster</strong> was attached or if a given number or hours has passed since then.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.message(msg, message)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".message_+3A_msg">msg</code></td>
<td>
<p>Character: Name for the message (used internally). Should be able to be assigned to a list (i.e., no spaces, punctuation, etc.).</p>
</td></tr>
<tr><td><code id=".message_+3A_message">message</code></td>
<td>
<p>Text for the message.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> (invisibly).
</p>

<hr>
<h2 id='.minVal'>Get minimum value from GRaster metadata</h2><span id='topic+.minVal'></span>

<h3>Description</h3>

<p>Get minimum value from GRaster metadata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.minVal(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".minVal_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='.nlevels'>Count number of levels from a data.frame/table, list, or SpatRaster</h2><span id='topic+.nlevels'></span>

<h3>Description</h3>

<p>Counts number of levels in a character string (specifically, the empty string <code>""</code>), a <code>data.frame</code>, <code>data.table</code>, or list of <code>data.frame</code>s or <code>data.table</code>s or empty strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.nlevels(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".nlevels_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>, <code>SpatRaster</code>, <em>or</em> a <code>data.frame</code>, <code>data.table</code>, an empty string, or a list thereof.</p>
</td></tr>
</table>

<hr>
<h2 id='.plot'>Plot using a G-object's <code><a href="#topic+sources">sources()</a></code> name</h2><span id='topic+.plot'></span>

<h3>Description</h3>

<p>Plot using a G-object's <code><a href="#topic+sources">sources()</a></code> name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".plot_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+sources">sources()</a></code> name of a <code>GRaster</code> or <code>GVector</code></p>
</td></tr>
<tr><td><code id=".plot_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code><a href="#topic+plot">plot()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='.projection'>Get &quot;GRASS&quot; projection of raster or vector</h2><span id='topic+.projection'></span>

<h3>Description</h3>

<p>&quot;Getter&quot; for the @projection slot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.projection(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".projection_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> or <code>GVector</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character.
</p>

<hr>
<h2 id='.quiet'>Returns .quiet() or NULL for &quot;flags&quot; argument to GRASS modules</h2><span id='topic+.quiet'></span>

<h3>Description</h3>

<p>A function for developers used for setting the &quot;quiet' argument in <code>flags</code> arguments passed to <code><a href="rgrass.html#topic+execGRASS">rgrass::execGRASS()</a></code>. If <code>faster("debug")</code> is <code>TRUE</code>, the string &quot;quiet&quot; is returned. If <code>FALSE</code>, then <code>NULL</code> is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.quiet()
</code></pre>


<h3>Value</h3>

<p>A string (.quiet()) or <code>NULL</code>.
</p>

<hr>
<h2 id='.rastInfo'>Metadata on rasters and vectors in GRASS</h2><span id='topic+.rastInfo'></span>

<h3>Description</h3>

<p><code>.rastInfo()</code> and <code>.vectInfo()</code> fetch metadata on rasters and vectors in <strong>GRASS</strong>. The <code>print()</code>, <code>show()</code>, and <code>summary()</code> functions can be used to display this metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rastInfo(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".rastInfo_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>, <code>GVector</code>, or <code>sources</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Metadata on the extent, dimensions, resolution, bottom/top, etc. of rasters and vectors in <strong>GRASS</strong>.
</p>

<hr>
<h2 id='.region+2Cmissing-method'>Report or change the extent, dimensions, and/or resolution of a region GRASS</h2><span id='topic+.region+2Cmissing-method'></span><span id='topic+.region'></span><span id='topic+.region+2CSpatRaster-method'></span><span id='topic+.region+2CGRegion-method'></span><span id='topic+.region+2CGRaster-method'></span><span id='topic+.region+2CGVector-method'></span><span id='topic+.regionExt+2Cmissing-method'></span><span id='topic+.regionExt'></span><span id='topic+.regionExt+2Cnumeric-method'></span><span id='topic+.regionExt+2CGSpatial-method'></span><span id='topic+.regionDim+2Cmissing-method'></span><span id='topic+.regionDim'></span><span id='topic+.regionDim+2Cnumeric-method'></span><span id='topic+.regionDim+2CGRegion-method'></span><span id='topic+.regionRes+2Cmissing-method'></span><span id='topic+.regionRes'></span><span id='topic+.regionRes+2Cnumeric-method'></span><span id='topic+.regionRes+2CGRegion-method'></span>

<h3>Description</h3>

<p>These functions either change the extent, dimensions, and/or resolution of a <strong>GRASS</strong> &quot;region&quot; or report the current region's extent, dimensions, and/or resolution (see <code>vignette("regions", package = "fasterRaster")</code>). These functions are mostly used internally and rarely of interest to most users.
</p>

<ul>
<li> <p><code>.region()</code>: All 2D and 3D aspects of a region.
</p>
</li>
<li> <p><code>.regionDim()</code>: x- and y-dimensions.
</p>
</li>
<li> <p><code>.regionExt()</code>: x- and y-extent.
</p>
</li>
<li> <p><code>.regionRes()</code>: x- and y-resolution.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'missing'
.region(x)

## S4 method for signature 'SpatRaster'
.region(x)

## S4 method for signature 'GRegion'
.region(x)

## S4 method for signature 'GRaster'
.region(x, trim = NULL)

## S4 method for signature 'GVector'
.region(x)

## S4 method for signature 'missing'
.regionExt(x)

## S4 method for signature 'numeric'
.regionExt(x, respect)

## S4 method for signature 'GSpatial'
.regionExt(x, respect)

## S4 method for signature 'missing'
.regionDim(x)

## S4 method for signature 'numeric'
.regionDim(x, respect)

## S4 method for signature 'GRegion'
.regionDim(x, respect)

## S4 method for signature 'missing'
.regionRes(x)

## S4 method for signature 'numeric'
.regionRes(x, respect)

## S4 method for signature 'GRegion'
.regionRes(x, respect)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".region+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>Any of:
</p>

<ul>
<li><p> Missing (default): Reports the extent, resolution, and dimensions of the current region. All other arguments will be ignored. You can also use <code><a href="#topic+ext">ext()</a></code>, <code><a href="#topic+dim">dim()</a></code>, and <code><a href="#topic+res">res()</a></code> and related functions with missing arguments.
</p>
</li>
<li><p> A <code>GSpatial</code>, <code>GRegion</code>, <code>GRaster</code>, <code>GVector</code> object: Sets the region&quot;s extent, dimensions, and/or resolution to those of the object.
</p>
</li>
<li><p> A <code>numeric</code> vector. This will resize the region's extent, resample the region's resolution/dimensions, or both, to ensure the desired dimensions or resolution are retained:
* 2 values for <code>.regionDim()</code>: Number of rows and columns
* 4 values for <code>.regionExt()</code>: Westernmost and easternmost easting (longitude), and southernmost and northernmost northing (latitude)
* 2 values for <code>.regionRes()</code>: Size of cells in the x- and y-dimensions
</p>
</li></ul>
</td></tr>
<tr><td><code id=".region+2B2Cmissing-method_+3A_trim">trim</code></td>
<td>
<p>A <code>GRaster</code> or <code>NULL</code> (default). If a <code>GRaster</code>, then the region will be trimmed to the non-<code>NA</code> cells in this raster. <code>trim</code> can only be non-<code>NULL</code> if <code>x</code> is a <code>GRaster</code>. Ignored if <code>NULL</code>.</p>
</td></tr>
<tr><td><code id=".region+2B2Cmissing-method_+3A_respect">respect</code></td>
<td>
<p>Character or <code>GRaster</code>: Indicates what aspect(s) of the current region to retain. Different functions allow for a different aspect to be retained. Partial matching is used.
</p>

<ul>
<li> <p><code>.regionDim()</code>: <code>"extent"</code> (extent unchanged, resolution may be changed) or <code>"resolution"</code> (resolution unchanged, extent may be changed).
</p>
</li>
<li> <p><code>.regionExt()</code>: <code>"dimensions"</code> (dimensions unchanged, extent may be changed) or <code>"resolution"</code> (resolution unchanged, extent may be changed).
</p>
</li>
<li> <p><code>.regionRes()</code>: <code>"extent"</code> (extent may be changed and/or dimensions may be changed to accommodate desired cell size) or <code>"dimensions"</code> (extent may be changed, dimensions unchanged).
Alternatively, a <code>GRaster</code> can be supplied:
</p>
</li>
<li> <p><code>.regionDim()</code>: New region will have same extent and resolution.
</p>
</li>
<li> <p><code>.regionExt()</code>: New region will have same dimensions and resolution.
</p>
</li>
<li> <p><code>.regionRes()</code>: New region will have same extent and dimensions.
</p>
</li></ul>

<p>In this case, the new region&quot;s registration will be the same as this raster, and cell resolution will be the same
</p>
<p>Note: In most cases extent cannot be retained exactly if the resolution is changed. When resolution is changed, the actual extent will be the user-supplied extent expanded by zero to one rows or zero to one columns to accommodate an integer number of cells of the desired size. The western and northern limits of the extent will be retained, while the eastern and southern limits of the extent will be moved to accommodate an integer number of columns and rows.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When resizing extent, <strong>terra</strong> keeps the <code>xmin</code> (west) and <code>ymax</code> (north) the fixed and shifts <code>xmax</code> (east) and <code>ymin</code> (south) as needed. To retain as much fidelity between <strong>fasterRaster</strong> and <strong>terra</strong> as possible, these functions do the same to the region.
</p>


<h3>Value</h3>

<p>The value returned depends on how the function is used:
</p>

<ul>
<li><p> If used with no arguments, <code>.region()</code> returns a <code>GRegion</code> object.
</p>
</li>
<li><p> If used with no arguments, <code>.regionDim()</code>, <code>.regionExt()</code>, and <code>.regionRes()</code> return numeric or integer vectors.
</p>
</li>
<li><p> If the function is used to change reshape/resample the region, it returns a <code>GRegion</code> object reflecting the region <em>before</em> it was changed. This allows users to revert to the original region if desired.
</p>
</li></ul>


<hr>
<h2 id='.rename'>Rename a raster or vector in an existing GRASS session</h2><span id='topic+.rename'></span>

<h3>Description</h3>

<p>Rename a raster or vector in an existing <strong>GRASS</strong> session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rename(from, to, rastOrVect = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".rename_+3A_from">from</code>, <code id=".rename_+3A_to">to</code></td>
<td>
<p><code>sources</code> of the raster or vector to rename.</p>
</td></tr>
<tr><td><code id=".rename_+3A_rastorvect">rastOrVect</code></td>
<td>
<p>Either <code>NULL</code> (default), <code>"raster"</code>, or <code>"vector"</code>. This specifies the type of object to be renamed. Partial matching is allowed. If left as <code>NULL</code> (default), the function will try to identify if the object is a raster or vector, and return an error if there is both a raster and vector of given name. Note that unlike in <strong>R</strong>, <strong>GRASS</strong> can have rasters and vector&quot;s with the same name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function invisibly returns <code>TRUE</code> if the desired rasters and/or vectors were named, and <code>FALSE</code> if raster and/or vector to be renamed did not exist in the <code>GRASS</code> session. Notably, a raster or vector or both are renamed in an existing <code>GRASS</code> session.
</p>

<hr>
<h2 id='.rm'>Delete objects in the active GRASS session</h2><span id='topic+.rm'></span>

<h3>Description</h3>

<p>Delete the names of all rasters and/or vectors that have been exported to or created in the active <strong>GRASS</strong> session's location and mapset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rm(x, type = NULL, warn = TRUE, verify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".rm_+3A_x">x</code></td>
<td>
<p>Character, a <code>GSpatial</code> object, or missing (default):
</p>

<ul>
<li><p> Character:
</p>

<ul>
<li><p> Any of <code>"rasters"</code> (all rasters), <code>"vectors"</code> (all spatial vectors), <code>"rasters3d"</code> (3D-rasters), and/or <code>"groups"</code> (groups), and all of these types will be deleted. Partial matching is supported.
</p>
</li>
<li><p> The <code>sources</code> of the object to be deleted. Argument <code>type</code> must be specified.
</p>
</li></ul>

</li>
<li> <p><code>GSpatial</code> object (i.e., a <code>GRaster</code> or <code>GVector</code>): Delete this object.
</p>
</li>
<li><p> Missing: Delete everything in the active <strong>GRASS</strong> session.
</p>
</li></ul>
</td></tr>
<tr><td><code id=".rm_+3A_type">type</code></td>
<td>
<p>The type of spatial objects to delete. This can include <code>"rasters"</code> (all rasters), <code>"vectors"</code> (all spatial vectors), <code>"rasters3d"</code> (3D-rasters), and/or <code>"groups"</code> (groups). Partial matching is supported. If missing, all objects are candidates for deletion if they match <code>x</code>.</p>
</td></tr>
<tr><td><code id=".rm_+3A_warn">warn</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), display warning if no matches or if everything in <strong>GRASS</strong> is to be deleted.</p>
</td></tr>
<tr><td><code id=".rm_+3A_verify">verify</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), the function will search for the item(s) to be deleted first to verify they exist. If this is <code>FALSE</code>, then <code>x</code> MUST be specified and <code>type</code> must be '<code>raster</code>' or <code>'vector'</code> (one value per value in <code>x</code>). This has no effect if <code>x</code> is a <code>GSpatial</code> object. It's main use is to save a bit of time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> (invisibly).
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+rm">rm()</a></code>
</p>

<hr>
<h2 id='.vAsDataTable'>Convert a GRASS vector's attribute table to a data.table</h2><span id='topic+.vAsDataTable'></span>

<h3>Description</h3>

<p><strong>GRASS</strong> vectors can be linked to an attribute table, which can be exported from <strong>GRASS</strong> to <strong>R</strong> using this function. <strong>This function is mostly of use to developers.</strong>
</p>
<p>Values in the <code>cat</code> column are not necessarily unique&ndash;if a value appears more than once, the set of features they index are (in other software) called &quot;multipart&quot; features. The table can have more columns with metadata for each feature.
</p>
<p>This function is typically used by developers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.vAsDataTable(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".vAsDataTable_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code> or the name of a vector in <strong>GRASS</strong>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> or <code>NULL</code> if the vector is not attached to a database.
</p>

<hr>
<h2 id='.vAttachDatabase'>Add a database table to a GRASS attribute table</h2><span id='topic+.vAttachDatabase'></span>

<h3>Description</h3>

<p><code>.vAttachDatabase()</code> adds a table to a <strong>GRASS</strong> vector. This table is meant to be &quot;invisible&quot; to most users&ndash;they should use interact with attribute tables using the <code>GVector</code> slot <code style="white-space: pre;">&#8288;@table&#8288;</code>. Some functions require tables (e.g., <code><a href="#topic+extract">extract()</a></code> and <code><a href="#topic+spatSample">spatSample()</a></code>). <strong>This function is mostly of use to developers.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.vAttachDatabase(x, table = NULL, replace = TRUE, cats = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".vAttachDatabase_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code> or the name of a vector in <strong>GRASS</strong>.</p>
</td></tr>
<tr><td><code id=".vAttachDatabase_+3A_table">table</code></td>
<td>
<p>Either <code>NULL</code> (default), or a <code>data.frame</code> or <code>data.table</code>, or a numeric or integer vector:
</p>

<ul>
<li><p> If <code>NULL</code>, then a bare minimal table will be created with a column named <code>cat</code>, holding sequential integer values.
</p>
</li>
<li><p> If a <code>data.frame</code> or <code>data.table</code> and no column is named <code>cat</code>, one will be created with sequential integer values. If the table does have a column named <code>cat</code>, then it should have integer (not just numeric) values.
</p>
</li>
<li><p> If a <code>vector</code>, then these are coerced to type <code>integer</code> and used to define the <code>cat</code> column.
</p>
</li></ul>

<p>There should be one row/value per geometry in <code>x</code>.</p>
</td></tr>
<tr><td><code id=".vAttachDatabase_+3A_replace">replace</code></td>
<td>
<p>Logical: If <code>TRUE</code>, replace the existing database connection.</p>
</td></tr>
<tr><td><code id=".vAttachDatabase_+3A_cats">cats</code></td>
<td>
<p>Either <code>NULL</code> (default), or an integer vector: This is provided as a means to save time by passing <code>cats</code> to this function if it has already been generated by a calling function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the <code><a href="#topic+sources">sources()</a></code> name of a vector in <strong>GRASS</strong>.
</p>

<hr>
<h2 id='.vCats'>Category column values of a GRASS vector</h2><span id='topic+.vCats'></span>

<h3>Description</h3>

<p>Returns values in the <code>cat</code> column of a vector in <strong>GRASS</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.vCats(x, layer = 1, db = FALSE, integer = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".vCats_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code> or the name of a vector in <strong>GRASS</strong>.</p>
</td></tr>
<tr><td><code id=".vCats_+3A_layer">layer</code></td>
<td>
<p>Integer, numeric integer, or character: Layer from which to obtain category values.</p>
</td></tr>
<tr><td><code id=".vCats_+3A_db">db</code></td>
<td>
<p>Logical: If <code>TRUE</code>, return category numbers from the database table associated with the vector. If <code>FALSE</code> (default), return category numbers from the actual vector.</p>
</td></tr>
<tr><td><code id=".vCats_+3A_integer">integer</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), return category values as integers. In some cases, a geometry can have multiple categories, in which case <code>NA</code> is returned. If <code>FALSE</code>, return category values as strings (and thus, if a geometry has more than one category, does not convert to <code>NA</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector.
</p>

<hr>
<h2 id='.vDetachDatabase'>Add a database table to a GRASS attribute table</h2><span id='topic+.vDetachDatabase'></span>

<h3>Description</h3>

<p><code>.vDetachDatabase()</code> detaches the database from a <strong>GRASS</strong> vector and deletes it. This table is meant to be &quot;invisible&quot; to most users&ndash;they should use interact with attribute tables using the <code>GVector</code> slot <code style="white-space: pre;">&#8288;@table&#8288;</code>. Some functions do require tables (e.g., <code><a href="#topic+extract">extract()</a></code> and <code><a href="#topic+spatSample">spatSample()</a></code>). <strong>This function is mostly of use to developers.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.vDetachDatabase(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".vDetachDatabase_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code> or the name of a vector in <strong>GRASS</strong>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the <code><a href="#topic+sources">sources()</a></code> name of a vector in <strong>GRASS</strong>.
</p>

<hr>
<h2 id='.vectInfo'>Metadata on a vector in GRASS</h2><span id='topic+.vectInfo'></span>

<h3>Description</h3>

<p>This function queries <strong>GRASS</strong> to obtain metadata on a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.vectInfo(x, integer = TRUE, cats = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".vectInfo_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code> or the <code><a href="#topic+sources">sources()</a></code> name of one.</p>
</td></tr>
<tr><td><code id=".vectInfo_+3A_integer">integer</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), the &quot;cats&quot; of a vector will be returned as type integer. If <code>FALSE</code>, they will be returned as a character vector.</p>
</td></tr>
<tr><td><code id=".vectInfo_+3A_cats">cats</code></td>
<td>
<p><code>NULL</code> (default) or an integer vector of category numbers, one per geometry.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vectInfo</code> object (a list).
</p>

<hr>
<h2 id='.vHasDatabase'>Tests if a GRASS vector is linked to an attribute table</h2><span id='topic+.vHasDatabase'></span>

<h3>Description</h3>

<p><strong>GRASS</strong> vectors can be lined to one or more attribute tables, or &quot;databases.&quot;. This function tests to see if the vector does indeed have a database. This function is typically used by developers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.vHasDatabase(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".vHasDatabase_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code> or the <code><a href="#topic+sources">sources()</a></code> name of a vector in <strong>GRASS</strong>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical.
</p>

<hr>
<h2 id='.vIncrementCats'>Increment category values of a &quot;GRASS&quot; vector</h2><span id='topic+.vIncrementCats'></span>

<h3>Description</h3>

<p>Adds a constant to all category values of a <strong>GRASS</strong> vector. <strong>This function is mostly of use to developers.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.vIncrementCats(x, add)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".vIncrementCats_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code> or the <code><a href="#topic+sources">sources()</a></code> name of one.</p>
</td></tr>
<tr><td><code id=".vIncrementCats_+3A_add">add</code></td>
<td>
<p>Integer: Value to add to each category value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code><a href="#topic+sources">sources()</a></code> name of a <strong>GRASS</strong> vector with category values incremented.
</p>

<hr>
<h2 id='.vNames'>Names of columns of a GRASS vector's attribute table</h2><span id='topic+.vNames'></span>

<h3>Description</h3>

<p>This function returns the column names of a <strong>GRASS</strong> vector's attribute table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.vNames(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".vNames_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code> or the name of a vector in <strong>GRASS</strong>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector.
</p>

<hr>
<h2 id='.vRecat'>Re-make vector &quot;category&quot; (cat) values</h2><span id='topic+.vRecat'></span>

<h3>Description</h3>

<p>Each geometry in a <strong>GRASS</strong> vector has a &quot;category&quot; number (abbreviated &quot;cat&quot; in output and modules). Geometries can have the same or different numbers, but for functions to work as intended, they often need to have sequential category values, starting at 1, with no skips between integers. This function reconstitutes the category values of a vector in <strong>GRASS</strong> so they being with 1 and have no skips. <strong>This function is mostly of use to developers.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.vRecat(x, gtype, cats = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".vRecat_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code> or the <code><a href="#topic+sources">sources()</a></code> name of a vector in <strong>GRASS</strong>.</p>
</td></tr>
<tr><td><code id=".vRecat_+3A_gtype">gtype</code></td>
<td>
<p>Character: Type of vector features in <strong>GRASS</strong> format (i.e., either <code>point</code>, <code>line</code>, or <code>area</code>). See <code><a href="#topic+geomtype">geomtype()</a></code>.</p>
</td></tr>
<tr><td><code id=".vRecat_+3A_cats">cats</code></td>
<td>
<p><code>NULL</code> (default) or <code>integer</code> or <code>character</code> vector: Category values of the <strong>GRASS</strong> vector. Supplying these can speed the re-assignment of categories. The values of <code>cats</code> is <em>not</em> used as the new category values. Rather, they will be used to indicate which geometries belong to the same multi-part feature.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code><a href="#topic+sources">sources()</a></code> name of a vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.vIncrementCats">.vIncrementCats()</a></code>, <code><a href="#topic+.vCats">.vCats()</a></code>
</p>

<hr>
<h2 id='.vValidCats'>Are the category values of a vector valid?</h2><span id='topic+.vValidCats'></span>

<h3>Description</h3>

<p>Category values of a <strong>GRASS</strong> vector can be invalid if <strong>GRASS</strong> assigns more than one value to a geometry (e.g., &quot;7/12&quot;). This can occur when the vector was created by software that does not use a topological system (e.g., a shapefile).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.vValidCats(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".vValidCats_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code> or the <code><a href="#topic+sources">sources()</a></code> name of one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical.
</p>

<hr>
<h2 id='.workDir+2CGLocation-method'>Get a GLocation's working directory</h2><span id='topic+.workDir+2CGLocation-method'></span><span id='topic+.workDir'></span>

<h3>Description</h3>

<p>This function returns the working directory of a <code>GLocation</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GLocation'
.workDir(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".workDir+2B2CGLocation-method_+3A_x">x</code></td>
<td>
<p>A <code>GLocation</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character.
</p>

<hr>
<h2 id='.zonal'>Internal function for zonal()</h2><span id='topic+.zonal'></span>

<h3>Description</h3>

<p>Internal function for zonal()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.zonal(x, z, fun, probs, zones, xnames)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".zonal_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+sources">sources()</a></code> name of <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id=".zonal_+3A_z">z</code></td>
<td>
<p><code><a href="#topic+sources">sources()</a></code> name of &quot;zones&quot; <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id=".zonal_+3A_fun">fun</code></td>
<td>
<p>Character: Name of function(s).</p>
</td></tr>
<tr><td><code id=".zonal_+3A_probs">probs</code></td>
<td>
<p>Numeric in the range 0 to 1, inclusive.</p>
</td></tr>
<tr><td><code id=".zonal_+3A_zones">zones</code></td>
<td>
<p>Vector of zone values (integers).</p>
</td></tr>
<tr><td><code id=".zonal_+3A_xnames">xnames</code></td>
<td>
<p>Character: Names of <code>x</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='.zonalByVector'>Internal function for zonal() when y is a GVector</h2><span id='topic+.zonalByVector'></span>

<h3>Description</h3>

<p>Internal function for zonal() when y is a GVector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.zonalByVector(x, z, fun, probs, gtype)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".zonalByVector_+3A_x">x</code></td>
<td>
<p>GRaster <code><a href="#topic+sources">sources()</a></code> name.</p>
</td></tr>
<tr><td><code id=".zonalByVector_+3A_z">z</code></td>
<td>
<p>GVector <code><a href="#topic+sources">sources()</a></code> name.</p>
</td></tr>
<tr><td><code id=".zonalByVector_+3A_fun">fun</code></td>
<td>
<p>Character</p>
</td></tr>
<tr><td><code id=".zonalByVector_+3A_gtype">gtype</code></td>
<td>
<p><code>geomtype(z, grass = TRUE)</code> (&quot;area&quot;, &quot;line&quot;, or &quot;point&quot;)</p>
</td></tr>
</table>

<hr>
<h2 id='+5B'>Subset geometries of a GVector</h2><span id='topic++5B'></span><span id='topic++5B+2CGVector+2CANY+2CANY-method'></span><span id='topic++5B+2CGRaster+2CGRaster+2CANY-method'></span>

<h3>Description</h3>

<p>The <code>[</code> operator returns a subset or remove specific geometries of a <code>GVector</code>. You can get the number of geometries using <code><a href="#topic+ngeom">ngeom()</a></code>. Note that you cannot use this function to change the &quot;order&quot; in which geometries or their associated records in a data table appear. For example, <code>vector[1:3]</code> and <code>vector[3:1]</code> will yield the exact same results.
</p>
<p>Note that subsetting can take a very long time if you are retaining only a small number of geometries from a vector with many geometries. The routine selects geometries by removing those that are not in <code>i</code>. So if you can write code to remove fewer geometries (i.e., an &quot;inverse&quot; selection), it may go faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector,ANY,ANY'
x[i, j]

## S4 method for signature 'GRaster,GRaster,ANY'
x[i, j]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B5B_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="+2B5B_+3A_i">i</code></td>
<td>
<p>Numeric integer, integer, or logical vector: Indicates which geometry(ies) to obtain. Negative numeric or integer values will remove the given geometries from the output. If a logical vector is supplied and it is not the same length as the number of geometries, it will be recycled.</p>
</td></tr>
<tr><td><code id="+2B5B_+3A_j">j</code></td>
<td>
<p>Numeric integer, integer, logical, or character: Indices or name(s) of the column(s) to obtain. You can see column names using <code><a href="#topic+names">names()</a></code>. Negative numeric or integer values will remove the given columns from the output. If a logical vector is supplied and it is not the same length as the number of columns, it will be recycled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subset">subset()</a></code>, <a href="#topic++24">$</a>, <code><a href="#topic++5B+5B">[[</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

### GRasters

# Example data
madElev &lt;- fastData("madElev") # elevation raster
madForest2000 &lt;- fastData("madForest2000") # forest raster
madForest2014 &lt;- fastData("madForest2014") # forest raster

# Convert SpatRasters to GRasters
elev &lt;- fast(madElev)
forest2000 &lt;- fast(madForest2000)
forest2014 &lt;- fast(madForest2014)

# Re-assigning values of a GRaster
constant &lt;- elev
constant[] &lt;- pi
names(constant) &lt;- "pi_raster"
constant

# Re-assigning specific values of a raster
replace &lt;- elev
replace[replace == 1] &lt;- -20
replace

# Subsetting specific values of a raster based on another raster
elevInForest &lt;- elev[forest2000 == 1]
plot(c(elev, forest2000, elevInForest), nr = 1)

# Adding and replacing layers of a GRaster
rasts &lt;- c(elev, constant, forest2000)

# Combine with another layer:
add(rasts) &lt;- forest2014 # one way
rasts

rasts &lt;- c(rasts, forest2014) # another way

### Subsetting GRaster layers

# Subset:
rasts &lt;- c(elev, forest2000, forest2014)
rasts[[2:3]]
subset(rasts, 2:3)
subset(rasts, c("madForest2000", "madElev"))
rasts[[c("madForest2000", "madElev")]]
rasts$madForest2000

# Get every other layer:
rasts[[c(FALSE, TRUE)]]

### Replacing layers of a GRaster

# Replace a layer
logElev &lt;- log(elev)
names(logElev) &lt;- "logElev"
rasts$madForest2014 &lt;- logElev
rasts

# Replace a layer:
rasts[[3]] &lt;- forest2000
rasts

### GVectors

# example data
madDypsis &lt;- fastData("madDypsis") # vector of points

# Convert SpatVector to GVector
dypsis &lt;- fast(madDypsis)

### Retrieving GVector columns

dypsis$species # Returns the column

dypsis[[c("year", "species")]] # Returns a GRaster with these columns
dypsis[ , c("year", "species")] # Same as above

### Subsetting GVector geometries

# Subset first three geometries
dypsis[1:3]
dypsis[1:3, "species"]

# Get geometries by data table condition
dypsis[dypsis$species == "Dypsis betsimisarakae"]

### (Re)assigning GVector column values

# New column
dypsis$pi &lt;- pi

# Re-assign values
dypsis$pi &lt;- "pie"

# Re-assign specific values
dypsis$institutionCode[dypsis$institutionCode == "MO"] &lt;-
   "Missouri Botanical Garden"

}
</code></pre>

<hr>
<h2 id='+5B+5B'>Subset layers from a GRaster, or specific columns from a GVector</h2><span id='topic++5B+5B'></span><span id='topic++5B+5B+2CGRaster+2CANY+2CANY-method'></span><span id='topic++5B+5B+2CGVector+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>The <code>[[</code> operator can be used to subset or remove one or more layers from a <code>GRaster</code>. It can also be used to subset or remove columns from a <code>GVector</code> with a data table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster,ANY,ANY'
x[[i, j]]

## S4 method for signature 'GVector,ANY,ANY'
x[[i, j]]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B5B+2B5B_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> or <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B_+3A_i">i</code></td>
<td>
<p>Numeric integer, integer, logical, or character: Indicates the layer(s) of a <code>GRaster</code> to subset, or the column(s) of a <code>GVector</code> to return. If negative numeric or integer values are supplied, then these layers or columns will be removed from the output.</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B_+3A_j">j</code></td>
<td>
<p>Ignored for <code>[[</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code> or <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subset">subset()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

### GRasters

# Example data
madElev &lt;- fastData("madElev") # elevation raster
madForest2000 &lt;- fastData("madForest2000") # forest raster
madForest2014 &lt;- fastData("madForest2014") # forest raster

# Convert SpatRasters to GRasters
elev &lt;- fast(madElev)
forest2000 &lt;- fast(madForest2000)
forest2014 &lt;- fast(madForest2014)

# Re-assigning values of a GRaster
constant &lt;- elev
constant[] &lt;- pi
names(constant) &lt;- "pi_raster"
constant

# Re-assigning specific values of a raster
replace &lt;- elev
replace[replace == 1] &lt;- -20
replace

# Subsetting specific values of a raster based on another raster
elevInForest &lt;- elev[forest2000 == 1]
plot(c(elev, forest2000, elevInForest), nr = 1)

# Adding and replacing layers of a GRaster
rasts &lt;- c(elev, constant, forest2000)

# Combine with another layer:
add(rasts) &lt;- forest2014 # one way
rasts

rasts &lt;- c(rasts, forest2014) # another way

### Subsetting GRaster layers

# Subset:
rasts &lt;- c(elev, forest2000, forest2014)
rasts[[2:3]]
subset(rasts, 2:3)
subset(rasts, c("madForest2000", "madElev"))
rasts[[c("madForest2000", "madElev")]]
rasts$madForest2000

# Get every other layer:
rasts[[c(FALSE, TRUE)]]

### Replacing layers of a GRaster

# Replace a layer
logElev &lt;- log(elev)
names(logElev) &lt;- "logElev"
rasts$madForest2014 &lt;- logElev
rasts

# Replace a layer:
rasts[[3]] &lt;- forest2000
rasts

### GVectors

# example data
madDypsis &lt;- fastData("madDypsis") # vector of points

# Convert SpatVector to GVector
dypsis &lt;- fast(madDypsis)

### Retrieving GVector columns

dypsis$species # Returns the column

dypsis[[c("year", "species")]] # Returns a GRaster with these columns
dypsis[ , c("year", "species")] # Same as above

### Subsetting GVector geometries

# Subset first three geometries
dypsis[1:3]
dypsis[1:3, "species"]

# Get geometries by data table condition
dypsis[dypsis$species == "Dypsis betsimisarakae"]

### (Re)assigning GVector column values

# New column
dypsis$pi &lt;- pi

# Re-assign values
dypsis$pi &lt;- "pie"

# Re-assign specific values
dypsis$institutionCode[dypsis$institutionCode == "MO"] &lt;-
   "Missouri Botanical Garden"

}
</code></pre>

<hr>
<h2 id='+5B+5B+26lt+3B-'>Replace layers of a GRaster</h2><span id='topic++5B+5B+3C-'></span><span id='topic++5B+5B+3C-+2CGRaster+2CANY-method'></span>

<h3>Description</h3>

<p>The <code style="white-space: pre;">&#8288;[[&lt;-&#8288;</code> operator can be used to replace a layer in a multi-layer <code>GRaster</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'GRaster,ANY'
x[[i]] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B5B+2B5B+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B+2B26lt+2B3B-_+3A_i">i</code></td>
<td>
<p>A numeric integer, integer, logical, or character: Indicates the layer to replace. If a logical vector, then the vector must have the same length as there are layers in <code>x</code>.</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>Either a <code>GRaster</code> or <code>NULL</code>: If <code>NULL</code>, then the layer indicated by <code>i</code> will be removed.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

### GRasters

# Example data
madElev &lt;- fastData("madElev") # elevation raster
madForest2000 &lt;- fastData("madForest2000") # forest raster
madForest2014 &lt;- fastData("madForest2014") # forest raster

# Convert SpatRasters to GRasters
elev &lt;- fast(madElev)
forest2000 &lt;- fast(madForest2000)
forest2014 &lt;- fast(madForest2014)

# Re-assigning values of a GRaster
constant &lt;- elev
constant[] &lt;- pi
names(constant) &lt;- "pi_raster"
constant

# Re-assigning specific values of a raster
replace &lt;- elev
replace[replace == 1] &lt;- -20
replace

# Subsetting specific values of a raster based on another raster
elevInForest &lt;- elev[forest2000 == 1]
plot(c(elev, forest2000, elevInForest), nr = 1)

# Adding and replacing layers of a GRaster
rasts &lt;- c(elev, constant, forest2000)

# Combine with another layer:
add(rasts) &lt;- forest2014 # one way
rasts

rasts &lt;- c(rasts, forest2014) # another way

### Subsetting GRaster layers

# Subset:
rasts &lt;- c(elev, forest2000, forest2014)
rasts[[2:3]]
subset(rasts, 2:3)
subset(rasts, c("madForest2000", "madElev"))
rasts[[c("madForest2000", "madElev")]]
rasts$madForest2000

# Get every other layer:
rasts[[c(FALSE, TRUE)]]

### Replacing layers of a GRaster

# Replace a layer
logElev &lt;- log(elev)
names(logElev) &lt;- "logElev"
rasts$madForest2014 &lt;- logElev
rasts

# Replace a layer:
rasts[[3]] &lt;- forest2000
rasts

### GVectors

# example data
madDypsis &lt;- fastData("madDypsis") # vector of points

# Convert SpatVector to GVector
dypsis &lt;- fast(madDypsis)

### Retrieving GVector columns

dypsis$species # Returns the column

dypsis[[c("year", "species")]] # Returns a GRaster with these columns
dypsis[ , c("year", "species")] # Same as above

### Subsetting GVector geometries

# Subset first three geometries
dypsis[1:3]
dypsis[1:3, "species"]

# Get geometries by data table condition
dypsis[dypsis$species == "Dypsis betsimisarakae"]

### (Re)assigning GVector column values

# New column
dypsis$pi &lt;- pi

# Re-assign values
dypsis$pi &lt;- "pie"

# Re-assign specific values
dypsis$institutionCode[dypsis$institutionCode == "MO"] &lt;-
   "Missouri Botanical Garden"

}
</code></pre>

<hr>
<h2 id='+5B+26lt+3B-'>Replace values of a GRaster</h2><span id='topic++5B+3C-'></span><span id='topic++5B+3C-+2CGRaster+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2CGRaster+2CGRaster+2CANY-method'></span>

<h3>Description</h3>

<p>The <code style="white-space: pre;">&#8288;[&lt;-&#8288;</code> operator can be used to replace all of the values of a <code>GRaster</code>, or specific values depending on the expression in <code>i</code>. For example, you could use <code>rast[] &lt;- 10</code> to assign 10 to all cells, or <code>rast[rast &gt; 0] &lt;- 10</code> to assign all cells with values &gt;0 to 10. You can also use one raster to set values in another, as in <code>rast1[rast2 &gt; 0] &lt;- 10</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'GRaster,missing,ANY'
x[i, j] &lt;- value

## S4 replacement method for signature 'GRaster,GRaster,ANY'
x[i, j] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B5B+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="+2B5B+2B26lt+2B3B-_+3A_i">i</code></td>
<td>
<p>Either missing or a conditional statement that resolves to a <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="+2B5B+2B26lt+2B3B-_+3A_j">j</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="+2B5B+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>A numeric, integer, or logical value, or <code>NA</code>. Only a single value can be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

### GRasters

# Example data
madElev &lt;- fastData("madElev") # elevation raster
madForest2000 &lt;- fastData("madForest2000") # forest raster
madForest2014 &lt;- fastData("madForest2014") # forest raster

# Convert SpatRasters to GRasters
elev &lt;- fast(madElev)
forest2000 &lt;- fast(madForest2000)
forest2014 &lt;- fast(madForest2014)

# Re-assigning values of a GRaster
constant &lt;- elev
constant[] &lt;- pi
names(constant) &lt;- "pi_raster"
constant

# Re-assigning specific values of a raster
replace &lt;- elev
replace[replace == 1] &lt;- -20
replace

# Subsetting specific values of a raster based on another raster
elevInForest &lt;- elev[forest2000 == 1]
plot(c(elev, forest2000, elevInForest), nr = 1)

# Adding and replacing layers of a GRaster
rasts &lt;- c(elev, constant, forest2000)

# Combine with another layer:
add(rasts) &lt;- forest2014 # one way
rasts

rasts &lt;- c(rasts, forest2014) # another way

### Subsetting GRaster layers

# Subset:
rasts &lt;- c(elev, forest2000, forest2014)
rasts[[2:3]]
subset(rasts, 2:3)
subset(rasts, c("madForest2000", "madElev"))
rasts[[c("madForest2000", "madElev")]]
rasts$madForest2000

# Get every other layer:
rasts[[c(FALSE, TRUE)]]

### Replacing layers of a GRaster

# Replace a layer
logElev &lt;- log(elev)
names(logElev) &lt;- "logElev"
rasts$madForest2014 &lt;- logElev
rasts

# Replace a layer:
rasts[[3]] &lt;- forest2000
rasts

### GVectors

# example data
madDypsis &lt;- fastData("madDypsis") # vector of points

# Convert SpatVector to GVector
dypsis &lt;- fast(madDypsis)

### Retrieving GVector columns

dypsis$species # Returns the column

dypsis[[c("year", "species")]] # Returns a GRaster with these columns
dypsis[ , c("year", "species")] # Same as above

### Subsetting GVector geometries

# Subset first three geometries
dypsis[1:3]
dypsis[1:3, "species"]

# Get geometries by data table condition
dypsis[dypsis$species == "Dypsis betsimisarakae"]

### (Re)assigning GVector column values

# New column
dypsis$pi &lt;- pi

# Re-assign values
dypsis$pi &lt;- "pie"

# Re-assign specific values
dypsis$institutionCode[dypsis$institutionCode == "MO"] &lt;-
   "Missouri Botanical Garden"

}
</code></pre>

<hr>
<h2 id='+24'>Subset a GRaster layer, or return values from a column of a GVector's table</h2><span id='topic++24'></span><span id='topic++24+2CGRaster-method'></span><span id='topic++24+2CGVector-method'></span>

<h3>Description</h3>

<p>The <code>dollar</code> notation can be used to get a single layer of a multi-layer <code>GRaster</code> or the values of a column from a <code>GVector</code>'s data table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
x$name

## S4 method for signature 'GVector'
x$name
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B24_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> or <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="+2B24_+3A_name">name</code></td>
<td>
<p>Character: The name of a <code>GRaster</code> or of a column of a <code>GVector</code>'s data table. Names of rasters and vectors can be found using <code><a href="#topic+names">names()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code> or vector of the same type as the <code>GVector</code>'s column.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subset">subset()</a></code>, <code><a href="#topic++5B">[</a></code>, <code><a href="#topic++5B+5B">[[</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

### GRasters

# Example data
madElev &lt;- fastData("madElev") # elevation raster
madForest2000 &lt;- fastData("madForest2000") # forest raster
madForest2014 &lt;- fastData("madForest2014") # forest raster

# Convert SpatRasters to GRasters
elev &lt;- fast(madElev)
forest2000 &lt;- fast(madForest2000)
forest2014 &lt;- fast(madForest2014)

# Re-assigning values of a GRaster
constant &lt;- elev
constant[] &lt;- pi
names(constant) &lt;- "pi_raster"
constant

# Re-assigning specific values of a raster
replace &lt;- elev
replace[replace == 1] &lt;- -20
replace

# Subsetting specific values of a raster based on another raster
elevInForest &lt;- elev[forest2000 == 1]
plot(c(elev, forest2000, elevInForest), nr = 1)

# Adding and replacing layers of a GRaster
rasts &lt;- c(elev, constant, forest2000)

# Combine with another layer:
add(rasts) &lt;- forest2014 # one way
rasts

rasts &lt;- c(rasts, forest2014) # another way

### Subsetting GRaster layers

# Subset:
rasts &lt;- c(elev, forest2000, forest2014)
rasts[[2:3]]
subset(rasts, 2:3)
subset(rasts, c("madForest2000", "madElev"))
rasts[[c("madForest2000", "madElev")]]
rasts$madForest2000

# Get every other layer:
rasts[[c(FALSE, TRUE)]]

### Replacing layers of a GRaster

# Replace a layer
logElev &lt;- log(elev)
names(logElev) &lt;- "logElev"
rasts$madForest2014 &lt;- logElev
rasts

# Replace a layer:
rasts[[3]] &lt;- forest2000
rasts

### GVectors

# example data
madDypsis &lt;- fastData("madDypsis") # vector of points

# Convert SpatVector to GVector
dypsis &lt;- fast(madDypsis)

### Retrieving GVector columns

dypsis$species # Returns the column

dypsis[[c("year", "species")]] # Returns a GRaster with these columns
dypsis[ , c("year", "species")] # Same as above

### Subsetting GVector geometries

# Subset first three geometries
dypsis[1:3]
dypsis[1:3, "species"]

# Get geometries by data table condition
dypsis[dypsis$species == "Dypsis betsimisarakae"]

### (Re)assigning GVector column values

# New column
dypsis$pi &lt;- pi

# Re-assign values
dypsis$pi &lt;- "pie"

# Re-assign specific values
dypsis$institutionCode[dypsis$institutionCode == "MO"] &lt;-
   "Missouri Botanical Garden"

}
</code></pre>

<hr>
<h2 id='+24+26lt+3B-'>Replace a raster layer or a column from a vector's data table</h2><span id='topic++24+3C-'></span><span id='topic++24+3C-+2CGRaster-method'></span><span id='topic++24+3C-+2CGVector-method'></span>

<h3>Description</h3>

<p>The <code style="white-space: pre;">&#8288;$&lt;-&#8288;</code> notation can be used to replace a specific layer in a multi-layer <code>GRaster</code>, or a to replace a specific column from a <code>GVector</code>'s data table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'GRaster'
x$name &lt;- value

## S4 replacement method for signature 'GVector'
x$name &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B24+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> or <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="+2B24+2B26lt+2B3B-_+3A_name">name</code></td>
<td>
<p>Character: Name of the <code>GRaster</code> layer to replace, or name of the <code>GVector</code> column to replace.</p>
</td></tr>
<tr><td><code id="+2B24+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>Character: The name of a <code>GRaster</code> layer or the name of a column in a <code>GVector</code>'s data table. Names of rasters and vector tables' columns cab be obtained using <code><a href="#topic+names">names()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code> or the column of a <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic++24">$</a>, <code><a href="#topic++5B+5B+3C-">[[&lt;-</a></code>, and <code><a href="#topic+add+3C-">add&lt;-</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

### GRasters

# Example data
madElev &lt;- fastData("madElev") # elevation raster
madForest2000 &lt;- fastData("madForest2000") # forest raster
madForest2014 &lt;- fastData("madForest2014") # forest raster

# Convert SpatRasters to GRasters
elev &lt;- fast(madElev)
forest2000 &lt;- fast(madForest2000)
forest2014 &lt;- fast(madForest2014)

# Re-assigning values of a GRaster
constant &lt;- elev
constant[] &lt;- pi
names(constant) &lt;- "pi_raster"
constant

# Re-assigning specific values of a raster
replace &lt;- elev
replace[replace == 1] &lt;- -20
replace

# Subsetting specific values of a raster based on another raster
elevInForest &lt;- elev[forest2000 == 1]
plot(c(elev, forest2000, elevInForest), nr = 1)

# Adding and replacing layers of a GRaster
rasts &lt;- c(elev, constant, forest2000)

# Combine with another layer:
add(rasts) &lt;- forest2014 # one way
rasts

rasts &lt;- c(rasts, forest2014) # another way

### Subsetting GRaster layers

# Subset:
rasts &lt;- c(elev, forest2000, forest2014)
rasts[[2:3]]
subset(rasts, 2:3)
subset(rasts, c("madForest2000", "madElev"))
rasts[[c("madForest2000", "madElev")]]
rasts$madForest2000

# Get every other layer:
rasts[[c(FALSE, TRUE)]]

### Replacing layers of a GRaster

# Replace a layer
logElev &lt;- log(elev)
names(logElev) &lt;- "logElev"
rasts$madForest2014 &lt;- logElev
rasts

# Replace a layer:
rasts[[3]] &lt;- forest2000
rasts

### GVectors

# example data
madDypsis &lt;- fastData("madDypsis") # vector of points

# Convert SpatVector to GVector
dypsis &lt;- fast(madDypsis)

### Retrieving GVector columns

dypsis$species # Returns the column

dypsis[[c("year", "species")]] # Returns a GRaster with these columns
dypsis[ , c("year", "species")] # Same as above

### Subsetting GVector geometries

# Subset first three geometries
dypsis[1:3]
dypsis[1:3, "species"]

# Get geometries by data table condition
dypsis[dypsis$species == "Dypsis betsimisarakae"]

### (Re)assigning GVector column values

# New column
dypsis$pi &lt;- pi

# Re-assign values
dypsis$pi &lt;- "pie"

# Re-assign specific values
dypsis$institutionCode[dypsis$institutionCode == "MO"] &lt;-
   "Missouri Botanical Garden"

}
</code></pre>

<hr>
<h2 id='activeCat+2CGRaster-method'>Get or set the column with category labels in a categorical raster</h2><span id='topic+activeCat+2CGRaster-method'></span><span id='topic+activeCat'></span><span id='topic+activeCats+2CGRaster-method'></span><span id='topic+activeCats'></span><span id='topic+activeCat+3C-+2CGRaster-method'></span><span id='topic+activeCat+3C-'></span>

<h3>Description</h3>

<p>These functions return or set the column of the labels to be matched to each value in the raster of a categorical <code>GRaster</code> (see <code>vignette("GRasters", package = "fasterRaster")</code>). <em>Important</em>: Following <code><a href="terra.html#topic+activeCat">terra::activeCat()</a></code>, the first column in the &quot;levels&quot; table is ignored, so an &quot;active category&quot; value of 1 means the second column is used as labels, a value of 2 means the third is used, and so on.
</p>

<ul>
<li> <p><code>activeCat()</code> returns the column of the labels to be matched to each value in the raster for a single raster layer.
</p>
</li>
<li> <p><code>activeCats()</code> does the same, but for all layers of a <code>GRaster</code>.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;activeCat()&lt;-&#8288;</code> sets the column to be used as category labels.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
activeCat(x, layer = 1, names = FALSE)

## S4 method for signature 'GRaster'
activeCats(x, names = FALSE)

## S4 replacement method for signature 'GRaster'
activeCat(x, layer = 1) &lt;- value

## S4 replacement method for signature 'GRaster'
activeCat(x, layer = 1) &lt;- value

## S4 replacement method for signature 'GRaster'
activeCat(x, layer = 1) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="activeCat+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A categorical <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="activeCat+2B2CGRaster-method_+3A_layer">layer</code></td>
<td>
<p>Numeric, integer, logical, or character: Indicates for which layer(s) to get or set the active category column. This can be a number (the index of the raster(s)), a logical vector (<code>TRUE</code> ==&gt; get/set the active category column, <code>FALSE</code> ==&gt; leave as-is), or a character vector (names of layers).</p>
</td></tr>
<tr><td><code id="activeCat+2B2CGRaster-method_+3A_names">names</code></td>
<td>
<p>Logical: If <code>TRUE</code>, display the name(s) of the active column(s). If <code>FALSE</code> (default), report the index of the active column. Following <code><a href="terra.html#topic+activeCat">terra::activeCat()</a></code>, the first column in the levels table is ignored. So, an active column of &quot;1&quot; means the second column is active. &quot;2&quot; means the third column is active, and so on.</p>
</td></tr>
<tr><td><code id="activeCat+2B2CGRaster-method_+3A_value">value</code></td>
<td>
<p>Numeric, integer, or character. Following <code><a href="terra.html#topic+activeCat">terra::activeCat()</a></code>, the first column in each levels table is ignored. So, if you want the second column to be the category label, use 1. If you want the third column, use 2, and so on. You can also specify the active column by its column name (though this can't be the first column's name).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>activeCat()</code> returns an integer or character of the active column index or name. <code>activeCats()</code> returns a vector of indices or names. <code style="white-space: pre;">&#8288;activeCat()&lt;-&#8288;</code> returns a <code>GRaster</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data: Land cover raster
madCover &lt;- fastData("madCover")

# Convert categorical SpatRaster to categorical GRaster:
cover &lt;- fast(madCover)

### Properties of categorical rasters

cover # note categories
is.factor(cover) # Is the raster categorical?
nlevels(cover) # number of levels
levels(cover) # just the value and active column
cats(cover) # all columns
minmax(cover) # min/max values
minmax(cover, levels = TRUE) # min/max categories
catNames(cover) # column names of the levels table
missingCats(cover) # categories in table with no values in raster
freq(cover) # frequency of each category (number of cells)
zonalGeog(cover) # geometric statistics

### Active column

# Which column sets the category labels?
activeCat(cover)
activeCat(cover, names = TRUE)

activeCats(c(cover, cover))

# Choose a different column for category labels:
levels(cover)
activeCat(cover) &lt;- 2
levels(cover)

### Managing levels tables

# Remove unused levels:
nlevels(cover)
cover &lt;- droplevels(cover)
nlevels(cover)

# Re-assign levels:
value &lt;- c(20, 30, 40, 50, 120, 130, 140, 170)
label &lt;- c("Cropland", "Cropland", "Forest", "Forest",
 "Grassland", "Shrubland", "Herbaceous", "Flooded")

newCats &lt;- data.frame(value = value, label = label)

cover &lt;- categories(cover, layer = 1, value = newCats)
cats(cover)

# This is the same as:
levels(cover) &lt;- newCats
cats(cover)

# Are there any values not assigned a category?
missingCats(cover)

# Let's assign a category for value 210 (water):
water &lt;- data.frame(value = 210, label = "Water")
addCats(cover) &lt;- water
levels(cover)

# Add more information to the levels table using merge():
landType &lt;- data.frame(
     Value = c(20, 30, 40, 50, 120),
     Type = c("Irrigated", "Rainfed", "Broadleaf evergreen",
     "Broadleaf deciduous", "Mosaic with forest")
)
cats(cover)
cover &lt;- addCats(cover, landType, merge = TRUE)
cats(cover)

### Logical operations on categorical rasters

cover &lt; "Forest" # 1 for cells with a value &lt; 40, 0 otherwise
cover &lt;= "Forest" # 1 for cells with a value &lt; 120, 0 otherwise
cover == "Forest" # 1 for cells with value of 40-120, 0 otherwise
cover != "Forest" # 1 for cells with value that is not 40-120, 0 otherwise
cover &gt; "Forest" # 1 for cells with a value &gt; 120, 0 otherwise
cover &gt;= "Forest" # 1 for cells with a value &gt;= 120, 0 otherwise

cover %in% c("Cropland", "Forest") # 1 for cropland/forest cells, 0 otherwise

### Combine categories from different rasters

# For the example, will create a second categorical raster fromm elevation.

# Divide elevation raster into "low/medium/high" levels:
madElev &lt;- fastData("madElev")
elev &lt;- fast(madElev)
elev &lt;- project(elev, cover, method = "near") # convert to same CRS
fun &lt;- "= if(madElev &lt; 100, 0, if(madElev &lt; 400, 1, 2))"
elevCat &lt;- app(elev, fun)

levs &lt;- data.frame(
     value = c(0, 1, 2),
     elevation = c("low", "medium", "high")
)
levels(elevCat) &lt;- list(levs)

# Combine levels:
combined &lt;- concats(cover, elevCat)
combined
levels(combined)

# Combine levels, treating value/NA combinations as new categories:
combinedNA &lt;- concats(cover, elevCat, na.rm = FALSE)
combinedNA
levels(combinedNA)

}
</code></pre>

<hr>
<h2 id='add+26lt+3B-'>&quot;Stack&quot; a GRaster</h2><span id='topic+add+3C-'></span><span id='topic+add+3C-+2CGRaster+2CGRaster-method'></span>

<h3>Description</h3>

<p>This function &quot;stacks&quot; one <code>GRaster</code> with another. It has the same functionality as <code><a href="#topic+c">c()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'GRaster,GRaster'
add(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add+2B26lt+2B3B-_+3A_x">x</code>, <code id="add+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+c">c()</a></code>, <a href="terra.html#topic+add">terra::add&lt;-</a>, <code><a href="terra.html#topic+c">terra::c()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

### GRasters

# Example data
madElev &lt;- fastData("madElev") # elevation raster
madForest2000 &lt;- fastData("madForest2000") # forest raster
madForest2014 &lt;- fastData("madForest2014") # forest raster

# Convert SpatRasters to GRasters
elev &lt;- fast(madElev)
forest2000 &lt;- fast(madForest2000)
forest2014 &lt;- fast(madForest2014)

# Re-assigning values of a GRaster
constant &lt;- elev
constant[] &lt;- pi
names(constant) &lt;- "pi_raster"
constant

# Re-assigning specific values of a raster
replace &lt;- elev
replace[replace == 1] &lt;- -20
replace

# Subsetting specific values of a raster based on another raster
elevInForest &lt;- elev[forest2000 == 1]
plot(c(elev, forest2000, elevInForest), nr = 1)

# Adding and replacing layers of a GRaster
rasts &lt;- c(elev, constant, forest2000)

# Combine with another layer:
add(rasts) &lt;- forest2014 # one way
rasts

rasts &lt;- c(rasts, forest2014) # another way

### Subsetting GRaster layers

# Subset:
rasts &lt;- c(elev, forest2000, forest2014)
rasts[[2:3]]
subset(rasts, 2:3)
subset(rasts, c("madForest2000", "madElev"))
rasts[[c("madForest2000", "madElev")]]
rasts$madForest2000

# Get every other layer:
rasts[[c(FALSE, TRUE)]]

### Replacing layers of a GRaster

# Replace a layer
logElev &lt;- log(elev)
names(logElev) &lt;- "logElev"
rasts$madForest2014 &lt;- logElev
rasts

# Replace a layer:
rasts[[3]] &lt;- forest2000
rasts

### GVectors

# example data
madDypsis &lt;- fastData("madDypsis") # vector of points

# Convert SpatVector to GVector
dypsis &lt;- fast(madDypsis)

### Retrieving GVector columns

dypsis$species # Returns the column

dypsis[[c("year", "species")]] # Returns a GRaster with these columns
dypsis[ , c("year", "species")] # Same as above

### Subsetting GVector geometries

# Subset first three geometries
dypsis[1:3]
dypsis[1:3, "species"]

# Get geometries by data table condition
dypsis[dypsis$species == "Dypsis betsimisarakae"]

### (Re)assigning GVector column values

# New column
dypsis$pi &lt;- pi

# Re-assign values
dypsis$pi &lt;- "pie"

# Re-assign specific values
dypsis$institutionCode[dypsis$institutionCode == "MO"] &lt;-
   "Missouri Botanical Garden"

}
</code></pre>

<hr>
<h2 id='addCats+2CGRaster-method'>Add rows or columns to the &quot;levels&quot; table of a categorical raster</h2><span id='topic+addCats+2CGRaster-method'></span><span id='topic+addCats'></span><span id='topic+addCats+3C-+2CGRaster-method'></span><span id='topic+addCats+3C-'></span>

<h3>Description</h3>

<p><code>addCats()</code> and <code style="white-space: pre;">&#8288;addCats()&lt;-&#8288;</code> add information to a categorical&lsquo;GRaster&rsquo;s &quot;levels&quot; table.
</p>

<ul>
<li><p> addCats()' uses <code><a href="data.table.html#topic+merge">data.table::merge()</a></code> or <code><a href="base.html#topic+cbind">cbind()</a></code> to do this&ndash;it does not add new rows, but rather new columns.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;addCats()&lt;-&#8288;</code> uses <code><a href="#topic+rbind">rbind()</a></code> to add new categories (rows) to the &quot;levels&quot; table.
</p>
</li></ul>

<p>GRaster<code style="white-space: pre;">&#8288;s can represent categorical data (see &#8288;</code>vignette(&quot;GRasters&quot;, package = &quot;fasterRaster&quot;)<code style="white-space: pre;">&#8288;). Cell values are actually integers, each corresponding to a category, such as "desert" or "wetland." A categorical raster is associated with a "levels" table that matches each value to a category name. The table must be &#8288;</code>NULL' (i.e., no categories&ndash;so not a categorical raster), or have at least two columns. The first column must have integers and represent raster values. One or more subsequent columns must have category labels. The column with these labels is the &quot;active category&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
addCats(x, value, merge = FALSE, layer = 1)

## S4 replacement method for signature 'GRaster'
addCats(x, layer = 1) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addCats+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="addCats+2B2CGRaster-method_+3A_value">value</code></td>
<td>
<p>A <code>data.frame</code>, <code>data.table</code>, a list of <code>data.frames</code> or <code>data.tables</code> with one per raster layer, or a categorical <code>SpatRaster</code>. The table's first column is the &quot;value&quot; column and must contain numeric values (of class <code>numeric</code> or <code>character</code>). If a <code>SpatRaster</code> is supplied, then its categories will be transferred to the <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="addCats+2B2CGRaster-method_+3A_merge">merge</code></td>
<td>
<p>Logical (function <code>addCats()</code>): If <code>FALSE</code> (default), columns will be combined with the existing &quot;levels&quot; table using <code><a href="base.html#topic+cbind">cbind()</a></code>. If <code>TRUE</code>, they will be combined using <code><a href="data.table.html#topic+merge">data.table::merge()</a></code>.</p>
</td></tr>
<tr><td><code id="addCats+2B2CGRaster-method_+3A_layer">layer</code></td>
<td>
<p>Numeric integers, logical vector, or character: Layer(s) to which to add or from which to drop levels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>. The &quot;levels&quot; table of the raster is modified.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+factors">terra::addCats()</a></code>, <code><a href="#topic+concats">concats()</a></code>, <code><a href="#topic+combineLevels">combineLevels()</a></code>, <code><a href="#topic+droplevels">droplevels()</a></code>, <code style="white-space: pre;">&#8288;vignette("GRasters", package = "fasterRaster"&#8288;</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data: Land cover raster
madCover &lt;- fastData("madCover")

# Convert categorical SpatRaster to categorical GRaster:
cover &lt;- fast(madCover)

### Properties of categorical rasters

cover # note categories
is.factor(cover) # Is the raster categorical?
nlevels(cover) # number of levels
levels(cover) # just the value and active column
cats(cover) # all columns
minmax(cover) # min/max values
minmax(cover, levels = TRUE) # min/max categories
catNames(cover) # column names of the levels table
missingCats(cover) # categories in table with no values in raster
freq(cover) # frequency of each category (number of cells)
zonalGeog(cover) # geometric statistics

### Active column

# Which column sets the category labels?
activeCat(cover)
activeCat(cover, names = TRUE)

activeCats(c(cover, cover))

# Choose a different column for category labels:
levels(cover)
activeCat(cover) &lt;- 2
levels(cover)

### Managing levels tables

# Remove unused levels:
nlevels(cover)
cover &lt;- droplevels(cover)
nlevels(cover)

# Re-assign levels:
value &lt;- c(20, 30, 40, 50, 120, 130, 140, 170)
label &lt;- c("Cropland", "Cropland", "Forest", "Forest",
 "Grassland", "Shrubland", "Herbaceous", "Flooded")

newCats &lt;- data.frame(value = value, label = label)

cover &lt;- categories(cover, layer = 1, value = newCats)
cats(cover)

# This is the same as:
levels(cover) &lt;- newCats
cats(cover)

# Are there any values not assigned a category?
missingCats(cover)

# Let's assign a category for value 210 (water):
water &lt;- data.frame(value = 210, label = "Water")
addCats(cover) &lt;- water
levels(cover)

# Add more information to the levels table using merge():
landType &lt;- data.frame(
     Value = c(20, 30, 40, 50, 120),
     Type = c("Irrigated", "Rainfed", "Broadleaf evergreen",
     "Broadleaf deciduous", "Mosaic with forest")
)
cats(cover)
cover &lt;- addCats(cover, landType, merge = TRUE)
cats(cover)

### Logical operations on categorical rasters

cover &lt; "Forest" # 1 for cells with a value &lt; 40, 0 otherwise
cover &lt;= "Forest" # 1 for cells with a value &lt; 120, 0 otherwise
cover == "Forest" # 1 for cells with value of 40-120, 0 otherwise
cover != "Forest" # 1 for cells with value that is not 40-120, 0 otherwise
cover &gt; "Forest" # 1 for cells with a value &gt; 120, 0 otherwise
cover &gt;= "Forest" # 1 for cells with a value &gt;= 120, 0 otherwise

cover %in% c("Cropland", "Forest") # 1 for cropland/forest cells, 0 otherwise

### Combine categories from different rasters

# For the example, will create a second categorical raster fromm elevation.

# Divide elevation raster into "low/medium/high" levels:
madElev &lt;- fastData("madElev")
elev &lt;- fast(madElev)
elev &lt;- project(elev, cover, method = "near") # convert to same CRS
fun &lt;- "= if(madElev &lt; 100, 0, if(madElev &lt; 400, 1, 2))"
elevCat &lt;- app(elev, fun)

levs &lt;- data.frame(
     value = c(0, 1, 2),
     elevation = c("low", "medium", "high")
)
levels(elevCat) &lt;- list(levs)

# Combine levels:
combined &lt;- concats(cover, elevCat)
combined
levels(combined)

# Combine levels, treating value/NA combinations as new categories:
combinedNA &lt;- concats(cover, elevCat, na.rm = FALSE)
combinedNA
levels(combinedNA)

}
</code></pre>

<hr>
<h2 id='addons'>Test if addons directory exists and if an addon is installed</h2><span id='topic+addons'></span>

<h3>Description</h3>

<p>This function tests to see if the &quot;addons&quot; directory specified using <code><a href="#topic+faster">faster()</a></code> actually exists, and if a particular <strong>GRASS</strong> <code style="white-space: pre;">&#8288;addons module is available. The &#8288;</code>addons<code style="white-space: pre;">&#8288;folder and module must exists for methods that rely on particular **GRASS**&#8288;</code>addons<code style="white-space: pre;">&#8288;to work. See&#8288;</code>vignette(&quot;addons&quot;, package = &quot;fasterRaster&quot;)'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addons(x = NULL, fail = TRUE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addons_+3A_x">x</code></td>
<td>
<p>Either <code>NULL</code> or a character specifying the name of a <strong>GRASS</strong> addons module. If <code>NULL</code>, the existence of the <code>addonsDir</code> (see <code><a href="#topic+faster">faster()</a></code>) will be tested. If the module name is provided, the existence of the folder and module will be tested. The &quot;<code style="white-space: pre;">&#8288;/bin&#8288;</code>&quot; subfolder should not be included.</p>
</td></tr>
<tr><td><code id="addons_+3A_fail">fail</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), and the addons folder is not correctly specified, the exit the function with an error. If <code>FALSE</code>, then <code>NULL</code> will be returned with a warning.</p>
</td></tr>
<tr><td><code id="addons_+3A_verbose">verbose</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), display a message on success or warning (the <code>fail</code> option always displays a message).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical.
</p>


<h3>See Also</h3>

<p><code>vignette("addons", package = "fasterRaster")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Does the addons folder exist?
ao &lt;- addons(fail = "warning")
if (ao) print("Addons is folder is probably correctly specified.")

# Does this particular module exist?
addon &lt;- "v.centerpoint"
exten &lt;- addons(addon, fail = FALSE)

if (exten) print("Extension `v.centerpoints` is installed.")

}
</code></pre>

<hr>
<h2 id='addTable+26lt+3B-+2CGVector+2Cdata.frame-method'>Attach or detach GVector's data table</h2><span id='topic+addTable+3C-+2CGVector+2Cdata.frame-method'></span><span id='topic+addTable+3C-'></span><span id='topic+addTable+3C-+2CGVector+2Cdata.table-method'></span><span id='topic+addTable+3C-+2CGVector+2Cmatrix-method'></span><span id='topic+dropTable+2CGVector-method'></span><span id='topic+dropTable'></span>

<h3>Description</h3>

<p><code>addTable()</code> adds an entire table to a <code>GVector</code>. It will replace any existing table. There must be one row in the table for each geometry (see <code><a href="#topic+ngeom">ngeom()</a></code>). You can also add a table column-by-column using the <code><a href="#topic++24+3C-">$&lt;-</a></code> operator.
</p>
<p><code>dropTable()</code> removes a data table associated with a <code>GVector</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'GVector,data.frame'
addTable(x, ...) &lt;- value

## S4 replacement method for signature 'GVector,data.table'
addTable(x, ...) &lt;- value

## S4 replacement method for signature 'GVector,matrix'
addTable(x, ...) &lt;- value

## S4 method for signature 'GVector'
dropTable(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addTable+2B26lt+2B3B-+2B2CGVector+2B2Cdata.frame-method_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="addTable+2B26lt+2B3B-+2B2CGVector+2B2Cdata.frame-method_+3A_...">...</code></td>
<td>
<p>Other arguments (ignored).</p>
</td></tr>
<tr><td><code id="addTable+2B26lt+2B3B-+2B2CGVector+2B2Cdata.frame-method_+3A_value">value</code></td>
<td>
<p>A <code>data.frame</code>, <code>data.table</code>, or <code>matrix</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic++24+3C-">$&lt;-</a></code>, <code><a href="#topic+colbind">colbind()</a></code>, <code><a href="#topic+rbind">rbind()</a></code>, <code><a href="#topic+as.data.frame">as.data.frame()</a></code>, <code><a href="#topic+as.data.table">as.data.table()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)

# Rivers vector
madRivers &lt;- fastData("madRivers")

# Convert sf to a GVector
rivers &lt;- fast(madRivers)

# Convert GVector to data.frame or data.table
as.data.frame(rivers)
as.data.table(rivers)

# Subset rivers vector
rivers1 &lt;- rivers[1:2]
rivers2 &lt;- rivers[10:11]

# Concatenate rivers
riversCombo &lt;- rbind(rivers1, rivers2)
riversCombo

# Add columns
newCol &lt;- data.frame(new = 1:11)
riversCol &lt;- colbind(rivers, newCol)
riversCol

# Remove table
riversCopy &lt;- rivers
riversCopy # has data table
riversCopy &lt;- dropTable(riversCopy)
riversCopy # no data table

# Add a new table
newTable &lt;- data.frame(num = 1:11, letters = letters[1:11])
addTable(riversCopy) &lt;- newTable
riversCopy

}
</code></pre>

<hr>
<h2 id='aggregate+2CGRaster-method'>Aggregate raster cells into larger cells or combine geometries of a vector</h2><span id='topic+aggregate+2CGRaster-method'></span><span id='topic+aggregate'></span><span id='topic+aggregate+2CGVector-method'></span>

<h3>Description</h3>

<p>When applied to a <code>GRaster</code>, <code>aggregate()</code> creates a new raster with cells that are a multiple of the size of the cells of the original raster. The new cells can be larger or smaller than the original cells (this function thus emulates both the <code>terra::aggregate()</code> and <code><a href="terra.html#topic+disaggregate">terra::disagg()</a></code> functions.)
</p>
<p>When applied to a <code>GVector</code>, all geometries are combined into a &quot;multipart&quot; geometry, in which geometries are treated as if they were a single unit. Borders between aggregated geometries can be dissolved if the <code>dissolve</code> argument is <code>TRUE</code>. If the <code>GVector</code> has a data table associated with it, the output will also have a data table as long as there is at least one column with values that are all the same. Values of columns that do not have duplicated values will be converted to <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
aggregate(
  x,
  fact = 2,
  fun = "mean",
  weight = FALSE,
  prob = NULL,
  na.rm = FALSE
)

## S4 method for signature 'GVector'
aggregate(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aggregate+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> or <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="aggregate+2B2CGRaster-method_+3A_fact">fact</code></td>
<td>
<p>Numeric vector (rasters only): One, two, or three positive values. These reflect the size of the new cells as multiples of the size of the old cells. If just one value is supplied, this is used for all two or three dimensions. If two values are supplied, the first is multiplied by the east-west size of cells, and the second north-south size of cells (the raster must be 2D). If three values are supplied, the third value is used as the multiplier of the vertical dimension of cells. Values are calculated using all cells that have their centers contained by the target cell.
</p>
<p>Note that unlike <code>terra::aggregate()</code> and <code><a href="terra.html#topic+disaggregate">terra::disagg()</a></code>, these values need not be integers.</p>
</td></tr>
<tr><td><code id="aggregate+2B2CGRaster-method_+3A_fun">fun</code></td>
<td>
<p>Character (rasters only): Name of the function used to aggregate. For <code>GRaster</code>s, this is the function that summarizes across cells. For <code>GVector</code>s, this function will be used to calculate new values of numeric or integer cells.
</p>

<ul>
<li> <p><code>mean</code>: Average (default)
</p>
</li>
<li> <p><code>median</code>: Median
</p>
</li>
<li> <p><code>mode</code>: Most common value
</p>
</li>
<li> <p><code>min</code>: Minimum
</p>
</li>
<li> <p><code>max</code>: Maximum
</p>
</li>
<li> <p><code>range</code>: Difference between maximum and minimum
</p>
</li>
<li> <p><code>sum</code>: Sum
</p>
</li>
<li> <p><code>varpop</code>: Population variance
</p>
</li>
<li> <p><code>sdpop</code>: Population standard deviation
</p>
</li>
<li> <p><code>quantile</code>: Quantile (see argument <code>prob</code>)
</p>
</li>
<li> <p><code>count</code>: Number of non-<code>NA</code> cell
</p>
</li>
<li> <p><code>diversity</code>: Number of unique values
</p>
</li></ul>
</td></tr>
<tr><td><code id="aggregate+2B2CGRaster-method_+3A_weight">weight</code></td>
<td>
<p>Logical (rasters only): If <code>FALSE</code>, each source cell that has its center in the destination cell will be counted equally. If <code>TRUE</code>, the value of each source will be weighted the proportion of the destination cell the source cell covers.</p>
</td></tr>
<tr><td><code id="aggregate+2B2CGRaster-method_+3A_prob">prob</code></td>
<td>
<p>Numeric (rasters only): Quantile at which to calculate <code>quantile</code>.</p>
</td></tr>
<tr><td><code id="aggregate+2B2CGRaster-method_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical (rasters only): If <code>FALSE</code> (default), propagate <code>NA</code> cells or <code>NA</code> values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code> or <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+aggregate">stats::aggregate()</a></code>, <code><a href="terra.html#topic+aggregate">terra::aggregate()</a></code>, <code><a href="#topic+disagg">disagg()</a></code>, <code><a href="terra.html#topic+disaggregate">terra::disagg()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")
madCoast4 &lt;- fastData("madCoast4")

### aggregating a GRaster

# Convert:
elev &lt;- fast(madElev)

### Aggregate GRaster by same factor in 2 dimensions
# fasterRaster
agg2 &lt;- aggregate(elev, 2, "mean")
agg2

# Compare rasters aggregated by fasterRaster and terra.
# These should be the same.
agg2terra &lt;- aggregate(madElev, 2)

agg2 &lt;- rast(agg2)
agg2 &lt;- extend(agg2, agg2terra)
agg2 - agg2terra # value is ~0

### Aggregate GRaster by a non-integer factor in 2 dimensions
# fasterRaster
agg2.9 &lt;- aggregate(elev, 2.9, "mean")
agg2.9

# terra
agg2.9terra &lt;- aggregate(madElev, 2.9, "mean")
agg2.9terra

# Compare rasters aggregated by fasterRaster and terra.
# These should be different.
res(agg2.9)
res(agg2.9terra) # terra rounds aggregation factor down
2 * res(madElev) # original resolution multiplied by 2

### Aggregate GRaster by different factor in 2 dimensions
agg2x3 &lt;- aggregate(elev, c(2, 3), "mean")
agg2x3

### aggregating a GVector

madCoast4 &lt;- fastData("madCoast4")

# Convert:
coast4 &lt;- fast(madCoast4)

# Aggregate and disaggregate:
aggCoast &lt;- aggregate(coast4)
disaggCoast &lt;- disagg(coast4)

ngeom(coast4)
ngeom(aggCoast)
ngeom(disaggCoast)

# plot
oldpar &lt;- par(mfrow = c(1, 3))
plot(coast4, main = "Original", col = 1:nrow(coast4))
plot(aggCoast, main = "Aggregated", col = 1:nrow(aggCoast))
plot(disaggCoast, main = "Disaggregated", col = 1:nrow(disaggCoast))
par(oldpar)

}
</code></pre>

<hr>
<h2 id='app+2CGRaster-method'>Apply a function to a set of rasters</h2><span id='topic+app+2CGRaster-method'></span><span id='topic+app'></span><span id='topic+appFuns'></span><span id='topic+appCheck+2CGRaster+2Ccharacter-method'></span><span id='topic+appCheck'></span>

<h3>Description</h3>

<p><code>app()</code> applies a function to a set of &quot;stacked&quot; rasters. It is similar to the <code><a href="terra.html#topic+app">terra::app()</a></code> and <code><a href="terra.html#topic+lapp">terra::lapp()</a></code> functions.
</p>
<p><code>appFuns()</code> provides a table of <strong>GRASS</strong> functions that can be used by <code>app()</code> and their equivalents in <strong>R</strong>.
</p>
<p><code>appCheck()</code> tests whether a formula supplied to <code>app()</code> has any &quot;forbidden&quot; function calls.
</p>
<p>The <code>app()</code> function operates in a manner somewhat different from <code><a href="terra.html#topic+app">terra::app()</a></code>. The function to be applied <em>must</em> be written as a character string. For example, if the <code>GRaster</code> had layer names &quot;<code>x1</code>&quot; and &quot;<code>x2</code>&quot;, then the function might be like <code>"= max(sqrt(x1), log(x2))"</code>. Rasters <strong>cannot</strong> have the same names as functions used in the formula. In this example, the rasters could not be named &quot;max&quot;, &quot;sqrt&quot;, or &quot;log&quot;. Note that the name of a <code>GRaster</code> is given by <code><a href="#topic+names">names()</a></code>&ndash;this can be different from the name of the object in <strong>R</strong>.
</p>
<p>The <code>app()</code> function will automatically check for <code>GRaster</code> names that appear also to be functions that appear in the formula. However, you can check a formula before running <code>app()</code> by using the <code>appCheck()</code> function. You can obtain a list of <code>app()</code> functions using <code>appFuns()</code>. Note that these are sometimes different from how they are applied in <strong>R</strong>.
</p>
<p>Tips:
</p>

<ul>
<li><p> Make sure your <code>GRaster</code>s have <code>names()</code>. The function matches on these, not the name of the variable you use in <strong>R</strong> for the <code>GRaster</code>.
</p>
</li>
<li><p> Use <code>null()</code> instead of <code>NA</code>, and use <code>isnull()</code> instead of <code>is.na()</code>.
</p>
</li>
<li><p> If you want to calculate values using while ignoring <code>NA</code> (or <code>null</code>) values, see the functions that begin with <code>n</code> (like <code>nmean</code>).
</p>
</li>
<li><p> Be mindful of the data type that a function returns. In <strong>GRASS</strong>, these are <code>CELL</code> (integer), <code>FCELL</code> (floating point values&ndash;precise to about the 7th decimal place), and <code>DCELL</code> (double-floating point values&ndash;precise to about the 15th decimal place; commensurate with the <strong>R</strong> <code>numeric</code> type). In cases where you want a <code>GRaster</code> to be treated like a float or double type raster, wrap the name of the <code>GRaster</code> in the <code>float()</code> or <code>double()</code> functions. This is especially useful if the <code>GRaster</code> might be assumed to be the <code>CELL</code> type because it only contains integer values. You can get the data type of a raster using <code><a href="#topic+datatype">datatype()</a></code> with the <code>type</code> argument set to <code>GRASS</code>. You can change the data type of a <code>GRaster</code> using <code><a href="#topic+as.int">as.int()</a></code>, <code><a href="#topic+as.float">as.float()</a></code>, and <code><a href="#topic+as.doub">as.doub()</a></code>. Note that categorical rasters are really <code>CELL</code> (integer) rasters with an associated &quot;levels&quot; table. You can also change a <code>CELL</code> raster to a <code>FCELL</code> raster by adding then subtracting a decimal value, as in <code>x - 0.1 + 0.1</code>. See <code>vignette("GRasters", package = "fasterRaster")</code>.
</p>
</li>
<li><p> The <code>rand()</code> function returns integer values by default. If you want non-integer values, use the tricks mentioned above to datatype non-integer values. For example, if you want uniform random values in the range between 0 and 1, use something like <code style="white-space: pre;">&#8288;= float(rand(0 + 0.1, 1 + 0.1) - 0.1)&#8288;</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
app(x, fun, datatype = "auto", seed = NULL)

appFuns(warn = TRUE)

## S4 method for signature 'GRaster,character'
appCheck(x, fun, msgOnGood = TRUE, failOnBad = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="app+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> with one or more named layers.</p>
</td></tr>
<tr><td><code id="app+2B2CGRaster-method_+3A_fun">fun</code></td>
<td>
<p>Character: The function to apply. This must be written as a character string that follows these rules:
</p>

<ul>
<li><p> It must use typical arithmetic operators like <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> and/or functions that can be seen using <code>appFuns(TRUE)</code>.
</p>
</li>
<li><p> The <code><a href="#topic+names">names()</a></code> of the rasters do not match any of the functions in the <code>appFuns(TRUE)</code> table. Note that <code>x</code> and <code>y</code> are forbidden names :(
</p>
</li></ul>

<p>The help page for <strong>GRASS</strong> module <code>r.mapcalc</code> will be especially helpful. You can see this page using <code>grassHelp("r.mapcalc")</code>.</p>
</td></tr>
<tr><td><code id="app+2B2CGRaster-method_+3A_datatype">datatype</code></td>
<td>
<p>Character: This ensures that rasters are treated as a certain type before they are operated on. This is useful when using rasters that have all integer values, which <strong>GRASS</strong> can assume represent integers, even if they are not supposed to. In this case, the output of operations on this raster might be an integer if otherwise not corrected. Partial matching is used, and options include:
</p>

<ul>
<li> <p><code>"integer"</code>: Force all rasters to integers by truncating their values. The output may still be of type <code>float</code> if the operation creates non-integer values.
</p>
</li>
<li> <p><code>"float"</code>: Force rasters to be considered floating-point values.
</p>
</li>
<li> <p><code>"double"</code>: Force rasters to be considered double-floating point values.
</p>
</li>
<li> <p><code>"auto"</code> (default): Ensure that rasters are represented by their native <code><a href="#topic+datatype">datatype()</a></code> (i.e., &quot;CELL&quot; rasters as integers, &quot;FCELL&quot; rasters as floating-point, and &quot;DCELL&quot; as double-floating point).
</p>
</li></ul>
</td></tr>
<tr><td><code id="app+2B2CGRaster-method_+3A_seed">seed</code></td>
<td>
<p>Numeric integer vector or <code>NULL</code> (default): A number for the random seed. Used only for <code>app()</code> function <code>rand()</code>, that generates a random number. If <code>NULL</code>, a seed will be generated. Defining the seed is useful for replicating a raster made with <code>rand()</code>. This must be an integer!</p>
</td></tr>
<tr><td><code id="app+2B2CGRaster-method_+3A_warn">warn</code></td>
<td>
<p>Logical (function <code>appFuns()</code>): If <code>TRUE</code> (default), display a warning when <code>allFuns()</code> is not called interactively.</p>
</td></tr>
<tr><td><code id="app+2B2CGRaster-method_+3A_msgongood">msgOnGood</code></td>
<td>
<p>Logical (function <code>appCheck()</code>): If <code>TRUE</code> (default), display a message if no overt problems with the raster names and formula are detected.</p>
</td></tr>
<tr><td><code id="app+2B2CGRaster-method_+3A_failonbad">failOnBad</code></td>
<td>
<p>Logical (function <code>appCheck()</code>): If <code>TRUE</code> (default), fail if overt problems with raster names and the formula are detected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+app">terra::app()</a></code>, <code><a href="terra.html#topic+lapp">terra::lapp()</a></code>, <code><a href="#topic+subst">subst()</a></code>, <code><a href="#topic+classify">classify()</a></code>, and especially the <strong>GRASS</strong> manual page for module <code>r.mapcalc</code> (see <code>grassHelp("r.mapcalc")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Elevation raster
madElev &lt;- fastData("madElev")

# Convert SpatRaster to a GRaster:
elev &lt;- fast(madElev)

# Create a "stack" of rasters for us to operate on:
x &lt;- c(elev, elev^2, sqrt(elev))

# Demonstrate check for badly-named rasters:
names(x) &lt;- c("cos", "asin", "exp")
fun &lt;- "= cos / asin + exp"
appCheck(x, fun, failOnBad = FALSE)

# Rename rasters acceptable names and run the function:
names(x) &lt;- c("x1", "x2", "x3")
fun &lt;- "= (x1 / x2) + x3"
appCheck(x, fun, failOnBad = FALSE)
app(x, fun = fun)

# This is the same as:
(x[[1]] / x[[2]]) + x[[3]]

# We can view a table of app() functions using appFuns():
appFuns()

# We can also get the same table using:
data(appFunsTable)

# Apply other functions:
fun &lt;- "= median(x1 / x2, x3, x1 * 2, cos(x2))"
app(x, fun = fun)

fun &lt;- "= round(x1) * tan(x2) + log(x3, 10)"
app(x, fun = fun)

# Demonstrate effects of data type:
fun &lt;- "= x1 + x3"
app(x, fun = fun, datatype = "float") # output is floating-point
app(x, fun = fun, datatype = "integer") # output is integer

# Some functions override the "datatype" argument:
fun &lt;- "= sin(x2)"
app(x, fun = fun, datatype = "integer")

# Make a raster with random values [1:4], with equal probability of each:
fun &lt;- "= round(rand(0.5, 4.5))"
rand &lt;- app(elev, fun = fun)
rand

freqs &lt;- freq(rand) # cell frequencies
print(freqs)

}
</code></pre>

<hr>
<h2 id='appFunsTable'>Functions that can be used in app()</h2><span id='topic+appFunsTable'></span>

<h3>Description</h3>

<p>This is a table of functions that can be used in the <code><a href="#topic+app">app()</a></code> function, their <strong>R</strong> equivalents, and the <code><a href="#topic+datatype">datatype()</a></code> they return. You can view this table using <code>?appFunsTable</code> or as a searchable, sortable <strong>Shiny</strong> table using <code><a href="#topic+appFuns">appFuns()</a></code>.
</p>


<h3>Format</h3>

<p>A <code>data.frame</code>.
</p>


<h3>Source</h3>

<p><a href="https://grass.osgeo.org">OSGeo</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Elevation raster
madElev &lt;- fastData("madElev")

# Convert SpatRaster to a GRaster:
elev &lt;- fast(madElev)

# Create a "stack" of rasters for us to operate on:
x &lt;- c(elev, elev^2, sqrt(elev))

# Demonstrate check for badly-named rasters:
names(x) &lt;- c("cos", "asin", "exp")
fun &lt;- "= cos / asin + exp"
appCheck(x, fun, failOnBad = FALSE)

# Rename rasters acceptable names and run the function:
names(x) &lt;- c("x1", "x2", "x3")
fun &lt;- "= (x1 / x2) + x3"
appCheck(x, fun, failOnBad = FALSE)
app(x, fun = fun)

# This is the same as:
(x[[1]] / x[[2]]) + x[[3]]

# We can view a table of app() functions using appFuns():
appFuns()

# We can also get the same table using:
data(appFunsTable)

# Apply other functions:
fun &lt;- "= median(x1 / x2, x3, x1 * 2, cos(x2))"
app(x, fun = fun)

fun &lt;- "= round(x1) * tan(x2) + log(x3, 10)"
app(x, fun = fun)

# Demonstrate effects of data type:
fun &lt;- "= x1 + x3"
app(x, fun = fun, datatype = "float") # output is floating-point
app(x, fun = fun, datatype = "integer") # output is integer

# Some functions override the "datatype" argument:
fun &lt;- "= sin(x2)"
app(x, fun = fun, datatype = "integer")

# Make a raster with random values [1:4], with equal probability of each:
fun &lt;- "= round(rand(0.5, 4.5))"
rand &lt;- app(elev, fun = fun)
rand

freqs &lt;- freq(rand) # cell frequencies
print(freqs)

}
</code></pre>

<hr>
<h2 id='Arith+2CGRaster+2Clogical-method'>Arithmetic operations on GRasters</h2><span id='topic+Arith+2CGRaster+2Clogical-method'></span><span id='topic+Arith'></span><span id='topic+Arith+2Clogical+2CGRaster-method'></span><span id='topic+Arith+2CGRaster+2Cnumeric-method'></span><span id='topic+Arith+2CGRaster+2Cinteger-method'></span><span id='topic+Arith+2Cnumeric+2CGRaster-method'></span><span id='topic+Arith+2Cinteger+2CGRaster-method'></span><span id='topic+Arith+2CGRaster+2CGRaster-method'></span><span id='topic+Arith+2CGVector+2CGVector-method'></span>

<h3>Description</h3>

<p><strong><code>GRaster</code>s</strong>: You can do arithmetic operations on <code>GRaster</code>s and using normal operators in <strong>R</strong>: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>, <code>%%</code> (modulus), and <code>%/%</code> (integer division).
</p>
<p><strong><code>GVector</code>s</strong>: You can also do arithmetic operations on <code>GVector</code>s:<br /><br />
<code>+</code> operator: Same as <code><a href="#topic+union">union()</a></code><br />
<code>-</code> operator: Same as <code><a href="#topic+erase">erase()</a></code><br />
<code>*</code> operator: Same as <code><a href="#topic+intersect">intersect()</a></code><br />
<code>/</code> operator: Same as <code><a href="#topic+xor">xor()</a></code><br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster,logical'
Arith(e1, e2)

## S4 method for signature 'logical,GRaster'
Arith(e1, e2)

## S4 method for signature 'GRaster,numeric'
Arith(e1, e2)

## S4 method for signature 'GRaster,integer'
Arith(e1, e2)

## S4 method for signature 'numeric,GRaster'
Arith(e1, e2)

## S4 method for signature 'integer,GRaster'
Arith(e1, e2)

## S4 method for signature 'GRaster,GRaster'
Arith(e1, e2)

## S4 method for signature 'GVector,GVector'
Arith(e1, e2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Arith+2B2CGRaster+2B2Clogical-method_+3A_e1">e1</code>, <code id="Arith+2B2CGRaster+2B2Clogical-method_+3A_e2">e2</code></td>
<td>
<p><code>GRaster</code>s, <code>numeric</code>s, <code>integer</code>s, or <code>logical</code>s.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Example data
madElev &lt;- fastData("madElev")

# Convert a SpatRaster to a GRaster
elev &lt;- fast(madElev)
elevs &lt;- c(elev, elev, log10(elev) - 1, sqrt(elev))
names(elevs) &lt;- c("elev1", "elev2", "log_elev", "sqrt_elev")

elev
elevs

# do some math
elev + 100
elev - 100
elev * 100
elev / 100
elev ^ 2
elev %/% 100 # divide then round down
elev %% 100 # modulus

100 + elev
100 %/% elev
100 %% elev

elevs + 100
100 + elevs

# math with logicals
elev + TRUE
elev - TRUE
elev * TRUE
elev / TRUE
elev ^ TRUE
elev %/% TRUE # divide then round down
elev %% TRUE # modulus

elevs + TRUE
TRUE + elevs

# Raster interacting with raster(s):
elev + elev
elev - elev
elev * elev
elev / elev
elev ^ log(elev)
elev %/% sqrt(elev) # divide then round down
elev %% sqrt(elev) # modulus

elevs + elev
elev * elevs

# sign
abs(-1 * elev)
abs(elevs)

# powers
sqrt(elevs)

# trigonometry
sin(elev)
cos(elev)
tan(elev)

asin(elev)
acos(elev)
atan(elev)

atan(elevs)
atan2(elev, elev^1.2)
atan2(elevs, elev^1.2)
atan2(elev, elevs^1.2)
atan2(elevs, elevs^1.2)

# logarithms
exp(elev)
log(elev)
ln(elev)
log2(elev)
log1p(elev)
log10(elev)
log10p(elev)
log(elev, 3)

log(elevs)

# rounding
round(elev + 0.5)
floor(elev + 0.5)
ceiling(elev + 0.5)
trunc(elev + 0.5)

}
</code></pre>

<hr>
<h2 id='as.contour+2CGRaster-method'>Contour lines from a &quot;GRaster&quot;</h2><span id='topic+as.contour+2CGRaster-method'></span><span id='topic+as.contour'></span>

<h3>Description</h3>

<p>Create a <code>GVector</code> of contour lines from a <code>GRaster</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
as.contour(x, nlevels, levels)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.contour+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="as.contour+2B2CGRaster-method_+3A_nlevels">nlevels</code></td>
<td>
<p>Numeric: A positive integer or missing (default). Number of levels at which to calculate contours. Levels will be calculated in equal-sized steps from the smallest to the largest value of <code>x</code>. Either <code>nlevels</code> or <code>levels</code> must be specified.</p>
</td></tr>
<tr><td><code id="as.contour+2B2CGRaster-method_+3A_levels">levels</code></td>
<td>
<p>Numeric vector: A numeric vector of values at which to calculate contour lines. Either <code>nlevels</code> or <code>levels</code> must be specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GVector</code> representing contour lines.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+contour">terra::as.contour()</a></code>, <strong>GRASS</strong> manual page for module <code>r.contour</code> (see <code>grassHelp("r.contour")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Elevation raster
madElev &lt;- fastData("madElev")

# Convert a SpatRaster to a GRaster:
elev &lt;- fast(madElev)

# Calculate contour lines:
conts &lt;- as.contour(elev, nlevels = 10)

plot(elev)
plot(conts, add = TRUE)

}
</code></pre>

<hr>
<h2 id='as.data.frame+2CGVector-method'>Convert GVector to a data frame</h2><span id='topic+as.data.frame+2CGVector-method'></span><span id='topic+as.data.frame'></span><span id='topic+as.data.table+2CGVector-method'></span><span id='topic+as.data.table'></span>

<h3>Description</h3>

<p>Convert a <code>GVector</code>'s data table to a <code>data.frame</code> or <code>data.table</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector'
as.data.frame(x)

## S4 method for signature 'GVector'
as.data.table(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame+2B2CGVector-method_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> or <code>NULL</code> (if the <code>GRaster</code> has no data table).
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+as.data.frame">terra::as.data.frame()</a></code>, <code><a href="data.table.html#topic+as.data.table">data.table::as.data.table()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Example data
madElev &lt;- fastData("madElev")
madForest2000 &lt;- fastData("madForest2000")
madCoast0 &lt;- fastData("madCoast0")
madRivers &lt;- fastData("madRivers")
madDypsis &lt;- fastData("madDypsis")

### GRaster properties

# convert SpatRasters to GRasters
elev &lt;- fast(madElev)
forest &lt;- fast(madForest2000)

# plot
plot(elev)

dim(elev) # rows, columns, depths, layers
nrow(elev) # rows
ncol(elev) # columns
ndepth(elev) # depths
nlyr(elev) # layers

res(elev) # resolution

ncell(elev) # cells
ncell3d(elev) # cells (3D rasters only)

topology(elev) # number of dimensions
is.2d(elev) # is it 2D?
is.3d(elev) # is it 3D?

minmax(elev) # min/max values

# name of object in GRASS
sources(elev)

# "names" of the object
names(elev)

# coordinate reference system
crs(elev)

# extent (bounding box)
ext(elev)

# data type
datatype(elev)

# assigning
copy &lt;- elev
copy[] &lt;- pi # assign all cells to the value of pi
copy

# concatenating multiple GRasters
rasts &lt;- c(elev, forest)
rasts

# adding a raster "in place"
add(rasts) &lt;- ln(elev)
rasts

# subsetting
rasts[[1]]
rasts[["madForest2000"]]

# assigning
rasts[[4]] &lt;- elev &gt; 500

# number of layers
nlyr(rasts)

# names
names(rasts)
names(rasts) &lt;- c("elev_meters", "forest", "ln_elev", "high_elevation")
rasts

### GVector properties

# convert sf vectors to GVectors
coast &lt;- fast(madCoast4)
rivers &lt;- fast(madRivers)
dypsis &lt;- fast(madDypsis)

# extent
ext(rivers)

W(rivers) # western extent
E(rivers) # eastern extent
S(rivers) # southern extent
N(rivers) # northern extent
top(rivers) # top extent (NA for 2D rasters like this one)
bottom(rivers) # bottom extent (NA for 2D rasters like this one)

# coordinate reference system
crs(rivers)
st_crs(rivers)

# column names and data types
names(coast)
datatype(coast)

# name of object in GRASS
sources(rivers)

# points, lines, or polygons?
geomtype(dypsis)
geomtype(rivers)
geomtype(coast)

is.points(dypsis)
is.points(coast)

is.lines(rivers)
is.lines(dypsis)

is.polygons(coast)
is.polygons(dypsis)

# dimensions
nrow(rivers) # how many spatial features
ncol(rivers) # hay many columns in the data frame

# number of geometries and sub-geometries
ngeom(coast)
nsubgeom(coast)

# 2- or 3D
topology(rivers) # dimensionality
is.2d(elev) # is it 2D?
is.3d(elev) # is it 3D?

# Update values from GRASS
# (Reads values from GRASS... will not appear to do anything in this case)
coast &lt;- update(coast)

### operations on GVectors

# convert to data frame
as.data.frame(rivers)
as.data.table(rivers)

# subsetting
rivers[c(1:2, 5)] # select 3 rows/geometries
rivers[-5:-11] # remove rows/geometries 5 through 11
rivers[ , 1] # column 1
rivers[ , "NAM"] # select column
rivers[["NAM"]] # select column
rivers[1, 2:3] # row/geometry 1 and column 2 and 3
rivers[c(TRUE, FALSE)] # select every other geometry (T/F vector is recycled)
rivers[ , c(TRUE, FALSE)] # select every other column (T/F vector is recycled)

# removing data table
noTable &lt;- dropTable(rivers)
noTable
nrow(rivers)
nrow(noTable)

# Refresh values from GRASS
# (Reads values from GRASS... will not appear to do anything in this case
# since the rivers object is up-to-date):
rivers &lt;- update(rivers)

# Concatenating multiple vectors
rivers2 &lt;- rbind(rivers, rivers)
dim(rivers)
dim(rivers2)

}
</code></pre>

<hr>
<h2 id='as.int+2CGRaster-method'>Coerce raster to integer, float, or double precision</h2><span id='topic+as.int+2CGRaster-method'></span><span id='topic+as.int'></span><span id='topic+as.float+2CGRaster-method'></span><span id='topic+as.float'></span><span id='topic+as.doub+2CGRaster-method'></span><span id='topic+as.doub'></span>

<h3>Description</h3>

<p>In <strong>fasterRaster</strong>, rasters can have three data types: &quot;factor&quot; (categorical rasters), &quot;integer&quot; (integers), &quot;float&quot; (floating point values, accurate to 6th to 9th decimal places), and &quot;double&quot; (double-precision values, accurate to the 15th to 17th decimal places). The type of raster can be checked with:
</p>

<ul>
<li> <p><code>as.int()</code>: Coerce values to integers (<strong>GRASS</strong> type <code>CELL</code>).
</p>
</li>
<li> <p><code>as.float()</code>: Coerce values to floating-point precision.
</p>
</li>
<li> <p><code>as.doub()</code>: Coerce values to double-floating point precision.
</p>
</li>
<li><p> Integer rasters can be converted categorical rasters by adding &quot;levels&quot; tables with <code><a href="#topic+levels+3C-">levels&lt;-</a></code> or <code><a href="#topic+categories">categories()</a></code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
as.int(x)

## S4 method for signature 'GRaster'
as.float(x)

## S4 method for signature 'GRaster'
as.doub(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.int+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+datatype">datatype()</a></code>, <code><a href="terra.html#topic+datatype">terra::datatype()</a></code>, <code><a href="#topic+is.int">is.int()</a></code>, <code><a href="#topic+is.float">is.float()</a></code>, <code><a href="#topic+is.doub">is.doub()</a></code>, <code><a href="#topic+levels+3C-">levels&lt;-</a></code>, <code>vignette("GRasters", package = "fasterRaster")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")
madForest2000 &lt;- fastData("madForest2000")

# Convert SpatRasters to GRasters
elev &lt;- fast(madElev)
forest &lt;- fast(madForest2000)

### GRaster properties

# plotting
plot(elev)

# dimensions
dim(elev) # rows, columns, depths, layers
nrow(elev) # rows
ncol(elev) # columns
ndepth(elev) # depths
nlyr(elev) # layers

res(elev) # resolution (2D)
res3d(elev) # resolution (3D)
zres(elev) # vertical resolution
xres(elev) # vertical resolution
yres(elev) # vertical resolution
zres(elev) # vertical resolution (NA because this is a 2D GRaster)

# cell counts
ncell(elev) # cells
ncell3d(elev) # cells (3D rasters only)

# number of NA and non-NA cells
nacell(elev)
nonnacell(elev)

# topology
topology(elev) # number of dimensions
is.2d(elev) # is it 2-dimensional?
is.3d(elev) # is it 3-dimensional?

minmax(elev) # min/max values

# "names" of the object
names(elev)

# coordinate reference system
crs(elev)
st_crs(elev)
coordRef(elev)

# extent (bounding box)
ext(elev)

# vertical extent (not defined for this raster)
zext(elev)

# data type
datatype(elev) # fasterRaster type
datatype(elev, "GRASS") # GRASS type
datatype(elev, "terra") # terra type
datatype(elev, "GDAL") # GDAL type

is.integer(elev)
is.float(elev)
is.double(elev)
is.factor(elev)

# convert data type
as.int(elev) # integer; note that "elev" is already of type "integer"
as.float(elev) # floating-precision
as.doub(elev) # double-precision

# assigning
pie &lt;- elev
pie[] &lt;- pi # assign all cells to the value of pi
pie

# concatenating multiple GRasters
rasts &lt;- c(elev, forest)
rasts

# subsetting
rasts[[1]]
rasts[["madForest2000"]]

# replacing
rasts[[2]] &lt;- 2 * forest
rasts

# adding layers
rasts[[3]] &lt;- elev &gt; 500 # add a layer
rasts &lt;- c(rasts, sqrt(elev)) # add another
add(rasts) &lt;- ln(elev)
rasts

# names
names(rasts)
names(rasts) &lt;- c("elev_meters", "2_x_forest", "high_elevation", "sqrt_elev", "ln_elev")
rasts

# remove a layer
rasts[["2_x_forest"]] &lt;- NULL
rasts

# number of layers
nlyr(rasts)

# correlation and covariance matrices
madLANDSAT &lt;- fastData("madLANDSAT")
landsat &lt;- fast(madLANDSAT) # projects matrix
layerCor(landsat) # correlation
layerCor(landsat, fun = 'cov') # covariance

}
</code></pre>

<hr>
<h2 id='as.lines+2CGRaster-method'>Convert a raster to a lines vector</h2><span id='topic+as.lines+2CGRaster-method'></span><span id='topic+as.lines'></span>

<h3>Description</h3>

<p><code><a href="#topic+as.lines">as.lines()</a></code> converts a <code>GRaster</code> to a &quot;lines&quot; <code>GVector</code>. Before you apply this function, you may need to run <code><a href="#topic+thinLines">thinLines()</a></code> on the raster to reduce linear features to a single-cell width. You may also need to use <a href="#topic+breakPolys">clean geometry</a> (especially the <code><a href="#topic+removeDups">removeDups()</a></code> and <code><a href="#topic+removeDangles">removeDangles()</a></code>) afterward to remove duplicated vertices and &quot;dangling&quot; lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
as.lines(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.lines+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>. If more than one layer is in the <code>GRaster</code>, only the first will be used (with a warning).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.points">as.points()</a></code>, <code><a href="#topic+as.polygons">as.polygons()</a></code>, <code><a href="terra.html#topic+as.lines">terra::as.lines()</a></code>, <code><a href="#topic+thinLines">thinLines()</a></code>, <a href="#topic+breakPolys">geometry cleaning</a>, and <strong>GRASS</strong> module <code>r.to.vect</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Elevation
madElev &lt;- fastData("madElev")

# Convert to GRaster:
elev &lt;- fast(madElev)

# Thin elevation raster:
thinned &lt;- thinLines(elev, iter = 300)
plot(thinned)

# Convert to lines:
rastToLines &lt;- as.lines(thinned)
plot(rastToLines)

# We can clean this:
cleanLines &lt;- fixDangles(x = rastToLines)
plot(rastToLines, col = "red")
plot(cleanLines, add = TRUE)

}
</code></pre>

<hr>
<h2 id='as.points+2CGRaster-method'>Convert a GRaster, or lines or polygons GVector to a points vector</h2><span id='topic+as.points+2CGRaster-method'></span><span id='topic+as.points'></span><span id='topic+as.points+2CGVector-method'></span>

<h3>Description</h3>

<p><code>as.points()</code> converts a <code>GRaster</code>, or a lines or polygons <code>GVector</code> to a points <code>GVector</code>.
</p>
<p>For <code>GRasters</code>, the points have the coordinates of cell centers and are assigned the cells' values. Only non-<code>NA</code> cells will be converted to points.
</p>
<p>For <code>GVectors</code>, each point will have the attributes of the line or polygon to which it belonged. Points are extracted from each vertex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
as.points(x, values = TRUE)

## S4 method for signature 'GVector'
as.points(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.points+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>, <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="as.points+2B2CGRaster-method_+3A_values">values</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), create an attribute table with raster cell values, with one row per point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>points</code> <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crds">crds()</a></code>, <code><a href="#topic+as.lines">as.lines()</a></code>, <code><a href="#topic+as.polygons">as.polygons()</a></code>, <code><a href="terra.html#topic+as.points">terra::as.points()</a></code>, and modules <code>v.to.points</code> and <code>r.to.vect</code> in <strong>GRASS</strong>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Elevation raster, outline of a part of Madagascar, and rivers vector:
madElev &lt;- fastData("madElev")
madCoast0 &lt;- fastData("madCoast0")
madRivers &lt;- fastData("madRivers")

# Convert to GRaster and GVectors:
elev &lt;- fast(madElev)
coast &lt;- fast(madCoast0)
rivers &lt;- fast(madRivers)

# For this example, we will first crop to a small extent.
river &lt;- rivers[1]
elevCrop &lt;- crop(elev, river)
elevPoints &lt;- as.points(elevCrop)
elevPoints

plot(elevCrop)
plot(elevPoints, pch = '.', add = TRUE)

# Extract points from vectors:
coastPoints &lt;- as.points(coast)
riversPoints &lt;- as.points(rivers)

plot(coast)
plot(coastPoints, add = TRUE)

plot(rivers, col = "blue", add = TRUE)
plot(riversPoints, col = "blue", add = TRUE)

}
</code></pre>

<hr>
<h2 id='as.polygons+2CGRaster-method'>Convert a raster to a polygons vector</h2><span id='topic+as.polygons+2CGRaster-method'></span><span id='topic+as.polygons'></span>

<h3>Description</h3>

<p><code><a href="#topic+as.polygons">as.polygons()</a></code> converts a <code>GRaster</code> to a &quot;polygons&quot; <code>GVector</code>. After running this function, <a href="#topic+breakPolys">geometry cleaning</a> may be useful to use to &quot;tidy up&quot; the vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
as.polygons(x, round = TRUE, smooth = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.polygons+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>. If more than one layer is in the <code>GRaster</code>, only the first will be used (with a warning).</p>
</td></tr>
<tr><td><code id="as.polygons+2B2CGRaster-method_+3A_round">round</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), values in the raster will be rounded first before conversion to a vector. This causes cells that are adjacent that have the same (rounded) values to be combined into a single polygon. For more control, see <code><a href="#topic+clump">clump()</a></code>.</p>
</td></tr>
<tr><td><code id="as.polygons+2B2CGRaster-method_+3A_smooth">smooth</code></td>
<td>
<p>Logical: If <code>TRUE</code>, round the corners of square features. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.points">as.points()</a></code>, <code><a href="#topic+as.lines">as.lines()</a></code>, <code><a href="terra.html#topic+as.polygons">terra::as.polygons()</a></code>, <a href="#topic+breakPolys">geometry cleaning</a>, and <strong>GRASS</strong> module <code>r.to.vect</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Elevation
madElev &lt;- fastData("madElev")

# Convert SpatRaster to GRaster:
elev &lt;- fast(madElev)

# To speed things up, first group cells of similar value:
elevClumps &lt;- clump(elev, minDiff = 0.0115)

# Convert to polygons:
rastToPolys &lt;- as.polygons(elevClumps)
plot(rastToPolys)

}
</code></pre>

<hr>
<h2 id='bioclims+2CGRaster-method'>BIOCLIM rasters</h2><span id='topic+bioclims+2CGRaster-method'></span><span id='topic+bioclims'></span><span id='topic+bioclims+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>The BIOCLIM set of bioclimatic variables were created for modeling species' geographic distributions (Booth et al. 2014). This function can create the &quot;standard&quot; 19 set of variables, plus several more from an &quot;extended&quot; set.
</p>
<p>&quot;Classic&quot; set of BIOCLIM variables (Booth et al. 2014):
The units reported below assume that input rasters are in mm (precipitation) and deg C (temperature), and that each raster represents a month (but other time units are allowed, with corresponding changes to the temporal units assumed below).
</p>

<ul>
<li><p> BIO1: Mean annual temperature, calculated using monthly means (deg C)
</p>
</li>
<li><p> BIO2: Mean diurnal range across months (average of monthly difference between maximum and minimum temperature) (deg C)
</p>
</li>
<li><p> BIO3: Isothermality (100 * BIO02 / BIO07; unit-less)
</p>
</li>
<li><p> BIO4: Temperature seasonality (standard deviation across months of average monthly temperature * 100; deg C)
</p>
</li>
<li><p> BIO5: Maximum temperature of the warmest month (based on maximum temperature; deg C)
</p>
</li>
<li><p> BIO6: Minimum temperature of the coldest month (based on minimum temperature; deg C)
</p>
</li>
<li><p> BIO7: Range of annual temperature (BIO05 - BIO06; deg C)
</p>
</li>
<li><p> BIO8: Temperature of the wettest quarter (based on mean temperature; deg C)
</p>
</li>
<li><p> BIO9: Temperature of the driest quarter (based on mean temperature; deg C)
</p>
</li>
<li><p> BIO10: Temperature of the warmest quarter (based on mean temperature; deg C)
</p>
</li>
<li><p> BIO11: Temperature of the coldest quarter (based on mean temperature; deg C)
</p>
</li>
<li><p> BIO12: Total annual precipitation (mm)
</p>
</li>
<li><p> BIO13: Precipitation of the wettest month (mm)
</p>
</li>
<li><p> BIO14: Precipitation of the driest month (mm)
</p>
</li>
<li><p> BIO15: Precipitation seasonality (100 * coefficient of variation; unit-less)
</p>
</li>
<li><p> BIO16: Precipitation of the wettest quarter (mm)
</p>
</li>
<li><p> BIO17: Precipitation of the driest quarter (mm)
</p>
</li>
<li><p> BIO18: Precipitation of the warmest quarter (based on mean temperature; mm)
</p>
</li>
<li><p> BIO19: Precipitation of the coldest quarter (based on mean temperature; mm)
</p>
</li></ul>

<p>&quot;Extended&quot; set of BIOCLIM variables (starts at 41 to avoid conflicts with Kriticos et al. 2014):
</p>

<ul>
<li><p> BIO41: Temperature of the quarter following the coldest quarter (based on mean temperature; deg C)
</p>
</li>
<li><p> BIO42: Temperature of the quarter following the warmest quarter (based on mean temperature; deg C)
</p>
</li>
<li><p> BIO43: Precipitation of the quarter following the coldest quarter (based on mean temperature; mm)
</p>
</li>
<li><p> BIO44: Precipitation of the quarter following the warmest quarter (based on mean temperature; mm)
</p>
</li>
<li><p> BIO45: Temperature of the quarter following the driest quarter (based on mean temperature; deg C)
</p>
</li>
<li><p> BIO46: Temperature of the quarter following the wettest quarter (based on mean temperature; deg C)
</p>
</li>
<li><p> BIO47: Precipitation of the quarter following the driest quarter (based on mean temperature; mm)
</p>
</li>
<li><p> BIO48: Precipitation of the quarter following the wettest quarter (based on mean temperature; mm)
</p>
</li>
<li><p> BIO49: Hottest month (based on maximum temperature)
</p>
</li>
<li><p> BIO50: Coldest month (based on minimum temperature)
</p>
</li>
<li><p> BIO51: Wettest month
</p>
</li>
<li><p> BIO52: Driest month
</p>
</li>
<li><p> BIO53: First month of the warmest quarter (based on mean temperature)
</p>
</li>
<li><p> BIO54: First month of the coldest quarter (based on mean temperature)
</p>
</li>
<li><p> BIO55: First month of the wettest quarter
</p>
</li>
<li><p> BIO56: First month of the driest quarter
</p>
</li>
<li><p> BIO57: The greatest decrease in temperature from one month to the next (deg C; always &gt;= 0)
</p>
</li>
<li><p> BIO58: The greatest increase in temperature from one month to the next (deg C; always &gt;= 0)
</p>
</li>
<li><p> BIO59: The greatest decrease in precipitation from one month to the next (mm; always &gt;= 0)
</p>
</li>
<li><p> BIO60: The greatest increase in precipitation from one month to the next (mm; always &gt;= 0)
</p>
</li></ul>

<p>By default, &quot;quarter&quot; refers to any consecutive run of three months, not a financial quarter. A quarter can thus include November-December-January, or December-January-February, for example. However, the length of a quarter can be changed using the argument <code>quarter</code>.
</p>
<p>The variables are defined assuming that the input rasters represent monthly values (12 rasters for min/max temperature and precipitation), but you can also use sets of 52 rasters, representing one per week, in which case &quot;quarter&quot; would be a successive run of 3 weeks. You could also attempt 365 rasters, in which case a &quot;quarter&quot; would be a run of 3 successive days.
</p>
<p>BIOCLIMs 41 through 44 are added here to capture the &quot;shoulder&quot; seasons (spring and autumn) important in temperature regions. BIOCLIMs 45 through 48 are also included for consistency.
</p>
<p>BIOCLIMs 49 through 60 are not bioclimatic variables per se, but useful for assessing the properties of the variables that are defined based on the &quot;-est&quot; month or quarter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
bioclims(
  ppt,
  tmin,
  tmax,
  tmean = NULL,
  bios = NULL,
  sample = TRUE,
  quarter = 3,
  pptDelta = 1,
  verbose = TRUE
)

## S4 method for signature 'SpatRaster'
bioclims(
  ppt,
  tmin,
  tmax,
  tmean = NULL,
  bios = NULL,
  sample = TRUE,
  quarter = 3,
  pptDelta = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bioclims+2B2CGRaster-method_+3A_ppt">ppt</code></td>
<td>
<p>A multi-layered <code>GRaster</code> or <code>SpatRaster</code>, representing monthly/weekly/daily precipitation.</p>
</td></tr>
<tr><td><code id="bioclims+2B2CGRaster-method_+3A_tmin">tmin</code>, <code id="bioclims+2B2CGRaster-method_+3A_tmax">tmax</code></td>
<td>
<p>A multi-layered <code>GRaster</code> or <code>SpatRaster</code>, representing monthly/weekly/daily minimum and maximum temperature.</p>
</td></tr>
<tr><td><code id="bioclims+2B2CGRaster-method_+3A_tmean">tmean</code></td>
<td>
<p>Either <code>NULL</code> (default), or a multi-layered <code>GRaster</code> or <code>SpatRaster</code>, representing monthly/weekly/daily average temperature. If <code>NULL</code>, <code>tmean</code> will be calculated internally from <code>tmin</code> and <code>tmax</code>. Providing these rasters thus saves time if you already have them on hand.</p>
</td></tr>
<tr><td><code id="bioclims+2B2CGRaster-method_+3A_bios">bios</code></td>
<td>
<p>Any of:
</p>

<ul>
<li><p> Numeric values: Calculate these BIOCLIM variables. For example, <code>bios = c(1, 12)</code> calculates BIOCLIMs 1 and 12.
</p>
</li>
<li> <p><code>NULL</code> (default): Calculate BIOCLIMs 1 through 19
</p>
</li>
<li> <p><code>"*"</code>: Calculate all BIOCLIMs this function can calculate.
</p>
</li>
<li> <p><code>"+"</code>: Calculate BIOCLIMs 41 onward.
</p>
</li>
<li><p> Any combination of the above except <code>NULL</code> (e.g., <code>c(1, 12, "+")</code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="bioclims+2B2CGRaster-method_+3A_sample">sample</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), BIO4 and 15 are calculated with the sample standard deviation. If <code>FALSE</code>, then the population standard deviation is used.</p>
</td></tr>
<tr><td><code id="bioclims+2B2CGRaster-method_+3A_quarter">quarter</code></td>
<td>
<p>Numeric: Length of a &quot;quarter&quot;. BIOCLIM variables are typically calculated using monthly-averaged rasters (e.g., precipitation and temperature of January, February, etc.), in which case a &quot;quarter&quot; is 3 months (so the default for <code>quarter</code> is 3). However, this function can accommodate any set of rasters representing a time series (e.g., 365 for daily rasters), in which case the user can decide what constitutes a &quot;quarter&quot; for calculation of the any BIOCLIMs that use &quot;quarters&quot; in their definitions.</p>
</td></tr>
<tr><td><code id="bioclims+2B2CGRaster-method_+3A_pptdelta">pptDelta</code></td>
<td>
<p>Numeric: Value to add to precipitation for calculation of BIO15 (coefficient of variation of precipitation, times 100). Adding a small value avoids division by 0. The default is 1.</p>
</td></tr>
<tr><td><code id="bioclims+2B2CGRaster-method_+3A_verbose">verbose</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), display progress.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code> with one or more layers.
</p>


<h3>References</h3>

<p>Booth, T.H., Nix, H.A., Busby, J.R., and Hutchinson, M.F.  2014.  BIOCLIM: The first species distribution modeling package, its early applications and relevance to most current MaxEnt studies. <em>Diversity and Distributions</em> 20:1-9 <a href="https://doi.org/10.1111/ddi.12144">doi:10.1111/ddi.12144</a>.
</p>
<p>Kriticos, D.J., Jarošik, V., and Otam N.  2014.  Extending the suite of BIOCLIM variables: A proposed registry system and case study using principal components analysis. <em>Methods in Ecology and Evolution</em> 5:956-960 <a href="https://doi.org/10.1111/2041-210X.12244">doi:10.1111/2041-210X.12244</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Load rasters with precipitation and min/max temperature
madPpt &lt;- fastData("madPpt")
madTmin &lt;- fastData("madTmin")
madTmax &lt;- fastData("madTmax")

### Classic and extended BIOCLIMs from SpatRasters
bcSR &lt;- bioclims(madPpt, madTmin, madTmax, bios = "*")
bcSR

### BIOCLIMs from GRasters
ppt &lt;- fast(madPpt)
tmin &lt;- fast(madTmin)
tmax &lt;- fast(madTmax)

# For small rasters, takes longer to run compared to SpatRaster version:
bc &lt;- bioclims(ppt, tmin, tmax, bios = c(1, 5, 12))
bc
plot(bc)

}
</code></pre>

<hr>
<h2 id='breakPolys+2CGVector-method'>Fix issues with geometries of a vector</h2><span id='topic+breakPolys+2CGVector-method'></span><span id='topic+breakPolys'></span><span id='topic+fixBridges+2CGVector-method'></span><span id='topic+fixBridges'></span><span id='topic+fixDangles+2CGVector-method'></span><span id='topic+fixDangles'></span><span id='topic+fixLines+2CGVector-method'></span><span id='topic+fixLines'></span><span id='topic+remove0+2CGVector-method'></span><span id='topic+remove0'></span><span id='topic+removeAngles+2CGVector-method'></span><span id='topic+removeAngles'></span><span id='topic+removeBridges+2CGVector-method'></span><span id='topic+removeBridges'></span><span id='topic+removeDangles+2CGVector-method'></span><span id='topic+removeDangles'></span><span id='topic+removeDupCentroids+2CGVector-method'></span><span id='topic+removeDupCentroids'></span><span id='topic+removeDups+2CGVector-method'></span><span id='topic+removeDups'></span><span id='topic+removeSmallPolys+2CGVector-method'></span><span id='topic+removeSmallPolys'></span><span id='topic+snap+2CGVector-method'></span><span id='topic+snap'></span>

<h3>Description</h3>

<p>These functions are intended to help fix geometric issues with a <code>GVector</code>. Note that the functionality of the <code>snap()</code> and <code>removeAreas()</code> functions can also be implemented when using <code><a href="#topic+fast">fast()</a></code> to create a <code>GVector</code>.
</p>

<ul>
<li> <p><code>breakPolys()</code>: Break topologically clean areas. This is similar to <code>fixLines()</code>, except that it does not break loops. Topologically clean vectors may occur if the vector was imported from a format that does not enforce topology, such as a shapefile. Duplicate geometries are automatically removed after breaking.
</p>
</li>
<li> <p><code>fixBridges()</code>: Change &quot;bridges&quot; to &quot;islands&quot; (which are topologically incorrect) within geometries to lines.
</p>
</li>
<li> <p><code>fixDangles()</code>: Change &quot;dangles&quot; hanging off boundaries to lines if shorter than <code>tolerance</code> distance. If <code>tolerance</code> is &lt;0, all dangles will be changed to lines.  Units of <code>tolerance</code> are in map units, or in degrees for unprojected CRSs. If <code>tolerance</code> &lt;0, all dangles are removed, and the function will retain only closed loops and lines connecting loops. Dangles will be removed from longest to shortest.
</p>
</li>
<li> <p><code>fixLines()</code>: Break lines at intersections and lines that form closed loops.
</p>
</li>
<li> <p><code>remove0()</code>: Remove all boundaries and lines with a length of 0.
</p>
</li>
<li> <p><code>removeAngles()</code>: Collapse lines that diverge at an angle that is computationally equivalent to 0. This tool often needs to be followed with the <code>break()</code> and <code>removeDups()</code> methods.
</p>
</li>
<li> <p><code>removeBridges()</code>: Remove &quot;bridges&quot; to &quot;islands&quot; (which are topologically incorrect) within geometries.
</p>
</li>
<li> <p><code>removeDangles()</code>: Remove &quot;dangling&quot; lines if shorter than <code>tolerance</code> distance. If <code>tolerance</code> is &lt;0, all dangles will be removed. Units of <code>tolerance</code> are in map units, or in degrees for unprojected CRSs. If <code>tolerance</code> &lt;0, all dangles are removed, and the function will retain only closed loops and lines connecting loops. Dangles will be removed from longest to shortest.
</p>
</li>
<li> <p><code>removeDupCentroids()</code>: Remove duplicated area centroids. In <strong>GRASS</strong>, closed polygons have their attributes mapped to a (hidden) centroid of the polygon.
</p>
</li>
<li> <p><code>removeDups()</code>: Remove duplicated features and area centroids.
</p>
</li>
<li> <p><code>removeSmallPolys()</code>: Remove polygons smaller than <code>tolerance</code>. Units of <code>tolerance</code> are in square meters (regardless of the CRS).
</p>
</li>
<li> <p><code>snap()</code>: Snap lines/boundaries to each other if they are less than <code>tolerance</code> apart. Subsequent removal of dangles may be needed. Units of <code>tolerance</code> are map units, or degrees for unprojected CRSs.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector'
breakPolys(x)

## S4 method for signature 'GVector'
fixBridges(x)

## S4 method for signature 'GVector'
fixDangles(x, tolerance = -1)

## S4 method for signature 'GVector'
fixLines(x)

## S4 method for signature 'GVector'
remove0(x)

## S4 method for signature 'GVector'
removeAngles(x)

## S4 method for signature 'GVector'
removeBridges(x)

## S4 method for signature 'GVector'
removeDangles(x, tolerance = -1)

## S4 method for signature 'GVector'
removeDupCentroids(x)

## S4 method for signature 'GVector'
removeDups(x)

## S4 method for signature 'GVector'
removeSmallPolys(x, tolerance)

## S4 method for signature 'GVector'
snap(x, tolerance)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="breakPolys+2B2CGVector-method_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="breakPolys+2B2CGVector-method_+3A_tolerance">tolerance</code></td>
<td>
<p>Numeric or <code>NULL</code> (default): Minimum distance in map units (degrees for unprojected, usually meters for projected) or minimum area (in meters-squared, regardless of projection).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+topology">terra::topology()</a></code>, <code><a href="#topic+fillHoles">fillHoles()</a></code>, <code><a href="terra.html#topic+topology">terra::removeDupNodes()</a></code>, <em>Details</em> section in <code><a href="#topic+fast">fast()</a></code>, <code><a href="#topic+simplifyGeom">simplifyGeom()</a></code>, <code><a href="#topic+smoothGeom">smoothGeom()</a></code>, <strong>GRASS</strong> manual page for module <code>v.clean</code> (see <code>grassHelp("v.clean")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Example data
madRivers &lt;- fastData("madRivers")
rivers &lt;- fast(madRivers)
soam &lt;- rivers[rivers$NAM == "SOAMIANINA"] # select one river for illustration

### Simplify geometry (remove nodes)

vr &lt;- simplifyGeom(soam, tolerance = 2000)
dp &lt;- simplifyGeom(soam, tolerance = 2000, method = "dp")
dpr &lt;- simplifyGeom(soam, tolerance = 2000, method = "dpr", prop = 0.5)
rw &lt;- simplifyGeom(soam, tolerance = 2000, method = "rw")

plot(soam, col = "black", lwd = 3)
plot(vr, col = "blue", add = TRUE)
plot(dp, col = "red", add = TRUE)
plot(dpr, col = "chartreuse", add = TRUE)
plot(rw, col = "orange", add = TRUE)

legend("bottom",
   xpd = NA,
   legend = c(
	  "Original",
      "Vertex reduction",
      "Douglas-Peucker",
      "Douglas-Peucker reduction",
      "Reumann-Witkam"
	),
	col = c("black", "blue", "red", "chartreuse", "orange"),
	lwd = c(3, 1, 1, 1, 1)
)

### Smooth geometry

hermite &lt;- smoothGeom(soam, dist = 2000, angle = 3)
chaiken &lt;- smoothGeom(soam, method = "Chaiken", dist = 2000)

plot(soam, col = "black", lwd = 2)
plot(hermite, col = "blue", add = TRUE)
plot(chaiken, col = "red", add = TRUE)

legend("bottom",
   xpd = NA,
   legend = c(
	  "Original",
      "Hermite",
      "Chaiken"
	),
	col = c("black", "blue", "red"),
	lwd = c(2, 1, 1, 1, 1)
)

### Clean geometry

# Has no effect on this vector!
noDangs &lt;- removeDangles(soam, tolerance = 10000)

plot(soam, col = "black", lwd = 2)
plot(noDangs, col = "red", add = TRUE)

legend("bottom",
   xpd = NA,
   legend = c(
	  "Original",
      "No dangles"
	),
	lwd = c(2, 1),
	col = c("black", "red")
)

}
</code></pre>

<hr>
<h2 id='buffer+2CGRaster-method'>Increase/decrease the size of a vector or around non-NA cells of a raster</h2><span id='topic+buffer+2CGRaster-method'></span><span id='topic+buffer'></span><span id='topic+buffer+2CGVector-method'></span><span id='topic+st_buffer+2CGVector-method'></span><span id='topic+st_buffer'></span>

<h3>Description</h3>

<p>Buffers can be constructed for <code>GRaster</code>s or <code>GVector</code>s. For rasters, the <code>buffer()</code> function creates a buffer around non-<code>NA</code> cells. The output will be a raster. For vectors, the <code>buffer()</code> and <code>st_buffer()</code> functions create a vector polygon larger or smaller than the focal vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
buffer(
  x,
  width,
  unit = "meters",
  method = "Euclidean",
  background = 0,
  lowMemory = FALSE
)

## S4 method for signature 'GVector'
buffer(x, width, capstyle = "round", dissolve = TRUE)

## S4 method for signature 'GVector'
st_buffer(x, dist, endCapStyle = "round", dissolve = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buffer+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> or <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="buffer+2B2CGRaster-method_+3A_width">width</code></td>
<td>
<p>Numeric: For rasters &ndash; Maximum distance cells must be from focal cells to be within the buffer. For rasters, if the buffering unit is <code style="white-space: pre;">&#8288;"cells&#8288;</code>&quot;, then to get <code>n</code> cell widths, use <code>n + epsilon</code>, where <code>epsilon</code> is a small number (e.g., 0.001). The larger the buffer, this smaller this must be to ensure just <code>n</code> cells are included.
</p>
<p>For vectors, distance from the object to place the buffer. Negative values create &quot;inside&quot; buffers. Units are in the same units as the current coordinate reference system (e.g., degrees for WGS84 or NAD83, often meters for projected systems).</p>
</td></tr>
<tr><td><code id="buffer+2B2CGRaster-method_+3A_unit">unit</code></td>
<td>
<p>Character: Rasters &ndash; Indicates the units of <code>width</code>. Can be one of:
</p>

<ul>
<li> <p><code>"cells"</code>: Units are numbers of cells.
</p>
</li>
<li> <p><code>"meters"</code> (default), <code>"metres"</code>, or <code>"m"</code>
</p>
</li>
<li> <p><code>"kilometers"</code> or <code>"km"</code>
</p>
</li>
<li> <p><code>"feet"</code> or <code>"ft"</code>
</p>
</li>
<li> <p><code>"miles"</code> or <code>"mi"</code>
</p>
</li>
<li> <p><code>"nautical miles"</code> or <code>"nmi"</code>
</p>
</li></ul>

<p>Partial matching is used and case is ignored.</p>
</td></tr>
<tr><td><code id="buffer+2B2CGRaster-method_+3A_method">method</code></td>
<td>
<p>Character: Rasters &ndash; Only used if <code>units</code> is <code>"cells"</code>. Indicates the manner in which distances are calculated for adding of cells:
</p>

<ul>
<li> <p><code>"Euclidean"</code>: Euclidean distance (default)
</p>
</li>
<li> <p><code>"Manhattan"</code>: &quot;taxi-cab&quot; distance
</p>
</li>
<li> <p><code>"maximum"</code>: Maximum of the north-south and east-west distances between points.
</p>
</li></ul>

<p>Partial matching is used and case is ignored.</p>
</td></tr>
<tr><td><code id="buffer+2B2CGRaster-method_+3A_background">background</code></td>
<td>
<p>Numeric: Rasters &ndash; Value to assign to cells that are not <code>NA</code> and not part of the buffer (default is 0).</p>
</td></tr>
<tr><td><code id="buffer+2B2CGRaster-method_+3A_lowmemory">lowMemory</code></td>
<td>
<p>Logical: Rasters &ndash; Only used if buffering a raster and <code>units</code> is not <code>"meters"</code>. If <code>FALSE</code> (default) use faster, memory-intensive procedure. If <code>TRUE</code> then use the slower, low-memory version. To help decide which to use, consider using the low-memory version on a system with 1 GB of RAM for a raster larger than about 32000 x 32000 cells, or for a system with  with 8 GB of RAM a raster larger than about 90000 x 90000 cells.</p>
</td></tr>
<tr><td><code id="buffer+2B2CGRaster-method_+3A_capstyle">capstyle</code>, <code id="buffer+2B2CGRaster-method_+3A_endcapstyle">endCapStyle</code></td>
<td>
<p>Character: Vectors &ndash; Style for ending the &quot;cap&quot; of buffers around lines. Valid options include <code>"rounded"</code>, <code>"square"</code>, and &quot;<code>flat</code>&quot;.</p>
</td></tr>
<tr><td><code id="buffer+2B2CGRaster-method_+3A_dissolve">dissolve</code></td>
<td>
<p>Logical (<code>GVector</code>s): If <code>TRUE</code> (default), dissolve all buffers after creation. If <code>FALSE</code>, construct a buffer for each geometry. Note that overlapping buffers can cause this function to fail because it creates a topologically ambiguous polygon. Thus, using <code>dissolve = TRUE</code> is recommended.</p>
</td></tr>
<tr><td><code id="buffer+2B2CGRaster-method_+3A_dist">dist</code></td>
<td>
<p>Vectors &ndash; Same as <code>width</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that in some cases, topologically incorrect vectors can be created when buffering. This can arise when buffers intersect to create intersections that technically belong to two or more geometries. This issue can be resolved by dissolving borders between buffered geometries using <code>dissolve = TRUE</code>, but as of now, there is no fix if you do not want to dissolve geometries. A workaround would be to create a different <code>GVector</code> for each geometry, and then buffer each individually :(.
</p>


<h3>Value</h3>

<p>A <code>GRaster</code> or a <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+buffer">terra::buffer()</a></code>, <code><a href="sf.html#topic+geos_unary">sf::st_buffer()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Elevation raster, rivers vector
madElev &lt;- fastData("madElev")
madRivers &lt;- fastData("madRivers")

# Convert a SpatRaster to a GRaster, and sf to a GVector
elev &lt;- fast(madElev)
rivers &lt;- fast(madRivers)

### Buffer a raster by a given distance:
buffByDist &lt;- buffer(elev, width = 2000) # 2000-m buffer
plot(buffByDist, legend = FALSE)
plot(madElev, add = TRUE)

### Buffer a raster by a given number of cells:
buffByCells &lt;- buffer(elev, width = 20.01, unit = "cells") # 20-cell buffer
plot(buffByCells, legend = FALSE)
plot(madElev, add = TRUE)

### Buffer a vector:
buffRivers &lt;- buffer(rivers, width = 2000, dissolve = TRUE) # 2000-m buffer
plot(buffRivers)
plot(st_geometry(madRivers), col = "blue", add = TRUE)

}
</code></pre>

<hr>
<h2 id='c+2CGRaster-method'>&quot;Stack&quot; GRasters</h2><span id='topic+c+2CGRaster-method'></span><span id='topic+c'></span>

<h3>Description</h3>

<p><code>GRaster</code>s can be &quot;stacked&quot; using this function, effectively creating a multi-layered raster. This is different from creating a 3-dimensional raster, though such an effect can be emulated using stacking. <code>GVector</code>s can be combined into a single vector.  Stacks can only be created when:
</p>

<ul>
<li><p> All objects are the same class (either all <code>GRaster</code>s or all <code>GVector</code>s).
</p>
</li>
<li><p> All objects have the same coordinate reference system (see crs()).
</p>
</li>
<li><p> Horizontal extents are the same (see <code><a href="#topic+ext">ext()</a></code>).
</p>
</li>
<li><p> Horizontal dimensions are the same (see <code><a href="#topic+res">res()</a></code>).
</p>
</li>
<li><p> The topology (2- or 3-dimensional) must be the same. If 3D, then all rasters must have the same number of depths and vertical extents (see <code><a href="#topic+topology">topology()</a></code>).
</p>
</li></ul>

<p>Data tables associated with <code>GVector</code>s will be combined if each vector has a table and if each table has the same columns and data types. Otherwise, the data table will be combined using <code><a href="#topic+merge">merge()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
c(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> or a <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="c+2B2CGRaster-method_+3A_...">...</code></td>
<td>
<p>One or more <code>GRaster</code>s, one or more <code>GVector</code>s, a list of <code>GRaster</code>s, or a list of <code>GVector</code>s. You can use a mix of lists and individual rasters or vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+add+3C-">add&lt;-</a>, <code><a href="terra.html#topic+c">terra::c()</a></code>, <code><a href="terra.html#topic+add+3C-">add&lt;-</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
madForest2000 &lt;- fastData("madForest2000")
madForest2014 &lt;- fastData("madForest2014")

# Convert SpatRasters to GRasters:
forest2000 &lt;- fast(madForest2000)
forest2014 &lt;- fast(madForest2014)

# Combine:
forest &lt;- c(forest2000, forest2014)
forest

nlyr(forest)

}
</code></pre>

<hr>
<h2 id='catNames+2CGRaster-method'>Names of columns of the levels table of a categorical raster</h2><span id='topic+catNames+2CGRaster-method'></span><span id='topic+catNames'></span><span id='topic+catNames+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>This function returns the column names of each &quot;levels&quot; table of a categorical raster (see <code>vignette("GRasters", package = "fasterRaster")</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
catNames(x, layer = NULL)

## S4 method for signature 'SpatRaster'
catNames(x, layer = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="catNames+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="catNames+2B2CGRaster-method_+3A_layer">layer</code></td>
<td>
<p><code>NULL</code>, numeric integer, or character: The index (indices) or name(s) of one or more raster layers. The default is <code>NULL</code>, in which case all names for all layers are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character vectors.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cats">cats()</a></code>, <code>vignette("GRasters", package = "fasterRaster")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data: Land cover raster
madCover &lt;- fastData("madCover")

# Convert categorical SpatRaster to categorical GRaster:
cover &lt;- fast(madCover)

### Properties of categorical rasters

cover # note categories
is.factor(cover) # Is the raster categorical?
nlevels(cover) # number of levels
levels(cover) # just the value and active column
cats(cover) # all columns
minmax(cover) # min/max values
minmax(cover, levels = TRUE) # min/max categories
catNames(cover) # column names of the levels table
missingCats(cover) # categories in table with no values in raster
freq(cover) # frequency of each category (number of cells)
zonalGeog(cover) # geometric statistics

### Active column

# Which column sets the category labels?
activeCat(cover)
activeCat(cover, names = TRUE)

activeCats(c(cover, cover))

# Choose a different column for category labels:
levels(cover)
activeCat(cover) &lt;- 2
levels(cover)

### Managing levels tables

# Remove unused levels:
nlevels(cover)
cover &lt;- droplevels(cover)
nlevels(cover)

# Re-assign levels:
value &lt;- c(20, 30, 40, 50, 120, 130, 140, 170)
label &lt;- c("Cropland", "Cropland", "Forest", "Forest",
 "Grassland", "Shrubland", "Herbaceous", "Flooded")

newCats &lt;- data.frame(value = value, label = label)

cover &lt;- categories(cover, layer = 1, value = newCats)
cats(cover)

# This is the same as:
levels(cover) &lt;- newCats
cats(cover)

# Are there any values not assigned a category?
missingCats(cover)

# Let's assign a category for value 210 (water):
water &lt;- data.frame(value = 210, label = "Water")
addCats(cover) &lt;- water
levels(cover)

# Add more information to the levels table using merge():
landType &lt;- data.frame(
     Value = c(20, 30, 40, 50, 120),
     Type = c("Irrigated", "Rainfed", "Broadleaf evergreen",
     "Broadleaf deciduous", "Mosaic with forest")
)
cats(cover)
cover &lt;- addCats(cover, landType, merge = TRUE)
cats(cover)

### Logical operations on categorical rasters

cover &lt; "Forest" # 1 for cells with a value &lt; 40, 0 otherwise
cover &lt;= "Forest" # 1 for cells with a value &lt; 120, 0 otherwise
cover == "Forest" # 1 for cells with value of 40-120, 0 otherwise
cover != "Forest" # 1 for cells with value that is not 40-120, 0 otherwise
cover &gt; "Forest" # 1 for cells with a value &gt; 120, 0 otherwise
cover &gt;= "Forest" # 1 for cells with a value &gt;= 120, 0 otherwise

cover %in% c("Cropland", "Forest") # 1 for cropland/forest cells, 0 otherwise

### Combine categories from different rasters

# For the example, will create a second categorical raster fromm elevation.

# Divide elevation raster into "low/medium/high" levels:
madElev &lt;- fastData("madElev")
elev &lt;- fast(madElev)
elev &lt;- project(elev, cover, method = "near") # convert to same CRS
fun &lt;- "= if(madElev &lt; 100, 0, if(madElev &lt; 400, 1, 2))"
elevCat &lt;- app(elev, fun)

levs &lt;- data.frame(
     value = c(0, 1, 2),
     elevation = c("low", "medium", "high")
)
levels(elevCat) &lt;- list(levs)

# Combine levels:
combined &lt;- concats(cover, elevCat)
combined
levels(combined)

# Combine levels, treating value/NA combinations as new categories:
combinedNA &lt;- concats(cover, elevCat, na.rm = FALSE)
combinedNA
levels(combinedNA)

}
</code></pre>

<hr>
<h2 id='cellSize+2CGRaster-method'>Area of GRaster cells</h2><span id='topic+cellSize+2CGRaster-method'></span><span id='topic+cellSize'></span>

<h3>Description</h3>

<p><code>cellArea()</code> returns a raster will cell values equal to their area. To get the area of all cells of a raster, see <code><a href="#topic+expanse">expanse()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
cellSize(x, mask = FALSE, lyrs = FALSE, unit = "meters2")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cellSize+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="cellSize+2B2CGRaster-method_+3A_mask">mask</code></td>
<td>
<p>Logical: If <code>TRUE</code>, then cells that are <code>NA</code> in <code>x</code> are also <code>NA</code> in the output.</p>
</td></tr>
<tr><td><code id="cellSize+2B2CGRaster-method_+3A_lyrs">lyrs</code></td>
<td>
<p>Logical:
</p>

<ul>
<li><p> If <code>lyrs</code> is <code>FALSE</code> (default), then the output has a single layer. In this case, if <code>mask</code> is <code>TRUE</code>, then cells that are <code>NA</code> in the <em>first</em> layer are also <code>NA</code> in the output.
</p>
</li>
<li><p> If <code>lyrs</code> is <code>TRUE</code>, then the output has the same number of layers as <code>x</code> if <code>mask</code> is also <code>TRUE</code>. In this case, cells that area <code>NA</code> in the input will also be <code>NA</code> in the output in the respective layer.
</p>
</li></ul>
</td></tr>
<tr><td><code id="cellSize+2B2CGRaster-method_+3A_unit">unit</code></td>
<td>
<p>Character: Units of area. Partial matching is used, and case is ignored. Can be any of:
</p>

<ul>
<li> <p><code>"meters2"</code> (default), <code>"metres2"</code>, or <code>"m2"</code>
</p>
</li>
<li> <p><code>"km2"</code> or <code>"kilometers2"</code>
</p>
</li>
<li> <p><code>"ha"</code> or <code>"hectares"</code>
</p>
</li>
<li> <p><code>"ac"</code> or <code>"acres"</code>
</p>
</li>
<li> <p><code>"mi2"</code> or <code>"miles2"</code>
</p>
</li>
<li> <p><code>"ft2"</code> or <code>"feet2"</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+cellSize">terra::cellSize()</a></code>, <code><a href="#topic+expanse">expanse()</a></code>, <code><a href="#topic+zonalGeog">zonalGeog()</a></code>, <code><a href="omnibus.html#topic+convertUnits">omnibus::convertUnits()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Elevation raster
madElev &lt;- fastData("madElev")

# Convert a SpatRaster to a GRaster:
elev &lt;- fast(madElev)

# Cell size, no masking, single layer
cs1 &lt;- cellSize(elev)
plot(cs1)

# Cell size, with masking, single layer
cs2 &lt;- cellSize(elev, mask = TRUE)
plot(cs2)

# Cell size, no masking, multilayer
elev2 &lt;- c(elev, log(elev - 200))
cs3 &lt;- cellSize(elev2)
plot(cs3)

# Cell size, masking by 1st layer, multilayer (ignores subsequent layers)
cs4 &lt;- cellSize(elev2, mask = TRUE)
plot(cs4)

# Cell size, masking by each layer, multilayer
cs5 &lt;- cellSize(elev2, mask = TRUE, lyrs = TRUE)
plot(cs5)

}
</code></pre>

<hr>
<h2 id='centroids+2CGVector-method'>Centroid(s) of a vector</h2><span id='topic+centroids+2CGVector-method'></span><span id='topic+centroids'></span>

<h3>Description</h3>

<p>This function locates the centroid of each geometry of a <code>GVector</code>.
</p>
<p><strong>To use this function</strong>, you must a) have correctly specified the <code>addonsDir</code> option using <code><a href="#topic+faster">faster()</a></code>, and b) installed the <strong>GRASS</strong> addon <code>v.centerpoint</code>. See <code><a href="#topic+addons">addons()</a></code> and <code>vignette("addons", package = "fasterRaster")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector'
centroids(x, method = NULL, fail = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="centroids+2B2CGVector-method_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="centroids+2B2CGVector-method_+3A_method">method</code></td>
<td>
<p>Character or <code>NULL</code> (default): Method used for calculating centroids. The method of calculation depends on whether the input is a <code>points</code>, <code>lines</code>, or <code>polygons</code> <code>GVector</code>. If the value is <code>NULL</code>, then the default method will be chosen, depending on the geometry type of the <code>GVector</code>:
</p>

<ul>
<li> <p><code>points</code>:
</p>

<ul>
<li> <p><code>"mean"</code> (default for <code>points</code>): Mean of coordinates.
</p>
</li>
<li> <p><code>"median"</code>: Geometric median; more robust to outliers.
</p>
</li>
<li> <p><code>"pmedian"</code>: Point in <code>x</code> closest to the geometric median.
</p>
</li></ul>

</li>
<li> <p><code>lines</code>:
</p>

<ul>
<li> <p><code>"mid"</code> (default for <code>lines</code>): Mid-point on each line; will fall exactly on the line.
</p>
</li>
<li> <p><code>"mean"</code>: Center of gravity of all line segments; may not fall on the line.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"median&#8288;</code>: Geometric median; may not fall on the line.
</p>
</li></ul>

</li>
<li> <p><code>polygons</code>:
</p>

<ul>
<li> <p><code>"mean"</code> (default for <code>polygons</code>): Center of gravity (area), calculated using area triangulation.
</p>
</li>
<li> <p><code>"median"</code>: Geometric mean; may not fall inside the polygon.
</p>
</li>
<li> <p><code>"bmedian"</code>: Geometric mean; minimum distance to boundaries; may not fall inside the polygon.
</p>
</li></ul>

</li></ul>

<p>Partial matching is used and case is ignored.</p>
</td></tr>
<tr><td><code id="centroids+2B2CGVector-method_+3A_fail">fail</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), and the addons folder is not correctly specified, the exit the function with an error. If <code>FALSE</code>, then <code>NULL</code> will be returned with a warning.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A points <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+centroids">terra::centroids()</a></code>; <strong>GRASS</strong> addon module <code>v.centerpoint</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Points, lines, and polygons
madDypsis &lt;- fastData("madDypsis")
madRivers &lt;- fastData("madRivers")
madCoast4 &lt;- fastData("madCoast4")

# Convert to  GVectors:
dypsis &lt;- fast(madDypsis)
rivers &lt;- fast(madRivers)
coast4 &lt;- fast(madCoast4)

# Point centroids:
dypMean &lt;- centroids(dypsis, fail = FALSE)
dypMedian &lt;- centroids(dypsis, method = "median", fail = FALSE)
dypPMedian &lt;- centroids(dypsis, method = "pmedian", fail = FALSE)

if (!is.null(dypMean)) {

plot(dypsis)
plot(dypMean, col = "red", add = TRUE)
plot(dypMedian, col = "green", pch = 2, add = TRUE)
plot(dypPMedian, col = "orange", pch = 1, add = TRUE)
legend("bottomright",
   legend = c("mean", "median", "pmedian"),
   col = c("red", "green", "orange"),
   pch = c(16, 2, 1),
   xpd = NA
)

}

# Line centroids:
riversMid &lt;- centroids(rivers, fail = FALSE)
riversMean &lt;- centroids(rivers, method = "mean", fail = FALSE)
riversMedian &lt;- centroids(rivers, method = "median", fail = FALSE)

if (!is.null(riversMid)) {

plot(rivers)
plot(riversMid, col = "red", add = TRUE)
plot(riversMean, col = "green", pch = 2, add = TRUE)
plot(riversMedian, col = "orange", pch = 1, add = TRUE)
legend("bottomright",
   legend = c("mid", "mean", "median"),
   col = c("red", "green", "orange"),
   pch = c(16, 2, 1),
   xpd = NA
)

}

# Polygon centroids:
coastMean &lt;- centroids(coast4, fail = FALSE)
coastMedian &lt;- centroids(coast4, method = "median", fail = FALSE)
coastBMedian &lt;- centroids(coast4, method = "bmedian", fail = FALSE)

if (!is.null(coastMean)) {

plot(coast4)
plot(coastMean, col = "red", add = TRUE)
plot(coastMedian, col = "green", pch = 2, add = TRUE)
plot(coastBMedian, col = "orange", pch = 1, add = TRUE)
legend("bottomright",
   legend = c("mean", "median", "bmedian"),
   col = c("red", "green", "orange"),
   pch = c(16, 2, 1),
   xpd = NA
)

}

}
</code></pre>

<hr>
<h2 id='classify+2CGRaster-method'>Classify GRaster cell values</h2><span id='topic+classify+2CGRaster-method'></span><span id='topic+classify'></span>

<h3>Description</h3>

<p>This function classifies a 'GRaster&ldquo; so that cells that have values within a given range are assigned a new value. The <code><a href="#topic+subst">subst()</a></code> function is a simpler method for replacing specific values or category levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
classify(x, rcl, include.lowest = FALSE, right = TRUE, others = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="classify+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="classify+2B2CGRaster-method_+3A_rcl">rcl</code></td>
<td>
<p>Reclassification system:
</p>

<ul>
<li><p> A single integer: Number of &quot;bins&quot; into which to divide values. Arguments <code>include.lowest</code> and <code>right</code> apply.
</p>
</li>
<li><p> A vector of numeric values: Breakpoints of bins into which to divide values. These will be sorted from lowest to highest before classification. Arguments <code>include.lowest</code> and <code>right</code> apply.
</p>
</li>
<li><p> A 2-column <code>matrix</code>, <code>data.frame</code>, or <code>data.table</code>: The first column provides specific values in <code>x</code> to be replaced, and the second provides the values they are replaced with. This method is only useful for classifying <code>integer</code> <code>GRaster</code>s. Arguments <code>include.lowest</code> and <code>right</code> are ignored. Cells will be classified in the order in which values are listed in the first column.
</p>
</li>
<li><p> A 3-column <code>matrix</code>, <code>data.frame</code>, or <code>data.table</code>: The first column provides the lower value of a bin, the second the upper value, and the third the value to assign to the cells in the bin. Arguments <code>include.lowest</code> and <code>right</code> apply. Cells will be classified in the order of how intervals are listed (intervals will not be sorted).
</p>
</li></ul>
</td></tr>
<tr><td><code id="classify+2B2CGRaster-method_+3A_include.lowest">include.lowest</code>, <code id="classify+2B2CGRaster-method_+3A_right">right</code></td>
<td>
<p>Logical: These arguments determine how cells that have values exactly equal to the lower or upper ends of an interval are classified.
</p>

<ul>
<li> <p><code>include.lowest = TRUE</code> and <code>right = TRUE</code>: All intervals will be &quot;left-open, right-closed&quot; except for the lowest interval, which will be &quot;left-closed/right-closed&quot;.
</p>
</li>
<li> <p><code>include.lowest = FALSE</code> and <code>right = FALSE</code>: Intervals will be &quot;left-closed/right-open&quot;. Cells with values equal to the highest higher boundary will not be reclassified.
</p>
</li>
<li> <p><code>include.lowest = TRUE</code> and <code>right = FALSE</code>: All intervals will be &quot;left-closed/right-open&quot;, except for the highest interval, which will be &quot;right-closed/left-closed&quot;.
</p>
</li>
<li> <p><code>right = NA</code>: Only useful for classifying <code>integer</code> <code>GRaster</code>s. All intervals are &quot;left-closed/right-closed&quot;. This is easier than accounting for &quot;open&quot; intervals when dealing with integers. Argument <code>include.lowest</code> is ignored.
</p>
</li></ul>
</td></tr>
<tr><td><code id="classify+2B2CGRaster-method_+3A_others">others</code></td>
<td>
<p>Integer or <code>NULL</code> (default), or <code>NA</code>: Value to assign to cells that do not fall into the set intervals. Cells with <code>NA</code> values are not reclassified. Setting <code>others</code> equal to <code>NULL</code> or <code>NA</code> replaces all other values with <code>NA</code>. The value will be coerced to an integer value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>. The raster will be a categorical <code>GRaster</code> if the original values were continuous (i.e., a single- or double-precision raster), or of type &quot;integer&quot; if the input was an integer. See <code>vignette("GRasters", package = "fasterRaster")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+classify">terra::classify()</a></code>, <code><a href="#topic+subst">subst()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")

# Convert a SpatRaster to a GRaster:
elev &lt;- fast(madElev)

# Classify using a scalar indicating number of bins
scalar &lt;- classify(elev, 5)
scalar
levels(scalar)

# Classify using a vector, indicating bin break points
vector &lt;- classify(elev, rcl = c(0, 100, 200, 300, 400, 500, 600))
vector
levels(vector)

# Classify using a 2-column matrix (only valid for integer rasters)
rcl &lt;- data.frame(is = c(1:3, 5, 10), becomes = c(100:102, 105, 110))
twoCol &lt;- classify(elev, rcl = rcl)
twoCol

# Classify using a 3-column table
rcl &lt;- data.frame(
   from = c(0, 100, 200, 300, 400, 500),
   to = c(100, 200, 300, 400, 500, 600),
   becomes = c(1, 2, 3, 10, 12, 15)
)
threeCol &lt;- classify(elev, rcl = rcl)
threeCol
levels(threeCol)

# Convert all values outside range to NA (default)
rcl &lt;- c(100, 200, 300)
v1 &lt;- classify(elev, rcl = rcl)
v1
plot(v1)

# Convert all values outside range to -1
rcl &lt;- c(100, 200, 300)
v2 &lt;- classify(elev, rcl = rcl, others = -1)
v2
plot(v2)

### Left-open/right-closed (default)
minmax(elev) # note min/max values
rcl &lt;- c(1, 200, 570)
v3 &lt;- classify(elev, rcl = rcl, others = 10)
levels(v3)
plot(v3)

### Left-closed/right-open
minmax(elev) # note min/max values
rcl &lt;- c(1, 200, 570)
v4 &lt;- classify(elev, rcl = rcl, others = 10, right = FALSE)
levels(v4)

# Left-open except for lowest bin/right-closed
minmax(elev) # note min/max values
rcl &lt;- c(1, 200, 570)
v5 &lt;- classify(elev, rcl = rcl, others = 10, include.lowest = TRUE)
v5 &lt;- droplevels(v5)
levels(v5)

# Left-closed/right-open except for highest bin
minmax(elev) # note min/max values
rcl &lt;- c(1, 200, 570)
v6 &lt;- classify(elev, rcl = rcl, others = 10,
   right = FALSE, include.lowest = TRUE)
v6 &lt;- droplevels(v6)
levels(v6)

}
</code></pre>

<hr>
<h2 id='clump+2CGRaster-method'>Group adjacent cells with similar values</h2><span id='topic+clump+2CGRaster-method'></span><span id='topic+clump'></span>

<h3>Description</h3>

<p><code>clump()</code> identifies groups of adjacent cells that have the same value or same approximate value, and assigns them a unique number, creating &quot;clumps&quot; of same- or similar-valued cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
clump(x, minDiff = 0, minClumpSize = 1, diagonal = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clump+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="clump+2B2CGRaster-method_+3A_mindiff">minDiff</code></td>
<td>
<p>Numeric in the range [0, 1): Minimum difference between cells in order for them to be assigned to the same clump. This is a proportion of the range across all cells. For example, if <code>minDiff</code> is set to 0.01, then the maximum difference between cells in a clump can be up to 1% of the entire range across all cells. Small values can create large clumps. The default is 0, in which case values have to be exactly the same.</p>
</td></tr>
<tr><td><code id="clump+2B2CGRaster-method_+3A_minclumpsize">minClumpSize</code></td>
<td>
<p>Numeric integer &gt;= 1. Minimum number of cells in a clump. The default is 1.</p>
</td></tr>
<tr><td><code id="clump+2B2CGRaster-method_+3A_diagonal">diagonal</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), then cells &quot;connected&quot; at corners will be included as part of the same clump.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Elevation raster
madElev &lt;- fastData("madElev")

# Convert a SpatRaster to a GRaster:
elev &lt;- fast(madElev)

# Find clumps based on exact values. This will appear as a gradient because
# most cells are assigned to a group of 1 cell.
exact &lt;- clump(elev)
plot(exact)

# Clump based on approximate values:
approx &lt;- clump(elev, minDiff = 0.0075)
plot(approx)

# Clump based on approximate values with minimum clump size:
approx20 &lt;- clump(elev, minDiff = 0.005, minClumpSize = 20)
plot(approx20)

approx
approx20

}
</code></pre>

<hr>
<h2 id='clusterPoints+2CGVector-method'>Identify clusters of points</h2><span id='topic+clusterPoints+2CGVector-method'></span><span id='topic+clusterPoints'></span>

<h3>Description</h3>

<p><code>clusterPoints()</code> partitions points in a &quot;points&quot; <code>GVector</code> into clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector'
clusterPoints(x, method = "DBSCAN", minIn = NULL, maxDist = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clusterPoints+2B2CGVector-method_+3A_x">x</code></td>
<td>
<p>A &quot;points&quot; <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="clusterPoints+2B2CGVector-method_+3A_method">method</code></td>
<td>
<p>Character: Method used to identify clusters. Explanations of methods are provided in the help page for the <strong>GRASS</strong> module <code>v.cluster</code>, available using <code>grassHelp("v.cluster")</code>.
</p>

<ul>
<li> <p><code>"DBSCAN"</code> (default): Density-Based Spatial Clustering of Applications with Noise.
</p>
</li>
<li> <p><code>"DBSCAN2"</code>: A modification of DBSCAN.
</p>
</li>
<li> <p><code>"density"</code>: Cluster points by relative density.
</p>
</li>
<li> <p><code>"OPTICS"</code>: Ordering Points to Identify the Clustering Structure
</p>
</li>
<li> <p><code>"OPTICS2"</code>: A modification of OPTICS.
</p>
</li></ul>

<p>Case is ignored, but partial matching is not used.</p>
</td></tr>
<tr><td><code id="clusterPoints+2B2CGVector-method_+3A_minin">minIn</code></td>
<td>
<p>Integer, numeric integer, or <code>NULL</code> (default): Minimum number of points in a cluster. If <code>NULL</code>, then <code>minIn</code> is set to 3 for a 2-dimensional vector and 4 for a 3-dimensional vector.</p>
</td></tr>
<tr><td><code id="clusterPoints+2B2CGVector-method_+3A_maxdist">maxDist</code></td>
<td>
<p>Numeric or <code>NULL</code> (default): Maximum distance between neighboring points in a cluster for DBSCAN, DBSCAN2, and OPTICS. If <code>NULL</code>, the maximum distance will be set to the 99th quantile of observed pairwise distances between points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of integers indicating the cluster to which each point belongs.
</p>


<h3>See Also</h3>

<p><strong>GRASS</strong> manual page for module <code>v.cluster</code> (see <code>grassHelp("v.cluster")</code>)
</p>

<hr>
<h2 id='colbind+2CGVector-method'>Add columns to the data table of a GVector</h2><span id='topic+colbind+2CGVector-method'></span><span id='topic+colbind'></span>

<h3>Description</h3>

<p><code>colbind()</code> adds columns to the data table of a <code>GVector</code>. You can combine multiple a <code>GVector</code>'s data table with <code>data.frame</code>s, <code>data.table</code>s, <code>matrices</code>, or the data table(s) from other <code>GVector</code>(s). To combine two <code>GVector</code>s, see <code><a href="#topic+rbind">rbind()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector'
colbind(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="colbind+2B2CGVector-method_+3A_x">x</code>, <code id="colbind+2B2CGVector-method_+3A_...">...</code></td>
<td>
<p>The first argument must be a <code>GVector</code>. Subsequent arguments can be <code>data.frame</code>s, <code>data.table</code>s, <code>matrices</code>, or <code>GVector</code>s. Only the data tables of subsequent <code>GVector</code>s are added to the table in <code>x</code>; the geometries are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rbind">rbind()</a></code>, <code><a href="#topic+addTable+3C-">addTable&lt;-</a></code>, <code><a href="#topic+dropTable">dropTable()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)

# Rivers vector
madRivers &lt;- fastData("madRivers")

# Convert sf to a GVector
rivers &lt;- fast(madRivers)

# Convert GVector to data.frame or data.table
as.data.frame(rivers)
as.data.table(rivers)

# Subset rivers vector
rivers1 &lt;- rivers[1:2]
rivers2 &lt;- rivers[10:11]

# Concatenate rivers
riversCombo &lt;- rbind(rivers1, rivers2)
riversCombo

# Add columns
newCol &lt;- data.frame(new = 1:11)
riversCol &lt;- colbind(rivers, newCol)
riversCol

# Remove table
riversCopy &lt;- rivers
riversCopy # has data table
riversCopy &lt;- dropTable(riversCopy)
riversCopy # no data table

# Add a new table
newTable &lt;- data.frame(num = 1:11, letters = letters[1:11])
addTable(riversCopy) &lt;- newTable
riversCopy

}
</code></pre>

<hr>
<h2 id='combineLevels+2CGRaster-method'>Combine levels table from multiple categorical GRasters</h2><span id='topic+combineLevels+2CGRaster-method'></span><span id='topic+combineLevels'></span><span id='topic+combineLevels+2Clist-method'></span>

<h3>Description</h3>

<p>This function creates a single &quot;levels&quot; table from the levels tables of one or more categorical <code>GRaster</code>s.
</p>
<p>The difference between this function and <code><a href="#topic+concats">concats()</a></code> is that <code>concats()</code> creates a &quot;combined&quot; <code>GRaster</code> with a combined levels table, whereas this one just merges the levels tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
combineLevels(x, ...)

## S4 method for signature 'list'
combineLevels(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combineLevels+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> or a <code>list</code> of <code>GRaster</code>s.</p>
</td></tr>
<tr><td><code id="combineLevels+2B2CGRaster-method_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code><a href="data.table.html#topic+merge">data.table::merge()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with a &quot;levels&quot; table (a <code>data.frame</code> or <code>data.table</code>), and the active category number for the new table. Following <code><a href="terra.html#topic+activeCat">terra::activeCat()</a></code>, the number is offset by 1, so a value of 1 indicates that the second column in the table should be used for the category labels, a value of 2 indicates the third column should be used, and so on.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+concats">concats()</a></code>, <a href="terra.html#topic+concats">terra::concats</a>, <code>vignette("GRasters", package = "fasterRaster")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data: Land cover raster
madCover &lt;- fastData("madCover")

# Convert categorical SpatRaster to categorical GRaster:
cover &lt;- fast(madCover)

### Properties of categorical rasters

cover # note categories
is.factor(cover) # Is the raster categorical?
nlevels(cover) # number of levels
levels(cover) # just the value and active column
cats(cover) # all columns
minmax(cover) # min/max values
minmax(cover, levels = TRUE) # min/max categories
catNames(cover) # column names of the levels table
missingCats(cover) # categories in table with no values in raster
freq(cover) # frequency of each category (number of cells)
zonalGeog(cover) # geometric statistics

### Active column

# Which column sets the category labels?
activeCat(cover)
activeCat(cover, names = TRUE)

activeCats(c(cover, cover))

# Choose a different column for category labels:
levels(cover)
activeCat(cover) &lt;- 2
levels(cover)

### Managing levels tables

# Remove unused levels:
nlevels(cover)
cover &lt;- droplevels(cover)
nlevels(cover)

# Re-assign levels:
value &lt;- c(20, 30, 40, 50, 120, 130, 140, 170)
label &lt;- c("Cropland", "Cropland", "Forest", "Forest",
 "Grassland", "Shrubland", "Herbaceous", "Flooded")

newCats &lt;- data.frame(value = value, label = label)

cover &lt;- categories(cover, layer = 1, value = newCats)
cats(cover)

# This is the same as:
levels(cover) &lt;- newCats
cats(cover)

# Are there any values not assigned a category?
missingCats(cover)

# Let's assign a category for value 210 (water):
water &lt;- data.frame(value = 210, label = "Water")
addCats(cover) &lt;- water
levels(cover)

# Add more information to the levels table using merge():
landType &lt;- data.frame(
     Value = c(20, 30, 40, 50, 120),
     Type = c("Irrigated", "Rainfed", "Broadleaf evergreen",
     "Broadleaf deciduous", "Mosaic with forest")
)
cats(cover)
cover &lt;- addCats(cover, landType, merge = TRUE)
cats(cover)

### Logical operations on categorical rasters

cover &lt; "Forest" # 1 for cells with a value &lt; 40, 0 otherwise
cover &lt;= "Forest" # 1 for cells with a value &lt; 120, 0 otherwise
cover == "Forest" # 1 for cells with value of 40-120, 0 otherwise
cover != "Forest" # 1 for cells with value that is not 40-120, 0 otherwise
cover &gt; "Forest" # 1 for cells with a value &gt; 120, 0 otherwise
cover &gt;= "Forest" # 1 for cells with a value &gt;= 120, 0 otherwise

cover %in% c("Cropland", "Forest") # 1 for cropland/forest cells, 0 otherwise

### Combine categories from different rasters

# For the example, will create a second categorical raster fromm elevation.

# Divide elevation raster into "low/medium/high" levels:
madElev &lt;- fastData("madElev")
elev &lt;- fast(madElev)
elev &lt;- project(elev, cover, method = "near") # convert to same CRS
fun &lt;- "= if(madElev &lt; 100, 0, if(madElev &lt; 400, 1, 2))"
elevCat &lt;- app(elev, fun)

levs &lt;- data.frame(
     value = c(0, 1, 2),
     elevation = c("low", "medium", "high")
)
levels(elevCat) &lt;- list(levs)

# Combine levels:
combined &lt;- concats(cover, elevCat)
combined
levels(combined)

# Combine levels, treating value/NA combinations as new categories:
combinedNA &lt;- concats(cover, elevCat, na.rm = FALSE)
combinedNA
levels(combinedNA)

}
</code></pre>

<hr>
<h2 id='Compare+2CGRaster+2CGRaster-method'>Compare-methods operations on GRasters and GRegions</h2><span id='topic+Compare+2CGRaster+2CGRaster-method'></span><span id='topic+Compare-methods'></span><span id='topic+Compare+2Clogical+2CGRaster-method'></span><span id='topic+Compare+2CGRaster+2Clogical-method'></span><span id='topic+Compare+2Cnumeric+2CGRaster-method'></span><span id='topic+Compare+2CGRaster+2Cnumeric-method'></span><span id='topic+Compare+2CGRaster+2Cinteger-method'></span><span id='topic+Compare+2Cinteger+2CGRaster-method'></span><span id='topic+Compare+2CGRaster+2Ccharacter-method'></span><span id='topic+Compare+2Ccharacter+2CGRaster-method'></span><span id='topic+Compare+2CGRegion+2CGRegion-method'></span>

<h3>Description</h3>

<p>You can do comparative operations on <code>GRaster</code>s using normal operators in <strong>R</strong>: <code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code>, <code>&gt;=</code>, and <code>&gt;</code>. You can also use <code><a href="#topic++25in+25">%in%</a></code> for categorical <code>GRasters</code> (see <code>vignette("GRasters", package = "fasterRaster")</code>).
</p>
<p>You can also compare two <code>GRegion</code>s using the <code>==</code> and <code>!=</code> operators. Most users of <strong>fasterRaster</strong> will not have to work much with &quot;regions&quot; (see <code>vignette("regions", package = "fasterRaster")</code>), so can ignore this functionality. <code>GRegion</code>s are the same if they have the same coordinate reference system, location/project and mapset (see <code>vignette("projects_mapsets", package = "fasterRaster")</code>), topology (2D or 3D), extent, and resolution. If both are 3D, then they must also have the same vertical extent and number of depths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster,GRaster'
Compare(e1, e2)

## S4 method for signature 'logical,GRaster'
Compare(e1, e2)

## S4 method for signature 'GRaster,logical'
Compare(e1, e2)

## S4 method for signature 'numeric,GRaster'
Compare(e1, e2)

## S4 method for signature 'GRaster,numeric'
Compare(e1, e2)

## S4 method for signature 'GRaster,integer'
Compare(e1, e2)

## S4 method for signature 'integer,GRaster'
Compare(e1, e2)

## S4 method for signature 'GRaster,character'
Compare(e1, e2)

## S4 method for signature 'character,GRaster'
Compare(e1, e2)

## S4 method for signature 'GRegion,GRegion'
Compare(e1, e2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Compare+2B2CGRaster+2B2CGRaster-method_+3A_e1">e1</code>, <code id="Compare+2B2CGRaster+2B2CGRaster-method_+3A_e2">e2</code></td>
<td>
<p>Values depend on the type of comparison:
</p>

<ul>
<li><p> Comparing <code>GRaster</code>s to logical, numeric, character values: <code>e1</code> and <code>e2</code> can be any one of these. Comparison to a character string can be useful when using a categorical raster, in which case you can use something like <code>raster1 == "Wetlands"</code> to coerce all &quot;wetland&quot; cells to be 1 (TRUE) and all others 0 (FALSE) or <code>NA</code> (if it was originally <code>NA</code>).
</p>
</li>
<li><p> Comparing a <code>GRegion</code> to another <code>GRegion</code>: <code>e1</code> and <code>e2</code> must be <code>GRegion</code>s!
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Comparing <code>GRaster</code>s: An &quot;integer&quot; <code>GRaster</code> with values of 0 (FALSE), 1 (TRUE), or <code>NA</code> (neither).
</p>
<p>Comparing <code>GRegion</code>s: Output is logical.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")

# Convert a SpatRaster to a GRaster
elev &lt;- fast(madElev)
elevs &lt;- c(elev, elev, log10(elev) - 1, sqrt(elev))
names(elevs) &lt;- c("elev1", "elev2", "log_elev", "sqrt_elev")

elev
elevs

# Comparisons
elev &lt; 100
elev &lt;= 100
elev == 100
elev != 100
elev &gt; 100
elev &gt;= 100

elev + 100 &lt; 2 * elev

elevs &gt; 10
10 &gt; elevs

# logic
elev &lt; 10 | elev &gt; 200
elev &lt; 10 | cos(elev) &gt; 0.9

elev &lt; 10 | TRUE
TRUE | elev &gt; 200

elev &lt; 10 | FALSE
FALSE | elev &gt; 200

elev &lt; 10 &amp; cos(elev) &gt; 0.9

elev &lt; 10 &amp; TRUE
TRUE &amp; elev &gt; 200

elev &lt; 10 &amp; FALSE
FALSE &amp; elev &gt; 200

}
</code></pre>

<hr>
<h2 id='compareGeom+2CGRaster+2CGRaster-method'>Determine if GRasters and/or GVectors are geographically comparable</h2><span id='topic+compareGeom+2CGRaster+2CGRaster-method'></span><span id='topic+compareGeom'></span><span id='topic+compareGeom+2CGVector+2CGVector-method'></span><span id='topic+compareGeom+2CGRaster+2CGVector-method'></span><span id='topic+compareGeom+2CGVector+2CGRaster-method'></span>

<h3>Description</h3>

<p><code>compareGeom()</code> compares geographic metadata between two or more <code>GRaster</code>s and/or <code>GVector</code>s. In many cases, spatial objects must be comparable for them to &quot;interact&quot; (e.g., conducting arithmetic operations, masking, etc.).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster,GRaster'
compareGeom(
  x,
  y,
  ...,
  location = TRUE,
  mapset = TRUE,
  topo = TRUE,
  lyrs = FALSE,
  crs = TRUE,
  ext = TRUE,
  zext = TRUE,
  rowcol = TRUE,
  depths = TRUE,
  res = TRUE,
  zres = TRUE,
  stopOnError = TRUE,
  messages = TRUE
)

## S4 method for signature 'GVector,GVector'
compareGeom(
  x,
  y,
  ...,
  location = TRUE,
  mapset = TRUE,
  topo = FALSE,
  crs = TRUE,
  ext = FALSE,
  zext = FALSE,
  geometry = FALSE,
  stopOnError = TRUE,
  messages = TRUE
)

## S4 method for signature 'GRaster,GVector'
compareGeom(
  x,
  y,
  ...,
  location = TRUE,
  mapset = TRUE,
  topo = FALSE,
  crs = TRUE,
  ext = FALSE,
  zext = FALSE,
  stopOnError = TRUE,
  messages = TRUE
)

## S4 method for signature 'GVector,GRaster'
compareGeom(
  x,
  y,
  ...,
  location = TRUE,
  mapset = TRUE,
  topo = FALSE,
  crs = TRUE,
  ext = FALSE,
  zext = FALSE,
  stopOnError = TRUE,
  messages = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compareGeom+2B2CGRaster+2B2CGRaster-method_+3A_x">x</code>, <code id="compareGeom+2B2CGRaster+2B2CGRaster-method_+3A_y">y</code>, <code id="compareGeom+2B2CGRaster+2B2CGRaster-method_+3A_...">...</code></td>
<td>
<p><code>GRaster</code>s or <code>GVector</code>s. If <code>y</code> is <code>GRaster</code>, then the <code>...</code> must also be <code>GRaster</code>s (or missing). If <code>y</code> is <code>GVector</code>, then the <code>...</code> must also be <code>GVector</code>s (or missing).</p>
</td></tr>
<tr><td><code id="compareGeom+2B2CGRaster+2B2CGRaster-method_+3A_location">location</code>, <code id="compareGeom+2B2CGRaster+2B2CGRaster-method_+3A_mapset">mapset</code></td>
<td>
<p>Logical: Compare <strong>GRASS</strong> &quot;project/location&quot; and &quot;mapsets&quot; (see <code>vignette("projects_mapsets", package = "fasterRaster")</code>). Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="compareGeom+2B2CGRaster+2B2CGRaster-method_+3A_topo">topo</code></td>
<td>
<p>Logical: Test for same topology (2D or 3D). By default, this is <code>TRUE</code> for raster-raster comparisons, and <code>FALSE</code> for all others.</p>
</td></tr>
<tr><td><code id="compareGeom+2B2CGRaster+2B2CGRaster-method_+3A_lyrs">lyrs</code></td>
<td>
<p>Logical (rasters only): Compare number of layers of &quot;stacked&quot; rasters. Note this is different from number of vertical &quot;depths&quot; of a raster. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="compareGeom+2B2CGRaster+2B2CGRaster-method_+3A_crs">crs</code></td>
<td>
<p>Logical: Compare coordinate reference systems. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="compareGeom+2B2CGRaster+2B2CGRaster-method_+3A_ext">ext</code></td>
<td>
<p>Logical: If <code>TRUE</code>, test for same extent. By default, is <code>TRUE</code> for raster-raster comparison and <code>FALSE</code> for all others.</p>
</td></tr>
<tr><td><code id="compareGeom+2B2CGRaster+2B2CGRaster-method_+3A_zext">zext</code></td>
<td>
<p>Logical: Test for same vertical extents (3D only). By default, this is <code>TRUE</code> for raster-raster comparisons, and <code>FALSE</code> for all others.</p>
</td></tr>
<tr><td><code id="compareGeom+2B2CGRaster+2B2CGRaster-method_+3A_rowcol">rowcol</code></td>
<td>
<p>Logical (rasters only): Test for same number of rows and columns. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="compareGeom+2B2CGRaster+2B2CGRaster-method_+3A_depths">depths</code></td>
<td>
<p>Logical (rasters only): Test for same number of depths. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="compareGeom+2B2CGRaster+2B2CGRaster-method_+3A_res">res</code></td>
<td>
<p>Logical (rasters only): Test for same resolution in x- and y-dimensions. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="compareGeom+2B2CGRaster+2B2CGRaster-method_+3A_zres">zres</code></td>
<td>
<p>Logical (rasters only): Test for same resolution in z dimension. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="compareGeom+2B2CGRaster+2B2CGRaster-method_+3A_stoponerror">stopOnError</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), throw an error with an explanation if the objects are not comparable. If <code>FALSE</code> (default), return <code>TRUE</code> or <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="compareGeom+2B2CGRaster+2B2CGRaster-method_+3A_messages">messages</code></td>
<td>
<p>Logical: If <code style="white-space: pre;">&#8288;TRUE (default), display a warning if a condition is not met. This only comes into effect if &#8288;</code>stopOnError<code>is</code>FALSE'.</p>
</td></tr>
<tr><td><code id="compareGeom+2B2CGRaster+2B2CGRaster-method_+3A_geometry">geometry</code></td>
<td>
<p>Logical (vector-vector comparison only): Compare geometry. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical (invisibly): <code>TRUE</code> for no mismatches detected, <code>FALSE</code> for incompatibility), or side effect of throwing an error.
</p>

<hr>
<h2 id='complete.cases+2CGRaster-method'>Rows of a GRaster or GVector's table that have no NAs or that have NAs</h2><span id='topic+complete.cases+2CGRaster-method'></span><span id='topic+complete.cases'></span><span id='topic+complete.cases+2CGVector-method'></span><span id='topic+missing.cases+2CGRaster-method'></span><span id='topic+missing.cases'></span><span id='topic+missing.cases+2CGVector-method'></span>

<h3>Description</h3>

<p>When applied to a categorical <code>GRaster</code>, <code>compete.cases()</code> returns <code>TRUE</code> for each row of the &quot;levels&quot; table that has no <code>NA</code>s in it. In contrast, <code>missing.cases()</code> returns <code>TRUE</code> for each row that has at least one <code>NA</code> in it. If the raster is not categorical, then <code>NA</code> is returned.
</p>
<p>When applied to a <code>GVector</code> with a data table, <code>complete.cases()</code> returns <code>TRUE</code> for each row where there are no <code>NA</code>s. if the <code>GVector</code> has no data table, then a vector of <code>TRUE</code> values the same length as the total number of geometries will be returned. In contrast, <code>missing.cases()</code> returns <code>TRUE</code> for every row that has at least one <code>NA</code> in it. If the <code>GVector</code> has no data table, then a vector of <code>FALSE</code> values is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
complete.cases(..., levels = TRUE)

## S4 method for signature 'GVector'
complete.cases(...)

## S4 method for signature 'GRaster'
missing.cases(..., levels = TRUE)

## S4 method for signature 'GVector'
missing.cases(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="complete.cases+2B2CGRaster-method_+3A_...">...</code></td>
<td>
<p>A <code>GRaster</code> or <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="complete.cases+2B2CGRaster-method_+3A_levels">levels</code></td>
<td>
<p>Logical (<code>GRaster</code>s only): If <code>TRUE</code> (default), then assess only the &quot;value&quot; and <code><a href="#topic+activeCat">activeCat()</a></code> columns of the levels table (see <code><a href="#topic+levels">levels()</a></code>). If <code>FALSE</code>, then assess all columns (see <code><a href="#topic+cats">cats()</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Both <code>complete.cases()</code> and <code>missing.cases()</code> return the same type of object. The output depends on the input:
</p>

<ul>
<li><p> A categorical <code>GRaster</code> with just one layer: A logical vector.
</p>
</li>
<li><p> An integer, float, or double <code>GRaster</code> with just one layer: <code>NA</code>.
</p>
</li>
<li><p> A <code>GRaster</code> with multiple layers: A list with one element per layer with either logical vectors or <code>NA</code>s, as per above.
</p>
</li>
<li><p> A <code>GVector</code> with a data table: A logical vector.
</p>
</li>
<li><p> A <code>GVector</code> without a data table: <code>NA</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+missingCats">missingCats()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Plant specimens (points) and land cover
madDypsis &lt;- fastData("madDypsis")
madCover &lt;- fastData("madCover")

# Convert to GVector and GRaster
dypsis &lt;- fast(madDypsis)
cover &lt;- fast(madCover)

### GVector

# Look at the data table:
as.data.table(dypsis)

# Which rows have no NAs?
complete.cases(dypsis)

# Which rows have at least one NA (opposite of above)?
missing.cases(dypsis)

### GRaster

# Look at the levels table:
levels(cover)

# Which rows of levels table have no NAs?
complete.cases(cover)

# Which rows have at least one NA (opposite of above)?
missing.cases(cover)

}
</code></pre>

<hr>
<h2 id='compositeRGB+2CGRaster-method'>Combine red, green, and blue color bands to make a composite GRaster</h2><span id='topic+compositeRGB+2CGRaster-method'></span><span id='topic+compositeRGB'></span>

<h3>Description</h3>

<p>This function takes as arguments three rasters typically representing red, green, and blue color bands, and returns a single raster with values based on their combination. Typically, this raster should be plotted in grayscale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
compositeRGB(r, g = NULL, b = NULL, levels = 256, dither = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compositeRGB+2B2CGRaster-method_+3A_r">r</code>, <code id="compositeRGB+2B2CGRaster-method_+3A_g">g</code>, <code id="compositeRGB+2B2CGRaster-method_+3A_b">b</code></td>
<td>
<p>Either:
</p>

<ul>
<li><p> One <code>GRaster</code> with one band each for <code>r</code>, <code>g</code>, or <code>b</code> representing red, green, and blue color bands; or
</p>
</li>
<li> <p><code>r</code> is  single <code>GRaster</code> with 3 bands (R, G, and B bands), and <code>g</code> and <code>b</code> are <code>NULL</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="compositeRGB+2B2CGRaster-method_+3A_levels">levels</code></td>
<td>
<p>Either a single value that is an integer, or a vector of integers: Number of levels of red, green, and blue intensities represented in <code>r</code>, <code>g</code>, and <code>b</code>. If a single value is supplied, it is assumed that all three have the same number of levels. If three values are supplied, then they correspond to the R, G, and B bands. The default is 256 (assume that R, G, and B rasters have values between 0 and 255).</p>
</td></tr>
<tr><td><code id="compositeRGB+2B2CGRaster-method_+3A_dither">dither</code></td>
<td>
<p>Logical: If <code>TRUE</code>, apply Floyd-Steinberg dithering. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotRGB">plotRGB()</a></code>, <code><a href="terra.html#topic+plotRGB">terra::plotRGB()</a></code>, <strong>GRASS</strong> manual page for module <code>r.composite</code> (see <code>grassHelp("r.composite")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Example data
madElev &lt;- fastData("madElev") # elevation raster
madLANDSAT &lt;- fastData("madLANDSAT") # multi-layer raster
madRivers &lt;- fastData("madRivers") # lines vector

# Convert SpatRaster to GRaster and SpatVector to GVector
elev &lt;- fast(madElev)
rivers &lt;- fast(madRivers)
landsat &lt;- fast(madLANDSAT)

# Plot:
plot(elev)
plot(rivers, add = TRUE)

# Histograms:
hist(elev)
hist(landsat)

# Plot surface reflectance in RGB:
plotRGB(landsat, 3, 2, 1) # "natural" color
plotRGB(landsat, 4, 1, 2, stretch = "lin") # emphasize near-infrared (vegetation)

# Make composite map from RGB layers and plot in grayscale:
comp &lt;- compositeRGB(r = landsat[[3]], g = landsat[[2]], b = landsat[[1]])
grays &lt;- paste0("gray", 0:100)
plot(comp, col = grays)

}
</code></pre>

<hr>
<h2 id='concats+2CGRaster-method'>Combine values/categories of multiple GRasters into a single GRaster</h2><span id='topic+concats+2CGRaster-method'></span><span id='topic+concats'></span>

<h3>Description</h3>

<p>This function takes from 2 to 10 integer or categorical (factor) <code>GRaster</code>s and creates a single <code>GRaster</code> that has one value per combination of values in the inputs. For example, say that there were two input rasters, with values 1 and 2 in the one raster, and 3 and 4 in the other. If the following combinations of values occurred between the two rasters, then the output raster would be re-coded with the new values:</p>

<table>
<tr>
 <td style="text-align: left;">
   <code>input_raster1</code> </td><td style="text-align: left;"> <code>input_raster2</code> </td><td style="text-align: left;"> <code>output_raster</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   1 </td><td style="text-align: left;"> 3 </td><td style="text-align: left;"> 0 </td>
</tr>
<tr>
 <td style="text-align: left;">
   1 </td><td style="text-align: left;"> 4 </td><td style="text-align: left;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   2 </td><td style="text-align: left;"> 3 </td><td style="text-align: left;"> 2 </td>
</tr>
<tr>
 <td style="text-align: left;">
   2 </td><td style="text-align: left;"> 4 </td><td style="text-align: left;"> 3 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>If the argument <code>na.rm</code> is set to <code>TRUE</code> (which it is, by default), then whenever at least one cell has an <code>NA</code> value, then the output will also have an <code>NA</code> (i.e., a new category number is not created). However, if <code>na.rm</code> is <code>FALSE</code>, then combinations that include an <code>NA</code> are assigned a new category number, unless all values are <code>NA</code> (in which case the output will be <code>NA</code>).
</p>
<p>The difference between this function and <code><a href="#topic+combineLevels">combineLevels()</a></code> is that this one creates a &quot;combined&quot; <code>GRaster</code> with a combined levels table, whereas <code>combineLevels()</code> just merges the levels tables.
</p>
<p>If the inputs are all categorical rasters, then a <code><a href="#topic+levels">levels()</a></code> table will also be returned with the new levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
concats(x, ..., na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="concats+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> with one or more layers, each of which must be have cells that represent integers or categories (factors).</p>
</td></tr>
<tr><td><code id="concats+2B2CGRaster-method_+3A_...">...</code></td>
<td>
<p>Either missing or integer/categorical (factor) <code>GRaster</code>s.</p>
</td></tr>
<tr><td><code id="concats+2B2CGRaster-method_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), then any combinations that include an <code>NA</code> cell will result in an <code>NA</code> cell in the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>. If the inputs are all categorical (factor) rasters, then a levels table will also be returned with the new combined levels.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+combineLevels">combineLevels()</a></code>, <code><a href="terra.html#topic+concats">terra::concats()</a></code>, <code>vignette("GRasters", package = "fasterRaster")</code>, <strong>GRASS</strong> manual page for module <code>r.cross</code> (see <code>grassHelp("r.cross")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data: Land cover raster
madCover &lt;- fastData("madCover")

# Convert categorical SpatRaster to categorical GRaster:
cover &lt;- fast(madCover)

### Properties of categorical rasters

cover # note categories
is.factor(cover) # Is the raster categorical?
nlevels(cover) # number of levels
levels(cover) # just the value and active column
cats(cover) # all columns
minmax(cover) # min/max values
minmax(cover, levels = TRUE) # min/max categories
catNames(cover) # column names of the levels table
missingCats(cover) # categories in table with no values in raster
freq(cover) # frequency of each category (number of cells)
zonalGeog(cover) # geometric statistics

### Active column

# Which column sets the category labels?
activeCat(cover)
activeCat(cover, names = TRUE)

activeCats(c(cover, cover))

# Choose a different column for category labels:
levels(cover)
activeCat(cover) &lt;- 2
levels(cover)

### Managing levels tables

# Remove unused levels:
nlevels(cover)
cover &lt;- droplevels(cover)
nlevels(cover)

# Re-assign levels:
value &lt;- c(20, 30, 40, 50, 120, 130, 140, 170)
label &lt;- c("Cropland", "Cropland", "Forest", "Forest",
 "Grassland", "Shrubland", "Herbaceous", "Flooded")

newCats &lt;- data.frame(value = value, label = label)

cover &lt;- categories(cover, layer = 1, value = newCats)
cats(cover)

# This is the same as:
levels(cover) &lt;- newCats
cats(cover)

# Are there any values not assigned a category?
missingCats(cover)

# Let's assign a category for value 210 (water):
water &lt;- data.frame(value = 210, label = "Water")
addCats(cover) &lt;- water
levels(cover)

# Add more information to the levels table using merge():
landType &lt;- data.frame(
     Value = c(20, 30, 40, 50, 120),
     Type = c("Irrigated", "Rainfed", "Broadleaf evergreen",
     "Broadleaf deciduous", "Mosaic with forest")
)
cats(cover)
cover &lt;- addCats(cover, landType, merge = TRUE)
cats(cover)

### Logical operations on categorical rasters

cover &lt; "Forest" # 1 for cells with a value &lt; 40, 0 otherwise
cover &lt;= "Forest" # 1 for cells with a value &lt; 120, 0 otherwise
cover == "Forest" # 1 for cells with value of 40-120, 0 otherwise
cover != "Forest" # 1 for cells with value that is not 40-120, 0 otherwise
cover &gt; "Forest" # 1 for cells with a value &gt; 120, 0 otherwise
cover &gt;= "Forest" # 1 for cells with a value &gt;= 120, 0 otherwise

cover %in% c("Cropland", "Forest") # 1 for cropland/forest cells, 0 otherwise

### Combine categories from different rasters

# For the example, will create a second categorical raster fromm elevation.

# Divide elevation raster into "low/medium/high" levels:
madElev &lt;- fastData("madElev")
elev &lt;- fast(madElev)
elev &lt;- project(elev, cover, method = "near") # convert to same CRS
fun &lt;- "= if(madElev &lt; 100, 0, if(madElev &lt; 400, 1, 2))"
elevCat &lt;- app(elev, fun)

levs &lt;- data.frame(
     value = c(0, 1, 2),
     elevation = c("low", "medium", "high")
)
levels(elevCat) &lt;- list(levs)

# Combine levels:
combined &lt;- concats(cover, elevCat)
combined
levels(combined)

# Combine levels, treating value/NA combinations as new categories:
combinedNA &lt;- concats(cover, elevCat, na.rm = FALSE)
combinedNA
levels(combinedNA)

}
</code></pre>

<hr>
<h2 id='connectors+2CGVector+2CGVector-method'>Create lines connecting nearest features of two GVectors</h2><span id='topic+connectors+2CGVector+2CGVector-method'></span><span id='topic+connectors'></span>

<h3>Description</h3>

<p><code>connectors()</code> creates a lines <code>GVector</code> which represent the shortest (Great Circle) paths between each feature of one <code>GVector</code> and the nearest feature of another <code>GVector</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector,GVector'
connectors(x, y, minDist = NULL, maxDist = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="connectors+2B2CGVector+2B2CGVector-method_+3A_x">x</code>, <code id="connectors+2B2CGVector+2B2CGVector-method_+3A_y">y</code></td>
<td>
<p><code>GVector</code>s.</p>
</td></tr>
<tr><td><code id="connectors+2B2CGVector+2B2CGVector-method_+3A_mindist">minDist</code>, <code id="connectors+2B2CGVector+2B2CGVector-method_+3A_maxdist">maxDist</code></td>
<td>
<p>Either <code>NULL</code> (default) or numeric values: Ignore features separated by less than or greater than these distances.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GVector</code> with a data table that has the length of each connecting line in meters.
</p>


<h3>See Also</h3>

<p><strong>GRASS</strong> manual for module <code>v.distance</code> (see <code>grassHelp("v.distance")</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)

# Rivers vector and locations of Dypsis plants
madRivers &lt;- fastData("madRivers")
madDypsis &lt;- fastData("madDypsis")

# Convert sf's to GVectors:
dypsis &lt;- fast(madDypsis)
rivers &lt;- fast(madRivers)

### Connections from each point to nearest river
consFromDypsis &lt;- connectors(dypsis, rivers)

plot(rivers, col = "blue")
plot(dypsis, add = TRUE)
plot(consFromDypsis, col = "red", add = TRUE)

### Connections from each river to nearest point
consFromRivers &lt;- connectors(rivers, dypsis)

plot(rivers, col = "blue")
plot(dypsis, add = TRUE)
plot(consFromRivers, col = "red", add = TRUE)

}
</code></pre>

<hr>
<h2 id='convHull+2CGVector-method'>Minimum convex hull around a spatial vector</h2><span id='topic+convHull+2CGVector-method'></span><span id='topic+convHull'></span>

<h3>Description</h3>

<p>Create a minimum convex hull around a spatial vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector'
convHull(x, by = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convHull+2B2CGVector-method_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="convHull+2B2CGVector-method_+3A_by">by</code></td>
<td>
<p>Character: If <code>""</code> (default), then a convex hull is created for all geometries together. Otherwise, this is the name of a field in the vector. Hulls will be created for each set of geometries with the same value in this column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><code>link[terra]{convHull}</code>, <code>link[sf]{st_convex_hull}</code>, module <code>v.hull</code> in <strong>GRASS</strong> (see <code>grassHelp("v.hull")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)

# Points vector of specimens of species in the plant genus Dypsis
madDypsis &lt;- fastData("madDypsis")

# Convert sf to a GVector:
dypsis &lt;- fast(madDypsis)

### Convex hull for all plant specimens together:
ch &lt;- convHull(dypsis)

### Convex hull for each species:
head(dypsis) # See the "rightsHolder" column?
chHolder &lt;- convHull(dypsis, by = "rightsHolder")

### Plot:
plot(dypsis)
plot(ch, add = TRUE)
n &lt;- length(chHolder)
for (i in 1:n) {
   plot(chHolder[[i]], border = i, add = TRUE)
}

}
</code></pre>

<hr>
<h2 id='crds+2CGRaster-method'>Coordinates of a vector&quot;s features or a raster&quot;s cell centers</h2><span id='topic+crds+2CGRaster-method'></span><span id='topic+crds'></span><span id='topic+crds+2CGVector-method'></span><span id='topic+st_coordinates'></span>

<h3>Description</h3>

<p>Returns the coordinates of the center of cells of a <code>GRaster</code> or coordinates of a <code>GVector</code>'s vertices. The output will be a <code>matrix</code>, <code>data.frame</code>, or <code>list</code>. If you want the output to be a &quot;points&quot; <code>GVector</code>, use <code><a href="#topic+as.points">as.points()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
crds(x, z = is.3d(x), na.rm = TRUE)

## S4 method for signature 'GVector'
crds(x, z = is.3d(x))

st_coordinates(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crds+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code> or a <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="crds+2B2CGRaster-method_+3A_z">z</code></td>
<td>
<p>If <code>TRUE</code> (default), return x-, y-, and z-coordinates. If <code>FALSE</code>, just return x- and y-coordinates. For 2-dimensional objects, z-coordinates will all be 0.</p>
</td></tr>
<tr><td><code id="crds+2B2CGRaster-method_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical: If <code>TRUE</code>, remove cells that are <code>NA</code> (<code>GRaster</code>s only).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code>, <code>data.frame</code>, or <code>list</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+crds">terra::crds()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Plant specimens (points), elevation (raster)
madDypsis &lt;- fastData("madDypsis")
madElev &lt;- fastData("madElev")

# Convert a SpatRaster to a GRaster, and sf to a GVector
dypsis &lt;- fast(madDypsis)
elev &lt;- fast(madElev)

### Get coordinates:
dypsisPoints &lt;- crds(dypsis)
elevPoints &lt;- crds(elev)

head(dypsisPoints)
head(elevPoints)

}
</code></pre>

<hr>
<h2 id='crop+2CGRaster-method'>Remove parts of a GRaster or GVector</h2><span id='topic+crop+2CGRaster-method'></span><span id='topic+crop'></span><span id='topic+crop+2CGVector-method'></span>

<h3>Description</h3>

<p><code>crop()</code> removes parts of a <code>GRaster</code> or <code>GVector</code> that fall &quot;outside&quot; another raster or vector. You cannot make the <code>GRaster</code> or <code>GVector</code> larger than it already is (see <code><a href="#topic+extend">extend()</a></code>). Rasters may not be cropped to the exact extent, as the extent will be enlarged to encompass an integer number of cells. If you wish to remove certain cells of a raster, see <code><a href="#topic+mask">mask()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
crop(x, y, fail = TRUE)

## S4 method for signature 'GVector'
crop(x, y, extent = FALSE, fail = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crop+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> or <code>GVector</code> to be cropped.</p>
</td></tr>
<tr><td><code id="crop+2B2CGRaster-method_+3A_y">y</code></td>
<td>
<p>A <code>GRaster</code> or <code>GVector</code> to serve as a template for cropping.</p>
</td></tr>
<tr><td><code id="crop+2B2CGRaster-method_+3A_fail">fail</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), and the cropped object would have zero extent in at least one dimension, then exit the function with an error. If <code>FALSE</code>, then display a warning and return <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="crop+2B2CGRaster-method_+3A_extent">extent</code></td>
<td>
<p>Logical:
</p>

<ul>
<li><p> If <code>y</code> is a &quot;points&quot; <code>GVector</code>: Use the convex hull around <code>y</code> to crop <code>x</code>.
</p>
</li>
<li><p> If <code>y</code> is a &quot;lines&quot; or &quot;polygons&quot; <code>GVector</code>: If <code>TRUE</code>, use the extent of <code>y</code> to crop <code>x</code>.
</p>
</li>
<li><p> if <code>y</code> is a <code>GVector</code>, <code>x</code> will be cropped to the extent of <code>y</code> (<code>extent</code> is ignored).
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Known differences from <code><a href="terra.html#topic+crop">terra::crop()</a></code>:
</p>

<ul>
<li><p> If <code>x</code> and <code>y</code> are &quot;points&quot; vectors, and <code>extent</code> is <code>TRUE</code>, <strong>terra</strong> removes points that fall on the extent boundary. <strong>fasterRaster</strong> does not remove points on the extent boundary.
</p>
</li>
<li><p> If <code>x</code> is a &quot;points&quot; vector and <code>y</code> is a &quot;lines&quot; vectors, and <code>extent</code> is <code>FALSE</code>, <strong>terra</strong> uses the extent of <code>y</code> to crop the points.  <strong>fasterRaster</strong> uses the minimum convex hull of the lines vector.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>GRaster</code> or <code>GVector</code> (or <code>NULL</code> if <code>fail</code> is <code>FALSE</code> and the output would have a zero east-west and/or north-south extent).
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+crop">terra::crop()</a></code>, <code><a href="sf.html#topic+st_crop">sf::st_crop()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Elevation raster
madElev &lt;- fastData("madElev")

# Plant specimen points vector
madDypsis &lt;- fastData("madDypsis")

# Rivers lines vector
madRivers &lt;- fastData("madRivers")

# Polygons vector
madCoast4 &lt;- fastData("madCoast4")
madAnt &lt;- madCoast4[madCoast4$NAME_4 == "Antanambe", ]

# Convert to fasterRaster format:
elev &lt;- fast(madElev)
dypsis &lt;- fast(madDypsis)
rivers &lt;- fast(madRivers)
coast &lt;- fast(madCoast4)
ant &lt;- fast(madAnt)

### Crop raster by vector:
rastByVect &lt;- crop(elev, ant)
plot(elev, col = "gray", legend = FALSE)
plot(rastByVect, add = TRUE)
plot(ant, add = TRUE)

### Crop raster by raster:

# For this example, make the SpatRaster smaller, then crop by this.
templateRast &lt;- crop(madElev, madAnt)

template &lt;- fast(templateRast)
rastByRast &lt;- crop(elev, template)

plot(elev, col = "gray", legend = FALSE)
plot(rastByRast, add = TRUE)

### Crop vector by raster:

# For this example, make the SpatRaster smaller, then crop by this.
templateRast &lt;- crop(madElev, madAnt)

template &lt;- fast(templateRast)
ptsByRast &lt;- crop(dypsis, template)

plot(elev, col = "gray", legend = FALSE)
plot(templateRast, add = TRUE)
plot(dypsis, add = TRUE)
plot(ptsByRast, pch = 21, bg = "red", add = TRUE)

### Crop vector by vector:
ptsSubset &lt;- dypsis[1:10] # use first 10 points as cropping template

# Crop points vector by convex hull around points:
ptsByPts &lt;- crop(dypsis, ptsSubset)
plot(dypsis)
plot(convHull(ptsSubset), lty = "dotted", border = "blue", add = TRUE)
plot(ptsByPts, col = "red", add = TRUE)
plot(ptsSubset, col = "blue", pch = 3, cex = 1.6, add = TRUE)
legend("topleft",
    legend = c("Dypsis", "Selected", "Crop template", "Convex hull"),
    pch = c(16, 16, 3, NA),
    lwd = c(NA, NA, NA, 1),
    col = c("black", "red", "blue", "blue"),
    lty = c(NA, NA, NA, "dotted"),
    xpd = NA,
    bg = "white"
)

# Crop points vector by extent of points:
ptsByPts &lt;- crop(dypsis, ptsSubset, ext = TRUE)
plot(dypsis)
plot(ptsByPts, col = "red", add = TRUE)
plot(ptsSubset, col = "blue", pch = 3, cex = 1.6, add = TRUE)
legend("topleft",
    legend = c("Dypsis", "Selected", "Crop template"),
    pch = c(16, 16, 3),
    lwd = c(NA, NA, NA),
    col = c("black", "red", "blue"),
    lty = c(NA, NA, NA),
    xpd = NA,
    bg = "white"
)

# Crop points vector by convex hull around lines:
ptsByPts &lt;- crop(dypsis, rivers)
plot(rivers, col = "blue", pch = 3, cex = 1.6)
plot(dypsis, add = TRUE)
plot(convHull(rivers), lty = "dotted", border = "blue", add = TRUE)
plot(ptsByPts, col = "red", add = TRUE)
legend("topleft",
    legend = c("Dypsis", "Selected", "Rivers", "Convex hull"),
    pch = c(16, 16, NA, NA),
    lwd = c(NA, NA, 1, 1),
    col = c("black", "red", "blue", "blue"),
    lty = c(NA, NA, "solid", "dotted"),
    xpd = NA,
    bg = "white"
)

# Crop points vector by extent of lines:
ptsByPts &lt;- crop(dypsis, rivers, ext = TRUE)
plot(rivers, col = "blue", pch = 3, cex = 1.6)
plot(dypsis, add = TRUE)
plot(convHull(rivers), lty = "dotted", border = "blue", add = TRUE)
plot(ptsByPts, col = "red", add = TRUE)
legend("topleft",
    legend = c("Dypsis", "Selected", "Rivers"),
    pch = c(16, 16, NA),
    lwd = c(NA, NA, 1),
    col = c("black", "red", "blue"),
    lty = c(NA, NA, "solid"),
    xpd = NA,
    bg = "white"
)

# Crop points vector by polygon:
ptsByPts &lt;- crop(dypsis, ant)
plot(dypsis)
plot(ant, border = "blue", pch = 3, cex = 1.6, add = TRUE)
plot(ptsByPts, col = "red", add = TRUE)
legend("topleft",
    legend = c("Dypsis", "Selected", "Antanambe"),
    pch = c(16, 16, NA),
    lwd = c(NA, NA, 1),
    col = c("black", "red", "blue"),
    lty = c(NA, NA, "solid"),
    xpd = NA,
    bg = "white"
)

# Crop lines vector by polygon:
linesByPoly &lt;- crop(rivers, ant)
plot(rivers)
plot(ant, border = "blue", pch = 3, cex = 1.6, add = TRUE)
plot(linesByPoly, col = "red", add = TRUE)
legend("topleft",
    legend = c("Rivers", "Selected", "Antanambe"),
    col = c("black", "red", "blue"),
    lwd = 1,
    xpd = NA,
    bg = "white"
)

# Crop polygon vector by convex hull around points:
polyByPoints &lt;- crop(ant, dypsis)
plot(dypsis, col = "red")
plot(ant, border = "blue", add = TRUE)
plot(polyByPoints, border = "red", add = TRUE)
legend("topleft",
    legend = c("Dypsis", "Antanambe", "Selected"),
    col = c("red", "blue", "red"),
    pch = c(16, NA, NA),
    lwd = c(NA, 1, 1),
    xpd = NA,
    bg = "white"
)

}
</code></pre>

<hr>
<h2 id='crs+2Cmissing-method'>Coordinate reference system of a GRaster or GVector</h2><span id='topic+crs+2Cmissing-method'></span><span id='topic+crs'></span><span id='topic+crs+2CGLocation-method'></span><span id='topic+st_crs+2Cmissing-method'></span><span id='topic+st_crs'></span><span id='topic+st_crs+2CGLocation-method'></span><span id='topic+coordRef+2Cmissing-method'></span><span id='topic+coordRef'></span><span id='topic+coordRef+2CGRaster-method'></span><span id='topic+coordRef+2CGVector-method'></span>

<h3>Description</h3>

<p>Get the coordinate reference system (CRS) of a <code>GRaster</code> or <code>GVector</code>s, or from the currently active <strong>GRASS</strong> &quot;project/location&quot; (see <code>vignette("projects_mapsets", package = "fasterRaster")</code>):
</p>

<ul>
<li> <p><code>crs()</code>: Return a WKT string (an object of class <code>character</code>).
</p>
</li>
<li> <p><code>st_crs()</code>: Return a <code>crs</code> object (from the <strong>sf</strong> package).
</p>
</li>
<li> <p><code>coordRef()</code>: Return a <code>list</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'missing'
crs(x)

## S4 method for signature 'GLocation'
crs(x)

## S4 method for signature 'missing'
st_crs(x, ...)

## S4 method for signature 'GLocation'
st_crs(x, ...)

st_crs(x, ...)

## S4 method for signature 'missing'
coordRef(x)

## S4 method for signature 'GRaster'
coordRef(x)

## S4 method for signature 'GVector'
coordRef(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crs+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>An object that inherits from a <code>GLocation</code> (i.e., a <code>GRaster</code> or <code>GVector</code>) or missing. If missing, the coordinate reference system of the currently active <strong>GRASS</strong> &quot;project/location&quot; is reported.</p>
</td></tr>
<tr><td><code id="crs+2B2Cmissing-method_+3A_...">...</code></td>
<td>
<p>Other arguments (generally unused).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>crs()</code> returns a <code>character</code> object, <code>st_crs()</code> returns <code>crs</code> object, and <code>coordRef()</code> a <code>list</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+crs">terra::crs()</a></code>, <code><a href="sf.html#topic+st_crs">sf::st_crs()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")
madForest2000 &lt;- fastData("madForest2000")

# Convert SpatRasters to GRasters
elev &lt;- fast(madElev)
forest &lt;- fast(madForest2000)

### GRaster properties

# plotting
plot(elev)

# dimensions
dim(elev) # rows, columns, depths, layers
nrow(elev) # rows
ncol(elev) # columns
ndepth(elev) # depths
nlyr(elev) # layers

res(elev) # resolution (2D)
res3d(elev) # resolution (3D)
zres(elev) # vertical resolution
xres(elev) # vertical resolution
yres(elev) # vertical resolution
zres(elev) # vertical resolution (NA because this is a 2D GRaster)

# cell counts
ncell(elev) # cells
ncell3d(elev) # cells (3D rasters only)

# number of NA and non-NA cells
nacell(elev)
nonnacell(elev)

# topology
topology(elev) # number of dimensions
is.2d(elev) # is it 2-dimensional?
is.3d(elev) # is it 3-dimensional?

minmax(elev) # min/max values

# "names" of the object
names(elev)

# coordinate reference system
crs(elev)
st_crs(elev)
coordRef(elev)

# extent (bounding box)
ext(elev)

# vertical extent (not defined for this raster)
zext(elev)

# data type
datatype(elev) # fasterRaster type
datatype(elev, "GRASS") # GRASS type
datatype(elev, "terra") # terra type
datatype(elev, "GDAL") # GDAL type

is.integer(elev)
is.float(elev)
is.double(elev)
is.factor(elev)

# convert data type
as.int(elev) # integer; note that "elev" is already of type "integer"
as.float(elev) # floating-precision
as.doub(elev) # double-precision

# assigning
pie &lt;- elev
pie[] &lt;- pi # assign all cells to the value of pi
pie

# concatenating multiple GRasters
rasts &lt;- c(elev, forest)
rasts

# subsetting
rasts[[1]]
rasts[["madForest2000"]]

# replacing
rasts[[2]] &lt;- 2 * forest
rasts

# adding layers
rasts[[3]] &lt;- elev &gt; 500 # add a layer
rasts &lt;- c(rasts, sqrt(elev)) # add another
add(rasts) &lt;- ln(elev)
rasts

# names
names(rasts)
names(rasts) &lt;- c("elev_meters", "2_x_forest", "high_elevation", "sqrt_elev", "ln_elev")
rasts

# remove a layer
rasts[["2_x_forest"]] &lt;- NULL
rasts

# number of layers
nlyr(rasts)

# correlation and covariance matrices
madLANDSAT &lt;- fastData("madLANDSAT")
landsat &lt;- fast(madLANDSAT) # projects matrix
layerCor(landsat) # correlation
layerCor(landsat, fun = 'cov') # covariance

}
</code></pre>

<hr>
<h2 id='datatype+2CGRaster-method'>Get the datatype of a GRaster or of GVector columns</h2><span id='topic+datatype+2CGRaster-method'></span><span id='topic+datatype'></span><span id='topic+datatype+2CGVector-method'></span>

<h3>Description</h3>

<p>For <code>GRaster</code>s, <code>datatype()</code> returns the data type (see <code>vignette("GRasters", package = "fasterRaster")</code>). For <code>GVector</code>s, <code>datatype()</code> returns the class of each column of the attribute table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
datatype(x, type = "fasterRaster", forceDouble = TRUE)

## S4 method for signature 'GVector'
datatype(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="datatype+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> or <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="datatype+2B2CGRaster-method_+3A_type">type</code></td>
<td>
<p>(<code>GRaster</code>s only) <code>NULL</code> or character: Type of datatype to report (<code>GRaster</code> only):
</p>

<ul>
<li> <p><code>"fasterRaster"</code> (default): Reports the <strong>fasterRaster</strong> type (factor, integer, float, or double)
</p>
</li>
<li> <p><code>"terra"</code>: Report the (inferred) <strong>terra</strong> data type (e.g., INT2U, FLT4S). Please see the table in the documentation for [writeRaster()' for an explanation of these codes.
</p>
</li>
<li> <p><code>"GRASS"</code>: Will return &quot;CELL&quot; (integer), &quot;FCELL&quot; (floating-point value), or &quot;DCELL&quot; (double-floating point value)
</p>
</li>
<li> <p><code>"GDAL"</code>: See <a href="https://gdal.org/en/stable/user/raster_data_model.html">GDAL: Raster Band</a>. Please also see the table in the <code><a href="#topic+writeRaster">writeRaster()</a></code> help page.
</p>
</li></ul>
</td></tr>
<tr><td><code id="datatype+2B2CGRaster-method_+3A_forcedouble">forceDouble</code></td>
<td>
<p>Logical (<code>GRaster</code>s and <code>SpatRaster</code>s only): If <code>TRUE</code> (default), and the raster appears to represent non-integer values, then the raster will be assumed to represent double-floating point values (<strong>GRASS</strong>: type &quot;DCELL&quot;, <strong>terra</strong>: type &quot;FLT8S&quot;, <strong>fasterRaster</strong>: type &quot;double&quot;, and <strong>GDAL</strong>: type &quot;Float64&quot;). <code>forceDouble</code> reports the actual datatype if <code>type = "fasterRaster"</code> (i.e., the type is not forced to &quot;double&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>datatype()</code> for a <code>GRaster</code> returns a character. <code>datatype()</code> for a <code>GVector</code> returns a data frame, with one row per field. If the <code>GVector</code> has no attribute table, the function returns <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+datatype">terra::datatype()</a></code>, <code>vignette("GRasters", package = "fasterRaster")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Example data
madElev &lt;- fastData("madElev")
madForest2000 &lt;- fastData("madForest2000")
madCoast0 &lt;- fastData("madCoast0")
madRivers &lt;- fastData("madRivers")
madDypsis &lt;- fastData("madDypsis")

### GRaster properties

# convert SpatRasters to GRasters
elev &lt;- fast(madElev)
forest &lt;- fast(madForest2000)

# plot
plot(elev)

dim(elev) # rows, columns, depths, layers
nrow(elev) # rows
ncol(elev) # columns
ndepth(elev) # depths
nlyr(elev) # layers

res(elev) # resolution

ncell(elev) # cells
ncell3d(elev) # cells (3D rasters only)

topology(elev) # number of dimensions
is.2d(elev) # is it 2D?
is.3d(elev) # is it 3D?

minmax(elev) # min/max values

# name of object in GRASS
sources(elev)

# "names" of the object
names(elev)

# coordinate reference system
crs(elev)

# extent (bounding box)
ext(elev)

# data type
datatype(elev)

# assigning
copy &lt;- elev
copy[] &lt;- pi # assign all cells to the value of pi
copy

# concatenating multiple GRasters
rasts &lt;- c(elev, forest)
rasts

# adding a raster "in place"
add(rasts) &lt;- ln(elev)
rasts

# subsetting
rasts[[1]]
rasts[["madForest2000"]]

# assigning
rasts[[4]] &lt;- elev &gt; 500

# number of layers
nlyr(rasts)

# names
names(rasts)
names(rasts) &lt;- c("elev_meters", "forest", "ln_elev", "high_elevation")
rasts

### GVector properties

# convert sf vectors to GVectors
coast &lt;- fast(madCoast4)
rivers &lt;- fast(madRivers)
dypsis &lt;- fast(madDypsis)

# extent
ext(rivers)

W(rivers) # western extent
E(rivers) # eastern extent
S(rivers) # southern extent
N(rivers) # northern extent
top(rivers) # top extent (NA for 2D rasters like this one)
bottom(rivers) # bottom extent (NA for 2D rasters like this one)

# coordinate reference system
crs(rivers)
st_crs(rivers)

# column names and data types
names(coast)
datatype(coast)

# name of object in GRASS
sources(rivers)

# points, lines, or polygons?
geomtype(dypsis)
geomtype(rivers)
geomtype(coast)

is.points(dypsis)
is.points(coast)

is.lines(rivers)
is.lines(dypsis)

is.polygons(coast)
is.polygons(dypsis)

# dimensions
nrow(rivers) # how many spatial features
ncol(rivers) # hay many columns in the data frame

# number of geometries and sub-geometries
ngeom(coast)
nsubgeom(coast)

# 2- or 3D
topology(rivers) # dimensionality
is.2d(elev) # is it 2D?
is.3d(elev) # is it 3D?

# Update values from GRASS
# (Reads values from GRASS... will not appear to do anything in this case)
coast &lt;- update(coast)

### operations on GVectors

# convert to data frame
as.data.frame(rivers)
as.data.table(rivers)

# subsetting
rivers[c(1:2, 5)] # select 3 rows/geometries
rivers[-5:-11] # remove rows/geometries 5 through 11
rivers[ , 1] # column 1
rivers[ , "NAM"] # select column
rivers[["NAM"]] # select column
rivers[1, 2:3] # row/geometry 1 and column 2 and 3
rivers[c(TRUE, FALSE)] # select every other geometry (T/F vector is recycled)
rivers[ , c(TRUE, FALSE)] # select every other column (T/F vector is recycled)

# removing data table
noTable &lt;- dropTable(rivers)
noTable
nrow(rivers)
nrow(noTable)

# Refresh values from GRASS
# (Reads values from GRASS... will not appear to do anything in this case
# since the rivers object is up-to-date):
rivers &lt;- update(rivers)

# Concatenating multiple vectors
rivers2 &lt;- rbind(rivers, rivers)
dim(rivers)
dim(rivers2)

}
</code></pre>

<hr>
<h2 id='delaunay+2CGVector-method'>Delaunay triangulation for points</h2><span id='topic+delaunay+2CGVector-method'></span><span id='topic+delaunay'></span>

<h3>Description</h3>

<p>This function creates a Delaunay triangulation from a &quot;points&quot; <code>GVector</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector'
delaunay(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delaunay+2B2CGVector-method_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code> &quot;points&quot; object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+voronoi">terra::delaunay()</a></code>, module <code>v.delaunay</code> in <strong>GRASS</strong>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)

# Example vectors
madDypsis &lt;- fastData("madDypsis") # points
madCoast4 &lt;- fastData("madCoast4") # polygons

# Convert sf vectors to GVectors
dypsis &lt;- fast(madDypsis)
coast4 &lt;- fast(madCoast4)
ant &lt;- coast4[coast4$NAME_4 == "Antanambe"]

# Delaunay triangulation
dypsisDel &lt;- delaunay(dypsis)
plot(dypsisDel)
plot(dypsis, pch = 1, col = "red", add = TRUE)

# Voronoi tessellation
vor &lt;- voronoi(dypsis)
plot(vor)
plot(dypsis, pch = 1, col = "red", add = TRUE)

# Random Voronoi tessellation
rand &lt;- rvoronoi(coast4, size = 100)
plot(rand)

}
</code></pre>

<hr>
<h2 id='denoise+2CGRaster-method'>Remove or retain &quot;noise&quot; in a raster using PCA</h2><span id='topic+denoise+2CGRaster-method'></span><span id='topic+denoise'></span><span id='topic+noise+2CGRaster-method'></span><span id='topic+noise'></span>

<h3>Description</h3>

<p><code>denoise()</code> applies a principal component analysis (PCA) to layers of a <code>GRaster</code>, then uses the PCA to predict values back to a raster. This retains only coarse-scale trends, thereby removing &quot;noise&quot; (locally extreme values that fall far from a PC axis).
</p>
<p><code>noise()</code> does the opposite by first constructing the PCA, predicting values back to the raster, then subtracting these values from the original, removing coarse-scale trends and thereby leaving &quot;noise&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
denoise(x, scale = FALSE, percent = 80)

## S4 method for signature 'GRaster'
noise(x, scale = FALSE, percent = 80)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="denoise+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> with two or more layers.</p>
</td></tr>
<tr><td><code id="denoise+2B2CGRaster-method_+3A_scale">scale</code></td>
<td>
<p>Logical: If <code>TRUE</code>, input layers will be rescaled by dividing each layer by its overall population standard deviation. Note that rasters will always be centered (have their mean subtracted from values). Centering and scaling is recommended when rasters values are in different units. The default is <code>FALSE</code> (do not scale).</p>
</td></tr>
<tr><td><code id="denoise+2B2CGRaster-method_+3A_percent">percent</code></td>
<td>
<p>Numeric integer or integer in the range 50 to 99 (default is 80): Minimum total variation explained in the retained PC axes. Higher values will cause <code>denoise()</code> to remove less noise, and <code>noise()</code> to return less noise. If this value to too low to retain even one axis, the function will fail with a message to that effect.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A multi-layer <code>GRaster</code> with one layer per input.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+princomp">princomp()</a></code>, <code><a href="stats.html#topic+prcomp">stats::prcomp()</a></code>, <strong>GRASS</strong> manual page for module <code>i.pca</code> (see <code>grassHelp("i.pca")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Climate raster:
madChelsa &lt;- fastData("madChelsa")

# Convert a SpatRaster to a GRaster:
chelsa &lt;- fast(madChelsa)

### Denoise:
quiet &lt;- denoise(chelsa, scale = TRUE)

compare1 &lt;- c(chelsa[["bio1"]], quiet[["bio1"]])
plot(compare1)

compare2 &lt;- c(chelsa[["bio7"]], quiet[["bio7"]])
plot(compare2)

### Noise:
loud &lt;- noise(chelsa, scale = TRUE)

compare1 &lt;- c(chelsa[["bio1"]], loud[["bio1"]])
plot(compare1)

compare2 &lt;- c(chelsa[["bio7"]], loud[["bio7"]])
plot(compare2)

}
</code></pre>

<hr>
<h2 id='dim+2CGRegion-method'>Number of rows, columns, depths, cells, and layers</h2><span id='topic+dim+2CGRegion-method'></span><span id='topic+dim'></span><span id='topic+dim3d+2Cmissing-method'></span><span id='topic+dim3d'></span><span id='topic+dim3d+2CGRegion-method'></span><span id='topic+nrow+2Cmissing-method'></span><span id='topic+nrow'></span><span id='topic+nrow+2CGRegion-method'></span><span id='topic+ncol+2Cmissing-method'></span><span id='topic+ncol'></span><span id='topic+ncol+2CGRegion-method'></span><span id='topic+ndepth+2Cmissing-method'></span><span id='topic+ndepth'></span><span id='topic+ndepth+2CGRegion-method'></span><span id='topic+ncell+2Cmissing-method'></span><span id='topic+ncell'></span><span id='topic+ncell+2CGRegion-method'></span><span id='topic+ncell3d+2Cmissing-method'></span><span id='topic+ncell3d'></span><span id='topic+ncell3d+2CGRegion-method'></span><span id='topic+dim+2CGVector-method'></span><span id='topic+nrow+2CGVector-method'></span><span id='topic+ncol+2CGVector-method'></span><span id='topic+nlyr+2Cmissing-method'></span><span id='topic+nlyr'></span><span id='topic+nlyr+2CGRaster-method'></span>

<h3>Description</h3>

<p>For <code>GRegion</code>s: Number of rows, columns, depths, and cells:
</p>

<ul>
<li> <p><code>dim()</code>: Rows and columns
</p>
</li>
<li> <p><code>dim3d()</code>: Rows, columns, and depths
</p>
</li>
<li> <p><code>nrow()</code>: Rows
</p>
</li>
<li> <p><code>ncol()</code>: Columns
</p>
</li>
<li> <p><code>ndepth()</code>: Depths (for 3-dimensional rasters only)
</p>
</li>
<li> <p><code>ncell()</code>: Number of cells (2 dimensions)
</p>
</li>
<li> <p><code>ncell3d()</code>: Number of cells (3 dimensions)
</p>
</li></ul>

<p>For <code>GRaster</code>s: As above, plus number of layers:
</p>

<ul>
<li> <p><code>nlyr()</code>: Layers (number of &quot;stacked&quot; rasters&ndash;different from depths of a raster).
</p>
</li></ul>

<p>For <code>GVector</code>s: Number of geometries and fields (columns):
</p>

<ul>
<li> <p><code>dim()</code>: Number of geometries and number of columns in data table
</p>
</li>
<li> <p><code>nrow()</code>: Number of geometries
</p>
</li>
<li> <p><code>ncol()</code>: Number of columns in data table
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRegion'
dim(x)

## S4 method for signature 'missing'
dim3d(x)

## S4 method for signature 'GRegion'
dim3d(x)

## S4 method for signature 'missing'
nrow(x)

## S4 method for signature 'GRegion'
nrow(x)

## S4 method for signature 'missing'
ncol(x)

## S4 method for signature 'GRegion'
ncol(x)

## S4 method for signature 'missing'
ndepth(x)

## S4 method for signature 'GRegion'
ndepth(x)

## S4 method for signature 'missing'
ncell(x)

## S4 method for signature 'GRegion'
ncell(x)

## S4 method for signature 'missing'
ncell3d(x)

## S4 method for signature 'GRegion'
ncell3d(x)

## S4 method for signature 'GVector'
dim(x)

## S4 method for signature 'GVector'
nrow(x)

## S4 method for signature 'GVector'
ncol(x)

## S4 method for signature 'missing'
nlyr(x)

## S4 method for signature 'GRaster'
nlyr(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dim+2B2CGRegion-method_+3A_x">x</code></td>
<td>
<p>A <code>GRegion</code>, <code>GRaster</code>, <code>GVector</code>, or missing. If missing, then the dimensions of the currently active &quot;region&quot; are returned (see <code>vignette("regions", package = "fasterRaster")</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value or vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ngeom">ngeom()</a></code>, <code><a href="#topic+nsubgeom">nsubgeom()</a></code>, <code><a href="#topic+nacell">nacell()</a></code>, <code><a href="#topic+nonnacell">nonnacell()</a></code>, <code><a href="terra.html#topic+dimensions">terra::dim()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Example data
madElev &lt;- fastData("madElev")
madForest2000 &lt;- fastData("madForest2000")
madCoast0 &lt;- fastData("madCoast0")
madRivers &lt;- fastData("madRivers")
madDypsis &lt;- fastData("madDypsis")

### GRaster properties

# convert SpatRasters to GRasters
elev &lt;- fast(madElev)
forest &lt;- fast(madForest2000)

# plot
plot(elev)

dim(elev) # rows, columns, depths, layers
nrow(elev) # rows
ncol(elev) # columns
ndepth(elev) # depths
nlyr(elev) # layers

res(elev) # resolution

ncell(elev) # cells
ncell3d(elev) # cells (3D rasters only)

topology(elev) # number of dimensions
is.2d(elev) # is it 2D?
is.3d(elev) # is it 3D?

minmax(elev) # min/max values

# name of object in GRASS
sources(elev)

# "names" of the object
names(elev)

# coordinate reference system
crs(elev)

# extent (bounding box)
ext(elev)

# data type
datatype(elev)

# assigning
copy &lt;- elev
copy[] &lt;- pi # assign all cells to the value of pi
copy

# concatenating multiple GRasters
rasts &lt;- c(elev, forest)
rasts

# adding a raster "in place"
add(rasts) &lt;- ln(elev)
rasts

# subsetting
rasts[[1]]
rasts[["madForest2000"]]

# assigning
rasts[[4]] &lt;- elev &gt; 500

# number of layers
nlyr(rasts)

# names
names(rasts)
names(rasts) &lt;- c("elev_meters", "forest", "ln_elev", "high_elevation")
rasts

### GVector properties

# convert sf vectors to GVectors
coast &lt;- fast(madCoast4)
rivers &lt;- fast(madRivers)
dypsis &lt;- fast(madDypsis)

# extent
ext(rivers)

W(rivers) # western extent
E(rivers) # eastern extent
S(rivers) # southern extent
N(rivers) # northern extent
top(rivers) # top extent (NA for 2D rasters like this one)
bottom(rivers) # bottom extent (NA for 2D rasters like this one)

# coordinate reference system
crs(rivers)
st_crs(rivers)

# column names and data types
names(coast)
datatype(coast)

# name of object in GRASS
sources(rivers)

# points, lines, or polygons?
geomtype(dypsis)
geomtype(rivers)
geomtype(coast)

is.points(dypsis)
is.points(coast)

is.lines(rivers)
is.lines(dypsis)

is.polygons(coast)
is.polygons(dypsis)

# dimensions
nrow(rivers) # how many spatial features
ncol(rivers) # hay many columns in the data frame

# number of geometries and sub-geometries
ngeom(coast)
nsubgeom(coast)

# 2- or 3D
topology(rivers) # dimensionality
is.2d(elev) # is it 2D?
is.3d(elev) # is it 3D?

# Update values from GRASS
# (Reads values from GRASS... will not appear to do anything in this case)
coast &lt;- update(coast)

### operations on GVectors

# convert to data frame
as.data.frame(rivers)
as.data.table(rivers)

# subsetting
rivers[c(1:2, 5)] # select 3 rows/geometries
rivers[-5:-11] # remove rows/geometries 5 through 11
rivers[ , 1] # column 1
rivers[ , "NAM"] # select column
rivers[["NAM"]] # select column
rivers[1, 2:3] # row/geometry 1 and column 2 and 3
rivers[c(TRUE, FALSE)] # select every other geometry (T/F vector is recycled)
rivers[ , c(TRUE, FALSE)] # select every other column (T/F vector is recycled)

# removing data table
noTable &lt;- dropTable(rivers)
noTable
nrow(rivers)
nrow(noTable)

# Refresh values from GRASS
# (Reads values from GRASS... will not appear to do anything in this case
# since the rivers object is up-to-date):
rivers &lt;- update(rivers)

# Concatenating multiple vectors
rivers2 &lt;- rbind(rivers, rivers)
dim(rivers)
dim(rivers2)

}
</code></pre>

<hr>
<h2 id='disagg+2CGVector-method'>Coerce as multipart GVector to a singlepart GVector</h2><span id='topic+disagg+2CGVector-method'></span><span id='topic+disagg'></span>

<h3>Description</h3>

<p><code>GVectors</code> can contain a mix of &quot;singlepart&quot; and &quot;multipart&quot; features. A singlepart feature is a single point, set of connected line segments, or a polygon. A multipart feature is a set of lines, sets of connected line segments, or set of polygons that are treated as a single feature. This function converts all multipart features to singlepart features. If the <code>GVector</code> has an attribute table, rows will be duplicated so that each of the new <code>GVector</code>'s geometries have the rows that correspond to their &quot;parent&quot; geometries.
</p>
<p>If you want to &quot;split&quot; cells of a <code>GRaster</code> into smaller cells, use <code><a href="#topic+aggregate">aggregate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector'
disagg(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disagg+2B2CGVector-method_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aggregate">aggregate()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")
madCoast4 &lt;- fastData("madCoast4")

### aggregating a GRaster

# Convert:
elev &lt;- fast(madElev)

### Aggregate GRaster by same factor in 2 dimensions
# fasterRaster
agg2 &lt;- aggregate(elev, 2, "mean")
agg2

# Compare rasters aggregated by fasterRaster and terra.
# These should be the same.
agg2terra &lt;- aggregate(madElev, 2)

agg2 &lt;- rast(agg2)
agg2 &lt;- extend(agg2, agg2terra)
agg2 - agg2terra # value is ~0

### Aggregate GRaster by a non-integer factor in 2 dimensions
# fasterRaster
agg2.9 &lt;- aggregate(elev, 2.9, "mean")
agg2.9

# terra
agg2.9terra &lt;- aggregate(madElev, 2.9, "mean")
agg2.9terra

# Compare rasters aggregated by fasterRaster and terra.
# These should be different.
res(agg2.9)
res(agg2.9terra) # terra rounds aggregation factor down
2 * res(madElev) # original resolution multiplied by 2

### Aggregate GRaster by different factor in 2 dimensions
agg2x3 &lt;- aggregate(elev, c(2, 3), "mean")
agg2x3

### aggregating a GVector

madCoast4 &lt;- fastData("madCoast4")

# Convert:
coast4 &lt;- fast(madCoast4)

# Aggregate and disaggregate:
aggCoast &lt;- aggregate(coast4)
disaggCoast &lt;- disagg(coast4)

ngeom(coast4)
ngeom(aggCoast)
ngeom(disaggCoast)

# plot
oldpar &lt;- par(mfrow = c(1, 3))
plot(coast4, main = "Original", col = 1:nrow(coast4))
plot(aggCoast, main = "Aggregated", col = 1:nrow(aggCoast))
plot(disaggCoast, main = "Disaggregated", col = 1:nrow(disaggCoast))
par(oldpar)

}
</code></pre>

<hr>
<h2 id='distance+2CGRaster+2Cmissing-method'>Geographic distance</h2><span id='topic+distance+2CGRaster+2Cmissing-method'></span><span id='topic+distance'></span><span id='topic+distance+2CGRaster+2CGVector-method'></span><span id='topic+distance+2CGVector+2CGVector-method'></span><span id='topic+distance+2CGVector+2Cmissing-method'></span>

<h3>Description</h3>

<p>This function produces a raster or a matrix of geographic distances, depending on the input:
</p>
<p><strong>Case 1: Argument <code>x</code> is a <code>GRaster</code> and <code>y</code> is missing:</strong> By default, this function replaces values in all <code>NA</code> cells with the distance between them and their closest non-<code>NA</code> cell. Alternatively, all non-<code>NA</code> cells can have their values replaced by the distance to <code>NA</code> cells. You can also specify which cells (by value) have their values replaced by distance to other cells.
</p>
<p><strong>Case 2: Argument <code>x</code> is a <code>GRaster</code> and <code>y</code> is a <code>GVector</code>:</strong> All cells in the raster have their value replaced by the distance to the nearest features in the <code>GVector</code>. Alternatively, calculate the distance from any cell covered by a vector object and the nearest cell <em>not</em> covered by a vector object. Note that the vector is rasterized first.
</p>
<p><strong>Case 3: Argument <code>x</code> is a <code>GVector</code> and <code>y</code> is a <code>GVector</code>:</strong> A matrix of pairwise distances between all features in one versus the other <code>GVector</code> is returned.
</p>
<p><strong>Case 4: Argument <code>x</code> is a <code>GVector</code> and <code>y</code> is missing:</strong> A matrix of pairwise distances between all features in the <code>GVector</code> is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster,missing'
distance(
  x,
  y,
  target = NA,
  fillNA = TRUE,
  unit = "meters",
  method = ifelse(is.lonlat(x), "geodesic", "Euclidean"),
  minDist = NULL,
  maxDist = NULL
)

## S4 method for signature 'GRaster,GVector'
distance(
  x,
  y,
  fillNA = TRUE,
  thick = TRUE,
  unit = "meters",
  method = ifelse(is.lonlat(x), "geodesic", "Euclidean"),
  minDist = NULL,
  maxDist = NULL
)

## S4 method for signature 'GVector,GVector'
distance(x, y, unit = "meters", minDist = NULL, maxDist = NULL)

## S4 method for signature 'GVector,missing'
distance(x, y, unit = "meters", minDist = NULL, maxDist = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance+2B2CGRaster+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> or <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="distance+2B2CGRaster+2B2Cmissing-method_+3A_y">y</code></td>
<td>
<p>Either missing, or a <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="distance+2B2CGRaster+2B2Cmissing-method_+3A_target">target</code></td>
<td>
<p>Numeric: Only applicable for case 1, when <code>x</code> is a <code>GRaster</code> and <code>y</code> is missing.  If this is <code>NA</code> (default), then cells with <code>NA</code>s have their values replaced with the distance to the nearest non-<code>NA</code> cell. If this is another value, then cells with these values have their values replaced with the distance to any other cell (meaning, both <code>NA</code> and non-<code>NA</code>, except for cells with this value).</p>
</td></tr>
<tr><td><code id="distance+2B2CGRaster+2B2Cmissing-method_+3A_fillna">fillNA</code></td>
<td>
<p>Logical: Determines which raster cells to fill with distances.
</p>

<ul>
<li><p> Case 1, when <code>x</code> is a <code>GRaster</code> and <code>y</code> is missing: If <code>TRUE</code> (default), fill values of <code>NA</code> cells with distances to non-<code>NA</code> cells. If <code>FALSE</code>, fill non-<code>NA</code> cells width distance to <code>NA</code> cells.
</p>
</li>
<li><p> Case 2, when <code>x</code> is a <code>GRaster</code> and <code>y</code> is a <code>GVector</code>: If <code>TRUE</code> (default), then the returned raster will contain the distance from the cell to the closest feature in the vector. If <code>FALSE</code>, then cells covered by the vector will have their values replaced with the distance to the nearest cell not covered, and cells that are not covered by the vector will have values of 0.
</p>
</li>
<li><p> Case 3, when <code>x</code> is a <code>GVector</code> and <code>y</code> is a <code>GVector</code>: This argument is not used in this case.
</p>
</li></ul>
</td></tr>
<tr><td><code id="distance+2B2CGRaster+2B2Cmissing-method_+3A_unit">unit</code></td>
<td>
<p>Character: Units of the output. Any of:
</p>

<ul>
<li> <p><code>"meters"</code>, <code>"metres"</code>, or <code>"m"</code> (default)
</p>
</li>
<li> <p><code>"kilometers"</code> or <code>"km"</code>
</p>
</li>
<li> <p><code>"miles"</code> or <code>"mi"</code>
</p>
</li>
<li> <p><code>"nautical miles"</code> or <code>"nmi"</code>
</p>
</li>
<li> <p><code>"yards"</code> or <code>"yd"</code>
</p>
</li>
<li> <p><code>"feet"</code> or <code>"ft"</code> &ndash; international, 1 foot exactly equals 0.3048 meters
</p>
</li></ul>

<p>Partial matching is used and case is ignored.</p>
</td></tr>
<tr><td><code id="distance+2B2CGRaster+2B2Cmissing-method_+3A_method">method</code></td>
<td>
<p>Character: The type of distance to calculate. Partial matching is used and capitalization is ignored. Possible values include:
</p>

<ul>
<li> <p><code>Euclidean</code> (default for projected rasters): Euclidean distance.
</p>
</li>
<li> <p><code>geodesic</code> (default for unprojected rasters): Geographic distance. If <code>x</code> is unprojected (e.g., WGS84 or NAD83), then the <code>method</code> must be <code>"geodesic"</code>.
</p>
</li>
<li> <p><code>squared</code>: Squared Euclidean distance (faster than just Euclidean distance but same rank&ndash;good for cases where only order matters).
</p>
</li>
<li> <p><code>maximum</code>: Maximum Euclidean distance.
</p>
</li>
<li> <p><code>Manhattan</code>: Manhattan distance (i.e., &quot;taxicab&quot; distance, distance along cells going only north-south and east-west and never along a diagonal).
</p>
</li></ul>
</td></tr>
<tr><td><code id="distance+2B2CGRaster+2B2Cmissing-method_+3A_mindist">minDist</code>, <code id="distance+2B2CGRaster+2B2Cmissing-method_+3A_maxdist">maxDist</code></td>
<td>
<p>Either <code>NULL</code> (default) or numeric values: Ignore distances less than or greater than these distances.</p>
</td></tr>
<tr><td><code id="distance+2B2CGRaster+2B2Cmissing-method_+3A_thick">thick</code></td>
<td>
<p>Logical: Only applicable for case 2, when <code>x</code> is a <code>GRaster</code> and <code>y</code> is a <code>GVector</code>. If <code>TRUE</code> (default), then the vector will be represented by &quot;thickened&quot; lines (i.e., any cell that the line/boundary touches, not just the ones on the rendering path).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> is a <code>GRaster</code>, then the output is a <code>GRaster</code>. If <code>x</code> is a <code>GVector</code>, then the output is a numeric vector.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+distance">terra::distance()</a></code>; <strong>GRASS</strong> modules <code>r.grow.distance</code> and <code>v.distance</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Elevation raster, rivers vector, locations of Dypsis plants
madElev &lt;- fastData("madElev")
madRivers &lt;- fastData("madRivers")
madDypsis &lt;- fastData("madDypsis")

# Convert a SpatRaster to a GRaster, and sf to a GVector
elev &lt;- fast(madElev)
rivers &lt;- fast(madRivers)
dypsis &lt;- fast(madDypsis)

### case 1: GRaster by itself

# Distance between NA cells and nearest non-NA cells
naDist &lt;- distance(elev)
names(naDist) &lt;- "NA Distance"
plot(naDist)

# Distance between non-NA cells and nearest NA cells
nonNaDist &lt;- distance(elev, fillNA = FALSE)
names(nonNaDist) &lt;- "non-NA Distance"
plot(nonNaDist)

# Distance between cells with an elevation of 3 and any other cell that != 3
distFocal3 &lt;- distance(elev, target = 3)
names(distFocal3) &lt;- "Distance from 3"
plot(distFocal3)

# Distance between any cell and cells with a value of 3
distTo3 &lt;- distance(elev, fillNA = FALSE, target = 3)
names(distTo3) &lt;- "Distance to 3"
plot(distTo3)

### Case 2: GRaster and GVector
distToVect &lt;- distance(elev, rivers)

plot(distToVect)
plot(rivers, add = TRUE)

### Case 3: GVector vs GVector
plot(rivers)
plot(dypsis, add = TRUE)

distToRivers &lt;- distance(dypsis, rivers, unit = "yd")
distToPlants &lt;- distance(rivers, dypsis)
distToRivers
distToPlants

### Case 4: GVector vs itself
distToItself &lt;- distance(dypsis)
distToItself

}
</code></pre>

<hr>
<h2 id='droplevels+2CGRaster-method'>Remove rows from the &quot;levels&quot; table of a categorical raster</h2><span id='topic+droplevels+2CGRaster-method'></span><span id='topic+droplevels'></span>

<h3>Description</h3>

<p><code>droplevels()</code> removes levels (category values) from the &quot;levels&quot; table of a categorical <code>GRaster</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
droplevels(x, level = NULL, layer = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="droplevels+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="droplevels+2B2CGRaster-method_+3A_level">level</code></td>
<td>
<p><code>NULL</code>, character, numeric, integer, or logical: Level(s) to drop. If <code>NULL</code> (default), then all levels without values in the raster are dropped (this may remove the &quot;levels&quot; table entirely if all levels are dropped, converting the raster to an <code>integer</code>-type raster).  If a character, this is the category label(s) to drop. If numeric or integer, this is the category value(s) to drop. If logical, values that are <code>TRUE</code> are dropped.</p>
</td></tr>
<tr><td><code id="droplevels+2B2CGRaster-method_+3A_layer">layer</code></td>
<td>
<p>Numeric integers, logical vector, or character: Layer(s) to which to add or from which to drop levels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>. The &quot;levels&quot; table of the raster is modified.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+missingCats">missingCats()</a></code>, <code><a href="#topic+missing.cases">missing.cases()</a></code>, <code><a href="terra.html#topic+factors">terra::droplevels()</a></code>, <code>vignette("GRasters", package = "fasterRaster")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data: Land cover raster
madCover &lt;- fastData("madCover")

# Convert categorical SpatRaster to categorical GRaster:
cover &lt;- fast(madCover)

### Properties of categorical rasters

cover # note categories
is.factor(cover) # Is the raster categorical?
nlevels(cover) # number of levels
levels(cover) # just the value and active column
cats(cover) # all columns
minmax(cover) # min/max values
minmax(cover, levels = TRUE) # min/max categories
catNames(cover) # column names of the levels table
missingCats(cover) # categories in table with no values in raster
freq(cover) # frequency of each category (number of cells)
zonalGeog(cover) # geometric statistics

### Active column

# Which column sets the category labels?
activeCat(cover)
activeCat(cover, names = TRUE)

activeCats(c(cover, cover))

# Choose a different column for category labels:
levels(cover)
activeCat(cover) &lt;- 2
levels(cover)

### Managing levels tables

# Remove unused levels:
nlevels(cover)
cover &lt;- droplevels(cover)
nlevels(cover)

# Re-assign levels:
value &lt;- c(20, 30, 40, 50, 120, 130, 140, 170)
label &lt;- c("Cropland", "Cropland", "Forest", "Forest",
 "Grassland", "Shrubland", "Herbaceous", "Flooded")

newCats &lt;- data.frame(value = value, label = label)

cover &lt;- categories(cover, layer = 1, value = newCats)
cats(cover)

# This is the same as:
levels(cover) &lt;- newCats
cats(cover)

# Are there any values not assigned a category?
missingCats(cover)

# Let's assign a category for value 210 (water):
water &lt;- data.frame(value = 210, label = "Water")
addCats(cover) &lt;- water
levels(cover)

# Add more information to the levels table using merge():
landType &lt;- data.frame(
     Value = c(20, 30, 40, 50, 120),
     Type = c("Irrigated", "Rainfed", "Broadleaf evergreen",
     "Broadleaf deciduous", "Mosaic with forest")
)
cats(cover)
cover &lt;- addCats(cover, landType, merge = TRUE)
cats(cover)

### Logical operations on categorical rasters

cover &lt; "Forest" # 1 for cells with a value &lt; 40, 0 otherwise
cover &lt;= "Forest" # 1 for cells with a value &lt; 120, 0 otherwise
cover == "Forest" # 1 for cells with value of 40-120, 0 otherwise
cover != "Forest" # 1 for cells with value that is not 40-120, 0 otherwise
cover &gt; "Forest" # 1 for cells with a value &gt; 120, 0 otherwise
cover &gt;= "Forest" # 1 for cells with a value &gt;= 120, 0 otherwise

cover %in% c("Cropland", "Forest") # 1 for cropland/forest cells, 0 otherwise

### Combine categories from different rasters

# For the example, will create a second categorical raster fromm elevation.

# Divide elevation raster into "low/medium/high" levels:
madElev &lt;- fastData("madElev")
elev &lt;- fast(madElev)
elev &lt;- project(elev, cover, method = "near") # convert to same CRS
fun &lt;- "= if(madElev &lt; 100, 0, if(madElev &lt; 400, 1, 2))"
elevCat &lt;- app(elev, fun)

levs &lt;- data.frame(
     value = c(0, 1, 2),
     elevation = c("low", "medium", "high")
)
levels(elevCat) &lt;- list(levs)

# Combine levels:
combined &lt;- concats(cover, elevCat)
combined
levels(combined)

# Combine levels, treating value/NA combinations as new categories:
combinedNA &lt;- concats(cover, elevCat, na.rm = FALSE)
combinedNA
levels(combinedNA)

}
</code></pre>

<hr>
<h2 id='dropRows+2Cdata.table-method'>Remove rows in a data.table, data.frame, or matrix.</h2><span id='topic+dropRows+2Cdata.table-method'></span><span id='topic+dropRows'></span><span id='topic+dropRows+2Cdata.frame-method'></span><span id='topic+dropRows+2Cmatrix-method'></span>

<h3>Description</h3>

<p>As of September of 2023, the <strong>data.table</strong> package does not have a function for removing rows by index. This function does this job.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'data.table'
dropRows(x, drops)

## S4 method for signature 'data.frame'
dropRows(x, drops)

## S4 method for signature 'matrix'
dropRows(x, drops)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dropRows+2B2Cdata.table-method_+3A_x">x</code></td>
<td>
<p>A <code>data.table</code> or <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="dropRows+2B2Cdata.table-method_+3A_drops">drops</code></td>
<td>
<p>Numeric, integer, or logical vector: Indices or indicators of rows to remove.
</p>
<p>If a logical vector is supplied, rows that correspond to <code>TRUE</code> will be removed. If the vector is shorter than the number of rows, values of <code>drops</code> will be recycled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> or <code>data.frame</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(data.table)

dt &lt;- data.table(
   x = 1:10,
   y = letters[1:10],
   z = rnorm(10)
)

# make some values NA
dt[x == 4 | x == 8, y := NA_character_]
dt

# Replace NAs:
replaceNAs(dt, replace = -99, cols = "y")
dt

# Drop rows:
dropped &lt;- dropRows(dt, 8:10)
dropped

# NB May not print... in that case, use:
print(dropped)

# We can also use replaceNAs() on vectors:
y &lt;- 1:10
y[c(2, 10)] &lt;- NA
replaceNAs(y, -99)

# Same as:
y &lt;- 1:10
y[c(2, 10)] &lt;- NA
y[is.na(y)] &lt;- -99
</code></pre>

<hr>
<h2 id='erase+2CGVector+2CGVector-method'>Select parts of a polygon GVector erase shared by another polygon GVector</h2><span id='topic+erase+2CGVector+2CGVector-method'></span><span id='topic+erase'></span>

<h3>Description</h3>

<p>The <code>erase()</code> function removes from the <code>x</code> &quot;polygons&quot; <code>GVector</code> parts that overlap with the <code>y</code> &quot;polygons&quot; <code>GVector</code>. You can also use the <code>-</code> operator (e.g., <code>vect1 - vect2</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector,GVector'
erase(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="erase+2B2CGVector+2B2CGVector-method_+3A_x">x</code>, <code id="erase+2B2CGVector+2B2CGVector-method_+3A_y">y</code></td>
<td>
<p><code>GVector</code>s.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+c">c()</a></code>, <code><a href="#topic+aggregate">aggregate()</a></code>, <code><a href="#topic+crop">crop()</a></code>, <code><a href="#topic+intersect">intersect()</a></code>, <code><a href="#topic+union">union()</a></code>, <code><a href="#topic+xor">xor()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)

# Polygon of coastal Madagascar and Dypsis specimens
madCoast4 &lt;- fastData("madCoast4") # polygons
madDypsis &lt;- fastData("madDypsis") # points

# Convert vectors:
coast4 &lt;- fast(madCoast4)
dypsis &lt;- fast(madDypsis)

# Create another polygons vector from a convex hull around Dypsis points
hull &lt;- convHull(dypsis)

### union()

unioned &lt;- union(coast4, hull)
plot(unioned)

plus &lt;- coast4 + hull # same as union()

### intersect

inter &lt;- intersect(coast4, hull)
plot(coast4)
plot(hull, border = "red", add = TRUE)
plot(inter, border = "blue", add = TRUE)

### xor

xr &lt;- xor(coast4, hull)
plot(coast4)
plot(xr, border = "blue", add = TRUE)

### erase

erased &lt;- erase(coast4, hull)
plot(coast4)
plot(erased, border = "blue", add = TRUE)

minus &lt;- coast4 - hull # same as erase()

}
</code></pre>

<hr>
<h2 id='expanse+2CGVector-method'>Area of polygons or length of lines</h2><span id='topic+expanse+2CGVector-method'></span><span id='topic+expanse'></span>

<h3>Description</h3>

<p>This function calculates the area of each polygon in a &quot;polygons&quot; <code>GVector</code> or the length of lines in a &quot;lines&quot; <code>GVector</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector'
expanse(x, unit = "m")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expanse+2B2CGVector-method_+3A_x">x</code></td>
<td>
<p>A &quot;polygons&quot; or &quot;lines&quot; <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="expanse+2B2CGVector-method_+3A_unit">unit</code></td>
<td>
<p>Character: Units in which to report values. Areal units are squared, linear are not. Can be any of:
</p>

<ul>
<li> <p><code>"meters"</code>(default), <code>"metres"</code>, or <code>"m"</code>
</p>
</li>
<li> <p><code>"km"</code> or <code>"kilometers"</code>
</p>
</li>
<li> <p><code>"ha"</code> or <code>"hectares"</code>
</p>
</li>
<li> <p><code>"ft"</code> or <code>"feet"</code>
</p>
</li>
<li> <p><code>"ac"</code> or <code>"acres"</code>
</p>
</li>
<li> <p><code>"percent"</code>
</p>
</li></ul>

<p>Partial matching is used and case is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric values, one per geometry in <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)

# Example data:
madCoast4 &lt;- fastData("madCoast4")
madRivers &lt;- fastData("madRivers")
madDypsis &lt;- fastData("madDypsis")

# Convert sf vectors to GVectors:
coast &lt;- fast(madCoast4)
rivers &lt;- fast(madRivers)
dypsis &lt;- fast(madDypsis)

# Geographic properties:
ext(rivers) # extent
crs(rivers) # coordinate reference system
st_crs(rivers) # coordinate reference system
coordRef(rivers) # coordinate reference system

# Column names and data types:
names(coast)
datatype(coast)

# Points, lines, or polygons?
geomtype(dypsis)
geomtype(rivers)
geomtype(coast)

is.points(dypsis)
is.points(coast)

is.lines(rivers)
is.lines(dypsis)

is.polygons(coast)
is.polygons(dypsis)

# Number of dimensions:
topology(rivers)
is.2d(rivers) # 2-dimensional?
is.3d(rivers) # 3-dimensional?

# Just the data table:
as.data.frame(rivers)
as.data.table(rivers)

# Top/bottom of the data table:
head(rivers)
tail(rivers)

# Vector or table with just selected columns:
names(rivers)
rivers$NAME
rivers[[c("NAM", "NAME_0")]]
rivers[[c(3, 5)]]

# Select geometries/rows of the vector:
nrow(rivers)
selected &lt;- rivers[2:6]
nrow(selected)

# Plot:
plot(coast)
plot(rivers, col = "blue", add = TRUE)
plot(selected, col = "red", lwd = 2, add = TRUE)

# Vector math:
hull &lt;- convHull(dypsis)

un &lt;- union(coast, hull)
sameAsUnion &lt;- coast + hull
plot(un)
plot(sameAsUnion)

inter &lt;- intersect(coast, hull)
sameAsIntersect &lt;- coast * hull
plot(inter)
plot(sameAsIntersect)

er &lt;- erase(coast, hull)
sameAsErase &lt;- coast - hull
plot(er)
plot(sameAsErase)

xr &lt;- xor(coast, hull)
sameAsXor &lt;- coast / hull
plot(xr)
plot(sameAsXor)

# Vector area and length:
expanse(coast, unit = "km") # polygons areas
expanse(rivers, unit = "km") # river lengths

### Fill holes

# First, we will make some holes by creating buffers around points.
buffs &lt;- buffer(dypsis, 500)

holes &lt;- coast - buffs
plot(holes)

filled &lt;- fillHoles(holes, fail = FALSE)

}
</code></pre>

<hr>
<h2 id='ext+2Cmissing-method'>Spatial bounds of a GRaster or GVector</h2><span id='topic+ext+2Cmissing-method'></span><span id='topic+ext'></span><span id='topic+ext+2CGSpatial-method'></span><span id='topic+zext+2Cmissing-method'></span><span id='topic+zext'></span><span id='topic+zext+2CGSpatial-method'></span><span id='topic+W+2Cmissing-method'></span><span id='topic+W'></span><span id='topic+W+2CGSpatial-method'></span><span id='topic+E+2Cmissing-method'></span><span id='topic+E'></span><span id='topic+E+2CGSpatial-method'></span><span id='topic+N+2Cmissing-method'></span><span id='topic+N'></span><span id='topic+N+2CGSpatial-method'></span><span id='topic+S+2Cmissing-method'></span><span id='topic+S'></span><span id='topic+S+2CGSpatial-method'></span><span id='topic+top+2Cmissing-method'></span><span id='topic+top'></span><span id='topic+top+2CGSpatial-method'></span><span id='topic+bottom+2CGSpatial-method'></span><span id='topic+bottom'></span>

<h3>Description</h3>

<p>These functions return the extent of a <code>GSpatial</code> object (<code>GRegions</code>, <code>GRaster</code>s, and <code>GVector</code>s):
</p>

<ul>
<li> <p><code>ext()</code>: 2-dimensional spatial extent (i.e., westernmost/easternmost and southernmost/northernmost coordinates of area represented).<br />
</p>
</li>
<li> <p><code>zext()</code>: Vertical extent (i.e., topmost and bottom-most elevation of the volume represented). The vertical extent is not <code>NA</code> only if the object is 3-dimensional.<br />
</p>
</li>
<li> <p><code>W()</code>, <code>E()</code>, <code>N()</code>, <code>S()</code>: Coordinates of one side of horizontal extent.<br />
</p>
</li>
<li> <p><code>top()</code> and <code>bottom()</code>: Coordinates of top and bottom of vertical extent.<br />
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'missing'
ext(x, vector = FALSE)

## S4 method for signature 'GSpatial'
ext(x, vector = FALSE)

## S4 method for signature 'missing'
zext(x)

## S4 method for signature 'GSpatial'
zext(x)

## S4 method for signature 'missing'
W(x, char = FALSE)

## S4 method for signature 'GSpatial'
W(x, char = FALSE)

## S4 method for signature 'missing'
E(x, char = FALSE)

## S4 method for signature 'GSpatial'
E(x, char = FALSE)

## S4 method for signature 'missing'
N(x, char = FALSE)

## S4 method for signature 'GSpatial'
N(x, char = FALSE)

## S4 method for signature 'missing'
S(x, char = FALSE)

## S4 method for signature 'GSpatial'
S(x, char = FALSE)

## S4 method for signature 'missing'
top(x, char = FALSE)

## S4 method for signature 'GSpatial'
top(x, char = FALSE)

## S4 method for signature 'GSpatial'
bottom(x, char = FALSE)

## S4 method for signature 'GSpatial'
bottom(x, char = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ext+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>An object that inherits from <code>GSpatial</code> (i.e., a <code>GRaster</code> or <code>GVector</code>) or missing. If missing, then the horizontal or vertical extent of the currently active &quot;region&quot; is returned (see <code>vignette("regions", package = "fasterRaster")</code>).</p>
</td></tr>
<tr><td><code id="ext+2B2Cmissing-method_+3A_vector">vector</code></td>
<td>
<p>Logical: If <code>FALSE</code> (default), return a <code>SpatExtent</code> object. If <code>TRUE</code>, return the extent as a named vector.</p>
</td></tr>
<tr><td><code id="ext+2B2Cmissing-method_+3A_char">char</code></td>
<td>
<p>Logical: If <code>FALSE</code> (default), return a numeric value. If <code>TRUE</code>, return as a character.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned values depend on the function:
</p>

<ul>
<li> <p><code>ext()</code>: A <code>SpatExtent</code> object (<strong>terra</strong> package) or a numeric vector.
</p>
</li>
<li> <p><code>zext()</code>: A numeric vector.
</p>
</li>
<li> <p><code>W()</code>, <code>E()</code>, <code>N()</code>, <code>S()</code>, <code>top()</code>, and <code>bottom()</code>: A numeric value or character.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="terra.html#topic+ext">terra::ext()</a></code>, <code><a href="sf.html#topic+st_bbox">sf::st_bbox()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Example data
madElev &lt;- fastData("madElev")
madForest2000 &lt;- fastData("madForest2000")
madCoast0 &lt;- fastData("madCoast0")
madRivers &lt;- fastData("madRivers")
madDypsis &lt;- fastData("madDypsis")

### GRaster properties

# convert SpatRasters to GRasters
elev &lt;- fast(madElev)
forest &lt;- fast(madForest2000)

# plot
plot(elev)

dim(elev) # rows, columns, depths, layers
nrow(elev) # rows
ncol(elev) # columns
ndepth(elev) # depths
nlyr(elev) # layers

res(elev) # resolution

ncell(elev) # cells
ncell3d(elev) # cells (3D rasters only)

topology(elev) # number of dimensions
is.2d(elev) # is it 2D?
is.3d(elev) # is it 3D?

minmax(elev) # min/max values

# name of object in GRASS
sources(elev)

# "names" of the object
names(elev)

# coordinate reference system
crs(elev)

# extent (bounding box)
ext(elev)

# data type
datatype(elev)

# assigning
copy &lt;- elev
copy[] &lt;- pi # assign all cells to the value of pi
copy

# concatenating multiple GRasters
rasts &lt;- c(elev, forest)
rasts

# adding a raster "in place"
add(rasts) &lt;- ln(elev)
rasts

# subsetting
rasts[[1]]
rasts[["madForest2000"]]

# assigning
rasts[[4]] &lt;- elev &gt; 500

# number of layers
nlyr(rasts)

# names
names(rasts)
names(rasts) &lt;- c("elev_meters", "forest", "ln_elev", "high_elevation")
rasts

### GVector properties

# convert sf vectors to GVectors
coast &lt;- fast(madCoast4)
rivers &lt;- fast(madRivers)
dypsis &lt;- fast(madDypsis)

# extent
ext(rivers)

W(rivers) # western extent
E(rivers) # eastern extent
S(rivers) # southern extent
N(rivers) # northern extent
top(rivers) # top extent (NA for 2D rasters like this one)
bottom(rivers) # bottom extent (NA for 2D rasters like this one)

# coordinate reference system
crs(rivers)
st_crs(rivers)

# column names and data types
names(coast)
datatype(coast)

# name of object in GRASS
sources(rivers)

# points, lines, or polygons?
geomtype(dypsis)
geomtype(rivers)
geomtype(coast)

is.points(dypsis)
is.points(coast)

is.lines(rivers)
is.lines(dypsis)

is.polygons(coast)
is.polygons(dypsis)

# dimensions
nrow(rivers) # how many spatial features
ncol(rivers) # hay many columns in the data frame

# number of geometries and sub-geometries
ngeom(coast)
nsubgeom(coast)

# 2- or 3D
topology(rivers) # dimensionality
is.2d(elev) # is it 2D?
is.3d(elev) # is it 3D?

# Update values from GRASS
# (Reads values from GRASS... will not appear to do anything in this case)
coast &lt;- update(coast)

### operations on GVectors

# convert to data frame
as.data.frame(rivers)
as.data.table(rivers)

# subsetting
rivers[c(1:2, 5)] # select 3 rows/geometries
rivers[-5:-11] # remove rows/geometries 5 through 11
rivers[ , 1] # column 1
rivers[ , "NAM"] # select column
rivers[["NAM"]] # select column
rivers[1, 2:3] # row/geometry 1 and column 2 and 3
rivers[c(TRUE, FALSE)] # select every other geometry (T/F vector is recycled)
rivers[ , c(TRUE, FALSE)] # select every other column (T/F vector is recycled)

# removing data table
noTable &lt;- dropTable(rivers)
noTable
nrow(rivers)
nrow(noTable)

# Refresh values from GRASS
# (Reads values from GRASS... will not appear to do anything in this case
# since the rivers object is up-to-date):
rivers &lt;- update(rivers)

# Concatenating multiple vectors
rivers2 &lt;- rbind(rivers, rivers)
dim(rivers)
dim(rivers2)

}
</code></pre>

<hr>
<h2 id='extend+2CGRaster+2Cnumeric-method'>Add rows and columns around a writeRaster</h2><span id='topic+extend+2CGRaster+2Cnumeric-method'></span><span id='topic+extend'></span><span id='topic+extend+2CGRaster+2CSpatRaster-method'></span><span id='topic+extend+2CGRaster+2CSpatVector-method'></span><span id='topic+extend+2CGRaster+2CSpatExtent-method'></span><span id='topic+extend+2CGRaster+2Csf-method'></span><span id='topic+extend+2CGRaster+2CGSpatial-method'></span>

<h3>Description</h3>

<p><code>extend()</code> adds cells around a raster, making it larger.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster,numeric'
extend(x, y, fill = NA)

## S4 method for signature 'GRaster,SpatRaster'
extend(x, y, snap = "near", fill = NA)

## S4 method for signature 'GRaster,SpatVector'
extend(x, y, snap = "near", fill = NA)

## S4 method for signature 'GRaster,SpatExtent'
extend(x, y, snap = "near", fill = NA)

## S4 method for signature 'GRaster,sf'
extend(x, y, snap = "near", fill = NA)

## S4 method for signature 'GRaster,GSpatial'
extend(x, y, snap = "near", fill = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extend+2B2CGRaster+2B2Cnumeric-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="extend+2B2CGRaster+2B2Cnumeric-method_+3A_y">y</code></td>
<td>
<p>Any of:
</p>

<ul>
<li><p> An object from which an extent can be obtained; i.e., a <code>SpatRaster</code>, <code>SpatVector</code>, <code>SpatExtent</code>, <code>sf</code> vector, or a <code>GSpatial</code> object (any of <code>GRaster</code>, <code>GVector</code>, or <code>GRegion</code>). If the extent of <code>x</code> is &quot;outside&quot; the extent of <code>y</code> on any side, the side(s) of <code>x</code> that are outside will be kept as-is (i.e., the extent of <code>x</code> will never be shrunk).
</p>
</li>
<li><p> A single positive integer: Number of rows and columns to add to the top, bottom, and sides of the raster.
</p>
</li>
<li><p> Two integers &gt;= 0: Number of columns (1st value) to add to the sides, and number of rows (2nd value) to add to the top and bottom of the raster.
</p>
</li>
<li><p> Four integers &gt;= 0: Number of rows and columns to add (left column, right column, bottom row, top row).
</p>
</li></ul>
</td></tr>
<tr><td><code id="extend+2B2CGRaster+2B2Cnumeric-method_+3A_fill">fill</code></td>
<td>
<p>Numeric: Value to place in the new cells. The default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="extend+2B2CGRaster+2B2Cnumeric-method_+3A_snap">snap</code></td>
<td>
<p>Character: Method used to align <code>y</code> to <code>x</code>. Partial matching is used. This is only used if <code>y</code> is not a set of numbers.
</p>

<ul>
<li> <p><code>"near"</code> (default): Round to nearest row/column
</p>
</li>
<li> <p><code>"in"</code>: Round &quot;inward&quot; toward the extent of <code>x</code> to nearest row/column
</p>
</li>
<li> <p><code>"out"</code>: Round &quot;outward&quot; away from the extent of <code>x</code> to the nearest row/column.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Known issues: When <code>GRaster</code>s are saved to disk explicitly using <code><a href="#topic+writeRaster">writeRaster()</a></code>, or implicitly using <code><a href="#topic+rast">rast()</a></code> or <code><a href="#topic+plot">plot()</a></code>, rows and columns that are entirely <code>NA</code> are dropped.
</p>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+extend">terra::extend()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")
madRivers &lt;- fastData("madRivers")

# Send spatial objects to GRASS:
elev &lt;- fast(madElev)
rivers &lt;- fast(madRivers)

# Extend raster by number of rows/columns:
extended1 &lt;- extend(elev, 10, fill = 900)
extended2 &lt;- extend(elev, c(10, 20), fill = 900)
extended3 &lt;- extend(elev, c(10, 80, 0, 100), fill = 900)
dim(elev)
dim(extended1)
dim(extended2)
dim(extended3)

plot(extended3)

# When exporting a raster, NA rows and columns are removed.
extended4 &lt;- extend(elev, 100, fill=1) # default fill is NA
extended4terra &lt;- rast(extended4)

dim(extended4)
dim(extended4terra)

plot(extended4)

# Extend the raster by another object with a wider extent.

# For tis example, first crop the raster, then extend it.
elevCrop &lt;- crop(elev, rivers)
uncrop &lt;- extend(elevCrop, elev, fill = 900)
plot(uncrop)

}
</code></pre>

<hr>
<h2 id='extract+2CGRaster+2CGVector-method'>Extract values from a GRaster at locations in a points GVector</h2><span id='topic+extract+2CGRaster+2CGVector-method'></span><span id='topic+extract'></span><span id='topic+extract+2CGRaster+2Cdata.frame-method'></span><span id='topic+extract+2CGRaster+2Cdata.table-method'></span><span id='topic+extract+2CGRaster+2Cmatrix-method'></span><span id='topic+extract+2CGRaster+2Cnumeric-method'></span><span id='topic+extract+2CGVector+2CGVector-method'></span><span id='topic+extract+2CGVector+2Cdata.frame-method'></span><span id='topic+extract+2CGVector+2Cdata.table-method'></span><span id='topic+extract+2CGVector+2Cmatrix-method'></span><span id='topic+extract+2CGVector+2Cnumeric-method'></span>

<h3>Description</h3>

<p><code>extract()</code> obtains the values of a <code>GRaster</code> or <code>GVector</code> associated with the locations of a set of points. The output depends on the input:
</p>

<ul>
<li> <p><strong>Case #1: <code>x</code> is a numeric or integer <code>GRaster</code> and <code>y</code> is a points <code>GVector</code></strong>: Returns values of cells that have points. If <code>xy</code> is <code>TRUE</code>, also returns the coordinates of the points.
</p>
</li>
<li> <p><strong>Case #2: <code>x</code> is a categorical (factor) <code>GRaster</code> and <code>y</code> is a points <code>GVector</code></strong>: Same as case #1, but if <code>cats</code> is <code>TRUE</code>, returns category labels of cells that have points. If <code>xy</code> is <code>TRUE</code>, also returns the coordinates of the points.
</p>
</li>
<li> <p><strong>Case #3: <code>x</code> is a categorical <code>GRaster</code> and <code>y</code> is a lines or polygons <code>GVector</code></strong>: Returns a summary (e.g., mean, standard deviation, etc.) of all cells that overlap the line(s) or polygon(s).
</p>
</li>
<li> <p><strong>Case #4: <code>x</code> is a <code>GVector</code> and <code>y</code> is a points <code>GVector</code></strong>: Returns the data table row associated each point. If <code>xy</code> is <code>TRUE</code>, also returns the coordinates of the points.
Note that whenever a points <code>GVector</code> is allowed for <code>y</code>, a <code>data.frame</code>, <code>data.table</code>, <code>matrix</code>, or <code>numeric</code> values representing points can be used instead.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster,GVector'
extract(
  x,
  y,
  fun = "mean",
  prob = 0.5,
  overlap = TRUE,
  xy = FALSE,
  cats = TRUE,
  verbose = FALSE,
  ...
)

## S4 method for signature 'GRaster,data.frame'
extract(x, y, xy = FALSE, cats = TRUE)

## S4 method for signature 'GRaster,data.table'
extract(x, y, xy = FALSE, cats = TRUE)

## S4 method for signature 'GRaster,matrix'
extract(x, y, xy = FALSE, cats = TRUE)

## S4 method for signature 'GRaster,numeric'
extract(x, y, xy = FALSE, cats = TRUE)

## S4 method for signature 'GVector,GVector'
extract(x, y, xy = FALSE, verbose = TRUE)

## S4 method for signature 'GVector,data.frame'
extract(x, y, xy = FALSE, verbose = TRUE)

## S4 method for signature 'GVector,data.table'
extract(x, y, xy = FALSE, verbose = TRUE)

## S4 method for signature 'GVector,matrix'
extract(x, y, xy = FALSE, verbose = TRUE)

## S4 method for signature 'GVector,numeric'
extract(x, y, xy = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract+2B2CGRaster+2B2CGVector-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> or <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="extract+2B2CGRaster+2B2CGVector-method_+3A_y">y</code></td>
<td>
<p>A <code>GVector</code>, <em>or</em> a <code>data.frame</code> or <code>matrix</code> where the first two columns represent longitude and latitude (in that order), <em>or</em> a two-element numeric vector where the first column represents longitude and the second latitude. Values of <code>x</code> will be extracted from the points in <code>y</code>. <code>GVector</code>s can be of types points, lines, or polygons.</p>
</td></tr>
<tr><td><code id="extract+2B2CGRaster+2B2CGVector-method_+3A_fun">fun</code></td>
<td>
<p>Character vector: Name(s) of function(s) to apply to values. This is used when <code>x</code> is a <code>GRaster</code> and <code>y</code> is a lines or polygons <code>GVector</code>. The method(s) specified by <code>fun</code> will be applied to all cell values that overlap with each geometry (i.e., individual cell values will not be returned). Valid functions include:
</p>

<ul>
<li> <p><code>"countNonNA"</code>: Number of overlapping cells.
</p>
</li>
<li> <p><code>"countNA"</code>: Number of overlapping <code>NA</code> cells.
</p>
</li>
<li> <p><code>"mean"</code>: Average.
</p>
</li>
<li> <p><code>"min"</code>: Minimum.
</p>
</li>
<li> <p><code>"max"</code>: Minimum.
</p>
</li>
<li> <p><code>"sum"</code>: Sum.
</p>
</li>
<li> <p><code>"range"</code>: Maximum - minimum.
</p>
</li>
<li> <p><code>"sd"</code>: Sample standard deviation (same as <code><a href="stats.html#topic+sd">stats::sd()</a></code>).
</p>
</li>
<li> <p><code>"sdpop"</code>: Population standard deviation.
</p>
</li>
<li> <p><code>"var"</code>: Sample variance (same as <code><a href="stats.html#topic+cor">stats::var()</a></code>).
</p>
</li>
<li> <p><code>"varpop"</code>: Population variance.
</p>
</li>
<li> <p><code>"cv"</code>: Coefficient of variation.
</p>
</li>
<li> <p><code>"cvpop"</code>: Population coefficient of variation.
</p>
</li>
<li> <p><code>"median"</code>: Median.
</p>
</li>
<li> <p><code>"quantile"</code>: Quantile; you can specify the quantile using the <code>prob</code> argument.
</p>
</li></ul>
</td></tr>
<tr><td><code id="extract+2B2CGRaster+2B2CGVector-method_+3A_prob">prob</code></td>
<td>
<p>Numeric in the range from 0 to 1: Quantile which to calculate. The value of <code>prob</code> will be rounded to the nearest hundredth.</p>
</td></tr>
<tr><td><code id="extract+2B2CGRaster+2B2CGVector-method_+3A_overlap">overlap</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), and <code>y</code> is a lines or polygons <code>GVector</code>, then account for potential overlap of geometries when extracting. This can be slow, so if you are sure geometries do not overlap, you can change this to <code>FALSE</code>. This argument is ignored if <code>y</code> is a points <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="extract+2B2CGRaster+2B2CGVector-method_+3A_xy">xy</code></td>
<td>
<p>Logical: If <code>TRUE</code> and <code>y</code> represents points, also return the coordinates of each point. Default is <code>FALSE.</code></p>
</td></tr>
<tr><td><code id="extract+2B2CGRaster+2B2CGVector-method_+3A_cats">cats</code></td>
<td>
<p>Logical (extracting from a raster): If <code>TRUE</code> (default) and <code>x</code> is a categorical <code>GRaster</code>, then return the category labels instead of the values.</p>
</td></tr>
<tr><td><code id="extract+2B2CGRaster+2B2CGVector-method_+3A_verbose">verbose</code></td>
<td>
<p>Logical: If <code>TRUE</code>, display progress (will only function when extracting from points on a <code>GRaster</code> when the number of <code>GRaster</code>s is large, or when extracting using a &quot;points&quot; <code>GVector</code> with lots of points).</p>
</td></tr>
<tr><td><code id="extract+2B2CGRaster+2B2CGVector-method_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code><a href="#topic+project">project()</a></code>. This is used only if extracting from a <code>GRaster</code> at locations specified by a <code>GVector</code>, and they have a different coordinate reference system. In this case, users should specify the <code>wrap</code> argument to <code><a href="#topic+project">project()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> or <code>data.table</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+extract">terra::extract()</a></code>, and modules <code>r.what</code> and <code>v.what</code> in <strong>GRASS</strong>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Example data: elevation raster and points vector
madElev &lt;- fastData("madElev") # raster
madCover &lt;- fastData("madCover") # categorical raster
madDypsis &lt;- fastData("madDypsis") # points vector
madRivers &lt;- fastData("madRivers") # lines vector
madCoast4 &lt;- fastData("madCoast4") # polygons vector

# Convert to fasterRaster formats:
elev &lt;- fast(madElev) # raster
cover &lt;- fast(madCover) # categorical raster
dypsis &lt;- fast(madDypsis) # points vector
rivers &lt;- fast(madRivers) # lines vector
coast &lt;- fast(madCoast4) # polygons vector

# Get values of elevation at points where Dypsis species are located:
extract(elev, dypsis, xy = TRUE)

# Extract from categorical raster at points:
categories &lt;- extract(cover, dypsis)
categoryValues &lt;- extract(cover, dypsis, cats = FALSE)
categories
categoryValues

# Extract and summarize values on a raster across polygons:
extract(elev, coast, fun = c("sum", "mean", "countNonNA"), overlap = FALSE)

# Extract and summarize values on a raster across lines:
extract(elev, rivers, fun = c("sum", "mean", "countNonNA"), overlap = FALSE)

# Extract from a polygons vector at a points vector:
polysFromPoints &lt;- extract(coast, dypsis, xy = TRUE)
head(polysFromPoints) # first 3 are outside polygons vector, next 3 are inside

}
</code></pre>

<hr>
<h2 id='fast'>Create a GRaster or GVector</h2><span id='topic+fast'></span><span id='topic+fast+2Ccharacter-method'></span><span id='topic+fast+2CSpatRaster-method'></span><span id='topic+fast+2CSpatVector-method'></span><span id='topic+fast+2Csf-method'></span><span id='topic+fast+2Cmissing-method'></span><span id='topic+fast+2Cnumeric-method'></span><span id='topic+fast+2Cdata.frame-method'></span><span id='topic+fast+2Cdata.table-method'></span><span id='topic+fast+2Cmatrix-method'></span>

<h3>Description</h3>

<p><code>fast()</code> creates a <code>GRaster</code> or <code>GVector</code> from 1) a file; 2) from a <code>SpatRaster</code>, <code>SpatVector</code>, or <code>sf</code> vector; or 3) from a numeric vector, <code>matrix</code>, <code>data.frame</code>, or <code>data.table</code>. Behind the scenes, this function will also create a connection to <strong>GRASS</strong> if none has yet been made yet.
</p>
<p><strong>GRASS</strong> supports loading from disk a variety of raster formats (see the <strong>GRASS</strong> manual page for <code>r.in.gdal</code> (see <code>grassHelp("r.in.gdal")</code>) and vector formats <code>v.in.ogr</code> (see grassHelp(&quot;v.in.ogr&quot;)'), though not all of them will work with this function.
</p>
<p>Note that <code>GVectors</code> may fail to be created if they contain issues that do not coincide with the topological data model used by <strong>GRASS</strong>. The most common of these is overlapping polygons. See <em>Details</em> on how to fix these kinds of issues.
</p>
<p>Note also that <strong>GRASS</strong> (and thus, <strong>fasterRaster</strong>) is <em>not</em> very fast when loading vectors. So, if the vector is large and you only want a portion of it, consider using the <code>extent</code> argument to load the spatial subset you need.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character'
fast(
  x,
  rastOrVect = NULL,
  levels = TRUE,
  extent = NULL,
  correct = TRUE,
  snap = NULL,
  area = NULL,
  steps = 10,
  dropTable = FALSE,
  resolve = NA,
  verbose = TRUE,
  ...
)

## S4 method for signature 'SpatRaster'
fast(x, ...)

## S4 method for signature 'SpatVector'
fast(
  x,
  extent = NULL,
  correct = TRUE,
  snap = NULL,
  area = NULL,
  steps = 10,
  dropTable = FALSE,
  resolve = NA,
  verbose = TRUE
)

## S4 method for signature 'sf'
fast(
  x,
  extent = NULL,
  correct = TRUE,
  snap = NULL,
  area = NULL,
  steps = 10,
  resolve = NA,
  dropTable = FALSE,
  verbose = TRUE
)

## S4 method for signature 'missing'
fast(x, rastOrVect, crs = "")

## S4 method for signature 'numeric'
fast(x, crs = "", keepgeom = FALSE)

## S4 method for signature 'data.frame'
fast(x, geom = 1:2, crs = "", keepgeom = FALSE)

## S4 method for signature 'data.table'
fast(x, geom = 1:2, crs = "", keepgeom = FALSE)

## S4 method for signature 'matrix'
fast(x, geom = 1:2, crs = "", keepgeom = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fast_+3A_x">x</code></td>
<td>
<p>Any one of:
</p>

<ul>
<li><p> A <code>SpatRaster</code> raster. Rasters can have one or more layers.
</p>
</li>
<li><p> A <code>SpatVector</code> or <code>sf</code> spatial vector. See especially arguments <code>correct</code>, <code>area</code>, <code>snap</code>, <code>steps</code>, and <code>verbose</code>.
</p>
</li>
<li><p> A character string or a vector of strings with the path(s) and filename(s) of one or more rasters or one vector to be loaded directly into <strong>GRASS</strong>. The function will attempt to ascertain the type of object from the file extension (raster or vector), but it can help to indicate which it is using the <code>rastOrVect</code> argument if it is unclear. For rasters, see especially argument <code>levels</code>. For vectors, see especially arguments <code>correct</code>, <code>resolve</code>, <code>area</code>, <code>snap</code>, <code>steps</code>, and <code>verbose</code>.
</p>
</li>
<li><p> A vector with an even number of numeric values representing longitude/latitude pairs. See arguments <code>geom</code>, <code>keepgeom</code>, and <code>crs</code>.
</p>
</li>
<li><p> A <code>data.frame</code>, <code>data.table</code>, or <code>matrix</code>: Create a <code>points</code> <code>GVector</code>. Two of the columns must represent longitude and latitude. See arguments <code>geom</code>, <code>keepgeom</code>, and <code>crs</code>.
</p>
</li>
<li><p> Missing: Creates a generic <code>GRaster</code> or <code>GVector</code>. You must specify <code>rastOrVect</code>; for example, <code>fast(rastOrVect = "raster")</code>. Also see argument <code>crs</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fast_+3A_rastorvect">rastOrVect</code></td>
<td>
<p>Either <code>NULL</code> (default), or <code>"raster"</code> or <code>"vector"</code>: If <code>x</code> is a filename, then the function will try to ascertain whether it represents a raster or a vector, but sometimes this will fail. In that case, it can help to specify if the file holds a raster or vector. Partial matching is used.</p>
</td></tr>
<tr><td><code id="fast_+3A_levels">levels</code></td>
<td>
<p>(<code>GRaster</code>s only): Any of:
</p>

<ul>
<li><p> Logical: If <code>TRUE</code> (default) and at least one layer of a raster is of type <code>integer</code>, search for a &quot;levels&quot; file, load it, and attach levels. A levels file will have the same name as the raster file, but end with any of &quot;rdata&quot;, &quot;rdat&quot;, &quot;rda&quot;, &quot;rds&quot;, &quot;csv&quot;, or &quot;tab&quot; (case will generally not matter). If such a file is not found, no levels will be assigned. The levels file must contain either a <code>data.frame</code>, <code>data.table</code>, or <code>list</code> of <code>data.frame</code>s or <code>data.table</code>s, or <code>NULL</code>.
</p>
</li>
<li><p> A <code>data.frame</code>, <code>data.table</code>, or list of <code>data.frame</code>s or <code>data.table</code>s with categories for categorical rasters. The first column of a table corresponds to raster values and must be of type <code>integer</code>. A subsequent column corresponds to category labels. By default, the second column is assumed to represent labels, but this can be changed with <code><a href="#topic+activeCat+3C-">activeCat&lt;-</a></code>. Level tables can also be <code>NULL</code> (e.g., <code>data.fame(NULL)</code>). You can also assign levels after loading a raster using <code><a href="#topic+levels+3C-">levels&lt;-</a></code>.
</p>
</li>
<li> <p><code>NULL</code>: Do not attach a levels table.
#'
</p>
</li></ul>
</td></tr>
<tr><td><code id="fast_+3A_extent">extent</code></td>
<td>
<p>(<code>GVector</code>s only): Either a <code>NULL</code> (default), or a <code>GVector</code>, a <code>SpatVector</code>, a <code>SpatExtent</code> object, an <code>sf</code> vector, a <code>bbox</code> object, or a numeric vector of 4 values providing a bounding box. If provided, only vector features within this bounding box are imported. If <code>extent</code> is a numeric vector, the values <em>must</em> be in the order west, east, south, north. If <code>NULL</code>, the entire vector is imported.</p>
</td></tr>
<tr><td><code id="fast_+3A_correct">correct</code></td>
<td>
<p>Logical (<code>GVector</code>s only): Correct topological issues. See <em>Details</em> for more details! By default, this is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fast_+3A_snap">snap</code></td>
<td>
<p><code>GVector</code>s only: Numeric or <code>NULL</code> (default). The value of <code>snap</code> indicates how close vertices need to be for them to be shifted to to the same location. Units of <code>snap</code> are map units (usually meters), or degrees for unprojected CRSs. For lines and polygons vectors, a value of <code>NULL</code> will invoke an iterative procedure to find an optimal, smallest value of <code>snap</code>. To turn snapping off, set <code>snap = 0</code>. See <em>Details</em> for more details!</p>
</td></tr>
<tr><td><code id="fast_+3A_area">area</code></td>
<td>
<p>Polygon <code>GVector</code>s only: Either a positive numeric value or <code>NULL</code> (default). Remove polygons with an area smaller than this value. Units of <code>area</code> are in square meters (regardless of the CRS). If <code>NULL</code>, then an iterative procedure is used to identify a value of <code>area</code> that results in a topologically correct polygon vector. For point and lines vectors, this argument is ignored. To turn area removal off, set <code>area = 0</code>. See <em>Details</em> for more details!</p>
</td></tr>
<tr><td><code id="fast_+3A_steps">steps</code></td>
<td>
<p><code>GVector</code>s only: A positive integer &gt; 1 (default is 10). When using automatic vector correction (i.e., either <code>snap = NULL</code> and/or <code>area = NULL</code>), this is the number of values of <code>snap</code> and/or <code>area</code> to try to generate a correct topology, including no snapping or polygon removal (i.e, <code>snap = 0</code> and <code>area = 0</code>).</p>
</td></tr>
<tr><td><code id="fast_+3A_droptable">dropTable</code></td>
<td>
<p><code>GVector</code>s only: Logical. If <code>TRUE</code>, then drop the data table associated with a vector. By default, this is <code>FALSE</code>. See <em>Details</em> for more details!</p>
</td></tr>
<tr><td><code id="fast_+3A_resolve">resolve</code></td>
<td>
<p><code>GVector</code>s only: Character. If a <code>GVector</code> would be topologically invalid after a first attempt at creating it, then this method will be used to resolve the issue and create a valid <code>GVector</code>. Partial matching is used.
</p>

<ul>
<li> <p><code>"disaggregate"</code>: Coerce each area of overlap between polygons into its own geometry. The output will not have a data table associated with it.
</p>
</li>
<li> <p><code>"aggregate"</code>: Coerce all geometries into a &quot;multipart&quot; geometry so it acts like a single geometry. The output will not have a data table associated with it.
</p>
</li>
<li> <p><code>NA</code> (default): Do neither of the above and if either <code>snap</code> or <code>area</code> is <code>NULL</code>, keep trying to create the <code>GVector</code>. Upon success, the <code>GVector</code> will retain any data table associated with it unless <code>dropTable</code> is <code>FALSE</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fast_+3A_verbose">verbose</code></td>
<td>
<p><code>GVector</code>s only: Logical. Displays progress when using automatic topology correction.</p>
</td></tr>
<tr><td><code id="fast_+3A_...">...</code></td>
<td>
<p>Other arguments::
</p>

<ul>
<li> <p><code>table</code> (<code>GVector</code>s&ndash;useful mainly to developers, not most users): A <code>data.frame</code> or <code>data.table</code> with one row per geometry in a <code>GVector</code>. Serves as an attribute table.
</p>
</li>
<li> <p><code>xVect</code> (<code>GVector</code>s&ndash;useful mainly to developers, not most users): The <code>SpatVector</code> that corresponds to the file named by <code>x</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fast_+3A_crs">crs</code></td>
<td>
<p>String: Coordinate reference system (CRS) WKT2 string. This argument is used for creating a <code>GVector</code> from a <code>numeric</code> vector or a <code>data.frame</code> or similar, or from <code>fast(rastOrVect = "vector")</code> or <code>fast(rastOrVect = "raster")</code>. By default, the function will use the value of <code><a href="#topic+crs">crs()</a></code> (no arguments), which is the CRS of the current <strong>GRASS</strong> &quot;project/location&quot; (see <code>vignette("projects_mapsets", package = "fasterRaster")</code>).</p>
</td></tr>
<tr><td><code id="fast_+3A_keepgeom">keepgeom</code></td>
<td>
<p>Logical: If <code>x</code> is a set of <code>numeric</code> coordinates, or a <code>data.frame</code> or similar, then they can be coerced into a <code>points</code> <code>GVector</code>. If <code>keepgeom</code> is <code>TRUE</code>, then the coordinates will be included in the data table of the <code>GVector</code>. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fast_+3A_geom">geom</code></td>
<td>
<p>Character or integer vector: If <code>x</code> is a <code>data.frame</code>, <code>data.table</code>, or <code>matrix</code>, this specifies which columns of <code>x</code> represent longitude and latitude. Columns can be given by name (a character vector) or index (a numeric or integer vector). The default is to use the first two columns of <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>GRASS</strong> uses a &quot;topological&quot; model for vectors. Topological issues generally arise only with polygon vectors, not point or line vectors. Sometimes, polygons created in other software are topologically incorrect&ndash;the borders of adjacent polygons may cross one another, or there may be small gaps between them. These errors can be corrected by slightly shifting vertices and/or removing small polygons that result from intersections of larger ones that border one another. A topological system also recognizes that boundaries to adjacent polygons are shared by the areas, so should not be ascribed attributes that belong to both areas (e.g., the shared border between two countries &quot;belongs&quot; to both countries).
</p>
<p>By default, <code>fast()</code> will try to correct topological errors in vectors. There are three levels of correction, and they are not necessarily mutually exclusive:
</p>

<ol>
<li> <p><strong>Automatic correction</strong>: By default, <code>fast()</code> will apply automatic topology correction. You can turn this off using the <code>correct = FALSE</code> argument, though in most cases this is not recommended.
</p>
</li>
<li> <p><strong><em>Manual</em> snapping and/or area removal</strong>: In addition to correction from step 1, you can cause vertices of polygons close to one another to be &quot;snapped&quot; to same place and/or polygons that are smaller than some threshold to be removed. Problems with mis-aligned vertices arise when adjacent polygons are meant to share borders, but slight differences in the locations of the vertices cause them to  mis-align. This mis-alignment can also produce small &quot;slivers&quot; of polygons that are the areas where they overlap. You can snap vertices within a given distance of one another using the <code>snap</code> argument followed by a numeric value, like <code>snap = 0.000001</code>. Units of <code>snap</code> are in map units (usually meters) for projected coordinate reference systems and degrees for unprojected systems (e.g., WGS84, NAD83, NAD27). You can also remove polygons that are smaller than a particular area using the <code>area</code> argument followed by a numeric value (e.g., <code>area = 1</code>). The units of <code>area</code> are in meters-squared, regardless of the coordinate reference system. Note that using <code>snap</code> and <code>area</code> entails some risk, as it is possible for nearby vertices to actually be distinct and for small areas to be legitimate.
</p>
</li>
<li> <p><strong>Automatic snapping and/or area removal</strong>: In addition to the correction from step 1, you can use automatic <code>snap</code> and/or <code>area</code> correction on polygons vectors by setting <code>snap</code> and/or <code>area</code> to <code>NULL</code> (i.e., their default values). If just <code>snap</code> is <code>NULL</code>, only automatic snapping will be performed, and if just <code>area</code> is <code>NULL</code>, then only automatic area removal will be performed. Regardless, you will also need to set an integer value for <code>steps</code>, which is the number of steps to take between the smallest value of <code>snap</code> and/or <code>area</code> and the maximum value attempted. The function will then proceed by first attempting <code>snap = 0</code> and/or <code>area = 0</code> (i.e., no snapping or area removal). If this does not produce a topologically correct vector, <strong>GRASS</strong> will (internally) suggest a range for <code>snap</code>. The <code>fast()</code> function then creates <code>steps</code> values from the lowest to the highest values of this range evenly-spaced along the log values of this range, then proceed to repeat the importing process until either the vector is imported correctly or the maximum value of <code>snap</code> is reached and results in a failed topology. Smaller values of <code>step</code> will result in more fine-grained attempts so are less likely to yield overcorrection, but can also take more time. The value of <code>area</code> in automatic correction is set to <code>snap^2</code>. <strong>NB</strong>: Automated snapping and area removal are only performed on polygons vectors, even if <code>snap</code> or <code>area</code> is <code>NULL</code>. To snap lines or points, you must set <code>snap</code> equal to a numeric value. The <code>area</code> correction is ignored for points and lines.
</p>
</li></ol>

<p>Issues can also arise due to:
</p>

<ul>
<li> <p><strong>Data table-vector mismatching</strong>: If your vector has a data table (&quot;attribute table&quot;) associated with it, errors can occur if there are more/fewer geometries (or multi-geometries) per row in the table. If you do not really need the data table to do your analysis, you can remove it (and thus obviate this error) using <code>dropTable = TRUE</code>.
</p>
</li>
<li> <p><strong>Dissolving or aggregating &quot;invalid&quot; geometries</strong>: Using the <code>resolve</code> argument, you can create a topologically valid vector by either coercing all overlapping portions of polygons into their own geometries (<code>resolve = "disaggregate"</code>), or by coercing them into a single, combined geometry (<code>resolve = "aggregate"</code>). Aggregation/disaggregation will be implemented after loading the vector into <strong>GRASS</strong> using the settings given by <code>snap</code> and <code>area</code>. Aggregation/disaggregation will cause any associated data table to be dropped (it forces <code>dropTable</code> to be <code>TRUE</code>). The default action is to do neither aggregation nor disaggregation (<code>resolve = NA</code>).
</p>
</li></ul>

<p>If none of these fixes work, you can try:
</p>

<ul>
<li> <p><strong>Correction outside of <em>fasterRaster</em></strong>: Before you convert the vector into <strong>fasterRaster</strong>'s <code>GVector</code> format, you can also try using the <code><a href="terra.html#topic+is.valid">terra::makeValid()</a></code> or <code><a href="sf.html#topic+valid">sf::st_make_valid()</a></code> tools to fix issues, then use <code>fast()</code>.
</p>
</li>
<li> <p><strong>Post-conversion to a <code>GVector</code></strong>: If you do get a vector loaded into <code>GVector</code> format, you can also use a set of <strong>fasterRaster</strong> vector-manipulation <a href="#topic+breakPolys">tools</a> or <code><a href="#topic+fillHoles">fillHoles()</a></code> to fix issues.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>GRaster</code> or <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><code><a href="rgrass.html#topic+read_RAST">read_RAST</a></code> and <code><a href="rgrass.html#topic+read_VECT">read_VECT</a></code>, <a href="#topic+breakPolys">vector cleaning</a>, <code><a href="#topic+fillHoles">fillHoles()</a></code>, plus <strong>GRASS</strong> modules <code>v.in.ogr</code> (see <code>grassHelp("v.in.ogr")</code>) and <code>r.import</code> (<code>grassHelp("r.import")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Example data
madElev &lt;- fastData("madElev") # integer raster
madCover &lt;- fastData("madCover") # categorical raster
madCoast4 &lt;- fastData("madCoast4") # polygons vector
madRivers &lt;- fastData("madRivers") # lines vector
madDypsis &lt;- fastData("madDypsis") # points vector

### Create GRasters from SpatRasters

# Create an integer raster:
elev &lt;- fast(madElev)
elev

# Create a categorical raster:
cover &lt;- fast(madCover)
madCover
levels(madCover) # category levels

# Create a GRaster from a file on disk:
rastFile &lt;- system.file("extdata", "madForest2000.tif", package = "fasterRaster")
forest2000 &lt;- fast(rastFile)
forest2000

# Create a 1's raster that spans the world:
ones &lt;- fast(rastOrVect = "raster", crs = "epsg:4326")
ones

### Create GVectors

# Create a GVector from an sf vector:
coast4 &lt;- fast(madCoast4)
coast4

# Create a GVector from a SpatVector:
madRivers &lt;- vect(madRivers)
class(madRivers)
rivers &lt;- fast(madRivers)
rivers

# Create a GVector from a vector on disk:
vectFile &lt;- system.file("extdata/shapes", "madCoast.shp",
   package = "fasterRaster")
coast0 &lt;- fast(vectFile)
coast0

# Import only Dypsis occurrences in a restricted area:
ant &lt;- coast4[coast4$NAME_4 == "Antanambe"]
dypsisRestrict &lt;- fast(madDypsis, extent = ant)
dypsis &lt;- fast(madDypsis)

plot(coast4)
plot(ant, col = "gray80", add = TRUE)
plot(dypsis, add = TRUE)
plot(dypsisRestrict, col = "red", add = TRUE)

# Create a generic GVector that spans the world:
wallToWall &lt;- fast(rastOrVect = "vector", crs = "epsg:4326") # WGS84
wallToWall

# Create a GVector from a numeric vector
pts &lt;- c(-90.2, 38.6, -122.3, 37.9)
pts &lt;- fast(pts, crs = "epsg:4326") # WGS84

# Create a GVector from a matrix (can also use data.frame or data.table):
mat &lt;- matrix(c(-90.2, 38.6, -122.3, 37.9), ncol = 2, byrow = TRUE)
mat &lt;- fast(mat, crs = "epsg:4326", keepgeom = TRUE) # WGS84

}
</code></pre>

<hr>
<h2 id='fastData'>Get one of the example rasters or spatial vectors</h2><span id='topic+fastData'></span>

<h3>Description</h3>

<p>This function is a simple way to get example rasters or spatial vector datasets that come with <strong>fasterRaster</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastData(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fastData_+3A_x">x</code></td>
<td>
<p>The name of the raster or spatial vector to get. All of these represent a portion of the eastern coast of Madagascar.
</p>
<p>Spatial vectors (objects of class <code>sf</code> from the <strong>sf</strong> package):
</p>

<ul>
<li> <p><a href="#topic+madCoast0">madCoast0</a>: Outline of the region (polygon)
</p>
</li>
<li> <p><a href="#topic+madCoast4">madCoast4</a>: Outlines of the Fokontanies (Communes) of the region (polygons)
</p>
</li>
<li> <p><a href="#topic+madDypsis">madDypsis</a>: Records of plants of the genus <em>Dypsis</em> (points)
</p>
</li>
<li> <p><a href="#topic+madRivers">madRivers</a>: Major rivers (lines)
</p>
</li></ul>

<p>Rasters (objects of class <code>SpatRaster</code> from the <strong>terra</strong> package, saved as GeoTIFF files):
</p>

<ul>
<li> <p><a href="#topic+madChelsa">madChelsa</a>: Bioclimatic variables
</p>
</li>
<li> <p><a href="#topic+madCover">madCover</a>: Land cover
</p>
</li>
<li> <p><code><a href="#topic+madElev">madElev</a></code>: Elevation
</p>
</li>
<li> <p><a href="#topic+madForest2000">madForest2000</a>: Forest cover in year 2000
</p>
</li>
<li> <p><a href="#topic+madForest2014">madForest2014</a>: Forest cover in year 2014
</p>
</li>
<li> <p><a href="#topic+madLANDSAT">madLANDSAT</a>: Surface reflectance in 2023
</p>
</li>
<li> <p><a href="#topic+madPpt">madPpt</a>, <a href="#topic+madTmin">madTmin</a>, <a href="#topic+madTmax">madTmax</a>: Rasters of mean monthly precipitation, and minimum and maximum temperature.
</p>
</li></ul>

<p>Data frames
</p>

<ul>
<li> <p><a href="#topic+appFunsTable">appFunsTable</a>: Table of functions usable by <code><a href="#topic+app">app()</a></code>
</p>
</li>
<li> <p><a href="#topic+madCoverCats">madCoverCats</a>: Land cover values and categories for <a href="#topic+madCover">madCover</a>
</p>
</li>
<li> <p><a href="#topic+vegIndices">vegIndices</a>: Vegetation indices that can be calculated with <code><a href="#topic+vegIndex">vegIndex()</a></code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>SpatRaster</code>, <code>sf</code> spatial vector, or a <code>data.frame</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### vector data

library(sf)

# For vector data, we can use data(*) or fastData(*):
data(madCoast0) # same as next line
madCoast0 &lt;- fastData("madCoast0") # same as previous
madCoast0
plot(st_geometry(madCoast0))

madCoast4 &lt;- fastData("madCoast4")
madCoast4
plot(st_geometry(madCoast4), add = TRUE)

madRivers &lt;- fastData("madRivers")
madRivers
plot(st_geometry(madRivers), col = "blue", add = TRUE)

madDypsis &lt;- fastData("madDypsis")
madDypsis
plot(st_geometry(madDypsis), col = "red", add = TRUE)

### raster data

library(terra)

# For raster data, we can get the file directly or using fastData(*):
rastFile &lt;- system.file("extdata/madElev.tif", package="fasterRaster")
madElev &lt;- terra::rast(rastFile)

madElev &lt;- fastData("madElev") # same as previous two lines
madElev
plot(madElev)

madForest2000 &lt;- fastData("madForest2000")
madForest2000
plot(madForest2000)

madForest2014 &lt;- fastData("madForest2014")
madForest2014
plot(madForest2014)

# multi-layer rasters
madChelsa &lt;- fastData("madChelsa")
madChelsa
plot(madChelsa)

madPpt &lt;- fastData("madPpt")
madTmin &lt;- fastData("madTmin")
madTmax &lt;- fastData("madTmax")
madPpt
madTmin
madTmax


# RGB raster
madLANDSAT &lt;- fastData("madLANDSAT")
madLANDSAT
plotRGB(madLANDSAT, 4, 1, 2, stretch = "lin")

# categorical raster
madCover &lt;- fastData("madCover")
madCover
madCover &lt;- droplevels(madCover)
levels(madCover) # levels in the raster
nlevels(madCover) # number of categories
catNames(madCover) # names of categories table

plot(madCover)
</code></pre>

<hr>
<h2 id='faster'>Set or get options shared across fasterRaster functions</h2><span id='topic+faster'></span>

<h3>Description</h3>

<p><code>faster()</code> either sets or gets options used across <strong>fasterRaster</strong> functions. Its use can vary:
</p>

<ul>
<li><p> Get current values of a particular option: Use <code>faster("option_name")</code>. Values will remain unchanged.
</p>
</li>
<li><p> Get current values of all options: Use <code>faster()</code> (no arguments). Values will remain unchanged.
</p>
</li>
<li><p> Get default values of a particular option: Use <code>faster("option_name", default = TRUE)</code>. Values will remain unchanged.
</p>
</li>
<li><p> Get default values of all options: Use <code>faster(default = TRUE)</code>. Values will remain unchanged.
</p>
</li>
<li><p> Set values of particular options: Use the form <code style="white-space: pre;">&#8288;faster(option 1 = value1, option2 = value2)&#8288;</code>.
</p>
</li>
<li><p> Set all options to their defaults: Use <code>faster(restore = TRUE)</code>.
</p>
</li></ul>

<p>You cannot simultaneously get and set options.
</p>
<p>To run most <strong>fasterRaster</strong> functions, you must set the <code>grassDir</code> option.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>faster(..., default = FALSE, restore = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="faster_+3A_...">...</code></td>
<td>
<p>Either:
</p>

<ul>
<li><p> A character vector: Name(s) of option(s) to get values of;
</p>
</li>
<li><p> An option and the value of the option using an <code>option = value</code> pattern; or
</p>
</li>
<li><p> A names <code>list</code> with names that match the options you wish to change, and with values to assign to each option.
</p>
</li></ul>

<p>Options include:
</p>

<ul>
<li> <p><code>grassDir</code> (character): The folder in which <strong>GRASS</strong> is installed on your computer. You must set this option to run most <strong>fasterRaster</strong> functions. Depending on your operating system, your install directory will look something like this:
</p>

<ul>
<li><p> Windows: <code>"C:/Program Files/GRASS GIS 8.4"</code>
</p>
</li>
<li><p> Mac OS: <code>"/Applications/GRASS-8.4.app/Contents/Resources"</code>
</p>
</li>
<li><p> Linux: <code>"/usr/local/grass"</code>
</p>
</li></ul>

</li>
<li> <p><code>addonsDir</code> (character): Folder in which <strong>GRASS</strong> addons are stored. If <code>NA</code> and <code>grassDir</code> is not <code>NA</code>, this will be assumed to be <code>file.path(grassDir, "addons")</code>. The default values is <code>NA</code>.
</p>
</li>
<li> <p><code>cores</code> (integer/numeric integer): Number of processor cores to use on a task. The default is 2. Some <strong>GRASS</strong> modules are parallelized.
</p>
</li>
<li> <p><code>memory</code> (integer/numeric): The amount of memory to allocate to a task, in GB, for <strong>GRASS</strong>. The default is 2048 MB (i.e., 2 GB). Some <strong>GRASS</strong> modules can take advantage of more memory.
</p>
</li>
<li> <p><code>useDataTable</code> (logical): If <code>FALSE</code> (default), functions that return tabular output produce <code>data.frame</code>s. If <code>TRUE</code>, output will be <code>data.table</code>s from the <strong>data.table</strong> package. This can be much faster, but it might require you to know how to use <code>data.table</code>s if you want to manipulate them in <strong>R</strong>. You can always convert them to <code>data.frame</code>s using <code><a href="base.html#topic+as.data.frame">base::as.data.frame()</a></code>.
</p>
</li>
<li> <p><code>verbose</code> (logical): If <code>TRUE</code>, show progress during function operations and other messages. Default is <code>FALSE</code>. This overrides the value of any <code>verbose</code> argument in a function.
</p>
</li>
<li> <p><code>debug</code> (logical): If <code>TRUE</code>, show <strong>GRASS</strong> messages and otherwise hidden slots in classes. This is mainly used for debugging, so most users will want to keep this at its default, <code>FALSE</code>.
</p>
</li>
<li> <p><code>workDir</code> (character): The folder in which <strong>GRASS</strong> rasters, vectors, and other objects are created and manipulated. By default, this is given by <code><a href="base.html#topic+tempdir">tempdir()</a></code>. Note that on some systems, changing the default folder to somewhere else can cause problems with <strong>fasterRaster</strong> being able to find rasters in <strong>GRASS</strong> that have been created.
</p>
</li></ul>
</td></tr>
<tr><td><code id="faster_+3A_default">default</code></td>
<td>
<p>Logical: Return the default value(s) of the option(s). The default value of <code>default</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="faster_+3A_restore">restore</code></td>
<td>
<p>Logical: If <code>TRUE</code>, the all options will be reset to their default values. The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If options are changed, then a named list of option values <em>before</em> they were changed is returned invisibly.
</p>
<p>If option values are requested, a named list with option values is returned (not invisibly).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# See current values for options:
faster("grassDir")
faster("cores")
faster("memory")
faster("useDataTable")
faster() # all options

# See default values for options:
faster("cores", default = TRUE)
faster(default = TRUE) # all options

# Set options (change accordingly for your system!!!)
if (FALSE) {

   opts. &lt;- faster() # remember starting values of options

   faster(grassDir = "C:/Program Files/GRASS GIS 8.4")
   faster(verbose = TRUE, memory = 1024, cores = 1)

   faster(c("grassDir", "verbose", "memory", "cores"))

   faster(opts.) # reset options to starting values

}

}
</code></pre>

<hr>
<h2 id='fillHoles+2CGVector-method'>Fill holes in a GVector</h2><span id='topic+fillHoles+2CGVector-method'></span><span id='topic+fillHoles'></span>

<h3>Description</h3>

<p><code>fillHoles()</code> removes holes in a <code>GVector</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector'
fillHoles(x, fail = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fillHoles+2B2CGVector-method_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="fillHoles+2B2CGVector-method_+3A_fail">fail</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), and <strong>GRASS 8.3</strong> or higher is not installed, cause an error. If <code>FALSE</code>, a warning will be displayed and a <code>NULL</code> value will be returned. This function requires <strong>GRASS 8.3</strong> or higher to be installed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+fill">terra::fillHoles()</a></code>, <strong>GRASS</strong> manual page for module <code>v.fill.holes</code> (see <code>grassHelp("v.fill.holes")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)

# Example data:
madCoast4 &lt;- fastData("madCoast4")
madRivers &lt;- fastData("madRivers")
madDypsis &lt;- fastData("madDypsis")

# Convert sf vectors to GVectors:
coast &lt;- fast(madCoast4)
rivers &lt;- fast(madRivers)
dypsis &lt;- fast(madDypsis)

# Geographic properties:
ext(rivers) # extent
crs(rivers) # coordinate reference system
st_crs(rivers) # coordinate reference system
coordRef(rivers) # coordinate reference system

# Column names and data types:
names(coast)
datatype(coast)

# Points, lines, or polygons?
geomtype(dypsis)
geomtype(rivers)
geomtype(coast)

is.points(dypsis)
is.points(coast)

is.lines(rivers)
is.lines(dypsis)

is.polygons(coast)
is.polygons(dypsis)

# Number of dimensions:
topology(rivers)
is.2d(rivers) # 2-dimensional?
is.3d(rivers) # 3-dimensional?

# Just the data table:
as.data.frame(rivers)
as.data.table(rivers)

# Top/bottom of the data table:
head(rivers)
tail(rivers)

# Vector or table with just selected columns:
names(rivers)
rivers$NAME
rivers[[c("NAM", "NAME_0")]]
rivers[[c(3, 5)]]

# Select geometries/rows of the vector:
nrow(rivers)
selected &lt;- rivers[2:6]
nrow(selected)

# Plot:
plot(coast)
plot(rivers, col = "blue", add = TRUE)
plot(selected, col = "red", lwd = 2, add = TRUE)

# Vector math:
hull &lt;- convHull(dypsis)

un &lt;- union(coast, hull)
sameAsUnion &lt;- coast + hull
plot(un)
plot(sameAsUnion)

inter &lt;- intersect(coast, hull)
sameAsIntersect &lt;- coast * hull
plot(inter)
plot(sameAsIntersect)

er &lt;- erase(coast, hull)
sameAsErase &lt;- coast - hull
plot(er)
plot(sameAsErase)

xr &lt;- xor(coast, hull)
sameAsXor &lt;- coast / hull
plot(xr)
plot(sameAsXor)

# Vector area and length:
expanse(coast, unit = "km") # polygons areas
expanse(rivers, unit = "km") # river lengths

### Fill holes

# First, we will make some holes by creating buffers around points.
buffs &lt;- buffer(dypsis, 500)

holes &lt;- coast - buffs
plot(holes)

filled &lt;- fillHoles(holes, fail = FALSE)

}
</code></pre>

<hr>
<h2 id='fillNAs+2CGRaster-method'>Fill NA cells in a raster using interpolation</h2><span id='topic+fillNAs+2CGRaster-method'></span><span id='topic+fillNAs'></span>

<h3>Description</h3>

<p>This function uses splines to fill <code>NA</code> cells in a raster based on the values of nearby cells. Depending on the method used, not all <code>NA</code> cells can be filled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
fillNAs(
  x,
  lambda = NULL,
  method = "bilinear",
  min = -Inf,
  max = Inf,
  cells = Inf
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fillNAs+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="fillNAs+2B2CGRaster-method_+3A_lambda">lambda</code></td>
<td>
<p>Either <code>NULL</code> (default), or a numeric value &gt; 0: If <code>NULL</code>, then the function will use leave-one-out crossvalidation to find the optimal value.</p>
</td></tr>
<tr><td><code id="fillNAs+2B2CGRaster-method_+3A_method">method</code></td>
<td>
<p>Character: Type of spline, either &quot;<code>bilinear</code>&quot; (default), &quot;<code>bicubic</code>&quot;, or &quot;<code>RST</code>&quot; (regularized splines with tension). Partial matching is used and case is ignored.
</p>
<p><strong>Note</strong>: The RST method will often display warnings, but these can be ignored.</p>
</td></tr>
<tr><td><code id="fillNAs+2B2CGRaster-method_+3A_min">min</code>, <code id="fillNAs+2B2CGRaster-method_+3A_max">max</code></td>
<td>
<p>Numeric: Lowest and highest values allowed in the interpolated values. Values outside these bounds will be truncated to the minimum/maximum value(s) allowed. The default imposes no constraints. For multi-layered rasters, you can supply a single value for <code>min</code> and/or <code>max</code>, or multiple values (one per layer). Values will be recycled if there are fewer than one or them per layer in the raster.</p>
</td></tr>
<tr><td><code id="fillNAs+2B2CGRaster-method_+3A_cells">cells</code></td>
<td>
<p>Integer or numeric integer: Number of cells away from the non-<code>NA</code> cells to fill. For example, if <code>cells = 2</code>, then only cells within a 2-cell buffer of non-<code>NA</code> cells will be filled. The default is <code>Inf</code> (fill all possible cells&ndash;some methods may not be able to do this, depending on the configuration of the raster).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+interpNear">terra::interpNear()</a></code>, <strong>GRASS</strong> module <code>r.fillnulls</code> (see <code>grassHelp("r.fillnulls")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Elevation raster:
madElev &lt;- fastData("madElev")

# Convert a SpatRaster to a GRaster:
elev &lt;- fast(madElev)

### Fill NAs:
bilinear &lt;- fillNAs(elev)
bicubic &lt;- fillNAs(elev, method = "bicubic")
rst &lt;- fillNAs(elev, method = "rst")

maps &lt;- c(elev, bilinear, bicubic, rst)
names(maps) &lt;- c("original", "bilinear", "bicubic", "RST")
plot(maps)

### Constrain interpolated values to &gt; 0
constrained &lt;- fillNAs(elev, min = 0)

# Compare unconstrained and constrained:
minmax(bilinear)
minmax(constrained)

### Interpolate to only first 10 cells away from non-NA cells:
restrained &lt;- fillNAs(elev, cells = 10)

maps &lt;- c(elev, restrained)
names(maps) &lt;- c("Original", "within 10 cells")
plot(maps)

}
</code></pre>

<hr>
<h2 id='flow+2CGRaster-method'>Identify watershed basins and direction and accumulation of flow</h2><span id='topic+flow+2CGRaster-method'></span><span id='topic+flow'></span>

<h3>Description</h3>

<p>The <code>flow()</code> function uses a raster representing elevation to compute other rasters representing:
</p>

<ul>
<li><p> Flow accumulation;
</p>
</li>
<li><p> Direction of flow;
</p>
</li>
<li><p> Watershed basins;
</p>
</li>
<li><p> Flooded areas; and/or
</p>
</li>
<li><p> Topographic convergence (log of flow accumulation divided by local slope).
</p>
</li></ul>

<p>More details about the computations can be found at the help page for the <strong>GRASS</strong> module <code>r.terraflow</code>] (see <code>grassHelp("r.terraflow")</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
flow(
  x,
  direction = "multi",
  return = "accumulation",
  dirThreshold = Inf,
  scratchDir = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flow+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> with a single layer, typically representing elevation.</p>
</td></tr>
<tr><td><code id="flow+2B2CGRaster-method_+3A_direction">direction</code></td>
<td>
<p>Character: Either <code>"single"</code> or <code>"multi"</code>. This indicates whether a single-direction flow or multi-direction flow model is used. The default is <code>"multi"</code>. Partial matching is used and case is ignored.</p>
</td></tr>
<tr><td><code id="flow+2B2CGRaster-method_+3A_return">return</code></td>
<td>
<p>Character vector: Indicates what rasters to return. Partial matching is used and case is ignored. Options include:
</p>

<ul>
<li> <p><code>"accumulation"</code> (default): Flow accumulation raster.
</p>
</li>
<li> <p><code>"basins"</code>: Watershed basins
</p>
</li>
<li> <p><code>"direction"</code>: Flow direction
</p>
</li>
<li> <p><code>"flooded"</code>: Flooded areas
</p>
</li>
<li> <p><code>"TCI"</code>: Topographic convergence index
</p>
</li>
<li> <p><code>"*"</code>: All of the above
</p>
</li></ul>
</td></tr>
<tr><td><code id="flow+2B2CGRaster-method_+3A_dirthreshold">dirThreshold</code></td>
<td>
<p>Numeric (default is <code>Inf</code>): For the multi-direction flow model, this indicates the amount of accumulated flow above which the single-direction flow rule is used to locate the egress of water from a cell. This is the <code>d8cut</code> parameter in <code>r.stream.extract</code>.</p>
</td></tr>
<tr><td><code id="flow+2B2CGRaster-method_+3A_scratchdir">scratchDir</code></td>
<td>
<p>Character or <code>NULL</code> (default): Directory in which to store temporary files. The <strong>GRASS</strong> module <code>r.terraflow</code> makes a lot of temporary files. If this is <code>NULL</code>, then a temporary folder in the user's working directory will be used (see <code><a href="base.html#topic+getwd">getwd()</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flowPath">flowPath()</a></code>, <code><a href="#topic+streams">streams()</a></code>, the <strong>GRASS</strong> module <code>r.terraflow</code> (see <code>grassHelp("r.terraflow")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")
elev &lt;- fast(madElev)

# Calculate flow accumulation and watershed basins
water &lt;- flow(elev, return = c("accum", "basins"))
water

elevWater &lt;- c(elev, water)
plot(elevWater)

}
</code></pre>

<hr>
<h2 id='flowPath+2CGRaster-method'>Path of water flow across a landscape</h2><span id='topic+flowPath+2CGRaster-method'></span><span id='topic+flowPath'></span>

<h3>Description</h3>

<p>This function finds the least-cost pathway from a set of starting points to the lowest cells accessible from them while, in each step, traversing &quot;down&quot; slope gradients. It is intended to depict the path a drop of water would take when flowing across a landscape. For a single starting point, the defaults settings will produce a raster with cells with values of 1 along the path. All other cells will be set to <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
flowPath(x, y, return = "ID")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flowPath+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> with a single layer, typically representing elevation.</p>
</td></tr>
<tr><td><code id="flowPath+2B2CGRaster-method_+3A_y">y</code></td>
<td>
<p>A &quot;points&quot; <code>GVector</code>. The <code>GVector</code> must have &lt;= 1024 points.</p>
</td></tr>
<tr><td><code id="flowPath+2B2CGRaster-method_+3A_return">return</code></td>
<td>
<p>Character: Indicates the type of values &quot;burned&quot; into the cells of the output raster. Case is ignored and partial matching is used, but only one option can be selected.
</p>

<ul>
<li><p> &quot;<code>ID</code>&quot; (default): Cells in each path are labeled with the index of the starting point. A cell in the flow path of the first point will have a value of 1, a cell in the flow path of the second point will have a value of 2, and so on.
</p>
</li>
<li><p> &quot;<code>sequence</code>&quot;: The output raster's cells will start with 1 at the source point(s), then accumulate so that the next cell in the flow path is 2, the one after that 3, and so on.
</p>
</li>
<li><p> &quot;<code>copy</code>&quot;: The cells in the flow path will have the elevation raster's values in the cells along the flow path(s).
</p>
</li>
<li><p> &quot;<code>accumulation</code>&quot;: Cells in the flow path will accumulate the elevation raster's cell values. For example, if the starting cell has an elevation of 700 and the next cell in the drainage path has a value of 600 and the one after that 500, then the first cell in the path will have a value of 700, the next 1300 (= 700 + 600), and the third 1800 (= 700 + 600 + 500).
</p>
</li>
<li><p> A numeric value: All cells in flow paths will be assigned this value.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flow">flow()</a></code>, <code><a href="#topic+streams">streams()</a></code>, the <strong>GRASS</strong> module <code>r.drain</code> (see <code>grassHelp("r.drain")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")
madCoast4 &lt;- fastData("madCoast4")

# Convert to GRaster and crop to a sub-portion (easier for visualizing)
elev &lt;- fast(madElev)
coast4 &lt;- fast(madCoast4)
ant &lt;- coast4[coast4$NAME_4 == "Antanambe"]
elevAnt &lt;- crop(elev, ant)

# Create a set of random points to serve as starting points:
starts &lt;- spatSample(elevAnt, 10, as.points = TRUE, seed = 2)

# Remove points in water:
starts &lt;- starts[complete.cases(starts)]

# Calculate flow paths and label each by ID:
paths &lt;- flowPath(elevAnt, starts)
paths

plot(elevAnt, legend = FALSE, main = "Flow path for each point")
plot(paths, add = TRUE)
plot(starts, pch = 1, add = TRUE)

# Flow paths with cell values indicating number of cells from each start:
seqs &lt;- flowPath(elevAnt, starts, return = "seq")

plot(elevAnt, legend = FALSE, main = "Sequentially-numbered flow paths")
plot(seqs, add = TRUE)
plot(starts, pch = 1, add = TRUE)

# We can convert flow paths to lines:
seqLines &lt;- as.lines(seqs)
plot(seqLines)
seqLines

}
</code></pre>

<hr>
<h2 id='focal+2CGRaster-method'>Calculate cell values based on values of nearby cells</h2><span id='topic+focal+2CGRaster-method'></span><span id='topic+focal'></span>

<h3>Description</h3>

<p>This function calculates statistics on a moving &quot;neighborhood&quot; of cells of a raster. The neighborhood can be a square, circle, or a user-defined set of cells (with or without weights).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
focal(x, w = 3, fun = "sum", circle = FALSE, quantile = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="focal+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="focal+2B2CGRaster-method_+3A_w">w</code></td>
<td>
<p>Numeric integer or a square matrix with an odd number of rows and columns: The size and nature of the neighborhood:
</p>

<ul>
<li><p> &quot;Square&quot; neighborhoods (when <code>circle = FALSE</code>): An odd integer &gt;= 3, indicating indicates the size of a &quot;square&quot; neighborhood (number of cells wide and number or cells tall).
</p>
</li>
<li><p> &quot;Circular&quot; neighborhoods (when <code>circle = TRUE</code>): An odd integer &gt;=3, indicating the diameter of the circle.
</p>
</li>
<li><p> A matrix of cell weights: The matrix must be square and have an odd number of rows and columns (example: <code>matrix(c(0.5, 1, 0.5, 1, 2, 1, 0.5, 1, 0.5), nrow=3)</code>). You cannot use a weights matrix when <code>circle = TRUE</code>. Cells with <code>NA</code> as a weight will be ignored. Note that weighted matrices should not be used for function <code>min</code>, <code>max</code>, <code>count</code>, <code>nunique</code>, or <code>interspersion</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="focal+2B2CGRaster-method_+3A_fun">fun</code></td>
<td>
<p>Character: Name of the function to apply to the neighborhood:
</p>

<ul>
<li><p> &quot;<code>mean</code>&quot; (default)
</p>
</li>
<li><p> &quot;<code>median</code>&quot;
</p>
</li>
<li><p> &quot;<code>mode</code>&quot;
</p>
</li>
<li><p> &quot;<code>min</code>&quot; or &quot;<code>max</code>&quot;: Minimum or maximum. Should not use a weights matrix.
</p>
</li>
<li><p> &quot;<code>range</code>&quot;: Difference between the maximum and minimum.  Should not use a weights matrix.
</p>
</li>
<li><p> &quot;<code>sd</code>&quot;: Sample standard deviation.  NB: This is the same as the <code><a href="stats.html#topic+sd">stats::sd()</a></code> function.
</p>
</li>
<li><p> &quot;<code>sdpop</code>&quot;: Population standard deviation. NB: This is the same as the function &quot;stddev&quot; in the <strong>GRASS</strong> module <code>r.neighbors</code>.
</p>
</li>
<li><p> &quot;<code>sum</code>&quot;: Sum of non-'NA&ldquo; cells.
</p>
</li>
<li><p> &quot;<code>count</code>&quot;: Number of non-'NA cells. Should not use a weights matrix.
</p>
</li>
<li><p> &quot;<code>var</code>&quot;: Sample variance.  NB: This is the same as the <code><a href="stats.html#topic+cor">stats::var()</a></code> function.
</p>
</li>
<li><p> &quot;<code>varpop</code>&quot;: Population variance. NB: This is the same as the function &quot;variance&quot; in the <strong>GRASS</strong> module <code>r.neighbors</code>.
</p>
</li>
<li><p> &quot;<code>nunique</code>&quot;: Number of unique values. Should not use a weights matrix.
</p>
</li>
<li><p> &quot;<code>interspersion</code>&quot;: Proportion of cells with values different from focal cell (e.g., if 6 of 8 cells have different values, then the interspersion is 6/8 = 0.75). NB: This is slightly different from how it is defined in the <strong>GRASS</strong> module <code>r.neighbors</code>. Should not use a weights matrix.
</p>
</li>
<li><p> &quot;<code>quantile</code>&quot;: Quantile of values. The value in argument <code>quantile</code> is used to specify the quantile.
</p>
</li></ul>

<p>The center cell value is always included in the calculations, and all calculations ignore <code>NA</code> cells (i.e., they do not count as cells in the focal neighborhood).</p>
</td></tr>
<tr><td><code id="focal+2B2CGRaster-method_+3A_circle">circle</code></td>
<td>
<p>Logical: If <code>FALSE</code> (default), use a square neighborhood. If <code>TRUE</code>, use a circular neighborhood. When this is <code>TRUE</code>, argument <code>w</code> cannot be a matrix.</p>
</td></tr>
<tr><td><code id="focal+2B2CGRaster-method_+3A_quantile">quantile</code></td>
<td>
<p>Numeric between 0 and 1, inclusive: Quantile to calculate when <code>fun = "quantile"</code>. The default value is 0.5 (median), and valid values must be in the range between 0 and 1, inclusive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+focal">terra::focal()</a></code>, <strong>GRASS</strong> manual page for module <code>r.neighbors</code> (see <code>grassHelp("r.neighbors")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")

# Convert a SpatRaster to a GRaster:
elev &lt;- fast(madElev)

# Focal calculations:
sums &lt;- focal(elev, fun = "sum")
means &lt;- focal(elev, fun = "mean")

# Focal calculations on a circular window:
sds &lt;- focal(elev, fun = "sd") # square
sdsCircle &lt;- focal(elev, fun = "sd", circle = TRUE) # circle

sds
sdsCircle

plot(sds - sdsCircle)

# Focal calculations with user-defined weights:
w &lt;- matrix(c(1, 0, 1, 0, 1, 0, 1, 0, 1), ncol = 3)
w
sumsWeighted &lt;- focal(elev, fun = "sum", w = w)

s &lt;- c(sums, sumsWeighted)
minmax(s)

}
</code></pre>

<hr>
<h2 id='fractalRast+2CGRaster-method'>Create fractal raster</h2><span id='topic+fractalRast+2CGRaster-method'></span><span id='topic+fractalRast'></span>

<h3>Description</h3>

<p><code>fractalRast()</code> creates a raster with a fractal pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
fractalRast(x, n = 1, mu = 0, sigma = 1, dimension = 2.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fractalRast+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>. The output will have the same extent and dimensions as this raster.</p>
</td></tr>
<tr><td><code id="fractalRast+2B2CGRaster-method_+3A_n">n</code></td>
<td>
<p>A numeric integer: Number of rasters to generate.</p>
</td></tr>
<tr><td><code id="fractalRast+2B2CGRaster-method_+3A_mu">mu</code>, <code id="fractalRast+2B2CGRaster-method_+3A_sigma">sigma</code></td>
<td>
<p>Numeric: Mean and sample standard deviation of output.</p>
</td></tr>
<tr><td><code id="fractalRast+2B2CGRaster-method_+3A_dimension">dimension</code></td>
<td>
<p>Numeric: Fractal dimension. Must be between 2 and 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rSpatialDepRast">rSpatialDepRast()</a></code>, <code><a href="#topic+rnormRast">rnormRast()</a></code>, <code><a href="#topic+runifRast">runifRast()</a></code>, <strong>GRASS</strong> manual page for module <code>r.surf.fractal</code> (see <code>grassHelp("r.surf.fractal")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Elevation raster
madElev &lt;- fastData("madElev")

# Convert a SpatRaster to a GRaster:
elev &lt;- fast(madElev)

### Create a raster with values drawn from a uniform distribution:
unif &lt;- runifRast(elev)
plot(unif)

### Create a raster with values drawn from a normal distribution:
norms &lt;- rnormRast(elev, n = 2, mu = c(5, 10), sigma = c(2, 1))
plot(norms)
hist(norms, bins = 100)

# Create a raster with random, seemingly normally-distributed values:
rand &lt;- rSpatialDepRast(elev, dist = 1000)
plot(rand)

# Values appear normal on first inspection:
hist(rand)

# ... but actually are patterned:
hist(rand, bins = 100)

# Create a fractal raster:
fractal &lt;- fractalRast(elev, n = 2, dimension = c(2.1, 2.8))
plot(fractal)
hist(fractal)

}
</code></pre>

<hr>
<h2 id='fragmentation+2CSpatRaster-method'>Landscape fragmentation class following Riitters et al. (2020)</h2><span id='topic+fragmentation+2CSpatRaster-method'></span><span id='topic+fragmentation'></span><span id='topic+fragmentation+2CGRaster-method'></span>

<h3>Description</h3>

<p>Riitters et al. (2020) propose a classification scheme for forest fragmentation (which can be applied to any habitat type). The scheme relies on calculating density (e.g., number of forested cells in a window around a focal cell) and connectivity (number of cases where neighboring cells are both forested). This function calculates these classes from a <code>GRaster</code> or <code>SpatRaster</code> in which the focal habitat type has cell values of 1, and non-focal habitat type has cell values of 0 or <code>NA</code>.
</p>
<p>Note that by default, the <code>SpatRaster</code> and <code>GRaster</code> versions will create different results around the border of the raster. The <code>SpatRaster</code> version uses the <code><a href="terra.html#topic+focal">terra::focal()</a></code> function, which will not return an <code>NA</code> value when its window overlaps the raster border if the <code>na.rm</code> argument is <code>TRUE</code>. However, the <code>GRaster</code> version uses the <strong>GRASS</strong> module <code>r.neighbors</code>, which does return <code>NA</code> values in these cases.
</p>
<p>The fragmentation classes are:
</p>

<ul>
<li><p> Value provided by <code>none</code>: None (i.e., no forest; default is <code>NA</code>).
</p>
</li>
<li><p> 1: Patch
</p>
</li>
<li><p> 2: Transitional
</p>
</li>
<li><p> 3: Perforated
</p>
</li>
<li><p> 4: Edge
</p>
</li>
<li><p> 5: Undetermined (not possible to obtain when <code>w = 3</code>)
</p>
</li>
<li><p> 6: Interior
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
fragmentation(
  x,
  w = 3,
  undet = "undetermined",
  none = NA,
  na.rm = TRUE,
  cores = faster("cores"),
  verbose = TRUE
)

## S4 method for signature 'GRaster'
fragmentation(x, w = 3, undet = "undetermined", none = NA, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fragmentation+2B2CSpatRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>SpatRaster</code> or <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="fragmentation+2B2CSpatRaster-method_+3A_w">w</code></td>
<td>
<p>An odd, positive integer: Size of the window across which fragmentation is calculated (in units of &quot;rows&quot; and &quot;columns&quot;). The default is 3, meaning the function uses a 3x3 moving window to calculate fragmentation. For large rasters, compute time is ~<em>O</em>(<code>N</code>) + <em>O</em>(<code>N * w^2</code>), where <code>N</code> is the number of cells in the raster. So, even a small increase in <code>w</code> can increase compute time by a lot.</p>
</td></tr>
<tr><td><code id="fragmentation+2B2CSpatRaster-method_+3A_undet">undet</code></td>
<td>
<p>Character: How to assign the &quot;undetermined&quot; case. Valid values are <code>"perforated"</code> (default), <code>"edge"</code>, and <code>"undetermined"</code>. Partial matching is used. If <code>Pf</code> is the proportional density raster cell value and <code>Pff</code> the proportional connectivity raster cell value, the undetermined case occurs when <code>Pf</code> &gt; 0.6 and <code>Pf == Pff</code>.</p>
</td></tr>
<tr><td><code id="fragmentation+2B2CSpatRaster-method_+3A_none">none</code></td>
<td>
<p>Integer or <code>NA</code> (default): Value to assign to a cell with no focal habitat. Riitters et al. use <code>NA</code>. This will be forced to an integer if it is not an actual integer.</p>
</td></tr>
<tr><td><code id="fragmentation+2B2CSpatRaster-method_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default) and <code>x</code> is a <code>SpatRaster</code>, then cells near the edge of the raster where the window overlaps the edge can still be assigned a fragmentation class. If <code>FALSE</code>, these cells will be assigned a value of <code>none</code>.</p>
</td></tr>
<tr><td><code id="fragmentation+2B2CSpatRaster-method_+3A_cores">cores</code></td>
<td>
<p>Integer: Number of processor cores to use for when processing a <code>SpatRaster</code>.</p>
</td></tr>
<tr><td><code id="fragmentation+2B2CSpatRaster-method_+3A_verbose">verbose</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), display progress.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A categorical <code>SpatRaster</code> or <code>GRaster</code>. The values assigned to each class can be seen with <code><a href="#topic+levels">levels()</a></code>.
</p>


<h3>References</h3>

<p>Riitters, K., J. Wickham, R. O'Neill, B. Jones, and E. Smith. 2000. Global-scale patterns of forest fragmentation. <em>Conservation Ecology</em> 4:3. URL: <a href="http://www.consecol.org/vol4/iss2/art3/">http://www.consecol.org/vol4/iss2/art3/</a>. Also note the <a href="https://www.ecologyandsociety.org/vol4/iss2/art3/errata/january26.2001.html">errata</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data:
madForest &lt;- fastData("madForest2000") # raster

### Fragmentation classes from a SpatRaster

fragTerra &lt;- fragmentation(madForest)
plot(fragTerra)
levels(fragTerra)
freq(fragTerra)

### Fragmentation classes from a GRaster

# Convert to GRaster:
forest &lt;- fast(madForest)

# Fragmentation class:
frag &lt;- fragmentation(forest)
plot(frag)
levels(frag)
freq(frag)

}
</code></pre>

<hr>
<h2 id='freq+2CGRaster-method'>Frequencies of cell values in a raster</h2><span id='topic+freq+2CGRaster-method'></span><span id='topic+freq'></span>

<h3>Description</h3>

<p><code>freq()</code> tabulates the frequency of cell values in a raster. For rasters where <code><a href="#topic+datatype">datatype()</a></code> is <code>integer</code> or <code>factor</code>, the frequency of each value or level is reported. For other rasters, the range of values is divided into bins, and the number of cells with values in each bin is reported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
freq(x, digits = 3, bins = 100, value = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="freq+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="freq+2B2CGRaster-method_+3A_digits">digits</code></td>
<td>
<p>Numeric integer: Number of digits by which to round raster values. Ignored for integer and categorical rasters.</p>
</td></tr>
<tr><td><code id="freq+2B2CGRaster-method_+3A_bins">bins</code></td>
<td>
<p>Positive numeric integer: Number of bins in which to divide values of <code>numeric</code> rasters. The default is 100. For <code>integer</code> and categorical rasters, each value is tallied (i.e., this is ignored).</p>
</td></tr>
<tr><td><code id="freq+2B2CGRaster-method_+3A_value">value</code></td>
<td>
<p>Numeric or <code>NULL</code> (default): If numeric, only cells with this value will be counted. If <code>NULL</code>, all values will be counted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> or a named <code>list</code> of <code>data.frame</code>s, one per layer in <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+freq">terra::freq()</a></code>, module <code>r.stats</code> in <strong>GRASS</strong>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev") # raster
madCover &lt;- fastData("madCover") # categorical raster

# Convert to GRasters
elev &lt;- fast(madElev) # raster
cover &lt;- fast(madCover) # categorical raster

# Frequencies of integer raster values
f &lt;- freq(elev)
print(f) # have to do this sometimes if output is a data table

# Frequencies of categorical raster values
f &lt;- freq(cover)
print(f) # have to do this sometimes if output is a data table

# Frequencies of given values
f &lt;- freq(elev, value = 1)
print(f) # have to do this sometimes if output is a data table

# When a GRaster has non-integer values, they will be binned:
f &lt;- freq(elev + 0.1, bins = 10)
print(f)

}
</code></pre>

<hr>
<h2 id='geomorphons+2CGRaster-method'>Identify terrain feature types</h2><span id='topic+geomorphons+2CGRaster-method'></span><span id='topic+geomorphons'></span>

<h3>Description</h3>

<p>Geomorphons are idealized terrain types calculated from an elevator raster based on a moving window of a given size. The window is a torus (which can have an inner radius of 0, so can also be a circle), which allows it to identify geomorphons of a given size while ignoring ones larger or smaller. There are 10 basic geomorphons. Consult the the manual for <strong>GRASS</strong> module <code>r.geomorphon</code> using <code>grassHelp("r.geomorphon")</code> for more details and diagrams of each type of geomorphon. Geomorphon types include:
</p>

<ol>
<li><p> Flat areas: Focal area has approximately the same elevation as surrounding areas
</p>
</li>
<li><p> Pits: An area is lower than all other surrounding areas
</p>
</li>
<li><p> Valley: Focal area has elevation similar to two opposing side of the window but lower than the other two opposing sides
</p>
</li>
<li><p> Footslope: Focal region is at the &quot;bottom&quot; of a slope
</p>
</li>
<li><p> Hollow: A small valley/indention in the crest of a hill
</p>
</li>
<li><p> Slope: Cells in the window form an approximately uniform slope
</p>
</li>
<li><p> Spur: An extrusion at the foot of a hill (i.e.,, a small hill extending out from the foot of a slope)
</p>
</li>
<li><p> Shoulder: The crest of a slope
</p>
</li>
<li><p> Ridge: Opposite of a valley; focal area is higher than two opposing sides but approximately the same elevation as the other two opposing sides
</p>
</li>
<li><p> Peak: Focal area is higher than any other in the window
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
geomorphons(
  x,
  inner = 0,
  outer = 3,
  unit = "cells",
  flat = 1,
  flatDist = 0,
  mode = "1"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geomorphons+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A single-layer <code>GRaster</code>, typically representing elevation.</p>
</td></tr>
<tr><td><code id="geomorphons+2B2CGRaster-method_+3A_inner">inner</code>, <code id="geomorphons+2B2CGRaster-method_+3A_outer">outer</code></td>
<td>
<p>Integer: Inner and outer radii of the torus used to identify geomorphons, in cells or meters (set by argument <code>unit</code>). The inner default value is 0 and the outer default value is 3. The <code>outer</code> radius sets the maximum size of a geomorphon that that can be identified, and <code>inner</code> sets the smallest size. If <code>unit</code> is <code>"meters"</code>, the value of <code>outer</code> must be larger than the smaller dimension of any cell in the east-west and north-south directions.</p>
</td></tr>
<tr><td><code id="geomorphons+2B2CGRaster-method_+3A_unit">unit</code></td>
<td>
<p>Character: Units of <code>inner</code> and outer; can be either <code>"cells"</code> (default) or <code>"meters"</code>. Partial matching is used.</p>
</td></tr>
<tr><td><code id="geomorphons+2B2CGRaster-method_+3A_flat">flat</code></td>
<td>
<p>Numeric value &gt;= 0: Minimum difference (in degrees) between the focal area areas around it for a geomorphon to be considered as &quot;flat&quot;. Larger cells (i.e., ~1 km resolution or larger) require smaller values (&lt;&lt;1) to correctly identify flat areas. Higher values result in more areas being classified as &quot;flat&quot; geomorphons. The default value is 1.</p>
</td></tr>
<tr><td><code id="geomorphons+2B2CGRaster-method_+3A_flatdist">flatDist</code></td>
<td>
<p>Numeric: Distance (in meters) to correct for the effect of large distances on the diminished capacity to identify &quot;flat&quot; geomorphons. If the distance between the focal area and a surrounding area surpasses this distance, then the effective value of <code>flat</code> will be reduced</p>
</td></tr>
<tr><td><code id="geomorphons+2B2CGRaster-method_+3A_mode">mode</code></td>
<td>
<p>Character: Method for implementing the zenith/line-of-site search. Partial matching is used:
</p>

<ul>
<li> <p><code>"1"</code> (default): The &quot;original&quot; geomorphon mode (in <strong>GRASS</strong> module <code>r.geomorphon</code>, the &quot;anglev1&quot; method)
</p>
</li>
<li> <p><code>"2"</code>: Better handling of cases with equal zenith/nadir angles (the &quot;anglev2&quot; method)
</p>
</li>
<li> <p><code>"2d"</code>: As <code>"2"</code>, but takes into account zenith/nadir distance (&quot;anglev2_distance&quot; method)
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A categorical <code>GRaster</code> where each geomorphon is a category (see <code>vignette("GRasters", package = "fasterRaster")</code>).
</p>


<h3>See Also</h3>

<p><strong>GRASS</strong> manual for module <code>r.geomorphon</code> (see <code>grassHelp("r.geomorphon")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")

# Convert a SpatRaster to a GRaster:
elev &lt;- fast(madElev)

# Geomorphons:
geos &lt;- geomorphons(elev)
geos
levels(geos) # levels
freq(geos) # frequencies across cells

col &lt;- c("gray90", "red", "orange", "blue", "green", "pink", "firebrick",
  "purple", "gray50", "black")
plot(geos, col = col)

}
</code></pre>

<hr>
<h2 id='geomtype+2CGVector-method'>Geometry of a GVector (points, lines, or polygons)</h2><span id='topic+geomtype+2CGVector-method'></span><span id='topic+geomtype'></span><span id='topic+is.points+2CGVector-method'></span><span id='topic+is.points'></span><span id='topic+is.lines+2CGVector-method'></span><span id='topic+is.lines'></span><span id='topic+is.polygons+2CGVector-method'></span><span id='topic+is.polygons'></span>

<h3>Description</h3>

<p><code>geomtype()</code> reports whether a <code>GVector</code> represents points, lines, or polygons. The &quot;<code style="white-space: pre;">&#8288;is.*&#8288;</code>&quot; functions test whether the <code>GVector</code> represents points, lines, or polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector'
geomtype(x, grass = FALSE)

## S4 method for signature 'GVector'
is.points(x)

## S4 method for signature 'GVector'
is.lines(x)

## S4 method for signature 'GVector'
is.polygons(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geomtype+2B2CGVector-method_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="geomtype+2B2CGVector-method_+3A_grass">grass</code></td>
<td>
<p>Logical: If <code>FALSE</code> (default), return <strong>terra</strong>-like geometry types (&quot;points&quot;, &quot;lines&quot;, or &quot;polygons&quot;). If <code>TRUE</code>, return <strong>GRASS</strong>-like geometry types (&quot;point&quot;, &quot;line&quot;, &quot;area&quot;&ndash;note that these are a subset of the available types and may not be the &quot;true&quot; <strong>GRASS</strong> type).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>geomtype()</code> returns either &quot;points&quot;, &quot;lines&quot;, or &quot;polygons&quot; if the <code>grass</code> arguments is <code>FALSE</code>, or &quot;point&quot;, &quot;line&quot;, &quot;area&quot; if <code>grass</code> is <code>TRUE</code>. The &quot;<code style="white-space: pre;">&#8288;is.*&#8288;</code>&quot; functions return <code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+geomtype">terra::geomtype()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)

# Example data:
madCoast4 &lt;- fastData("madCoast4")
madRivers &lt;- fastData("madRivers")
madDypsis &lt;- fastData("madDypsis")

# Convert sf vectors to GVectors:
coast &lt;- fast(madCoast4)
rivers &lt;- fast(madRivers)
dypsis &lt;- fast(madDypsis)

# Geographic properties:
ext(rivers) # extent
crs(rivers) # coordinate reference system
st_crs(rivers) # coordinate reference system
coordRef(rivers) # coordinate reference system

# Column names and data types:
names(coast)
datatype(coast)

# Points, lines, or polygons?
geomtype(dypsis)
geomtype(rivers)
geomtype(coast)

is.points(dypsis)
is.points(coast)

is.lines(rivers)
is.lines(dypsis)

is.polygons(coast)
is.polygons(dypsis)

# Number of dimensions:
topology(rivers)
is.2d(rivers) # 2-dimensional?
is.3d(rivers) # 3-dimensional?

# Just the data table:
as.data.frame(rivers)
as.data.table(rivers)

# Top/bottom of the data table:
head(rivers)
tail(rivers)

# Vector or table with just selected columns:
names(rivers)
rivers$NAME
rivers[[c("NAM", "NAME_0")]]
rivers[[c(3, 5)]]

# Select geometries/rows of the vector:
nrow(rivers)
selected &lt;- rivers[2:6]
nrow(selected)

# Plot:
plot(coast)
plot(rivers, col = "blue", add = TRUE)
plot(selected, col = "red", lwd = 2, add = TRUE)

# Vector math:
hull &lt;- convHull(dypsis)

un &lt;- union(coast, hull)
sameAsUnion &lt;- coast + hull
plot(un)
plot(sameAsUnion)

inter &lt;- intersect(coast, hull)
sameAsIntersect &lt;- coast * hull
plot(inter)
plot(sameAsIntersect)

er &lt;- erase(coast, hull)
sameAsErase &lt;- coast - hull
plot(er)
plot(sameAsErase)

xr &lt;- xor(coast, hull)
sameAsXor &lt;- coast / hull
plot(xr)
plot(sameAsXor)

# Vector area and length:
expanse(coast, unit = "km") # polygons areas
expanse(rivers, unit = "km") # river lengths

### Fill holes

# First, we will make some holes by creating buffers around points.
buffs &lt;- buffer(dypsis, 500)

holes &lt;- coast - buffs
plot(holes)

filled &lt;- fillHoles(holes, fail = FALSE)

}
</code></pre>

<hr>
<h2 id='global+2CGRaster-method'>Summary statistics for GRasters</h2><span id='topic+global+2CGRaster-method'></span><span id='topic+global'></span><span id='topic+global+2Cmissing-method'></span>

<h3>Description</h3>

<p><code>global()</code> calculates a summary statistic across all the cells of a <code>GRaster</code>. It returns a single value for each layer of the raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
global(x, fun = "mean", probs = seq(0, 1, 0.25), ...)

## S4 method for signature 'missing'
global(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="global+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> or missing.  If missing, then a vector of all of the accepted function names is returned.</p>
</td></tr>
<tr><td><code id="global+2B2CGRaster-method_+3A_fun">fun</code></td>
<td>
<p>Character vector: The name of the function(s):
</p>

<ul>
<li> <p><code>"*"</code>: All of the functions below.
</p>
</li>
<li> <p><code>"cv"</code>: Sample coefficient of variation (expressed as a proportion of the mean).
</p>
</li>
<li> <p><code>"cvpop"</code>: Population coefficient of variation (expressed as a proportion of the mean).
</p>
</li>
<li> <p><code>"max"</code> and <code>"min"</code>: Highest and lowest values across non-<code>NA</code> cells. NB: <code><a href="#topic+minmax">minmax()</a></code> is faster.
</p>
</li>
<li> <p><code>"mean"</code> (default): Average.
</p>
</li>
<li> <p><code>"meanAbs"</code>: Mean of absolute values.
</p>
</li>
<li> <p><code>"median"</code>: Median.
</p>
</li>
<li> <p><code>"quantile"</code>: Quantile (see also argument <code>probs</code>).
</p>
</li>
<li> <p><code>"range"</code>: Range. Note that following <code><a href="terra.html#topic+global">terra::global()</a></code>, the minimum and maximum are reported, not the actual range.
</p>
</li>
<li> <p><code>"sd"</code>: Sample standard deviation (same as <code><a href="stats.html#topic+sd">stats::sd()</a></code>).
</p>
</li>
<li> <p><code>"sdpop"</code>: Population standard deviation.
</p>
</li>
<li> <p><code>"sum"</code>: Sum.
</p>
</li>
<li> <p><code>"var"</code>: Sample variance (same as <code><a href="stats.html#topic+cor">stats::var()</a></code>).
</p>
</li>
<li> <p><code>"varpop"</code>: Population variance.
</p>
</li></ul>
</td></tr>
<tr><td><code id="global+2B2CGRaster-method_+3A_probs">probs</code></td>
<td>
<p>Numeric within the range from 0 to 1: Quantile(s) at which to calculate <code>quantile</code>.</p>
</td></tr>
<tr><td><code id="global+2B2CGRaster-method_+3A_...">...</code></td>
<td>
<p>Other arguments (unused).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> is missing, the function returns a character vector of all accepted function names. If <code>x</code> is a <code>GRaster</code>, a data frame with the specified statistics is returned.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+global">terra::global()</a></code> and <strong>GRASS</strong> module <code>r.univar</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")

# Convert a SpatRaster to a GRaster:
elev &lt;- fast(madElev)

# What functions can we use with global()?
global()

# Calculate global statistics:
global(elev, fun = c("mean", "var", "varpop"))
global(elev, "quantile", probs = c(0.25, 0.5, 0.75))

global(elev, "*") # calculate all available functions

}
</code></pre>

<hr>
<h2 id='GLocation-class'>Classes for fasterRaster sessions, regions, rasters, and vectors</h2><span id='topic+GLocation-class'></span><span id='topic+GLocation'></span><span id='topic+GSpatial-class'></span><span id='topic+GSpatial'></span><span id='topic+GRegion-class'></span><span id='topic+GRegion'></span><span id='topic+GRaster-class'></span><span id='topic+GRaster'></span><span id='topic+GVector-class'></span><span id='topic+GVector'></span>

<h3>Description</h3>

<p>The <code>G</code>-suite of S4 classes contain pointers to <strong>GRASS</strong> objects or metadata about the current <strong>GRASS</strong> session. Most users will manipulate objects using these classes, but do not need to know the details.
</p>

<ul>
<li><p> The <code>GLocation</code> class stores information about the <strong>GRASS</strong> &quot;project&quot;/&quot;location&quot;(see <code>vignette("projects_mapsets", package = "fasterRaster")</code>), and coordinate reference system. Contained by all the rest.
</p>
</li>
<li><p> The <code>GSpatial</code> class contains the <code>GLocation</code> class and stores information about spatial objects (extent, topology) plus the name of the file representing it in <strong>GRASS</strong> (its <code>source</code>). Contained by <code>GRegion</code>, <code>GRaster</code>, and <code>GVector</code>.
</p>
</li>
<li><p> The <code>GRegion</code> class contains the <code>GSpatial</code> class and stores information about grids (dimensions and resolution). They do have <code>sources</code>, but these are not used (they're always <code>NA</code>). Contained by <code>GRaster</code>. The <code>GRegion</code> corresponds to <strong>GRASS</strong> &quot;regions&quot;, though <code>GRegion</code> objects are not actually pointers to <strong>GRASS</strong> &quot;region&quot; files (see <code>vignette("regions", package = "fasterRaster")</code>).
</p>
</li>
<li><p> The <code>GRaster</code> class contains the <code>GRegion</code> class and represents rasters. It stores information on number of layers, categories, min/max values, and user-friendly names. Categorical <code>GRaster</code>s are associated with a &quot;levels&quot; table for representing categorical data (e.g., wetlands, forest, etc.).
</p>
</li>
<li><p> The <code>GVector</code> class contains the <code>GSpatial</code> class and represents spatial vectors. It may or may not have an associated <code>data.table</code> (i.e., a <code>data.frame</code>), which contains metadata about each geometry in the vector.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>GLocation</code>, <code>GSpatial</code>, <code>GRegion</code>, <code>GRaster</code>, or <code>GVector</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>location</code></dt><dd><p>Character (all classes): The <strong>GRASS</strong> &quot;project&quot;/&quot;location&quot; of the object. The default value is <code>default</code>. Can be obtained using the hidden function <code>.location()</code>. See <code>vignette("projects_mapsets", package = "fasterRaster")</code>.</p>
</dd>
<dt><code>mapset</code></dt><dd><p>Character (all classes): The <strong>GRASS</strong> &quot;mapset&quot;. Default value is <code>PERMANENT</code>. Typically hidden to users. Can be obtained using the hidden function <code>.mapset()</code>. See <code>vignette("projects_mapsets", package = "fasterRaster")</code>.</p>
</dd>
<dt><code>workDir</code></dt><dd><p>Character (all classes): Directory in which <strong>GRASS</strong> stores files.</p>
</dd>
<dt><code>topology</code></dt><dd><p>Character (<code>GSpatial</code> objects, including <code>GRegion</code>s, <code>GRaster</code>s, and <code>GVector</code>s): Valid values are <code style="white-space: pre;">&#8288;2D&#8288;</code> (2-dimensional&ndash;most rasters and vectors) or <code style="white-space: pre;">&#8288;3D&#8288;</code> (3-dimensional&ndash;e.g., LIDAR data). Can be obtained using <code><a href="#topic+topology">topology()</a></code>.</p>
</dd>
<dt><code>sources</code></dt><dd><p>Character (<code>GRaster</code>s and <code>GVector</code>s): Name of the object in <strong>GRASS</strong>. These are typically made on-the-fly and provide the pointer to the object from <strong>R</strong> to <strong>GRASS</strong>. Changing them manually will break the connection. Can be obtained using <code><a href="#topic+sources">sources()</a></code>.</p>
</dd>
<dt><code>names</code></dt><dd><p>Character  (<code>GRaster</code>s only): Name of a raster or each raster layer in. Can be obtained using <code><a href="#topic+names">names()</a></code>.</p>
</dd>
<dt><code>crs</code></dt><dd><p>Character (all classes): Coordinate reference systems string (preferably in WKT2 format). Can be obtained using <code><a href="#topic+crs">crs()</a></code> or <code><a href="#topic+st_crs">st_crs()</a></code>.</p>
</dd>
<dt><code>projection</code></dt><dd><p>Character: The <strong>GRASS</strong> &quot;projection&quot; for a <code>GRaster</code> or <code>GVector</code>. Can be obtained using <code>.projection()</code>.</p>
</dd>
<dt><code>dimensions</code></dt><dd><p>Dimensions:
</p>

<ul>
<li> <p><code>GRegion</code>s and <code>GRaster</code>s: Vector of three integers indicating number of rows, columns, and depths (for 3D objects). Can be obtained using <code><a href="#topic+dim">dim()</a></code>, plus <code><a href="#topic+nrow">nrow()</a></code>, <code><a href="#topic+ncol">ncol()</a></code>, and <code><a href="#topic+ndepth">ndepth()</a></code>.
</p>
</li>
<li> <p><code>GVectors</code>s: Vector of two integers indicating number of geometries and number of fields. Can be obtained using <code><a href="#topic+dim">dim()</a></code>, plus <code><a href="#topic+nrow">nrow()</a></code> and <code><a href="#topic+ncol">ncol()</a></code>.
</p>
</li></ul>
</dd>
<dt><code>extent</code></dt><dd><p>Numeric vector with four values (<code>GSpatial</code> objects, including <code>GRegion</code>s, <code>GRaster</code>s, and <code>GVector</code>s): Extent of the object listed in order from westernmost longitude, easternmost longitude, southernmost latitude, northernmost latitude. Can be obtained using <code><a href="#topic+ext">ext()</a></code>.</p>
</dd>
<dt><code>zextent</code></dt><dd><p>Numeric (<code>GSpatial</code> objects, including <code>GRegion</code>s, <code>GRaster</code>s, and <code>GVector</code>s): Bottom- and top-most extents of 3D <code>GRaster</code>s and <code>GVector</code>s. Can be obtained using <code><a href="#topic+zext">zext()</a></code>.</p>
</dd>
<dt><code>geometry</code></dt><dd><p>Character (<code>GVectors</code>s): Either <code>points</code>, <code>lines</code>, or <code>polygons</code>. Can be obtained using <code><a href="#topic+geomtype">geomtype()</a></code>.</p>
</dd>
<dt><code>nLayers</code></dt><dd><p>Integer (<code>GRaster</code>s): Number of layers (&quot;stacked&quot; rasters&ndash;different from number of depths of 3D rasters). Can be obtained using <code><a href="#topic+nlyr">nlyr()</a></code>.</p>
</dd>
<dt><code>nGeometries</code></dt><dd><p>Integer (<code>GVector</code>s): Number of features (points, lines, or polygons). Can be obtained using <code><a href="#topic+nrow">nrow()</a></code>.</p>
</dd>
<dt><code>datatypeGRASS</code></dt><dd><p>Character (<code>GRaster</code>s): Type of data stored in a raster, as interpreted by <code>GRASS</code>. This is either <code>CELL</code> (integers), <code>FCELL</code> (floating-point values), or <code>DCELL</code> (double-values). Can be obtained using <code><a href="#topic+datatype">datatype()</a></code>.</p>
</dd>
<dt><code>resolution</code></dt><dd><p>Vector of two numeric values (<code>GRegion</code>s, including <code>GRaster</code>s): Size of a raster cell in the east-west direction and in the north-south direction. Can be obtained using <code><a href="#topic+res">res()</a></code> and <code><a href="#topic+res3d">res3d()</a></code>.</p>
</dd>
<dt><code>minVal,maxVal</code></dt><dd><p>Numeric (<code>GRaster</code>s): Minimum and maximum value across all cells. Can be obtained using <code><a href="#topic+minmax">minmax()</a></code>.</p>
</dd>
<dt><code>activeCat</code></dt><dd><p>Integer (<code>GRaster</code>s): Column index of the category labels. Must be &gt;0. Note that from the user's standpoint, 1 is subtracted from this number. So a value if <code style="white-space: pre;">&#8288;@activeCat&#8288;</code> is <code>2</code>, then the user would see &quot;1&quot; when printed. Can be obtained using <code><a href="#topic+activeCat">activeCat()</a></code>.</p>
</dd>
<dt><code>levels</code></dt><dd><p>List of <code>data.table</code>s (<code>GRaster</code>s): Tables for categorical rasters. If a raster is not categorical, the <code>data.table</code> is <code>NULL</code>, as in <code>data.table(NULL)</code>. Can be obtained using <code>levels()</code> or <code>cats()</code>.</p>
</dd>
<dt><code>table</code></dt><dd><p><code>data.table</code> (<code>GVector</code>s): Table with metadata, one row per geometry (point, line, or plane). If no table is associated with the vector, this must be <code>data.table(NULL)</code>. The column with the category value is given in <code style="white-space: pre;">&#8288;@catName&#8288;</code>.</p>
</dd>
<dt><code>catName</code></dt><dd><p>Character (<code>GVector</code>s): Name of the column in the vector's database that contains category values (integers).</p>
</dd>
</dl>

<hr>
<h2 id='grassGUI+2Cmissing-method'>Start the GRASS GUI (potentially dangerous!)</h2><span id='topic+grassGUI+2Cmissing-method'></span><span id='topic+grassGUI'></span>

<h3>Description</h3>

<p>This function starts the <strong>GRASS</strong> GUI. It is provided merely as a utility... in most cases, it should <em>not</em> be used if you are doing any kind of analysis of rasters or vectors using <strong>fasterRaster</strong>. The reason for this prohibition is that <strong>fasterRaster</strong> objects, like <code>GRaster</code>s and <code>GVector</code>s, are really &quot;pointers&quot; to objects in <strong>GRASS</strong>. If <strong>fasterRaster</strong> points to a <strong>GRASS</strong> object that is changed in <strong>GRASS</strong> but not <strong>R</strong>, then <strong>fasterRaster</strong> will not &quot;know&quot; about it, so changed won't be reflected in the <strong>fasterRaster</strong> object.
</p>
<p>One aspect of the GUI that is useful but will not change objects is to use it to plot rasters and vectors. However, the a <strong>fasterRaster</strong> object in <strong>R</strong> will have a different name in <strong>GRASS</strong>. The name in <strong>GRASS</strong> of a <code>GVector</code> or <code>GRaster</code> is given by <code><a href="#topic+sources">sources()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'missing'
grassGUI()
</code></pre>


<h3>Value</h3>

<p>Nothing (starts the <strong>GRASS</strong> GUI).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mow">mow()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# DANGER: Making changes to rasters/vectors in the GUI can "break" them in R.
if (interactive()) grassGUI()

}
</code></pre>

<hr>
<h2 id='grassHelp'>Open the help page for a GRASS module</h2><span id='topic+grassHelp'></span>

<h3>Description</h3>

<p>This function opens the manual page for a <strong>GRASS</strong> module (function) in your browser.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grassHelp(x, online = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grassHelp_+3A_x">x</code></td>
<td>
<p>Character: Any of:
</p>

<ul>
<li><p> The name of a <strong>GRASS</strong> module (e.g., <code>"r.mapcalc"</code>).
</p>
</li>
<li> <p><code>"toc"</code>: <strong>GRASS</strong> manual table of contents.
</p>
</li>
<li> <p><code>"index"</code>: Display an index of topics.
</p>
</li></ul>
</td></tr>
<tr><td><code id="grassHelp_+3A_online">online</code></td>
<td>
<p>Logical: If <code>FALSE</code> (default), show the manual page that was included with your installation of <strong>GRASS</strong> on your computer.  If <code>FALSE</code>, show the manual page online (requires an Internet connection). In either case, the manual page will display for the version of <strong>GRASS</strong> you have installed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing (opens a web page).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted() &amp; interactive()) {

# Open help pages for `r.mapcalc` and `r.sun`:
grassHelp("r.mapcalc")
grassHelp("r.sun")

# GRASS table of contents:
grassHelp("toc")

# Index page:
grassHelp("index")

}
</code></pre>

<hr>
<h2 id='grassInfo'>GRASS citation, version, and copyright information</h2><span id='topic+grassInfo'></span>

<h3>Description</h3>

<p>Report the <strong>GRASS</strong> citation, version/release year, version number, or copyright information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grassInfo(x = "citation")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grassInfo_+3A_x">x</code></td>
<td>
<p>Character: What to return. Any of:
</p>

<ul>
<li> <p><code>"citation"</code> (default)
</p>
</li>
<li> <p><code>"copyright"</code>: Copyright information
</p>
</li>
<li> <p><code>"version"</code>: Version number and release year
</p>
</li>
<li> <p><code>"versionNumber"</code>: Version number as numeric, major and minor only (e.g., 8.4)
</p>
</li></ul>

<p>Partial matching is used and case is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Citation
grassInfo()

# Version number
grassInfo("version")

# Version number
grassInfo("versionNumber")

# Version number
grassInfo("versionNumber")

# Copyright
grassInfo("copyright")

}
</code></pre>

<hr>
<h2 id='grassStarted'>Has &quot;GRASS&quot; been started or not?</h2><span id='topic+grassStarted'></span>

<h3>Description</h3>

<p>Returns <code>TRUE</code> or <code>FALSE</code>, depending on whether a <strong>GRASS</strong> connection has been made or not within the current <strong>R</strong> session. Usually used only by developers. <strong>GRASS</strong> is started the first time <code><a href="#topic+fast">fast()</a></code> is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grassStarted()
</code></pre>


<h3>Value</h3>

<p>Logical.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
grassStarted()

</code></pre>

<hr>
<h2 id='grid+2CGRaster-method'>Create a grid GVector</h2><span id='topic+grid+2CGRaster-method'></span><span id='topic+grid'></span><span id='topic+grid+2CGVector-method'></span>

<h3>Description</h3>

<p>This function creates a <code>GVector</code> of &quot;wall-to-wall&quot; cells (like a lattice). The input can be a <code>GVector</code> or <code>GRaster</code>, which provides the extent of the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
grid(x, nx = NULL, ny = NULL, use = "number", angle = 0)

## S4 method for signature 'GVector'
grid(x, nx = NULL, ny = NULL, use = "number", angle = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> or <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="grid+2B2CGRaster-method_+3A_nx">nx</code>, <code id="grid+2B2CGRaster-method_+3A_ny">ny</code></td>
<td>
<p>Integer or numeric:
</p>

<ul>
<li><p> If <code>use</code> is <code>"number"</code>, then these values represent the number of rows and columns in the grid.
</p>
</li>
<li><p> If <code>use</code> is <code>size</code>, then these values represent the size of the cells in the x- and y-dimensions.
</p>
</li></ul>
</td></tr>
<tr><td><code id="grid+2B2CGRaster-method_+3A_use">use</code></td>
<td>
<p>Character: How to generate the grid. If this is <code>number</code> (default), then <code>nx</code> and <code>ny</code> are taken to be the number of grid cells. If <code>size</code>, then <code>nx</code> and <code>ny</code> are taken to be the size of the grid cells.</p>
</td></tr>
<tr><td><code id="grid+2B2CGRaster-method_+3A_angle">angle</code></td>
<td>
<p>Numeric: Degrees by which to rotate grid (from north, clockwise).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hexagons">hexagons()</a></code>, module <code>v.mkgrid</code> in <strong>GRASS</strong>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)

# Points vector of specimens of species in the plant genus Dypsis
madCoast0 &lt;- fastData("madCoast0")

# Convert sf to a GVector:
coast &lt;- fast(madCoast0)

### grid

# grid specified by number of cells in x-dimension
g1 &lt;- grid(coast, nx = 10)
plot(coast, col = "cornflowerblue")
plot(g1, add = TRUE)

# grid specified by number of cells in x- and y-dimension
g2 &lt;- grid(coast, nx = 10, ny = 5)
plot(coast, col = "cornflowerblue")
plot(g2, add = TRUE)

# grid specified by size of cells in both dimensions
g3 &lt;- grid(coast, nx = 1250, ny = 2000, use = "size")
plot(coast, col = "cornflowerblue")
plot(g3, add = TRUE)

### hexagons

hexes &lt;- hexagons(coast, ny = 10)
plot(hexes)
plot(coast, lwd = 2, add = TRUE)

hexes &lt;- hexagons(coast, ny = 10, expand = c(0.3, 0.1))
plot(hexes)
plot(coast, lwd = 2, add = TRUE)

}
</code></pre>

<hr>
<h2 id='head+2CGVector-method'>Return first or last part of the data frame of a GVector</h2><span id='topic+head+2CGVector-method'></span><span id='topic+head'></span><span id='topic+tail+2CGVector-method'></span><span id='topic+tail'></span>

<h3>Description</h3>

<p>Return the first or last part of a <code>GVector</code>'s data table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector'
head(x, n = 6L, keepnums = TRUE, ...)

## S4 method for signature 'GVector'
tail(x, n = 6L, keepnums = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="head+2B2CGVector-method_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="head+2B2CGVector-method_+3A_n">n</code></td>
<td>
<p>Integer: Number of rows to display.</p>
</td></tr>
<tr><td><code id="head+2B2CGVector-method_+3A_keepnums">keepnums</code></td>
<td>
<p>Logical: If no <code>rownames</code> are present, create them. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="head+2B2CGVector-method_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> or <code>data.frame</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+headtail">terra::head()</a></code>, <code><a href="terra.html#topic+headtail">terra::tail()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)

# Example data:
madCoast4 &lt;- fastData("madCoast4")
madRivers &lt;- fastData("madRivers")
madDypsis &lt;- fastData("madDypsis")

# Convert sf vectors to GVectors:
coast &lt;- fast(madCoast4)
rivers &lt;- fast(madRivers)
dypsis &lt;- fast(madDypsis)

# Geographic properties:
ext(rivers) # extent
crs(rivers) # coordinate reference system
st_crs(rivers) # coordinate reference system
coordRef(rivers) # coordinate reference system

# Column names and data types:
names(coast)
datatype(coast)

# Points, lines, or polygons?
geomtype(dypsis)
geomtype(rivers)
geomtype(coast)

is.points(dypsis)
is.points(coast)

is.lines(rivers)
is.lines(dypsis)

is.polygons(coast)
is.polygons(dypsis)

# Number of dimensions:
topology(rivers)
is.2d(rivers) # 2-dimensional?
is.3d(rivers) # 3-dimensional?

# Just the data table:
as.data.frame(rivers)
as.data.table(rivers)

# Top/bottom of the data table:
head(rivers)
tail(rivers)

# Vector or table with just selected columns:
names(rivers)
rivers$NAME
rivers[[c("NAM", "NAME_0")]]
rivers[[c(3, 5)]]

# Select geometries/rows of the vector:
nrow(rivers)
selected &lt;- rivers[2:6]
nrow(selected)

# Plot:
plot(coast)
plot(rivers, col = "blue", add = TRUE)
plot(selected, col = "red", lwd = 2, add = TRUE)

# Vector math:
hull &lt;- convHull(dypsis)

un &lt;- union(coast, hull)
sameAsUnion &lt;- coast + hull
plot(un)
plot(sameAsUnion)

inter &lt;- intersect(coast, hull)
sameAsIntersect &lt;- coast * hull
plot(inter)
plot(sameAsIntersect)

er &lt;- erase(coast, hull)
sameAsErase &lt;- coast - hull
plot(er)
plot(sameAsErase)

xr &lt;- xor(coast, hull)
sameAsXor &lt;- coast / hull
plot(xr)
plot(sameAsXor)

# Vector area and length:
expanse(coast, unit = "km") # polygons areas
expanse(rivers, unit = "km") # river lengths

### Fill holes

# First, we will make some holes by creating buffers around points.
buffs &lt;- buffer(dypsis, 500)

holes &lt;- coast - buffs
plot(holes)

filled &lt;- fillHoles(holes, fail = FALSE)

}
</code></pre>

<hr>
<h2 id='hexagons+2CGRaster-method'>Create a hexagonal grid</h2><span id='topic+hexagons+2CGRaster-method'></span><span id='topic+hexagons'></span><span id='topic+hexagons+2CGVector-method'></span>

<h3>Description</h3>

<p>This function creates a <code>GVector</code> of &quot;wall-to-wall&quot; hexagons. The input can be a <code>GVector</code> or <code>GRaster</code>, which provides the extent of the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
hexagons(x, ny = 10, expand = 0, angle = 0)

## S4 method for signature 'GVector'
hexagons(x, ny = 10, expand = 0, angle = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hexagons+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> or <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="hexagons+2B2CGRaster-method_+3A_ny">ny</code></td>
<td>
<p>Integer or numeric integer: Number of rows of hexagons that span the extent of object <code>x</code>.</p>
</td></tr>
<tr><td><code id="hexagons+2B2CGRaster-method_+3A_expand">expand</code></td>
<td>
<p>One or two numeric values: Expand the region by this proportion in both directions (a single value) or in the x- and y-dimensions separately. Expanding the region can be helpful to ensure the entire area of interest is covered by polygons, which can otherwise leave gaps at the edges. The number of rows and columns will be increased, but the number of hexagons that span <code>x</code> will still be <code>ny</code>.</p>
</td></tr>
<tr><td><code id="hexagons+2B2CGRaster-method_+3A_angle">angle</code></td>
<td>
<p>Numeric: Degrees by which to rotate grid (from north, clockwise).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grid">grid()</a></code>, module <code>v.mkgrid</code> in <strong>GRASS</strong>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)

# Points vector of specimens of species in the plant genus Dypsis
madCoast0 &lt;- fastData("madCoast0")

# Convert sf to a GVector:
coast &lt;- fast(madCoast0)

### grid

# grid specified by number of cells in x-dimension
g1 &lt;- grid(coast, nx = 10)
plot(coast, col = "cornflowerblue")
plot(g1, add = TRUE)

# grid specified by number of cells in x- and y-dimension
g2 &lt;- grid(coast, nx = 10, ny = 5)
plot(coast, col = "cornflowerblue")
plot(g2, add = TRUE)

# grid specified by size of cells in both dimensions
g3 &lt;- grid(coast, nx = 1250, ny = 2000, use = "size")
plot(coast, col = "cornflowerblue")
plot(g3, add = TRUE)

### hexagons

hexes &lt;- hexagons(coast, ny = 10)
plot(hexes)
plot(coast, lwd = 2, add = TRUE)

hexes &lt;- hexagons(coast, ny = 10, expand = c(0.3, 0.1))
plot(hexes)
plot(coast, lwd = 2, add = TRUE)

}
</code></pre>

<hr>
<h2 id='hillshade+2CGRaster-method'>Hillshading</h2><span id='topic+hillshade+2CGRaster-method'></span><span id='topic+hillshade'></span>

<h3>Description</h3>

<p>Hillshade rasters are often used for display purposes because they make topographical relief look &quot;real&quot; to the eye.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
hillshade(x, angle = 45, direction = 0, zscale = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hillshade+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> (typically representing elevation).</p>
</td></tr>
<tr><td><code id="hillshade+2B2CGRaster-method_+3A_angle">angle</code></td>
<td>
<p>Numeric: The altitude of the sun above the horizon in degrees. Valid values are in the range [0, 90], and the default value is 45 (half way from the horizon to overhead).</p>
</td></tr>
<tr><td><code id="hillshade+2B2CGRaster-method_+3A_direction">direction</code></td>
<td>
<p>The direction (azimuth) in which the sun is shining in degrees. Valid values are in the range 0 to 360. The default is 0, meaning the sun is at due south (180 degrees) and shining due north (0 degrees). Note that in this function, 0 corresponds to north and 180 to south, but in the <strong>GRASS</strong> module <code>r.relief</code>, &quot;east orientation&quot; is used (0 is east, 90 is north, etc.).</p>
</td></tr>
<tr><td><code id="hillshade+2B2CGRaster-method_+3A_zscale">zscale</code></td>
<td>
<p>Numeric: Value by which to exaggerate terrain. The default is 1.  Numbers greater than this will increase apparent relief, and less than this (even negative) will diminish it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")

# Convert a SpatRaster to a GRaster
elev &lt;- fast(madElev)

# Calculate all topographic metrics
topos &lt;- terrain(elev, v = "*")
topos

plot(topos) # NB Aspect has values of NA when it cannot be defined

# Calculate a hillshade raster
hs &lt;- hillshade(elev)
plot(hs)

}
</code></pre>

<hr>
<h2 id='hist+2CGRaster-method'>Plot a histogram of raster values</h2><span id='topic+hist+2CGRaster-method'></span><span id='topic+hist'></span>

<h3>Description</h3>

<p>This function creates a histogram of values in <code>GRaster</code>. The function is modeled after <code><a href="graphics.html#topic+hist">graphics::hist()</a></code>, but actually uses <code><a href="graphics.html#topic+barplot">graphics::barplot()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
hist(x, layer, maxnl = 16, bins = 30, freq = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hist+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="hist+2B2CGRaster-method_+3A_layer">layer</code></td>
<td>
<p>Character, numeric, or integer: Indicates which layer of a multi-layer <code>GRaster</code> for which to plot a histogram. The layer can be identified using its <code><a href="base.html#topic+name">name()</a></code> (character) or index (numeric or integer). If this is missing, then up to <code>maxnl</code> layers are plotted.</p>
</td></tr>
<tr><td><code id="hist+2B2CGRaster-method_+3A_maxnl">maxnl</code></td>
<td>
<p>Maximum number of layers for which to create histograms. This is 16 by default, but ignored if <code>layer</code> is defined.</p>
</td></tr>
<tr><td><code id="hist+2B2CGRaster-method_+3A_bins">bins</code></td>
<td>
<p>Positive numeric integer: Number of bins in which to divide values of a raster with continuous values. For <code>integer</code> and categorical rasters, each value is tallied.</p>
</td></tr>
<tr><td><code id="hist+2B2CGRaster-method_+3A_freq">freq</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), plot the frequency of values. If <code>FALSE</code>, plot the density of values (i.e., the number in each bin divided by the total number of cells with non-<code>NA</code> values).</p>
</td></tr>
<tr><td><code id="hist+2B2CGRaster-method_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code><a href="graphics.html#topic+barplot">graphics::barplot()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of <code>data.frame</code>s (invisibly), one per layer plotted, and creates a graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Example data
madElev &lt;- fastData("madElev") # elevation raster
madLANDSAT &lt;- fastData("madLANDSAT") # multi-layer raster
madRivers &lt;- fastData("madRivers") # lines vector

# Convert SpatRaster to GRaster and SpatVector to GVector
elev &lt;- fast(madElev)
rivers &lt;- fast(madRivers)
landsat &lt;- fast(madLANDSAT)

# Plot:
plot(elev)
plot(rivers, add = TRUE)

# Histograms:
hist(elev)
hist(landsat)

# Plot surface reflectance in RGB:
plotRGB(landsat, 3, 2, 1) # "natural" color
plotRGB(landsat, 4, 1, 2, stretch = "lin") # emphasize near-infrared (vegetation)

# Make composite map from RGB layers and plot in grayscale:
comp &lt;- compositeRGB(r = landsat[[3]], g = landsat[[2]], b = landsat[[1]])
grays &lt;- paste0("gray", 0:100)
plot(comp, col = grays)

}
</code></pre>

<hr>
<h2 id='horizonHeight+2CGRaster-method'>Horizon height</h2><span id='topic+horizonHeight+2CGRaster-method'></span><span id='topic+horizonHeight'></span>

<h3>Description</h3>

<p><code>horizonHeight()</code> uses a raster representing elevation to calculate the height of the horizon in a particular direction from each cell on a raster. Height is expressed in radians or degrees from the horizontal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
horizonHeight(
  x,
  units = "radians",
  step = 90,
  northIs0 = TRUE,
  bufferZone = 0,
  distance = 1,
  maxDist = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="horizonHeight+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="horizonHeight+2B2CGRaster-method_+3A_units">units</code></td>
<td>
<p>Character: Units of the height. Either <code>radians</code> (default) or <code>degrees</code>. Partial matching is used.</p>
</td></tr>
<tr><td><code id="horizonHeight+2B2CGRaster-method_+3A_step">step</code></td>
<td>
<p>Numeric integer between 0 and 360, inclusive: Angle step size (in degrees) for calculating horizon height. The direction in which horizon height is calculated is incremented from 0 to 360, with the last value excluded.</p>
</td></tr>
<tr><td><code id="horizonHeight+2B2CGRaster-method_+3A_northis0">northIs0</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), horizon height calculated in the 0-degree direction will be facing north,  and proceed clockwise So, under &quot;north orientation&quot;, 0 is north, 90 east, 180 south, and 270 west. If <code>FALSE</code>, angles are in &quot;east orientation&quot;, and proceed counterclockwise from east. So, east is 0, north 90, west 180, and south 270. North orientation is the default for this function in <strong>R</strong>, but east orientation is the default in the <strong>GRASS</strong> module <code>r.horizon</code>. <strong>Note:</strong> The <code><a href="#topic+sun">sun()</a></code> function requires aspect to be in east orientation.</p>
</td></tr>
<tr><td><code id="horizonHeight+2B2CGRaster-method_+3A_bufferzone">bufferZone</code></td>
<td>
<p>Numeric &gt;= 0 (default is 0): A buffer of the specified width will be generated around the raster before calculation of horizon angle. If the coordinate system is in longitude/latitude (e.g., WGS84 or NAD83), then this is specified in degrees. Otherwise units are map units (usually meters).</p>
</td></tr>
<tr><td><code id="horizonHeight+2B2CGRaster-method_+3A_distance">distance</code></td>
<td>
<p>Numeric between 0.5 and 1.5, inclusive (default is 1): This determines the step size when searching for the horizon from a given point. The default value of 1 goes cell-by-cell (i.e., search distance step size is one cell width).</p>
</td></tr>
<tr><td><code id="horizonHeight+2B2CGRaster-method_+3A_maxdist">maxDist</code></td>
<td>
<p>Either <code>NULL</code> (default) or numeric &gt;= 0: Maximum distance to consider when finding horizon height in meters. If <code>NULL</code>, the maximum distance is the full extent of the raster. Smaller values can decrease run time but also reduce accuracy.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code> with one or more layers. The layers will be named <code>height_</code><em>xyz</em>, where <em>xyz</em> is degrees from north or from east, depending on whether north or east orientation is used.
</p>


<h3>See Also</h3>

<p><strong>GRASS</strong> manual page for module <code>r.horizon</code> (see <code>grassHelp("r.horizon")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")

# convert a SpatRaster to a GRaster
elev &lt;- fast(madElev)

# calculate horizon height in north and east directions
hhNorth &lt;- horizonHeight(elev)
hhNorth
plot(hhNorth)

# calculate horizon height in east and north directions
hhEast &lt;- horizonHeight(elev, northIs0 = FALSE)
hhEast
plot(hhEast)

}
</code></pre>

<hr>
<h2 id='init+2CGRaster-method'>GRaster with values equal to row, column, coordinate, regular, or &quot;chess&quot;</h2><span id='topic+init+2CGRaster-method'></span><span id='topic+init'></span>

<h3>Description</h3>

<p>This function can be used to make a <code>GRaster</code> with cell values equal to the cell center's longitude, latitude, row, or column, or in a &quot;chess&quot;-like or &quot;regular&quot; pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
init(x, fun, odd = TRUE, vals = c(0, 1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="init+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> to be used as a template.</p>
</td></tr>
<tr><td><code id="init+2B2CGRaster-method_+3A_fun">fun</code></td>
<td>
<p>Character: Any of:
</p>

<ul>
<li> <p><code>"x"</code> or <code>"y"</code>: Cell longitude or latitude
</p>
</li>
<li> <p><code>"row"</code> or <code>"col"</code>: Cell row or column
</p>
</li>
<li> <p><code>"chess"</code>: Alternating values.
</p>
</li>
<li> <p><code>"regular"</code>: Evenly-spaced cells with the same value.
</p>
</li></ul>
</td></tr>
<tr><td><code id="init+2B2CGRaster-method_+3A_odd">odd</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), and <code>fun</code> is <code>"chess"</code>, then the top left cell in the raster will be a &quot;negative&quot; cell. If <code>FALSE</code>, then the top left cell with be &quot;positive&quot;.</p>
</td></tr>
<tr><td><code id="init+2B2CGRaster-method_+3A_vals">vals</code></td>
<td>
<p>Vector of two numeric values: If <code>fun</code> is <code>"chess"</code> or <code>"regular"</code>, then assign the first value to &quot;positive&quot; cells and the second value to &quot;negative&quot; cells. The default is <code>c(1, 0)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code> with as many layers as <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+init">terra::init()</a></code>, <code><a href="#topic+longlat">longlat()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Elevation raster, rivers vector
madElev &lt;- fastData("madElev")

# Convert to a GRaster
elev &lt;- fast(madElev)

# Cell coordinates
init(elev, "x")
init(elev, "y")

# Cell row or column
init(elev, "row")
init(elev, "col")

# Chess
elevAgg &lt;- aggregate(elev, 32) # make cells bigger so we can see them

chessOdd &lt;- init(elevAgg, "chess")
chessEven &lt;- init(elevAgg, "chess", odd = FALSE)

chess &lt;- c(chessOdd, chessEven)
names(chess) &lt;- c("odd", "even")
plot(chess)

# Chess with user-defined values
elevAgg &lt;- aggregate(elev, 32) # make cells bigger so we can see

chessOdd13 &lt;- init(elevAgg, "chess", vals = c(0, 13))
chessEven13 &lt;- init(elevAgg, "chess", odd = FALSE, vals = c(0, 13))

chess13 &lt;- c(chessOdd13, chessEven13)
names(chess13) &lt;- c("odd", "even")
plot(chess13)

# Regular
elevAgg &lt;- aggregate(elev, 32) # make cells bigger so we can see

regOdd &lt;- init(elevAgg, "regular")
regEven &lt;- init(elevAgg, "regular", odd = FALSE)

reg &lt;- c(regOdd, regEven)
names(reg) &lt;- c("odd", "even")
plot(reg)

}
</code></pre>

<hr>
<h2 id='interpIDW+2CGVector+2CGRaster-method'>Interpolate values at points to a GRaster using inverse-distance weighting</h2><span id='topic+interpIDW+2CGVector+2CGRaster-method'></span><span id='topic+interpIDW'></span>

<h3>Description</h3>

<p>This function interpolates values from a set of points to a raster using inverse distance weighting (IDW).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector,GRaster'
interpIDW(x, y, field, nPoints = Inf, power = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpIDW+2B2CGVector+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A &quot;points&quot; <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="interpIDW+2B2CGVector+2B2CGRaster-method_+3A_y">y</code></td>
<td>
<p>A <code>GRaster</code> to serve as a template for interpolation: Only points in <code>x</code> that fall inside the extent of the raster will be used for interpolation. You can increase the extent of a <code>GRaster</code> using <code><a href="#topic+extend">extend()</a></code>.</p>
</td></tr>
<tr><td><code id="interpIDW+2B2CGVector+2B2CGRaster-method_+3A_field">field</code></td>
<td>
<p>Character, integer, or numeric integer: Name or index of the column in <code>x</code> with values to interpolate. If <code>NULL</code> and if <code>x</code> is a 3-dimensional &quot;points&quot; <code>GVector</code>, then the interpolation will act on the z-coordinate of each point.</p>
</td></tr>
<tr><td><code id="interpIDW+2B2CGVector+2B2CGRaster-method_+3A_npoints">nPoints</code></td>
<td>
<p>Integer or numeric integer: Number of nearest points to use for interpolation. The default is to use all points (<code>Inf</code>).</p>
</td></tr>
<tr><td><code id="interpIDW+2B2CGVector+2B2CGRaster-method_+3A_power">power</code></td>
<td>
<p>Numeric value &gt; 0: Power to which to take distance when interpolating. The default value is two, so the value of each point used for interpolation is <code class="reqn">1 / d^2</code> where <em>d</em> is distance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+interpIDW">terra::interpIDW()</a></code>, <code><a href="#topic+interpSplines">interpSplines()</a></code>, <code><a href="#topic+fillNAs">fillNAs()</a></code>, <strong>GRASS</strong> module <code>v.surf.idw</code> (se <code>grassHelp("v.surf.idw")</code>)
</p>

<hr>
<h2 id='interpSplines+2CGVector+2CGRaster-method'>Interpolate values at points to a GRaster using splines</h2><span id='topic+interpSplines+2CGVector+2CGRaster-method'></span><span id='topic+interpSplines'></span>

<h3>Description</h3>

<p>This function interpolates values in the data table of a &quot;points&quot; <code>GVector</code> to a <code>GRaster</code> using splines with Tykhonov regularization to avoid overfitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector,GRaster'
interpSplines(
  x,
  y,
  field,
  method = "bilinear",
  lambda = NULL,
  solver = "Cholesky",
  xlength = NULL,
  ylength = NULL,
  interpolate = TRUE,
  verbose = is.null(lambda)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpSplines+2B2CGVector+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A &quot;points&quot; <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="interpSplines+2B2CGVector+2B2CGRaster-method_+3A_y">y</code></td>
<td>
<p>A <code>GRaster</code>: The output will have the same extent and resolution as this raster.</p>
</td></tr>
<tr><td><code id="interpSplines+2B2CGVector+2B2CGRaster-method_+3A_field">field</code></td>
<td>
<p>Character or integer or numeric integer: Name or index of the column in <code>x</code> with values to interpolate. If <code>NULL</code> and if <code>x</code> is a 3-dimensional &quot;points&quot; <code>GVector</code>, then the interpolation will act on the z-coordinate of each point.</p>
</td></tr>
<tr><td><code id="interpSplines+2B2CGVector+2B2CGRaster-method_+3A_method">method</code></td>
<td>
<p>Character: The method to use for interpolation can be either <code>"bilinear"</code> (default) or <code>"bicubic"</code>. Partial matching is used.</p>
</td></tr>
<tr><td><code id="interpSplines+2B2CGVector+2B2CGRaster-method_+3A_lambda">lambda</code></td>
<td>
<p>Either <code>NULL</code> (default) or numeric value &gt; 0: The Tykhonov regularization parameter. If <code>NULL</code>, cross-validation will be used to determine the optimal parameter value. Cross-validation can take quite a while. If you use cross-validation, the output will either be a <code>GRaster</code> or a <code>data.frame</code>, depending on the value of <code>interpolate</code>.</p>
</td></tr>
<tr><td><code id="interpSplines+2B2CGVector+2B2CGRaster-method_+3A_solver">solver</code></td>
<td>
<p>Character: Type of solver to use. Can be either of <code>"Cholesky"</code> or <code>"cg"</code>. Partial matching is used and case is ignored.</p>
</td></tr>
<tr><td><code id="interpSplines+2B2CGVector+2B2CGRaster-method_+3A_xlength">xlength</code>, <code id="interpSplines+2B2CGVector+2B2CGRaster-method_+3A_ylength">ylength</code></td>
<td>
<p>Either <code>NULL</code> (default), or numeric &gt; 0: Length of the spline step in the x- and y-directions. If <code>NULL</code>, these will be set to 4 times the length of the extent in the respective direction.</p>
</td></tr>
<tr><td><code id="interpSplines+2B2CGVector+2B2CGRaster-method_+3A_interpolate">interpolate</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), then create a <code>GRaster</code> with interpolated values. If <code>FALSE</code>, return a table with <code>lambda</code> values from cross-validation. This argument is ignored if <code>lambda</code> is a numeric value.</p>
</td></tr>
<tr><td><code id="interpSplines+2B2CGVector+2B2CGRaster-method_+3A_verbose">verbose</code></td>
<td>
<p>Logical: if <code>TRUE</code>, display progress.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you receive the error, &quot;No data within this subregion. Consider increasing spline step values, try increasing the values of <code>xlength</code> and <code>ylength</code>.
</p>
<p>If cross-validation takes too long, or other warnings/errors persist, you can randomly subsample <code>x</code> to ~100 points to get an optimum value of <code>lambda</code> (using <code>interpolate = FALSE</code>), then use this value in the same function again without cross-validation (setting <code>lambda</code> equal to this value and <code>interpolate = TRUE</code>).
</p>


<h3>Value</h3>

<p>Output depends on values of <code>lambda</code> and <code>interpolate</code>:
</p>

<ul>
<li> <p><code>lambda</code> is <code>NULL</code> and <code>interpolate</code> is <code>TRUE</code>: A <code>GRaster</code> with an attribute named <code>lambdas</code>. This is a <code>data.frame</code> with values of <code>lambda</code> that were assessed, plus <code>mean</code> (mean residual value) and <code>rms</code> (root mean square error). You can see the table using <code>attr(output_raster, "lambdas", exact = TRUE)</code>.
</p>
</li>
<li> <p><code>lambda</code> is <code>NULL</code> and <code>interpolate</code> is <code>FALSE</code>: A <code>data.frame</code> with values of <code>lambdas</code> that were assessed, plus <code>mean</code> (mean residual value) and <code>rms</code> (root mean square error). You can see the table using <code>attr(output_raster, "lambdas", exact = TRUE)</code>.
</p>
</li>
<li> <p><code>lambda</code> is a number (<code>interpolate</code> is ignored): A <code>GRaster</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+interpIDW">interpIDW()</a></code>, <code><a href="#topic+fillNAs">fillNAs()</a></code>, <strong>GRASS</strong> module <code>v.surf.bspline</code> (see <code>grassHelp("v.surf.bspline")</code>)
</p>

<hr>
<h2 id='intersect+2CGVector+2CGVector-method'>Intersection of two GVectors</h2><span id='topic+intersect+2CGVector+2CGVector-method'></span><span id='topic+intersect'></span>

<h3>Description</h3>

<p>The <code>intersect()</code> function selects the area of overlap between two <code>GVector</code>s of the same type (points, lines or polygons). You can also use the <code>*</code> operator (e.g., <code>vect1 * vect2</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector,GVector'
intersect(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intersect+2B2CGVector+2B2CGVector-method_+3A_x">x</code>, <code id="intersect+2B2CGVector+2B2CGVector-method_+3A_y">y</code></td>
<td>
<p><code>GVector</code>s.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+c">c()</a></code>, <code><a href="#topic+aggregate">aggregate()</a></code>, <code><a href="#topic+crop">crop()</a></code>, <code><a href="#topic+union">union()</a></code>, <code><a href="#topic+xor">xor()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)

# Polygon of coastal Madagascar and Dypsis specimens
madCoast4 &lt;- fastData("madCoast4") # polygons
madDypsis &lt;- fastData("madDypsis") # points

# Convert vectors:
coast4 &lt;- fast(madCoast4)
dypsis &lt;- fast(madDypsis)

# Create another polygons vector from a convex hull around Dypsis points
hull &lt;- convHull(dypsis)

### union()

unioned &lt;- union(coast4, hull)
plot(unioned)

plus &lt;- coast4 + hull # same as union()

### intersect

inter &lt;- intersect(coast4, hull)
plot(coast4)
plot(hull, border = "red", add = TRUE)
plot(inter, border = "blue", add = TRUE)

### xor

xr &lt;- xor(coast4, hull)
plot(coast4)
plot(xr, border = "blue", add = TRUE)

### erase

erased &lt;- erase(coast4, hull)
plot(coast4)
plot(erased, border = "blue", add = TRUE)

minus &lt;- coast4 - hull # same as erase()

}
</code></pre>

<hr>
<h2 id='is.2d+2CGSpatial-method'>Test if a GRaster or GVector is 2- or 3-dimensional</h2><span id='topic+is.2d+2CGSpatial-method'></span><span id='topic+is.2d'></span><span id='topic+is.3d+2CGSpatial-method'></span><span id='topic+is.3d'></span>

<h3>Description</h3>

<p>Test whether a <code>GRaster</code> or <code>GVector</code> is 2- or 3-dimensional.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GSpatial'
is.2d(x)

## S4 method for signature 'GSpatial'
is.3d(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.2d+2B2CGSpatial-method_+3A_x">x</code></td>
<td>
<p>An object that inherits from the <code>GSpatial</code> class (i.e., a <code>GRaster</code> or <code>GVector</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+topology">topology()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Example data
madElev &lt;- fastData("madElev")
madForest2000 &lt;- fastData("madForest2000")
madCoast0 &lt;- fastData("madCoast0")
madRivers &lt;- fastData("madRivers")
madDypsis &lt;- fastData("madDypsis")

### GRaster properties

# convert SpatRasters to GRasters
elev &lt;- fast(madElev)
forest &lt;- fast(madForest2000)

# plot
plot(elev)

dim(elev) # rows, columns, depths, layers
nrow(elev) # rows
ncol(elev) # columns
ndepth(elev) # depths
nlyr(elev) # layers

res(elev) # resolution

ncell(elev) # cells
ncell3d(elev) # cells (3D rasters only)

topology(elev) # number of dimensions
is.2d(elev) # is it 2D?
is.3d(elev) # is it 3D?

minmax(elev) # min/max values

# name of object in GRASS
sources(elev)

# "names" of the object
names(elev)

# coordinate reference system
crs(elev)

# extent (bounding box)
ext(elev)

# data type
datatype(elev)

# assigning
copy &lt;- elev
copy[] &lt;- pi # assign all cells to the value of pi
copy

# concatenating multiple GRasters
rasts &lt;- c(elev, forest)
rasts

# adding a raster "in place"
add(rasts) &lt;- ln(elev)
rasts

# subsetting
rasts[[1]]
rasts[["madForest2000"]]

# assigning
rasts[[4]] &lt;- elev &gt; 500

# number of layers
nlyr(rasts)

# names
names(rasts)
names(rasts) &lt;- c("elev_meters", "forest", "ln_elev", "high_elevation")
rasts

### GVector properties

# convert sf vectors to GVectors
coast &lt;- fast(madCoast4)
rivers &lt;- fast(madRivers)
dypsis &lt;- fast(madDypsis)

# extent
ext(rivers)

W(rivers) # western extent
E(rivers) # eastern extent
S(rivers) # southern extent
N(rivers) # northern extent
top(rivers) # top extent (NA for 2D rasters like this one)
bottom(rivers) # bottom extent (NA for 2D rasters like this one)

# coordinate reference system
crs(rivers)
st_crs(rivers)

# column names and data types
names(coast)
datatype(coast)

# name of object in GRASS
sources(rivers)

# points, lines, or polygons?
geomtype(dypsis)
geomtype(rivers)
geomtype(coast)

is.points(dypsis)
is.points(coast)

is.lines(rivers)
is.lines(dypsis)

is.polygons(coast)
is.polygons(dypsis)

# dimensions
nrow(rivers) # how many spatial features
ncol(rivers) # hay many columns in the data frame

# number of geometries and sub-geometries
ngeom(coast)
nsubgeom(coast)

# 2- or 3D
topology(rivers) # dimensionality
is.2d(elev) # is it 2D?
is.3d(elev) # is it 3D?

# Update values from GRASS
# (Reads values from GRASS... will not appear to do anything in this case)
coast &lt;- update(coast)

### operations on GVectors

# convert to data frame
as.data.frame(rivers)
as.data.table(rivers)

# subsetting
rivers[c(1:2, 5)] # select 3 rows/geometries
rivers[-5:-11] # remove rows/geometries 5 through 11
rivers[ , 1] # column 1
rivers[ , "NAM"] # select column
rivers[["NAM"]] # select column
rivers[1, 2:3] # row/geometry 1 and column 2 and 3
rivers[c(TRUE, FALSE)] # select every other geometry (T/F vector is recycled)
rivers[ , c(TRUE, FALSE)] # select every other column (T/F vector is recycled)

# removing data table
noTable &lt;- dropTable(rivers)
noTable
nrow(rivers)
nrow(noTable)

# Refresh values from GRASS
# (Reads values from GRASS... will not appear to do anything in this case
# since the rivers object is up-to-date):
rivers &lt;- update(rivers)

# Concatenating multiple vectors
rivers2 &lt;- rbind(rivers, rivers)
dim(rivers)
dim(rivers2)

}
</code></pre>

<hr>
<h2 id='is.int+2CGRaster-method'>Data type of a raster</h2><span id='topic+is.int+2CGRaster-method'></span><span id='topic+is.int'></span><span id='topic+is.cell+2CGRaster-method'></span><span id='topic+is.cell'></span><span id='topic+is.float+2CGRaster-method'></span><span id='topic+is.float'></span><span id='topic+is.doub+2CGRaster-method'></span><span id='topic+is.doub'></span><span id='topic+is.factor+2CGRaster-method'></span><span id='topic+is.factor'></span>

<h3>Description</h3>

<p>In <strong>fasterRaster</strong>, rasters can have three data types: &quot;factor&quot; (categorical rasters), &quot;integer&quot; (integers), &quot;float&quot; (floating point values, accurate to the 6th to 9th decimal places), and &quot;double&quot; (double-precision values, accurate to the 15th to 17th decimal places). The type of raster can be checked with:
</p>

<ul>
<li> <p><code>is.factor()</code>: The raster will have integer values and categories matched to the integers (see levels()).
</p>
</li>
<li> <p><code>is.int()</code>: Are values integers? Note that <code>is.int()</code> will return <code>FALSE</code> for categorical rasters, even though cell values are technically integers.
</p>
</li>
<li> <p><code>is.cell()</code>: Are values integers (<code>TRUE</code> for <code>integer</code> and categorical rasters).
</p>
</li>
<li> <p><code>is.float()</code>: Are values floating-point precision?
</p>
</li>
<li> <p><code>is.doub()</code>: Are values double-floating point precision?
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
is.int(x)

## S4 method for signature 'GRaster'
is.cell(x)

## S4 method for signature 'GRaster'
is.float(x)

## S4 method for signature 'GRaster'
is.doub(x)

## S4 method for signature 'GRaster'
is.factor(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.int+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+datatype">datatype()</a></code>, <code><a href="terra.html#topic+datatype">terra::datatype()</a></code>, <code><a href="#topic+as.int">as.int()</a></code>, <code><a href="#topic+as.float">as.float()</a></code>, <code><a href="#topic+as.doub">as.doub()</a></code>, <code><a href="#topic+is.factor">is.factor()</a></code>, <code>vignette("GRasters", package = "fasterRaster")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")
madForest2000 &lt;- fastData("madForest2000")

# Convert SpatRasters to GRasters
elev &lt;- fast(madElev)
forest &lt;- fast(madForest2000)

### GRaster properties

# plotting
plot(elev)

# dimensions
dim(elev) # rows, columns, depths, layers
nrow(elev) # rows
ncol(elev) # columns
ndepth(elev) # depths
nlyr(elev) # layers

res(elev) # resolution (2D)
res3d(elev) # resolution (3D)
zres(elev) # vertical resolution
xres(elev) # vertical resolution
yres(elev) # vertical resolution
zres(elev) # vertical resolution (NA because this is a 2D GRaster)

# cell counts
ncell(elev) # cells
ncell3d(elev) # cells (3D rasters only)

# number of NA and non-NA cells
nacell(elev)
nonnacell(elev)

# topology
topology(elev) # number of dimensions
is.2d(elev) # is it 2-dimensional?
is.3d(elev) # is it 3-dimensional?

minmax(elev) # min/max values

# "names" of the object
names(elev)

# coordinate reference system
crs(elev)
st_crs(elev)
coordRef(elev)

# extent (bounding box)
ext(elev)

# vertical extent (not defined for this raster)
zext(elev)

# data type
datatype(elev) # fasterRaster type
datatype(elev, "GRASS") # GRASS type
datatype(elev, "terra") # terra type
datatype(elev, "GDAL") # GDAL type

is.integer(elev)
is.float(elev)
is.double(elev)
is.factor(elev)

# convert data type
as.int(elev) # integer; note that "elev" is already of type "integer"
as.float(elev) # floating-precision
as.doub(elev) # double-precision

# assigning
pie &lt;- elev
pie[] &lt;- pi # assign all cells to the value of pi
pie

# concatenating multiple GRasters
rasts &lt;- c(elev, forest)
rasts

# subsetting
rasts[[1]]
rasts[["madForest2000"]]

# replacing
rasts[[2]] &lt;- 2 * forest
rasts

# adding layers
rasts[[3]] &lt;- elev &gt; 500 # add a layer
rasts &lt;- c(rasts, sqrt(elev)) # add another
add(rasts) &lt;- ln(elev)
rasts

# names
names(rasts)
names(rasts) &lt;- c("elev_meters", "2_x_forest", "high_elevation", "sqrt_elev", "ln_elev")
rasts

# remove a layer
rasts[["2_x_forest"]] &lt;- NULL
rasts

# number of layers
nlyr(rasts)

# correlation and covariance matrices
madLANDSAT &lt;- fastData("madLANDSAT")
landsat &lt;- fast(madLANDSAT) # projects matrix
layerCor(landsat) # correlation
layerCor(landsat, fun = 'cov') # covariance

}
</code></pre>

<hr>
<h2 id='is.lonlat+2Ccharacter-method'>Test if a coordinate reference system is unprojected</h2><span id='topic+is.lonlat+2Ccharacter-method'></span><span id='topic+is.lonlat'></span><span id='topic+is.lonlat+2CGLocation-method'></span><span id='topic+is.lonlat+2Csf-method'></span>

<h3>Description</h3>

<p><code>is.lonlat()</code> attempts to determine if a coordinate reference system is unprojected (e.g., WGS84, NAD83, NAD27, etc.). For <code>GRaster</code>s and <code>GVector</code>s, the function should always be correct. For WKT character strings and <code>sf</code> vectors, it does this by looking for the &quot;CONVERSION[&quot; tag in the WKT string (or the object's WKT string), and if it finds one, returns <code>FALSE</code>. This may not be truthful in all cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character'
is.lonlat(x)

## S4 method for signature 'GLocation'
is.lonlat(x)

## S4 method for signature 'sf'
is.lonlat(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.lonlat+2B2Ccharacter-method_+3A_x">x</code></td>
<td>
<p>A WKT coordinate reference string or an object from which on can be obtained (e.g., a <code>GRaster</code>, <code>GVector</code>, <code>GRegion</code>, <code>GLocation</code>, <code>SpatRaster</code>, <code>SpatVector</code>, or <code>sf</code> object).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical (<code>TRUE</code> if unprojected, <code>FALSE</code> otherwise).
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+is.lonlat">terra::is.lonlat()</a></code>
</p>

<hr>
<h2 id='is.na+2CGRaster-method'>Mathematical operations on each layer of a GRasters</h2><span id='topic+is.na+2CGRaster-method'></span><span id='topic+is.na'></span><span id='topic+not.na+2CGRaster-method'></span><span id='topic+not.na'></span><span id='topic+abs+2CGRaster-method'></span><span id='topic+abs'></span><span id='topic+sin+2CGRaster-method'></span><span id='topic+sin'></span><span id='topic+cos+2CGRaster-method'></span><span id='topic+cos'></span><span id='topic+tan+2CGRaster-method'></span><span id='topic+tan'></span><span id='topic+asin+2CGRaster-method'></span><span id='topic+asin'></span><span id='topic+acos+2CGRaster-method'></span><span id='topic+acos'></span><span id='topic+atan+2CGRaster-method'></span><span id='topic+atan'></span><span id='topic+atan2+2CGRaster+2CGRaster-method'></span><span id='topic+atan2'></span><span id='topic+exp+2CGRaster-method'></span><span id='topic+exp'></span><span id='topic+log1p+2CGRaster-method'></span><span id='topic+log1p'></span><span id='topic+log10p+2CGRaster-method'></span><span id='topic+log10p'></span><span id='topic+log+2CGRaster-method'></span><span id='topic+log'></span><span id='topic+ln+2CGRaster-method'></span><span id='topic+ln'></span><span id='topic+log2+2CGRaster-method'></span><span id='topic+log2'></span><span id='topic+log10+2CGRaster-method'></span><span id='topic+log10'></span><span id='topic+sqrt+2CGRaster-method'></span><span id='topic+sqrt'></span><span id='topic+round+2CGRaster-method'></span><span id='topic+round'></span><span id='topic+floor+2CGRaster-method'></span><span id='topic+floor'></span><span id='topic+ceiling+2CGRaster-method'></span><span id='topic+ceiling'></span><span id='topic+trunc+2CGRaster-method'></span><span id='topic+trunc'></span>

<h3>Description</h3>

<p>You can apply mathematical functions to each layer of a <code>GRaster</code>. The output is a <code>GRaster</code> with the same number or layers as the input. Available functions include:<br />
</p>

<ul>
<li> <p><code>NA</code>s:
</p>

<ul>
<li> <p><code>is.na()</code>
</p>
</li>
<li> <p><code>not.na()</code>
</p>
</li></ul>

</li>
<li><p> Absolute value: <code>abs()</code>
</p>
</li>
<li><p> Trigonometric functions (assumes values are in radians):
</p>

<ul>
<li> <p><code>cos()</code>
</p>
</li>
<li> <p><code>sin()</code>
</p>
</li>
<li> <p><code>tan()</code>
</p>
</li>
<li> <p><code>acos()</code>
</p>
</li>
<li> <p><code>asin()</code>
</p>
</li>
<li> <p><code>atan()</code>
</p>
</li>
<li> <p><code>atan2()</code>
</p>
</li></ul>

</li>
<li><p> Exponential and logarithmic functions:
</p>

<ul>
<li> <p><code>exp()</code>
</p>
</li>
<li> <p><code>log()</code> (natural log)
</p>
</li>
<li> <p><code>ln()</code> (also natural log)
</p>
</li>
<li> <p><code>log2()</code> (log, base 2)
</p>
</li>
<li> <p><code>log10()</code> (log, base 10)
</p>
</li>
<li> <p><code>log1p()</code> (same as <code>log(x + 1)</code>)
</p>
</li>
<li> <p><code>log10p()</code> (same as <code>log(x + 1, base = 10)</code>)
</p>
</li></ul>

</li>
<li><p> Power functions:
</p>

<ul>
<li> <p><code>sqrt()</code>
</p>
</li>
<li> <p><code>x^y</code>
</p>
</li></ul>

</li>
<li><p> Rounding:
</p>

<ul>
<li> <p><code>round()</code>
</p>
</li>
<li> <p><code>floor()</code> (round down)
</p>
</li>
<li> <p><code>ceiling()</code> (round up)
</p>
</li>
<li> <p><code>trunc()</code> (remove decimal portion)
</p>
</li></ul>

</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
is.na(x)

## S4 method for signature 'GRaster'
not.na(x, falseNA = FALSE)

## S4 method for signature 'GRaster'
abs(x)

## S4 method for signature 'GRaster'
sin(x)

## S4 method for signature 'GRaster'
cos(x)

## S4 method for signature 'GRaster'
tan(x)

## S4 method for signature 'GRaster'
asin(x)

## S4 method for signature 'GRaster'
acos(x)

## S4 method for signature 'GRaster'
atan(x)

## S4 method for signature 'GRaster,GRaster'
atan2(y, x)

## S4 method for signature 'GRaster'
exp(x)

## S4 method for signature 'GRaster'
log1p(x)

## S4 method for signature 'GRaster'
log10p(x)

## S4 method for signature 'GRaster'
log(x, base = exp(1))

## S4 method for signature 'GRaster'
ln(x)

## S4 method for signature 'GRaster'
log2(x)

## S4 method for signature 'GRaster'
log10(x)

## S4 method for signature 'GRaster'
sqrt(x)

## S4 method for signature 'GRaster'
round(x, digits = 0)

## S4 method for signature 'GRaster'
floor(x)

## S4 method for signature 'GRaster'
ceiling(x)

## S4 method for signature 'GRaster'
trunc(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.na+2B2CGRaster-method_+3A_x">x</code>, <code id="is.na+2B2CGRaster-method_+3A_y">y</code></td>
<td>
<p><code>GRaster</code>s.</p>
</td></tr>
<tr><td><code id="is.na+2B2CGRaster-method_+3A_falsena">falseNA</code></td>
<td>
<p>Logical (function <code>not.na()</code>): If <code>FALSE</code> (default), non-<code>NA</code> cells will be converted to 1, and <code>NA</code> cells to 0. If <code>TRUE</code>, non-<code>NA</code> cells will be converted to  and <code>NA</code> cells will stay as <code>NA</code>.</p>
</td></tr>
<tr><td><code id="is.na+2B2CGRaster-method_+3A_base">base</code></td>
<td>
<p>Numeric: Base of the logarithm.</p>
</td></tr>
<tr><td><code id="is.na+2B2CGRaster-method_+3A_digits">digits</code></td>
<td>
<p>Numeric: Number of digits to round to. If negative, then rounding is to the nearest positive power of 10. For example, if <code>digits = -2</code>, then the <code>GRaster</code> values are rounded to the nearest 100.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Example data
madElev &lt;- fastData("madElev")

# Convert a SpatRaster to a GRaster
elev &lt;- fast(madElev)
elevs &lt;- c(elev, elev, log10(elev) - 1, sqrt(elev))
names(elevs) &lt;- c("elev1", "elev2", "log_elev", "sqrt_elev")

elev
elevs

# do some math
elev + 100
elev - 100
elev * 100
elev / 100
elev ^ 2
elev %/% 100 # divide then round down
elev %% 100 # modulus

100 + elev
100 %/% elev
100 %% elev

elevs + 100
100 + elevs

# math with logicals
elev + TRUE
elev - TRUE
elev * TRUE
elev / TRUE
elev ^ TRUE
elev %/% TRUE # divide then round down
elev %% TRUE # modulus

elevs + TRUE
TRUE + elevs

# Raster interacting with raster(s):
elev + elev
elev - elev
elev * elev
elev / elev
elev ^ log(elev)
elev %/% sqrt(elev) # divide then round down
elev %% sqrt(elev) # modulus

elevs + elev
elev * elevs

# sign
abs(-1 * elev)
abs(elevs)

# powers
sqrt(elevs)

# trigonometry
sin(elev)
cos(elev)
tan(elev)

asin(elev)
acos(elev)
atan(elev)

atan(elevs)
atan2(elev, elev^1.2)
atan2(elevs, elev^1.2)
atan2(elev, elevs^1.2)
atan2(elevs, elevs^1.2)

# logarithms
exp(elev)
log(elev)
ln(elev)
log2(elev)
log1p(elev)
log10(elev)
log10p(elev)
log(elev, 3)

log(elevs)

# rounding
round(elev + 0.5)
floor(elev + 0.5)
ceiling(elev + 0.5)
trunc(elev + 0.5)

}
</code></pre>

<hr>
<h2 id='kernel+2CGVector-method'>Kernel density estimator of points</h2><span id='topic+kernel+2CGVector-method'></span><span id='topic+kernel'></span>

<h3>Description</h3>

<p><code>kernel()</code> creates a raster using a kernel density estimator of the density of points in a &quot;points&quot; <code>GVector</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector'
kernel(x, y, kernel = "Epanechnikov", optimize = TRUE, h = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kernel+2B2CGVector-method_+3A_x">x</code></td>
<td>
<p>A &quot;points&quot; <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="kernel+2B2CGVector-method_+3A_y">y</code></td>
<td>
<p>A <code>GRaster</code>: The extent and resolution of this raster will be used to create the density raster. Otherwise, values in this raster are ignored.</p>
</td></tr>
<tr><td><code id="kernel+2B2CGVector-method_+3A_kernel">kernel</code></td>
<td>
<p>Character: Name of the kernel function to use. Possible values include:
</p>

<ul>
<li> <p><code>"Epanechnikov"</code> (default)
</p>
</li>
<li> <p><code>"Gaussian"</code>
</p>
</li>
<li> <p><code>"uniform"</code>
</p>
</li>
<li> <p><code>"triangular"</code>
</p>
</li>
<li> <p><code>"quartic"</code>
</p>
</li>
<li> <p><code>"triweight"</code>
</p>
</li>
<li> <p><code>"cosine"</code>
</p>
</li></ul>

<p>Partial matching is used, and case is ignored.</p>
</td></tr>
<tr><td><code id="kernel+2B2CGVector-method_+3A_optimize">optimize</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), then attempt to find the optimal radius less than or equal to the <code>radius</code> value using the &quot;Gaussian&quot; kernel. If <code>FALSE</code>, use the <code>radius</code> value as-is.</p>
</td></tr>
<tr><td><code id="kernel+2B2CGVector-method_+3A_h">h</code></td>
<td>
<p>Numeric or <code>NULL</code> (default): Smoothing bandwidth of kernel estimator.
</p>
<p>If this is <code>NULL</code>, the Epanechnikov kernel is used, and <code>optimize</code> is <code>TRUE</code>, then Silverman's rule-of-thumb is used to estimate the optimal value of <code>h</code>:
</p>
<p style="text-align: center;"><code class="reqn">h = 0.9 * min(\sigma_x / n^1/6, \sigma_y / n^1/6)</code>
</p>

<p>If the Gaussian kernel is used, and <code>optimize</code> is <code>TRUE</code>, then the <strong>GRASS</strong> <code>v.kernel</code> function will attempt to identify the optimal bandwidth, up to the value of <code>h</code>, if <code>h</code> is defined.
</p>
<p>Otherwise, if <code>h</code> is <code>NULL</code>, then the value will be arbitrarily set at 1/5th of the shorter of the distance of the x- and y-extent of the points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><strong>GRASS</strong> manual page for module <code>v.kernel</code> (see <code>grassHelp("v.kernel")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Elevation raster, plant specimen collections, rivers vector,
# outline of area vector
madElev &lt;- fastData("madElev")
madDypsis &lt;- fastData("madDypsis")

# Convert to fasterRaster format:
elev &lt;- fast(madElev)
dypsis &lt;- fast(madDypsis)

# Kernel density estimation:
kde &lt;- kernel(dypsis, elev)
plot(kde)
plot(dypsis, add = TRUE, pch = 1)

}
</code></pre>

<hr>
<h2 id='layerCor+2CGRaster-method'>Correlation between GRasters</h2><span id='topic+layerCor+2CGRaster-method'></span><span id='topic+layerCor'></span>

<h3>Description</h3>

<p>This function returns a correlation or covariance matrix between two or more <code>GRaster</code> layers. This function returns the sample correlation and covariance (i.e., the denominator is n - 1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
layerCor(x, fun = "cor")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="layerCor+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> with two or more layers.</p>
</td></tr>
<tr><td><code id="layerCor+2B2CGRaster-method_+3A_fun">fun</code></td>
<td>
<p>Character: Name of the statistic to calculate; either <code>"cor"</code> (default) or <code>"cov"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric <code>matrix</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+layerCor">terra::layerCor()</a></code>, <code><a href="stats.html#topic+cor">stats::cor()</a></code>, <code><a href="stats.html#topic+cor">stats::cov()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madChelsa &lt;- fastData("madChelsa")

# Convert a SpatRaster to a GRaster:
chelsa &lt;- fast(madChelsa)

# Correlation
layerCor(chelsa, "cor")

# Covariance
layerCor(chelsa, "cov")

}
</code></pre>

<hr>
<h2 id='levels+2CGRaster-method'>Set and get categories for categorical rasters</h2><span id='topic+levels+2CGRaster-method'></span><span id='topic+levels'></span><span id='topic+cats+2CGRaster-method'></span><span id='topic+cats'></span><span id='topic+categories+2CGRaster-method'></span><span id='topic+categories'></span><span id='topic+levels+3C-+2CGRaster+2Cdata.frame-method'></span><span id='topic+levels+3C-'></span><span id='topic+levels+3C-+2CGRaster+2Cdata.table-method'></span><span id='topic+levels+3C-+2CGRaster+2CGRaster-method'></span><span id='topic+levels+3C-+2CGRaster+2Clist-method'></span>

<h3>Description</h3>

<p><code>GRaster</code>s can represent categorical data. Cell values are actually integers, each corresponding to a category, such as &quot;desert&quot; or &quot;wetland.&quot; A categorical raster is associated with a table that matches each value to a category name. The table must be <code>NULL</code> (i.e., no categories&ndash;so not a categorical raster), or have at least two columns. The first column must have integers and represent raster values. One or more subsequent columns must have category labels. The column with these labels is the &quot;active category&quot;.
</p>

<ul>
<li> <p><code>levels()</code>: Displays the &quot;levels&quot; table of a raster (just the value and active category columns).
</p>
</li>
<li> <p><code>cats()</code>: Displays the entire &quot;levels&quot; table of a raster.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;levels()&lt;-&#8288;</code>: (Re)assigns the &quot;levels&quot; table to each layer of a raster. Assigning a &quot;levels&quot; table to an integer raster makes it a categorical raster.
</p>
</li>
<li> <p><code>categories()</code>: (Re)assigns the &quot;levels&quot; table to specific layer(s) of a raster.
</p>
</li>
<li><p> For a complete list of functions relevant to categorical rasters, see 'vignette(&quot;GRasters&quot;, package = &quot;fasterRaster&quot;)).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
levels(x)

## S4 method for signature 'GRaster'
cats(x, layer = 1:nlyr(x))

## S4 method for signature 'GRaster'
categories(x, layer = 1, value, active = 1)

## S4 replacement method for signature 'GRaster,data.frame'
levels(x) &lt;- value

## S4 replacement method for signature 'GRaster,data.table'
levels(x) &lt;- value

## S4 replacement method for signature 'GRaster,GRaster'
levels(x) &lt;- value

## S4 replacement method for signature 'GRaster,list'
levels(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="levels+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="levels+2B2CGRaster-method_+3A_layer">layer</code></td>
<td>
<p>Numeric integers, logical vector, or character: For <code>cats()</code> and <code>categories()</code>, this specifies the layer(s)for which to obtain level(s).</p>
</td></tr>
<tr><td><code id="levels+2B2CGRaster-method_+3A_value">value</code></td>
<td>
<p>A <code>data.frame</code>, <code>data.table</code>, a list of <code>data.frames</code> or <code>data.tables</code> with one per raster layer, or a categorical <code>SpatRaster</code>. The table's first column is the &quot;value&quot; column and must contain numeric values (of class <code>numeric</code> or <code>character</code>). If a <code>SpatRaster</code> is supplied, then its categories will be transferred to the <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="levels+2B2CGRaster-method_+3A_active">active</code></td>
<td>
<p>An integer or a character: The index or column name of the column used for category labels (the &quot;active column&quot;). Following <code><a href="terra.html#topic+activeCat">terra::activeCat()</a></code>, the first column of the &quot;levels&quot; table is ignored, so a value of 1 means to use the second column of the table for labels. A value of 2 means to use the third column, and so on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Values returned are:
</p>

<ul>
<li> <p><code>levels()</code> and <code>cats()</code>: A list of <code>data.frame</code>s or <code>data.table</code>s, one per raster layer.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;levels()&lt;-&#8288;</code> and <code>categories()</code>: A <code>GRaster</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="terra.html#topic+factors">terra::levels()</a></code>, <code><a href="#topic+levels+3C-">levels&lt;-</a></code>, <code><a href="terra.html#topic+factors">terra::cats()</a></code>, <code><a href="terra.html#topic+factors">terra::categories()</a></code>, see <code>vignette("GRasters", package = "fasterRaster")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data: Land cover raster
madCover &lt;- fastData("madCover")

# Convert categorical SpatRaster to categorical GRaster:
cover &lt;- fast(madCover)

### Properties of categorical rasters

cover # note categories
is.factor(cover) # Is the raster categorical?
nlevels(cover) # number of levels
levels(cover) # just the value and active column
cats(cover) # all columns
minmax(cover) # min/max values
minmax(cover, levels = TRUE) # min/max categories
catNames(cover) # column names of the levels table
missingCats(cover) # categories in table with no values in raster
freq(cover) # frequency of each category (number of cells)
zonalGeog(cover) # geometric statistics

### Active column

# Which column sets the category labels?
activeCat(cover)
activeCat(cover, names = TRUE)

activeCats(c(cover, cover))

# Choose a different column for category labels:
levels(cover)
activeCat(cover) &lt;- 2
levels(cover)

### Managing levels tables

# Remove unused levels:
nlevels(cover)
cover &lt;- droplevels(cover)
nlevels(cover)

# Re-assign levels:
value &lt;- c(20, 30, 40, 50, 120, 130, 140, 170)
label &lt;- c("Cropland", "Cropland", "Forest", "Forest",
 "Grassland", "Shrubland", "Herbaceous", "Flooded")

newCats &lt;- data.frame(value = value, label = label)

cover &lt;- categories(cover, layer = 1, value = newCats)
cats(cover)

# This is the same as:
levels(cover) &lt;- newCats
cats(cover)

# Are there any values not assigned a category?
missingCats(cover)

# Let's assign a category for value 210 (water):
water &lt;- data.frame(value = 210, label = "Water")
addCats(cover) &lt;- water
levels(cover)

# Add more information to the levels table using merge():
landType &lt;- data.frame(
     Value = c(20, 30, 40, 50, 120),
     Type = c("Irrigated", "Rainfed", "Broadleaf evergreen",
     "Broadleaf deciduous", "Mosaic with forest")
)
cats(cover)
cover &lt;- addCats(cover, landType, merge = TRUE)
cats(cover)

### Logical operations on categorical rasters

cover &lt; "Forest" # 1 for cells with a value &lt; 40, 0 otherwise
cover &lt;= "Forest" # 1 for cells with a value &lt; 120, 0 otherwise
cover == "Forest" # 1 for cells with value of 40-120, 0 otherwise
cover != "Forest" # 1 for cells with value that is not 40-120, 0 otherwise
cover &gt; "Forest" # 1 for cells with a value &gt; 120, 0 otherwise
cover &gt;= "Forest" # 1 for cells with a value &gt;= 120, 0 otherwise

cover %in% c("Cropland", "Forest") # 1 for cropland/forest cells, 0 otherwise

### Combine categories from different rasters

# For the example, will create a second categorical raster fromm elevation.

# Divide elevation raster into "low/medium/high" levels:
madElev &lt;- fastData("madElev")
elev &lt;- fast(madElev)
elev &lt;- project(elev, cover, method = "near") # convert to same CRS
fun &lt;- "= if(madElev &lt; 100, 0, if(madElev &lt; 400, 1, 2))"
elevCat &lt;- app(elev, fun)

levs &lt;- data.frame(
     value = c(0, 1, 2),
     elevation = c("low", "medium", "high")
)
levels(elevCat) &lt;- list(levs)

# Combine levels:
combined &lt;- concats(cover, elevCat)
combined
levels(combined)

# Combine levels, treating value/NA combinations as new categories:
combinedNA &lt;- concats(cover, elevCat, na.rm = FALSE)
combinedNA
levels(combinedNA)

}
</code></pre>

<hr>
<h2 id='Logic+2CGRaster+2CGRaster-method'>Logic-methods operations on GRasters</h2><span id='topic+Logic+2CGRaster+2CGRaster-method'></span><span id='topic+Logic-methods'></span><span id='topic+Logic+2Clogical+2CGRaster-method'></span><span id='topic+Logic+2CGRaster+2Clogical-method'></span><span id='topic+Logic+2CGRaster+2Cnumeric-method'></span><span id='topic+Logic+2Cnumeric+2CGRaster-method'></span><span id='topic+Logic+2CGRaster+2Cinteger-method'></span><span id='topic+Logic+2Cinteger+2CGRaster-method'></span>

<h3>Description</h3>

<p>You can do logical operations on <code>GRaster</code>s. A cell with a value of 1 is interpreted as <code>TRUE</code>, and a value of 0 is interpreted as <code>FALSE</code>. You can compare:
</p>

<ul>
<li><p> A <code>GRaster</code> to another <code>GRaster</code>
</p>
</li>
<li><p> A <code>GRaster</code> to a logical value (<code>TRUE</code> or <code>FALSE</code>, but not <code>NA</code>&ndash;see <code><a href="#topic+not.na">not.na()</a></code>)
</p>
</li>
<li><p> A <code>GRaster</code> to a numeric or integer value that is 0 or 1
</p>
</li></ul>

<p>Operators include:
</p>

<ul>
<li> <p><code>|</code>: <code>TRUE</code> if either condition is <code>TRUE</code> (or 1), but returns <code>NA</code> if either condition is <code>NA</code>.
</p>
</li>
<li> <p><code>&amp;</code>: <code>TRUE</code> if both conditions are <code>TRUE</code> (or 1), but <code>NA</code> if either is <code>NA</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster,GRaster'
Logic(e1, e2)

## S4 method for signature 'logical,GRaster'
Logic(e1, e2)

## S4 method for signature 'GRaster,logical'
Logic(e1, e2)

## S4 method for signature 'GRaster,numeric'
Logic(e1, e2)

## S4 method for signature 'numeric,GRaster'
Logic(e1, e2)

## S4 method for signature 'GRaster,integer'
Logic(e1, e2)

## S4 method for signature 'integer,GRaster'
Logic(e1, e2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Logic+2B2CGRaster+2B2CGRaster-method_+3A_e1">e1</code>, <code id="Logic+2B2CGRaster+2B2CGRaster-method_+3A_e2">e2</code></td>
<td>
<p>Two <code>GRaster</code>s, or a <code>GRaster</code> and a logical value (<code>TRUE</code> or <code>FALSE</code>, but not <code>NA</code>), a numeric value that is 0 or 1 (but not <code>NA_real_</code>), or an integer value that is 0 or 1 (but not <code>NA_integer_</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A binary <code>GRaster</code> (1 ==&gt; <code>TRUE</code>, 0 ==&gt; <code>FALSE</code>, plus <code>NA</code> when comparison results in <code>NA</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")

# Convert a SpatRaster to a GRaster
elev &lt;- fast(madElev)
elevs &lt;- c(elev, elev, log10(elev) - 1, sqrt(elev))
names(elevs) &lt;- c("elev1", "elev2", "log_elev", "sqrt_elev")

elev
elevs

# Comparisons
elev &lt; 100
elev &lt;= 100
elev == 100
elev != 100
elev &gt; 100
elev &gt;= 100

elev + 100 &lt; 2 * elev

elevs &gt; 10
10 &gt; elevs

# logic
elev &lt; 10 | elev &gt; 200
elev &lt; 10 | cos(elev) &gt; 0.9

elev &lt; 10 | TRUE
TRUE | elev &gt; 200

elev &lt; 10 | FALSE
FALSE | elev &gt; 200

elev &lt; 10 &amp; cos(elev) &gt; 0.9

elev &lt; 10 &amp; TRUE
TRUE &amp; elev &gt; 200

elev &lt; 10 &amp; FALSE
FALSE &amp; elev &gt; 200

}
</code></pre>

<hr>
<h2 id='longlat+2CGRaster-method'>Create longitude/latitude rasters</h2><span id='topic+longlat+2CGRaster-method'></span><span id='topic+longlat'></span>

<h3>Description</h3>

<p><code>longlat()</code> creates two rasters, one with cell values equal to the longitude of the cell centers, and one with cell values equal to the latitude of the cell centers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
longlat(x, degrees = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="longlat+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="longlat+2B2CGRaster-method_+3A_degrees">degrees</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), coordinate values of cells will be in degrees. If <code>FALSE</code>, and <code>x</code> is in a projected coordinate reference system, values will represent coordinates in map units (usually meters). Values will always be in degrees when the coordinate reference system is unprojected (e.g., WGS84, NAD83, etc.).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code> stack.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+init">init()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")

# Convert a SpatRaster to a GRaster
elev &lt;- fast(madElev)

# Create longitude/latitude rasters
ll &lt;- longlat(elev)
ll # note units of cell values!

}
</code></pre>

<hr>
<h2 id='madChelsa'>Rasters of bioclimatic variables for an eastern portion of Madagascar</h2><span id='topic+madChelsa'></span>

<h3>Description</h3>

<p>Rasters of bioclimatic variables for an eastern portion of Madagascar from CHELSA version 2.1 in unprojected (WGS84) coordinates. Values represent averages across 1980-2010. Only these BIOCLIM variables are included:
* <code>bio1</code>: Mean annual temperature (deg C)
* <code>bio7</code>: Temperature annual range (hottest - coldest month temperature; deg C)
* <code>bio12</code>: Total annual precipitation (mm)
* <code>bio15</code>: Precipitation seasonality (unit-less)
</p>


<h3>Format</h3>

<p>An object of class <code>SpatRaster</code> in unprojected (WGS84) coordinates.
</p>


<h3>Source</h3>

<p><a href="https://doi.org/10.1038/sdata.2017.122">doi:10.1038/sdata.2017.122</a>
</p>


<h3>References</h3>

<p>Karger, D.N., Conrad, O., Bohner, J., Kawohl, T., Kreft, H., Soria-Auza, R.W., Zimmermann, N.E., Linder, H.P., and Kessler, M.  2017.  Climatologies at high resolution for the earth's land surface areas. <em>Scientific Data</em> 4:170122. <a href="https://doi.org/10.1038/sdata.2017.122">doi:10.1038/sdata.2017.122</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### vector data

library(sf)

# For vector data, we can use data(*) or fastData(*):
data(madCoast0) # same as next line
madCoast0 &lt;- fastData("madCoast0") # same as previous
madCoast0
plot(st_geometry(madCoast0))

madCoast4 &lt;- fastData("madCoast4")
madCoast4
plot(st_geometry(madCoast4), add = TRUE)

madRivers &lt;- fastData("madRivers")
madRivers
plot(st_geometry(madRivers), col = "blue", add = TRUE)

madDypsis &lt;- fastData("madDypsis")
madDypsis
plot(st_geometry(madDypsis), col = "red", add = TRUE)

### raster data

library(terra)

# For raster data, we can get the file directly or using fastData(*):
rastFile &lt;- system.file("extdata/madElev.tif", package="fasterRaster")
madElev &lt;- terra::rast(rastFile)

madElev &lt;- fastData("madElev") # same as previous two lines
madElev
plot(madElev)

madForest2000 &lt;- fastData("madForest2000")
madForest2000
plot(madForest2000)

madForest2014 &lt;- fastData("madForest2014")
madForest2014
plot(madForest2014)

# multi-layer rasters
madChelsa &lt;- fastData("madChelsa")
madChelsa
plot(madChelsa)

madPpt &lt;- fastData("madPpt")
madTmin &lt;- fastData("madTmin")
madTmax &lt;- fastData("madTmax")
madPpt
madTmin
madTmax


# RGB raster
madLANDSAT &lt;- fastData("madLANDSAT")
madLANDSAT
plotRGB(madLANDSAT, 4, 1, 2, stretch = "lin")

# categorical raster
madCover &lt;- fastData("madCover")
madCover
madCover &lt;- droplevels(madCover)
levels(madCover) # levels in the raster
nlevels(madCover) # number of categories
catNames(madCover) # names of categories table

plot(madCover)
</code></pre>

<hr>
<h2 id='madCoast'>Shapefile of a portion of the coastline of Madagascar</h2><span id='topic+madCoast'></span>

<h3>Description</h3>

<p>Borders of a selected portion of Madagascar
</p>


<h3>Format</h3>

<p>ESRI Shapefile.
</p>


<h3>Source</h3>

<p><a href="https://gadm.org">Database of Global Administrative Areas Version 2.8 (GADM)</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### vector data

library(sf)

# For vector data, we can use data(*) or fastData(*):
data(madCoast0) # same as next line
madCoast0 &lt;- fastData("madCoast0") # same as previous
madCoast0
plot(st_geometry(madCoast0))

madCoast4 &lt;- fastData("madCoast4")
madCoast4
plot(st_geometry(madCoast4), add = TRUE)

madRivers &lt;- fastData("madRivers")
madRivers
plot(st_geometry(madRivers), col = "blue", add = TRUE)

madDypsis &lt;- fastData("madDypsis")
madDypsis
plot(st_geometry(madDypsis), col = "red", add = TRUE)

### raster data

library(terra)

# For raster data, we can get the file directly or using fastData(*):
rastFile &lt;- system.file("extdata/madElev.tif", package="fasterRaster")
madElev &lt;- terra::rast(rastFile)

madElev &lt;- fastData("madElev") # same as previous two lines
madElev
plot(madElev)

madForest2000 &lt;- fastData("madForest2000")
madForest2000
plot(madForest2000)

madForest2014 &lt;- fastData("madForest2014")
madForest2014
plot(madForest2014)

# multi-layer rasters
madChelsa &lt;- fastData("madChelsa")
madChelsa
plot(madChelsa)

madPpt &lt;- fastData("madPpt")
madTmin &lt;- fastData("madTmin")
madTmax &lt;- fastData("madTmax")
madPpt
madTmin
madTmax


# RGB raster
madLANDSAT &lt;- fastData("madLANDSAT")
madLANDSAT
plotRGB(madLANDSAT, 4, 1, 2, stretch = "lin")

# categorical raster
madCover &lt;- fastData("madCover")
madCover
madCover &lt;- droplevels(madCover)
levels(madCover) # levels in the raster
nlevels(madCover) # number of categories
catNames(madCover) # names of categories table

plot(madCover)
</code></pre>

<hr>
<h2 id='madCoast0'>Spatial vector of a portion of the coastline of Madagascar</h2><span id='topic+madCoast0'></span>

<h3>Description</h3>

<p>Borders of a selected portion of Madagascar
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(madCoast4)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>sf</code>.
</p>


<h3>Source</h3>

<p><a href="https://gadm.org">Database of Global Administrative Areas Version 2.8 (GADM)</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### vector data

library(sf)

# For vector data, we can use data(*) or fastData(*):
data(madCoast0) # same as next line
madCoast0 &lt;- fastData("madCoast0") # same as previous
madCoast0
plot(st_geometry(madCoast0))

madCoast4 &lt;- fastData("madCoast4")
madCoast4
plot(st_geometry(madCoast4), add = TRUE)

madRivers &lt;- fastData("madRivers")
madRivers
plot(st_geometry(madRivers), col = "blue", add = TRUE)

madDypsis &lt;- fastData("madDypsis")
madDypsis
plot(st_geometry(madDypsis), col = "red", add = TRUE)

### raster data

library(terra)

# For raster data, we can get the file directly or using fastData(*):
rastFile &lt;- system.file("extdata/madElev.tif", package="fasterRaster")
madElev &lt;- terra::rast(rastFile)

madElev &lt;- fastData("madElev") # same as previous two lines
madElev
plot(madElev)

madForest2000 &lt;- fastData("madForest2000")
madForest2000
plot(madForest2000)

madForest2014 &lt;- fastData("madForest2014")
madForest2014
plot(madForest2014)

# multi-layer rasters
madChelsa &lt;- fastData("madChelsa")
madChelsa
plot(madChelsa)

madPpt &lt;- fastData("madPpt")
madTmin &lt;- fastData("madTmin")
madTmax &lt;- fastData("madTmax")
madPpt
madTmin
madTmax


# RGB raster
madLANDSAT &lt;- fastData("madLANDSAT")
madLANDSAT
plotRGB(madLANDSAT, 4, 1, 2, stretch = "lin")

# categorical raster
madCover &lt;- fastData("madCover")
madCover
madCover &lt;- droplevels(madCover)
levels(madCover) # levels in the raster
nlevels(madCover) # number of categories
catNames(madCover) # names of categories table

plot(madCover)
</code></pre>

<hr>
<h2 id='madCoast4'>Spatial vector of a portion of the coastline of Madagascar</h2><span id='topic+madCoast4'></span>

<h3>Description</h3>

<p>Borders of a selected portion of Madagascar
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(madCoast4)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>sf</code>.
</p>


<h3>Source</h3>

<p><a href="https://gadm.org">Database of Global Administrative Areas Version 2.8 (GADM)</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### vector data

library(sf)

# For vector data, we can use data(*) or fastData(*):
data(madCoast0) # same as next line
madCoast0 &lt;- fastData("madCoast0") # same as previous
madCoast0
plot(st_geometry(madCoast0))

madCoast4 &lt;- fastData("madCoast4")
madCoast4
plot(st_geometry(madCoast4), add = TRUE)

madRivers &lt;- fastData("madRivers")
madRivers
plot(st_geometry(madRivers), col = "blue", add = TRUE)

madDypsis &lt;- fastData("madDypsis")
madDypsis
plot(st_geometry(madDypsis), col = "red", add = TRUE)

### raster data

library(terra)

# For raster data, we can get the file directly or using fastData(*):
rastFile &lt;- system.file("extdata/madElev.tif", package="fasterRaster")
madElev &lt;- terra::rast(rastFile)

madElev &lt;- fastData("madElev") # same as previous two lines
madElev
plot(madElev)

madForest2000 &lt;- fastData("madForest2000")
madForest2000
plot(madForest2000)

madForest2014 &lt;- fastData("madForest2014")
madForest2014
plot(madForest2014)

# multi-layer rasters
madChelsa &lt;- fastData("madChelsa")
madChelsa
plot(madChelsa)

madPpt &lt;- fastData("madPpt")
madTmin &lt;- fastData("madTmin")
madTmax &lt;- fastData("madTmax")
madPpt
madTmin
madTmax


# RGB raster
madLANDSAT &lt;- fastData("madLANDSAT")
madLANDSAT
plotRGB(madLANDSAT, 4, 1, 2, stretch = "lin")

# categorical raster
madCover &lt;- fastData("madCover")
madCover
madCover &lt;- droplevels(madCover)
levels(madCover) # levels in the raster
nlevels(madCover) # number of categories
catNames(madCover) # names of categories table

plot(madCover)
</code></pre>

<hr>
<h2 id='madCover'>Raster of land cover for an eastern portion of Madagascar</h2><span id='topic+madCover'></span>

<h3>Description</h3>

<p>Raster of land cover for an eastern portion of Madagascar. Note that the land cover classes have been simplified, so this raster should <em>not</em> be used for &quot;real&quot; analyses.
</p>


<h3>Format</h3>

<p>An object of class <code>SpatRaster</code> in unprojected (WGS84) coordinates.
</p>


<h3>Source</h3>

<p><a href="http://due.esrin.esa.int">http://due.esrin.esa.int</a>
</p>


<h3>References</h3>

<p>Arino O., P. Bicheron, F. Achard, J. Latham, R. Witt and J.-L. Weber. 2008. GlobCover: The most detailed portrait of Earth. European Space Agency Bulletin 136:25-31. <a href="http://due.esrin.esa.int">http://due.esrin.esa.int</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+madCoverCats">madCoverCats</a>, <code>vignette("GRasters", package = "fasterRaster")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### vector data

library(sf)

# For vector data, we can use data(*) or fastData(*):
data(madCoast0) # same as next line
madCoast0 &lt;- fastData("madCoast0") # same as previous
madCoast0
plot(st_geometry(madCoast0))

madCoast4 &lt;- fastData("madCoast4")
madCoast4
plot(st_geometry(madCoast4), add = TRUE)

madRivers &lt;- fastData("madRivers")
madRivers
plot(st_geometry(madRivers), col = "blue", add = TRUE)

madDypsis &lt;- fastData("madDypsis")
madDypsis
plot(st_geometry(madDypsis), col = "red", add = TRUE)

### raster data

library(terra)

# For raster data, we can get the file directly or using fastData(*):
rastFile &lt;- system.file("extdata/madElev.tif", package="fasterRaster")
madElev &lt;- terra::rast(rastFile)

madElev &lt;- fastData("madElev") # same as previous two lines
madElev
plot(madElev)

madForest2000 &lt;- fastData("madForest2000")
madForest2000
plot(madForest2000)

madForest2014 &lt;- fastData("madForest2014")
madForest2014
plot(madForest2014)

# multi-layer rasters
madChelsa &lt;- fastData("madChelsa")
madChelsa
plot(madChelsa)

madPpt &lt;- fastData("madPpt")
madTmin &lt;- fastData("madTmin")
madTmax &lt;- fastData("madTmax")
madPpt
madTmin
madTmax


# RGB raster
madLANDSAT &lt;- fastData("madLANDSAT")
madLANDSAT
plotRGB(madLANDSAT, 4, 1, 2, stretch = "lin")

# categorical raster
madCover &lt;- fastData("madCover")
madCover
madCover &lt;- droplevels(madCover)
levels(madCover) # levels in the raster
nlevels(madCover) # number of categories
catNames(madCover) # names of categories table

plot(madCover)
</code></pre>

<hr>
<h2 id='madCoverCats'>Table of land cover classes for an eastern portion of Madagascar</h2><span id='topic+madCoverCats'></span>

<h3>Description</h3>

<p>This data frame corresponds to the <a href="#topic+madCover">madCover</a> raster, which represents land cover for an eastern portion of Madagascar. Note that the land cover classes have been simplified, so this table and raster should <em>not</em> be used for &quot;real&quot; analyses.
</p>


<h3>Format</h3>

<p>An object of class <code>data.frame</code>.
</p>


<h3>Source</h3>

<p><a href="http://due.esrin.esa.int">http://due.esrin.esa.int</a>
</p>


<h3>References</h3>

<p>Arino O., P. Bicheron, F. Achard, J. Latham, R. Witt and J.-L. Weber. 2008. GlobCover: The most detailed portrait of Earth. European Space Agency Bulletin 136:25-31. <a href="http://due.esrin.esa.int">http://due.esrin.esa.int</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+madCover">madCover</a>, <code>vignette("GRasters", package = "fasterRaster")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### vector data

library(sf)

# For vector data, we can use data(*) or fastData(*):
data(madCoast0) # same as next line
madCoast0 &lt;- fastData("madCoast0") # same as previous
madCoast0
plot(st_geometry(madCoast0))

madCoast4 &lt;- fastData("madCoast4")
madCoast4
plot(st_geometry(madCoast4), add = TRUE)

madRivers &lt;- fastData("madRivers")
madRivers
plot(st_geometry(madRivers), col = "blue", add = TRUE)

madDypsis &lt;- fastData("madDypsis")
madDypsis
plot(st_geometry(madDypsis), col = "red", add = TRUE)

### raster data

library(terra)

# For raster data, we can get the file directly or using fastData(*):
rastFile &lt;- system.file("extdata/madElev.tif", package="fasterRaster")
madElev &lt;- terra::rast(rastFile)

madElev &lt;- fastData("madElev") # same as previous two lines
madElev
plot(madElev)

madForest2000 &lt;- fastData("madForest2000")
madForest2000
plot(madForest2000)

madForest2014 &lt;- fastData("madForest2014")
madForest2014
plot(madForest2014)

# multi-layer rasters
madChelsa &lt;- fastData("madChelsa")
madChelsa
plot(madChelsa)

madPpt &lt;- fastData("madPpt")
madTmin &lt;- fastData("madTmin")
madTmax &lt;- fastData("madTmax")
madPpt
madTmin
madTmax


# RGB raster
madLANDSAT &lt;- fastData("madLANDSAT")
madLANDSAT
plotRGB(madLANDSAT, 4, 1, 2, stretch = "lin")

# categorical raster
madCover &lt;- fastData("madCover")
madCover
madCover &lt;- droplevels(madCover)
levels(madCover) # levels in the raster
nlevels(madCover) # number of categories
catNames(madCover) # names of categories table

plot(madCover)
</code></pre>

<hr>
<h2 id='madDypsis'>Spatial points vector of records of Dypsis in eastern Madagascar</h2><span id='topic+madDypsis'></span>

<h3>Description</h3>

<p>Spatial points vector of herbarium specimens and observations of plants in the genus <em>Dypsis</em> (slender, evergreen palms) from a portion of eastern Madagascar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(madDypsis)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>sf</code>.
</p>


<h3>Source</h3>

<p><a href="https://gbif.org">Global Biodiversity Information Facility (GBIF)</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### vector data

library(sf)

# For vector data, we can use data(*) or fastData(*):
data(madCoast0) # same as next line
madCoast0 &lt;- fastData("madCoast0") # same as previous
madCoast0
plot(st_geometry(madCoast0))

madCoast4 &lt;- fastData("madCoast4")
madCoast4
plot(st_geometry(madCoast4), add = TRUE)

madRivers &lt;- fastData("madRivers")
madRivers
plot(st_geometry(madRivers), col = "blue", add = TRUE)

madDypsis &lt;- fastData("madDypsis")
madDypsis
plot(st_geometry(madDypsis), col = "red", add = TRUE)

### raster data

library(terra)

# For raster data, we can get the file directly or using fastData(*):
rastFile &lt;- system.file("extdata/madElev.tif", package="fasterRaster")
madElev &lt;- terra::rast(rastFile)

madElev &lt;- fastData("madElev") # same as previous two lines
madElev
plot(madElev)

madForest2000 &lt;- fastData("madForest2000")
madForest2000
plot(madForest2000)

madForest2014 &lt;- fastData("madForest2014")
madForest2014
plot(madForest2014)

# multi-layer rasters
madChelsa &lt;- fastData("madChelsa")
madChelsa
plot(madChelsa)

madPpt &lt;- fastData("madPpt")
madTmin &lt;- fastData("madTmin")
madTmax &lt;- fastData("madTmax")
madPpt
madTmin
madTmax


# RGB raster
madLANDSAT &lt;- fastData("madLANDSAT")
madLANDSAT
plotRGB(madLANDSAT, 4, 1, 2, stretch = "lin")

# categorical raster
madCover &lt;- fastData("madCover")
madCover
madCover &lt;- droplevels(madCover)
levels(madCover) # levels in the raster
nlevels(madCover) # number of categories
catNames(madCover) # names of categories table

plot(madCover)
</code></pre>

<hr>
<h2 id='madElev'>Elevation raster for an eastern portion of Madagascar</h2><span id='topic+madElev'></span>

<h3>Description</h3>

<p>Elevation raster for an eastern portion of Madagascar.
</p>


<h3>Format</h3>

<p>An object of class <code>SpatRaster</code>. Values are mean meters above sea level.
</p>


<h3>Source</h3>

<p><a href="https://worldclim.org">WorldClim Version 2.1</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### vector data

library(sf)

# For vector data, we can use data(*) or fastData(*):
data(madCoast0) # same as next line
madCoast0 &lt;- fastData("madCoast0") # same as previous
madCoast0
plot(st_geometry(madCoast0))

madCoast4 &lt;- fastData("madCoast4")
madCoast4
plot(st_geometry(madCoast4), add = TRUE)

madRivers &lt;- fastData("madRivers")
madRivers
plot(st_geometry(madRivers), col = "blue", add = TRUE)

madDypsis &lt;- fastData("madDypsis")
madDypsis
plot(st_geometry(madDypsis), col = "red", add = TRUE)

### raster data

library(terra)

# For raster data, we can get the file directly or using fastData(*):
rastFile &lt;- system.file("extdata/madElev.tif", package="fasterRaster")
madElev &lt;- terra::rast(rastFile)

madElev &lt;- fastData("madElev") # same as previous two lines
madElev
plot(madElev)

madForest2000 &lt;- fastData("madForest2000")
madForest2000
plot(madForest2000)

madForest2014 &lt;- fastData("madForest2014")
madForest2014
plot(madForest2014)

# multi-layer rasters
madChelsa &lt;- fastData("madChelsa")
madChelsa
plot(madChelsa)

madPpt &lt;- fastData("madPpt")
madTmin &lt;- fastData("madTmin")
madTmax &lt;- fastData("madTmax")
madPpt
madTmin
madTmax


# RGB raster
madLANDSAT &lt;- fastData("madLANDSAT")
madLANDSAT
plotRGB(madLANDSAT, 4, 1, 2, stretch = "lin")

# categorical raster
madCover &lt;- fastData("madCover")
madCover
madCover &lt;- droplevels(madCover)
levels(madCover) # levels in the raster
nlevels(madCover) # number of categories
catNames(madCover) # names of categories table

plot(madCover)
</code></pre>

<hr>
<h2 id='madForest2000'>Forest cover in year 2000 for a portion of Madagascar</h2><span id='topic+madForest2000'></span>

<h3>Description</h3>

<p>Raster of occurrence/non-occurrence of forest cover in a portion of Madagascar. Cells are 30-m in resolution. Values represent forest (1) or non-forest (<code>NA</code>).
</p>


<h3>Format</h3>

<p>An object of class <code>SpatRaster</code>.
</p>


<h3>References</h3>

<p>Vielledent, G., Grinand, C., Rakotomala, F.A., Ranaivosoa, <span class="pkg">R</span>., Rakotoarijaona, J-R., Allnutt, T.F., and Achard, F.  2018.  Combining global tree cover loss data with historical national forest cover maps to look at six decades of deforestation and forest fragmentation in Madagascar. <em>Biological Conservation</em> 222:189-197. <a href="https://doi.org/10.1016/j.biocon.2018.04.008">doi:10.1016/j.biocon.2018.04.008</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### vector data

library(sf)

# For vector data, we can use data(*) or fastData(*):
data(madCoast0) # same as next line
madCoast0 &lt;- fastData("madCoast0") # same as previous
madCoast0
plot(st_geometry(madCoast0))

madCoast4 &lt;- fastData("madCoast4")
madCoast4
plot(st_geometry(madCoast4), add = TRUE)

madRivers &lt;- fastData("madRivers")
madRivers
plot(st_geometry(madRivers), col = "blue", add = TRUE)

madDypsis &lt;- fastData("madDypsis")
madDypsis
plot(st_geometry(madDypsis), col = "red", add = TRUE)

### raster data

library(terra)

# For raster data, we can get the file directly or using fastData(*):
rastFile &lt;- system.file("extdata/madElev.tif", package="fasterRaster")
madElev &lt;- terra::rast(rastFile)

madElev &lt;- fastData("madElev") # same as previous two lines
madElev
plot(madElev)

madForest2000 &lt;- fastData("madForest2000")
madForest2000
plot(madForest2000)

madForest2014 &lt;- fastData("madForest2014")
madForest2014
plot(madForest2014)

# multi-layer rasters
madChelsa &lt;- fastData("madChelsa")
madChelsa
plot(madChelsa)

madPpt &lt;- fastData("madPpt")
madTmin &lt;- fastData("madTmin")
madTmax &lt;- fastData("madTmax")
madPpt
madTmin
madTmax


# RGB raster
madLANDSAT &lt;- fastData("madLANDSAT")
madLANDSAT
plotRGB(madLANDSAT, 4, 1, 2, stretch = "lin")

# categorical raster
madCover &lt;- fastData("madCover")
madCover
madCover &lt;- droplevels(madCover)
levels(madCover) # levels in the raster
nlevels(madCover) # number of categories
catNames(madCover) # names of categories table

plot(madCover)
</code></pre>

<hr>
<h2 id='madForest2014'>Forest cover in year 2014 for a portion of Madagascar</h2><span id='topic+madForest2014'></span>

<h3>Description</h3>

<p>Raster of occurrence/non-occurrence of forest cover in a portion of Madagascar. Cells are 30-m in resolution. Values represent forest (1) or non-forest (<code>NA</code>).
</p>


<h3>Format</h3>

<p>An object of class <code>SpatRaster</code>..
</p>


<h3>References</h3>

<p>Vielledent, G., Grinand, C., Rakotomala, F.A., Ranaivosoa, <span class="pkg">R</span>., Rakotoarijaona, J-R., Allnutt, T.F., and Achard, F.  2018.  Combining global tree cover loss data with historical national forest cover maps to look at six decades of deforestation and forest fragmentation in Madagascar. <em>Biological Conservation</em> 222:189-197. <a href="https://doi.org/10.1016/j.biocon.2018.04.008">doi:10.1016/j.biocon.2018.04.008</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### vector data

library(sf)

# For vector data, we can use data(*) or fastData(*):
data(madCoast0) # same as next line
madCoast0 &lt;- fastData("madCoast0") # same as previous
madCoast0
plot(st_geometry(madCoast0))

madCoast4 &lt;- fastData("madCoast4")
madCoast4
plot(st_geometry(madCoast4), add = TRUE)

madRivers &lt;- fastData("madRivers")
madRivers
plot(st_geometry(madRivers), col = "blue", add = TRUE)

madDypsis &lt;- fastData("madDypsis")
madDypsis
plot(st_geometry(madDypsis), col = "red", add = TRUE)

### raster data

library(terra)

# For raster data, we can get the file directly or using fastData(*):
rastFile &lt;- system.file("extdata/madElev.tif", package="fasterRaster")
madElev &lt;- terra::rast(rastFile)

madElev &lt;- fastData("madElev") # same as previous two lines
madElev
plot(madElev)

madForest2000 &lt;- fastData("madForest2000")
madForest2000
plot(madForest2000)

madForest2014 &lt;- fastData("madForest2014")
madForest2014
plot(madForest2014)

# multi-layer rasters
madChelsa &lt;- fastData("madChelsa")
madChelsa
plot(madChelsa)

madPpt &lt;- fastData("madPpt")
madTmin &lt;- fastData("madTmin")
madTmax &lt;- fastData("madTmax")
madPpt
madTmin
madTmax


# RGB raster
madLANDSAT &lt;- fastData("madLANDSAT")
madLANDSAT
plotRGB(madLANDSAT, 4, 1, 2, stretch = "lin")

# categorical raster
madCover &lt;- fastData("madCover")
madCover
madCover &lt;- droplevels(madCover)
levels(madCover) # levels in the raster
nlevels(madCover) # number of categories
catNames(madCover) # names of categories table

plot(madCover)
</code></pre>

<hr>
<h2 id='madLANDSAT'>Rasters of surface reflectance for an eastern portion of Madagascar</h2><span id='topic+madLANDSAT'></span>

<h3>Description</h3>

<p>Raster layers of surface reflectance from LANDSAT 9 for an eastern portion of Madagascar taken May 21, 2023. Four bands are represented:
</p>

<ul>
<li><p> &lsquo;band2&rsquo;: Blue (450-510 nm)
</p>
</li>
<li><p> &lsquo;band3&rsquo;: Green (530-590 nm)
</p>
</li>
<li><p> &lsquo;band4&rsquo;: Red (640-670 nm)
</p>
</li>
<li><p> &lsquo;band5&rsquo;: Near-infrared (850-880 nm)
The rasters have been resampled to 90-m resolution to reduce their size, then rescaled to integers in the range 0 to 255.
</p>
</li></ul>



<h3>Format</h3>

<p>An object of class <code>SpatRaster</code> in Universal Trans-Mercator (UTM), Zone 39 North with a WGS84 coordinate system, at 90 m resolution.
</p>


<h3>Source</h3>

<p>United States Geological Survey's <a href="https://earthexplorer.usgs.gov">EarthExplorer</a>. Also see <a href="https://www.usgs.gov/faqs/what-are-band-designations-landsat-satellites">band definitions</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### vector data

library(sf)

# For vector data, we can use data(*) or fastData(*):
data(madCoast0) # same as next line
madCoast0 &lt;- fastData("madCoast0") # same as previous
madCoast0
plot(st_geometry(madCoast0))

madCoast4 &lt;- fastData("madCoast4")
madCoast4
plot(st_geometry(madCoast4), add = TRUE)

madRivers &lt;- fastData("madRivers")
madRivers
plot(st_geometry(madRivers), col = "blue", add = TRUE)

madDypsis &lt;- fastData("madDypsis")
madDypsis
plot(st_geometry(madDypsis), col = "red", add = TRUE)

### raster data

library(terra)

# For raster data, we can get the file directly or using fastData(*):
rastFile &lt;- system.file("extdata/madElev.tif", package="fasterRaster")
madElev &lt;- terra::rast(rastFile)

madElev &lt;- fastData("madElev") # same as previous two lines
madElev
plot(madElev)

madForest2000 &lt;- fastData("madForest2000")
madForest2000
plot(madForest2000)

madForest2014 &lt;- fastData("madForest2014")
madForest2014
plot(madForest2014)

# multi-layer rasters
madChelsa &lt;- fastData("madChelsa")
madChelsa
plot(madChelsa)

madPpt &lt;- fastData("madPpt")
madTmin &lt;- fastData("madTmin")
madTmax &lt;- fastData("madTmax")
madPpt
madTmin
madTmax


# RGB raster
madLANDSAT &lt;- fastData("madLANDSAT")
madLANDSAT
plotRGB(madLANDSAT, 4, 1, 2, stretch = "lin")

# categorical raster
madCover &lt;- fastData("madCover")
madCover
madCover &lt;- droplevels(madCover)
levels(madCover) # levels in the raster
nlevels(madCover) # number of categories
catNames(madCover) # names of categories table

plot(madCover)
</code></pre>

<hr>
<h2 id='madPpt'>Rasters of average monthly precipitation for an eastern portion of Madagascar</h2><span id='topic+madPpt'></span>

<h3>Description</h3>

<p>Rasters of precipitation for an eastern portion of Madagascar from WorldClim 2.1 at ~3.33 arcminute resolution projected to the Tananarive (Paris)/Laborde Grid coordinate reference system. Values represent monthly averages across 1970-2000. Units are in millimeters. These should not be used for formal analysis.
</p>


<h3>Format</h3>

<p>An object of class <code>SpatRaster</code>.
</p>


<h3>Source</h3>

<p><a href="https://doi.org/10.1002/joc.5086">doi:10.1002/joc.5086</a>
</p>


<h3>References</h3>

<p>Fick, S.E. and Hijmans, R.J.  2017.  WorldClim 2: New 1-km spatial resolution climate surfaces for global land areas.  International Journal of Climatology 37:4302-4315. <a href="https://doi.org/10.1002/joc.5086">doi:10.1002/joc.5086</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### vector data

library(sf)

# For vector data, we can use data(*) or fastData(*):
data(madCoast0) # same as next line
madCoast0 &lt;- fastData("madCoast0") # same as previous
madCoast0
plot(st_geometry(madCoast0))

madCoast4 &lt;- fastData("madCoast4")
madCoast4
plot(st_geometry(madCoast4), add = TRUE)

madRivers &lt;- fastData("madRivers")
madRivers
plot(st_geometry(madRivers), col = "blue", add = TRUE)

madDypsis &lt;- fastData("madDypsis")
madDypsis
plot(st_geometry(madDypsis), col = "red", add = TRUE)

### raster data

library(terra)

# For raster data, we can get the file directly or using fastData(*):
rastFile &lt;- system.file("extdata/madElev.tif", package="fasterRaster")
madElev &lt;- terra::rast(rastFile)

madElev &lt;- fastData("madElev") # same as previous two lines
madElev
plot(madElev)

madForest2000 &lt;- fastData("madForest2000")
madForest2000
plot(madForest2000)

madForest2014 &lt;- fastData("madForest2014")
madForest2014
plot(madForest2014)

# multi-layer rasters
madChelsa &lt;- fastData("madChelsa")
madChelsa
plot(madChelsa)

madPpt &lt;- fastData("madPpt")
madTmin &lt;- fastData("madTmin")
madTmax &lt;- fastData("madTmax")
madPpt
madTmin
madTmax


# RGB raster
madLANDSAT &lt;- fastData("madLANDSAT")
madLANDSAT
plotRGB(madLANDSAT, 4, 1, 2, stretch = "lin")

# categorical raster
madCover &lt;- fastData("madCover")
madCover
madCover &lt;- droplevels(madCover)
levels(madCover) # levels in the raster
nlevels(madCover) # number of categories
catNames(madCover) # names of categories table

plot(madCover)
</code></pre>

<hr>
<h2 id='madRivers'>Major rivers in a selected portion of Madagascar</h2><span id='topic+madRivers'></span>

<h3>Description</h3>

<p>Spatial lines object of major rivers in a portion of Madagascar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(madRivers)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>sf</code>.
</p>


<h3>Source</h3>

<p><a href="https://diva-gis.org/">DIVA-GIS</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### vector data

library(sf)

# For vector data, we can use data(*) or fastData(*):
data(madCoast0) # same as next line
madCoast0 &lt;- fastData("madCoast0") # same as previous
madCoast0
plot(st_geometry(madCoast0))

madCoast4 &lt;- fastData("madCoast4")
madCoast4
plot(st_geometry(madCoast4), add = TRUE)

madRivers &lt;- fastData("madRivers")
madRivers
plot(st_geometry(madRivers), col = "blue", add = TRUE)

madDypsis &lt;- fastData("madDypsis")
madDypsis
plot(st_geometry(madDypsis), col = "red", add = TRUE)

### raster data

library(terra)

# For raster data, we can get the file directly or using fastData(*):
rastFile &lt;- system.file("extdata/madElev.tif", package="fasterRaster")
madElev &lt;- terra::rast(rastFile)

madElev &lt;- fastData("madElev") # same as previous two lines
madElev
plot(madElev)

madForest2000 &lt;- fastData("madForest2000")
madForest2000
plot(madForest2000)

madForest2014 &lt;- fastData("madForest2014")
madForest2014
plot(madForest2014)

# multi-layer rasters
madChelsa &lt;- fastData("madChelsa")
madChelsa
plot(madChelsa)

madPpt &lt;- fastData("madPpt")
madTmin &lt;- fastData("madTmin")
madTmax &lt;- fastData("madTmax")
madPpt
madTmin
madTmax


# RGB raster
madLANDSAT &lt;- fastData("madLANDSAT")
madLANDSAT
plotRGB(madLANDSAT, 4, 1, 2, stretch = "lin")

# categorical raster
madCover &lt;- fastData("madCover")
madCover
madCover &lt;- droplevels(madCover)
levels(madCover) # levels in the raster
nlevels(madCover) # number of categories
catNames(madCover) # names of categories table

plot(madCover)
</code></pre>

<hr>
<h2 id='madTmax'>Rasters of average monthly maximum temperature for an eastern portion of Madagascar</h2><span id='topic+madTmax'></span>

<h3>Description</h3>

<p>Rasters of maximum temperature for an eastern portion of Madagascar from WorldClim 2.1 at ~3.3 arcminute resolution projected to the Tananarive (Paris)/Laborde Grid coordinate reference system. Values represent monthly averages across 1970-2000. Units are in degrees C. These should not be used for formal analysis.
</p>


<h3>Format</h3>

<p>An object of class <code>SpatRaster</code>.
</p>


<h3>Source</h3>

<p><a href="https://doi.org/10.1002/joc.5086">doi:10.1002/joc.5086</a>
</p>


<h3>References</h3>

<p>Fick, S.E. and Hijmans, R.J.  2017.  WorldClim 2: New 1-km spatial resolution climate surfaces for global land areas.  International Journal of Climatology 37:4302-4315. <a href="https://doi.org/10.1002/joc.5086">doi:10.1002/joc.5086</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### vector data

library(sf)

# For vector data, we can use data(*) or fastData(*):
data(madCoast0) # same as next line
madCoast0 &lt;- fastData("madCoast0") # same as previous
madCoast0
plot(st_geometry(madCoast0))

madCoast4 &lt;- fastData("madCoast4")
madCoast4
plot(st_geometry(madCoast4), add = TRUE)

madRivers &lt;- fastData("madRivers")
madRivers
plot(st_geometry(madRivers), col = "blue", add = TRUE)

madDypsis &lt;- fastData("madDypsis")
madDypsis
plot(st_geometry(madDypsis), col = "red", add = TRUE)

### raster data

library(terra)

# For raster data, we can get the file directly or using fastData(*):
rastFile &lt;- system.file("extdata/madElev.tif", package="fasterRaster")
madElev &lt;- terra::rast(rastFile)

madElev &lt;- fastData("madElev") # same as previous two lines
madElev
plot(madElev)

madForest2000 &lt;- fastData("madForest2000")
madForest2000
plot(madForest2000)

madForest2014 &lt;- fastData("madForest2014")
madForest2014
plot(madForest2014)

# multi-layer rasters
madChelsa &lt;- fastData("madChelsa")
madChelsa
plot(madChelsa)

madPpt &lt;- fastData("madPpt")
madTmin &lt;- fastData("madTmin")
madTmax &lt;- fastData("madTmax")
madPpt
madTmin
madTmax


# RGB raster
madLANDSAT &lt;- fastData("madLANDSAT")
madLANDSAT
plotRGB(madLANDSAT, 4, 1, 2, stretch = "lin")

# categorical raster
madCover &lt;- fastData("madCover")
madCover
madCover &lt;- droplevels(madCover)
levels(madCover) # levels in the raster
nlevels(madCover) # number of categories
catNames(madCover) # names of categories table

plot(madCover)
</code></pre>

<hr>
<h2 id='madTmin'>Rasters of average monthly minimum temperature for an eastern portion of Madagascar</h2><span id='topic+madTmin'></span>

<h3>Description</h3>

<p>Rasters of minimum temperature for an eastern portion of Madagascar from WorldClim 2.1 at ~3.33 arcminute resolution projected to the Tananarive (Paris)/Laborde Grid coordinate reference system. Values represent monthly averages across 1970-2000. Units are in degrees C. These should not be used for formal analysis.
</p>


<h3>Format</h3>

<p>An object of class <code>SpatRaster</code>.
</p>


<h3>Source</h3>

<p><a href="https://doi.org/10.1002/joc.5086">doi:10.1002/joc.5086</a>
</p>


<h3>References</h3>

<p>Fick, S.E. and Hijmans, R.J.  2017.  WorldClim 2: New 1-km spatial resolution climate surfaces for global land areas.  International Journal of Climatology 37:4302-4315. <a href="https://doi.org/10.1002/joc.5086">doi:10.1002/joc.5086</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### vector data

library(sf)

# For vector data, we can use data(*) or fastData(*):
data(madCoast0) # same as next line
madCoast0 &lt;- fastData("madCoast0") # same as previous
madCoast0
plot(st_geometry(madCoast0))

madCoast4 &lt;- fastData("madCoast4")
madCoast4
plot(st_geometry(madCoast4), add = TRUE)

madRivers &lt;- fastData("madRivers")
madRivers
plot(st_geometry(madRivers), col = "blue", add = TRUE)

madDypsis &lt;- fastData("madDypsis")
madDypsis
plot(st_geometry(madDypsis), col = "red", add = TRUE)

### raster data

library(terra)

# For raster data, we can get the file directly or using fastData(*):
rastFile &lt;- system.file("extdata/madElev.tif", package="fasterRaster")
madElev &lt;- terra::rast(rastFile)

madElev &lt;- fastData("madElev") # same as previous two lines
madElev
plot(madElev)

madForest2000 &lt;- fastData("madForest2000")
madForest2000
plot(madForest2000)

madForest2014 &lt;- fastData("madForest2014")
madForest2014
plot(madForest2014)

# multi-layer rasters
madChelsa &lt;- fastData("madChelsa")
madChelsa
plot(madChelsa)

madPpt &lt;- fastData("madPpt")
madTmin &lt;- fastData("madTmin")
madTmax &lt;- fastData("madTmax")
madPpt
madTmin
madTmax


# RGB raster
madLANDSAT &lt;- fastData("madLANDSAT")
madLANDSAT
plotRGB(madLANDSAT, 4, 1, 2, stretch = "lin")

# categorical raster
madCover &lt;- fastData("madCover")
madCover
madCover &lt;- droplevels(madCover)
levels(madCover) # levels in the raster
nlevels(madCover) # number of categories
catNames(madCover) # names of categories table

plot(madCover)
</code></pre>

<hr>
<h2 id='mask+2CGRaster+2CGRaster-method'>Mask values in a raster</h2><span id='topic+mask+2CGRaster+2CGRaster-method'></span><span id='topic+mask'></span><span id='topic+mask+2CGRaster+2CGVector-method'></span>

<h3>Description</h3>

<p>The output of <code>mask()</code> is a <code>GRaster</code> that has the same as values as the input raster. However, if the <code>mask</code> argument is a <code>GRaster</code>, the output will have <code>NA</code> values in the same cells that the <code>mask</code> raster has <code>NA</code> cells. If the <code>mask</code> argument is a <code>GVector</code>, then the output raster will have <code>NA</code> values in cells the <code>GVector</code> does not cover.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster,GRaster'
mask(x, mask, inverse = FALSE, maskvalues = NA, updatevalue = NA)

## S4 method for signature 'GRaster,GVector'
mask(x, mask, inverse = FALSE, updatevalue = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mask+2B2CGRaster+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="mask+2B2CGRaster+2B2CGRaster-method_+3A_mask">mask</code></td>
<td>
<p>A <code>GRaster</code> or <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="mask+2B2CGRaster+2B2CGRaster-method_+3A_inverse">inverse</code></td>
<td>
<p>Logical: If <code>TRUE</code>, the effect of the mask is inverted. That is, a copy of the input raster is made, but cells that overlap with an <code>NA</code> in the mask raster or are not covered by the mask vector retain their values. Cells that overlap with an <code>NA</code> in the mask raster or overlap with the mask vector are forced to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="mask+2B2CGRaster+2B2CGRaster-method_+3A_maskvalues">maskvalues</code></td>
<td>
<p>Numeric vector, including <code>NA</code> (only for when <code>mask</code> is a <code>GRaster</code>): The value(s) in the mask raster cells that serve as the mask. The default is <code>NA</code>, in which case cells in the input raster that overlap with <code>NA</code> cells in the mask are forced to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="mask+2B2CGRaster+2B2CGRaster-method_+3A_updatevalue">updatevalue</code></td>
<td>
<p>Numeric, including <code>NA</code> (default): The values assigned to masked cells.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+mask">terra::mask()</a></code>, <strong>GRASS</strong> module <code>r.mask</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Example data
madElev &lt;- fastData("madElev") # raster
madForest &lt;- fastData("madForest2000") # raster
madCoast &lt;- fastData("madCoast4") # vector

# Convert to GRasters and GVectors
elev &lt;- fast(madElev)
forest &lt;- fast(madForest)
coast &lt;- fast(madCoast)

ant &lt;- coast[coast$NAME_4 == "Antanambe"]

# Mask by a raster or  vector:
maskByRast &lt;- mask(elev, forest)
plot(c(forest, maskByRast))

maskByVect &lt;- mask(elev, ant)
plot(maskByVect)
plot(ant, add = TRUE)

# Mask by a raster or vector, but invert mask:
maskByRastInvert &lt;- mask(elev, forest, inverse = TRUE)
plot(c(forest, maskByRastInvert))

maskByVectInvert &lt;- mask(elev, ant, inverse = TRUE)
plot(maskByVectInvert)
plot(ant, add = TRUE)

# Mask by a raster, but use custom values for the mask:
maskByRastCustomMask &lt;- mask(elev, elev, maskvalues = 1:20)
plot(c(elev &lt;= 20, maskByRastCustomMask))

# Mask by a raster or vector, but force masked values to a custom value:
byRastCustomUpdate &lt;- mask(elev, forest, updatevalue = 7)
plot(byRastCustomUpdate)

byVectCustomUpdate &lt;- mask(elev, ant, updatevalue = 7)
plot(byVectCustomUpdate)

# Mask by a raster, inverse, custom values, and custom update:
byRastAll &lt;-
   mask(elev, elev, inverse = TRUE, maskvalues = 1:20, updatevalue = 7)

plot(c(elev, byRastAll))

}
</code></pre>

<hr>
<h2 id='maskNA+2CGRaster-method'>Mask all non-NA cells or all NA cells</h2><span id='topic+maskNA+2CGRaster-method'></span><span id='topic+maskNA'></span>

<h3>Description</h3>

<p>This function converts all non-<code>NA</code> cells in a <code>GRaster</code> to a single user-defined value, leaving <code>NA</code> cells as <code>NA</code>. Alternatively, it can convert <code>NA</code> cells to a user-defined value, and all non-<code>NA</code> cells to <code>NA.</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
maskNA(x, value = 1, invert = FALSE, retain = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maskNA+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="maskNA+2B2CGRaster-method_+3A_value">value</code></td>
<td>
<p>Numeric: Value to which to assign to masked cells. The default is 1.</p>
</td></tr>
<tr><td><code id="maskNA+2B2CGRaster-method_+3A_invert">invert</code></td>
<td>
<p>Logical: If <code>FALSE</code> (default), convert non-<code>NA</code> cells to <code>value</code>, and leave <code>NA</code> cells as-is. If <code>TRUE</code>, convert all <code>NA</code> cells to <code>value</code>, and non-<code>NA</code> cells to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="maskNA+2B2CGRaster-method_+3A_retain">retain</code></td>
<td>
<p>Logical: If <code>invert</code> is <code>TRUE</code> and <code>retain</code> is <code>FALSE</code> (default), non-<code>NA</code> cells will retain their value. This argument is ignored if <code>invert</code> is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+not.na">not.na()</a></code>, <code><a href="#topic+app">app()</a></code>, <code><a href="#topic+mask">mask()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Elevation raster
madElev &lt;- fastData("madElev")

# Convert a SpatRaster to a GRaster:
elev &lt;- fast(madElev)

# Convert non-NA to 1, NA cells remain NA
elevMask &lt;- maskNA(elev)
elevMask
plot(c(elev, elevMask))

# Convert NA to 1, non-NA cells become NA
elevInvertMask &lt;- maskNA(elev, invert = TRUE)
elevInvertMask
plot(c(elev, elevInvertMask))

# Convert NA to 200, non-NA cells keep their values
elevInvertRetain &lt;- maskNA(elev, value = 200, invert = TRUE, retain = TRUE)
elevInvertRetain
plot(c(elev, elevInvertRetain))

}
</code></pre>

<hr>
<h2 id='match+2CGRaster-method'>Find which cells of a GRaster match certain values</h2><span id='topic+match+2CGRaster-method'></span><span id='topic+match'></span><span id='topic++25in+25+2CGRaster-method'></span><span id='topic++25in+25'></span><span id='topic++25notin+25+2CGRaster-method'></span><span id='topic++25notin+25'></span>

<h3>Description</h3>

<p>The <code>match()</code> function takes a <code>GRaster</code> and a numeric, integer or character vector as inputs and returns a <code>GRaster</code> with cell values that correspond to the index of each element in the vector that matched the original cell value. For example, if a 4-cell raster had values 3, <code>NA</code>, 5, 4, and the vector was <code>c(3, 4)</code>, then the output would be a 4-cell raster with values 1, <code>NA</code>, <code>NA</code>, 2 because the first value in the vector was 3 (so the cell with 3 is assigned 1), and because the second value in the vector was 4 (so the cell with 4 was assigned 2). The other two values had no matches.
</p>
<p>If the <code>GRaster</code> is categorical, then the vector can be category labels instead of numeric values.
</p>
<p>The <code>%in%</code> operator returns a <code>GRaster</code> with cell values that are 1 if their original values appeared in the vector, and 0 if not (or <code>NA</code> if the original value was <code>NA</code>). If the <code>GRaster</code> is categorical, then the vector can be category labels instead of numeric values.
</p>
<p>The <code style="white-space: pre;">&#8288;%notin%&#8288;</code> operator returns 1 for cells with values that are <em>not</em> found in the vector, and 0 otherwise. If the <code>GRaster</code> is categorical, then the vector can be category labels instead of numeric values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
match(x, table, nomatch = NA)

## S4 method for signature 'GRaster'
x %in% table

## S4 method for signature 'GRaster'
x %notin% table
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>: Note that any kind of <code>GRaster</code> is acceptable (integer, float, double, or categorical), but matching may not work as intended for float and double rasters because of problems with comparing floating-point values.</p>
</td></tr>
<tr><td><code id="match+2B2CGRaster-method_+3A_table">table</code></td>
<td>
<p>A numeric, integer, or character vector.</p>
</td></tr>
<tr><td><code id="match+2B2CGRaster-method_+3A_nomatch">nomatch</code></td>
<td>
<p>Numeric or integer: Value to return when no match is found.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+match">terra::match()</a></code>, <code><a href="#topic+match">match()</a></code>, <code><a href="omnibus.html#topic+notIn">omnibus::notIn()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data: Elevation and land cover rasters
madElev &lt;- fastData("madElev")
madCover &lt;- fastData("madCover")

### match() with an integer raster:

elev &lt;- fast(madElev)

# Cells in elevation raster replaced with index in which they appear
# in the table:
table &lt;- c(10, 20, 30, 40, 50)
elevIndex &lt;- match(elev, table)
elevIndexNeg &lt;- match(elev, table, nomatch = -100)

plot(c(elevIndex, elevIndexNeg))

### Using %in% and %notin% on an integer GRaster:

elev &lt;- fast(madElev)
table &lt;- c(10, 20, 30, 40, 50)

ins &lt;- elev %in% table
notins &lt;- elev %notin% table

plot(c(ins, notins))

### match() with a categorical raster:

cover &lt;- fast(madCover)
cover &lt;- droplevels(cover)
levels(cover)

forestLabels &lt;- c(
   "Sparse broadleaved evergreen/semi-deciduous forest",
   "Broadleaved deciduous forest",
   "Grassland with mosaic forest",
   "Flooded forest"
)

forestClasses &lt;- match(cover, forestLabels)
plot(forestClasses)
levels(forestClasses)

forestNoMatch &lt;- match(cover, forestLabels, nomatch = -100)
plot(forestNoMatch)
levels(forestNoMatch)

### Using %in% and %notin% on a categorical GRaster:

cover &lt;- fast(madCover)
cover &lt;- droplevels(cover)
levels(cover)

forestLabels &lt;- c(
   "Sparse broadleaved evergreen/semi-deciduous forest",
   "Broadleaved deciduous forest",
   "Grassland with mosaic forest",
   "Flooded forest"
)

forest &lt;- cover %in% forestLabels
plot(forest)

notForest &lt;- cover %notin% forestLabels
plot(notForest)

}
</code></pre>

<hr>
<h2 id='mean+2CGRaster-method'>Mathematical operations on two or more GRasters</h2><span id='topic+mean+2CGRaster-method'></span><span id='topic+mean'></span><span id='topic+mmode+2CGRaster-method'></span><span id='topic+mmode'></span><span id='topic+median+2CGRaster-method'></span><span id='topic+median'></span><span id='topic+count+2CGRaster-method'></span><span id='topic+count'></span><span id='topic+sum+2CGRaster-method'></span><span id='topic+sum'></span><span id='topic+min+2CGRaster-method'></span><span id='topic+min'></span><span id='topic+max+2CGRaster-method'></span><span id='topic+max'></span><span id='topic+which.min+2CGRaster-method'></span><span id='topic+which.min'></span><span id='topic+which.max+2CGRaster-method'></span><span id='topic+which.max'></span><span id='topic+sdpop+2Cnumeric-method'></span><span id='topic+sdpop'></span><span id='topic+varpop+2CGRaster-method'></span><span id='topic+varpop'></span><span id='topic+varpop+2Cnumeric-method'></span><span id='topic+stdev+2CGRaster-method'></span><span id='topic+stdev'></span><span id='topic+var+2CGRaster-method'></span><span id='topic+var'></span><span id='topic+nunique+2CGRaster-method'></span><span id='topic+nunique'></span><span id='topic+skewness+2CGRaster-method'></span><span id='topic+skewness'></span><span id='topic+kurtosis+2CGRaster-method'></span><span id='topic+kurtosis'></span><span id='topic+range+2CGRaster-method'></span><span id='topic+range'></span><span id='topic+quantile+2CGRaster-method'></span><span id='topic+quantile'></span><span id='topic+anyNA+2CGRaster-method'></span><span id='topic+anyNA'></span><span id='topic+allNA+2CGRaster-method'></span><span id='topic+allNA'></span>

<h3>Description</h3>

<p>These functions can be applied to a &quot;stack&quot; of <code>GRaster</code>s with two or more layers. They return a single-layered <code>GRaster</code>.  If you want to summarize across cells in a raster (e.g., calculate the mean value of all cells on a raster), use <code><a href="#topic+global">global()</a></code>. Options include:
</p>

<ul>
<li><p> Numeration: <code>count()</code> (number of non-<code>NA</code> cells), <code>sum()</code>.
</p>
</li>
<li><p> Central tendency: <code>mean()</code>, <code>mmode()</code> (mode), <code>median()</code>.
</p>
</li>
<li><p> Extremes: <code>min()</code>, <code>max()</code>, <code>which.min()</code> (index of raster with the minimum value), <code>which.max()</code> (index of the raster with the maximum value)
</p>
</li>
<li><p> Dispersion: <code>range()</code>, <code>stdev()</code> (standard deviation), <code>var()</code> (sample variance), <code>varpop()</code> (population variance), <code>nunique()</code> (number of unique values), <code>quantile()</code> (use argument <code>probs</code>), <code>skewness()</code>, and <code>kurtosis()</code>.
</p>
</li>
<li> <p><code>NA</code>s: <code>anyNA()</code> (any cells are <code>NA</code>?), <code>allNA()</code> (are all cells <code>NA</code>?)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
mean(x, na.rm = FALSE)

## S4 method for signature 'GRaster'
mmode(x, na.rm = FALSE)

## S4 method for signature 'GRaster'
median(x, na.rm = FALSE)

## S4 method for signature 'GRaster'
count(x)

## S4 method for signature 'GRaster'
sum(x, na.rm = FALSE)

## S4 method for signature 'GRaster'
min(x, na.rm = FALSE)

## S4 method for signature 'GRaster'
max(x, na.rm = FALSE)

## S4 method for signature 'GRaster'
which.min(x)

## S4 method for signature 'GRaster'
which.max(x)

## S4 method for signature 'numeric'
sdpop(x, na.rm = FALSE)

## S4 method for signature 'GRaster'
varpop(x, na.rm = FALSE)

## S4 method for signature 'numeric'
varpop(x, na.rm = FALSE)

## S4 method for signature 'GRaster'
stdev(x, pop = TRUE, na.rm = FALSE)

## S4 method for signature 'GRaster'
var(x, na.rm = FALSE)

## S4 method for signature 'GRaster'
nunique(x, na.rm = FALSE)

## S4 method for signature 'GRaster'
skewness(x, na.rm = FALSE)

## S4 method for signature 'GRaster'
kurtosis(x, na.rm = FALSE)

## S4 method for signature 'GRaster'
range(x, na.rm = FALSE)

## S4 method for signature 'GRaster'
quantile(x, prob, na.rm = FALSE)

## S4 method for signature 'GRaster'
anyNA(x)

## S4 method for signature 'GRaster'
allNA(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>. Typically, this raster will have two or more layers. Values will be calculated within cells across rasters.</p>
</td></tr>
<tr><td><code id="mean+2B2CGRaster-method_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical: If <code>FALSE</code> (default), of one cell value has an <code>NA</code>, the result will be <code>NA</code>. If <code>TRUE</code>, <code>NA</code>s are ignored.</p>
</td></tr>
<tr><td><code id="mean+2B2CGRaster-method_+3A_pop">pop</code></td>
<td>
<p>Logical (for <code>stdev()</code>): If <code>TRUE</code> (default), calculate the population standard deviation across layers. If <code>FALSE</code>, calculate the sample standard deviation.</p>
</td></tr>
<tr><td><code id="mean+2B2CGRaster-method_+3A_prob">prob</code></td>
<td>
<p>Numeric: Quantile to calculate. Used for <code>quantile()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Example data
madChelsa &lt;- fastData("madChelsa")

# Convert a SpatRaster to a GRaster
chelsa &lt;- fast(madChelsa)
chelsa # 4 layers

# Central tendency
mean(chelsa)
mmode(chelsa)
median(chelsa)

# Statistics
nunique(chelsa)
sum(chelsa)
count(chelsa)
min(chelsa)
max(chelsa)
range(chelsa)
skewness(chelsa)
kurtosis(chelsa)

stdev(chelsa)
stdev(chelsa, pop = FALSE)
var(chelsa)
varpop(chelsa)

# Which layers have maximum/minimum?
which.min(chelsa)
which.max(chelsa)

# Regression

# Note the intercept is different for fasterRaster::regress().
regress(chelsa)
regress(madChelsa, 1:nlyr(madChelsa))

# Note: To get quantiles for each layer, use global().
quantile(chelsa, 0.1)

# NAs
madForest2000 &lt;- fastData("madForest2000")
forest2000 &lt;- fast(madForest2000)
forest2000 &lt;- project(forest2000, chelsa, method = "near")

chelsaForest &lt;- c(chelsa, forest2000)

nas &lt;- anyNA(chelsaForest)
plot(nas)

allNas &lt;- allNA(chelsaForest)
plot(allNas)

}
</code></pre>

<hr>
<h2 id='merge+2CGRaster+2CGRaster-method'>Combine two or more rasters with different extents and fill in NAs</h2><span id='topic+merge+2CGRaster+2CGRaster-method'></span><span id='topic+merge'></span>

<h3>Description</h3>

<p><code>merge()</code> combines two or more <code>GRaster</code>s, possibly with different extents, into a single larger <code>GRaster</code>. Where the same cell has different values in each raster, the value of the first raster's cell is used. If this is <code>NA</code>, then the value of the second raster's cell is used, and so on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster,GRaster'
merge(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge+2B2CGRaster+2B2CGRaster-method_+3A_x">x</code>, <code id="merge+2B2CGRaster+2B2CGRaster-method_+3A_y">y</code>, <code id="merge+2B2CGRaster+2B2CGRaster-method_+3A_...">...</code></td>
<td>
<p><code>GRaster</code>s.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+merge">terra::merge()</a></code>, <code><a href="terra.html#topic+mosaic">terra::mosaic()</a></code>, and <strong>GRASS</strong> module <code>r.patch</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Example data
madElev &lt;- fastData("madElev")
madCoast4 &lt;- fastData("madCoast4")
madCoast4 &lt;- vect(madCoast4)

# For the example, crop the elevation raster to two communes
madAnt &lt;- madCoast4[madCoast4$NAME_4 == "Antanambe", ]
madMan &lt;- madCoast4[madCoast4$NAME_4 == "Manompana", ]

elevAnt &lt;- crop(madElev, madAnt)
elevMan &lt;- crop(madElev, madMan)

plot(madElev)
plot(elevAnt, col = "red", legend = FALSE, add = TRUE)
plot(elevMan, col = "blue", legend = FALSE, add = TRUE)

# Convert a SpatRaster to a GRaster
ant &lt;- fast(elevAnt)
man &lt;- fast(elevMan)

# merge
antMan &lt;- merge(ant, man)
plot(antMan, main = "Antman!")

}
</code></pre>

<hr>
<h2 id='minmax+2CGRaster-method'>Minimum and maximum values or categories of a GRaster</h2><span id='topic+minmax+2CGRaster-method'></span><span id='topic+minmax'></span>

<h3>Description</h3>

<p><code>minmax()</code> reports the minimum and maximum values across all non-NA cells of a <code>GRaster</code>. When the <code>levels</code> argument is <code>TRUE</code> and the raster is categorical, the function reports the &quot;lowest&quot; and &quot;highest&quot; category values in a categorical (factor) <code>GRaster</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
minmax(x, levels = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="minmax+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="minmax+2B2CGRaster-method_+3A_levels">levels</code></td>
<td>
<p>Logical: If <code>TRUE</code> and the raster is a categorical raster, return the &quot;lowest&quot; and &quot;highest&quot; categories. The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>minmax()</code> returns a numeric matrix, and <code>minmax(..., levels = TRUE)</code> returns a <code>data.frame</code> with category names. In the latter case, non-categorical rasters will have <code>NA</code> values.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+minmax">terra::minmax()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")
madForest2000 &lt;- fastData("madForest2000")

# Convert SpatRasters to GRasters
elev &lt;- fast(madElev)
forest &lt;- fast(madForest2000)

### GRaster properties

# plotting
plot(elev)

# dimensions
dim(elev) # rows, columns, depths, layers
nrow(elev) # rows
ncol(elev) # columns
ndepth(elev) # depths
nlyr(elev) # layers

res(elev) # resolution (2D)
res3d(elev) # resolution (3D)
zres(elev) # vertical resolution
xres(elev) # vertical resolution
yres(elev) # vertical resolution
zres(elev) # vertical resolution (NA because this is a 2D GRaster)

# cell counts
ncell(elev) # cells
ncell3d(elev) # cells (3D rasters only)

# number of NA and non-NA cells
nacell(elev)
nonnacell(elev)

# topology
topology(elev) # number of dimensions
is.2d(elev) # is it 2-dimensional?
is.3d(elev) # is it 3-dimensional?

minmax(elev) # min/max values

# "names" of the object
names(elev)

# coordinate reference system
crs(elev)
st_crs(elev)
coordRef(elev)

# extent (bounding box)
ext(elev)

# vertical extent (not defined for this raster)
zext(elev)

# data type
datatype(elev) # fasterRaster type
datatype(elev, "GRASS") # GRASS type
datatype(elev, "terra") # terra type
datatype(elev, "GDAL") # GDAL type

is.integer(elev)
is.float(elev)
is.double(elev)
is.factor(elev)

# convert data type
as.int(elev) # integer; note that "elev" is already of type "integer"
as.float(elev) # floating-precision
as.doub(elev) # double-precision

# assigning
pie &lt;- elev
pie[] &lt;- pi # assign all cells to the value of pi
pie

# concatenating multiple GRasters
rasts &lt;- c(elev, forest)
rasts

# subsetting
rasts[[1]]
rasts[["madForest2000"]]

# replacing
rasts[[2]] &lt;- 2 * forest
rasts

# adding layers
rasts[[3]] &lt;- elev &gt; 500 # add a layer
rasts &lt;- c(rasts, sqrt(elev)) # add another
add(rasts) &lt;- ln(elev)
rasts

# names
names(rasts)
names(rasts) &lt;- c("elev_meters", "2_x_forest", "high_elevation", "sqrt_elev", "ln_elev")
rasts

# remove a layer
rasts[["2_x_forest"]] &lt;- NULL
rasts

# number of layers
nlyr(rasts)

# correlation and covariance matrices
madLANDSAT &lt;- fastData("madLANDSAT")
landsat &lt;- fast(madLANDSAT) # projects matrix
layerCor(landsat) # correlation
layerCor(landsat, fun = 'cov') # covariance

}
</code></pre>

<hr>
<h2 id='missingCats+2CGRaster-method'>Values in a categorical raster with no assigned category</h2><span id='topic+missingCats+2CGRaster-method'></span><span id='topic+missingCats'></span>

<h3>Description</h3>

<p>This function reports the values in a categorical <code>GRaster</code> that have no matching category label in its &quot;levels&quot; table.
</p>
<p><code>GRaster</code>s can represent categorical data. Cell values are actually integers, each corresponding to a category, such as &quot;desert&quot; or &quot;wetland.&quot; A categorical raster is associated with a table that matches each value to a category name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
missingCats(x, layer = 1:nlyr(x))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="missingCats+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="missingCats+2B2CGRaster-method_+3A_layer">layer</code></td>
<td>
<p>Numeric integers, logical vector, or character: Layer(s) for which to obtain missing categories.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector (if <code>x</code>is just one layer), or a named list of numeric vectors, one per layer in <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+missingCats">missingCats()</a></code>, <code><a href="#topic+missing.cases">missing.cases()</a></code>, <code><a href="#topic+droplevels">droplevels()</a></code>, <code>vignette("GRasters", package = "fasterRaster")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data: Land cover raster
madCover &lt;- fastData("madCover")

# Convert categorical SpatRaster to categorical GRaster:
cover &lt;- fast(madCover)

### Properties of categorical rasters

cover # note categories
is.factor(cover) # Is the raster categorical?
nlevels(cover) # number of levels
levels(cover) # just the value and active column
cats(cover) # all columns
minmax(cover) # min/max values
minmax(cover, levels = TRUE) # min/max categories
catNames(cover) # column names of the levels table
missingCats(cover) # categories in table with no values in raster
freq(cover) # frequency of each category (number of cells)
zonalGeog(cover) # geometric statistics

### Active column

# Which column sets the category labels?
activeCat(cover)
activeCat(cover, names = TRUE)

activeCats(c(cover, cover))

# Choose a different column for category labels:
levels(cover)
activeCat(cover) &lt;- 2
levels(cover)

### Managing levels tables

# Remove unused levels:
nlevels(cover)
cover &lt;- droplevels(cover)
nlevels(cover)

# Re-assign levels:
value &lt;- c(20, 30, 40, 50, 120, 130, 140, 170)
label &lt;- c("Cropland", "Cropland", "Forest", "Forest",
 "Grassland", "Shrubland", "Herbaceous", "Flooded")

newCats &lt;- data.frame(value = value, label = label)

cover &lt;- categories(cover, layer = 1, value = newCats)
cats(cover)

# This is the same as:
levels(cover) &lt;- newCats
cats(cover)

# Are there any values not assigned a category?
missingCats(cover)

# Let's assign a category for value 210 (water):
water &lt;- data.frame(value = 210, label = "Water")
addCats(cover) &lt;- water
levels(cover)

# Add more information to the levels table using merge():
landType &lt;- data.frame(
     Value = c(20, 30, 40, 50, 120),
     Type = c("Irrigated", "Rainfed", "Broadleaf evergreen",
     "Broadleaf deciduous", "Mosaic with forest")
)
cats(cover)
cover &lt;- addCats(cover, landType, merge = TRUE)
cats(cover)

### Logical operations on categorical rasters

cover &lt; "Forest" # 1 for cells with a value &lt; 40, 0 otherwise
cover &lt;= "Forest" # 1 for cells with a value &lt; 120, 0 otherwise
cover == "Forest" # 1 for cells with value of 40-120, 0 otherwise
cover != "Forest" # 1 for cells with value that is not 40-120, 0 otherwise
cover &gt; "Forest" # 1 for cells with a value &gt; 120, 0 otherwise
cover &gt;= "Forest" # 1 for cells with a value &gt;= 120, 0 otherwise

cover %in% c("Cropland", "Forest") # 1 for cropland/forest cells, 0 otherwise

### Combine categories from different rasters

# For the example, will create a second categorical raster fromm elevation.

# Divide elevation raster into "low/medium/high" levels:
madElev &lt;- fastData("madElev")
elev &lt;- fast(madElev)
elev &lt;- project(elev, cover, method = "near") # convert to same CRS
fun &lt;- "= if(madElev &lt; 100, 0, if(madElev &lt; 400, 1, 2))"
elevCat &lt;- app(elev, fun)

levs &lt;- data.frame(
     value = c(0, 1, 2),
     elevation = c("low", "medium", "high")
)
levels(elevCat) &lt;- list(levs)

# Combine levels:
combined &lt;- concats(cover, elevCat)
combined
levels(combined)

# Combine levels, treating value/NA combinations as new categories:
combinedNA &lt;- concats(cover, elevCat, na.rm = FALSE)
combinedNA
levels(combinedNA)

}
</code></pre>

<hr>
<h2 id='mow'>Remove rasters and vectors from the GRASS cache</h2><span id='topic+mow'></span>

<h3>Description</h3>

<p><strong>fasterRaster</strong> functions attempt to delete rasters and vectors in the <strong>GRASS</strong> cache, but not all intermediate files can be removed. This function can be used to clear the cache of extraneous rasters and vectors.
</p>
<p>Calling this function inside another function's environment and defining <code>x</code> as <code>"*"</code> can be very <strong>dangerous</strong>, as it will detect objects outside of that environment, and thus delete any rasters/vectors outside that environment. Here is a guide:
</p>

<ul>
<li><p> To delete files associated with a single <code>GRaster</code> or <code>GVector</code>, use <code>mow(GRaster_to_unlink)</code> or <code>mow(GVector_to_unlink)</code>.
To remove all rasters, all vectors, or all rasters and vectors in the <strong>GRASS</strong> cache that are not linked to a <code>GRaster</code> or <code>GVector</code>, use <code>mow("*")</code>.
To remove all rasters or all vectors in the <strong>GRASS</strong> cache, use <code>mow("*", type = "rasters")</code> or <code>mow("*", type = "vectors")</code>.
To remove all rasters or all vectors in the <strong>GRASS</strong> cache <em>except</em> for certain ones, use <code>mow("*", unlinked = FALSE, keep = list(GRaster_to_keep, GVector_to_keep))</code>. You can combine this with the <code>keep</code> argument to retain specific rasters or vectors. For example, you can use <code>mow("*", unlinked = FALSE, type = "rasters", keep = list(GRaster_to_keep))</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>mow(
  x = "unlinked",
  pos = NULL,
  type = NULL,
  keep = NULL,
  verbose = TRUE,
  ask = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mow_+3A_x">x</code></td>
<td>
<p>Any of:
</p>

<ul>
<li> <p><code>"unlinked"</code> (default): Delete <strong>GRASS</strong> rasters and/or vectors that are unlinked to <code>GRaster</code>s or <code>GVector</code>s in the environment in which the function was called, or the environment named in <code>pos</code>.
</p>
</li>
<li><p> A <code>GRaster</code> or <code>GVector</code>: Delete the <strong>GRASS</strong> raster or vector pointed to by this object.
</p>
</li>
<li><p> A <code>list</code> of <code>GRaster</code>s and/or <code>GVector</code>s: Delete the <strong>GRASS</strong> raster(s) and/or vector(s) pointed to by these objects.
</p>
</li>
<li> <p><code>"*"</code>: Delete <em>all</em> <strong>GRASS</strong> rasters and/or vectors pointed to by objects in the environment named in <code>pos</code>. Only objects in <code>keep</code> will not be deleted.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mow_+3A_pos">pos</code></td>
<td>
<p>Either <code>NULL</code> (default), or an environment. This is used only if <code>x</code> is <code>"unlinked"</code> or <code>"*"</code>. In that case, if <code>pos</code> is <code>NULL</code>, the environment in which this function was called will be searched for <code>GRaster</code>s and <code>GVector</code>s for removal of their associated <strong>GRASS</strong> rasters and vectors. Otherwise, the named environment will be searched.</p>
</td></tr>
<tr><td><code id="mow_+3A_type">type</code></td>
<td>
<p>Either <code>NULL</code> or a character vector. This is used only if <code>x</code> is <code>"unlinked"</code> or <code>"*"</code>. If <code>NULL</code>, all rasters and vectors in the <strong>GRASS</strong> cache are candidates for deletion. Otherwise, this can be either <code>"rasters"</code>, <code>"vectors"</code>, or both.</p>
</td></tr>
<tr><td><code id="mow_+3A_keep">keep</code></td>
<td>
<p>Either <code>NULL</code> (default) or a <code>list()</code> of <code>GRaster</code>s and/or <code>GVector</code>s that you want to retain. This is used only if <code>x</code> is <code>"unlinked"</code> or <code>"*"</code>. The rasters and vectors in <strong>GRASS</strong> pointed to by these objects will not be deleted.</p>
</td></tr>
<tr><td><code id="mow_+3A_verbose">verbose</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), report progress.</p>
</td></tr>
<tr><td><code id="mow_+3A_ask">ask</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), prompt for reassurance. This is used only if <code>x</code> is <code>"unlinked"</code> or <code>"*"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns a named vector with the number of rasters and vectors deleted.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+tmpFile">terra::tmpFiles()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
madElev &lt;- fastData("madElev")
elev &lt;- fast(madElev)

mow(elev, ask = TRUE) # delete GRASS raster attached to `elev`

}
</code></pre>

<hr>
<h2 id='nacell+2CGRaster-method'>Number of NA or non-NA cells in a raster</h2><span id='topic+nacell+2CGRaster-method'></span><span id='topic+nacell'></span><span id='topic+nonnacell+2CGRaster-method'></span><span id='topic+nonnacell'></span>

<h3>Description</h3>

<p>The <code>nacell()</code> function counts the number of <code>NA</code> cells in a <code>GRaster</code>, and the <code>nonnacell()</code> reports the number of non-<code>NA</code> cells. If the raster is 3D, then all cells in all layers are counted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
nacell(x, warn = TRUE)

## S4 method for signature 'GRaster'
nonnacell(x, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nacell+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="nacell+2B2CGRaster-method_+3A_warn">warn</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), display a warning about how much time the computation could take.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value, one per raster layer in the input.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ncell">ncell()</a></code>, <code><a href="#topic+ncell3d">ncell3d()</a></code>, <code><a href="terra.html#topic+dimensions">terra::ncell()</a></code>, <code><a href="#topic+dim">dim()</a></code>, <code><a href="terra.html#topic+dimensions">terra::dim()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")
madForest2000 &lt;- fastData("madForest2000")

# Convert SpatRasters to GRasters
elev &lt;- fast(madElev)
forest &lt;- fast(madForest2000)

### GRaster properties

# plotting
plot(elev)

# dimensions
dim(elev) # rows, columns, depths, layers
nrow(elev) # rows
ncol(elev) # columns
ndepth(elev) # depths
nlyr(elev) # layers

res(elev) # resolution (2D)
res3d(elev) # resolution (3D)
zres(elev) # vertical resolution
xres(elev) # vertical resolution
yres(elev) # vertical resolution
zres(elev) # vertical resolution (NA because this is a 2D GRaster)

# cell counts
ncell(elev) # cells
ncell3d(elev) # cells (3D rasters only)

# number of NA and non-NA cells
nacell(elev)
nonnacell(elev)

# topology
topology(elev) # number of dimensions
is.2d(elev) # is it 2-dimensional?
is.3d(elev) # is it 3-dimensional?

minmax(elev) # min/max values

# "names" of the object
names(elev)

# coordinate reference system
crs(elev)
st_crs(elev)
coordRef(elev)

# extent (bounding box)
ext(elev)

# vertical extent (not defined for this raster)
zext(elev)

# data type
datatype(elev) # fasterRaster type
datatype(elev, "GRASS") # GRASS type
datatype(elev, "terra") # terra type
datatype(elev, "GDAL") # GDAL type

is.integer(elev)
is.float(elev)
is.double(elev)
is.factor(elev)

# convert data type
as.int(elev) # integer; note that "elev" is already of type "integer"
as.float(elev) # floating-precision
as.doub(elev) # double-precision

# assigning
pie &lt;- elev
pie[] &lt;- pi # assign all cells to the value of pi
pie

# concatenating multiple GRasters
rasts &lt;- c(elev, forest)
rasts

# subsetting
rasts[[1]]
rasts[["madForest2000"]]

# replacing
rasts[[2]] &lt;- 2 * forest
rasts

# adding layers
rasts[[3]] &lt;- elev &gt; 500 # add a layer
rasts &lt;- c(rasts, sqrt(elev)) # add another
add(rasts) &lt;- ln(elev)
rasts

# names
names(rasts)
names(rasts) &lt;- c("elev_meters", "2_x_forest", "high_elevation", "sqrt_elev", "ln_elev")
rasts

# remove a layer
rasts[["2_x_forest"]] &lt;- NULL
rasts

# number of layers
nlyr(rasts)

# correlation and covariance matrices
madLANDSAT &lt;- fastData("madLANDSAT")
landsat &lt;- fast(madLANDSAT) # projects matrix
layerCor(landsat) # correlation
layerCor(landsat, fun = 'cov') # covariance

}
</code></pre>

<hr>
<h2 id='names+2CGRaster-method'>Name(s) of a GRaster or columns of a GVector's data table</h2><span id='topic+names+2CGRaster-method'></span><span id='topic+names'></span><span id='topic+names+3C-+2CGRaster-method'></span><span id='topic+names+3C-'></span><span id='topic+names+2CGVector-method'></span><span id='topic+names+3C-+2CGVector-method'></span>

<h3>Description</h3>

<p><code>names()</code> returns that names(s) of a <code>GRaster</code> or of columns of a <code>GVector</code>'s data table'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
names(x)

## S4 replacement method for signature 'GRaster'
names(x) &lt;- value

## S4 method for signature 'GVector'
names(x)

## S4 replacement method for signature 'GVector'
names(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="names+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> or <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="names+2B2CGRaster-method_+3A_value">value</code></td>
<td>
<p>Character: Name(s) to assign to the raster(s).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code style="white-space: pre;">&#8288;names(value) &lt;-&#8288;</code> assigns a new name to the <code>GRaster</code> or to the columns of a <code>GVector</code>'s data table.
</p>


<h3>Value</h3>

<p>Character vector.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+names">terra::names()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")
madForest2000 &lt;- fastData("madForest2000")

# Convert SpatRasters to GRasters
elev &lt;- fast(madElev)
forest &lt;- fast(madForest2000)

### GRaster properties

# plotting
plot(elev)

# dimensions
dim(elev) # rows, columns, depths, layers
nrow(elev) # rows
ncol(elev) # columns
ndepth(elev) # depths
nlyr(elev) # layers

res(elev) # resolution (2D)
res3d(elev) # resolution (3D)
zres(elev) # vertical resolution
xres(elev) # vertical resolution
yres(elev) # vertical resolution
zres(elev) # vertical resolution (NA because this is a 2D GRaster)

# cell counts
ncell(elev) # cells
ncell3d(elev) # cells (3D rasters only)

# number of NA and non-NA cells
nacell(elev)
nonnacell(elev)

# topology
topology(elev) # number of dimensions
is.2d(elev) # is it 2-dimensional?
is.3d(elev) # is it 3-dimensional?

minmax(elev) # min/max values

# "names" of the object
names(elev)

# coordinate reference system
crs(elev)
st_crs(elev)
coordRef(elev)

# extent (bounding box)
ext(elev)

# vertical extent (not defined for this raster)
zext(elev)

# data type
datatype(elev) # fasterRaster type
datatype(elev, "GRASS") # GRASS type
datatype(elev, "terra") # terra type
datatype(elev, "GDAL") # GDAL type

is.integer(elev)
is.float(elev)
is.double(elev)
is.factor(elev)

# convert data type
as.int(elev) # integer; note that "elev" is already of type "integer"
as.float(elev) # floating-precision
as.doub(elev) # double-precision

# assigning
pie &lt;- elev
pie[] &lt;- pi # assign all cells to the value of pi
pie

# concatenating multiple GRasters
rasts &lt;- c(elev, forest)
rasts

# subsetting
rasts[[1]]
rasts[["madForest2000"]]

# replacing
rasts[[2]] &lt;- 2 * forest
rasts

# adding layers
rasts[[3]] &lt;- elev &gt; 500 # add a layer
rasts &lt;- c(rasts, sqrt(elev)) # add another
add(rasts) &lt;- ln(elev)
rasts

# names
names(rasts)
names(rasts) &lt;- c("elev_meters", "2_x_forest", "high_elevation", "sqrt_elev", "ln_elev")
rasts

# remove a layer
rasts[["2_x_forest"]] &lt;- NULL
rasts

# number of layers
nlyr(rasts)

# correlation and covariance matrices
madLANDSAT &lt;- fastData("madLANDSAT")
landsat &lt;- fast(madLANDSAT) # projects matrix
layerCor(landsat) # correlation
layerCor(landsat, fun = 'cov') # covariance

}
</code></pre>

<hr>
<h2 id='ngeom+2CGVector-method'>Number of geometries and subgeometries in a vector</h2><span id='topic+ngeom+2CGVector-method'></span><span id='topic+ngeom'></span><span id='topic+nsubgeom+2CGVector-method'></span><span id='topic+nsubgeom'></span>

<h3>Description</h3>

<p><code>GVector</code>s represent two types of &quot;geometries&quot;. In &quot;singlepart&quot; geometries, each point, set of connected line segments, or polygon is treated like its own feature and has its own row in an attribute table. For example, a province might be composed of islands. In this case, each island would be represented as its own feature and could have its own row in the attribute indicating, say, the name and area of each island.
</p>
<p>In &quot;multipart&quot; geometries, features are collected together and thu manipulated as if they were a single feature and have a singe line in an attribute table. Each multipart feature can contain one or more singlepart features. For example, all of the islands comprising  province would be collated together and have a single row in the attribute table indicating the name of the province and the area of the entire province.
</p>
<p><code>ngeom()</code> returns the number of geometries. Singlepart features are treated as one geometry each, and multipart features are treated as one geometry each.
</p>
<p><code>nsubgeom()</code> Returns the number of subgeometries. Singlepart geometries each represent a single subgeometry. Multipart geometries represent one or more subgeometries. The number of subgeometries will thus always be the same as or more than the number of geometries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector'
ngeom(x)

## S4 method for signature 'GVector'
nsubgeom(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ngeom+2B2CGVector-method_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nrow">nrow()</a></code>, <code><a href="#topic+dim">dim()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)

# Example data:
madCoast4 &lt;- fastData("madCoast4")
madRivers &lt;- fastData("madRivers")
madDypsis &lt;- fastData("madDypsis")

# Convert sf vectors to GVectors:
coast &lt;- fast(madCoast4)
rivers &lt;- fast(madRivers)
dypsis &lt;- fast(madDypsis)

# Geographic properties:
ext(rivers) # extent
crs(rivers) # coordinate reference system
st_crs(rivers) # coordinate reference system
coordRef(rivers) # coordinate reference system

# Column names and data types:
names(coast)
datatype(coast)

# Points, lines, or polygons?
geomtype(dypsis)
geomtype(rivers)
geomtype(coast)

is.points(dypsis)
is.points(coast)

is.lines(rivers)
is.lines(dypsis)

is.polygons(coast)
is.polygons(dypsis)

# Number of dimensions:
topology(rivers)
is.2d(rivers) # 2-dimensional?
is.3d(rivers) # 3-dimensional?

# Just the data table:
as.data.frame(rivers)
as.data.table(rivers)

# Top/bottom of the data table:
head(rivers)
tail(rivers)

# Vector or table with just selected columns:
names(rivers)
rivers$NAME
rivers[[c("NAM", "NAME_0")]]
rivers[[c(3, 5)]]

# Select geometries/rows of the vector:
nrow(rivers)
selected &lt;- rivers[2:6]
nrow(selected)

# Plot:
plot(coast)
plot(rivers, col = "blue", add = TRUE)
plot(selected, col = "red", lwd = 2, add = TRUE)

# Vector math:
hull &lt;- convHull(dypsis)

un &lt;- union(coast, hull)
sameAsUnion &lt;- coast + hull
plot(un)
plot(sameAsUnion)

inter &lt;- intersect(coast, hull)
sameAsIntersect &lt;- coast * hull
plot(inter)
plot(sameAsIntersect)

er &lt;- erase(coast, hull)
sameAsErase &lt;- coast - hull
plot(er)
plot(sameAsErase)

xr &lt;- xor(coast, hull)
sameAsXor &lt;- coast / hull
plot(xr)
plot(sameAsXor)

# Vector area and length:
expanse(coast, unit = "km") # polygons areas
expanse(rivers, unit = "km") # river lengths

### Fill holes

# First, we will make some holes by creating buffers around points.
buffs &lt;- buffer(dypsis, 500)

holes &lt;- coast - buffs
plot(holes)

filled &lt;- fillHoles(holes, fail = FALSE)

}
</code></pre>

<hr>
<h2 id='nlevels+2CGRaster-method'>Number of categories in a categorical raster</h2><span id='topic+nlevels+2CGRaster-method'></span><span id='topic+nlevels'></span>

<h3>Description</h3>

<p>This function reports the number of categories (levels) in a categorical <code>GRaster</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
nlevels(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nlevels+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named, numeric vector of integers. The values represent the number of categories (rows) that appear in the raster's levels table.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+levels">levels()</a></code>, <code><a href="terra.html#topic+factors">terra::levels()</a></code>, <code><a href="#topic+droplevels">droplevels()</a></code>, <code>vignette("GRasters", package = "fasterRaster")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data: Land cover raster
madCover &lt;- fastData("madCover")

# Convert categorical SpatRaster to categorical GRaster:
cover &lt;- fast(madCover)

### Properties of categorical rasters

cover # note categories
is.factor(cover) # Is the raster categorical?
nlevels(cover) # number of levels
levels(cover) # just the value and active column
cats(cover) # all columns
minmax(cover) # min/max values
minmax(cover, levels = TRUE) # min/max categories
catNames(cover) # column names of the levels table
missingCats(cover) # categories in table with no values in raster
freq(cover) # frequency of each category (number of cells)
zonalGeog(cover) # geometric statistics

### Active column

# Which column sets the category labels?
activeCat(cover)
activeCat(cover, names = TRUE)

activeCats(c(cover, cover))

# Choose a different column for category labels:
levels(cover)
activeCat(cover) &lt;- 2
levels(cover)

### Managing levels tables

# Remove unused levels:
nlevels(cover)
cover &lt;- droplevels(cover)
nlevels(cover)

# Re-assign levels:
value &lt;- c(20, 30, 40, 50, 120, 130, 140, 170)
label &lt;- c("Cropland", "Cropland", "Forest", "Forest",
 "Grassland", "Shrubland", "Herbaceous", "Flooded")

newCats &lt;- data.frame(value = value, label = label)

cover &lt;- categories(cover, layer = 1, value = newCats)
cats(cover)

# This is the same as:
levels(cover) &lt;- newCats
cats(cover)

# Are there any values not assigned a category?
missingCats(cover)

# Let's assign a category for value 210 (water):
water &lt;- data.frame(value = 210, label = "Water")
addCats(cover) &lt;- water
levels(cover)

# Add more information to the levels table using merge():
landType &lt;- data.frame(
     Value = c(20, 30, 40, 50, 120),
     Type = c("Irrigated", "Rainfed", "Broadleaf evergreen",
     "Broadleaf deciduous", "Mosaic with forest")
)
cats(cover)
cover &lt;- addCats(cover, landType, merge = TRUE)
cats(cover)

### Logical operations on categorical rasters

cover &lt; "Forest" # 1 for cells with a value &lt; 40, 0 otherwise
cover &lt;= "Forest" # 1 for cells with a value &lt; 120, 0 otherwise
cover == "Forest" # 1 for cells with value of 40-120, 0 otherwise
cover != "Forest" # 1 for cells with value that is not 40-120, 0 otherwise
cover &gt; "Forest" # 1 for cells with a value &gt; 120, 0 otherwise
cover &gt;= "Forest" # 1 for cells with a value &gt;= 120, 0 otherwise

cover %in% c("Cropland", "Forest") # 1 for cropland/forest cells, 0 otherwise

### Combine categories from different rasters

# For the example, will create a second categorical raster fromm elevation.

# Divide elevation raster into "low/medium/high" levels:
madElev &lt;- fastData("madElev")
elev &lt;- fast(madElev)
elev &lt;- project(elev, cover, method = "near") # convert to same CRS
fun &lt;- "= if(madElev &lt; 100, 0, if(madElev &lt; 400, 1, 2))"
elevCat &lt;- app(elev, fun)

levs &lt;- data.frame(
     value = c(0, 1, 2),
     elevation = c("low", "medium", "high")
)
levels(elevCat) &lt;- list(levs)

# Combine levels:
combined &lt;- concats(cover, elevCat)
combined
levels(combined)

# Combine levels, treating value/NA combinations as new categories:
combinedNA &lt;- concats(cover, elevCat, na.rm = FALSE)
combinedNA
levels(combinedNA)

}
</code></pre>

<hr>
<h2 id='pairs+2CGRaster-method'>Scatterplot of values in each GRaster layer against the others</h2><span id='topic+pairs+2CGRaster-method'></span><span id='topic+pairs'></span>

<h3>Description</h3>

<p><code>pairs()</code> generates a scatterplot between values of cells in each layer of a <code>GRaster</code> against all the other layers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
pairs(x, n = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairs+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> with two or more layers.</p>
</td></tr>
<tr><td><code id="pairs+2B2CGRaster-method_+3A_n">n</code></td>
<td>
<p>A numeric integer, integer, or <code>NULL</code> (default): Number of cells to sample. If <code>NULL</code>, 50% of the total number of cells will be used.</p>
</td></tr>
<tr><td><code id="pairs+2B2CGRaster-method_+3A_...">...</code></td>
<td>
<p>Arguments to send to <code><a href="graphics.html#topic+pairs">graphics::pairs()</a></code> (which typically sends them to <code><a href="graphics.html#topic+plot.default">graphics::plot()</a></code>). Special arguments for affecting certain panels include:
</p>

<ul>
<li><p> Correlation panels &ndash; <code>cor.cex</code>: Size of the values of the correlation coefficients.
</p>
</li>
<li><p> Histogram panels &ndash; <code>hist.col</code>: Histogram color.
</p>
</li>
<li><p> Dot-plot panels &ndash; <code>colramp</code>: Function taking an integer <code>n</code> as input and returning <code>n</code> names of colors. The default is: <code>colorRampPalette(c("white", blues9))</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing (creates a plot).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")
madForest2000 &lt;- fastData("madForest2000")

# Convert SpatRasters to GRasters
elev &lt;- fast(madElev)
forest &lt;- fast(madForest2000)

### GRaster properties

# plotting
plot(elev)

# dimensions
dim(elev) # rows, columns, depths, layers
nrow(elev) # rows
ncol(elev) # columns
ndepth(elev) # depths
nlyr(elev) # layers

res(elev) # resolution (2D)
res3d(elev) # resolution (3D)
zres(elev) # vertical resolution
xres(elev) # vertical resolution
yres(elev) # vertical resolution
zres(elev) # vertical resolution (NA because this is a 2D GRaster)

# cell counts
ncell(elev) # cells
ncell3d(elev) # cells (3D rasters only)

# number of NA and non-NA cells
nacell(elev)
nonnacell(elev)

# topology
topology(elev) # number of dimensions
is.2d(elev) # is it 2-dimensional?
is.3d(elev) # is it 3-dimensional?

minmax(elev) # min/max values

# "names" of the object
names(elev)

# coordinate reference system
crs(elev)
st_crs(elev)
coordRef(elev)

# extent (bounding box)
ext(elev)

# vertical extent (not defined for this raster)
zext(elev)

# data type
datatype(elev) # fasterRaster type
datatype(elev, "GRASS") # GRASS type
datatype(elev, "terra") # terra type
datatype(elev, "GDAL") # GDAL type

is.integer(elev)
is.float(elev)
is.double(elev)
is.factor(elev)

# convert data type
as.int(elev) # integer; note that "elev" is already of type "integer"
as.float(elev) # floating-precision
as.doub(elev) # double-precision

# assigning
pie &lt;- elev
pie[] &lt;- pi # assign all cells to the value of pi
pie

# concatenating multiple GRasters
rasts &lt;- c(elev, forest)
rasts

# subsetting
rasts[[1]]
rasts[["madForest2000"]]

# replacing
rasts[[2]] &lt;- 2 * forest
rasts

# adding layers
rasts[[3]] &lt;- elev &gt; 500 # add a layer
rasts &lt;- c(rasts, sqrt(elev)) # add another
add(rasts) &lt;- ln(elev)
rasts

# names
names(rasts)
names(rasts) &lt;- c("elev_meters", "2_x_forest", "high_elevation", "sqrt_elev", "ln_elev")
rasts

# remove a layer
rasts[["2_x_forest"]] &lt;- NULL
rasts

# number of layers
nlyr(rasts)

# correlation and covariance matrices
madLANDSAT &lt;- fastData("madLANDSAT")
landsat &lt;- fast(madLANDSAT) # projects matrix
layerCor(landsat) # correlation
layerCor(landsat, fun = 'cov') # covariance

}
</code></pre>

<hr>
<h2 id='pcs'>Retrieve a principal components model from a PCA GRaster</h2><span id='topic+pcs'></span>

<h3>Description</h3>

<p>Retrieve a principal components model from a PCA GRaster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcs(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcs_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> created by <code><a href="#topic+princomp">princomp()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>prcomp</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+princomp">princomp()</a></code>, <code><a href="terra.html#topic+princomp">terra::princomp()</a></code>, module <code>i.pca</code> in <strong>GRASS</strong>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Climate raster:
madChelsa &lt;- fastData("madChelsa")

# Convert a SpatRaster to a GRaster:
chelsa &lt;- fast(madChelsa)

# Generate raster with layers representing principal component predictions:
pcRast &lt;- princomp(chelsa, scale = TRUE)
plot(pcRast)

# Get information on the PCA:
prinComp &lt;- pcs(pcRast)

prinComp
summary(prinComp)
plot(prinComp)

}
</code></pre>

<hr>
<h2 id='plot+2CGRaster+2Cmissing-method'>Display a raster or vector</h2><span id='topic+plot+2CGRaster+2Cmissing-method'></span><span id='topic+plot'></span><span id='topic+plot+2CGVector+2Cmissing-method'></span>

<h3>Description</h3>

<p><code>plot()</code> displays a <code>GRaster</code> or <code>GVector</code>.
</p>
<p>This function is essentially a hack, as it it not possible to dependably call the appropriate <strong>GRASS</strong> modules and display a raster or vector without potential confusion on the user side. Instead, this function 1) simplifies the focal <code>GRaster</code> or <code>GVector</code> to make it smaller when saved to disk; 2) writes the object to disk; 3) (internally) creates a <code>SpatRaster</code> or <code>SpatVector</code> object; then 4) plots the object using <code><a href="terra.html#topic+plot">terra::plot()</a></code>. Thus, if you are interested in making maps, it will always be faster to make them directly with <strong>terra</strong> or <strong>sf</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster,missing'
plot(x, y, simplify = TRUE, ...)

## S4 method for signature 'GVector,missing'
plot(x, y, maxGeoms = 10000, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot+2B2CGRaster+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> or <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2CGRaster+2B2Cmissing-method_+3A_y">y</code></td>
<td>
<p>Missing&ndash;leave as empty.</p>
</td></tr>
<tr><td><code id="plot+2B2CGRaster+2B2Cmissing-method_+3A_simplify">simplify</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default) and the raster has an x- and/or y-resolution that is greater than the screen resolution, then <code><a href="#topic+aggregate">aggregate()</a></code> will be applied to the raster before it is saved to reduce the time it takes to save the raster.</p>
</td></tr>
<tr><td><code id="plot+2B2CGRaster+2B2Cmissing-method_+3A_...">...</code></td>
<td>
<p>Other arguments to send to <code><a href="terra.html#topic+plot">terra::plot()</a></code>.</p>
</td></tr>
<tr><td><code id="plot+2B2CGRaster+2B2Cmissing-method_+3A_maxgeoms">maxGeoms</code></td>
<td>
<p>Positive integer (vectors only): Maximum number of features before vector simplification is applied before saving to disk then creating a <code>SpatVector</code> for plotting. The default is 10000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing (displays a raster or vector).
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+plot">terra::plot()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Example data
madElev &lt;- fastData("madElev") # elevation raster
madLANDSAT &lt;- fastData("madLANDSAT") # multi-layer raster
madRivers &lt;- fastData("madRivers") # lines vector

# Convert SpatRaster to GRaster and SpatVector to GVector
elev &lt;- fast(madElev)
rivers &lt;- fast(madRivers)
landsat &lt;- fast(madLANDSAT)

# Plot:
plot(elev)
plot(rivers, add = TRUE)

# Histograms:
hist(elev)
hist(landsat)

# Plot surface reflectance in RGB:
plotRGB(landsat, 3, 2, 1) # "natural" color
plotRGB(landsat, 4, 1, 2, stretch = "lin") # emphasize near-infrared (vegetation)

# Make composite map from RGB layers and plot in grayscale:
comp &lt;- compositeRGB(r = landsat[[3]], g = landsat[[2]], b = landsat[[1]])
grays &lt;- paste0("gray", 0:100)
plot(comp, col = grays)

}
</code></pre>

<hr>
<h2 id='plotRGB+2CGRaster-method'>Create red-green-blue plot from a raster with RGB layers</h2><span id='topic+plotRGB+2CGRaster-method'></span><span id='topic+plotRGB'></span>

<h3>Description</h3>

<p>This function takes as its main argument a <code>GRaster</code> with at least three layers typically representing red, green, and blue components (plus possibly an &quot;alpha&quot;, or transparency layer). As with <code><a href="#topic+plot">plot()</a></code>, this function is somewhat of a hack in that it downsamples the layers to a coarser resolution using <code><a href="#topic+aggregate">aggregate()</a></code>, saves the raster to disk, then uses <code><a href="terra.html#topic+plotRGB">terra::plotRGB()</a></code> to do the actual plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
plotRGB(x, r = 1, g = 2, b = 3, a = NULL, simplify = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotRGB+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>. Values must be in the range from 0 to 255.</p>
</td></tr>
<tr><td><code id="plotRGB+2B2CGRaster-method_+3A_r">r</code>, <code id="plotRGB+2B2CGRaster-method_+3A_g">g</code>, <code id="plotRGB+2B2CGRaster-method_+3A_b">b</code></td>
<td>
<p>Either a numeric integer or the <code><a href="#topic+names">names()</a></code> of layers representing red, green, and blue components.</p>
</td></tr>
<tr><td><code id="plotRGB+2B2CGRaster-method_+3A_a">a</code></td>
<td>
<p>Either <code>NULL</code> (default), or a numeric integer or the <code><a href="#topic+names">names()</a></code> of a layer representing transparency.</p>
</td></tr>
<tr><td><code id="plotRGB+2B2CGRaster-method_+3A_simplify">simplify</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), then downsample the <code>GRaster</code> before plotting. This can save time for very dense rasters.</p>
</td></tr>
<tr><td><code id="plotRGB+2B2CGRaster-method_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code><a href="terra.html#topic+plotRGB">terra::plotRGB()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing (makes a plot).
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+plotRGB">terra::plotRGB()</a></code>, <code><a href="#topic+plot">plot()</a></code>, <code><a href="#topic+compositeRGB">compositeRGB()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Example data
madElev &lt;- fastData("madElev") # elevation raster
madLANDSAT &lt;- fastData("madLANDSAT") # multi-layer raster
madRivers &lt;- fastData("madRivers") # lines vector

# Convert SpatRaster to GRaster and SpatVector to GVector
elev &lt;- fast(madElev)
rivers &lt;- fast(madRivers)
landsat &lt;- fast(madLANDSAT)

# Plot:
plot(elev)
plot(rivers, add = TRUE)

# Histograms:
hist(elev)
hist(landsat)

# Plot surface reflectance in RGB:
plotRGB(landsat, 3, 2, 1) # "natural" color
plotRGB(landsat, 4, 1, 2, stretch = "lin") # emphasize near-infrared (vegetation)

# Make composite map from RGB layers and plot in grayscale:
comp &lt;- compositeRGB(r = landsat[[3]], g = landsat[[2]], b = landsat[[1]])
grays &lt;- paste0("gray", 0:100)
plot(comp, col = grays)

}
</code></pre>

<hr>
<h2 id='predict+2CGRaster-method'>Make predictions from a linear or generalized linear model to a GRaster</h2><span id='topic+predict+2CGRaster-method'></span><span id='topic+predict'></span>

<h3>Description</h3>

<p>This version of the <code>predict()</code> function make predictions to a set of <code>GRaster</code>s from a model object.
</p>
<p>The model must be either a linear model, which is of class <code>lm</code> and typically created using the <code><a href="stats.html#topic+lm">stats::lm()</a></code> function or a generalized linear model (GLM), which is class <code>glm</code> and typically created using <code><a href="stats.html#topic+glm">stats::glm()</a></code>. Other packages can also create <code>lm</code> or <code>glm</code> objects, but they may not work in this function. For example, generalized additive models, which can be created using the <code>gam()</code> function in the <strong>mgcv</strong> package, inherit the <code>glm</code> class, but cannot be used in this function. However, <code>glm</code> objects created with the <strong>speedglm</strong> package should work with this function.
</p>
<p>This <code>predict()</code> function can handle:
</p>

<ul>
<li><p> Linear predictors and intercepts like <code>1 + x</code>;
</p>
</li>
<li><p> Quadratic terms like <code>x^2</code> (or, in <strong>R</strong> formula notation, <code>I(x^2)</code>);
</p>
</li>
<li><p> Two-way interaction terms between scalars like <code>x1:x2</code> and <code>x1 * x2</code>;
</p>
</li>
<li><p> Categorical predictors (i.e., categorical <code>GRaster</code>s; see <code>vignette("GRasters", package = "fasterRaster")</code>);
</p>
</li>
<li><p> Two-way interactions between a categorical predictor and a scalar predictor; and
</p>
</li>
<li><p> Two-way interactions between categorical predictors.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
predict(object, model, type = "response")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict+2B2CGRaster-method_+3A_object">object</code></td>
<td>
<p>A <code>GRaster</code> with one or more layers.</p>
</td></tr>
<tr><td><code id="predict+2B2CGRaster-method_+3A_model">model</code></td>
<td>
<p>An <code>lm</code> or <code>glm</code> model object.</p>
</td></tr>
<tr><td><code id="predict+2B2CGRaster-method_+3A_type">type</code></td>
<td>
<p>Character: Type of prediction to make. This can be either <code>link</code> (default; predictions are made on the scale of the link function) or <code>response</code> (predictions are made on the scale of the response variable). This function can only make predictions on the scale of the response for the identity, logit, log, or cloglog (complementary log-log) link functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+predict">terra::predict()</a></code>; <code><a href="stats.html#topic+predict">stats::predict()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

### This example creates a simple model of Dypsis distribution using
# elevation, distance to forest, land cover class, and nearness to rivers.

# Elevation raster, forest cover in year 2000, land cover class, and
# points where Dypsis plants have been collected
madElev &lt;- fastData("madElev")
madForest2000 &lt;- fastData("madForest2000")
madCover &lt;- fastData("madCover")
madRivers &lt;- fastData("madRivers")
madDypsis &lt;- fastData("madDypsis")

# Convert SpatRasters to GRasters and sf vectors to GVectors:
elev &lt;- fast(madElev)
forest &lt;- fast(madForest2000)
cover &lt;- fast(madCover)
rivers &lt;- fast(madRivers)
dypsis &lt;- fast(madDypsis)

# Distance to forest
distToForest &lt;- distance(forest, unit = "m")
distToForest &lt;- log1p(distToForest) # log(x + 1) of distance
names(distToForest) &lt;- "distToForest"

# "Stack" elevation and forest cover
continuous &lt;- c(elev, distToForest)

# Scale continuous predictors to mean of 0 and sd of 1
continuousScaled &lt;- scale(continuous)
names(continuousScaled) &lt;- c("elevation", "distToForest")

# Project land cover raster
coverProj &lt;- project(cover, continuousScaled)

# Near a river?
riverBuffer &lt;- buffer(rivers, 5000)
nearRiver &lt;- rasterize(riverBuffer, elev, background = 0)
names(nearRiver) &lt;- "nearRiver"
levels(nearRiver) &lt;- data.frame(value = 0:1, label = c("far", "near"))

# Combine continuous/categorical data
covariateRasters &lt;- c(continuousScaled, coverProj, nearRiver)
plot(covariateRasters)

# Extract environmental values at Dypsis locations:
presEnv &lt;- extract(covariateRasters, dypsis, cats = TRUE)
presEnv$presBg &lt;- 1
head(presEnv)

# Extract elevation and forest cover at 2000 background sites:
bgEnv &lt;- spatSample(covariateRasters, size = 3000, values = TRUE, cats = TRUE)
bgEnv &lt;- bgEnv[stats::complete.cases(bgEnv), ]
bgEnv &lt;- bgEnv[1:2000, ]
bgEnv$presBg &lt;- 0
head(bgEnv)

# Combine presence and background data:
env &lt;- rbind(presEnv, bgEnv)

# Calibrate model:
form &lt;- presBg ~ elevation + distToForest +
  I(distToForest^2) + elevation * distToForest +
  madCover + nearRiver

model &lt;- stats::glm(form, data = env, family = stats::binomial)
summary(model)

# Make predictions and map:
prediction &lt;- predict(covariateRasters, model, type = "response")
prediction

# Not a great model!
plot(prediction, main = "Predicted")
plot(dypsis, pch = 1, add = TRUE)

}
</code></pre>

<hr>
<h2 id='princomp+2CGRaster-method'>Apply a principal component analysis (PCA) to layers of a GRaster</h2><span id='topic+princomp+2CGRaster-method'></span><span id='topic+princomp'></span>

<h3>Description</h3>

<p>This function applies a principal component analysis to layers of a <code>GRaster</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
princomp(x, scale = TRUE, scores = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="princomp+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> with two or more layers.</p>
</td></tr>
<tr><td><code id="princomp+2B2CGRaster-method_+3A_scale">scale</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), input layers will be rescaled by dividing each layer by its overall population standard deviation. Rasters will always be centered (have their mean subtracted from values). Centering and scaling is recommended when rasters values are in different units.</p>
</td></tr>
<tr><td><code id="princomp+2B2CGRaster-method_+3A_scores">scores</code></td>
<td>
<p>Logical: If <code>TRUE</code>, the <code>prcomp</code> object will have the scores attached to it. This can greatly increase the size of the object in memory if the input raster has many cells. It will also take more time. If <code>FALSE</code> (default), then skip returning scores.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A multi-layer <code>GRaster</code> with one layer per principal component axis. The <code><a href="#topic+pcs">pcs()</a></code> function can be used on the output raster to retrieve a <code>prcomp</code> object from the raster, which includes rotations (loadings) and proportions of variance explained.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+princomp">terra::princomp()</a></code>, <code><a href="terra.html#topic+prcomp">terra::prcomp()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Climate raster:
madChelsa &lt;- fastData("madChelsa")

# Convert a SpatRaster to a GRaster:
chelsa &lt;- fast(madChelsa)

# Generate raster with layers representing principal component predictions:
pcRast &lt;- princomp(chelsa, scale = TRUE)
plot(pcRast)

# Get information on the PCA:
prinComp &lt;- pcs(pcRast)

prinComp
summary(prinComp)
plot(prinComp)

}
</code></pre>

<hr>
<h2 id='print.rastInfo'>Display a fasterRaster object</h2><span id='topic+print.rastInfo'></span><span id='topic+print'></span><span id='topic+show.rastInfo'></span><span id='topic+print.vectInfo'></span><span id='topic+show.vectInfo'></span><span id='topic+show'></span><span id='topic+show+2CGLocation-method'></span><span id='topic+print.GLocation'></span><span id='topic+summary+2CGLocation-method'></span><span id='topic+summary'></span><span id='topic+show+2CGSpatial-method'></span><span id='topic+print.GSpatial'></span><span id='topic+summary+2CGSpatial-method'></span><span id='topic+show+2CGRegion-method'></span><span id='topic+print.GRegion'></span><span id='topic+summary+2CGRegion-method'></span><span id='topic+show+2CGRaster-method'></span><span id='topic+print.GRaster'></span><span id='topic+summary+2CGRaster-method'></span><span id='topic+show+2CGVector-method'></span><span id='topic+print.GVector'></span><span id='topic+summary+2CGVector-method'></span>

<h3>Description</h3>

<p>Display a <code>GLocation</code>, <code>GSpatial</code>, <code>GRegion</code>, <code>GRaster</code>, or <code>GVector</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rastInfo'
print(x, ...)

show.rastInfo(x)

## S3 method for class 'vectInfo'
print(x, ...)

## S3 method for class 'vectInfo'
show(x)

## S4 method for signature 'GLocation'
show(object)

## S3 method for class 'GLocation'
print(x, ...)

## S4 method for signature 'GLocation'
summary(object)

## S4 method for signature 'GSpatial'
show(object)

## S3 method for class 'GSpatial'
print(x, ...)

## S4 method for signature 'GSpatial'
summary(object)

## S4 method for signature 'GRegion'
show(object)

## S3 method for class 'GRegion'
print(x, ...)

## S4 method for signature 'GRegion'
summary(object)

## S4 method for signature 'GRaster'
show(object)

## S3 method for class 'GRaster'
print(x, ...)

## S4 method for signature 'GRaster'
summary(object)

## S4 method for signature 'GVector'
show(object)

## S3 method for class 'GVector'
print(x, ...)

## S4 method for signature 'GVector'
summary(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.rastInfo_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
<tr><td><code id="print.rastInfo_+3A_object">object</code>, <code id="print.rastInfo_+3A_x">x</code></td>
<td>
<p>An object of class <code>GLocation</code>, <code>GSpatial</code>, <code>GRegion</code>, <code>GRaster</code>, or <code>GVector</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing (side effect is to display metadata on the given object).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Example data
madElev &lt;- fastData("madElev")
madForest2000 &lt;- fastData("madForest2000")
madCoast0 &lt;- fastData("madCoast0")
madRivers &lt;- fastData("madRivers")
madDypsis &lt;- fastData("madDypsis")

### GRaster properties

# convert SpatRasters to GRasters
elev &lt;- fast(madElev)
forest &lt;- fast(madForest2000)

# plot
plot(elev)

dim(elev) # rows, columns, depths, layers
nrow(elev) # rows
ncol(elev) # columns
ndepth(elev) # depths
nlyr(elev) # layers

res(elev) # resolution

ncell(elev) # cells
ncell3d(elev) # cells (3D rasters only)

topology(elev) # number of dimensions
is.2d(elev) # is it 2D?
is.3d(elev) # is it 3D?

minmax(elev) # min/max values

# name of object in GRASS
sources(elev)

# "names" of the object
names(elev)

# coordinate reference system
crs(elev)

# extent (bounding box)
ext(elev)

# data type
datatype(elev)

# assigning
copy &lt;- elev
copy[] &lt;- pi # assign all cells to the value of pi
copy

# concatenating multiple GRasters
rasts &lt;- c(elev, forest)
rasts

# adding a raster "in place"
add(rasts) &lt;- ln(elev)
rasts

# subsetting
rasts[[1]]
rasts[["madForest2000"]]

# assigning
rasts[[4]] &lt;- elev &gt; 500

# number of layers
nlyr(rasts)

# names
names(rasts)
names(rasts) &lt;- c("elev_meters", "forest", "ln_elev", "high_elevation")
rasts

### GVector properties

# convert sf vectors to GVectors
coast &lt;- fast(madCoast4)
rivers &lt;- fast(madRivers)
dypsis &lt;- fast(madDypsis)

# extent
ext(rivers)

W(rivers) # western extent
E(rivers) # eastern extent
S(rivers) # southern extent
N(rivers) # northern extent
top(rivers) # top extent (NA for 2D rasters like this one)
bottom(rivers) # bottom extent (NA for 2D rasters like this one)

# coordinate reference system
crs(rivers)
st_crs(rivers)

# column names and data types
names(coast)
datatype(coast)

# name of object in GRASS
sources(rivers)

# points, lines, or polygons?
geomtype(dypsis)
geomtype(rivers)
geomtype(coast)

is.points(dypsis)
is.points(coast)

is.lines(rivers)
is.lines(dypsis)

is.polygons(coast)
is.polygons(dypsis)

# dimensions
nrow(rivers) # how many spatial features
ncol(rivers) # hay many columns in the data frame

# number of geometries and sub-geometries
ngeom(coast)
nsubgeom(coast)

# 2- or 3D
topology(rivers) # dimensionality
is.2d(elev) # is it 2D?
is.3d(elev) # is it 3D?

# Update values from GRASS
# (Reads values from GRASS... will not appear to do anything in this case)
coast &lt;- update(coast)

### operations on GVectors

# convert to data frame
as.data.frame(rivers)
as.data.table(rivers)

# subsetting
rivers[c(1:2, 5)] # select 3 rows/geometries
rivers[-5:-11] # remove rows/geometries 5 through 11
rivers[ , 1] # column 1
rivers[ , "NAM"] # select column
rivers[["NAM"]] # select column
rivers[1, 2:3] # row/geometry 1 and column 2 and 3
rivers[c(TRUE, FALSE)] # select every other geometry (T/F vector is recycled)
rivers[ , c(TRUE, FALSE)] # select every other column (T/F vector is recycled)

# removing data table
noTable &lt;- dropTable(rivers)
noTable
nrow(rivers)
nrow(noTable)

# Refresh values from GRASS
# (Reads values from GRASS... will not appear to do anything in this case
# since the rivers object is up-to-date):
rivers &lt;- update(rivers)

# Concatenating multiple vectors
rivers2 &lt;- rbind(rivers, rivers)
dim(rivers)
dim(rivers2)

}
</code></pre>

<hr>
<h2 id='project+2CGRaster-method'>Change the coordinate reference system of a GRaster or GVector</h2><span id='topic+project+2CGRaster-method'></span><span id='topic+project'></span><span id='topic+project+2CGVector-method'></span>

<h3>Description</h3>

<p><code>project()</code> changes the coordinate reference system (CRS) of a <code>GRaster</code> or <code>GVector</code>. It has three use cases:
</p>

<ul>
<li> <p><code>x</code> is a <code>GRaster</code> and <code>y</code> is a <code>GRaster</code>: <code>x</code> will be projected to the CRS of <code>y</code> and resampled to have the same resolution as <code>y</code>. If argument <code>align</code> is <code>FALSE</code>, then it will also be cropped to the extent of <code>y</code>.
</p>
</li>
<li> <p><code>x</code> is a <code>GRaster</code> and <code>y</code> is a <code>GVector</code> or a CRS string (typically in Well-Known Text format): <code>x</code> will be projected to the CRS specified by <code>y</code> and resampled but not cropped.
</p>
</li>
<li> <p><code>x</code> is a <code>GVector</code> and <code>y</code> is a <code>GRaster</code>, <code>GVector</code>, or CRS string: The vector will be projected to the CRS of <code>y</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
project(
  x,
  y,
  align = FALSE,
  method = NULL,
  fallback = TRUE,
  res = "fallback",
  wrap = FALSE,
  verbose = FALSE
)

## S4 method for signature 'GVector'
project(x, y, wrap = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="project+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> or <code>GVector</code> to be projected.</p>
</td></tr>
<tr><td><code id="project+2B2CGRaster-method_+3A_y">y</code></td>
<td>
<p>A character or <code>GLocation</code> object (i.e., typically a <code>GRaster</code> or <code>GVector</code>): Used to set the focal <code>GRaster</code> or <code>GVector</code>'s new CRS (and resolution and possibly extent, for <code>GRaster</code>s).</p>
</td></tr>
<tr><td><code id="project+2B2CGRaster-method_+3A_align">align</code></td>
<td>
<p>Logical: If <code>FALSE</code> (default), and <code>x</code> and <code>y</code> are <code>GRaster</code>s, then the extent of <code>x</code> will be cropped to the extent of <code>y</code>. If <code>TRUE</code>, no cropping is performed.</p>
</td></tr>
<tr><td><code id="project+2B2CGRaster-method_+3A_method">method</code></td>
<td>
<p>Character or <code>NULL</code> (for <code>GRaster</code>s only): Method to use to conduct the transformation (rasters only). Partial matching is used.
</p>

<ul>
<li> <p><code>NULL</code> (default): Automatically choose based on raster properties (<code>near</code> for categorical data, <code>bilinear</code> for continuous data).
</p>
</li>
<li> <p><code>"near"</code>: Nearest neighbor. Best for categorical data, and often a poor choice for continuous data.  If <code><a href="#topic+datatype">datatype()</a></code> is <code>integer</code>, this method will be used by default.
</p>
</li>
<li> <p><code>"bilinear"</code>: Bilinear interpolation (default for non-categorical data; uses weighted values from 4 cells).
</p>
</li>
<li> <p><code>"bicubic"</code>: Bicubic interpolation (uses weighted values from 16 cells).
</p>
</li>
<li> <p><code>"lanczos"</code>: Lanczos interpolation (uses weighted values from 25 cells).
</p>
</li></ul>

<p><em>Note #1</em>: If <code>x</code> and <code>y</code> are <code>GRaster</code>s, and <code>res = "terra"</code>, then the same <code>method</code> is used to resample <code>x</code> to the resolution of <code>y</code> before projecting <code>x</code>.
</p>
<p><em>Note #2</em>: Methods that use multiple cells will cause the focal cell to become <code>NA</code> if there is at least one cell with an <code>NA</code> in the cells it draws from. These <code>NA</code> cells can often be filled using the <code>fallback</code> argument.</p>
</td></tr>
<tr><td><code id="project+2B2CGRaster-method_+3A_fallback">fallback</code></td>
<td>
<p>Logical (for projecting <code>GRaster</code>s only): If <code>TRUE</code> (default), then use &quot;lower&quot; resampling methods to fill in <code>NA</code> cells when a &quot;higher&quot; resampling method is used. For example, if <code>method = "bicubic"</code>, <code>NA</code> cells will be filled in using the <code>bilinear</code> method, except when that results in <code>NA</code>s, in which case the <code>near</code> method will be used. Fallback causes fewer cells to revert to <code>NA</code> values, so may be better at capturing complex &quot;edges&quot; (e.g., coastlines). Fallback does increase processing time because each &quot;lower&quot; method must be applied, then results merged. Fallback is not used if <code>method = "near"</code>.</p>
</td></tr>
<tr><td><code id="project+2B2CGRaster-method_+3A_res">res</code></td>
<td>
<p>Character (for projecting <code>GRaster</code>s only): Method used to set the resolution of a <code>GRaster</code> in the new CRS. This can be one of three options.  Partial matching is used and case ignored:
</p>

<ul>
<li> <p><code>"terra"</code>: This method creates an output raster that is as close as possible in values and resolution to the one that <code><a href="terra.html#topic+project">terra::project()</a></code> would create. However, for large rasters (i.e., many cells), this can fail because <code>terra::project()</code> encounters memory limits (it is used internally to create a template). This method resamples the focal raster in its starting CRS, then projects it to the destination CRS.
</p>
</li>
<li> <p><code>"template"</code>: This method can only be used if <code>y</code> is a <code>GRaster</code>. The output will have the same resolution as <code>y</code> and possibly the same extent (depending on the value of <code>align</code>). However, unlike the <code>"terra"</code> method, cell values will not necessarily be as close as possible to what <code><a href="terra.html#topic+project">terra::project()</a></code> would generate (unless <code>method = "near"</code>). Unlike the <code>"terra"</code> method, this method does not resample the focal raster in its starting CRS before projecting. For large rasters it will be faster than the <code>"terra"</code> method (especially if <code style="white-space: pre;">&#8288;"method = "near"&#8288;</code>), and it should be less likely to fail because of memory limits.
</p>
</li>
<li><p> Two numeric values: Values for the new resolution (x- and y-dimensions).
</p>
</li>
<li> <p><code>"center"</code>: This method locates the centroid of the raster to be projected (in the same CRS as the original raster). It then creates four points north, south, east, and west of the centroid, each spaced one cell's width from the centroid. This set of points is then projected to the new CRS. The new cell size in the x-dimension will be the average of the distance between the east and west points from the centroid, and in the y-dimension the average from the centroid to the north and south points.
</p>
</li>
<li> <p><code>"fallback"</code> (default): This applies the <code>terra</code> method first, but if that fails, then tries <code>template</code>, then <code>center</code>. This process can take a long time for large rasters.
</p>
</li></ul>
</td></tr>
<tr><td><code id="project+2B2CGRaster-method_+3A_wrap">wrap</code></td>
<td>
<p>Logical:
</p>

<ul>
<li> <p><code>GRaster</code>s: When projecting rasters that &quot;wrap around&quot; (i.e., whole-world rasters or rasters that have edges that actually circle around to meet on the globe), <code>wrap</code> should be <code>TRUE</code> to avoid removing rows and columns from the &quot;edge&quot; of the map. The default is <code>FALSE</code>.
</p>
</li>
<li> <p><code>GVector</code>s: When projecting vectors that span the international date line at 180E/W, <code>wrap</code> should be <code>TRUE</code> to avoid an issue where the coordinates are incorrectly mapped to the range -180 to 180.
</p>
</li></ul>
</td></tr>
<tr><td><code id="project+2B2CGRaster-method_+3A_verbose">verbose</code></td>
<td>
<p>Logical (for projecting <code>GRaster</code>s only): If <code>TRUE</code>, display progress. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When projecting a raster, the &quot;fallback&quot; methods in <strong>GRASS</strong> module <code>r.import</code> are actually used, even though the <code>method</code> argument takes the strings specifying non-fallback methods. See the manual page for the <code>r.import</code> <strong>GRASS</strong> module.
</p>


<h3>Value</h3>

<p>A <code>GRaster</code> or <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+project">terra::project()</a></code>, <code><a href="sf.html#topic+st_transform">sf::st_transform()</a></code>, <strong>GRASS</strong> manual pages for modules <code>r.proj</code> and <code>v.proj</code> (see <code>grassHelp("r.proj")</code> and <code>grassHelp("v.proj")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

### Setup for all examples

library(sf)
library(terra)

# Climate raster, elevation raster, rivers vector
madElev &lt;- fastData("madElev")
madRivers &lt;- fastData("madRivers")
madChelsa &lt;- fastData("madChelsa")

# Convert objects into fasterRaster formats
chelsa &lt;- fast(madChelsa)
elev &lt;- fast(madElev)
rivers &lt;- fast(madRivers)

### Project raster without resampling
elevWGS84 &lt;- project(elev, crs(chelsa))
elevWGS84

### Project raster and resample to resolution of another raster
elevWGS84Resamp &lt;- project(elev, chelsa)
elevWGS84Resamp

res(elevWGS84)
res(elevWGS84Resamp)
res(chelsa)

### Project vector
riversWGS84 &lt;- project(rivers, chelsa)
riversWGS84
cat(crs(rivers)) # using "cat()" to make it look nice
cat(crs(riversWGS84))

}
</code></pre>

<hr>
<h2 id='rast+2CGRaster-method'>Convert a GRaster to a SpatRaster</h2><span id='topic+rast+2CGRaster-method'></span><span id='topic+rast'></span>

<h3>Description</h3>

<p>The <strong>fasterRaster</strong> version of the <code>rast()</code> function converts a <code>GRaster</code> to a <code>SpatRaster</code> (from the <strong>terra</strong> package).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
rast(x, mm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rast+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="rast+2B2CGRaster-method_+3A_mm">mm</code></td>
<td>
<p>Logical: If <code>TRUE</code>, call <code><a href="terra.html#topic+minmax">terra::setMinMax()</a></code> on the raster to ensure it has metadata on the minimum and maximum values. For large rasters, this can take a long time, so the default value of <code>mm</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rast+2B2CGRaster-method_+3A_...">...</code></td>
<td>
<p>Additional arguments to send to <code><a href="#topic+writeRaster">writeRaster()</a></code>. These are typically unneeded, though <code>bigTiff</code> may be of use if the raster is large, and supplying <code>datatype</code> can speed conversion of large rasters. See <code><a href="#topic+writeRaster">writeRaster()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>SpatRaster</code> (<strong>terra</strong> package).
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+rast">terra::rast()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")
madForest2000 &lt;- fastData("madForest2000")

# Convert SpatRasters to GRasters
elev &lt;- fast(madElev)
forest &lt;- fast(madForest2000)

### GRaster properties

# plotting
plot(elev)

# dimensions
dim(elev) # rows, columns, depths, layers
nrow(elev) # rows
ncol(elev) # columns
ndepth(elev) # depths
nlyr(elev) # layers

res(elev) # resolution (2D)
res3d(elev) # resolution (3D)
zres(elev) # vertical resolution
xres(elev) # vertical resolution
yres(elev) # vertical resolution
zres(elev) # vertical resolution (NA because this is a 2D GRaster)

# cell counts
ncell(elev) # cells
ncell3d(elev) # cells (3D rasters only)

# number of NA and non-NA cells
nacell(elev)
nonnacell(elev)

# topology
topology(elev) # number of dimensions
is.2d(elev) # is it 2-dimensional?
is.3d(elev) # is it 3-dimensional?

minmax(elev) # min/max values

# "names" of the object
names(elev)

# coordinate reference system
crs(elev)
st_crs(elev)
coordRef(elev)

# extent (bounding box)
ext(elev)

# vertical extent (not defined for this raster)
zext(elev)

# data type
datatype(elev) # fasterRaster type
datatype(elev, "GRASS") # GRASS type
datatype(elev, "terra") # terra type
datatype(elev, "GDAL") # GDAL type

is.integer(elev)
is.float(elev)
is.double(elev)
is.factor(elev)

# convert data type
as.int(elev) # integer; note that "elev" is already of type "integer"
as.float(elev) # floating-precision
as.doub(elev) # double-precision

# assigning
pie &lt;- elev
pie[] &lt;- pi # assign all cells to the value of pi
pie

# concatenating multiple GRasters
rasts &lt;- c(elev, forest)
rasts

# subsetting
rasts[[1]]
rasts[["madForest2000"]]

# replacing
rasts[[2]] &lt;- 2 * forest
rasts

# adding layers
rasts[[3]] &lt;- elev &gt; 500 # add a layer
rasts &lt;- c(rasts, sqrt(elev)) # add another
add(rasts) &lt;- ln(elev)
rasts

# names
names(rasts)
names(rasts) &lt;- c("elev_meters", "2_x_forest", "high_elevation", "sqrt_elev", "ln_elev")
rasts

# remove a layer
rasts[["2_x_forest"]] &lt;- NULL
rasts

# number of layers
nlyr(rasts)

# correlation and covariance matrices
madLANDSAT &lt;- fastData("madLANDSAT")
landsat &lt;- fast(madLANDSAT) # projects matrix
layerCor(landsat) # correlation
layerCor(landsat, fun = 'cov') # covariance

}
</code></pre>

<hr>
<h2 id='rasterize+2CGVector+2CGRaster-method'>Convert a GVector to a GRaster</h2><span id='topic+rasterize+2CGVector+2CGRaster-method'></span><span id='topic+rasterize'></span>

<h3>Description</h3>

<p>The <code>rasterize()</code> function converts a <code>GVector</code> into a <code>GRaster</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector,GRaster'
rasterize(x, y, field = "", background = NA, by = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rasterize+2B2CGVector+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="rasterize+2B2CGVector+2B2CGRaster-method_+3A_y">y</code></td>
<td>
<p>A <code>GRaster</code>: The new raster will have the same extent and resolution as this raster.</p>
</td></tr>
<tr><td><code id="rasterize+2B2CGVector+2B2CGRaster-method_+3A_field">field</code></td>
<td>
<p>Character: Name of a column in the data table of <code>y</code> to &quot;burn&quot; into the raster. If not <code>""</code> (default), then the output will be a categorical <code>GRraster</code>. If <code>field</code> is <code>""</code>, then all geometries will be &quot;burned&quot; to the raster and have the same value.</p>
</td></tr>
<tr><td><code id="rasterize+2B2CGVector+2B2CGRaster-method_+3A_background">background</code></td>
<td>
<p>Numeric or <code>NA</code> (default): Value to put in cells that are not covered by the <code>GVector</code>. Note that if this is not <code>NA</code> and not an integer, then the output cannot be a categorical raster (i.e., there will be no &quot;levels&quot; table associated with it).</p>
</td></tr>
<tr><td><code id="rasterize+2B2CGVector+2B2CGRaster-method_+3A_by">by</code></td>
<td>
<p>Either <code>NULL</code> (default) or character: If this is not <code>NULL</code>, then the <code>GVector</code> will be subset by the values in the field named by <code>by</code>. The output will be a multi-layer raster, with one layer per unique value in <code>by</code>.</p>
</td></tr>
<tr><td><code id="rasterize+2B2CGVector+2B2CGRaster-method_+3A_verbose">verbose</code></td>
<td>
<p>Logical: If <code>by</code> is not <code>NULL</code>, display progress.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+rasterize">terra::rasterize()</a></code>, <strong>GRASS</strong> module <code>v.to.rast</code> (see <code>grassHelp("v.to.rast")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Elevation raster, outline of a part of Madagascar, and rivers vector:
madElev &lt;- fastData("madElev") # raster
madDypsis &lt;- fastData("madDypsis") # points vector
madRivers &lt;- fastData("madRivers") # lines vector
madCoast4 &lt;- fastData("madCoast4") # polygons vector

# Convert to GRaster and GVectors:
elev &lt;- fast(madElev)
dypsis &lt;- fast(madDypsis)
coast4 &lt;- fast(madCoast4)
rivers &lt;- fast(madRivers)

# Convert points, line, and polygons vectors to rasters:
points &lt;- rasterize(dypsis, elev)
plot(points)

lines &lt;- rasterize(rivers, elev)
plot(lines)

polys &lt;- rasterize(coast4, elev)
plot(polys)

communes &lt;- rasterize(coast4, elev, field = "NAME_4")
plot(communes)

# Change background value:
polysNeg1 &lt;- rasterize(coast4, elev, background = -1)
plot(polysNeg1)

# Make one layer per river:
byRiver &lt;- rasterize(rivers, elev, field = "NAM", by = "NAM")
plot(byRiver)

}
</code></pre>

<hr>
<h2 id='rbind+2CGVector-method'>Combine one or more GVectors</h2><span id='topic+rbind+2CGVector-method'></span><span id='topic+rbind'></span>

<h3>Description</h3>

<p><code>rbind()</code> combines two or more <code>GVector</code>s of the same type (points, lines, or polygons) and same coordinate reference system. You can speed operations by putting the vector that is largest in memory first in <code>rbind(...)</code>. If the <code>GVector</code>s have data tables, these will also be combined using <code>rbind()</code> if their column names and data types match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector'
rbind(..., deparse.level = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rbind+2B2CGVector-method_+3A_...">...</code></td>
<td>
<p>One or more <code>GVector</code>s.</p>
</td></tr>
<tr><td><code id="rbind+2B2CGVector-method_+3A_deparse.level">deparse.level</code></td>
<td>
<p>See <code><a href="#topic+rbind">rbind()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+colbind">colbind()</a></code>, <code><a href="#topic+addTable+3C-">addTable&lt;-</a></code>, <code><a href="#topic+dropTable">dropTable()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)

# Rivers vector
madRivers &lt;- fastData("madRivers")

# Convert sf to a GVector
rivers &lt;- fast(madRivers)

# Convert GVector to data.frame or data.table
as.data.frame(rivers)
as.data.table(rivers)

# Subset rivers vector
rivers1 &lt;- rivers[1:2]
rivers2 &lt;- rivers[10:11]

# Concatenate rivers
riversCombo &lt;- rbind(rivers1, rivers2)
riversCombo

# Add columns
newCol &lt;- data.frame(new = 1:11)
riversCol &lt;- colbind(rivers, newCol)
riversCol

# Remove table
riversCopy &lt;- rivers
riversCopy # has data table
riversCopy &lt;- dropTable(riversCopy)
riversCopy # no data table

# Add a new table
newTable &lt;- data.frame(num = 1:11, letters = letters[1:11])
addTable(riversCopy) &lt;- newTable
riversCopy

}
</code></pre>

<hr>
<h2 id='regress+2CGRaster+2Cmissing-method'>Regression intercept, slope, r2, and t-value across each set of cells</h2><span id='topic+regress+2CGRaster+2Cmissing-method'></span><span id='topic+regress'></span>

<h3>Description</h3>

<p>This function performs a regression on each set of cells in a multi-layered <code>GRaster</code>. The output is a <code>GRaster</code> with the intercept, slope, r^2 value, and Student's t value. The regression formula is as <code>y ~ 1 + x</code>, where <code>x</code> is the layer number of each layer (e.g., 1 for the first or top layer in the input <code>GRaster</code>, 2 for the second or second-to-top layer, etc.). Note that this is restricted version of the functionality in <code><a href="terra.html#topic+regress">terra::regress()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster,missing'
regress(y, x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regress+2B2CGRaster+2B2Cmissing-method_+3A_y">y</code></td>
<td>
<p>A multi-layer <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="regress+2B2CGRaster+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="regress+2B2CGRaster+2B2Cmissing-method_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical: If <code>FALSE</code>, any series of cells with <code>NA</code> in at least one cell results in an <code>NA</code> in the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A multi-layer <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+regress">terra::regress()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Example data
madChelsa &lt;- fastData("madChelsa")

# Convert a SpatRaster to a GRaster
chelsa &lt;- fast(madChelsa)
chelsa # 4 layers

# Central tendency
mean(chelsa)
mmode(chelsa)
median(chelsa)

# Statistics
nunique(chelsa)
sum(chelsa)
count(chelsa)
min(chelsa)
max(chelsa)
range(chelsa)
skewness(chelsa)
kurtosis(chelsa)

stdev(chelsa)
stdev(chelsa, pop = FALSE)
var(chelsa)
varpop(chelsa)

# Which layers have maximum/minimum?
which.min(chelsa)
which.max(chelsa)

# Regression

# Note the intercept is different for fasterRaster::regress().
regress(chelsa)
regress(madChelsa, 1:nlyr(madChelsa))

# Note: To get quantiles for each layer, use global().
quantile(chelsa, 0.1)

# NAs
madForest2000 &lt;- fastData("madForest2000")
forest2000 &lt;- fast(madForest2000)
forest2000 &lt;- project(forest2000, chelsa, method = "near")

chelsaForest &lt;- c(chelsa, forest2000)

nas &lt;- anyNA(chelsaForest)
plot(nas)

allNas &lt;- allNA(chelsaForest)
plot(allNas)

}
</code></pre>

<hr>
<h2 id='reorient+2CGRaster-method'>Convert degrees between 'north-orientation' and 'east orientation'</h2><span id='topic+reorient+2CGRaster-method'></span><span id='topic+reorient'></span><span id='topic+reorient+2Cnumeric-method'></span>

<h3>Description</h3>

<p>This function converts facing between &quot;north orientation&quot; and &quot;east orientation&quot;.
</p>
<p>In &quot;north orientation&quot; systems, a 0-degree facing is north, and the angle of facing proceeds clockwise. For example, a 90 degree facing faces east, 180 south, and 270 west. In &quot;east orientation&quot;, a 0-degree facing is east, and the facing angle proceeds counter-clockwise. For example, 90 is north, 180 is west, and 270 south.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
reorient(x, units = "degrees")

## S4 method for signature 'numeric'
reorient(x, units = "degrees")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reorient+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A numeric vector or a <code>GRaster</code> with cell values equal to facing (in degrees).</p>
</td></tr>
<tr><td><code id="reorient+2B2CGRaster-method_+3A_units">units</code></td>
<td>
<p>Character: &quot;Units&quot; of values in <code>x</code>: either <code>"degrees"</code> for degrees (default) or <code>"radians"</code>. Partial matching is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code> or numeric vector. Values will be in the range between 0 and 360 and represents facing in the system &quot;opposing&quot; the input's system. For example, if the input is north orientation, the output will be east orientation. If the input is in east orientation, the output will be in north orientation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Re-orient numeric values:
facings &lt;- c(0, 90, 180, 270, 360)
reorient(facings)

# Re-reorienting returns the same values:
reorient(reorient(facings))

if (grassStarted()) {

### Re-orient a GRaster:

# Setup
library(terra)
madElev &lt;- fastData("madElev")
elev &lt;- fast(madElev)

# Calculate aspect in degrees, using north orientation:
aspectNorth &lt;- terrain(elev, "aspect")

# Re-orient to east-facing:
aspectEast &lt;- reorient(aspectNorth)

# Re-reorienting is the same, to within rounding error:
aspectNorth - reorient(reorient(aspectNorth))

# Plot:
aspects &lt;- c(aspectNorth, aspectEast)
names(aspects) &lt;- c("north_orientation", "east_orientation")
plot(aspects)


}
</code></pre>

<hr>
<h2 id='replaceNAs+2Cdata.frame-method'>Replace NAs in a data.table or data.frame column, or in a vector</h2><span id='topic+replaceNAs+2Cdata.frame-method'></span><span id='topic+replaceNAs'></span><span id='topic+replaceNAs+2Cmatrix-method'></span><span id='topic+replaceNAs+2Cdata.table-method'></span><span id='topic+replaceNAs+2Cnumeric-method'></span><span id='topic+replaceNAs+2Cinteger-method'></span><span id='topic+replaceNAs+2Clogical-method'></span><span id='topic+replaceNAs+2Ccharacter-method'></span>

<h3>Description</h3>

<p>This function replaces <code>NA</code>s in one or more <code>data.table</code>, <code>data.frame</code>, or <code>matrix</code> columns, or in vectors, with a user-defined value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'data.frame'
replaceNAs(x, replace, cols = NULL)

## S4 method for signature 'matrix'
replaceNAs(x, replace, cols = NULL)

## S4 method for signature 'data.table'
replaceNAs(x, replace, cols = NULL)

## S4 method for signature 'numeric'
replaceNAs(x, replace)

## S4 method for signature 'integer'
replaceNAs(x, replace)

## S4 method for signature 'logical'
replaceNAs(x, replace)

## S4 method for signature 'character'
replaceNAs(x, replace)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="replaceNAs+2B2Cdata.frame-method_+3A_x">x</code></td>
<td>
<p>A <code>data.table</code> or <code>data.frame</code> or <code>matrix</code>, or a vector of numeric, integer, logical, or character values.</p>
</td></tr>
<tr><td><code id="replaceNAs+2B2Cdata.frame-method_+3A_replace">replace</code></td>
<td>
<p>A value of any atomic class (numeric, integer, character, Date, etc.): Value to to replace <code>NA</code>s.</p>
</td></tr>
<tr><td><code id="replaceNAs+2B2Cdata.frame-method_+3A_cols">cols</code></td>
<td>
<p><code>NULL</code>, character, numeric, integer, or logical vector: Indicates columns for which to replace <code>NA</code>s. If <code>NULL</code>, then all columns will have <code>NA</code>s replaced. If a character, this is the column name(s). If numeric or integer, this is the columns' indices. If logical, columns with <code>TRUE</code> have <code>NA</code>s replaced. If a logical vector has fewer than the total number of columns, it will be recycled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code>, <code>data.frame</code>, <code>matrix</code>, or vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(data.table)

dt &lt;- data.table(
   x = 1:10,
   y = letters[1:10],
   z = rnorm(10)
)

# make some values NA
dt[x == 4 | x == 8, y := NA_character_]
dt

# Replace NAs:
replaceNAs(dt, replace = -99, cols = "y")
dt

# Drop rows:
dropped &lt;- dropRows(dt, 8:10)
dropped

# NB May not print... in that case, use:
print(dropped)

# We can also use replaceNAs() on vectors:
y &lt;- 1:10
y[c(2, 10)] &lt;- NA
replaceNAs(y, -99)

# Same as:
y &lt;- 1:10
y[c(2, 10)] &lt;- NA
y[is.na(y)] &lt;- -99
</code></pre>

<hr>
<h2 id='res+2Cmissing-method'>Spatial resolution</h2><span id='topic+res+2Cmissing-method'></span><span id='topic+res'></span><span id='topic+res+2CGRegion-method'></span><span id='topic+xres+2Cmissing-method'></span><span id='topic+xres'></span><span id='topic+xres+2CGRegion-method'></span><span id='topic+yres+2Cmissing-method'></span><span id='topic+yres'></span><span id='topic+yres+2CGRegion-method'></span><span id='topic+zres+2Cmissing-method'></span><span id='topic+zres'></span><span id='topic+zres+2CGRegion-method'></span><span id='topic+res3d+2Cmissing-method'></span><span id='topic+res3d'></span><span id='topic+res3d+2CGRegion-method'></span>

<h3>Description</h3>

<p>Spatial resolution of a <code>GRaster</code>:
</p>

<ul>
<li> <p><code>res()</code>: 2-dimensional resolution (x and y).<br /><br />
</p>
</li>
<li> <p><code>res3d()</code>: 3-dimensional resolution (z, y, and z).<br /><br />
</p>
</li>
<li> <p><code>xres()</code>, <code>yres()</code>, and <code>zres()</code>: East-west resolution, north-south resolution, and top-bottom resolution.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'missing'
res(x)

## S4 method for signature 'GRegion'
res(x)

## S4 method for signature 'missing'
xres(x)

## S4 method for signature 'GRegion'
xres(x)

## S4 method for signature 'missing'
yres(x)

## S4 method for signature 'GRegion'
yres(x)

## S4 method for signature 'missing'
zres(x)

## S4 method for signature 'GRegion'
zres(x)

## S4 method for signature 'missing'
res3d(x)

## S4 method for signature 'GRegion'
res3d(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="res+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>, <code>GRegion</code>, or missing. If missing, the resolution of the currently active &quot;region&quot; is returned (see <code>vignette("regions", package = "fasterRaster")</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. For both <code>res()</code> and <code>res3d()</code>, the first value is the length of cells in the x-direction and the second the length of cells in the y-direction. For <code>res3d()</code> the third value is height of a voxel (the z-direction). <code>xres()</code>, <code>yres()</code>, and <code>zres()</code> each return a single value.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+dimensions">terra::res()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")
madForest2000 &lt;- fastData("madForest2000")

# Convert SpatRasters to GRasters
elev &lt;- fast(madElev)
forest &lt;- fast(madForest2000)

### GRaster properties

# plotting
plot(elev)

# dimensions
dim(elev) # rows, columns, depths, layers
nrow(elev) # rows
ncol(elev) # columns
ndepth(elev) # depths
nlyr(elev) # layers

res(elev) # resolution (2D)
res3d(elev) # resolution (3D)
zres(elev) # vertical resolution
xres(elev) # vertical resolution
yres(elev) # vertical resolution
zres(elev) # vertical resolution (NA because this is a 2D GRaster)

# cell counts
ncell(elev) # cells
ncell3d(elev) # cells (3D rasters only)

# number of NA and non-NA cells
nacell(elev)
nonnacell(elev)

# topology
topology(elev) # number of dimensions
is.2d(elev) # is it 2-dimensional?
is.3d(elev) # is it 3-dimensional?

minmax(elev) # min/max values

# "names" of the object
names(elev)

# coordinate reference system
crs(elev)
st_crs(elev)
coordRef(elev)

# extent (bounding box)
ext(elev)

# vertical extent (not defined for this raster)
zext(elev)

# data type
datatype(elev) # fasterRaster type
datatype(elev, "GRASS") # GRASS type
datatype(elev, "terra") # terra type
datatype(elev, "GDAL") # GDAL type

is.integer(elev)
is.float(elev)
is.double(elev)
is.factor(elev)

# convert data type
as.int(elev) # integer; note that "elev" is already of type "integer"
as.float(elev) # floating-precision
as.doub(elev) # double-precision

# assigning
pie &lt;- elev
pie[] &lt;- pi # assign all cells to the value of pi
pie

# concatenating multiple GRasters
rasts &lt;- c(elev, forest)
rasts

# subsetting
rasts[[1]]
rasts[["madForest2000"]]

# replacing
rasts[[2]] &lt;- 2 * forest
rasts

# adding layers
rasts[[3]] &lt;- elev &gt; 500 # add a layer
rasts &lt;- c(rasts, sqrt(elev)) # add another
add(rasts) &lt;- ln(elev)
rasts

# names
names(rasts)
names(rasts) &lt;- c("elev_meters", "2_x_forest", "high_elevation", "sqrt_elev", "ln_elev")
rasts

# remove a layer
rasts[["2_x_forest"]] &lt;- NULL
rasts

# number of layers
nlyr(rasts)

# correlation and covariance matrices
madLANDSAT &lt;- fastData("madLANDSAT")
landsat &lt;- fast(madLANDSAT) # projects matrix
layerCor(landsat) # correlation
layerCor(landsat, fun = 'cov') # covariance

}
</code></pre>

<hr>
<h2 id='resample+2CGRaster+2CGRaster-method'>Change the cell size of a GRaster</h2><span id='topic+resample+2CGRaster+2CGRaster-method'></span><span id='topic+resample'></span><span id='topic+resample+2CGRaster+2Cnumeric-method'></span>

<h3>Description</h3>

<p><code>resample()</code> changes the cell size (resolution) of a <code>GRaster</code> using either another raster as a template or a user-defined resolution. Note that the extent of the output raster may be expanded to accommodate an integer number of cells. The function is not guaranteed to recreate the same output as <code><a href="terra.html#topic+resample">terra::resample()</a></code>, even when the same resampling method is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster,GRaster'
resample(x, y, method = NULL, fallback = TRUE)

## S4 method for signature 'GRaster,numeric'
resample(x, y, method = NULL, fallback = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resample+2B2CGRaster+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>The <code>GRaster</code> to resample.</p>
</td></tr>
<tr><td><code id="resample+2B2CGRaster+2B2CGRaster-method_+3A_y">y</code></td>
<td>
<p>Either a <code>GRaster</code> to serve as a template, or a numeric vector with two or three values. If a numeric vector, the values represent east-west and north-south resolution for 2D rasters, or east-west, north-south, and top-bottom resolution for 3D rasters.</p>
</td></tr>
<tr><td><code id="resample+2B2CGRaster+2B2CGRaster-method_+3A_method">method</code></td>
<td>
<p>Character or <code>NULL</code>: Method to use to assign values to cells. Partial matching is used.
</p>

<ul>
<li> <p><code>NULL</code> (default): Automatically choose based on raster properties (<code>near</code> for categorical or integer rasters, <code>bilinear</code> for continuous data).
</p>
</li>
<li> <p><code>"near"</code>: Nearest neighbor. Best for categorical data, and often a poor choice for continuous data.  If <code><a href="#topic+nlevels">nlevels()</a></code> is &gt;0, this method will be used regardless of the value of <code>method</code>. If you still want to use a different method, coerce the raster to a different type using <code><a href="#topic+as.int">as.int()</a></code>, <code><a href="#topic+as.float">as.float()</a></code>, or <code><a href="#topic+as.doub">as.doub()</a></code>.
</p>
</li>
<li> <p><code>"bilinear"</code>: Bilinear interpolation (default for non-categorical data; uses weighted values from 4 cells).
</p>
</li>
<li> <p><code>"bicubic"</code>: Bicubic interpolation (uses weighted values from 16 cells).
</p>
</li>
<li> <p><code>"lanczos"</code>: Lanczos interpolation (uses weighted values from 25 cells).
Note that methods that use multiple cells will cause the focal cell to become <code>NA</code> if there is at least one cell with an <code>NA</code> in the cells it draws from. These <code>NA</code> cells can be filled using the <code>fallback</code> option.
</p>
</li></ul>
</td></tr>
<tr><td><code id="resample+2B2CGRaster+2B2CGRaster-method_+3A_fallback">fallback</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), then use &quot;lower&quot; methods to fill in <code>NA</code> cells when a &quot;higher&quot; method is used. For example, if <code>method = "bicubic"</code>, <code>NA</code> cells will be filled in using the <code>bilinear</code> method, except when that results in <code>NA</code>s, in which case the <code>near</code> method will be used. Fallback causes fewer cells to revert to <code>NA</code> values, so can be better at resampling the edges of rasters. However, fallback does increase processing time because each &quot;lower&quot; method must be applied, then results merged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+resample">terra::resample()</a></code>, <strong>GRASS</strong> modules <code>r.resample</code> and <code>r.resamp.interp</code> (see <code style="white-space: pre;">&#8288;grassHelp("&#8288;</code>r.resample<code style="white-space: pre;">&#8288;") and &#8288;</code>grassHelp(&quot;<code>r.resamp.interp</code>&quot;)')
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Elevation raster
madElev &lt;- fastData("madElev")
elev &lt;- fast(madElev)

### Resample raster to 120 x 120 m
elev120 &lt;- resample(elev, c(120, 120), method="bilinear")
elev
elev120

### Resample using another raster as a template

template &lt;- aggregate(elev, 4)

nearest &lt;- resample(elev, template, method = "nearest")

bilinear &lt;- resample(elev, template, method = "bilinear")
bilinearNoFB &lt;- resample(elev, template, method = "bilinear", fallback = FALSE)

bicubic &lt;- resample(elev, template, method = "bicubic")
bicubicNoFB &lt;- resample(elev, template, method = "bicubic", fallback = FALSE)

lanczos &lt;- resample(elev, template, method = "lanczos")
lanczosNoFB &lt;- resample(elev, template, method = "lanczos", fallback = FALSE)

# rasters resampled without fallback have fewer non-NA cells
resampled &lt;- c(nearest, bilinear, bilinearNoFB, bicubic, bicubicNoFB, lanczos,
    lanczosNoFB)
names(resampled) &lt;- c("nearest", "bilinear", "bilinearNoFB", "bicubic",
    "bicubicNoFB", "lanczos", "lanczosNoFB")
ones &lt;- resampled * 0 + 1
global(ones, "sum") # number of non-NA cells
global(resampled, c("mean", "sd", "min", "max")) # other statistics

# Compare fallback to no fallback
frLanczos &lt;- rast(lanczos)
frLanczosNoFB &lt;- rast(lanczosNoFB)

plot(frLanczos, col = "red",
    main = "Red: Cells in fallback not non-fallback", legend = FALSE)
plot(frLanczosNoFB, add=TRUE)

# Compare fasterRaster with terra
coarserTerra &lt;- aggregate(madElev, 4)
terraLanczos &lt;- resample(madElev, coarserTerra, method = "lanczos")

frLanczos &lt;- extend(frLanczos, terraLanczos)
frLanczosNoFB &lt;- extend(frLanczosNoFB, terraLanczos)

frLanczos - terraLanczos
frLanczosNoFB - terraLanczos

plot(frLanczos - terraLanczos, main = "Difference")
plot(frLanczosNoFB - terraLanczos, main = "Difference")

plot(terraLanczos, col = "red",
    main = "Red: Cells in terra not in FR", legend = FALSE)
plot(frLanczos, add=TRUE)

plot(frLanczos, col = "red",
    main = "Red: Cells in FR not in terra", legend = FALSE)
plot(terraLanczos, add=TRUE)

}
</code></pre>

<hr>
<h2 id='rnormRast+2CGRaster-method'>Create a raster with random values drawn from a normal distribution</h2><span id='topic+rnormRast+2CGRaster-method'></span><span id='topic+rnormRast'></span>

<h3>Description</h3>

<p><code>rnormRast()</code> creates a raster with values drawn from a normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
rnormRast(x, n = 1, mu = 0, sigma = 1, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rnormRast+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>: The output will have the same extent and dimensions as this raster.</p>
</td></tr>
<tr><td><code id="rnormRast+2B2CGRaster-method_+3A_n">n</code></td>
<td>
<p>An integer: Number of rasters to generate.</p>
</td></tr>
<tr><td><code id="rnormRast+2B2CGRaster-method_+3A_mu">mu</code>, <code id="rnormRast+2B2CGRaster-method_+3A_sigma">sigma</code></td>
<td>
<p>Numeric: Mean and sample standard deviation of output. If creating more than one raster, you can provide one value per raster. If there are fewer, they will be recycled.</p>
</td></tr>
<tr><td><code id="rnormRast+2B2CGRaster-method_+3A_seed">seed</code></td>
<td>
<p>Numeric integer or <code>NULL</code>: Random seed. If <code>NULL</code>, then a random seed is used for each raster. If provided, there should be one seed value per raster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rSpatialDepRast">rSpatialDepRast()</a></code>, <code><a href="#topic+fractalRast">fractalRast()</a></code>, <code><a href="#topic+runifRast">runifRast()</a></code>, <strong>GRASS</strong> manual page for module <code>r.random.surface</code> (see <code>grassHelp("r.random.surface")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Elevation raster
madElev &lt;- fastData("madElev")

# Convert a SpatRaster to a GRaster:
elev &lt;- fast(madElev)

### Create a raster with values drawn from a uniform distribution:
unif &lt;- runifRast(elev)
plot(unif)

### Create a raster with values drawn from a normal distribution:
norms &lt;- rnormRast(elev, n = 2, mu = c(5, 10), sigma = c(2, 1))
plot(norms)
hist(norms, bins = 100)

# Create a raster with random, seemingly normally-distributed values:
rand &lt;- rSpatialDepRast(elev, dist = 1000)
plot(rand)

# Values appear normal on first inspection:
hist(rand)

# ... but actually are patterned:
hist(rand, bins = 100)

# Create a fractal raster:
fractal &lt;- fractalRast(elev, n = 2, dimension = c(2.1, 2.8))
plot(fractal)
hist(fractal)

}
</code></pre>

<hr>
<h2 id='rSpatialDepRast+2CGRaster-method'>Create a random raster with or without spatial dependence</h2><span id='topic+rSpatialDepRast+2CGRaster-method'></span><span id='topic+rSpatialDepRast'></span>

<h3>Description</h3>

<p><code>rSpatialDepRast()</code> creates a raster with random values in cells. Across the raster, values are approximately normally distributed, though a raster with a &quot;true&quot; normal distribution can be made with <code><a href="#topic+rnormRast">rnormRast()</a></code>. Spatial dependence can be introduced, though all together the values will still be approximately normally distributed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
rSpatialDepRast(
  x,
  n = 1,
  mu = 0,
  sigma = 1,
  dist = 0,
  exponent = 1,
  delay = 0,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rSpatialDepRast+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>: The output will have the same extent and dimensions as this raster.</p>
</td></tr>
<tr><td><code id="rSpatialDepRast+2B2CGRaster-method_+3A_n">n</code></td>
<td>
<p>An integer: Number of rasters to generate.</p>
</td></tr>
<tr><td><code id="rSpatialDepRast+2B2CGRaster-method_+3A_mu">mu</code>, <code id="rSpatialDepRast+2B2CGRaster-method_+3A_sigma">sigma</code></td>
<td>
<p>Numeric: Mean and sample standard deviation of output. If creating more than one raster, you can provide one value per raster. If there are fewer, they will be recycled.</p>
</td></tr>
<tr><td><code id="rSpatialDepRast+2B2CGRaster-method_+3A_dist">dist</code></td>
<td>
<p>Numeric: Maximum distance of spatial autocorrelation (in map units&ndash;typically meters). Default is 0 (no spatial autocorrelation). If creating more than one raster, you can provide one value per raster. If there are fewer, values will be recycled.</p>
</td></tr>
<tr><td><code id="rSpatialDepRast+2B2CGRaster-method_+3A_exponent">exponent</code></td>
<td>
<p>Numeric &gt; 0: Distance decay exponent. If creating more than one raster, you can provide one value per raster. If there are fewer, values will be recycled.</p>
</td></tr>
<tr><td><code id="rSpatialDepRast+2B2CGRaster-method_+3A_delay">delay</code></td>
<td>
<p>Numeric &gt;= 0: Values &gt;0 force the distance decay of similarity to remain constant up to this distance. Beyond this distance, the decay exponent takes effect. Default is 0. If creating more than one raster, you can provide one value per raster. If there are fewer, values will be recycled.</p>
</td></tr>
<tr><td><code id="rSpatialDepRast+2B2CGRaster-method_+3A_seed">seed</code></td>
<td>
<p>Numeric integer or <code>NULL</code>: Random seed. If <code>NULL</code>, then a random seed is used for each raster. If provided, there should be one seed value per raster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rnormRast">rnormRast()</a></code>, <code><a href="#topic+fractalRast">fractalRast()</a></code>, <code><a href="#topic+runifRast">runifRast()</a></code>, <strong>GRASS</strong> manual page for module <code>r.random.surface</code> (see <code>grassHelp("r.random.surface")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Elevation raster
madElev &lt;- fastData("madElev")

# Convert a SpatRaster to a GRaster:
elev &lt;- fast(madElev)

### Create a raster with values drawn from a uniform distribution:
unif &lt;- runifRast(elev)
plot(unif)

### Create a raster with values drawn from a normal distribution:
norms &lt;- rnormRast(elev, n = 2, mu = c(5, 10), sigma = c(2, 1))
plot(norms)
hist(norms, bins = 100)

# Create a raster with random, seemingly normally-distributed values:
rand &lt;- rSpatialDepRast(elev, dist = 1000)
plot(rand)

# Values appear normal on first inspection:
hist(rand)

# ... but actually are patterned:
hist(rand, bins = 100)

# Create a fractal raster:
fractal &lt;- fractalRast(elev, n = 2, dimension = c(2.1, 2.8))
plot(fractal)
hist(fractal)

}
</code></pre>

<hr>
<h2 id='ruggedness+2CGRaster-method'>Terrain ruggedness index</h2><span id='topic+ruggedness+2CGRaster-method'></span><span id='topic+ruggedness'></span>

<h3>Description</h3>

<p>For a given focal grid cell, the terrain ruggedness index (TRI) is calculated by taking the square root of the average of the squared difference between the focal cell's elevation and the elevations of the 8 surrounding cells, or </p>
<p style="text-align: center;"><code class="reqn">\sqrt(\sum_{i = 1}^{8}(m_i - m_0)^2 / 8)</code>
</p>
<p> where <code class="reqn">m_0</code> is the elevation of the focal cell and <code class="reqn">m_i</code> is the elevation of the <em>i</em>th grid cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
ruggedness(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ruggedness+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>References</h3>

<p>Riley, S.J., DeGloria, S.D., and Elliot, R. 1999. A terrain ruggedness index that quantifies topographic heterogeneity. <em>Intermountain Journal of Sciences</em> 5:23-27.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+terrain">terrain()</a></code>, <code><a href="#topic+wetness">wetness()</a></code>, <code><a href="#topic+geomorphons">geomorphons()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Elevation raster
madElev &lt;- fastData("madElev")

# Convert to GRaster:
elev &lt;- fast(madElev)

# Terrain ruggedness index:
tri &lt;- ruggedness(elev)
plot(c(elev, tri))

# Topographic wetness index:
twi &lt;- wetness(elev)
plot(c(elev, twi))

}
</code></pre>

<hr>
<h2 id='runifRast+2CGRaster-method'>Create a raster with random values drawn from a uniform distribution</h2><span id='topic+runifRast+2CGRaster-method'></span><span id='topic+runifRast'></span>

<h3>Description</h3>

<p><code>runifRast()</code> creates a raster with values drawn from a uniform (flat) distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
runifRast(x, n = 1, low = 0, high = 1, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runifRast+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>. The output will have the same extent and dimensions as this raster.</p>
</td></tr>
<tr><td><code id="runifRast+2B2CGRaster-method_+3A_n">n</code></td>
<td>
<p>A numeric integer: Number of rasters to generate.</p>
</td></tr>
<tr><td><code id="runifRast+2B2CGRaster-method_+3A_low">low</code>, <code id="runifRast+2B2CGRaster-method_+3A_high">high</code></td>
<td>
<p>Numeric: Minimum and maximum values from which to select.</p>
</td></tr>
<tr><td><code id="runifRast+2B2CGRaster-method_+3A_seed">seed</code></td>
<td>
<p>Numeric integer vector or <code>NULL</code>: Random seed. If <code>NULL</code>, then a different seed will be generated by <strong>GRASS</strong>. Defining this is useful if you want to recreate rasters.  If provided, there should be one seed value per raster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rnormRast">rnormRast()</a></code>, <code><a href="#topic+rSpatialDepRast">rSpatialDepRast()</a></code>, <code><a href="#topic+fractalRast">fractalRast()</a></code>, <strong>GRASS</strong> manual page for module <code>r.random.surface</code> (see <code>grassHelp("r.random.surface")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Elevation raster
madElev &lt;- fastData("madElev")

# Convert a SpatRaster to a GRaster:
elev &lt;- fast(madElev)

### Create a raster with values drawn from a uniform distribution:
unif &lt;- runifRast(elev)
plot(unif)

### Create a raster with values drawn from a normal distribution:
norms &lt;- rnormRast(elev, n = 2, mu = c(5, 10), sigma = c(2, 1))
plot(norms)
hist(norms, bins = 100)

# Create a raster with random, seemingly normally-distributed values:
rand &lt;- rSpatialDepRast(elev, dist = 1000)
plot(rand)

# Values appear normal on first inspection:
hist(rand)

# ... but actually are patterned:
hist(rand, bins = 100)

# Create a fractal raster:
fractal &lt;- fractalRast(elev, n = 2, dimension = c(2.1, 2.8))
plot(fractal)
hist(fractal)

}
</code></pre>

<hr>
<h2 id='rvoronoi+2CGRaster-method'>Create a randomly-positioned tesselation</h2><span id='topic+rvoronoi+2CGRaster-method'></span><span id='topic+rvoronoi'></span><span id='topic+rvoronoi+2CGVector-method'></span>

<h3>Description</h3>

<p>This function partitions a region into Voronoi polygons that completely overlap it. Each polygon has a random center. The function is essentially a wrapper for <code><a href="#topic+spatSample">spatSample()</a></code> and <code><a href="#topic+voronoi">voronoi()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
rvoronoi(x, size = 100, seed = NULL)

## S4 method for signature 'GVector'
rvoronoi(x, size = 100, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rvoronoi+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> or <code>GVector</code> used to constrain the location of random points used to create the tesselation.</p>
</td></tr>
<tr><td><code id="rvoronoi+2B2CGRaster-method_+3A_size">size</code></td>
<td>
<p>Numeric integer or integer: Number of polygons.</p>
</td></tr>
<tr><td><code id="rvoronoi+2B2CGRaster-method_+3A_seed">seed</code></td>
<td>
<p>Numeric integer, integer, or <code>NULL</code> (default): Value used as a random seed. If <code>NULL</code>, a random seed will be generated by <strong>GRASS</strong>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GVector</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)

# Example vectors
madDypsis &lt;- fastData("madDypsis") # points
madCoast4 &lt;- fastData("madCoast4") # polygons

# Convert sf vectors to GVectors
dypsis &lt;- fast(madDypsis)
coast4 &lt;- fast(madCoast4)
ant &lt;- coast4[coast4$NAME_4 == "Antanambe"]

# Delaunay triangulation
dypsisDel &lt;- delaunay(dypsis)
plot(dypsisDel)
plot(dypsis, pch = 1, col = "red", add = TRUE)

# Voronoi tessellation
vor &lt;- voronoi(dypsis)
plot(vor)
plot(dypsis, pch = 1, col = "red", add = TRUE)

# Random Voronoi tessellation
rand &lt;- rvoronoi(coast4, size = 100)
plot(rand)

}
</code></pre>

<hr>
<h2 id='sampleRast+2CGRaster-method'>Randomly sample cells from a GRaster</h2><span id='topic+sampleRast+2CGRaster-method'></span><span id='topic+sampleRast'></span>

<h3>Description</h3>

<p><code>sampleRast()</code> randomly samples cells from non-<code>NA</code> cells of a raster. The output will be a raster with selected non-<code>NA</code> cells, and all other cells set to <code>NA</code>. To generate random points, see <code><a href="#topic+spatSample">spatSample()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
sampleRast(
  x,
  size,
  prop = FALSE,
  maskvalues = NA,
  updatevalue = NULL,
  test = FALSE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleRast+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="sampleRast+2B2CGRaster-method_+3A_size">size</code></td>
<td>
<p>Numeric: Number of cells or proportion of cells to select.</p>
</td></tr>
<tr><td><code id="sampleRast+2B2CGRaster-method_+3A_prop">prop</code></td>
<td>
<p>Logical: If <code>TRUE</code>, the value of <code>size</code> will be interpreted as a proportion of cells. The default is <code>FALSE</code> (<code>size</code> is interpreted as the number of cells to select).</p>
</td></tr>
<tr><td><code id="sampleRast+2B2CGRaster-method_+3A_maskvalues">maskvalues</code></td>
<td>
<p>Numeric vector, including <code>NA</code>, or <code>NULL</code> (default): Values in the raster to select from. All others will be ignored. If this is <code>NULL</code>, then only non-<code>NA</code> cells will be selected for retention.</p>
</td></tr>
<tr><td><code id="sampleRast+2B2CGRaster-method_+3A_updatevalue">updatevalue</code></td>
<td>
<p>Numeric or <code>NULL</code> (default): Value to assign to masked cells. If <code>NULL</code>, then the values in the input raster are retained.</p>
</td></tr>
<tr><td><code id="sampleRast+2B2CGRaster-method_+3A_test">test</code></td>
<td>
<p>Logical: If <code>TRUE</code>, and <code>size</code> is greater than the number of non-<code>NA</code> cells in <code>x</code>, then fail. Testing this can take a long time for large rasters. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sampleRast+2B2CGRaster-method_+3A_seed">seed</code></td>
<td>
<p><code>NULL</code> (default) or numeric: If <code>NULL</code>, then a random seed will be generated for the random number generator. Otherwise a seed can be provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spatSample">spatSample()</a></code>; <code><a href="terra.html#topic+sample">terra::spatSample()</a></code>, module <code>r.random</code> in <strong>GRASS</strong>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Example data
madElev &lt;- fastData("madElev") # raster

# Convert to GRasters and GVectors
elev &lt;- fast(madElev)

### spatSample()

# Random points as data.frame or data.table:
randVals &lt;- spatSample(elev, size = 20, values = TRUE)
randVals

# Random points as a points GVector:
randPoints &lt;- spatSample(elev, size = 20, as.points = TRUE)
randPoints
plot(elev)
plot(randPoints, add = TRUE)

# Random points in a select area:
madCoast &lt;- fastData("madCoast4") # vector
coast &lt;- fast(madCoast)
ant &lt;- coast[coast$NAME_4 == "Antanambe"] # subset

restrictedPoints &lt;- spatSample(elev, size = 20, as.points = TRUE,
   strata = ant)

plot(elev)
plot(ant, add = TRUE)
plot(restrictedPoints, add = TRUE) # note 20 points for entire geometry

# Random points, one set per subgeometry:
stratifiedPoints &lt;- spatSample(elev, size = 20, as.points = TRUE,
   strata = ant, byStratum = TRUE)

plot(elev)
plot(ant, add = TRUE)
plot(stratifiedPoints, pch = 21, bg = "red", add = TRUE) # note 20 points per subgeometry

# Random categories:
madCover &lt;- fastData("madCover") # raster
cover &lt;- fast(madCover)

randCover &lt;- spatSample(cover, size = 20, values = TRUE,
     cat = TRUE, xy = TRUE)
randCover

### sampleRast()

# Random cells in non-NA cells:
rand &lt;- sampleRast(elev, 10000)
plot(rand)
nonnacell(rand)

# Use custom values for the mask:
randCustomMask &lt;- sampleRast(elev, 10000, maskvalues = 1:20)
plot(randCustomMask)

# Force selected values to a custom value:
randCustomUpdate &lt;- sampleRast(elev, 10000, updatevalue = 7)
plot(randCustomUpdate)

# Custom values for mask and set selected cells to custom value:
randAll &lt;- sampleRast(elev, 10000, maskvalues = 1:20, updatevalue = 7)
plot(randAll)

}
</code></pre>

<hr>
<h2 id='scale+2CGRaster-method'>Center and scale a GRaster, or the opposite</h2><span id='topic+scale+2CGRaster-method'></span><span id='topic+scale'></span><span id='topic+scalepop+2CGRaster-method'></span><span id='topic+scalepop'></span><span id='topic+unscale+2CGRaster-method'></span><span id='topic+unscale'></span>

<h3>Description</h3>

<p><code>scale()</code> and <code>scalepop()</code> center and scale layers in a <code>GRaster</code> by subtracting from each raster its mean value (centering), then dividing by its standard deviation (scaling). This is useful for using the raster in a linear model, for example, because unscaled predictors can lead to numerical instability. The <code>scale()</code> function uses the sample standard deviation, and the <code>scalepop()</code> function uses the population standard deviation. For even moderately-sized rasters, the difference between these two is negligible, but the <code>scalepop()</code> function can be much faster than the <code>scale()</code> function.
</p>
<p>The <code>unscale()</code> function does the opposite of <code>scale()</code> and <code>scalepop()</code>: it multiples each layer by a value (presumably, its standard deviation), and adds another value (presumably, its mean).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
scale(x, center = TRUE, scale = TRUE)

## S4 method for signature 'GRaster'
scalepop(x, center = TRUE, scale = TRUE)

## S4 method for signature 'GRaster'
unscale(x, center = NULL, scale = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="scale+2B2CGRaster-method_+3A_center">center</code></td>
<td>
<p>Value depends on the function:
</p>

<ul>
<li> <p><code>scale()</code>: Logical: If <code>TRUE</code> (default), subtract from each raster layer its mean.
</p>
</li>
<li> <p><code>unscale()</code>: Numeric vector or <code>NULL</code> (default): This can be a single value, which will be recycled if there is more than one layer in the raster, or one value per raster layer. If a value is <code>NA</code>, then no un-centering will be performed on the relevant raster layer. If <code>NULL</code>, then no un-centering is done.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale+2B2CGRaster-method_+3A_scale">scale</code></td>
<td>
<p>Value depends on the function:
</p>

<ul>
<li> <p><code>scale()</code>: Logical: If <code>TRUE</code> (default), divide each layer by its standard deviation.
</p>
</li>
<li> <p><code>unscale()</code>: Numeric vector or <code>NULL</code> (default): This can be a single value, which will be recycled if there is more than one layer in the raster, or one value per raster layer. If a value is <code>NA</code>, then no unscaling will be done on the relevant raster layer. If <code>NULL</code>, then no un-scaling is done.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>All functions return a <code>GRaster</code>. The output of <code>scale()</code> and <code>scalepop()</code> will have two attributes, &quot;center&quot; and &quot;scale&quot;, which have the means and standard deviations of the original rasters (if <code>center</code> and <code>scale</code> are <code>TRUE</code>, otherwise, they will be <code>NA</code>). These can be obtained using <code>attributes(output_raster)$center</code> and <code>attributes(output_raster)$scale</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Climate rasters:
madChelsa &lt;- fastData("madChelsa")

# Convert to GRasters:
chelsa &lt;- fast(madChelsa)

### Center and scale rasters
# Scale with using sample SD:
chScaled &lt;- scale(chelsa)
chScaled

# Scale with using population SD:
chScaledPop &lt;- scalepop(chelsa)
chScaledPop

# Means are very close to 0 and SDs to 1:
global(chScaled, c("mean", "sd", "min", "max"))
global(chScaledPop, c("mean", "sd", "min", "max"))

# Get original means and sd's:
centers &lt;- attributes(chScaled)$center
scales &lt;- attributes(chScaled)$scale
centers
scales

### Unscale rasters:
chUnscaled &lt;- unscale(chScaled, center = centers, scale = scales)

# Means and SD are returned to original values:
global(chUnscaled, c("mean", "sd", "min", "max")) # unscaled
global(chelsa, c("mean", "sd", "min", "max")) # original

}
</code></pre>

<hr>
<h2 id='segregate+2CGRaster-method'>Create one GRaster layer per unique value in a GRaster</h2><span id='topic+segregate+2CGRaster-method'></span><span id='topic+segregate'></span>

<h3>Description</h3>

<p>This function creates a multi-layered <code>GRaster</code> for every unique values in an input <code>GRaster</code>. By default, the output will have a value of 1 wherever the input has the given value, and 0 elsewhere. This is useful for creating dummy variable <code>GRaster</code> layers for use with models that have factors, especially if the input <code>GRaster</code> is categorical. Note that the <code><a href="#topic+predict">predict()</a></code> function in <strong>fasterRaster</strong> usually does not need this treatment of <code>GRaster</code>s since it can handle categorical rasters already.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
segregate(x, classes = NULL, keep = FALSE, other = 0, bins = 100, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="segregate+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="segregate+2B2CGRaster-method_+3A_classes">classes</code></td>
<td>
<p>Either <code>NULL</code> (default) or a character vector with category labels for which to create outputs. If the input is not a categorical/factor or <code>integer</code> <code>GRaster</code>, this is ignored.</p>
</td></tr>
<tr><td><code id="segregate+2B2CGRaster-method_+3A_keep">keep</code></td>
<td>
<p>Logical: If <code>FALSE</code> (default), then the original value in the input <code>GRaster</code> will be retained in the each of the output <code>GRaster</code> layers wherever the input had the respective value. Other cells will be assigned a value of <code>other</code>.</p>
</td></tr>
<tr><td><code id="segregate+2B2CGRaster-method_+3A_other">other</code></td>
<td>
<p>Numeric or <code>NA</code>: Value to assign to cells that do not have the target value.</p>
</td></tr>
<tr><td><code id="segregate+2B2CGRaster-method_+3A_bins">bins</code></td>
<td>
<p>Numeric: Number of bins in which to put values. This is only used for <code>GRaster</code>s that are not categorical/factor rasters or <code>integer</code> rasters.</p>
</td></tr>
<tr><td><code id="segregate+2B2CGRaster-method_+3A_digits">digits</code></td>
<td>
<p>Numeric: Number of digits to which to round input if it is a <code>numeric</code> or <code>double</code> <code>GRaster</code> (see <code>vignettes("GRasters", package = "fasterRaster")</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the input <code>x</code> is a single-layered <code>GRaster</code>, the output will be a multi-layered <code>GRaster</code> with one layer per value in the input, or one layer per values in <code>classes</code>. If the input is a multi-layered <code>GRaster</code>, the output will be a <code>list</code> of multi-layered <code>GRaster</code>s.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+segregate">terra::segregate()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Elevation and land cover raster
madElev &lt;- fastData("madElev") # integer raster
madCover &lt;- fastData("madCover") # categorical raster

# Convert to GRasters
elev &lt;- fast(madElev)
cover &lt;- fast(madCover)

# Subset elevation raster to just a few values to make example faster:
elevSubset &lt;- elev[elev &lt;= 3]
segregate(elevSubset)
segregate(elevSubset, keep = TRUE, other = -1)

# Segregate the factor raster
segregate(cover)

classes &lt;- c("Grassland with mosaic forest", "Mosaic cropland/vegetation")
seg &lt;- segregate(cover, classes = classes)
plot(seg)

}
</code></pre>

<hr>
<h2 id='selectRange+2CGRaster-method'>Select values from rasters in a stack based on values in another raster</h2><span id='topic+selectRange+2CGRaster-method'></span><span id='topic+selectRange'></span>

<h3>Description</h3>

<p><code>selectRange()</code> selects values from <code>GRaster</code>s in a &quot;stack&quot; based on the values in another &quot;selection&quot; raster. For example, if the stack has three layers (call them A, B, and C), the &quot;selection&quot; raster could have values of 1, 2, or 3 in each cell. The raster that is returned will have values from A wherever the selection raster is 1, B from where it is 2, and C from where it is 3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
selectRange(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selectRange+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>, typically with more than one layer.</p>
</td></tr>
<tr><td><code id="selectRange+2B2CGRaster-method_+3A_y">y</code></td>
<td>
<p>A <code>GRaster</code> with integer values. The raster will be rounded if it does not. The values are typically between 1 and the number of layers in <code>x</code>, but wherever they are outside this range, the returned raster will have <code>NA</code> values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")

# Convert a SpatRaster to a GRaster
elev &lt;- fast(madElev)

# Make a stack of various versions of "elev" from which to select from:
x &lt;- c(elev, 10 * elev, ln(elev), -1 * elev)
x

# Make a layer with random numbers between 1 and 4:
fun &lt;- "= round(rand(0.5, 4.5))"
y &lt;- app(elev, fun = fun)

selected &lt;- selectRange(x, y)

}
</code></pre>

<hr>
<h2 id='seqToSQL'>Format a numeric series into an SQL value call</h2><span id='topic+seqToSQL'></span>

<h3>Description</h3>

<p>This function takes as its argument a vector of integers or numeric values, and converts sequential runs to a range while keeping non-sequential values as-is. For example, <code>c(1, 5, 6, 7, 8, 9, 15, 16, 20)</code> becomes <code>"1,5-9,15-16,20"</code>. This reduces the number of characters necessary to supply to a SQL condition. This function is mainly of use to developers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqToSQL(x, maxChar = 29900, sort = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seqToSQL_+3A_x">x</code></td>
<td>
<p>A vector of numerical values. The vector should be sorted from  lowers to highest for the most efficient &quot;compression&quot; of sequential ranges. Values will be coerced to class <code>integer</code>.</p>
</td></tr>
<tr><td><code id="seqToSQL_+3A_maxchar">maxChar</code></td>
<td>
<p>Integer or numeric: Maximum number of characters to include in the output. If the output has more than this number of characters, the remainder is dropped, and the <code>trim</code> attribute of the output is set to <code>TRUE</code>. The default is 29900, which is the maximum length of an SQL statement that <strong>GRASS</strong> seems to be able to handle (minus a safety margin).</p>
</td></tr>
<tr><td><code id="seqToSQL_+3A_sort">sort</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), sort <code>x</code> before converting to SQL. This can reduce the length of the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string. The string has three attributes. The <code>trim</code> attribute is <code>TRUE</code> or <code>FALSE</code>, depending on whether <code>maxChar</code> was reached or not (and subsequent numbers dropped from the string). The <code>lastIndex</code> attribute is the last index of <code>x</code> that was processed (i.e., the index of the last value in the output), and the number of values represented by the output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- 1:5
seqToSQL(x)

x &lt;- c(1:5, 7)
seqToSQL(x)

x &lt;- c(1:5, 7, 15:16)
y &lt;- c(1:5, 7, 15:16, 20)
seqToSQL(x)
seqToSQL(y)

seqToSQL(x, maxChar = 5)
seqToSQL(y, maxChar = 8)

seqToSQL(10:1, sort = FALSE)
seqToSQL(10:1, sort = TRUE)

</code></pre>

<hr>
<h2 id='simplifyGeom+2CGVector-method'>Simplify the geometry of a vector</h2><span id='topic+simplifyGeom+2CGVector-method'></span><span id='topic+simplifyGeom'></span>

<h3>Description</h3>

<p><code>simplifyGeom()</code> reduces the number of vertices used to represent a vector (i.e., to save memory or disk space). There are several methods available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector'
simplifyGeom(x, tolerance = NULL, method = "VR", prop = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simplifyGeom+2B2CGVector-method_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="simplifyGeom+2B2CGVector-method_+3A_tolerance">tolerance</code></td>
<td>
<p>Numeric &gt;= 0: Threshold distance in map units (degrees for unprojected, usually meters for projected). If <code>NULL</code>, then 2% of the minimum of the x-, y-, and z-extent will be used.</p>
</td></tr>
<tr><td><code id="simplifyGeom+2B2CGVector-method_+3A_method">method</code></td>
<td>
<p>Character: Method used to reduce the number of vertices. Partial matching is used, and case does not matter:
</p>

<ul>
<li> <p><code>"VR"</code>: Vertex reduction (default, simplest): If two points p1 and p2 on the same line are closer than the threshold, remove p2. The <code>tolerance</code> argument represents this threshold distance.
</p>
</li>
<li> <p><code>"DP"</code>: Douglas-Peucker (AKA Ramer-Douglas-Peucker) algorithm: Simply stated, for points p1, p2, and p3 on a line, this method constructs a line segment between p1 and p3. If p2 is closer than the threshold to the line segment, it is removed. In this example, the <code>tolerance</code> argument refers to the maximum distance between p2 and the line segment.
</p>
</li>
<li> <p><code>"DPR"</code>: Douglas-Peucker algorithm with reduction: As the Douglas-Pueker method, but each geometry is thinned so that in the end it has only a given proportion of the starting number of points. The <code>prop</code> argument refers to this proportion of remaining points.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"RW&#8288;</code>: Reumann-Witkam algorithm: For points p1, p2, p3, and p4 on a line, constructs two line segments parallel to the line segment defined by p1 and p4. These are placed <code>tolerance</code> distance one either side of the p1-p4 line segment. If the line segment p1-p2 or p3-p4 falls entirely within the bounds of the two outer parallel segments, p2 and p3 are removed, leaving just p1 and p4.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simplifyGeom+2B2CGVector-method_+3A_prop">prop</code></td>
<td>
<p>Positive value between 0 and 1: Proportion of points that will be retained for each geometry when the Douglas-Peucker algorithm with reduction is applied (ignored otherwise). Default is 0.5 (retain 50% of vertices).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smoothGeom">smoothGeom()</a></code>, <a href="#topic+breakPolys">geometry cleaning</a>, <code><a href="terra.html#topic+simplify">terra::simplifyGeom()</a></code>, <strong>GRASS</strong> manual page for module <code>v.generalize</code> (see <code>grassHelp("v.generalize")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Example data
madRivers &lt;- fastData("madRivers")
rivers &lt;- fast(madRivers)
soam &lt;- rivers[rivers$NAM == "SOAMIANINA"] # select one river for illustration

### Simplify geometry (remove nodes)

vr &lt;- simplifyGeom(soam, tolerance = 2000)
dp &lt;- simplifyGeom(soam, tolerance = 2000, method = "dp")
dpr &lt;- simplifyGeom(soam, tolerance = 2000, method = "dpr", prop = 0.5)
rw &lt;- simplifyGeom(soam, tolerance = 2000, method = "rw")

plot(soam, col = "black", lwd = 3)
plot(vr, col = "blue", add = TRUE)
plot(dp, col = "red", add = TRUE)
plot(dpr, col = "chartreuse", add = TRUE)
plot(rw, col = "orange", add = TRUE)

legend("bottom",
   xpd = NA,
   legend = c(
	  "Original",
      "Vertex reduction",
      "Douglas-Peucker",
      "Douglas-Peucker reduction",
      "Reumann-Witkam"
	),
	col = c("black", "blue", "red", "chartreuse", "orange"),
	lwd = c(3, 1, 1, 1, 1)
)

### Smooth geometry

hermite &lt;- smoothGeom(soam, dist = 2000, angle = 3)
chaiken &lt;- smoothGeom(soam, method = "Chaiken", dist = 2000)

plot(soam, col = "black", lwd = 2)
plot(hermite, col = "blue", add = TRUE)
plot(chaiken, col = "red", add = TRUE)

legend("bottom",
   xpd = NA,
   legend = c(
	  "Original",
      "Hermite",
      "Chaiken"
	),
	col = c("black", "blue", "red"),
	lwd = c(2, 1, 1, 1, 1)
)

### Clean geometry

# Has no effect on this vector!
noDangs &lt;- removeDangles(soam, tolerance = 10000)

plot(soam, col = "black", lwd = 2)
plot(noDangs, col = "red", add = TRUE)

legend("bottom",
   xpd = NA,
   legend = c(
	  "Original",
      "No dangles"
	),
	lwd = c(2, 1),
	col = c("black", "red")
)

}
</code></pre>

<hr>
<h2 id='sineRast+2CGRaster-method'>Sine wave rasters</h2><span id='topic+sineRast+2CGRaster-method'></span><span id='topic+sineRast'></span>

<h3>Description</h3>

<p>This function creates one or more rasters with sine waves in the north-south and east-west directions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
sineRast(
  x,
  ns = 1,
  ew = 1,
  nsOffset = 0,
  ewOffset = 0,
  nsAmp = 1,
  ewAmp = 1,
  combos = FALSE,
  mask = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sineRast+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="sineRast+2B2CGRaster-method_+3A_ns">ns</code>, <code id="sineRast+2B2CGRaster-method_+3A_ew">ew</code></td>
<td>
<p>Numeric: Number of complete sine waves (i.e., wavelengths) in the north-south and east-west directions. A wavelength of 1 creates a &quot;full&quot; sine wave (e.g., starting at 0 at one end and ending at 0 at the other). A wavelength of 2 would create two such waves, and so on. A value of 0 creates no waves in the given direction (i.e., each row or column has constant values). The default value is 1.</p>
</td></tr>
<tr><td><code id="sineRast+2B2CGRaster-method_+3A_nsoffset">nsOffset</code>, <code id="sineRast+2B2CGRaster-method_+3A_ewoffset">ewOffset</code></td>
<td>
<p>Numeric: Offset of the sine waves from the edges of the raster, expressed as a proportion of the length of the raster. The default is 0, so the values of the outermost cells will be close to 0 (but not exactly 0 because centers of cells at the raster edges are not on the actual edge). If an offset value is 0.2, for example, then it will be pushed &quot;inward&quot; toward the middle of the raster by 20% of the raster's extent.</p>
</td></tr>
<tr><td><code id="sineRast+2B2CGRaster-method_+3A_nsamp">nsAmp</code>, <code id="sineRast+2B2CGRaster-method_+3A_ewamp">ewAmp</code></td>
<td>
<p>Numeric: Amplitude (minimum and maximum of the sine wave) in the north-south and east-west directions. The default is 1. Note that when north-south and east-west waves are created (i.e., <code>ns</code> and <code>ew</code> are both &gt; 0), the effective amplitude is halved so that the sum is equal to <code>nsAmp + ewAmp</code>.</p>
</td></tr>
<tr><td><code id="sineRast+2B2CGRaster-method_+3A_combos">combos</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), create sine rasters using all possible combinations of values of <code>ns</code>, <code>ew</code>, <code>nsOffset</code>, <code>ewOffset</code>, and <code>amp</code>. If <code>FALSE</code>, you can only supply either one value per parameter, or the same number of values per parameter. In this latter case, one raster will be created per pairwise set of the unique parameters. For example, you could specify 3 values for <code>ns</code> and either one or three values for any of the other parameters, and three rasters would be created.</p>
</td></tr>
<tr><td><code id="sineRast+2B2CGRaster-method_+3A_mask">mask</code></td>
<td>
<p>Either <code>NULL</code> (default), or a <code>GRaster</code> or <code>GVector</code>: Used as a mask for the output. If this is a <code>GVector</code>, then only cells that are not <code>NA</code> in the mask have values. If this is a <code>GVector</code>, then only cells that overlap the vector have values assigned. All other values will be <code>NA</code>.</p>
</td></tr>
<tr><td><code id="sineRast+2B2CGRaster-method_+3A_verbose">verbose</code></td>
<td>
<p>Logical: If <code>TRUE</code>, display progress.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Elevation raster
madElev &lt;- fastData("madElev")

# Convert to GRaster:
elev &lt;- fast(madElev)

### Simple sine waves:
waves &lt;- sineRast(elev, ns = 2, ew = 1)
plot(waves)

### Sine waves with different amplitudes:
amps &lt;- sineRast(elev, nsAmp = c(1, 5), ewAmp = c(1, 5))
amps

### Sine waves with and without north-south offset:
noOffsets &lt;- sineRast(elev, ns = 1, ew = 1)
offsets &lt;- sineRast(elev, ns = 1, ew = 1, nsOffset = 0.25)
offs &lt;- c(noOffsets, offsets)
names(offs) &lt;- c("no offset", "offset")
plot(offs)

### Masking:
madCoast4 &lt;- fastData("madCoast4")
coast4 &lt;- fast(madCoast4, verbose = FALSE)

masked &lt;- sineRast(elev, mask = coast4)
plot(masked)

### Multiple sine waves (multiple rasters):
mults &lt;- sineRast(elev, ns = 1:2, ew = 1:2)
combos &lt;- sineRast(elev, ns = 1:2, ew = 1:2, combos = TRUE)
plot(mults)
plot(combos)

}
</code></pre>

<hr>
<h2 id='smoothGeom+2CGVector-method'>Smooth the geometry of a vector</h2><span id='topic+smoothGeom+2CGVector-method'></span><span id='topic+smoothGeom'></span>

<h3>Description</h3>

<p><code>smoothGeom()</code> makes line segments of a vector appear less angular.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector'
smoothGeom(x, method = "Hermite", dist = NULL, angle = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smoothGeom+2B2CGVector-method_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="smoothGeom+2B2CGVector-method_+3A_method">method</code></td>
<td>
<p>Character: Method used to smooth line segments. Partial matching is used, and case does not matter:
</p>

<ul>
<li> <p><code>"Hermite"</code>: Hermite interpolation (default): Guarantees that the output vector always passes through the original points. This method adds points (possibly many) by constructing cubic splines with points approximately <code>dist</code> apart. The number of points can be reduced by specifying a smaller value of <code>angle</code>, which specifies the minimum angle between two successive line segments.
</p>
</li>
<li> <p><code>"Chaiken"</code>: Chaiken's algorithm: Guarantees that the new vector always touches the midpoint of each original line segment. The points on the new line are at least <code>dist</code> apart.
</p>
</li></ul>
</td></tr>
<tr><td><code id="smoothGeom+2B2CGVector-method_+3A_dist">dist</code></td>
<td>
<p>Numeric &gt; 0 of <code>NULL</code> (default): Minimum distance (see <code>method</code>). Units are in map units. If <code>NULL</code>, then 2% of the minimum of the x-, y-, and z-extent will be used.</p>
</td></tr>
<tr><td><code id="smoothGeom+2B2CGVector-method_+3A_angle">angle</code></td>
<td>
<p>Numeric &gt; 0: Maximum angle for the Hermite algorithm. Default is 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simplifyGeom">simplifyGeom()</a></code>, <code><a href="terra.html#topic+simplify">terra::simplifyGeom()</a></code>, <a href="#topic+breakPolys">geometry cleaning</a>, <strong>GRASS</strong> manual page for module <code>v.generalize</code> (see <code>grassHelp("v.generalize")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Example data
madRivers &lt;- fastData("madRivers")
rivers &lt;- fast(madRivers)
soam &lt;- rivers[rivers$NAM == "SOAMIANINA"] # select one river for illustration

### Simplify geometry (remove nodes)

vr &lt;- simplifyGeom(soam, tolerance = 2000)
dp &lt;- simplifyGeom(soam, tolerance = 2000, method = "dp")
dpr &lt;- simplifyGeom(soam, tolerance = 2000, method = "dpr", prop = 0.5)
rw &lt;- simplifyGeom(soam, tolerance = 2000, method = "rw")

plot(soam, col = "black", lwd = 3)
plot(vr, col = "blue", add = TRUE)
plot(dp, col = "red", add = TRUE)
plot(dpr, col = "chartreuse", add = TRUE)
plot(rw, col = "orange", add = TRUE)

legend("bottom",
   xpd = NA,
   legend = c(
	  "Original",
      "Vertex reduction",
      "Douglas-Peucker",
      "Douglas-Peucker reduction",
      "Reumann-Witkam"
	),
	col = c("black", "blue", "red", "chartreuse", "orange"),
	lwd = c(3, 1, 1, 1, 1)
)

### Smooth geometry

hermite &lt;- smoothGeom(soam, dist = 2000, angle = 3)
chaiken &lt;- smoothGeom(soam, method = "Chaiken", dist = 2000)

plot(soam, col = "black", lwd = 2)
plot(hermite, col = "blue", add = TRUE)
plot(chaiken, col = "red", add = TRUE)

legend("bottom",
   xpd = NA,
   legend = c(
	  "Original",
      "Hermite",
      "Chaiken"
	),
	col = c("black", "blue", "red"),
	lwd = c(2, 1, 1, 1, 1)
)

### Clean geometry

# Has no effect on this vector!
noDangs &lt;- removeDangles(soam, tolerance = 10000)

plot(soam, col = "black", lwd = 2)
plot(noDangs, col = "red", add = TRUE)

legend("bottom",
   xpd = NA,
   legend = c(
	  "Original",
      "No dangles"
	),
	lwd = c(2, 1),
	col = c("black", "red")
)

}
</code></pre>

<hr>
<h2 id='sources+2CGRaster-method'>Name of a raster or vector in a GRASS session</h2><span id='topic+sources+2CGRaster-method'></span><span id='topic+sources'></span><span id='topic+sources+2CGVector-method'></span><span id='topic+sources+2Ccharacter-method'></span>

<h3>Description</h3>

<p><code>sources()</code> retrieves the name of a raster or vector in <strong>GRASS</strong>. <code>GRaster</code>s and <code>GVector</code>s are actually pointers to objects stored in a <strong>GRASS</strong> database. When using <strong>fasterRaster</strong> functions on rasters and vectors, the commands are translated into <strong>GRASS</strong> commands and executed on the objects named in the pointers. These objects use a &quot;source&quot; (which is really a filename) to refer to the <strong>GRASS</strong> objects. This function is mostly of use to developers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
sources(x)

## S4 method for signature 'GVector'
sources(x)

## S4 method for signature 'character'
sources(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sources+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>Either a <code>GSpatial</code> object or one that inherits from it (i.e., a <code>GRaster</code> or <code>GVector</code>), <em>or</em> a character. If a character, then the character itself is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")
madForest2000 &lt;- fastData("madForest2000")

# Convert SpatRasters to GRasters
elev &lt;- fast(madElev)
forest &lt;- fast(madForest2000)

### GRaster properties

# plotting
plot(elev)

# dimensions
dim(elev) # rows, columns, depths, layers
nrow(elev) # rows
ncol(elev) # columns
ndepth(elev) # depths
nlyr(elev) # layers

res(elev) # resolution (2D)
res3d(elev) # resolution (3D)
zres(elev) # vertical resolution
xres(elev) # vertical resolution
yres(elev) # vertical resolution
zres(elev) # vertical resolution (NA because this is a 2D GRaster)

# cell counts
ncell(elev) # cells
ncell3d(elev) # cells (3D rasters only)

# number of NA and non-NA cells
nacell(elev)
nonnacell(elev)

# topology
topology(elev) # number of dimensions
is.2d(elev) # is it 2-dimensional?
is.3d(elev) # is it 3-dimensional?

minmax(elev) # min/max values

# "names" of the object
names(elev)

# coordinate reference system
crs(elev)
st_crs(elev)
coordRef(elev)

# extent (bounding box)
ext(elev)

# vertical extent (not defined for this raster)
zext(elev)

# data type
datatype(elev) # fasterRaster type
datatype(elev, "GRASS") # GRASS type
datatype(elev, "terra") # terra type
datatype(elev, "GDAL") # GDAL type

is.integer(elev)
is.float(elev)
is.double(elev)
is.factor(elev)

# convert data type
as.int(elev) # integer; note that "elev" is already of type "integer"
as.float(elev) # floating-precision
as.doub(elev) # double-precision

# assigning
pie &lt;- elev
pie[] &lt;- pi # assign all cells to the value of pi
pie

# concatenating multiple GRasters
rasts &lt;- c(elev, forest)
rasts

# subsetting
rasts[[1]]
rasts[["madForest2000"]]

# replacing
rasts[[2]] &lt;- 2 * forest
rasts

# adding layers
rasts[[3]] &lt;- elev &gt; 500 # add a layer
rasts &lt;- c(rasts, sqrt(elev)) # add another
add(rasts) &lt;- ln(elev)
rasts

# names
names(rasts)
names(rasts) &lt;- c("elev_meters", "2_x_forest", "high_elevation", "sqrt_elev", "ln_elev")
rasts

# remove a layer
rasts[["2_x_forest"]] &lt;- NULL
rasts

# number of layers
nlyr(rasts)

# correlation and covariance matrices
madLANDSAT &lt;- fastData("madLANDSAT")
landsat &lt;- fast(madLANDSAT) # projects matrix
layerCor(landsat) # correlation
layerCor(landsat, fun = 'cov') # covariance

}
</code></pre>

<hr>
<h2 id='spatSample+2CGRaster-method'>Sample random points from a GRaster or GVector</h2><span id='topic+spatSample+2CGRaster-method'></span><span id='topic+spatSample'></span><span id='topic+spatSample+2CGVector-method'></span>

<h3>Description</h3>

<p><code>spatSample()</code> randomly locates points across a <code>GRaster</code> or <code>GVector</code>. It can return a <code>GVector</code>, the coordinates, values associated with the points, or all of these. If you want to generate a raster with randomly-sampled cells, see <code><a href="#topic+sampleRast">sampleRast()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
spatSample(
  x,
  size,
  as.points = FALSE,
  values = TRUE,
  cats = TRUE,
  xy = FALSE,
  strata = NULL,
  byStratum = FALSE,
  zlim = NULL,
  seed = NULL,
  verbose = FALSE
)

## S4 method for signature 'GVector'
spatSample(
  x,
  size,
  as.points = FALSE,
  values = TRUE,
  xy = FALSE,
  byStratum = FALSE,
  zlim = NULL,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spatSample+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> or <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="spatSample+2B2CGRaster-method_+3A_size">size</code></td>
<td>
<p>Numeric value &gt; 0: Number of points to create.</p>
</td></tr>
<tr><td><code id="spatSample+2B2CGRaster-method_+3A_as.points">as.points</code></td>
<td>
<p>Logical: If <code>FALSE</code> (default), the output is a <code>data.frame</code> or <code>data.table</code>. If <code>TRUE</code>, the output is a &quot;points&quot; <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="spatSample+2B2CGRaster-method_+3A_values">values</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), values of the <code>GRaster</code> at points are returned.</p>
</td></tr>
<tr><td><code id="spatSample+2B2CGRaster-method_+3A_cats">cats</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default) and the <code>GRaster</code> is categorical, then return the category label of each cell. If <code>values</code> is also <code>TRUE</code>, then the cell value will also be returned.</p>
</td></tr>
<tr><td><code id="spatSample+2B2CGRaster-method_+3A_xy">xy</code></td>
<td>
<p>Logical: If <code>TRUE</code>, return the longitude and latitude of each point. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="spatSample+2B2CGRaster-method_+3A_strata">strata</code></td>
<td>
<p>Either <code>NULL</code> (default), or a <code>GVector</code> defining strata. If supplied, the <code>size</code> argument will be interpreted as number of points to place per geometry in <code>strata</code>. Note that using strata can dramatically slow the process.</p>
</td></tr>
<tr><td><code id="spatSample+2B2CGRaster-method_+3A_bystratum">byStratum</code></td>
<td>
<p>Logical: If <code>FALSE</code> (default), then <code>size</code> number of points will be placed within the entire area delineated by <code>strata</code>. If <code>TRUE</code>, then <code>size</code> points will be placed within each subgeometry of <code>strata</code>.</p>
</td></tr>
<tr><td><code id="spatSample+2B2CGRaster-method_+3A_zlim">zlim</code></td>
<td>
<p>Either <code>NULL</code> (default), or a vector of two numbers defining the lower and upper altitudinal bounds of coordinates. This cannot be combined with <code>values = TRUE</code> or <code>cats = TRUE</code>.</p>
</td></tr>
<tr><td><code id="spatSample+2B2CGRaster-method_+3A_seed">seed</code></td>
<td>
<p>Either <code>NULL</code> (default) or an integer: Random number seed. If this is <code>NULL</code>, the a seed will be set randomly. Values will be rounded to the nearest integer.</p>
</td></tr>
<tr><td><code id="spatSample+2B2CGRaster-method_+3A_verbose">verbose</code></td>
<td>
<p>Logical: If <code>TRUE</code>, display progress. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>, <code>data.table</code>, or <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sampleRast">sampleRast()</a></code>, <code><a href="terra.html#topic+sample">terra::spatSample()</a></code>, module <code>v.random</code> in <strong>GRASS</strong>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Example data
madElev &lt;- fastData("madElev") # raster

# Convert to GRasters and GVectors
elev &lt;- fast(madElev)

### spatSample()

# Random points as data.frame or data.table:
randVals &lt;- spatSample(elev, size = 20, values = TRUE)
randVals

# Random points as a points GVector:
randPoints &lt;- spatSample(elev, size = 20, as.points = TRUE)
randPoints
plot(elev)
plot(randPoints, add = TRUE)

# Random points in a select area:
madCoast &lt;- fastData("madCoast4") # vector
coast &lt;- fast(madCoast)
ant &lt;- coast[coast$NAME_4 == "Antanambe"] # subset

restrictedPoints &lt;- spatSample(elev, size = 20, as.points = TRUE,
   strata = ant)

plot(elev)
plot(ant, add = TRUE)
plot(restrictedPoints, add = TRUE) # note 20 points for entire geometry

# Random points, one set per subgeometry:
stratifiedPoints &lt;- spatSample(elev, size = 20, as.points = TRUE,
   strata = ant, byStratum = TRUE)

plot(elev)
plot(ant, add = TRUE)
plot(stratifiedPoints, pch = 21, bg = "red", add = TRUE) # note 20 points per subgeometry

# Random categories:
madCover &lt;- fastData("madCover") # raster
cover &lt;- fast(madCover)

randCover &lt;- spatSample(cover, size = 20, values = TRUE,
     cat = TRUE, xy = TRUE)
randCover

### sampleRast()

# Random cells in non-NA cells:
rand &lt;- sampleRast(elev, 10000)
plot(rand)
nonnacell(rand)

# Use custom values for the mask:
randCustomMask &lt;- sampleRast(elev, 10000, maskvalues = 1:20)
plot(randCustomMask)

# Force selected values to a custom value:
randCustomUpdate &lt;- sampleRast(elev, 10000, updatevalue = 7)
plot(randCustomUpdate)

# Custom values for mask and set selected cells to custom value:
randAll &lt;- sampleRast(elev, 10000, maskvalues = 1:20, updatevalue = 7)
plot(randAll)

}
</code></pre>

<hr>
<h2 id='streams+2CGRaster-method'>Create stream network</h2><span id='topic+streams+2CGRaster-method'></span><span id='topic+streams'></span>

<h3>Description</h3>

<p>This function estimates the course of streams and rivers from an elevation raster. It is based on the <strong>GRASS</strong> module <code>r.stream.extract</code>, where more details can be found (see <code>grassHelp("r.stream.extract")</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
streams(
  x,
  accumulation = NULL,
  depression = NULL,
  flowThreshold = 1,
  dirThreshold = 1,
  montgomery = 0,
  minLength = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="streams+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> representing elevation.</p>
</td></tr>
<tr><td><code id="streams+2B2CGRaster-method_+3A_accumulation">accumulation</code></td>
<td>
<p>Either <code>NULL</code> (default) or a raster representing flow accumulation. If not supplied, an accumulation will created internally. You can generate an accumulation raster using <code><a href="#topic+flow">flow()</a></code>.</p>
</td></tr>
<tr><td><code id="streams+2B2CGRaster-method_+3A_depression">depression</code></td>
<td>
<p>Either <code>NULL</code> (default) or a <code>GRaster</code> representing depressions (areas from which streams will not flow out of).</p>
</td></tr>
<tr><td><code id="streams+2B2CGRaster-method_+3A_flowthreshold">flowThreshold</code></td>
<td>
<p>Numeric &gt; 0: Minimum threshold for a stream to be generated. The default is 1, which is not necessarily a reasonable value.</p>
</td></tr>
<tr><td><code id="streams+2B2CGRaster-method_+3A_dirthreshold">dirThreshold</code></td>
<td>
<p>Numeric (default is <code>Inf</code>): When flow exceeds this threshold, its direction is estimated using a single-flow direction algorithm. Below this threshold, a multi-direction flow model is used. This is the <code>d8cut</code> parameter in <code>r.stream.extract</code>, and it is only used if <code>accumulation</code> is <code>NULL</code>.  The default is 1, which is not necessarily a reasonable value.</p>
</td></tr>
<tr><td><code id="streams+2B2CGRaster-method_+3A_montgomery">montgomery</code></td>
<td>
<p>Numeric: The &quot;Montgomery&quot; exponent for slope, multiplied by accumulation as per <code>accumulation * slope^montgomery</code>. This value is then compared to the threshold to determine if it is sufficient. The default is 0 (i.e., no slope scaling).</p>
</td></tr>
<tr><td><code id="streams+2B2CGRaster-method_+3A_minlength">minLength</code></td>
<td>
<p>Numeric: First-order streams less than this length are removed (units in cells). Default is 0 (no removal).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flow">flow()</a></code>, <code><a href="#topic+flowPath">flowPath()</a></code>, <strong>GRASS</strong> manual for module <code>r.stream.extract</code> (see <code>grassHelp("r.stream.extract")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")

# Convert a SpatRaster to a GRaster
elev &lt;- fast(madElev)

# Calculate stream channels
streams &lt;- streams(elev)
plot(streams)

}
</code></pre>

<hr>
<h2 id='stretch+2CGRaster-method'>Rescale values in a GRaster</h2><span id='topic+stretch+2CGRaster-method'></span><span id='topic+stretch'></span>

<h3>Description</h3>

<p><code>stretch()</code> rescales the values in a <code>GRaster</code>. All values can be rescaled, or just values in a user-defined range. This range can be given by specifying either the lower and upper bounds of the range using <code>smin</code> and <code>smax</code>, and/or by the quantiles (across all cells of the raster) using <code>minq</code> and <code>maxq</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
stretch(x, minv = 0, maxv = 255, minq = 0, maxq = 1, smin = NA, smax = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stretch+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="stretch+2B2CGRaster-method_+3A_minv">minv</code>, <code id="stretch+2B2CGRaster-method_+3A_maxv">maxv</code></td>
<td>
<p>Numeric: Minimum and maximum values to which to rescale values.</p>
</td></tr>
<tr><td><code id="stretch+2B2CGRaster-method_+3A_minq">minq</code>, <code id="stretch+2B2CGRaster-method_+3A_maxq">maxq</code></td>
<td>
<p>Numeric: Specifies range of values to rescale, given by their quantiles. The default is to stretch all values (the 0th and 100th quantiles). One or both are  ignored if <code>smin</code> and/or <code>smax</code> are provided.</p>
</td></tr>
<tr><td><code id="stretch+2B2CGRaster-method_+3A_smin">smin</code>, <code id="stretch+2B2CGRaster-method_+3A_smax">smax</code></td>
<td>
<p>Numeric or <code>NA</code>: Specifies range of values to rescale. If <code>NA</code> (default), then all values are rescaled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+stretch">terra::stretch()</a></code> and module <code>r.rescale</code> in <strong>GRASS</strong> (not used on this function)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")

# Convert a SpatRaster to a GRaster
elev &lt;- fast(madElev)

### Stretch based on user-defined range

#  fasterRaster
fr &lt;- stretch(elev, smin=1, smax=100)
fr

# terra
tr &lt;- stretch(madElev, smin = 1, smax = 100)
tr

# Compare fasterRaster to terra output
fr &lt;- rast(fr)
fr &lt;- extend(fr, tr)
fr - tr

### Stretch values in a certain quantile range

#  fasterRaster
fr &lt;- stretch(elev, minq = 0.25, maxq = 0.75)
fr

# terra
tr &lt;- stretch(madElev, minq = 0.25, maxq = 0.75)
tr

# Compare fasterRaster to terra output
fr &lt;- rast(fr)
fr &lt;- extend(fr, tr)
fr - tr

}
</code></pre>

<hr>
<h2 id='subset+2CGRaster-method'>Subset layers from a GRaster, or specific rows from a GVector</h2><span id='topic+subset+2CGRaster-method'></span><span id='topic+subset'></span><span id='topic+subset+2CGVector-method'></span>

<h3>Description</h3>

<p><code>subset()</code> can be used to subset or remove one or more layers from a <code>GRaster</code>. It can also be used to subset or remove rows from a <code>GVector</code> with a data table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
subset(x, subset, negate = FALSE)

## S4 method for signature 'GVector'
subset(x, subset, negate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> or <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="subset+2B2CGRaster-method_+3A_subset">subset</code></td>
<td>
<p>Numeric integer, integer, logical, or character: Indicates the layer(s) of a <code>GRaster</code> to subset, or the rows(s) of a <code>GVector</code> to return.</p>
</td></tr>
<tr><td><code id="subset+2B2CGRaster-method_+3A_negate">negate</code></td>
<td>
<p>Logical: If <code>TRUE</code>, all layers or rows in <code>subset</code> will be <em>removed</em> from the output. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code> or <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic++5B+5B">[[</a></code>, <code><a href="#topic++5B">[</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

### GRasters

# Example data
madElev &lt;- fastData("madElev") # elevation raster
madForest2000 &lt;- fastData("madForest2000") # forest raster
madForest2014 &lt;- fastData("madForest2014") # forest raster

# Convert SpatRasters to GRasters
elev &lt;- fast(madElev)
forest2000 &lt;- fast(madForest2000)
forest2014 &lt;- fast(madForest2014)

# Re-assigning values of a GRaster
constant &lt;- elev
constant[] &lt;- pi
names(constant) &lt;- "pi_raster"
constant

# Re-assigning specific values of a raster
replace &lt;- elev
replace[replace == 1] &lt;- -20
replace

# Subsetting specific values of a raster based on another raster
elevInForest &lt;- elev[forest2000 == 1]
plot(c(elev, forest2000, elevInForest), nr = 1)

# Adding and replacing layers of a GRaster
rasts &lt;- c(elev, constant, forest2000)

# Combine with another layer:
add(rasts) &lt;- forest2014 # one way
rasts

rasts &lt;- c(rasts, forest2014) # another way

### Subsetting GRaster layers

# Subset:
rasts &lt;- c(elev, forest2000, forest2014)
rasts[[2:3]]
subset(rasts, 2:3)
subset(rasts, c("madForest2000", "madElev"))
rasts[[c("madForest2000", "madElev")]]
rasts$madForest2000

# Get every other layer:
rasts[[c(FALSE, TRUE)]]

### Replacing layers of a GRaster

# Replace a layer
logElev &lt;- log(elev)
names(logElev) &lt;- "logElev"
rasts$madForest2014 &lt;- logElev
rasts

# Replace a layer:
rasts[[3]] &lt;- forest2000
rasts

### GVectors

# example data
madDypsis &lt;- fastData("madDypsis") # vector of points

# Convert SpatVector to GVector
dypsis &lt;- fast(madDypsis)

### Retrieving GVector columns

dypsis$species # Returns the column

dypsis[[c("year", "species")]] # Returns a GRaster with these columns
dypsis[ , c("year", "species")] # Same as above

### Subsetting GVector geometries

# Subset first three geometries
dypsis[1:3]
dypsis[1:3, "species"]

# Get geometries by data table condition
dypsis[dypsis$species == "Dypsis betsimisarakae"]

### (Re)assigning GVector column values

# New column
dypsis$pi &lt;- pi

# Re-assign values
dypsis$pi &lt;- "pie"

# Re-assign specific values
dypsis$institutionCode[dypsis$institutionCode == "MO"] &lt;-
   "Missouri Botanical Garden"

}
</code></pre>

<hr>
<h2 id='subst+2CGRaster-method'>Replace a specific value(s) in a GRaster</h2><span id='topic+subst+2CGRaster-method'></span><span id='topic+subst'></span>

<h3>Description</h3>

<p>This function replaces one or more user-specified values in a raster with other values. See <code><a href="#topic+classify">classify()</a></code> for replacing ranges of values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
subst(x, from, to, others = NULL, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subst+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="subst+2B2CGRaster-method_+3A_from">from</code>, <code id="subst+2B2CGRaster-method_+3A_to">to</code></td>
<td>
<p>Vectors of numeric or character values. The value(s) in <code>from</code> will be replaced with the value(s) in <code>to</code>. They must be the same length, or, if you supply a single value for <code>to</code>, then all values in <code>from</code> will be converted to the same value of <code>to</code>. Numeric/integer or character vectors can be used:
</p>

<ul>
<li> <p><code>from</code> and <code>to</code> are numeric or integer vectors: Values in <code>from</code> will be replaced by their corresponding value in <code>to</code>.
</p>
</li>
<li> <p><code>from</code> and <code>to</code> are character vectors: You can use a character vector for <code>from</code> and <code>to</code>. In this case, the input raster must be a factor (categorical) raster or an integer raster. If <code>from</code> is a character vector, these levels(categories) will be replaced by the levels in <code>to.</code> This can add levels to a <code>GRaster</code> <code>to</code> has labels that do not match any existing labels in <code>from</code>.
</p>
</li>
<li> <p><code>from</code> is a character vector and <code>to</code> is an integer vector: Cells in <code>x</code> that correspond to the given label will have their values replaced by the corresponding value in <code>to</code>, and be matched the the corresponding label. If no label corresponds to the new value, a new level will be created. The input must be a categorical raster.
</p>
</li>
<li> <p><code>from</code> is an integer vector and <code>to</code> is a character vector: Cells in <code>x</code> that have a value in <code>from</code> will be replaced by values that match the labels in <code>to</code>. If the input raster does not have a value that corresponds to the given label in <code>y</code>, then a new value will be created.
</p>
</li></ul>
</td></tr>
<tr><td><code id="subst+2B2CGRaster-method_+3A_others">others</code></td>
<td>
<p><code>NULL</code> (default), <code>NA</code>, numeric, or a character:
</p>

<ul>
<li> <p><code>NULL</code> (default): Values that do not appear in <code>from</code> will be unchanged.
</p>
</li>
<li> <p><code>NA</code>: Values that do not appear in <code>from</code> will be set to <code>NA</code>.
</p>
</li>
<li><p> Character: Cells in <code>x</code> that do not appear in <code>to</code> will be assigned to this level. In this case, <code>x</code> must be a categorical (factor) raster.
</p>
</li></ul>
</td></tr>
<tr><td><code id="subst+2B2CGRaster-method_+3A_warn">warn</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), display a warning when new levels are created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+subst">terra::subst()</a></code>, <code><a href="#topic+classify">classify()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")
madCover &lt;- fastData("madCover")

### Substitution within an integer/numeric raster

# Convert SpatRaster to GRaster
elev &lt;- fast(madElev)

# Simple substitution of one value, keeping all other values
newElev &lt;- elev
newElev[newElev == 100] &lt;- -100
newElev[newElev &gt; 500] &lt;- 500
hist(newElev)

# Simple substitution of one value, keeping all other values
substituted &lt;- subst(elev, from = 300, to = -300)
substituteds &lt;- c(elev, substituted)
names(substituteds) &lt;- c("original", "substituted")
plot(substituteds)

# Simple substitution of three values, keeping all other values
substituted &lt;- subst(elev, from = c(299, 300, 301), to = c(-699, -600, -601))
substituteds &lt;- c(elev, substituted)
names(substituteds) &lt;- c("original", "substituted")
plot(substituteds)

# Simple substitution of three values to one other value, retaining remainder
substituted &lt;- subst(elev, from = c(299, 300, 301), to = -1000)
substituteds &lt;- c(elev, substituted)
names(substituteds) &lt;- c("original", "substituted")
plot(substituteds)

# Simple substitution of one value, setting all other values to 100
substituted &lt;- subst(elev, from = 300, to = -300, others = 100)
substituteds &lt;- c(elev, substituted)
names(substituteds) &lt;- c("original", "substituted")
plot(substituteds)

### Substitution within a factor/categorical raster

# Convert a SpatRaster to a GRaster:
cover &lt;- fast(madCover)

cover &lt;- droplevels(cover) # remove unused levels
levels(cover) # levels of "cover"

# Substitute using level name, replace with EXISTING level label
from &lt;- "Mosaic cropland/vegetation"
to &lt;- "Mosaic crops"
categ &lt;- subst(cover, from = from, to = to)
freq(cover) # original frequencies of each land cover class
freq(categ) # note change in frequency of "from" and "to" categories
plot(c(cover, categ))

# Substitute using level name, replace with NEW level label
from &lt;- c("Mosaic crops", "Mosaic cropland/vegetation")
to &lt;- c("Mixed cropland")
categ &lt;- subst(cover, from = from, to = to)
freq(cover) # original frequencies of each land cover class
freq(categ) # note change in frequency of "from" and "to" categories
plot(c(cover, categ))

# Substitute using level name, replace with NEW level label
from &lt;- c("Mosaic crops", "Mosaic cropland/vegetation")
to &lt;- c("Mixed cropland", "Mixed cropland/vegetation")
categ &lt;- subst(cover, from = from, to = to)
freq(cover) # original frequencies of each land cover class
freq(categ) # note change in frequency of "from" and "to" categories
plot(c(cover, categ))

# Substitute using level name, replace with VALUE of an existing label
from &lt;- c("Mosaic crops", "Mosaic cropland/vegetation")
to &lt;- 120
categ &lt;- subst(cover, from = from, to = to)
freq(cover) # original frequencies of each land cover class
freq(categ) # note change in frequency of "from" and "to" categories
plot(c(cover, categ))

# Substitute using level name, replace with new level name, replace all others
from &lt;- c("Mosaic crops", "Mosaic cropland/vegetation")
to &lt;- "Crops"
categ &lt;- subst(cover, from = from, to = to, others = "Other")
freq(cover) # original frequencies of each land cover class
freq(categ) # note change in frequency of "from" and "to" categories
plot(c(cover, categ))

}
</code></pre>

<hr>
<h2 id='sun'>Solar radiance and irradiance</h2><span id='topic+sun'></span>

<h3>Description</h3>

<p>The <code>sun()</code> function calculates beam (direct), diffuse and ground reflected solar irradiation for a given day and set of topographic and atmospheric conditions. The function relies on the <strong>GRASS</strong> module <code>r.sun</code>, the manual page for which contains a detailed explanation (see <code>grassHelp("r.sun")</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sun(
  elevation,
  coeff_bh,
  coeff_dh,
  slope,
  aspect,
  hh,
  horizon_step = 90,
  albedo = 0.2,
  linke = 3,
  day = 1,
  step = 0.5,
  declination = NULL,
  solar_constant = 1367,
  distance_step = 1,
  npartitions = 1,
  beam_rad = TRUE,
  diff_rad = TRUE,
  refl_rad = TRUE,
  glob_rad = TRUE,
  insol_time = TRUE,
  lowMemory = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sun_+3A_elevation">elevation</code></td>
<td>
<p>A <code>GRaster</code> with values representing elevation (typically in meters).</p>
</td></tr>
<tr><td><code id="sun_+3A_coeff_bh">coeff_bh</code></td>
<td>
<p>A <code>GRaster</code>: A raster with values of the real-sky beam radiation coefficient. Valid values are between 0 and 1.</p>
</td></tr>
<tr><td><code id="sun_+3A_coeff_dh">coeff_dh</code></td>
<td>
<p>A <code>GRaster</code>: A raster with values of the real-sky diffuse radiation coefficient. Valid values are between 0 and 1.</p>
</td></tr>
<tr><td><code id="sun_+3A_slope">slope</code></td>
<td>
<p>A <code>GRaster</code>: This is a raster representing topographic slope in radians. It can be generated using <code><a href="#topic+terrain">terrain()</a></code>.</p>
</td></tr>
<tr><td><code id="sun_+3A_aspect">aspect</code></td>
<td>
<p>A <code>GRaster</code>: This is a raster representing topographic aspect in degrees. It can be generated using <code><a href="#topic+terrain">terrain()</a></code>. If generated with that function, &quot;east orientation&quot; <em>must</em> be used (i.e., argument <code>northIs0</code> must be <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="sun_+3A_hh">hh</code></td>
<td>
<p>A &quot;stack&quot; of <code>GRaster</code>s: This represents height of the horizon in radians in particular directions. Horizon height can be calculated using <code><a href="#topic+horizonHeight">horizonHeight()</a></code>. The directions <em>must</em> be in &quot;east orientation&quot; (i.e., argument <code>northIs0</code> in <code>horzionHeight()</code> must be <code>FALSE</code>). The directions must correspond with the sequence given by <code>horizon_step</code> (see next argument). For example, if <code>horizon_step</code> is 90, then <code>hh</code> must contain rasters representing horizon height at 0 (east), 90 (north), 180 (west), and 270 (south) aspects.
#'</p>
</td></tr>
<tr><td><code id="sun_+3A_horizon_step">horizon_step</code></td>
<td>
<p>Numeric &gt;0: Difference between angular steps in which horizon height is measured. One horizon height raster will be made per value from 0 to 360 - <code>horizon_step</code> degrees.</p>
</td></tr>
<tr><td><code id="sun_+3A_albedo">albedo</code></td>
<td>
<p>A <code>GRaster</code> or a numeric value: This is either a raster with values of ground albedo or a numeric value (in which case albedo is assumed to be the same everywhere). Albedo is unit-less, and the default value is 0.2.</p>
</td></tr>
<tr><td><code id="sun_+3A_linke">linke</code></td>
<td>
<p>A <code>GRaster</code> or a numeric value: This is either a raster with values of the Linke atmospheric turbidity coefficient or a numeric value (in which case the same value is assumed for all locations). The Linke coefficient is unit-less. The default value is 3, but see also the <strong>GRASS</strong> manual page for module <code>r.sun</code> (<code>grassHelp("r.sun")</code>).</p>
</td></tr>
<tr><td><code id="sun_+3A_day">day</code></td>
<td>
<p>Positive integer between 1 to 365, inclusive: Day of year for which to calculate ir/radiation. Default is 1 (January 1st).</p>
</td></tr>
<tr><td><code id="sun_+3A_step">step</code></td>
<td>
<p>Positive integer between 0 and 24, inclusive. Time step in hours for all-day radiation sums. Decimal values are OK.</p>
</td></tr>
<tr><td><code id="sun_+3A_declination">declination</code></td>
<td>
<p>Numeric or <code>NULL</code> (default). Declination value. If <code>NULL</code>, this is calculated automatically.</p>
</td></tr>
<tr><td><code id="sun_+3A_solar_constant">solar_constant</code></td>
<td>
<p>Positive numeric: The solar constant (solar energy hitting the top of the atmosphere). Default is 1367. Units are W / m^2.</p>
</td></tr>
<tr><td><code id="sun_+3A_distance_step">distance_step</code></td>
<td>
<p>Positive numeric between 0.5 and 1.5, inclusive: Sampling distance coefficient. Default is 1.</p>
</td></tr>
<tr><td><code id="sun_+3A_npartitions">npartitions</code></td>
<td>
<p>Positive numeric. Number of chunks in which to read input files. Default is 1.</p>
</td></tr>
<tr><td><code id="sun_+3A_beam_rad">beam_rad</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), generate a raster with beam irradiation with units of Wh / m^2 / day (&quot;mode 2&quot; of the <code>r.sun</code> <strong>GRASS</strong> module).</p>
</td></tr>
<tr><td><code id="sun_+3A_diff_rad">diff_rad</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), generate a raster representing irradiation in Wh / m^2 /day</p>
</td></tr>
<tr><td><code id="sun_+3A_refl_rad">refl_rad</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), generate a raster with ground-reflected irradiation with units of Wh / m^2 / day (&quot;mode 2&quot; of the <code>r.sun</code> <strong>GRASS</strong> module).</p>
</td></tr>
<tr><td><code id="sun_+3A_glob_rad">glob_rad</code></td>
<td>
<p>Logical:. If <code>TRUE</code> (default), generate a raster with total irradiance/irradiation with units of Wh / m^2 / day (&quot;mode 2&quot; of the <code>r.sun</code> <strong>GRASS</strong> module).</p>
</td></tr>
<tr><td><code id="sun_+3A_insol_time">insol_time</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), generate a raster with total insolation time in hours (&quot;mode 2&quot; of the <code>r.sun</code> <strong>GRASS</strong> module).</p>
</td></tr>
<tr><td><code id="sun_+3A_lowmemory">lowMemory</code></td>
<td>
<p>Logical: If <code>TRUE</code>, use the low-memory version of the <code>r.sun</code> <strong>GRASS</strong> module. The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A raster or raster stack stack with the same extent, resolution, and coordinate reference system as <code>elevation</code>. Assuming all possible rasters are generated they represent:
</p>

<ul>
<li> <p><code>beam_rad</code>: Beam radiation (Watt-hours/m2/day)
</p>
</li>
<li> <p><code>diff_rad</code>: Diffuse radiation (Watt-hours/m2/day)
</p>
</li>
<li> <p><code>refl_rad</code>: Reflected radiation (Watt-hours/m2/day)
</p>
</li>
<li> <p><code>glob_rad</code>: Global radiation (Watt-hours/m2/day)
</p>
</li>
<li> <p><code>insol_time</code>: Insolation duration (hours)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+terrain">terrain()</a></code>, <code><a href="#topic+horizonHeight">horizonHeight()</a></code>, <strong>GRASS</strong> manual page for module <code>r.sun</code> (see <code>grassHelp("r.sun")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")

# Convert a SpatRaster to a GRaster
elev &lt;- fast(madElev)

### Calculate input rasters

# Values below are just a guess
coeff_bh &lt;- coeff_dh &lt;- elev
coeff_bh[] &lt;- 0.4
coeff_dh[] &lt;- 0.6

slope &lt;- terrain(elev, "slope")
aspect &lt;- terrain(elev, "aspect", northIs0 = FALSE)

horizon_step &lt;- 90
hh &lt;- horizonHeight(elev, step = horizon_step, northIs0 = FALSE)

### calculate solar ir/radiance

solar &lt;- sun(
	elevation = elev,
	coeff_bh = coeff_bh,
	coeff_dh = coeff_dh,
	slope = slope,
	aspect = aspect,
	hh = hh,
	horizon_step = horizon_step,
	albedo = 0.2,
	linke = 1.5,
	day = 1,
	step = 0.5,
	declination = NULL,
	solar_constant = 1367,
	
	distance_step = 1,
	npartitions = 1,

	beam_rad = TRUE,
	diff_rad = TRUE,
	refl_rad = TRUE,
	glob_rad = TRUE,
	insol_time = TRUE,

	lowMemory = FALSE
)

solar

}
</code></pre>

<hr>
<h2 id='terrain+2CGRaster-method'>Slope, aspect, curvature, and partial slopes</h2><span id='topic+terrain+2CGRaster-method'></span><span id='topic+terrain'></span>

<h3>Description</h3>

<p><code>terrain()</code> calculates topographic indices, including slope, aspect, curvature, and partial slopes (slopes in the east-west or north-south directions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
terrain(
  x,
  v = "slope",
  units = "degrees",
  undefinedAspect = NA,
  northIs0 = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="terrain+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> (typically representing elevation).</p>
</td></tr>
<tr><td><code id="terrain+2B2CGRaster-method_+3A_v">v</code></td>
<td>
<p>Name of the topographic metric(s) to calculate. Valid values include one or more of:
</p>

<ul>
<li> <p><code>"slope"</code>: Slope. Units are given by argument <code>units</code>.
</p>
</li>
<li> <p><code>"aspect"</code>: Aspect. When argument <code>northIs0</code> is <code>TRUE</code> (default), then aspect is given in degrees from north going clockwise (0 = north, 90 = east, 180 = south, 270 = west).  Units are given by argument <code>units</code>.
</p>
</li>
<li> <p><code>"profileCurve"</code>: Profile curvature.
</p>
</li>
<li> <p><code>"tanCurve"</code>: Tangential curvature.
</p>
</li>
<li> <p><code>"dx"</code>: Slope in east-west direction.
</p>
</li>
<li> <p><code>"dy"</code>: Slope in north-south direction.
</p>
</li>
<li> <p><code>"dxx"</code>: Second partial derivative in east-west direction.
</p>
</li>
<li> <p><code>"dyy"</code>: Second partial derivative in north-south direction.
</p>
</li>
<li> <p><code>"dxy"</code>: Second partial derivative along east-west and north-south direction.
</p>
</li>
<li> <p><code>"*"</code>: All of the above.
</p>
</li></ul>
</td></tr>
<tr><td><code id="terrain+2B2CGRaster-method_+3A_units">units</code></td>
<td>
<p>Character: &quot;Units&quot; in which to calculate slope and aspect: either <code>"degrees"</code> for degrees (default), <code>"radians"</code>, or <code>"percent"</code>. Partial matching is used.</p>
</td></tr>
<tr><td><code id="terrain+2B2CGRaster-method_+3A_undefinedaspect">undefinedAspect</code></td>
<td>
<p>Numeric or <code>NA</code> (default): Value to assign to flat areas for which aspect cannot be calculated.</p>
</td></tr>
<tr><td><code id="terrain+2B2CGRaster-method_+3A_northis0">northIs0</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), aspect will be reported in &quot;north orientation,&quot; such that 0 is north, and degrees run clockwise (90 is east, 180 south, 270 west). If <code>FALSE</code>, then aspect will be reported in &quot;east orientation,&quot; such that 0 is east, and degrees run counterclockwise (90 is north, 180 west, 270 south). The latter is the default in <strong>GRASS</strong>, but the former is the default in <code><a href="terra.html#topic+terrain">terra::terrain()</a></code> function, so is used here as the default. <strong>Note:</strong> The <code><a href="#topic+sun">sun()</a></code> function requires aspect to be in east orientation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code> with one or more layers.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+terrain">terra::terrain()</a></code>, <code><a href="#topic+ruggedness">ruggedness()</a></code>, <code><a href="#topic+wetness">wetness()</a></code>, <code><a href="#topic+geomorphons">geomorphons()</a></code>, module <code>r.slope.aspect</code> in <strong>GRASS</strong>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")

# Convert a SpatRaster to a GRaster
elev &lt;- fast(madElev)

# Calculate all topographic metrics
topos &lt;- terrain(elev, v = "*")
topos

plot(topos) # NB Aspect has values of NA when it cannot be defined

# Calculate a hillshade raster
hs &lt;- hillshade(elev)
plot(hs)

}
</code></pre>

<hr>
<h2 id='thinLines+2CGRaster-method'>Reduce linear features on a raster so linear features are 1 cell wide</h2><span id='topic+thinLines+2CGRaster-method'></span><span id='topic+thinLines'></span>

<h3>Description</h3>

<p>The <code>thinLines()</code> function attempts to reduce linear features on a raster to just 1 cell wide. You may need to run <code>thinLines()</code> multiple times on the same raster (or experiment with the <code>iter</code> argument) to get acceptable output. <code>thinLines()</code> can be helpful to run on a raster before using <code><a href="#topic+as.lines">as.lines()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
thinLines(x, iter = 200)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="thinLines+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="thinLines+2B2CGRaster-method_+3A_iter">iter</code></td>
<td>
<p>Numeric integer: Number of iterations (default is 200).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.lines">as.lines()</a></code>, <strong>GRASS</strong> manual page for module <code>r.thin</code> (see <code>grassHelp("r.thin")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Elevation
madElev &lt;- fastData("madElev")

# Convert to GRaster:
elev &lt;- fast(madElev)

# Thin elevation raster:
thinned &lt;- thinLines(elev, iter = 300)
plot(thinned)

# Convert to lines:
rastToLines &lt;- as.lines(thinned)
plot(rastToLines)

# We can clean this:
cleanLines &lt;- fixDangles(x = rastToLines)
plot(rastToLines, col = "red")
plot(cleanLines, add = TRUE)

}
</code></pre>

<hr>
<h2 id='thinPoints+2CGVector+2CGRaster-method'>Reduce number of points in same raster cell</h2><span id='topic+thinPoints+2CGVector+2CGRaster-method'></span><span id='topic+thinPoints'></span>

<h3>Description</h3>

<p>This function thins a &quot;points&quot; <code>GVector</code> so that it has no more than <code>n</code> points per grid cell in a raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector,GRaster'
thinPoints(x, y, n = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="thinPoints+2B2CGVector+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A &quot;points&quot; <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="thinPoints+2B2CGVector+2B2CGRaster-method_+3A_y">y</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="thinPoints+2B2CGVector+2B2CGRaster-method_+3A_n">n</code></td>
<td>
<p>Integer or numeric integer: Maximum number of points to remain in a cell. The default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;points&quot; <code>GVector</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Elevation and points
madElev &lt;- fastData("madElev")
madDypsis &lt;- fastData("madDypsis")

# Convert to fasterRaster formats:
elev &lt;- fast(madElev)
dypsis &lt;- fast(madDypsis)

# Aggregate cells of the raster so they are bigger
elevAgg &lt;- aggregate(elev, 32)

# Remove all but one or two points per cell
thin1 &lt;- thinPoints(dypsis, elevAgg, n = 1)
thin2 &lt;- thinPoints(dypsis, elevAgg, n = 2)

# Plot
plot(elevAgg)
plot(dypsis, add = TRUE)
plot(thin2, col = "yellow", add = TRUE)
plot(thin1, col = "red", add = TRUE)
legend(
   "bottomright",
   legend = c("In original &amp; thin 1 &amp; 2",
     "In just thin 1 &amp; 2", "In just thin 1"),
   pch = 16,
   col = c("black", "yellow", "red"),
   bg = "white",
   xpd = NA
)

}
</code></pre>

<hr>
<h2 id='tiles+2CGRaster-method'>Divide a GRaster into spatially exclusive subsets</h2><span id='topic+tiles+2CGRaster-method'></span><span id='topic+tiles'></span>

<h3>Description</h3>

<p>This function divides a <code>GRaster</code> into &quot;tiles&quot; or spatial subsets which can be used for speeding some raster calculations. Tiles can be mutually exclusive or overlap by a user-defined number of cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
tiles(x, n, overlap = 0, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tiles+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> with one or more layers.</p>
</td></tr>
<tr><td><code id="tiles+2B2CGRaster-method_+3A_n">n</code></td>
<td>
<p>Numeric vector: Number of tiles to create. This can be a single number, in which case <code>x</code> is divided into <code>n</code> × <code>n</code> tiles, or two values in which case it is divided into <code>n[1]</code> × <code>n[2]</code> tiles (rows x columns).</p>
</td></tr>
<tr><td><code id="tiles+2B2CGRaster-method_+3A_overlap">overlap</code></td>
<td>
<p>Numeric vector (default is 0): Number of rows/columns by which to expand the size of tiles so they overlap. This can be a single value or two values. If just one is provided, the tiles will be expanded by <code>overlap</code> rows and <code>overlaps</code> columns. If two numbers are provided, the tiles will be expanded by <code>overlap[1]</code> rows and <code>overlap[2]</code> columns.</p>
</td></tr>
<tr><td><code id="tiles+2B2CGRaster-method_+3A_verbose">verbose</code></td>
<td>
<p>Logical: If <code>TRUE</code>, display progress. Default is <code>FALSE</code>. Progress is only displayed if <code>x</code> is a multi-layer <code>GRaster</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> has just one layer, then the output is a <code>list</code> with one element per tile. The <code><a href="base.html#topic+lapply">lapply()</a></code> and <code><a href="base.html#topic+sapply">sapply()</a></code> functions can be used to apply functions to each tile in the list. If <code>x</code> has more than one layer, then the output will be a <code>list</code> of <code>list</code>s, with each sub-<code>list</code> containing the tiles for one <code>GRaster</code> layer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Elevation raster
madElev &lt;- fastData("madElev")

# Convert a SpatRaster to a GRaster:
elev &lt;- fast(madElev)

# Create spatially exclusive tiles:
exclusive &lt;- tiles(elev, n = 2, verbose = TRUE)

startpar &lt;- par(mfrow = c(2, 3))
plot(elev, main = "Original")

for (i in seq_along(exclusive)) {
	plot(exclusive[[i]], ext = elev, main = paste("Tile", i))
}
par(startpar)

# Create tiles that overlap:
overlaps &lt;- tiles(elev, n = 2, overlap = 200, verbose = TRUE)

startpar &lt;- par(mfrow = c(2, 3))
plot(elev, main = "Original")

for (i in seq_along(overlaps)) {
	plot(overlaps[[i]], ext = elev, main = paste("Tile", i))
}
par(startpar)

}
</code></pre>

<hr>
<h2 id='topology+2CGSpatial-method'>Topology (2- or 3-dimensions) of a GRaster or GVector</h2><span id='topic+topology+2CGSpatial-method'></span><span id='topic+topology'></span>

<h3>Description</h3>

<p><code>GRaster</code>s and <code>GVector</code>s can have 2-dimensional or 3-dimensional coordinates. This function returns the dimensions of the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GSpatial'
topology(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="topology+2B2CGSpatial-method_+3A_x">x</code></td>
<td>
<p>A <code>GSpatial</code> object (i.e., a <code>GRaster</code> or <code>GVector</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either &quot;2D&quot; or &quot;3D&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.2d">is.2d()</a></code>, <code><a href="#topic+is.3d">is.3d()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")
madForest2000 &lt;- fastData("madForest2000")

# Convert SpatRasters to GRasters
elev &lt;- fast(madElev)
forest &lt;- fast(madForest2000)

### GRaster properties

# plotting
plot(elev)

# dimensions
dim(elev) # rows, columns, depths, layers
nrow(elev) # rows
ncol(elev) # columns
ndepth(elev) # depths
nlyr(elev) # layers

res(elev) # resolution (2D)
res3d(elev) # resolution (3D)
zres(elev) # vertical resolution
xres(elev) # vertical resolution
yres(elev) # vertical resolution
zres(elev) # vertical resolution (NA because this is a 2D GRaster)

# cell counts
ncell(elev) # cells
ncell3d(elev) # cells (3D rasters only)

# number of NA and non-NA cells
nacell(elev)
nonnacell(elev)

# topology
topology(elev) # number of dimensions
is.2d(elev) # is it 2-dimensional?
is.3d(elev) # is it 3-dimensional?

minmax(elev) # min/max values

# "names" of the object
names(elev)

# coordinate reference system
crs(elev)
st_crs(elev)
coordRef(elev)

# extent (bounding box)
ext(elev)

# vertical extent (not defined for this raster)
zext(elev)

# data type
datatype(elev) # fasterRaster type
datatype(elev, "GRASS") # GRASS type
datatype(elev, "terra") # terra type
datatype(elev, "GDAL") # GDAL type

is.integer(elev)
is.float(elev)
is.double(elev)
is.factor(elev)

# convert data type
as.int(elev) # integer; note that "elev" is already of type "integer"
as.float(elev) # floating-precision
as.doub(elev) # double-precision

# assigning
pie &lt;- elev
pie[] &lt;- pi # assign all cells to the value of pi
pie

# concatenating multiple GRasters
rasts &lt;- c(elev, forest)
rasts

# subsetting
rasts[[1]]
rasts[["madForest2000"]]

# replacing
rasts[[2]] &lt;- 2 * forest
rasts

# adding layers
rasts[[3]] &lt;- elev &gt; 500 # add a layer
rasts &lt;- c(rasts, sqrt(elev)) # add another
add(rasts) &lt;- ln(elev)
rasts

# names
names(rasts)
names(rasts) &lt;- c("elev_meters", "2_x_forest", "high_elevation", "sqrt_elev", "ln_elev")
rasts

# remove a layer
rasts[["2_x_forest"]] &lt;- NULL
rasts

# number of layers
nlyr(rasts)

# correlation and covariance matrices
madLANDSAT &lt;- fastData("madLANDSAT")
landsat &lt;- fast(madLANDSAT) # projects matrix
layerCor(landsat) # correlation
layerCor(landsat, fun = 'cov') # covariance

}
</code></pre>

<hr>
<h2 id='trim+2CGRaster-method'>Remove rows and columns from a raster that are all NA</h2><span id='topic+trim+2CGRaster-method'></span><span id='topic+trim'></span>

<h3>Description</h3>

<p>This function removes any rows and columns from  a <code>GRaster</code> that are all <code>NA</code>.
</p>
<p>If the <code>GRaster</code> is a stack of rasters, then the rasters will all be trimmed to the same extent such that none have any rows or columns that are all <code>NA</code>. In other words, if at least one raster in the stack has a non-<code>NA</code> cell in a row or column, all rasters will retain that row or column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
trim(x, pad = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trim+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="trim+2B2CGRaster-method_+3A_pad">pad</code></td>
<td>
<p>Numeric integer: Number of <code>NA</code> rows and columns to retain. The default is 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+trim">terra::trim()</a></code>, <code><a href="#topic+extend">extend()</a></code>, and <strong>GRASS</strong> module <code>g.region</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Elevation raster
madElev &lt;- fastData("madElev")

# Convert SpatRaster to a GRaster:
elev &lt;- fast(madElev)

# Trim NA rows/columns:
trimmedElev &lt;- trim(elev)
dim(elev)
dim(trimmedElev)

# Trim a "stack" of rasters. We will artificially add NA rows and columns to
# one raster to demonstrate how the trim() function removes only rows/columns
# that are NA for *all* rasters.
elevNAs &lt;- elev

fun &lt;- " = if(col() &gt; ncols() - 200, null(), madElev)"
elevNAs &lt;- app(elevNAs, fun)

# Notice raster is "narrower" because we added NA columns
plot(elevNAs)

elevs &lt;- c(elev, elevNAs)
trimmedElevs &lt;- trim(elevs)
trimmedElevNAs &lt;- trim(elevNAs)

dim(elevs)
dim(trimmedElevNAs)
dim(trimmedElevs)

}
</code></pre>

<hr>
<h2 id='union+2CGVector+2CGVector-method'>Combine two GVectors</h2><span id='topic+union+2CGVector+2CGVector-method'></span><span id='topic+union'></span>

<h3>Description</h3>

<p>The <code>union()</code> function combines two &quot;polygons&quot; <code>GVector</code>s. The output will have at least as many geometries as both <code>GVector</code>s, plus more if polygons of one divide polygons of the other, and vice versa. You can also use the <code>+</code> operator (e.g., <code>vect1 + vect2</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector,GVector'
union(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="union+2B2CGVector+2B2CGVector-method_+3A_x">x</code>, <code id="union+2B2CGVector+2B2CGVector-method_+3A_y">y</code></td>
<td>
<p><code>GVector</code>s representing polygons.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+c">c()</a></code>, <code><a href="#topic+aggregate">aggregate()</a></code>, <code><a href="#topic+crop">crop()</a></code>, <code><a href="#topic+intersect">intersect()</a></code>, <code><a href="#topic+xor">xor()</a></code>, <code><a href="#topic+erase">erase()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)

# Polygon of coastal Madagascar and Dypsis specimens
madCoast4 &lt;- fastData("madCoast4") # polygons
madDypsis &lt;- fastData("madDypsis") # points

# Convert vectors:
coast4 &lt;- fast(madCoast4)
dypsis &lt;- fast(madDypsis)

# Create another polygons vector from a convex hull around Dypsis points
hull &lt;- convHull(dypsis)

### union()

unioned &lt;- union(coast4, hull)
plot(unioned)

plus &lt;- coast4 + hull # same as union()

### intersect

inter &lt;- intersect(coast4, hull)
plot(coast4)
plot(hull, border = "red", add = TRUE)
plot(inter, border = "blue", add = TRUE)

### xor

xr &lt;- xor(coast4, hull)
plot(coast4)
plot(xr, border = "blue", add = TRUE)

### erase

erased &lt;- erase(coast4, hull)
plot(coast4)
plot(erased, border = "blue", add = TRUE)

minus &lt;- coast4 - hull # same as erase()

}
</code></pre>

<hr>
<h2 id='update+2CGRaster-method'>Refresh metadata in a GRaster or GVector</h2><span id='topic+update+2CGRaster-method'></span><span id='topic+update'></span><span id='topic+update+2CGVector-method'></span>

<h3>Description</h3>

<p><code>GRaster</code>s and <code>GVector</code>s are really pointers to objects in <strong>GRASS</strong>. The values displayed when you use <code>show()</code> or <code>print()</code> for a <code>GRaster</code> or <code>GVector</code> are stored in <strong>R</strong>. If, on the odd chance that you make a change to a <code>GRaster</code> or <code>GVector</code> (e.g., using commands in the <strong>rgrass</strong> package), the changes will not be automatically reflected in the <code>GRaster</code> or <code>GVector</code>. This function can be used to update the objects in <strong>R</strong> to reflect their proper values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
update(object)

## S4 method for signature 'GVector'
update(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update+2B2CGRaster-method_+3A_object">object</code></td>
<td>
<p>A <code>GRaster</code> or <code>GVector</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code> or <code>GVector</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")
madForest2000 &lt;- fastData("madForest2000")

# Convert SpatRasters to GRasters
elev &lt;- fast(madElev)
forest &lt;- fast(madForest2000)

### GRaster properties

# plotting
plot(elev)

# dimensions
dim(elev) # rows, columns, depths, layers
nrow(elev) # rows
ncol(elev) # columns
ndepth(elev) # depths
nlyr(elev) # layers

res(elev) # resolution (2D)
res3d(elev) # resolution (3D)
zres(elev) # vertical resolution
xres(elev) # vertical resolution
yres(elev) # vertical resolution
zres(elev) # vertical resolution (NA because this is a 2D GRaster)

# cell counts
ncell(elev) # cells
ncell3d(elev) # cells (3D rasters only)

# number of NA and non-NA cells
nacell(elev)
nonnacell(elev)

# topology
topology(elev) # number of dimensions
is.2d(elev) # is it 2-dimensional?
is.3d(elev) # is it 3-dimensional?

minmax(elev) # min/max values

# "names" of the object
names(elev)

# coordinate reference system
crs(elev)
st_crs(elev)
coordRef(elev)

# extent (bounding box)
ext(elev)

# vertical extent (not defined for this raster)
zext(elev)

# data type
datatype(elev) # fasterRaster type
datatype(elev, "GRASS") # GRASS type
datatype(elev, "terra") # terra type
datatype(elev, "GDAL") # GDAL type

is.integer(elev)
is.float(elev)
is.double(elev)
is.factor(elev)

# convert data type
as.int(elev) # integer; note that "elev" is already of type "integer"
as.float(elev) # floating-precision
as.doub(elev) # double-precision

# assigning
pie &lt;- elev
pie[] &lt;- pi # assign all cells to the value of pi
pie

# concatenating multiple GRasters
rasts &lt;- c(elev, forest)
rasts

# subsetting
rasts[[1]]
rasts[["madForest2000"]]

# replacing
rasts[[2]] &lt;- 2 * forest
rasts

# adding layers
rasts[[3]] &lt;- elev &gt; 500 # add a layer
rasts &lt;- c(rasts, sqrt(elev)) # add another
add(rasts) &lt;- ln(elev)
rasts

# names
names(rasts)
names(rasts) &lt;- c("elev_meters", "2_x_forest", "high_elevation", "sqrt_elev", "ln_elev")
rasts

# remove a layer
rasts[["2_x_forest"]] &lt;- NULL
rasts

# number of layers
nlyr(rasts)

# correlation and covariance matrices
madLANDSAT &lt;- fastData("madLANDSAT")
landsat &lt;- fast(madLANDSAT) # projects matrix
layerCor(landsat) # correlation
layerCor(landsat, fun = 'cov') # covariance

}
</code></pre>

<hr>
<h2 id='vect+2CGVector-method'>Convert a GVector to a SpatVector or sf vector</h2><span id='topic+vect+2CGVector-method'></span><span id='topic+vect'></span><span id='topic+st_as_sf+2CGVector-method'></span><span id='topic+st_as_sf'></span>

<h3>Description</h3>

<p>The <strong>fasterRaster</strong> version of the <code>vect()</code> function converts a <code>GVector</code> to a <code>SpatVector</code> (from the <strong>terra</strong> package). The <strong>fasterRaster</strong> version of the <code>st_as_sf()</code> function converts a <code>GVector</code> to an <code>sf</code> object (<strong>sf</strong> package).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector'
vect(x, ...)

## S4 method for signature 'GVector'
st_as_sf(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vect+2B2CGVector-method_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="vect+2B2CGVector-method_+3A_...">...</code></td>
<td>
<p>Additional arguments to send to <code><a href="#topic+writeVector">writeVector()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>vect()</code> returns a <code>SpatVector</code> (<strong>terra</strong> package), and <code>st_as_sf()</code> returns an <code>sf</code> vector (<strong>sf</strong> package).
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+vect">terra::vect()</a></code>, <code><a href="sf.html#topic+st_as_sf">sf::st_as_sf()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)

# Example data:
madCoast4 &lt;- fastData("madCoast4")
madRivers &lt;- fastData("madRivers")
madDypsis &lt;- fastData("madDypsis")

# Convert sf vectors to GVectors:
coast &lt;- fast(madCoast4)
rivers &lt;- fast(madRivers)
dypsis &lt;- fast(madDypsis)

# Geographic properties:
ext(rivers) # extent
crs(rivers) # coordinate reference system
st_crs(rivers) # coordinate reference system
coordRef(rivers) # coordinate reference system

# Column names and data types:
names(coast)
datatype(coast)

# Points, lines, or polygons?
geomtype(dypsis)
geomtype(rivers)
geomtype(coast)

is.points(dypsis)
is.points(coast)

is.lines(rivers)
is.lines(dypsis)

is.polygons(coast)
is.polygons(dypsis)

# Number of dimensions:
topology(rivers)
is.2d(rivers) # 2-dimensional?
is.3d(rivers) # 3-dimensional?

# Just the data table:
as.data.frame(rivers)
as.data.table(rivers)

# Top/bottom of the data table:
head(rivers)
tail(rivers)

# Vector or table with just selected columns:
names(rivers)
rivers$NAME
rivers[[c("NAM", "NAME_0")]]
rivers[[c(3, 5)]]

# Select geometries/rows of the vector:
nrow(rivers)
selected &lt;- rivers[2:6]
nrow(selected)

# Plot:
plot(coast)
plot(rivers, col = "blue", add = TRUE)
plot(selected, col = "red", lwd = 2, add = TRUE)

# Vector math:
hull &lt;- convHull(dypsis)

un &lt;- union(coast, hull)
sameAsUnion &lt;- coast + hull
plot(un)
plot(sameAsUnion)

inter &lt;- intersect(coast, hull)
sameAsIntersect &lt;- coast * hull
plot(inter)
plot(sameAsIntersect)

er &lt;- erase(coast, hull)
sameAsErase &lt;- coast - hull
plot(er)
plot(sameAsErase)

xr &lt;- xor(coast, hull)
sameAsXor &lt;- coast / hull
plot(xr)
plot(sameAsXor)

# Vector area and length:
expanse(coast, unit = "km") # polygons areas
expanse(rivers, unit = "km") # river lengths

### Fill holes

# First, we will make some holes by creating buffers around points.
buffs &lt;- buffer(dypsis, 500)

holes &lt;- coast - buffs
plot(holes)

filled &lt;- fillHoles(holes, fail = FALSE)

}
</code></pre>

<hr>
<h2 id='vegIndex+2CGRaster-method'>Vegetation indices from surface reflectance</h2><span id='topic+vegIndex+2CGRaster-method'></span><span id='topic+vegIndex'></span>

<h3>Description</h3>

<p>This function calculates one of many types of vegetation indices from a raster with four bands representing blue (B), green (G), red (R), and near infrared (NIR), plus possibly channels 5 and 7. The function requires rasters that represent surface reflectance, so should have values that fall in the range 0 to 1, unless they are digital number rasters (e.g., integers in the range 0 to 255). If digital number format is used, then the <code>bits</code> argument should be defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
vegIndex(
  x,
  index = "NDVI",
  r = NULL,
  g = NULL,
  b = NULL,
  nir = NULL,
  b5 = NULL,
  b7 = NULL,
  soilSlope = NULL,
  soilIntercept = NULL,
  soilNR = 0.08,
  bits = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vegIndex+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> with one layer per required band. Values should be between 0 and 1.</p>
</td></tr>
<tr><td><code id="vegIndex+2B2CGRaster-method_+3A_index">index</code></td>
<td>
<p>Character or character vector: The vegetation index or indices to calculate. You can find a list of available indices using <a href="#topic+fastData">fastData(&quot;vegIndices&quot;)</a> (also see <a href="#topic+vegIndices">vegIndices</a>). The first column, &quot;<code>index</code>&quot; provides the name of the index, and these are the values that this argument will accept (e.g., &quot;NDVI&quot;, &quot;EVI2&quot;). Partial matching is used, and case is ignored. You can also use these shortcuts:
</p>

<ul>
<li> <p><code>"*"</code>: Calculate <em>all</em> indices
</p>
</li>
<li> <p><code>"RNIR"</code>: Calculate all indices that use R and NIR channels (but not other channels).
</p>
</li>
<li> <p><code>"NotSoil"</code>: Calculate all indices that use any channels but do not require <code>soilSlope</code> or <code>soilIntercept</code>.
</p>
</li></ul>

<p><em>Note</em>: A near-comprehensive table of indices can be found on the <a href="https://www.indexdatabase.de">Index Database: A Database for Remote Sensing Indices</a>.</p>
</td></tr>
<tr><td><code id="vegIndex+2B2CGRaster-method_+3A_r">r</code>, <code id="vegIndex+2B2CGRaster-method_+3A_g">g</code>, <code id="vegIndex+2B2CGRaster-method_+3A_b">b</code>, <code id="vegIndex+2B2CGRaster-method_+3A_nir">nir</code></td>
<td>
<p>Numeric or character: Index or <code><a href="#topic+names">names()</a></code> of the layers in <code>x</code> that represent the red, green, blue, and near infrared channels. Values must be in the range from 0 to 1 or integers.</p>
</td></tr>
<tr><td><code id="vegIndex+2B2CGRaster-method_+3A_b5">b5</code>, <code id="vegIndex+2B2CGRaster-method_+3A_b7">b7</code></td>
<td>
<p>Numeric or character: Index of names of the layers representing bands 5 and 7. These are used only for GVI and PVI. Values must be in the range from 0 to 1 or integers.</p>
</td></tr>
<tr><td><code id="vegIndex+2B2CGRaster-method_+3A_soilslope">soilSlope</code>, <code id="vegIndex+2B2CGRaster-method_+3A_soilintercept">soilIntercept</code>, <code id="vegIndex+2B2CGRaster-method_+3A_soilnr">soilNR</code></td>
<td>
<p>Numeric: Values of the soil slope, intercept, and soil noise reduction factor (0.08, by default). Used only for calculation of MSAVI.</p>
</td></tr>
<tr><td><code id="vegIndex+2B2CGRaster-method_+3A_bits">bits</code></td>
<td>
<p>Either <code>NULL</code> (default) or numeric integer or integer with a value of 7, 8, 10, or 16: If the rasters are represented by integers (so do not fall in the range of 0 to 1), then the number of bits can be supplied using <code>bits</code>. If this is the case, then they will range from 0 to 2^<code>n</code>, where <code>n</code> is 7, 8, 10, or 16. If bit rasters are supplied, they must be of <code><a href="#topic+datatype">datatype()</a></code> &quot;integer&quot;. If raster values are in the range from 0 to 1, then <code>bits</code> should be <code>NULL</code> (default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><strong>GRASS</strong> manual page for module <code>i.vi</code> (see <code>grassHelp("i.vi")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Elevation raster, rivers vector
madLANDSAT &lt;- fastData("madLANDSAT")

# Convert a SpatRaster to a GRaster:
landsat &lt;- fast(madLANDSAT)

# See available vegetation indices:
vegIndices

# Normalized Difference Vegetation Index and Enhanced Vegetation Index:
indices &lt;- c("ndvi", "evi")
vi &lt;- vegIndex(landsat, index = indices, r = 1, b = 3, nir = 4, bits = 8)
plot(vi)

# All indices using R and NIR:
rnir &lt;- vegIndex(landsat, index = "rnir", r = 1, nir = 4, bits = 8)

# Note: Some values are highly skewed
plot(rnir)

}
</code></pre>

<hr>
<h2 id='vegIndices'>Table of vegetation indices that can be calculated from remote sensing surface reflectance data using <code><a href="#topic+vegIndex">vegIndex()</a></code>. A near-comprehensive table of indices can be found on the <a href="https://www.indexdatabase.de">Index Database: A Database for Remote Sensing Indices</a>.</h2><span id='topic+vegIndices'></span>

<h3>Description</h3>

<p>A table of vegetation indices that ca be calculated using <code><a href="#topic+vegIndex">vegIndex()</a></code>. Columns include:
</p>

<ul>
<li><p> 'index&ldquo;: Abbreviation of the index.
</p>
</li>
<li> <p><code>definition</code>: Index name
</p>
</li>
<li> <p><code>R</code>, <code>G</code>, <code>B</code>, <code>NIR</code>, <code>channel5</code>, <code>channel7</code>: Whether or not the index uses the red, green, blue, or near-infrared channels, and channels 5 and 7.
</p>
</li>
<li> <p><code>soilLineslope</code>, <code>soilIntercept</code>, <code>soilNR</code>: Whether or not the index requires soil line slope, soil intercept, and a soil noise reduction factor.
</p>
</li></ul>



<h3>Format</h3>

<p>An object of class <code>data.frame</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vegIndex">vegIndex()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### vector data

library(sf)

# For vector data, we can use data(*) or fastData(*):
data(madCoast0) # same as next line
madCoast0 &lt;- fastData("madCoast0") # same as previous
madCoast0
plot(st_geometry(madCoast0))

madCoast4 &lt;- fastData("madCoast4")
madCoast4
plot(st_geometry(madCoast4), add = TRUE)

madRivers &lt;- fastData("madRivers")
madRivers
plot(st_geometry(madRivers), col = "blue", add = TRUE)

madDypsis &lt;- fastData("madDypsis")
madDypsis
plot(st_geometry(madDypsis), col = "red", add = TRUE)

### raster data

library(terra)

# For raster data, we can get the file directly or using fastData(*):
rastFile &lt;- system.file("extdata/madElev.tif", package="fasterRaster")
madElev &lt;- terra::rast(rastFile)

madElev &lt;- fastData("madElev") # same as previous two lines
madElev
plot(madElev)

madForest2000 &lt;- fastData("madForest2000")
madForest2000
plot(madForest2000)

madForest2014 &lt;- fastData("madForest2014")
madForest2014
plot(madForest2014)

# multi-layer rasters
madChelsa &lt;- fastData("madChelsa")
madChelsa
plot(madChelsa)

madPpt &lt;- fastData("madPpt")
madTmin &lt;- fastData("madTmin")
madTmax &lt;- fastData("madTmax")
madPpt
madTmin
madTmax


# RGB raster
madLANDSAT &lt;- fastData("madLANDSAT")
madLANDSAT
plotRGB(madLANDSAT, 4, 1, 2, stretch = "lin")

# categorical raster
madCover &lt;- fastData("madCover")
madCover
madCover &lt;- droplevels(madCover)
levels(madCover) # levels in the raster
nlevels(madCover) # number of categories
catNames(madCover) # names of categories table

plot(madCover)
</code></pre>

<hr>
<h2 id='voronoi+2CGVector-method'>Voronoi tessellation</h2><span id='topic+voronoi+2CGVector-method'></span><span id='topic+voronoi'></span>

<h3>Description</h3>

<p>This function creates a Voronoi tessellation from a set of spatial points or polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector'
voronoi(x, buffer = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="voronoi+2B2CGVector-method_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code> &quot;points&quot; object.</p>
</td></tr>
<tr><td><code id="voronoi+2B2CGVector-method_+3A_buffer">buffer</code></td>
<td>
<p>Numeric: By default, this function creates a vector that has an extent exactly the same as the input data. However, the apparent extent can be changed by setting this value to a value different from 0. Negative values reduce the size of the extent, and positive extend it.  Units are in map units.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+voronoi">terra::voronoi()</a></code>, <code><a href="sf.html#topic+geos_unary">sf::st_voronoi()</a></code>, module <code>v.voronoi</code> in <strong>GRASS</strong>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)

# Example vectors
madDypsis &lt;- fastData("madDypsis") # points
madCoast4 &lt;- fastData("madCoast4") # polygons

# Convert sf vectors to GVectors
dypsis &lt;- fast(madDypsis)
coast4 &lt;- fast(madCoast4)
ant &lt;- coast4[coast4$NAME_4 == "Antanambe"]

# Delaunay triangulation
dypsisDel &lt;- delaunay(dypsis)
plot(dypsisDel)
plot(dypsis, pch = 1, col = "red", add = TRUE)

# Voronoi tessellation
vor &lt;- voronoi(dypsis)
plot(vor)
plot(dypsis, pch = 1, col = "red", add = TRUE)

# Random Voronoi tessellation
rand &lt;- rvoronoi(coast4, size = 100)
plot(rand)

}
</code></pre>

<hr>
<h2 id='wetness+2CGRaster-method'>Topographic wetness index</h2><span id='topic+wetness+2CGRaster-method'></span><span id='topic+wetness'></span>

<h3>Description</h3>

<p>This function creates a raster map with values equal to the topographic wetness index (TWI), which is a measure of how much overland water flow tends to accumulate in or flow away from a location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
wetness(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wetness+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> (typically representing elevation). The raster must be projected (i.e., not in WGS84, NAD83, et cetera).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+terrain">terrain()</a></code>, <code><a href="#topic+ruggedness">ruggedness()</a></code>, <code><a href="#topic+geomorphons">geomorphons()</a></code>, <strong>GRASS</strong> manual for module <code>r.topidx</code> (see <code>grassHelp("r.topidx")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Elevation raster
madElev &lt;- fastData("madElev")

# Convert to GRaster:
elev &lt;- fast(madElev)

# Terrain ruggedness index:
tri &lt;- ruggedness(elev)
plot(c(elev, tri))

# Topographic wetness index:
twi &lt;- wetness(elev)
plot(c(elev, twi))

}
</code></pre>

<hr>
<h2 id='writeRaster+2CGRaster+2Ccharacter-method'>Save a GRaster to disk</h2><span id='topic+writeRaster+2CGRaster+2Ccharacter-method'></span><span id='topic+writeRaster'></span><span id='topic+writeRaster+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>This function saves a <code>GRaster</code> to disk directly from a <strong>GRASS</strong> session. It is faster than using <code><a href="#topic+rast">rast()</a></code>, then saving the output of that to disk (because <code>rast()</code> actually save the raster to disk, anyway).
</p>
<p>The function will attempt to ascertain the file type to be ascertained from the file extension, but you can specify the format using the <code>format</code> argument (see entry for <code>...</code>). You can see a list of supported formats by simply using this function with no arguments, as in <code>writeRaster()</code>, or by consulting the online help page for the <strong>GRASS</strong> module <code>r.out.gdal</code> (see <code>grassHelp("r.out.gdal")</code>). Only the <code>GeoTIFF</code> file format is guaranteed to work for multi-layered rasters.
</p>
<p>The function will attempt to optimize the <code>datatype</code> argument, but this can take a long time. You can speed this up by setting <code>datatype</code> manually. Note that if you are saving a &quot;stack&quot; of <code>GRaster</code>s with different <code>datatype</code>s, the one with the highest information density will be used (e.g., low-bit integer &lt; high-bit integer &lt; floating-point &lt; double-floating point). This can make rasters with lower datatypes much larger on disk. In these cases, it make be best to save rasters with similar <code>datatype</code>s together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster,character'
writeRaster(
  x,
  filename,
  overwrite = FALSE,
  datatype = NULL,
  byLayer = FALSE,
  names = TRUE,
  levelsExt = NULL,
  compress = "LZW",
  warn = TRUE,
  ...
)

## S4 method for signature 'missing,missing'
writeRaster(x, filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="writeRaster+2B2CGRaster+2B2Ccharacter-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> or missing: If missing, a table of supported file types is reported.</p>
</td></tr>
<tr><td><code id="writeRaster+2B2CGRaster+2B2Ccharacter-method_+3A_filename">filename</code></td>
<td>
<p>Character: Path and file name.</p>
</td></tr>
<tr><td><code id="writeRaster+2B2CGRaster+2B2Ccharacter-method_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical: If <code>FALSE</code> (default), do not save over existing file(s).</p>
</td></tr>
<tr><td><code id="writeRaster+2B2CGRaster+2B2Ccharacter-method_+3A_datatype">datatype</code></td>
<td>
<p><code>NULL</code> (default) or character: The datatype of the values stored in non-ASCII rasters. If <code>NULL</code>, this will be ascertained from the raster, and the function usually does a good job at it. However, you can force it manually, but note that in some cases, trying to save a <code>GRaster</code> using an inappropriate <code>datatype</code> for its values can result in an error or in the function exiting without an error but also without having written the raster to disk. The argument can take any of those shown below under the first four columns, but whatever is used, it will be converted to the <strong>GDAL</strong> version.</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>fasterRaster</strong> </td><td style="text-align: left;"> <strong>terra</strong> </td><td style="text-align: left;"> <strong>GRASS</strong> </td><td style="text-align: left;"> <strong>GDAL</strong> </td><td style="text-align: left;"> <strong>Values</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>integer</code> </td><td style="text-align: left;"> <code>INT1U</code> </td><td style="text-align: left;"> <code>CELL</code> </td><td style="text-align: left;"> <code>Byte</code> </td><td style="text-align: left;"> Integer values from 0 to 255 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>integer</code> </td><td style="text-align: left;"> <code>INT2U</code> </td><td style="text-align: left;"> <code>CELL</code> </td><td style="text-align: left;"> <code>UInt16</code> </td><td style="text-align: left;"> Integer values from 0 to 65,534 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>integer</code> </td><td style="text-align: left;"> <code>INT2S</code> </td><td style="text-align: left;"> <code>CELL</code> </td><td style="text-align: left;"> <code>Int16</code> </td><td style="text-align: left;"> Integer values from -32,767 to -32,767 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>integer</code> </td><td style="text-align: left;"> <code>INT4S</code> </td><td style="text-align: left;"> <code>CELL</code> </td><td style="text-align: left;"> <code>Int32</code> </td><td style="text-align: left;"> Integer values from -2,147,483,647 to 2,147,483,647 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>float</code> </td><td style="text-align: left;"> <code>FLT4S</code> </td><td style="text-align: left;"> <code>FCELL</code> </td><td style="text-align: left;"> <code>Float32</code> </td><td style="text-align: left;"> Values from -3.4E+38 to 3.4E+38, including decimal values </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>double</code> </td><td style="text-align: left;"> <code>FLT8S</code> </td><td style="text-align: left;"> <code>DCELL</code> </td><td style="text-align: left;"> <code>Float64</code> </td><td style="text-align: left;"> Values from -1.79E+308 to 1.79E+308, including decimal values </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>factor</code> </td><td style="text-align: left;"> <code>INT</code>* </td><td style="text-align: left;"> <code>CELL</code> </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;INT*&#8288;</code> </td><td style="text-align: left;"> Integer values corresponding to categories </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><code>*</code> Depends on the integers (signed/unsigned, range of values). Categorical rasters will have an associated file saved with them that has category values and labels. The file name will be the same as the raster's file name, but end with the extension given by <code>levelsExt</code> (<code>.csv</code> by default).</p>
</td></tr>
<tr><td><code id="writeRaster+2B2CGRaster+2B2Ccharacter-method_+3A_bylayer">byLayer</code></td>
<td>
<p>Logical: If <code>FALSE</code> (default), multi-layer rasters will be saved in one file. If <code>TRUE</code>, the each layer will be saved in a separate file. The filename from <code>filename</code> will be amended so that it ends with <code style="white-space: pre;">&#8288;_&lt;name&gt;&#8288;</code> (then the file extension), where <code style="white-space: pre;">&#8288;&lt;name&gt;&#8288;</code> is give by <code><a href="#topic+names">names()</a></code>. Note that if any characters in raster names will not work in a file name, then the function will fail (e.g., a backslash or question mark).</p>
</td></tr>
<tr><td><code id="writeRaster+2B2CGRaster+2B2Ccharacter-method_+3A_names">names</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), save a file with raster layer names. The file will have the same name as the raster file but end with &quot;<code style="white-space: pre;">&#8288;_names.csv&#8288;</code>&quot;. Currently, the <code><a href="#topic+names">names()</a></code> attribute of rasters cannot be saved in the raster, which can create confusion when multi-layered rasters are saved. Turning on this option will save the ancillary file with layer names. If it exists, this file will be read by <code><a href="#topic+fast">fast()</a></code> so layer names are assigned when the raster is read by that function. The absence of a &quot;names&quot; file will not create any issues with this function or <code><a href="#topic+fast">fast()</a></code>, other than not having the metadata on layer names.</p>
</td></tr>
<tr><td><code id="writeRaster+2B2CGRaster+2B2Ccharacter-method_+3A_levelsext">levelsExt</code></td>
<td>
<p>Character, logical, or <code>NULL</code> (default): Name of the file extension for the &quot;levels&quot; file that accompanies a categorical <code>GRaster</code>. When saving categorical rasters, the raster file is accompanied with a &quot;levels&quot; file that contain information on the levels of the raster. This file is the same as <code>filename</code>, except it has a different extension. Valid values depend on how many raster layers are saved at a time (case is ignored):
</p>

<ul>
<li><p> DefaultOne raster layer: <code>".csv"</code>
</p>
</li>
<li><p> Two or more layers, with at least one categorical raster: <code>".rds"</code>, <code>".rda"</code>, <code>".rdat"</code>, <code>".rdata"</code>
</p>
</li>
<li><p> Any: <code>NULL</code> or <code>TRUE</code> automatically selects either <code>".csv"</code> (one raster layer) or <code style="white-space: pre;">&#8288;".rds&#8288;</code> (two or more)
</p>
</li>
<li><p> Any: <code>FALSE</code> disables saving of a levels file.
</p>
</li></ul>
</td></tr>
<tr><td><code id="writeRaster+2B2CGRaster+2B2Ccharacter-method_+3A_compress">compress</code></td>
<td>
<p>Character: Type of compression to use for GeoTIFF files:
</p>

<ul>
<li> <p><code>"LZW"</code> (default)
</p>
</li>
<li> <p><code>"DEFLATE"</code>
</p>
</li>
<li> <p><code>"PACKBITS"</code>
</p>
</li>
<li> <p><code>"LZMA"</code>
</p>
</li>
<li> <p><code>NULL</code>: No compression is used, but the file can still be reduced in size by using zip, gzip, or other compressions.
</p>
</li></ul>
</td></tr>
<tr><td><code id="writeRaster+2B2CGRaster+2B2Ccharacter-method_+3A_warn">warn</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), display a warning if the <code>datatype</code> argument does not match the value given by <code>datatype(x, "GDAL")</code>, or if the <code>fileExt</code> argument will not work with the given raster and so has been automatically changed.</p>
</td></tr>
<tr><td><code id="writeRaster+2B2CGRaster+2B2Ccharacter-method_+3A_...">...</code></td>
<td>
<p>Additional arguments. These can include:
</p>

<ul>
<li> <p><code>bigTiff</code>: Logical: If <code>TRUE</code>, and the file format is a GeoTIFF and would be larger than 4 GB (regardless of compression), then the file will be saved in BIGTIFF format.
</p>
</li>
<li> <p><code>format</code>: Character, indicating file format. This is usually ascertained from the file extension, but in case this fails, it can be stated explicitly. When using other formats, you may have to specify the <code>createopts</code> argument, too (see help page for <strong>GRASS</strong> module <code>r.out.gdal</code>). Two common formats include:
</p>

<ul>
<li> <p><code>"GTiff"</code> (default): GeoTIFF <code>filename</code> ends in <code>.tif</code>.
</p>
</li>
<li> <p><code>"ASC"</code>: ASCII <code>filename</code> ends in <code>.asc</code>
</p>
</li></ul>

</li>
<li><p> Additional arguments to send to <strong>GRASS</strong> modules <code>r.out.gdal</code> and <code>r.out.ascii</code>.
</p>
</li>
<li> <p><code>precision</code>: Numeric: For ASCII files, you may need to state the number of significant digits. 32-bit values have 7 digits and 64-bit values have 16. So in these cases the argument would be <code>precision=7</code> or <code>precision=16</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GRaster</code> (invisibly). A raster is also saved to disk.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+writeRaster">terra::writeRaster()</a></code>, <strong>GRASS</strong> module <code>r.out.gdal</code> (see <code>grassHelp("r.out.gdal")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madElev &lt;- fastData("madElev")
madChelsa &lt;- fastData("madChelsa")

### What raster formats can we attempt to write?
writeRaster()

### Save GRaster to disk (using temporary file)
elev &lt;- fast(madElev)
filename &lt;- tempfile(fileext = ".tif")
writeRaster(elev, filename)

# Load raster from disk
elev2 &lt;- fast(filename)
elev2

### Save multi-layer GRaster to disk in one file (using temporary file)
chelsa &lt;- fast(madChelsa)
filename &lt;- tempfile(fileext = ".tif")
writeRaster(chelsa, filename)

# Load raster from disk
chelsa2 &lt;- fast(filename)
chelsa2

### Save multi-layer GRaster to disk layer-by-layer (using temporary file)
chelsa &lt;- fast(madChelsa)
filename &lt;- tempfile(fileext = ".tif")
writeRaster(chelsa, filename, byLayer = TRUE)

# Load one of the rasters from disk
filename2 &lt;- sub(filename, pattern = ".tif", replacement = "_bio1.tif")
chelsaBio1 &lt;- fast(filename2)
chelsaBio1

}
</code></pre>

<hr>
<h2 id='writeVector+2CGVector+2Ccharacter-method'>Save a GVector to disk</h2><span id='topic+writeVector+2CGVector+2Ccharacter-method'></span><span id='topic+writeVector'></span><span id='topic+writeVector+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>This function saves a <code>GVector</code> to disk directly from a <strong>GRASS</strong> session.
</p>
<p>By default, files will be of OGC GeoPackage format (extension &quot;<code>.gpkg</code>&quot;), but this can be changed with the <code>format</code> argument. You can see a list of supported formats by simply using this function with no arguments, as in <code>writeVector()</code>, or by consulting the online help page for <strong>GRASS</strong> module <code>v.out.ogr</code> (see <code>grassHelp("v.out.ogr")</code>).
</p>
<p>Note that if the vector has a data table attached and at least one numeric or integer column has an <code>NA</code> or <code>NaN</code> value, the function will yield a warning like:
</p>
<div class="sourceCode"><pre>Warning 1: Invalid value type found in record 2 for field column_with_NA_or_NaN. This warning will no longer be emitted.
</pre></div>
<p>Also note that despite the promise, this warning will be displayed again.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector,character'
writeVector(
  x,
  filename,
  overwrite = FALSE,
  format = NULL,
  attachTable = TRUE,
  ...
)

## S4 method for signature 'missing,missing'
writeVector(x, filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="writeVector+2B2CGVector+2B2Ccharacter-method_+3A_x">x</code></td>
<td>
<p>A <code>GVector</code>.</p>
</td></tr>
<tr><td><code id="writeVector+2B2CGVector+2B2Ccharacter-method_+3A_filename">filename</code></td>
<td>
<p>Character: Path and file name.</p>
</td></tr>
<tr><td><code id="writeVector+2B2CGVector+2B2Ccharacter-method_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical: If <code>FALSE</code> (default), do not save over existing files.</p>
</td></tr>
<tr><td><code id="writeVector+2B2CGVector+2B2Ccharacter-method_+3A_format">format</code></td>
<td>
<p>Character or <code>NULL</code>: File format. If <code>NULL</code> (default), then the function will attempt to get the format from the file name extension. Partial matching is used and case is ignored. You can see a list of formats using <code>writeVector()</code> (no arguments). Some common formats include:
</p>

<ul>
<li> <p><code>"GPKG"</code>: OGC GeoPackage (extension <code>.gpkg</code>).
</p>
</li>
<li> <p><code>"CSV"</code>: Comma-separated value... saves the data table only, not the geometries (extension <code>.csv</code>).
</p>
</li>
<li> <p><code>"ESRI Shapefile"</code>: ESRI shapefile (extension <code>.shp</code>).
</p>
</li>
<li> <p><code>"GeoJSON"</code>: GeoJSON (extension <code>GeoJSON</code>)
</p>
</li>
<li> <p><code>"KML"</code>: Keyhole Markup Language (extension <code>.kml</code>)
</p>
</li>
<li> <p><code>"netCDF"</code>: NetCDF (extension <code>.ncdf</code>)
</p>
</li>
<li> <p><code>"XLSX"</code>: MS Office Open XML spreadsheet (extension <code>.xlsx</code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="writeVector+2B2CGVector+2B2Ccharacter-method_+3A_attachtable">attachTable</code></td>
<td>
<p>Logical: If <code>TRUE</code> (default), attach the attribute to table to the vector before saving it. If <code>FALSE</code>, the attribute table will not be attached.</p>
</td></tr>
<tr><td><code id="writeVector+2B2CGVector+2B2Ccharacter-method_+3A_...">...</code></td>
<td>
<p>Additional arguments to send to <strong>GRASS</strong> module <code>v.out.ogr</code> (see <code>grassHelp("v.out.ogr")</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns a <code>GRaster</code> (the input, <code>x</code>). Also saves the vector to disk.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+writeVector">terra::writeVector()</a></code>, <code><a href="sf.html#topic+st_write">sf::st_write()</a></code>, <strong>GRASS</strong> module <code>v.out.ogr</code> (see <code>grassHelp("v.out.ogr")</code>)
</p>
<p><code><a href="terra.html#topic+writeVector">terra::writeVector()</a></code>, the <strong>GRASS</strong> module manual page for <code>v.out.ogr</code> (see <code>grassHelp("v.out.ogr")</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data
madRivers &lt;- fastData("madRivers")

# What file formats can we attempt to write?
writeVector()

# Convert SpatVector to GVector
rivers &lt;- fast(madRivers)
rivers

# Save GVector to disk as GeoPackage
filename &lt;- tempfile(fileext = ".gpkg")
writeVector(rivers, filename)

# Save GVector to disk as ESRI Shapefile
filename &lt;- tempfile(fileext = ".shp")
writeVector(rivers, filename)

# Save GVector to disk as Google Earth KML
filename &lt;- tempfile(fileext = ".klm")
writeVector(rivers, filename)

# Save GVector data table to disk as comma-separated file
filename &lt;- tempfile(fileext = ".csv")
writeVector(rivers, filename)

# Save GVector data table to disk as NetCDF
filename &lt;- tempfile(fileext = ".ncdf")
writeVector(rivers, filename)

# Save GVector data table to disk as Excel file
filename &lt;- tempfile(fileext = ".xlsx")
writeVector(rivers, filename)

}
</code></pre>

<hr>
<h2 id='xor+2CGVector+2CGVector-method'>Select parts of polygons not shared between two GVectors</h2><span id='topic+xor+2CGVector+2CGVector-method'></span><span id='topic+xor'></span>

<h3>Description</h3>

<p>The <code>xor()</code> function selects the area that does <em>not</em> overlap between two &quot;polygon&quot; <code>GVector</code>s. You can also use the <code>/</code> operator, as in <code>vect1 / vect2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GVector,GVector'
xor(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xor+2B2CGVector+2B2CGVector-method_+3A_x">x</code>, <code id="xor+2B2CGVector+2B2CGVector-method_+3A_y">y</code></td>
<td>
<p><code>GVector</code>s.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>GVector</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crop">crop()</a></code>, <code><a href="#topic+intersect">intersect()</a></code>, <code><a href="#topic+union">union()</a></code>, <code><a href="#topic+erase">erase()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(sf)

# Polygon of coastal Madagascar and Dypsis specimens
madCoast4 &lt;- fastData("madCoast4") # polygons
madDypsis &lt;- fastData("madDypsis") # points

# Convert vectors:
coast4 &lt;- fast(madCoast4)
dypsis &lt;- fast(madDypsis)

# Create another polygons vector from a convex hull around Dypsis points
hull &lt;- convHull(dypsis)

### union()

unioned &lt;- union(coast4, hull)
plot(unioned)

plus &lt;- coast4 + hull # same as union()

### intersect

inter &lt;- intersect(coast4, hull)
plot(coast4)
plot(hull, border = "red", add = TRUE)
plot(inter, border = "blue", add = TRUE)

### xor

xr &lt;- xor(coast4, hull)
plot(coast4)
plot(xr, border = "blue", add = TRUE)

### erase

erased &lt;- erase(coast4, hull)
plot(coast4)
plot(erased, border = "blue", add = TRUE)

minus &lt;- coast4 - hull # same as erase()

}
</code></pre>

<hr>
<h2 id='zonal+2CGRaster+2CANY-method'>Statistics on cells of a GRaster stratified by cells of another raster</h2><span id='topic+zonal+2CGRaster+2CANY-method'></span><span id='topic+zonal'></span>

<h3>Description</h3>

<p>Function <code>zonal()</code> calculates statistics (mean, sum, etc.) on cells of a <code>GRaster</code> by &quot;zones&quot; created by cells of another <code>GRaster</code> or <code>GVector</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster,ANY'
zonal(x, z, fun = "mean", probs = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zonal+2B2CGRaster+2B2CANY-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code> for which to calculate summary statistics.</p>
</td></tr>
<tr><td><code id="zonal+2B2CGRaster+2B2CANY-method_+3A_z">z</code></td>
<td>
<p>A <code>GRaster</code> or <code>GVector</code> used to define zones:
</p>

<ul>
<li><p> If <code>z</code> is a <code>GRaster</code>, then it must be of type <code>integer</code> or <code>factor</code> (see <code>vignette("GRasters", package = "fasterRaster")</code>). Zones will be established based on cells that have the same value in this raster.
</p>
</li>
<li><p> If <code>z</code> is a <code>GVector</code>, zones will be created for each geometry. If geometries overlap, then the zonal statistics will be calculated for the ones on top. Thus statistics for the zones defined by geometries below these may not represent all the cells covered by that geometry.
</p>
</li></ul>
</td></tr>
<tr><td><code id="zonal+2B2CGRaster+2B2CANY-method_+3A_fun">fun</code></td>
<td>
<p>Character vector: Name of the function(s) to summarize <code>x</code> with. These can include:
</p>

<ul>
<li> <p><code>"*"</code>: All of the functions below.
</p>
</li>
<li> <p><code>"cv"</code>: Sample coefficient of variation (expressed as a proportion of the mean).
</p>
</li>
<li> <p><code>"cvpop"</code>: Population coefficient of variation (expressed as a proportion of the mean).
</p>
</li>
<li> <p><code>"max"</code> and <code>"min"</code>: Highest and lowest values across non-<code>NA</code> cells.
</p>
</li>
<li> <p><code>"mean"</code> (default): Average.
</p>
</li>
<li> <p><code>"meanAbs"</code>: Mean of absolute values.
</p>
</li>
<li> <p><code>"median"</code>: Median.
</p>
</li>
<li> <p><code>"quantile"</code>: Quantile (see also argument <code>probs</code>).
</p>
</li>
<li> <p><code>"range"</code>: Range.
</p>
</li>
<li> <p><code>"sd"</code>: Sample standard deviation.
</p>
</li>
<li> <p><code>"sdpop"</code>: Population standard deviation.
</p>
</li>
<li> <p><code>"sum"</code>: Sum.
</p>
</li>
<li> <p><code>"var"</code>: Sample variance.
</p>
</li>
<li> <p><code>"varpop"</code>: Population variance.
</p>
</li></ul>
</td></tr>
<tr><td><code id="zonal+2B2CGRaster+2B2CANY-method_+3A_probs">probs</code></td>
<td>
<p>Numeric: Quantile at which to calculate <code>quantile</code>. Only a single value between 0 and 1 is allowed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> or <code>data.table</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Elevation SpatRaster:
madElev &lt;- fastData("madElev")

# Convert a SpatRaster to a GRaster:
elev &lt;- fast(madElev)

### Calculate zonal statistics using a GRaster as zones

# Generate a "zones" GRaster by dividing raster into areas based on
# high/low elevation.
names(elev) # Use this name in app() formula.
fun &lt;- "= if (madElev &lt;200, 0, if (madElev &lt;400, 1, 2))"
zones &lt;- app(elev, fun = fun)

# Calculate zonal statistics using a raster as zones
zonal(elev, zones, fun = "mean")
zonal(elev, zones, fun = "*") # all statistics

# Calculate zonal statistics on multi-layered GRaster
elev2 &lt;- c(elev, log10(elev))
zonal(elev2, zones, fun = c("mean", "sum", "sdpop"))

### Calculate zonal statistics using a GVector as zones

madCoast4 &lt;- fastData("madCoast4")
coast &lt;- fast(madCoast4)

zonal(elev, z = coast, fun = "mean")

}
</code></pre>

<hr>
<h2 id='zonalGeog+2CGRaster-method'>Geographic statistics for sets of cells with the same values</h2><span id='topic+zonalGeog+2CGRaster-method'></span><span id='topic+zonalGeog'></span>

<h3>Description</h3>

<p>This function calculates geographic statistics for each set of cells in an <code>integer</code> or <code>factor</code> <code>GRaster</code>. Statistics include:
</p>

<ul>
<li><p> Area
</p>
</li>
<li><p> Perimeter length
</p>
</li>
<li><p> &quot;Compact square&quot; statistic: <code class="reqn">4 \sqrt(area) / perimeter)</code>
</p>
</li>
<li><p> &quot;Compact circle&quot; statistic: <code class="reqn">4 * P / ( 2 \sqrt(\pi * A))</code> where <em>P</em> is the perimeter length and <em>A</em> the area.
</p>
</li>
<li><p> fractal dimension: <code class="reqn">2 ( log(P) / log(A + 0.001))</code> where <em>P</em> is perimeter length and <em>A</em> is area.
</p>
</li>
<li><p> The average x- and y-coordinates of each zone.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GRaster'
zonalGeog(x, unit = "meters")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zonalGeog+2B2CGRaster-method_+3A_x">x</code></td>
<td>
<p>A <code>GRaster</code>.</p>
</td></tr>
<tr><td><code id="zonalGeog+2B2CGRaster-method_+3A_unit">unit</code></td>
<td>
<p>Character: Units of the output. Any of:
</p>

<ul>
<li> <p><code>"meters"</code> (default)
</p>
</li>
<li> <p><code>"kilometers"</code> or <code>"km"</code>
</p>
</li>
<li> <p><code>"miles"</code> or <code>"mi"</code>
</p>
</li>
<li> <p><code>"yards"</code> or <code>"yd"</code>
</p>
</li>
<li> <p><code>"feet"</code> or <code>"ft"</code>: International foot; 1 foot exactly equal to 0.3048 meters
</p>
</li>
<li> <p><code>"cells"</code>: Number or cells
</p>
</li></ul>

<p>Partial matching is used and case is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>data.frame</code>s or a <code>data.table</code>s, one per layer in <code>x</code>. Only layers that are integers or factors have their geographies calculated. Other layers have <code>NULL</code> tables returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (grassStarted()) {

# Setup
library(terra)

# Example data: Elevation and land cover
madElev &lt;- fastData("madElev")
madForest2000 &lt;- fastData("madForest2000")
madCover &lt;- fastData("madCover")

# Convert to GRasters:
elev &lt;- fast(madElev)
forest2000 &lt;- fast(madForest2000)
cover &lt;- fast(madCover)

# Rename
names(elev) &lt;- "elev"
names(forest2000) &lt;- "forest"

# Geometric statistics for an integer raster zoned by elevation:
fun &lt;-
  "= if (elev &lt;400 &amp; forest == 1, 0, if (elev &gt;=400 &amp; forest == 1, 1, null()))"
forestByElev &lt;- app(c(elev, forest2000), fun = fun)
plot(forestByElev, main = "forest &lt; 400 m &amp; &gt;= 400 m")
zonalGeog(forestByElev)

# Geometric statistics for a categorical raster:
zonalGeog(cover)

}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
