<!DOCTYPE html><html><head><title>Help for package reshape</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {reshape}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add.all.combinations'><p>Add all combinations</p></a></li>
<li><a href='#add.missing.levels'><p>Add in any missing values</p></a></li>
<li><a href='#all.vars.character'><p>Get all variables</p></a></li>
<li><a href='#as.data.frame.cast_df'><p>as.data.frame.cast\_df</p></a></li>
<li><a href='#as.data.frame.cast_matrix'><p>as.data.frame.cast\_matrix</p></a></li>
<li><a href='#as.matrix.cast_df'><p>as.matrix.cast\_df</p></a></li>
<li><a href='#as.matrix.cast_matrix'><p>as.matrix.cast\_matrix</p></a></li>
<li><a href='#cast'><p>Cast function</p></a></li>
<li><a href='#cast_matrix'><p>Cast matrix.</p></a></li>
<li><a href='#cast_parse_formula'><p>Cast parse formula</p></a></li>
<li><a href='#check_formula'><p>Check formula</p></a></li>
<li><a href='#clean.vars'><p>Clean variables.</p></a></li>
<li><a href='#colsplit'><p>Split a vector into multiple columns</p></a></li>
<li><a href='#combine_factor'><p>Combine factor levels</p></a></li>
<li><a href='#compute.margins'><p>Compute margins</p></a></li>
<li><a href='#condense'><p>Condense</p></a></li>
<li><a href='#condense.df'><p>Condense a data frame</p></a></li>
<li><a href='#dim_names'><p>Dimension names</p></a></li>
<li><a href='#expand'><p>Expand</p></a></li>
<li><a href='#expand.grid.df'><p>Expand grid</p></a></li>
<li><a href='#French+20fries'><p>Sensory data from a french fries experiment</p></a></li>
<li><a href='#funstofun'><p>Aggregate multiple functions into a single function</p></a></li>
<li><a href='#guess_value'><p>Guess value</p></a></li>
<li><a href='#margin.vars'><p>Margin variables</p></a></li>
<li><a href='#melt'><p>Melt</p></a></li>
<li><a href='#melt_check'><p>Melt check.</p></a></li>
<li><a href='#melt.array'><p>Melt an array</p></a></li>
<li><a href='#melt.cast_df'><p>Melt cast data.frames</p></a></li>
<li><a href='#melt.cast_matrix'><p>Melt cast matrices</p></a></li>
<li><a href='#melt.data.frame'><p>Melt a data frame</p></a></li>
<li><a href='#melt.default'><p>Default melt function</p></a></li>
<li><a href='#melt.list'><p>Melt a list</p></a></li>
<li><a href='#merge_all'><p>Merge all</p></a></li>
<li><a href='#merge_recurse'><p>Merge recursively</p></a></li>
<li><a href='#namerows'><p>Name rows</p></a></li>
<li><a href='#nested.by'><p>Nested.by function</p></a></li>
<li><a href='#nulldefault'><p>Null default</p></a></li>
<li><a href='#prettyprint'><p>Pretty print</p></a></li>
<li><a href='#rdimnames'><p>Dimension names</p></a></li>
<li><a href='#recast'><p>Recast</p></a></li>
<li><a href='#rename'><p>Rename</p></a></li>
<li><a href='#rescaler'><p>Rescaler</p></a></li>
<li><a href='#rescaler.data.frame'><p>Rescale a data frame</p></a></li>
<li><a href='#rescaler.default'><p>Default rescaler</p></a></li>
<li><a href='#rescaler.matrix'><p>Rescale a matrix</p></a></li>
<li><a href='#reshape1'><p>Casting workhorse.</p></a></li>
<li><a href='#round_any'><p>Round any</p></a></li>
<li><a href='#Smiths'><p>Demo data describing the Smiths</p></a></li>
<li><a href='#sort_df'><p>Sort data frame</p></a></li>
<li><a href='#sparseby'><p>Apply a Function to a Data Frame split by levels of indices</p></a></li>
<li><a href='#stamp'><p>Stamp</p></a></li>
<li><a href='#str.cast_matrix'><p>Print cast objects</p></a></li>
<li><a href='#strip.dups'><p>Strip duplicates.</p></a></li>
<li><a href='#tidystamp'><p>Tidy up stamped data set</p></a></li>
<li><a href='#Tips'><p>Tipping data</p></a></li>
<li><a href='#uniquedefault'><p>Unique default</p></a></li>
<li><a href='#untable'><p>Untable a dataset</p></a></li>
<li><a href='#updatelist'><p>Update list</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.8.9</td>
</tr>
<tr>
<td>Title:</td>
<td>Flexibly Reshape Data</td>
</tr>
<tr>
<td>Description:</td>
<td>Flexibly restructure and aggregate data using 
  just two functions: melt and cast.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://had.co.nz/reshape">http://had.co.nz/reshape</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.6.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>plyr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-12 14:33:18 UTC; hadleywickham</td>
</tr>
<tr>
<td>Author:</td>
<td>Hadley Wickham [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hadley Wickham &lt;hadley@rstudio.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-12 15:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add.all.combinations'>Add all combinations</h2><span id='topic+add.all.combinations'></span>

<h3>Description</h3>

<p>Add all combinations of the given rows and columns to the data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.all.combinations(data, vars = list(NULL), fill=NA)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.all.combinations_+3A_data">data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="add.all.combinations_+3A_vars">vars</code></td>
<td>
<p>variables (list of character vectors)</p>
</td></tr>
<tr><td><code id="add.all.combinations_+3A_fill">fill</code></td>
<td>
<p>value to fill structural missings with</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to ensure that we have a matrix of the appropriate
dimensionaliy with no missing cells.</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>rdunif &lt;- 
function(n=20, min=0, max=10) floor(runif(n,min, max))
df &lt;- data.frame(a = rdunif(), b = rdunif(),c = rdunif(), result=1:20)
add.all.combinations(df)
add.all.combinations(df, list("a", "b"))
add.all.combinations(df, list("a", "b"), fill=0)
add.all.combinations(df, list(c("a", "b")))
add.all.combinations(df, list("a", "b", "c"))
add.all.combinations(df, list(c("a", "b"), "c"))
add.all.combinations(df, list(c("a", "b", "c")))</code></pre>

<hr>
<h2 id='add.missing.levels'>Add in any missing values</h2><span id='topic+add.missing.levels'></span>

<h3>Description</h3>

<p>@keyword internal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.missing.levels(data, vars=NULL, fill=NA)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.missing.levels_+3A_data">data</code></td>
<td>
</td></tr>
<tr><td><code id="add.missing.levels_+3A_vars">vars</code></td>
<td>
</td></tr>
<tr><td><code id="add.missing.levels_+3A_fill">fill</code></td>
<td>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='all.vars.character'>Get all variables</h2><span id='topic+all.vars.character'></span>

<h3>Description</h3>

<p>All variables in character string of formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all.vars.character(formula, blank.char = ".")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all.vars.character_+3A_formula">formula</code></td>
<td>
</td></tr>
<tr><td><code id="all.vars.character_+3A_blank.char">blank.char</code></td>
<td>
</td></tr>
</table>


<h3>Details</h3>

<p>Removes .</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>all.vars.character("a + b")
all.vars.character("a + b | c")
all.vars.character("a + b")
all.vars.character(". ~ a + b")
all.vars.character("a ~ b | c + d + e")</code></pre>

<hr>
<h2 id='as.data.frame.cast_df'>as.data.frame.cast\_df</h2><span id='topic+as.data.frame.cast_df'></span>

<h3>Description</h3>

<p>Convert cast data.frame into a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cast_df'
as.data.frame(x, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.cast_df_+3A_x">x</code></td>
<td>
</td></tr>
<tr><td><code id="as.data.frame.cast_df_+3A_...">...</code></td>
<td>
</td></tr>
</table>


<h3>Details</h3>

<p>Strips off cast related attributes so data frame becomes a normal data frame</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='as.data.frame.cast_matrix'>as.data.frame.cast\_matrix</h2><span id='topic+as.data.frame.cast_matrix'></span>

<h3>Description</h3>

<p>Convert cast matrix into a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cast_matrix'
as.data.frame(x, row.names, optional, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.cast_matrix_+3A_x">x</code></td>
<td>
</td></tr>
<tr><td><code id="as.data.frame.cast_matrix_+3A_row.names">row.names</code></td>
<td>
</td></tr>
<tr><td><code id="as.data.frame.cast_matrix_+3A_optional">optional</code></td>
<td>
</td></tr>
<tr><td><code id="as.data.frame.cast_matrix_+3A_...">...</code></td>
<td>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts a matrix produced by cast into a data frame with
appropriate id columns.</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='as.matrix.cast_df'>as.matrix.cast\_df</h2><span id='topic+as.matrix.cast_df'></span>

<h3>Description</h3>

<p>Convert cast data.frame into a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cast_df'
as.matrix(x, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.cast_df_+3A_x">x</code></td>
<td>
</td></tr>
<tr><td><code id="as.matrix.cast_df_+3A_...">...</code></td>
<td>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts a data frame produced by cast into a matrix with
appropriate dimnames.</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='as.matrix.cast_matrix'>as.matrix.cast\_matrix</h2><span id='topic+as.matrix.cast_matrix'></span>

<h3>Description</h3>

<p>Convert cast matrix into a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cast_matrix'
as.matrix(x, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.cast_matrix_+3A_x">x</code></td>
<td>
</td></tr>
<tr><td><code id="as.matrix.cast_matrix_+3A_...">...</code></td>
<td>
</td></tr>
</table>


<h3>Details</h3>

<p>Strips off cast related attributes so matrix becomes a normal matrix</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='cast'>Cast function</h2><span id='topic+cast'></span>

<h3>Description</h3>

<p>Cast a molten data frame into the reshaped or aggregated form you want
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cast(data, formula = ... ~ variable, fun.aggregate=NULL, ...,
  margins=FALSE, subset=TRUE, df=FALSE, fill=NULL, add.missing=FALSE,
  value = guess_value(data))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cast_+3A_data">data</code></td>
<td>
<p>molten data frame, see <code><a href="#topic+melt">melt</a></code></p>
</td></tr>
<tr><td><code id="cast_+3A_formula">formula</code></td>
<td>
<p>casting formula, see details for specifics</p>
</td></tr>
<tr><td><code id="cast_+3A_fun.aggregate">fun.aggregate</code></td>
<td>
<p>aggregation function</p>
</td></tr>
<tr><td><code id="cast_+3A_add.missing">add.missing</code></td>
<td>
<p>fill in missing combinations?</p>
</td></tr>
<tr><td><code id="cast_+3A_value">value</code></td>
<td>
<p>name of value column</p>
</td></tr>
<tr><td><code id="cast_+3A_...">...</code></td>
<td>
<p>further arguments are passed to aggregating function</p>
</td></tr>
<tr><td><code id="cast_+3A_margins">margins</code></td>
<td>
<p>vector of variable names (can include &quot;grand\_col&quot; and &quot;grand\_row&quot;) to compute margins for, or TRUE to computer all margins</p>
</td></tr>
<tr><td><code id="cast_+3A_subset">subset</code></td>
<td>
<p>logical vector to subset data set with before reshaping</p>
</td></tr>
<tr><td><code id="cast_+3A_df">df</code></td>
<td>
<p>argument used internally</p>
</td></tr>
<tr><td><code id="cast_+3A_fill">fill</code></td>
<td>
<p>value with which to fill in structural missings, defaults to value from applying <code>fun.aggregate</code> to 0 length vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Along with <code><a href="#topic+melt">melt</a></code>  and <a href="#topic+recast">recast</a>, this is the only function you should ever need to use.
Once you have melted your data, cast will arrange it into the form you desire
based on the specification given by <code>formula</code>.
</p>
<p>The cast formula has the following format: <code>x_variable + x_2 ~ y_variable + y_2 ~ z_variable ~  ... | list_variable + ... </code>
The order of the variables makes a difference.  The first varies slowest, and the last
fastest.  There are a couple of special variables: &quot;...&quot; represents all other variables
not used in the formula and &quot;.&quot; represents no variable, so you can do <code>formula=var1 ~ .</code>
</p>
<p>Creating high-D arrays is simple, and allows a class of transformations that are hard
without <code><a href="base.html#topic+apply">apply</a></code> and <code><a href="base.html#topic+sweep">sweep</a></code>
</p>
<p>If the combination of variables you supply does not uniquely identify one row in the
original data set, you will need to supply an aggregating function, <code>fun.aggregate</code>.
This function should take a vector of numbers and return a summary statistic(s).  It must
return the same number of arguments regardless of the length of the input vector.
If it returns multiple value you can use &quot;result\_variable&quot; to control where they appear.
By default they will appear as the last column variable.
</p>
<p>The margins argument should be passed a vector of variable names, eg.
<code>c("month","day")</code>.  It will silently drop any variables that can not be margined
over.  You can also use &quot;grand\_col&quot; and &quot;grand\_row&quot; to get grand row and column margins
respectively.
</p>
<p>Subset takes a logical vector that will be evaluated in the context of <code>data</code>,
so you can do something like <code>subset = variable=="length"</code>
</p>
<p>All the actual reshaping is done by <code><a href="#topic+reshape1">reshape1</a></code>, see its documentation
for details of the implementation</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+reshape1">reshape1</a></code>,  <a href="http://had.co.nz/reshape/">http://had.co.nz/reshape/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>#Air quality example
names(airquality) &lt;- tolower(names(airquality))
aqm &lt;- melt(airquality, id=c("month", "day"), na.rm=TRUE)

cast(aqm, day ~ month ~ variable)
cast(aqm, month ~ variable, mean)
cast(aqm, month ~ . | variable, mean)
cast(aqm, month ~ variable, mean, margins=c("grand_row", "grand_col"))
cast(aqm, day ~ month, mean, subset=variable=="ozone")
cast(aqm, month ~ variable, range)
cast(aqm, month ~ variable + result_variable, range)
cast(aqm, variable ~ month ~ result_variable,range)

#Chick weight example
names(ChickWeight) &lt;- tolower(names(ChickWeight))
chick_m &lt;- melt(ChickWeight, id=2:4, na.rm=TRUE)

cast(chick_m, time ~ variable, mean) # average effect of time
cast(chick_m, diet ~ variable, mean) # average effect of diet
cast(chick_m, diet ~ time ~ variable, mean) # average effect of diet &amp; time

# How many chicks at each time? - checking for balance
cast(chick_m, time ~ diet, length)
cast(chick_m, chick ~ time, mean)
cast(chick_m, chick ~ time, mean, subset=time &lt; 10 &amp; chick &lt; 20)

cast(chick_m, diet + chick ~ time)
cast(chick_m, chick ~ time ~ diet)
cast(chick_m, diet + chick ~ time, mean, margins="diet")

#Tips example
cast(melt(tips), sex ~ smoker, mean, subset=variable=="total_bill")
cast(melt(tips), sex ~ smoker | variable, mean)

ff_d &lt;- melt(french_fries, id=1:4, na.rm=TRUE)
cast(ff_d, subject ~ time, length)
cast(ff_d, subject ~ time, length, fill=0)
cast(ff_d, subject ~ time, function(x) 30 - length(x))
cast(ff_d, subject ~ time, function(x) 30 - length(x), fill=30)
cast(ff_d, variable ~ ., c(min, max))
cast(ff_d, variable ~ ., function(x) quantile(x,c(0.25,0.5)))
cast(ff_d, treatment ~ variable, mean, margins=c("grand_col", "grand_row"))
cast(ff_d, treatment + subject ~ variable, mean, margins="treatment")
</code></pre>

<hr>
<h2 id='cast_matrix'>Cast matrix.</h2><span id='topic+cast_matrix'></span>

<h3>Description</h3>

<p>Createa a new cast matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cast_matrix(m, dimnames)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cast_matrix_+3A_m">m</code></td>
<td>
<p>matrix to turn into cast matrix</p>
</td></tr>
<tr><td><code id="cast_matrix_+3A_dimnames">dimnames</code></td>
<td>
<p>list of dimension names (as data.frames), row, col, ...</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For internal use only</p>


<h3>Value</h3>

<p>object of type <code><a href="#topic+cast_matrix">cast_matrix</a></code></p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='cast_parse_formula'>Cast parse formula</h2><span id='topic+cast_parse_formula'></span>

<h3>Description</h3>

<p>Parse formula for casting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cast_parse_formula(formula = "...  ~ variable", varnames)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cast_parse_formula_+3A_formula">formula</code></td>
<td>
</td></tr>
<tr><td><code id="cast_parse_formula_+3A_varnames">varnames</code></td>
<td>
</td></tr>
</table>


<h3>Details</h3>

<p>@value row character vector of row names
@value col character vector of column names
@value aggregate boolean whether aggregation will occur
@keyword internal</p>


<h3>Value</h3>

<table>
<tr><td><code>row</code></td>
<td>
<p>character vector of row names</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>character vector of column names</p>
</td></tr>
<tr><td><code>aggregate</code></td>
<td>
<p>boolean whether aggregation will occur</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>cast_parse_formula("a + ...", letters[1:6])
cast_parse_formula("a | ...", letters[1:6])
cast_parse_formula("a + b ~ c ~ . | ...", letters[1:6])</code></pre>

<hr>
<h2 id='check_formula'>Check formula</h2><span id='topic+check_formula'></span>

<h3>Description</h3>

<p>Checks that formula is a valid reshaping formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_formula(formula, varnames)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_formula_+3A_formula">formula</code></td>
<td>
<p>formula to check</p>
</td></tr>
<tr><td><code id="check_formula_+3A_varnames">varnames</code></td>
<td>
<p>vector of variable names</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='clean.vars'>Clean variables.</h2><span id='topic+clean.vars'></span>

<h3>Description</h3>

<p>Clean variable list for reshaping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean.vars(vars)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean.vars_+3A_vars">vars</code></td>
<td>
<p>vector of variable names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of &quot;real&quot; variable names (excluding result\_variable etc.)</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='colsplit'>Split a vector into multiple columns</h2><span id='topic+colsplit'></span><span id='topic+colsplit.factor'></span><span id='topic+colsplit.character'></span>

<h3>Description</h3>

<p>This function can be used to split up a column that has been pasted together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colsplit(x, split="", names)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colsplit_+3A_x">x</code></td>
<td>
<p>character vector or factor to split up</p>
</td></tr>
<tr><td><code id="colsplit_+3A_split">split</code></td>
<td>
<p>regular expression to split on</p>
</td></tr>
<tr><td><code id="colsplit_+3A_names">names</code></td>
<td>
<p>names for output columns</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='combine_factor'>Combine factor levels</h2><span id='topic+combine_factor'></span>

<h3>Description</h3>

<p>Convenience function to make it easy to combine multiple levels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_factor(fac, variable=levels(fac), other.label="Other")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_factor_+3A_fac">fac</code></td>
<td>
<p>factor variable</p>
</td></tr>
<tr><td><code id="combine_factor_+3A_variable">variable</code></td>
<td>
<p>either a vector of   .  See examples for more details.</p>
</td></tr>
<tr><td><code id="combine_factor_+3A_other.label">other.label</code></td>
<td>
<p>label for other level</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(a = LETTERS[sample(5, 15, replace=TRUE)], y = rnorm(15))  
combine_factor(df$a, c(1,2,2,1,2))
combine_factor(df$a, c(1:4, 1))
(f &lt;- reorder(df$a, df$y))
percent &lt;- tapply(abs(df$y), df$a, sum)
combine_factor(f, c(order(percent)[1:3]))</code></pre>

<hr>
<h2 id='compute.margins'>Compute margins</h2><span id='topic+compute.margins'></span>

<h3>Description</h3>

<p>Compute marginal values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.margins(data, margins, vars, fun.aggregate, ..., df=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.margins_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="compute.margins_+3A_margins">margins</code></td>
<td>
<p>margins to compute</p>
</td></tr>
<tr><td><code id="compute.margins_+3A_vars">vars</code></td>
<td>
<p>all id variables</p>
</td></tr>
<tr><td><code id="compute.margins_+3A_fun.aggregate">fun.aggregate</code></td>
<td>
<p>aggregation function</p>
</td></tr>
<tr><td><code id="compute.margins_+3A_...">...</code></td>
<td>
<p>other argument passed to aggregation function</p>
</td></tr>
<tr><td><code id="compute.margins_+3A_df">df</code></td>
<td>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='condense'>Condense</h2><span id='topic+condense'></span>

<h3>Description</h3>

<p>Condense a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condense(data, variables, fun, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condense_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="condense_+3A_variables">variables</code></td>
<td>
<p>variables to condense over</p>
</td></tr>
<tr><td><code id="condense_+3A_fun">fun</code></td>
<td>
<p>aggregating function, may multiple values</p>
</td></tr>
<tr><td><code id="condense_+3A_...">...</code></td>
<td>
<p>further arguments passed on to aggregating function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Works very much like by, but keeps data in original data frame format.
Results column is a list, so that each cell may contain an object or a vector etc.
Assumes data is in molten format. Aggregating function must return the
same number of arguments for all input.</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='condense.df'>Condense a data frame</h2><span id='topic+condense.df'></span>

<h3>Description</h3>

<p>Condense
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condense.df(data, variables, fun, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condense.df_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="condense.df_+3A_variables">variables</code></td>
<td>
<p>character vector of variables to condense over</p>
</td></tr>
<tr><td><code id="condense.df_+3A_fun">fun</code></td>
<td>
<p>function to condense with</p>
</td></tr>
<tr><td><code id="condense.df_+3A_...">...</code></td>
<td>
<p>arguments passed to condensing function</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='dim_names'>Dimension names</h2><span id='topic+dim_names'></span>

<h3>Description</h3>

<p>Convenience method for extracting row and column names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dim_names(data, vars)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dim_names_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="dim_names_+3A_vars">vars</code></td>
<td>
<p>variables to use</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='expand'>Expand</h2><span id='topic+expand'></span>

<h3>Description</h3>

<p>Expand out condensed data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand(data)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_+3A_data">data</code></td>
<td>
<p>condensed data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If aggregating function supplied to condense returns multiple values, this
function &quot;melts&quot; it again, creating a new column called result\_variable.
</p>
<p>If the aggregating funtion is a named vector, then those names will be used,
otherwise will be number X1, X2, ..., Xn etc.</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='expand.grid.df'>Expand grid</h2><span id='topic+expand.grid.df'></span>

<h3>Description</h3>

<p>Expand grid of data frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand.grid.df(..., unique=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand.grid.df_+3A_...">...</code></td>
<td>
<p>list of data frames (first varies fastest)</p>
</td></tr>
<tr><td><code id="expand.grid.df_+3A_unique">unique</code></td>
<td>
<p>only use unique rows?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates new data frame containing all combination of rows from
data.frames in <code>...</code></p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>expand.grid.df(data.frame(a=1,b=1:2))
expand.grid.df(data.frame(a=1,b=1:2), data.frame())
expand.grid.df(data.frame(a=1,b=1:2), data.frame(c=1:2, d=1:2))
expand.grid.df(data.frame(a=1,b=1:2), data.frame(c=1:2, d=1:2), data.frame(e=c("a","b")))</code></pre>

<hr>
<h2 id='French+20fries'>Sensory data from a french fries experiment</h2><span id='topic+french_fries'></span>

<h3>Description</h3>

<p>This data was collected from a sensory experiment conducted at Iowa State University in 2004.  The investigators were interested in the effect of using three different fryer oils had on the taste of the fries.
</p>
<p>Variables:
</p>

<ul>
<li><p> time in weeks from start of study.
</p>
</li>
<li><p> treatment (type of oil), 
</p>
</li>
<li><p> subject, 
</p>
</li>
<li><p> replicate, 
</p>
</li>
<li><p> potato-y flavour, 
</p>
</li>
<li><p> buttery flavour, 
</p>
</li>
<li><p> grassy flavour,
</p>
</li>
<li><p> rancid flavour,
</p>
</li>
<li><p> painty flavour 
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(french_fries)</code></pre>


<h3>Format</h3>

<p>A data frame with 696 rows and 9 variables</p>

<hr>
<h2 id='funstofun'>Aggregate multiple functions into a single function</h2><span id='topic+funstofun'></span>

<h3>Description</h3>

<p>Combine multiple functions to a single function returning a named vector of outputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funstofun(...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funstofun_+3A_...">...</code></td>
<td>
<p>functions to combine</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each function should produce a single number as output</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>funstofun(min, max)(1:10)
funstofun(length, mean, var)(rnorm(100))</code></pre>

<hr>
<h2 id='guess_value'>Guess value</h2><span id='topic+guess_value'></span>

<h3>Description</h3>

<p>Guess name of value column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess_value(df)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guess_value_+3A_df">df</code></td>
<td>
<p>Data frame to guess value column from</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Strategy:
</p>

<ol>
<li><p> Is value or (all) column present? If so, use that
</p>
</li>
<li><p> Otherwise, guess that last column is the value column
</p>
</li></ol>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='margin.vars'>Margin variables</h2><span id='topic+margin.vars'></span>

<h3>Description</h3>

<p>Works out list of variables to margin over to get desired margins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>margin.vars(vars = list(NULL, NULL), margins = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="margin.vars_+3A_vars">vars</code></td>
<td>
<p>list of column and row variables</p>
</td></tr>
<tr><td><code id="margin.vars_+3A_margins">margins</code></td>
<td>
<p>vector of variable names to margin over</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Variables that can't be margined over are dropped silently.</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='melt'>Melt</h2><span id='topic+melt'></span>

<h3>Description</h3>

<p>Melt an object into a form suitable for easy casting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>melt(data, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="melt_+3A_data">data</code></td>
<td>
<p>Data set to melt</p>
</td></tr>
<tr><td><code id="melt_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the specific melt method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This the generic melt function. See the following functions
for specific details for different data structures:
</p>

<ul>
<li> <p><code><a href="#topic+melt.data.frame">melt.data.frame</a></code> for data.frames
</p>
</li>
<li> <p><code><a href="#topic+melt.array">melt.array</a></code> for arrays, matrices and tables
</p>
</li>
<li> <p><code><a href="#topic+melt.list">melt.list</a></code> for lists
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='melt_check'>Melt check.</h2><span id='topic+melt_check'></span>

<h3>Description</h3>

<p>Check that input variables to melt are appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>melt_check(data, id.vars, measure.vars)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="melt_check_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="melt_check_+3A_id.vars">id.vars</code></td>
<td>
<p>Vector of identifying variable names or indexes</p>
</td></tr>
<tr><td><code id="melt_check_+3A_measure.vars">measure.vars</code></td>
<td>
<p>Vector of Measured variable names or indexes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If id.vars or measure.vars are missing, <code>melt_check</code> will do its
best to impute them.If you only
supply one of id.vars and measure.vars, melt will assume the remainder of
the variables in the data set belong to the other. If you supply neither,
melt will assume character and factor variables are id variables,
and all other are measured.</p>


<h3>Value</h3>

<table>
<tr><td><code>id</code></td>
<td>
<p>list id variable names</p>
</td></tr>
<tr><td><code>measure</code></td>
<td>
<p>list of measured variable names</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='melt.array'>Melt an array</h2><span id='topic+melt.array'></span><span id='topic+melt.matrix'></span><span id='topic+melt.table'></span>

<h3>Description</h3>

<p>This function melts a high-dimensional array into a form that you can use <code><a href="#topic+cast">cast</a></code> with.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'array'
melt(data, varnames = names(dimnames(data)), ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="melt.array_+3A_data">data</code></td>
<td>
<p>array to melt</p>
</td></tr>
<tr><td><code id="melt.array_+3A_varnames">varnames</code></td>
<td>
<p>variable names to use in molten data.frame</p>
</td></tr>
<tr><td><code id="melt.array_+3A_...">...</code></td>
<td>
<p>other arguments ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This code is conceptually similar to <code><a href="base.html#topic+as.data.frame.table">as.data.frame.table</a></code></p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- array(1:24, c(2,3,4))
melt(a)
melt(a, varnames=c("X","Y","Z"))
dimnames(a) &lt;- lapply(dim(a), function(x) LETTERS[1:x])
melt(a)
melt(a, varnames=c("X","Y","Z"))
dimnames(a)[1] &lt;- list(NULL)
melt(a)</code></pre>

<hr>
<h2 id='melt.cast_df'>Melt cast data.frames</h2><span id='topic+melt.cast_df'></span>

<h3>Description</h3>

<p>Melt the results of a cast
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cast_df'
melt(data, drop.margins=TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="melt.cast_df_+3A_data">data</code></td>
<td>
</td></tr>
<tr><td><code id="melt.cast_df_+3A_drop.margins">drop.margins</code></td>
<td>
</td></tr>
<tr><td><code id="melt.cast_df_+3A_...">...</code></td>
<td>
<p>other arguments ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This can be useful when performning complex aggregations - melting
the result of a cast will do it's best to figure out the correct variables
to use as id and measured.</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='melt.cast_matrix'>Melt cast matrices</h2><span id='topic+melt.cast_matrix'></span>

<h3>Description</h3>

<p>Melt the results of a cast
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cast_matrix'
melt(data, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="melt.cast_matrix_+3A_data">data</code></td>
<td>
</td></tr>
<tr><td><code id="melt.cast_matrix_+3A_...">...</code></td>
<td>
<p>other arguments ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts to a data frame and then uses <code><a href="#topic+melt.cast_df">melt.cast_df</a></code></p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='melt.data.frame'>Melt a data frame</h2><span id='topic+melt.data.frame'></span>

<h3>Description</h3>

<p>Melt a data frame into form suitable for easy casting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
melt(data, id.vars, measure.vars,
  variable_name = "variable", na.rm = !preserve.na, preserve.na = TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="melt.data.frame_+3A_data">data</code></td>
<td>
<p>Data set to melt</p>
</td></tr>
<tr><td><code id="melt.data.frame_+3A_id.vars">id.vars</code></td>
<td>
<p>Id variables. If blank, will use all non measure.vars variables.  Can be integer (variable position) or string (variable name)</p>
</td></tr>
<tr><td><code id="melt.data.frame_+3A_measure.vars">measure.vars</code></td>
<td>
<p>Measured variables. If blank, will use all non id.vars variables. Can be integer (variable position) or string (variable name)</p>
</td></tr>
<tr><td><code id="melt.data.frame_+3A_variable_name">variable_name</code></td>
<td>
<p>Name of the variable that will store the names of the original variables</p>
</td></tr>
<tr><td><code id="melt.data.frame_+3A_na.rm">na.rm</code></td>
<td>
<p>Should NA values be removed from the data set?</p>
</td></tr>
<tr><td><code id="melt.data.frame_+3A_preserve.na">preserve.na</code></td>
<td>
<p>Old argument name, now deprecated</p>
</td></tr>
<tr><td><code id="melt.data.frame_+3A_...">...</code></td>
<td>
<p>other arguments ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You need to tell melt which of your variables are id variables, and which
are measured variables. If you only supply one of <code>id.vars</code> and
<code>measure.vars</code>, melt will assume the remainder of the variables in the
data set belong to the other. If you supply neither, melt will assume
factor and character variables are id variables, and all others are
measured.</p>


<h3>Value</h3>

<p>molten data</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>


<h3>See Also</h3>

<p><a href="http://had.co.nz/reshape/">http://had.co.nz/reshape/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>head(melt(tips))
names(airquality) &lt;- tolower(names(airquality))
melt(airquality, id=c("month", "day"))
names(ChickWeight) &lt;- tolower(names(ChickWeight))
melt(ChickWeight, id=2:4)</code></pre>

<hr>
<h2 id='melt.default'>Default melt function</h2><span id='topic+melt.default'></span>

<h3>Description</h3>

<p>For vectors, make a column of a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
melt(data, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="melt.default_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="melt.default_+3A_...">...</code></td>
<td>
<p>arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='melt.list'>Melt a list</h2><span id='topic+melt.list'></span>

<h3>Description</h3>

<p>Melting a list recursively melts each component of the list and joins the results together
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
melt(data, ..., level=1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="melt.list_+3A_data">data</code></td>
<td>
</td></tr>
<tr><td><code id="melt.list_+3A_...">...</code></td>
<td>
<p>other arguments passed down</p>
</td></tr>
<tr><td><code id="melt.list_+3A_level">level</code></td>
<td>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- as.list(1:4)
melt(a)
names(a) &lt;- letters[1:4]
melt(a)
attr(a, "varname") &lt;- "ID"
melt(a)
a &lt;- list(matrix(1:4, ncol=2), matrix(1:6, ncol=2))
melt(a)
a &lt;- list(matrix(1:4, ncol=2), array(1:27, c(3,3,3)))
melt(a)
melt(list(1:5, matrix(1:4, ncol=2)))
melt(list(list(1:3), 1, list(as.list(3:4), as.list(1:2))))</code></pre>

<hr>
<h2 id='merge_all'>Merge all</h2><span id='topic+merge_all'></span>

<h3>Description</h3>

<p>Merge together a series of data.frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_all(dfs, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_all_+3A_dfs">dfs</code></td>
<td>
<p>list of data frames to merge</p>
</td></tr>
<tr><td><code id="merge_all_+3A_...">...</code></td>
<td>
<p>other arguments passed on to merge</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Order of data frames should be from most complete to least complete</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+merge_recurse">merge_recurse</a></code></p>

<hr>
<h2 id='merge_recurse'>Merge recursively</h2><span id='topic+merge_recurse'></span>

<h3>Description</h3>

<p>Recursively merge data frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_recurse(dfs, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_recurse_+3A_dfs">dfs</code></td>
<td>
<p>list of data frames to merge</p>
</td></tr>
<tr><td><code id="merge_recurse_+3A_...">...</code></td>
<td>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+merge_all">merge_all</a></code></p>

<hr>
<h2 id='namerows'>Name rows</h2><span id='topic+namerows'></span>

<h3>Description</h3>

<p>Add variable to data frame containing rownames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>namerows(df, col.name = "id")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="namerows_+3A_df">df</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="namerows_+3A_col.name">col.name</code></td>
<td>
<p>name of new column containing rownames</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is useful when the thing that you want to melt by is the rownames
of the data frame, not an explicit variable</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='nested.by'>Nested.by function</h2><span id='topic+nested.by'></span>

<h3>Description</h3>

<p>Nest series of by statements returning nested list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nested.by(data, INDICES, FUN, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nested.by_+3A_data">data</code></td>
<td>
</td></tr>
<tr><td><code id="nested.by_+3A_indices">INDICES</code></td>
<td>
</td></tr>
<tr><td><code id="nested.by_+3A_fun">FUN</code></td>
<td>
</td></tr>
<tr><td><code id="nested.by_+3A_...">...</code></td>
<td>
</td></tr>
</table>


<h3>Details</h3>

<p>Work horse for producing cast lists.</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='nulldefault'>Null default</h2><span id='topic+nulldefault'></span>

<h3>Description</h3>

<p>Use default value when null
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nulldefault(x, default)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nulldefault_+3A_x">x</code></td>
<td>
</td></tr>
<tr><td><code id="nulldefault_+3A_default">default</code></td>
<td>
</td></tr>
</table>


<h3>Details</h3>

<p>Handy method when argument defaults aren't good enough.</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='prettyprint'>Pretty print</h2><span id='topic+prettyprint'></span>

<h3>Description</h3>

<p>Print reshaped data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prettyprint(x, digits=getOption("digits"), ..., colnames=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prettyprint_+3A_x">x</code></td>
<td>
</td></tr>
<tr><td><code id="prettyprint_+3A_digits">digits</code></td>
<td>
</td></tr>
<tr><td><code id="prettyprint_+3A_...">...</code></td>
<td>
</td></tr>
<tr><td><code id="prettyprint_+3A_colnames">colnames</code></td>
<td>
</td></tr>
</table>


<h3>Details</h3>

<p>This will always work on the direct output from cast, but may not
if you have manipulated (e.g. subsetted) the results.</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='rdimnames'>Dimension names</h2><span id='topic+rdimnames'></span><span id='topic+rdimnames+3C-'></span><span id='topic+rcolnames'></span><span id='topic+rcolnames+3C-'></span><span id='topic+rrownames'></span><span id='topic+rrownames+3C-'></span>

<h3>Description</h3>

<p>These methods provide easy access to the special dimension names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdimnames(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdimnames_+3A_x">x</code></td>
<td>
</td></tr>
</table>


<h3>Details</h3>

<p>Reshape stores dimension names in a slightly different format to
base R, to allow for (e.g.) multiple levels of column header.  These
accessor functions allow you to get and set them.</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='recast'>Recast</h2><span id='topic+recast'></span>

<h3>Description</h3>

<p><a href="#topic+melt">melt</a> and <a href="#topic+cast">cast</a> data in a single step
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recast(data, formula, ..., id.var, measure.var)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recast_+3A_data">data</code></td>
<td>
<p>Data set to melt</p>
</td></tr>
<tr><td><code id="recast_+3A_formula">formula</code></td>
<td>
<p>Casting formula, see <a href="#topic+cast">cast</a> for specifics</p>
</td></tr>
<tr><td><code id="recast_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <a href="#topic+cast">cast</a></p>
</td></tr>
<tr><td><code id="recast_+3A_id.var">id.var</code></td>
<td>
<p>Identifying variables. If blank, will use all non measure.var variables</p>
</td></tr>
<tr><td><code id="recast_+3A_measure.var">measure.var</code></td>
<td>
<p>Measured variables. If blank, will use all non id.var variables</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This conveniently wraps melting and casting a data frame into
one step.</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>


<h3>See Also</h3>

<p><a href="http://had.co.nz/reshape/">http://had.co.nz/reshape/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>recast(french_fries, time ~ variable, id.var=1:4)</code></pre>

<hr>
<h2 id='rename'>Rename</h2><span id='topic+rename'></span>

<h3>Description</h3>

<p>Rename an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename(x, replace)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_+3A_x">x</code></td>
<td>
<p>object to be renamed</p>
</td></tr>
<tr><td><code id="rename_+3A_replace">replace</code></td>
<td>
<p>named vector specifying new names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rename function provide an easy way to rename the columns of a
data.frame or the items in a list.</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>rename(mtcars, c(wt = "weight", cyl = "cylinders"))
a &lt;- list(a = 1, b = 2, c = 3)
rename(a, c(b = "a", c = "b", a="c")) 

# Example supplied by Timothy Bates
names &lt;- c("john", "tim", "andy")
ages &lt;- c(50, 46, 25)
mydata &lt;- data.frame(names,ages)
names(mydata) #-&gt; "name",  "ages"

# lets change "ages" to singular.
# nb: The operation is not done in place, so you need to set your 
# data to that returned from rename

mydata &lt;- rename(mydata, c(ages="age"))
names(mydata) #-&gt; "name",  "age"</code></pre>

<hr>
<h2 id='rescaler'>Rescaler</h2><span id='topic+rescaler'></span>

<h3>Description</h3>

<p>Convenient methods for rescaling data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescaler(x, type="sd", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescaler_+3A_x">x</code></td>
<td>
<p>object to rescale</p>
</td></tr>
<tr><td><code id="rescaler_+3A_type">type</code></td>
<td>
<p>type of rescaling to use (see description for details)</p>
</td></tr>
<tr><td><code id="rescaler_+3A_...">...</code></td>
<td>
<p>other options (only pasesed to <code><a href="base.html#topic+rank">rank</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Provides methods for vectors, matrices and data.frames
</p>
<p>Currently, five rescaling options are implemented:
</p>

<ul>
<li> <p><code>I</code>: do nothing
</p>
</li>
<li> <p><code>range</code>: scale to [0, 1]
</p>
</li>
<li> <p><code>rank</code>: convert values to ranks
</p>
</li>
<li> <p><code>robust</code>: robust version of <code>sd</code>, substract median and divide by median absolute deviation
</p>
</li>
<li> <p><code>sd</code>: subtract mean and divide by standard deviation
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+rescaler.default">rescaler.default</a></code></p>

<hr>
<h2 id='rescaler.data.frame'>Rescale a data frame</h2><span id='topic+rescaler.data.frame'></span>

<h3>Description</h3>

<p>Rescales data frame by columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
rescaler(x, type="sd", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescaler.data.frame_+3A_x">x</code></td>
<td>
<p>data.frame to rescale</p>
</td></tr>
<tr><td><code id="rescaler.data.frame_+3A_type">type</code></td>
<td>
<p>type of rescaling to apply</p>
</td></tr>
<tr><td><code id="rescaler.data.frame_+3A_...">...</code></td>
<td>
<p>other arguments passed to rescaler</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='rescaler.default'>Default rescaler</h2><span id='topic+rescaler.default'></span>

<h3>Description</h3>

<p>See <code><a href="#topic+rescaler">rescaler</a></code> for details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
rescaler(x, type="sd", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescaler.default_+3A_x">x</code></td>
<td>
<p>vector to rescale</p>
</td></tr>
<tr><td><code id="rescaler.default_+3A_type">type</code></td>
<td>
<p>type of rescaling to apply</p>
</td></tr>
<tr><td><code id="rescaler.default_+3A_...">...</code></td>
<td>
<p>other arguments passed to rescaler</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='rescaler.matrix'>Rescale a matrix</h2><span id='topic+rescaler.matrix'></span>

<h3>Description</h3>

<p>Rescales matrix by columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
rescaler(x, type="sd", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescaler.matrix_+3A_x">x</code></td>
<td>
<p>matrix to rescale</p>
</td></tr>
<tr><td><code id="rescaler.matrix_+3A_type">type</code></td>
<td>
<p>type of rescaling to apply</p>
</td></tr>
<tr><td><code id="rescaler.matrix_+3A_...">...</code></td>
<td>
<p>other arguments passed to rescaler</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='reshape1'>Casting workhorse.</h2><span id='topic+reshape1'></span>

<h3>Description</h3>

<p>Takes data frame and variable list and casts data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reshape1(data, vars = list(NULL, NULL), fun.aggregate=NULL, margins,
  df=FALSE, fill=NA, add.missing=FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reshape1_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="reshape1_+3A_vars">vars</code></td>
<td>
<p>variables to appear in columns</p>
</td></tr>
<tr><td><code id="reshape1_+3A_fun.aggregate">fun.aggregate</code></td>
<td>
<p>variables to appear in rows</p>
</td></tr>
<tr><td><code id="reshape1_+3A_margins">margins</code></td>
<td>
<p>aggregation function</p>
</td></tr>
<tr><td><code id="reshape1_+3A_df">df</code></td>
<td>
<p>should the aggregating function be supplied with the entire data frame, or just the relevant entries from the values column</p>
</td></tr>
<tr><td><code id="reshape1_+3A_fill">fill</code></td>
<td>
<p>vector of variable names (can include &quot;grand\_col&quot; and &quot;grand\_row&quot;) to compute margins for, or TRUE to computer all margins</p>
</td></tr>
<tr><td><code id="reshape1_+3A_add.missing">add.missing</code></td>
<td>
<p>value with which to fill in structural missings</p>
</td></tr>
<tr><td><code id="reshape1_+3A_...">...</code></td>
<td>
<p>further arguments are passed to aggregating function</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+cast">cast</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ffm &lt;- melt(french_fries, id=1:4, na.rm = TRUE)
# Casting lists ----------------------------
cast(ffm, treatment ~ rep | variable, mean)
cast(ffm, treatment ~ rep | subject, mean)
cast(ffm, treatment ~ rep | time, mean)
cast(ffm, treatment ~ rep | time + variable, mean)
names(airquality) &lt;- tolower(names(airquality))
aqm &lt;- melt(airquality, id=c("month", "day"), preserve=FALSE)
#Basic call
reshape1(aqm, list("month", NULL), mean)
reshape1(aqm, list("month", "variable"), mean)
reshape1(aqm, list("day", "month"), mean)

#Explore margins  ----------------------------
reshape1(aqm, list("month", NULL), mean, "month")
reshape1(aqm, list("month", NULL) , mean, "grand_col")
reshape1(aqm, list("month", NULL) , mean, "grand_row")

reshape1(aqm, list(c("month", "day"), NULL), mean, "month")
reshape1(aqm, list(c("month"), "variable"), mean, "month")
reshape1(aqm, list(c("variable"), "month"), mean, "month")
reshape1(aqm, list(c("month"), "variable"), mean, c("month","variable"))

reshape1(aqm, list(c("month"), "variable"), mean, c("grand_row"))
reshape1(aqm, list(c("month"), "variable"), mean, c("grand_col"))
reshape1(aqm, list(c("month"), "variable"), mean, c("grand_row","grand_col"))

reshape1(aqm, list(c("variable","day"),"month"), mean,c("variable"))
reshape1(aqm, list(c("variable","day"),"month"), mean,c("variable","grand_row"))
reshape1(aqm, list(c("month","day"), "variable"), mean, "month")

# Multiple fnction returns  ----------------------------
reshape1(aqm, list(c("month", "result_variable"), NULL), range)
reshape1(aqm, list(c("month"),"result_variable") , range)
reshape1(aqm, list(c("result_variable", "month"), NULL), range)

reshape1(aqm, list(c("month", "result_variable"), "variable"), range, "month")
reshape1(aqm, list(c("month", "result_variable"), "variable"), range, "variable")
reshape1(aqm, list(c("month", "result_variable"), "variable"), range, c("variable","month"))
reshape1(aqm, list(c("month", "result_variable"), "variable"), range, c("grand_col"))
reshape1(aqm, list(c("month", "result_variable"), "variable"), range, c("grand_row"))

reshape1(aqm, list(c("month"), c("variable")), function(x) diff(range(x))) </code></pre>

<hr>
<h2 id='round_any'>Round any</h2><span id='topic+round_any'></span>

<h3>Description</h3>

<p>Round to multiple of any number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>round_any(x, accuracy, f=round)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="round_any_+3A_x">x</code></td>
<td>
<p>numeric vector to round</p>
</td></tr>
<tr><td><code id="round_any_+3A_accuracy">accuracy</code></td>
<td>
<p>number to round to</p>
</td></tr>
<tr><td><code id="round_any_+3A_f">f</code></td>
<td>
<p>function to use for round (eg. <code><a href="base.html#topic+floor">floor</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Useful when you want to round a number to arbitrary precision</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>round_any(135, 10)
round_any(135, 100)
round_any(135, 25)
round_any(135, 10, floor)
round_any(135, 100, floor)
round_any(135, 25, floor)
round_any(135, 10, ceiling)
round_any(135, 100, ceiling)
round_any(135, 25, ceiling)</code></pre>

<hr>
<h2 id='Smiths'>Demo data describing the Smiths</h2><span id='topic+smiths'></span>

<h3>Description</h3>

<p>A small demo dataset describing John and Mary Smith.  Used in the introductory vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(smiths)</code></pre>


<h3>Format</h3>

<p>A data frame with 2 rows and 5 variables</p>

<hr>
<h2 id='sort_df'>Sort data frame</h2><span id='topic+sort_df'></span>

<h3>Description</h3>

<p>Convenience method for sorting a data frame using the given variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_df(data, vars=names(data))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_df_+3A_data">data</code></td>
<td>
<p>data frame to sort</p>
</td></tr>
<tr><td><code id="sort_df_+3A_vars">vars</code></td>
<td>
<p>variables to use for sorting</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple wrapper around order</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='sparseby'>Apply a Function to a Data Frame split by levels of indices</h2><span id='topic+sparseby'></span>

<h3>Description</h3>

<p>Function <code>sparseby</code> is a modified version of <code><a href="base.html#topic+by">by</a></code> for
<code><a href="base.html#topic+tapply">tapply</a></code> applied to data frames.  It always returns
a new data frame rather than a multi-way array. </p>


<h3>Usage</h3>

<pre><code class='language-R'>sparseby(data, INDICES = list(), FUN, ..., GROUPNAMES = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparseby_+3A_data">data</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object, normally a data frame, possibly a matrix.</p>
</td></tr>
<tr><td><code id="sparseby_+3A_indices">INDICES</code></td>
<td>
<p> a variable or list of variables indicating the subgroups of <code>data</code> </p>
</td></tr>
<tr><td><code id="sparseby_+3A_fun">FUN</code></td>
<td>
<p>a function to be applied to data frame subsets of <code>data</code>.</p>
</td></tr>
<tr><td><code id="sparseby_+3A_...">...</code></td>
<td>
<p>further arguments to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="sparseby_+3A_groupnames">GROUPNAMES</code></td>
<td>
<p>a logical variable indicating whether the group names should be
bound to the result</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A data frame or matrix is split by row into data frames or matrices respectively subsetted by the values of one or more factors, and function <code>FUN</code> is applied to each subset in turn.
</p>
<p><code>sparseby</code> is much faster and more memory efficient than <code><a href="base.html#topic+by">by</a></code> or <code><a href="base.html#topic+tapply">tapply</a></code> in the situation where the combinations of <code>INDICES</code> present in the data form a sparse subset of all possible combinations.
</p>


<h3>Value</h3>

 
<p>A data frame or matrix containing the results of <code>FUN</code> applied to each subgroup of the matrix. The result depends on what is returned from <code>FUN</code>:
</p>
<p>If <code>FUN</code> returns <code>NULL</code> on any subsets, those are dropped.
</p>
<p>If it returns a single value or a vector of values, the length must be consistent across all subgroups. These will be returned as values in rows of the resulting data frame or matrix.
</p>
<p>If it returns data frames or matrices, they must all have the same number of columns, and they will be bound with <code><a href="base.html#topic+rbind">rbind</a></code> into a single data frame or matrix.
</p>
<p>Names for the columns will be taken from the names in the list of <code>INDICES</code> or from the results of <code>FUN</code>, as appropriate.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+tapply">tapply</a></code>, <code><a href="base.html#topic+by">by</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(index=c(rep(1,4),rep(2,3)),value=c(1:7))
x
sparseby(x,x$index,nrow)

# The version below works entirely in matrices
x &lt;- as.matrix(x)
sparseby(x,list(group = x[,"index"]), function(subset) c(mean=mean(subset[,2])))
</code></pre>

<hr>
<h2 id='stamp'>Stamp</h2><span id='topic+stamp'></span>

<h3>Description</h3>

<p>Stamp is like reshape but the &quot;stamping&quot; function is passed the entire data frame, instead of just a few variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stamp(data, formula = . ~ ., fun.aggregate, ..., margins=NULL,
  subset=TRUE, add.missing=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stamp_+3A_data">data</code></td>
<td>
<p>data.frame (no molten)</p>
</td></tr>
<tr><td><code id="stamp_+3A_formula">formula</code></td>
<td>
<p>formula that describes arrangement of result, columns ~ rows, see <code><a href="stats.html#topic+reshape">reshape</a></code> for more information</p>
</td></tr>
<tr><td><code id="stamp_+3A_fun.aggregate">fun.aggregate</code></td>
<td>
<p>aggregation function to use, should take a data frame as the first argument</p>
</td></tr>
<tr><td><code id="stamp_+3A_...">...</code></td>
<td>
<p>arguments passed to the aggregation function</p>
</td></tr>
<tr><td><code id="stamp_+3A_margins">margins</code></td>
<td>
<p>margins to compute (character vector, or <code>TRUE</code> for all margins), can contain <code>grand_row</code> or <code>grand_col</code> to inclue grand row or column margins respectively.</p>
</td></tr>
<tr><td><code id="stamp_+3A_subset">subset</code></td>
<td>
<p>logical vector by which to subset the data frame, evaluated in the context of the data frame so you can</p>
</td></tr>
<tr><td><code id="stamp_+3A_add.missing">add.missing</code></td>
<td>
<p>fill in missing combinations?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is very similar to the <code><a href="base.html#topic+by">by</a></code> function except in the form
of the output which is arranged using the formula as in <code><a href="stats.html#topic+reshape">reshape</a></code>
</p>
<p>Note that it's very easy to create objects that R can't print with this
function.  You will probably want to save the results to a variable and
then use extract the results.  See the examples.</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='str.cast_matrix'>Print cast objects</h2><span id='topic+str.cast_matrix'></span><span id='topic+str.cast_df'></span><span id='topic+print.cast_matrix'></span><span id='topic+print.cast_df'></span>

<h3>Description</h3>

<p>Printing methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cast_matrix'
str(object, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str.cast_matrix_+3A_object">object</code></td>
<td>
</td></tr>
<tr><td><code id="str.cast_matrix_+3A_...">...</code></td>
<td>
</td></tr>
</table>


<h3>Details</h3>

<p>Used for printing.</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='strip.dups'>Strip duplicates.</h2><span id='topic+strip.dups'></span>

<h3>Description</h3>

<p>Strips out duplicates from data.frame and replace them with blanks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strip.dups(df)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strip.dups_+3A_df">df</code></td>
<td>
<p>data.frame to modify</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character matrix</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='tidystamp'>Tidy up stamped data set</h2><span id='topic+tidystamp'></span>

<h3>Description</h3>

<p>@keyword internal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidystamp(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidystamp_+3A_x">x</code></td>
<td>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='Tips'>Tipping data</h2><span id='topic+tips'></span>

<h3>Description</h3>

<p>One waiter recorded information about each tip he received over a period of a few months working in one restaurant. He collected several variables: 
</p>

<ul>
<li><p> tip in dollars, 
</p>
</li>
<li><p> bill in dollars, 
</p>
</li>
<li><p> sex of the bill payer, 
</p>
</li>
<li><p> whether there were smokers in the party, 
</p>
</li>
<li><p> day of the week, 
</p>
</li>
<li><p> time of day, 
</p>
</li>
<li><p> size of the party. 
</p>
</li></ul>

<p>In all he recorded 244 tips. The data was reported in a collection of case studies 
for business statistics (Bryant &amp; Smith 1995).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tips)</code></pre>


<h3>Format</h3>

<p>A data frame with 244 rows and 7 variables</p>


<h3>References</h3>

<p>Bryant, P. G. and Smith, M (1995) <em>Practical Data Analysis: Case Studies in Business Statistics</em>.  Homewood, IL: Richard D. Irwin Publishing:
</p>

<hr>
<h2 id='uniquedefault'>Unique default</h2><span id='topic+uniquedefault'></span>

<h3>Description</h3>

<p>Convenience function for setting default if not unique
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniquedefault(values, default)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniquedefault_+3A_values">values</code></td>
<td>
<p>vector of values</p>
</td></tr>
<tr><td><code id="uniquedefault_+3A_default">default</code></td>
<td>
<p>default to use if values not uniquez</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used by ggplot2</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='untable'>Untable a dataset</h2><span id='topic+untable'></span>

<h3>Description</h3>

<p>Inverse of table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>untable(df, num)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="untable_+3A_df">df</code></td>
<td>
<p>matrix or data.frame to untable</p>
</td></tr>
<tr><td><code id="untable_+3A_num">num</code></td>
<td>
<p>vector of counts (of same length as <code>df</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a tabulated dataset (or matrix) this will untabulate it
by repeating each row by the number of times it was repeated</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

<hr>
<h2 id='updatelist'>Update list</h2><span id='topic+updatelist'></span>

<h3>Description</h3>

<p>Update a list, but don't create new entries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updatelist(x, y)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updatelist_+3A_x">x</code></td>
<td>
<p>list to be updated</p>
</td></tr>
<tr><td><code id="updatelist_+3A_y">y</code></td>
<td>
<p>list with updated values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Don't know what this is used for!</p>


<h3>Author(s)</h3>

<p>Hadley Wickham &lt;h.wickham@gmail.com&gt;</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
