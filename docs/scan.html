<!DOCTYPE html><html><head><title>Help for package scan</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {scan}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.inheritParams'><p>Dummy function to inherit global descriptions of parameters</p></a></li>
<li><a href='#%&gt;%'><p>Pipe</p></a></li>
<li><a href='#$.scdf'><p>Select an scdf</p></a></li>
<li><a href='#add_l2'><p>Add level-2 data</p></a></li>
<li><a href='#as_scdf'><p>as_scdf</p></a></li>
<li><a href='#as.data.frame.scdf'><p>Creating a long format data frame from several single-case data frames</p>
(scdf).</a></li>
<li><a href='#autocorr'><p>Autocorrelation for single-case data</p></a></li>
<li><a href='#autocorrSC'><p>List of old deprecated function names</p></a></li>
<li><a href='#batch_apply'><p>Apply a function to each element in an scdf.</p></a></li>
<li><a href='#cdc'><p>Conservative Dual-Criterion Method</p></a></li>
<li><a href='#coef.sc_plm'><p>Extract coefficients from plm/hplm objects</p></a></li>
<li><a href='#combine'><p>Combine single-case data frames</p></a></li>
<li><a href='#convert'><p>Convert</p></a></li>
<li><a href='#corrected_tau'><p>Baseline corrected tau</p></a></li>
<li><a href='#describe'><p>Descriptive statistics for single-case data</p></a></li>
<li><a href='#design'><p>Generate a single-case design matrix</p></a></li>
<li><a href='#estimate_design'><p>Estimate single-case design</p></a></li>
<li><a href='#example_data'><p>Single-case example data</p></a></li>
<li><a href='#export'><p>Export scan objects to html or latex</p></a></li>
<li><a href='#fill_missing'><p>Replacing missing measurement times in single-case data</p></a></li>
<li><a href='#hplm'><p>Hierarchical piecewise linear model / piecewise regression</p></a></li>
<li><a href='#ird'><p>IRD - Improvement rate difference</p></a></li>
<li><a href='#is.scdf'><p>scdf objects</p>
Tests for objects of type &quot;scdf&quot;</a></li>
<li><a href='#moving_median'><p>Transform every single case of a single case data frame</p></a></li>
<li><a href='#mplm'><p>Multivariate Piecewise linear model / piecewise regression</p></a></li>
<li><a href='#nap'><p>Nonoverlap of all Pairs</p></a></li>
<li><a href='#outlier'><p>Handling outliers in single-case data</p></a></li>
<li><a href='#overlap'><p>Overlap indices for single-case data</p></a></li>
<li><a href='#pand'><p>Percentage of all non-overlapping data</p></a></li>
<li><a href='#pem'><p>Percent exceeding the median</p></a></li>
<li><a href='#pet'><p>Percent exceeding the trend</p></a></li>
<li><a href='#plm'><p>Piecewise linear model / piecewise regression</p></a></li>
<li><a href='#plot_rand'><p>Plot random distribution</p></a></li>
<li><a href='#plot.scdf'><p>Plot single-case data</p></a></li>
<li><a href='#pnd'><p>Percentage of non-overlapping data</p></a></li>
<li><a href='#power_test'><p>Empirical power analysis for single-case data</p></a></li>
<li><a href='#print.sc'><p>Print methods for scan objects</p></a></li>
<li><a href='#print.scdf'><p>Print an scdf</p></a></li>
<li><a href='#rand_test'><p>Randomization Tests for single-case data</p></a></li>
<li><a href='#random_scdf'><p>Single-case data generator</p></a></li>
<li><a href='#ranks'><p>Rank-transformation of single-case data files</p></a></li>
<li><a href='#rci'><p>Reliable change index</p></a></li>
<li><a href='#read_scdf'><p>Load single-case data from files</p></a></li>
<li><a href='#sample_names'><p>Samples random names</p></a></li>
<li><a href='#scan-package'><p>Single-Case Data Analyses</p></a></li>
<li><a href='#scdf'><p>Single case data frame</p></a></li>
<li><a href='#scdf_attr'><p>Set and get scdf attributes</p></a></li>
<li><a href='#select_cases'><p>Select a subset of cases</p></a></li>
<li><a href='#select_phases'><p>Select and combine phases for overlap analyses</p></a></li>
<li><a href='#set_vars'><p>Set analysis variables in an scdf</p></a></li>
<li><a href='#shift'><p>Shift values in a single-case data file</p></a></li>
<li><a href='#shinyscan'><p>A Shiny app for scan</p></a></li>
<li><a href='#smd'><p>Standardized mean differences</p></a></li>
<li><a href='#smooth_cases'><p>Smoothing single-case data</p></a></li>
<li><a href='#standardize'><p>Standardize values of an scdf file</p></a></li>
<li><a href='#style_plot'><p>Create styles for single-case data plots</p></a></li>
<li><a href='#subset.scdf'><p>Subset cases, rows, and variables</p></a></li>
<li><a href='#summary.scdf'><p>Summary function for an scdf</p></a></li>
<li><a href='#tau_u'><p>Tau-U for single-case data</p></a></li>
<li><a href='#trend'><p>Trend analysis for single-cases data</p></a></li>
<li><a href='#truncate_phase'><p>Truncate single-case data</p></a></li>
<li><a href='#write_scdf'><p>Data output</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Single-Case Data Analyses for Single and Multiple Baseline
Designs</td>
</tr>
<tr>
<td>Version:</td>
<td>0.60.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-08</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, nlme, utils, methods, graphics, car, knitr, kableExtra,
readxl, mblm, magrittr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), shiny, yaml, scplot</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of procedures for analysing, visualising, 
  and managing single-case data. These include piecewise linear regression 
  models, multilevel models, overlap indices ('PND', 'PEM', 'PAND', 'PET', 'tau-u', 
  'baseline corrected tau', 'CDC'), and randomization tests. Data preparation functions 
  support outlier detection, handling missing values, scaling, truncation, 
  rank transformation, and smoothing. An export function helps to generate 
  html and latex tables in a publication friendly style. More details can be 
  found in the online book 'Analyzing single-case data with R and scan', Juergen Wilbert (2023)
  <a href="https://jazznbass.github.io/scan-Book/">https://jazznbass.github.io/scan-Book/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jazznbass/scan/">https://github.com/jazznbass/scan/</a>,
<a href="https://jazznbass.github.io/scan-Book/">https://jazznbass.github.io/scan-Book/</a>,
<a href="https://github.com/jazznbass/scan">https://github.com/jazznbass/scan</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jazznbass/scan/issues">https://github.com/jazznbass/scan/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-08 07:42:16 UTC; jurgenwilbert</td>
</tr>
<tr>
<td>Author:</td>
<td>Juergen Wilbert <a href="https://orcid.org/0000-0002-8392-2873"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Timo Lueke <a href="https://orcid.org/0000-0002-2603-7341"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Juergen Wilbert &lt;juergen.wilbert@uni-potsdam.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-08 13:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.inheritParams'>Dummy function to inherit global descriptions of parameters</h2><span id='topic+.inheritParams'></span>

<h3>Description</h3>

<p>Dummy function to inherit global descriptions of parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.inheritParams(
  data,
  scdf,
  dvar,
  mvar,
  pvar,
  decreasing,
  phases,
  model,
  contrast,
  contrast_level,
  contrast_slope,
  trend,
  level,
  slope,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".inheritParams_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id=".inheritParams_+3A_scdf">scdf</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id=".inheritParams_+3A_dvar">dvar</code></td>
<td>
<p>Character string with the name of the dependent variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id=".inheritParams_+3A_mvar">mvar</code></td>
<td>
<p>Character string with the name of the measurement time variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id=".inheritParams_+3A_pvar">pvar</code></td>
<td>
<p>Character string with the name of the phase variable. Defaults to
the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id=".inheritParams_+3A_decreasing">decreasing</code></td>
<td>
<p>If you expect data to be lower in the B phase, set
<code>decreasing = TRUE</code>. Default is <code>decreasing = FALSE</code>.</p>
</td></tr>
<tr><td><code id=".inheritParams_+3A_phases">phases</code></td>
<td>
<p>A vector of two characters or numbers indicating the two phases
that should be compared. E.g., <code>phases = c("A","C")</code> or <code>phases = c(2,4)</code>
for comparing the second to the fourth phase. Phases could be combined by
providing a list with two elements. E.g., <code>phases = list(A = c(1,3), B = c(2,4))</code> will compare phases 1 and 3 (as A) against 2 and 4 (as B). Default
is <code>phases = c(1,2)</code>.</p>
</td></tr>
<tr><td><code id=".inheritParams_+3A_model">model</code></td>
<td>
<p>Model used for calculating the dummy parameters (see Huitema &amp;
McKean, 2000). Default is <code>model = "W"</code>. Possible values are: <code>"B&amp;L-B"</code>,
<code>"H-M"</code>, <code>"W"</code>, and deprecated <code>"JW"</code>.</p>
</td></tr>
<tr><td><code id=".inheritParams_+3A_contrast">contrast</code></td>
<td>
<p>Sets contrast_level and contrast_slope. Either &quot;first&quot;,
&quot;preceding&quot; or a contrast matrix.</p>
</td></tr>
<tr><td><code id=".inheritParams_+3A_contrast_level">contrast_level</code></td>
<td>
<p>Either &quot;first&quot;, &quot;preceding&quot; or a contrast matrix. If NA
contrast_level is a copy of contrast.</p>
</td></tr>
<tr><td><code id=".inheritParams_+3A_contrast_slope">contrast_slope</code></td>
<td>
<p>Either &quot;first&quot;, &quot;preceding&quot; or a contrast matrix. If NA
contrast_level is a copy of contrast.</p>
</td></tr>
<tr><td><code id=".inheritParams_+3A_trend">trend</code></td>
<td>
<p>A logical indicating if a trend parameters is included in the
model.</p>
</td></tr>
<tr><td><code id=".inheritParams_+3A_level">level</code></td>
<td>
<p>A logical indicating if a level parameters is included in the
model.</p>
</td></tr>
<tr><td><code id=".inheritParams_+3A_slope">slope</code></td>
<td>
<p>A logical indicating if a slope parameters is included in the
model.</p>
</td></tr>
<tr><td><code id=".inheritParams_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the function.</p>
</td></tr>
</table>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Several functions in scan are designed to work with pipes <code style="white-space: pre;">&#8288;\%&gt;\%&#8288;</code>. This
pipe function is directly imported from magrittr.
</p>


<h3>Details</h3>

<p>Since R 4.1 a pipe operator |&gt; is included in base R. This pipe
operator can be used along with scan perfectly fine.
</p>

<hr>
<h2 id='+24.scdf'>Select an scdf</h2><span id='topic++24.scdf'></span><span id='topic++5B.scdf'></span>

<h3>Description</h3>

<p>Select an scdf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scdf'
x$i

## S3 method for class 'scdf'
x[i]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B24.scdf_+3A_x">x</code></td>
<td>
<p>A scdf object</p>
</td></tr>
<tr><td><code id="+2B24.scdf_+3A_i">i</code></td>
<td>
<p>A case name from x</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scdf
</p>

<hr>
<h2 id='add_l2'>Add level-2 data</h2><span id='topic+add_l2'></span>

<h3>Description</h3>

<p>Merges variables with corresponding case names from a data.frame with an scdf
file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_l2(scdf, data_l2, cvar = "case")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_l2_+3A_scdf">scdf</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="add_l2_+3A_data_l2">data_l2</code></td>
<td>
<p>A level 2 dataset.</p>
</td></tr>
<tr><td><code id="add_l2_+3A_cvar">cvar</code></td>
<td>
<p>Character string with the name of the &quot;case&quot; variable in the L2
dataset (default is 'case').</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is mostly used in combination with the <code><a href="#topic+hplm">hplm()</a></code> function.
</p>


<h3>Value</h3>

<p>An scdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hplm">hplm()</a></code>
</p>
<p>Other data manipulation functions: 
<code><a href="#topic+as.data.frame.scdf">as.data.frame.scdf</a>()</code>,
<code><a href="#topic+as_scdf">as_scdf</a>()</code>,
<code><a href="#topic+fill_missing">fill_missing</a>()</code>,
<code><a href="#topic+moving_median">moving_median</a>()</code>,
<code><a href="#topic+outlier">outlier</a>()</code>,
<code><a href="#topic+ranks">ranks</a>()</code>,
<code><a href="#topic+scdf">scdf</a>()</code>,
<code><a href="#topic+select_cases">select_cases</a>()</code>,
<code><a href="#topic+set_vars">set_vars</a>()</code>,
<code><a href="#topic+shift">shift</a>()</code>,
<code><a href="#topic+smooth_cases">smooth_cases</a>()</code>,
<code><a href="#topic+standardize">standardize</a>()</code>,
<code><a href="#topic+truncate_phase">truncate_phase</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Leidig2018 %&gt;% add_l2(Leidig2018_l2)
</code></pre>

<hr>
<h2 id='as_scdf'>as_scdf</h2><span id='topic+as_scdf'></span>

<h3>Description</h3>

<p>Converts a data frame to an scdf object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_scdf(
  object,
  cvar = "case",
  pvar = "phase",
  dvar = "values",
  mvar = "mt",
  phase_names = NULL,
  sort_cases = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_scdf_+3A_object">object</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="as_scdf_+3A_cvar">cvar</code></td>
<td>
<p>Sets the &quot;case&quot; variable. Defaults to <code>case</code>.</p>
</td></tr>
<tr><td><code id="as_scdf_+3A_pvar">pvar</code></td>
<td>
<p>Sets the &quot;phase&quot; variable. Defaults to <code>phase</code>.</p>
</td></tr>
<tr><td><code id="as_scdf_+3A_dvar">dvar</code></td>
<td>
<p>Sets the &quot;values&quot; variable. Defaults to <code>values</code>.</p>
</td></tr>
<tr><td><code id="as_scdf_+3A_mvar">mvar</code></td>
<td>
<p>Sets the variable name of the &quot;mt&quot; variable. Defaults to <code>mt</code>.</p>
</td></tr>
<tr><td><code id="as_scdf_+3A_phase_names">phase_names</code></td>
<td>
<p>A character vector with phase names. Defaults to the phase
names provided in the phase variable.</p>
</td></tr>
<tr><td><code id="as_scdf_+3A_sort_cases">sort_cases</code></td>
<td>
<p>If set TRUE, the resulting list is sorted by label names
(alphabetically increasing).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An scdf.
</p>


<h3>See Also</h3>

<p>Other data manipulation functions: 
<code><a href="#topic+add_l2">add_l2</a>()</code>,
<code><a href="#topic+as.data.frame.scdf">as.data.frame.scdf</a>()</code>,
<code><a href="#topic+fill_missing">fill_missing</a>()</code>,
<code><a href="#topic+moving_median">moving_median</a>()</code>,
<code><a href="#topic+outlier">outlier</a>()</code>,
<code><a href="#topic+ranks">ranks</a>()</code>,
<code><a href="#topic+scdf">scdf</a>()</code>,
<code><a href="#topic+select_cases">select_cases</a>()</code>,
<code><a href="#topic+set_vars">set_vars</a>()</code>,
<code><a href="#topic+shift">shift</a>()</code>,
<code><a href="#topic+smooth_cases">smooth_cases</a>()</code>,
<code><a href="#topic+standardize">standardize</a>()</code>,
<code><a href="#topic+truncate_phase">truncate_phase</a>()</code>
</p>

<hr>
<h2 id='as.data.frame.scdf'>Creating a long format data frame from several single-case data frames
(scdf).</h2><span id='topic+as.data.frame.scdf'></span>

<h3>Description</h3>

<p>The as.data.frame function transposes an scdf into one long data frame.
Additionally, a data frame can be merged that includes level 2 data of the
subjects. This might be helpful to prepare data to be used with other
packages than scan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scdf'
as.data.frame(x, ..., l2 = NULL, id = "case")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.scdf_+3A_x">x</code></td>
<td>
<p>An scdf object</p>
</td></tr>
<tr><td><code id="as.data.frame.scdf_+3A_...">...</code></td>
<td>
<p>Not implemented</p>
</td></tr>
<tr><td><code id="as.data.frame.scdf_+3A_l2">l2</code></td>
<td>
<p>A data frame providing additional variables at Level 2. The scdf
has to have names for all cases and the Level 2 data frame has to have a
column with corresponding case names.</p>
</td></tr>
<tr><td><code id="as.data.frame.scdf_+3A_id">id</code></td>
<td>
<p>Variable name of the Level 2 data frame that contains the case
names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns one data frame with data of all single-cases structured by
the case variable.
</p>


<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>


<h3>See Also</h3>

<p>Other data manipulation functions: 
<code><a href="#topic+add_l2">add_l2</a>()</code>,
<code><a href="#topic+as_scdf">as_scdf</a>()</code>,
<code><a href="#topic+fill_missing">fill_missing</a>()</code>,
<code><a href="#topic+moving_median">moving_median</a>()</code>,
<code><a href="#topic+outlier">outlier</a>()</code>,
<code><a href="#topic+ranks">ranks</a>()</code>,
<code><a href="#topic+scdf">scdf</a>()</code>,
<code><a href="#topic+select_cases">select_cases</a>()</code>,
<code><a href="#topic+set_vars">set_vars</a>()</code>,
<code><a href="#topic+shift">shift</a>()</code>,
<code><a href="#topic+smooth_cases">smooth_cases</a>()</code>,
<code><a href="#topic+standardize">standardize</a>()</code>,
<code><a href="#topic+truncate_phase">truncate_phase</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Convert the list of three single-case data frames from Grosche (2011)
### into one long data frame
Grosche2011
Grosche2011_long &lt;- as.data.frame(Grosche2011)
Grosche2011_long

## Combine an scdf with data for l2
Leidig2018_long &lt;- as.data.frame(Leidig2018, l2 = Leidig2018_l2)
names(Leidig2018_long)
summary(Leidig2018_long)

</code></pre>

<hr>
<h2 id='autocorr'>Autocorrelation for single-case data</h2><span id='topic+autocorr'></span>

<h3>Description</h3>

<p>The autocorr function calculates autocorrelations within each phase and
across all phases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autocorr(data, dvar, pvar, mvar, lag_max = 3, lag.max, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autocorr_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="autocorr_+3A_dvar">dvar</code></td>
<td>
<p>Character string with the name of the dependent variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="autocorr_+3A_pvar">pvar</code></td>
<td>
<p>Character string with the name of the phase variable. Defaults to
the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="autocorr_+3A_mvar">mvar</code></td>
<td>
<p>Character string with the name of the measurement time variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="autocorr_+3A_lag_max">lag_max</code>, <code id="autocorr_+3A_lag.max">lag.max</code></td>
<td>
<p>The lag up to which autocorrelations will be computed.</p>
</td></tr>
<tr><td><code id="autocorr_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code><a href="stats.html#topic+acf">acf()</a></code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing separate autocorrelations for each phase and
for all phases (for each single-case). If <code>lag_max</code> exceeds the length
of a phase minus one, NA is returned for this cell.
</p>


<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+acf">acf()</a></code>
</p>
<p>Other regression functions: 
<code><a href="#topic+corrected_tau">corrected_tau</a>()</code>,
<code><a href="#topic+hplm">hplm</a>()</code>,
<code><a href="#topic+mplm">mplm</a>()</code>,
<code><a href="#topic+plm">plm</a>()</code>,
<code><a href="#topic+trend">trend</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compute autocorrelations for a list of four single-cases up to lag 2.
autocorr(Huber2014, lag_max = 2)
</code></pre>

<hr>
<h2 id='autocorrSC'>List of old deprecated function names</h2><span id='topic+autocorrSC'></span><span id='topic+deprecated-functions'></span><span id='topic+design_rSC'></span><span id='topic+longSCDF'></span><span id='topic+corrected_tauSC'></span><span id='topic+trendSC'></span><span id='topic+truncateSC'></span><span id='topic+style_plotSC'></span><span id='topic+style.plotSC'></span><span id='topic+smoothSC'></span><span id='topic+shiftSC'></span><span id='topic+tauUSC'></span><span id='topic+describeSC'></span><span id='topic+rankSC'></span><span id='topic+power_testSC'></span><span id='topic+fillmissingSC'></span><span id='topic+overlapSC'></span><span id='topic+outlierSC'></span><span id='topic+randSC'></span><span id='topic+rand.test'></span><span id='topic+rSC'></span><span id='topic+rciSC'></span><span id='topic+rCi'></span><span id='topic+readSC.excel'></span><span id='topic+readSC'></span><span id='topic+writeSC'></span>

<h3>Description</h3>

<p>This is a list with functions names that have been replaced by new names
which are in line with R syntax guidelines. The old function names still
work. They are wrappers that call the new function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autocorrSC(...)

design_rSC(...)

longSCDF(...)

corrected_tauSC(...)

trendSC(...)

truncateSC(...)

style_plotSC(...)

style.plotSC(...)

smoothSC(...)

shiftSC(...)

tauUSC(...)

describeSC(...)

rankSC(...)

power_testSC(...)

fillmissingSC(...)

overlapSC(...)

outlierSC(...)

randSC(...)

rand.test(...)

rSC(...)

rciSC(...)

rCi(...)

readSC.excel(...)

readSC(...)

writeSC(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autocorrSC_+3A_...">...</code></td>
<td>
<p>Arguments passed through to the new function.</p>
</td></tr>
</table>

<hr>
<h2 id='batch_apply'>Apply a function to each element in an scdf.</h2><span id='topic+batch_apply'></span>

<h3>Description</h3>

<p>This function applies a given function to each case of a multiple case scdf,
returning a list of the output of each function call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batch_apply(scdf, fn, simplify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="batch_apply_+3A_scdf">scdf</code></td>
<td>
<p>A list of inputs to apply the function to.</p>
</td></tr>
<tr><td><code id="batch_apply_+3A_fn">fn</code></td>
<td>
<p>The function to apply to each element. Use a <code>.</code> as a
placeholder for the scdf (e.g. <code>describe(.)</code>).</p>
</td></tr>
<tr><td><code id="batch_apply_+3A_simplify">simplify</code></td>
<td>
<p>If simplify is TRUE and <code>fn</code> returns a vector of values,
<code>batch_apply</code> will return a data frame case names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the output of each function call.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>batch_apply(exampleAB, coef(plm(.)))

</code></pre>

<hr>
<h2 id='cdc'>Conservative Dual-Criterion Method</h2><span id='topic+cdc'></span>

<h3>Description</h3>

<p>The <code>cdc()</code> function applies the Conservative Dual-Criterion Method (Fisher,
Kelley, &amp; Lomas, 2003) to scdf objects. It compares phase B data points to
both phase A mean and trend (OLS, bi-split, tri-split) with an additional
increase/decrease of .25 SD. A binomial test against a 50/50 distribution is
computed and p-values below .05 are labeled &quot;systematic change&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdc(
  data,
  dvar,
  pvar,
  mvar,
  decreasing = FALSE,
  trend_method = c("OLS", "bisplit", "trisplit"),
  conservative = 0.25,
  phases = c(1, 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdc_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="cdc_+3A_dvar">dvar</code></td>
<td>
<p>Character string with the name of the dependent variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="cdc_+3A_pvar">pvar</code></td>
<td>
<p>Character string with the name of the phase variable. Defaults to
the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="cdc_+3A_mvar">mvar</code></td>
<td>
<p>Character string with the name of the measurement time variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="cdc_+3A_decreasing">decreasing</code></td>
<td>
<p>If you expect data to be lower in the B phase, set
<code>decreasing = TRUE</code>. Default is <code>decreasing = FALSE</code>.</p>
</td></tr>
<tr><td><code id="cdc_+3A_trend_method">trend_method</code></td>
<td>
<p>Method used to calculate the trend line. Default is
<code>trend_method = "OLS"</code>. Possible values are: <code>"OLS"</code>, <code>"bisplit"</code>, and
<code>"trisplit"</code>. <code>"bisplit"</code>, and <code>"trisplit"</code> should only be used for cases
with at least five data-points in both relevant phases.</p>
</td></tr>
<tr><td><code id="cdc_+3A_conservative">conservative</code></td>
<td>
<p>The CDC method adjusts the original mean and trend lines
by adding (expected increase) or subtracting (expected decrease) an
additional .25 SD before evaluating phase B data. Default is the CDC method
with <code>conservative = .25</code>. To apply the Dual-Criterion (DC) method, set
<code>conservative = 0</code>.</p>
</td></tr>
<tr><td><code id="cdc_+3A_phases">phases</code></td>
<td>
<p>A vector of two characters or numbers indicating the two phases
that should be compared. E.g., <code>phases = c("A","C")</code> or <code>phases = c(2,4)</code>
for comparing the second to the fourth phase. Phases could be combined by
providing a list with two elements. E.g., <code>phases = list(A = c(1,3), B = c(2,4))</code> will compare phases 1 and 3 (as A) against 2 and 4 (as B). Default
is <code>phases = c(1,2)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>cdc</code></td>
<td>
<p>CDC Evaluation based on a p-value below .05.</p>
</td></tr>
<tr><td><code>cdc_exc</code></td>
<td>
<p>Number of phase B datapoints indicating expected change.</p>
</td></tr>
<tr><td><code>cdc_nb</code></td>
<td>
<p>Number of phase B datapoints.</p>
</td></tr> <tr><td><code>cdc_p</code></td>
<td>
<p>P value of Binomial
Test.</p>
</td></tr> <tr><td><code>cdc_all</code></td>
<td>
<p>Overall CDC Evaluation based on all instances/cases of
a Multiple Baseline Design.</p>
</td></tr> <tr><td><code>N</code></td>
<td>
<p>Number of cases.</p>
</td></tr>
<tr><td><code>decreasing</code></td>
<td>
<p>Logical argument from function call (see <code>Arguments</code>
above).</p>
</td></tr>
<tr><td><code>conservative</code></td>
<td>
<p>Numeric argument from function call (see <code>Arguments</code>
above).</p>
</td></tr> <tr><td><code>case_names</code></td>
<td>
<p>Assigned name of single-case.</p>
</td></tr> <tr><td><code>phases</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Timo Lueke
</p>


<h3>References</h3>

<p>Fisher, W. W., Kelley, M. E., &amp; Lomas, J. E. (2003). Visual Aids
and Structured Criteria for Improving Visual Inspection and Interpretation
of Single-Case Designs. <em>Journal of Applied Behavior Analysis, 36</em>,
387-406. https://doi.org/10.1901/jaba.2003.36-387
</p>


<h3>See Also</h3>

<p>Other overlap functions: 
<code><a href="#topic+nap">nap</a>()</code>,
<code><a href="#topic+overlap">overlap</a>()</code>,
<code><a href="#topic+pand">pand</a>()</code>,
<code><a href="#topic+pem">pem</a>()</code>,
<code><a href="#topic+pet">pet</a>()</code>,
<code><a href="#topic+pnd">pnd</a>()</code>,
<code><a href="#topic+tau_u">tau_u</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Apply the CDC method (standard OLS line)
design &lt;- design(n = 1, slope = 0.2)
dat &lt;- random_scdf(design, seed = 42)
cdc(dat)

## Apply the CDC with Koenig's bi-split and an expected decrease in phase B.
cdc(exampleAB_decreasing, decreasing = TRUE, trend_method = "bisplit")

## Apply the CDC with Tukey's tri-split, comparing the first and fourth phase.
cdc(exampleABAB, trend_method = "trisplit", phases = c(1,4))

## Apply the Dual-Criterion (DC) method (i.e., mean and trend without
##shifting).
cdc(exampleAB_decreasing, decreasing = TRUE, trend_method = "bisplit", conservative = 0)


</code></pre>

<hr>
<h2 id='coef.sc_plm'>Extract coefficients from plm/hplm objects</h2><span id='topic+coef.sc_plm'></span>

<h3>Description</h3>

<p>Extract coefficients from plm/hplm objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sc_plm'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.sc_plm_+3A_object">object</code></td>
<td>
<p>plm or hplm object</p>
</td></tr>
<tr><td><code id="coef.sc_plm_+3A_...">...</code></td>
<td>
<p>not implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with coefficient table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coefficients(plm(exampleAB$Johanna))

</code></pre>

<hr>
<h2 id='combine'>Combine single-case data frames</h2><span id='topic+combine'></span><span id='topic+c.scdf'></span>

<h3>Description</h3>

<p>Combine single-case data frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine(..., dvar = NULL, pvar = NULL, mvar = NULL, info = NULL, author = NULL)

## S3 method for class 'scdf'
c(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_+3A_...">...</code></td>
<td>
<p>scdf objects</p>
</td></tr>
<tr><td><code id="combine_+3A_dvar">dvar</code></td>
<td>
<p>Character string. Name of the dependent variable. Defaults to the
dependent variable of the first case provided.</p>
</td></tr>
<tr><td><code id="combine_+3A_pvar">pvar</code></td>
<td>
<p>Character string. Name of the phase variable. Defaults to the
phase variable of the first case provided.</p>
</td></tr>
<tr><td><code id="combine_+3A_mvar">mvar</code></td>
<td>
<p>Character string. Name of the measurement-time variable. Defaults
to the measurement-time variable of the first case provided.</p>
</td></tr>
<tr><td><code id="combine_+3A_info">info</code></td>
<td>
<p>additional information on the scdf file.</p>
</td></tr>
<tr><td><code id="combine_+3A_author">author</code></td>
<td>
<p>author of the data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scdf. If not set differently, the attributes of this scdf are
copied from the first scdf provided (i.e the first argument of the
function).
</p>

<hr>
<h2 id='convert'>Convert</h2><span id='topic+convert'></span>

<h3>Description</h3>

<p>Converts an scdf object into R code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert(
  scdf,
  file = "",
  study_name = "study",
  case_name = "case",
  inline = FALSE,
  indent = 2,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_+3A_scdf">scdf</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="convert_+3A_file">file</code></td>
<td>
<p>A filename for exporting the syntax.</p>
</td></tr>
<tr><td><code id="convert_+3A_study_name">study_name</code></td>
<td>
<p>Character string. Name of the study object.</p>
</td></tr>
<tr><td><code id="convert_+3A_case_name">case_name</code></td>
<td>
<p>Character string. Name of the scdf objects.</p>
</td></tr>
<tr><td><code id="convert_+3A_inline">inline</code></td>
<td>
<p>If TRUE, phase definition is in an online version.</p>
</td></tr>
<tr><td><code id="convert_+3A_indent">indent</code></td>
<td>
<p>Integer. Indentation.</p>
</td></tr>
<tr><td><code id="convert_+3A_silent">silent</code></td>
<td>
<p>If TRUE, syntax is not printed to the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a string (invisible).
</p>


<h3>See Also</h3>

<p>Other io-functions: 
<code><a href="#topic+read_scdf">read_scdf</a>()</code>,
<code><a href="#topic+write_scdf">write_scdf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filename &lt;- tempfile()
convert(exampleABC, file = filename)
source(filename)
all.equal(study, exampleABC)
unlink(filename)
</code></pre>

<hr>
<h2 id='corrected_tau'>Baseline corrected tau</h2><span id='topic+corrected_tau'></span>

<h3>Description</h3>

<p>Kendall's tau correlation for the dependent variable and the phase variable
is calculated after correcting for a baseline trend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corrected_tau(
  data,
  dvar,
  pvar,
  mvar,
  phases = c(1, 2),
  alpha = 0.05,
  continuity = FALSE,
  repeated = FALSE,
  tau_method = "b"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corrected_tau_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="corrected_tau_+3A_dvar">dvar</code></td>
<td>
<p>Character string with the name of the dependent variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="corrected_tau_+3A_pvar">pvar</code></td>
<td>
<p>Character string with the name of the phase variable. Defaults to
the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="corrected_tau_+3A_mvar">mvar</code></td>
<td>
<p>Character string with the name of the measurement time variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="corrected_tau_+3A_phases">phases</code></td>
<td>
<p>A vector of two characters or numbers indicating the two phases
that should be compared. E.g., <code>phases = c("A","C")</code> or <code>phases = c(2,4)</code>
for comparing the second to the fourth phase. Phases could be combined by
providing a list with two elements. E.g., <code>phases = list(A = c(1,3), B = c(2,4))</code> will compare phases 1 and 3 (as A) against 2 and 4 (as B). Default
is <code>phases = c(1,2)</code>.</p>
</td></tr>
<tr><td><code id="corrected_tau_+3A_alpha">alpha</code></td>
<td>
<p>Sets the p-value at and below which a baseline correction is
applied.</p>
</td></tr>
<tr><td><code id="corrected_tau_+3A_continuity">continuity</code></td>
<td>
<p>If TRUE applies a continuity correction for calculating p</p>
</td></tr>
<tr><td><code id="corrected_tau_+3A_repeated">repeated</code></td>
<td>
<p>If TRUE applies the repeated median method for calculating
slope and intercept (<code><a href="mblm.html#topic+mblm">mblm()</a></code>)</p>
</td></tr>
<tr><td><code id="corrected_tau_+3A_tau_method">tau_method</code></td>
<td>
<p>Character with values &quot;a&quot; or &quot;b&quot; (default) indicating
whether Kendall Tau A or Kendall Tau B is applied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method has been proposed by Tarlow (2016). The baseline data
are checked for a significant autocorrelation (based on Kendall's Tau). If
so, a non-parametric Theil-Sen regression is applied for the baseline data
where the dependent values are regressed on the measurement time. The
resulting slope information is then used to predict data of the B-phase.
The dependent variable is now corrected for this baseline trend and the
residuals of the Theil-Sen regression are taken for further calculations.
Finally, Kendall's tau is calculated for the dependent variable and the
dichotomous phase variable. The function here provides two extensions to
this procedure: The more accurate Siegel repeated median regression is
applied when <code>repeated = TRUE</code> and a continuity correction is applied when
<code>continuity = TRUE</code>.
</p>


<h3>References</h3>

<p>Tarlow, K. R. (2016). An Improved Rank Correlation Effect Size
Statistic for Single-Case Designs: Baseline Corrected Tau. <em>Behavior
Modification, 41(4)</em>, 427â€“467. https://doi.org/10.1177/0145445516676750
</p>


<h3>See Also</h3>

<p>Other regression functions: 
<code><a href="#topic+autocorr">autocorr</a>()</code>,
<code><a href="#topic+hplm">hplm</a>()</code>,
<code><a href="#topic+mplm">mplm</a>()</code>,
<code><a href="#topic+plm">plm</a>()</code>,
<code><a href="#topic+trend">trend</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- scdf(c(A = 33,25,17,25,14,13,15, B = 15,16,16,5,7,9,6,5,3,3,8,11,7))
corrected_tau(dat)
</code></pre>

<hr>
<h2 id='describe'>Descriptive statistics for single-case data</h2><span id='topic+describe'></span>

<h3>Description</h3>

<p>The <code>describe()</code> function provides common descriptive statistics for
single-case data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>describe(data, dvar, pvar, mvar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="describe_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="describe_+3A_dvar">dvar</code></td>
<td>
<p>Character string with the name of the dependent variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="describe_+3A_pvar">pvar</code></td>
<td>
<p>Character string with the name of the phase variable. Defaults to
the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="describe_+3A_mvar">mvar</code></td>
<td>
<p>Character string with the name of the measurement time variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>n = number of measurements; mis = number of missing vaues; m = mean;
md = median; sd = standard deviation; mad = median average deviation; min =
minimum; max = maximum; trend = weight of depended variable regressed on
time (values ~ mt).
</p>


<h3>Value</h3>

<p>A list containing a data frame of descriptive statistics
(descriptives); the cse design (design); the number of cases (N)
</p>


<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>


<h3>See Also</h3>

<p><code><a href="#topic+overlap">overlap()</a></code>, <code><a href="#topic+plot.scdf">plot.scdf()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Descriptive statistics for a study of three single-cases
describe(Grosche2011)

## Descriptives of a three phase design
describe(exampleABC)

## Write descriptive statistics to .csv-file
study &lt;- describe(Waddell2011)
write.csv(study$descriptives, file = tempfile())
</code></pre>

<hr>
<h2 id='design'>Generate a single-case design matrix</h2><span id='topic+design'></span>

<h3>Description</h3>

<p>Generates a parameter list used for generating multiple random single-cases.
This is used within the <code>random_scdf</code> function and the <code>power_test</code> function
and for other Monte-Carlo tasks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design(
  n = 1,
  phase_design = list(A = 5, B = 15),
  trend = 0,
  level = list(0),
  slope = list(0),
  start_value = 50,
  s = 10,
  rtt = 0.8,
  extreme_prop = list(0),
  extreme_range = c(-4, -3),
  missing_prop = 0,
  distribution = c("normal", "gaussian", "poisson", "binomial"),
  n_trials = NULL,
  mt = NULL,
  B_start = NULL,
  m,
  phase.design,
  MT,
  B.start,
  extreme.p,
  extreme.d,
  missing.p
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="design_+3A_n">n</code></td>
<td>
<p>Number of cases to be designed (Default is <code>n = 1</code>).</p>
</td></tr>
<tr><td><code id="design_+3A_phase_design">phase_design</code>, <code id="design_+3A_phase.design">phase.design</code></td>
<td>
<p>A list defining the length and label of each
phase. E.g., <code>phase.length = list(A1 = 10, B1 = 10, A2 = 10, B2 = 10)</code>. Use
vectors if you want to define different values for each case <code style="white-space: pre;">&#8288;phase.length = list(A = c(10, 15), B = c(10, 15)&#8288;</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_trend">trend</code></td>
<td>
<p>Defines the effect size of a trend added incrementally to each
measurement across the whole data-set. To assign different trends to
several single-cases, use a vector of values (e.g. <code>trend = c(.1, .3, .5)</code>). If the number of cases exceeds the length of the vector, values are
recycled. When using a 'gaussian' distribution, the <code>trend</code> parameters
indicate effect size
<em>d</em> changes.  When using a binomial or poisson distribution, <code>trend</code>
indicates an increase in points / counts per measurement.</p>
</td></tr>
<tr><td><code id="design_+3A_level">level</code></td>
<td>
<p>A list that defines the level increase (effect size <em>d</em>) at the
beginning of each phase relative to the previous phase (e.g. <code>list(A = 0, B = 1)</code>). The first element must be zero as the first phase of a single-case
has no level effect (if you have one less list element than the number of
phases, scan will add a leading element with 0 values). Use vectors to
define variable level effects for each case (e.g. <code>list(A = c(0, 0), B = c(1, 2))</code>). When using a 'gaussian' distribution, the <code>level</code> parameters
indicate effect size <em>d</em> changes. When using a binomial or poisson
distribution, <code>level</code> indicates an increase in points / counts with the
onset of each phase.</p>
</td></tr>
<tr><td><code id="design_+3A_slope">slope</code></td>
<td>
<p>A list that defines the increase per measurement for each phase
compared to the previous phase. <code>slope = list(A = 0, B = .1)</code> generates an
incremental increase of 0.1 per measurement starting at the B phase. The
first list element must be zero as the first phase of a single-case has no
slope effect (if you have one less list element than the number of phases,
scan will add a leading element with 0 values). Use vectors to define
variable slope effects for each case (e.g. <code>list(A = c(0, 0), B = c(0.1, 0.2))</code>). If the number of cases exceeds the length of the vector, values
are recycled. When using a 'gaussian' distribution, the <code>slope</code> parameters
indicate effect size <em>d</em> changes per measurement. When using a binomial or
poisson distribution, <code>slope</code> indicates an increase in points / counts per
measurement.</p>
</td></tr>
<tr><td><code id="design_+3A_start_value">start_value</code>, <code id="design_+3A_m">m</code></td>
<td>
<p>Starting value at the first measurement. Default is
<code>50</code>. When <code>distribution = "poission"</code> the start_value represents
frequency. When <code>distribution = "binomial"</code> start_value must range between
0 and 1 and they represent the probability of on event. To assign different
start values to several single-cases, use a vector of values (e.g. <code>c(50, 42, 56)</code>). If the number of cases exceeds the length of the vector, values
are recycled. The <code>m</code> argument is deprecated.</p>
</td></tr>
<tr><td><code id="design_+3A_s">s</code></td>
<td>
<p>Standard deviation used to calculate absolute values from level,
slope, trend effects and to calculate and error distribution from the <code>rtt</code>
values. Set to <code>10</code> by default. To assign different variances to several
single-cases, use a vector of values (e.g. <code>s = c(5, 10, 15)</code>). If the
number of cases exceeds the length of the vector, values are recycled. if
the distribution is 'poisson' or 'binomial' s is not applied.</p>
</td></tr>
<tr><td><code id="design_+3A_rtt">rtt</code></td>
<td>
<p>Reliability of the underlying simulated measurements. Set <code>rtt = .8</code> by default. To assign different reliabilities to several single-cases,
use a vector of values (e.g. <code>rtt = c(.6, .7, .8)</code>). If the number of cases
exceeds the length of the vector, values are repeated. <code>rtt</code> has no effect
when you're using binomial or poisson distributions.</p>
</td></tr>
<tr><td><code id="design_+3A_extreme_prop">extreme_prop</code>, <code id="design_+3A_extreme.p">extreme.p</code></td>
<td>
<p>Probability of extreme values. <code>extreme.p = .05</code> gives a five percent probability of an extreme value. A vector of
values assigns different probabilities to multiple cases. If the number of
cases exceeds the length of the vector, values are recycled.</p>
</td></tr>
<tr><td><code id="design_+3A_extreme_range">extreme_range</code>, <code id="design_+3A_extreme.d">extreme.d</code></td>
<td>
<p>Range for extreme values. <code>extreme_range = c(-7,-6)</code> uses extreme values within a range of -7 and -6 . In case of a
binomial or poisson distribution, <code>extreme_range</code> indicates frequencies. In
case of a gaussian (or normal) distribution it indicates effect size d.
Caution: the first value must be smaller than the second, otherwise the
procedure will fail.</p>
</td></tr>
<tr><td><code id="design_+3A_missing_prop">missing_prop</code>, <code id="design_+3A_missing.p">missing.p</code></td>
<td>
<p>Portion of missing values. <code>missing_prop = 0.1</code>
creates 10\
different probabilities to multiple cases. If the number of cases exceeds
the length of the vector, values are repeated.</p>
</td></tr>
<tr><td><code id="design_+3A_distribution">distribution</code></td>
<td>
<p>Distribution of the criteria varible. Default is
<code>"normal"</code>. Possible values are <code>"normal"</code>, <code>"binomial"</code>, and <code>"poisson"</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_n_trials">n_trials</code></td>
<td>
<p>If <code>distribution</code> (see below) is <code>"binomial"</code>, <code>n_trials</code> is
the number of trials/observations/items.</p>
</td></tr>
<tr><td><code id="design_+3A_mt">mt</code>, <code id="design_+3A_mt">MT</code></td>
<td>
<p>Number of measurements (in each study). Default is <code>mt = 20</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_b_start">B_start</code>, <code id="design_+3A_b.start">B.start</code></td>
<td>
<p>Phase B starting point. The default setting <code>B_start = 6</code> would assign the first five scores (of each case) to phase A, and all
following scores to phase B. To assign different starting points for a set
of multiple single-cases, use a vector of starting values (e.g., <code>B_start = c(6, 7, 8)</code>). If the number of cases exceeds the length of the vector,
values will be recycled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class sc_design.
</p>


<h3>Author(s)</h3>

<p>Juergen Wibert
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Create random single-case data and inspect it
 design &lt;- design(
   n = 3, rtt = 0.75, slope = 0.1, extreme_prop = 0.1,
   missing_prop = 0.1
 )
 dat &lt;- random_scdf(design, round = 1, random.names = TRUE, seed = 123)
 describe(dat)

 ## And now have a look at poisson-distributed data
 design &lt;- design(
   n = 3, B_start = c(6, 10, 14), mt = c(12, 20, 22), start_value = 10,
   distribution = "poisson", level = -5, missing_prop = 0.1
 )
 dat &lt;- random_scdf(design, seed = 1234)
 pand(dat, decreasing = TRUE)
</code></pre>

<hr>
<h2 id='estimate_design'>Estimate single-case design</h2><span id='topic+estimate_design'></span>

<h3>Description</h3>

<p>This functions takes an scdf and extracts design parameters. The resulting
object can be used to randomly create new scdf files with the same underlying
parameters. This is useful for Monte-Carlo studies and bootstrapping
procedures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_design(
  data,
  dvar,
  pvar,
  mvar,
  s = NULL,
  rtt = NULL,
  overall_effects = FALSE,
  overall_rtt = TRUE,
  model = "JW",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_design_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="estimate_design_+3A_dvar">dvar</code></td>
<td>
<p>Character string with the name of the dependent variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="estimate_design_+3A_pvar">pvar</code></td>
<td>
<p>Character string with the name of the phase variable. Defaults to
the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="estimate_design_+3A_mvar">mvar</code></td>
<td>
<p>Character string with the name of the measurement time variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="estimate_design_+3A_s">s</code></td>
<td>
<p>The standard deviation depicting the between case variance of the
overall performance. If more than two single-cases are included in the
scdf, the variance is estimated if s is set to NULL.</p>
</td></tr>
<tr><td><code id="estimate_design_+3A_rtt">rtt</code></td>
<td>
<p>The reliability of the measurements. The reliability is estimated
when rtt = NULL.</p>
</td></tr>
<tr><td><code id="estimate_design_+3A_overall_effects">overall_effects</code></td>
<td>
<p>If TRUE, trend, level, and slope effect estimations
will be identical for each case. If FALSE, effects are estimated for each
case separately.</p>
</td></tr>
<tr><td><code id="estimate_design_+3A_overall_rtt">overall_rtt</code></td>
<td>
<p>Ignored when <code>rtt</code> is set. If TRUE, rtt estimations will
be based on all cases and identical for each case. If FALSE rtt is
estimated for each case separately.</p>
</td></tr>
<tr><td><code id="estimate_design_+3A_model">model</code></td>
<td>
<p>Model used for calculating the dummy parameters (see Huitema &amp;
McKean, 2000). Default is <code>model = "W"</code>. Possible values are: <code>"B&amp;L-B"</code>,
<code>"H-M"</code>, <code>"W"</code>, and deprecated <code>"JW"</code>.</p>
</td></tr>
<tr><td><code id="estimate_design_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the plm function used for parameter
estimation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of parameters for each single-case. Parameters include name,
length, and starting measurement time of each phase, trend, level, and
slope effects for each phase, start value, standard deviation, and
reliability for each case.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a random scdf with predefined parameters
set.seed(1234)
design &lt;- design(
  n = 10, trend = -0.02,
  level = list(0, 1), rtt = 0.8,
  s = 1
)
scdf&lt;- random_scdf(design)

# Estimate the parameters based on the scdf and create a new random scdf
# based on these estimations
design_est &lt;- estimate_design(scdf, rtt = 0.8)
scdf_est &lt;- random_scdf(design_est)

# Analyze both datasets with an hplm model. See how similar the estimations
# are:
hplm(scdf, slope = FALSE)
hplm(scdf_est, slope = FALSE)

# Also similar results for pand and randomization tests:
pand(scdf)
pand(scdf_est)
rand_test(scdf)
rand_test(scdf_est)
</code></pre>

<hr>
<h2 id='example_data'>Single-case example data</h2><span id='topic+example_data'></span><span id='topic+Beretvas2008'></span><span id='topic+Borckardt2014'></span><span id='topic+Huitema2000'></span><span id='topic+Waddell2011'></span><span id='topic+byHeart2011'></span><span id='topic+Grosche2011'></span><span id='topic+Grosche2014'></span><span id='topic+GruenkeWilbert2014'></span><span id='topic+Huber2014'></span><span id='topic+example_A24'></span><span id='topic+exampleAB_simple'></span><span id='topic+exampleAB'></span><span id='topic+exampleAB_add'></span><span id='topic+exampleAB_decreasing'></span><span id='topic+exampleAB_score'></span><span id='topic+exampleABC'></span><span id='topic+exampleABC_outlier'></span><span id='topic+exampleABC_50'></span><span id='topic+exampleABAB'></span><span id='topic+exampleA1B1A2B2'></span><span id='topic+exampleA1B1A2B2_zvt'></span><span id='topic+exampleAB_50'></span><span id='topic+exampleAB_50.l2'></span><span id='topic+exampleABC_150'></span><span id='topic+exampleAB_mpd'></span><span id='topic+Lenz2013'></span><span id='topic+Leidig2018'></span><span id='topic+Leidig2018_l2'></span><span id='topic+SSDforR2017'></span><span id='topic+Parker2011'></span><span id='topic+Parker2007'></span><span id='topic+Parker2009'></span><span id='topic+Parker2011b'></span><span id='topic+Tarlow2017'></span>

<h3>Description</h3>

<p>The <a href="#topic+scan">scan</a> package comes with a set of fictitious and authentic
single-case study data, by courtesy of the particular authors.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Beretvas2008</code></td>
<td>
<p>Fictitious single-case intervention study.
<strong>Reference:</strong> Beretvas, S., &amp; Chung, H. (2008). An evaluation of
modified R2-change effect size indices for single-subject experimental
designs. <em>Evidence-Based Communication Assessment and Intervention, 2</em>,
120-128.</p>
</td></tr>
<tr><td><code>Borckardt2014</code></td>
<td>
<p>Fictitious daily pain ratings evaluating a
psychological treatment. <b>Reference:</b> Borckardt, J. J., &amp; Nash, M. R.
(2014). Simulation modelling analysis for small sets of single-subject data
collected over time. <em>Neuropsychological Rehabilitation, 24</em>, 492-506.</p>
</td></tr>
<tr><td><code>Huitema2000</code></td>
<td>
<p>Fictitious single-case intervention study.
<b>Reference:</b> Huitema, B. E., &amp; McKean, J. W. (2000). Design
specification issues in time-series intervention models. <em>Educational
and Psychological Measurement, 60</em>, 38-58.</p>
</td></tr>
<tr><td><code>Waddell2011</code></td>
<td>
<p>Fictitious
single-case intervention study. <b>Reference:</b> Waddell, D. E., Nassar, S.
L., &amp; Gustafson, S. A. (2011). Single-Case Design in Psychophysiological
Research: Part II: Statistical Analytic Approaches. <em>Journal of
Neurotherapy, 15</em>, 160-169.</p>
</td></tr>
<tr><td><code>byHeart2011</code></td>
<td>
<p>Multiple-baseline (11 cases)
intervention study on flash card vocabulary learning by Juergen Wilbert.</p>
</td></tr>
<tr><td><code>Grosche2011</code></td>
<td>
<p>Multiple-baseline (3 cases) intervention study on a
direct-instructive reading intervention. <b>Reference:</b> Grosche, M.
(2011). Effekte einer direkt-instruktiven Foerderung der Lesegenauigkeit.
<em>Empirische Sonderpaedagogik, 3</em>, 147-161.</p>
</td></tr>
<tr><td><code>Grosche2014</code></td>
<td>
<p>Multiple-baseline (3 cases x 3 materials) intervention
study on a reading intervention. <b>Reference:</b> Grosche, M., Lueke, T., &amp;
Wilbert, J. (in prep.).</p>
</td></tr>
<tr><td><code>GruenkeWilbert2014</code></td>
<td>
<p>Multiple-baseline (6
cases) intervention study on story mapping. <b>Reference:</b> Gruenke, M.,
Wilbert, J., &amp; Stegemann-Calder, K. (2013). Analyzing the effects of story
mapping on the reading comprehension of children with low intellectual
abilities. <em>Learning Disabilities: A Contemporary Journal, 11</em>, 51-64.</p>
</td></tr>
<tr><td><code>Huber2014</code></td>
<td>
<p>Multiple-baseline (4 cases) intervention study on
behavioral compliance. Scores refer to compliant behavior in percent.
<b>Reference:</b> Huber, C. (in prep.).</p>
</td></tr>
<tr><td><code>Lenz2013</code></td>
<td>
<p>Fictious example from the paper Lenz, A. S. (2013).
Calculating Effect Size in Single-Case Research: A Comparison of Nonoverlap
Methods. Measurement and Evaluation in Counseling and Development, 46(1),
64â€“73.</p>
</td></tr> <tr><td><code>Leidig2018</code></td>
<td>
</td></tr> <tr><td><code>Leidig2018_l2</code></td>
<td>
</td></tr> <tr><td><code>SSDforR2017</code></td>
<td>
<p>Example
from the R package SSDforR.</p>
</td></tr> <tr><td><code>Parker2011</code></td>
<td>
<p>Example from Parker, R. I.,
Vannest, K. J., Davis, J. L., &amp; Sauber, S. B. (2011). Combining Nonoverlap
and Trend for Single-Case Research: Tau-U. Behavior Therapy, 42(2), 284â€“299.
https://doi.org/10.1016/j.beth.2010.08.006</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>

<hr>
<h2 id='export'>Export scan objects to html or latex</h2><span id='topic+export'></span><span id='topic+export.sc_desc'></span><span id='topic+export.sc_nap'></span><span id='topic+export.sc_overlap'></span><span id='topic+export.sc_pem'></span><span id='topic+export.sc_plm'></span><span id='topic+export.sc_power'></span><span id='topic+export.sc_smd'></span><span id='topic+export.sc_trend'></span><span id='topic+export.scdf'></span>

<h3>Description</h3>

<p>Export creates html files of tables or displays them directly in the viewer
pane of rstudio. When applied in rmarkdown/quarto, tables can also be created
for pdf/latex output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export(object, ...)

## S3 method for class 'sc_desc'
export(
  object,
  caption = NA,
  footnote = NA,
  filename = NA,
  kable_styling_options = list(),
  kable_options = list(),
  flip = FALSE,
  ...
)

## S3 method for class 'sc_nap'
export(
  object,
  caption = NA,
  footnote = NA,
  filename = NA,
  kable_styling_options = list(),
  kable_options = list(),
  round = 2,
  ...
)

## S3 method for class 'sc_overlap'
export(
  object,
  caption = NA,
  footnote = NULL,
  filename = NA,
  kable_styling_options = list(),
  kable_options = list(),
  round = 2,
  flip = FALSE,
  ...
)

## S3 method for class 'sc_pem'
export(
  object,
  caption = NA,
  footnote = NA,
  filename = NA,
  kable_styling_options = list(),
  kable_options = list(),
  round = 2,
  ...
)

## S3 method for class 'sc_plm'
export(
  object,
  caption = NA,
  footnote = NA,
  filename = NA,
  kable_styling_options = list(),
  kable_options = list(),
  round = 2,
  nice = TRUE,
  ...
)

## S3 method for class 'sc_power'
export(
  object,
  caption = NA,
  footnote = NA,
  filename = NA,
  kable_styling_options = list(),
  kable_options = list(),
  ...
)

## S3 method for class 'sc_smd'
export(
  object,
  caption = NA,
  footnote = NA,
  filename = NA,
  select = c("Case", `Mean A` = "mA", `Mean B` = "mB", `SD A` = "sdA", `SD B` = "sdB",
    `SD Cohen` = "sd cohen", `SD Hedges` = "sd hedges", "Glass' delta", "Hedges' g",
    "Hedges' g correction", "Hedges' g durlak correction", "Cohen's d"),
  kable_styling_options = list(),
  kable_options = list(),
  round = 2,
  flip = FALSE,
  ...
)

## S3 method for class 'sc_trend'
export(
  object,
  caption = NA,
  footnote = NA,
  filename = NA,
  kable_styling_options = list(),
  kable_options = list(),
  round = 2,
  ...
)

## S3 method for class 'scdf'
export(
  object,
  caption = NA,
  footnote = NA,
  filename = NA,
  kable_styling_options = list(),
  kable_options = list(),
  cols,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_+3A_object">object</code></td>
<td>
<p>An scdf or an object exported from a scan function.</p>
</td></tr>
<tr><td><code id="export_+3A_...">...</code></td>
<td>
<p>Further Arguments passed to internal functions.</p>
</td></tr>
<tr><td><code id="export_+3A_caption">caption</code></td>
<td>
<p>Character string with table caption. If left NA (default) a
caption will be created based on the exported object.</p>
</td></tr>
<tr><td><code id="export_+3A_footnote">footnote</code></td>
<td>
<p>Character string with table footnote. If left NA (default) a
footnote will be created based on the exported object.</p>
</td></tr>
<tr><td><code id="export_+3A_filename">filename</code></td>
<td>
<p>String containing the file name. If a filename is given the
output will be written to that file.</p>
</td></tr>
<tr><td><code id="export_+3A_kable_styling_options">kable_styling_options</code></td>
<td>
<p>list with arguments passed to the kable_styling
function.</p>
</td></tr>
<tr><td><code id="export_+3A_kable_options">kable_options</code></td>
<td>
<p>list with arguments passed to the kable function.</p>
</td></tr>
<tr><td><code id="export_+3A_flip">flip</code></td>
<td>
<p>If TRUE, some objects are exported with rows and columns flipped.</p>
</td></tr>
<tr><td><code id="export_+3A_round">round</code></td>
<td>
<p>Integer passed to the digits argument internally used to round
values.</p>
</td></tr>
<tr><td><code id="export_+3A_nice">nice</code></td>
<td>
<p>If set TRUE (default) output values are rounded and optimized for
publication tables.</p>
</td></tr>
<tr><td><code id="export_+3A_select">select</code></td>
<td>
<p>A character vector containing the names of the variables to be
included. If the vector is named, the variables will be renamed
accordingly.</p>
</td></tr>
<tr><td><code id="export_+3A_cols">cols</code></td>
<td>
<p>Defines which columns are included when exporting an scdf. It is
either a vector of variable names or the string &quot;main&quot; will select the
central variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns or displays a specially formatted html (or latex) file.
</p>

<hr>
<h2 id='fill_missing'>Replacing missing measurement times in single-case data</h2><span id='topic+fill_missing'></span>

<h3>Description</h3>

<p>The <code>fillmissing()</code> function replaces missing measurements in single-case
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_missing(data, dvar, mvar, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_missing_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="fill_missing_+3A_dvar">dvar</code></td>
<td>
<p>Character string with the name of the dependent variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="fill_missing_+3A_mvar">mvar</code></td>
<td>
<p>Character string with the name of the measurement time variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="fill_missing_+3A_na.rm">na.rm</code></td>
<td>
<p>If set <code>TRUE</code>, <code>NA</code> values are also interpolated. Default is
<code>na.rm = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This procedure is recommended if there are gaps between measurement times
(e.g. MT: 1, 2, 3, 4, 5, ... 8, 9) or explicitly missing values in your
single-case data and you want to calculate overlap indices (<code><a href="#topic+overlap">overlap()</a></code>) or a
randomization test (<code><a href="#topic+rand_test">rand_test()</a></code>).
</p>


<h3>Value</h3>

<p>A single-case data frame with interpolated missing data points.  See
<code><a href="#topic+scdf">scdf()</a></code> to learn about the SCDF Format.
</p>


<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>


<h3>See Also</h3>

<p>Other data manipulation functions: 
<code><a href="#topic+add_l2">add_l2</a>()</code>,
<code><a href="#topic+as.data.frame.scdf">as.data.frame.scdf</a>()</code>,
<code><a href="#topic+as_scdf">as_scdf</a>()</code>,
<code><a href="#topic+moving_median">moving_median</a>()</code>,
<code><a href="#topic+outlier">outlier</a>()</code>,
<code><a href="#topic+ranks">ranks</a>()</code>,
<code><a href="#topic+scdf">scdf</a>()</code>,
<code><a href="#topic+select_cases">select_cases</a>()</code>,
<code><a href="#topic+set_vars">set_vars</a>()</code>,
<code><a href="#topic+shift">shift</a>()</code>,
<code><a href="#topic+smooth_cases">smooth_cases</a>()</code>,
<code><a href="#topic+standardize">standardize</a>()</code>,
<code><a href="#topic+truncate_phase">truncate_phase</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## In his study, Grosche (2011) could not realize measurements each
## single week for all participants. During the course of 100 weeks,
## about 20 measurements per person at different times were administered.

## Fill missing values in a single-case dataset with discontinuous
## measurement times
Grosche2011filled &lt;- fill_missing(Grosche2011)
study &lt;- c(Grosche2011[2], Grosche2011filled[2])
names(study) &lt;- c("Original", "Filled")
plot(study)

## Fill missing values in a single-case dataset that are NA
Maggie &lt;- random_scdf(design(level = list(0,1)), seed = 123)
Maggie_n &lt;- Maggie
replace.positions &lt;- c(10,16,18)
Maggie_n[[1]][replace.positions,"values"] &lt;- NA
Maggie_f &lt;- fill_missing(Maggie_n)
study &lt;- c(Maggie, Maggie_n, Maggie_f)
names(study) &lt;- c("original", "missing", "interpolated")
plot(study, marks = list(positions = replace.positions), style = "grid2")

</code></pre>

<hr>
<h2 id='hplm'>Hierarchical piecewise linear model / piecewise regression</h2><span id='topic+hplm'></span><span id='topic+print.sc_hplm'></span><span id='topic+export.sc_hplm'></span><span id='topic+coef.sc_hplm'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+hplm">hplm()</a></code> function computes a hierarchical piecewise regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hplm(
  data,
  dvar,
  pvar,
  mvar,
  model = c("W", "H-M", "B&amp;L-B", "JW"),
  contrast = c("first", "preceding"),
  contrast_level = NA,
  contrast_slope = NA,
  method = c("ML", "REML"),
  control = list(opt = "optim"),
  random.slopes = FALSE,
  lr.test = FALSE,
  ICC = TRUE,
  trend = TRUE,
  level = TRUE,
  slope = TRUE,
  fixed = NULL,
  random = NULL,
  update.fixed = NULL,
  data.l2 = NULL,
  ...
)

## S3 method for class 'sc_hplm'
print(x, ...)

## S3 method for class 'sc_hplm'
export(
  object,
  caption = NA,
  footnote = NA,
  filename = NA,
  kable_styling_options = list(),
  kable_options = list(),
  round = 2,
  nice = TRUE,
  ...
)

## S3 method for class 'sc_hplm'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hplm_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="hplm_+3A_dvar">dvar</code></td>
<td>
<p>Character string with the name of the dependent variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="hplm_+3A_pvar">pvar</code></td>
<td>
<p>Character string with the name of the phase variable. Defaults to
the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="hplm_+3A_mvar">mvar</code></td>
<td>
<p>Character string with the name of the measurement time variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="hplm_+3A_model">model</code></td>
<td>
<p>Model used for calculating the dummy parameters (see Huitema &amp;
McKean, 2000). Default is <code>model = "W"</code>. Possible values are: <code>"B&amp;L-B"</code>,
<code>"H-M"</code>, <code>"W"</code>, and deprecated <code>"JW"</code>.</p>
</td></tr>
<tr><td><code id="hplm_+3A_contrast">contrast</code></td>
<td>
<p>Sets contrast_level and contrast_slope. Either &quot;first&quot;,
&quot;preceding&quot; or a contrast matrix.</p>
</td></tr>
<tr><td><code id="hplm_+3A_contrast_level">contrast_level</code></td>
<td>
<p>Either &quot;first&quot;, &quot;preceding&quot; or a contrast matrix. If NA
contrast_level is a copy of contrast.</p>
</td></tr>
<tr><td><code id="hplm_+3A_contrast_slope">contrast_slope</code></td>
<td>
<p>Either &quot;first&quot;, &quot;preceding&quot; or a contrast matrix. If NA
contrast_level is a copy of contrast.</p>
</td></tr>
<tr><td><code id="hplm_+3A_method">method</code></td>
<td>
<p>Method used to fit your model. Pass <code>"REML"</code> to maximize the
restricted log-likelihood or <code>"ML"</code> for maximized log-likelihood. Default
is <code>"ML"</code>.</p>
</td></tr>
<tr><td><code id="hplm_+3A_control">control</code></td>
<td>
<p>A list of settings for the estimation algorithm, replacing the
default values passed to the function <code>lmeControl</code> of the <code>nlme</code> package.</p>
</td></tr>
<tr><td><code id="hplm_+3A_random.slopes">random.slopes</code></td>
<td>
<p>If <code>random.slopes = TRUE</code> random slope effects of the
level, trend, and treatment parameter are estimated.</p>
</td></tr>
<tr><td><code id="hplm_+3A_lr.test">lr.test</code></td>
<td>
<p>If set TRUE likelihood ratio tests are calculated comparing
model with vs. without random slope parameters.</p>
</td></tr>
<tr><td><code id="hplm_+3A_icc">ICC</code></td>
<td>
<p>If <code>ICC = TRUE</code> an intraclass-correlation is estimated.</p>
</td></tr>
<tr><td><code id="hplm_+3A_trend">trend</code></td>
<td>
<p>A logical indicating if a trend parameters is included in the
model.</p>
</td></tr>
<tr><td><code id="hplm_+3A_level">level</code></td>
<td>
<p>A logical indicating if a level parameters is included in the
model.</p>
</td></tr>
<tr><td><code id="hplm_+3A_slope">slope</code></td>
<td>
<p>A logical indicating if a slope parameters is included in the
model.</p>
</td></tr>
<tr><td><code id="hplm_+3A_fixed">fixed</code></td>
<td>
<p>Defaults to the fixed part of the standard piecewise regression
model. The parameter phase followed by the phase name (e.g., phaseB)
indicates the level effect of the corresponding phase. The parameter
'inter' followed by the phase name (e.g., interB) adresses the slope effect
based on the method provide in the model argument (e.g., &quot;B&amp;L-B&quot;). The
formula can be changed for example to include further L1 or L2 variables
into the regression model.</p>
</td></tr>
<tr><td><code id="hplm_+3A_random">random</code></td>
<td>
<p>The random part of the model.</p>
</td></tr>
<tr><td><code id="hplm_+3A_update.fixed">update.fixed</code></td>
<td>
<p>An easier way to change the fixed model part
(e.g., <code>. ~ . + newvariable</code>).</p>
</td></tr>
<tr><td><code id="hplm_+3A_data.l2">data.l2</code></td>
<td>
<p>A dataframe providing additional variables at Level 2. The
scdf File has to have names for all cases and the Level 2 dataframe has to
have a column named 'cases' with the names of the cases the Level 2
variables belong to.</p>
</td></tr>
<tr><td><code id="hplm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the lme function.</p>
</td></tr>
<tr><td><code id="hplm_+3A_x">x</code></td>
<td>
<p>An object returned by <code><a href="#topic+hplm">hplm()</a></code></p>
</td></tr>
<tr><td><code id="hplm_+3A_object">object</code></td>
<td>
<p>An scdf or an object exported from a scan function.</p>
</td></tr>
<tr><td><code id="hplm_+3A_caption">caption</code></td>
<td>
<p>Character string with table caption. If left NA (default) a
caption will be created based on the exported object.</p>
</td></tr>
<tr><td><code id="hplm_+3A_footnote">footnote</code></td>
<td>
<p>Character string with table footnote. If left NA (default) a
footnote will be created based on the exported object.</p>
</td></tr>
<tr><td><code id="hplm_+3A_filename">filename</code></td>
<td>
<p>String containing the file name. If a filename is given the
output will be written to that file.</p>
</td></tr>
<tr><td><code id="hplm_+3A_kable_styling_options">kable_styling_options</code></td>
<td>
<p>list with arguments passed to the kable_styling
function.</p>
</td></tr>
<tr><td><code id="hplm_+3A_kable_options">kable_options</code></td>
<td>
<p>list with arguments passed to the kable function.</p>
</td></tr>
<tr><td><code id="hplm_+3A_round">round</code></td>
<td>
<p>Integer passed to the digits argument internally used to round
values.</p>
</td></tr>
<tr><td><code id="hplm_+3A_nice">nice</code></td>
<td>
<p>If set TRUE (default) output values are rounded and optimized for
publication tables.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>model</code></td>
<td>
<p>List containing infromation about the applied model</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>Number of single-cases.</p>
</td></tr> <tr><td><code>formla</code></td>
<td>
<p>A list containing the fixed
and the random formulas of the hplm model.</p>
</td></tr> <tr><td><code>hplm</code></td>
<td>
<p>Object of class lme
contaning the multilevel model</p>
</td></tr> <tr><td><code>model.0</code></td>
<td>
<p>Object of class lme containing
the Zero Model.</p>
</td></tr> <tr><td><code>ICC</code></td>
<td>
<p>List containing intraclass correlation and test
parameters.</p>
</td></tr> <tr><td><code>model.without</code></td>
<td>
<p>Object of class gls containing the fixed
effect model.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>print(sc_hplm)</code>: Print results
</p>
</li>
<li> <p><code>export(sc_hplm)</code>: Export results as html table (see <code><a href="#topic+export">export()</a></code>)
</p>
</li>
<li> <p><code>coef(sc_hplm)</code>: Extract model coefficients
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>


<h3>See Also</h3>

<p>Other regression functions: 
<code><a href="#topic+autocorr">autocorr</a>()</code>,
<code><a href="#topic+corrected_tau">corrected_tau</a>()</code>,
<code><a href="#topic+mplm">mplm</a>()</code>,
<code><a href="#topic+plm">plm</a>()</code>,
<code><a href="#topic+trend">trend</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Compute hplm model on a MBD over fifty cases (restricted log-likelihood)
hplm(exampleAB_50, method = "REML", random.slopes = FALSE)

## Analyzing with additional L2 variables
Leidig2018 %&gt;%
  add_l2(Leidig2018_l2) %&gt;%
  hplm(update.fixed = .~. + gender + migration + ITRF_TOTAL*phaseB,
       slope = FALSE, random.slopes = FALSE, lr.test = FALSE
  )

</code></pre>

<hr>
<h2 id='ird'>IRD - Improvement rate difference</h2><span id='topic+ird'></span><span id='topic+print.sc_ird'></span>

<h3>Description</h3>

<p><code>ird()</code> calculates the robust improvement rate difference as proposed by
Parker and colleagues (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ird(data, dvar, pvar, decreasing = FALSE, phases = c(1, 2))

## S3 method for class 'sc_ird'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ird_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="ird_+3A_dvar">dvar</code></td>
<td>
<p>Character string with the name of the dependent variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="ird_+3A_pvar">pvar</code></td>
<td>
<p>Character string with the name of the phase variable. Defaults to
the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="ird_+3A_decreasing">decreasing</code></td>
<td>
<p>If you expect data to be lower in the B phase, set
<code>decreasing = TRUE</code>. Default is <code>decreasing = FALSE</code>.</p>
</td></tr>
<tr><td><code id="ird_+3A_phases">phases</code></td>
<td>
<p>A vector of two characters or numbers indicating the two phases
that should be compared. E.g., <code>phases = c("A","C")</code> or <code>phases = c(2,4)</code>
for comparing the second to the fourth phase. Phases could be combined by
providing a list with two elements. E.g., <code>phases = list(A = c(1,3), B = c(2,4))</code> will compare phases 1 and 3 (as A) against 2 and 4 (as B). Default
is <code>phases = c(1,2)</code>.</p>
</td></tr>
<tr><td><code id="ird_+3A_x">x</code></td>
<td>
<p>An object returned by <code><a href="#topic+ird">ird()</a></code></p>
</td></tr>
<tr><td><code id="ird_+3A_digits">digits</code></td>
<td>
<p>The minimum number of significant digits to be use.</p>
</td></tr>
<tr><td><code id="ird_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The adaptation of the improvement rate difference for single-case phase
comparisons was developed by Parker and colleagues (2009). A variation called
robust improvement rate difference was proposed by Parker and colleagues in
2011. This function calculates the robust improvement rate difference. It
follows the formula suggested by Pustejovsky (2019). For a multiple case
design, ird is based on the overall improvement rate of all cases which is
the average of the irds for each case.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>print(sc_ird)</code>: Print results
</p>
</li></ul>


<h3>References</h3>

<p>Parker, R. I., Vannest, K. J., &amp; Brown, L. (2009). The
improvement rate difference for single-case research. Exceptional Children,
75(2), 135-150.
</p>
<p>Parker, R. I., Vannest, K. J., &amp; Davis, J. L. (2011). Effect Size in
Single-Case Research: A Review of Nine Nonoverlap Techniques. Behavior
Modification, 35(4), 303-322. https://doi.org/10.1177/0145445511399147
</p>
<p>Pustejovsky, J. E. (2019). Procedural sensitivities of effect sizes for
single-case designs with directly observed behavioral outcome measures.
<em>Psychological Methods</em>, <em>24(2)</em>, 217-235.
https://doi.org/10.1037/met0000179
</p>

<hr>
<h2 id='is.scdf'>scdf objects
Tests for objects of type &quot;scdf&quot;</h2><span id='topic+is.scdf'></span>

<h3>Description</h3>

<p>scdf objects
Tests for objects of type &quot;scdf&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.scdf(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.scdf_+3A_x">x</code></td>
<td>
<p>An object to be tested</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns TRUE or FALSE depending on whether its argument is of scdf type or not.
</p>

<hr>
<h2 id='moving_median'>Transform every single case of a single case data frame</h2><span id='topic+moving_median'></span><span id='topic+moving_mean'></span><span id='topic+local_regression'></span><span id='topic+first_of'></span><span id='topic+across_cases'></span><span id='topic+all_cases'></span><span id='topic+transform.scdf'></span>

<h3>Description</h3>

<p>Takes an scdf and applies transformations to each individual case. This is
useful to calculate or modify new variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moving_median(x, lag = 1)

moving_mean(x, lag = 1)

local_regression(x, mt = 1:length(x), f = 0.2)

first_of(x, positions = 0)

across_cases(...)

all_cases(...)

## S3 method for class 'scdf'
transform(`_data`, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moving_median_+3A_x">x</code></td>
<td>
<p>A logical vector.</p>
</td></tr>
<tr><td><code id="moving_median_+3A_lag">lag</code></td>
<td>
<p>Number of values surrounding a value to calculate the average</p>
</td></tr>
<tr><td><code id="moving_median_+3A_mt">mt</code></td>
<td>
<p>A vector with measurement times.</p>
</td></tr>
<tr><td><code id="moving_median_+3A_f">f</code></td>
<td>
<p>the proportion of surrounding data influencing each data point.</p>
</td></tr>
<tr><td><code id="moving_median_+3A_positions">positions</code></td>
<td>
<p>A numeric vector with relative positions to the first
appearance of a TRUE value in x.</p>
</td></tr>
<tr><td><code id="moving_median_+3A_...">...</code></td>
<td>
<p>Expressions.</p>
</td></tr>
<tr><td><code id="moving_median_+3A__data">_data</code></td>
<td>
<p>An scdf.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method of the generic transform function. Unlike the
generic function, it calculates expressions serially. This means that the
results of the calculation of one expression are the basis for the following
computations. The <code>n</code> function returns the number of measurements in a
case. The <code>all_cases</code> function is a helper function that extracts the
values of a variable from all cases. It takes an expression as an argument.
For example, <code>mean(all_cases(values))</code> calculates the mean of the values
from all cases. <code>mean(all_cases(values[phase == "A"]))</code> will calculate
the mean of all values where phase is A. The function <code>across_cases</code>
allows to calculate new variables or replace existing variables across all
cases. E.g., <code>across_cases(values_ranked = rank(values, na.last =
"keep"))</code> will calculate a new variable with values ranked across all cases.
</p>


<h3>Value</h3>

<p>An scdf.
</p>


<h3>See Also</h3>

<p>Other data manipulation functions: 
<code><a href="#topic+add_l2">add_l2</a>()</code>,
<code><a href="#topic+as.data.frame.scdf">as.data.frame.scdf</a>()</code>,
<code><a href="#topic+as_scdf">as_scdf</a>()</code>,
<code><a href="#topic+fill_missing">fill_missing</a>()</code>,
<code><a href="#topic+outlier">outlier</a>()</code>,
<code><a href="#topic+ranks">ranks</a>()</code>,
<code><a href="#topic+scdf">scdf</a>()</code>,
<code><a href="#topic+select_cases">select_cases</a>()</code>,
<code><a href="#topic+set_vars">set_vars</a>()</code>,
<code><a href="#topic+shift">shift</a>()</code>,
<code><a href="#topic+smooth_cases">smooth_cases</a>()</code>,
<code><a href="#topic+standardize">standardize</a>()</code>,
<code><a href="#topic+truncate_phase">truncate_phase</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Creates a single-case with frequency distributions. The proportion and
## percentage of the frequencies are calculated with transform:
design &lt;- design(
 n = 3,
 level = 5,
 distribution = "binomial",
 n_trials = 20,
 start_value = 0.5
)
study &lt;- random_scdf(design)
transform(study, proportion = values/trials, percentage = proportion * 100)

## Z standardize the dependent variable and add two new variables:
exampleAB %&gt;%
  transform(
    values = scale(values),
    mean_values = mean(values),
    sd_values = sd(values)
  )

## Use `all` to calculate global variables.
exampleAB %&gt;%
  transform(
    values_center_case = values - mean(values[phase == "A"]),
    values_center_global = values - mean(all(values[phase == "A"])),
    value_dif = values_center_case - values_center_global
  )

## Use `across_cases` to calculate or replace a variable with values from
## all cases. E.g., standardize the dependent variable:
exampleABC %&gt;%
  transform(
    across_cases(values = scale(values))
  )

## Rank transform the values based on all cases vs. within each case:
exampleABC %&gt;%
  transform(
    across_cases(values_across = rank(values, na.last="keep")),
    value_within = rank(values, na.last="keep")
  )

## Three helper functions to smooth the data
Huber2014$Berta %&gt;%
transform(
  "compliance (moving median)" = moving_median(compliance),
  "compliance (moving mean)" = moving_mean(compliance),
  "compliance (local regression)" = local_regression(compliance, mt)
)

## Function first_of() helps to set NAs for specific phases.
## E.g., you want to replace the first two values of phase A and the first
## value of phase B and its preceding value.

byHeart2011 %&gt;%
  transform(
    values = replace(values, first_of(phase == "A", 0:1), NA),
    values = replace(values, first_of(phase == "B", -1:0), NA)
  )
</code></pre>

<hr>
<h2 id='mplm'>Multivariate Piecewise linear model / piecewise regression</h2><span id='topic+mplm'></span><span id='topic+print.sc_mplm'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+mplm">mplm()</a></code> function computes a multivariate piecewise regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mplm(
  data,
  dvar,
  mvar,
  pvar,
  model = c("W", "H-M", "B&amp;L-B", "JW"),
  contrast = c("first", "preceding"),
  contrast_level = c(NA, "first", "preceding"),
  contrast_slope = c(NA, "first", "preceding"),
  trend = TRUE,
  level = TRUE,
  slope = TRUE,
  formula = NULL,
  update = NULL,
  na.action = na.omit,
  ...
)

## S3 method for class 'sc_mplm'
print(x, digits = "auto", std = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mplm_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="mplm_+3A_dvar">dvar</code></td>
<td>
<p>Character string with the name of the dependent variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="mplm_+3A_mvar">mvar</code></td>
<td>
<p>Character string with the name of the measurement time variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="mplm_+3A_pvar">pvar</code></td>
<td>
<p>Character string with the name of the phase variable. Defaults to
the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="mplm_+3A_model">model</code></td>
<td>
<p>Model used for calculating the dummy parameters (see Huitema &amp;
McKean, 2000). Default is <code>model = "W"</code>. Possible values are: <code>"B&amp;L-B"</code>,
<code>"H-M"</code>, <code>"W"</code>, and deprecated <code>"JW"</code>.</p>
</td></tr>
<tr><td><code id="mplm_+3A_contrast">contrast</code></td>
<td>
<p>Sets contrast_level and contrast_slope. Either &quot;first&quot;,
&quot;preceding&quot; or a contrast matrix.</p>
</td></tr>
<tr><td><code id="mplm_+3A_contrast_level">contrast_level</code></td>
<td>
<p>Either &quot;first&quot;, &quot;preceding&quot; or a contrast matrix. If NA
contrast_level is a copy of contrast.</p>
</td></tr>
<tr><td><code id="mplm_+3A_contrast_slope">contrast_slope</code></td>
<td>
<p>Either &quot;first&quot;, &quot;preceding&quot; or a contrast matrix. If NA
contrast_level is a copy of contrast.</p>
</td></tr>
<tr><td><code id="mplm_+3A_trend">trend</code></td>
<td>
<p>A logical indicating if a trend parameters is included in the
model.</p>
</td></tr>
<tr><td><code id="mplm_+3A_level">level</code></td>
<td>
<p>A logical indicating if a level parameters is included in the
model.</p>
</td></tr>
<tr><td><code id="mplm_+3A_slope">slope</code></td>
<td>
<p>A logical indicating if a slope parameters is included in the
model.</p>
</td></tr>
<tr><td><code id="mplm_+3A_formula">formula</code></td>
<td>
<p>Defaults to the standard piecewise regression model. The
parameter phase followed by the phase name (e.g., <code>phaseB</code>) indicates the
level effect of the corresponding phase. The parameter 'inter' followed by
the phase name (e.g., <code>interB</code>) adresses the slope effect based on the
method provide in the model argument (e.g., <code>"B&amp;L-B"</code>). The formula can be
changed for example to include further variables into the regression model.</p>
</td></tr>
<tr><td><code id="mplm_+3A_update">update</code></td>
<td>
<p>An easier way to change the regression formula (e.g., <code>. ~ . + newvariable</code>).</p>
</td></tr>
<tr><td><code id="mplm_+3A_na.action">na.action</code></td>
<td>
<p>Defines how to deal with missing values</p>
</td></tr>
<tr><td><code id="mplm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the lm function.</p>
</td></tr>
<tr><td><code id="mplm_+3A_x">x</code></td>
<td>
<p>Object returned from <code><a href="#topic+mplm">mplm()</a></code>.</p>
</td></tr>
<tr><td><code id="mplm_+3A_digits">digits</code></td>
<td>
<p>The minimum number of significant digits to be use.
If set to &quot;auto&quot; (default), values are predefined.</p>
</td></tr>
<tr><td><code id="mplm_+3A_std">std</code></td>
<td>
<p>If TRUE, a table with standardized estimates is included.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>model</code></td>
<td>
<p>Character string from function call (see arguments
above).</p>
</td></tr> <tr><td><code>full.model</code></td>
<td>
<p>Full regression model list.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>print(sc_mplm)</code>: Print results
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>


<h3>See Also</h3>

<p>Other regression functions: 
<code><a href="#topic+autocorr">autocorr</a>()</code>,
<code><a href="#topic+corrected_tau">corrected_tau</a>()</code>,
<code><a href="#topic+hplm">hplm</a>()</code>,
<code><a href="#topic+plm">plm</a>()</code>,
<code><a href="#topic+trend">trend</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- mplm(Leidig2018$`1a1`,
  dvar = c("academic_engagement", "disruptive_behavior")
)
print(res)
## also report standardized coefficients:
print(res, std = TRUE)
</code></pre>

<hr>
<h2 id='nap'>Nonoverlap of all Pairs</h2><span id='topic+nap'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+nap">nap()</a></code> function calculates the nonoverlap of all pairs (NAP; Parker &amp;
Vannest, 2009).  NAP summarizes the overlap between all pairs of phase A and
phase B data points.  If an increase of phase B scores is expected, a
non-overlapping pair has a higher phase B data point.  The NAP equals
<em>number of pairs showing no overlap / number of pairs</em>.  Because NAP can
only take values between 50 and 100 percent, a rescaled and therefore more
intuitive NAP (0-100\
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nap(data, dvar, pvar, decreasing = FALSE, phases = c(1, 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nap_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="nap_+3A_dvar">dvar</code></td>
<td>
<p>Character string with the name of the dependent variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="nap_+3A_pvar">pvar</code></td>
<td>
<p>Character string with the name of the phase variable. Defaults to
the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="nap_+3A_decreasing">decreasing</code></td>
<td>
<p>If you expect data to be lower in the B phase, set
<code>decreasing = TRUE</code>. Default is <code>decreasing = FALSE</code>.</p>
</td></tr>
<tr><td><code id="nap_+3A_phases">phases</code></td>
<td>
<p>A vector of two characters or numbers indicating the two phases
that should be compared. E.g., <code>phases = c("A","C")</code> or <code>phases = c(2,4)</code>
for comparing the second to the fourth phase. Phases could be combined by
providing a list with two elements. E.g., <code>phases = list(A = c(1,3), B = c(2,4))</code> will compare phases 1 and 3 (as A) against 2 and 4 (as B). Default
is <code>phases = c(1,2)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>nap</code></td>
<td>
<p>A data frame with NAP and additional values for each
case.</p>
</td></tr> <tr><td><code>N</code></td>
<td>
<p>Number of cases.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>


<h3>References</h3>

<p>Parker, R. I., &amp; Vannest, K. (2009). An improved effect size for
single-case research: Nonoverlap of all pairs. <em>Behavior Therapy</em>, <em>40</em>,
357-367.
</p>


<h3>See Also</h3>

<p>Other overlap functions: 
<code><a href="#topic+cdc">cdc</a>()</code>,
<code><a href="#topic+overlap">overlap</a>()</code>,
<code><a href="#topic+pand">pand</a>()</code>,
<code><a href="#topic+pem">pem</a>()</code>,
<code><a href="#topic+pet">pet</a>()</code>,
<code><a href="#topic+pnd">pnd</a>()</code>,
<code><a href="#topic+tau_u">tau_u</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Calculate NAP for a study with  lower expected phase B scores
## (e.g. aggressive behavior)
gretchen &lt;- scdf(c(A = 12, 14, 9, 10, B = 10, 6, 4, 5, 3, 4))
nap(gretchen, decreasing = TRUE)

## Request NAP for all cases from the Grosche2011 scdf
nap(Grosche2011)

</code></pre>

<hr>
<h2 id='outlier'>Handling outliers in single-case data</h2><span id='topic+outlier'></span>

<h3>Description</h3>

<p>Identifies and drops outliers within a single-case data frame (scdf).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outlier(
  data,
  dvar,
  pvar,
  mvar,
  method = c("MAD", "Cook", "SD", "CI"),
  criteria = 3.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outlier_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="outlier_+3A_dvar">dvar</code></td>
<td>
<p>Character string with the name of the dependent variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="outlier_+3A_pvar">pvar</code></td>
<td>
<p>Character string with the name of the phase variable. Defaults to
the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="outlier_+3A_mvar">mvar</code></td>
<td>
<p>Character string with the name of the measurement time variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="outlier_+3A_method">method</code></td>
<td>
<p>Specifies the method for outlier identification. Set <code>method = "MAD"</code> for mean average deiviation, <code>method = "SD"</code> for standard
deviations, <code>method = "CI"</code> for confidence intervals, <code>method = "Cook"</code> for
Cook's Distance based on the Piecewise Linear Regression Model.</p>
</td></tr>
<tr><td><code id="outlier_+3A_criteria">criteria</code></td>
<td>
<p>Specifies the criteria for outlier identification. Based on
the <code>method</code> setting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>method = "SD"</code>, <code>criteria = 2</code> would refer t0 two
standard deviations. For <code>method = "MAD"</code>, <code>criteria = 3.5</code> would
refer to 3.5 times the mean average deviation. For <code>method = "CI"</code>,
<code>criteria = 0.99</code> would refer to a 99 percent confidence interval. For
<code>method = "cook"</code>, <code>criteria = "4/n"</code> would refer to a Cook's
Distance greater than 4/n.
</p>


<h3>Value</h3>

<table>
<tr><td><code>data</code></td>
<td>
<p>A single-case data frame with substituted outliers.</p>
</td></tr>
<tr><td><code>dropped.n</code></td>
<td>
<p>A list with the number of dropped data points for each
single-case.</p>
</td></tr> <tr><td><code>dropped.mt</code></td>
<td>
<p>A list with the measurement-times of dropped
data points for each single-case (values are based on the <code>mt</code> variable
of each single-case data frame).</p>
</td></tr> <tr><td><code>sd.matrix</code></td>
<td>
<p>A list with a matrix for
each case with values for the upper and lower boundaries based on the
standard deviation.</p>
</td></tr> <tr><td><code>ci.matrix</code></td>
<td>
<p>A list with a matrix for each
single-case with values for the upper and lower boundaries based on the
confidence interval.</p>
</td></tr> <tr><td><code>cook</code></td>
<td>
<p>A list of Cook's Distances for each
measurement of each single-case.</p>
</td></tr> <tr><td><code>criteria</code></td>
<td>
<p>Criteria used for outlier
analysis.</p>
</td></tr> <tr><td><code>N</code></td>
<td>
<p>Number of single-cases.</p>
</td></tr> <tr><td><code>case.names</code></td>
<td>
<p>Case
identifier.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>


<h3>See Also</h3>

<p>Other data manipulation functions: 
<code><a href="#topic+add_l2">add_l2</a>()</code>,
<code><a href="#topic+as.data.frame.scdf">as.data.frame.scdf</a>()</code>,
<code><a href="#topic+as_scdf">as_scdf</a>()</code>,
<code><a href="#topic+fill_missing">fill_missing</a>()</code>,
<code><a href="#topic+moving_median">moving_median</a>()</code>,
<code><a href="#topic+ranks">ranks</a>()</code>,
<code><a href="#topic+scdf">scdf</a>()</code>,
<code><a href="#topic+select_cases">select_cases</a>()</code>,
<code><a href="#topic+set_vars">set_vars</a>()</code>,
<code><a href="#topic+shift">shift</a>()</code>,
<code><a href="#topic+smooth_cases">smooth_cases</a>()</code>,
<code><a href="#topic+standardize">standardize</a>()</code>,
<code><a href="#topic+truncate_phase">truncate_phase</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Identify outliers using 1.5 standard deviations as criterion
susanne &lt;- random_scdf(level = 1.0)
res_outlier &lt;- outlier(susanne, method = "SD", criteria = 1.5)
plot(susanne, marks = res_outlier)

## Identify outliers in the original data from Grosche (2011)
## using Cook's Distance greater than 4/n as criterion
res_outlier &lt;- outlier(Grosche2011, method = "Cook", criteria = "4/n")
plot(Grosche2011, marks = res_outlier)

</code></pre>

<hr>
<h2 id='overlap'>Overlap indices for single-case data</h2><span id='topic+overlap'></span>

<h3>Description</h3>

<p>The <code>overlap</code> function provides the most common overlap indices for
single-case data and some additional statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlap(data, dvar, pvar, mvar, decreasing = FALSE, phases = c(1, 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlap_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="overlap_+3A_dvar">dvar</code></td>
<td>
<p>Character string with the name of the dependent variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="overlap_+3A_pvar">pvar</code></td>
<td>
<p>Character string with the name of the phase variable. Defaults to
the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="overlap_+3A_mvar">mvar</code></td>
<td>
<p>Character string with the name of the measurement time variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="overlap_+3A_decreasing">decreasing</code></td>
<td>
<p>If you expect data to be lower in the B phase, set
<code>decreasing = TRUE</code>. Default is <code>decreasing = FALSE</code>.</p>
</td></tr>
<tr><td><code id="overlap_+3A_phases">phases</code></td>
<td>
<p>A vector of two characters or numbers indicating the two phases
that should be compared. E.g., <code>phases = c("A","C")</code> or <code>phases = c(2,4)</code>
for comparing the second to the fourth phase. Phases could be combined by
providing a list with two elements. E.g., <code>phases = list(A = c(1,3), B = c(2,4))</code> will compare phases 1 and 3 (as A) against 2 and 4 (as B). Default
is <code>phases = c(1,2)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See corresponding functions of PND, PEM, PET, NAP, PAND for
calculation. Tau_U(A) reports &quot;A vs. B - Trend A&quot; whereas Tau_U(BA) reports
&quot;A vs. B + Trend B - Trend A&quot;. Base_Tau is baseline corrected tau
(correction applied when autocorrelation in phase A is significant).
Diff_mean is the mean difference. Diff_trend is the difference in the
regression estimation of the dependent variable on measurement-time (<code>x ~ mt</code>) for each phase. SMD is the mean difference divided by the standard
deviation of phase A. Hedges_g is the mean difference divided by the pooled
standard deviation: <code class="reqn">\sqrt{ (n_A - 1)sd_A^2 + (n_B - 1)sd_B^2 \over n_A
  + n_B - 2 }</code> with a hedges correction applied: <code class="reqn">Hedges_g * (1 -
  \frac{3}{4n - 9} ) )</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>overlap</code></td>
<td>
<p>A data frame consisting of the following indices for
each single-case for all cases: PND, PEM, PET, NAP, PAND, IRD, Tau-U (A vs. B -
Trend A), Diff_mean, Diff_trend, SMD, Hedges-g.</p>
</td></tr>
<tr><td><code>phases.A</code></td>
<td>
<p>Selection for A phase.</p>
</td></tr> <tr><td><code>phases.B</code></td>
<td>
<p>Selection for B
phase.</p>
</td></tr> <tr><td><code>design</code></td>
<td>
<p>Phase design.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>


<h3>See Also</h3>

<p>Other overlap functions: 
<code><a href="#topic+cdc">cdc</a>()</code>,
<code><a href="#topic+nap">nap</a>()</code>,
<code><a href="#topic+pand">pand</a>()</code>,
<code><a href="#topic+pem">pem</a>()</code>,
<code><a href="#topic+pet">pet</a>()</code>,
<code><a href="#topic+pnd">pnd</a>()</code>,
<code><a href="#topic+tau_u">tau_u</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Display overlap indices for one single-case
overlap(Huitema2000, decreasing = TRUE)

## Display overlap indices for six single-cases
overlap(GruenkeWilbert2014)

## Combining phases for analyszing designs with more than two phases
overlap(exampleA1B1A2B2, phases = list(c("A1","A2"), c("B1","B2")))

</code></pre>

<hr>
<h2 id='pand'>Percentage of all non-overlapping data</h2><span id='topic+pand'></span><span id='topic+print.sc_pand'></span><span id='topic+export.sc_pand'></span>

<h3>Description</h3>

<p>The <code>pand()</code> function calculates the percentage of all non-overlapping data
(PAND; Parker, Hagan-Burke, &amp; Vannest, 2007), an index to quantify a level
increase (or decrease) in performance after the onset of an intervention.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pand(
  data,
  dvar,
  pvar,
  decreasing = FALSE,
  phases = c(1, 2),
  method = c("sort", "minimum")
)

## S3 method for class 'sc_pand'
print(x, ...)

## S3 method for class 'sc_pand'
export(
  object,
  caption = NA,
  footnote = NA,
  filename = NA,
  kable_styling_options = list(),
  kable_options = list(),
  round = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pand_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="pand_+3A_dvar">dvar</code></td>
<td>
<p>Character string with the name of the dependent variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="pand_+3A_pvar">pvar</code></td>
<td>
<p>Character string with the name of the phase variable. Defaults to
the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="pand_+3A_decreasing">decreasing</code></td>
<td>
<p>If you expect data to be lower in the B phase, set
<code>decreasing = TRUE</code>. Default is <code>decreasing = FALSE</code>.</p>
</td></tr>
<tr><td><code id="pand_+3A_phases">phases</code></td>
<td>
<p>A vector of two characters or numbers indicating the two phases
that should be compared. E.g., <code>phases = c("A","C")</code> or <code>phases = c(2,4)</code>
for comparing the second to the fourth phase. Phases could be combined by
providing a list with two elements. E.g., <code>phases = list(A = c(1,3), B = c(2,4))</code> will compare phases 1 and 3 (as A) against 2 and 4 (as B). Default
is <code>phases = c(1,2)</code>.</p>
</td></tr>
<tr><td><code id="pand_+3A_method">method</code></td>
<td>
<p>Either <code>"sort"</code>&quot; or <code>"minimum"</code>. See details.</p>
</td></tr>
<tr><td><code id="pand_+3A_x">x</code></td>
<td>
<p>An object returned by <code><a href="#topic+pand">pand()</a></code></p>
</td></tr>
<tr><td><code id="pand_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the function.</p>
</td></tr>
<tr><td><code id="pand_+3A_object">object</code></td>
<td>
<p>An scdf or an object exported from a scan function.</p>
</td></tr>
<tr><td><code id="pand_+3A_caption">caption</code></td>
<td>
<p>Character string with table caption. If left NA (default) a
caption will be created based on the exported object.</p>
</td></tr>
<tr><td><code id="pand_+3A_footnote">footnote</code></td>
<td>
<p>Character string with table footnote. If left NA (default) a
footnote will be created based on the exported object.</p>
</td></tr>
<tr><td><code id="pand_+3A_filename">filename</code></td>
<td>
<p>String containing the file name. If a filename is given the
output will be written to that file.</p>
</td></tr>
<tr><td><code id="pand_+3A_kable_styling_options">kable_styling_options</code></td>
<td>
<p>list with arguments passed to the kable_styling
function.</p>
</td></tr>
<tr><td><code id="pand_+3A_kable_options">kable_options</code></td>
<td>
<p>list with arguments passed to the kable function.</p>
</td></tr>
<tr><td><code id="pand_+3A_round">round</code></td>
<td>
<p>Integer passed to the digits argument internally used to round
values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>PAND was proposed by Parker, Hagan-Burke, and Vannest in 2007. The authors
emphasize that PAND is designed for application in a multiple case design with
a substantial number of measurements, technically at least 20 to 25, but
preferably 60 or more. PAND is defined as 100% minus the percentage of data
points that need to be removed from either phase in order to ensure nonoverlap
between the phases. Several approaches have been suggested to calculate PAND,
leading to potentially different outcomes. In their 2007 paper, Parker and
colleagues present an algorithm for computing PAND. The algorithm involves
sorting the scores of a time series, including the associated phases, and
comparing the resulting phase order with the original phase order using a
contingency table. To account for ties, the algorithm includes a randomization
process where ties are randomly assigned to one of the two phases.
Consequently, executing the algorithm multiple times could yield different
results. It is important to note that this algorithm does not produce the same
results as the PAND definition provided earlier in the same paper. However, it
offers the advantage of allowing the calculation of an effect size measure
<code>phi</code>, and the application of statistical tests for frequency distributions.
Pustejovsky (2019) presented a mathematical formulation of Parker's original
definition for comparing two phases of a single case: </p>
<p style="text-align: center;"><code class="reqn">PAND =
\frac{1}{m+n}max\{(i+j)I(y^A_{i}&lt;y^B_{n+1-j}\}</code>
</p>
<p> This formulation provides
accurate results for PAND, but the original definition has the drawback of an
unknown distribution under the null hypothesis, making a statistical test
difficult. The <code>pand()</code> function enables the calculation of PAND using both
methods. The first approach (<code>method = "sort"</code>) follows the algorithm
described above, with the exclusion of randomization before sorting to avoid
ambiguity. It calculates a phi measure and provides the results of a
chi-squared test and a Fisher exact test. The second approach (<code>method = "minimum"</code>) applies the aforementioned formula. The code of this function is
based on the code of the <code>SingleCaseES</code> package (function <code>calc_PAND</code>). For a
multiple case design, overlaps are calculated for each case, summed, and then
divided by the total number of measurements. No statistical test is conducted
for this method.
</p>


<h3>Value</h3>

<table>
<tr><td><code>pand</code></td>
<td>
<p>Percentage of all non-overlapping data.</p>
</td></tr> <tr><td><code>phi</code></td>
<td>
<p>Effect
size Phi based on expected and observed values.</p>
</td></tr>
<tr><td><code>perc_overlap</code></td>
<td>
<p>Percentage of overlapping data points.</p>
</td></tr> <tr><td><code>overlaps</code></td>
<td>
<p>Number of
overlapping data points.</p>
</td></tr> <tr><td><code>n</code></td>
<td>
<p>Number of data points.</p>
</td></tr> <tr><td><code>N</code></td>
<td>
<p>Number
of cases.</p>
</td></tr> <tr><td><code>n_a</code></td>
<td>
<p>Number of data points in phase A.</p>
</td></tr> <tr><td><code>n_b</code></td>
<td>
<p>Number of
data points in phase B.</p>
</td></tr> <tr><td><code>matrix</code></td>
<td>
<p>2x2 frequency
matrix of phase A and B comparisons.</p>
</td></tr> <tr><td><code>matrix_counts</code></td>
<td>
<p>2x2 counts matrix
of phase A and B comparisons.</p>
</td></tr> <tr><td><code>chi_test</code></td>
<td>
<p>A Chi-squared analysis of expected and observed data
(<code><a href="stats.html#topic+chisq.test">chisq.test()</a></code>).</p>
</td></tr> <tr><td><code>fisher_test</code></td>
<td>
<p>A Fisher exact test analysis of expected and observed data
(<code><a href="stats.html#topic+fisher.test">fisher.test()</a></code>).</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>print(sc_pand)</code>: Print results
</p>
</li>
<li> <p><code>export(sc_pand)</code>: Export results as html table (see <code><a href="#topic+export">export()</a></code>)
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>


<h3>References</h3>

<p>Parker, R. I., Hagan-Burke, S., &amp; Vannest, K. (2007). Percentage
of All Non-Overlapping Data (PAND): An Alternative to PND. <em>The Journal of
Special Education, 40</em>, 194-204.
</p>
<p>Parker, R. I., &amp; Vannest, K. (2009). An Improved Effect Size for Single-Case
Research: Nonoverlap of All Pairs. <em>Behavior Therapy, 40</em>, 357-367.
</p>
<p>Pustejovsky, J. E. (2019). Procedural sensitivities of effect sizes for
single-case designs with directly observed behavioral outcome measures.
<em>Psychological Methods</em>, <em>24(2)</em>, 217-235.
https://doi.org/10.1037/met0000179
</p>
<p>Pustejovsky JE, Chen M, Swan DM (2023). SingleCaseES: A Calculator for
Single-Case Effect Sizes. R package version 0.7.1.9999,
https://jepusto.github.io/SingleCaseES/.
</p>


<h3>See Also</h3>

<p>Other overlap functions: 
<code><a href="#topic+cdc">cdc</a>()</code>,
<code><a href="#topic+nap">nap</a>()</code>,
<code><a href="#topic+overlap">overlap</a>()</code>,
<code><a href="#topic+pem">pem</a>()</code>,
<code><a href="#topic+pet">pet</a>()</code>,
<code><a href="#topic+pnd">pnd</a>()</code>,
<code><a href="#topic+tau_u">tau_u</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## REplication of the Parker et al. 2007 example
pand(Parker2007)

## Calculate the PAND with an expected decrease of phase B scores
cubs &lt;- scdf(c(20,22,24,17,21,13,10,9,20,9,18), B_start = 5)
pand(cubs, decreasing = TRUE)

</code></pre>

<hr>
<h2 id='pem'>Percent exceeding the median</h2><span id='topic+pem'></span>

<h3>Description</h3>

<p>The <code>pem</code> function returns the percentage of phase B data exceeding the
phase A median.  Additionally, a chi square test against a 50/50
distribution is computed.  Different measures of central tendency can be
addressed for alternative analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pem(
  data,
  dvar,
  pvar,
  decreasing = FALSE,
  binom.test = TRUE,
  chi.test = FALSE,
  FUN = median,
  phases = c(1, 2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pem_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="pem_+3A_dvar">dvar</code></td>
<td>
<p>Character string with the name of the dependent variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="pem_+3A_pvar">pvar</code></td>
<td>
<p>Character string with the name of the phase variable. Defaults to
the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="pem_+3A_decreasing">decreasing</code></td>
<td>
<p>If you expect data to be lower in the B phase, set
<code>decreasing = TRUE</code>. Default is <code>decreasing = FALSE</code>.</p>
</td></tr>
<tr><td><code id="pem_+3A_binom.test">binom.test</code></td>
<td>
<p>Computes a binomial test for a 50/50 distribution. Default
is <code>binom.test = TRUE</code>.</p>
</td></tr>
<tr><td><code id="pem_+3A_chi.test">chi.test</code></td>
<td>
<p>Computes a Chi-square test. The default setting
<code>chi.test = FALSE</code> skips the Chi-square test.</p>
</td></tr>
<tr><td><code id="pem_+3A_fun">FUN</code></td>
<td>
<p>Data points are compared with the phase A median. Use this
argument to implement alternative measures of central tendency. Default is
<code>FUN = median</code></p>
</td></tr>
<tr><td><code id="pem_+3A_phases">phases</code></td>
<td>
<p>A vector of two characters or numbers indicating the two phases
that should be compared. E.g., <code>phases = c("A","C")</code> or <code>phases = c(2,4)</code>
for comparing the second to the fourth phase. Phases could be combined by
providing a list with two elements. E.g., <code>phases = list(A = c(1,3), B = c(2,4))</code> will compare phases 1 and 3 (as A) against 2 and 4 (as B). Default
is <code>phases = c(1,2)</code>.</p>
</td></tr>
<tr><td><code id="pem_+3A_...">...</code></td>
<td>
<p>Additional arguments for the <code>FUN</code> parameter (e.g.
<code>FUN = mean, trim = 0.1</code> will use the 10 percent trimmed arithmetic
mean instead of the median for comparisons). The function must take a vector
of numeric values and the <code>na.rm</code> argument and return a numeric value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>


<h3>See Also</h3>

<p>Other overlap functions: 
<code><a href="#topic+cdc">cdc</a>()</code>,
<code><a href="#topic+nap">nap</a>()</code>,
<code><a href="#topic+overlap">overlap</a>()</code>,
<code><a href="#topic+pand">pand</a>()</code>,
<code><a href="#topic+pet">pet</a>()</code>,
<code><a href="#topic+pnd">pnd</a>()</code>,
<code><a href="#topic+tau_u">tau_u</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Calculate the PEM including the Binomial and Chi-square tests for a single-case
dat &lt;- random_scdf(5, level = 0.5)
pem(dat, chi.test = TRUE)

</code></pre>

<hr>
<h2 id='pet'>Percent exceeding the trend</h2><span id='topic+pet'></span>

<h3>Description</h3>

<p>The <code>pet</code> function returns the percentage of Phase B data points that exceed
the prediction based on the Phase A trend. A binomial test against a 50/50
distribution is calculated. It also calculates the percentage of Phase B data
points that exceed the upper (or lower) 95 percent confidence interval of the
predicted progression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pet(data, dvar, pvar, mvar, ci = 0.95, decreasing = FALSE, phases = c(1, 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pet_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="pet_+3A_dvar">dvar</code></td>
<td>
<p>Character string with the name of the dependent variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="pet_+3A_pvar">pvar</code></td>
<td>
<p>Character string with the name of the phase variable. Defaults to
the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="pet_+3A_mvar">mvar</code></td>
<td>
<p>Character string with the name of the measurement time variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="pet_+3A_ci">ci</code></td>
<td>
<p>Width of the confidence interval. Default is <code>ci = 0.95</code>.</p>
</td></tr>
<tr><td><code id="pet_+3A_decreasing">decreasing</code></td>
<td>
<p>If you expect data to be lower in the B phase, set
<code>decreasing = TRUE</code>. Default is <code>decreasing = FALSE</code>.</p>
</td></tr>
<tr><td><code id="pet_+3A_phases">phases</code></td>
<td>
<p>A vector of two characters or numbers indicating the two phases
that should be compared. E.g., <code>phases = c("A","C")</code> or <code>phases = c(2,4)</code>
for comparing the second to the fourth phase. Phases could be combined by
providing a list with two elements. E.g., <code>phases = list(A = c(1,3), B = c(2,4))</code> will compare phases 1 and 3 (as A) against 2 and 4 (as B). Default
is <code>phases = c(1,2)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>PET</code></td>
<td>
<p>Percent exceeding the trend.</p>
</td></tr> <tr><td><code>PET.ci</code></td>
<td>
<p>Percent
exceeding the upper / lower 95\
Test.</p>
</td></tr> <tr><td><code>ci.percent</code></td>
<td>
<p>Width of confidence interval in percent.</p>
</td></tr>
<tr><td><code>se.factors</code></td>
<td>
<p>Standard error.</p>
</td></tr> <tr><td><code>N</code></td>
<td>
<p>Number of cases.</p>
</td></tr>
<tr><td><code>decreasing</code></td>
<td>
<p>Logical argument from function call (see <code>Arguments</code>
above).</p>
</td></tr> <tr><td><code>case.names</code></td>
<td>
<p>Assigned name of single-case.</p>
</td></tr> <tr><td><code>phases</code></td>
<td>
<p>-</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>


<h3>See Also</h3>

<p>Other overlap functions: 
<code><a href="#topic+cdc">cdc</a>()</code>,
<code><a href="#topic+nap">nap</a>()</code>,
<code><a href="#topic+overlap">overlap</a>()</code>,
<code><a href="#topic+pand">pand</a>()</code>,
<code><a href="#topic+pem">pem</a>()</code>,
<code><a href="#topic+pnd">pnd</a>()</code>,
<code><a href="#topic+tau_u">tau_u</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Calculate the PET and use a 99%-CI for the additional calculation
# create random example data
design &lt;- design(n = 5, slope = 0.2)
dat &lt;- random_scdf(design, seed = 23)
pet(dat, ci = .99)

</code></pre>

<hr>
<h2 id='plm'>Piecewise linear model / piecewise regression</h2><span id='topic+plm'></span>

<h3>Description</h3>

<p>The <code>plm</code> function computes a piecewise regression model (see Huitema &amp;
McKean, 2000).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plm(
  data,
  dvar,
  pvar,
  mvar,
  AR = 0,
  model = c("W", "H-M", "B&amp;L-B", "JW"),
  family = "gaussian",
  trend = TRUE,
  level = TRUE,
  slope = TRUE,
  contrast = c("first", "preceding"),
  contrast_level = c(NA, "first", "preceding"),
  contrast_slope = c(NA, "first", "preceding"),
  formula = NULL,
  update = NULL,
  na.action = na.omit,
  r_squared = TRUE,
  var_trials = NULL,
  dvar_percentage = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plm_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="plm_+3A_dvar">dvar</code></td>
<td>
<p>Character string with the name of the dependent variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="plm_+3A_pvar">pvar</code></td>
<td>
<p>Character string with the name of the phase variable. Defaults to
the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="plm_+3A_mvar">mvar</code></td>
<td>
<p>Character string with the name of the measurement time variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="plm_+3A_ar">AR</code></td>
<td>
<p>Maximal lag of autoregression. Modeled based on the
Autoregressive-Moving Average (ARMA) function.  When AR is set, the family
argument must be set to <code>family = "gaussian"</code>.</p>
</td></tr>
<tr><td><code id="plm_+3A_model">model</code></td>
<td>
<p>Model used for calculating the dummy parameters (see Huitema &amp;
McKean, 2000). Default is <code>model = "W"</code>. Possible values are: <code>"B&amp;L-B"</code>,
<code>"H-M"</code>, <code>"W"</code>, and deprecated <code>"JW"</code>.</p>
</td></tr>
<tr><td><code id="plm_+3A_family">family</code></td>
<td>
<p>Set the distribution family. Defaults to a gaussian
distribution. See the <code>family</code> function for more details.</p>
</td></tr>
<tr><td><code id="plm_+3A_trend">trend</code></td>
<td>
<p>A logical indicating if a trend parameters is included in the
model.</p>
</td></tr>
<tr><td><code id="plm_+3A_level">level</code></td>
<td>
<p>A logical indicating if a level parameters is included in the
model.</p>
</td></tr>
<tr><td><code id="plm_+3A_slope">slope</code></td>
<td>
<p>A logical indicating if a slope parameters is included in the
model.</p>
</td></tr>
<tr><td><code id="plm_+3A_contrast">contrast</code></td>
<td>
<p>Sets contrast_level and contrast_slope. Either &quot;first&quot;,
&quot;preceding&quot; or a contrast matrix.</p>
</td></tr>
<tr><td><code id="plm_+3A_contrast_level">contrast_level</code></td>
<td>
<p>Either &quot;first&quot;, &quot;preceding&quot; or a contrast matrix. If NA
contrast_level is a copy of contrast.</p>
</td></tr>
<tr><td><code id="plm_+3A_contrast_slope">contrast_slope</code></td>
<td>
<p>Either &quot;first&quot;, &quot;preceding&quot; or a contrast matrix. If NA
contrast_level is a copy of contrast.</p>
</td></tr>
<tr><td><code id="plm_+3A_formula">formula</code></td>
<td>
<p>Defaults to the standard piecewise regression model. The
parameter phase followed by the phase name (e.g., phaseB) indicates the
level effect of the corresponding phase. The parameter 'inter' followed by
the phase name (e.g., interB) adresses the slope effect based on the method
provide in the model argument (e.g., &quot;B&amp;L-B&quot;). The formula can be changed
for example to include further variables into the regression model.</p>
</td></tr>
<tr><td><code id="plm_+3A_update">update</code></td>
<td>
<p>An easier way to change the regression formula (e.g., <code>. ~ . + newvariable</code>).</p>
</td></tr>
<tr><td><code id="plm_+3A_na.action">na.action</code></td>
<td>
<p>Defines how to deal with missing values.</p>
</td></tr>
<tr><td><code id="plm_+3A_r_squared">r_squared</code></td>
<td>
<p>Logical. If TRUE, delta r_squares will be calculated for
each predictor.</p>
</td></tr>
<tr><td><code id="plm_+3A_var_trials">var_trials</code></td>
<td>
<p>Name of the variable containing the number of trials (only
for binomial regressions). If a single integer is provided this is
considered to be a the constant number of trials across all measurements.</p>
</td></tr>
<tr><td><code id="plm_+3A_dvar_percentage">dvar_percentage</code></td>
<td>
<p>Only for binomial distribution. If set TRUE, the
dependent variable is assumed to represent proportions <code style="white-space: pre;">&#8288;[0,1]&#8288;</code>. Otherwise
dvar is assumed to represent counts.</p>
</td></tr>
<tr><td><code id="plm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the glm function.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>formula</code></td>
<td>
<p>plm formula. Uselful if you want to use the update or
formula argument and you don't know the names of the parameters.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>Character string from function call (see <code>Arguments</code>
above).</p>
</td></tr>
<tr><td><code>F.test</code></td>
<td>
<p>F-test values of modelfit.</p>
</td></tr> <tr><td><code>r.squares</code></td>
<td>
<p>Explained variance
R squared for each model parameter.</p>
</td></tr>
<tr><td><code>ar</code></td>
<td>
<p>Autoregression lag from function call (see <code>Arguments</code>
above).</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>Distribution family from function call
(see <code>Arguments</code> above).</p>
</td></tr>
<tr><td><code>full.model</code></td>
<td>
<p>Full regression model list from the gls or glm function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>


<h3>References</h3>

<p>Beretvas, S., &amp; Chung, H. (2008). An evaluation of modified
R2-change effect size indices for single-subject experimental designs.
<em>Evidence-Based Communication Assessment and Intervention, 2</em>,
120-128.
</p>
<p>Huitema, B. E., &amp; McKean, J. W. (2000). Design specification issues in
time-series intervention models. <em>Educational and Psychological
Measurement, 60</em>, 38-58.
</p>


<h3>See Also</h3>

<p>Other regression functions: 
<code><a href="#topic+autocorr">autocorr</a>()</code>,
<code><a href="#topic+corrected_tau">corrected_tau</a>()</code>,
<code><a href="#topic+hplm">hplm</a>()</code>,
<code><a href="#topic+mplm">mplm</a>()</code>,
<code><a href="#topic+trend">trend</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Compute a piecewise regression model for a random single-case
set.seed(123)
AB &lt;- design(
  phase_design = list(A = 10, B = 20),
  level = list(A = 0, B = 1), slope = list(A = 0, B = 0.05),
  trend = 0.05
)
dat &lt;- random_scdf(design = AB)
plm(dat, AR = 3)

## Another example with a more complex design
A1B1A2B2 &lt;- design(
  phase_design = list(A1 = 15, B1 = 20, A2 = 15, B2 = 20),
  level = list(A1 = 0, B1 = 1, A2 = -1, B2 = 1),
  slope = list(A1 = 0, B1 = 0.0, A2 = 0, B2 = 0.0),
  trend = 0.0)
dat &lt;- random_scdf(design = A1B1A2B2, seed = 123)
plm(dat, contrast = "preceding")

## no slope effects were found. Therefore, you might want to the drop slope
## estimation:
plm(dat, slope = FALSE, contrast = "preceding")

## and now drop the trend estimation as well
plm(dat, slope = FALSE, trend = FALSE, contrast = "preceding")

## A poisson regression
example_A24 %&gt;%
  plm(family = "poisson")

## A binomial regression (frequencies as dependent variable)
plm(exampleAB_score$Christiano, family = "binomial", var_trials = "trials")

## A binomial regression (percentage as dependent variable)
exampleAB_score$Christiano %&gt;%
  transform(percentage = values/trials) %&gt;%
  set_dvar("percentage") %&gt;%
  plm(family = "binomial", var_trials = "trials", dvar_percentage = TRUE)
</code></pre>

<hr>
<h2 id='plot_rand'>Plot random distribution</h2><span id='topic+plot_rand'></span>

<h3>Description</h3>

<p>This function takes the return of the rand_test function and creates a
histogram with the distribution of the rand sample statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_rand(
  object,
  xlab = NA,
  ylab = "Frequency",
  title = "Random distribution",
  text_observed = "observed",
  color = "lightgrey",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_rand_+3A_object">object</code></td>
<td>
<p>Object returned from the rand_test() function</p>
</td></tr>
<tr><td><code id="plot_rand_+3A_xlab">xlab</code></td>
<td>
<p>Label for the x-axis.</p>
</td></tr>
<tr><td><code id="plot_rand_+3A_ylab">ylab</code></td>
<td>
<p>Label for the y-axis.</p>
</td></tr>
<tr><td><code id="plot_rand_+3A_title">title</code></td>
<td>
<p>Plot title.</p>
</td></tr>
<tr><td><code id="plot_rand_+3A_text_observed">text_observed</code></td>
<td>
<p>Text for marking the number of observed statistic.</p>
</td></tr>
<tr><td><code id="plot_rand_+3A_color">color</code></td>
<td>
<p>Bar color.</p>
</td></tr>
<tr><td><code id="plot_rand_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the plot function.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.scdf'>Plot single-case data</h2><span id='topic+plot.scdf'></span><span id='topic+plotSC'></span>

<h3>Description</h3>

<p>This function provides a plot of a single-case or multiple single-cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scdf'
plot(...)

plotSC(
  data,
  dvar,
  pvar,
  mvar,
  ylim = NULL,
  xlim = NULL,
  xinc = 1,
  lines = NULL,
  marks = NULL,
  phase.names = NULL,
  xlab = NULL,
  ylab = NULL,
  main = "",
  case.names = NULL,
  style = getOption("scan.plot.style"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.scdf_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the plot command.</p>
</td></tr>
<tr><td><code id="plot.scdf_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="plot.scdf_+3A_dvar">dvar</code></td>
<td>
<p>Character string with the name of the dependent variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="plot.scdf_+3A_pvar">pvar</code></td>
<td>
<p>Character string with the name of the phase variable. Defaults to
the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="plot.scdf_+3A_mvar">mvar</code></td>
<td>
<p>Character string with the name of the measurement time variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="plot.scdf_+3A_ylim">ylim</code></td>
<td>
<p>Lower and upper limits of the y-axis (e.g., <code>ylim = c(0,
  20)</code> sets the y-axis to a scale from 0 to 20). With multiple single-cases
you can use <code>ylim = c(0, NA)</code> to scale the y-axis from 0 to the
maximum of each case. <code>ylim</code> is not set by default, which makes
<code>scan</code> set a proper scale based on the given data.</p>
</td></tr>
<tr><td><code id="plot.scdf_+3A_xlim">xlim</code></td>
<td>
<p>Lower and upper limits of the x-axis (e.g., <code>xlim = c(0,
  20)</code> sets the x-axis to a scale from 0 to 20). With multiple single-cases
you can use <code>ylim = c(0, NA)</code> to scale the x-axis from 0 to the
maximum of each case. <code>xlim</code> is not set by default, which makes
<code>scan</code> set a proper scale based on the given data.</p>
</td></tr>
<tr><td><code id="plot.scdf_+3A_xinc">xinc</code></td>
<td>
<p>An integer. Increment of the x-axis. 1 :each mt value will be
printed, 2 : every other value, 3 : every third values etc.</p>
</td></tr>
<tr><td><code id="plot.scdf_+3A_lines">lines</code></td>
<td>
<p>A list defining one or multiple lines or curves to be plotted.
The argument is passed as a list (e.g., <code>list(type = "median")</code>). Some
of the procedures can be refined with an additional argument (e.g.,
<code>lines = list(type = "mean", trim = 0.2)</code> adds a 20\
line. For multiple lines, provide a list element for each line (e.g.,
<code>list( list(type = "median", col = "red"), list(type = "trend", col =
  "blue"))</code>.
Possible lines are: </p>

<ul>
<li><p><code>"median"</code> Separate lines for phase A and B medians.
</p>
</li>
<li><p><code>"mean"</code> Separate lines for phase A and B means. By default it is
10\
<code>lines = list(type = "mean", trim = 0.2)</code> draws a 20\
</p>
</li>
<li><p><code>"trend"</code> Separate lines for phase A and B trends.
</p>
</li>
<li><p><code>"trendA"</code> OLS trend line for phase A, extrapolated throughout phase B.
</p>
</li>
<li><p><code>"trendA_bisplit"</code> Split middle (bi-split) trend line for phase A, extrapolated throughout phase B.
</p>
</li>
<li><p><code>"trendA_trisplit"</code> Tukey tri-split trend line for phase A, extrapolated throughout phase B.
</p>
</li>
<li><p><code>"maxA/minA"</code> Line at the level of the highest or lowest phase A score.
</p>
</li>
<li><p><code>"medianA"</code> Line at the phase A median score.  </p>
</li>
<li><p><code>"meanA"</code>
Line at the phase A 10\
using the additional argument (e.g., <code>lines = list(type = "meanA", trim = 0.2)</code>).
</p>
</li>
<li><p><code>"plm"</code> Regression lines for piecewise linear regression model.
</p>
</li>
<li><p><code>"plm.ar"</code> Regression lines for piecewise autoregression model.
The lag is specified like this: <code>lines = list(type = "plm.ar", ar = 2)</code>. Default lag is set to 2.
</p>
</li>
<li><p><code>"movingMean"</code> Draws a moving mean curve, with a specified lag:
<code>lines = list(type = "movingMean", lag = 2)</code>. Default is a lag 1 curve.
</p>
</li>
<li><p><code>"movingMedian"</code> Draws a moving median curve, with a specified
lag: <code>lines = list(type = "movingMedian", lag = 3)</code>. Default is a lag 1 curve.
</p>
</li>
<li><p><code>"loreg"</code> Draws a non-parametric local regression line. The
proportion of data influencing each data point can be specified using
<code>lines = list(type = "loreg"m f = 0.66)</code>. The default is 0.5.  </p>
</li>
<li><p><code>"lty"</code>
Use this argument to define the line type. Examples are: <code>"solid"</code>,
<code>"dashed"</code>, <code>"dotted"</code>.  </p>
</li>
<li><p><code>"lwd"</code> Use this argument to
define the line's thickness, e.g., <code>lwd = 4</code>.  </p>
</li>
<li><p><code>"col"</code> Use
this argument to define the line's color, e.g., <code>col = "red"</code>.  </p>
</li></ul>
</td></tr>
<tr><td><code id="plot.scdf_+3A_marks">marks</code></td>
<td>
<p>A list of parameters defining markings of certain data points.
</p>
 <ul>
<li><p><code>"positions"</code> A vector or a list of vectors indicating
measurement-times to be highlighted. In case of a vector, the marked
measurement-times are the same for all plotted cases. In case of a list of
vectors, marks are set differently for each case. The list must have the
same length as there are cases in the data file.  </p>
</li>
<li><p><code>"col"</code> Color of
the marks.  </p>
</li>
<li><p><code>"cex"</code> Size of the marks.  </p>
</li></ul>
<p> Use for example
<code>marks = list(positions = c(1, 8, 15), col = "red", cex = 3)</code> to make
the MTs one, eight and 18 appear big and red.</p>
</td></tr>
<tr><td><code id="plot.scdf_+3A_phase.names">phase.names</code></td>
<td>
<p>By default phases are labeled based on the levels of the
phase variable.
Use this argument to specify different labels: <code>phase.names = c("Baseline",
"Intervention")</code>.</p>
</td></tr>
<tr><td><code id="plot.scdf_+3A_xlab">xlab</code></td>
<td>
<p>The label of the x-axis. Default is <code>xlab = "Measurement
time"</code>.</p>
</td></tr>
<tr><td><code id="plot.scdf_+3A_ylab">ylab</code></td>
<td>
<p>The labels of the y-axis. Default is <code>ylab = "Score"</code>.</p>
</td></tr>
<tr><td><code id="plot.scdf_+3A_main">main</code></td>
<td>
<p>Main title of the plot.</p>
</td></tr>
<tr><td><code id="plot.scdf_+3A_case.names">case.names</code></td>
<td>
<p>Case names. If not provided, names are taken from the scdf.
Set <code>case.names = ""</code> if you don't like to include case names.</p>
</td></tr>
<tr><td><code id="plot.scdf_+3A_style">style</code></td>
<td>
<p>Either a character with the name of a pre-implemented style or a
style object. See <code><a href="#topic+style_plot">style_plot</a></code> to learn about this format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a plot of one or multiple single-cases.
</p>


<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>


<h3>See Also</h3>

<p><code><a href="#topic+style_plot">style_plot</a></code>, <code><a href="#topic+describeSC">describeSC</a></code>,
<code><a href="#topic+overlapSC">overlapSC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Request the default plot of the data from Borckhardt (2014)
plot(Borckardt2014)

## Plot the three cases from Grosche (2011) and visualize the phase A trend
plot(Grosche2011, style = "grid", lines = "trendA")

## Request the local regression line for Georg from that data set and customize the plot
plot(Grosche2011$Georg, style = "sienna", ylim = c(0,NA),
       xlab = "Training session", ylab = "Words per minute",
       phase.names = c("Baseline", "Intervention"), xinc = 5,
       lines = list(type = "loreg", f = 0.2, lty = "solid", col = "black", lwd = 3))

## Plot a random MBD over three cases and mark interesting MTs
dat &lt;- random_scdf(design = design(3))
plot(dat, marks = list(positions = list(c(2,4,5),c(1,2,3),c(7,8,9)), col = "blue",
       cex = 1.4), style = c("grid", "annotate", "tiny"))

</code></pre>

<hr>
<h2 id='pnd'>Percentage of non-overlapping data</h2><span id='topic+pnd'></span>

<h3>Description</h3>

<p>This function returns the percentage of non-overlapping data.  Due to its
error-proneness the PND should not be used, but <code><a href="#topic+nap">nap</a></code> or
<code><a href="#topic+pand">pand</a></code> instead (see Parker &amp; Vannest, 2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnd(data, dvar, pvar, decreasing = FALSE, phases = c(1, 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pnd_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="pnd_+3A_dvar">dvar</code></td>
<td>
<p>Character string with the name of the dependent variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="pnd_+3A_pvar">pvar</code></td>
<td>
<p>Character string with the name of the phase variable. Defaults to
the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="pnd_+3A_decreasing">decreasing</code></td>
<td>
<p>If you expect data to be lower in the B phase, set
<code>decreasing = TRUE</code>. Default is <code>decreasing = FALSE</code>.</p>
</td></tr>
<tr><td><code id="pnd_+3A_phases">phases</code></td>
<td>
<p>A vector of two characters or numbers indicating the two phases
that should be compared. E.g., <code>phases = c("A","C")</code> or <code>phases = c(2,4)</code>
for comparing the second to the fourth phase. Phases could be combined by
providing a list with two elements. E.g., <code>phases = list(A = c(1,3), B = c(2,4))</code> will compare phases 1 and 3 (as A) against 2 and 4 (as B). Default
is <code>phases = c(1,2)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>PND</code></td>
<td>
<p>Percentage of non-overlapping data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>


<h3>See Also</h3>

<p>Other overlap functions: 
<code><a href="#topic+cdc">cdc</a>()</code>,
<code><a href="#topic+nap">nap</a>()</code>,
<code><a href="#topic+overlap">overlap</a>()</code>,
<code><a href="#topic+pand">pand</a>()</code>,
<code><a href="#topic+pem">pem</a>()</code>,
<code><a href="#topic+pet">pet</a>()</code>,
<code><a href="#topic+tau_u">tau_u</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Calculate the PND for multiple single-case data
pnd(GruenkeWilbert2014)

</code></pre>

<hr>
<h2 id='power_test'>Empirical power analysis for single-case data</h2><span id='topic+power_test'></span>

<h3>Description</h3>

<p>Conducts a Monte-Carlo study on the test-power and alpha-error probability of
a statistical function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_test(
  design,
  method = c("plm_level", "rand", "tauU"),
  effect = "level",
  n_sim = 100,
  design_is_one_study = TRUE,
  alpha_test = TRUE,
  power_test = TRUE,
  binom_test = FALSE,
  binom_test_alpha = FALSE,
  binom_test_power = FALSE,
  binom_test_correct = FALSE,
  ci = FALSE,
  alpha_level = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power_test_+3A_design">design</code></td>
<td>
<p>An object returned from the <code>design</code> function.</p>
</td></tr>
<tr><td><code id="power_test_+3A_method">method</code></td>
<td>
<p>A (named) list that defines the methods the power analysis is
based on. Each element can contain a function (that takes an scdf file and
returns a p value) or a character string (the name of predefined
functions). default <code>method = list("plm_level", "rand", "tauU")</code> computes a
power analysis based on <code><a href="#topic+tau_u">tau_u()</a></code>, <code><a href="#topic+rand_test">rand_test()</a></code> and <code><a href="#topic+plm">plm()</a></code> analyses.
(Further predefined functions are: &quot;plm_slope&quot;, &quot;plm_poisson_level&quot;,
&quot;plm_poisson_slope&quot;, &quot;hplm_level&quot;, &quot;hplm_slope&quot;, &quot;base_tau&quot;.</p>
</td></tr>
<tr><td><code id="power_test_+3A_effect">effect</code></td>
<td>
<p>Either &quot;level&quot; or &quot;slope&quot;. The respective effect of the
provided design is set to 0 when computing the alpha-error proportion.</p>
</td></tr>
<tr><td><code id="power_test_+3A_n_sim">n_sim</code></td>
<td>
<p>Number of sample studies created for the the Monte-Carlo study.
Default is <code>n = 100</code>. Ignored if design_is_one_study = FALSE.</p>
</td></tr>
<tr><td><code id="power_test_+3A_design_is_one_study">design_is_one_study</code></td>
<td>
<p>If TRUE, the design is assumed to define all cases
of one study that is repeatedly randomly created <code>n_sim</code> times. If false,
the design is assumed to contain all cases from which a random sample is
generated. This is useful for very specific complex simulation studies.</p>
</td></tr>
<tr><td><code id="power_test_+3A_alpha_test">alpha_test</code></td>
<td>
<p>Logical. If TRUE, alpha error is calculated.</p>
</td></tr>
<tr><td><code id="power_test_+3A_power_test">power_test</code></td>
<td>
<p>Logical. If TRUE, power is calculated.</p>
</td></tr>
<tr><td><code id="power_test_+3A_binom_test">binom_test</code></td>
<td>
<p>Shortcut. When set TRUE, binom_test_power is set to 0.80,
binom_test_alpha is set to 0.05, and binom_test_correct is set to 0.875.</p>
</td></tr>
<tr><td><code id="power_test_+3A_binom_test_alpha">binom_test_alpha</code></td>
<td>
<p>Either FALSE or a value. If a value is provided, a
binomial test is calculated testing if the alpha error proportion is less
than the provided value.</p>
</td></tr>
<tr><td><code id="power_test_+3A_binom_test_power">binom_test_power</code></td>
<td>
<p>Either FALSE or a value. If a value is provided, a
binomial test is calculated testing if the power is greater than the
provided value.</p>
</td></tr>
<tr><td><code id="power_test_+3A_binom_test_correct">binom_test_correct</code></td>
<td>
<p>Either FALSE or a value. If a value is provided, a
binomial test is calculated testing if the correct proportion is greater
than the provided value.</p>
</td></tr>
<tr><td><code id="power_test_+3A_ci">ci</code></td>
<td>
<p>Either FALSE or a value. If a value is provided, confidence
intervals at the provided level are calculated for power, alpha error, and
correct proportions.</p>
</td></tr>
<tr><td><code id="power_test_+3A_alpha_level">alpha_level</code></td>
<td>
<p>Alpha level used to calculate the proportion of
significant tests. Default is <code>alpha_level = 0.05</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on a <code><a href="#topic+design">design()</a></code> object, a large number of single-cases are generated
and re-analyzed with a provided statistical function. The proportion of
significant analyzes is the test power. In a second step, a specified effect
of the design object is set to 0 and again single-cases are generated and
reanalyzed. The proportion of significant analyzes is the alpha error
probability.
</p>


<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>


<h3>See Also</h3>

<p><code><a href="#topic+random_scdf">random_scdf()</a></code>, <code><a href="#topic+design">design()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Assume you want to conduct a single-case study with 15 measurements
## (phases: A = 6 and B = 9) using a highly reliable test and
## an expected level effect of d = 1.4.
## A (strong) trend effect is trend = 0.05. What is the power?
## (Note: n_sims is set to 10. Set n_sims to 1000 for a serious calculation.)
design &lt;- design(
  n = 1, phase_design = list(A = 6, B = 9),
  rtt = 0.8, level = 1.4, trend = 0.05
)
power_test(design, n_sim = 10)

## Would you achieve higher power by setting up a MBD with three cases?
design &lt;- design(
  n = 3, phase_design = list(A = 6, B = 9),
  rtt = 0.8, level = 1.4, trend = 0.05
)
power_test(design, n_sim=10, method=list("hplm_level", "rand", "tauU_meta"))
</code></pre>

<hr>
<h2 id='print.sc'>Print methods for scan objects</h2><span id='topic+print.sc'></span><span id='topic+print.sc_ac'></span><span id='topic+print.sc_bctau'></span><span id='topic+print.sc_cdc'></span><span id='topic+print.sc_desc'></span><span id='topic+print.sc_design'></span><span id='topic+print.sc_nap'></span><span id='topic+print.sc_outlier'></span><span id='topic+print.sc_overlap'></span><span id='topic+print.sc_pem'></span><span id='topic+print.sc_pet'></span><span id='topic+print.sc_plm'></span><span id='topic+print.sc_pnd'></span><span id='topic+print.sc_power'></span><span id='topic+print.sc_rand'></span><span id='topic+print.sc_rci'></span><span id='topic+print.sc_smd'></span><span id='topic+print.sc_trend'></span>

<h3>Description</h3>

<p>Print methods for scan objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sc_ac'
print(x, digits = "auto", ...)

## S3 method for class 'sc_bctau'
print(x, nice = TRUE, digits = "auto", ...)

## S3 method for class 'sc_cdc'
print(x, nice = TRUE, ...)

## S3 method for class 'sc_desc'
print(x, digits = "auto", ...)

## S3 method for class 'sc_design'
print(x, ...)

## S3 method for class 'sc_nap'
print(x, digits = "auto", nice = TRUE, ...)

## S3 method for class 'sc_outlier'
print(x, digits = "auto", ...)

## S3 method for class 'sc_overlap'
print(x, digits = "auto", ...)

## S3 method for class 'sc_pem'
print(x, ...)

## S3 method for class 'sc_pet'
print(x, ...)

## S3 method for class 'sc_plm'
print(x, lag_max = 3, ...)

## S3 method for class 'sc_pnd'
print(x, ...)

## S3 method for class 'sc_power'
print(x, duration = FALSE, digits = 1, ...)

## S3 method for class 'sc_rand'
print(x, ...)

## S3 method for class 'sc_rci'
print(x, ...)

## S3 method for class 'sc_smd'
print(x, digits = "auto", ...)

## S3 method for class 'sc_trend'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.sc_+3A_x">x</code></td>
<td>
<p>Object</p>
</td></tr>
<tr><td><code id="print.sc_+3A_digits">digits</code></td>
<td>
<p>The minimum number of significant digits to be use.
If set to &quot;auto&quot; (default), values are predefined.</p>
</td></tr>
<tr><td><code id="print.sc_+3A_...">...</code></td>
<td>
<p>Further parameters passed to the print function</p>
</td></tr>
<tr><td><code id="print.sc_+3A_nice">nice</code></td>
<td>
<p>If set TRUE (default) output values are rounded and optimized for
publication tables.</p>
</td></tr>
<tr><td><code id="print.sc_+3A_lag_max">lag_max</code></td>
<td>
<p>Maximum lag to be reported for autocorrelation of residuals.
Default is <code>3</code>. Set <code>FALSE</code> for no report of autocorrelations.</p>
</td></tr>
<tr><td><code id="print.sc_+3A_duration">duration</code></td>
<td>
<p>If TRUE the duration for computation is printed.</p>
</td></tr>
</table>

<hr>
<h2 id='print.scdf'>Print an scdf</h2><span id='topic+print.scdf'></span>

<h3>Description</h3>

<p>Print an scdf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scdf'
print(
  x,
  cases = getOption("scan.print.cases"),
  rows = getOption("scan.print.rows"),
  cols = getOption("scan.print.cols"),
  long = getOption("scan.print.long"),
  digits = getOption("scan.print.digits"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.scdf_+3A_x">x</code></td>
<td>
<p>An scdf object</p>
</td></tr>
<tr><td><code id="print.scdf_+3A_cases">cases</code></td>
<td>
<p>Number of cases to be printed. &quot;fit&quot; fits the number to the current screen width.</p>
</td></tr>
<tr><td><code id="print.scdf_+3A_rows">rows</code></td>
<td>
<p>Number of rows to be printed.</p>
</td></tr>
<tr><td><code id="print.scdf_+3A_cols">cols</code></td>
<td>
<p>Columns to be printed. &quot;Main&quot; only prints the dependent, measurement-time and phase variable.</p>
</td></tr>
<tr><td><code id="print.scdf_+3A_long">long</code></td>
<td>
<p>Logical. If TRUE cases are printed in one by a time.</p>
</td></tr>
<tr><td><code id="print.scdf_+3A_digits">digits</code></td>
<td>
<p>Number of digits.</p>
</td></tr>
<tr><td><code id="print.scdf_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the print function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Print options for scdf objects could be set globally:
option(scan.print.cases = &quot;all&quot;),
option(scan.print.rows = 10),
option(scan.print.cols = &quot;main&quot;),
option(scan.print.long = TRUE),
option(scan.print.digits = 0),
option(scan.print.scdf.name = FALSE)
</p>

<hr>
<h2 id='rand_test'>Randomization Tests for single-case data</h2><span id='topic+rand_test'></span>

<h3>Description</h3>

<p>The <code>rand_test</code> function computes a randomization test for single or multiple
baseline single-case data.  The function is based on an algorithm from the
<code>SCRT</code> package (Bulte &amp; Onghena, 2009, 2012), but rewritten and extended
for the use in AB designs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rand_test(
  data,
  dvar,
  pvar,
  statistic = c("Mean B-A", "Mean A-B", "Median B-A", "Median A-B", "Mean |A-B|",
    "Median |A-B|"),
  number = 500,
  complete = FALSE,
  limit = 5,
  startpoints = NA,
  exclude.equal = FALSE,
  phases = c(1, 2),
  graph = FALSE,
  output = NULL,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rand_test_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="rand_test_+3A_dvar">dvar</code></td>
<td>
<p>Character string with the name of the dependent variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="rand_test_+3A_pvar">pvar</code></td>
<td>
<p>Character string with the name of the phase variable. Defaults to
the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="rand_test_+3A_statistic">statistic</code></td>
<td>
<p>Defines the statistic on which the comparison of phases A
and B is based on. Default setting is <code>statistic = "Mean B-A"</code>. The
following comparisons are possible: </p>
 <ul>
<li><p><code>"Mean A-B"</code>: Uses
the difference between the mean of phase A and the mean of phase B. This is
appropriate if a decrease of scores was expected for phase B.
</p>
</li>
<li><p><code>"Mean B-A"</code>: Uses the difference between the mean of phase B and
the mean of phase A. This is appropriate if an increase of scores was
expected for phase B.  </p>
</li>
<li><p><code>"Mean |A-B|"</code>: Uses the absolute value of
the difference between the means of phases A and B.  </p>
</li>
<li><p><code>"Median
A-B"</code>: The same as <code>"Mean A-B"</code>, but based on the median.
</p>
</li>
<li><p><code>"Median B-A"</code>: The same as <code>"Mean B-A"</code>, but based on the
median.  </p>
</li></ul>
</td></tr>
<tr><td><code id="rand_test_+3A_number">number</code></td>
<td>
<p>Sample size of the randomization distribution. The exactness of
the p-value can not exceed <code class="reqn">1/number</code> (i.e., <code>number = 100</code> results in
p-values with an exactness of one percent). Default is <code>number = 500</code>. For
faster processing use <code>number = 100</code>. For more precise p-values set <code>number = 1000</code>).</p>
</td></tr>
<tr><td><code id="rand_test_+3A_complete">complete</code></td>
<td>
<p>If TRUE, the distribution is based on a complete permutation
of all possible starting combinations. This setting overwrites the number
Argument. The default setting is FALSE.</p>
</td></tr>
<tr><td><code id="rand_test_+3A_limit">limit</code></td>
<td>
<p>Minimal number of data points per phase in the sample. The first
number refers to the A-phase and the second to the B-phase (e.g., <code>limit = c(5,3)</code>). If only one number is given, this number is applied to both
phases. Default is <code>limit = 5</code>.</p>
</td></tr>
<tr><td><code id="rand_test_+3A_startpoints">startpoints</code></td>
<td>
<p>Alternative to the <code>limit</code>-parameter <code>startpoints</code> exactly
defines the possible start points of phase B (e.g., <code>startpoints = 4:9</code>
restricts the phase B start points to measurements 4 to 9. <code>startpoints</code>
overruns the <code>limit</code>-parameter.</p>
</td></tr>
<tr><td><code id="rand_test_+3A_exclude.equal">exclude.equal</code></td>
<td>
<p>If set to <code>exclude.equal = FALSE</code>, which is the
default, random distribution values equal to the observed distribution are
counted as null-hypothesis conform. That is, they decrease the probability
of rejecting the null-hypothesis (increase the p-value).
<code>exclude.equal</code> should be set to <code>TRUE</code> if you analyse one single-case
design (not a multiple baseline data set) to reach a sufficient power. But
be aware, that it increases the chance of an alpha-error.</p>
</td></tr>
<tr><td><code id="rand_test_+3A_phases">phases</code></td>
<td>
<p>A vector of two characters or numbers indicating the two phases
that should be compared. E.g., <code>phases = c("A","C")</code> or <code>phases = c(2,4)</code>
for comparing the second to the fourth phase. Phases could be combined by
providing a list with two elements. E.g., <code>phases = list(A = c(1,3), B = c(2,4))</code> will compare phases 1 and 3 (as A) against 2 and 4 (as B). Default
is <code>phases = c(1,2)</code>.</p>
</td></tr>
<tr><td><code id="rand_test_+3A_graph">graph</code></td>
<td>
<p>If <code>graph = TRUE</code>, a histogram of the resulting distribution is
plotted. It is <code>FALSE</code> by default. <em>Note: use the more versatile
<code><a href="#topic+plot_rand">plot_rand()</a></code> function instead.</em></p>
</td></tr>
<tr><td><code id="rand_test_+3A_output">output</code></td>
<td>
<p>(deprecated and not implemented)</p>
</td></tr>
<tr><td><code id="rand_test_+3A_seed">seed</code></td>
<td>
<p>A seed number for the random generator.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>statistic</code></td>
<td>
<p>Character string from function call (see
<code>Arguments</code> above).</p>
</td></tr> <tr><td><code>N</code></td>
<td>
<p>Number of single-cases.</p>
</td></tr>
<tr><td><code>n1</code></td>
<td>
<p>Number of data points in phase A.</p>
</td></tr> <tr><td><code>n2</code></td>
<td>
<p>Number of data
points in phase B.</p>
</td></tr> <tr><td><code>limit</code></td>
<td>
<p>Numeric from function call (see
<code>Arguments</code> above).</p>
</td></tr>
<tr><td><code>startpoints</code></td>
<td>
<p>A vector defining the start points passed from the
function call (see <code>Arguments</code> above).</p>
</td></tr> <tr><td><code>p.value</code></td>
<td>
<p>P-value of the
randomization test for the given data.</p>
</td></tr> <tr><td><code>number</code></td>
<td>
<p>Sample size of
randomization distribution from function call (see <code>Arguments</code> above).</p>
</td></tr>
<tr><td><code>complete</code></td>
<td>
<p>Logical argument from function call (see <code>Arguments</code>
above).</p>
</td></tr> <tr><td><code>observed.statistic</code></td>
<td>
<p>Test statistic observed for the given
single-case data. (see <code>statistic</code> in the <code>Arguments</code> above.)</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>Z-value of observed test statistic.</p>
</td></tr> <tr><td><code>p.z.single</code></td>
<td>
<p>Probability
of z-value.</p>
</td></tr> <tr><td><code>distribution</code></td>
<td>
<p>Test statistic distribution from randomized
data sets.</p>
</td></tr> <tr><td><code>possible.combinations</code></td>
<td>
<p>Number of possible combinations
under the given restrictions.</p>
</td></tr> <tr><td><code>auto.corrected.number</code></td>
<td>
<p><code>TRUE</code>
indicates that a corrected number of combinations was used. This happens, if
the number of possible combinations (under the given restrictions) undercuts
the requested <code>number</code> of combinations.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>


<h3>References</h3>

<p>Bulte, I., &amp; Onghena, P. (2009). Randomization tests for
multiple-baseline designs: An extension of the SCRT-R package.
<em>Behavior Research Methods, 41</em>, 477-485.
</p>
<p>Bulte, I., &amp; Onghena, P. (2012). <em>SCRT: Single-Case Randomization Tests</em>.
Available from: <a href="https://CRAN.R-project.org/package=SCRT">https://CRAN.R-project.org/package=SCRT</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Compute a randomization test on the first case of the byHeart2011 data and include a graph
rand_test(byHeart2011[1], statistic = "Median B-A", graph = TRUE, seed = 123)

## Compute a randomization test on the Grosche2011 data using complete permutation
rand_test(Grosche2011, statistic = "Median B-A", complete = TRUE, limit = 4, seed = 123)

</code></pre>

<hr>
<h2 id='random_scdf'>Single-case data generator</h2><span id='topic+random_scdf'></span>

<h3>Description</h3>

<p>The <code>random_scdf</code> function generates random single-case data frames for
monte-carlo studies and demonstration purposes. <code>design</code> is used to set
up a design matrix with all parameters needed for the <code>random_scdf</code>
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_scdf(design = NULL, round = NA, random_names = FALSE, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_scdf_+3A_design">design</code></td>
<td>
<p>A design matrix which is created by <code>design</code> and specifies
all parameters.</p>
</td></tr>
<tr><td><code id="random_scdf_+3A_round">round</code></td>
<td>
<p>Rounds the scores to the defined decimal. To round to the second
decimal, set <code>round = 2</code>.</p>
</td></tr>
<tr><td><code id="random_scdf_+3A_random_names">random_names</code></td>
<td>
<p>Is <code>FALSE</code> by default. If set <code>random_names =
  TRUE</code> cases are assigned random first names. If set <code>"neutral", "male"
  or "female"</code> only gender neutral, male, or female names are chosen. The
names are drawn from the 2,000 most popular names for newborns in 2012 in
the U.S. (1,000 male and 1,000 female names).</p>
</td></tr>
<tr><td><code id="random_scdf_+3A_seed">seed</code></td>
<td>
<p>A seed number for the random generator.</p>
</td></tr>
<tr><td><code id="random_scdf_+3A_...">...</code></td>
<td>
<p>arguments that are directly passed to the <code>design</code> function
for a more concise coding.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single-case data frame. See <code><a href="#topic+scdf">scdf</a></code> to learn about this
format.
</p>


<h3>Author(s)</h3>

<p>Juergen Wibert
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Create random single-case data and inspect it
design &lt;- design(
  n = 3, rtt = 0.75, slope = 0.1, extreme_prop = 0.1,
  missing_prop = 0.1
)
dat &lt;- random_scdf(design, round = 1, random_names = TRUE, seed = 123)
describe(dat)

## And now have a look at poisson-distributed data
design &lt;- design(
  n = 3, B_start = c(6, 10, 14), mt = c(12, 20, 22), start_value = 10,
  distribution = "poisson", level = -5, missing_prop = 0.1
)
dat &lt;- random_scdf(design, seed = 1234)
pand(dat, decreasing = TRUE)
</code></pre>

<hr>
<h2 id='ranks'>Rank-transformation of single-case data files</h2><span id='topic+ranks'></span>

<h3>Description</h3>

<p><em>This function is superseded by the more versatile
<code><a href="#topic+transform.scdf">transform.scdf</a></code> function.</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ranks(data, var, grand = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranks_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="ranks_+3A_var">var</code></td>
<td>
<p>A string or string vector with the names of the variables to be
ranked.</p>
</td></tr>
<tr><td><code id="ranks_+3A_grand">grand</code></td>
<td>
<p>If TRUE, ranks will be calculated across all cases. If FALSE
ranks are calculated within each case.</p>
</td></tr>
<tr><td><code id="ranks_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the <code><a href="base.html#topic+rank">rank</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>scdf</code> object where the values of the variable(s) are
replaced with ranks.
</p>


<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>


<h3>See Also</h3>

<p>Other data manipulation functions: 
<code><a href="#topic+add_l2">add_l2</a>()</code>,
<code><a href="#topic+as.data.frame.scdf">as.data.frame.scdf</a>()</code>,
<code><a href="#topic+as_scdf">as_scdf</a>()</code>,
<code><a href="#topic+fill_missing">fill_missing</a>()</code>,
<code><a href="#topic+moving_median">moving_median</a>()</code>,
<code><a href="#topic+outlier">outlier</a>()</code>,
<code><a href="#topic+scdf">scdf</a>()</code>,
<code><a href="#topic+select_cases">select_cases</a>()</code>,
<code><a href="#topic+set_vars">set_vars</a>()</code>,
<code><a href="#topic+shift">shift</a>()</code>,
<code><a href="#topic+smooth_cases">smooth_cases</a>()</code>,
<code><a href="#topic+standardize">standardize</a>()</code>,
<code><a href="#topic+truncate_phase">truncate_phase</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ranks(Huber2014, var = "compliance")
</code></pre>

<hr>
<h2 id='rci'>Reliable change index</h2><span id='topic+rci'></span>

<h3>Description</h3>

<p>The <code>rci()</code> function computes three indices of reliable change (Wise, 2004)
and corresponding descriptive statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rci(data, dvar, pvar, rel, ci = 0.95, graph = FALSE, phases = c(1, 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rci_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="rci_+3A_dvar">dvar</code></td>
<td>
<p>Character string with the name of the dependent variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="rci_+3A_pvar">pvar</code></td>
<td>
<p>Character string with the name of the phase variable. Defaults to
the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="rci_+3A_rel">rel</code></td>
<td>
<p>Reliability of the measure, used to compute the standard error.</p>
</td></tr>
<tr><td><code id="rci_+3A_ci">ci</code></td>
<td>
<p>Width of confidence interval as a decimal. Default is <code>ci = 0.95</code>
applying a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="rci_+3A_graph">graph</code></td>
<td>
<p>If set <code>TRUE</code>, a box plot of phase A and B scores is displayed.
<code>graph = FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="rci_+3A_phases">phases</code></td>
<td>
<p>A vector of two characters or numbers indicating the two phases
that should be compared. E.g., <code>phases = c("A","C")</code> or <code>phases = c(2,4)</code>
for comparing the second to the fourth phase. Phases could be combined by
providing a list with two elements. E.g., <code>phases = list(A = c(1,3), B = c(2,4))</code> will compare phases 1 and 3 (as A) against 2 and 4 (as B). Default
is <code>phases = c(1,2)</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>


<h3>References</h3>

<p>Christensen, L., &amp; Mendoza, J. L. (1986). A method of assessing
change in a single subject: An alteration of the RC index. <em>Behavior
Therapy, 17</em>, 305-308.
</p>
<p>Hageman, W. J. J., &amp; Arrindell, W. A. (1993). A further refinement of the
reliable change (RC) index by improving the pre-post difference score:
Introducing RCID. <em>Behaviour Research and Therapy, 31</em>, 693-700.
</p>
<p>Jacobson, N. S., &amp; Truax, P. (1991). Clinical Significance: A statistical
approach to defining meaningful change in psychotherapy research.
<em>Journal of Consulting and Clinical Psychology, 59</em>, 12-19.
</p>
<p>Wise, E. A. (2004). Methods for analyzing psychotherapy outcomes: A review
of clinical significance, reliable change, and recommendations for future
directions. <em>Journal of Personality Assessment, 82</em>, 50 - 59.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Report the RCIs of the first case from the byHeart data and include a graph
rci(byHeart2011[1], graph = TRUE, rel = 0.8)

</code></pre>

<hr>
<h2 id='read_scdf'>Load single-case data from files</h2><span id='topic+read_scdf'></span>

<h3>Description</h3>

<p>Use the <code>read_scdf</code> function to load single-case data csv, excel, or yaml
files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_scdf(
  file,
  cvar = "case",
  pvar = "phase",
  dvar = "values",
  mvar = "mt",
  sort_cases = FALSE,
  phase_names = NULL,
  type = NA,
  na = c("", "NA"),
  sort.labels = NULL,
  phase.names = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_scdf_+3A_file">file</code></td>
<td>
<p>Either a character string defining the file to be loaded (e.g.
<code>"SC_Anita.csv"</code> (if left empty a dialog box for choosing will be opened)
or a data.frame.</p>
</td></tr>
<tr><td><code id="read_scdf_+3A_cvar">cvar</code></td>
<td>
<p>Sets the variable name of the &quot;case&quot; variable. Defaults to
<code>"case"</code>.</p>
</td></tr>
<tr><td><code id="read_scdf_+3A_pvar">pvar</code></td>
<td>
<p>Sets the variable name of the &quot;phase&quot; variable. Defaults to <code>"phase"</code>.</p>
</td></tr>
<tr><td><code id="read_scdf_+3A_dvar">dvar</code></td>
<td>
<p>Sets the variable name of the &quot;values&quot; variable. Defaults to <code>"values"</code>.</p>
</td></tr>
<tr><td><code id="read_scdf_+3A_mvar">mvar</code></td>
<td>
<p>Sets the variable name of the &quot;mt&quot; variable. Defaults to <code>"mt"</code>.</p>
</td></tr>
<tr><td><code id="read_scdf_+3A_sort_cases">sort_cases</code>, <code id="read_scdf_+3A_sort.labels">sort.labels</code></td>
<td>
<p>If set TRUE, the resulting list is sorted by
label names (alphabetically increasing).</p>
</td></tr>
<tr><td><code id="read_scdf_+3A_phase_names">phase_names</code>, <code id="read_scdf_+3A_phase.names">phase.names</code></td>
<td>
<p>A character vector with phase names. Defaults
to the phase names provided in the phase variable.</p>
</td></tr>
<tr><td><code id="read_scdf_+3A_type">type</code></td>
<td>
<p>Format of the file to be loaded. Either &quot;csv&quot;, &quot;xlsx&quot;, &quot;xls&quot;,
&quot;excel&quot;, &quot;yml&quot; is possible. By default (NA) the type is extracted from the
file extension.</p>
</td></tr>
<tr><td><code id="read_scdf_+3A_na">na</code></td>
<td>
<p>Character vector of strings to interpret as missing values.</p>
</td></tr>
<tr><td><code id="read_scdf_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the respective read function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a single-case data frame. See <code><a href="#topic+scdf">scdf</a></code> to learn
about the format of these data frames.
</p>


<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.table()</a></code>, <code><a href="base.html#topic+readRDS">readRDS()</a></code>
</p>
<p>Other io-functions: 
<code><a href="#topic+convert">convert</a>()</code>,
<code><a href="#topic+write_scdf">write_scdf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Read SC-data from a file named "study1.csv" in your working directory
# study1 &lt;- read_scdf("study1.csv")

## Read SC-data from a .csv-file with semicolon as field and comma as decimal separator
# study2 &lt;- read_scdf("study2.csv", sep = ";", dec = ",")

## write_scdf and read_scdf
filename &lt;- file.path(tempdir(), "test.csv")
write_scdf(exampleA1B1A2B2_zvt, filename)
dat &lt;- read_scdf(filename, cvar = "case", pvar = "part", dvar = "zvt", mvar = "day")
res1 &lt;- describe(exampleA1B1A2B2_zvt)$descriptives
res2 &lt;- describe(dat)$descriptives
all.equal(res1,res2)

</code></pre>

<hr>
<h2 id='sample_names'>Samples random names</h2><span id='topic+sample_names'></span>

<h3>Description</h3>

<p>Samples random names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_names(n = 1, type = "neutral", seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_names_+3A_n">n</code></td>
<td>
<p>Number of names</p>
</td></tr>
<tr><td><code id="sample_names_+3A_type">type</code></td>
<td>
<p>&quot;neutral&quot;, &quot;male&quot;, &quot;female&quot;, or &quot;mixed&quot;</p>
</td></tr>
<tr><td><code id="sample_names_+3A_seed">seed</code></td>
<td>
<p>A seed for the random number generator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with random names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sample_names(3)
</code></pre>

<hr>
<h2 id='scan-package'>Single-Case Data Analyses</h2><span id='topic+scan-package'></span><span id='topic+scan'></span>

<h3>Description</h3>

<p>A collection of procedures for analysing, visualising, and managing
single-case data.
</p>


<h3>Author(s)</h3>

<p>Juergen Wilbert [aut, cre]
</p>

<hr>
<h2 id='scdf'>Single case data frame</h2><span id='topic+scdf'></span><span id='topic+scdf-class'></span><span id='topic+as.scdf'></span>

<h3>Description</h3>

<p><code>scdf()</code> is the constructor for the <code>scdf</code> class. It stores single-case study
data with one or more single-cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scdf(
  values,
  B_start,
  mt,
  phase,
  phase_design = NULL,
  name = NULL,
  dvar = "values",
  pvar = "phase",
  mvar = "mt",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scdf_+3A_values">values</code></td>
<td>
<p>A vector containing measurement values of the dependent
variable.</p>
</td></tr>
<tr><td><code id="scdf_+3A_b_start">B_start</code></td>
<td>
<p>The first measurement of phase B (simple coding if
design is strictly AB).</p>
</td></tr>
<tr><td><code id="scdf_+3A_mt">mt</code></td>
<td>
<p>A vector defining measurement times. Default is <code style="white-space: pre;">&#8288;mt = (1,2,3,...,n)&#8288;</code>.</p>
</td></tr>
<tr><td><code id="scdf_+3A_phase">phase</code></td>
<td>
<p>A vector defining phase assignments.</p>
</td></tr>
<tr><td><code id="scdf_+3A_phase_design">phase_design</code></td>
<td>
<p>A vector defining the length and label of
each phase. E.g., <code>phase_design = c(A1 = 10, B1 = 10, A2 = 10, B2 = 10)</code>.</p>
</td></tr>
<tr><td><code id="scdf_+3A_name">name</code></td>
<td>
<p>A name for the case.</p>
</td></tr>
<tr><td><code id="scdf_+3A_dvar">dvar</code></td>
<td>
<p>Character string with the name of the dependent variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="scdf_+3A_pvar">pvar</code></td>
<td>
<p>Character string with the name of the phase variable. Defaults to
the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="scdf_+3A_mvar">mvar</code></td>
<td>
<p>Character string with the name of the measurement time variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="scdf_+3A_...">...</code></td>
<td>
<p>Additional variables. E.g., <code style="white-space: pre;">&#8288;teacher = c(0,1,0,1,0,0,1), lesson = c(1,3,4,5,2,3)&#8288;</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the dependent variable is a named vector then the names are
extracted to create a phase design (e.g., <code>values = c(A = 2,3,5,4,3, B = 6,5,4,3)</code> will create an AB phase design with five and four measurements).
An scdf contains several attributes: <code>dvar</code> The name of the dependent
variable. <code>phase</code> The name of the phase variable. <code>mt</code> The name
of the measurement time variable. <code>author</code> Information on the author
of the data. <code>info</code> Further information on the data. E.g., a
publication. <code style="white-space: pre;">&#8288;dvar, phase&#8288;</code>, and <code>mt</code> are the defaults most of the
<code>scan</code> function use. You can change the values of the attributes with
the <code>scdf_attr</code> function (e.g., <code>scdf_attr(exampleAB_add, "dvar") &lt;- "depression"</code> defines depression as the dependent variable. Please
notice that all <code>scan</code> functions have arguments to define <code>dvar</code>,
<code>phase</code>, and <code>mt</code> for a given analysis.
</p>


<h3>Value</h3>

<p>Returns a single-case data frame <code>scdf</code> suitable for all
functions of the <code>scan</code> package. Multiple data sets (e.g. from
Multiple Baseline Designs) can be listed.
</p>


<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>


<h3>See Also</h3>

<p>Other data manipulation functions: 
<code><a href="#topic+add_l2">add_l2</a>()</code>,
<code><a href="#topic+as.data.frame.scdf">as.data.frame.scdf</a>()</code>,
<code><a href="#topic+as_scdf">as_scdf</a>()</code>,
<code><a href="#topic+fill_missing">fill_missing</a>()</code>,
<code><a href="#topic+moving_median">moving_median</a>()</code>,
<code><a href="#topic+outlier">outlier</a>()</code>,
<code><a href="#topic+ranks">ranks</a>()</code>,
<code><a href="#topic+select_cases">select_cases</a>()</code>,
<code><a href="#topic+set_vars">set_vars</a>()</code>,
<code><a href="#topic+shift">shift</a>()</code>,
<code><a href="#topic+smooth_cases">smooth_cases</a>()</code>,
<code><a href="#topic+standardize">standardize</a>()</code>,
<code><a href="#topic+truncate_phase">truncate_phase</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Scores on a letter naming task were collected on eleven days in a row.
## The intervention started after the fifth measurement,
## so the first B phase measurement was 6 (B_start = 6).
klaas &lt;- scdf(
  c(5, 7, 8, 5, 7, 12, 16, 18, 15, 14, 19),
  B_start = 6, name = "Klaas"
)
describe(klaas)

# Alternative coding 1:
klaas &lt;- scdf(
  c(A = 5, 7, 8, 5, 7, B = 12, 16, 18, 15, 14, 19),
  name = "Klaas"
)

# Alternative coding 2:
klaas &lt;- scdf(
  c(5, 7, 8, 5, 7, 12, 16, 18, 15, 14, 19),
  phase_design = c(A = 5, B = 6), name = "Klaas"
)

## Unfortunately in a similar study there were no data collected on
## days 3 and 9. Use NA to pass them to the function:
emmi &lt;- scdf(c(5, 7, NA, 5, 7, 12, 16, 18, NA, 14, 19),
  phase_design = c(A = 5, B = 6), name = "Emmi"
)
describe(emmi)

## In a MBD over three cases, data were collected eleven days in a row.
## Intervention starting points differ between subjects as they were
## randomly assigned. The three SCDFs are then combined in a list for
## further conjoined analyses.
charlotte &lt;- scdf(c(A = 5, 7, 10, 5, 12, B = 7, 10, 18, 15, 14, 19))
theresa &lt;- scdf(c(A = 3, 4, 3, 5, B = 7, 4, 7, 9, 8, 10, 12))
antonia &lt;- scdf(c(A = 9, 8, 8, 7, 5, 7, B = 6, 14, 15, 12, 16))
mbd &lt;- c(charlotte, theresa, antonia)
names(mbd) &lt;- c("Charlotte", "Theresa", "Antonia")
overlap(mbd)

## In a classroom-based intervention it was not possible to measure outcomes
## every day, but only on schooldays. The sequence of measurements is passed
## to the package by using a vector of measurement times.
frida &lt;- scdf(
  c(A = 3, 2, 4, 2, 2, 3, 5, 6, B = 8, 10, 8, 12, 14, 13, 12),
  mt = c(1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 14, 15, 16, 17, 18)
)
summary(frida)
describe(frida)

## example with two independent variables and four phases
jim &lt;- scdf(
  zvt = c(47, 58, 76, 63, 71, 59, 64, 69, 72, 77, 76, 73),
  d2 = c(131, 134, 141, 141, 140, 140, 138, 140, 141, 140, 138, 140),
  phase_design = c(A1 = 3, B1 = 3, A2 = 3, B2 = 3), dvar = "zvt"
)
overlap(jim, phases = list(c("A1", "A2"), c("B1", "B2")))
</code></pre>

<hr>
<h2 id='scdf_attr'>Set and get scdf attributes</h2><span id='topic+scdf_attr'></span><span id='topic+scdf_attr+3C-'></span><span id='topic+dv'></span><span id='topic+mt'></span><span id='topic+phase'></span>

<h3>Description</h3>

<p>Set and get scdf attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scdf_attr(x, var = NULL)

scdf_attr(x, var) &lt;- value

dv(scdf)

mt(scdf)

phase(scdf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scdf_attr_+3A_x">x</code></td>
<td>
<p>Variable</p>
</td></tr>
<tr><td><code id="scdf_attr_+3A_var">var</code></td>
<td>
<p>Attribute</p>
</td></tr>
<tr><td><code id="scdf_attr_+3A_value">value</code></td>
<td>
<p>set value</p>
</td></tr>
<tr><td><code id="scdf_attr_+3A_scdf">scdf</code></td>
<td>
<p>An <a href="#topic+scdf">scdf</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Attribute value
</p>

<hr>
<h2 id='select_cases'>Select a subset of cases</h2><span id='topic+select_cases'></span>

<h3>Description</h3>

<p>Select a subset of cases
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_cases(scdf, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_cases_+3A_scdf">scdf</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="select_cases_+3A_...">...</code></td>
<td>
<p>Selection criteria. Either numeric, objectnames, or as characters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An scdf with a subset of cases
</p>


<h3>See Also</h3>

<p>Other data manipulation functions: 
<code><a href="#topic+add_l2">add_l2</a>()</code>,
<code><a href="#topic+as.data.frame.scdf">as.data.frame.scdf</a>()</code>,
<code><a href="#topic+as_scdf">as_scdf</a>()</code>,
<code><a href="#topic+fill_missing">fill_missing</a>()</code>,
<code><a href="#topic+moving_median">moving_median</a>()</code>,
<code><a href="#topic+outlier">outlier</a>()</code>,
<code><a href="#topic+ranks">ranks</a>()</code>,
<code><a href="#topic+scdf">scdf</a>()</code>,
<code><a href="#topic+set_vars">set_vars</a>()</code>,
<code><a href="#topic+shift">shift</a>()</code>,
<code><a href="#topic+smooth_cases">smooth_cases</a>()</code>,
<code><a href="#topic+standardize">standardize</a>()</code>,
<code><a href="#topic+truncate_phase">truncate_phase</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>select_cases(exampleAB, Johanna, Karolina)
select_cases(exampleAB, c(Johanna, Karolina))
select_cases(exampleAB, 1,2)
select_cases(exampleAB, 1:2)
select_cases(exampleAB, -Johanna)
select_cases(exampleAB, -c(Johanna, Karolina))
v &lt;- c("Moritz", "Jannis")
select_cases(exampleA1B1A2B2, v)
</code></pre>

<hr>
<h2 id='select_phases'>Select and combine phases for overlap analyses</h2><span id='topic+select_phases'></span>

<h3>Description</h3>

<p>Useful when working with %&gt;% operators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_phases(data, A, B, phase_names = "auto")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_phases_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="select_phases_+3A_a">A</code></td>
<td>
<p>Selection of the A phase</p>
</td></tr>
<tr><td><code id="select_phases_+3A_b">B</code></td>
<td>
<p>Selection of the B phase</p>
</td></tr>
<tr><td><code id="select_phases_+3A_phase_names">phase_names</code></td>
<td>
<p>A character vector with names for the resulting phases.
The default <code>"auto"</code> generates phase names from the combination of the names
of the recombined phases.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An scdf with selected phases
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exampleA1B1A2B2_zvt %&gt;%
  select_phases(A = c(1, 3), B = c(2, 4)) %&gt;%
  overlap()
</code></pre>

<hr>
<h2 id='set_vars'>Set analysis variables in an scdf</h2><span id='topic+set_vars'></span><span id='topic+set_dvar'></span><span id='topic+set_mvar'></span><span id='topic+set_pvar'></span>

<h3>Description</h3>

<p>Set analysis variables in an scdf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_vars(data, dvar, mvar, pvar)

set_dvar(data, dvar)

set_mvar(data, mvar)

set_pvar(data, pvar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_vars_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="set_vars_+3A_dvar">dvar</code></td>
<td>
<p>Character string. Name of the dependent variable.</p>
</td></tr>
<tr><td><code id="set_vars_+3A_mvar">mvar</code></td>
<td>
<p>Character string. Name of the measurement-time variable.</p>
</td></tr>
<tr><td><code id="set_vars_+3A_pvar">pvar</code></td>
<td>
<p>Character string. Name of the phase variable.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other data manipulation functions: 
<code><a href="#topic+add_l2">add_l2</a>()</code>,
<code><a href="#topic+as.data.frame.scdf">as.data.frame.scdf</a>()</code>,
<code><a href="#topic+as_scdf">as_scdf</a>()</code>,
<code><a href="#topic+fill_missing">fill_missing</a>()</code>,
<code><a href="#topic+moving_median">moving_median</a>()</code>,
<code><a href="#topic+outlier">outlier</a>()</code>,
<code><a href="#topic+ranks">ranks</a>()</code>,
<code><a href="#topic+scdf">scdf</a>()</code>,
<code><a href="#topic+select_cases">select_cases</a>()</code>,
<code><a href="#topic+shift">shift</a>()</code>,
<code><a href="#topic+smooth_cases">smooth_cases</a>()</code>,
<code><a href="#topic+standardize">standardize</a>()</code>,
<code><a href="#topic+truncate_phase">truncate_phase</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exampleAB_add %&gt;% 
  set_dvar("depression") %&gt;%
  describe()
</code></pre>

<hr>
<h2 id='shift'>Shift values in a single-case data file</h2><span id='topic+shift'></span>

<h3>Description</h3>

<p><em>This function has been superseded by the much more versatile
<code><a href="#topic+transform.scdf">transform.scdf</a></code> function.</em>
Shifting the values might be helpful in cases where the measurement time
is given as a time variable (see example below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift(data, value, var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="shift_+3A_value">value</code></td>
<td>
<p>Number by which to shift the values</p>
</td></tr>
<tr><td><code id="shift_+3A_var">var</code></td>
<td>
<p>Character string with the name of the target variable.
Defaults to the measurement time variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scdf with shifted data
</p>


<h3>See Also</h3>

<p>Other data manipulation functions: 
<code><a href="#topic+add_l2">add_l2</a>()</code>,
<code><a href="#topic+as.data.frame.scdf">as.data.frame.scdf</a>()</code>,
<code><a href="#topic+as_scdf">as_scdf</a>()</code>,
<code><a href="#topic+fill_missing">fill_missing</a>()</code>,
<code><a href="#topic+moving_median">moving_median</a>()</code>,
<code><a href="#topic+outlier">outlier</a>()</code>,
<code><a href="#topic+ranks">ranks</a>()</code>,
<code><a href="#topic+scdf">scdf</a>()</code>,
<code><a href="#topic+select_cases">select_cases</a>()</code>,
<code><a href="#topic+set_vars">set_vars</a>()</code>,
<code><a href="#topic+smooth_cases">smooth_cases</a>()</code>,
<code><a href="#topic+standardize">standardize</a>()</code>,
<code><a href="#topic+truncate_phase">truncate_phase</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Shift the measurement time for a better estimation of the intercept
ex &lt;- shift(example_A24, value = -1996)
plm(ex)

# Please use transform instead:
example_A24 %&gt;%
  transform(year = year - 1996) %&gt;%
  plm()
</code></pre>

<hr>
<h2 id='shinyscan'>A Shiny app for scan</h2><span id='topic+shinyscan'></span>

<h3>Description</h3>

<p>Run a Shiny app with most of the scan functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shinyscan(quiet = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shinyscan_+3A_quiet">quiet</code></td>
<td>
<p>If TRUE (default) does not report shiny messages in the console.</p>
</td></tr>
<tr><td><code id="shinyscan_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code>shiny::runApp()</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function launches a shiny application.
You need to have <code>scplot</code> and <code>shiny</code> installed.
These packages are suggested but not necessarily installed along with scan.
<code>shinyscan()</code> will ask to install missing packages.
</p>

<hr>
<h2 id='smd'>Standardized mean differences</h2><span id='topic+smd'></span>

<h3>Description</h3>

<p>The <code>smd()</code> function provides various standardized mean effect sizes for
single-case data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smd(data, dvar, pvar, mvar, decreasing = FALSE, phases = c(1, 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smd_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="smd_+3A_dvar">dvar</code></td>
<td>
<p>Character string with the name of the dependent variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="smd_+3A_pvar">pvar</code></td>
<td>
<p>Character string with the name of the phase variable. Defaults to
the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="smd_+3A_mvar">mvar</code></td>
<td>
<p>Character string with the name of the measurement time variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="smd_+3A_decreasing">decreasing</code></td>
<td>
<p>If you expect data to be lower in the B phase, set
<code>decreasing = TRUE</code>. Default is <code>decreasing = FALSE</code>.</p>
</td></tr>
<tr><td><code id="smd_+3A_phases">phases</code></td>
<td>
<p>A vector of two characters or numbers indicating the two phases
that should be compared. E.g., <code>phases = c("A","C")</code> or <code>phases = c(2,4)</code>
for comparing the second to the fourth phase. Phases could be combined by
providing a list with two elements. E.g., <code>phases = list(A = c(1,3), B = c(2,4))</code> will compare phases 1 and 3 (as A) against 2 and 4 (as B). Default
is <code>phases = c(1,2)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'sd cohen' is the (unweigted) average of the variance of phase A and
B. 'sd Hedges' is the weighted average of the variance of phase A and B
(with a degrees of freedom correction). 'Hedges' g' is the mean difference
divided by 'sd Hedges'. 'Hedges' g correction' and 'Hedges' g durlak
correction' are two approaches of correcting Hedges' g for small sample
sizes. 'Glass' delta' is the mean difference divided by the standard
deviation of the A-phase. 'Cohens d&lsquo; is the mean difference divided by &rsquo;sd
cohen'.
</p>


<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>


<h3>See Also</h3>

<p><code><a href="#topic+overlap">overlap()</a></code>, <code><a href="#topic+describe">describe()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>smd(exampleAB)
</code></pre>

<hr>
<h2 id='smooth_cases'>Smoothing single-case data</h2><span id='topic+smooth_cases'></span>

<h3>Description</h3>

<p><em>This function is superseded by the more versatile
<code><a href="#topic+transform.scdf">transform.scdf</a></code> function.</em>
The <code>smooth_cases</code> function provides procedures to smooth single-case
data (i.e., to eliminate noise). A moving average function (mean- or
median-based) replaces each data point by the average of the surrounding
data points step-by-step. With a local regression function, each data point
is regressed by its surrounding data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_cases(data, dvar, mvar, method = "mean", intensity = NULL, FUN = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_cases_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="smooth_cases_+3A_dvar">dvar</code></td>
<td>
<p>Character string with the name of the dependent variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="smooth_cases_+3A_mvar">mvar</code></td>
<td>
<p>Character string with the name of the measurement time variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="smooth_cases_+3A_method">method</code>, <code id="smooth_cases_+3A_fun">FUN</code></td>
<td>
<p>Method determining the smoothed scores. Default <code>method =
"median"</code> is a moving median function. Further possible values are:
<code>"mean"</code> and a non-parametric <code>"regression"</code>.</p>
</td></tr>
<tr><td><code id="smooth_cases_+3A_intensity">intensity</code></td>
<td>
<p>For <code>method = "median"</code> and <code>"mean"</code> it
is the lag used for computing the average. Default is <code>intensity = 1</code>.
In case of <code>method = "regression"</code> it is the proportion of
surrounding data influencing each data point, which is <code>intensity =
0.2</code> by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>moving_median</code>, <code>moving_mean</code>, and <code>local_regression</code> are
helper function for <code><a href="#topic+transform.scdf">transform.scdf</a></code> returning the smoothed
values of a numeric vector.
</p>


<h3>Value</h3>

<p>Returns a data frame (for each single-case) with smoothed data
points. See <code><a href="#topic+scdf">scdf</a></code> to learn about the format of these data
frames.
</p>


<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>


<h3>See Also</h3>

<p>Other data manipulation functions: 
<code><a href="#topic+add_l2">add_l2</a>()</code>,
<code><a href="#topic+as.data.frame.scdf">as.data.frame.scdf</a>()</code>,
<code><a href="#topic+as_scdf">as_scdf</a>()</code>,
<code><a href="#topic+fill_missing">fill_missing</a>()</code>,
<code><a href="#topic+moving_median">moving_median</a>()</code>,
<code><a href="#topic+outlier">outlier</a>()</code>,
<code><a href="#topic+ranks">ranks</a>()</code>,
<code><a href="#topic+scdf">scdf</a>()</code>,
<code><a href="#topic+select_cases">select_cases</a>()</code>,
<code><a href="#topic+set_vars">set_vars</a>()</code>,
<code><a href="#topic+shift">shift</a>()</code>,
<code><a href="#topic+standardize">standardize</a>()</code>,
<code><a href="#topic+truncate_phase">truncate_phase</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Use the three different smoothing functions and compare the results
study &lt;- c(
  "Original" = Huber2014$Berta,
  "Moving median" = smooth_cases(Huber2014$Berta, method = "median"),
  "Moving mean" = smooth_cases(Huber2014$Berta, method = "mean"),
  "Local regression" = smooth_cases(Huber2014$Berta, method = "regression")
)
plot(study)

Huber2014$Berta %&gt;% 
transform(
  "compliance (moving median)" = moving_median(compliance),
  "compliance (moving mean)" = moving_mean(compliance),
  "compliance (local regression)" = local_regression(compliance, mt)
)

</code></pre>

<hr>
<h2 id='standardize'>Standardize values of an scdf file</h2><span id='topic+standardize'></span>

<h3>Description</h3>

<p><em>This function is superseded by the much more versatile
<code><a href="#topic+transform.scdf">transform.scdf</a></code> function (see example below).</em>
This function scales the measured values of an scdf file. It allows for mean
centering and standardization based on each single-case data set or a
scaling across all cases included in an scdf.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize(
  data,
  var,
  center = TRUE,
  scale = FALSE,
  m = 0,
  sd = 1,
  grand = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardize_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="standardize_+3A_var">var</code></td>
<td>
<p>A character string or a vector of character strings with variable
names that should be scaled.</p>
</td></tr>
<tr><td><code id="standardize_+3A_center">center</code></td>
<td>
<p>If set TRUE, data are mean centered.</p>
</td></tr>
<tr><td><code id="standardize_+3A_scale">scale</code></td>
<td>
<p>If set TRUE, the standard deviation is set.</p>
</td></tr>
<tr><td><code id="standardize_+3A_m">m</code></td>
<td>
<p>The target mean for centering.</p>
</td></tr>
<tr><td><code id="standardize_+3A_sd">sd</code></td>
<td>
<p>The target standard deviation for scaling</p>
</td></tr>
<tr><td><code id="standardize_+3A_grand">grand</code></td>
<td>
<p>If set TRUE, scaling is based on the mean and standard deviation
of all values across all single-cases within the scdf.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An scdf with the scaled values.
</p>


<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>


<h3>See Also</h3>

<p>Other data manipulation functions: 
<code><a href="#topic+add_l2">add_l2</a>()</code>,
<code><a href="#topic+as.data.frame.scdf">as.data.frame.scdf</a>()</code>,
<code><a href="#topic+as_scdf">as_scdf</a>()</code>,
<code><a href="#topic+fill_missing">fill_missing</a>()</code>,
<code><a href="#topic+moving_median">moving_median</a>()</code>,
<code><a href="#topic+outlier">outlier</a>()</code>,
<code><a href="#topic+ranks">ranks</a>()</code>,
<code><a href="#topic+scdf">scdf</a>()</code>,
<code><a href="#topic+select_cases">select_cases</a>()</code>,
<code><a href="#topic+set_vars">set_vars</a>()</code>,
<code><a href="#topic+shift">shift</a>()</code>,
<code><a href="#topic+smooth_cases">smooth_cases</a>()</code>,
<code><a href="#topic+truncate_phase">truncate_phase</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Standardize a multiple case scdf and compute an hplm
exampleAB_50 %&gt;%
  standardize("values", center = TRUE, scale = TRUE) %&gt;%
  hplm()

## The more versatile transform function supersedes standardize:
exampleAB_50 %&gt;%
  transform(values = (values - mean(all(values))) / sd(all(values))) %&gt;%
  hplm()
</code></pre>

<hr>
<h2 id='style_plot'>Create styles for single-case data plots</h2><span id='topic+style_plot'></span>

<h3>Description</h3>

<p>The <code>style_plot</code> function is used to create graphical styles for a
single-case plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>style_plot(style = "default", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="style_plot_+3A_style">style</code></td>
<td>
<p>A character string or a vector of character strings with
predefined styles.</p>
</td></tr>
<tr><td><code id="style_plot_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the plot command.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>style_plot("")</code> will return a list of predefined styles.
Predefined styles can be combined <code>style_plot(style = c("grid2",
  "tiny"))</code> where settings of a latter style overwrite settings of the
former. Additional style paramters are set following the style argument and
can be combined with those: <code>style_plot(style = "grid2", fill =
  "grey50", pch = 18)</code>.
</p>


<h3>Value</h3>

<p>Returns a list to be provided for the style argument of the
<code><a href="#topic+plot.scdf">plot.scdf()</a></code> function.
</p>
 <ul>
<li><p><code>fill</code> If set, the area under the line is filled
with the given color (e.g., <code>fill = "tomato"</code>). Use the standard R
command colors() to get a list of all possible colours. <code>fill</code> is
empty by default. </p>
</li>
<li><p><code>annotations</code> A list of parameters defining
annotations to each data point. This adds the score of each MT to your
plot.
</p>

<ul>
<li><p><code>"pos"</code> Position of the annotations: 1 = below, 2 =
left, 3 = above, 4 = right.
</p>
</li>
<li><p><code>"col"</code> Color of the annotations.
</p>
</li>
<li><p><code>"cex"</code> Size of the annotations.
</p>
</li>
<li><p><code>"round"</code> Rounds the values to the specified decimal.</p>
</li></ul>

</li>
<li><p><code>annotations = list(pos = 3, col =
"brown", round = 1)</code> adds scores rounded to one decimal above the data point
in brown color to the plot. </p>
</li>
<li><p><code>"names"</code> A list of parameters
defining the depiction of phase names (e.g. <code>names = list(cex = 0.8,
  col = "red", side = 1)</code>: cex for size, col for color, and side for
position). See <code><a href="graphics.html#topic+mtext">mtext</a></code> for more details. </p>
</li>
<li><p><code>"lwd"</code>
Width of the plot line. Default is <code>lwd = 2</code>. </p>
</li>
<li><p><code>"pch"</code> Point
type. Default is <code>pch = 17</code> (triangles). Other options are for
example: 16 (filled circles) or &quot;A&quot; (uses the letter A). </p>
</li>
<li><p><code>"main"</code>
Main title of the plot. </p>
</li>
<li><p><code>"mai"</code> Sets the margins of the plot.
</p>
</li>
<li><p><code>"bty"</code> Shape of the frame surrounding the inner plot
</p>
</li>
<li><p><code>"fill.bg"</code> Background color of the plot. If a vector is
provided, these colors will be assigned to phases (each phase name becomes
a color). </p>
</li>
<li><p><code>"grid"</code> Color of a grid. </p>
</li>
<li><p><code>"text.ABlag"</code> Text
displayed between phases. </p>
</li>
<li><p><code>"cex.axis"</code> Size of the axis
annotations </p>
</li>
<li><p><code>"las"</code> Orientation of the axis annotations
</p>
</li>
<li><p><code>"col.lines"</code> Color of the lines </p>
</li>
<li><p><code>"col.dots"</code> Color of
the dots </p>
</li>
<li><p><code>"col.seperator"</code> Color of the phase seperating lines
</p>
</li>
<li><p><code>"col.bg"</code> Color of the outer plot </p>
</li>
<li><p><code>"col"</code> General
color setting for the plot </p>
</li>
<li><p><code>"col.text"</code> Color of all labels of
the plot. </p>
</li></ul>



<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.scdf">plot.scdf()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>newstyle &lt;- style_plot(style = "default")
newstyle$text.ABlag &lt;- c("START", "END")
newstyle$col.dots &lt;- ""
newstyle$annotations &lt;- list(cex = 0.6, col = "grey10", offset = 0.4)
newstyle$names &lt;- list(cex = 0.8, col = "blue", side = 1, adj = 1, line = -1, at = 31)
newstyle$fill.bg &lt;- c("grey99", "grey95", "grey90")
plot(exampleABC, style = newstyle, main = "Example Plot")

</code></pre>

<hr>
<h2 id='subset.scdf'>Subset cases, rows, and variables</h2><span id='topic+subset.scdf'></span>

<h3>Description</h3>

<p>This function is mainly used to filter rows by a logical expression. It has
also arguments to filter variables and cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scdf'
subset(x, subset, select, cases, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.scdf_+3A_x">x</code></td>
<td>
<p>An scdf object.</p>
</td></tr>
<tr><td><code id="subset.scdf_+3A_subset">subset</code></td>
<td>
<p>Logical expression indicating rows to keep: missing values are
taken as false.</p>
</td></tr>
<tr><td><code id="subset.scdf_+3A_select">select</code></td>
<td>
<p>Expression, indicating columns to select from an scdf.</p>
</td></tr>
<tr><td><code id="subset.scdf_+3A_cases">cases</code></td>
<td>
<p>Expression, indicating cases to keep from an scdf.</p>
</td></tr>
<tr><td><code id="subset.scdf_+3A_...">...</code></td>
<td>
<p>not implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An scdf.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exampleAB %&gt;%
  subset((values &lt; 60 &amp; phase == "A") | (values &gt;= 60 &amp; phase == "B"))
subset(exampleAB_add, select = c(-cigarrets, -depression))
subset(exampleAB, cases = c(Karolina, Johanna))
subset(exampleA1B1A2B2, phase %in% c("A1", "B2"), cases = Pawel:Moritz)
</code></pre>

<hr>
<h2 id='summary.scdf'>Summary function for an scdf</h2><span id='topic+summary.scdf'></span>

<h3>Description</h3>

<p>Summary function for an scdf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scdf'
summary(object, all_cases = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.scdf_+3A_object">object</code></td>
<td>
<p>scdf</p>
</td></tr>
<tr><td><code id="summary.scdf_+3A_all_cases">all_cases</code></td>
<td>
<p>IF TRUE, more that 10 cases are summarized</p>
</td></tr>
<tr><td><code id="summary.scdf_+3A_...">...</code></td>
<td>
<p>not in use</p>
</td></tr>
</table>

<hr>
<h2 id='tau_u'>Tau-U for single-case data</h2><span id='topic+tau_u'></span><span id='topic+print.sc_tauu'></span><span id='topic+export.sc_tauu'></span>

<h3>Description</h3>

<p>This function calculates indices of the Tau-U family as proposed by Parker et
al. (2011a).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tau_u(
  data,
  dvar,
  pvar,
  tau_method = c("b", "a"),
  method = c("complete", "parker"),
  phases = c(1, 2),
  meta_analyses = TRUE,
  ci = 0.95,
  ci_method = c("z", "tau", "s"),
  meta_weight_method = c("z", "tau"),
  continuity_correction = FALSE,
  meta_method = NULL
)

## S3 method for class 'sc_tauu'
print(
  x,
  complete = FALSE,
  digits = "auto",
  select = c("Tau", "CI lower", "CI upper", "SD_S", "Z", "p"),
  nice_p = TRUE,
  ...
)

## S3 method for class 'sc_tauu'
export(
  object,
  caption = NA,
  footnote = NA,
  filename = NA,
  select = "auto",
  kable_styling_options = list(),
  kable_options = list(),
  meta = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tau_u_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="tau_u_+3A_dvar">dvar</code></td>
<td>
<p>Character string with the name of the dependent variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="tau_u_+3A_pvar">pvar</code></td>
<td>
<p>Character string with the name of the phase variable. Defaults to
the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="tau_u_+3A_tau_method">tau_method</code></td>
<td>
<p>Character with values &quot;a&quot; or &quot;b&quot; (default) indicating
whether Kendall Tau A or Kendall Tau B is applied.</p>
</td></tr>
<tr><td><code id="tau_u_+3A_method">method</code></td>
<td>
<p><code>"complete"</code> (default) or <code>"parker"</code>. The latter calculates the
number of possible pairs as described in Parker et al. (2011) which might
lead to tau-U values greater than 1.</p>
</td></tr>
<tr><td><code id="tau_u_+3A_phases">phases</code></td>
<td>
<p>A vector of two characters or numbers indicating the two phases
that should be compared. E.g., <code>phases = c("A","C")</code> or <code>phases = c(2,4)</code>
for comparing the second to the fourth phase. Phases could be combined by
providing a list with two elements. E.g., <code>phases = list(A = c(1,3), B = c(2,4))</code> will compare phases 1 and 3 (as A) against 2 and 4 (as B). Default
is <code>phases = c(1,2)</code>.</p>
</td></tr>
<tr><td><code id="tau_u_+3A_meta_analyses">meta_analyses</code></td>
<td>
<p>If TRUE, a meta analysis is conducted.</p>
</td></tr>
<tr><td><code id="tau_u_+3A_ci">ci</code></td>
<td>
<p>Confidence intervals</p>
</td></tr>
<tr><td><code id="tau_u_+3A_ci_method">ci_method</code></td>
<td>
<p>String to specify the method for calculating the standard
error of tau. Either &quot;tau&quot;, &quot;z&quot;, or &quot;s&quot; (not recommended).</p>
</td></tr>
<tr><td><code id="tau_u_+3A_meta_weight_method">meta_weight_method</code></td>
<td>
<p>String to specify the method for calculating the
weights of the studies. Either &quot;tau&quot; or &quot;z&quot;.</p>
</td></tr>
<tr><td><code id="tau_u_+3A_continuity_correction">continuity_correction</code></td>
<td>
<p>If TRUE, a continuity correction is applied for
calculating p-values of correlations (here: S will be reduced by one before
calculating Z)</p>
</td></tr>
<tr><td><code id="tau_u_+3A_meta_method">meta_method</code></td>
<td>
<p>(not implemented) All meta analyses are based on a fixed
model.</p>
</td></tr>
<tr><td><code id="tau_u_+3A_x">x</code></td>
<td>
<p>Object returned from <code><a href="#topic+tau_u">tau_u()</a></code>.</p>
</td></tr>
<tr><td><code id="tau_u_+3A_complete">complete</code></td>
<td>
<p>Print all parameters.</p>
</td></tr>
<tr><td><code id="tau_u_+3A_digits">digits</code></td>
<td>
<p>The minimum number of significant digits to be use.
If set to &quot;auto&quot; (default), values are predefined.</p>
</td></tr>
<tr><td><code id="tau_u_+3A_select">select</code></td>
<td>
<p>Character vector with name of variables to be included. When
the vector is named, variables are renamed appropriately.</p>
</td></tr>
<tr><td><code id="tau_u_+3A_nice_p">nice_p</code></td>
<td>
<p>If TRUE, p-values are printed in publication friendly form.</p>
</td></tr>
<tr><td><code id="tau_u_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the function.</p>
</td></tr>
<tr><td><code id="tau_u_+3A_object">object</code></td>
<td>
<p>An scdf or an object exported from a scan function.</p>
</td></tr>
<tr><td><code id="tau_u_+3A_caption">caption</code></td>
<td>
<p>Character string with table caption. If left NA (default) a
caption will be created based on the exported object.</p>
</td></tr>
<tr><td><code id="tau_u_+3A_footnote">footnote</code></td>
<td>
<p>Character string with table footnote. If left NA (default) a
footnote will be created based on the exported object.</p>
</td></tr>
<tr><td><code id="tau_u_+3A_filename">filename</code></td>
<td>
<p>String containing the file name. If a filename is given the
output will be written to that file.</p>
</td></tr>
<tr><td><code id="tau_u_+3A_kable_styling_options">kable_styling_options</code></td>
<td>
<p>list with arguments passed to the kable_styling
function.</p>
</td></tr>
<tr><td><code id="tau_u_+3A_kable_options">kable_options</code></td>
<td>
<p>list with arguments passed to the kable function.</p>
</td></tr>
<tr><td><code id="tau_u_+3A_meta">meta</code></td>
<td>
<p>If TRUE, the results of the meta analysis will be exported. If
FALSE, each single-case is exported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tau-U is an inconsistently operationalized construct. Parker et al.
(2011b) describe a method which may result in Tau-U outside the [-1;1]
interval. A different implementation of the method (provided at
http://www.singlecaseresearch.org/calculators/tau-u) uses tau-b (instead of
tau-a as in the original formulation by Parker). Bossart et. al (2018)
describe inconsistencies in the results from this implementation as well.
Another problems lies in the calculation in overall Tau-U values from
several single cases. The function presented here applies a meta-analysis
to gain the overall values. Each tau value is weighted by the inverse of
the variance (ie. the tau standard error). The confidence intervals for
single cases are calculated by Fisher-Z transforming tau, calculating the
confidence intervals, and inverse transform them back to tau (see Long &amp;
Cliff, 1997).
</p>


<h3>Value</h3>

<table>
<tr><td><code>table</code></td>
<td>
<p>A data frame containing statistics from the Tau-U
family, including: Pairs, positive and negative comparisons, S, and Tau</p>
</td></tr>
<tr><td><code>matrix</code></td>
<td>
<p>The matrix of comparisons used for calculating the
statistics.</p>
</td></tr> <tr><td><code>tau_u</code></td>
<td>
<p>Tau-U value.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>print(sc_tauu)</code>: Print results
</p>
</li>
<li> <p><code>export(sc_tauu)</code>: Export results as html table
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>


<h3>References</h3>

<p>Brossart, D. F., Laird, V. C., &amp; Armstrong, T. W. (2018).
Interpreting Kendallâ€™s Tau and Tau-U for single-case experimental designs.
<em>Cogent Psychology, 5(1)</em>, 1â€“26.
https://doi.org/10.1080/23311908.2018.1518687.
</p>
<p>Long, J. D., &amp; Cliff, N. (1997). Confidence intervals for Kendallâ€™s tau.
<em>British Journal of Mathematical and Statistical Psychology</em>, 50(1),
31â€“41. https://doi.org/10.1111/j.2044-8317.1997.tb01100.x
</p>
<p>Parker, R. I., Vannest, K. J., &amp; Davis, J. L. (2011a). Effect Size in
Single-Case Research: A Review of Nine Nonoverlap Techniques.
<em>Behavior Modification</em>, 35(4), 303â€“322. https://doi.org/10/dsdfs4
Parker, R. I., Vannest, K. J., Davis, J. L., &amp; Sauber, S. B. (2011b).
Combining Nonoverlap and Trend for Single-Case Research: Tau-U.
<em>Behavior Therapy, 42</em>, 284-299.
</p>


<h3>See Also</h3>

<p>Other overlap functions: 
<code><a href="#topic+cdc">cdc</a>()</code>,
<code><a href="#topic+nap">nap</a>()</code>,
<code><a href="#topic+overlap">overlap</a>()</code>,
<code><a href="#topic+pand">pand</a>()</code>,
<code><a href="#topic+pem">pem</a>()</code>,
<code><a href="#topic+pet">pet</a>()</code>,
<code><a href="#topic+pnd">pnd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tau_u(Grosche2011$Eva)

## Replicate  tau-U calculation from Parker et al. (2011)
bob &lt;- scdf(c(A = 2, 3, 5, 3, B = 4, 5, 5, 7, 6), name = "Bob")
res &lt;- tau_u(bob, method = "parker", tau_method = "a")
print(res, complete = TRUE)

## Request tau-U for all single-cases from the Grosche2011 data set
tau_u(Grosche2011)
</code></pre>

<hr>
<h2 id='trend'>Trend analysis for single-cases data</h2><span id='topic+trend'></span>

<h3>Description</h3>

<p>The <code>trend()</code> function provides an overview of linear trends in single case
data. By default, it provides the intercept and slope of a linear and
quadratic regression of measurement time on scores. Models are calculated
separately for each phase and across all phases. For more advanced use, you
can add regression models using the R-specific formula class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trend(
  data,
  dvar,
  pvar,
  mvar,
  offset = "deprecated",
  first_mt = 0,
  model = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trend_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="trend_+3A_dvar">dvar</code></td>
<td>
<p>Character string with the name of the dependent variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="trend_+3A_pvar">pvar</code></td>
<td>
<p>Character string with the name of the phase variable. Defaults to
the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="trend_+3A_mvar">mvar</code></td>
<td>
<p>Character string with the name of the measurement time variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="trend_+3A_offset">offset</code></td>
<td>
<p>(Deprecated. Please use first_mt). An offset for the first
measurement-time of each phase. If <code>offset = 0</code>, the phase measurement is
handled as MT 1. Default is <code>offset = -1</code>, setting the first value of MT to
0.</p>
</td></tr>
<tr><td><code id="trend_+3A_first_mt">first_mt</code></td>
<td>
<p>A numeric setting the value for the first measurement-time.
Default = 0.</p>
</td></tr>
<tr><td><code id="trend_+3A_model">model</code></td>
<td>
<p>A string or a list of (named) strings each depicting one
regression model. This is a formula expression of the standard R class. The
parameters of the model are <code>values</code>, <code>mt</code> and <code>phase</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>trend</code></td>
<td>
<p>A matrix containing the results (Intercept, B and beta)
of separate regression models for phase A, phase B, and the whole data.</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>Numeric argument from function call (see arguments
section).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>


<h3>See Also</h3>

<p><code><a href="#topic+describe">describe()</a></code>
</p>
<p>Other regression functions: 
<code><a href="#topic+autocorr">autocorr</a>()</code>,
<code><a href="#topic+corrected_tau">corrected_tau</a>()</code>,
<code><a href="#topic+hplm">hplm</a>()</code>,
<code><a href="#topic+mplm">mplm</a>()</code>,
<code><a href="#topic+plm">plm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Compute the linear and squared regression for a random single-case
design &lt;- design(slope = 0.5)
matthea &lt;- random_scdf(design)
trend(matthea)

## Besides the linear and squared regression models compute two custom models:
## a) a cubic model, and b) the values predicted by the natural logarithm of the
## measurement time.
design &lt;- design(slope = 0.3)
ben &lt;- random_scdf(design)
trend(ben, offset = 0, model = c("Cubic" = values ~ I(mt^3), "Log Time" = values ~ log(mt)))

</code></pre>

<hr>
<h2 id='truncate_phase'>Truncate single-case data</h2><span id='topic+truncate_phase'></span>

<h3>Description</h3>

<p>#' <em>This function is superseded by the more versatile
<code><a href="#topic+transform.scdf">transform.scdf</a></code> function.</em>
This function truncates data points at the beginning and / or end of each
phase in each case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>truncate_phase(
  data,
  dvar,
  pvar,
  truncate = list(A = c(0, 0), B = c(0, 0)),
  na = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="truncate_phase_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="truncate_phase_+3A_dvar">dvar</code></td>
<td>
<p>Character string with the name of the dependent variable.
Defaults to the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="truncate_phase_+3A_pvar">pvar</code></td>
<td>
<p>Character string with the name of the phase variable. Defaults to
the attributes in the scdf file.</p>
</td></tr>
<tr><td><code id="truncate_phase_+3A_truncate">truncate</code></td>
<td>
<p>A list with a vector of two (beginning and end) values for
each phase defining the number of data points to be deleted. For lists of
single-case data frames, the truncation is adapted to the length of each
phase for each single case.</p>
</td></tr>
<tr><td><code id="truncate_phase_+3A_na">na</code></td>
<td>
<p>If FALSE, the truncated measurement times are deleted. If TRUE, NAs
are set for the dependent variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A truncated data frame (for each single-case).
</p>


<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>


<h3>See Also</h3>

<p>Other data manipulation functions: 
<code><a href="#topic+add_l2">add_l2</a>()</code>,
<code><a href="#topic+as.data.frame.scdf">as.data.frame.scdf</a>()</code>,
<code><a href="#topic+as_scdf">as_scdf</a>()</code>,
<code><a href="#topic+fill_missing">fill_missing</a>()</code>,
<code><a href="#topic+moving_median">moving_median</a>()</code>,
<code><a href="#topic+outlier">outlier</a>()</code>,
<code><a href="#topic+ranks">ranks</a>()</code>,
<code><a href="#topic+scdf">scdf</a>()</code>,
<code><a href="#topic+select_cases">select_cases</a>()</code>,
<code><a href="#topic+set_vars">set_vars</a>()</code>,
<code><a href="#topic+shift">shift</a>()</code>,
<code><a href="#topic+smooth_cases">smooth_cases</a>()</code>,
<code><a href="#topic+standardize">standardize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Truncate the first two data points of both phases and compare the two 
## data sets
study &lt;- c(
  "Original" = byHeart2011[1],
  "Selected" = truncate_phase(
    byHeart2011[1], truncate = list(A = c(2, 0), B = c(2, 0))
  )
)
plot(study)
</code></pre>

<hr>
<h2 id='write_scdf'>Data output</h2><span id='topic+write_scdf'></span>

<h3>Description</h3>

<p>This function restructures and writes single-case data into a .csv-file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_scdf(data, filename = NULL, sep = ",", dec = ".", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_scdf_+3A_data">data</code></td>
<td>
<p>A single-case data frame. See <code><a href="#topic+scdf">scdf()</a></code> to learn about this
format.</p>
</td></tr>
<tr><td><code id="write_scdf_+3A_filename">filename</code></td>
<td>
<p>A character string defining the output file name (e.g.
<code>"SC_data.csv"</code>.</p>
</td></tr>
<tr><td><code id="write_scdf_+3A_sep">sep</code></td>
<td>
<p>The field separator string. Values within each row of x are
separated by this string.</p>
</td></tr>
<tr><td><code id="write_scdf_+3A_dec">dec</code></td>
<td>
<p>The string to use for decimal points in numeric or complex
columns: must be a single character.</p>
</td></tr>
<tr><td><code id="write_scdf_+3A_...">...</code></td>
<td>
<p>Further arguments passed to write.table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper for the write.table function with predefined parameters.
</p>


<h3>Author(s)</h3>

<p>Juergen Wilbert
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+write.table">write.table()</a></code>, <code><a href="base.html#topic+saveRDS">saveRDS()</a></code>
</p>
<p>Other io-functions: 
<code><a href="#topic+convert">convert</a>()</code>,
<code><a href="#topic+read_scdf">read_scdf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## write single-case data to a .csv-file
filename &lt;- tempfile(fileext = ".csv")
jessica &lt;- random_scdf(design(level = .5))
write_scdf(jessica, tempfile())

## write multiple cases to a .csv-file with semicolon as field and comma as
## decimal separator
write_scdf(Grosche2011, filename, sep = ";", dec = ",")

## read_scdf and write_scdf
write_scdf(exampleA1B1A2B2_zvt, filename)
dat &lt;- read_scdf(filename, cvar = "case", pvar = "part",
                 dvar = "zvt", mvar = "day")
res1 &lt;- describe(exampleA1B1A2B2_zvt)$descriptives
res2 &lt;- describe(dat)$descriptives
all.equal(res1,res2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
