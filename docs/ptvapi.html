<!DOCTYPE html><html lang="en"><head><title>Help for package ptvapi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ptvapi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ptvapi-package'><p>ptvapi: A package for accessing the Public Transport Victoria Timetable API</p></a></li>
<li><a href='#add_parameter'><p>Suffix a parameter to a HTML request</p></a></li>
<li><a href='#add_parameters'><p>Suffix one or many parameters to a HTML request</p></a></li>
<li><a href='#all_disruptions_to_tibble'><p>Convert the contents of a disruptions API call to a single tibble</p></a></li>
<li><a href='#assert_correct_attributes'><p>Assert that the API has returned the expected attributes</p></a></li>
<li><a href='#cached_route_types'><p>Retrieve route types, using cached values if possible</p></a></li>
<li><a href='#convert_to_melbourne_time'><p>Convert a datetime returned by the PTV API into Melbourne time</p></a></li>
<li><a href='#departure_to_tibble'><p>Convert a single departure to a tibble</p></a></li>
<li><a href='#departures'><p>Departures from a given stop</p></a></li>
<li><a href='#describe_route_type'><p>Convert a numeric route type to a human-friendly description</p></a></li>
<li><a href='#directions'><p>Directions for a given direction ID</p></a></li>
<li><a href='#directions_on_route'><p>Directions on a given route</p></a></li>
<li><a href='#disruption_information'><p>Information on a particular disruption</p></a></li>
<li><a href='#disruption_modes'><p>Retrieve a translation from description mode number to description mode name</p></a></li>
<li><a href='#disruption_to_tibble'><p>Convert a single disruption to a tibble</p></a></li>
<li><a href='#disruptions'><p>Information for all disruptions</p></a></li>
<li><a href='#disruptions_at_stop'><p>Disruptions at a given stop</p></a></li>
<li><a href='#disruptions_on_route'><p>Disruptions on a given route</p></a></li>
<li><a href='#fare_estimate'><p>Calculate a fare estimate between zones</p></a></li>
<li><a href='#filter_departures'><p>Filter parsed departures content according to user input</p></a></li>
<li><a href='#generate_request_url'><p>Generate a URL with devid and signature</p></a></li>
<li><a href='#geopath_to_tibble'><p>Convert a single geopath to a tibble</p></a></li>
<li><a href='#make_url_friendly'><p>Convert an input to a form that can be used in a URL.</p></a></li>
<li><a href='#map_and_rbind'><p>Map and rbind a list of data frames</p></a></li>
<li><a href='#outlet_to_tibble'><p>Convert a single outlet to a tibble</p></a></li>
<li><a href='#outlets'><p>Information for all outlets</p></a></li>
<li><a href='#outlets_nearby'><p>Information for outlets near a given location</p></a></li>
<li><a href='#parse_directions_content'><p>Parse content of directions API call</p></a></li>
<li><a href='#parse_fare_estimate_content'><p>Parse content of fare estimates API call</p></a></li>
<li><a href='#patterns'><p>Stopping pattern for a given run</p></a></li>
<li><a href='#process_response'><p>Process a raw httr response and return an object of class ptv_api</p></a></li>
<li><a href='#ptv_search'><p>Use a character term to search for routes, stops, and outlets.</p></a></li>
<li><a href='#PTVGET'><p>Submit a GET request to the PTV API</p></a></li>
<li><a href='#route_information'><p>Information for a given route</p></a></li>
<li><a href='#route_to_tibble'><p>Convert a single route to a tibble</p></a></li>
<li><a href='#route_types'><p>Retrieve a translation from route type number to name</p></a></li>
<li><a href='#routes'><p>Information for all routes</p></a></li>
<li><a href='#run_information'><p>Information for a given run</p></a></li>
<li><a href='#run_to_tibble'><p>Convert a single run to a tibble</p></a></li>
<li><a href='#runs_on_route'><p>Runs on a given route</p></a></li>
<li><a href='#search_outlets'><p>Search for outlets using text</p></a></li>
<li><a href='#search_routes'><p>Search for routes using text</p></a></li>
<li><a href='#search_stops'><p>Search for stops using text</p></a></li>
<li><a href='#stop_information'><p>Information for a given stop (metropolitan and V/Line stations only)</p></a></li>
<li><a href='#stop_to_tibble'><p>Convert a single stop to a tibble</p></a></li>
<li><a href='#stops_nearby'><p>Stops near a given location</p></a></li>
<li><a href='#stops_on_route'><p>Stops on a given route and route type</p></a></li>
<li><a href='#to_datetime'><p>Convert a POSIXct or character datetime to a format ready for a URL</p></a></li>
<li><a href='#to_integer'><p>Strictly convert an object to an integer</p></a></li>
<li><a href='#translate_route_type'><p>Translate a route type input into a numerical route type</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Access the 'Public Transport Victoria' Timetable API</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Access the 'Public Transport Victoria' Timetable API 
    <a href="https://www.ptv.vic.gov.au/footer/data-and-reporting/datasets/ptv-timetable-api/">https://www.ptv.vic.gov.au/footer/data-and-reporting/datasets/ptv-timetable-api/</a>,
    with results returned as familiar R data structures. Retrieve information on
    stops, routes, disruptions, departures, and more.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>httr, glue, digest, jsonlite, purrr, tibble, assertthat</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), dplyr, lubridate</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mdneuzerling/ptvapi">https://github.com/mdneuzerling/ptvapi</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mdneuzerling/ptvapi/issues">https://github.com/mdneuzerling/ptvapi/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-18 02:47:29 UTC; mdneuzerling</td>
</tr>
<tr>
<td>Author:</td>
<td>David Neuzerling [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Neuzerling &lt;david@neuzerling.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-18 03:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ptvapi-package'>ptvapi: A package for accessing the Public Transport Victoria Timetable API</h2><span id='topic+ptvapi'></span><span id='topic+ptvapi-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/ptvapi.png" alt='logo' />
</p>
<p>Accessing the Public Transport Victoria Timetable API reqiures a user ID
(also called a <code>devid</code>) and an API key. These can be accessed by contacting
Public Transport Victoria. See
<a href="https://www.ptv.vic.gov.au/footer/data-and-reporting/datasets/ptv-timetable-api/">https://www.ptv.vic.gov.au/footer/data-and-reporting/datasets/ptv-timetable-api/</a>
</p>
<p>The user ID and API key can be entered directly into all functions.
Alternatively, all functions will pick up on the PTV_USER_ID and API_KEY
environment variables, if defined.
</p>
<p>All API requests use SSL by default. To disable this, and to use the <code>http</code>
API endpoints rather than the <code>https</code> API endpoints, set the option:
</p>
<div class="sourceCode"><pre>options(use_insecure_ptv_connection = TRUE)
</pre></div>


<h3>Details</h3>

<p>This is an unofficial wrapper of the Public Transport Victoria Timetable API.
The author(s) of this package are unaffiliated with Public Transport
Victoria.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: David Neuzerling <a href="mailto:david@neuzerling.com">david@neuzerling.com</a> [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/mdneuzerling/ptvapi">https://github.com/mdneuzerling/ptvapi</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mdneuzerling/ptvapi/issues">https://github.com/mdneuzerling/ptvapi/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# tibble of all routes
routes()

# Search for routes by name (case insensitive, partial matching supported)
routes(route_name = "Frankston")

# All current disruptions
disruptions(disruption_status = "current")

# Train stops near Flinders Street Station
stops_nearby(
  latitude = -37.8183,
  longitude = 144.9671,
  route_types = "Train"
)

# Upcoming train departures from Flinders Street Station
departures(stop_id = 1071, route_type = "Train")

## End(Not run)
</code></pre>

<hr>
<h2 id='add_parameter'>Suffix a parameter to a HTML request</h2><span id='topic+add_parameter'></span>

<h3>Description</h3>

<p>Parameters are suffixed to a URL, like so:
&quot;request?para1=value1&amp;para2=value2&quot;. The first parameter is suffixed with &quot;?&quot;
and all others after that &quot;&amp;&quot;. This function will determine the correct
suffix based on the presence of &quot;&amp;&quot; in the request.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_parameter(
  request,
  parameter_name,
  parameter_value,
  .combine = "repeat_name"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_parameter_+3A_request">request</code></td>
<td>
<p>Character. The base URL or request which will be suffixed with
the parameter.</p>
</td></tr>
<tr><td><code id="add_parameter_+3A_parameter_name">parameter_name</code></td>
<td>
<p>Character. Name of parameter to suffix.</p>
</td></tr>
<tr><td><code id="add_parameter_+3A_parameter_value">parameter_value</code></td>
<td>
<p>Character, or a value that can be coerced to a
character. The value of the parameter to suffix.</p>
</td></tr>
<tr><td><code id="add_parameter_+3A_.combine">.combine</code></td>
<td>
<p>How to combine parameters with multiple values. One
of &quot;repeat_name&quot;, &quot;with_commas&quot;, &quot;with_hex_commas&quot;. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is no standardised way to combine multiple values for a
parameter. You should see how your API expects multiple values to be provided
to the same parameter. This function allows for the following strategies. If
any other value is provided, then the values will be concatenated and
separated with the provided value.
</p>

<ul>
<li><p> &quot;repeat_name&quot; (default). The values of the parameter are repeated
with the parameter name. For example, <code style="white-space: pre;">&#8288;("request", "para", c(1, 2))&#8288;</code> will
return &quot;request?para=1&amp;para=2&quot;.
</p>
</li>
<li><p> &quot;with_commas&quot;. The values of the parameter are concatenated and
separated with commas. For example, <code style="white-space: pre;">&#8288;("request", "para", c(1, 2))&#8288;</code> will
return &quot;request?para=1,2&quot;.
</p>
</li>
<li><p> &quot;with_commas&quot;. The values of the parameter are concatenated and
separated with the ASCII keycode in hexadecimal for a comma (&quot;%2C&quot;). For
example, <code style="white-space: pre;">&#8288;("request", "para", c(1, 2))&#8288;</code> will return &quot;request?para=1%2C2&quot;.
</p>
</li></ul>



<h3>Value</h3>

<p>Character. The request with suffixed parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ptvapi:::add_parameter("www.example.com", "animal", "crocodile")
ptvapi:::add_parameter(
  "www.example.com",
  "numbers",
  c(1, 2, 3),
  .combine = "repeat_names"
)
## End(Not run)

</code></pre>

<hr>
<h2 id='add_parameters'>Suffix one or many parameters to a HTML request</h2><span id='topic+add_parameters'></span>

<h3>Description</h3>

<p>Parameters are suffixed to a URL, like so:
&quot;request?para1=value1&amp;para2=value2&quot;. The first parameter is suffixed with &quot;?&quot;
and all others after that &quot;&amp;&quot;. This function will determine the correct
suffix based on the presence of &quot;&amp;&quot; in the request.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_parameters(request, ..., .combine = "repeat_name")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_parameters_+3A_request">request</code></td>
<td>
<p>Character. The base URL or request which will be suffixed with
the parameter.</p>
</td></tr>
<tr><td><code id="add_parameters_+3A_...">...</code></td>
<td>
<p>The parameters to be suffixed, with name/value pairs provided as
arguments.</p>
</td></tr>
<tr><td><code id="add_parameters_+3A_.combine">.combine</code></td>
<td>
<p>How to combine parameters with multiple values. One
of &quot;repeat_name&quot;, &quot;with_commas&quot;, &quot;with_hex_commas&quot;. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is no standardised way to combine multiple values for a
parameter. You should see how your API expects multiple values to be provided
to the same parameter. This function allows for the following strategies. If
any other value is provided, then the values will be concatenated and
separated with the provided value.
</p>

<ul>
<li><p> &quot;repeat_name&quot; (default). The values of the parameter are repeated
with the parameter name. For example, <code style="white-space: pre;">&#8288;("request", "para", c(1, 2))&#8288;</code> will
return &quot;request?para=1&amp;para=2&quot;.
</p>
</li>
<li><p> &quot;with_commas&quot;. The values of the parameter are concatenated and
separated with commas. For example, <code style="white-space: pre;">&#8288;("request", "para", c(1, 2))&#8288;</code> will
return &quot;request?para=1,2&quot;.
</p>
</li>
<li><p> &quot;with_commas&quot;. The values of the parameter are concatenated and
separated with the ASCII keycode in hexadecimal for a comma (&quot;%2C&quot;). For
example, <code style="white-space: pre;">&#8288;("request", "para", c(1, 2))&#8288;</code> will return &quot;request?para=1%2C2&quot;.
</p>
</li></ul>



<h3>Value</h3>

<p>Character. The request with suffixed parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ptvapi:::add_parameters("www.example.com", animal = crocodile)
ptvapi:::add_parameters(
  "www.example.com",
  animal = crocodile,
  food = "cherries"
)
ptvapi:::add_parameters(
  "www.example.com",
  animal = crocodile,
  numbers = c(1, 2, 3),
  .combine = "repeat_names"
)
## End(Not run)

</code></pre>

<hr>
<h2 id='all_disruptions_to_tibble'>Convert the contents of a disruptions API call to a single tibble</h2><span id='topic+all_disruptions_to_tibble'></span>

<h3>Description</h3>

<p>Disruptions API responses contain an element for every service type, eg.
metro train, taxis, Skybus. Normally we would map-reduce the content of an
API call with a function analogous to <code>disruption_to_tibble</code>. But because of
the extra layer of nesting in the response, we have to map-reduce the service
types first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_disruptions_to_tibble(disruptions_content)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="all_disruptions_to_tibble_+3A_disruptions_content">disruptions_content</code></td>
<td>
<p>The raw disruptions content returned by the
<code>disruptions</code> API call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that we return an empty tibble if there are no disruptions, so that
this situation is omitted.
</p>


<h3>Value</h3>

<p>A tibble with the following columns: </p>

<ul>
<li> <p><code>disruption_mode</code>
</p>
</li>
<li> <p><code>disruption_mode_description</code>
</p>
</li>
<li> <p><code>disruption_id</code>
</p>
</li>
<li> <p><code>title</code>
</p>
</li>
<li> <p><code>url</code>
</p>
</li>
<li> <p><code>description</code>
</p>
</li>
<li> <p><code>disruption_status</code>
</p>
</li>
<li> <p><code>disruption_type</code>
</p>
</li>
<li> <p><code>published_on</code>
</p>
</li>
<li> <p><code>last_updated</code>
</p>
</li>
<li> <p><code>from_date</code>
</p>
</li>
<li> <p><code>to_date</code>
</p>
</li>
<li> <p><code>routes</code>
</p>
</li>
<li> <p><code>stops</code>
</p>
</li>
<li> <p><code>colour</code>
</p>
</li>
<li> <p><code>display_on_board</code>
</p>
</li>
<li> <p><code>display_status</code>
</p>
</li></ul>


<hr>
<h2 id='assert_correct_attributes'>Assert that the API has returned the expected attributes</h2><span id='topic+assert_correct_attributes'></span>

<h3>Description</h3>

<p>The attributes returned by the API calls should be follow the API schema.
This function compares received attributes against a vector of expected
attributes, and returns an error if the two do not match. Unfortunately,
there is no easy fix for this error: the package developer(s) must be
notified, so that they can align the functions against the API schema.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_correct_attributes(received_attributes, expected_attributes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assert_correct_attributes_+3A_received_attributes">received_attributes</code></td>
<td>
<p>A character vector of attributes, in order.</p>
</td></tr>
<tr><td><code id="assert_correct_attributes_+3A_expected_attributes">expected_attributes</code></td>
<td>
<p>A character vector of expected attributes, in
order.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An error if the column names are not as expected.
</p>

<hr>
<h2 id='cached_route_types'>Retrieve route types, using cached values if possible</h2><span id='topic+cached_route_types'></span>

<h3>Description</h3>

<p>Route types will change extraordinarily rarely &mdash; this would require PTV to
add a new route type akin to &quot;train&quot; or &quot;bus&quot;. To avoid querying the API too
much, we prefer to use cached values for route type translation wherever
possible. This function effectively wraps <code>route_types</code>, returning cached
results if possible or caching results otherwise. Note that if a user
specifically calls <code>route_types</code> then we do <em>not</em> return cached results.
</p>
<p>We use the <code>pkg_env</code> as a cache, which is an environment created on package
load. This is not truly private &mdash; users could still access this as an
internal value. But it's effectively &quot;out of the way&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cached_route_types(
  user_id = determine_user_id(),
  api_key = determine_api_key()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cached_route_types_+3A_user_id">user_id</code></td>
<td>
<p>Integer or character. A user ID or devid provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="cached_route_types_+3A_api_key">api_key</code></td>
<td>
<p>Character. An API key, with dashes, provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named integer vector in which the values are the route type
descriptions, and the names of the vector are the route type numbers.
</p>

<hr>
<h2 id='convert_to_melbourne_time'>Convert a datetime returned by the PTV API into Melbourne time</h2><span id='topic+convert_to_melbourne_time'></span>

<h3>Description</h3>

<p>Convert a datetime returned by the PTV API into Melbourne time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_to_melbourne_time(datetime)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_to_melbourne_time_+3A_datetime">datetime</code></td>
<td>
<p>A datetime returned by the PTV API</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A datetime in the Melbourne timezone.
</p>

<hr>
<h2 id='departure_to_tibble'>Convert a single departure to a tibble</h2><span id='topic+departure_to_tibble'></span>

<h3>Description</h3>

<p>This function is designed to parse the content returned by the interior
steps of the <code>departures</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>departure_to_tibble(departure)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="departure_to_tibble_+3A_departure">departure</code></td>
<td>
<p>A departure, as a list, returned by the <code>departures</code> API
call.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble consisting of the following columns: </p>

<ul>
<li> <p><code>stop_id</code>
</p>
</li>
<li> <p><code>route_id</code>
</p>
</li>
<li> <p><code>run_id</code> (deprecated, use <code>run_ref</code> instead)
</p>
</li>
<li> <p><code>run_ref</code>
</p>
</li>
<li> <p><code>direction_id</code>
</p>
</li>
<li> <p><code>disruption_ids</code>
</p>
</li>
<li> <p><code>scheduled_departure</code>
</p>
</li>
<li> <p><code>estimated_departure</code>
</p>
</li>
<li> <p><code>at_platform</code>
</p>
</li>
<li> <p><code>platform_number</code>
</p>
</li>
<li> <p><code>flags</code>
</p>
</li>
<li> <p><code>departure_sequence</code>
</p>
</li></ul>


<hr>
<h2 id='departures'>Departures from a given stop</h2><span id='topic+departures'></span>

<h3>Description</h3>

<p><code>departures</code> retrieves all upcoming departures for a given stop ID and route
type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>departures(
  stop_id,
  route_type,
  route_id = NULL,
  direction_id = NULL,
  platform_numbers = NULL,
  departs = Sys.time(),
  look_backwards = FALSE,
  max_results = 5,
  include_cancelled = FALSE,
  validate_results = TRUE,
  user_id = determine_user_id(),
  api_key = determine_api_key()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="departures_+3A_stop_id">stop_id</code></td>
<td>
<p>An integer stop ID returned by the <code>stops_on_route</code> or
<code>stops_nearby</code> functions.</p>
</td></tr>
<tr><td><code id="departures_+3A_route_type">route_type</code></td>
<td>
<p>A route type which can be provided either as a non-negative
integer code, or as a character: &quot;Tram&quot;, &quot;Train&quot;, &quot;Bus&quot;, &quot;Vline&quot; or &quot;Night
Bus&quot;. Character inputs are not case-sensitive. Use the
<code><a href="#topic+route_types">route_types</a></code> function to extract a vector of all route types.</p>
</td></tr>
<tr><td><code id="departures_+3A_route_id">route_id</code></td>
<td>
<p>Optionally filter by a route ID. These can be obtained with
the <code>routes</code> function.</p>
</td></tr>
<tr><td><code id="departures_+3A_direction_id">direction_id</code></td>
<td>
<p>Optionally filter by a direction ID. These can be
obtained with the <code><a href="#topic+directions_on_route">directions_on_route</a></code> function.</p>
</td></tr>
<tr><td><code id="departures_+3A_platform_numbers">platform_numbers</code></td>
<td>
<p>Character vector. Optionally filter results by
platform number. Despite the name, these are characters.</p>
</td></tr>
<tr><td><code id="departures_+3A_departs">departs</code></td>
<td>
<p>POSIXct or Character. Optionally filter results to departures
on or after the given value, according to either scheduled or estimated
departure time. Characters are automatically converted to datetimes, and
are assumed to be given as Melbourne time. Defaults to the current system
time.</p>
</td></tr>
<tr><td><code id="departures_+3A_look_backwards">look_backwards</code></td>
<td>
<p>Boolean. Whether to look before <code>departs</code>. Use with
caution (see Details). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="departures_+3A_max_results">max_results</code></td>
<td>
<p>Integer. The maximum number of departures to return for
each route_id. Departures are ordered by estimated departure time, when
available, and scheduled departure time otherwise. When set to 0, all
departures after the given <code>departs</code> for the entire day are shown, and
potentially some in the early hours of the next morning. Defaults to 5.</p>
</td></tr>
<tr><td><code id="departures_+3A_include_cancelled">include_cancelled</code></td>
<td>
<p>Logical. Whether results should be returned if they
have been cancelled. Metropolitan train services only. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="departures_+3A_validate_results">validate_results</code></td>
<td>
<p>Boolean. If TRUE (the default), will apply additional
filters to ensure that the arguments to <code>departs</code>, <code>max_results</code>, and
<code>route_id</code> are respected if given.</p>
</td></tr>
<tr><td><code id="departures_+3A_user_id">user_id</code></td>
<td>
<p>Integer or character. A user ID or devid provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="departures_+3A_api_key">api_key</code></td>
<td>
<p>Character. An API key, with dashes, provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Filtering departures: The API supports filtering by departure time,
to show the departures after the given time. However, its behaviour is
unpredictable, returning departures around the given time, both before and
after. We apply an additional filter once the results are retrieved to
ensure that only departures at or after the given <code>departs</code> datetime are
shown.
</p>
<p>It's not clear what functionality <code>look_backwards</code> has. It's included here
regardless. Moreover, it's not clear how the API treats <code>route_id</code> or
<code>max_results</code>. We filter the results after retrieval, to ensure that
<code>departs</code>, <code>max_results</code>, and <code>route_id</code> are respected. This additional
validation can be disabled by setting <code>validate_results = TRUE</code>.
</p>


<h3>Value</h3>

<p>A tibble consisting of the following columns: </p>

<ul>
<li> <p><code>stop_id</code>
</p>
</li>
<li> <p><code>route_id</code>
</p>
</li>
<li> <p><code>run_id</code> (deprecated, use <code>run_ref</code> instead)
</p>
</li>
<li> <p><code>run_ref</code>
</p>
</li>
<li> <p><code>direction_id</code>
</p>
</li>
<li> <p><code>disruption_ids</code>
</p>
</li>
<li> <p><code>scheduled_departure</code>
</p>
</li>
<li> <p><code>estimated_departure</code>
</p>
</li>
<li> <p><code>at_platform</code>
</p>
</li>
<li> <p><code>platform_number</code>
</p>
</li>
<li> <p><code>flags</code>
</p>
</li>
<li> <p><code>departure_sequence</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
departures(stop_id = 1071, route_type = "Train")
departures(stop_id = 1071, route_type = 0)

departures(
  stop_id = 1071,
  route_type = "Train",
  platform_numbers = c(4, 5)
)

departures(
  stop_id = 1071,
  route_type = "Train",
  route_id = 6
)

departures(
  stop_id = 1071,
  route_type = "Train",
  departs = "2020-06-23 17:05:00"
)


## End(Not run)

</code></pre>

<hr>
<h2 id='describe_route_type'>Convert a numeric route type to a human-friendly description</h2><span id='topic+describe_route_type'></span>

<h3>Description</h3>

<p>This function effectively wraps the results of <code><a href="#topic+route_types">route_types</a></code> to
translate a route type to a human-readable form, such as translating <code>0</code> to
<code>"Train"</code>. This function is <em>not</em> vectorised.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>describe_route_type(
  route_type,
  user_id = determine_user_id(),
  api_key = determine_api_key()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="describe_route_type_+3A_route_type">route_type</code></td>
<td>
<p>Atomic integer or character.</p>
</td></tr>
<tr><td><code id="describe_route_type_+3A_user_id">user_id</code></td>
<td>
<p>Integer or character. A user ID or devid provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="describe_route_type_+3A_api_key">api_key</code></td>
<td>
<p>Character. An API key, with dashes, provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character
</p>

<hr>
<h2 id='directions'>Directions for a given direction ID</h2><span id='topic+directions'></span>

<h3>Description</h3>

<p>This function returns all directions with a given ID. Directions that share
an ID are not necessarily related, especially if not filtering by route type.
It's advised to use to the <code><a href="#topic+directions_on_route">directions_on_route</a></code> function to
search for directions of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>directions(
  direction_id,
  route_type = NULL,
  user_id = determine_user_id(),
  api_key = determine_api_key()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="directions_+3A_direction_id">direction_id</code></td>
<td>
<p>Integer.</p>
</td></tr>
<tr><td><code id="directions_+3A_route_type">route_type</code></td>
<td>
<p>Optionally filter results by a route type. A route type can
be provided either as a non-negative integer code, or as a character:
&quot;Tram&quot;, &quot;Train&quot;, &quot;Bus&quot;, &quot;Vline&quot; or &quot;Night Bus&quot;. Character inputs are not
case-sensitive. Use the <code><a href="#topic+route_types">route_types</a></code> function to extract a
vector of all route types.</p>
</td></tr>
<tr><td><code id="directions_+3A_user_id">user_id</code></td>
<td>
<p>Integer or character. A user ID or devid provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="directions_+3A_api_key">api_key</code></td>
<td>
<p>Character. An API key, with dashes, provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble consisting of the following columns: </p>

<ul>
<li> <p><code>direction_id</code>
</p>
</li>
<li> <p><code>direction_name</code>,
</p>
</li>
<li> <p><code>route_id</code>
</p>
</li>
<li> <p><code>route_type</code>
</p>
</li>
<li> <p><code>route_type_description</code>
</p>
</li>
<li> <p><code>route_direction_description</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
directions(direction_id = 5)
directions(direction_id = 5, route_type = "Train")
directions(direction_id = 5, route_type = 0)

## End(Not run)

</code></pre>

<hr>
<h2 id='directions_on_route'>Directions on a given route</h2><span id='topic+directions_on_route'></span>

<h3>Description</h3>

<p>Directions on a given route
</p>


<h3>Usage</h3>

<pre><code class='language-R'>directions_on_route(
  route_id,
  user_id = determine_user_id(),
  api_key = determine_api_key()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="directions_on_route_+3A_route_id">route_id</code></td>
<td>
<p>Integer. These can be listed and described with the
<code><a href="#topic+routes">routes</a></code> function.</p>
</td></tr>
<tr><td><code id="directions_on_route_+3A_user_id">user_id</code></td>
<td>
<p>Integer or character. A user ID or devid provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="directions_on_route_+3A_api_key">api_key</code></td>
<td>
<p>Character. An API key, with dashes, provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble consisting of the following columns: </p>

<ul>
<li> <p><code>direction_id</code>
</p>
</li>
<li> <p><code>direction_name</code>,
</p>
</li>
<li> <p><code>route_id</code>
</p>
</li>
<li> <p><code>route_type</code>
</p>
</li>
<li> <p><code>route_type_description</code>
</p>
</li>
<li> <p><code>route_direction_description</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
directions_on_route(6)

## End(Not run)
</code></pre>

<hr>
<h2 id='disruption_information'>Information on a particular disruption</h2><span id='topic+disruption_information'></span>

<h3>Description</h3>

<p>This function can be used when the integer disruption ID is already known.
This can be searched for with either <code>disruptions</code>,
<code>disruptions_on_route</code>, or <code>disruptions_at_stop</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disruption_information(
  disruption_id,
  user_id = determine_user_id(),
  api_key = determine_api_key()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disruption_information_+3A_disruption_id">disruption_id</code></td>
<td>
<p>Integer.</p>
</td></tr>
<tr><td><code id="disruption_information_+3A_user_id">user_id</code></td>
<td>
<p>Integer or character. A user ID or devid provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="disruption_information_+3A_api_key">api_key</code></td>
<td>
<p>Character. An API key, with dashes, provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the following columns: </p>

<ul>
<li> <p><code>disruption_mode</code>
</p>
</li>
<li> <p><code>disruption_mode_description</code>
</p>
</li>
<li> <p><code>disruption_id</code>
</p>
</li>
<li> <p><code>title</code>
</p>
</li>
<li> <p><code>url</code>
</p>
</li>
<li> <p><code>description</code>
</p>
</li>
<li> <p><code>disruption_status</code>
</p>
</li>
<li> <p><code>disruption_type</code>
</p>
</li>
<li> <p><code>published_on</code>
</p>
</li>
<li> <p><code>last_updated</code>
</p>
</li>
<li> <p><code>from_date</code>
</p>
</li>
<li> <p><code>to_date</code>
</p>
</li>
<li> <p><code>routes</code>
</p>
</li>
<li> <p><code>stops</code>
</p>
</li>
<li> <p><code>colour</code>
</p>
</li>
<li> <p><code>display_on_board</code>
</p>
</li>
<li> <p><code>display_status</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
disruption_information(206639)

## End(Not run)

</code></pre>

<hr>
<h2 id='disruption_modes'>Retrieve a translation from description mode number to description mode name</h2><span id='topic+disruption_modes'></span>

<h3>Description</h3>

<p>Disruption mode types (eg. &quot;metro_train&quot;, &quot;metro_tram&quot;, &quot;school_bus&quot;, &quot;taxi&quot;)
have corresponding integer IDs. This function retrieves a named vector in
which the values are the disruption mode descriptions, and the names of the
vector are the description mode numbers. Note that disruption mode names are
in snake case, that is, all lower case with underscores between words.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disruption_modes(user_id = determine_user_id(), api_key = determine_api_key())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disruption_modes_+3A_user_id">user_id</code></td>
<td>
<p>Integer or character. A user ID or devid provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="disruption_modes_+3A_api_key">api_key</code></td>
<td>
<p>Character. An API key, with dashes, provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector in which the values are the disruption mode
descriptions, and the names of the vector are the description mode numbers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: disruption_modes()

</code></pre>

<hr>
<h2 id='disruption_to_tibble'>Convert a single disruption to a tibble</h2><span id='topic+disruption_to_tibble'></span>

<h3>Description</h3>

<p>This function is designed to parse the content returned by the interior
steps of the <code>disruptions_on_route</code> and <code>disruptions_at_stop</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disruption_to_tibble(disruption)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disruption_to_tibble_+3A_disruption">disruption</code></td>
<td>
<p>A disruption, as a list, returned by the <code>disruptions</code> API
call.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the following columns: </p>

<ul>
<li> <p><code>disruption_id</code>
</p>
</li>
<li> <p><code>title</code>
</p>
</li>
<li> <p><code>url</code>
</p>
</li>
<li> <p><code>description</code>
</p>
</li>
<li> <p><code>disruption_status</code>
</p>
</li>
<li> <p><code>disruption_type</code>
</p>
</li>
<li> <p><code>published_on</code>
</p>
</li>
<li> <p><code>last_updated</code>
</p>
</li>
<li> <p><code>from_date</code>
</p>
</li>
<li> <p><code>to_date</code>
</p>
</li>
<li> <p><code>routes</code>
</p>
</li>
<li> <p><code>stops</code>
</p>
</li>
<li> <p><code>colour</code>
</p>
</li>
<li> <p><code>display_on_board</code>
</p>
</li>
<li> <p><code>display_status</code>
</p>
</li></ul>


<hr>
<h2 id='disruptions'>Information for all disruptions</h2><span id='topic+disruptions'></span>

<h3>Description</h3>

<p>Information for all disruptions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disruptions(
  route_types = NULL,
  disruption_modes = NULL,
  disruption_status = NULL,
  user_id = determine_user_id(),
  api_key = determine_api_key()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disruptions_+3A_route_types">route_types</code></td>
<td>
<p>Integer or character vector. Optionally filter by a vector
of route types. A route type can be provided either as a non-negative
integer code, or as a character: &quot;Tram&quot;, &quot;Train&quot;, &quot;Bus&quot;, &quot;Vline&quot; or &quot;Night
Bus&quot;. Character inputs are not case-sensitive. Use the
<code><a href="#topic+route_types">route_types</a></code> function to extract a vector of all route types.
The filter is applied to the disruption mode, rather than the routes that
are affected by the disruption. For example, filtering by the &quot;train&quot; route
type will restrict the disruptions returned to those with a mode
corresponding to &quot;metro_train&quot;.</p>
</td></tr>
<tr><td><code id="disruptions_+3A_disruption_modes">disruption_modes</code></td>
<td>
<p>Integer vector. Optionally filter by disruption
modes. For a full list of modes and their corresponding descriptions, use
the <code>disruptions_modes</code> function.</p>
</td></tr>
<tr><td><code id="disruptions_+3A_disruption_status">disruption_status</code></td>
<td>
<p>Character. Can be used to filter to either &quot;current&quot;
or &quot;planned&quot; disruptions. Defaults to NULL, in which case no filter is
applied.</p>
</td></tr>
<tr><td><code id="disruptions_+3A_user_id">user_id</code></td>
<td>
<p>Integer or character. A user ID or devid provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="disruptions_+3A_api_key">api_key</code></td>
<td>
<p>Character. An API key, with dashes, provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the following columns: </p>

<ul>
<li> <p><code>disruption_mode</code>
</p>
</li>
<li> <p><code>disruption_mode_description</code>
</p>
</li>
<li> <p><code>disruption_id</code>
</p>
</li>
<li> <p><code>title</code>
</p>
</li>
<li> <p><code>url</code>
</p>
</li>
<li> <p><code>description</code>
</p>
</li>
<li> <p><code>disruption_status</code>
</p>
</li>
<li> <p><code>disruption_type</code>
</p>
</li>
<li> <p><code>published_on</code>
</p>
</li>
<li> <p><code>last_updated</code>
</p>
</li>
<li> <p><code>from_date</code>
</p>
</li>
<li> <p><code>to_date</code>
</p>
</li>
<li> <p><code>routes</code>
</p>
</li>
<li> <p><code>stops</code>
</p>
</li>
<li> <p><code>colour</code>
</p>
</li>
<li> <p><code>display_on_board</code>
</p>
</li>
<li> <p><code>display_status</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
disruptions()
disruptions(route_types = c("Train", "Tram"))
disruptions(disruption_modes = c(0, 1))
disruptions(disruption_status = "current")

## End(Not run)

</code></pre>

<hr>
<h2 id='disruptions_at_stop'>Disruptions at a given stop</h2><span id='topic+disruptions_at_stop'></span>

<h3>Description</h3>

<p>Disruptions at a given stop
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disruptions_at_stop(
  stop_id,
  disruption_status = NULL,
  user_id = determine_user_id(),
  api_key = determine_api_key()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disruptions_at_stop_+3A_stop_id">stop_id</code></td>
<td>
<p>Integer stop ID.</p>
</td></tr>
<tr><td><code id="disruptions_at_stop_+3A_disruption_status">disruption_status</code></td>
<td>
<p>Character. Can be used to filter to either &quot;current&quot;
or &quot;planned&quot; disruptions. Defaults to NULL, in which case no filter is
applied.</p>
</td></tr>
<tr><td><code id="disruptions_at_stop_+3A_user_id">user_id</code></td>
<td>
<p>Integer or character. A user ID or devid provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="disruptions_at_stop_+3A_api_key">api_key</code></td>
<td>
<p>Character. An API key, with dashes, provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the following columns: </p>

<ul>
<li> <p><code>disruption_mode</code>
</p>
</li>
<li> <p><code>disruption_mode_description</code>
</p>
</li>
<li> <p><code>disruption_id</code>
</p>
</li>
<li> <p><code>title</code>
</p>
</li>
<li> <p><code>url</code>
</p>
</li>
<li> <p><code>description</code>
</p>
</li>
<li> <p><code>disruption_status</code>
</p>
</li>
<li> <p><code>disruption_type</code>
</p>
</li>
<li> <p><code>published_on</code>
</p>
</li>
<li> <p><code>last_updated</code>
</p>
</li>
<li> <p><code>from_date</code>
</p>
</li>
<li> <p><code>to_date</code>
</p>
</li>
<li> <p><code>routes</code>
</p>
</li>
<li> <p><code>stops</code>
</p>
</li>
<li> <p><code>colour</code>
</p>
</li>
<li> <p><code>display_on_board</code>
</p>
</li>
<li> <p><code>display_status</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
disruptions_at_stop(1071)
disruptions_at_stop(1071, disruption_status = "current")

## End(Not run)

</code></pre>

<hr>
<h2 id='disruptions_on_route'>Disruptions on a given route</h2><span id='topic+disruptions_on_route'></span>

<h3>Description</h3>

<p>Disruptions on a given route
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disruptions_on_route(
  route_id,
  stop_id = NULL,
  disruption_status = NULL,
  user_id = determine_user_id(),
  api_key = determine_api_key()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disruptions_on_route_+3A_route_id">route_id</code></td>
<td>
<p>Integer. These can be listed and described with the
<code><a href="#topic+routes">routes</a></code> function.</p>
</td></tr>
<tr><td><code id="disruptions_on_route_+3A_stop_id">stop_id</code></td>
<td>
<p>Integer. Optionally filter results to a specific stop ID.
These can be searched for with the <code>stops_on_route</code> and <code>stops_nearby</code>
functions.</p>
</td></tr>
<tr><td><code id="disruptions_on_route_+3A_disruption_status">disruption_status</code></td>
<td>
<p>Character. Can be used to filter to either &quot;current&quot;
or &quot;planned&quot; disruptions. Defaults to NULL, in which case no filter is
applied.</p>
</td></tr>
<tr><td><code id="disruptions_on_route_+3A_user_id">user_id</code></td>
<td>
<p>Integer or character. A user ID or devid provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="disruptions_on_route_+3A_api_key">api_key</code></td>
<td>
<p>Character. An API key, with dashes, provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the following columns: </p>

<ul>
<li> <p><code>disruption_mode</code>
</p>
</li>
<li> <p><code>disruption_mode_description</code>
</p>
</li>
<li> <p><code>disruption_id</code>
</p>
</li>
<li> <p><code>title</code>
</p>
</li>
<li> <p><code>url</code>
</p>
</li>
<li> <p><code>description</code>
</p>
</li>
<li> <p><code>disruption_status</code>
</p>
</li>
<li> <p><code>disruption_type</code>
</p>
</li>
<li> <p><code>published_on</code>
</p>
</li>
<li> <p><code>last_updated</code>
</p>
</li>
<li> <p><code>from_date</code>
</p>
</li>
<li> <p><code>to_date</code>
</p>
</li>
<li> <p><code>routes</code>
</p>
</li>
<li> <p><code>stops</code>
</p>
</li>
<li> <p><code>colour</code>
</p>
</li>
<li> <p><code>display_on_board</code>
</p>
</li>
<li> <p><code>display_status</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
disruptions_on_route(6)
disruptions_on_route(6, stop_id = 1071)
disruptions_on_route(6, disruption_status = "current")

## End(Not run)

</code></pre>

<hr>
<h2 id='fare_estimate'>Calculate a fare estimate between zones</h2><span id='topic+fare_estimate'></span>

<h3>Description</h3>

<p>Retrieve fare information for a journey through the given zones. Also
supports journey touch on and off times, to accommodate for discounts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fare_estimate(
  min_zone,
  max_zone,
  journey_touch_on = NULL,
  journey_touch_off = NULL,
  journey_in_free_tram_zone = FALSE,
  travelled_route_types = NULL,
  user_id = determine_user_id(),
  api_key = determine_api_key()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fare_estimate_+3A_min_zone">min_zone</code></td>
<td>
<p>Integer. Minimum zone travelled through.</p>
</td></tr>
<tr><td><code id="fare_estimate_+3A_max_zone">max_zone</code></td>
<td>
<p>Integer. Maximum zone travelled through.</p>
</td></tr>
<tr><td><code id="fare_estimate_+3A_journey_touch_on">journey_touch_on</code>, <code id="fare_estimate_+3A_journey_touch_off">journey_touch_off</code></td>
<td>
<p>POSIXct or Character. Optionally
filter results to a journey time. Values to both must be provided.
Characters are automatically converted to datetimes, and are assumed to be
given as Melbourne time.</p>
</td></tr>
<tr><td><code id="fare_estimate_+3A_journey_in_free_tram_zone">journey_in_free_tram_zone</code></td>
<td>
<p>Boolean. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fare_estimate_+3A_travelled_route_types">travelled_route_types</code></td>
<td>
<p>Integer or character vector. Optionally filter
by a vector of route types. A route type can be provided either as a
non-negative integer code, or as a character: &quot;Tram&quot;, &quot;Train&quot;, &quot;Bus&quot;,
&quot;Vline&quot; or &quot;Night Bus&quot;. Character inputs are not case-sensitive. Use the
<code><a href="#topic+route_types">route_types</a></code> function to extract a vector of all route types.</p>
</td></tr>
<tr><td><code id="fare_estimate_+3A_user_id">user_id</code></td>
<td>
<p>Integer or character. A user ID or devid provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="fare_estimate_+3A_api_key">api_key</code></td>
<td>
<p>Character. An API key, with dashes, provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame consisting of one row for each <code>passenger_type</code>, and the
following columns: </p>

<ul>
<li> <p><code>min_zone</code>
</p>
</li>
<li> <p><code>max_zone</code>
</p>
</li>
<li> <p><code>unique_zones</code>
</p>
</li>
<li> <p><code>early_bird</code>
</p>
</li>
<li> <p><code>free_tram_zone</code>
</p>
</li>
<li> <p><code>weekend_journey</code>
</p>
</li>
<li> <p><code>passenger_type</code>
</p>
</li>
<li> <p><code>fare_2_hour_peak</code>
</p>
</li>
<li> <p><code>fare_2_hour_off_peak</code>
</p>
</li>
<li> <p><code>fare_daily_peak</code>
</p>
</li>
<li> <p><code>fare_daily_off_peak</code>
</p>
</li>
<li> <p><code>pass_7_days</code>
</p>
</li>
<li> <p><code>pass_28_to_69_day_per_day</code>
</p>
</li>
<li> <p><code>pass_70_plus_day_per_day</code>
</p>
</li>
<li> <p><code>weekend_cap</code>
</p>
</li>
<li> <p><code>holiday_cap</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fare_estimate(min_zone = 1, max_zone = 2)

fare_estimate(min_zone = 1, max_zone = 1, journey_in_free_tram_zone = TRUE)

fare_estimate(
  min_zone = 1,
  max_zone = 2,
  travelled_route_types = c("Train", "Tram")
)

fare_estimate(
  min_zone = 1,
  max_zone = 2,
  journey_touch_on = "2020-06-21 07:31:00",
  journey_touch_off = "2020-06-21 08:45:00"
 )

## End(Not run)

</code></pre>

<hr>
<h2 id='filter_departures'>Filter parsed departures content according to user input</h2><span id='topic+filter_departures'></span>

<h3>Description</h3>

<p>The departures API call isn't always reliable. This function will take a
tibble of parsed departures content and filter it according to the following
inputs, if they are not <code>NULL</code>: </p>

<ul>
<li><p> Only departures after the given <code>departs</code>
</p>
</li>
<li><p> Only departures on the given route ID
</p>
</li>
<li><p> The next max_results departures per route ID, if <code>max_results</code> is not
0.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>filter_departures(parsed, departs = NULL, route_id = NULL, max_results = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_departures_+3A_parsed">parsed</code></td>
<td>
<p>A tibble of parsed departures content.</p>
</td></tr>
<tr><td><code id="filter_departures_+3A_departs">departs</code></td>
<td>
<p>POSIXct in the &quot;Australia/Melbourne&quot; time zone.</p>
</td></tr>
<tr><td><code id="filter_departures_+3A_route_id">route_id</code></td>
<td>
<p>Integer.</p>
</td></tr>
<tr><td><code id="filter_departures_+3A_max_results">max_results</code></td>
<td>
<p>Integer max results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A filtered tibble.
</p>

<hr>
<h2 id='generate_request_url'>Generate a URL with devid and signature</h2><span id='topic+generate_request_url'></span>

<h3>Description</h3>

<p>Generate a URL with devid and signature
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_request_url(
  request,
  user_id = determine_user_id(),
  api_key = determine_api_key()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_request_url_+3A_request">request</code></td>
<td>
<p>Character. A path without base URL or version, such as
&quot;routes&quot; or &quot;stop/1071&quot;.</p>
</td></tr>
<tr><td><code id="generate_request_url_+3A_user_id">user_id</code></td>
<td>
<p>Integer or character. A user ID or devid provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="generate_request_url_+3A_api_key">api_key</code></td>
<td>
<p>Character. An API key, with dashes, provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A complete URL character that can be queried with httr
</p>

<hr>
<h2 id='geopath_to_tibble'>Convert a single geopath to a tibble</h2><span id='topic+geopath_to_tibble'></span>

<h3>Description</h3>

<p>This function is designed to parse the <code>geopath</code> content returned by the
interior steps of some functions. If geopath data is requested, that content
will contain a list of <code>geopaths</code> for each route. This function is designed
to parse <em>one</em> of those geopaths into a tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geopath_to_tibble(geopath)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geopath_to_tibble_+3A_geopath">geopath</code></td>
<td>
<p>A <code>geopaths</code> object, as a list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble of routes, with the following columns:
</p>

<ul>
<li> <p><code>direction_id</code>
</p>
</li>
<li> <p><code>valid_from</code>
</p>
</li>
<li> <p><code>valid_to</code>
</p>
</li>
<li> <p><code>paths</code>
</p>
</li></ul>


<hr>
<h2 id='make_url_friendly'>Convert an input to a form that can be used in a URL.</h2><span id='topic+make_url_friendly'></span>

<h3>Description</h3>

<p>Before a character can be used as part of a html, spaces must be converted to
&quot;%20&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_url_friendly(input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_url_friendly_+3A_input">input</code></td>
<td>
<p>Character.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character.
</p>

<hr>
<h2 id='map_and_rbind'>Map and rbind a list of data frames</h2><span id='topic+map_and_rbind'></span>

<h3>Description</h3>

<p>This function is a simple combination of <code>purrr::map</code> and <code>purrr::reduce</code>
using <code>rbind</code>. This differs from <code>purrr::map_dfr</code>, which uses
<code>dplyr::map_dfr</code> and therefore introduces <code>dplyr</code> as a dependency. If the
provided list is empty, then an empty tibble will be returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_and_rbind(.x, .f, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_and_rbind_+3A_.x">.x</code></td>
<td>
<p>A list of data frames or tibbles.</p>
</td></tr>
<tr><td><code id="map_and_rbind_+3A_.f">.f</code></td>
<td>
<p>A function.</p>
</td></tr>
<tr><td><code id="map_and_rbind_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame or tibble.
</p>

<hr>
<h2 id='outlet_to_tibble'>Convert a single outlet to a tibble</h2><span id='topic+outlet_to_tibble'></span>

<h3>Description</h3>

<p>This function is designed to parse the content returned by the interior
steps of the <code><a href="#topic+outlets">outlets</a></code> and <code><a href="#topic+outlets_nearby">outlets_nearby</a></code>
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outlet_to_tibble(outlet)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="outlet_to_tibble_+3A_outlet">outlet</code></td>
<td>
<p>An outlet, as a list, returned by the <code><a href="#topic+outlets">outlets</a></code> API
call.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the following columns: </p>

<ul>
<li> <p><code>outlet_slid_spid</code>
</p>
</li>
<li> <p><code>outlet_name</code>
</p>
</li>
<li> <p><code>outlet_business</code>
</p>
</li>
<li> <p><code>outlet_latitude</code>
</p>
</li>
<li> <p><code>outlet_longitude</code>
</p>
</li>
<li> <p><code>outlet_suburb</code>
</p>
</li>
<li> <p><code>outlet_postcode</code>
</p>
</li>
<li> <p><code>outlet_business_hour_mon</code>
</p>
</li>
<li> <p><code>outlet_business_hour_tue</code>
</p>
</li>
<li> <p><code>outlet_business_hour_wed</code>
</p>
</li>
<li> <p><code>outlet_business_hour_thu</code>
</p>
</li>
<li> <p><code>outlet_business_hour_fri</code>
</p>
</li>
<li> <p><code>outlet_business_hour_sat</code>
</p>
</li>
<li> <p><code>outlet_business_hour_sun</code>
</p>
</li>
<li> <p><code>outlet_notes</code>
</p>
</li></ul>


<hr>
<h2 id='outlets'>Information for all outlets</h2><span id='topic+outlets'></span>

<h3>Description</h3>

<p>Information for all outlets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outlets(user_id = determine_user_id(), api_key = determine_api_key())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="outlets_+3A_user_id">user_id</code></td>
<td>
<p>Integer or character. A user ID or devid provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="outlets_+3A_api_key">api_key</code></td>
<td>
<p>Character. An API key, with dashes, provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>outlet_name</code> reported here is more accurately described as an outlet
<em>address</em>. We keep the <code>outlet_name</code> column name as this is how the PTV API
describes it.
</p>
<p>The business hours are reported as characters. Usually they take on
a format of &quot;8.00AM - 10.00PM&quot;, but there variants such as &quot;7.30AM - 11.00AM
and 1.30PM - 6.00PM&quot;. For days on which an outlet is closed, the opening
hours are usually reported as &quot;CLOSED&quot;, but can also be an empty character.
Some opening hours are &quot;24 Hours&quot;. These fields are also filled with missing
values and empty characters.
</p>


<h3>Value</h3>

<p>A tibble with the following columns: </p>

<ul>
<li> <p><code>outlet_slid_spid</code>
</p>
</li>
<li> <p><code>outlet_name</code>
</p>
</li>
<li> <p><code>outlet_business</code>
</p>
</li>
<li> <p><code>outlet_latitude</code>
</p>
</li>
<li> <p><code>outlet_longitude</code>
</p>
</li>
<li> <p><code>outlet_suburb</code>
</p>
</li>
<li> <p><code>outlet_postcode</code>
</p>
</li>
<li> <p><code>outlet_business_hour_mon</code>
</p>
</li>
<li> <p><code>outlet_business_hour_tue</code>
</p>
</li>
<li> <p><code>outlet_business_hour_wed</code>
</p>
</li>
<li> <p><code>outlet_business_hour_thu</code>
</p>
</li>
<li> <p><code>outlet_business_hour_fri</code>
</p>
</li>
<li> <p><code>outlet_business_hour_sat</code>
</p>
</li>
<li> <p><code>outlet_business_hour_sun</code>
</p>
</li>
<li> <p><code>outlet_notes</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
outlets()

## End(Not run)

</code></pre>

<hr>
<h2 id='outlets_nearby'>Information for outlets near a given location</h2><span id='topic+outlets_nearby'></span>

<h3>Description</h3>

<p>Information for outlets near a given location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outlets_nearby(
  latitude,
  longitude,
  max_distance = NULL,
  max_results = 30,
  user_id = determine_user_id(),
  api_key = determine_api_key()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="outlets_nearby_+3A_latitude">latitude</code></td>
<td>
<p>Numeric. Latitude in decimal degrees. For example, Flinders
Street Station is at approximately -37.8183 latitude.</p>
</td></tr>
<tr><td><code id="outlets_nearby_+3A_longitude">longitude</code></td>
<td>
<p>Numeric. Longitude in decimal degrees. For example, Flinders
Street Station is at approximately 144.9671 longitude.</p>
</td></tr>
<tr><td><code id="outlets_nearby_+3A_max_distance">max_distance</code></td>
<td>
<p>Integer. Optionally filter by maximum distance from the
given location, in metres.</p>
</td></tr>
<tr><td><code id="outlets_nearby_+3A_max_results">max_results</code></td>
<td>
<p>Integer. Defaults to 30. Caps the number of results
returned.</p>
</td></tr>
<tr><td><code id="outlets_nearby_+3A_user_id">user_id</code></td>
<td>
<p>Integer or character. A user ID or devid provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="outlets_nearby_+3A_api_key">api_key</code></td>
<td>
<p>Character. An API key, with dashes, provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>outlet_name</code> reported here is more accurately described as an outlet
<em>address</em>. We keep the <code>outlet_name</code> column name as this is how the PTV API
describes it.
</p>
<p>The business hours are reported as characters. Usually they take on
a format of &quot;8.00AM - 10.00PM&quot;, but there variants such as &quot;7.30AM - 11.00AM
and 1.30PM - 6.00PM&quot;. For days on which an outlet is closed, the opening
hours are usually reported as &quot;CLOSED&quot;, but can also be an empty character.
Some opening hours are &quot;24 Hours&quot;. These fields are also filled with missing
values and empty characters.
</p>


<h3>Value</h3>

<p>A tibble with the following columns: </p>

<ul>
<li> <p><code>outlet_slid_spid</code>
</p>
</li>
<li> <p><code>outlet_name</code>
</p>
</li>
<li> <p><code>outlet_business</code>
</p>
</li>
<li> <p><code>outlet_latitude</code>
</p>
</li>
<li> <p><code>outlet_longitude</code>
</p>
</li>
<li> <p><code>outlet_suburb</code>
</p>
</li>
<li> <p><code>outlet_postcode</code>
</p>
</li>
<li> <p><code>outlet_business_hour_mon</code>
</p>
</li>
<li> <p><code>outlet_business_hour_tue</code>
</p>
</li>
<li> <p><code>outlet_business_hour_wed</code>
</p>
</li>
<li> <p><code>outlet_business_hour_thu</code>
</p>
</li>
<li> <p><code>outlet_business_hour_fri</code>
</p>
</li>
<li> <p><code>outlet_business_hour_sat</code>
</p>
</li>
<li> <p><code>outlet_business_hour_sun</code>
</p>
</li>
<li> <p><code>outlet_notes</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
outlets_nearby(latitude = -37.8183, longitude = 144.9671)

## End(Not run)

</code></pre>

<hr>
<h2 id='parse_directions_content'>Parse content of directions API call</h2><span id='topic+parse_directions_content'></span>

<h3>Description</h3>

<p>This function is designed to parse the content returned by the interior
steps of the <code><a href="#topic+directions">directions</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_directions_content(directions_content)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_directions_content_+3A_directions_content">directions_content</code></td>
<td>
<p>A direction, as a list, returned by the
<code>directions</code> API call.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble consisting of the following columns: </p>

<ul>
<li> <p><code>direction_id</code>
</p>
</li>
<li> <p><code>direction_name</code>,
</p>
</li>
<li> <p><code>route_id</code>
</p>
</li>
<li> <p><code>route_type</code>
</p>
</li>
<li> <p><code>route_type_description</code>
</p>
</li>
<li> <p><code>route_direction_description</code>
</p>
</li></ul>


<hr>
<h2 id='parse_fare_estimate_content'>Parse content of fare estimates API call</h2><span id='topic+parse_fare_estimate_content'></span>

<h3>Description</h3>

<p>This function is designed to parse the content returned by the interior
steps of the <code><a href="#topic+fare_estimate">fare_estimate</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_fare_estimate_content(fare_estimate_content)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_fare_estimate_content_+3A_fare_estimate_content">fare_estimate_content</code></td>
<td>
<p>A direction, as a list, returned by the
<code><a href="#topic+fare_estimate">fare_estimate</a></code> API call.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame consisting of one row for each <code>passenger_type</code>, and the
following columns: </p>

<ul>
<li> <p><code>min_zone</code>
</p>
</li>
<li> <p><code>max_zone</code>
</p>
</li>
<li> <p><code>unique_zones</code>
</p>
</li>
<li> <p><code>early_bird</code>
</p>
</li>
<li> <p><code>free_tram_zone</code>
</p>
</li>
<li> <p><code>weekend_journey</code>
</p>
</li>
<li> <p><code>passenger_type</code>
</p>
</li>
<li> <p><code>fare_2_hour_peak</code>
</p>
</li>
<li> <p><code>fare_2_hour_off_peak</code>
</p>
</li>
<li> <p><code>fare_daily_peak</code>
</p>
</li>
<li> <p><code>fare_daily_off_peak</code>
</p>
</li>
<li> <p><code>pass_7_days</code>
</p>
</li>
<li> <p><code>pass_28_to_69_day_per_day</code>
</p>
</li>
<li> <p><code>pass_70_plus_day_per_day</code>
</p>
</li>
<li> <p><code>weekend_cap</code>
</p>
</li>
<li> <p><code>holiday_cap</code>
</p>
</li></ul>


<hr>
<h2 id='patterns'>Stopping pattern for a given run</h2><span id='topic+patterns'></span>

<h3>Description</h3>

<p>A pattern consists of all departures, stops, routes, runs, directions and
disruptions associated with a particular run ID. This is returned as a list
of tibbles, with output corresponding to their respective API calls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patterns(
  run_ref,
  route_type,
  stop_id = NULL,
  departs = Sys.time(),
  user_id = determine_user_id(),
  api_key = determine_api_key()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="patterns_+3A_run_ref">run_ref</code></td>
<td>
<p>A character run reference. This supersedes the integer
<code>run_id</code>. For backwards compatibility and since most run references are
integers, this function will attempt to convert an the argument to a
character. Run references may be retrieved from the
<code><a href="#topic+departures">departures</a></code> or <code><a href="#topic+runs_on_route">runs_on_route</a></code> functions.</p>
</td></tr>
<tr><td><code id="patterns_+3A_route_type">route_type</code></td>
<td>
<p>Optionally filter results by a route type. A route type can
be provided either as a non-negative integer code, or as a character:
&quot;Tram&quot;, &quot;Train&quot;, &quot;Bus&quot;, &quot;Vline&quot; or &quot;Night Bus&quot;. Character inputs are not
case-sensitive. Use the <code><a href="#topic+route_types">route_types</a></code> function to extract a
vector of all route types.</p>
</td></tr>
<tr><td><code id="patterns_+3A_stop_id">stop_id</code></td>
<td>
<p>Integer. Optionally filter results to a specific stop ID.
These can be searched for with the <code>stops_on_route</code> and <code>stops_nearby</code>
functions.</p>
</td></tr>
<tr><td><code id="patterns_+3A_departs">departs</code></td>
<td>
<p>POSIXct or character. Optionally filter by date. See Details.
Characters are automatically converted to departs, and are assumed to be
given as Melbourne time. The behaviour of the API is unpredictable when
using this argument &mdash; see details. Defaults to the current system time.</p>
</td></tr>
<tr><td><code id="patterns_+3A_user_id">user_id</code></td>
<td>
<p>Integer or character. A user ID or devid provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="patterns_+3A_api_key">api_key</code></td>
<td>
<p>Character. An API key, with dashes, provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>stops</code> tibble has an output similar to that returned by
<code><a href="#topic+stops_on_route">stops_on_route</a></code>. The <code>routes</code> tibble does not contain service
status information.
</p>
<p>Departures: The API seems to return the earliest 7 departures. While
the PTV Timetable API supports filtering patterns by datetimes, the
behaviour of this argument is not reliable &mdash; it appears to filter by day
only, returning the earliest 7 departures of a different day. It is
recommended that departures are retrieved via the <code><a href="#topic+departures">departures</a></code>
function.
</p>


<h3>Value</h3>

<p>An object of class &quot;ptvapi&quot;, which is effectively a list with the
following names: </p>
 <ul>
<li> <p><code>departures</code> </p>
</li>
<li> <p><code>stops</code> </p>
</li>
<li> <p><code>routes</code>
</p>
</li>
<li> <p><code>runs</code> </p>
</li>
<li> <p><code>directions</code> </p>
</li>
<li> <p><code>disruptions</code> </p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
patterns(run_ref = "1", route_type = 0)
patterns(run_ref = "1", route_type = "Train")

## End(Not run)

</code></pre>

<hr>
<h2 id='process_response'>Process a raw httr response and return an object of class ptv_api</h2><span id='topic+process_response'></span>

<h3>Description</h3>

<p>This S3 object returned by this function contains three elements:
</p>

<ul>
<li><p> status_code, as an integer
</p>
</li>
<li><p> request, which is the request URL without authentication details
</p>
</li>
<li><p> content, the unparsed body of the response
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>process_response(response, request_url_without_auth)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_response_+3A_response">response</code></td>
<td>
<p>A raw response generated by the <code>httr</code> package</p>
</td></tr>
<tr><td><code id="process_response_+3A_request_url_without_auth">request_url_without_auth</code></td>
<td>
<p>Character. The request <code>url</code>, without <code>devid</code>
and signature</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class ptv_api
</p>

<hr>
<h2 id='ptv_search'>Use a character term to search for routes, stops, and outlets.</h2><span id='topic+ptv_search'></span>

<h3>Description</h3>

<p>There's only one search API call, and it covers stops, routes, and outlets.
This function will return the response of this generic search. It is
expected that other functions will take on of these three categories of
search results, parse them, and return them to the user as a tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptv_search(
  search_term,
  latitude = NULL,
  longitude = NULL,
  max_distance = NULL,
  route_types = NULL,
  include_outlets = FALSE,
  match_stop_by_suburb = FALSE,
  match_route_by_suburb = FALSE,
  match_stop_by_gtfs_stop_id = FALSE,
  user_id = determine_user_id(),
  api_key = determine_api_key()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ptv_search_+3A_search_term">search_term</code></td>
<td>
<p>Character. Term used to perform search.</p>
</td></tr>
<tr><td><code id="ptv_search_+3A_latitude">latitude</code></td>
<td>
<p>Numeric. Latitude in decimal degrees. For example, Flinders
Street Station is at approximately -37.8183 latitude.</p>
</td></tr>
<tr><td><code id="ptv_search_+3A_longitude">longitude</code></td>
<td>
<p>Numeric. Longitude in decimal degrees. For example, Flinders
Street Station is at approximately 144.9671 longitude.</p>
</td></tr>
<tr><td><code id="ptv_search_+3A_max_distance">max_distance</code></td>
<td>
<p>Integer. Optionally filter by maximum distance from the
given location, in metres.</p>
</td></tr>
<tr><td><code id="ptv_search_+3A_route_types">route_types</code></td>
<td>
<p>Integer or character vector. Optionally filter by a vector
of route types. A route type can be provided either as a non-negative
integer code, or as a character: &quot;Tram&quot;, &quot;Train&quot;, &quot;Bus&quot;, &quot;Vline&quot; or &quot;Night
Bus&quot;. Character inputs are not case-sensitive. Use the
<code><a href="#topic+route_types">route_types</a></code> function to extract a vector of all route types.</p>
</td></tr>
<tr><td><code id="ptv_search_+3A_include_outlets">include_outlets</code></td>
<td>
<p>Boolean. Optional. Affects search results.</p>
</td></tr>
<tr><td><code id="ptv_search_+3A_match_stop_by_suburb">match_stop_by_suburb</code></td>
<td>
<p>Boolean. Optional. Affects search results.</p>
</td></tr>
<tr><td><code id="ptv_search_+3A_match_route_by_suburb">match_route_by_suburb</code></td>
<td>
<p>Boolean. Optional. Affects search results.</p>
</td></tr>
<tr><td><code id="ptv_search_+3A_match_stop_by_gtfs_stop_id">match_stop_by_gtfs_stop_id</code></td>
<td>
<p>Boolean. Optional. Affects search results.</p>
</td></tr>
<tr><td><code id="ptv_search_+3A_user_id">user_id</code></td>
<td>
<p>Integer or character. A user ID or devid provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="ptv_search_+3A_api_key">api_key</code></td>
<td>
<p>Character. An API key, with dashes, provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the search term is numeric and/or less than 3 characters, the API will
return only routes. By default, as little matching is done as possible, and
as little as possible is returned. We rely on functions that call on this
function to specify what is needed.
</p>


<h3>Value</h3>

<p>The response of the <code>search</code> API call.
</p>

<hr>
<h2 id='PTVGET'>Submit a GET request to the PTV API</h2><span id='topic+PTVGET'></span>

<h3>Description</h3>

<p>Submit a GET request to the PTV API
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PTVGET(
  request,
  user_id = determine_user_id(),
  api_key = determine_api_key(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PTVGET_+3A_request">request</code></td>
<td>
<p>A request or path for the API, eg. &quot;routes&quot;.</p>
</td></tr>
<tr><td><code id="PTVGET_+3A_user_id">user_id</code></td>
<td>
<p>Integer or character. A user ID or devid provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="PTVGET_+3A_api_key">api_key</code></td>
<td>
<p>Character. An API key, with dashes, provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="PTVGET_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>httr::GET</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A HTTP response. Content can be accessed with <code>httr::content</code>.
</p>


<h3>Obtaining API authentication details</h3>

<p>You will need to obtain a user ID (also called a devid) and an API key from
Public Transport Victoria. These are obtained by email. Instructions are
available at <a href="https://www.ptv.vic.gov.au/footer/data-and-reporting/datasets/ptv-timetable-api/">https://www.ptv.vic.gov.au/footer/data-and-reporting/datasets/ptv-timetable-api/</a>.
You may pass these two pieces of information directly to the function, or you
can set the PTV_USER_ID and PTV_API_KEY environment variables.
</p>

<hr>
<h2 id='route_information'>Information for a given route</h2><span id='topic+route_information'></span>

<h3>Description</h3>

<p>Information for a given route
</p>


<h3>Usage</h3>

<pre><code class='language-R'>route_information(
  route_id,
  include_geopath = FALSE,
  geopath_utc = NULL,
  user_id = determine_user_id(),
  api_key = determine_api_key()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="route_information_+3A_route_id">route_id</code></td>
<td>
<p>Integer. These can be listed and described with the
<code><a href="#topic+routes">routes</a></code> function.</p>
</td></tr>
<tr><td><code id="route_information_+3A_include_geopath">include_geopath</code></td>
<td>
<p>Logical. Whether to populate the <code>geopath</code> column.
Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="route_information_+3A_geopath_utc">geopath_utc</code></td>
<td>
<p>Date, or character that can be converted to a date. The
UTC date for which the geopaths are effective. Defaults to the current
date. Has no effect if <code>include_geopath = FALSE</code>. It's uncertain how much
historical or future-dated data is available.</p>
</td></tr>
<tr><td><code id="route_information_+3A_user_id">user_id</code></td>
<td>
<p>Integer or character. A user ID or devid provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="route_information_+3A_api_key">api_key</code></td>
<td>
<p>Character. An API key, with dashes, provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble of routes, with the following columns:
</p>

<ul>
<li> <p><code>route_id</code>
</p>
</li>
<li> <p><code>route_gtfs_id</code>
</p>
</li>
<li> <p><code>route_name</code>
</p>
</li>
<li> <p><code>route_type</code>
</p>
</li>
<li> <p><code>route_type_description</code>
</p>
</li>
<li> <p><code>route_number</code>
</p>
</li>
<li> <p><code>geopath</code>
</p>
</li>
<li> <p><code>service_status</code>
</p>
</li>
<li> <p><code>service_status_timestamp</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
route_information(6)
route_information(6, include_geopath = TRUE)
route_information(6, include_geopath = TRUE, geopath_utc = "2020-07-01")

## End(Not run)

</code></pre>

<hr>
<h2 id='route_to_tibble'>Convert a single route to a tibble</h2><span id='topic+route_to_tibble'></span>

<h3>Description</h3>

<p>This function is designed to parse the content returned by the interior steps
of the <code><a href="#topic+routes">routes</a></code> function. Service status information may be <code>NA</code>,
depending on the API call that was used to populate the information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>route_to_tibble(route)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="route_to_tibble_+3A_route">route</code></td>
<td>
<p>A route, as a list, returned by the <code><a href="#topic+routes">routes</a></code> API
call.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble of routes, with the following columns:
</p>

<ul>
<li> <p><code>route_id</code>
</p>
</li>
<li> <p><code>route_gtfs_id</code>
</p>
</li>
<li> <p><code>route_name</code>
</p>
</li>
<li> <p><code>route_type</code>
</p>
</li>
<li> <p><code>route_type_description</code>
</p>
</li>
<li> <p><code>route_number</code>
</p>
</li>
<li> <p><code>geopath</code>
</p>
</li>
<li> <p><code>service_status</code>
</p>
</li>
<li> <p><code>service_status_timestamp</code>
</p>
</li></ul>


<hr>
<h2 id='route_types'>Retrieve a translation from route type number to name</h2><span id='topic+route_types'></span>

<h3>Description</h3>

<p>Route types (tram, train, etc.) are provided to the PTV API as an integer
code. This function retrieves a named vector in which the values are the
route type descriptions, and the names of the vector are the route type
numbers. Note that &quot;Night Bus&quot; is a separate route type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>route_types(user_id = determine_user_id(), api_key = determine_api_key())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="route_types_+3A_user_id">user_id</code></td>
<td>
<p>Integer or character. A user ID or devid provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="route_types_+3A_api_key">api_key</code></td>
<td>
<p>Character. An API key, with dashes, provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named integer vector in which the values are the route type
descriptions, and the names of the vector are the route type numbers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
route_types()

## End(Not run)

</code></pre>

<hr>
<h2 id='routes'>Information for all routes</h2><span id='topic+routes'></span>

<h3>Description</h3>

<p>Information for all routes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>routes(
  route_types = NULL,
  route_name = NULL,
  user_id = determine_user_id(),
  api_key = determine_api_key()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="routes_+3A_route_types">route_types</code></td>
<td>
<p>Integer or character vector. Optionally filter by a vector
of route types. A route type can be provided either as a non-negative
integer code, or as a character: &quot;Tram&quot;, &quot;Train&quot;, &quot;Bus&quot;, &quot;Vline&quot; or &quot;Night
Bus&quot;. Character inputs are not case-sensitive. Use the
<code><a href="#topic+route_types">route_types</a></code> function to extract a vector of all route types.</p>
</td></tr>
<tr><td><code id="routes_+3A_route_name">route_name</code></td>
<td>
<p>Character. Optionally filter by route name. Partial matches
are accepted, and the matches are not case sensitive.</p>
</td></tr>
<tr><td><code id="routes_+3A_user_id">user_id</code></td>
<td>
<p>Integer or character. A user ID or devid provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="routes_+3A_api_key">api_key</code></td>
<td>
<p>Character. An API key, with dashes, provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble of routes, with the following columns:
</p>

<ul>
<li> <p><code>route_id</code>
</p>
</li>
<li> <p><code>route_gtfs_id</code>
</p>
</li>
<li> <p><code>route_name</code>
</p>
</li>
<li> <p><code>route_type</code>
</p>
</li>
<li> <p><code>route_type_description</code>
</p>
</li>
<li> <p><code>route_number</code>
</p>
</li>
<li> <p><code>geopath</code>
</p>
</li>
<li> <p><code>service_status</code>
</p>
</li>
<li> <p><code>service_status_timestamp</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
routes()
routes(route_types = "Train")
routes(route_types = 0)
routes(route_types = c("Train", "Tram"))
routes(route_name = "Frankston")
routes(route_name = "Craigie")
routes(route_name = "werribee")

## End(Not run)
</code></pre>

<hr>
<h2 id='run_information'>Information for a given run</h2><span id='topic+run_information'></span>

<h3>Description</h3>

<p>Run IDs are not unique across the network. If you are interested in a
specific run, consider supplying a value to the optional <code>route_type</code>
argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_information(
  run_ref,
  route_type = NULL,
  include_geopath = FALSE,
  geopath_utc = NULL,
  date_utc = NULL,
  user_id = determine_user_id(),
  api_key = determine_api_key()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_information_+3A_run_ref">run_ref</code></td>
<td>
<p>A character run reference. This supersedes the integer
<code>run_id</code>. For backwards compatibility and since most run references are
integers, this function will attempt to convert an the argument to a
character. Run references may be retrieved from the
<code><a href="#topic+departures">departures</a></code> or <code><a href="#topic+runs_on_route">runs_on_route</a></code> functions.</p>
</td></tr>
<tr><td><code id="run_information_+3A_route_type">route_type</code></td>
<td>
<p>Optionally filter results by a route type. A route type can
be provided either as a non-negative integer code, or as a character:
&quot;Tram&quot;, &quot;Train&quot;, &quot;Bus&quot;, &quot;Vline&quot; or &quot;Night Bus&quot;. Character inputs are not
case-sensitive. Use the <code><a href="#topic+route_types">route_types</a></code> function to extract a
vector of all route types.</p>
</td></tr>
<tr><td><code id="run_information_+3A_include_geopath">include_geopath</code></td>
<td>
<p>Logical. Whether to populate the <code>geopath</code> column.
Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="run_information_+3A_geopath_utc">geopath_utc</code></td>
<td>
<p>Date, or character that can be converted to a date. The
UTC date for which the geopaths are effective. Defaults to the current
date. Has no effect if <code>include_geopath = FALSE</code>. It's uncertain how much
historical or future-dated data is available.</p>
</td></tr>
<tr><td><code id="run_information_+3A_date_utc">date_utc</code></td>
<td>
<p>Date, or character that can be converted to a date. The
UTC date for which the results are effective. Defaults to the current date.
It's uncertain how much historical or future-dated data is available. This
argument is experimental and seems to not be functioning.</p>
</td></tr>
<tr><td><code id="run_information_+3A_user_id">user_id</code></td>
<td>
<p>Integer or character. A user ID or devid provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="run_information_+3A_api_key">api_key</code></td>
<td>
<p>Character. An API key, with dashes, provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the following columns: </p>

<ul>
<li> <p><code>run_id</code> (deprecated, use <code>run_ref</code> instead)
</p>
</li>
<li> <p><code>run_ref</code>
</p>
</li>
<li> <p><code>route_id</code>
</p>
</li>
<li> <p><code>route_type</code>
</p>
</li>
<li> <p><code>route_type_description</code>
</p>
</li>
<li> <p><code>direction_id</code>
</p>
</li>
<li> <p><code>run_sequence</code>
</p>
</li>
<li> <p><code>final_stop_id</code>
</p>
</li>
<li> <p><code>destination_name</code>
</p>
</li>
<li> <p><code>status</code>
</p>
</li>
<li> <p><code>express_stop_count</code>
</p>
</li>
<li> <p><code>vehicle_position</code>
</p>
</li>
<li> <p><code>vehicle_descriptor</code>
</p>
</li>
<li> <p><code>geopath</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
run_information("100")
run_information("100", include_geopath = TRUE)
run_information("100", include_geopath = TRUE, geopath_utc = "2020-07-01")
run_information("100", date_utc = "2020-07-01")

## End(Not run)

</code></pre>

<hr>
<h2 id='run_to_tibble'>Convert a single run to a tibble</h2><span id='topic+run_to_tibble'></span>

<h3>Description</h3>

<p>This function is designed to parse the content returned by the interior steps
of the <code><a href="#topic+runs_on_route">runs_on_route</a></code> and <code><a href="#topic+run_information">run_information</a></code>
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_to_tibble(run)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_to_tibble_+3A_run">run</code></td>
<td>
<p>A run, as a list, returned by the <code>runs</code> API call.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the following columns: </p>

<ul>
<li> <p><code>run_id</code> (deprecated, use <code>run_ref</code> instead)
</p>
</li>
<li> <p><code>run_ref</code>
</p>
</li>
<li> <p><code>route_id</code>
</p>
</li>
<li> <p><code>route_type</code>
</p>
</li>
<li> <p><code>route_type_description</code>
</p>
</li>
<li> <p><code>direction_id</code>
</p>
</li>
<li> <p><code>run_sequence</code>
</p>
</li>
<li> <p><code>final_stop_id</code>
</p>
</li>
<li> <p><code>destination_name</code>
</p>
</li>
<li> <p><code>status</code>
</p>
</li>
<li> <p><code>express_stop_count</code>
</p>
</li>
<li> <p><code>vehicle_position</code>
</p>
</li>
<li> <p><code>vehicle_descriptor</code>
</p>
</li>
<li> <p><code>geopath</code>
</p>
</li></ul>


<hr>
<h2 id='runs_on_route'>Runs on a given route</h2><span id='topic+runs_on_route'></span>

<h3>Description</h3>

<p>Runs on a given route
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runs_on_route(
  route_id,
  route_type = NULL,
  date_utc = NULL,
  user_id = determine_user_id(),
  api_key = determine_api_key()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runs_on_route_+3A_route_id">route_id</code></td>
<td>
<p>Integer. These can be listed and described with the
<code><a href="#topic+routes">routes</a></code> function.</p>
</td></tr>
<tr><td><code id="runs_on_route_+3A_route_type">route_type</code></td>
<td>
<p>Optionally filter results by a route type. A route type can
be provided either as a non-negative integer code, or as a character:
&quot;Tram&quot;, &quot;Train&quot;, &quot;Bus&quot;, &quot;Vline&quot; or &quot;Night Bus&quot;. Character inputs are not
case-sensitive. Use the <code><a href="#topic+route_types">route_types</a></code> function to extract a
vector of all route types.</p>
</td></tr>
<tr><td><code id="runs_on_route_+3A_date_utc">date_utc</code></td>
<td>
<p>Date, or character that can be converted to a date. The
UTC date for which the results are effective. Defaults to the current date.
It's uncertain how much historical or future-dated data is available. This
argument is experimental and seems to not be functioning.</p>
</td></tr>
<tr><td><code id="runs_on_route_+3A_user_id">user_id</code></td>
<td>
<p>Integer or character. A user ID or devid provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="runs_on_route_+3A_api_key">api_key</code></td>
<td>
<p>Character. An API key, with dashes, provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the following columns: </p>

<ul>
<li> <p><code>run_id</code> (deprecated, use <code>run_ref</code> instead)
</p>
</li>
<li> <p><code>run_ref</code>
</p>
</li>
<li> <p><code>route_id</code>
</p>
</li>
<li> <p><code>route_type</code>
</p>
</li>
<li> <p><code>route_type_description</code>
</p>
</li>
<li> <p><code>direction_id</code>
</p>
</li>
<li> <p><code>run_sequence</code>
</p>
</li>
<li> <p><code>final_stop_id</code>
</p>
</li>
<li> <p><code>destination_name</code>
</p>
</li>
<li> <p><code>status</code>
</p>
</li>
<li> <p><code>express_stop_count</code>
</p>
</li>
<li> <p><code>vehicle_position</code>
</p>
</li>
<li> <p><code>vehicle_descriptor</code>
</p>
</li>
<li> <p><code>geopath</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
runs_on_route(6)
runs_on_route(6, route_type = "Train")
runs_on_route(6, route_type = 0)

## End(Not run)

</code></pre>

<hr>
<h2 id='search_outlets'>Search for outlets using text</h2><span id='topic+search_outlets'></span>

<h3>Description</h3>

<p>This function will search outlets in which the search term can be found in
either the outlet name, outlet business or outlet suburb. The search is
case-insensitive. The search term must contain at least 3 characters, and
cannot be numeric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_outlets(
  search_term,
  latitude = NULL,
  longitude = NULL,
  max_distance = NULL,
  route_types = NULL,
  user_id = determine_user_id(),
  api_key = determine_api_key()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="search_outlets_+3A_search_term">search_term</code></td>
<td>
<p>Character. Term used to perform search.</p>
</td></tr>
<tr><td><code id="search_outlets_+3A_latitude">latitude</code></td>
<td>
<p>Numeric. Latitude in decimal degrees. For example, Flinders
Street Station is at approximately -37.8183 latitude.</p>
</td></tr>
<tr><td><code id="search_outlets_+3A_longitude">longitude</code></td>
<td>
<p>Numeric. Longitude in decimal degrees. For example, Flinders
Street Station is at approximately 144.9671 longitude.</p>
</td></tr>
<tr><td><code id="search_outlets_+3A_max_distance">max_distance</code></td>
<td>
<p>Integer. Optionally filter by maximum distance from the
given location, in metres.</p>
</td></tr>
<tr><td><code id="search_outlets_+3A_route_types">route_types</code></td>
<td>
<p>Integer or character vector. Optionally filter by a vector
of route types. A route type can be provided either as a non-negative
integer code, or as a character: &quot;Tram&quot;, &quot;Train&quot;, &quot;Bus&quot;, &quot;Vline&quot; or &quot;Night
Bus&quot;. Character inputs are not case-sensitive. Use the
<code><a href="#topic+route_types">route_types</a></code> function to extract a vector of all route types.</p>
</td></tr>
<tr><td><code id="search_outlets_+3A_user_id">user_id</code></td>
<td>
<p>Integer or character. A user ID or devid provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="search_outlets_+3A_api_key">api_key</code></td>
<td>
<p>Character. An API key, with dashes, provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the following columns: </p>

<ul>
<li> <p><code>outlet_slid_spid</code>
</p>
</li>
<li> <p><code>outlet_name</code>
</p>
</li>
<li> <p><code>outlet_business</code>
</p>
</li>
<li> <p><code>outlet_latitude</code>
</p>
</li>
<li> <p><code>outlet_longitude</code>
</p>
</li>
<li> <p><code>outlet_suburb</code>
</p>
</li>
<li> <p><code>outlet_postcode</code>
</p>
</li>
<li> <p><code>outlet_business_hour_mon</code>
</p>
</li>
<li> <p><code>outlet_business_hour_tue</code>
</p>
</li>
<li> <p><code>outlet_business_hour_wed</code>
</p>
</li>
<li> <p><code>outlet_business_hour_thu</code>
</p>
</li>
<li> <p><code>outlet_business_hour_fri</code>
</p>
</li>
<li> <p><code>outlet_business_hour_sat</code>
</p>
</li>
<li> <p><code>outlet_business_hour_sun</code>
</p>
</li>
<li> <p><code>outlet_notes</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
search_outlets("St Kilda")
search_outlets("St Kilda", route_types = c("Train", "Tram"))
search_outlets("St Kilda", route_types = 1)

search_outlets(
  "St Kilda",
  latitude = -37.867647,
  longitude = 144.976809
)
search_outlets(
  "St Kilda",
  latitude = -37.867647,
  longitude = 144.976809,
  max_distance = 100
)

## End(Not run)
</code></pre>

<hr>
<h2 id='search_routes'>Search for routes using text</h2><span id='topic+search_routes'></span>

<h3>Description</h3>

<p>This function will search routes in which the search term can be found in
one of many fields, such as <code>route_id</code>, <code>route_gtfs_id</code>, or <code>route_name</code>.
The search is case-insensitive. Unlike <code><a href="#topic+search_stops">search_stops</a></code> and
<code><a href="#topic+search_outlets">search_outlets</a></code>, this function supports searching for numerics,
and has no minimum character requirement for <code>search_term</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_routes(
  search_term,
  latitude = NULL,
  longitude = NULL,
  max_distance = NULL,
  route_types = NULL,
  user_id = determine_user_id(),
  api_key = determine_api_key()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="search_routes_+3A_search_term">search_term</code></td>
<td>
<p>Character. Term used to perform search.</p>
</td></tr>
<tr><td><code id="search_routes_+3A_latitude">latitude</code></td>
<td>
<p>Numeric. Latitude in decimal degrees. For example, Flinders
Street Station is at approximately -37.8183 latitude.</p>
</td></tr>
<tr><td><code id="search_routes_+3A_longitude">longitude</code></td>
<td>
<p>Numeric. Longitude in decimal degrees. For example, Flinders
Street Station is at approximately 144.9671 longitude.</p>
</td></tr>
<tr><td><code id="search_routes_+3A_max_distance">max_distance</code></td>
<td>
<p>Integer. Optionally filter by maximum distance from the
given location, in metres.</p>
</td></tr>
<tr><td><code id="search_routes_+3A_route_types">route_types</code></td>
<td>
<p>Integer or character vector. Optionally filter by a vector
of route types. A route type can be provided either as a non-negative
integer code, or as a character: &quot;Tram&quot;, &quot;Train&quot;, &quot;Bus&quot;, &quot;Vline&quot; or &quot;Night
Bus&quot;. Character inputs are not case-sensitive. Use the
<code><a href="#topic+route_types">route_types</a></code> function to extract a vector of all route types.</p>
</td></tr>
<tr><td><code id="search_routes_+3A_user_id">user_id</code></td>
<td>
<p>Integer or character. A user ID or devid provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="search_routes_+3A_api_key">api_key</code></td>
<td>
<p>Character. An API key, with dashes, provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble of routes, with the following columns:
</p>

<ul>
<li> <p><code>route_id</code>
</p>
</li>
<li> <p><code>route_gtfs_id</code>
</p>
</li>
<li> <p><code>route_name</code>
</p>
</li>
<li> <p><code>route_type</code>
</p>
</li>
<li> <p><code>route_type_description</code>
</p>
</li>
<li> <p><code>route_number</code>
</p>
</li>
<li> <p><code>geopath</code>
</p>
</li>
<li> <p><code>service_status</code>
</p>
</li>
<li> <p><code>service_status_timestamp</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
search_routes("Pakenham")
search_routes("Pakenham", route_types = c("Train", "Tram"))
search_routes("Pakenham", route_types = 1)

search_routes(
  "Pakenham",
  latitude = -38.077877,
  longitude = 145.484751
)
search_routes(
  "Pakenham",
  latitude = -38.077877,
  longitude = 145.484751,
  max_distance = 100
)

## End(Not run)
</code></pre>

<hr>
<h2 id='search_stops'>Search for stops using text</h2><span id='topic+search_stops'></span>

<h3>Description</h3>

<p>This function will search stops in which the search term can be found in
either the stop name or the stop suburb. The search is case-insensitive.
The search term must contain at least 3 characters, and cannot be numeric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_stops(
  search_term,
  latitude = NULL,
  longitude = NULL,
  max_distance = NULL,
  route_types = NULL,
  user_id = determine_user_id(),
  api_key = determine_api_key()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="search_stops_+3A_search_term">search_term</code></td>
<td>
<p>Character. Term used to perform search.</p>
</td></tr>
<tr><td><code id="search_stops_+3A_latitude">latitude</code></td>
<td>
<p>Numeric. Latitude in decimal degrees. For example, Flinders
Street Station is at approximately -37.8183 latitude.</p>
</td></tr>
<tr><td><code id="search_stops_+3A_longitude">longitude</code></td>
<td>
<p>Numeric. Longitude in decimal degrees. For example, Flinders
Street Station is at approximately 144.9671 longitude.</p>
</td></tr>
<tr><td><code id="search_stops_+3A_max_distance">max_distance</code></td>
<td>
<p>Integer. Optionally filter by maximum distance from the
given location, in metres.</p>
</td></tr>
<tr><td><code id="search_stops_+3A_route_types">route_types</code></td>
<td>
<p>Integer or character vector. Optionally filter by a vector
of route types. A route type can be provided either as a non-negative
integer code, or as a character: &quot;Tram&quot;, &quot;Train&quot;, &quot;Bus&quot;, &quot;Vline&quot; or &quot;Night
Bus&quot;. Character inputs are not case-sensitive. Use the
<code><a href="#topic+route_types">route_types</a></code> function to extract a vector of all route types.</p>
</td></tr>
<tr><td><code id="search_stops_+3A_user_id">user_id</code></td>
<td>
<p>Integer or character. A user ID or devid provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="search_stops_+3A_api_key">api_key</code></td>
<td>
<p>Character. An API key, with dashes, provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the following columns: </p>

<ul>
<li><p><code>stop_id</code>
</p>
</li>
<li><p><code>stop_name</code>
</p>
</li>
<li><p><code>stop_suburb</code>
</p>
</li>
<li><p><code>route_type</code>
</p>
</li>
<li><p><code>route_type_description</code>
</p>
</li>
<li><p><code>stop_sequence</code>
</p>
</li>
<li><p><code>stop_latitude</code>
</p>
</li>
<li><p><code>stop_longitude</code>
</p>
</li>
<li><p><code>disruption_ids</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
search_stops("Ascot Vale")
search_stops("Ascot Vale", route_types = c("Train", "Tram"))
search_stops("Ascot Vale", route_types = 1)

search_stops(
  "Ascot Vale",
  latitude = -37.774240,
  longitude = 144.915518
)
search_stops(
  "Ascot Vale",
  latitude = -37.774240,
  longitude = 144.915518,
  max_distance = 100
)

## End(Not run)
</code></pre>

<hr>
<h2 id='stop_information'>Information for a given stop (metropolitan and V/Line stations only)</h2><span id='topic+stop_information'></span>

<h3>Description</h3>

<p>This function can be used when integer stop ID is already known. This can be
searched for with either the <code><a href="#topic+stops_on_route">stops_on_route</a></code> or
<code><a href="#topic+stops_nearby">stops_nearby</a></code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_information(
  stop_id,
  route_type,
  user_id = determine_user_id(),
  api_key = determine_api_key()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stop_information_+3A_stop_id">stop_id</code></td>
<td>
<p>Integer stop ID.</p>
</td></tr>
<tr><td><code id="stop_information_+3A_route_type">route_type</code></td>
<td>
<p>A route type which can be provided either as a non-negative
integer code, or as a character: &quot;Tram&quot;, &quot;Train&quot;, &quot;Bus&quot;, &quot;Vline&quot; or &quot;Night
Bus&quot;. Character inputs are not case-sensitive. Use the
<code><a href="#topic+route_types">route_types</a></code> function to extract a vector of all route types.</p>
</td></tr>
<tr><td><code id="stop_information_+3A_user_id">user_id</code></td>
<td>
<p>Integer or character. A user ID or devid provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="stop_information_+3A_api_key">api_key</code></td>
<td>
<p>Character. An API key, with dashes, provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single-row tibble with the following columns: </p>

<ul>
<li><p><code>stop_id</code>
</p>
</li>
<li><p><code>stop_name</code>
</p>
</li>
<li><p><code>route_type</code>
</p>
</li>
<li><p><code>route_type_description</code>
</p>
</li>
<li><p><code>station_details_id</code>
</p>
</li>
<li><p><code>station_type</code>
</p>
</li>
<li><p><code>station_description</code>
</p>
</li>
<li><p><code>point_id</code>
</p>
</li>
<li><p><code>mode_id</code>
</p>
</li>
<li><p><code>operating_hours</code>
</p>
</li>
<li><p><code>flexible_stop_opening_hours</code>
</p>
</li>
<li><p><code>stop_contact</code>
</p>
</li>
<li><p><code>stop_ticket</code>
</p>
</li>
<li><p><code>stop_location</code>
</p>
</li>
<li><p><code>stop_amenities</code>
</p>
</li>
<li><p><code>stop_accessibility</code>
</p>
</li>
<li><p><code>stop_staffing</code>
</p>
</li>
<li><p><code>disruption_ids</code>
</p>
</li></ul>


<hr>
<h2 id='stop_to_tibble'>Convert a single stop to a tibble</h2><span id='topic+stop_to_tibble'></span>

<h3>Description</h3>

<p>This function is designed to parse the content returned by the interior
steps of the <code><a href="#topic+stops_on_route">stops_on_route</a></code> and <code><a href="#topic+stops_nearby">stops_nearby</a></code>
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_to_tibble(stop)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stop_to_tibble_+3A_stop">stop</code></td>
<td>
<p>A stop, as a list, returned by a stops API call.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the following columns: </p>

<ul>
<li><p><code>stop_id</code>
</p>
</li>
<li><p><code>stop_name</code>
</p>
</li>
<li><p><code>stop_suburb</code>
</p>
</li>
<li><p><code>route_type</code>
</p>
</li>
<li><p><code>route_type_description</code>
</p>
</li>
<li><p><code>stop_sequence</code>
</p>
</li>
<li><p><code>stop_latitude</code>
</p>
</li>
<li><p><code>stop_longitude</code>
</p>
</li>
<li><p><code>disruption_ids</code>
</p>
</li></ul>


<hr>
<h2 id='stops_nearby'>Stops near a given location</h2><span id='topic+stops_nearby'></span>

<h3>Description</h3>

<p>Stops near a given location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stops_nearby(
  latitude,
  longitude,
  max_distance = NULL,
  route_types = NULL,
  user_id = determine_user_id(),
  api_key = determine_api_key()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stops_nearby_+3A_latitude">latitude</code></td>
<td>
<p>Numeric. Latitude in decimal degrees. For example, Flinders
Street Station is at approximately -37.8183 latitude.</p>
</td></tr>
<tr><td><code id="stops_nearby_+3A_longitude">longitude</code></td>
<td>
<p>Numeric. Longitude in decimal degrees. For example, Flinders
Street Station is at approximately 144.9671 longitude.</p>
</td></tr>
<tr><td><code id="stops_nearby_+3A_max_distance">max_distance</code></td>
<td>
<p>Integer. Optionally filter by maximum distance from the
given location, in metres.</p>
</td></tr>
<tr><td><code id="stops_nearby_+3A_route_types">route_types</code></td>
<td>
<p>Integer or character vector. Optionally filter by a vector
of route types. A route type can be provided either as a non-negative
integer code, or as a character: &quot;Tram&quot;, &quot;Train&quot;, &quot;Bus&quot;, &quot;Vline&quot; or &quot;Night
Bus&quot;. Character inputs are not case-sensitive. Use the
<code><a href="#topic+route_types">route_types</a></code> function to extract a vector of all route types.</p>
</td></tr>
<tr><td><code id="stops_nearby_+3A_user_id">user_id</code></td>
<td>
<p>Integer or character. A user ID or devid provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="stops_nearby_+3A_api_key">api_key</code></td>
<td>
<p>Character. An API key, with dashes, provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the following columns: </p>

<ul>
<li><p><code>stop_id</code>
</p>
</li>
<li><p><code>stop_name</code>
</p>
</li>
<li><p><code>stop_suburb</code>
</p>
</li>
<li><p><code>route_type</code>
</p>
</li>
<li><p><code>route_type_description</code>
</p>
</li>
<li><p><code>stop_sequence</code>
</p>
</li>
<li><p><code>stop_latitude</code>
</p>
</li>
<li><p><code>stop_longitude</code>
</p>
</li>
<li><p><code>disruption_ids</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
stops_nearby(latitude = -37.8183, longitude = 144.9671)
stops_nearby(latitude = -37.8183, longitude = 144.9671, max_distance = 1000)
stops_nearby(
  latitude = -37.8183,
  longitude = 144.9671,
  route_types = c("Train", "Tram")
)

stops_nearby(
  latitude = -37.8183,
  longitude = 144.9671,
  route_types = 0
 )

## End(Not run)
</code></pre>

<hr>
<h2 id='stops_on_route'>Stops on a given route and route type</h2><span id='topic+stops_on_route'></span>

<h3>Description</h3>

<p>Stops on a given route and route type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stops_on_route(
  route_id,
  route_type,
  direction_id = NULL,
  user_id = determine_user_id(),
  api_key = determine_api_key()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stops_on_route_+3A_route_id">route_id</code></td>
<td>
<p>Integer. These can be listed and described with the
<code><a href="#topic+routes">routes</a></code> function.</p>
</td></tr>
<tr><td><code id="stops_on_route_+3A_route_type">route_type</code></td>
<td>
<p>A route type which can be provided either as a non-negative
integer code, or as a character: &quot;Tram&quot;, &quot;Train&quot;, &quot;Bus&quot;, &quot;Vline&quot; or &quot;Night
Bus&quot;. Character inputs are not case-sensitive. Use the
<code><a href="#topic+route_types">route_types</a></code> function to extract a vector of all route types.</p>
</td></tr>
<tr><td><code id="stops_on_route_+3A_direction_id">direction_id</code></td>
<td>
<p>Optionally filter by a direction ID. These can be
obtained with the <code><a href="#topic+directions_on_route">directions_on_route</a></code> function.</p>
</td></tr>
<tr><td><code id="stops_on_route_+3A_user_id">user_id</code></td>
<td>
<p>Integer or character. A user ID or devid provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="stops_on_route_+3A_api_key">api_key</code></td>
<td>
<p>Character. An API key, with dashes, provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the following columns: </p>

<ul>
<li><p><code>stop_id</code>
</p>
</li>
<li><p><code>stop_name</code>
</p>
</li>
<li><p><code>stop_suburb</code>
</p>
</li>
<li><p><code>route_type</code>
</p>
</li>
<li><p><code>route_type_description</code>
</p>
</li>
<li><p><code>stop_sequence</code>
</p>
</li>
<li><p><code>stop_latitude</code>
</p>
</li>
<li><p><code>stop_longitude</code>
</p>
</li>
<li><p><code>disruption_ids</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
stops_on_route(6, route_type = "Train")
stops_on_route(6, route_type = 0)

## End(Not run)

</code></pre>

<hr>
<h2 id='to_datetime'>Convert a POSIXct or character datetime to a format ready for a URL</h2><span id='topic+to_datetime'></span>

<h3>Description</h3>

<p>Datetimes accepted by the API need to be given in UTC. This function will
accept a datetime or a character with a suitable datetime format, and output
a character that is suitable for a URL. All URL input and output in this
package should be in Melbourne time, and the UTC conversion should happen
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_datetime(datetime)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to_datetime_+3A_datetime">datetime</code></td>
<td>
<p>POSIXct or Character.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The API seems to accept both &quot;%Y-%m-%dT%H:%M:%OS&quot; and &quot;%Y-%m-%d %H:%M:%OS&quot;,
but we opt for the former.
</p>


<h3>Value</h3>

<p>Character.
</p>

<hr>
<h2 id='to_integer'>Strictly convert an object to an integer</h2><span id='topic+to_integer'></span>

<h3>Description</h3>

<p>R does not have a built-in function to determine if a value is an integer
(<code>is.integer</code> will check if the class of an object is &quot;integer&quot;, but
<code>is.integer(3)</code> will return FALSE). This helper function fills that gap. It
will attempt to convert the input to an integer, but will error on any input
that cannot be confidently expressed as an integer. It serves as a stricter
version of <code>as.integer</code>. For example, the function will convert <code>3</code> or <code>"3"</code>
to integers, but will error on <code>3.5</code> or <code>"three"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_integer(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to_integer_+3A_x">x</code></td>
<td>
<p>An input of any type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer interpretation of <code>x</code>, if possible.
</p>

<hr>
<h2 id='translate_route_type'>Translate a route type input into a numerical route type</h2><span id='topic+translate_route_type'></span>

<h3>Description</h3>

<p>Many API calls require a route type (eg. &quot;Tram&quot; or &quot;Train&quot;). These must be
provided as integers, which are translated to route type descriptions with
the 'route_types() function/API call. This function will: </p>

<ul>
<li><p> Translate a case-insensitive description such as &quot;Tram&quot; or &quot;Train&quot; to
the corresponding route type code
</p>
</li>
<li><p> Check a given integer to see if it is a valid route type code,
returning it if so and erroring otherwise
</p>
</li>
<li><p> Return NULL on NULL input
</p>
</li></ul>

<p>This function is <em>not</em> vectorised.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translate_route_type(
  route_type,
  user_id = determine_user_id(),
  api_key = determine_api_key()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="translate_route_type_+3A_route_type">route_type</code></td>
<td>
<p>A route type which can be provided either as a non-negative
integer code, or as a character: &quot;Tram&quot;, &quot;Train&quot;, &quot;Bus&quot;, &quot;Vline&quot; or &quot;Night
Bus&quot;. Character inputs are not case-sensitive. Use the
<code><a href="#topic+route_types">route_types</a></code> function to extract a vector of all route types.</p>
</td></tr>
<tr><td><code id="translate_route_type_+3A_user_id">user_id</code></td>
<td>
<p>Integer or character. A user ID or devid provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
<tr><td><code id="translate_route_type_+3A_api_key">api_key</code></td>
<td>
<p>Character. An API key, with dashes, provided by Public
Transport Victoria. Refer to <code>?ptvapi</code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer route type code, or NULL if the input is NULL
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
