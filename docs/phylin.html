<!DOCTYPE html><html><head><title>Help for package phylin</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {phylin}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#d.gen'>
<p>Genetic distance matrix between vipers and lineages.</p></a></li>
<li><a href='#extract.val'>
<p>Extact pairwise values from a matrix in a specified order.</p></a></li>
<li><a href='#gen.variogram'>
<p>Semi-variogram with the genetic distance matrix</p></a></li>
<li><a href='#geo.dist'>
<p>Geographical distance matrix for samples and interpolation locations.</p></a></li>
<li><a href='#grid'>
<p>Grid centroids for the Iberian Peninsula.</p></a></li>
<li><a href='#grid.image'>
<p>Simple plot of interpolated grid.</p></a></li>
<li><a href='#gv.model'>
<p>Fit a model to the semi-variogram.</p></a></li>
<li><a href='#idw'>
<p>Inverse Distance Weighting interpolation</p></a></li>
<li><a href='#intgen.idw'>
<p>Interpolation of genetic distances to a a grid of points.</p></a></li>
<li><a href='#krig'>
<p>Simple and ordinary kriging.</p></a></li>
<li><a href='#midpoints'>
<p>Midpoints between pairs of coordinates</p></a></li>
<li><a href='#mpinv'>
<p>Generalized inverse of a matrix</p></a></li>
<li><a href='#mtest.gv'>
<p>Tests if a 'gv' object has a model.</p></a></li>
<li><a href='#multispecies'>
<p>Summarizes data from multiple species.</p></a></li>
<li><a href='#phylin-package'>
<p>Phylogenetic Landscape Interpolation.</p></a></li>
<li><a href='#plot.gv'>
<p>Plot a 'gv' object</p></a></li>
<li><a href='#predict.gv'>
<p>Predict method for 'gen.variogram' object with model.</p></a></li>
<li><a href='#print.gv'>
<p>Prints details of a 'gv' object</p></a></li>
<li><a href='#simul.env'>
<p>Simulated environments.</p></a></li>
<li><a href='#simul.gen.dist'>
<p>Simulated genetic distances.</p></a></li>
<li><a href='#simul.sample'>
<p>Random samples from simulation.</p></a></li>
<li><a href='#summary.gv'>
<p>Summary for 'gv' object</p></a></li>
<li><a href='#vipers'>
<p>Vipers sample locations for 'd.gen' dataset.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial Interpolation of Genetic Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-11-19</td>
</tr>
<tr>
<td>Author:</td>
<td>Pedro Tarroso, Guillermo Velo-Anton, Silvia Carvalho</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pedro Tarroso &lt;ptarroso@cibio.up.pt&gt;</td>
</tr>
<tr>
<td>Suggests:</td>
<td>geometry,raster,gdistance</td>
</tr>
<tr>
<td>Description:</td>
<td>The spatial interpolation of genetic distances between
	     samples is based on a modified kriging method that
	     accepts a genetic distance matrix and generates a map of
	     probability of lineage presence. This package also offers
	     tools to generate a map of  potential contact zones
	     between groups with user-defined thresholds in the tree
	     to account for old and recent divergence. Additionally,
	     it has functions for IDW interpolation using genetic data
	     and midpoints.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.r-project.org">https://www.r-project.org</a>, <a href="https://github.com/ptarroso/phylin">https://github.com/ptarroso/phylin</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-12-12 11:42:56 UTC; pedro</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-12-12 14:40:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='d.gen'>
Genetic distance matrix between vipers and lineages.
</h2><span id='topic+d.gen'></span>

<h3>Description</h3>

<p>This is a matrix of genetic distances between the <em>Vipera latastei</em>
samples. The values are cophenetic distances generated from the 
phylogenetic tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(d.gen)</code></pre>


<h3>Format</h3>

<p>'d.gen' is a matrix with 58 rows and columns. Columns and rows are 
organized with the same order found in the 'vipers' dataset.
</p>


<h3>References</h3>

<p>Velo-Anton G., Godinho R., Harris D. J. <em>et al.</em> (2012) Deep evolutionary lineages in a Western Mediterranean snake (<em>Vipera latastei</em>/<em>monticola</em> group) and high genetic structuring in Southern Iberian populations. <em>Molecular phylogenetics and evolution</em>, <b>65</b>, 965&ndash;973.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d.gen)
hc &lt;- hclust(as.dist(d.gen))
plot(hc, hang = -1, main="Vipers genetic distance tree", 
     xlab="Samples", cex=0.7)
</code></pre>

<hr>
<h2 id='extract.val'>
Extact pairwise values from a matrix in a specified order.
</h2><span id='topic+extract.val'></span>

<h3>Description</h3>

<p>This function extacts pairwise values from a matrix in a specified 
order in a user provided table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract.val(m, samples) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.val_+3A_m">m</code></td>
<td>

<p>Matrix with values to extract.
</p>
</td></tr>
<tr><td><code id="extract.val_+3A_samples">samples</code></td>
<td>

<p>Data frame with columns indicating pairs of samples to extract values.
Names must correspond to column and row names in the matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts the values from a matrix in the same pairs of 
populations/samples given in a table. It is useful for merging data
from a distance matrix of samples and the midpoints between samples (in
conjuction with <code><a href="#topic+midpoints">midpoints</a></code> function).
</p>


<h3>Value</h3>

<p>Returns a vector containing the values from the matrix m in the order given
in samples. 
</p>


<h3>Author(s)</h3>

<p>Pedro Tarroso &lt;ptarroso@cibio.up.pt&gt;
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code>
<code><a href="#topic+d.gen">d.gen</a></code>
<code><a href="#topic+midpoints">midpoints</a></code>
<code><a href="#topic+idw">idw</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(vipers)
data(d.gen)

# calculate midpoints
mp &lt;- midpoints(vipers[,1:2])

# extract values from d.gen. Columns 1 and 2 of mp have the information 
# about source and target samples.   
pair.data &lt;- extract.val(d.gen, mp[,1:2]) 

# it is easier to view in a plot:
plot(vipers[,1:2], pch=vipers[,3], main="Midpoints between samples", 
     xlab="Longitude", ylab="Latitude")
#trace all connecting lines between samples
sps &lt;- rownames(vipers)
for (i in 1:nrow(mp)) 
{
    sp &lt;- mp[i, 1:2] #source an target samples
    mask &lt;- c(which(sps == sp[,1]), which(sps == sp[,2]))
    lines(vipers$x[mask], vipers$y[mask], lty=2, col='lightgrey')
}

#midpoints with genetic distance acentuated
points(mp[,3:4], col='red', pch=16, cex=pair.data*15+0.5) 

</code></pre>

<hr>
<h2 id='gen.variogram'>
Semi-variogram with the genetic distance matrix
</h2><span id='topic+gen.variogram'></span>

<h3>Description</h3>

<p>Computes the semi-variance with the real and genetic distances, and
with user defined lag parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.variogram(x, y, lag = quantile(as.matrix(x), 0.05), tol=lag/2, lmax = NA,
              bootstraps = 999, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.variogram_+3A_x">x</code></td>
<td>

<p>Real distances matrix.
</p>
</td></tr>
<tr><td><code id="gen.variogram_+3A_y">y</code></td>
<td>

<p>Single genetic distances matrix or list of genetic distances
matrices.
</p>
</td></tr>
<tr><td><code id="gen.variogram_+3A_lag">lag</code></td>
<td>

<p>Real distance corresponding to the desired 'lag' interval. This is
used to calculate lag centers from 0 to 'lmax'.
</p>
</td></tr>
<tr><td><code id="gen.variogram_+3A_tol">tol</code></td>
<td>

<p>Tolerance for the lag center to search for pairs ('lag'-'tol',
'lag'+'tol').
</p>
</td></tr>
<tr><td><code id="gen.variogram_+3A_lmax">lmax</code></td>
<td>

<p>Maximum distance for lag centers. Pairs with distances higher than
'lmax' are not included in the calcualtion of the semi-variance. If
'lmax' is NA (default) then is used the maximum distance between
samples.
</p>
</td></tr>
<tr><td><code id="gen.variogram_+3A_bootstraps">bootstraps</code></td>
<td>

<p>This is the number of bootstraps used to calculate 95% confidence
interval for the median, when multiple genetic distances are given.
With a single genetic distance, this parameter is ignored.
</p>
</td></tr>
<tr><td><code id="gen.variogram_+3A_verbose">verbose</code></td>
<td>

<p>Boolean for verbosity. When TRUE and with multiple genetic distance
matrices, a log of error evolution is printed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces a table with real lag centers and
semi-variance. The formula to calculate semi-variance,
<code class="reqn">\gamma(h)</code>, is:
</p>
<p style="text-align: center;"><code class="reqn">\gamma(h) = {\frac{1}{2 n(h)}} \sum_{i=1}^{n}[z(x_i + h) -
        z(x_i)]^2</code>
</p>

<p>where <code class="reqn">n(h)</code> is the number of pairs with the lag distance <code class="reqn">h</code>
between them, and <code class="reqn">z</code> is the value of the sample <code class="reqn">x</code> at the
the location <code class="reqn">i</code>. The difference between sample
<code class="reqn">z(x_i+h)</code> and sample <code class="reqn">z(x_i)</code> is assumed to
correspond to their genetic distance.
</p>
<p>Multiple genetic distance matrices can be used. In this case, a
variogram is computed for each genetic distance and the results
summarised by the median and a 95% confidence interval calculated
with bootstraps.
</p>


<h3>Value</h3>

<p>Returns a 'gv' object with the input data, lag centers and semi-variance.
</p>


<h3>Note</h3>

<p>It is assumed that the order of samples in x corresponds to the same in y.
</p>


<h3>Author(s)</h3>

<p>Pedro Tarroso &lt;ptarroso@cibio.up.pt&gt;
</p>


<h3>References</h3>

<p>Fortin, M. -J. and Dale, M. (2006) <em>Spatial Analysis: A guide for Ecologists</em>. Cambridge: Cambridge University Press.
</p>
<p>Isaaks, E. H. and Srivastava, R. M. (1989) <em>An Introduction to applied geostatistics</em>. New York: Oxford University Press.
</p>
<p>Legendre, P. and Legendre, L. (1998) <em>Numerical ecology</em>. 2nd english edition. Amesterdam: Elsevier
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.gv">plot.gv</a></code>
<code><a href="#topic+predict.gv">predict.gv</a></code>
<code><a href="#topic+gv.model">gv.model</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
    data(vipers)
    data(d.gen)

    # create a distance matrix between samples
    r.dist &lt;- dist(vipers[,1:2])

    # variogram table with semi-variance and lag centers
    gv &lt;- gen.variogram(r.dist, d.gen)

    # plot variogram
    plot(gv)

    # fit a new variogram with different lag
    gv2 &lt;- gen.variogram(r.dist, d.gen, lag=0.2)
    plot(gv2)

</code></pre>

<hr>
<h2 id='geo.dist'>
Geographical distance matrix for samples and interpolation locations.
</h2><span id='topic+geo.dist'></span>

<h3>Description</h3>

<p>Calculates a geographical euclidean distances matrix based on a list
of coordinates for samples and for interpolation locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo.dist(from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geo.dist_+3A_from">from</code></td>
<td>

<p>Data frame with coordinates for source locations. Should have two
columns (longitude and latitude).
</p>
</td></tr>
<tr><td><code id="geo.dist_+3A_to">to</code></td>
<td>

<p>Data frame with coordinates for destination locations to where
distances are calculated. Should have two columns (longitude and
latitude).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return the matrix of euclidean distances between source locations
('from') to destination ('to') coordinates. The resulting matrix has
source locations in rows and destination in columns and respective
names are given based on the row names of the 'from' and 'to' data
frames.
</p>


<h3>Author(s)</h3>

<p>Pedro Tarroso &lt;ptarroso@cibio.up.pt&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vipers)

# create a grid of the sampled area
grid &lt;- expand.grid(x=seq(-10,10,0.5), y=seq(30, 50, 0.5))

rd &lt;- geo.dist(vipers[,1:2], grid)
</code></pre>

<hr>
<h2 id='grid'>
Grid centroids for the Iberian Peninsula.
</h2><span id='topic+grid'></span>

<h3>Description</h3>

<p>This is a list of coordinates representing the interpolation area in 
the Iberian Peninsula with a resolution of 0.09 degrees (~10km). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(grid)</code></pre>


<h3>Format</h3>

<p>The data format is a table with two columns (longitude, and latitude) 
and 7955 rows (pixels).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(grid)
plot(grid, cex=0.5, asp=1, main="Grid of pixels for interpolation",
     xlab="Longitude", ylab="Latitude")
</code></pre>

<hr>
<h2 id='grid.image'>
Simple plot of interpolated grid.
</h2><span id='topic+grid.image'></span>

<h3>Description</h3>

<p>Plots the interpolated grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.image(intpl, grid, breaks=10, ic=1, colFUN=heat.colors, 
           main=colnames(intpl)[ic], xlab=colnames(grid)[1], 
           ylab=colnames(grid)[2], sclab=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.image_+3A_intpl">intpl</code></td>
<td>

<p>A matrix or vector with interpolation results.
</p>
</td></tr>
<tr><td><code id="grid.image_+3A_grid">grid</code></td>
<td>

<p>A table containing longitude and latitude of interpolated locations.
</p>
</td></tr>
<tr><td><code id="grid.image_+3A_breaks">breaks</code></td>
<td>

<p>Number of breaks in the scale.
</p>
</td></tr>
<tr><td><code id="grid.image_+3A_ic">ic</code></td>
<td>

<p>Column index or name from 'intpl' table to show. Defaults to the first 
column. Can be used to plot standard deviation or any other column. This
value is ignored of 'intpl' is a vector.
</p>
</td></tr>
<tr><td><code id="grid.image_+3A_colfun">colFUN</code></td>
<td>

<p>Function to process colors. Can be any of R base color functions (e.g.
<code><a href="grDevices.html#topic+rainbow">rainbow</a></code>, <code><a href="grDevices.html#topic+terrain.colors">terrain.colors</a></code>, etc) or user defined
function.
</p>
</td></tr>
<tr><td><code id="grid.image_+3A_main">main</code></td>
<td>

<p>Main title.
</p>
</td></tr>
<tr><td><code id="grid.image_+3A_xlab">xlab</code></td>
<td>

<p>X axis label. Defaults to name of the first 'grid' column.
</p>
</td></tr>
<tr><td><code id="grid.image_+3A_ylab">ylab</code></td>
<td>

<p>Y axis label. Defaults to name of the secont 'grid' column.
</p>
</td></tr>
<tr><td><code id="grid.image_+3A_sclab">sclab</code></td>
<td>

<p>Scale label to plot under the scale bar.
</p>
</td></tr>
<tr><td><code id="grid.image_+3A_...">...</code></td>
<td>

<p>Futher arguments to be passed to par. Most used is 'cex' to control the 
font size.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function may be used to produce a simple plot of the interpolated
grid. It has some customizable features and it plots a scale bar of the
Z values shown.
</p>


<h3>Note</h3>

<p>Does not work with multiple plots (e.g. with 'layout').
</p>


<h3>Author(s)</h3>

<p>Pedro Tarroso &lt;ptarroso@cibio.up.pt&gt;
</p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+image">image</a></code>
<code><a href="#topic+krig">krig</a></code>
<code><a href="#topic+idw">idw</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(vipers)
    data(d.gen)

    # create a grid of the sampled area for inteprolation
    grid &lt;- expand.grid(x=seq(-9.5,3,0.25), y=seq(36, 43.75, 0.25))

    # create a distance matrix between samples
    r.dist &lt;- dist(vipers[,1:2])

    # fit a model with defaults (shperical model) and estimation of range
    gv &lt;- gen.variogram(r.dist, d.gen, 0.25)
    gv &lt;- gv.model(gv)

    # interpolation of the distances to first sample with ordinary kriging
    int.krig &lt;- krig(d.gen[,1], vipers[,1:2], grid, gv)

    #plot the interpolation results
    grid.image(int.krig, grid, main='Krigging Interpolation', 
               xlab='Longitude',ylab = 'Latitude', 
               sclab=paste('Genetic distance to sample', 
               colnames(d.gen)[1]))

    # User can add extra elements to the main plot.
    points(vipers[,1:2], cex=d.gen[,1]*15+0.2) 

</code></pre>

<hr>
<h2 id='gv.model'>
Fit a model to the semi-variogram.
</h2><span id='topic+gv.model'></span>

<h3>Description</h3>

<p>Fits a model to a semi-variogram contructed with
<code><a href="#topic+gen.variogram">gen.variogram</a></code>. Parameters for each model are estimated by
nonlinear least squares.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gv.model(gv, model='spherical', sill = NA, range=NA, nugget = 0,
         ctrl=nls.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gv.model_+3A_gv">gv</code></td>
<td>

<p>'gv' object from the <code><a href="#topic+gen.variogram">gen.variogram</a></code> function.
</p>
</td></tr>
<tr><td><code id="gv.model_+3A_model">model</code></td>
<td>

<p>Model to fit the data. Available models are spherical (default),
gaussian, exponential or linear. See details.
</p>
</td></tr>
<tr><td><code id="gv.model_+3A_sill">sill</code></td>
<td>

<p>The heigth (semi-variance) of the model when it stabilizes. Defaults to
NA.
</p>
</td></tr>
<tr><td><code id="gv.model_+3A_range">range</code></td>
<td>

<p>The length (real distance) where stabilization occurs. Defaults to NA.
</p>
</td></tr>
<tr><td><code id="gv.model_+3A_nugget">nugget</code></td>
<td>

<p>Intercept in the y-axis. Defaults to 0.
</p>
</td></tr>
<tr><td><code id="gv.model_+3A_ctrl">ctrl</code></td>
<td>

<p>Nls control object for the fitting procedure. (check ?nls.control for more
details).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a model to the data, either by estimating the model
parameters using nonlinear least squares or by user provided values.
Notice that parameters with NA will be estimated by the nls function
and parameters with values given are not estimated (by default, the
nugget is not estimated and set to zero).
The variogram model can be plotted using 'plot' function or used to predict
to a new set of values using 'predict'. It is used to define weights for
the krigging interpolation.
</p>
<p>The parameters of the semi-variogram model (<code class="reqn">\gamma</code>) are the
distance (<code class="reqn">h</code>), range (<code class="reqn">a</code>), sill (<code class="reqn">c = c_0 + c_1</code>;
where <code class="reqn">c_1</code> is the partial sill), and nugget
(<code class="reqn">c_0</code>).
The models available are:
</p>

<ol>
<li><p>gaussian:
</p>
<p style="text-align: center;"><code class="reqn">\gamma(h) = c_0 + c_1 \left(1-exp\left(-3\frac{h^2}
              {a^2}\right)\right)</code>
</p>

</li>
<li><p>exponential:
</p>
<p style="text-align: center;"><code class="reqn">\gamma(h) = c_0 + c_1 \left(1-exp\left(-\frac{3h}{a}
              \right)\right)</code>
</p>

</li>
<li><p>spherical:
</p>
<p style="text-align: center;"><code class="reqn"> \gamma(h) = \left\{
                \begin{array}{ll}
                c_0 + c_1\left(\frac{3}{2}\frac{h}{a} -
		                   \frac{1}{2}(\frac{h}{a})^3\right) &amp;
                    0 &lt; h \le a \\
                    c &amp; h &gt; a
                    \end{array}\right. </code>
</p>

</li>
<li><p>pentaspherical:
</p>
<p style="text-align: center;"><code class="reqn"> \gamma(h) = \left\{
                \begin{array}{ll}
                c_0 + c_1\left(\frac{15}{8}\frac{h}{a} -
		                   \frac{5}{4}(\frac{h}{a})^3 +
		                   \frac{3}{8}(\frac{h}{a})^5\right) &amp;
                    0 &lt; h \le a \\
                    c &amp; h &gt; a
                    \end{array}\right. </code>
</p>

</li>
<li><p>cubic:
</p>
<p style="text-align: center;"><code class="reqn"> \gamma(h) = \left\{
                \begin{array}{ll}
                c_0 + c_1\left(7(\frac{h}{a})^2 -
		                \frac{35}{4}(\frac{h}{a})^3 +
				\frac{7}{2}(\frac{h}{a})^5 -
				\frac{3}{4}(\frac{h}{a})^7\right) &amp;
                    0 &lt; h \le a \\
                    c &amp; h &gt; a
                    \end{array}\right. </code>
</p>

</li>
<li><p>linear:
</p>
<p style="text-align: center;"><code class="reqn"> \gamma(h) = \left\{
                \begin{array}{ll}
                c_0 + \left(\frac{c_1}{a}h\right) &amp;
                    0 &lt; h \le a \\
                    c &amp; h &gt; a
                    \end{array}\right. </code>
</p>

</li></ol>



<h3>Value</h3>

<p>Returns a 'gv' object with the model, input data, and parameter values.
</p>


<h3>Author(s)</h3>

<p>Pedro Tarroso &lt;ptarroso@cibio.up.pt&gt;
</p>


<h3>References</h3>

<p>Fortin, M. -J. and Dale, M. (2006) <em>Spatial Analysis: A guide for Ecologists</em>. Cambridge: Cambridge University Press.
</p>
<p>Isaaks, E. H. and Srivastava, R. M. (1989) <em>An Introduction to applied geostatistics</em>. New York: Oxford University Press.
</p>
<p>Legendre, P. and Legendre, L. (1998) <em>Numerical ecology</em>. 2nd english edition. Amesterdam: Elsevier
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.gv">plot.gv</a></code>
<code><a href="#topic+predict.gv">predict.gv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(vipers)
data(d.gen)

# create a distance matrix between samples
r.dist &lt;- dist(vipers[,1:2])

# fit a variogram with defaults (shperical model) and estimation of range
gv &lt;- gen.variogram(r.dist, d.gen)
gv &lt;- gv.model(gv)

# plot variogram
plot(gv)

# fit a new variogram with linear with sill model and range 8
gv2 &lt;- gv.model(gv, model='linear', range=8)
plot(gv2)

</code></pre>

<hr>
<h2 id='idw'>
Inverse Distance Weighting interpolation
</h2><span id='topic+idw'></span>

<h3>Description</h3>

<p>This function interpolates a list of samples with location and a value to
a table of coordinates, that generally represent a spatial grid. The 
interpolation is based on inverse distance weighting algoritm with three
different methods available for weight calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idw(values, coords, grid, method = "Shepard", p = 2, R = 2, N = 15,
    distFUN = geo.dist, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idw_+3A_values">values</code></td>
<td>

<p>A table of points to be interpolated. Table must contain x and y locations,
and a column of values to be interpolated.
</p>
</td></tr>
<tr><td><code id="idw_+3A_coords">coords</code></td>
<td>

<p>A table wit x and y coordinates of the samples.
</p>
</td></tr>
<tr><td><code id="idw_+3A_grid">grid</code></td>
<td>

<p>Coordinates of locations to interpolate. It is assumed to be in the same 
order as 'values' table.
</p>
</td></tr>
<tr><td><code id="idw_+3A_method">method</code></td>
<td>

<p>Method to calculate weights for idw. Should be &quot;Shepard&quot; (default), 
&quot;Modified&quot;, &quot;Neighbours&quot;, or distinctive abreviations of each. See details
section for additional help on each method.
</p>
</td></tr>
<tr><td><code id="idw_+3A_p">p</code></td>
<td>

<p>The power to use in weight calculation.
</p>
</td></tr>
<tr><td><code id="idw_+3A_r">R</code></td>
<td>

<p>Radius to use with Modified Shepard method.
</p>
</td></tr>
<tr><td><code id="idw_+3A_n">N</code></td>
<td>

<p>Maximum number of neighbours to use with Shepard with neighbours.
</p>
</td></tr>
<tr><td><code id="idw_+3A_distfun">distFUN</code></td>
<td>

<p>Distance function used to calculate distances between locations.
The default is 'geo.dist' which calculates simple euclidean
distances between the locations. This function must have a 'from'
and a 'to' arguments to specify, respectively, the source and
destination localities.
</p>
</td></tr>
<tr><td><code id="idw_+3A_...">...</code></td>
<td>

<p>Other arguments to be passed to distFUN.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The IDW interpolation algorithm is commonly used to interpolate genetic
data over a spatial grid. This function provides a simple interface to
interpolate such data with three methods:
</p>

<ol>
<li><p><em>Shepard</em>: 
weights are the inverse of the distance between the interpolation
location <code class="reqn">x</code> and the sample points <code class="reqn">x_i</code>, raised to the 
power <code class="reqn">p</code>
</p>
<p style="text-align: center;"><code class="reqn">w(x) = \frac{1}{d(x, x_i)^p}</code>
</p>


</li>
<li><p><em>Modified Shepard</em>:
distances are weighted with a search radius <code class="reqn">r</code> to calculate the 
interpolation weights 
</p>
<p style="text-align: center;"><code class="reqn">w(x) = \left(\frac{r-d(x, x_i)}{r.d(x, xi)}\right)^p</code>
</p>


</li>
<li><p><em>Shepard with neighbours</em>:
A maximum ammount of <code class="reqn">N</code> neighbours is allowed to the weight 
calculation following Shepard method.

</p>
</li></ol>



<h3>Value</h3>

<p>It return a vector for each row of the 'coords' table with the respective
interpolated value.
</p>


<h3>Author(s)</h3>

<p>Pedro Tarroso &lt;ptarroso@cibio.up.pt&gt;
</p>


<h3>References</h3>

<p>Fortin, M. -J. and Dale, M. (2006) <em>Spatial Analysis: A guide for Ecologists</em>. Cambridge: Cambridge University Press.
</p>
<p>Isaaks, E. H. and Srivastava, R. M. (1989) <em>An Introduction to applied geostatistics</em>. New York: Oxford University Press.
</p>
<p>Legendre, P. and Legendre, L. (1998) <em>Numerical ecology</em>. 2nd english edition. Amesterdam: Elsevier
</p>
<p>Vandergast, A. G.,Hathaway, S. A., Fisher, R. N., Boys, J., Bohonak, A. J., 
(2008) Are hotspots evolutionary potential adequately protected in 
southern California? <em>Biological Conservation</em>, <b>141</b>, 1648-1664.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intgen.idw">intgen.idw</a></code>
<code><a href="#topic+krig">krig</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vipers)
data(d.gen)
data(grid)

# interpolate and plot the genetic distances for sample s2 in the d.gen
int &lt;- idw(d.gen[,2], vipers[,1:2], grid)

grid.image(int, grid, main='IDW interpolation', xlab='Longitude', 
           ylab='Latitude', sclab="Genetic distance to sample s2")

points(vipers[,1:2], cex=d.gen[,2]*15+0.2)

# change idw power (i.e. points will have a larger influence in the 
# surroundings)
int &lt;- idw(d.gen[,2], vipers[,1:2], grid, p=5)

result &lt;- data.frame(grid, int)
grid.image(int, grid, main='IDW interpolation', xlab='Longitude', 
           ylab='Latitude', sclab="Genetic distance to sample s2")

points(vipers[,1:2], cex=d.gen[,2]*15+0.2)


# change idw method to "Modified Shepard" and define a maximum 
# neighbour distance
int &lt;- idw(d.gen[,2], vipers[,1:2], grid, 'Modified', R=10)

grid.image(int, grid, main='IDW interpolation', xlab='Longitude', 
           ylab='Latitude', sclab="Genetic distance to sample s2")

points(vipers[,1:2], cex=d.gen[,2]*15+0.2)

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
#        Example following methods in Vandergast et al. 2008        #
#            Fit a linear model and recover the residuals           #
# ATENTION:                                                         #
#    1- Vandergast et al. (2008) suggests a RMA instead of a        # 
#       ordinary linear regression as in this example. Try package  # 
#       'lmodel2' or or other similar for RMA linear regression.    #
#    2- This example tests if the package 'geometry' is installed   #
#       to compute midpoints. If TRUE, a Delaunay triangulation is  # 
#       used, similarly to Vandergast et al. (2008). Otherwise,     #
#       midpoints are computed for the combination of all pairs of  #
#       samples.                                                    #
#                                                                   #
# the d.gen and d.real matrices in this example have the same       # 
# column and row order!                                             #
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#

if (is.element('geometry', installed.packages()[,1])) 
    all=FALSE else 
    all=TRUE

mp &lt;- midpoints(vipers[,1:2], all=all)
d.real &lt;- as.matrix(dist(vipers[,1:2]))

fit &lt;- lm(as.vector(d.gen) ~ as.vector(d.real))
resid &lt;- matrix(fit$residuals, nrow(vipers), nrow(vipers))
dimnames(resid) &lt;- dimnames(d.gen)
mp$z &lt;- extract.val(resid, mp[,1:2])

int &lt;- idw(mp[,5], mp[,3:4], grid)

grid.image(int, grid, main='IDW interpolation', 
           xlab='Longitude', ylab='Latitude', 
           sclab="Residuals of genetic vs. real distances")

# plot samples connecting lines
for (i in 1:nrow(mp))
{
    pair &lt;- as.character(unlist(mp[i,1:2]))
    x &lt;- c(vipers[pair[1],1], vipers[pair[2],1])
    y &lt;- c(vipers[pair[1],2], vipers[pair[2],2])
    lines(x, y, lty=2)
}
points(vipers[,1:2], pch=16) # plot samples points in black
points(mp[,3:4], pch=16, col='gray') # plot midpoints in gray

</code></pre>

<hr>
<h2 id='intgen.idw'>
Interpolation of genetic distances to a a grid of points.
</h2><span id='topic+intgen.idw'></span>

<h3>Description</h3>

<p>Interpolations of a matrix containing genetic distances using the Inverse
Distance Weighting (IDW) algorithm. It generates a matrix of interpolated
values for each grid cell and for each sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intgen.idw(d.real, d.gen, method = "Shepard", p = 2, R = 2, N = 15)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intgen.idw_+3A_d.real">d.real</code></td>
<td>

<p>distance matrix between sampled locals (columns) and locals where 
interpolation is to be executed (rows). Names should correspond to genetic
distances matrix.
</p>
</td></tr>
<tr><td><code id="intgen.idw_+3A_d.gen">d.gen</code></td>
<td>

<p>genetic distances matrix. Names should correspond to real distances matrix,
but not necessarily in the same order.
</p>
</td></tr>
<tr><td><code id="intgen.idw_+3A_method">method</code></td>
<td>

<p>Method to calculate weights for idw. Should be &quot;Shepard&quot; (default), 
&quot;Modified&quot;, &quot;Neighbours&quot;, or distinctive abreviations of each. See details
section for additional help on each method.
</p>
</td></tr>
<tr><td><code id="intgen.idw_+3A_p">p</code></td>
<td>

<p>The power to use in weight calculation.
</p>
</td></tr>
<tr><td><code id="intgen.idw_+3A_r">R</code></td>
<td>

<p>Radius to use with Modified Shepard method.
</p>
</td></tr>
<tr><td><code id="intgen.idw_+3A_n">N</code></td>
<td>

<p>Maximum number of neighbours to use with Shepard with neighbours.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The IDW interpolation algorithm is commonly used to interpolate genetic
data over a spatial grid. This function provides a simple interface to
interpolate such data with three methods:
</p>

<ol>
<li><p><em>Shepard</em>: 
weights are the inverse of the distance between the interpolation
location <code class="reqn">x</code> and the sample points <code class="reqn">x_i</code>, raised to the 
power <code class="reqn">p</code>
</p>
<p style="text-align: center;"><code class="reqn">w(x) = \frac{1}{d(x, x_i)^p}</code>
</p>


</li>
<li><p><em>Modified Shepard</em>:
distances are weighted with a search radius <code class="reqn">r</code> to calculate the 
interpolation weights 
</p>
<p style="text-align: center;"><code class="reqn">w(x) = \left(\frac{r-d(x, x_i)}{r.d(x, xi)}\right)^p</code>
</p>


</li>
<li><p><em>Shepard with neighbours</em>:
A maximum ammount of <code class="reqn">N</code> neighbours is allowed to the weight 
calculation following Shepard method.

</p>
</li></ol>

<p>The functions 'intgen.idw' and 'idw' are similar but whereas the first
interpolate all samples to a grid-based coordinates, the second
interpolates a single set of values. Although 'idw' can be used to
generate the same results, the 'intgen.idw' should be faster (see the
examples).
</p>


<h3>Value</h3>

<p>This function returns a matrix containing all interpolated values for each
locality (rows) and for each sample (columns)
</p>


<h3>Author(s)</h3>

<p>Pedro Tarroso &lt;ptarroso@cibio.up.pt&gt;
</p>


<h3>References</h3>

<p>Fortin, M. -J. and Dale, M. (2006) <em>Spatial Analysis: A guide for Ecologists</em>. Cambridge: Cambridge University Press.
</p>
<p>Isaaks, E. H. and Srivastava, R. M. (1989) <em>An Introduction to applied geostatistics</em>. New York: Oxford University Press.
</p>
<p>Legendre, P. and Legendre, L. (1998) <em>Numerical ecology</em>. 2nd english edition. Amesterdam: Elsevier
</p>


<h3>See Also</h3>

<p><code><a href="#topic+idw">idw</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(vipers)
    data(d.gen)
    data(grid)

    # create a matrix of distances from sample points (columns) to all
    # grid pixels
    rd &lt;- geo.dist(grid, vipers[,1:2])

    #interpolate with idw
    result &lt;- intgen.idw(rd, d.gen)

    #plot the 12 random interpolations
    layout(matrix(c(1:12), 4,3))

    for (i in sample(1:nrow(vipers), 12))
    {
        dt &lt;- data.frame(grid, int=result[,i])
        # when samples are given with real coordinates, aspect of image 
        # should be maintained with asp=1 to plot properly. 
        image(sort(unique(grid[,1])), sort(unique(grid[,2])), 
              xtabs(int~x+y, dt), xlab='Longitude', ylab='Latitude', 
              main=colnames(result)[i])
        cex &lt;- (d.gen[,i]-min(d.gen[,i]))/(max(d.gen[,i])-min(d.gen[,i]))
        points(vipers[,1:2], cex=cex+0.5)
    }

## Not run: 
    # Compare 'idw' with 'intgen.idw' to generate the same results.
    # NOTE: it may take a few minutes to run.
    result2 &lt;- matrix(NA, nrow=nrow(grid), ncol=nrow(vipers))
    for (i in 1:nrow(vipers)) {
        values &lt;- d.gen[i,]
        intpl &lt;- idw(values, vipers[,1:2], grid)
        result2[,i] &lt;- intpl[,1]
    }
    colnames(result2) &lt;- rownames(vipers)

    # compare all items in the two matrices to check equality:
    all(result == result2)

## End(Not run)
</code></pre>

<hr>
<h2 id='krig'>
Simple and ordinary kriging.
</h2><span id='topic+krig'></span>

<h3>Description</h3>

<p>Computes simple or ordinary kringing using a list of sampled locations.
The interpolation is executed to the table of coordinates given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>krig(values, coords, grid, gv, distFUN = geo.dist, ..., m=NA, cv=FALSE,
     neg.weights = TRUE, clamp = FALSE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krig_+3A_values">values</code></td>
<td>

<p>A vector of values per sampled location.
</p>
</td></tr>
<tr><td><code id="krig_+3A_coords">coords</code></td>
<td>

<p>A table containing longitude and latitude of sample locations for each
value.
</p>
</td></tr>
<tr><td><code id="krig_+3A_grid">grid</code></td>
<td>

<p>A table containing the coordinates of locations to interpolate
</p>
</td></tr>
<tr><td><code id="krig_+3A_gv">gv</code></td>
<td>

<p>A fitted model to variogram as given by 'gv.model' function.
</p>
</td></tr>
<tr><td><code id="krig_+3A_distfun">distFUN</code></td>
<td>

<p>Distance function used to calculate distances between locations.
The default is 'geo.dist' which calculates simple euclidean
distances between the locations. This function must have a 'from'
and a 'to' arguments to specify, respectively, the source and
destination localities. Other functions can be given to include,
for instance, a landscape resistance (see examples and vignette).
</p>
</td></tr>
<tr><td><code id="krig_+3A_...">...</code></td>
<td>

<p>Other arguments to be passed to distFUN.
</p>
</td></tr>
<tr><td><code id="krig_+3A_m">m</code></td>
<td>

<p>A value for the mean. When the mean is known and given, a simple kriging
is used for the interpolation. If m = NA (default) then the mean is
estimated using ordinary kriging.
</p>
</td></tr>
<tr><td><code id="krig_+3A_cv">cv</code></td>
<td>

<p>A logical value to perform cross validation of the interpolation.
</p>
</td></tr>
<tr><td><code id="krig_+3A_neg.weights">neg.weights</code></td>
<td>

<p>A logical value indicating if negative weights are allowed in the
calculation. If FALSE, negative weights are corrected and eliminating the
need for clamping. See details.
</p>
</td></tr>
<tr><td><code id="krig_+3A_clamp">clamp</code></td>
<td>

<p>A logical value indicating if Z values will be adjusted to the interval
[0,1].
</p>
</td></tr>
<tr><td><code id="krig_+3A_verbose">verbose</code></td>
<td>

<p>A logical indicating if the function should be verbose.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function interpolates the probability of lineage occurrence to all
locations given in 'coords'. Usually 'coords' stores coordinates of
pixel centroids representing the study area with a user-defined spatial
resolution. The variogram with a fitted model describes the
autocorrelation structure of the genetic data. This is used by kriging
to determine the weight of the sampled points on the location to
predict a value.
</p>
<p>The most usual kriging is performed with geographical distances
between localities (samples and grid). The default function is the
'geo.dist' that calculate simple euclidean distances. However, the
'krig' function allows to provide user-defined distance functions to
calculate other kind of distances. A landscape resistance, for
instance, may be used to calculate cost distances between points and
to be used in the interpolation process. The same distance function
provided here has to be used before, to produce the variogram. The
function 'distFUN' has to have the arguments 'from' and 'to' to
use as source and destination coordinates, respectively. It may have
other arguments that can be passed to the function. See the vignette
for a exhaustive example on how to use this functionality.
</p>
<p>The kriging algorithm often produce negative weights for the interpolation.
This results in predictions outside the original range between zero and one.
Correcting negative weights allows to maintain predictions in this range and
to preserve kriging proprieties. Correction of negative weights is done
following Deutsch (1996): negative weights and small positive weights
(within the variation of the negative weights) are set to zero and the sum
of the resulting weights rescaled to one.
</p>
<p>Cross-validation is computed by leaving each of the observation in 'values'
out of kriging and predict for the same location. A mean squared error
(MSE) is computed using the original observation and the predicted value.
</p>


<h3>Value</h3>

<p>Returns a vector of interpolated values and respective variance for each
location in 'coords'.
</p>
<p>If cross-validation is performed (cv=TRUE) than a list of interpolation
and variance values is given with a cross-validation matrix (original
observation and predicted value) and a mean squared error (MSE).
</p>


<h3>Author(s)</h3>

<p>Pedro Tarroso &lt;ptarroso@cibio.up.pt&gt;
</p>


<h3>References</h3>

<p>Deutsch C. V. (1996) <em>Correcting for negative weights in ordinary kriging</em>. Computers and Geosciences, 22(7), 765-773.
</p>
<p>Fortin, M. -J. and Dale, M. (2006) <em>Spatial Analysis: A guide for Ecologists</em>. Cambridge: Cambridge University Press.
</p>
<p>Isaaks, E. H. and Srivastava, R. M. (1989) <em>An Introduction to applied geostatistics</em>. New York: Oxford University Press.
</p>
<p>Legendre, P. and Legendre, L. (1998) <em>Numerical ecology</em>. 2nd english edition. Amesterdam: Elsevier
</p>


<h3>See Also</h3>

<p><code>gen.variogram</code>
<code>plot.gv</code>
<code>predict.gv</code>
<code>idw</code>
<code><a href="#topic+intgen.idw">intgen.idw</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vipers)
data(d.gen)
data(grid)

# In this example we want to create the probable distribution of a
# lineage based on the genetic distance. We need a vector defining if
# each sample belongs or not to the lineage
lin &lt;- as.integer(vipers$lin == 1)

# create a distance matrix between samples
r.dist &lt;- dist(vipers[,1:2])

# fit a model with defaults (spherical model) and estimation of range
gv &lt;- gen.variogram(r.dist, d.gen)
gv &lt;- gv.model(gv)

# perform interpolation with ordinary kriging
int.krig &lt;- krig(lin, vipers[,1:2], grid, gv)

#plot the interpolation results
grid.image(int.krig, grid, main='Kriging with genetic distances',
           xlab='Longitude', ylab='Latitude',
           sclab='Lineage interpolation')
points(vipers[,1:2], pch=lin+1)

# plot the interpolation standard variance
grid.image(int.krig, grid, ic='sd',
           main='Kriging with genetic distances',
           xlab='Longitude', ylab='Latitude',
           sclab='Standard deviation')
points(vipers[,1:2], pch=lin+1)

#plot only pixels higher than 0.95
lin.krig &lt;- as.integer(int.krig$Z&gt;0.95)
grid.image(lin.krig, grid, main='Kriging with genetic distances',
           xlab='Longitude', ylab='Latitude', sclab='Lineage')
points(vipers[,1:2], pch=lin+1)

## Not run: 
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# The following code is an example to combine the possible clusters   #
#  of a tree in a single map. It samples the tree at different length #
# and combines the probabilities.                                     #
#                                                                     #
#                NOTE: it may take some time to run!                  #
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#

# A phylogenetic tree is sampled at different lengths. An appropriate
# package (e.g. ape) should be used to process the tree. To avoid extra
# dependencies we convert the genetic distances to an hclust.

hc &lt;- hclust(as.dist(d.gen))
hs = seq(0.01, 0.08, 0.005) # tree length sampling

# Another options for tree sampling can be using the nodes position,
# avoiding the root and tip levels:
# hs &lt;- hc$height[hc$height &gt; 0.0 &amp; hc$height &lt; max(hc$height)]
#
# Or a single threshold:
# hs &lt;- 0.06

contact = rep(0, nrow(grid)) # Sums all probabilities
for (h in hs) {
    lins &lt;- cutree(hc, h=h)
    print(paste("height =", h, ":", max(lins), "lineages")) #keep track
    ct = rep(1, nrow(grid)) # Product of individual cluster/lineage map
    for (i in unique(lins)) {
        lin &lt;- as.integer(lins == i)
        krg &lt;- krig(lin, vipers[,1:2], grid, gv,
                    clamp = TRUE, verbose=FALSE)
        # Probability of NOT belonging to a cluster.
        ct &lt;- ct * (1 - krg$Z) # Probab. of NOT belonging to a cluster
    }
    contact = contact + ct
}
krg$Z &lt;- contact / length(hs) # Recycle krg with contact zones

#plot the interpolation results
grid.image(krg, grid, xlab='Longitude', ylab='Latitude',
           main='Uncertainty in cluster classification / contact zones')
points(vipers[,1:2], pch=16, cex=0.5)

## End(Not run)
</code></pre>

<hr>
<h2 id='midpoints'>
Midpoints between pairs of coordinates
</h2><span id='topic+midpoints'></span>

<h3>Description</h3>

<p>Computes the midpoints for a table of sample points with coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>midpoints(samples, x=1, y=2, sp.name=row.names(samples), all=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="midpoints_+3A_samples">samples</code></td>
<td>

<p>Table with coordinates for each sample point.
</p>
</td></tr>
<tr><td><code id="midpoints_+3A_x">x</code></td>
<td>

<p>Column index or name of longitudes (x) in samples table (default is first column).
</p>
</td></tr>
<tr><td><code id="midpoints_+3A_y">y</code></td>
<td>

<p>Column index or name of latitudes (y) in samples table (default is second column).
</p>
</td></tr>
<tr><td><code id="midpoints_+3A_sp.name">sp.name</code></td>
<td>

<p>Name for each sample point (defaults to row names of samples).
</p>
</td></tr>
<tr><td><code id="midpoints_+3A_all">all</code></td>
<td>

<p>If TRUE computes midpoints between all sample points. If FALSE (default) 
computes a Delaunay triangulation and the midpoints of the resulting
connected samples.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the coordinates of the middle points between 
samples. The connecting network can be between all points or between 
neighbours with non-overlaping edges after a Delaunay triangulation.
</p>


<h3>Value</h3>

<p>Returns a data frame with 4 columns referring the source and target
samples (ss and ts, respectively) and the coordinates of the midpoints.
</p>


<h3>Note</h3>

<p>Depends on package 'geometry' for Delaunay triangulation.
</p>


<h3>Author(s)</h3>

<p>Pedro Tarroso &lt;ptarroso@cibio.up.pt&gt;
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code>
<code><a href="#topic+d.gen">d.gen</a></code>
<code><a href="#topic+extract.val">extract.val</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(vipers)
mp &lt;- midpoints(vipers[,1:2], all=TRUE) 
# With 'all=FALSE' (Delaunay triang.), package 'geometry' is mandatory.

</code></pre>

<hr>
<h2 id='mpinv'>
Generalized inverse of a matrix
</h2><span id='topic+mpinv'></span>

<h3>Description</h3>

<p>Computes the generalized inverse of a matrix using singular-value
decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpinv(A, eps = 1e-13)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpinv_+3A_a">A</code></td>
<td>

<p>Matrix to be inverted.
</p>
</td></tr>
<tr><td><code id="mpinv_+3A_eps">eps</code></td>
<td>

<p>Minimum value threshold.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix containing the inverse of matrix A.
</p>


<h3>Author(s)</h3>

<p>Pedro Tarroso &lt;ptarroso@cibio.up.pt&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    m &lt;- matrix(rnorm(16), 4, 4)
    mi &lt;- mpinv(m)
</code></pre>

<hr>
<h2 id='mtest.gv'>
Tests if a 'gv' object has a model.
</h2><span id='topic+mtest.gv'></span>

<h3>Description</h3>

<p>Tests if the semi-variogram in the 'gv' object has a model fitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    mtest.gv(gv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mtest.gv_+3A_gv">gv</code></td>
<td>

<p>An object with class 'gv'.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is usefull to test if a model for the semi-variogram in 'gv'
is already built.
</p>


<h3>Value</h3>

<p>logical
</p>


<h3>Note</h3>

<p>It is not exported.
</p>


<h3>Author(s)</h3>

<p>Pedro Tarroso &lt;ptarroso@cibio.up.pt&gt;
</p>

<hr>
<h2 id='multispecies'>
Summarizes data from multiple species.
</h2><span id='topic+multispecies'></span>

<h3>Description</h3>

<p>This function may be used to summarize data from different species or 
similar (e.g. different lineages, etc). By default, it summarizes with
the mean and standard deviation, but different functions may be used. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multispecies(..., FUN=list(mean=mean, sd=sd), na.rm=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multispecies_+3A_...">...</code></td>
<td>

<p>Input data to be summarized. It must be numeric and it can be multiple
vectors of the same size and order, or more simply a matrix with all
data to be summarised. The matrix must have the different species/data in 
columns. 
</p>
</td></tr>
<tr><td><code id="multispecies_+3A_fun">FUN</code></td>
<td>

<p>This is a list of functions to be applied to summarize the data. By default
it uses the mean and sd, but it can be any other function that returns a
number from a vector (e.g. max, min) or a user-defined function. If the
objects are named in the FUN list, than those names will be given to the
resulting columns. Otherwise, function are applied in the same order as
given.
</p>
</td></tr>
<tr><td><code id="multispecies_+3A_na.rm">na.rm</code></td>
<td>

<p>A logical indicating whether missing values should be removed. Will only
work if the functions in FUN accept it. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a simple wrapper with some error checking for the native
R function 'apply'. 
</p>


<h3>Value</h3>

<p>Returns a matrix with functions applied in the same order as FUN.
</p>


<h3>Author(s)</h3>

<p>Pedro Tarroso &lt;ptarroso@cibio.up.pt&gt;
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+apply">apply</a></code>
<code><a href="stats.html#topic+princomp">princomp</a></code>
<code><a href="stats.html#topic+prcomp">prcomp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vipers)
data(d.gen)
data(grid)

# create a matrix of distances from sample points (columns) to all
# grid pixels
rd &lt;- geo.dist(grid, vipers[,1:2])

#interpolate with idw
result &lt;- intgen.idw(rd, d.gen)

ms &lt;- multispecies(result)

# plot the mean
grid.image(ms, grid, main = "Mean")

# plot the standard deviation
grid.image(ms, grid, ic=2, main = "Standard Deviation")
</code></pre>

<hr>
<h2 id='phylin-package'>
Phylogenetic Landscape Interpolation.
</h2><span id='topic+phylin-package'></span><span id='topic+phylin'></span>

<h3>Description</h3>

<p>This package provides functions for the spatial interpolation
of genetic distances between samples. The interpolation is
based on a modified kriging method that accepts a genetic
distance matrix and generates a map of probability of lineage
presence. This package also offers tools to generate a map of
potential contact zones between groups with user-defined
thresholds in the tree to account for old and recent
divergence. Additionally, it has functions for IDW
interpolation using genetic data and midpoints.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> phylin</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2016-04-27</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The kriging algorithm uses a model fitted to the semi-variogram to weight
the values of the samples. Here the variogram was modified to fit a
model with pairwise comparison between genetic and real distances,
describing the spatial dependence in the genetic distance between samples.
A map for the lineage can be generated using only a vector that define if
each point belong to the a lineage or not.
</p>
<p>Since version 2.0, the kriging interpolation can be performed taking
into consideration a cost distance instead of simple geographical
distances between points. This can help in cases where a landscape
resistance explains better the genetic distances between samples
than the geographic distances alone.
</p>
<p>The IDW can be used to interpolate the genetic distance of each sample
against the others, or to interpolate genetic diverge at midpoints between
samples. The interpolated value at certain location is obtained by
weighting with the distances to the avaialable samples. Similarly to
kriging, these distance can be based on a cost distance calculation.
</p>


<h3>Author(s)</h3>

<p>Pedro Tarroso, Guillermo Velo-Anton, Silvia Carvalho
</p>
<p>Maintainer: Pedro Tarroso &lt;ptarroso@cibio.up.pt&gt;
</p>


<h3>References</h3>

<p>Tarroso, P., Velo-Anton, G., &amp; Carvalho, S.B. (2015). PHYLIN: an R package for phylogeographic interpolation. Molecular Ecology Resources, 15(2), 349-357.
</p>
<p>Tarroso, P., Carvalho, S.B. &amp; Velo-Anton, G. (2019). PHYLIN 2.0: Extending the phylogeographic interpolation method to include uncertainty and user-defined distance metrics. Molecular Ecology Resources, in press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## See examples for the included functions.
</code></pre>

<hr>
<h2 id='plot.gv'>
Plot a 'gv' object
</h2><span id='topic+plot.gv'></span>

<h3>Description</h3>

<p>Plot the semi-variogram in a gv object. If a multiple genetic
distances are found, it plots the median value and the 95% confidence
interval for the median.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gv'
plot(x, line.res = 100, pch=1, legend=TRUE, leg.x=NA,
                  leg.y=NA, leg.cex=1, bar.length=0.1, bar.col="gray",
                  bar.lty=par("lty"), xlab='Distance', ylab='Semivariance',
                  x.line=3, y.line=3, ncol=1, main=NULL,
                  leg.label = expression(italic('n')*' size'), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gv_+3A_x">x</code></td>
<td>

<p>'gv' object as given by 'gen.variogram'.
</p>
</td></tr>
<tr><td><code id="plot.gv_+3A_line.res">line.res</code></td>
<td>

<p>Number of points in the model line.
</p>
</td></tr>
<tr><td><code id="plot.gv_+3A_pch">pch</code></td>
<td>

<p>Symbol to be used in the plot.
</p>
</td></tr>
<tr><td><code id="plot.gv_+3A_legend">legend</code></td>
<td>

<p>Boolean indicating if a legend showing <em>n</em> size should be printed.
</p>
</td></tr>
<tr><td><code id="plot.gv_+3A_leg.x">leg.x</code></td>
<td>

<p>The x position for the legend. The legend will be placed at the right
side of the plot if this value is set to NA.
</p>
</td></tr>
<tr><td><code id="plot.gv_+3A_leg.y">leg.y</code></td>
<td>

<p>The y position for the legned. The legend will be placed at the bottom
of the plot if this value is set to NA.
</p>
</td></tr>
<tr><td><code id="plot.gv_+3A_leg.cex">leg.cex</code></td>
<td>

<p>Multiplication factor for the legend symbol size.
</p>
</td></tr>
<tr><td><code id="plot.gv_+3A_bar.length">bar.length</code></td>
<td>

<p>If multiple trees are given, confidence interval bars are ploted. The
horizontal length of the line at both bar tips is defined with this
parameter (defaults to 0.1).
</p>
</td></tr>
<tr><td><code id="plot.gv_+3A_bar.col">bar.col</code></td>
<td>

<p>The color of the bars when multiple trees are given.
</p>
</td></tr>
<tr><td><code id="plot.gv_+3A_bar.lty">bar.lty</code></td>
<td>

<p>The line type for the bars when multiple tree are given.
</p>
</td></tr>
<tr><td><code id="plot.gv_+3A_xlab">xlab</code></td>
<td>

<p>The label for x axis.
</p>
</td></tr>
<tr><td><code id="plot.gv_+3A_ylab">ylab</code></td>
<td>

<p>The label for y axis.
</p>
</td></tr>
<tr><td><code id="plot.gv_+3A_x.line">x.line</code></td>
<td>

<p>Position of x label in lines.
</p>
</td></tr>
<tr><td><code id="plot.gv_+3A_y.line">y.line</code></td>
<td>

<p>Position of y label in lines.
</p>
</td></tr>
<tr><td><code id="plot.gv_+3A_ncol">ncol</code></td>
<td>

<p>Number of legend columns.
</p>
</td></tr>
<tr><td><code id="plot.gv_+3A_main">main</code></td>
<td>

<p>Main title of the plot.
</p>
</td></tr>
<tr><td><code id="plot.gv_+3A_leg.label">leg.label</code></td>
<td>

<p>Legend title.
</p>
</td></tr>
<tr><td><code id="plot.gv_+3A_...">...</code></td>
<td>

<p>Further plotting arguments to be passed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple plot of the semi-variogram contained in a 'gv' object. If the object
has a model, the model line is also plotted.
</p>


<h3>Value</h3>

<p>Plot.
</p>


<h3>Author(s)</h3>

<p>Pedro Tarroso &lt;ptarroso@cibio.up.pt&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.variogram">gen.variogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vipers)
data(d.gen)

# create a distance matrix between samples
r.dist &lt;- dist(vipers[,1:2])

# fit a variogram with defaults (shperical model) and estimation of range
gv &lt;- gen.variogram(r.dist, d.gen, 0.25)

#plot semi-variogram
plot(gv)

# plot semi-variogram with model
gv &lt;- gv.model(gv)
plot(gv)
</code></pre>

<hr>
<h2 id='predict.gv'>
Predict method for 'gen.variogram' object with model.
</h2><span id='topic+predict.gv'></span>

<h3>Description</h3>

<p>Predicts values based on a fitted gen.variogram model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gv'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.gv_+3A_object">object</code></td>
<td>

<p>'gv' fitted model (see 'gen.variogram').
</p>
</td></tr>
<tr><td><code id="predict.gv_+3A_newdata">newdata</code></td>
<td>

<p>Real distances matrix to predict genetic distance by the fitted model.
</p>
</td></tr>
<tr><td><code id="predict.gv_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the matrix of predicted genetic distances. 
</p>


<h3>Author(s)</h3>

<p>Pedro Tarroso &lt;ptarroso@cibio.up.pt&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.variogram">gen.variogram</a></code>
<code><a href="#topic+plot.gv">plot.gv</a></code>
<code><a href="#topic+krig">krig</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vipers)
data(d.gen)

# create a grid of the sampled area for interpolation
grid &lt;- expand.grid(x=seq(-10,10,0.5), y=seq(30, 50, 0.5))

# create a distance matrix between samples
r.dist &lt;- dist(vipers[,1:2])

# fit a variogram with defaults (spherical model) and estimation of range
gv &lt;- gen.variogram(r.dist, d.gen)
gv &lt;- gv.model(gv)

all.dist &lt;- as.matrix(dist(grid))

result &lt;- predict(gv, all.dist)

</code></pre>

<hr>
<h2 id='print.gv'>
Prints details of a 'gv' object
</h2><span id='topic+print.gv'></span>

<h3>Description</h3>

<p>The function is used when a 'gv' object is called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gv'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gv_+3A_x">x</code></td>
<td>

<p>'gv' object as given by 'gen.variogram'.
</p>
</td></tr>
<tr><td><code id="print.gv_+3A_...">...</code></td>
<td>

<p>Further plotting arguments to be passed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This prints the details of a 'gv' object including number of observations
and other variogram creation parameters used. It will also display model
details if a model was fitted to the empirical variogram.
</p>


<h3>Author(s)</h3>

<p>Pedro Tarroso &lt;ptarroso@cibio.up.pt&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.variogram">gen.variogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vipers)
data(d.gen)

# create a distance matrix between samples
r.dist &lt;- dist(vipers[,1:2])

# fit a variogram with defaults (shperical model) and estimation of range
gv &lt;- gen.variogram(r.dist, d.gen, 0.25)

# print variogram details
gv

# add a model to variogram
gv &lt;- gv.model(gv)

# print variogram with model details
gv
</code></pre>

<hr>
<h2 id='simul.env'>
Simulated environments.
</h2><span id='topic+simul.env'></span>

<h3>Description</h3>

<p>A table with two gridded simulation environments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simulations)</code></pre>


<h3>Format</h3>

<p>'simul.env' is a data frame with 1849 rows and 4 columns. Each row is a cell
in the gridded surface. The column one and two are the x and y centroid
coordinates of each cell, respectively. The third and fourth columns are the
two simulates environments.
</p>


<h3>References</h3>

<p>Tarroso, P., Carvalho, S.B. &amp; Velo-Anton, G. (2019). PHYLIN 2.0: Extending the phylogeographic interpolation method to include uncertainty and user-defined distance metrics. Molecular Ecology Resources, in press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simulations)
# Plot the second environmental surface: negative values as open circles and
# positive as solid black circles. Size proportional to absolute value
plot(simul.env[,1:2], pch=1, cex=simul.env[,4]/5)
points(simul.env[,1:2], pch=16, cex=-simul.env[,4]/5)
</code></pre>

<hr>
<h2 id='simul.gen.dist'>
Simulated genetic distances.
</h2><span id='topic+simul.gen.dist'></span>

<h3>Description</h3>

<p>A 'dist' class object with simulated genetic distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simulations)</code></pre>


<h3>Format</h3>

<p>'simul.gen.dist' is an object with 'dist' class containing the simulated
genetic distances of 200 samples.
</p>


<h3>References</h3>

<p>Tarroso, P., Carvalho, S.B. &amp; Velo-Anton, G. (2019). PHYLIN 2.0: Extending the phylogeographic interpolation method to include uncertainty and user-defined distance metrics. Molecular Ecology Resources, in press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simulations)
hc &lt;- hclust(as.dist(simul.gen.dist))
plot(hc, main="Simulated gentic distances", xlab="Samples", cex=0.7)
</code></pre>

<hr>
<h2 id='simul.sample'>
Random samples from simulation.
</h2><span id='topic+simul.sample'></span>

<h3>Description</h3>

<p>A table with x and y coordinates of 200 random samples in the simulated grid
and a lineage information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simulations)</code></pre>


<h3>Format</h3>

<p>'simul.sample' is a data frame with 200 rows and 3 columns. Each row is a
sample in the simulated grid. The column one and two are the x and y
coordinates of each sample, respectively. The lineage to which each sample
belongs is given in the third column.
</p>


<h3>References</h3>

<p>Tarroso, P., Carvalho, S.B. &amp; Velo-Anton, G. (2019). PHYLIN 2.0: Extending the phylogeographic interpolation method to include uncertainty and user-defined distance metrics. Molecular Ecology Resources, in press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simulations)
# Plot all the samples with different symbols for each lineage.
plot(simul.sample[,1:2], pch=simul.sample[,3])
</code></pre>

<hr>
<h2 id='summary.gv'>
Summary for 'gv' object
</h2><span id='topic+summary.gv'></span>

<h3>Description</h3>

<p>Displays general information about the 'gv' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gv'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gv_+3A_object">object</code></td>
<td>

<p>'gv' object as given by 'gen.variogram' or 'gv.model'.
</p>
</td></tr>
<tr><td><code id="summary.gv_+3A_...">...</code></td>
<td>

<p>Further plotting arguments to be passed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print summary table.
</p>


<h3>Author(s)</h3>

<p>Pedro Tarroso &lt;ptarroso@cibio.up.pt&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.variogram">gen.variogram</a></code>
<code><a href="#topic+gv.model">gv.model</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vipers)
data(d.gen)

# create a distance matrix between samples
r.dist &lt;- dist(vipers[,1:2])

# fit a variogram with defaults (shperical model) and estimation of range
gv &lt;- gen.variogram(r.dist, d.gen)

#plot semi-variogram
summary(gv)

# plot semi-variogram with model
gv &lt;- gv.model(gv)
summary(gv)
</code></pre>

<hr>
<h2 id='vipers'>
Vipers sample locations for 'd.gen' dataset.
</h2><span id='topic+vipers'></span>

<h3>Description</h3>

<p>This dataset contains the x and y coordinates of 58 <em>Vipera latastei</em>
samples with corresponding lineages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(vipers)</code></pre>


<h3>Format</h3>

<p>A data frame with 3 columns (x/Longitude, y/Latitude and lineage) and 58
rows. 
</p>


<h3>Source</h3>

<p>Velo-Anton G., Godinho R., Harris D. J. <em>et al.</em> (2012) Deep evolutionary lineages in a Western Mediterranean snake (<em>Vipera latastei</em>/<em>monticola</em> group) and high genetic structuring in Southern Iberian populations. <em>Molecular phylogenetics and evolution</em>, <b>65</b>, 965&ndash;973.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vipers)
data(grid)
plot(grid, cex=0.5, col='lightgrey', asp=1,
     main="Vipers data", xlab="Longitude", ylab="Latitude")
points(vipers[,1:2], pch=vipers$lin)
legend(1, 38, legend=c("West", "South", "East"), pch=1:3, title="Lineages")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
