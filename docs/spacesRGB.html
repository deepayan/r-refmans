<!DOCTYPE html><html lang="en"><head><title>Help for package spacesRGB</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spacesRGB}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Basic+20Parameterized+20TransferFunctions'>
<p>Basic Parameterized TransferFunctions</p></a></li>
<li><a href='#Basic+20TransferFunctions'>
<p>Basic TransferFunctions</p></a></li>
<li><a href='#composition'><p>The composition of TransferFunction objects</p></a></li>
<li><a href='#Digital+20Cinema+20Distribution+20Master'>
<p>Digital Cinema Distribution Master, the EOTF of DCDM</p></a></li>
<li><a href='#Full+20Range+20to+20SMPTE+20Range'>
<p>Full Range to SMPTE Range</p></a></li>
<li><a href='#Hybrid+20Log-Gamma+20Transform'>
<p>Hybrid Log-Gamma Transform</p></a></li>
<li><a href='#inverse'><p>The inverse of a TransferFunction Object</p></a></li>
<li><a href='#Linear+20RGB+2C+20XYZ+2C+20and+20Lab+20Calculation'><p>Convert Signal RGB coordinates to Linear RGB, XYZ, or Lab</p></a></li>
<li><a href='#metadata'><p>metadata of a TransferFunction object</p></a></li>
<li><a href='#miscTF'><p>Miscellaneous TransferFunction Methods</p></a></li>
<li><a href='#Opto-Optical+20Transfer+20Function+2C+20parameterized'>
<p>Opto-Optical Transfer Function, general</p></a></li>
<li><a href='#Partial+20Output+20Device+20Transform+2C+20parameterized'>
<p>Partial Output Device Transform, general</p></a></li>
<li><a href='#Perceptual+20Quality+20Transform'>
<p>Perceptual Quality Transform</p></a></li>
<li><a href='#plot'><p>plot a TransferFunction</p></a></li>
<li><a href='#plotPatchesRGB'><p>Plot Patches defined by RGB</p></a></li>
<li><a href='#print'><p>Print Basic Facts about a TransferFunction</p></a></li>
<li><a href='#Reference+20Rendering+20Transform'>
<p>Reference Rendering Transform</p></a></li>
<li><a href='#RGB+20Space+20Management'><p>Manage RGB Spaces</p></a></li>
<li><a href='#RGB+20Space+20Query'><p>Query RGB Spaces</p></a></li>
<li><a href='#Signal+20RGB+20Calculation'><p>Calculate Signal RGB from Linear RGB, XYZ, or Lab</p></a></li>
<li><a href='#Standard+20Primaries'>
<p>Standard Primaries</p></a></li>
<li><a href='#transfer'><p>Apply TransferFunction to a Vector or an Array</p></a></li>
<li><a href='#TransferFunction'><p>Constructing and Testing TransferFunction Objects</p></a></li>
<li><a href='#validate'><p>Validate a TransferFunction by applying some simple Tests</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Standard and User-Defined RGB Color Spaces, with Conversion
Between RGB and CIE XYZ and Lab</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7-0</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-16</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Glenn Davis &lt;gdavis@gluonics.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>logger</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spacesXYZ, rgl, microbenchmark, knitr, rmarkdown</td>
</tr>
<tr>
<td>Description:</td>
<td>Standard RGB spaces included are sRGB, 'Adobe' RGB, 'ProPhoto' RGB, BT.709, and others.  User-defined RGB spaces are also possible.  There is partial support for ACES Color workflows.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-16 00:03:36 UTC; Glenn</td>
</tr>
<tr>
<td>Author:</td>
<td>Glenn Davis [aut, cre]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-16 03:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Basic+20Parameterized+20TransferFunctions'>
Basic Parameterized TransferFunctions
</h2><span id='topic+power.OETF'></span><span id='topic+power.EOTF'></span><span id='topic+power.OOTF'></span><span id='topic+affine.TF'></span><span id='topic+BT.1886.EOTF'></span><span id='topic+XYZfromRGB.TF'></span>

<h3>Description</h3>

<p>Each of these functions <em>returns</em> a <code>TransferFunction</code> object,
that depends on the argument values passed to it.
The returned object has the parameter values &quot;locked in&quot;.
These <code>TransferFunction</code> objects are a mixture of EOTFs, OETFs, OOTFs, and general-purpose transfer functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power.OETF( gamma )
power.EOTF( gamma )
power.OOTF( gamma )
BT.1886.EOTF( gamma=2.4, Lb=0, Lw=1 )
XYZfromRGB.TF( primaries, white )
affine.TF( y0, y1 )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Basic+2B20Parameterized+2B20TransferFunctions_+3A_gamma">gamma</code></td>
<td>
<p>the value of <code class="reqn">\gamma</code>; it must be positive</p>
</td></tr>
<tr><td><code id="Basic+2B20Parameterized+2B20TransferFunctions_+3A_lb">Lb</code></td>
<td>
<p>the black level</p>
</td></tr>
<tr><td><code id="Basic+2B20Parameterized+2B20TransferFunctions_+3A_lw">Lw</code></td>
<td>
<p>the white level</p>
</td></tr>
<tr><td><code id="Basic+2B20Parameterized+2B20TransferFunctions_+3A_primaries">primaries</code></td>
<td>
<p>a 3x2 or 4x2 matrix; see <b>Details</b></p>
</td></tr>
<tr><td><code id="Basic+2B20Parameterized+2B20TransferFunctions_+3A_white">white</code></td>
<td>
<p>a vector of length 1, 2, or 3; see <b>Details</b></p>
</td></tr>
<tr><td><code id="Basic+2B20Parameterized+2B20TransferFunctions_+3A_y0">y0</code></td>
<td>
<p>the number to which 0 maps</p>
</td></tr>
<tr><td><code id="Basic+2B20Parameterized+2B20TransferFunctions_+3A_y1">y1</code></td>
<td>
<p>the number to which 1 maps</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are 3 valid combinations of <code>primaries</code> and <code>white</code>, as given in this table:
</p>

<table>
<tr>
 <td style="text-align: center;">
<code>dim(primaries)</code>  </td><td style="text-align: center;"> <code>length(white)</code> </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: center;">
4x2 </td><td style="text-align: center;"> 1 </td><td style="text-align: left;">  <code>primaries</code> is a 4x2 matrix with CIE xy chromaticities of R,G,B,W in the rows</td>
</tr>
<tr>
 <td style="text-align: center;">
3x2 </td><td style="text-align: center;"> 2 </td><td style="text-align: left;">  <code>primaries</code> is a 3x2 matrix with CIE xy chromaticities of R,G,B in the rows</td>
</tr>
<tr>
 <td style="text-align: center;">
3x2 </td><td style="text-align: center;"> 3 </td><td style="text-align: left;">  <code>primaries</code> is a 3x2 matrix with CIE xy chromaticities of R,G,B in the rows</td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>If <code>length(white)</code> is 1, then <code>white</code> is the whitepoint Y.
If <code>length(white)</code> is 2, then <code>white</code> is the whitepoint xy (CIE chromaticity); 
the whitepoint Y is taken to be 1.
If <code>length(white)</code> is 3, <code>white</code> is the whitepoint XYZ (CIE tristimulus).
<br />
<code>primaries</code> can also be a plain numeric vector of length 6 or 8,
which is then converted to a 3x2 or 4x2 matrix, by row.
</p>


<h3>Value</h3>

<p><code>power.OETF()</code> returns a <code><a href="#topic+TransferFunction">TransferFunction</a></code> with the classical <code class="reqn">1/\gamma</code> power law.
<code>power.EOTF()</code> returns a <code><a href="#topic+TransferFunction">TransferFunction</a></code> with the classical <code class="reqn">\gamma</code> power law.
<code>power.OOTF()</code> is the same as <code><a href="#topic+power.EOTF">power.EOTF</a>()</code>,
but having a different name may make the creation of new RGB spaces clearer.
All three of these map [0,1] to [0,1].
</p>
<p><code>BT.1886.EOTF()</code> returns a <code><a href="#topic+TransferFunction">TransferFunction</a></code> that maps [0,1] to
[<code>Lb</code>,<code>Lw</code>], with non-linearity given by <code>gamma</code>.
The BT.1886 standard has details in Annex 1.
</p>
<p><code>XYZfromRGB.TF()</code> returns a 3D <code><a href="#topic+TransferFunction">TransferFunction</a></code> that is linear
and maps RGB=(1,1,1) to the XYZ of white.
The domain is set to the ACES cube  <code class="reqn">[-65504, 65504]^3</code> and the range is set to the smallest enclosing box.
For the inverse one can use <code>XYZfromRGB.TF()^-1</code>.
</p>
<p><code>affine.TF()</code> returns a 1D <code><a href="#topic+TransferFunction">TransferFunction</a></code> that maps 
0   &rarr;  <code class="reqn">y_0</code> and 1   &rarr;  <code class="reqn">y_1</code> in an affine way.
One must have <code class="reqn">y_0 \ne y_1</code>, but is is OK to have <code class="reqn">y_0 &gt; y_1</code>.
No quantities are associated with these values; the function is intended for arbitrary 1D scaling.
</p>


<h3>References</h3>

<p>BT.1886.
Reference electro-optical transfer function for flat panel displays used in HDTV studio production.
March 2011.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TransferFunction">TransferFunction</a></code>
</p>

<hr>
<h2 id='Basic+20TransferFunctions'>
Basic TransferFunctions
</h2><span id='topic+sRGB.EOTF'></span><span id='topic+BT.709.EOTF'></span><span id='topic+BT.2020.EOTF'></span><span id='topic+ProPhotoRGB.EOTF'></span><span id='topic+SMPTE.240M.EOTF'></span>

<h3>Description</h3>


<table>
<tr>
 <td style="text-align: left;">
<code>sRGB.EOTF</code>        </td><td style="text-align: left;"> the standardized sRGB transfer function </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>BT.709.EOTF</code>      </td><td style="text-align: left;"> the standardized BT.709 transfer function </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>BT.2020.EOTF</code>     </td><td style="text-align: left;"> the standardized BT.2020 transfer function </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ProPhotoRGB.EOTF</code> </td><td style="text-align: left;"> the standardized ProPhotoRGB transfer function </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>SMPTE.240M.EOTF</code>  </td><td style="text-align: left;"> the standardized SMPTE-240M transfer function </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Details</h3>

<p>All of these are built-in <code><a href="#topic+TransferFunction">TransferFunction</a></code> objects;
they have no parameters and are ready-to-go.
All are EOTFs and have domain and range the interval [0,1], and all are monotone increasing.
All are defined in 2 pieces, with a linear segment near 0.
All are easily inverted.
</p>


<h3>References</h3>

<p>Wikipedia. <b>sRGB</b>.
<a href="https://en.wikipedia.org/wiki/SRGB">https://en.wikipedia.org/wiki/SRGB</a>.
</p>
<p>BT.709.
Parameter values for the HDTV standards for production and international programme exchange.
June 2015.
</p>
<p>BT.2020.
Parameter values for ultra-high definition television systems for production and international programme exchange.
October 2015.
</p>
<p>Wikipedia. <b>ProPhoto RGB</b>.
<a href="https://en.wikipedia.org/wiki/ProPhoto_RGB_color_space">https://en.wikipedia.org/wiki/ProPhoto_RGB_color_space</a>.
</p>
<p>ANSI/SMPTE 240M-1995.
SMPTE STANDARD for Television Signal Parameters 1125-Line High-Definition Production Systems.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TransferFunction">TransferFunction</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make plot comparing 5 EOTFs
colvec	= c('black','red','blue','green','orange')
plot( sRGB.EOTF, color=colvec[1], main="The Basic 5 EOTFs" )
plot( BT.709.EOTF, color=colvec[2], add=TRUE )
plot( BT.2020.EOTF, color=colvec[3], add=TRUE )
plot( ProPhotoRGB.EOTF, color=colvec[4], add=TRUE )
plot( SMPTE.240M.EOTF, color=colvec[5], add=TRUE )
legend( 'topleft', legend=c('sRGB','BT.709','BT.2020','ProPhotoRGB','SMPTE.240M'), 
             col=colvec, bty='n', lty=1, lwd=2 )
</code></pre>

<hr>
<h2 id='composition'>The composition of TransferFunction objects</h2><span id='topic+composition'></span><span id='topic+composition.TransferFunction'></span><span id='topic++2A.TransferFunction'></span><span id='topic++25X+25.TransferFunction'></span><span id='topic++25+3B+25.TransferFunction'></span><span id='topic++25O+25.TransferFunction'></span><span id='topic++25X+25'></span><span id='topic++25+3B+25'></span><span id='topic++25O+25'></span><span id='topic+is.identity'></span><span id='topic+is.identity.TransferFunction'></span><span id='topic+identity.TF'></span>

<h3>Description</h3>

<p>The function <code>composition(TF1,TF2)</code> returns a <code>TransferFunction</code> that is 
<code>TF1</code> followed by <code>TF2</code>.
Four equivalent infix operators are also available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TransferFunction'
composition( TF1, TF2 )

## S3 method for class 'TransferFunction'
 TF1 * TF2 
## S3 method for class 'TransferFunction'
 TF1 %;% TF2 
## S3 method for class 'TransferFunction'
 TF1 %X% TF2 
## S3 method for class 'TransferFunction'
 TF2 %O% TF1 

identity.TF

## S3 method for class 'TransferFunction'
is.identity( TF )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="composition_+3A_tf1">TF1</code></td>
<td>
<p>a <code>TransferFunction</code> object</p>
</td></tr>
<tr><td><code id="composition_+3A_tf2">TF2</code></td>
<td>
<p>a <code>TransferFunction</code> object</p>
</td></tr>
<tr><td><code id="composition_+3A_tf">TF</code></td>
<td>
<p>a <code>TransferFunction</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to be composed, the dimensions of <code>TF1</code> and <code>TF2</code> must be equal,
or the dimension of one of them must be 1.
In the latter case, the function is applied to each coordinate in exactly the same way.
</p>
<p>All the above represent the function <code>TF1</code> followed by <code>TF2</code>.
In mathematics this operation is usually called <em>composition of functions</em>
(and <em>composition of morphisms</em> in category theory),
and in computer science and BT.2100 and BT.2390 it is called the <em>concatenation</em>.
In BT.2390 it is also called the <em>cascade</em>.
</p>
<p>The ACES literature uses infix notation with the symbol <code>'+'</code> 
which is unfortunate because in mathematics
the plus symbol is only used for commutative operations, which composition certainly is not.
The symbol <code>'*'</code> is offered here as an alternative,
since <code>'*'</code> does not imply commutativity (e.g. as in MATLAB's matrix multiplication).
In computer science the symbol <code>';'</code> is common, and so <code>%;%</code> is offered as an alternative.
In BT.2100 and BT.2390 the symbol   &otimes;  is used, and so <code>%X%</code> is offered as an alternative.
And finally, in mathematics   &#x25cb;  is used but in the opposite order,
so that <code>TF2 %O% TF1</code> is identical to <code>composition(TF1,TF2)</code>.
<br />
Each <code>TransferFunction</code> object is actually a list of so-called <em>elementary</em> transfer functions.
If <code>TF1</code> has <code class="reqn">M_1</code> elementary functions and <code>TF2</code> has <code class="reqn">M_2</code> elementary functions,
then <code>composition(TF1,TF2)</code> has <code class="reqn">\le M_1 + M_2</code> elementary functions.
It can be strictly less if there is cancellation of elementary functions at the end of <code>TF1</code>
and the beginning of <code>TF2</code>.
</p>


<h3>Value</h3>

<p><code>composition(TF1,TF2)</code> returns a <code>TransferFunction</code> object,
which applies <code>TF1</code> followed by <code>TF2</code>.
The individual objects <code>TF1</code> and <code>TF2</code> are stored  inside the returned object.
In case of ERROR it returns <code>NULL</code>.
The 4 infix operators above all invoke <code>composition()</code>.
</p>
<p><code>identity.TF</code> is a built-in global <code>TransferFunction</code> object which is a 
universal identity for composition.
This means that for any <code>TransferFunction</code>  <code>TF</code>,  
<code>TF*identity.TF = identity.TF*TF = TF</code>.
Moreover, <code>TF*TF^-1 = TF^1*TF = identity.TF</code>.
This is *not* the same as <code>base::identity()</code>.
</p>
<p><code>is.identity(TF)</code> tests whether <code>TF</code> is the universal identity,
and returns <code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>References</h3>

<p>Technical Bulletin.
TB-2018-002.
ACES Output Transform Details.
June 2018 (draft).
</p>
<p>ACES Retrospective and Enhancements
March 2017.
</p>
<p>BT.2100.
Image parameter values for high dynamic range television for use in production
and international programme exchange.
June 2017.
</p>
<p>BT.2390.
High dynamic range television for production and international programme exchange.
April 2018.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TransferFunction">TransferFunction</a></code>,
<code><a href="#topic+transfer">transfer</a>()</code>,
<code><a href="#topic+inverse">inverse</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comp = power.OOTF(2.2) * power.OOTF(1.4)
x = 0:100 / 100
max( abs( transfer(comp,x) - transfer(power.OOTF(2.2*1.4),x) ) )  #  1.110223e-16

comp * comp^-1
## This is a universal identity TransferFunction.

is.identity(comp * comp^-1)          # TRUE

identical( comp * identity.TF, comp )  # TRUE
</code></pre>

<hr>
<h2 id='Digital+20Cinema+20Distribution+20Master'>
Digital Cinema Distribution Master, the EOTF of DCDM
</h2><span id='topic+DCDM.EOTF'></span>

<h3>Description</h3>


<table>
<tr>
 <td style="text-align: left;">
<code>DCDM.EOTF</code>        </td><td style="text-align: left;"> the standardized DCDM transfer function </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Details</h3>

<p>This is a <code>TransferFunction</code> designed to be applied to XYZ, instead of the usual RGB.
The electrical encoding of XYZ is denoted X'Y'Z'.
The EOTF is:
</p>
<p style="text-align: center;"><code class="reqn"> X = (52.37/48) * (X')^{2.6} </code>
</p>

<p>and similarly for Y and Z.
</p>


<h3>References</h3>

<p>SMPTE Standard RP 431-2.
D-Cinema Quality - Reference Projector and Environment for the Display of DCDM in Review Rooms and Theaters.
2011.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TransferFunction">TransferFunction</a></code> 
</p>

<hr>
<h2 id='Full+20Range+20to+20SMPTE+20Range'>
Full Range to SMPTE Range
</h2><span id='topic+FullRangeToSMPTE.TF'></span>

<h3>Description</h3>


<table>
<tr>
 <td style="text-align: left;">
<code>FullRangeToSMPTE.TF</code>   </td><td style="text-align: left;">   the standardized SMPTE range transfer function </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Details</h3>

<p>This is a <code>TransferFunction</code> object that maps from non-linear display signal RGB to itself.
It maps from the full range [0,1] to the 
smaller range [ 64/1023, 940/1023 ] <code class="reqn">\approx</code>  [ 0.06256109, 0.9188661 ].
The latter is the 10-bit &quot;legal-SMPTE&quot;&quot; range.
It does this in an affine way, and in fact simply uses <code><a href="#topic+affine.TF">affine.TF</a>()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+affine.TF">affine.TF</a>()</code>,
<code><a href="#topic+TransferFunction">TransferFunction</a></code>
</p>

<hr>
<h2 id='Hybrid+20Log-Gamma+20Transform'>
Hybrid Log-Gamma Transform
</h2><span id='topic+HLG.OETF'></span><span id='topic+HLG.OOTF'></span>

<h3>Description</h3>

<p>The Hybrid Log-Gamma OETF is a transfer function that allows for the display of high dynamic range (HDR) video.
The version here is that supported by the 
ACES (Academy Color Encoding System) and 
HEVC (High Efficiency Video Coding) standards.
<br />
For use with ACES, a specialized HLG-based OOTF is provided that references the Perceptual Quality (PQ) EOTF.
It converts the ST.2084 (PQ) output to HLG using the method specified in Section 7 of BT.2390-0. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HLG.OETF()
HLG.OOTF( gamma=1.2, Lb=0, Lw=1000 )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Hybrid+2B20Log-Gamma+2B20Transform_+3A_gamma">gamma</code></td>
<td>
<p>the applied exponent, from scene linear to display linear</p>
</td></tr>
<tr><td><code id="Hybrid+2B20Log-Gamma+2B20Transform_+3A_lb">Lb</code></td>
<td>
<p>the luminance of black, in <code class="reqn">cd/m^2</code>, or nit.</p>
</td></tr>
<tr><td><code id="Hybrid+2B20Log-Gamma+2B20Transform_+3A_lw">Lw</code></td>
<td>
<p>the luminance of white, in <code class="reqn">cd/m^2</code>, or nit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>HLG.OOTF()</code> is 3D and does not operate on each channel independently.
It uses a scaling factor based on these RGB weights - (0.2627,0.6780,0.0593) - from Section 7 of BT.2390.
</p>


<h3>Value</h3>

<p><code>HLG.OETF()</code> returns a univariate <code>TransferFunction</code> that maps
linear scene RGB to signal display RGB.
The interval [0,1] maps to [0,1] (as in the HVEC standard).
<br />
<code>HLG.OOTF()</code> returns a multivariate <code>TransferFunction</code> of dimension 3
that maps linear scene RGB to linear display RGB.
It maps the cube [0,1]<code class="reqn">^3</code> to the cube [<code>Lb</code>,<code>Lw</code>]<code class="reqn">^3</code>,
but the image is only a proper subset of the cube.
</p>


<h3>References</h3>

<p>ST-2084.
SMPTE Standard - High Dynamic Range Electro-Optical Transfer Function of Mastering Reference Displays.
2014.
</p>
<p>BT.2390.
High dynamic range television for production and international programme exchange.
April 2018.
</p>
<p>H.265 : High Efficiency Video Coding.
https://www.itu.int/rec/T-REC-H.265-201802-I/en.
2018-02-13.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TransferFunction">TransferFunction</a></code>,
<code><a href="#topic+PQ.EOTF">PQ.EOTF</a></code>
</p>

<hr>
<h2 id='inverse'>The inverse of a TransferFunction Object</h2><span id='topic+inverse'></span><span id='topic+inverse.TransferFunction'></span><span id='topic++5E.TransferFunction'></span><span id='topic+is.invertible'></span><span id='topic+is.invertible.TransferFunction'></span>

<h3>Description</h3>

<p>The function <code>inverse()</code> returns a <code>TransferFunction</code> that is the inverse
of the argument (if the argument is invertible).
</p>
<p><code>is.invertible()</code> tests whether a <b>TransferFunction</b> object has an inverse.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TransferFunction'
inverse( TF )

## S3 method for class 'TransferFunction'
 TF ^ n 

## S3 method for class 'TransferFunction'
is.invertible( TF )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inverse_+3A_tf">TF</code></td>
<td>
<p>a <code>TransferFunction</code> object</p>
</td></tr>
<tr><td><code id="inverse_+3A_n">n</code></td>
<td>
<p>an integer exponent; valid values are -1, 0, and 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>inverse()</code> returns a <code>TransferFunction</code> object obtained by 
swapping <code>fun</code> and <code>funinv</code> and 
swapping <code>domain</code> and <code>range</code>.
The names of the elements composing <code>TF</code> are changed appropriately.
If <code>TF</code> is not invertible, it returns <code>NULL</code>.
</p>
<p>If <code>n=-1</code>, <code>TF^n</code> returns <code>inverse(TF)</code>.
If <code>n=1</code>, it returns <code>TF</code>.
If <code>n=0</code>, it returns the universal <code><a href="#topic+identity.TF">identity.TF</a></code>.
For any other value of <code>n</code> it returns <code>NULL</code>.
</p>
<p><code>is.invertible()</code> returns <code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+identity.TF">identity.TF</a></code>
</p>

<hr>
<h2 id='Linear+20RGB+2C+20XYZ+2C+20and+20Lab+20Calculation'>Convert Signal RGB coordinates to Linear RGB, XYZ, or Lab</h2><span id='topic+XYZfromRGB'></span><span id='topic+LabfromRGB'></span><span id='topic+LinearRGBfromSignalRGB'></span>

<h3>Description</h3>

<p>Convert signal RGB coordinates to linear RGB, XYZ, or Lab</p>


<h3>Usage</h3>

<pre><code class='language-R'>LinearRGBfromSignalRGB( RGB, space='sRGB', which='scene', TF=NULL, maxSignal=1 ) 

XYZfromRGB( RGB, space='sRGB', which='scene', TF=NULL, maxSignal=1 ) 

LabfromRGB( RGB, space='sRGB', which='scene', TF=NULL, maxSignal=1 ) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Linear+2B20RGB+2B2C+2B20XYZ+2B2C+2B20and+2B20Lab+2B20Calculation_+3A_rgb">RGB</code></td>
<td>
<p> a numeric Nx3 matrix with non-linear signal RGB coordinates in the rows, or a vector that can be converted to such a matrix, by row.
These should be in the appropriate cube <code>[0,maxSignal]</code><code class="reqn">^3</code>;
but see <code>OutOfGamut</code> in <b>Value</b> below.
</p>
</td></tr>
<tr><td><code id="Linear+2B20RGB+2B2C+2B20XYZ+2B2C+2B20and+2B20Lab+2B20Calculation_+3A_space">space</code></td>
<td>
<p>the name of an installed RGB space.
The name matching is partial and case-insensitive.</p>
</td></tr>
<tr><td><code id="Linear+2B20RGB+2B2C+2B20XYZ+2B2C+2B20and+2B20Lab+2B20Calculation_+3A_which">which</code></td>
<td>
<p>either <code>'scene'</code> or <code>'display'</code>.
For <code>LinearRGBfromSignalRGB()</code>, <code>which</code> describes the output RGB.
For <code>XYZfromRGB()</code>, <code>which</code> describes the output XYZ.
For <code>LabfromRGB()</code>, <code>which</code> describes the output Lab.
Usually the OOTF for the space is the identity and so <code>'scene'</code> and <code>'display'</code> are the same.
</p>
</td></tr>
<tr><td><code id="Linear+2B20RGB+2B2C+2B20XYZ+2B2C+2B20and+2B20Lab+2B20Calculation_+3A_tf">TF</code></td>
<td>
<p>if not <code>NULL</code>, <code>TF</code> is a <code>TransferFunction</code>
that overrides the appropriate transfer function of <code>space</code>.
<br />
<code>TF</code> can also be a positive number.
If <code>TF=1</code>, then <code>TF</code> is set to <code>identity.TF</code>,
so the returned RGB values are not clamped (see <b>Value</b>).
If <code>TF!=1</code> it is used to create either
<code>power.EOTF()</code> or <code>power.OETF()</code> as approriate.
If <code>TF</code> is not <code>NULL</code> in <code>LinearRGBfromSignalRGB()</code>, then <code>space</code> is ignored.
</p>
</td></tr>
<tr><td><code id="Linear+2B20RGB+2B2C+2B20XYZ+2B2C+2B20and+2B20Lab+2B20Calculation_+3A_maxsignal">maxSignal</code></td>
<td>
<p>maximum value of the input signal <code>RGB</code>.
It is just a simple scaling factor;
other common values are 100, 255, 1023, 4095, and 65535.
Even when <code>maxSignal</code>=1, the RGBs are still taken to be non-linear signal values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code>XYZfromRGB()</code>, the conversion is done in 2 steps:
</p>

<ul>
<li><p> signal RGB    &rarr;   linear RGB using <code>LinearRGBfromSignalRGB()</code> and all other the given arguments
</p>
</li>
<li><p> linear RGB    &rarr;   XYZ using the 3x3 matrix for the given <code>space</code> and <code>which</code>
</p>
</li></ul>



<h3>Value</h3>

<p><code>XYZfromRGB()</code> returns a <code>data.frame</code> with N rows and these columns:
</p>
<table role = "presentation">
<tr><td><code>OutOfGamut</code></td>
<td>
<p>a logical vector. TRUE means the input signal RGB is outside the cube <code>[0,maxSignal]</code><code class="reqn">^3</code>.
If <code>TF</code> is not <code>identity.TF</code>, 
then the input signal RGBs are clamped to this cube before further calculations.</p>
</td></tr>
<tr><td><code>XYZ</code></td>
<td>
<p>the calculated XYZ vectors, using the appropriate 3x3 matrix for the RGB space.
These are for viewing under the white point (either <code>'scene'</code> or <code>'display'</code>)
of the given RGB space.</p>
</td></tr>
</table>
<p><code>LabfromRGB()</code> returns a <code>data.frame</code> with N rows and these columns:
</p>
<table role = "presentation">
<tr><td><code>OutOfGamut</code></td>
<td>
<p>a logical vector. TRUE means the input signal RGB is outside the cube <code>[0,maxSignal]</code><code class="reqn">^3</code>.
If <code>TF</code> is not <code>identity.TF</code>, 
then the input signal RGBs are clamped to this cube before further calculations.</p>
</td></tr>
<tr><td><code>Lab</code></td>
<td>
<p>the calculated Lab vectors.
First XYZ is calculated using <code>XYZfromRGB()</code>.
Then XYZ   &rarr;  Lab
is calculated using
<code><a href="spacesXYZ.html#topic+fromXYZ">spacesXYZ::LabfromXYZ</a>()</code>,
with the white point
(either <code>'scene'</code> or <code>'display'</code>) of the given RGB space.
If R=G=B exactly, then a=b=0 exactly.</p>
</td></tr>
</table>
<p><code>LinearRGBfromSignalRGB()</code> returns a <code>data.frame</code> with N rows and these columns:
</p>
<table role = "presentation">
<tr><td><code>OutOfGamut</code></td>
<td>
<p>a logical vector. TRUE means the input signal RGB is outside the cube <code>[0,maxSignal]</code><code class="reqn">^3</code>.
If <code>TF</code> is not <code>identity.TF</code>, then the signal RGBs are clamped to this cube before linearizing.</p>
</td></tr>
<tr><td><code>RGB</code></td>
<td>
<p>the calculated linear RGB vectors, either scene linear or display linear, as specified by <code>which</code>.</p>
</td></tr>
</table>
<p>In case of error, all functions return NULL.
</p>


<h3>References</h3>

<p>Wikipedia. <b>RGB color space</b>.
<a href="https://en.wikipedia.org/wiki/RGB_color_space">https://en.wikipedia.org/wiki/RGB_color_space</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RGBfromXYZ">RGBfromXYZ</a>()</code>,
<code><a href="#topic+SignalRGBfromLinearRGB">SignalRGBfromLinearRGB</a>()</code>,
<code><a href="#topic+installRGB">installRGB</a>()</code>,
<code><a href="spacesXYZ.html#topic+fromXYZ">spacesXYZ::LabfromXYZ</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>XYZfromRGB( c(128,200,255, 0,0,0,  255,255,255), max=255 )$XYZ * 100
##              X         Y        Z
##  [1,] 47.60334  53.11601 102.3549
##  [2,]  0.00000   0.00000   0.0000
##  [3,] 95.04559 100.00000 108.9058


XYZfromRGB( c(128,200,255, 0,0,0,  255,255,255), space='Adobe', max=255 )$XYZ   * 100
##              X         Y        Z
##  [1,] 42.36398  50.82876 103.8704
##  [2,]  0.00000   0.00000   0.0000
##  [3,] 95.04559 100.00000 108.9058
</code></pre>

<hr>
<h2 id='metadata'>metadata of a TransferFunction object</h2><span id='topic+metadata'></span><span id='topic+metadata+3C-'></span><span id='topic+metadata.TransferFunction'></span><span id='topic+metadata+3C-.TransferFunction'></span>

<h3>Description</h3>

<p>Retrieve or set the metadata of a <b>TransferFunction</b> object.
The user is free to set this as he/she wishes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TransferFunction'
metadata( x, ...)

## S3 replacement method for class 'TransferFunction'
metadata( x, add=FALSE ) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="metadata_+3A_x">x</code></td>
<td>
<p>a <code>TransferFunction</code> <span class="rlang"><b>R</b></span> object</p>
</td></tr>
<tr><td><code id="metadata_+3A_...">...</code></td>
<td>
<p>optional names of metadata to return</p>
</td></tr>
<tr><td><code id="metadata_+3A_value">value</code></td>
<td>
<p>a named <code>list</code>.  
If <code>add</code> is <code>FALSE</code>, <code>value</code> replaces any existing <code>metadata</code>.   
If <code>add</code> is <code>TRUE</code>,  <code>value</code> is appended to the existing list of metadata.
If a name already exists, its value is updated using <code><a href="utils.html#topic+modifyList">modifyList</a>()</code>.
Unnamed items in  <code>value</code> are ignored.</p>
</td></tr>
<tr><td><code id="metadata_+3A_add">add</code></td>
<td>
<p>if <code>add=FALSE</code>, any existing metadata is discarded.
If <code>add=TRUE</code> then existing metadata is preserved, using <code>modifyList()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The metadata list is stored as <code>attr(x,'metadata')</code>.
After construction this list is empty.
</p>


<h3>Value</h3>

<p><code>metadata(x)</code> with no additional arguments returns the complete named list of metadata.
If arguments are present, then only those <code>metadata</code> items are returned.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+modifyList">modifyList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# get list of *all* metadata
metadata(TF)

# get just the number 'gamma'
metadata( TF, 'gamma' )

# alternative method to get just the number 'gamma'
metadata( TF )$gamma

# set the 'date'
metadata( TF ) = list( date="2016-04-01" )

## End(Not run)
</code></pre>

<hr>
<h2 id='miscTF'>Miscellaneous TransferFunction Methods</h2><span id='topic+dimension'></span><span id='topic+dimension.TransferFunction'></span><span id='topic+domain'></span><span id='topic+domain.TransferFunction'></span><span id='topic+orientation'></span><span id='topic+orientation.TransferFunction'></span>

<h3>Description</h3>

<p>Miscellaneous <code>TransferFunction</code> methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TransferFunction'
dimension( TF )

## S3 method for class 'TransferFunction'
domain( TF )

## S3 method for class 'TransferFunction'
orientation( TF )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="miscTF_+3A_tf">TF</code></td>
<td>
<p>a <code>TransferFunction</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dimension()</code> returns a positive integer - the dimension of the domain and range of <code>TF</code>.
If <code>TF</code> is a universal identity, it returns <code>NA</code>.
</p>
<p><code>domain()</code> returns a 2xN matrix with the domain box of <code>TF</code>,
where N is <code>dimension(TF)</code>.
If <code>TF</code> is a universal identity, it returns <code>NA</code>.
</p>
<p><code>orientation()</code> returns a real number.
If the value is positive it means that <code>TF</code> preserves orientation.
If the value is negative it means that <code>TF</code> reverses orientation.
When <code>dimension(TF)</code>=1, this simply corresponds to
the function being monotone increasing or decreasing, respectively.
In case of ERROR, the function returns <code>NA</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TransferFunction">TransferFunction</a></code>
<code><a href="#topic+identity.TF">identity.TF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF = affine.TF( 1, 108 )

dimension(TF)					# 1

orientation(TF)					# 107

orientation( affine.TF( 100, 1 ) )		# -99

domain(TF)
##      AU
##  min  0
##  max  1
</code></pre>

<hr>
<h2 id='Opto-Optical+20Transfer+20Function+2C+20parameterized'>
Opto-Optical Transfer Function, general
</h2><span id='topic+general.OOTF'></span>

<h3>Description</h3>

<p>This parameterized OOTF maps from ACES (linear scene) RGB to linear display RGB
(both of these are optical in nature).
<br />
This transform bypasses non-linear signal display RGB (which is electrical in nature).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>general.OOTF( display_pri, Ymin=0.00010, Ymid=7.2, Ymax=108,
                 observerWP=NULL, limiting_pri=NULL,
                 surround='dark', dynrange='SDR', glowmod='1.1', redmod='1.1' )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Opto-Optical+2B20Transfer+2B20Function+2B2C+2B20parameterized_+3A_display_pri">display_pri</code></td>
<td>
<p>a 4x2 matrix containing the display primaries, or a numeric vector of length 8
that can be converted to such a matrix, by row.
Some built-in matrices are <code><a href="#topic+REC709_PRI">REC709_PRI</a></code>, etc.
This argument cannot be <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="Opto-Optical+2B20Transfer+2B20Function+2B2C+2B20parameterized_+3A_ymin">Ymin</code></td>
<td>
<p>the minimum display luminance, in <code class="reqn">cd/m^2</code>, or nit.</p>
</td></tr>
<tr><td><code id="Opto-Optical+2B20Transfer+2B20Function+2B2C+2B20parameterized_+3A_ymid">Ymid</code></td>
<td>
<p>the middle display luminance, in <code class="reqn">cd/m^2</code>, or nit.</p>
</td></tr>
<tr><td><code id="Opto-Optical+2B20Transfer+2B20Function+2B2C+2B20parameterized_+3A_ymax">Ymax</code></td>
<td>
<p>the maximum display luminance, in <code class="reqn">cd/m^2</code>, or nit.</p>
</td></tr>
<tr><td><code id="Opto-Optical+2B20Transfer+2B20Function+2B2C+2B20parameterized_+3A_observerwp">observerWP</code></td>
<td>
<p>the xy chromaticity of the assumed observer whitepoint.
This is used to make a Chromatic Adaptation Transform (CAT) from the ACES whitepoint (approximately D60)
to the assumed observer whitepoint.
If <code>observerWP</code> is <code>NULL</code>, it is taken from <code>display_pri</code>.
If ACES and observer whitepoints are the same, there is no CAT.
</p>
</td></tr>
<tr><td><code id="Opto-Optical+2B20Transfer+2B20Function+2B2C+2B20parameterized_+3A_limiting_pri">limiting_pri</code></td>
<td>
<p>a 4x2 matrix containing the limiting primaries, or a numeric vector of length 8
that can be converted to such a matrix, by row.
If <code>limiting_pri</code> is not <code>NULL</code>, and not equal to <code>display_pri</code>,
then the output RGB is clamped to the RGB cube that corresponds to <code>limiting_pri</code>. 
</p>
</td></tr>
<tr><td><code id="Opto-Optical+2B20Transfer+2B20Function+2B2C+2B20parameterized_+3A_surround">surround</code></td>
<td>
<p>The level of the surround luminance.
Valid values are <code>'dark'</code> and <code>'dim'</code>.
If the level is <code>'dark'</code> there is no special color compensation.
Partial matching is enabled and matching is case-insensitive.
</p>
</td></tr>
<tr><td><code id="Opto-Optical+2B20Transfer+2B20Function+2B2C+2B20parameterized_+3A_dynrange">dynrange</code></td>
<td>
<p>the dynamic range of the display system.
Valid values are <code>'SDR'</code> (standard dynamic range) and <code>'HDR'</code> (high dynamic range).
If the value is <code>'HDR'</code> then <code>surround</code> is ignored.
Matching is partial and case-insensitive.
</p>
</td></tr>
<tr><td><code id="Opto-Optical+2B20Transfer+2B20Function+2B2C+2B20parameterized_+3A_glowmod">glowmod</code></td>
<td>
<p>the version of the Glow Modifier to use.  
The only version currently supported is <code>"1.1"</code>.
<br />
<code>glowmod</code> can also be <code>NULL</code>, <code>NA</code>, or <code>FALSE</code>,
which means to use no Glow Modifier at all.
</p>
</td></tr>
<tr><td><code id="Opto-Optical+2B20Transfer+2B20Function+2B2C+2B20parameterized_+3A_redmod">redmod</code></td>
<td>
<p>the version of the Red Modifier to use.  
The only version currently supported is <code>"1.1"</code>.
This string can also be <code>"1.1+pinv"</code>
which means to use a precision inverse; the forward transfer is exactly the same.
This precision inverse uses an iterative root-finder, 
and is slower than the approximate default inverse.
<br />
<code>redmod</code> can also be <code>NULL</code>, <code>NA</code>, or <code>FALSE</code>,
which means to use no Red Modifier at all.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The transfer is complicated; here is a summary of the steps:
</p>

<ol>
<li><p> glow module  (see argument <code>glowmod</code>)
</p>
</li>
<li><p> red modifier (see argument <code>redmod</code>)
</p>
</li>
<li><p> matrix conversion from AP0 RGB   &rarr;  AP1 RGB
</p>
</li>
<li><p> clamp to non-negative RGB
</p>
</li>
<li><p> global desaturation  (as in <code><a href="#topic+RRT.TF">RRT.TF</a></code>)
</p>
</li>
<li><p> single-stage tone-scale  (SSTS)  using <code>Ymin</code>, <code>Ymid</code>, and <code>Ymax</code>
</p>
</li>
<li><p> absolute luminance to linear code-value, in cube [0,1]<code class="reqn">^3</code>
</p>
</li>
<li><p> matrix conversion from AP1 RGB to XYZ
</p>
</li>
<li><p> dim surround compensation (optional, see arguments <code>surround</code> and <code>dynrange</code>)
</p>
</li>
<li><p> clamp XYZ to limiting primaries (optional, see argument <code>limiting_pri</code>)
</p>
</li>
<li><p> adapt XYZ from ACES whitepoint to observer whitepoint (optional, see argument <code>observerWP</code>)
</p>
</li>
<li><p> matrix conversion from XYZ to linear display RGB (see argument <code>display_pri</code>)
</p>
</li>
<li><p> scale and roll-white to avoid clipping (optional, only when <code>observerWP</code> is ACES whitepoint and display whitepoint is D65 or DCI whitepoint)
</p>
</li>
<li><p> clamp to non-negative RGB
</p>
</li></ol>
    


<h3>Value</h3>

<p><code>general.OOTF()</code> returns a <code>TransferFunction</code> of dimension 3
that maps ACES RGB to linear display RGB.
<br />
The domain of the returned <code>TransferFunction</code> depends on the values of 
<code>Ymin</code>, <code>Ymid</code>, and <code>Ymax</code>.
The range is [0,1]<code class="reqn">^3</code>, for which clamping may be used.
<br />
The <code><a href="#topic+metadata">metadata</a></code> contains the display primaries and whitepoint,
which is useful in <code><a href="#topic+installRGB">installRGB</a>()</code>.
</p>


<h3>Source</h3>

<p>This function was based on source code at:
<a href="https://github.com/ampas/aces-core">https://github.com/ampas/aces-core</a>;
especially the file <code>ACESlib.OutputTransforms.ctl</code>.
This transform is a sub-transform of the function <code>outputTransform()</code>;
it omits the final EOTF<code class="reqn">^{-1}</code> and optional Full-to-SMPTE range.
</p>


<h3>References</h3>

<p>ST 2065-1:2012.
SMPTE Standard - Academy Color Encoding Specification (ACES).
2013.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TransferFunction">TransferFunction</a></code>,
<code><a href="#topic+installRGB">installRGB</a>()</code>,
<code><a href="#topic+metadata">metadata</a>()</code>,
<a href="#topic+Standard+20Primaries">Standard Primaries</a>
</p>

<hr>
<h2 id='Partial+20Output+20Device+20Transform+2C+20parameterized'>
Partial Output Device Transform, general 
</h2><span id='topic+general.PODT'></span>

<h3>Description</h3>

<p>A partial Output Device Transform (PODT) maps from OCES to linear display RGB
(both of these are optical in nature).
The adjective &quot;partial&quot; is used because this
is an ODT that omits the final OETF (which maps from linear display RGB to signal display RGB).
<br />
This PODT is parameterized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>general.PODT( display_pri, Ymax=1, observerWP=NULL, surround='dark', limiting_pri=NULL )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Partial+2B20Output+2B20Device+2B20Transform+2B2C+2B20parameterized_+3A_display_pri">display_pri</code></td>
<td>
<p>a 4x2 matrix containing the display primaries, or a numeric vector of length 8
that can be converted to such a matrix, by row.
Some built-in matrices are <code><a href="#topic+REC709_PRI">REC709_PRI</a></code>, etc.
<br />
<code>display_pri</code> can also be <code>NULL</code>, which means that the PODT maps to XYZ, instead of RGB.
This is used in the case of DCDM (Digital Cinema Distribution Master).
See the User Guide Appendix for examples of this.
<br />
<code>display_pri</code>  is stored in the metadata of the returned object and later used
in <code><a href="#topic+installRGB">installRGB</a>()</code> (if the PODT is passed in an argument).
</p>
</td></tr>
<tr><td><code id="Partial+2B20Output+2B20Device+2B20Transform+2B2C+2B20parameterized_+3A_ymax">Ymax</code></td>
<td>
<p>the maximum luminance of the output device, in <code class="reqn">cd/m^2</code> (or nits).
This has no effect on the PODT itself.
It is stored in the metadata and later used
in <code><a href="#topic+installRGB">installRGB</a>()</code> (if the PODT is passed in an argument) when computing the
3x3 matrix that transforms from display RGB to display XYZ.
</p>
</td></tr>
<tr><td><code id="Partial+2B20Output+2B20Device+2B20Transform+2B2C+2B20parameterized_+3A_observerwp">observerWP</code></td>
<td>
<p>the xy chromaticity of the assumed observer whitepoint.
This is used to make a Chromatic Adaptation Transform (CAT) from the ACES whitepoint (approximately D60)
to the assumed observer whitepoint.
If <code>observerWP</code> is <code>NULL</code>, it is taken from <code>display_pri</code>.
If <code>display_pri</code> is <code>NULL</code>, then it is taken from <code>limiting_pri</code>.
If <code>limiting_pri</code> is <code>NULL</code>, or if two whitepoints are the same, then there is no CAT.
</p>
</td></tr>
<tr><td><code id="Partial+2B20Output+2B20Device+2B20Transform+2B2C+2B20parameterized_+3A_surround">surround</code></td>
<td>
<p>The level of the surround luminance.
Valid values are <code>'dark'</code> and <code>'dim'</code>.
If the level is <code>'dark'</code> there is no special color compensation.
Partial matching is enabled and matching is case-insensitive.
</p>
</td></tr>
<tr><td><code id="Partial+2B20Output+2B20Device+2B20Transform+2B2C+2B20parameterized_+3A_limiting_pri">limiting_pri</code></td>
<td>
<p>a 4x2 matrix containing the limiting primaries, or a numeric vector of length 8
that can be converted to such a matrix, by row.
If <code>limiting_pri</code> is not <code>NULL</code>, and not equal to <code>display_pri</code>,
then the output RGB is clamped to the RGB cube that corresponds to <code>limiting_pri</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The transfer is complicated; here is a summary of the steps:
</p>

<ol>
<li><p> matrix conversion from AP0 RGB   &rarr;  AP1 RGB
</p>
</li>
<li><p> clamp to non-negative RGB
</p>
</li>
<li><p> segmented spline, assuming <code>CINEMA_WHITE</code>=48 nit
</p>
</li>
<li><p> absolute luminance to linear code-value, in cube [0,1]<code class="reqn">^3</code>
</p>
</li>
<li><p> scale and roll-white to avoid clipping (optional, only when <code>observerWP</code> is ACES whitepoint and display whitepoint is D65 or DCI whitepoint)
</p>
</li>
<li><p> dim surround compensation with conversion to XYZ and back again (optional, see argument <code>surround</code>)
</p>
</li>
<li><p> matrix conversion from AP1 RGB to XYZ
</p>
</li>
<li><p> adapt XYZ from ACES whitepoint to observer whitepoint (optional, see argument <code>observerWP</code>)
</p>
</li>
<li><p> clamp XYZ to limiting primaries (optional, see argument <code>limiting_pri</code>)
</p>
</li>
<li><p> matrix conversion from XYZ to linear display RGB (but not for DCDM, see argument <code>display_pri</code>)
</p>
</li>
<li><p> clamp linear display RGB (or XYZ for DCDM) to the cube [0,1]<code class="reqn">^3</code>
</p>
</li></ol>
    


<h3>Value</h3>

<p><code>general.PODT()</code> returns a <code>TransferFunction</code> of dimension 3
that maps OCES RGB to linear display RGB.
The domain is [0,10000]<code class="reqn">^3</code> and the range is [0,1]<code class="reqn">^3</code>.
<br />
The <code><a href="#topic+metadata">metadata</a></code> contains the display primaries and whitepoint,
which is useful in <code><a href="#topic+installRGB">installRGB</a>()</code>.
</p>


<h3>Source</h3>

<p>This function was based on source code at:
<a href="https://github.com/ampas/aces-core">https://github.com/ampas/aces-core</a>;
especially the files under the folder <code>aces-dev-master/transforms/ctl/odt/</code>.
</p>


<h3>References</h3>

<p>ST 2065-1:2012.
SMPTE Standard - Academy Color Encoding Specification (ACES).
2013.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TransferFunction">TransferFunction</a></code>,
<code><a href="#topic+installRGB">installRGB</a>()</code>,
<code><a href="#topic+metadata">metadata</a>()</code>,
<code><a href="#topic+RRT.TF">RRT.TF</a></code>,
<a href="#topic+Standard+20Primaries">Standard Primaries</a>
</p>

<hr>
<h2 id='Perceptual+20Quality+20Transform'>
Perceptual Quality Transform
</h2><span id='topic+PQ.EOTF'></span>

<h3>Description</h3>

<p>The Perceptual Quantizer is a transfer function that allows for the display of high dynamic range (HDR) video.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PQ.EOTF( Lmax=10000 )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Perceptual+2B20Quality+2B20Transform_+3A_lmax">Lmax</code></td>
<td>
<p>the maximum luminance, in <code class="reqn">cd/m^2</code>, or nit.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>PQ.EOTF()</code> returns a <code>TransferFunction</code> that maps signal-display RGB to linear-display RGB.
The interval [0,1] maps to [0,<code>Lmax</code>].
</p>


<h3>References</h3>

<p>ST-2084.
SMPTE Standard - High Dynamic Range Electro-Optical Transfer Function of Mastering Reference Displays.
2014.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TransferFunction">TransferFunction</a></code>
</p>

<hr>
<h2 id='plot'>plot a TransferFunction</h2><span id='topic+plot.TransferFunction'></span>

<h3>Description</h3>

<p>plot a <code>TransferFunction</code> of dimension 1, 2, or 3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TransferFunction'
plot( x, color='red', main=TRUE, add=FALSE, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>a <code>TransferFunction</code> object with dimension N = 1, 2, or 3.</p>
</td></tr>
<tr><td><code id="plot_+3A_color">color</code></td>
<td>

<p>Any value acceptable as the <code>col</code> argument to <code>graphics::lines()</code>.
If N=3 this argument is currently ignored.
</p>
</td></tr>
<tr><td><code id="plot_+3A_main">main</code></td>
<td>
<p>If <code>main=TRUE</code> then a main title is generated from the object <code>x</code>.
If <code>main=FALSE</code> then no main title is displayed.
And if <code>main</code> is a character string then that string is used as the main title.
If N=3 this argument is currently ignored.
</p>
</td></tr>
<tr><td><code id="plot_+3A_add">add</code></td>
<td>

<p>If <code>add=TRUE</code> then the lines are added to an existing plot.
If N=3 this argument is currently ignored.
</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>other graphical parameters, see <b>Details</b></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If N=1 a conventional plot is drawn using <code>graphics::lines()</code>.
Commonly used graphical parameters applicable when N=1 are:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>log</code>  </td><td style="text-align: left;">  passed on to <code><a href="graphics.html#topic+plot.default">plot.default</a>()</code>. 
Care must be taken because many transfer functions have 0 in their domains. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>If N=2 a grid is generated in the domain box, and the image of that grid is plotted using using <code>graphics::lines()</code>.
<br />
If N=3 a grid is generated in the domain box, and the image of that grid is plotted in 3D
using <code>rgl::lines3d()</code>.
</p>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code>
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+lines">graphics::lines</a>()</code>,
<code><a href="rgl.html#topic+3dobjects">rgl::lines3d</a>()</code>
</p>

<hr>
<h2 id='plotPatchesRGB'>Plot Patches defined by RGB</h2><span id='topic+plotPatchesRGB'></span>

<h3>Description</h3>

<p>RGB patches are a very common way of comparing color renderings.
This function draws rectangular patches,
and can also draw triangles formed by omitting one vertex from the rectangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPatchesRGB( obj, space='sRGB', which='signal', maxColorValue=1,
                     background='gray50', shape='full', add=FALSE, labels=FALSE, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotPatchesRGB_+3A_obj">obj</code></td>
<td>

<p>an Nx3 matrix of RGBs for N patches, preferably with assigned <code>rownames</code>.
<code>obj</code> can also be a <code>data.frame</code> containing a unique matrix column whose name
starts with the string <code>'RGB'</code>.
If <code>obj</code> has columns <code>LEFT,TOP,WIDTH,HEIGHT</code> then these are used to place the patches,
with the Y coordinate increasing going <em>down</em> the page.
If <code>obj</code> has columns <code>LEFT,BOTTOM,WIDTH,HEIGHT</code> then these are used to place the patches,
with the Y coordinate increasing going <em>up</em> the page.
If there are no columns defining the location and size of the patches,
then defaults are supplied, see <b>Details</b>.
</p>
</td></tr>
<tr><td><code id="plotPatchesRGB_+3A_space">space</code></td>
<td>
<p>the name of an installed RGB space.
When the input RGB is linear, a transfer function of this RGB space is used
to convert linear RGB to signal RGB, see <b>Details</b>.</p>
</td></tr>
<tr><td><code id="plotPatchesRGB_+3A_which">which</code></td>
<td>
<p>the meaning of the RGB values in <code>obj</code>.
Valid values are <code>'signal'</code>, <code>'scene'</code>, and <code>'display'</code>.
See the Figure on page 2.
Partial matching is used.
For the RGB processing, see <b>Details</b>.
</p>
</td></tr>
<tr><td><code id="plotPatchesRGB_+3A_maxcolorvalue">maxColorValue</code></td>
<td>
<p>a positive number used for input RGB scaling, see <b>Details</b></p>
</td></tr>
<tr><td><code id="plotPatchesRGB_+3A_background">background</code></td>
<td>

<p>the color for the background behind all the patches.
If it is a character string, it is passed directly to <code>par()</code> as parameter <code>bg</code>.
If it is a numeric vector of length 3, it is processed just like the input RGB in <code>obj</code>,
see  <b>Details</b>.
If it is a number, it is interpreted as graylevel,
replicated to length 3, and treated as in the previous sentence.</p>
</td></tr>
<tr><td><code id="plotPatchesRGB_+3A_shape">shape</code></td>
<td>

<p>If <code>shape='full'</code> (the default) then the full rectangle is drawn.
<br />
If <code>shape='half'</code> then the rectangle is shrunk to 1/2 size, and with the same center.
<br />
If <code>shape</code> is one of <code>'left'</code>, <code>'right'</code>, <code>'bottom'</code>, or <code>'top'</code>
then only a  half-rectangle is drawn, and keeping the specified side.
<br />
If <code>shape</code> is one of <code>'topleft'</code>, <code>'topright'</code>, <code>'bottomleft'</code>, or <code>'bottomright'</code>,
then only a triangular half of the rectangle is drawn, 
and keeping the specified vertex.
<br />
If <code>shape='hhex'</code> then a hexagon is drawn inscribed in the rectangle with 2 horizontal
opposite sides (in contact with the rectangle sides).
And if the aspect ratio of the rectangle is <code class="reqn"> 2:\sqrt{3} </code> the hexagon is regular.
If <code>shape='vhex'</code> then the inscribed rectangle has 2 vertical opposite sides.
</p>
</td></tr>
<tr><td><code id="plotPatchesRGB_+3A_add">add</code></td>
<td>
<p>if <code>TRUE</code> then the patches are added to an existing plot</p>
</td></tr>
<tr><td><code id="plotPatchesRGB_+3A_labels">labels</code></td>
<td>
<p>controls how the patches are labeled, using <code>rownames(obj)</code>,
or 1:N if <code>rownames(obj)</code> is <code>NULL</code>.
The function used is <code>graphics::<a href="graphics.html#topic+text">text</a>()</code>.
If <code>labels=FALSE</code> then no labels are plotted.
If <code>labels=TRUE</code> then labels are plotted in the center of the patch when there are
columns defining the location and size of the patches, and to the right of the patch otherwise.
<br />
<code>labels</code> can also be a character string defining the location where the labels are drawn.
It can be the side of the patches, i.e. <code>left</code>, <code>right</code>, <code>top</code>, or <code>bottom</code>,
or the corner of the patches, i.e. <code>bottomleft</code>, <code>bottomright</code>, <code>topleft</code>, or <code>topright</code>.
</p>
</td></tr>
<tr><td><code id="plotPatchesRGB_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>graphics::<a href="graphics.html#topic+text">text</a>()</code>.
For example: <code>adj</code>, <code>cex</code>, etc.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>which='signal'</code> then the input RGBs are converted to hex codes using
<code><a href="grDevices.html#topic+rgb">rgb</a>()</code> using the <code>maxColorValue</code> argument,
and the <code>space</code> argument is ignored.
<br />
If <code>which='scene'</code> or  <code>which='display'</code> then the input linear RGBs are normalized
by division by <code>maxColorValue</code>, and then converted to signal RGB using
<code><a href="#topic+SignalRGBfromLinearRGB">SignalRGBfromLinearRGB</a>()</code> with the <code>space</code> argument.
The signal RGB is then converted to hex codes using <code><a href="grDevices.html#topic+rgb">rgb</a>()</code>.
</p>
<p>If <code>obj</code> is a matrix, or a data.frame without columns <code>LEFT,TOP,WIDTH,HEIGHT</code>,
then the patches are drawn vertically stacked and abutting from top to bottom.
</p>


<h3>Value</h3>

 <p><code>TRUE</code> if successful, and <code>FALSE</code> otherwise</p>


<h3>See Also</h3>

<p><code><a href="#topic+SignalRGBfromLinearRGB">SignalRGBfromLinearRGB</a>()</code>,
<code><a href="#topic+installRGB">installRGB</a>()</code>,
<code><a href="grDevices.html#topic+rgb">rgb</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
RGB = round( 255 * matrix( runif(6*3), 6, 3 ) )
plotPatchesRGB( RGB, max=255 )
</code></pre>

<hr>
<h2 id='print'>Print Basic Facts about a TransferFunction</h2><span id='topic+print'></span><span id='topic+print.TransferFunction'></span>

<h3>Description</h3>

<p>Each <code>TransferFunction</code> object is actually a list of so-called <em>elementary</em> transfer functions;
for details on this see <code><a href="#topic+composition">composition</a>()</code>.
This <code>print()</code> calls an internal <code>print()</code> function for each elementary function individually.
The internal <code>print()</code> also calls an 
internal <code>validate()</code> (with default arguments) which runs some basic tests
and formats the results nicely for printing, see <code><a href="#topic+validate">validate</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TransferFunction'
print( x, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>a <code>TransferFunction</code> object consisting of M <em>elementary</em> transfer functions</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>further arguments ignored, but required by the generic <code>print()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns <code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TransferFunction">TransferFunction</a></code>,
<code><a href="#topic+validate">validate</a>()</code>,
<code><a href="#topic+composition">composition</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tf = sRGB.EOTF^-1 * power.EOTF(2.5)
tf
##  #--------------------   [sRGB.EOTF]^-1    ---------------------#
##  [sRGB.EOTF]^-1 is a univariate TransferFunction.
##  domain:      [0,1]  (linear display)
##  range:       [0,1]  (non-linear signal)
##  invertible:  Yes
##  orientation: preserving
##  range-test points = 1300, max(distance)=0.
##  validation:  Passed
##  #--------------------   power.EOTF(2.5)    ---------------------#
##  power.EOTF(2.5) is a univariate TransferFunction.
##  domain:      [0,1]  (non-linear signal)
##  range:       [0,1]  (linear display)
##  invertible:  Yes
##  orientation: preserving
##  range-test points = 1300, max(distance)=0.
##  validation:  Passed
</code></pre>

<hr>
<h2 id='Reference+20Rendering+20Transform'>
Reference Rendering Transform
</h2><span id='topic+RRT.TF'></span><span id='topic+general.RRT'></span>

<h3>Description</h3>

<p>The fixed <code>RRT.TF</code> corresponds to the RRT in aces-dev 1.1.
<br />
A parameterized version <code>general.RRT()</code> is also provided - for experimentation.
This one returns a <code>TransferFunction</code> with the argument values &quot;locked-in&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RRT.TF
general.RRT( glowmod="1.1", redmod="1.1" )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Reference+2B20Rendering+2B20Transform_+3A_glowmod">glowmod</code></td>
<td>
<p>the version of the Glow Modifier to use.  
The only version currently supported is <code>"1.1"</code>.
<br />
<code>glowmod</code> can also be <code>NULL</code>, <code>NA</code>, or <code>FALSE</code>,
which means to use no Glow Modifier at all.
</p>
</td></tr>
<tr><td><code id="Reference+2B20Rendering+2B20Transform_+3A_redmod">redmod</code></td>
<td>
<p>the version of the Red Modifier to use.  
The only version currently supported is <code>"1.1"</code>.
This string can also be <code>"1.1+pinv"</code>
which means to use a precision inverse; the forward transfer is exactly the same.
This precision inverse uses an iterative root-finder, 
and is slower than the approximate default inverse.
<br />
<code>redmod</code> can also be <code>NULL</code>, <code>NA</code>, or <code>FALSE</code>,
which means to use no Red Modifier at all.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>RRT.TF</code> is a <code>Transferfunction</code> that maps ACES RGB to OCES RGB.
Both spaces are relative to the AP1 primaries.
<code>RRT.TF</code> is constructed by calling <code>general.RRT()</code> with its default arguments.
The transfer is complicated; here is a summary of the steps
starting with ACES RGB as input:
</p>

<ol>
<li><p> glow module (see argument <code>glowmod</code>)
</p>
</li>
<li><p> red modifier (see argument <code>redmod</code>)
</p>
</li>
<li><p> matrix conversion from AP0 RGB   &rarr;  AP1 RGB
</p>
</li>
<li><p> clamp to non-negative RGB
</p>
</li>
<li><p> global desaturation
</p>
</li>
<li><p> segmented spline, applied to each channel separately
</p>
</li>
<li><p> matrix conversion from AP1   &rarr;   AP0 (now OCES RGB)
</p>
</li></ol>



<h3>Value</h3>

<p><code>general.RRT()</code> returns a <code>Transferfunction</code> that maps ACES RGB to OCES RGB.
The domain is [0,47000]<code class="reqn">^3</code> and the range is [0,10000]<code class="reqn">^3</code>.
</p>


<h3>References</h3>

<p>ST 2065-1:2012.
SMPTE Standard - Academy Color Encoding Specification (ACES).
2013.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TransferFunction">TransferFunction</a></code>
</p>

<hr>
<h2 id='RGB+20Space+20Management'>Manage RGB Spaces</h2><span id='topic+installRGB'></span><span id='topic+uninstallRGB'></span>

<h3>Description</h3>

<p>Install/uninstall RGB spaces in a dictionary. 
The dictionary comes with 8 RGB spaces pre-installed.
To query the dictionary, use <code><a href="#topic+getRGB">getRGB</a>()</code> and <code><a href="#topic+summaryRGB">summaryRGB</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>installRGB( space, scene, display=NULL, OETF=NULL, EOTF=NULL, OOTF=NULL, overwrite=FALSE )
uninstallRGB( space )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RGB+2B20Space+2B20Management_+3A_space">space</code></td>
<td>
<p>name of the RGB space to install or uninstall or query.
After the RGB space is installed,
the string <code>space</code> can be used in the conversion functions,
e.g. <code><a href="#topic+RGBfromXYZ">RGBfromXYZ</a>()</code> and <code><a href="#topic+XYZfromRGB">XYZfromRGB</a>()</code>.</p>
</td></tr>
<tr><td><code id="RGB+2B20Space+2B20Management_+3A_scene">scene</code></td>
<td>

<p>the specification of the scene primaries and whitepoint.
There are many options here.
The 1st option is a 4x2 matrix with the CIE xy chromaticities of R,G,B,W in the rows, in that order.
The 2nd option is a list with 2 items: the primaries data and the whitepoint data.
These are described in the section <b>Primaries and Whitepoint Details</b> below.
If <code>scene</code> is <code>NULL</code>, it will duplicate the data from argument <code>display</code>.
</p>
</td></tr>
<tr><td><code id="RGB+2B20Space+2B20Management_+3A_display">display</code></td>
<td>

<p>the specification of the display primaries and whitepoint.
The options are the same as for argument <code>scene</code>.
If this is <code>NULL</code> (the default), the function will first look at the metadata of the transfer functions.
These built-in transfer functions
- <code>general.OOTF()</code> and <code>general.PODT()</code>  - 
already have this metadata assigned.
If the metadata is not found, it will duplicate the data from argument <code>scene</code>.
</p>
</td></tr>
<tr><td><code id="RGB+2B20Space+2B20Management_+3A_oetf">OETF</code></td>
<td>

<p>a <code><a href="#topic+TransferFunction">TransferFunction</a></code> of dimension 1 or 3.
<br />
<code>OETF</code> can also be a positive number <code class="reqn">\gamma</code>,
which is then passed to <code><a href="#topic+power.OETF">power.OETF</a>()</code> to create the <code><a href="#topic+TransferFunction">TransferFunction</a></code>.
This is the classical <code class="reqn">1/\gamma</code> power law.
<br />
<code>OETF</code> can also be <code>NULL</code>; see section <b>Transfer Function Details</b> for valid combinations.
</p>
</td></tr>
<tr><td><code id="RGB+2B20Space+2B20Management_+3A_eotf">EOTF</code></td>
<td>

<p>a <code><a href="#topic+TransferFunction">TransferFunction</a></code> of dimension 1 or 3.
<br />
<code>EOTF</code> can also be a positive number <code class="reqn">\gamma</code>,
which is then passed to <code><a href="#topic+power.EOTF">power.EOTF</a>()</code> to create the <code><a href="#topic+TransferFunction">TransferFunction</a></code>.
This is the classical <code class="reqn">\gamma</code> power law.
<br />
<code>EOTF</code> can also be one of these strings:
<code>'sRGB'</code>, <code>'ProPhotoRGB'</code>, <code>'BT.709'</code>,  <code>'BT.2020'</code>, or  <code>'240M'</code>,
which then installs the appropriate special EOTF function.
<br />
<code>EOTF</code> can also be <code>NULL</code>; see section <b>Transfer Function Details</b> for valid combinations.
</p>
</td></tr>
<tr><td><code id="RGB+2B20Space+2B20Management_+3A_ootf">OOTF</code></td>
<td>

<p>a <code><a href="#topic+TransferFunction">TransferFunction</a></code> of dimension 1 or 3.
<br />
<code>OOTF</code> can also be a positive number <code class="reqn">\gamma</code>,
which is then passed to <code><a href="#topic+power.OOTF">power.OOTF</a>()</code> to create the <code><a href="#topic+TransferFunction">TransferFunction</a></code>.
This is the classical <code class="reqn">\gamma</code> power law.
<br />
<code>EOTF</code> can also be <code>NULL</code>; see section <b>Transfer Function Details</b> for valid combinations.
</p>
</td></tr>
<tr><td><code id="RGB+2B20Space+2B20Management_+3A_overwrite">overwrite</code></td>
<td>

<p>in <code>installRGB()</code>, <code>space</code> is compared with previously installed
RGB space names in case-insensitive way.  
If there is a match, and <code>overwrite</code> is <code>FALSE</code>,
then the installation fails.
If <code>overwrite</code> is <code>TRUE</code>, then the existing space is overwritten.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both  <code>installRGB()</code> and <code>uninstallRGB()</code> check for matches with existing names.
The matching is full (not partial) and case-insensitive.
So it is impossible to have 2 spaces that differ only in case.
</p>


<h3>Value</h3>

<p><code>installRGB()</code> and <code>uninstallRGB()</code> return <code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>Primaries and Whitepoint Details</h3>

<p>The arguments <code>scene</code> and <code>display</code> can be a list with 2 items: 
<code>primaries</code> and <code>white</code> in that order.
There are 3 options for this list, as given in this table:
</p>

<table>
<tr>
 <td style="text-align: center;">
<code>dim(primaries)</code>  </td><td style="text-align: center;"> <code>length(white)</code> </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: center;">
4x2 </td><td style="text-align: center;"> 1 </td><td style="text-align: left;">  <code>primaries</code> is a 4x2 matrix with CIE xy chromaticities of R,G,B,W in the rows</td>
</tr>
<tr>
 <td style="text-align: center;">
3x2 </td><td style="text-align: center;"> 2 </td><td style="text-align: left;">  <code>primaries</code> is a 3x2 matrix with CIE xy chromaticities of R,G,B in the rows</td>
</tr>
<tr>
 <td style="text-align: center;">
3x2 </td><td style="text-align: center;"> 3 </td><td style="text-align: left;">  <code>primaries</code> is a 3x2 matrix with CIE xy chromaticities of R,G,B in the rows</td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>If <code>length(white)</code> is 1, then <code>white</code> is the whitepoint Y.
If <code>length(white)</code> is 2, then <code>white</code> is the whitepoint xy (CIE chromaticity); 
the whitepoint Y is taken to be 1.
If <code>length(white)</code> is 3, <code>white</code> is the whitepoint XYZ (CIE tristimulus).
<br />
The whitepoint is linearly transformed to RGB=(1,1,1).
For better numeric compatibility with standards, xy is recommended.
For better numeric compatibility with <cite>Lindbloom</cite>, XYZ is recommended.
See the <b>Examples</b> below.
</p>


<h3>Transfer Function Details</h3>

<p>The 3 transfer functions - <code>OETF</code>, <code>EOTF</code>, <code>OOTF</code> - can be <code>NULL</code> (the default) or given.
This yields 8 combinations, but only 6 are valid, as given in this table:
</p>

<table>
<tr>
 <td style="text-align: center;">
<code>OETF</code> </td><td style="text-align: center;"> <code>EOTF</code> </td><td style="text-align: center;"> <code>OOTF</code>         </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: center;">
 given      </td><td style="text-align: center;">   given     </td><td style="text-align: center;">   given             </td><td style="text-align: left;"> INVALID </td>
</tr>
<tr>
 <td style="text-align: center;">
 given      </td><td style="text-align: center;">   given     </td><td style="text-align: center;">   <code>OETF*EOTF</code>  </td><td style="text-align: left;"> <code>OOTF</code> is the composition <code>OETF</code> followed by <code>EOTF</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
 given      </td><td style="text-align: center;">  <code>OETF^-1*OOTF</code>      </td><td style="text-align: center;"> given </td><td style="text-align: left;"> <code>EOTF</code> is the composition <code>OETF^-1</code> followed by <code>OOTF</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
 <code>OOTF*EOTF^-1</code> </td><td style="text-align: center;">  given    </td><td style="text-align: center;"> given        </td><td style="text-align: left;"> <code>OETF</code> is the composition <code>OOTF</code> followed by <code>EOTF^-1</code> </td>
</tr>
<tr>
 <td style="text-align: center;"> 
 
given </td><td style="text-align: center;">  <code>OETF^-1</code>  </td><td style="text-align: center;">  <code>identity.TF</code>  </td><td style="text-align: left;"> <code>EOTF</code> is set to <code>OETF^-1</code>, and <code>OOTF</code> is set to the identity </td>
</tr>
<tr>
 <td style="text-align: center;"> 
  
 <code>EOTF^-1</code>  </td><td style="text-align: center;">  given  </td><td style="text-align: center;">  <code>identity.TF</code>  </td><td style="text-align: left;"> <code>OETF</code> is set to <code>EOTF^-1</code>, and <code>OOTF</code> is set to the identity </td>
</tr>
<tr>
 <td style="text-align: center;"> 

<code>NULL</code> </td><td style="text-align: center;"> <code>NULL</code> </td><td style="text-align: center;">  given              </td><td style="text-align: left;"> INVALID </td>
</tr>
<tr>
 <td style="text-align: center;">
<code>NULL</code> </td><td style="text-align: center;"> <code>NULL</code> </td><td style="text-align: center;"> <code>NULL</code>         </td><td style="text-align: left;"> all 3 transfer functions are set to <code>identity.TF</code>.  </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>Think of these 3 functions as forming a triangle.
If all 3 are given, the transfers may be ambiguous, i.e. the triangle may not commute.
If 2 functions are given, the 3rd is computed from those 2.
If only 1 function is given, and it is EOTF or OETF, then it makes sense to make the other one the inverse
of the given one, so that the OOTF is the identity.
If only the OOTF is given, there is no well-defined way to define the other 2.
If none are given, as in the last row,
this might be useful for testing conversion between RGB and XYZ.
</p>


<h3>Warning</h3>

<p>All the RGB spaces are stored in a dictionary.
If <code>installRGB()</code> is successful, the installed space is only in
the dictionary until the end of the <span class="rlang"><b>R</b></span> session.
To make it persist, please put the function call in an <span class="rlang"><b>R</b></span> script that is executed
after the package is loaded.
<br />
The dictionary comes with 8 RGB spaces pre-installed.
</p>


<h3>References</h3>

<p>Lindbloom, Bruce.
<b>RGB/XYZ Matrices</b>.
<a href="http://brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html">http://brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getRGB">getRGB</a>()</code>,
<code><a href="#topic+summaryRGB">summaryRGB</a>()</code>
<code><a href="#topic+RGBfromXYZ">RGBfromXYZ</a>()</code>,
<code><a href="#topic+XYZfromRGB">XYZfromRGB</a>()</code>,
<code><a href="#topic+TransferFunction">TransferFunction</a></code>,
<code><a href="#topic+power.OETF">power.OETF</a>()</code>,
<code><a href="#topic+power.EOTF">power.EOTF</a>()</code>,
<code><a href="#topic+power.OOTF">power.OOTF</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  install native RGB space for NEC PA242W display
prim = matrix( c(0.675,0.316, 0.199,0.715, 0.157,0.026), 3, 2, byrow=TRUE )
installRGB( 'PA242W', scene=NULL, display=list(primaries=prim,white=c(0.95047,1,1.08883)), OETF=2 )

#  install a linear version of sRGB  (OETF=1)
prim    = matrix( c(0.64,0.33,  0.30,0.60, 0.15,0.06), 3, 2, byrow=TRUE )
installRGB( 'linear-sRGB', scene=NULL, display=list(prim,c(0.3127,0.3290)), OETF=1 )

# make plot comparing three EOTFs
plot( getRGB('sRGB')$EOTF, col='black' )
plot( getRGB('linear')$EOTF, col='red', add=TRUE )
plot( getRGB('PA242W')$EOTF, col='blue', add=TRUE )

# Install an RGB space named 'HD+2.4', with encoding from BT.709 and display from BT.1886.
# the OOTF for this space is non-trivial
prim    = matrix( c(0.64,0.33,  0.30,0.60,  0.15,0.06 ), 3, 2, byrow=TRUE )
white   = c( 0.3127, 0.3290 )
installRGB( "HD+2.4", scene=NULL, display=list(prim,white),
                          OETF=(BT.709.EOTF)^-1, EOTF=BT.1886.EOTF(), over=TRUE )

# make plot comparing two OOTFs
plot( getRGB('HD+2.4')$OOTF, col='red')
plot( getRGB('sRGB')$OOTF, col='black', add=TRUE  )
</code></pre>

<hr>
<h2 id='RGB+20Space+20Query'>Query RGB Spaces</h2><span id='topic+getRGB'></span><span id='topic+getWhiteXYZ'></span><span id='topic+summaryRGB'></span>

<h3>Description</h3>

<p>Query and summarize the installed RGB spaces.
The RGB spaces are stored in a dictionary, which comes with 8 RGB spaces pre-installed.
These spaces are:
<b>sRGB</b>,        <b>AdobeRGB</b>,    <b>ProPhotoRGB</b>, <b>AppleRGB</b>,    <b>BT.709</b>,
<b>BT.2020</b>,     <b>240M</b>, and        <b>HD+2.4</b>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryRGB( verbosity=1 )

getRGB( space )
getWhiteXYZ( space, which='scene' )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RGB+2B20Space+2B20Query_+3A_space">space</code></td>
<td>
<p>name of the RGB space to query.
The name matching is partial and case-insensitive.
</p>
</td></tr>
<tr><td><code id="RGB+2B20Space+2B20Query_+3A_verbosity">verbosity</code></td>
<td>

<p>an integer that controls the return value of <code>summaryRGB()</code>, see <b>Value</b>.
</p>
</td></tr>
<tr><td><code id="RGB+2B20Space+2B20Query_+3A_which">which</code></td>
<td>
<p>the source of the whitepoint, either <code>'scene'</code> or <code>'display'</code>.
Matching is partial and case-insensitive.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>getWhiteXYZ()</code> is provided because some applications only need the whitepoint
for chromatic adaptation purposes, and this function is faster than <code>getRGB()</code>.
</p>


<h3>Value</h3>

<p><code>summaryRGB()</code>, with the default <code>verbosity=1</code>, returns a <code>data.frame</code>
with a row for each RGB space.
The row contains  primary, whitepoint, and transfer function information for each space.
The primary/whitepoint data is for both scene and display; all the data is numerical and the columns are labeled.
There are 22 columns so the display is very wide.
<br />
The transfer function data is a very short string.
If the OETF is classical (pure 1/<code class="reqn">\gamma</code> power law), the string is 1/<code class="reqn">\gamma</code>.
If the OETF is not classical, the string is 1/~<code class="reqn">\gamma</code>,
where <code class="reqn">\gamma</code> is the best-fit (or approximate or effective) <code class="reqn">\gamma</code> to the OETF in the <code class="reqn">L^1</code>-norm.
<br />
Similarly, if the EOTF is classical (pure <code class="reqn">\gamma</code> power law) the string is <code class="reqn">\gamma</code>,
and if the EOTF is not classical the string is ~<code class="reqn">\gamma</code>.
<br />
The OOTF is the quotient (to 2 decimal places) of the gammas of EOTF and OETF
(either true gamma or best-fit gamma).
If either gamma is best-fit then the string is preceede by a <code>'~'</code>,
which means <em>effective</em>.
<br />
If the <code>TransferFunction</code> has dimension 1, but the domain and range are not the interval [0,1],
the string is <code>'1D'</code>.
If the <code>TransferFunction</code> has dimension 3, the string is <code>'3D'</code>.
<br />
If <code>verbosity=0</code>, <code>summaryRGB()</code> returns the names of all the RGB spaces.
</p>
<p><code>getRGB()</code> returns a list with these items:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>space</code>   </td><td style="text-align: left;">   the full and original name of the RGB space  </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>scene</code> 	 </td><td style="text-align: left;">   a list with items <code>primaries</code>, <code>whiteXYZ</code>, <code>RGB2XYZ</code>, and <code>XYZ2RGB</code>  </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>display</code> </td><td style="text-align: left;">   a list with items <code>primaries</code>, <code>whiteXYZ</code>, <code>RGB2XYZ</code>, and <code>XYZ2RGB</code>  </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>EOTF</code>    </td><td style="text-align: left;">   Electro-Optical Transfer Function  </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>OETF</code>    </td><td style="text-align: left;">   Opto-Electronic Transfer Function  </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>OOTF</code>    </td><td style="text-align: left;">   Opto-Optical Transfer Function, and numerically equal to <code>OETF*EOTF</code>  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The items in the lists <code>scene</code> and <code>display</code> are
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>primaries</code> </td><td style="text-align: left;">   4x2 matrix with the xy chromaticities of the RGB primaries and white </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>whiteXYZ</code>  </td><td style="text-align: left;">   XYZ of the display white point, which maps to RGB=(1,1,1) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>RGB2XYZ</code>   </td><td style="text-align: left;">   3x3 matrix taking RGB to XYZ </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>XYZ2RGB</code>   </td><td style="text-align: left;">   3x3 matrix taking XYZ to RGB </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>All transfer functions are actual <code>TransferFunctions</code> objects, 
and not the numerical exponent or character string name.
They are suitable for plotting with <code><a href="#topic+plot.TransferFunction">plot.TransferFunction</a>()</code>; see the <b>Examples</b>.
In case of error, <code>getRGB()</code> returns NULL.
</p>
<p><code>getWhiteXYZ()</code> 
returns a numeric 3-vector with the XYZ of the whitepoint of the scene or the display.
In case of error it returns <code>NULL</code>.
</p>


<h3>References</h3>

<p>Lindbloom, Bruce.
<b>RGB/XYZ Matrices</b>.
<a href="http://brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html">http://brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+installRGB">installRGB</a>()</code>,
<code><a href="#topic+plot.TransferFunction">plot.TransferFunction</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make plot comparing three EOTFs
plot( getRGB('sRGB')$EOTF, col='black' )
plot( getRGB('BT.709')$EOTF, col='blue', add=TRUE )
plot( getRGB('ProPhotoRGB')$EOTF, col='red', add=TRUE )
</code></pre>

<hr>
<h2 id='Signal+20RGB+20Calculation'>Calculate Signal RGB from Linear RGB, XYZ, or Lab</h2><span id='topic+RGBfromXYZ'></span><span id='topic+RGBfromLab'></span><span id='topic+SignalRGBfromLinearRGB'></span>

<h3>Description</h3>

<p>Calculate signal RGB from linear RGB, XYZ, or Lab</p>


<h3>Usage</h3>

<pre><code class='language-R'>SignalRGBfromLinearRGB( RGB, space='sRGB', which='scene', TF=NULL, maxSignal=1 )

RGBfromXYZ( XYZ, space='sRGB', which='scene', TF=NULL, maxSignal=1 ) 

RGBfromLab( Lab, space='sRGB', which='scene', TF=NULL, maxSignal=1 ) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Signal+2B20RGB+2B20Calculation_+3A_rgb">RGB</code></td>
<td>
<p>a numeric Nx3 matrix with linear RGB coordinates in the rows,
or a vector that can be converted to such a matrix, by row.
The RGB may be outside the corresponding domain box (either scene or display), see <b>Details</b>.</p>
</td></tr>
<tr><td><code id="Signal+2B20RGB+2B20Calculation_+3A_xyz">XYZ</code></td>
<td>
<p>a numeric Nx3 matrix with CIE XYZ coordinates in the rows, or a vector that can be converted to such a matrix, by row.
The XYZ are assumed to be viewed under the white-point of the given RGB <code>space</code>.</p>
</td></tr>
<tr><td><code id="Signal+2B20RGB+2B20Calculation_+3A_lab">Lab</code></td>
<td>
<p>a numeric Nx3 matrix with CIE Lab coordinates in the rows, or a vector that can be converted to such a matrix, by row.</p>
</td></tr>
<tr><td><code id="Signal+2B20RGB+2B20Calculation_+3A_space">space</code></td>
<td>
<p>the name of an installed RGB space.
The name matching is partial and case-insensitive.</p>
</td></tr>
<tr><td><code id="Signal+2B20RGB+2B20Calculation_+3A_which">which</code></td>
<td>
<p>either <code>'scene'</code> or <code>'display'</code>.
For <code>RGBfromXYZ()</code> <code>which</code> describes the input XYZ.
For <code>SignalRGBfromLinearRGB()</code> <code>which</code> describes the input RGB.
</p>
</td></tr>
<tr><td><code id="Signal+2B20RGB+2B20Calculation_+3A_tf">TF</code></td>
<td>
<p>if not <code>NULL</code>, <code>TF</code> is a <code>TransferFunction</code>
that overrides the appropriate transfer function of <code>space</code>.
<code>TF</code> can also be a positive number.
If <code>TF=1</code>, then <code>TF</code> is set to <code>identity.TF</code>,
so the returned RGB values are actually linear, and they are not clamped to the appropriate domain box
(see <b>Value</b>).
If <code>TF!=1</code> it is used to create either
<code>power.EOTF()</code> or <code>power.OETF()</code> as approriate.
If <code>TF</code> is not <code>NULL</code> in <code>SignalRGBfromLinearRGB()</code>, then <code>space</code> is ignored.
</p>
</td></tr>
<tr><td><code id="Signal+2B20RGB+2B20Calculation_+3A_maxsignal">maxSignal</code></td>
<td>
<p>maximum value of non-linear <code>RGB</code>.
Other common values are 100, 255, 1023, 4095, and 65535.
Even when 1, they are still taken to be non-linear Signal values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code>RGBfromXYZ()</code>, the conversion is done in these steps:
</p>

<ul>
<li><p> XYZ    &rarr;   linear RGB using the 3x3 matrix for the given <code>space</code> and <code>which</code>
</p>
</li>
<li><p> if <code>TF</code> is not the identity, the linear RGBs are clamped to [0,1]<code class="reqn">^3</code> if necessary
</p>
</li>
<li><p> linear RGB    &rarr;   signal RGB using <code>SignalRGBfromLinearRGB()</code> and all other the given arguments
</p>
</li></ul>

<p>In <code>RGBfromLab()</code>, Lab   &rarr;  XYZ
is calculated using
<code><a href="spacesXYZ.html#topic+toXYZ">spacesXYZ::XYZfromLab</a>()</code>,
with the white point
(either <code>'scene'</code> or <code>'display'</code>) of the given RGB space.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> with N rows and these columns
</p>
<table role = "presentation">
<tr><td><code>RGB</code></td>
<td>
<p>signal RGB.
If <code>TF</code> is not the identity, the computed linear RGBs are clamped to [0,1]<code class="reqn">^3</code> if necessary,
which implies that the output signal RGBs are inside the cube [0,<code>maxSignal</code>]<code class="reqn">^3</code>.
Values are not rounded.</p>
</td></tr>
<tr><td><code>OutOfGamut</code></td>
<td>
<p>a logical, TRUE means one or more of the computed linear RGBs were actually clamped to [0,1].</p>
</td></tr>
</table>
<p>In <code>RGBfromLab()</code>, if a=b=0 exactly, the R=G=B exactly.
</p>
<p>In case of error, the functions return NULL.
</p>


<h3>References</h3>

<p>Wikipedia. <b>RGB color space</b>.
<a href="https://en.wikipedia.org/wiki/RGB_color_space">https://en.wikipedia.org/wiki/RGB_color_space</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+XYZfromRGB">XYZfromRGB</a>()</code>,
<code><a href="#topic+LinearRGBfromSignalRGB">LinearRGBfromSignalRGB</a>()</code>,
<code><a href="#topic+installRGB">installRGB</a>()</code>,
<code><a href="#topic+identity.TF">identity.TF</a></code>,
<code><a href="spacesXYZ.html#topic+toXYZ">spacesXYZ::XYZfromLab</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RGBfromXYZ( c(80.310897,90.306510,84.613450, 100,100,100)/100, max=255 )
##       RGB.R    RGB.G    RGB.B OutOfGamut
##  1 230.1676 249.4122 225.2472      FALSE
##  2 255.0000 249.1125 244.4704       TRUE
</code></pre>

<hr>
<h2 id='Standard+20Primaries'>
Standard Primaries
</h2><span id='topic+Standard+20Primaries'></span><span id='topic+AP0_PRI'></span><span id='topic+AP1_PRI'></span><span id='topic+REC709_PRI'></span><span id='topic+REC2020_PRI'></span><span id='topic+P3D65_PRI'></span><span id='topic+P3D60_PRI'></span><span id='topic+P3DCI_PRI'></span>

<h3>Description</h3>

<p>xy Chromaticities for some standard primary sets.
These include Red, Green, Blue, and White.
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>AP0_PRI</code>          </td><td style="text-align: left;"> ACES Scene-Referred Primaries, from SMPTE ST2065-1</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>AP1_PRI</code>          </td><td style="text-align: left;"> working space and rendering primaries for ACES 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>REC709_PRI</code>       </td><td style="text-align: left;"> Rec.709  (aka BT.709) primaries</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>REC2020_PRI</code>      </td><td style="text-align: left;"> Rec.2020  (aka BT.2020) primaries</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>P3D65_PRI</code>        </td><td style="text-align: left;"> RGB primaries from DCI-P3, with D65 for the whitepoint </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>P3D60_PRI</code>        </td><td style="text-align: left;"> RGB primaries from DCI-P3, with ACES whitepoint (approximately D60)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>P3DCI_PRI</code>        </td><td style="text-align: left;"> RGB primaries from DCI-P3, with DCI whitepoint</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Details</h3>

<p>All of these are built-in 4x2 matrices, with xy coordinates in the rows,
and in RGBW order.
</p>


<h3>References</h3>

<p>ST 2065-1:2012.
SMPTE Standard - Academy Color Encoding Specification (ACES).
2013.
</p>
<p>SMPTE Standard RP 431-2.
D-Cinema Quality - Reference Projector and Environment for the Display of DCDM in Review Rooms and Theaters.
2011.
</p>
<p>Wikipedia. <b>DCI-P3</b>.
<a href="https://en.wikipedia.org/wiki/DCI-P3">https://en.wikipedia.org/wiki/DCI-P3</a>.
</p>
<p>BT.709.
Parameter values for the HDTV standards for production and international programme exchange.
June 2015.
</p>
<p>BT.2020.
Parameter values for ultra-high definition television systems for production and international programme exchange.
October 2015.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>AP0_PRI
##          x        y
##  R 0.73470  0.26530
##  G 0.00000  1.00000
##  B 0.00010 -0.07700
##  W 0.32168  0.33767
</code></pre>

<hr>
<h2 id='transfer'>Apply TransferFunction to a Vector or an Array</h2><span id='topic+transfer'></span><span id='topic+transfer.TransferFunction'></span>

<h3>Description</h3>

<p>The function <code>transfer()</code> applies the given <code>TransferFunction</code> to the
given vector or array <code>x</code> and returns a numeric object of the same dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TransferFunction'
transfer( TF, x, domaincheck=TRUE )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transfer_+3A_tf">TF</code></td>
<td>
<p>a <code>TransferFunction</code> object, with dimension N</p>
</td></tr>
<tr><td><code id="transfer_+3A_x">x</code></td>
<td>
<p>a numeric vector or array.
If N<code class="reqn">\ge</code>2 then <code>x</code> must be an MxN matrix, or a vector that can be converted to such
a matrix, by row.
</p>
</td></tr>
<tr><td><code id="transfer_+3A_domaincheck">domaincheck</code></td>
<td>
<p>check whether numbers or rows of <code>x</code> are in the domain box of <code>TF</code> before application</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Let N := <code>dimension(TF)</code>.
<br />
If N=1 then <code>x</code> can have any length or dimension;
the function is applied to each number in <code>x</code> in a vectorized way,
and the returned object is then assigned the same dimensions as <code>x</code>.  
If <code>x</code> is a matrix then the returned object is assigned the same <code>rownames</code>.
If a number is <code>NA</code> then the returned number is also <code>NA</code>.
<br />
If N<code class="reqn">\ge</code>2 and <code>x</code> is an MxN matrix,
then the function is applied to each row of <code>x</code> individually and the returned object
is a matrix with the same dimensions and <code>rownames</code> as <code>x</code>.
If any number in a row is <code>NA</code> then the returned row is all <code>NA</code>s.
<br />
If <code>TF</code> is a universal identity (e.g. <code>identity.TF</code>), the function returns <code>x</code>
with no checking.
<br />
In case of a global error (e.g. dimension mismatch) the function returns <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TransferFunction">TransferFunction</a></code>,
<code><a href="#topic+identity.TF">identity.TF</a></code>
</p>

<hr>
<h2 id='TransferFunction'>Constructing and Testing TransferFunction Objects</h2><span id='topic+TransferFunction'></span><span id='topic+is.TransferFunction'></span><span id='topic+as.TransferFunction'></span><span id='topic+as.TransferFunction.default'></span>

<h3>Description</h3>

<p>The function <code>TransferFunction()</code> is the constructor for <b>TransferFunction</b> objects.
</p>
<p><code>is.TransferFunction()</code> tests whether an object is a valid <b>TransferFunction</b> object.<br />
<code>as.TransferFunction()</code> converts other variables to a <b>TransferFunction</b> object,
and is designed to be overridden by other packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TransferFunction( fun, funinv, domain, range, id=NULL )

is.TransferFunction(x)

## Default S3 method:
as.TransferFunction( ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TransferFunction_+3A_fun">fun</code></td>
<td>
<p>a function that accepts a numeric argument, and returns one of the same length.
The dimension of <code>fun</code> is determined by the arguments <code>domain</code> and <code>range</code>.
The function must be <em>injective</em> and this is checked if the function is univariate.  
The requirements for univariate and multivariate functions are very different, see <b>Details</b>.  </p>
</td></tr>
<tr><td><code id="TransferFunction_+3A_funinv">funinv</code></td>
<td>
<p>a function that the inverse for <code>fun</code>.
If <code>fun</code> is univariate and <code>funinv=NULL</code>, then an approximation for the inverse is computed
using <code>stats::splinefun()</code>.
If <code>fun</code> is multivariate and <code>funinv=NULL</code>, then it is an ERROR. </p>
</td></tr>
<tr><td><code id="TransferFunction_+3A_domain">domain</code></td>
<td>

<p>a 2xN matrix, or a numeric vector that can be converted to such a matrix, by column.
In each column, the entry in row 1 must be strictly less than the entry in row 2.  
The columns of <code>domain</code> define N intervals whose product is a box in <code class="reqn">R^N</code>
that is the domain of <code>fun</code>.
The box must be finite.
If N=1 then the box is just an interval, and <code>fun</code> is univariate.
Otherwise, <code>fun</code> is multivariate with dimension N.
</p>
</td></tr>
<tr><td><code id="TransferFunction_+3A_range">range</code></td>
<td>

<p>a 2xN matrix, or a numeric vector that can be converted to such a matrix, by column.
The N here must be equal to the N for <code>domain</code>.
The matrix defines a box that encloses the image of <code>domain</code> under <code>fun</code>.
The box must be finite.
</p>
</td></tr>
<tr><td><code id="TransferFunction_+3A_id">id</code></td>
<td>

<p>a character string that is helpful when printing the object, and in logging messages.
If <code>id=NULL</code> then an appropriate string is created from the function call.
</p>
</td></tr>
<tr><td><code id="TransferFunction_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object to test for being a valid <b>TransferFunction</b> object.</p>
</td></tr>
<tr><td><code id="TransferFunction_+3A_...">...</code></td>
<td>
<p>arguments for use in other packages.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>If <code>fun</code> is univariate, then it must be able to accept a numeric vector of any length,
and apply the function to each number in the vector; i.e. <code>fun</code> must be vectorized.
If a number in the vector is NA, then the function must silently return NA for that number;
usually this is not a problem.
The function is *not* required to test whether the number is in the <code>domain</code> interval;
this is handled by the <code>TransferFunction</code> code.
<br />
If <code>fun</code> is multivariate with dimension N, then it must be able to accept a vector
of length N and return a vector of length N.
It is *not* required to accept an MxN matrix.
It is *not* required to test whether the vector is in the domain box.
<br />
The function <code>funinv</code> has the same requirements as <code>fun</code>.
</p>


<h3>Value</h3>

<p><code>TransferFunction()</code> returns a <b>TransferFunction</b> object, or <code>NULL</code> in case of ERROR.
</p>
<p><code>is.TransferFunction()</code> returns <code>TRUE</code> or <code>FALSE</code>.
It only checks the <code>class</code>, using <code>base::inherits()</code>.
</p>
<p><code>as.TransferFunction.default()</code> issues an ERROR message and returns <code>NULL</code>..
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dimension">dimension</a>()</code>,
<code><a href="#topic+composition">composition</a>()</code>,
<code><a href="#topic+is.invertible">is.invertible</a>()</code>,  
<code><a href="#topic+metadata">metadata</a>()</code>,
<code><a href="#topic+inverse">inverse</a>()</code>,
<code><a href="#topic+transfer">transfer</a>()</code>,
<code><a href="#topic+orientation">orientation</a>()</code>,
<code><a href="#topic+validate">validate</a>()</code>,  
<code><a href="#topic+print.TransferFunction">print.TransferFunction</a>()</code>,
<code><a href="#topic+plot.TransferFunction">plot.TransferFunction</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  make a test TransferFunction

myfun = function(x) {x*x}

test  = TransferFunction( myfun, sqrt, domain=c(0,3), range=c(0,9), id='test.TF' )

#  print it
test
#--------------------   test.TF    ---------------------#
## test.TF is a univariate TransferFunction.
## domain:      [0,3]  (x)
## range:       [0,9]  (y)
## invertible:  Yes
## orientation: preserving
## range-test points = 1300, max(distance)=0.
## validation:  Passed

# and now plot it
plot( test )
</code></pre>

<hr>
<h2 id='validate'>Validate a TransferFunction by applying some simple Tests</h2><span id='topic+validate'></span><span id='topic+validate.TransferFunction'></span>

<h3>Description</h3>

<p>Each <code>TransferFunction</code> object is actually a list of so-called <em>elementary</em> transfer functions;
for details on this see <code><a href="#topic+composition">composition</a>()</code>.
This <code>validate()</code> applies an internal <code>validate()</code> function to each elementary function
individually.
The internal <code>validate()</code> function generates some points in the domain of the function
and checks that all points are transfered into the range of the function.
If the function is also invertible, it checks that the inverse transfers back to the original point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TransferFunction'
validate( TF, points=1300, tol=5.e-7, domain=NULL )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_+3A_tf">TF</code></td>
<td>
<p>a <code>TransferFunction</code> object with dimension N, and consisting of M elementary transfer functions</p>
</td></tr>
<tr><td><code id="validate_+3A_points">points</code></td>
<td>
<p>the number of points to test, in each elementary function</p>
</td></tr>
<tr><td><code id="validate_+3A_tol">tol</code></td>
<td>
<p>the numerical tolerance for the inversion test - this is relative to the length of the corresponding side of the domain box</p>
</td></tr>
<tr><td><code id="validate_+3A_domain">domain</code></td>
<td>
<p>a 2xN matrix to use as an alternate domain, for the first elementary function in the list only.
<code>domain</code> can also be a vector of length 2, which is then replicated to a 2xN matrix.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a logical vector of length M.
The value of the i'th element is the validation status of the i'th elementary function.
The returned vector has the attribute <code>'message'</code> which is a list of length M
with explanatory text.
For nicely formatted text see <code><a href="#topic+print">print</a>()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TransferFunction">TransferFunction</a></code>,
<code><a href="#topic+identity.TF">identity.TF</a></code>,
<code><a href="#topic+composition">composition</a>()</code>,
<code><a href="#topic+print.TransferFunction">print.TransferFunction</a>()</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
