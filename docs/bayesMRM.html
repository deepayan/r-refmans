<!DOCTYPE html><html lang="en"><head><title>Help for package bayesMRM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bayesMRM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bayesMRMApp'><p>Shiny App for exploring the results of Bayesian multivariate receptor modeling</p></a></li>
<li><a href='#bmrm'><p>Bayesian Analysis of Multivariate Receptor Modeling</p></a></li>
<li><a href='#convdiag_bmrm'><p>Convergence Diagnostics on MCMC samples in <code>bmrm</code></p></a></li>
<li><a href='#Elpaso'>
<p>PM2.5 speciation data from El Paso, Texas, USA.</p></a></li>
<li><a href='#idcond_check'><p>Check the identifiability conditions</p></a></li>
<li><a href='#pcplot'><p>Principal component plot</p></a></li>
<li><a href='#plot.bmrm'><p>Produce plots of the parameter estimates</p></a></li>
<li><a href='#summary.bmrm'><p>Summarize the output of the <code>bmrm</code> function</p></a></li>
<li><a href='#trace_ACF_plot'><p>Trace and/or ACF plots of elements of a variable</p>
in <code>bmrm</code> object</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Multivariate Receptor Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>2.4.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Man-Suk Oh &lt;msoh@ewha.ac.kr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Bayesian analysis of multivariate receptor modeling. The package consists of implementations of the methods of Park and Oh (2015) &lt;<a href="https://doi.org/10.1016%2Fj.chemolab.2015.08.021">doi:10.1016/j.chemolab.2015.08.021</a>&gt;.The package uses 'JAGS'(Just Another Gibbs Sampler) to generate Markov chain Monte Carlo samples of parameters. </td>
</tr>
<tr>
<td>Date:</td>
<td>2022-12-14</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>rjags,coda,ggplot2,grDevices,graphics,gridExtra,rgl,shiny,shinythemes</td>
</tr>
<tr>
<td>Suggests:</td>
<td>stats</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-14 02:05:48 UTC; EKLee</td>
</tr>
<tr>
<td>Author:</td>
<td>Man-Suk Oh [aut, cre],
  Eun-Kyung Lee [aut],
  Eun Sug Park [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-14 07:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='bayesMRMApp'>Shiny App for exploring the results of Bayesian multivariate receptor modeling</h2><span id='topic+bayesMRMApp'></span>

<h3>Description</h3>

<p>Call Shiny to show the results of Bayesian analysis of
multivariate receptor modeling in a web-based application.
This object contains
</p>

<ul>
<li><p> plots of the posterior means and 95% posterior intervals of parameters in
an object of class <code>bmrm</code>.
</p>
</li>
<li><p> tables of the posterior means of parameters in
an object of class <code>bmrm</code>.
</p>
</li>
<li><p> tables of the posterior quantiles of parameters in
an object of class <code>bmrm</code>, for prob=(0.025, 0.05, 0.25, 0.5, 0.75, 0.95, 0.975).
</p>
</li>
<li><p>  tables of convergence diagnostics of parameters in
an object of class <code>bmrm</code>.
</p>
</li>
<li><p> 3-dimensional dynamic principal component plots of data (Y) and
source profiles (rows of the estimated source composition matrix P)
in an object of class <code>bmrm</code>. The plot can be rotated by moving the cursor.
</p>
</li>
<li><p> trace plots and ACF plots of the first 6 elements of a parameter in an
object of class <code>bmrm</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>bayesMRMApp(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bayesMRMApp_+3A_x">x</code></td>
<td>
<p>an object of class <code>bmrm</code>, the output of the <code>bmrm</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>shiny App
</p>

<hr>
<h2 id='bmrm'>Bayesian Analysis of Multivariate Receptor Modeling</h2><span id='topic+bmrm'></span>

<h3>Description</h3>

<p>Generate posterior samples of the source
composition matrix  P, the source contribution matrix A,
and the error variance <code class="reqn">\Sigma</code> using 'JAGS', and computes
estimates of A,P,<code class="reqn">\Sigma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmrm(Y, q, muP,errdist="norm", df=4,
            varP.free=100, xi=NULL, Omega=NULL,
              a0=0.01, b0=0.01,
             nAdapt=1000, nBurnIn=5000, nIter=5000, nThin=1,
             P.init=NULL, A.init=NULL, Sigma.init=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bmrm_+3A_y">Y</code></td>
<td>
<p>data matrix</p>
</td></tr>
<tr><td><code id="bmrm_+3A_q">q</code></td>
<td>
<p>number of sources. It must be a positive integer.</p>
</td></tr>
<tr><td><code id="bmrm_+3A_mup">muP</code></td>
<td>
<p>(q,ncol(Y))-dimensional prior mean matrix for the source
composition matrix P, where q is the number of sources.
Zeros need to be assigned to prespecified elements of muP to satisfy
the identifiability condition C1. For the remaining free elements,
any nonnegative numbers (between 0 and 1 preferably) can be assigned.
If no or an insufficient number of zeros are preassigned in muP,
estimation can still be performed but the resulting estimates may
be subject to rotational ambiguities. (default=0.5 for nonzero elements ).</p>
</td></tr>
<tr><td><code id="bmrm_+3A_errdist">errdist</code></td>
<td>
<p>error distribution: either &quot;norm&quot; for normal distribution or &quot;t&quot;
for t distribution (default=&quot;norm&quot;)</p>
</td></tr>
<tr><td><code id="bmrm_+3A_df">df</code></td>
<td>
<p>degrees of freedom of a t-distribution when errdist=&quot;t&quot; (default=4)</p>
</td></tr>
<tr><td><code id="bmrm_+3A_varp.free">varP.free</code></td>
<td>
<p>scalar value of the prior variance of the free (nonzero) elements
of the source composition matrix P (default=100)</p>
</td></tr>
<tr><td><code id="bmrm_+3A_xi">xi</code></td>
<td>
<p>prior mean vector of the q-dimensional source contribution
vector at time t  (default=vector of 1's)</p>
</td></tr>
<tr><td><code id="bmrm_+3A_omega">Omega</code></td>
<td>
<p>diagonal matrix of the prior variance of the q-dimensional
source contribution vector at time t (default=identity matrix)</p>
</td></tr>
<tr><td><code id="bmrm_+3A_a0">a0</code></td>
<td>
<p>shape parameter of the Inverse Gamma prior of the error variance
(default=0.01)</p>
</td></tr>
<tr><td><code id="bmrm_+3A_b0">b0</code></td>
<td>
<p>scale parameter of the Inverse Gamma prior of the error variance
(default=0.01)</p>
</td></tr>
<tr><td><code id="bmrm_+3A_nadapt">nAdapt</code></td>
<td>
<p>number of iterations for adaptation in 'JAGS' (default=1000)</p>
</td></tr>
<tr><td><code id="bmrm_+3A_nburnin">nBurnIn</code></td>
<td>
<p>number of iterations for the burn-in period in MCMC (default=5000)</p>
</td></tr>
<tr><td><code id="bmrm_+3A_niter">nIter</code></td>
<td>
<p>number of iterations for monitoring samples from MCMC
(default=5000). <code>nIter</code> samples are saved in each chain of MCMC.</p>
</td></tr>
<tr><td><code id="bmrm_+3A_nthin">nThin</code></td>
<td>
<p>thinning interval for monitoring samples from MCMC (default=1)</p>
</td></tr>
<tr><td><code id="bmrm_+3A_p.init">P.init</code></td>
<td>
<p>initial value of the source composition matrix P.
If omitted, zeros are assigned to the elements corresponding to
zero elements in muP  and the nonzero elements of P.init will be
randomly generated from a uniform distrbution.</p>
</td></tr>
<tr><td><code id="bmrm_+3A_a.init">A.init</code></td>
<td>
<p>initial value of the source contribution matrix A.
If omitted, it will be calculated from Y and P.init.</p>
</td></tr>
<tr><td><code id="bmrm_+3A_sigma.init">Sigma.init</code></td>
<td>
<p>initial value of the error variance.
If omitted, it will be calculated from Y, A.init and P.init.</p>
</td></tr>
<tr><td><code id="bmrm_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Model</em>
</p>
<p>The basic model for Bayesian multivariate receptor model is
as follows:
</p>
<p><code class="reqn">Y_t=A_t P+E_t, t=1,\cdots,T</code>,
</p>
<p>where
</p>

<ul>
<li> <p><code class="reqn">Y_t</code> is a vector of observations of <code class="reqn">J</code> variables at time
<code class="reqn">t</code>, <code class="reqn">t = 1,\cdots,T</code>.
</p>
</li>
<li> <p><code class="reqn">P</code> is a <code class="reqn">q \times J</code>  source composition
matrix in which the <code class="reqn">k</code>-th row represents the <code class="reqn">k</code>-th source
composition profiles, <code class="reqn">k=1,\cdots,q</code>, <code class="reqn">q</code> is the number of sources.
</p>
</li>
<li> <p><code class="reqn">A_t</code> is a <code class="reqn">q</code> dimensional source contribution vector at time <code class="reqn">t</code>,
<code class="reqn">t=1,\cdots,T</code>.
</p>
</li>
<li> <p><code class="reqn">E_t =(E_{t1}, \cdots, E_{tJ})</code> is an error term
for the <code class="reqn">t</code>-th observations,
following <code class="reqn">E_{t} \sim N(0, \Sigma)</code> or <code class="reqn">E_{t} \sim t_{df}(0, \Sigma)</code>,
independently for <code class="reqn">j = 1,\cdots,J</code>, where <code class="reqn">\Sigma = diag(\sigma_{1}^2,...,
     \sigma_{J}^2)</code>.
</p>
</li></ul>

<p><em>Priors</em>
</p>

<ul>
<li><p> Prior distribution of <code class="reqn">A_t</code> is given as
a truncated multivariate normal distribution,
</p>

<ul>
<li> <p><code class="reqn"> A_t \sim N(\xi,\Omega) I(A_t \ge 0)</code>, independently for
<code class="reqn">t = 1,\cdots,T</code>.
</p>
</li></ul>

</li>
<li><p> Prior distribution of <code class="reqn">P_{kj}</code> (the <code class="reqn">(k,j)</code>-th element  of the source
composition matrix <code class="reqn">P</code>) is given as
</p>

<ul>
<li>
<p><code class="reqn"> P_{kj} \sim N(\code{muP}_{kj} , \code{varP.free} )I(P_{kj}
      \ge 0)</code>, for free (nonzero) <code class="reqn">P_{kj}</code>,
</p>
</li>
<li>
<p><code class="reqn"> P_{kj} \sim N(0, 1e-10 )I(P_{kj} \ge 0)</code>, for zero <code class="reqn">P_{kj}</code>,
</p>
<p>independently for  <code class="reqn">k = 1,\cdots,q; j = 1,\cdots,J </code>.
</p>
</li></ul>

</li>
<li><p> Prior distribution of <code class="reqn">\sigma_j^2</code> is <code class="reqn">IG(a0, b0)</code>, i.e.,
</p>

<ul>
<li> <p><code class="reqn">1/\sigma_j^2 \sim Gamma(a0, b0)</code>, having mean <code class="reqn">a0/b0</code>,
independently for <code class="reqn">j=1,...,J</code>.
</p>
</li></ul>

</li></ul>

<p><em>Notes</em>
</p>

<ul>
<li>
<p>We use the prior
<code class="reqn"> P_{kj} \sim N(0, 1e-10 )I(P_{kj} \ge 0)</code>  that is practically equal
to the point mass at 0 to simplify the model building in 'JAGS'.
</p>
</li>
<li><p>  The MCMC samples of A and P are post-processed (rescaled) before saving
so that <code class="reqn"> \sum_{j=1}^J P_{kj} =1</code> for each <code class="reqn">k=1,...,q</code> (the identifiablity
condition C3 of Park and Oh (2015).
</p>
</li></ul>



<h3>Value</h3>

<p>in <code>bmrm</code> object
</p>

<dl>
<dt>nsource</dt><dd><p>number of sources</p>
</dd>
<dt>nobs</dt><dd><p>number of observations in data Y</p>
</dd>
<dt>nvar</dt><dd><p>number of variables in data Y</p>
</dd>
<dt>Y</dt><dd><p>observed data matrix</p>
</dd>
<dt>muP</dt><dd><p>prior mean of the source composition matrix P</p>
</dd>
<dt>errdist</dt><dd><p>error distribution</p>
</dd>
<dt>df</dt><dd><p>degrees of freedom when errdist=&quot;t&quot;</p>
</dd>
<dt>A.hat</dt><dd><p>posterior mean of the source contribution matrix A</p>
</dd>
<dt>P.hat</dt><dd><p>posterior mean of the source composition matrix P</p>
</dd>
<dt>Sigma.hat</dt><dd><p>posterior mean of the error variance Sigma</p>
</dd>
<dt>A.sd</dt><dd><p>posterior standard deviation of the source contribution matrix A</p>
</dd>
<dt>P.sd</dt><dd><p>posterior standard deviation of the source composition matrix P</p>
</dd>
<dt>Sigma.sd</dt><dd><p>posterior standard deviation of the error variance Sigma</p>
</dd>
<dt>A.quantiles</dt><dd><p>posterior quantlies of A for prob=(0.025, 0.05,
0.25, 0.5, 0.75, 0.95, 0.975)</p>
</dd>
<dt>P.quantiles</dt><dd><p>posterior quantiles of P for prob=(0.025, 0.05,
0.25, 0.5, 0.75, 0.95, 0.975)</p>
</dd>
<dt>Sigma.quantiles</dt><dd><p>posterior quantiles of Sigma for prob=(0.025, 0.05,
0.25, 0.5, 0.75, 0.95, 0.975)</p>
</dd>
<dt>Y.hat</dt><dd><p>predicted value of Y computed from A.hat*P.hat</p>
</dd>
<dt>residual</dt><dd><p>Y-Y.hat</p>
</dd>
<dt>codaSamples</dt><dd><p>MCMC posterior samples of A, P, and <code class="reqn">\Sigma</code> in class &quot;mcmc.list&quot;</p>
</dd>
<dt>nIter</dt><dd><p>number of MCMC iterations per chain for monitoring samples from
MCMC</p>
</dd>
<dt>nBurnIn</dt><dd><p>number of iterations for the burn-in period in MCMC</p>
</dd>
<dt>nThin</dt><dd><p>thinning interval for monitoring samples from MCMC</p>
</dd>
</dl>



<h3>References</h3>

<p>Park, E.S. and Oh, M-S. (2015), Robust Bayesian Multivariate
Receptor Modeling, Chemometrics and intelligent laboratory systems,
149, 215-226.
</p>
<p>Plummer, M. 2003. JAGS: A program for analysis of Bayesian
graphical models using Gibbs sampling. Proceedings of the 3rd
international workshop on distributed statistical computing, pp. 125.
Technische Universit at Wien, Wien, Austria.
</p>
<p>Plummer, M. 2015. 'JAGS' Version 4.0.0 user manual.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Elpaso); Y=Elpaso$Y ; muP=Elpaso$muP ; q=nrow(muP)
out.Elpaso &lt;- bmrm(Y,q,muP)
summary(out.Elpaso)
plot(out.Elpaso)

</code></pre>

<hr>
<h2 id='convdiag_bmrm'>Convergence Diagnostics on MCMC samples in <code>bmrm</code></h2><span id='topic+convdiag_bmrm'></span>

<h3>Description</h3>

<p>Compute convergence diagnostics of
Geweke (1992), Heidelberger and Welch (1983), Raftery and Lewis(1992).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convdiag_bmrm(x , var="P", convdiag="geweke",print=TRUE,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convdiag_bmrm_+3A_x">x</code></td>
<td>
<p>an object of class <code>bmrm</code>, the output of the <code>bmrm</code> function</p>
</td></tr>
<tr><td><code id="convdiag_bmrm_+3A_var">var</code></td>
<td>
<p>name of a variable to which convergence disagnostics apply. It should be one of &quot;A&quot; (source contribution matrix),
&quot;P&quot; (source composition or profile matrix), &quot;Sigma&quot; (error variance).</p>
</td></tr>
<tr><td><code id="convdiag_bmrm_+3A_convdiag">convdiag</code></td>
<td>
<p>vector of convergence diagnostic methods. It should be any subvector
of (&quot;geweke&quot;, &quot;heidel&quot;,&quot;raftery&quot; ) (default=&quot;geweke&quot;).</p>
</td></tr>
<tr><td><code id="convdiag_bmrm_+3A_print">print</code></td>
<td>
<p>TRUE/FALSE, print convergence diagnostics results (default=TRUE)</p>
</td></tr>
<tr><td><code id="convdiag_bmrm_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Geweke's convergence diagnostic for Markov chains is based on
a test for equality of the means of the first and last part of a Markov chain
(by default the first 10% and the last 50%).
If the samples are drawn from the stationary distribution of the chain,
the two means should be equal and Geweke's statistic has an asymptotically
standard normal distribution. We use the function <code>geweke.diag</code> in <b>coda</b>
package (with default option) which provides the test statistics
(standard Z-scores) and the upper bound of
and p-values.
</p>
<p>Heidelberger and Welch's  convergence diagnostic tests the
null hypothesis that the sampled values come from a stationary distribution.
The test is successively applied, firstly to the whole chain, then after
discarding the first 10%, 20%, ... of the chain until either
the null hypothesis is accepted, or 50% of the chain has been discarded.
We use the function  <code>heidel.diag</code> (with default option)
which provides the staionary test results and p-values.
</p>
<p>Raftery and Lewis's diagnostic estimates the minimum number of iterations, burn-in,
thinning interval for zero autocorrelation, satisfying specified conditions
regarding quantile <code class="reqn">q</code> of parameters of interest. The conditions are
specified by a posterior quantile <code class="reqn">q</code> of parameters, an acceptable
tolerance (accuracy) <code class="reqn">r</code> for <code class="reqn">q</code>, a probability <code class="reqn">s</code> of being
within the interval <code class="reqn">q-r, q+r</code>.
We use the function  <code>raftery.diag</code> (with default option).
</p>


<h3>Value</h3>

<p>A list of  convergence diagnostics results
</p>

<dl>
<dt>convdiag</dt><dd><p>selected convergence diagnostic methods</p>
</dd>
<dt>geweke</dt><dd><p>Geweke's z-scores and p-values if <code>convdiag</code>
includes &quot;geweke&quot;, NULL if <code>convdiag</code> does not include &quot;geweke&quot;</p>
</dd>
<dt>heidel</dt><dd><p>Heidelberger and Welch's stationary test results
and p-values if <code>convdiag</code> includes &quot;heidel&quot;; NULL if
<code>convdiag</code> does not include &quot;heidel&quot;</p>
</dd>
<dt>raftery</dt><dd><p>Raftery and Lewis's estimates of burn-in, minimum number of iterations,
and thinning if <code>convdiag</code> includes &quot;raftery&quot;; NULL if
<code>convdiag</code> does not include &quot;raftery&quot;</p>
</dd>
</dl>



<h3>References</h3>

<p>Geweke, J.(1992) Evaluating the accuracy of sampling-based
approaches to calculating posterior moments. In Bayesian Statistics 4
(ed JM Bernado, JO Berger, AP Dawid and AFM Smith). Clarendon Press.
</p>
<p>Heidelberger P, and Welch PD. (1981) A spectral method for
confidence interval generation and run length control in simulations.
Comm. ACM. 24, 233-245.
</p>
<p>Heidelberger P. and Welch PD.(1983) Simulation run length
control in the presence of an initial transient.
Opns Res., 31, 1109-44,Oxford, UK.
</p>
<p>Plummer, M., Best, N., Cowles, K. and Vines K. (2006) CODA:
Convergence Diagnosis and Output Analysis for MCMC, R News, Vol 6, pp. 7-11.
</p>
<p>Raftery, A.E. and Lewis, S.M. (1992). One long run with diagnostics:
Implementation strategies for Markov chain Monte Carlo. Statistical Science, 7, 493-497.
</p>
<p>Raftery, A.E. and Lewis, S.M. (1995). The number of iterations,
convergence diagnostics and generic Metropolis algorithms. In Practical Markov Chain Monte
Carlo (W.R. Gilks, D.J. Spiegelhalter and S. Richardson, eds.). London, U.K.: Chapman and Hall.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Elpaso)
Y=Elpaso$Y ; muP=Elpaso$muP
q=nrow(muP)
out.Elpaso &lt;- bmrm(Y,q,muP, nAdapt=1000,nBurnIn=5000,nIter=5000,nThin=1)
conv1&lt;-convdiag_bmrm(out.Elpaso,var="P",convdiag="raftery" )
conv2&lt;-convdiag_bmrm(out.Elpaso,var="A", convdiag="geweke")
conv3&lt;-convdiag_bmrm(out.Elpaso,var="Sigma", convdiag=c("geweke","heidel"))
conv4&lt;-convdiag_bmrm(out.Elpaso,var="Sigma", convdiag=c("geweke","heidel", "raftery"))

</code></pre>

<hr>
<h2 id='Elpaso'>
PM2.5 speciation data from El Paso, Texas, USA.
</h2><span id='topic+Elpaso'></span>

<h3>Description</h3>

<p>The data frame has the following components:
</p>

<ul>
<li> <p><em>Y</em> 224 by 15 matrix of 224 observations on 15 PM2.5 species.
PM 2.5 was measured every three days during the time period of
1/2/2006 ~ 4/7/2009 from the Chamizal station in the city of El Paso, USA.
Out of the 58 original PM 2.5 species, 15 species were selected. After removing
any observations with missig values, the final data consists of 224 complete
observatins on the following 15 PM2.5 species:
</p>

<dl>
<dt>Al</dt><dd><p>Aluminum</p>
</dd>
<dt>Ca</dt><dd><p>Calcium</p>
</dd>
<dt>Cl2</dt><dd><p>Chlorine</p>
</dd>
<dt>EC</dt><dd><p>EC CSN</p>
</dd>
<dt>Fe</dt><dd><p>Iron</p>
</dd>
<dt>K_p</dt><dd><p>Potassium ion</p>
</dd>
<dt>Mg</dt><dd><p>Magnanese</p>
</dd>
<dt>NV_NO3</dt><dd><p>Non-volatile nitrate</p>
</dd>
<dt>NH4_p</dt><dd><p>Ammonium ion</p>
</dd>
<dt>Na</dt><dd><p>Sodium</p>
</dd>
<dt>OC</dt><dd><p>OC CSN unadjusted</p>
</dd>
<dt>SO4</dt><dd><p>Sulfate</p>
</dd>
<dt>Si</dt><dd><p>Silicon</p>
</dd>
<dt>Ti</dt><dd><p>Titanium</p>
</dd>
<dt>Zn</dt><dd><p>Zinc</p>
</dd>
</dl>

</li>
<li> <p><em>muP</em>  4 by 15 matrix of the prior mean of the source composition matrix P for data.  Zero values  are assigned for some elements of muP to satisfy the
identifiability conditions C1-C2 in Park and Oh (2015). The remaining nonzero elements of muP have value 0.5. Note that the number of sources (the number of rows in muP) is presumed to be 4 here.
</p>
</li></ul>



<h3>References</h3>

<p>Park, E.S. and Oh, M-S. (2016), Bayesian Quantile Multivariate
Receptor Modeling, Chemometrics and intelligent laboratory systems,
159, 174-180.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Elpaso)
Y=Elpaso$Y
muP=Elpaso$muP
</code></pre>

<hr>
<h2 id='idcond_check'>Check the identifiability conditions</h2><span id='topic+idcond_check'></span><span id='topic+idCond_check'></span>

<h3>Description</h3>

<p>Check the identifiability conditions C1-C2 of Park and Oh (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idCond_check(P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idcond_check_+3A_p">P</code></td>
<td>
<p>source composition matrix in multivariate receptor model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>idCond TRUE if all the conditions are satisfied, FALSE otherwise
</p>

<hr>
<h2 id='pcplot'>Principal component plot</h2><span id='topic+pcplot'></span>

<h3>Description</h3>

<p>Draw principal component plots of data (Y) and
source profiles (rows) of the estimated source composition matrix P.hat
(and P0 if there is another source composition matrix P0 to compare, e.g.,
P0 could be the true P in simulation or P0 could be another estimate of P)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcplot(x, P0, G3D=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcplot_+3A_x">x</code></td>
<td>
<p>an object of class <code>bmrm</code>, the output from the function <code>bmrm</code></p>
</td></tr>
<tr><td><code id="pcplot_+3A_p0">P0</code></td>
<td>
<p>estimated value of P (in simulation it can be the true value of P)</p>
</td></tr>
<tr><td><code id="pcplot_+3A_g3d">G3D</code></td>
<td>
<p>TRUE/FALSE, dynamic 3D plot (default=FALSE)</p>
</td></tr>
<tr><td><code id="pcplot_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Elpaso)
Y=Elpaso$Y ; muP=Elpaso$muP
q=nrow(muP)
out.Elpaso &lt;- bmrm(Y,q,muP, nAdapt=1000,nBurnIn=5000,nIter=5000,nThin=1)
pcplot(out.Elpaso)
pcplot(out.Elpaso,G3D=TRUE)

</code></pre>

<hr>
<h2 id='plot.bmrm'>Produce plots of the parameter estimates</h2><span id='topic+plot.bmrm'></span><span id='topic+plot'></span>

<h3>Description</h3>

<p>Produce plots of the estimated
posterior mean and 95% posterior intervals of A,P, Sigma
based on the MCMC samples in <code>bmrm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bmrm'
plot(x, type = "both", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.bmrm_+3A_x">x</code></td>
<td>
<p>an object of class <code>bmrm</code>, the output of the function <code>bmrm</code></p>
</td></tr>
<tr><td><code id="plot.bmrm_+3A_type">type</code></td>
<td>
<p>name of a variable (default=&quot;P&quot;).
It should be one of &quot;P&quot;(source composition or profile matrix P),
&quot;A&quot;(source contribution matrix A), &quot;both&quot; (both P and A), &quot;Sigma&quot; (error  variance).</p>
</td></tr>
<tr><td><code id="plot.bmrm_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following types of plots are drawn depending on the selected parameters:
</p>

<ul>
<li><p> P: bar plots of the posterior means with 95% posterior intervals of elements for each row of P
</p>
</li>
<li><p> A: time series plots of  posterior means with 95% posterior intervals elements for each column of A
</p>
</li>
<li><p> Sigma: posterior means with error bars for 95% posterior intervals of elements of Sigma
</p>
</li></ul>



<h3>Value</h3>

<p>plot
</p>

<hr>
<h2 id='summary.bmrm'>Summarize the output of the <code>bmrm</code> function</h2><span id='topic+summary.bmrm'></span><span id='topic+summary'></span>

<h3>Description</h3>

<p>An S3 method that summarizes the
output of the <code>bmrm</code> function in an object of class <code>bmrm</code>. This object
contains
the posterior mean, the posterior standard deviation, and
(0.025, 0.05,0.25, 0.5, 0.75,0.95, 0.975) posterior quantiles
of  A, P, <code class="reqn">\Sigma</code>. It also contains other
relevant information about the MCMC procedure such as the burn-in iterations,
the number of MCMC chains, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bmrm'
summary(object, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.bmrm_+3A_object">object</code></td>
<td>
<p>an object of class <code>bmrm</code>, the output of the <code>bmrm</code> function</p>
</td></tr>
<tr><td><code id="summary.bmrm_+3A_digits">digits</code></td>
<td>
<p>integer indicating the humber of signifiant digits</p>
</td></tr>
<tr><td><code id="summary.bmrm_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>summary of bmrm class (output of bmrm function)
</p>

<hr>
<h2 id='trace_ACF_plot'>Trace and/or ACF plots of elements of a variable
in <code>bmrm</code> object</h2><span id='topic+trace_ACF_plot'></span>

<h3>Description</h3>

<p>Produce trace and Auto-Correlation Function
plots (along with Effective sample size) of MCMC samples
of  elements of A, nonzero elements of P, elements of Sigma.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trace_ACF_plot(x,var="P", ACF=FALSE, nplot=0,irow=1, icol=1, saveFile=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trace_ACF_plot_+3A_x">x</code></td>
<td>
<p>an object of class <code>bmrm</code>, the output of the <code>bmrm</code> function</p>
</td></tr>
<tr><td><code id="trace_ACF_plot_+3A_var">var</code></td>
<td>
<p>name of a variable to which the plots apply.  It should be one of
&quot;A&quot; (source contribution matrix),
&quot;P&quot; (source composition matrix),
&quot;Sigma&quot; (error variance).</p>
</td></tr>
<tr><td><code id="trace_ACF_plot_+3A_acf">ACF</code></td>
<td>
<p>TRUE/FALSE  if TRUE ACF plots will be provided along with
effective sample sizes(dafault: FALSE)</p>
</td></tr>
<tr><td><code id="trace_ACF_plot_+3A_nplot">nplot</code></td>
<td>
<p>number of elements of 'var' for trace and/or ACF plots.
If 'nplot' is
smaller than the total number of elements of 'var' then plots of
'nplot' selected elements will be drawn. Otherwise, trace and/or ACF plots of  all
elements will be drawn.
(default=0  implies that all elements will be selected if var=&quot;P&quot; or &quot;Sigma&quot;,
and the first 12 elements will be selected  if  var=&quot;A&quot;)</p>
</td></tr>
<tr><td><code id="trace_ACF_plot_+3A_irow">irow</code></td>
<td>
<p>row index of A/P matrix or index of element of Sigma vector.
Plots of 'nplot' elements starting from (irow, icol) element of A/P or
elements starting from irow element of Sigma will be drawn (default=1).</p>
</td></tr>
<tr><td><code id="trace_ACF_plot_+3A_icol">icol</code></td>
<td>
<p>column number of  A/P matrix.  Plots of 'nplot' elements starting
from (irow, icol) element of A/P will be drawn (default=1).</p>
</td></tr>
<tr><td><code id="trace_ACF_plot_+3A_savefile">saveFile</code></td>
<td>
<p>TRUE/FALSE, save the plots in file
<em>'var'-trace.pdf</em> (default=FALSE)</p>
</td></tr>
<tr><td><code id="trace_ACF_plot_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Elpaso); Y=Elpaso$Y ; muP=Elpaso$muP ; q=nrow(muP)
out.Elpaso &lt;- bmrm(Y,q,muP, nAdapt=1000,nBurnIn=5000,nIter=5000,nThin=1)
trace_ACF_plot(out.Elpaso,"Sigma", ACF=TRUE)
trace_ACF_plot(out.Elpaso,"P", ACF=TRUE)
trace_ACF_plot(out.Elpaso,"A",ACF=TRUE, nplot=12, irow=2, icol=3)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
