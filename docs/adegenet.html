<!DOCTYPE html><html><head><title>Help for package adegenet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {adegenet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.internal_C_routines'><p>Internal C routines</p></a></li>
<li><a href='#a-score'><p>Compute and optimize a-score for Discriminant Analysis of Principal Components (DAPC)</p></a></li>
<li><a href='#Accessors'><p>Accessors for adegenet objects</p></a></li>
<li><a href='#Adegenet servers'><p> Web servers for adegenet</p></a></li>
<li><a href='#adegenet.package'><p>The adegenet package</p></a></li>
<li><a href='#adegenetWeb'><p>Functions to access online resources for adegenet</p></a></li>
<li><a href='#AIC.snapclust'><p>Compute Akaike Information Criterion (AIC) for snapclust</p></a></li>
<li><a href='#AICc'><p>Compute Akaike Information Criterion for small samples (AICc) for snapclust</p></a></li>
<li><a href='#as methods in adegenet'><p>Converting genind/genpop objects to other classes</p></a></li>
<li><a href='#as.genlight'><p>Conversion to class &quot;genlight&quot;</p></a></li>
<li><a href='#as.SNPbin'><p>Conversion to class &quot;SNPbin&quot;</p></a></li>
<li><a href='#Auxiliary functions'><p> Auxiliary functions for adegenet</p></a></li>
<li><a href='#BIC.snapclust'><p>Compute Bayesian Information Criterion (BIC) for snapclust</p></a></li>
<li><a href='#chooseCN'><p>Function to choose a connection network</p></a></li>
<li><a href='#colorplot'><p>Represents a cloud of points with colors</p></a></li>
<li><a href='#compoplot'><p>Genotype composition plot</p></a></li>
<li><a href='#coords.monmonier'><p>Returns original points in results paths of an object of class 'monmonier'</p></a></li>
<li><a href='#dapc'><p>Discriminant Analysis of Principal Components (DAPC)</p></a></li>
<li><a href='#DAPC cross-validation'><p>Cross-validation for Discriminant Analysis of Principal Components (DAPC)</p></a></li>
<li><a href='#dapc graphics'><p>Graphics for Discriminant Analysis of Principal Components (DAPC)</p></a></li>
<li><a href='#dapcIllus'><p>Simulated data illustrating the DAPC</p></a></li>
<li><a href='#df2genind'><p>Convert a data.frame of allele data to a genind object.</p></a></li>
<li><a href='#dist.genpop'><p> Genetic distances between populations</p></a></li>
<li><a href='#eHGDP'><p>Extended HGDP-CEPH dataset</p></a></li>
<li><a href='#export_to_mvmapper'><p>Export analysis for mvmapper visualisation</p></a></li>
<li><a href='#extract.PLINKmap'><p>Reading PLINK Single Nucleotide Polymorphism data</p></a></li>
<li><a href='#fasta2DNAbin'><p> Read large DNA alignments into R</p></a></li>
<li><a href='#fasta2genlight'><p> Extract Single Nucleotide Polymorphism (SNPs) from alignments</p></a></li>
<li><a href='#find.clusters'><p>find.cluster: cluster identification using successive K-means</p></a></li>
<li><a href='#findMutations'><p>Identify mutations between DNA sequences</p></a></li>
<li><a href='#gengraph'><p>Genetic transitive graphs</p></a></li>
<li><a href='#genind class'><p>adegenet formal class (S4) for individual genotypes</p></a></li>
<li><a href='#genind2df'><p>Convert a genind object to a data.frame.</p></a></li>
<li><a href='#genind2genpop'><p>Conversion from a genind to a genpop object</p></a></li>
<li><a href='#genlight auxiliary functions'><p>Auxiliary functions for genlight objects</p></a></li>
<li><a href='#genlight-class'><p>Formal class &quot;genlight&quot;</p></a></li>
<li><a href='#genpop class'><p>adegenet formal class (S4) for allele counts in populations</p></a></li>
<li><a href='#global.rtest'><p>Global and local tests</p></a></li>
<li><a href='#glPca'><p>Principal Component Analysis for genlight objects</p></a></li>
<li><a href='#glPlot'><p>Plotting genlight objects</p></a></li>
<li><a href='#glSim'><p>Simulation of simple genlight objects</p></a></li>
<li><a href='#H3N2'><p>Seasonal influenza (H3N2) HA segment data</p></a></li>
<li><a href='#haploGen'><p>Simulation of genealogies of haplotypes</p></a></li>
<li><a href='#hier'><p>Access and manipulate the population hierarchy for genind or genlight objects.</p></a></li>
<li><a href='#Hs'><p>Expected heterozygosity (Hs)</p></a></li>
<li><a href='#Hs.test'><p>Test differences in expected heterozygosity (Hs)</p></a></li>
<li><a href='#HWE.test.genind'><p>Hardy-Weinberg Equilibrium test for multilocus data</p></a></li>
<li><a href='#hybridize'><p>Function hybridize takes two genind in inputs</p>
and generates hybrids individuals having one parent
in both objects.</a></li>
<li><a href='#hybridtoy'><p>Toy hybrid dataset</p></a></li>
<li><a href='#import2genind'><p>Importing data from several softwares to a genind object</p></a></li>
<li><a href='#Inbreeding estimation'><p>Likelihood-based estimation of inbreeding</p></a></li>
<li><a href='#initialize,genind-method'><p>genind constructor</p></a></li>
<li><a href='#initialize,genpop-method'><p>genpop constructor</p></a></li>
<li><a href='#isPoly-methods'><p> Assess polymorphism in genind/genpop objects</p></a></li>
<li><a href='#KIC'><p>Compute Akaike Information Criterion for small samples (AICc) for snapclust</p></a></li>
<li><a href='#loadingplot'><p>Represents a cloud of points with colors</p></a></li>
<li><a href='#makefreq'><p>Compute allelic frequencies</p></a></li>
<li><a href='#microbov'><p>Microsatellites genotypes of 15 cattle breeds</p></a></li>
<li><a href='#minorAllele'><p>Compute minor allele frequency</p></a></li>
<li><a href='#monmonier'><p>Boundary detection using Monmonier algorithm</p></a></li>
<li><a href='#nancycats'><p>Microsatellites genotypes of 237 cats from 17 colonies of Nancy (France)</p></a></li>
<li><a href='#old2new_genind'><p>Convert objects with obsolete classes into new objects</p></a></li>
<li><a href='#pairDistPlot'><p>Pairwise distance plots</p></a></li>
<li><a href='#propShared'><p>Compute proportion of shared alleles</p></a></li>
<li><a href='#propTyped-methods'><p> Compute the proportion of typed elements</p></a></li>
<li><a href='#read.fstat'><p>Reading data from Fstat</p></a></li>
<li><a href='#read.genepop'><p>Reading data from Genepop</p></a></li>
<li><a href='#read.genetix'><p>Reading data from GENETIX</p></a></li>
<li><a href='#read.snp'><p>Reading Single Nucleotide Polymorphism data</p></a></li>
<li><a href='#read.structure'><p>Reading data from STRUCTURE</p></a></li>
<li><a href='#repool'><p>Pool several genotypes into a single dataset</p></a></li>
<li><a href='#rupica'><p>Microsatellites genotypes of 335 chamois (Rupicapra rupicapra) from the</p>
Bauges mountains (France)</a></li>
<li><a href='#scaleGen'><p>Compute scaled allele frequencies</p></a></li>
<li><a href='#selPopSize'><p> Select genotypes of well-represented populations</p></a></li>
<li><a href='#seploc'><p> Separate data per locus</p></a></li>
<li><a href='#seppop'><p> Separate genotypes per population</p></a></li>
<li><a href='#seqTrack'><p>SeqTrack algorithm for reconstructing genealogies</p></a></li>
<li><a href='#SequencesToGenind'><p> Importing data from an alignement of sequences to a genind object</p></a></li>
<li><a href='#setPop'><p>Manipulate the population factor of genind objects.</p></a></li>
<li><a href='#showmekittens'><p>When you need a break...</p></a></li>
<li><a href='#sim2pop'><p>Simulated genotypes of two georeferenced populations</p></a></li>
<li><a href='#snapclust'><p>Maximum-likelihood genetic clustering using EM algorithm</p></a></li>
<li><a href='#snapclust.choose.k'><p>Choose the number of clusters for snapclust using AIC, BIC or AICc</p></a></li>
<li><a href='#SNPbin-class'><p>Formal class &quot;SNPbin&quot;</p></a></li>
<li><a href='#snpposi'><p>Analyse the position of polymorphic sites</p></a></li>
<li><a href='#snpzip'><p>Identification of structural SNPs</p></a></li>
<li><a href='#spca'><p>Spatial principal component analysis</p></a></li>
<li><a href='#spca_randtest'><p>Monte Carlo test for sPCA</p></a></li>
<li><a href='#spcaIllus'><p>Simulated data illustrating the sPCA</p></a></li>
<li><a href='#strata'><p>Access and manipulate the population strata for genind or genlight objects.</p></a></li>
<li><a href='#swallowtails'><p>Microsatellites genotypes of 781 swallowtail butterflies from 40 populations in</p>
Alberta and British Columbia, Canada</a></li>
<li><a href='#tab'><p>Access allele counts or frequencies</p></a></li>
<li><a href='#truenames'><p> Restore true labels of an object</p></a></li>
<li><a href='#virtualClasses'><p>Virtual classes for adegenet</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Exploratory Analysis of Genetic and Genomic Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.10</td>
</tr>
<tr>
<td>Description:</td>
<td>Toolset for the exploration of genetic and genomic
    data. Adegenet provides formal (S4) classes for storing and handling
    various genetic data, including genetic markers with varying ploidy
    and hierarchical population structure ('genind' class), alleles counts
    by populations ('genpop'), and genome-wide SNP data ('genlight'). It
    also implements original multivariate methods (DAPC, sPCA), graphics,
    statistical tests, simulation tools, distance and similarity measures,
    and several spatial methods. A range of both empirical and simulated
    datasets is also provided to illustrate various methods.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/thibautjombart/adegenet">https://github.com/thibautjombart/adegenet</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14), methods, ade4</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, stats, grDevices, MASS, igraph, ape, shiny, ggplot2,
seqinr, parallel, boot, reshape2, dplyr (&ge; 0.4.1), vegan</td>
</tr>
<tr>
<td>Suggests:</td>
<td>adespatial, pegas, hierfstat, maps, spdep, interp, splancs,
poppr, testthat</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'adegenet.package.R' 'datasets.R' 'dist.genlight.R'
'orthobasis.R' 'classes.R' 'constructors.R' 'accessors.R'
'basicMethods.R' 'handling.R' 'auxil.R' 'minorAllele.R'
'setAs.R' 'SNPbin.R' 'strataMethods.R' 'hierarchyMethods.R'
'glHandle.R' 'glFunctions.R' 'glSim.R' 'find.clust.R'
'hybridize.R' 'scale.R' 'fstat.R' 'import.R' 'seqTrack.R'
'chooseCN.R' 'genind2genpop.R' 'loadingplot.R' 'sequences.R'
'gstat.randtest.R' 'makefreq.R' 'colorplot.R' 'monmonier.R'
'spca.R' 'coords.monmonier.R' 'haploGen.R' 'old2new.R'
'global_local_tests.R' 'dapc.R' 'compoplot.R' 'xvalDapc.R'
'haploPop.R' 'PCtest.R' 'dist.genpop.R' 'Hs.R' 'propShared.R'
'export.R' 'HWE.R' 'propTyped.R' 'inbreeding.R' 'glPlot.R'
'gengraph.R' 'simOutbreak.R' 'mutations.R' 'snpposi.R'
'snpzip.R' 'pairDist.R' 'snapclust.R' 'AIC.snapclust.R'
'AICc.snapclust.R' 'BIC.snapclust.R' 'KIC.snapclust.R'
'snapclust.choose.k.R' 'servers.R' 'showmekittens.R'
'spca_randtest.R' 'export_to_mvmapper.R' 'doc_C_routines.R'
'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-25 22:43:53 UTC; zhian</td>
</tr>
<tr>
<td>Author:</td>
<td>Thibaut Jombart <a href="https://orcid.org/0000-0003-2226-8692"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Zhian N. Kamvar <a href="https://orcid.org/0000-0003-1458-7108"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Caitlin Collins [ctb],
  Roman Lustrik [ctb],
  Marie-Pauline Beugin [ctb],
  Brian J. Knaus [ctb],
  Peter Solymos [ctb],
  Vladimir Mikryukov [ctb],
  Klaus Schliep [ctb],
  Tiago Maié [ctb],
  Libor Morkovsky [ctb],
  Ismail Ahmed [ctb],
  Anne Cori [ctb],
  Federico Calboli [ctb],
  RJ Ewing [ctb],
  Frédéric Michaud [ctb],
  Rebecca DeCamp [ctb],
  Alexandre Courtiol
    <a href="https://orcid.org/0000-0003-0637-2959"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Lindsay V. Clark <a href="https://orcid.org/0000-0002-3881-9252"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Pavel Dimens <a href="https://orcid.org/0000-0003-3823-0373"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zhian N. Kamvar &lt;zkamvar@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-26 22:00:23 UTC</td>
</tr>
</table>
<hr>
<h2 id='.internal_C_routines'>Internal C routines</h2><span id='topic+.internal_C_routines'></span><span id='topic+CheckAllSeg'></span><span id='topic+GLdotProd'></span><span id='topic+GLsumFreq'></span><span id='topic+GLsumInt'></span><span id='topic+binIntToBytes'></span><span id='topic+bytesToBinInt'></span><span id='topic+bytesToInt'></span><span id='topic+nb_shared_all'></span>

<h3>Description</h3>

<p>These functions are internal C routines used in adegenet. Do not use them
unless you know what you are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.internal_C_routines
</code></pre>


<h3>Format</h3>

<p>An object of class <code>NULL</code> of length 0.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart
</p>

<hr>
<h2 id='a-score'>Compute and optimize a-score for Discriminant Analysis of Principal Components (DAPC)</h2><span id='topic+a.score'></span><span id='topic+optim.a.score'></span>

<h3>Description</h3>

<p>These functions are under development. Please email the author before
using them for published results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a.score(x, n.sim=10, ...)

optim.a.score(x, n.pca=1:ncol(x$tab), smart=TRUE, n=10, plot=TRUE,
              n.sim=10, n.da=length(levels(x$grp)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="a-score_+3A_x">x</code></td>
<td>
<p>a <code>dapc</code> object.</p>
</td></tr>
<tr><td><code id="a-score_+3A_n.pca">n.pca</code></td>
<td>
<p>a vector of <code>integers</code> indicating the number of axes retained in the
Principal Component Analysis (PCA) steps of DAPC. <code>nsim</code> DAPC
will be run for each value in <code>n.pca</code>, unless the smart approach
is used (see details).</p>
</td></tr>
<tr><td><code id="a-score_+3A_smart">smart</code></td>
<td>
<p>a <code>logical</code> indicating whether a smart, less
computer-intensive approach should be used (TRUE, default) or not
(FALSE). See details section.</p>
</td></tr>
<tr><td><code id="a-score_+3A_n">n</code></td>
<td>
<p>an <code>integer</code> indicating the numbers of values spanning the
range of <code>n.pca</code> to be used in the smart approach.</p>
</td></tr>
<tr><td><code id="a-score_+3A_plot">plot</code></td>
<td>
<p>a <code>logical</code> indicating whether the results should be
displayed graphically (TRUE, default) or not (FALSE).</p>
</td></tr>
<tr><td><code id="a-score_+3A_n.sim">n.sim</code></td>
<td>
<p>an <code>integer</code> indicating the number of simulations to
be performed for each number of retained PC.</p>
</td></tr>
<tr><td><code id="a-score_+3A_n.da">n.da</code></td>
<td>
<p>an <code>integer</code> indicating the number of axes retained in the
Discriminant Analysis step.</p>
</td></tr>
<tr><td><code id="a-score_+3A_...">...</code></td>
<td>
<p>further arguments passed to other methods; currently unused..</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Discriminant Analysis of Principal Components seeks a reduced
space inside which observations are best discriminated into
pre-defined groups. One way to assess the quality of the
discrimination is looking at re-assignment of individuals to their
prior group, successful re-assignment being a sign of strong discrimination.
</p>
<p>However, when the original space is very large, ad hoc solutions can
be found, which discriminate very well the sampled individuals but
would perform poorly on new samples. In such a case, DAPC
re-assignment would be high even for randomly chosen clusters.
The a-score measures this bias. It is computed as (Pt-Pr), where Pt is
the reassignment probability using the true cluster, and Pr is the
reassignment probability for randomly permuted clusters. A a-score
close to one is a sign that the DAPC solution is both strongly
discriminating and stable, while low values (toward 0 or lower)
indicate either weak discrimination or instability of the results.
</p>
<p>The a-score can serve as a criterion for choosing the optimal number of
PCs in the PCA step of DAPC, i.e. the number of PC maximizing the
a-score. Two procedures are implemented in <code>optim.a.score</code>. The
smart procedure selects evenly distributed number of PCs in a
pre-defined range, compute the a-score for each, and then interpolate
the results using splines, predicting an approximate optimal number of
PCs. The other procedure (when <code>smart</code> is FALSE) performs the
computations for all number of PCs request by the user. The 'optimal'
number is then the one giving the highest mean a-score (computed over
the groups).
</p>


<h3>Value</h3>

<p>=== a.score ===<br />
<code>a.score</code> returns a list with the following components:<br />
</p>
<table>
<tr><td><code>tab</code></td>
<td>
<p>a matrix of a-scores with groups in columns and simulations in row.</p>
</td></tr>
<tr><td><code>pop.score</code></td>
<td>
<p>a vector giving the mean a-score for each population.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>the overall mean a-score.</p>
</td></tr></table>
<p><br />
</p>
<p>=== optim.a.score ===<br />
<code>optima.score</code> returns a list with the following components:<br />
</p>
<table>
<tr><td><code>pop.score</code></td>
<td>
<p>a list giving the mean a-score of the populations
for each number of retained PC (each element of the list corresponds
to a number of retained PCs).</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>a vector giving the overall mean a-score for each number
of retained PCs.</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>(only when <code>smart</code> is TRUE) the predictions of the
spline, given in x and y coordinates.</p>
</td></tr>
<tr><td><code>best</code></td>
<td>
<p>the optimal number of PCs to be retained.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a> </p>


<h3>References</h3>

<p>Jombart T, Devillard S and Balloux F  (2010) Discriminant analysis of
principal components: a new method for the analysis of genetically
structured populations. BMC Genetics11:94. doi:10.1186/1471-2156-11-94
</p>


<h3>See Also</h3>

<p>- <code><a href="#topic+find.clusters">find.clusters</a></code>: to identify clusters without prior.
</p>
<p>- <code><a href="#topic+dapc">dapc</a></code>: the Discriminant Analysis of Principal
Components (DAPC)
</p>

<hr>
<h2 id='Accessors'>Accessors for adegenet objects</h2><span id='topic++24+2Cgenind-method'></span><span id='topic++24+2Cgenpop-method'></span><span id='topic++24+3C-+2Cgenind-method'></span><span id='topic++24+3C-+2Cgenpop-method'></span><span id='topic++5B+2Cgenind-method'></span><span id='topic++5B+2Cgenind+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2Cgenpop-method'></span><span id='topic++5B+2Cgenpop+2CANY+2CANY+2CANY-method'></span><span id='topic+nLoc'></span><span id='topic+nLoc+2Cgen-method'></span><span id='topic+nLoc+2Cgenind-method'></span><span id='topic+nLoc+2Cgenpop-method'></span><span id='topic+locFac'></span><span id='topic+locFac+2Cgen-method'></span><span id='topic+locFac+2Cgenind-method'></span><span id='topic+locFac+2Cgenpop-method'></span><span id='topic+nAll'></span><span id='topic+nAll+2Cgen-method'></span><span id='topic+nAll+2Cgenind-method'></span><span id='topic+nAll+2Cgenpop-method'></span><span id='topic+nPop'></span><span id='topic+nPop+2Cgenind-method'></span><span id='topic+nPop+2Cgenpop-method'></span><span id='topic+nInd'></span><span id='topic+nInd+2Cgenind-method'></span><span id='topic+pop'></span><span id='topic+pop+3C-'></span><span id='topic+pop+2Cgenind-method'></span><span id='topic+pop+3C-+2Cgen-method'></span><span id='topic+pop+3C-+2Cgenind-method'></span><span id='topic+locNames'></span><span id='topic+locNames+2Cgen-method'></span><span id='topic+locNames+2Cgenind-method'></span><span id='topic+locNames+2Cgenpop-method'></span><span id='topic+locNames+3C-'></span><span id='topic+locNames+3C-+2Cgen-method'></span><span id='topic+locNames+3C-+2Cgenind-method'></span><span id='topic+locNames+3C-+2Cgenpop-method'></span><span id='topic+popNames'></span><span id='topic+popNames+2Cgenind-method'></span><span id='topic+popNames+2Cgenpop-method'></span><span id='topic+popNames+3C-'></span><span id='topic+popNames+3C-+2Cgenind-method'></span><span id='topic+popNames+3C-+2Cgenpop-method'></span><span id='topic+indNames'></span><span id='topic+indNames+2Cgenind-method'></span><span id='topic+indNames+3C-'></span><span id='topic+indNames+3C-+2Cgenind-method'></span><span id='topic+ploidy'></span><span id='topic+ploidy+2Cgenind-method'></span><span id='topic+ploidy+2Cgenpop-method'></span><span id='topic+ploidy+3C-'></span><span id='topic+ploidy+3C-+2Cgenind-method'></span><span id='topic+ploidy+3C-+2Cgenpop-method'></span><span id='topic+alleles'></span><span id='topic+alleles+2Cgen-method'></span><span id='topic+alleles+2Cgenind-method'></span><span id='topic+alleles+2Cgenpop-method'></span><span id='topic+alleles+3C-'></span><span id='topic+alleles+3C-+2Cgen-method'></span><span id='topic+alleles+3C-+2Cgenind-method'></span><span id='topic+alleles+3C-+2Cgenpop-method'></span><span id='topic+other'></span><span id='topic+other+2Cgen-method'></span><span id='topic+other+2Cgenind-method'></span><span id='topic+other+2Cgenpop-method'></span><span id='topic+other+3C-'></span><span id='topic+other+3C-+2Cgen-method'></span><span id='topic+other+3C-+2Cgenind-method'></span><span id='topic+other+3C-+2Cgenpop-method'></span>

<h3>Description</h3>

<p>An accessor is a function that allows to interact with slots of an
object in a convenient way. Several accessors are available for <a href="#topic+genind-class">genind</a> or
<a href="#topic+genpop-class">genpop</a> objects. The operator &quot;$&quot; and &quot;$&lt;-&quot; are used to
access the slots, being equivalent to &quot;@&quot; and &quot;@&lt;-&quot;.<br />
</p>
<p>The operator &quot;[&quot; is a flexible way to subset data by individuals,
populations, alleles, and loci. When using a matrix-like syntax,
subsetting will apply to the dimensios of the @tab slot. In addition,
specific arguments <code>loc</code> and <code>pop</code> can be used to indicate
subsets of loci and populations. The argument <code>drop</code> is a logical
indicating if alleles becoming non-polymorphic in a new dataset should
be removed (default: FALSE). Examples:<br />
</p>

<ul>
<li><p> &quot;obj[i,j]&quot; returns &quot;obj&quot; with a subset 'i' of individuals and 'j' of
alleles.<br />
</p>
</li>
<li><p> &quot;obj[1:10,]&quot; returns an object with only the first 10 genotypes (if
&quot;obj&quot; is a <a href="#topic+genind-class">genind</a>) or the first 10 populations (if
&quot;obj&quot; is a <a href="#topic+genpop-class">genpop</a>) <br />
</p>
</li>
<li><p> &quot;obj[1:10, 5:10]&quot; returns an object keeping the first 10 entities and
the alleles 5 to 10.<br />
</p>
</li>
<li><p> &quot;obj[loc=c(1,3)]&quot; returns an object keeping only the 1st and 3rd
loci, using <code>locNames(obj)</code> as reference; logicals, or named loci
also work; this overrides other subsetting of alleles.<br />
</p>
</li>
<li><p> &quot;obj[pop=2:4]&quot; returns an object keeping only individuals from the
populations 2, 3 and 4, using <code>popNames(obj)</code> as reference;
logicals, or named populations also work; this overrides other
subsetting of individuals.<br />
</p>
</li>
<li><p> &quot;obj[i=1:2, drop=TRUE]&quot; returns an object keeping only the first
two individuals (or populations), dropping the alleles no longer
present in the data.<br />
</p>
</li></ul>

<p>The argument <code>treatOther</code> handles the treatment of objects in the
<code>@other</code> slot (see details). The argument <code>drop</code> can be set
to TRUE to drop alleles that are no longer represented in the subset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nInd(x, ...)
nLoc(x, ...)
nAll(x, onlyObserved = FALSE, ...)
nPop(x, ...)
pop(x)
indNames(x, ...)
## S4 method for signature 'genind'
indNames(x, ...)
locNames(x, ...)
## S4 method for signature 'genind'
locNames(x, withAlleles=FALSE, ...)
## S4 method for signature 'genpop'
locNames(x, withAlleles=FALSE, ...)
popNames(x, ...)
## S4 method for signature 'genind'
popNames(x, ...)
popNames(x, ...)
## S4 method for signature 'genpop'
popNames(x, ...)
ploidy(x, ...)
## S4 method for signature 'genind'
ploidy(x, ...)
## S4 method for signature 'genpop'
ploidy(x, ...)
## S4 method for signature 'genind'
other(x, ...)
## S4 method for signature 'genpop'
other(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Accessors_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+genind-class">genind</a> or a <a href="#topic+genpop-class">genpop</a> object.</p>
</td></tr>
<tr><td><code id="Accessors_+3A_onlyobserved">onlyObserved</code></td>
<td>
<p>a logical indicating whether the allele count should
also include the alleles with onlyObserved columns in the matrix. Defaults
to <code>FALSE</code>, which will report only the observed alleles in the
given population. <code>onlyObserved = TRUE</code> will be the equivalent of
<code>table(locFac(x))</code>, but faster.</p>
</td></tr>
<tr><td><code id="Accessors_+3A_withalleles">withAlleles</code></td>
<td>
<p>a logical indicating whether the result should be
of the form [locus name].[allele name], instead of [locus name].</p>
</td></tr>
<tr><td><code id="Accessors_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to other methods
(currently not used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;[&quot; operator can treat elements in the <code>@other</code> slot as
well. For instance, if <code>obj@other$xy</code> contains spatial
coordinates, the <code>obj[1:3, ]@other$xy</code> will contain the spatial
coordinates of the genotypes (or population) 1,2 and 3. This is
handled through the argument <code>treatOther</code>, a logical defaulting
to TRUE. If set to FALSE, the <code>@other</code> returned unmodified.<br />
</p>
<p>Note that only matrix-like, vector-like and lists can be proceeded in
<code>@other</code>. Other kind of objects will issue a warning an be
returned as they are, unless the argument <code>quiet</code> is left to
TRUE, its default value.<br />
</p>
<p>The <code>drop</code> argument can be set to TRUE to retain only alleles
that are present in the subset. To achieve better control of
polymorphism of the data, see <code><a href="#topic+isPoly">isPoly</a></code>.
</p>
<p><code>nAll()</code> reflects the number of columns per locus present in the current
gen object. If <code>onlyObserved = TRUE</code>, then the number of columns with at
least one non-missing allele is shown. 
</p>


<h3>Value</h3>

<p>A <a href="#topic+genind-class">genind</a> or <a href="#topic+genpop-class">genpop</a> object.
</p>


<h3>Methods</h3>


<dl>
<dt>nInd</dt><dd><p>returns the number of individuals in the <code>genind</code> object</p>
</dd>
<dt>nLoc</dt><dd><p>returns the number of loci</p>
</dd>
<dt>nAll</dt><dd><p>returns the number of observed alleles in each locus</p>
</dd>
<dt>nPop</dt><dd><p>returns the number of populations</p>
</dd>
<dt>pop</dt><dd><p>returns a factor assigning individuals to populations.</p>
</dd>
<dt>pop&lt;-</dt><dd><p>replacement method for the <code>@pop</code> slot of an
object.</p>
</dd>
<dt>popNames</dt><dd><p>returns the names of populations.</p>
</dd>
<dt>popNames&lt;-</dt><dd><p>sets the names of populations using a vector of
length <code>nPop(x)</code>.</p>
</dd>
<dt>indNames</dt><dd><p>returns the names of individuals.</p>
</dd>
<dt>indNames&lt;-</dt><dd><p>sets the names of individuals using a vector of
length <code>nInd(x)</code>.</p>
</dd>
<dt>locNames</dt><dd><p>returns the names of markers and/or alleles.</p>
</dd>
<dt>locNames&lt;-</dt><dd><p>sets the names of markers using a vector of
length <code>nLoc(x)</code>.</p>
</dd>
<dt>locFac</dt><dd><p>returns a factor that defines which locus each column of the <code>@tab</code> slot belongs to</p>
</dd>
<dt>ploidy</dt><dd><p>returns the ploidy of the data.</p>
</dd>
<dt>ploidy&lt;-</dt><dd><p>sets the ploidy of the data using an integer.</p>
</dd>
<dt>alleles</dt><dd><p>returns the alleles of each locus.</p>
</dd>
<dt>alleles&lt;-</dt><dd><p>sets the alleles of each locus using a list with
one character vector for each locus.</p>
</dd>
<dt>other</dt><dd><p>returns the content of the <code>@other</code> slot
(misc. information); returns <code>NULL</code> if the slot is onlyObserved or of
length zero.</p>
</dd>
<dt>other&lt;-</dt><dd><p>sets the content of the <code>@other</code> slot
(misc. information); the provided value needs to be a list; it
not, provided value will be stored within a list.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nancycats)
nancycats
pop(nancycats) # get the populations
indNames(nancycats) # get the labels of individuals
locNames(nancycats) # get the labels of the loci
alleles(nancycats)  # get the alleles
nAll(nancycats)     # count the number of alleles

head(tab(nancycats)) # get allele counts

# get allele frequencies, replace NAs
head(tab(nancycats, freq = TRUE, NA.method = "mean")) 

# let's isolate populations 4 and 8
popNames(nancycats)
obj &lt;- nancycats[pop=c(4, 8)]
obj
popNames(obj)
pop(obj)
nAll(obj, onlyObserved = TRUE) # count number of alleles among these two populations
nAll(obj) # count number of columns in the data
all(nAll(obj, onlyObserved = TRUE) == lengths(alleles(obj))) # will be FALSE since drop = FALSE
all(nAll(obj) == lengths(alleles(obj))) # will be FALSE since drop = FALSE

# let's isolate two markers, fca23 and fca90
locNames(nancycats)
obj &lt;- nancycats[loc=c("fca23","fca90")]
obj
locNames(obj)

# illustrate pop
obj &lt;- nancycats[sample(1:100, 10)]
pop(obj)
pop(obj) &lt;- rep(c('b', 'a'), each = 5)
pop(obj)

# illustrate locNames
locNames(obj)
locNames(obj, withAlleles = TRUE)
locNames(obj)[1] &lt;- "newLocus"
locNames(obj)
locNames(obj, withAlleles=TRUE)

# illustrate how 'other' slot is handled
data(sim2pop)
nInd(sim2pop)
other(sim2pop[1:6]) # xy is subsetted automatically
other(sim2pop[1:6, treatOther=FALSE]) # xy is left as is

</code></pre>

<hr>
<h2 id='Adegenet+20servers'> Web servers for adegenet </h2><span id='topic+adegenetServer'></span>

<h3>Description</h3>

<p>The function <code>adegenetServer</code> opens up a web page providing a
simple user interface for some of the functionalities implemented in
adegenet. These servers have been developed using the package
<code>shiny</code>.<br />
</p>
<p>Currently available servers include:
</p>

<ul>
<li> <p><code>DAPC</code>: a server for the Discriminant Analysis of
Principal Components (see ?dapc)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>adegenetServer(what=c("DAPC"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Adegenet+2B20servers_+3A_what">what</code></td>
<td>
<p>a character string indicating which server to start;
currently accepted values are: &quot;DAPC&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function invisibly returns NULL.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>
Caitlin Collins
</p>


<h3>See Also</h3>

<p><a href="#topic+dapc">dapc</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## this opens a web page for DAPC
adegenetServer()

## End(Not run)
</code></pre>

<hr>
<h2 id='adegenet.package'>The adegenet package</h2><span id='topic+adegenet.package'></span><span id='topic+adegenet'></span>

<h3>Description</h3>

<p>This package is devoted to the multivariate analysis of genetic markers
data. These data can be codominant markers (e.g. microsatellites) or
presence/absence data (e.g. AFLP), and have any level of ploidy.  'adegenet'
defines three formal (S4) classes:<br /> - <a href="#topic+genind-class">genind</a>: a class for
data of individuals (&quot;genind&quot; stands for genotypes-individuals).<br /> -
<a href="#topic+genpop-class">genpop</a>: a class for data of groups of individuals (&quot;genpop&quot;
stands for genotypes-populations)<br /> - <a href="#topic+genlight-class">genlight</a>: a class for
genome-wide SNP data<br />
</p>


<h3>Details</h3>

<p>For more information about these classes, type &quot;class ? genind&quot;, &quot;class ?
genpop&quot;, or &quot;?genlight&quot;.<br />
</p>
<p>Essential functionalities of the package are presented througout 4
tutorials, accessible using <code>adegenetTutorial(which="name-below")</code>:<br />
- <code>basics</code>: introduction to the package.<br /> - <code>spca</code>: multivariate
analysis of spatial genetic patterns.<br /> - <code>dapc</code>: population structure
and group assignment using DAPC.<br /> - <code>genomics</code>: introduction to the
class <a href="#topic+genlight-class">genlight</a> for the handling and analysis of genome-wide
SNP data.<br />
</p>
<p>Note: In older versions of adegenet, these tutorials were avilable as
vignettes, accessible through the function <code>vignette("name-below",
package="adegenet")</code>:<br /> - <code>adegenet-basics</code>.<br /> -
<code>adegenet-spca</code>.<br /> - <code>adegenet-dapc</code>.<br /> -
<code>adegenet-genomics</code>.<br />
</p>
<p>Important functions are also summarized below.<br />
</p>
<p>=== IMPORTING DATA ===<br /> = TO GENIND OBJECTS = <br /> <code>adegenet</code> imports
data to <a href="#topic+genind-class">genind</a> object from the following softwares:<br /> -
STRUCTURE: see <code><a href="#topic+read.structure">read.structure</a></code><br /> - GENETIX: see
<code><a href="#topic+read.genetix">read.genetix</a></code><br /> - FSTAT: see <code><a href="#topic+read.fstat">read.fstat</a></code><br /> -
Genepop: see <code><a href="#topic+read.genepop">read.genepop</a></code><br /> To import data from any of these
formats, you can also use the general function
<code><a href="#topic+import2genind">import2genind</a></code>.<br />
</p>
<p>In addition, it can extract polymorphic sites from nucleotide and amino-acid
alignments:<br /> - DNA files: use <code><a href="ape.html#topic+read.dna">read.dna</a></code> from the ape
package, and then extract SNPs from DNA alignments using
<code><a href="#topic+DNAbin2genind">DNAbin2genind</a></code>. <br />
</p>
<p>- protein sequences alignments: polymorphic sites can be extracted from
protein sequences alignments in <code>alignment</code> format (package
<code>seqinr</code>, see <code><a href="seqinr.html#topic+as.alignment">as.alignment</a></code>) using the function
<code><a href="#topic+alignment2genind">alignment2genind</a></code>. <br />
</p>
<p>The function <code><a href="#topic+fasta2DNAbin">fasta2DNAbin</a></code> allows for reading fasta files into
DNAbin object with minimum RAM requirements.<br />
</p>
<p>It is also possible to read genotypes coded by character strings from a
data.frame in which genotypes are in rows, markers in columns. For this, use
<code><a href="#topic+df2genind">df2genind</a></code>. Note that <code><a href="#topic+df2genind">df2genind</a></code> can be used for
any level of ploidy.<br />
</p>
<p>= TO GENLIGHT OBJECTS = <br /> SNP data can be read from the following
formats:<br /> - PLINK: see function <code><a href="#topic+read.PLINK">read.PLINK</a></code><br /> - .snp
(adegenet's own format): see function <code><a href="#topic+read.snp">read.snp</a></code><br />
</p>
<p>SNP can also be extracted from aligned DNA sequences with the fasta format,
using <code><a href="#topic+fasta2genlight">fasta2genlight</a></code><br />
</p>
<p>=== EXPORTING DATA ===<br /> <code>adegenet</code> exports data from
</p>
<p>Genotypes can also be recoded from a <a href="#topic+genind-class">genind</a> object into a
data.frame of character strings, using any separator between alleles. This
covers formats from many softwares like GENETIX or STRUCTURE. For this, see
<code><a href="#topic+genind2df">genind2df</a></code>.<br />
</p>
<p>Also note that the <code>pegas</code> package imports <a href="#topic+genind-class">genind</a> objects
using the function <code>as.loci</code>.
</p>
<p>=== MANIPULATING DATA ===<br /> Several functions allow one to manipulate
<a href="#topic+genind-class">genind</a> or <a href="#topic+genpop-class">genpop</a> objects<br /> -
<code><a href="#topic+genind2genpop">genind2genpop</a></code>: convert a <a href="#topic+genind-class">genind</a> object to a
<a href="#topic+genpop-class">genpop</a> <br /> - <code><a href="#topic+seploc">seploc</a></code>: creates one object per
marker; for <a href="#topic+genlight-class">genlight</a> objects, creates blocks of SNPs.<br /> -
<code><a href="#topic+seppop">seppop</a></code>: creates one object per population <br /> -
- <code><a href="#topic+tab">tab</a></code>: access the allele data (counts or frequencies) of an object
(<a href="#topic+genind-class">genind</a> and <a href="#topic+genpop-class">genpop</a>) <br /> -
x[i,j]: create a new object keeping only genotypes (or populations) indexed
by 'i' and the alleles indexed by 'j'.<br /> - <code><a href="#topic+makefreq">makefreq</a></code>: returns
a table of allelic frequencies from a <a href="#topic+genpop-class">genpop</a> object.<br /> -
<code><a href="#topic+repool">repool</a></code> merges genoptypes from different gene pools into one
single <a href="#topic+genind-class">genind</a> object.<br /> - <code><a href="#topic+propTyped">propTyped</a></code> returns the
proportion of available (typed) data, by individual, population, and/or
locus.<br /> - <code><a href="#topic+selPopSize">selPopSize</a></code> subsets data, retaining only genotypes
from a population whose sample size is above a given level.<br /> -
<code><a href="#topic+pop">pop</a></code> sets the population of a set of genotypes.<br />
</p>
<p>=== ANALYZING DATA ===<br /> Several functions allow to use usual, and less
usual analyses:<br /> - <code><a href="#topic+HWE.test.genind">HWE.test.genind</a></code>: performs HWE test for all
populations and loci combinations <br /> - <code><a href="#topic+dist.genpop">dist.genpop</a></code>: computes 5
genetic distances among populations.  <br /> - <code><a href="#topic+monmonier">monmonier</a></code>:
implementation of the Monmonier algorithm, used to seek genetic boundaries
among individuals or populations. Optimized boundaries can be obtained using
<code><a href="#topic+optimize.monmonier">optimize.monmonier</a></code>. Object of the class <code>monmonier</code> can be
plotted and printed using the corresponding methods. <br /> -
<code><a href="#topic+spca">spca</a></code>: implements Jombart et al.  (2008) spatial Principal
Component Analysis <br /> - <code><a href="#topic+global.rtest">global.rtest</a></code>: implements Jombart et
al. (2008) test for global spatial structures <br /> -
<code><a href="#topic+local.rtest">local.rtest</a></code>: implements Jombart et al. (2008) test for local
spatial structures <br /> - <code><a href="#topic+propShared">propShared</a></code>: computes the proportion of
shared alleles in a set of genotypes (i.e. from a genind object)<br /> -
<code><a href="#topic+propTyped">propTyped</a></code>: function to investigate missing data in several ways
<br /> - <code><a href="#topic+scaleGen">scaleGen</a></code>: generic method to scale <a href="#topic+genind-class">genind</a> or
<a href="#topic+genpop-class">genpop</a> before a principal component analysis <br /> -
<code><a href="#topic+Hs">Hs</a></code>: computes the average expected heterozygosity by population
in a <a href="#topic+genpop-class">genpop</a>. Classically Used as a measure of genetic
diversity.<br /> - <code><a href="#topic+find.clusters">find.clusters</a></code> and <code><a href="#topic+dapc">dapc</a></code>: implement
the Discriminant Analysis of Principal Component (DAPC, Jombart et al.,
2010).<br /> - <code><a href="#topic+seqTrack">seqTrack</a></code>: implements the SeqTrack algorithm for
recontructing transmission trees of pathogens (Jombart et al., 2010) .<br />
<code><a href="#topic+glPca">glPca</a></code>: implements PCA for <a href="#topic+genlight-class">genlight</a> objects.<br /> -
<code><a href="#topic+gengraph">gengraph</a></code>: implements some simple graph-based clustering using
genetic data.  - <code><a href="#topic+snpposi.plot">snpposi.plot</a></code> and <code><a href="#topic+snpposi.test">snpposi.test</a></code>:
visualize the distribution of SNPs on a genetic sequence and test their
randomness.  - <code><a href="#topic+adegenetServer">adegenetServer</a></code>: opens up a web interface for
some functionalities of the package (DAPC with cross validation and feature
selection).<br />
</p>
<p>=== GRAPHICS ===<br /> - <code><a href="#topic+colorplot">colorplot</a></code>: plots points with associated
values for up to three variables represented by colors using the RGB system;
useful for spatial mapping of principal components.<br /> -
<code><a href="#topic+loadingplot">loadingplot</a></code>: plots loadings of variables. Useful for
representing the contribution of alleles to a given principal component in a
multivariate method. <br /> - <code><a href="#topic+scatter.dapc">scatter.dapc</a></code>: scatterplots for DAPC
results.<br /> - <code><a href="#topic+compoplot">compoplot</a></code>: plots membership probabilities from a
DAPC object. <br />
</p>
<p>=== SIMULATING DATA ===<br /> - <code><a href="#topic+hybridize">hybridize</a></code>: implements
hybridization between two populations. <br /> - <code><a href="#topic+haploGen">haploGen</a></code>:
simulates genealogies of haplotypes, storing full genomes. <br />
<code><a href="#topic+glSim">glSim</a></code>: simulates simple <a href="#topic+genlight-class">genlight</a> objects.<br />
</p>
<p>=== DATASETS ===<br /> - <code><a href="#topic+H3N2">H3N2</a></code>: Seasonal influenza (H3N2) HA
segment data. <br /> - <code><a href="#topic+dapcIllus">dapcIllus</a></code>: Simulated data illustrating the
DAPC. <br /> - <code><a href="#topic+eHGDP">eHGDP</a></code>: Extended HGDP-CEPH dataset. <br /> -
<code><a href="#topic+microbov">microbov</a></code>: Microsatellites genotypes of 15 cattle breeds. <br /> -
<code><a href="#topic+nancycats">nancycats</a></code>: Microsatellites genotypes of 237 cats from 17
colonies of Nancy (France). <br /> - <code><a href="#topic+rupica">rupica</a></code>: Microsatellites
genotypes of 335 chamois (Rupicapra rupicapra) from the Bauges mountains
(France).<br /> - <code><a href="#topic+sim2pop">sim2pop</a></code>: Simulated genotypes of two
georeferenced populations.<br /> - <code><a href="#topic+spcaIllus">spcaIllus</a></code>: Simulated data
illustrating the sPCA. <br />
</p>
<p>For more information, visit the adegenet website using the function
<code><a href="#topic+adegenetWeb">adegenetWeb</a></code>.<br />
</p>
<p>Tutorials are available via the command <code>adegenetTutorial</code>.<br />
</p>
<p>To cite adegenet, please use the reference given by
<code>citation("adegenet")</code> (or see references below).
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart &lt;t.jombart@imperial.ac.uk&gt;<br />
Developers: Zhian N. Kamvar &lt;zkamvar@gmail.com&gt;,
Caitlin Collins &lt;caitiecollins17@gmail.com&gt;,
Ismail Ahmed &lt;ismail.ahmed@inserm.fr&gt;,
Federico Calboli, Tobias Erik Reiners, Peter
Solymos, Anne Cori, <br /> Contributed datasets from: Katayoun
Moazami-Goudarzi, Denis Laloë, Dominique Pontier, Daniel Maillard, Francois
Balloux.
</p>


<h3>References</h3>

<p>Jombart T. (2008) adegenet: a R package for the multivariate
analysis of genetic markers <em>Bioinformatics</em> 24: 1403-1405. doi:
10.1093/bioinformatics/btn129<br />
</p>
<p>Jombart T. and Ahmed I. (2011) adegenet 1.3-1: new tools for the analysis of
genome-wide SNP data.  <em>Bioinformatics</em>. doi:
10.1093/bioinformatics/btr521
</p>
<p>Jombart T, Devillard S and Balloux F (2010) Discriminant analysis of
principal components: a new method for the analysis of genetically
structured populations. BMC Genetics 11:94.  doi:10.1186/1471-2156-11-94<br />
</p>
<p>Jombart T, Eggo R, Dodd P, Balloux F (2010) Reconstructing disease outbreaks
from genetic data: a graph approach. <em>Heredity</em>. doi:
10.1038/hdy.2010.78.<br />
</p>
<p>Jombart, T., Devillard, S., Dufour, A.-B. and Pontier, D. (2008) Revealing
cryptic spatial patterns in genetic variability by a new multivariate
method. <em>Heredity</em>, <b>101</b>, 92&ndash;103.<br />
</p>
<p>See adegenet website: <a href="http://adegenet.r-forge.r-project.org/">http://adegenet.r-forge.r-project.org/</a><br />
</p>
<p>Please post your questions on 'the adegenet forum':
adegenet-forum@lists.r-forge.r-project.org
</p>


<h3>See Also</h3>

<p>adegenet is related to several packages, in particular:<br /> -
<code>ade4</code> for multivariate analysis<br /> - <code>pegas</code> for population
genetics tools<br /> - <code>ape</code> for phylogenetics and DNA data handling<br /> -
<code>seqinr</code> for handling nucleic and proteic sequences<br /> - <code>shiny</code>
for R-based web interfaces<br />
</p>

<hr>
<h2 id='adegenetWeb'>Functions to access online resources for adegenet</h2><span id='topic+adegenetWeb'></span><span id='topic+adegenetTutorial'></span><span id='topic+adegenetIssues'></span>

<h3>Description</h3>

<p>These functions simply open websites or documents
available online providing resources for adegenet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adegenetWeb()

adegenetTutorial(
  which = c("basics", "spca", "dapc", "genomics", "strata", "snapclust")
)

adegenetIssues()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adegenetWeb_+3A_which">which</code></td>
<td>
<p>a character string indicating which tutorial to open (see details)</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> adegenetWeb opens adegenet's website
</p>
</li>
<li><p> adegenetTutorial opens adegenet tutorials
</p>
</li>
<li><p> adegenetIssues opens the issue page on github;
this is used to report a bug or post a feature request.
</p>
</li></ul>

<p>Available tutorials are:
</p>

<ul>
<li><p> 'basics': general introduction to adegenet; covers basic data structures, import/export, handling, and a number of population genetics methods
</p>
</li>
<li><p> 'spca': spatial genetic structures using the spatial Principal Component Analysis
</p>
</li>
<li><p> 'dapc': population structure using the Discriminant Analysis of Principal Components
</p>
</li>
<li><p> 'genomics': handling large genome-wide SNP data using adegenet
</p>
</li>
<li><p> 'strata': introduction to hierarchical population structure in adegenet
</p>
</li>
<li><p> 'snapclust': introduction to fast maximum-likelihood genetic clustering using snapclust
</p>
</li></ul>


<hr>
<h2 id='AIC.snapclust'>Compute Akaike Information Criterion (AIC) for snapclust</h2><span id='topic+AIC.snapclust'></span>

<h3>Description</h3>

<p>Do not use. We work on that stuff. Contact us if interested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'snapclust'
AIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AIC.snapclust_+3A_object">object</code></td>
<td>
<p>An object returned by the function <code><a href="#topic+snapclust">snapclust</a></code>.</p>
</td></tr>
<tr><td><code id="AIC.snapclust_+3A_...">...</code></td>
<td>
<p>Further arguments for compatibility with the <code>AIC</code> generic
(currently not used).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+snapclust">snapclust</a></code> to generate clustering solutions.
</p>

<hr>
<h2 id='AICc'>Compute Akaike Information Criterion for small samples (AICc) for snapclust</h2><span id='topic+AICc'></span><span id='topic+AICc.snapclust'></span>

<h3>Description</h3>

<p>Do not use. We work on that stuff. Contact us if interested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AICc(object, ...)

## S3 method for class 'snapclust'
AICc(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AICc_+3A_object">object</code></td>
<td>
<p>An object returned by the function <code><a href="#topic+snapclust">snapclust</a></code>.</p>
</td></tr>
<tr><td><code id="AICc_+3A_...">...</code></td>
<td>
<p>Further arguments for compatibility with the <code>AIC</code> generic
(currently not used).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+snapclust">snapclust</a></code> to generate clustering solutions.
</p>

<hr>
<h2 id='as+20methods+20in+20adegenet'>Converting genind/genpop objects to other classes</h2><span id='topic+as-method'></span><span id='topic+as+2Cgenind+2Cdata.frame-method'></span><span id='topic+as+2Cgenpop+2Cdata.frame-method'></span><span id='topic+as+2Cgenind+2Cmatrix-method'></span><span id='topic+as+2Cgenpop+2Cmatrix-method'></span><span id='topic+as+2Cgenind+2Cgenpop-method'></span><span id='topic+ktab-class'></span><span id='topic+as+2Cgenind+2Cktab-method'></span><span id='topic+as+2Cgenpop+2Cktab-method'></span><span id='topic+coerce+2Cgenind+2Cdata.frame-method'></span><span id='topic+coerce+2Cgenpop+2Cdata.frame-method'></span><span id='topic+coerce+2Cgenind+2Cmatrix-method'></span><span id='topic+coerce+2Cgenpop+2Cmatrix-method'></span><span id='topic+coerce+2Cgenind+2Cgenpop-method'></span><span id='topic+coerce+2Cgenind+2Cktab-method'></span><span id='topic+coerce+2Cgenpop+2Cktab-method'></span><span id='topic+as.data.frame.genind'></span><span id='topic+as.data.frame.genpop'></span><span id='topic+as.matrix.genind'></span><span id='topic+as.matrix.genpop'></span><span id='topic+as.genpop.genind'></span><span id='topic+as.ktab.genind'></span><span id='topic+as.ktab.genpop'></span>

<h3>Description</h3>

<p>These S3 and S4 methods are used to coerce <a href="#topic+genind-class">genind</a> and
<a href="#topic+genpop-class">genpop</a> objects to matrix-like objects. In most cases,
this is equivalent to calling the <code>@tab</code> slot. An exception to
this is the convertion to <code><a href="ade4.html#topic+ktab">ktab</a></code> objects used in the
ade4 package as inputs for K-tables methods (e.g. Multiple Coinertia
Analysis).<br />
</p>


<h3>Usage</h3>

<p><code>as(object, Class)</code>
</p>


<h3>Arguments</h3>


<dl>
<dt><code>object</code></dt><dd><p>a <a href="#topic+genind-class">genind</a> or a <a href="#topic+genpop-class">genpop</a> object.</p>
</dd>
<dt><code>Class</code></dt><dd><p>the name of the class to which the object should
be coerced, for instance <code>"data.frame"</code> or <code>"matrix"</code>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p>from one object class to another using
<code>as(object,"Class")</code>, where the <code>object</code> is of the old
class and the returned object is of the new class <code>"Class"</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(microbov)
x &lt;- tab(microbov,NA.method="mean")
as(x[1:3],"data.frame")

## dudi functions attempt to convert their first argument
## to a data.frame; so they can be used on genind/genpop objects.
## perform a PCA
pca1 &lt;- dudi.pca(x, scale=FALSE, scannf=FALSE)
pca1

x &lt;- genind2genpop(microbov,miss="chi2")
x &lt;- as(x,"ktab")
class(x)
## perform a STATIS analysis
statis1 &lt;- statis(x, scannf=FALSE)
statis1
plot(statis1)


## End(Not run)
</code></pre>

<hr>
<h2 id='as.genlight'>Conversion to class &quot;genlight&quot;</h2><span id='topic+as+2Cgenlight+2Cmatrix-method'></span><span id='topic+as+2Cgenlight+2Cdata.frame-method'></span><span id='topic+as+2Cgenlight+2Clist-method'></span><span id='topic+as.genlight'></span><span id='topic+as.genlight+2Cmatrix-method'></span><span id='topic+as.genlight+2Cdata.frame-method'></span><span id='topic+as.genlight+2Clist-method'></span><span id='topic+coerce+2Cgenlight+2Cmatrix-method'></span><span id='topic+coerce+2Cgenlight+2Cdata.frame-method'></span><span id='topic+coerce+2Cgenlight+2Clist-method'></span>

<h3>Description</h3>

<p>The class <code>genlight</code> is a formal (S4) class for storing a genotypes
of binary SNPs in a compact way, using a bit-level coding scheme. New
instances of this class are best created using <code>new</code>; see the
manpage of <a href="#topic+genlight-class">genlight</a> for more information on this point.
</p>
<p>As a shortcut, conversion methods can be used to convert various
objects into a <a href="#topic+genlight-class">genlight</a> object. Conversions can be
achieved using S3-style (<code>as.genlight(x)</code>) or S4-style
(<code>as(x,"genlight"</code>) procedures. All of them call upon the
constructor (<code>new</code>) of <a href="#topic+genlight-class">genlight</a> objects.
</p>
<p>Conversion is currently available from the following objects:
- matrix of type integer/numeric
- data.frame with integer/numeric data
- list of vectors of integer/numeric type
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart (<a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>)</p>


<h3>See Also</h3>

<p>Related class:<br />
-  <code><a href="#topic+SNPbin-class">SNPbin</a></code>, for storing individual genotypes of
binary SNPs<br />
</p>
<p>-  <code><a href="#topic+genind-class">genind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## data to be converted
dat &lt;- list(toto=c(1,1,0,0,2,2,1,2,NA), titi=c(NA,1,1,0,1,1,1,0,0), tata=c(NA,0,3, NA,1,1,1,0,0))

## using the constructor
x1 &lt;- new("genlight", dat)
x1

## using 'as' methods
x2 &lt;- as.genlight(dat)
x3 &lt;- as(dat, "genlight")

identical(x1,x2)
identical(x1,x3)

## End(Not run)

</code></pre>

<hr>
<h2 id='as.SNPbin'>Conversion to class &quot;SNPbin&quot;</h2><span id='topic+as+2CSNPbin+2Cinteger-method'></span><span id='topic+as+2CSNPbin+2Cnumeric-method'></span><span id='topic+as.SNPbin'></span><span id='topic+as.SNPbin+2Cinteger-method'></span><span id='topic+as.SNPbin+2Cnumeric-method'></span><span id='topic+coerce+2Cinteger+2CSNPbin-method'></span><span id='topic+coerce+2Cnumeric+2CSNPbin-method'></span>

<h3>Description</h3>

<p>The class <a href="#topic+SNPbin-class">SNPbin</a> is a formal (S4) class for storing a genotype
of binary SNPs in a compact way, using a bit-level coding scheme. New
instances of this class are best created using <code>new</code>; see the
manpage of <a href="#topic+SNPbin-class">SNPbin</a> for more information on this point.
</p>
<p>As a shortcut, conversion methods can be used to convert various
objects into a <a href="#topic+SNPbin-class">SNPbin</a> object. Conversions can be
achieved using S3-style (<code>as.SNPbin(x)</code>) or S4-style
(<code>as(x,"SNPbin"</code>) procedures. All of them call upon the
constructor (<code>new</code>) of <a href="#topic+SNPbin-class">SNPbin</a> objects.
</p>
<p>Conversion is currently available from the following objects:
- integer vectors
- numeric vectors
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart (<a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>)</p>


<h3>See Also</h3>

<p>Related class:<br />
-  <code><a href="#topic+SNPbin-class">SNPbin</a></code>
-  <code><a href="#topic+genlight-class">genlight</a></code>, for storing multiple binary SNP
genotypes. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## data to be converted
dat &lt;- c(1,0,0,2,1,1,1,2,2,1,1,0,0,1)

## using the constructor
x1 &lt;- new("SNPbin", dat)
x1

## using 'as' methods
x2 &lt;- as.SNPbin(dat)
x3 &lt;- as(dat, "SNPbin")

identical(x1,x2)
identical(x1,x3)

## End(Not run)
</code></pre>

<hr>
<h2 id='Auxiliary+20functions'> Auxiliary functions for adegenet</h2><span id='topic+checkType'></span><span id='topic+.rmspaces'></span><span id='topic+.genlab'></span><span id='topic+.readExt'></span><span id='topic+corner'></span><span id='topic+num2col'></span><span id='topic+fac2col'></span><span id='topic+any2col'></span><span id='topic+transp'></span><span id='topic+bluepal'></span><span id='topic+redpal'></span><span id='topic+greenpal'></span><span id='topic+greypal'></span><span id='topic+flame'></span><span id='topic+azur'></span><span id='topic+seasun'></span><span id='topic+lightseasun'></span><span id='topic+deepseasun'></span><span id='topic+spectral'></span><span id='topic+wasp'></span><span id='topic+funky'></span><span id='topic+virid'></span><span id='topic+hybridpal'></span>

<h3>Description</h3>

<p>adegenet implements a number of auxiliary procedures that might be of
interest for users. These include graphical tools to translate
variables (numeric or factors) onto a color scale, adding transparency
to existing colors, pre-defined color palettes, extra functions to
access documentation, and low-level treatment of character vectors.
</p>
<p>These functions are mostly auxiliary procedures used internally in
adegenet.<br />
</p>
<p>These items include:
</p>

<ul>
<li> <p><code>num2col</code>: translates a numeric vector into colors. 
</p>
</li>
<li> <p><code>fac2col</code>: translates a factor into colors. 
</p>
</li>
<li> <p><code>any2col</code>: translates a vector of type numeric, character
or factor into colors. 
</p>
</li>
<li> <p><code>transp</code>: adds transparency to a vector of colors. Note that
transparent colors are not supported on some graphical devices.
</p>
</li>
<li> <p><code>corner</code>: adds text to a corner of a figure. 
</p>
</li>
<li> <p><code>checkType</code>: checks the type of markers being used in a
function and issues an error if appropriate.
</p>
</li>
<li> <p><code>.rmspaces</code>: remove peripheric spaces in a character string. 
</p>
</li>
<li> <p><code>.genlab</code>: generate labels in a correct alphanumeric ordering. 
</p>
</li>
<li> <p><code>.readExt</code>: read the extension of a given file. 
</p>
</li></ul>

<p>Color palettes include:
</p>

<ul>
<li> <p><code>bluepal</code>: white -&gt; dark blue
</p>
</li>
<li> <p><code>redpal</code>: white -&gt; dark red
</p>
</li>
<li> <p><code>greenpal</code>: white -&gt; dark green
</p>
</li>
<li> <p><code>greypal</code>: white -&gt; dark grey
</p>
</li>
<li> <p><code>flame</code>: gold -&gt; red
</p>
</li>
<li> <p><code>azur</code>: gold -&gt; blue
</p>
</li>
<li> <p><code>seasun</code>: blue -&gt; gold -&gt; red
</p>
</li>
<li> <p><code>lightseasun</code>: blue -&gt; gold -&gt; red (light variant)
</p>
</li>
<li> <p><code>deepseasun</code>: blue -&gt; gold -&gt; red (deep variant)
</p>
</li>
<li> <p><code>spectral</code>: red -&gt; yellow -&gt; blue (RColorBrewer variant)
</p>
</li>
<li> <p><code>wasp</code>: gold -&gt; brown -&gt; black
</p>
</li>
<li> <p><code>funky</code>: many colors
</p>
</li>
<li> <p><code>virid</code>: adaptation of the <code>viridis</code> palette, from
the <code>viridis</code> package.
</p>
</li>
<li> <p><code>hybridpal</code>: reorder a color palette (<code>virid</code> by
default) to display sharp contrast between the first two colors, and
interpolated colors after; ideal for datasets where two parental
populations are provided first, followed by various degrees of
hybrids.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>.genlab(base, n)
corner(text, posi="topleft",  inset=0.1, ...)
num2col(x, col.pal=heat.colors, reverse=FALSE,
        x.min=min(x,na.rm=TRUE), x.max=max(x,na.rm=TRUE),
        na.col="transparent")
fac2col(x, col.pal=funky, na.col="transparent", seed=NULL)
any2col(x, col.pal=seasun, na.col="transparent")
transp(col, alpha=.5)
hybridpal(col.pal = virid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Auxiliary+2B20functions_+3A_base">base</code></td>
<td>
<p>a character string forming the base of the labels</p>
</td></tr>
<tr><td><code id="Auxiliary+2B20functions_+3A_n">n</code></td>
<td>
<p>the number of labels to generate</p>
</td></tr>
<tr><td><code id="Auxiliary+2B20functions_+3A_text">text</code></td>
<td>
<p>a character string to be added to the plot</p>
</td></tr>
<tr><td><code id="Auxiliary+2B20functions_+3A_posi">posi</code></td>
<td>
<p>a character matching any combinations of &quot;top/bottom&quot; and
&quot;left/right&quot;.</p>
</td></tr>
<tr><td><code id="Auxiliary+2B20functions_+3A_inset">inset</code></td>
<td>
<p>a vector of two numeric values (recycled if needed)
indicating the inset, as a fraction of the plotting region.</p>
</td></tr>
<tr><td><code id="Auxiliary+2B20functions_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="graphics.html#topic+text">text</a></code></p>
</td></tr>
<tr><td><code id="Auxiliary+2B20functions_+3A_x">x</code></td>
<td>
<p>a numeric vector (for <code>num2col</code>) or a vector converted
to a factor (for <code>fac2col</code>).</p>
</td></tr>
<tr><td><code id="Auxiliary+2B20functions_+3A_col.pal">col.pal</code></td>
<td>
<p>a function generating colors according to a given palette.</p>
</td></tr>
<tr><td><code id="Auxiliary+2B20functions_+3A_reverse">reverse</code></td>
<td>
<p>a logical stating whether the palette should be
inverted (TRUE), or not (FALSE, default).</p>
</td></tr>
<tr><td><code id="Auxiliary+2B20functions_+3A_x.min">x.min</code></td>
<td>
<p>the minimal value from which to start the color scale</p>
</td></tr>
<tr><td><code id="Auxiliary+2B20functions_+3A_x.max">x.max</code></td>
<td>
<p>the maximal value from which to start the color scale</p>
</td></tr>
<tr><td><code id="Auxiliary+2B20functions_+3A_na.col">na.col</code></td>
<td>
<p>the color to be used for missing values (NAs)</p>
</td></tr>
<tr><td><code id="Auxiliary+2B20functions_+3A_seed">seed</code></td>
<td>
<p>a seed for R's random number generated, used to fix the
random permutation of colors in the palette used; if NULL, no
randomization is used and the colors are taken from the palette
according to the ordering of the levels.</p>
</td></tr>
<tr><td><code id="Auxiliary+2B20functions_+3A_col">col</code></td>
<td>
<p>a vector of colors</p>
</td></tr>
<tr><td><code id="Auxiliary+2B20functions_+3A_alpha">alpha</code></td>
<td>
<p>a numeric value between 0 and 1 representing the alpha
coefficient; 0: total transparency; 1: no transparency.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>.genlab</code>, a character vector of size &quot;n&quot;.
<code>num2col</code> and <code>fac2col</code> return a vector of
colors. <code>any2col</code> returns a list with the following components:
<code>$col</code> (a vector of colors), <code>$leg.col</code> (colors for the
legend), and <code>$leg.txt</code> (text for the legend).
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a> </p>


<h3>See Also</h3>

<p>The R package RColorBrewer, proposing a nice selection of color
palettes. The <code>viridis</code> package, with many excellent palettes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
.genlab("Locus-",11)

## transparent colors using "transp"
plot(rnorm(1000), rnorm(1000), col=transp("blue",.3), pch=20, cex=4)


## numeric values to color using num2col
plot(1:100, col=num2col(1:100), pch=20, cex=4)
plot(1:100, col=num2col(1:100, col.pal=bluepal), pch=20, cex=4)
plot(1:100, col=num2col(1:100, col.pal=flame), pch=20, cex=4)
plot(1:100, col=num2col(1:100, col.pal=wasp), pch=20, cex=4)
plot(1:100, col=num2col(1:100, col.pal=azur,rev=TRUE), pch=20, cex=4)
plot(1:100, col=num2col(1:100, col.pal=spectral), pch=20, cex=4)
plot(1:100, col=num2col(1:100, col.pal=virid), pch=20, cex=4)

## factor as colors using fac2col
dat &lt;- cbind(c(rnorm(50,8), rnorm(100), rnorm(150,3),
rnorm(50,10)),c(rnorm(50,1),rnorm(100),rnorm(150,3), rnorm(50,5)))
fac &lt;- rep(letters[1:4], c(50,100,150,50))
plot(dat, col=fac2col(fac), pch=19, cex=4)
plot(dat, col=transp(fac2col(fac)), pch=19, cex=4)
plot(dat, col=transp(fac2col(fac,seed=2)), pch=19, cex=4)

## use of any2col
x &lt;- factor(1:10)
col.info &lt;- any2col(x, col.pal=funky)
plot(x, col=col.info$col, main="Use of any2col on a factor")
legend("bottomleft", fill=col.info$leg.col, legend=col.info$leg.txt, bg="white")

x &lt;- 100:1
col.info &lt;- any2col(x, col.pal=wasp)
barplot(x, col=col.info$col, main="Use of any2col on a numeric")
legend("bottomleft", fill=col.info$leg.col, legend=col.info$leg.txt, bg="white")

</code></pre>

<hr>
<h2 id='BIC.snapclust'>Compute Bayesian Information Criterion (BIC) for snapclust</h2><span id='topic+BIC.snapclust'></span>

<h3>Description</h3>

<p>Do not use. We work on that stuff. Contact us if interested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'snapclust'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BIC.snapclust_+3A_object">object</code></td>
<td>
<p>An object returned by the function <code><a href="#topic+snapclust">snapclust</a></code>.</p>
</td></tr>
<tr><td><code id="BIC.snapclust_+3A_...">...</code></td>
<td>
<p>Further arguments for compatibility with the <code>BIC</code> generic
(currently not used).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+snapclust">snapclust</a></code> to generate clustering solutions.
</p>

<hr>
<h2 id='chooseCN'>Function to choose a connection network</h2><span id='topic+chooseCN'></span>

<h3>Description</h3>

<p>The function <code>chooseCN</code> is a simple interface to build a connection
network (CN) from xy coordinates. The user chooses from 6 types of graph and
one additional weighting scheme.  <code>chooseCN</code> calls functions from
appropriate packages, handles non-unique coordinates and returns a
connection network either with classe <code>nb</code> or <code>listw</code>. For graph
types 1-4, duplicated locations are not accepted and will issue an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chooseCN(
  xy,
  ask = TRUE,
  type = NULL,
  result.type = "nb",
  d1 = NULL,
  d2 = NULL,
  k = NULL,
  a = NULL,
  dmin = NULL,
  plot.nb = TRUE,
  edit.nb = FALSE,
  check.duplicates = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chooseCN_+3A_xy">xy</code></td>
<td>
<p>an matrix or data.frame with two columns for x and y coordinates.</p>
</td></tr>
<tr><td><code id="chooseCN_+3A_ask">ask</code></td>
<td>
<p>a logical stating whether graph should be chosen interactively
(TRUE,default) or not (FALSE). Set to FALSE if <code>type</code> is provided.</p>
</td></tr>
<tr><td><code id="chooseCN_+3A_type">type</code></td>
<td>
<p>an integer giving the type of graph (see details).</p>
</td></tr>
<tr><td><code id="chooseCN_+3A_result.type">result.type</code></td>
<td>
<p>a character giving the class of the returned object.
Either &quot;nb&quot; (default) or &quot;listw&quot;, both from <code>spdep</code> package. See
details.</p>
</td></tr>
<tr><td><code id="chooseCN_+3A_d1">d1</code></td>
<td>
<p>the minimum distance between any two neighbours. Used if
<code>type=5.</code></p>
</td></tr>
<tr><td><code id="chooseCN_+3A_d2">d2</code></td>
<td>
<p>the maximum distance between any two neighbours. Used if
<code>type=5</code>. Can also be a character: &quot;dmin&quot; for the minimum distance so
that each site has at least one connection, or &quot;dmax&quot; to have all sites
connected (despite the later has no sense).</p>
</td></tr>
<tr><td><code id="chooseCN_+3A_k">k</code></td>
<td>
<p>the number of neighbours per point. Used if <code>type=6</code>.</p>
</td></tr>
<tr><td><code id="chooseCN_+3A_a">a</code></td>
<td>
<p>the exponent of the inverse distance matrix. Used if <code>type=7</code>.</p>
</td></tr>
<tr><td><code id="chooseCN_+3A_dmin">dmin</code></td>
<td>
<p>the minimum distance between any two distinct points. Used to
avoid infinite spatial proximities (defined as the inversed spatial
distances). Used if <code>type=7</code>.</p>
</td></tr>
<tr><td><code id="chooseCN_+3A_plot.nb">plot.nb</code></td>
<td>
<p>a logical stating whether the resulting graph should be
plotted (TRUE, default) or not (FALSE).</p>
</td></tr>
<tr><td><code id="chooseCN_+3A_edit.nb">edit.nb</code></td>
<td>
<p>a logical stating whether the resulting graph should be
edited manually for corrections (TRUE) or not (FALSE, default).</p>
</td></tr>
<tr><td><code id="chooseCN_+3A_check.duplicates">check.duplicates</code></td>
<td>
<p>a logical indicating if duplicate coordinates should be detected; this can be an issue for some graphs; TRUE by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are 7 kinds of graphs proposed: <br /> Delaunay triangulation (type 1)<br />
Gabriel graph (type 2)<br /> Relative neighbours (type 3)<br /> Minimum spanning
tree (type 4)<br /> Neighbourhood by distance (type 5)<br /> K nearests neighbours
(type 6)<br /> Inverse distances (type 7)<br />
</p>
<p>The last option (type=7) is not a true neighbouring graph: all sites are
neighbours, but the spatial weights are directly proportional to the
inversed spatial distances.<br /> Also not that in this case, the output of the
function is always a <code>listw</code> object, even if <code>nb</code> was
requested.<br />
</p>
<p>The choice of the connection network has been discuted on the adegenet
forum. Please search the archives from adegenet website (section 'contact')
using 'graph' as keyword.
</p>


<h3>Value</h3>

<p>Returns a connection network having the class <code>nb</code> or
<code>listw</code>. The xy coordinates are passed as attribute to the created
object.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spca">spca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(nancycats)

par(mfrow=c(2,2))
cn1 &lt;- chooseCN(nancycats@other$xy,ask=FALSE,type=1)
cn2 &lt;- chooseCN(nancycats@other$xy,ask=FALSE,type=2)
cn3 &lt;- chooseCN(nancycats@other$xy,ask=FALSE,type=3)
cn4 &lt;- chooseCN(nancycats@other$xy,ask=FALSE,type=4)
par(mfrow=c(1,1))

## End(Not run)

</code></pre>

<hr>
<h2 id='colorplot'>Represents a cloud of points with colors</h2><span id='topic+colorplot'></span><span id='topic+colorplot.default'></span>

<h3>Description</h3>

<p>The <code>colorplot</code> function represents a cloud of points with colors
corresponding to a combination of 1,2 or 3 quantitative variables,
assigned to RGB (Red, Green, Blue) channels. For instance, this can be useful to
represent up to 3 principal components in space. Note that the
property of such representation to convey multidimensional information
has not been investigated.<br />
</p>
<p><code>colorplot</code> is a S3 generic function. Methods are defined for
particular objects, like <code><a href="#topic+spca">spca</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorplot(...)

## Default S3 method:
colorplot(xy, X, axes=NULL, add.plot=FALSE, defaultLevel=0, transp=FALSE, alpha=.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colorplot_+3A_xy">xy</code></td>
<td>
<p>a numeric matrix with two columns (e.g. a matrix of spatial coordinates.</p>
</td></tr>
<tr><td><code id="colorplot_+3A_x">X</code></td>
<td>
<p>a matrix-like containing numeric values that are translated
into the RGB system. Variables are considered to be in columns.</p>
</td></tr>
<tr><td><code id="colorplot_+3A_axes">axes</code></td>
<td>
<p>the index of the columns of X to be represented. Up to
three axes can be chosen. If null, up to the first three columns of
X are used.</p>
</td></tr>
<tr><td><code id="colorplot_+3A_add.plot">add.plot</code></td>
<td>
<p>a logical stating whether the colorplot should be
added to the existing plot (defaults to FALSE).</p>
</td></tr>
<tr><td><code id="colorplot_+3A_defaultlevel">defaultLevel</code></td>
<td>
<p>a numeric value between 0 and 1, giving the
default level in a color for which values are not specified. Used
whenever less than three axes are specified.</p>
</td></tr>
<tr><td><code id="colorplot_+3A_transp">transp</code></td>
<td>
<p>a logical stating whether the produced colors should be
transparent (TRUE) or not (FALSE, default).</p>
</td></tr>
<tr><td><code id="colorplot_+3A_alpha">alpha</code></td>
<td>
<p>the alpha level for transparency, between 0 (fully
transparent) and 1 (not transparent); see <code>?rgb</code> for more details.</p>
</td></tr>
<tr><td><code id="colorplot_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to other methods. In
<code>colorplot.default</code>, these arguments are passed to plot/points
functions. See <code>?plot.default</code> and <code>?points</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns a vector of colours used in the plot.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'># a toy example
xy &lt;- expand.grid(1:10,1:10)
df &lt;- data.frame(x=1:100, y=100:1, z=runif(100,0,100))
colorplot(xy,df,cex=10,main="colorplot: toy example")

## Not run: 
# a genetic example using a sPCA
if(require(spdep)){
data(spcaIllus)
dat3 &lt;- spcaIllus$dat3
spca3 &lt;- spca(dat3,xy=dat3$other$xy,ask=FALSE,type=1,plot=FALSE,scannf=FALSE,nfposi=1,nfnega=1)
colorplot(spca3, cex=4, main="colorplot: a sPCA example")
text(spca3$xy[,1], spca3$xy[,2], dat3$pop)
mtext("P1-P2 in cline\tP3 random \tP4 local repulsion")
}

## End(Not run)
</code></pre>

<hr>
<h2 id='compoplot'>Genotype composition plot</h2><span id='topic+compoplot'></span><span id='topic+compoplot.matrix'></span><span id='topic+compoplot.dapc'></span><span id='topic+compoplot.snapclust'></span>

<h3>Description</h3>

<p>The compoplot uses a barplot to represent the group assignment probability of
individuals to several groups. It is a generic with methods for the following
objects:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compoplot(x, ...)

## S3 method for class 'matrix'
compoplot(
  x,
  col.pal = funky,
  border = NA,
  subset = NULL,
  show.lab = FALSE,
  lab = rownames(x),
  legend = TRUE,
  txt.leg = colnames(x),
  n.col = 4,
  posi = NULL,
  cleg = 0.8,
  bg = transp("white"),
  ...
)

## S3 method for class 'dapc'
compoplot(x, only.grp = NULL, border = NA, ...)

## S3 method for class 'snapclust'
compoplot(x, border = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compoplot_+3A_x">x</code></td>
<td>
<p>an object to be used for plotting (see description)</p>
</td></tr>
<tr><td><code id="compoplot_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>barplot</code></p>
</td></tr>
<tr><td><code id="compoplot_+3A_col.pal">col.pal</code></td>
<td>
<p>a color palette to be used for the groups; defaults to <code>funky</code></p>
</td></tr>
<tr><td><code id="compoplot_+3A_border">border</code></td>
<td>
<p>a color for the border of the barplot; use <code>NA</code> to
indicate no border.</p>
</td></tr>
<tr><td><code id="compoplot_+3A_subset">subset</code></td>
<td>
<p>a subset of individuals to retain</p>
</td></tr>
<tr><td><code id="compoplot_+3A_show.lab">show.lab</code></td>
<td>
<p>a logical indicating if individual labels should be displayed</p>
</td></tr>
<tr><td><code id="compoplot_+3A_lab">lab</code></td>
<td>
<p>a vector of individual labels; if NULL, row.names of the matrix are used</p>
</td></tr>
<tr><td><code id="compoplot_+3A_legend">legend</code></td>
<td>
<p>a logical indicating whether a legend should be provided for the colors</p>
</td></tr>
<tr><td><code id="compoplot_+3A_txt.leg">txt.leg</code></td>
<td>
<p>a character vector to be used for the legend</p>
</td></tr>
<tr><td><code id="compoplot_+3A_n.col">n.col</code></td>
<td>
<p>the number of columns to be used for the legend</p>
</td></tr>
<tr><td><code id="compoplot_+3A_posi">posi</code></td>
<td>
<p>the position of the legend</p>
</td></tr>
<tr><td><code id="compoplot_+3A_cleg">cleg</code></td>
<td>
<p>a size factor for the legend</p>
</td></tr>
<tr><td><code id="compoplot_+3A_bg">bg</code></td>
<td>
<p>the background to be used for the legend</p>
</td></tr>
<tr><td><code id="compoplot_+3A_only.grp">only.grp</code></td>
<td>
<p>a subset of groups to retain</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>matrix</code>: a matrix with individuals in row and genetic clusters in
column, each entry being an assignment probability of the corresponding
individual to the corresponding group
</p>
</li>
<li> <p><code>dapc</code>: the output of the <code>dapc</code> function; in this case,
group assignments are based upon geometric criteria in the discriminant space
</p>
</li>
<li> <p><code>snapclust</code>: the output of the <code>snapclust</code> function; in
this case, group assignments are based upon the likelihood of genotypes
belonging to their groups
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>
</p>

<hr>
<h2 id='coords.monmonier'>Returns original points in results paths of an object of class 'monmonier'</h2><span id='topic+coords.monmonier'></span>

<h3>Description</h3>

<p>The original implementation of <code>monmonier</code> in package
<b>adegenet</b> returns path coordinates, <code>coords.monmonier</code>
additionally displays identities of the original points of the network,
based on original coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coords.monmonier(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coords.monmonier_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+monmonier">monmonier</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with elements according to the <code>x$nrun</code> result of the <code><a href="#topic+monmonier">monmonier</a></code> object.
Corresponding path points are in the same order as in the original object.
</p>
<p>run1 (run2, ...): for each run, a list containing a matrix giving the
original points in the network (<code>first</code> and <code>second</code>,
indicating pairs of neighbours). Path coordinates are stored in
columns <code>x.hw</code> and <code>y.hw</code>. <code>first</code> and <code>second</code>
are integers referring to the row numbers in the <code>x$xy</code> matrix of
the original <code><a href="#topic+monmonier">monmonier</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:Solymos.Peter@aotk.szie.hu">Solymos.Peter@aotk.szie.hu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+monmonier">monmonier</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
if(require(spdep)){

load(system.file("files/mondata1.rda",package="adegenet"))
cn1 &lt;- chooseCN(mondata1$xy,type=2,ask=FALSE)
mon1 &lt;- monmonier(mondata1$xy,dist(mondata1$x1),cn1,threshold=2,nrun=3)

mon1$run1
mon1$run2
mon1$run3
path.coords &lt;- coords.monmonier(mon1)
path.coords
}

## End(Not run)
</code></pre>

<hr>
<h2 id='dapc'>Discriminant Analysis of Principal Components (DAPC)</h2><span id='topic+dapc'></span><span id='topic+dapc.data.frame'></span><span id='topic+dapc.matrix'></span><span id='topic+dapc.genind'></span><span id='topic+dapc.dudi'></span><span id='topic+dapc.genlight'></span><span id='topic+print.dapc'></span><span id='topic+summary.dapc'></span><span id='topic+predict.dapc'></span><span id='topic+as.lda'></span><span id='topic+as.lda.dapc'></span>

<h3>Description</h3>

<p>These functions implement the Discriminant Analysis of Principal
Components (DAPC, Jombart et al. 2010). This method descibes the
diversity between pre-defined groups. When groups are unknown, use
<code>find.clusters</code> to infer genetic clusters. See 'details' section
for a succint description of the method, and
<code>vignette("adegenet-dapc")</code> for a tutorial. Graphical methods for
DAPC are documented in <code><a href="#topic+scatter.dapc">scatter.dapc</a></code> (see
<code>?scatter.dapc</code>).
</p>
<p><code>dapc</code> is a generic function performing the DAPC on the following
types of objects:<br />
- <code>data.frame</code> (only numeric data)<br />
- <code>matrix</code> (only numeric data)<br />
- <code><a href="#topic+genind-class">genind</a></code> objects (genetic markers)<br />
- <code><a href="#topic+genlight-class">genlight</a></code> objects (genome-wide SNPs)
</p>
<p>These methods all return an object with class <code>dapc</code>.
</p>
<p>Functions that can be applied to these objects are (the &quot;.dapc&quot; can be
ommitted):
</p>
<p>- <code>print.dapc</code>: prints the content of a <code>dapc</code> object.<br />
- <code>summary.dapc</code>: extracts useful information from a <code>dapc</code>
object.<br />
- <code>predict.dapc</code>: predicts group memberships based on DAPC results.<br />
- <code>xvalDapc</code>: performs cross-validation of DAPC using varying
numbers of PCs (and keeping the number of discriminant functions
fixed); it currently has methods for <code>data.frame</code> and <code>matrix</code>.<br />
</p>
<p>DAPC implementation calls upon <code><a href="ade4.html#topic+dudi.pca">dudi.pca</a></code> from the
<code>ade4</code> package (except for <a href="#topic+genlight-class">genlight</a> objects)
and <code><a href="MASS.html#topic+lda">lda</a></code> from the <code>MASS</code> package. The
<code>predict</code> procedure uses <code><a href="MASS.html#topic+predict.lda">predict.lda</a></code> from the
<code>MASS</code> package.
</p>
<p><code>as.lda</code> is a generic with a method for <code>dapc</code> object which
converts these objects into outputs similar to that of
<code>lda.default</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
dapc(x, grp, n.pca=NULL, n.da=NULL, center=TRUE,
     scale=FALSE, var.contrib=TRUE, var.loadings=FALSE, pca.info=TRUE,
     pca.select=c("nbEig","percVar"), perc.pca=NULL, ..., dudi=NULL)

## S3 method for class 'matrix'
dapc(x, ...)

## S3 method for class 'genind'
dapc(x, pop=NULL, n.pca=NULL, n.da=NULL, scale=FALSE,
     truenames=TRUE, var.contrib=TRUE, var.loadings=FALSE, pca.info=TRUE,
     pca.select=c("nbEig","percVar"), perc.pca=NULL, ...)

## S3 method for class 'genlight'
dapc(x, pop=NULL, n.pca=NULL, n.da=NULL,
   scale=FALSE, var.contrib=TRUE, var.loadings=FALSE, pca.info=TRUE,
   pca.select=c("nbEig", "percVar"), perc.pca=NULL, glPca=NULL, ...)

## S3 method for class 'dudi'
dapc(x, grp, ...)

## S3 method for class 'dapc'
print(x, ...)

## S3 method for class 'dapc'
summary(object, ...)

## S3 method for class 'dapc'
predict(object, newdata, prior = object$prior, dimen,
         method = c("plug-in", "predictive", "debiased"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dapc_+3A_x">x</code></td>
<td>
<p><code>a data.frame</code>, <code>matrix</code>, or <code><a href="#topic+genind-class">genind</a></code>
object. For the <code>data.frame</code> and <code>matrix</code> arguments, only
quantitative variables should be provided.</p>
</td></tr>
<tr><td><code id="dapc_+3A_grp">grp</code>, <code id="dapc_+3A_pop">pop</code></td>
<td>
<p>a <code>factor</code> indicating the group membership of
individuals; for <code>scatter</code>, an optional grouping of individuals.</p>
</td></tr>
<tr><td><code id="dapc_+3A_n.pca">n.pca</code></td>
<td>
<p>an <code>integer</code> indicating the number of axes retained in the
Principal Component Analysis (PCA) step. If <code>NULL</code>, interactive selection is triggered.</p>
</td></tr>
<tr><td><code id="dapc_+3A_n.da">n.da</code></td>
<td>
<p>an <code>integer</code> indicating the number of axes retained in the
Discriminant Analysis step. If <code>NULL</code>, interactive selection is triggered.</p>
</td></tr>
<tr><td><code id="dapc_+3A_center">center</code></td>
<td>
<p>a <code>logical</code> indicating whether variables should be centred to
mean 0 (TRUE, default) or not (FALSE). Always TRUE for <a href="#topic+genind-class">genind</a> objects.</p>
</td></tr>
<tr><td><code id="dapc_+3A_scale">scale</code></td>
<td>
<p>a <code>logical</code> indicating whether variables should be scaled
(TRUE) or not (FALSE, default). Scaling consists in dividing variables by their
(estimated) standard deviation to account for trivial differences in
variances.</p>
</td></tr>
<tr><td><code id="dapc_+3A_var.contrib">var.contrib</code></td>
<td>
<p>a <code>logical</code> indicating whether the
contribution of original variables (alleles, for <a href="#topic+genind-class">genind</a> objects)
should be provided (TRUE, default) or not (FALSE). Such output can be useful,
but can also create huge matrices when there is a lot of variables.</p>
</td></tr>
<tr><td><code id="dapc_+3A_var.loadings">var.loadings</code></td>
<td>
<p>a <code>logical</code> indicating whether the
loadings of original variables (alleles, for <a href="#topic+genind-class">genind</a> objects)
should be provided (TRUE) or not (FALSE, default). Such output can be useful,
but can also create huge matrices when there is a lot of variables.</p>
</td></tr>
<tr><td><code id="dapc_+3A_pca.info">pca.info</code></td>
<td>
<p>a <code>logical</code> indicating whether information about
the prior PCA should be stored (TRUE, default) or not (FALSE). This
information is required to predict group membership of new
individuals using <code>predict</code>, but makes the object slightly bigger.</p>
</td></tr>
<tr><td><code id="dapc_+3A_pca.select">pca.select</code></td>
<td>
<p>a <code>character</code> indicating the mode of selection of PCA
axes, matching either &quot;nbEig&quot; or &quot;percVar&quot;. For &quot;nbEig&quot;, the user
has to specify the number of axes retained (interactively, or via
<code>n.pca</code>). For &quot;percVar&quot;, the user has to specify the minimum amount of
the total variance to be preserved by the retained axes, expressed as a
percentage (interactively, or via <code>perc.pca</code>).  </p>
</td></tr>
<tr><td><code id="dapc_+3A_perc.pca">perc.pca</code></td>
<td>
<p>a <code>numeric</code> value between 0 and 100 indicating the
minimal percentage of the total variance of the data to be expressed by the
retained axes of PCA.</p>
</td></tr>
<tr><td><code id="dapc_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to other functions. For
<code>dapc.matrix</code>, arguments are to match those of
<code>dapc.data.frame</code>; for <code>dapc.genlight</code>, arguments passed
to <code><a href="#topic+glPca">glPca</a></code></p>
</td></tr>
<tr><td><code id="dapc_+3A_glpca">glPca</code></td>
<td>
<p>an optional <code><a href="#topic+glPca">glPca</a></code> object; if provided,
dimension reduction is not performed (saving computational time) but
taken directly from this object.</p>
</td></tr>
<tr><td><code id="dapc_+3A_object">object</code></td>
<td>
<p>a <code>dapc</code> object.</p>
</td></tr>
<tr><td><code id="dapc_+3A_truenames">truenames</code></td>
<td>
<p>a <code>logical</code> indicating whether true (i.e., user-specified)
labels should be used in object outputs (TRUE, default) or not (FALSE).</p>
</td></tr>
<tr><td><code id="dapc_+3A_dudi">dudi</code></td>
<td>
<p>optionally, a multivariate analysis with the class
<code>dudi</code> (from the ade4 package). If provided, prior PCA will be
ignored, and this object will be used as a prior step for variable
orthogonalisation.</p>
</td></tr>
<tr><td><code id="dapc_+3A_newdata">newdata</code></td>
<td>
<p>an optional dataset of individuals whose membership is
seeked; can be a data.frame, a matrix, a <a href="#topic+genind-class">genind</a> or a
<a href="#topic+genlight-class">genlight</a> object, but object class must match the
original ('training') data. In particular, variables must be exactly
the same as in the original data. For  <a href="#topic+genind-class">genind</a>
objects, see <code><a href="#topic+repool">repool</a></code> to ensure matching of alleles.</p>
</td></tr>
<tr><td><code id="dapc_+3A_prior">prior</code>, <code id="dapc_+3A_dimen">dimen</code>, <code id="dapc_+3A_method">method</code></td>
<td>
<p>see <code>?predict.lda</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Discriminant Analysis of Principal Components (DAPC) is designed
to investigate the genetic structure of biological populations. This
multivariate method consists in a two-steps procedure. First, genetic
data are transformed (centred, possibly scaled) and submitted to a
Principal Component Analysis (PCA). Second, principal components of
PCA are submitted to a Linear Discriminant Analysis (LDA). A trivial
matrix operation allows to express discriminant functions as linear
combination of alleles, therefore allowing one to compute allele
contributions. More details about the computation of DAPC are to be
found in the indicated reference.
</p>
<p>DAPC does not infer genetic clusters ex nihilo; for this, see the
<code><a href="#topic+find.clusters">find.clusters</a></code> function.
</p>


<h3>Value</h3>

<p>=== dapc objects ===<br />
The class <code>dapc</code> is a list with the following
components:<br />
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>n.pca</code></td>
<td>
<p>number of PCA axes retained</p>
</td></tr>
<tr><td><code>n.da</code></td>
<td>
<p>number of DA axes retained</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>proportion of variance conserved by PCA principal components</p>
</td></tr>
<tr><td><code>eig</code></td>
<td>
<p>a numeric vector of eigenvalues.</p>
</td></tr>
<tr><td><code>grp</code></td>
<td>
<p>a factor giving prior group assignment</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>a numeric vector giving prior group probabilities</p>
</td></tr>
<tr><td><code>assign</code></td>
<td>
<p>a factor giving posterior group assignment</p>
</td></tr>
<tr><td><code>tab</code></td>
<td>
<p>matrix of retained principal components of PCA</p>
</td></tr>
<tr><td><code>loadings</code></td>
<td>
<p>principal axes of DAPC, giving coefficients of the linear
combination of retained PCA axes.</p>
</td></tr>
<tr><td><code>ind.coord</code></td>
<td>
<p>principal components of DAPC, giving the coordinates
of individuals onto principal axes of DAPC; also called the
discriminant functions.</p>
</td></tr>
<tr><td><code>grp.coord</code></td>
<td>
<p>coordinates of the groups onto the principal axes of DAPC.</p>
</td></tr>
<tr><td><code>posterior</code></td>
<td>
<p>a data.frame giving posterior membership probabilities for
all individuals and all clusters.</p>
</td></tr>
<tr><td><code>var.contr</code></td>
<td>
<p>(optional) a data.frame giving the contributions of original
variables (alleles in the case of genetic data) to the principal components
of DAPC.</p>
</td></tr>
<tr><td><code>var.load</code></td>
<td>
<p>(optional) a data.frame giving the loadings of original
variables (alleles in the case of genetic data) to the principal components
of DAPC.</p>
</td></tr>
<tr><td><code>match.prp</code></td>
<td>
<p>a list, where each item is the proportion of individuals 
correctly matched to their original population in cross-validation.</p>
</td></tr>
</table>
<p>=== other outputs ===<br />
Other functions have different outputs:<br />
- <code>summary.dapc</code> returns a list with 6 components: <code>n.dim</code> (number
of retained DAPC axes), <code>n.pop</code> (number of groups/populations),
<code>assign.prop</code> (proportion of overall correct assignment),
<code>assign.per.pop</code> (proportion of correct assignment per group),
<code>prior.grp.size</code> (prior group sizes), and <code>post.grp.size</code> (posterior
group sizes),  <code>xval.dapc</code>, <code>xval.genind</code> and <code>xval</code>
(all return a list of four lists, each one with as many items as
cross-validation runs.  The first item is a list of <code>assign</code>
components, the secon is a list of <code>posterior</code> components, the
thirs is a list of <code>ind.score</code> components and the fourth is a
list of <code>match.prp</code> items, i.e. the prortion of the validation
set correctly matched to its original population)
</p>


<h3>Author(s)</h3>

<p> Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a> </p>


<h3>References</h3>

<p>Jombart T, Devillard S and Balloux F  (2010) Discriminant analysis of
principal components: a new method for the analysis of genetically
structured populations. BMC Genetics11:94. doi:10.1186/1471-2156-11-94
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+xvalDapc">xvalDapc</a></code>: selection of the optimal numbers of PCA axes
retained in DAPC using cross-validation.
</p>
</li>
<li> <p><code><a href="#topic+scatter.dapc">scatter.dapc</a></code>, <code><a href="#topic+assignplot">assignplot</a></code>,
<code><a href="#topic+compoplot">compoplot</a></code>: graphics for DAPC.
</p>
</li>
<li> <p><code><a href="#topic+find.clusters">find.clusters</a></code>: to identify clusters without prior.
</p>
</li>
<li> <p><code><a href="#topic+dapcIllus">dapcIllus</a></code>: a set of simulated data illustrating
the DAPC
</p>
</li>
<li> <p><code><a href="#topic+eHGDP">eHGDP</a></code>, <code><a href="#topic+H3N2">H3N2</a></code>: empirical datasets
illustrating DAPC
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## data(dapcIllus), data(eHGDP), and data(H3N2) illustrate the dapc
## see ?dapcIllus, ?eHGDP, ?H3N2
##
## Not run: 
example(dapcIllus)
example(eHGDP)
example(H3N2)

## End(Not run)

## H3N2 EXAMPLE ##
data(H3N2)
pop(H3N2) &lt;- factor(H3N2$other$epid)
dapc1 &lt;- dapc(H3N2, var.contrib=FALSE, scale=FALSE, n.pca=150, n.da=5)

## remove internal segments and ellipses, different pch, add MStree
scatter(dapc1, cell=0, pch=18:23, cstar=0, mstree=TRUE, lwd=2, lty=2)

## label individuals at the periphery
# air = 2 is a measure of how much space each label needs
# pch = NA suppresses plotting of points
scatter(dapc1, label.inds = list(air = 2, pch = NA))

## only ellipse, custom labels
scatter(dapc1, cell=2, pch="", cstar=0, posi.da="top",
        label=paste("year\n",2001:2006), axesel=FALSE, col=terrain.colors(10))


## SHOW COMPOPLOT ON MICROBOV DATA ##
data(microbov)
dapc1 &lt;- dapc(microbov, n.pca=20, n.da=15)
compoplot(dapc1, lab="")




## Not run: 
## EXAMPLE USING GENLIGHT OBJECTS ##
## simulate data
x &lt;- glSim(50,4e3-50, 50, ploidy=2)
x
plot(x)

## perform DAPC
dapc1 &lt;- dapc(x, n.pca=10, n.da=1)
dapc1

## plot results
scatter(dapc1, scree.da=FALSE)

## SNP contributions
loadingplot(dapc1$var.contr)
loadingplot(tail(dapc1$var.contr, 100), main="Loading plot - last 100 SNPs")



## USE "PREDICT" TO PREDICT GROUPS OF NEW INDIVIDUALS ##
## load data
data(sim2pop)

## we make a dataset of:
## 30 individuals from pop A
## 30 individuals from pop B
## 30 hybrids

## separate populations and make F1
temp &lt;- seppop(sim2pop)
temp &lt;- lapply(temp, function(e) hybridize(e,e,n=30)) # force equal popsizes

## make hybrids
hyb &lt;- hybridize(temp[[1]], temp[[2]], n=30)

## repool data - needed to ensure allele matching
newdat &lt;- repool(temp[[1]], temp[[2]], hyb)
pop(newdat) &lt;- rep(c("pop A", "popB", "hyb AB"), c(30,30,30))

## perform the DAPC on the first 2 pop (60 first indiv)
dapc1 &lt;- dapc(newdat[1:60],n.pca=5,n.da=1)

## plot results
scatter(dapc1, scree.da=FALSE)

## make prediction for the 30 hybrids
hyb.pred &lt;- predict(dapc1, newdat[61:90])
hyb.pred

## plot the inferred coordinates (circles are hybrids)
points(hyb.pred$ind.scores, rep(.1, 30))

## look at assignment using assignplot
assignplot(dapc1, new.pred=hyb.pred)
title("30 indiv popA, 30 indiv pop B, 30 hybrids")

## image using compoplot
compoplot(dapc1, new.pred=hyb.pred, ncol=2)
title("30 indiv popA, 30 indiv pop B, 30 hybrids")

## CROSS-VALIDATION ##
data(sim2pop)
xval &lt;- xvalDapc(sim2pop@tab, pop(sim2pop), n.pca.max=100, n.rep=3)
xval
boxplot(xval$success~xval$n.pca, xlab="Number of PCA components",
ylab="Classification succes", main="DAPC - cross-validation")


## End(Not run)


</code></pre>

<hr>
<h2 id='DAPC+20cross-validation'>Cross-validation for Discriminant Analysis of Principal Components (DAPC)</h2><span id='topic+xvalDapc'></span><span id='topic+xvalDapc.default'></span><span id='topic+xvalDapc.data.frame'></span><span id='topic+xvalDapc.matrix'></span><span id='topic+xvalDapc.genlight'></span><span id='topic+xvalDapc.genind'></span>

<h3>Description</h3>

<p>The function <code>xvalDapc</code> performs stratified cross-validation of DAPC 
using varying numbers of PCs (and keeping the number of discriminant
functions fixed); <code>xvalDapc</code> is a generic with methods for
<code>data.frame</code> and <code>matrix</code>.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xvalDapc(x, ...)

## Default S3 method:
xvalDapc(x, grp, n.pca.max = 300, n.da = NULL,
              training.set = 0.9, result = c("groupMean", "overall"),
              center = TRUE, scale = FALSE,
              n.pca=NULL, n.rep = 30, xval.plot = TRUE, ...)

## S3 method for class 'data.frame'
xvalDapc(x, grp, n.pca.max = 300, n.da = NULL,
              training.set = 0.9, result = c("groupMean", "overall"),
              center = TRUE, scale = FALSE,
              n.pca=NULL, n.rep = 30, xval.plot = TRUE, ...)

## S3 method for class 'matrix'
xvalDapc(x, grp, n.pca.max = 300, n.da = NULL,
              training.set = 0.9, result = c("groupMean", "overall"),
              center = TRUE, scale = FALSE,
              n.pca=NULL, n.rep = 30, xval.plot = TRUE, ...)

## S3 method for class 'genlight'
xvalDapc(x, ...)

## S3 method for class 'genind'
xvalDapc(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DAPC+2B20cross-validation_+3A_x">x</code></td>
<td>
<p><code>a data.frame</code> or a <code>matrix</code> used as input of DAPC.</p>
</td></tr>
<tr><td><code id="DAPC+2B20cross-validation_+3A_grp">grp</code></td>
<td>
<p>a <code>factor</code> indicating the group membership of
individuals.</p>
</td></tr>
<tr><td><code id="DAPC+2B20cross-validation_+3A_n.pca.max">n.pca.max</code></td>
<td>
<p>maximum number of PCA components to retain.</p>
</td></tr>
<tr><td><code id="DAPC+2B20cross-validation_+3A_n.da">n.da</code></td>
<td>
<p>an <code>integer</code> indicating the number of axes retained in the
Discriminant Analysis step. If <code>NULL</code>, n.da defaults to 1 less than
the number of groups.</p>
</td></tr>
<tr><td><code id="DAPC+2B20cross-validation_+3A_training.set">training.set</code></td>
<td>
<p>the proportion of data (individuals) to be used
for the training set; defaults to 0.9 if all groups have &gt;= 10 members; otherwise,
training.set scales automatically to the largest proportion that still 
ensures all groups will be present in both training and validation sets.</p>
</td></tr>
<tr><td><code id="DAPC+2B20cross-validation_+3A_result">result</code></td>
<td>
<p>a character string; &quot;groupMean&quot; for group-wise assignment
sucess, or  &quot;overall&quot; for an overall mean assignment success; see details.</p>
</td></tr>
<tr><td><code id="DAPC+2B20cross-validation_+3A_center">center</code></td>
<td>
<p>a <code>logical</code> indicating whether variables should be centred to
mean 0 (TRUE, default) or not (FALSE). Always TRUE for <a href="#topic+genind-class">genind</a> objects.</p>
</td></tr>
<tr><td><code id="DAPC+2B20cross-validation_+3A_scale">scale</code></td>
<td>
<p>a <code>logical</code> indicating whether variables should be scaled
(TRUE) or not (FALSE, default). Scaling consists in dividing variables by their
(estimated) standard deviation to account for trivial differences in
variances.</p>
</td></tr>
<tr><td><code id="DAPC+2B20cross-validation_+3A_n.pca">n.pca</code></td>
<td>
<p>an <code>integer</code> vector indicating the number of
different number of PCA axes to be retained for the cross
validation; if <code>NULL</code>, this will be dertermined automatically.</p>
</td></tr>
<tr><td><code id="DAPC+2B20cross-validation_+3A_n.rep">n.rep</code></td>
<td>
<p>the number of replicates to be carried out at each level of
PC retention; defaults to 30.</p>
</td></tr>
<tr><td><code id="DAPC+2B20cross-validation_+3A_xval.plot">xval.plot</code></td>
<td>
<p>a logical indicating whether a plot of the cross-validation
results should be generated.</p>
</td></tr>
<tr><td><code id="DAPC+2B20cross-validation_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="boot.html#topic+boot">boot</a></code>.
<strong>see Details.</strong></p>
</td></tr> </table>


<h3>Details</h3>

<p> The Discriminant Analysis of Principal Components (DAPC) relies on
dimension reduction of the data using PCA followed by a linear discriminant
analysis. How many PCA axes to retain is often a non-trivial question. Cross
validation provides an objective way to decide how many axes to retain:
different numbers are tried and the quality of the corresponding DAPC is
assessed by cross- validation: DAPC is performed on a training set, typically
made of 90% of the observations (comprising 90% of the observations in each
subpopulation) , and then used to predict the groups of the 10% of remaining
observations. The current method uses the average prediction success per group
(result=&quot;groupMean&quot;), or the overall prediction success (result=&quot;overall&quot;).
The number of PCs associated with the lowest Mean Squared Error is then
retained in the DAPC.
</p>


<h4>Parallel Computing</h4>

<p>The permutation of the data for cross-validation is performed in part by the
function<code><a href="boot.html#topic+boot">boot</a></code>. If you have a modern computer, it is
likely that you have multiple cores on your system. R by default utilizes
only one of these cores unless you tell it otherwise. For details, please
see the documentation of <code><a href="boot.html#topic+boot">boot</a></code>. Basically, if you want to
use multiple cores, you need two arguments:
</p>

<ol>
<li> <p><code>parallel</code> - what R parallel system to use (see below)
</p>
</li>
<li> <p><code>ncpus</code> - number of cores you want to use
</p>
</li></ol>
 
<p>If you are on a unix system (Linux or OSX), you will want to specify
<code>parallel = "multicore"</code>. If you are on Windows, you will want to
specify <code>parallel = "snow"</code>.
</p>
 


<h3>Value</h3>

<p>A <code>list</code> containing seven items, and a <code>plot</code> of the results. The
first is a <code>data.frame</code> with two columns, the first giving the number of
PCs of PCA retained in the corresponding DAPC, and the second giving the
proportion of successful group assignment for each replicate. The second item
gives the mean and confidence interval for random chance. The third gives the
mean successful assignment at each level of PC retention. The fourth indicates
which number of PCs is associated with the highest mean success. The fifth
gives the Root Mean Squared Error at each level of PC retention. The sixth
indicates which number of PCs is associated with the lowest MSE. The seventh
item contains the DAPC carried out with the optimal number of PCs, determined
with reference to MSE.
</p>
<p>If <code>xval.plot=TRUE</code> a scatterplot of the results of cross-validation 
will be displayed. 
</p>


<h3>Author(s)</h3>

<p> Caitlin Collins <a href="mailto:caitlin.collins12@imperial.ac.uk">caitlin.collins12@imperial.ac.uk</a>,
Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>,
Zhian N. Kamvar <a href="mailto:kamvarz@science.oregonstate.edu">kamvarz@science.oregonstate.edu</a> </p>


<h3>References</h3>

<p>Jombart T, Devillard S and Balloux F  (2010) Discriminant analysis of
principal components: a new method for the analysis of genetically
structured populations. BMC Genetics11:94. doi:10.1186/1471-2156-11-94
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dapc">dapc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## CROSS-VALIDATION ##
data(sim2pop)
xval &lt;- xvalDapc(sim2pop@tab, pop(sim2pop), n.pca.max=100, n.rep=3)
xval

## 100 replicates ##

# Serial version (SLOW!)
system.time(xval &lt;- xvalDapc(sim2pop@tab, pop(sim2pop), n.pca.max=100, n.rep=100))

# Parallel version (faster!)
system.time(xval &lt;- xvalDapc(sim2pop@tab, pop(sim2pop), n.pca.max=100, n.rep=100, 
                             parallel = "multicore", ncpus = 2))

## End(Not run)
</code></pre>

<hr>
<h2 id='dapc+20graphics'>Graphics for Discriminant Analysis of Principal Components (DAPC)</h2><span id='topic+scatter.dapc'></span><span id='topic+assignplot'></span>

<h3>Description</h3>

<p>These functions provide graphic outputs for Discriminant Analysis of
Principal Components (DAPC, Jombart et al. 2010). See <code>?dapc</code> for
details about this method. DAPC graphics are detailed in the DAPC tutorial
accessible using <code>vignette("adegenet-dapc")</code>.
</p>
<p>These functions all require an object of class <code>dapc</code>
(the &quot;.dapc&quot; can be ommitted when calling the functions):<br />
- <code>scatter.dapc</code>: produces scatterplots of principal components (or
'discriminant functions'), with a screeplot of eigenvalues as inset.<br />
- <code>assignplot</code>: plot showing the probabilities of assignment of
individuals to the different clusters.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dapc'
scatter(x, xax=1, yax=2, grp=x$grp, col=seasun(length(levels(grp))),
      pch=20, bg="white", solid=.7, scree.da=TRUE,
      scree.pca=FALSE, posi.da="bottomright",
      posi.pca="bottomleft", bg.inset="white", ratio.da=.25,
      ratio.pca=.25, inset.da=0.02, inset.pca=0.02,
      inset.solid=.5, onedim.filled=TRUE, mstree=FALSE, lwd=1,
      lty=1, segcol="black", legend=FALSE, posi.leg="topright",
      cleg=1, txt.leg=levels(grp), cstar = 1, cellipse = 1.5,
      axesell = FALSE, label = levels(grp), clabel = 1, xlim =
      NULL, ylim = NULL, grid = FALSE, addaxes = TRUE, origin =
      c(0,0), include.origin = TRUE, sub = "", csub = 1, possub =
      "bottomleft", cgrid = 1, pixmap = NULL, contour = NULL, area
      = NULL, label.inds = NULL, ...)

assignplot(x, only.grp=NULL, subset=NULL, new.pred=NULL, cex.lab=.75,pch=3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dapc+2B20graphics_+3A_x">x</code></td>
<td>
<p>a <code>dapc</code> object.</p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_xax">xax</code>, <code id="dapc+2B20graphics_+3A_yax">yax</code></td>
<td>
<p><code>integers</code> specifying which principal components of DAPC
should be shown in x and y axes. </p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_grp">grp</code></td>
<td>
<p>a factor defining group membership for the individuals. The scatterplot
is optimal only for the default group, i.e. the one used in the
DAPC analysis.</p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_col">col</code></td>
<td>
<p>a suitable color to be used for groups. The specified vector
should match the number of groups, not the number of individuals.</p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_pch">pch</code></td>
<td>
<p>a <code>numeric</code> indicating the type of point to be used to indicate
the prior group of individuals (see <code><a href="graphics.html#topic+points">points</a></code> documentation for
more details); one value is expected for each group; recycled if necessary.</p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_bg">bg</code></td>
<td>
<p>the color used for the background of the scatterplot.</p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_solid">solid</code></td>
<td>
<p>a value between 0 and 1 indicating the alpha level for the colors of
the plot; 0=full transparency, 1=solid colours.</p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_scree.da">scree.da</code></td>
<td>
<p>a logical indicating whether a screeplot of Discriminant Analysis
eigenvalues should be displayed in inset (TRUE) or not (FALSE).</p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_scree.pca">scree.pca</code></td>
<td>
<p>a logical indicating whether a screeplot of Principal Component Analysis
eigenvalues should be displayed in inset (TRUE) or not (FALSE); retained axes are
displayed in black.</p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_posi.da">posi.da</code></td>
<td>
<p>the position of the inset of DA eigenvalues; can match any
combination of &quot;top/bottom&quot; and &quot;left/right&quot;.</p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_posi.pca">posi.pca</code></td>
<td>
<p>the position of the inset of PCA eigenvalues; can match any
combination of &quot;top/bottom&quot; and &quot;left/right&quot;.</p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_bg.inset">bg.inset</code></td>
<td>
<p>the color to be used as background for the inset plots.</p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_ratio.da">ratio.da</code></td>
<td>
<p>the size of the inset of DA eigenvalues as a proportion of the
current plotting region.</p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_ratio.pca">ratio.pca</code></td>
<td>
<p>the size of the inset of PCA eigenvalues as a proportion of the
current plotting region.</p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_inset.da">inset.da</code></td>
<td>
<p>a vector with two numeric values (recycled if needed) indicating
the inset to be used for the screeplot of DA eigenvalues as a proportion of the
current plotting region; see <code>?add.scatter</code> for more details.</p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_inset.pca">inset.pca</code></td>
<td>
<p>a vector with two numeric values (recycled if needed) indicating
the inset to be used for the screeplot of PCA eigenvalues as a proportion of the
current plotting region; see <code>?add.scatter</code> for more details.</p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_inset.solid">inset.solid</code></td>
<td>
<p>a value between 0 and 1 indicating the alpha level for the colors of
the inset plots; 0=full transparency, 1=solid colours.</p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_onedim.filled">onedim.filled</code></td>
<td>
<p>a logical indicating whether curves should be filled when
plotting a single discriminant function (TRUE), or not (FALSE).</p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_mstree">mstree</code></td>
<td>
<p>a logical indicating whether a minimum spanning tree linking the
groups and based on the squared distances between the groups inside the entire
space should added to the plot (TRUE), or not (FALSE).</p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_lwd">lwd</code>, <code id="dapc+2B20graphics_+3A_lty">lty</code>, <code id="dapc+2B20graphics_+3A_segcol">segcol</code></td>
<td>
<p>the line width, line type, and segment colour to be used for
the minimum spanning tree.</p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_legend">legend</code></td>
<td>
<p>a logical indicating whether a legend for group colours should added
to the plot (TRUE), or not (FALSE).</p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_posi.leg">posi.leg</code></td>
<td>
<p>the position of the legend for group colours; can match any
combination of &quot;top/bottom&quot; and &quot;left/right&quot;, or a set of x/y coordinates stored
as a list (<code>locator</code> can be used).</p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_cleg">cleg</code></td>
<td>
<p>a size factor used for the legend.</p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_cstar">cstar</code>, <code id="dapc+2B20graphics_+3A_cellipse">cellipse</code>, <code id="dapc+2B20graphics_+3A_axesell">axesell</code>, <code id="dapc+2B20graphics_+3A_label">label</code>, <code id="dapc+2B20graphics_+3A_clabel">clabel</code>, <code id="dapc+2B20graphics_+3A_xlim">xlim</code>, <code id="dapc+2B20graphics_+3A_ylim">ylim</code>, <code id="dapc+2B20graphics_+3A_grid">grid</code>, <code id="dapc+2B20graphics_+3A_addaxes">addaxes</code>, <code id="dapc+2B20graphics_+3A_origin">origin</code>, <code id="dapc+2B20graphics_+3A_include.origin">include.origin</code>, <code id="dapc+2B20graphics_+3A_sub">sub</code>, <code id="dapc+2B20graphics_+3A_csub">csub</code>, <code id="dapc+2B20graphics_+3A_possub">possub</code>, <code id="dapc+2B20graphics_+3A_cgrid">cgrid</code>, <code id="dapc+2B20graphics_+3A_pixmap">pixmap</code>, <code id="dapc+2B20graphics_+3A_contour">contour</code>, <code id="dapc+2B20graphics_+3A_area">area</code></td>
<td>
<p>arguments
passed to <code><a href="ade4.html#topic+s.class">s.class</a></code>; see <code>?s.class</code> for more informations</p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_only.grp">only.grp</code></td>
<td>
<p>a <code>character</code> vector indicating which groups should be
displayed. Values should match values of <code>x$grp</code>. If <code>NULL</code>, all
results are displayed</p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_subset">subset</code></td>
<td>
<p><code>integer</code> or <code>logical</code> vector indicating which
individuals should be displayed. If <code>NULL</code>, all
results are displayed</p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_new.pred">new.pred</code></td>
<td>
<p>an optional list, as returned by the <code>predict</code> method for
<code>dapc</code> objects; if provided, the individuals with unknown groups are added
at the bottom of the plot. To visualize these individuals only, specify
<code>only.grp="unknown"</code>.</p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_cex.lab">cex.lab</code></td>
<td>
<p>a <code>numeric</code> indicating the size of labels.</p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_txt.leg">txt.leg</code></td>
<td>
<p>a character vector indicating the text to be used in
the legend; if not provided, group names stored in <code>x$grp</code> are
used.</p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_label.inds">label.inds</code></td>
<td>
<p>Named list of arguments passed to the 
<code><a href="vegan.html#topic+orditorp">orditorp</a></code> function. This will label individual points 
witout overlapping. Arguments <code>x</code> and <code>display</code> are hardcoded and 
should not be specified by user.</p>
</td></tr>
<tr><td><code id="dapc+2B20graphics_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to other functions. For
<code>scatter</code>, arguments passed to <code>points</code>; for <code>compoplot</code>,
arguments passed to <code>barplot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the documentation of <code><a href="#topic+dapc">dapc</a></code> for more information about the method.
</p>


<h3>Value</h3>

<p>All functions return the matched call.<br />
</p>


<h3>Author(s)</h3>

<p> Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a> </p>


<h3>References</h3>

<p>Jombart T, Devillard S and Balloux F  (2010) Discriminant analysis of
principal components: a new method for the analysis of genetically
structured populations. BMC Genetics11:94. doi:10.1186/1471-2156-11-94
</p>


<h3>See Also</h3>

<p>- <code><a href="#topic+dapc">dapc</a></code>: implements the DAPC.
</p>
<p>- <code><a href="#topic+find.clusters">find.clusters</a></code>: to identify clusters without prior.
</p>
<p>- <code><a href="#topic+dapcIllus">dapcIllus</a></code>: a set of simulated data illustrating the DAPC
</p>
<p>- <code><a href="#topic+eHGDP">eHGDP</a></code>, <code><a href="#topic+H3N2">H3N2</a></code>: empirical datasets illustrating
DAPC
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(H3N2)
dapc1 &lt;- dapc(H3N2, pop=H3N2$other$epid, n.pca=30,n.da=6)

## defautl plot ##
scatter(dapc1)

## label individuals at the periphery
# air = 2 is a measure of how much space each label needs
# pch = NA suppresses plotting of points
scatter(dapc1, label.inds = list(air = 2, pch = NA))

## showing different scatter options ##
## remove internal segments and ellipses, different pch, add MStree
scatter(dapc1, pch=18:23, cstar=0, mstree=TRUE, lwd=2, lty=2, posi.da="topleft")

## only ellipse, custom labels, use insets
scatter(dapc1, cell=2, pch="", cstar=0, posi.pca="topleft", posi.da="topleft", scree.pca=TRUE,
inset.pca=c(.01,.3), label=paste("year\n",2001:2006), axesel=FALSE, col=terrain.colors(10))

## without ellipses, use legend for groups
scatter(dapc1, cell=0, cstar=0, scree.da=FALSE, clab=0, cex=3,
solid=.4, bg="white", leg=TRUE, posi.leg="topleft")

## only one axis
scatter(dapc1,1,1,scree.da=FALSE, legend=TRUE, solid=.4,bg="white")



## example using genlight objects ##
## simulate data
x &lt;- glSim(50,4e3-50, 50, ploidy=2)
x
plot(x)

## perform DAPC
dapc2 &lt;- dapc(x, n.pca=10, n.da=1)
dapc2

## plot results
scatter(dapc2, scree.da=FALSE, leg=TRUE, txt.leg=paste("group",
c('A','B')), col=c("red","blue"))

## SNP contributions
loadingplot(dapc2$var.contr)
loadingplot(tail(dapc2$var.contr, 100), main="Loading plot - last 100 SNPs")



## assignplot / compoplot ##
assignplot(dapc1, only.grp=2006)

data(microbov)
dapc3 &lt;- dapc(microbov, n.pca=20, n.da=15)
compoplot(dapc3, lab="")

## End(Not run)
</code></pre>

<hr>
<h2 id='dapcIllus'>Simulated data illustrating the DAPC</h2><span id='topic+dapcIllus'></span>

<h3>Description</h3>

<p>Datasets illustrating the Discriminant Analysis of Principal Components
(DAPC, Jombart et al. submitted).<br />
</p>


<h3>Format</h3>

<p><code>dapcIllus</code> is list of 4 components being all genind objects.
</p>


<h3>Details</h3>

<p>These data were simulated using various models using Easypop (2.0.1).  The
<code>dapcIllus</code> is a list containing the following <a href="#topic+genind-class">genind</a>
objects:<br /> - &quot;a&quot;: island model with 6 populations <br /> - &quot;b&quot;: hierarchical
island model with 6 populations (3,2,1) <br /> - &quot;c&quot;: one-dimensional stepping
stone with 2x6 populations, and a boundary between the two sets of 6
populations<br /> - &quot;d&quot;: one-dimensional stepping stone with 24 populations<br />
</p>
<p>See &quot;source&quot; for a reference providing simulation details.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>
</p>


<h3>Source</h3>

<p>Jombart, T., Devillard, S. and Balloux, F.  Discriminant analysis of
principal components: a new method for the analysis of genetically
structured populations. Submitted to <em>BMC genetics</em>.
</p>


<h3>References</h3>

<p>Jombart, T., Devillard, S. and Balloux, F.  Discriminant
analysis of principal components: a new method for the analysis of
genetically structured populations. Submitted to <em>Genetics</em>.
</p>


<h3>See Also</h3>

<p>- <code><a href="#topic+dapc">dapc</a></code>: implements the DAPC.
</p>
<p>- <code><a href="#topic+eHGDP">eHGDP</a></code>: dataset illustrating the DAPC and
<code>find.clusters</code>.
</p>
<p>- <code><a href="#topic+H3N2">H3N2</a></code>: dataset illustrating the DAPC.
</p>
<p>- <code><a href="#topic+find.clusters">find.clusters</a></code>: to identify clusters without prior.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

data(dapcIllus)
attach(dapcIllus)
a # this is a genind object, like b, c, and d.


## FINS CLUSTERS EX NIHILO
clust.a &lt;- find.clusters(a, n.pca=100, n.clust=6)
clust.b &lt;- find.clusters(b, n.pca=100, n.clust=6)
clust.c &lt;- find.clusters(c, n.pca=100, n.clust=12)
clust.d &lt;- find.clusters(d, n.pca=100, n.clust=24)

## examin outputs
names(clust.a)
lapply(clust.a, head)


## PERFORM DAPCs
dapc.a &lt;- dapc(a, pop=clust.a$grp, n.pca=100, n.da=5)
dapc.b &lt;- dapc(b, pop=clust.b$grp, n.pca=100, n.da=5)
dapc.c &lt;- dapc(c, pop=clust.c$grp, n.pca=100, n.da=11)
dapc.d &lt;- dapc(d, pop=clust.d$grp, n.pca=100, n.da=23)


## LOOK AT ONE RESULT
dapc.a
summary(dapc.a)

## FORM A LIST OF RESULTS FOR THE 4 DATASETS
lres &lt;- list(dapc.a, dapc.b, dapc.c, dapc.d)


## DRAW 4 SCATTERPLOTS
par(mfrow=c(2,2))
lapply(lres, scatter)


# detach data
detach(dapcIllus)

## End(Not run)

</code></pre>

<hr>
<h2 id='df2genind'>Convert a data.frame of allele data to a genind object.</h2><span id='topic+df2genind'></span>

<h3>Description</h3>

<p>The function <code>df2genind</code> converts a data.frame (or a matrix) into a
<a href="#topic+genind-class">genind</a> object. The data.frame must meet the following
requirements:
</p>

<ul>
<li><p> genotypes are in row (one row per genotype)
</p>
</li>
<li><p> markers/loci are in columns
</p>
</li>
<li><p> each element is a string of characters coding alleles, ideally
separated by a character string (argument <code>sep</code>); if no separator is
used, the number of characters coding alleles must be indicated (argument
<code>ncode</code>).</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>df2genind(
  X,
  sep = NULL,
  ncode = NULL,
  ind.names = NULL,
  loc.names = NULL,
  pop = NULL,
  NA.char = "",
  ploidy = 2,
  type = c("codom", "PA"),
  strata = NULL,
  hierarchy = NULL,
  check.ploidy = getOption("adegenet.check.ploidy")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df2genind_+3A_x">X</code></td>
<td>
<p>a matrix or a data.frame containing allelle data only (see
decription)</p>
</td></tr>
<tr><td><code id="df2genind_+3A_sep">sep</code></td>
<td>
<p>a character string separating alleles. See details.</p>
</td></tr>
<tr><td><code id="df2genind_+3A_ncode">ncode</code></td>
<td>
<p>an optional integer giving the number of characters used for
coding one genotype at one locus. If not provided, this is determined from
data.</p>
</td></tr>
<tr><td><code id="df2genind_+3A_ind.names">ind.names</code></td>
<td>
<p>optinal, a vector giving the individuals names; if NULL,
taken from rownames of X. If factor or numeric, vector is converted to
character.</p>
</td></tr>
<tr><td><code id="df2genind_+3A_loc.names">loc.names</code></td>
<td>
<p>an optional character vector giving the markers names; if
NULL, taken from colnames of X.</p>
</td></tr>
<tr><td><code id="df2genind_+3A_pop">pop</code></td>
<td>
<p>an optional factor giving the population of each individual.</p>
</td></tr>
<tr><td><code id="df2genind_+3A_na.char">NA.char</code></td>
<td>
<p>a character string corresponding to missing allele (to be
treated as NA)</p>
</td></tr>
<tr><td><code id="df2genind_+3A_ploidy">ploidy</code></td>
<td>
<p>an integer indicating the degree of ploidy of the genotypes.</p>
</td></tr>
<tr><td><code id="df2genind_+3A_type">type</code></td>
<td>
<p>a character string indicating the type of marker: 'codom' stands
for 'codominant' (e.g. microstallites, allozymes); 'PA' stands for
'presence/absence' markers (e.g. AFLP, RAPD).</p>
</td></tr>
<tr><td><code id="df2genind_+3A_strata">strata</code></td>
<td>
<p>an optional data frame that defines population stratifications
for your samples. This is especially useful if you have a hierarchical or
factorial sampling design.</p>
</td></tr>
<tr><td><code id="df2genind_+3A_hierarchy">hierarchy</code></td>
<td>
<p>a hierarchical formula that explicitely defines hierarchical
levels in your strata. see <code><a href="igraph.html#topic+hierarchy">hierarchy</a></code> for details.</p>
</td></tr>
<tr><td><code id="df2genind_+3A_check.ploidy">check.ploidy</code></td>
<td>
<p>a boolean indicating if the ploidy should be checked (TRUE,
default) or not (FALSE). Not checking the ploidy makes the import much faster,
but might result in bugs/problems if the input file is misread or the ploidy is
wrong. It is therefore advised to first import and check a subset of data to 
see if everything works as expected before setting this option to false.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+genind2df">genind2df</a></code> to convert <a href="#topic+genind-class">genind</a> objects back to
such a data.frame.
</p>
<p>=== Details for the <code>sep</code> argument ===<br /> this character is directly
used in reguar expressions like <code>gsub</code>, and thus require some characters
to be preceeded by double backslashes. For instance, &quot;/&quot; works but &quot;|&quot; must
be coded as &quot;\|&quot;.
</p>


<h3>Value</h3>

<p>an object of the class <a href="#topic+genind-class">genind</a> for <code>df2genind</code>; a
matrix of biallelic genotypes for <code>genind2df</code>
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>, Zhian N. Kamvar
<a href="mailto:kamvarz@science.oregonstate.edu">kamvarz@science.oregonstate.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genind2df">genind2df</a></code>, <code><a href="#topic+import2genind">import2genind</a></code>,
<code><a href="#topic+read.genetix">read.genetix</a></code>, <code><a href="#topic+read.fstat">read.fstat</a></code>,
<code><a href="#topic+read.structure">read.structure</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## simple example
df &lt;- data.frame(locusA=c("11","11","12","32"),
locusB=c(NA,"34","55","15"),locusC=c("22","22","21","22"))
row.names(df) &lt;- .genlab("genotype",4)
df

obj &lt;- df2genind(df, ploidy=2, ncode=1)
obj
tab(obj)


## converting a genind as data.frame
genind2df(obj)
genind2df(obj, sep="/")

</code></pre>

<hr>
<h2 id='dist.genpop'> Genetic distances between populations </h2><span id='topic+dist.genpop'></span>

<h3>Description</h3>

<p>This function computes measures of genetic distances
between populations using a <code>genpop</code> object. <br />
Currently, five distances are available, some of which are euclidian
(see details).<br />
</p>
<p>A non-euclidian distance can be transformed into an Euclidean one
using <code><a href="ade4.html#topic+cailliez">cailliez</a></code> in order to perform a
Principal Coordinate Analysis <code><a href="ade4.html#topic+dudi.pco">dudi.pco</a></code> (both
functions in <code>ade4</code>). <br />
</p>
<p>The function <code>dist.genpop</code> is based on former <code>dist.genet</code>
function of <code>ade4</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.genpop(x, method = 1, diag = FALSE, upper = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist.genpop_+3A_x">x</code></td>
<td>
<p> a list of class <code>genpop</code>  </p>
</td></tr>
<tr><td><code id="dist.genpop_+3A_method">method</code></td>
<td>
<p> an integer between 1 and 5. See details </p>
</td></tr>
<tr><td><code id="dist.genpop_+3A_diag">diag</code></td>
<td>
<p> a logical value indicating whether the diagonal of the distance matrix should be printed by <code>print.dist</code> </p>
</td></tr>
<tr><td><code id="dist.genpop_+3A_upper">upper</code></td>
<td>
<p> a logical value indicating whether the upper triangle of the distance matrix should be printed by <code>print.dist</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <b>A</b> a table containing allelic frequencies with <em>t</em> populations (rows) and <em>m</em> alleles (columns).<br />
Let  <code class="reqn">\nu</code> the number of loci. The locus <em>j</em> gets <em>m(j)</em> alleles. 
<code class="reqn">m=\sum_{j=1}^{\nu} m(j)</code><br />
</p>
<p>For the row <em>i</em> and the modality <em>k</em> of the variable <em>j</em>, notice the value <code class="reqn">a_{ij}^k</code> (<code class="reqn">1 \leq i \leq t</code>, <code class="reqn">1 \leq j \leq \nu</code>,
<code class="reqn">1 \leq k \leq m(j)</code>) the value of the initial table.<br />
</p>
<p><code class="reqn">a_{ij}^+=\sum_{k=1}^{m(j)}a_{ij}^k</code> and <code class="reqn">p_{ij}^k=\frac{a_{ij}^k}{a_{ij}^+}</code><br />
</p>
<p>Let <b>P</b> the table of general term <code class="reqn">p_{ij}^k</code><br />
<code class="reqn">p_{ij}^+=\sum_{k=1}^{m(j)}p_{ij}^k=1</code>, <code class="reqn">p_{i+}^+=\sum_{j=1}^{\nu}p_{ij}^+=\nu</code>, <code class="reqn">p_{++}^+=\sum_{j=1}^{\nu}p_{i+}^+=t\nu</code><br />
</p>
<p>The option <code>method</code> computes the distance matrices between populations using the frequencies <code class="reqn">p_{ij}^k</code>. <br />
</p>
<p>1. Nei's distance (not Euclidean): <br />
<code class="reqn">D_1(a,b)=- \ln(\frac{\sum_{k=1}^{\nu} \sum_{j=1}^{m(k)}
p_{aj}^k p_{bj}^k}{\sqrt{\sum_{k=1}^{\nu} \sum_{j=1}^{m(k)}
{(p_{aj}^k) }^2}\sqrt{\sum_{k=1}^{\nu} \sum_{j=1}^{m(k)}
{(p_{bj}^k)}^2}})</code><br />
</p>
<p>2. Angular distance or Edwards' distance (Euclidean):<br />
<code class="reqn">D_2(a,b)=\sqrt{1-\frac{1}{\nu} \sum_{k=1}^{\nu}
\sum_{j=1}^{m(k)} \sqrt{p_{aj}^k  p_{bj}^k}}</code><br />
</p>
<p>3. Coancestrality coefficient or Reynolds' distance (Eucledian):<br />
<code class="reqn">D_3(a,b)=\sqrt{\frac{\sum_{k=1}^{\nu}
\sum_{j=1}^{m(k)}{(p_{aj}^k - p_{bj}^k)}^2}{2 \sum_{k=1}^{\nu} (1-
\sum_{j=1}^{m(k)}p_{aj}^k p_{bj}^k)}}</code><br />
</p>
<p>4. Classical Euclidean distance or Rogers' distance (Eucledian):<br />
<code class="reqn">D_4(a,b)=\frac{1}{\nu} \sum_{k=1}^{\nu} \sqrt{\frac{1}{2}
\sum_{j=1}^{m(k)}{(p_{aj}^k - p_{bj}^k)}^2}</code><br />
</p>
<p>5. Absolute genetics distance or Provesti 's distance (not Euclidean):<br />
<code class="reqn">D_5(a,b)=\frac{1}{2{\nu}} \sum_{k=1}^{\nu} \sum_{j=1}^{m(k)}
|p_{aj}^k - p_{bj}^k|</code>
</p>


<h3>Value</h3>

<p>returns a distance matrix of class <code>dist</code> between the rows of the data frame
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a><br />
Former dist.genet code by Daniel Chessel <a href="mailto:chessel@biomserv.univ-lyon1.fr">chessel@biomserv.univ-lyon1.fr</a><br />
and documentation by Anne B. Dufour <a href="mailto:dufour@biomserv.univ-lyon1.fr">dufour@biomserv.univ-lyon1.fr</a>
</p>


<h3>References</h3>

 
<p>To complete informations about distances:<br />
</p>
<p>Distance 1:<br />
Nei, M. (1972) Genetic distances between populations. <em>American Naturalist</em>, <b>106</b>, 283&ndash;292. <br />
Nei M. (1978) Estimation of average heterozygosity and genetic distance from a small number of individuals. <em>Genetics</em>, <b>23</b>, 341&ndash;369. <br />
Avise, J. C. (1994) Molecular markers, natural history and evolution. Chapman &amp; Hall, London. 
</p>
<p>Distance 2:<br />
Edwards, A.W.F. (1971) Distance between populations on the basis of gene frequencies. <em>Biometrics</em>, <b>27</b>, 873&ndash;881. <br />
Cavalli-Sforza L.L. and Edwards A.W.F. (1967) Phylogenetic analysis: models and estimation procedures. <em>Evolution</em>, <b>32</b>, 550&ndash;570. <br />
Hartl, D.L. and Clark, A.G. (1989) Principles of population genetics. Sinauer Associates, Sunderland, Massachussetts (p. 303).
</p>
<p>Distance 3:<br />
Reynolds, J. B., B. S. Weir, and C. C. Cockerham. (1983) Estimation of the coancestry coefficient: basis for a short-term genetic distance. <em>Genetics</em>, <b>105</b>, 767&ndash;779.
</p>
<p>Distance 4:<br />
Rogers, J.S. (1972) Measures of genetic similarity and genetic distances. <em>Studies in Genetics</em>, Univ. Texas Publ., <b>7213</b>, 145&ndash;153.  <br />
Avise, J. C. (1994) Molecular markers, natural history and evolution. Chapman &amp; Hall, London. 
</p>
<p>Distance 5:<br />
Prevosti A. (1974) La distancia genetica entre poblaciones. <em>Miscellanea Alcobe</em>, <b>68</b>, 109&ndash;118. <br />
Prevosti A., Ocaña J. and Alonso G. (1975) Distances between populations of Drosophila subobscura, based on chromosome arrangements frequencies. <em>Theoretical and Applied Genetics</em>, <b>45</b>, 231&ndash;241. <br />
</p>
<p>For more information on dissimilarity indexes:<br />
Gower J. and Legendre P. (1986) Metric and Euclidean properties of
dissimilarity coefficients. <em>Journal of Classification</em>, <b>3</b>,
5&ndash;48 <br />
</p>
<p>Legendre P. and Legendre L. (1998) <em>Numerical Ecology</em>, Elsevier
Science B.V. 20, pp274&ndash;288.<br /> 
</p>


<h3>See Also</h3>

 <p><code><a href="ade4.html#topic+cailliez">cailliez</a></code>,<code><a href="ade4.html#topic+dudi.pco">dudi.pco</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(microsatt)
obj &lt;- as.genpop(microsatt$tab)

listDist &lt;- lapply(1:5, function(i) cailliez(dist.genpop(obj,met=i)))
for(i in 1:5) {attr(listDist[[i]],"Labels") &lt;- popNames(obj)}
listPco &lt;- lapply(listDist, dudi.pco,scannf=FALSE)

par(mfrow=c(2,3))
for(i in 1:5) {scatter(listPco[[i]],sub=paste("Dist:", i))}


## End(Not run)
</code></pre>

<hr>
<h2 id='eHGDP'>Extended HGDP-CEPH dataset</h2><span id='topic+eHGDP'></span>

<h3>Description</h3>

<p>This dataset consists of 1350 individuals from native Human populations
distributed worldwide typed at 678 microsatellite loci. The original
HGDP-CEPH panel [1-3] has been extended by several native American
populations [4]. This dataset was used to illustrate the Discriminant
Analysis of Principal Components (DAPC, [5]).
</p>


<h3>Format</h3>

<p><code>eHGDP</code> is a genind object with a data frame named
<code>popInfo</code> as supplementary component (<code>eHGDP@other$popInfo</code>),
which contains the following variables: </p>
 <dl>
<dt>Population: </dt><dd><p>a
character vector indicating populations.</p>
</dd> <dt>Region: </dt><dd><p>a character vector
indicating the geographic region of each population.</p>
</dd> <dt>Label: </dt><dd><p>a
character vector indicating the correspondence with population labels used
in the genind object (i.e., as output by <code>pop(eHGDP)</code>).</p>
</dd>
<dt>Latitude,Longitude: </dt><dd><p>geographic coordinates of the populations,
indicated as north and east degrees.</p>
</dd> </dl>



<h3>Source</h3>

<p>Original panel by Human Genome Diversity Project (HGDP) and Centre
d'Etude du Polymorphisme Humain (CEPH). See reference [4] for Native
American populations.
</p>
<p>This copy of the dataset was prepared by Francois Balloux.
</p>


<h3>References</h3>

<p>[1] Rosenberg NA, Pritchard JK, Weber JL, Cann HM, Kidd KK, et
al. (2002) Genetic structure of human populations. <em>Science</em> 298:
2381-2385.
</p>
<p>[2] Ramachandran S, Deshpande O, Roseman CC, Rosenberg NA, Feldman MW, et
al. (2005) Support from the relationship of genetic and geographic distance
in human populations for a serial founder effect originating in Africa.
<em>Proc Natl Acad Sci U S A</em> 102: 15942-15947.
</p>
<p>[3] Cann HM, de Toma C, Cazes L, Legrand MF, Morel V, et al. (2002) A human
genome diversity cell line panel.  <em>Science</em> 296: 261-262.
</p>
<p>[4] Wang S, Lewis CM, Jakobsson M, Ramachandran S, Ray N, et al. (2007)
Genetic Variation and Population Structure in Native Americans. <em>PLoS
Genetics</em> 3: e185.
</p>
<p>[5] Jombart, T., Devillard, S. and Balloux, F.  Discriminant analysis of
principal components: a new method for the analysis of genetically
structured populations. Submitted to <em>BMC genetics</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## LOAD DATA
data(eHGDP)
eHGDP


## PERFORM DAPC - USE POPULATIONS AS CLUSTERS
## to reproduce exactly analyses from the paper, use "n.pca=1000"
dapc1 &lt;- dapc(eHGDP, all.contrib=TRUE, scale=FALSE,
n.pca=200, n.da=80) # takes 2 minutes
dapc1

## (see ?dapc for details about the output)



## SCREEPLOT OF EIGENVALUES
barplot(dapc1$eig, main="eHGDP - DAPC eigenvalues",
col=c("red","green","blue", rep("grey", 1000)))



## SCATTERPLOTS
## (!) Note: colors may be inverted with respect to [5]
## as signs of principal components are arbitrary
## and change from one computer to another
##
## axes 1-2
s.label(dapc1$grp.coord[,1:2], clab=0, sub="Axes 1-2")
par(xpd=T)
colorplot(dapc1$grp.coord[,1:2], dapc1$grp.coord, cex=3, add=TRUE)
add.scatter.eig(dapc1$eig,10,1,2, posi="bottomright", ratio=.3, csub=1.25)

## axes 2-3
s.label(dapc1$grp.coord[,2:3], clab=0, sub="Axes 2-3")
par(xpd=T)
colorplot(dapc1$grp.coord[,2:3], dapc1$grp.coord, cex=3, add=TRUE)
add.scatter.eig(dapc1$eig,10,1,2, posi="bottomright", ratio=.3, csub=1.25)



## MAP DAPC1 RESULTS
if(require(maps)){

xy &lt;- cbind(eHGDP$other$popInfo$Longitude, eHGDP$other$popInfo$Latitude)

par(mar=rep(.1,4))
map(fill=TRUE, col="lightgrey")
colorplot(xy, -dapc1$grp.coord, cex=3, add=TRUE, trans=FALSE)
}



## LOOK FOR OTHER CLUSTERS
## to reproduce results of the reference paper, use :
## grp &lt;- find.clusters(eHGDP, max.n=50, n.pca=200, scale=FALSE)
## and then
## plot(grp$Kstat, type="b", col="blue")

grp &lt;- find.clusters(eHGDP, max.n=30, n.pca=200,
scale=FALSE, n.clust=4) # takes about 2 minutes
names(grp)

## (see ?find.clusters for details about the output)



## PERFORM DAPC - USE POPULATIONS AS CLUSTERS
## to reproduce exactly analyses from the paper, use "n.pca=1000"
dapc2 &lt;- dapc(eHGDP, pop=grp$grp, all.contrib=TRUE,
scale=FALSE, n.pca=200, n.da=80) # takes around a 1 minute
dapc2


## PRODUCE SCATTERPLOT
scatter(dapc2) # axes 1-2
scatter(dapc2,2,3) # axes 2-3


## MAP DAPC2 RESULTS
if(require(maps)){
xy &lt;- cbind(eHGDP$other$popInfo$Longitude,
eHGDP$other$popInfo$Latitude)

myCoords &lt;- apply(dapc2$ind.coord, 2, tapply, pop(eHGDP), mean)

par(mar=rep(.1,4))
map(fill=TRUE, col="lightgrey")
colorplot(xy, myCoords, cex=3, add=TRUE, trans=FALSE)
}


## End(Not run)

</code></pre>

<hr>
<h2 id='export_to_mvmapper'>Export analysis for mvmapper visualisation</h2><span id='topic+export_to_mvmapper'></span><span id='topic+export_to_mvmapper.default'></span><span id='topic+export_to_mvmapper.dapc'></span><span id='topic+export_to_mvmapper.dudi'></span><span id='topic+export_to_mvmapper.spca'></span>

<h3>Description</h3>

<p><code>mvmapper</code> is an interactive tool for visualising outputs of a
multivariate analysis on a map from a web browser. The function
<code>export_to_mvmapper</code> is a generic with methods for several standard
classes of analyses in <code>adegenet</code> and <code>ade4</code>. Information on
individual locations, as well as any other relevant data, is passed through
the second argument <code>info</code>. By default, the function returns a formatted
<code>data.frame</code> and writes the output to a .csv file.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_to_mvmapper(x, ...)

## Default S3 method:
export_to_mvmapper(x, ...)

## S3 method for class 'dapc'
export_to_mvmapper(x, info, write_file = TRUE, out_file = NULL, ...)

## S3 method for class 'dudi'
export_to_mvmapper(x, info, write_file = TRUE, out_file = NULL, ...)

## S3 method for class 'spca'
export_to_mvmapper(x, info, write_file = TRUE, out_file = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_to_mvmapper_+3A_x">x</code></td>
<td>
<p>The analysis to be exported. Can be a <code>dapc</code>, <code>spca</code>, or a
<code>dudi</code> object.</p>
</td></tr>
<tr><td><code id="export_to_mvmapper_+3A_...">...</code></td>
<td>
<p>Further arguments to pass to other methods.</p>
</td></tr>
<tr><td><code id="export_to_mvmapper_+3A_info">info</code></td>
<td>
<p>A <code>data.frame</code> with additional information containing at
least the following columns: <code>key</code> (unique individual identifier),
<code>lat</code> (latitude), and <code>lon</code> (longitude). Other columns will be
exported as well, but are optional.</p>
</td></tr>
<tr><td><code id="export_to_mvmapper_+3A_write_file">write_file</code></td>
<td>
<p>A <code>logical</code> indicating if the output should be written
out to a .csv file. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="export_to_mvmapper_+3A_out_file">out_file</code></td>
<td>
<p>A character string indicating the file to which the output
should be written. If NULL, the file used will be named
<code>'mvmapper_data_[date and time].csv'</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mvmapper</code> can be found at:
<a href="https://popphylotools.github.io/mvMapper/">https://popphylotools.github.io/mvMapper/</a>
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> which can serve as input to <code>mvmapper</code>,
containing at least the following columns:
</p>

<ul>
<li> <p><code>key</code>: unique individual identifiers
</p>
</li>
<li> <p><code>PC1</code>: first principal component; further principal components are
optional, but if provided will be numbered and follow <code>PC1</code>.
</p>
</li>
<li> <p><code>lat</code>: latitude for each individual
</p>
</li>
<li> <p><code>lon</code>: longitude for each individual
</p>
</li></ul>

<p>In addition, specific information is added for some analyses:
</p>

<ul>
<li> <p><code>spca</code>: <code>Lag_PC</code> columns contain the lag-vectors of the
principal components; the lag operator computes, for each individual, the
average score of neighbouring individuals; it is useful for clarifying
patches and clines.
</p>
</li>
<li> <p><code>dapc</code>: <code>grp</code> is the group used in the analysis;
<code>assigned_grp</code> is the group assignment based on the discriminant
functions; <code>support</code> is the statistical support (i.e. assignment
probability) for <code>assigned_grp</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code>mvmapper</code> is available at:
<a href="https://popphylotools.github.io/mvMapper/">https://popphylotools.github.io/mvMapper/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# An example using the microsatellite dataset of Dupuis et al. 2016 (781
# individuals, 10 loci, doi: 10.1111/jeb.12931)

# Reading input file from adegenet

input_data &lt;- system.file("data/swallowtails.rda", package="adegenet")
data(swallowtails)


# conducting a DAPC (n.pca determined using xvalDapc, see ??xvalDapc)

dapc1 &lt;- dapc(swallowtails, n.pca=40, n.da=200)


# read in swallowtails_loc.csv, which contains "key", "lat", and "lon"
# columns with column headers (this example contains additional columns
# containing species identifications, locality descriptions, and COI
# haplotype clades)

input_locs &lt;- system.file("files/swallowtails_loc.csv", package = "adegenet")
loc &lt;- read.csv(input_locs, header = TRUE)


# generate mvmapper input file, automatically write the output to a csv, and
# name the output csv "mvMapper_Data.csv"
out_dir &lt;- tempdir()
out_file &lt;- file.path(out_dir, "mvMapper_Data.csv")

out &lt;- export_to_mvmapper(dapc1, loc, write_file = TRUE, out_file = out_file)

</code></pre>

<hr>
<h2 id='extract.PLINKmap'>Reading PLINK Single Nucleotide Polymorphism data</h2><span id='topic+extract.PLINKmap'></span><span id='topic+read.PLINK'></span><span id='topic+read.plink'></span>

<h3>Description</h3>

<p>The function <code>read.PLINK</code> reads a data file exported by the PLINK
software with extension '.raw' and converts it into a <code>"<a href="#topic+genlight-class">genlight</a>"</code>
object. Optionally, information about SNPs can be read from a &quot;.map&quot; file,
either by specifying the argument <code>map.file</code> in <code>read.PLINK</code>, or
using <code>extract.PLINKmap</code> to add information to an existing
<code>"<a href="#topic+genlight-class">genlight</a>"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract.PLINKmap(file, x = NULL)

read.PLINK(
  file,
  map.file = NULL,
  quiet = FALSE,
  chunkSize = 1000,
  parallel = FALSE,
  n.cores = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.PLINKmap_+3A_file">file</code></td>
<td>
<p>for <code>read.PLINK</code> a character string giving the path to the
file to convert, with the extension &quot;.raw&quot;; for <code>extract.PLINKmap</code>, a
character string giving the path to a file with extension &quot;.map&quot;.</p>
</td></tr>
<tr><td><code id="extract.PLINKmap_+3A_x">x</code></td>
<td>
<p>an optional object of the class <code>"<a href="#topic+genlight-class">genlight</a>"</code>, in which
the information read is stored; if provided, information is matched against
the names of the loci in <code>x</code>, as returned by <code>locNames(x)</code>; if not
provided, a list of two components is returned, containing chromosome and
position information.</p>
</td></tr>
<tr><td><code id="extract.PLINKmap_+3A_map.file">map.file</code></td>
<td>
<p>an optional character string indicating the path to a &quot;.map&quot;
file, which contains information about the SNPs (chromosome, position). If
provided, this information is processed by <code>extract.PLINKmap</code> and
stored in the <code>@other</code> slot.</p>
</td></tr>
<tr><td><code id="extract.PLINKmap_+3A_quiet">quiet</code></td>
<td>
<p>logical stating whether a conversion messages should be printed
(TRUE,default) or not (FALSE).</p>
</td></tr>
<tr><td><code id="extract.PLINKmap_+3A_chunksize">chunkSize</code></td>
<td>
<p>an integer indicating the number of genomes to be read at a
time; larger values require more RAM but decrease the time needed to read
the data.</p>
</td></tr>
<tr><td><code id="extract.PLINKmap_+3A_parallel">parallel</code></td>
<td>
<p>a logical indicating whether multiple cores -if available-
should be used for the computations (TRUE, default), or not (FALSE);
requires the package <code>parallel</code> to be installed (see details).</p>
</td></tr>
<tr><td><code id="extract.PLINKmap_+3A_n.cores">n.cores</code></td>
<td>
<p>if <code>parallel</code> is TRUE, the number of cores to be used in
the computations; if NULL, then the maximum number of cores available on the
computer is used.</p>
</td></tr>
<tr><td><code id="extract.PLINKmap_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to other functions - currently not
used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function reads data by chunks of several genomes (minimum 1, no maximum)
at a time, which allows one to read massive datasets with negligible RAM
requirements (albeit at a cost of computational time). The argument
<code>chunkSize</code> indicates the number of genomes read at a time. Increasing
this value decreases the computational time required to read data in, while
increasing memory requirements.
</p>
<p>See details for the documentation about how to export data using PLINK to
the '.raw' format.
</p>
<p>=== Exporting data from PLINK ===
</p>
<p>Data need to be exported from PLINK using the option &quot;&ndash;recodeA&quot; (and NOT
&quot;&ndash;recodeAD&quot;). The PLINK command should therefore look like: <code>plink
--file data --recodeA</code>. For more information on this topic, please look at
this webpage: <a href="http://zzz.bwh.harvard.edu/plink/">http://zzz.bwh.harvard.edu/plink/</a>
</p>


<h3>Value</h3>

<p>- read.PLINK: an object of the class <code>"<a href="#topic+genlight-class">genlight</a>"</code>
</p>
<p>- extract.PLINKmap: if a <code>"<a href="#topic+genlight-class">genlight</a>"</code> is provided as argument
<code>x</code>, this object incorporating the new information about SNPs in the
<code>@other</code> slot (with new components 'chromosome' and 'position');
otherwise, a list with two components containing chromosome and position
information.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>
</p>


<h3>See Also</h3>

<p>- <code>?genlight</code> for a description of the class
<code>"<a href="#topic+genlight-class">genlight</a>"</code>.
</p>
<p>- <code><a href="#topic+read.snp">read.snp</a></code>: read SNPs in adegenet's '.snp' format.
</p>
<p>- <code><a href="#topic+fasta2genlight">fasta2genlight</a></code>: extract SNPs from alignments with fasta
format.
</p>
<p>- other import function in adegenet: <code><a href="#topic+import2genind">import2genind</a></code>,
<code><a href="#topic+df2genind">df2genind</a></code>, <code><a href="#topic+read.genetix">read.genetix</a></code>
<code><a href="#topic+read.fstat">read.fstat</a></code>, <code><a href="#topic+read.structure">read.structure</a></code>,
<code><a href="#topic+read.genepop">read.genepop</a></code>.
</p>
<p>- another function <code>read.plink</code> is available in the package
<code>snpMatrix</code>.
</p>

<hr>
<h2 id='fasta2DNAbin'> Read large DNA alignments into R</h2><span id='topic+fasta2DNAbin'></span>

<h3>Description</h3>

<p>The function <code>fasta2DNAbin</code> reads alignments with the fasta
format (extensions &quot;.fasta&quot;, &quot;.fas&quot;, or &quot;.fa&quot;), and outputs a
<code><a href="ape.html#topic+DNAbin">DNAbin</a></code> object (the efficient DNA representation from the
ape package). The output contains either the full alignments, or only
SNPs. This implementation is designed for memory-efficiency,
and can read in larger datasets than Ape's <code><a href="ape.html#topic+read.dna">read.dna</a></code>.
</p>
<p>The function reads data by chunks of a few genomes (minimum 1, no
maximum) at a time, which allows one to read massive datasets with
negligible RAM requirements (albeit at a cost of computational
time). The argument <code>chunkSize</code> indicates the number of genomes
read at a time. Increasing this value decreases the computational time
required to read data in, while increasing memory requirements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fasta2DNAbin(file, quiet=FALSE, chunkSize=10, snpOnly=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fasta2DNAbin_+3A_file">file</code></td>
<td>
<p> a character string giving the path to the file to
convert, with the extension &quot;.fa&quot;, &quot;.fas&quot;, or &quot;.fasta&quot;.
</p>
<p>Can also be a <a href="base.html#topic+connection">connection</a> (which will be opened for reading if
necessary, and if so <code><a href="base.html#topic+close">close</a></code>d (and hence destroyed) at the
end of the function call).</p>
</td></tr>
<tr><td><code id="fasta2DNAbin_+3A_quiet">quiet</code></td>
<td>
<p>a logical stating whether a conversion messages should be
printed (FALSE, default) or not (TRUE).</p>
</td></tr>
<tr><td><code id="fasta2DNAbin_+3A_chunksize">chunkSize</code></td>
<td>
<p>an integer indicating the number of genomes to be
read at a time; larger values require more RAM but decrease the time
needed to read the data.</p>
</td></tr>
<tr><td><code id="fasta2DNAbin_+3A_snponly">snpOnly</code></td>
<td>
<p>a logical indicating whether SNPs only should be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of the class <code><a href="ape.html#topic+DNAbin">DNAbin</a></code></p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a> </p>


<h3>See Also</h3>

<p>- <code>?DNAbin</code> for a description of the class <code><a href="ape.html#topic+DNAbin">DNAbin</a></code>.
</p>
<p>- <code><a href="#topic+read.snp">read.snp</a></code>: read SNPs in adegenet's '.snp' format.
</p>
<p>- <code><a href="#topic+read.PLINK">read.PLINK</a></code>: read SNPs in PLINK's '.raw' format.
</p>
<p>- <code><a href="#topic+df2genind">df2genind</a></code>: convert any multiallelic markers into
adegenet <a href="#topic+genind-class">genind</a>.
</p>
<p>- <code><a href="#topic+import2genind">import2genind</a></code>: read multiallelic markers from various
software into adegenet.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## show the example file ##
## this is the path to the file:
myPath &lt;- system.file("files/usflu.fasta",package="adegenet")
myPath

## read the file
obj &lt;- fasta2DNAbin(myPath, chunk=10) # process 10 sequences at a time
obj

## End(Not run)
</code></pre>

<hr>
<h2 id='fasta2genlight'> Extract Single Nucleotide Polymorphism (SNPs) from alignments</h2><span id='topic+fasta2genlight'></span>

<h3>Description</h3>

<p>The function <code>fasta2genlight</code> reads alignments with the fasta
format (extensions &quot;.fasta&quot;, &quot;.fas&quot;, or &quot;.fa&quot;), extracts the binary
SNPs, and converts the output into a <a href="#topic+genlight-class">genlight</a> object. 
</p>
<p>The function reads data by chunks of a few genomes (minimum 1, no
maximum) at a time, which allows one to read massive datasets with
negligible RAM requirements (albeit at a cost of computational
time). The argument <code>chunkSize</code> indicates the number of genomes
read at a time. Increasing this value decreases the computational time
required to read data in, while increasing memory requirements.
</p>
<p>Multiple cores can be used to decrease the overall computational time
on parallel architectures (needs the package <code>parallel</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fasta2genlight(file, quiet = FALSE, chunkSize = 1000, saveNbAlleles = FALSE,
               parallel = FALSE, n.cores = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fasta2genlight_+3A_file">file</code></td>
<td>
<p> a character string giving the path to the file to
convert, with the extension &quot;.fa&quot;, &quot;.fas&quot;, or &quot;.fasta&quot;.</p>
</td></tr>
<tr><td><code id="fasta2genlight_+3A_quiet">quiet</code></td>
<td>
<p> logical stating whether a conversion messages should be
printed (FALSE,default) or not (TRUE).</p>
</td></tr>
<tr><td><code id="fasta2genlight_+3A_chunksize">chunkSize</code></td>
<td>
<p>an integer indicating the number of genomes to be
read at a time; larger values require more RAM but decrease the time
needed to read the data.</p>
</td></tr>
<tr><td><code id="fasta2genlight_+3A_savenballeles">saveNbAlleles</code></td>
<td>
<p>a logical indicating whether the number of
alleles for each loci in the original alignment should be saved in the
<code>other</code> slot (TRUE), or not (FALSE, default). In large genomes,
this takes some space but allows for tracking SNPs with more than 2
alleles, lost during the conversion.</p>
</td></tr>
<tr><td><code id="fasta2genlight_+3A_parallel">parallel</code></td>
<td>
<p>a logical indicating whether multiple cores -if
available- should be used for the computations (TRUE, default), or
not (FALSE); requires the package <code>parallel</code> to be installed
(see details).</p>
</td></tr>
<tr><td><code id="fasta2genlight_+3A_n.cores">n.cores</code></td>
<td>
<p>if <code>parallel</code> is TRUE, the number of cores to be
used in the computations; if NULL, then the maximum number of cores
available on the computer is used.</p>
</td></tr>
<tr><td><code id="fasta2genlight_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to other functions -
currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>=== Using multiple cores ===
</p>
<p>Most recent machines have one or several processors with multiple
cores. R processes usually use one single core. The package
<code>parallel</code> allows for parallelizing some computations on
multiple cores, which decreases drastically computational time.
</p>
<p>To use this functionality, you need to have the last version of the
<code>parallel</code> package installed.
</p>


<h3>Value</h3>

<p>an object of the class <a href="#topic+genlight-class">genlight</a></p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a> </p>


<h3>See Also</h3>

<p>- <code>?genlight</code> for a description of the class <a href="#topic+genlight-class">genlight</a>.
</p>
<p>- <code><a href="#topic+read.snp">read.snp</a></code>: read SNPs in adegenet's '.snp' format.
</p>
<p>- <code><a href="#topic+read.PLINK">read.PLINK</a></code>: read SNPs in PLINK's '.raw' format.
</p>
<p>- <code><a href="#topic+df2genind">df2genind</a></code>: convert any multiallelic markers into
adegenet <a href="#topic+genind-class">genind</a>.
</p>
<p>- <code><a href="#topic+import2genind">import2genind</a></code>: read multiallelic markers from various
software into adegenet.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## show the example file ##
## this is the path to the file:
myPath &lt;- system.file("files/usflu.fasta",package="adegenet")
myPath

## read the file
obj &lt;- fasta2genlight(myPath, chunk=10) # process 10 sequences at a time
obj

## look at extracted information
position(obj)
alleles(obj)
locNames(obj)

## plot positions of polymorphic sites
temp &lt;- density(position(obj), bw=10)
plot(temp, xlab="Position in the alignment", lwd=2, main="Location of the SNPs")
points(position(obj), rep(0, nLoc(obj)), pch="|", col="red")

## End(Not run)
</code></pre>

<hr>
<h2 id='find.clusters'>find.cluster: cluster identification using successive K-means</h2><span id='topic+find.clusters'></span><span id='topic+find.clusters.data.frame'></span><span id='topic+find.clusters.matrix'></span><span id='topic+find.clusters.genind'></span><span id='topic+find.clusters.genlight'></span><span id='topic+.find.sub.clusters'></span>

<h3>Description</h3>

<p>These functions implement the clustering procedure used in Discriminant Analysis
of Principal Components (DAPC, Jombart et al. 2010). This procedure consists in
running successive K-means with an increasing number of clusters (<code>k</code>),
after transforming data using a principal component analysis (PCA). For each
model, a statistical measure of goodness of fit (by default, BIC) is computed,
which allows to choose the optimal <code>k</code>. See <code>details</code> for a
description of how to select the optimal <code>k</code> and
<code>vignette("adegenet-dapc")</code> for a tutorial.
</p>
<p>Optionally, hierarchical clustering can be sought by providing a prior
clustering of individuals (argument <code>clust</code>). In such case, clusters will
be sought within each prior group.
</p>
<p>The K-means procedure used in <code>find.clusters</code> is
<code><a href="stats.html#topic+kmeans">kmeans</a></code> function from the <code>stats</code> package. The PCA
function is <code><a href="ade4.html#topic+dudi.pca">dudi.pca</a></code> from the <code>ade4</code> package, except
for <a href="#topic+genlight-class">genlight</a> objects which use the <code><a href="#topic+glPca">glPca</a></code> procedure
from adegenet.
</p>
<p><code>find.clusters</code> is a generic function with methods for the
following types of objects:<br />
</p>

<ul>
<li> <p><code>data.frame</code> (only numeric data)<br />
</p>
</li>
<li> <p><code>matrix</code> (only numeric data)<br />
</p>
</li>
<li> <p><code><a href="#topic+genind-class">genind</a></code> objects (genetic markers)<br />
</p>
</li>
<li> <p><code><a href="#topic+genlight-class">genlight</a></code> objects (genome-wide SNPs)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'data.frame'
find.clusters(x, clust = NULL, n.pca = NULL, n.clust =
              NULL, method = c("kmeans", "ward"), stat = c("BIC","AIC", "WSS"),
              choose.n.clust = TRUE, criterion = c("diffNgroup", "min","goesup",
              "smoothNgoesup", "goodfit"), max.n.clust = round(nrow(x)/10),
              n.iter = 1e5, n.start = 10, center = TRUE, scale = TRUE,
              pca.select = c("nbEig","percVar"), perc.pca = NULL, ..., dudi =
              NULL)

## S3 method for class 'matrix'
find.clusters(x, ...)

## S3 method for class 'genind'
find.clusters(x, clust = NULL, n.pca = NULL, n.clust = NULL,
              method = c("kmeans", "ward"), stat = c("BIC","AIC", "WSS"),
              choose.n.clust = TRUE, criterion = c("diffNgroup", "min","goesup",
              "smoothNgoesup", "goodfit"), max.n.clust = round(nrow(x@tab)/10),
              n.iter = 1e5, n.start = 10, scale = FALSE, truenames = TRUE,
              ...)

## S3 method for class 'genlight'
find.clusters(x, clust = NULL, n.pca = NULL, n.clust = NULL,
              method = c("kmeans", "ward"), stat = c("BIC", "AIC", "WSS"),
              choose.n.clust = TRUE, criterion = c("diffNgroup",
              "min","goesup","smoothNgoesup", "goodfit"), max.n.clust =
              round(nInd(x)/10), n.iter = 1e5,n.start = 10, scale = FALSE,
              pca.select = c("nbEig","percVar"), perc.pca = NULL,glPca=NULL,
              ...) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.clusters_+3A_x">x</code></td>
<td>
<p><code>a data.frame</code>, <code>matrix</code>, or <code><a href="#topic+genind-class">genind</a></code>
object. For the <code>data.frame</code> and <code>matrix</code> arguments, only
quantitative variables should be provided.</p>
</td></tr>
<tr><td><code id="find.clusters_+3A_clust">clust</code></td>
<td>
<p>an optional <code>factor</code> indicating a prior group membership of
individuals. If provided, sub-clusters will be sought within each prior
group.</p>
</td></tr>
<tr><td><code id="find.clusters_+3A_n.pca">n.pca</code></td>
<td>
<p>an <code>integer</code> indicating the number of axes retained in the
Principal Component Analysis (PCA) step. If <code>NULL</code>, interactive
selection is triggered.</p>
</td></tr>
<tr><td><code id="find.clusters_+3A_n.clust">n.clust</code></td>
<td>
<p> an optinal <code>integer</code> indicating the number of clusters to
be sought. If provided, the function will only run K-means once, for this
number of clusters. If left as <code>NULL</code>, several K-means are run for a
range of k (number of clusters) values.</p>
</td></tr>
<tr><td><code id="find.clusters_+3A_method">method</code></td>
<td>
<p>a <code>character</code> string indicating the type of clustering
method to be used; &quot;kmeans&quot; (default) uses K-means clustering, and is the
original implementation of <code>find.clusters</code>; &quot;ward&quot; is an alternative
which uses Ward's hierarchical clustering; this latter method seems to be more
reliable on some simulated datasets, but will be less computer-efficient for
large numbers (thousands) of individuals.</p>
</td></tr>
<tr><td><code id="find.clusters_+3A_stat">stat</code></td>
<td>
<p> a <code>character</code> string matching 'BIC', 'AIC', or 'WSS', which
indicates the statistic to be computed for each model (i.e., for each value
of <code>k</code>). BIC: Bayesian Information Criterion. AIC: Aikaike's
Information Criterion. WSS: within-groups sum of squares, that is, residual
variance.</p>
</td></tr>
<tr><td><code id="find.clusters_+3A_choose.n.clust">choose.n.clust</code></td>
<td>
<p> a <code>logical</code> indicating whether the number of
clusters should be chosen by the user (TRUE, default), or automatically,
based on a given criterion (argument <code>criterion</code>). It is HIGHLY
RECOMMENDED to choose the number of clusters INTERACTIVELY, since i) the
decrease of the summary statistics (BIC by default) is informative, and ii)
no criteria for automatic selection is appropriate to all cases (see
details).</p>
</td></tr>
<tr><td><code id="find.clusters_+3A_criterion">criterion</code></td>
<td>
<p> a <code>character</code> string matching &quot;diffNgroup&quot;,
&quot;min&quot;,&quot;goesup&quot;, &quot;smoothNgoesup&quot;, or &quot;goodfit&quot;, indicating the criterion for
automatic selection of the optimal number of clusters. See <code>details</code>
for an explanation of these procedures.</p>
</td></tr>
<tr><td><code id="find.clusters_+3A_max.n.clust">max.n.clust</code></td>
<td>
<p> an <code>integer</code> indicating the maximum number of clusters
to be tried. Values of 'k' will be picked up between 1 and
<code>max.n.clust</code></p>
</td></tr>
<tr><td><code id="find.clusters_+3A_n.iter">n.iter</code></td>
<td>
<p> an <code>integer</code> indicating the number of iterations to be used
in each run of K-means algorithm. Corresponds to <code>iter.max</code> of
<code>kmeans</code> function.</p>
</td></tr>
<tr><td><code id="find.clusters_+3A_n.start">n.start</code></td>
<td>
<p> an <code>integer</code> indicating the number of randomly chosen
starting centroids to be used in each run of the K-means algorithm. Using
more starting points ensures convergence of the algorithm. Corresponds to
<code>nstart</code> of <code>kmeans</code> function.</p>
</td></tr>
<tr><td><code id="find.clusters_+3A_center">center</code></td>
<td>
<p>a <code>logical</code> indicating whether variables should be centred to
mean 0 (TRUE, default) or not (FALSE). Always TRUE for <a href="#topic+genind-class">genind</a>
objects.</p>
</td></tr>
<tr><td><code id="find.clusters_+3A_scale">scale</code></td>
<td>
<p>a <code>logical</code> indicating whether variables should be scaled
(TRUE) or not (FALSE, default). Scaling consists in dividing variables by
their (estimated) standard deviation to account for trivial differences in
variances. In allele frequencies, it comes with the risk of giving
uninformative alleles more importance while downweighting informative
alleles. Further scaling options are available for <a href="#topic+genind-class">genind</a>
objects (see argument <code>scale.method</code>).</p>
</td></tr>
<tr><td><code id="find.clusters_+3A_pca.select">pca.select</code></td>
<td>
<p>a <code>character</code> indicating the mode of selection of PCA
axes, matching either &quot;nbEig&quot; or &quot;percVar&quot;. For &quot;nbEig&quot;, the user has to
specify the number of axes retained (interactively, or via
<code>n.pca</code>). For &quot;percVar&quot;, the user has to specify the minimum amount of
the total variance to be preserved by the retained axes, expressed as a
percentage (interactively, or via <code>perc.pca</code>).  </p>
</td></tr>
<tr><td><code id="find.clusters_+3A_perc.pca">perc.pca</code></td>
<td>
<p>a <code>numeric</code> value between 0 and 100 indicating the minimal
percentage of the total variance of the data to be expressed by the retained
axes of PCA.</p>
</td></tr>
<tr><td><code id="find.clusters_+3A_truenames">truenames</code></td>
<td>
<p>a <code>logical</code> indicating whether true (i.e., user-specified)
labels should be used in object outputs (TRUE, default) or not (FALSE), in
which case generic labels are used.</p>
</td></tr>
<tr><td><code id="find.clusters_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to other functions. For
<code>find.clusters.matrix</code>, arguments are to match those of the
<code>data.frame</code> method.</p>
</td></tr>
<tr><td><code id="find.clusters_+3A_dudi">dudi</code></td>
<td>
<p>optionally, a multivariate analysis with the class <code>dudi</code> (from
the ade4 package). If provided, prior PCA will be ignored, and this object
will be used as a prior step for variable orthogonalisation.</p>
</td></tr>
<tr><td><code id="find.clusters_+3A_glpca">glPca</code></td>
<td>
<p>an optional <code><a href="#topic+glPca">glPca</a></code> object; if provided, dimension
reduction is not performed (saving computational time) but taken directly
from this object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>=== ON THE SELECTION OF K ===<br />
(where K is the 'optimal' number of clusters)
</p>
<p>So far, the analysis of data simulated under various population
genetics models (see reference) suggested an ad hoc rule for the
selection of the optimal number of clusters. First important result is
that BIC seems more efficient than AIC and WSS to select the
appropriate number of clusters (see example). The rule of thumb
consists in increasing K until it no longer leads to an appreciable
improvement of fit (i.e., to a decrease of BIC).  In the most simple
models (island models), BIC decreases until it reaches the optimal K,
and then increases. In these cases, our rule amounts to choosing the
lowest K. In other models such as stepping stones, the decrease of BIC
often continues after the optimal K, but is much less steep.
</p>
<p>An alternative approach is the automatic selection based on a fixed
criterion. Note that, in any case, it is highly recommended to look at
the graph of the BIC for different numbers of clusters as displayed
during the interactive cluster selection.
To use automated selection, set <code>choose.n.clust</code> to FALSE and specify
the <code>criterion</code> you want to use, from the following values:
</p>
<p>- &quot;diffNgroup&quot;: differences between successive values of the summary
statistics (by default, BIC) are splitted into two groups using a
Ward's clustering method (see <code>?hclust</code>), to differentiate sharp
decrease from mild decreases or increases. The retained K is the one
before the first group switch. Appears to work well for
island/hierarchical models, and decently for isolation by distance
models, albeit with some unstability. Can be impacted by an initial,
very sharp decrease of the test statistics. IF UNSURE ABOUT THE
CRITERION TO USE, USE THIS ONE.
</p>
<p>- &quot;min&quot;: the model with the minimum summary statistics (as specified
by <code>stat</code> argument, BIC by default) is retained. Is likely to
work for simple island model, using BIC. It is likely to fail in
models relating to stepping stones, where the BIC always decreases
(albeit by a small amount) as K increases. In general, this approach
tends to over-estimate the number of clusters.
</p>
<p>- &quot;goesup&quot;: the selected model is the K after which increasing the
number of clusters leads to increasing the summary statistics. Suffers
from inaccuracy, since i) a steep decrease might follow a small 'bump'
of increase of the statistics, and ii) increase might never happen, or
happen after negligible decreases. Is likely to work only for
clear-cut island models.
</p>
<p>- &quot;smoothNgoesup&quot;: a variant of &quot;goesup&quot;, in which the summary
statistics is first smoothed using a lowess approach. Is meant to be
more accurate than &quot;goesup&quot; as it is less prone to stopping to small
'bumps' in the decrease of the statistics.
</p>
<p>- &quot;goodfit&quot;: another criterion seeking a good fit with a minimum
number of clusters. This approach does not rely on differences between
successive statistics, but on absolute fit. It selects the model with
the smallest K so that the overall fit is above a given threshold.
</p>


<h3>Value</h3>

<p>The class <code>find.clusters</code> is a list with the following
components:<br />
</p>
<table>
<tr><td><code>Kstat</code></td>
<td>
<p>a <code>numeric</code> vector giving the values of the summary
statistics for the different values of K. Is NULL if <code>n.clust</code> was specified.</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>a <code>numeric</code> value giving the value of the summary statistics
for the retained model</p>
</td></tr>
<tr><td><code>grp</code></td>
<td>
<p>a <code>factor</code> giving group membership for each individual.</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>an <code>integer</code> vector giving the size of the different clusters.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a> </p>


<h3>References</h3>

<p>Jombart T, Devillard S and Balloux F (2010) Discriminant analysis of
principal components: a new method for the analysis of genetically
structured populations. BMC Genetics 11:94. doi:10.1186/1471-2156-11-94
</p>


<h3>See Also</h3>

<p>- <code><a href="#topic+dapc">dapc</a></code>: implements the DAPC.
</p>
<p>- <code><a href="#topic+scatter.dapc">scatter.dapc</a></code>: graphics for DAPC.
</p>
<p>- <code><a href="#topic+dapcIllus">dapcIllus</a></code>: dataset illustrating the DAPC and <code>find.clusters</code>.
</p>
<p>- <code><a href="#topic+eHGDP">eHGDP</a></code>: dataset illustrating the DAPC and <code>find.clusters</code>.
</p>
<p>- <code><a href="stats.html#topic+kmeans">kmeans</a></code>: implementation of K-means in the stat package.
</p>
<p>- <code><a href="ade4.html#topic+dudi.pca">dudi.pca</a></code>: implementation of PCA in the ade4 package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## THIS ONE TAKES A FEW MINUTES TO RUN ## 
data(eHGDP)

## here, n.clust is specified, so that only on K value is used
grp &lt;- find.clusters(eHGDP, max.n=30, n.pca=200, scale=FALSE,
n.clust=4) # takes about 2 minutes
names(grp)
grp$Kstat
grp$stat


## to try different values of k (interactive)
grp &lt;- find.clusters(eHGDP, max.n=50, n.pca=200, scale=FALSE)

## and then, to plot BIC values:
plot(grp$Kstat, type="b", col="blue")



## ANOTHER SIMPLE EXAMPLE ## 
data(sim2pop) # this actually contains 2 pop

## DETECTION WITH BIC (clear result)
foo.BIC &lt;- find.clusters(sim2pop, n.pca=100, choose=FALSE)
plot(foo.BIC$Kstat, type="o", xlab="number of clusters (K)", ylab="BIC",
col="blue", main="Detection based on BIC")
points(2, foo.BIC$Kstat[2], pch="x", cex=3)
mtext(3, tex="'X' indicates the actual number of clusters")


## DETECTION WITH AIC (less clear-cut)
foo.AIC &lt;- find.clusters(sim2pop, n.pca=100, choose=FALSE, stat="AIC")
plot(foo.AIC$Kstat, type="o", xlab="number of clusters (K)",
ylab="AIC", col="purple", main="Detection based on AIC")
points(2, foo.AIC$Kstat[2], pch="x", cex=3)
mtext(3, tex="'X' indicates the actual number of clusters")


## DETECTION WITH WSS (less clear-cut)
foo.WSS &lt;- find.clusters(sim2pop, n.pca=100, choose=FALSE, stat="WSS")
plot(foo.WSS$Kstat, type="o", xlab="number of clusters (K)", ylab="WSS
(residual variance)", col="red", main="Detection based on WSS")
points(2, foo.WSS$Kstat[2], pch="x", cex=3)
mtext(3, tex="'X' indicates the actual number of clusters")


## TOY EXAMPLE FOR GENLIGHT OBJECTS ##
x &lt;- glSim(100,500,500)
x
plot(x)
grp &lt;- find.clusters(x, n.pca = 100, choose = FALSE, stat = "BIC")
plot(grp$Kstat, type = "o", xlab = "number of clusters (K)",
     ylab = "BIC",
     main = "find.clusters on a genlight object\n(two groups)")

## End(Not run)
</code></pre>

<hr>
<h2 id='findMutations'>Identify mutations between DNA sequences</h2><span id='topic+findMutations'></span><span id='topic+findMutations.DNAbin'></span><span id='topic+graphMutations'></span><span id='topic+graphMutations.DNAbin'></span>

<h3>Description</h3>

<p>The function <code>findMutations</code> identifies mutations (position and
nature) of pairs of aligned DNA sequences. The function
<code>graphMutations</code> does the same thing but plotting mutations on a
directed graph.<br />
</p>
<p>Both functions are generics, but the only methods implemented in
adegenet so far is for <code><a href="ape.html#topic+DNAbin">DNAbin</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findMutations(...)

## S3 method for class 'DNAbin'
findMutations(x, from=NULL, to=NULL, allcomb=TRUE, ...)

graphMutations(...)

## S3 method for class 'DNAbin'
graphMutations(x, from=NULL, to=NULL, allcomb=TRUE, plot=TRUE,
               curved.edges=TRUE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findMutations_+3A_x">x</code></td>
<td>
<p>a <code>DNAbin</code> object containing aligned sequences, as a matrix.</p>
</td></tr>
<tr><td><code id="findMutations_+3A_from">from</code></td>
<td>
<p>a vector indicating the DNA sequences from which mutations
should be found. If <code>NULL</code>, all sequences are considered (i.e.,
<code>1:nrow(x)</code>).</p>
</td></tr>
<tr><td><code id="findMutations_+3A_to">to</code></td>
<td>
<p>a vector indicating the DNA sequences to which mutations
should be found. If <code>NULL</code>, all sequences are considered (i.e.,
<code>1:nrow(x)</code>).</p>
</td></tr>
<tr><td><code id="findMutations_+3A_allcomb">allcomb</code></td>
<td>
<p>a logical indicating whether all combinations of
sequences (from and to) should be considered (TRUE, default), or not
(FALSE).</p>
</td></tr>
<tr><td><code id="findMutations_+3A_plot">plot</code></td>
<td>
<p>a logical indicating whether the graph should be plotted.</p>
</td></tr>
<tr><td><code id="findMutations_+3A_curved.edges">curved.edges</code></td>
<td>
<p>a logical indicating whether the edges of the
graph should be curved.</p>
</td></tr>
<tr><td><code id="findMutations_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to other methods. Used in
<code>graphMutations</code> where it is passed to the plot method for
<code>igraph</code> objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>findMutations</code>, a named list indicating the mutations from
one sequence to another. For each comparison, a three-column matrix is
provided, corresponding to the nucleotides in first and second
sequence, and a summary of the mutation provided as:
[position]:[nucleotide in first sequence]-&gt;[nucleotide in second
sequence].
</p>
<p>For <code>graphMutations</code>, a graph with the class <code>igraph</code>.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+fasta2DNAbin">fasta2DNAbin</a></code> to read fasta alignments with minimum
RAM use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(woodmouse)

## mutations between first 3 sequences
findMutations(woodmouse[1:3,])

## mutations from the first to sequences 2 and 3
findMutations(woodmouse[1:3,], from=1)

## same, graphical display
g &lt;- graphMutations(woodmouse[1:3,], from=1)

## some manual checks
as.character(woodmouse)[1:3,35]
as.character(woodmouse)[1:3,36]
as.character(woodmouse)[1:3,106]


## End(Not run)
</code></pre>

<hr>
<h2 id='gengraph'>Genetic transitive graphs</h2><span id='topic+gengraph'></span><span id='topic+gengraph.default'></span><span id='topic+gengraph.matrix'></span><span id='topic+gengraph.dist'></span><span id='topic+gengraph.genind'></span><span id='topic+gengraph.genpop'></span><span id='topic+gengraph.DNAbin'></span>

<h3>Description</h3>

<p>These functions are under development. Please email the author before
using them for published work.<br />
</p>
<p>The function <code>gengraph</code> generates graphs based on genetic
distances, so that pairs of entities (individuals or populations) are
connected if and only if they are distant by less than a given
threshold distance. Graph algorithms and classes from the
<code><a href="igraph.html#topic+igraph">igraph</a></code> package are used.<br />
</p>
<p><code>gengraph</code> is a generic function with methods for the
following types of objects:<br />
- <code>matrix</code> (only numeric data)<br />
- <code>dist</code> <br />
- <code><a href="#topic+genind-class">genind</a></code> objects (genetic markers, individuals)<br />
- <code><a href="#topic+genpop-class">genpop</a></code> objects (genetic markers, populations)<br />
-  <code><a href="ape.html#topic+DNAbin">DNAbin</a></code> objects (DNA sequences)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gengraph(x, ...)

## S3 method for class 'matrix'
gengraph(x, cutoff=NULL, ngrp=NULL, computeAll=FALSE,
           plot=TRUE, show.graph=TRUE, col.pal=funky, truenames=TRUE,
           nbreaks=10, ...)

## S3 method for class 'dist'
gengraph(x, cutoff=NULL, ngrp=NULL, computeAll=FALSE,
           plot=TRUE, show.graph=TRUE, col.pal=funky, truenames=TRUE,
           nbreaks=10, ...)

## S3 method for class 'genind'
gengraph(x, cutoff=NULL, ngrp=NULL, computeAll=FALSE,
           plot=TRUE, show.graph=TRUE, col.pal=funky, truenames=TRUE,
           nbreaks=10, ...)

## S3 method for class 'genpop'
gengraph(x, cutoff=NULL, ngrp=NULL, computeAll=FALSE,
           plot=TRUE, show.graph=TRUE, col.pal=funky, method=1,
           truenames=TRUE, nbreaks=10, ...)

## S3 method for class 'DNAbin'
gengraph(x, cutoff=NULL, ngrp=NULL, computeAll=FALSE,
           plot=TRUE, show.graph=TRUE, col.pal=funky, truenames=TRUE,
           nbreaks=10, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gengraph_+3A_x">x</code></td>
<td>
<p>a <code>matrix</code>, <code>dist</code>, <code><a href="#topic+genind-class">genind</a></code>,
<code><a href="#topic+genpop-class">genpop</a></code>, or <code>DNAbin</code> object. For
<code>matrix</code> and <code>dist</code>, the object represents pairwise
(by default, Hamming) distances between considered individuals.</p>
</td></tr>
<tr><td><code id="gengraph_+3A_cutoff">cutoff</code></td>
<td>
<p>a <code>numeric</code> value indicating the cutoff point,
i.e. the distance at which two entities are no longer connected in
the garph produced by the method.</p>
</td></tr>
<tr><td><code id="gengraph_+3A_ngrp">ngrp</code></td>
<td>
<p>an <code>integer</code> indicating the number of groups to be
looked for. A message is issued if this exact number could not be found.</p>
</td></tr>
<tr><td><code id="gengraph_+3A_computeall">computeAll</code></td>
<td>
<p>a <code>logical</code> stating whether to investigate
solutions for every (integer) cutoff point; defaults to FALSE.</p>
</td></tr>
<tr><td><code id="gengraph_+3A_plot">plot</code></td>
<td>
<p>a <code>logical</code> indicating whether plots should be drawn;
defaults to TRUE; this operation can take time for large, highly-connected graphs.</p>
</td></tr>
<tr><td><code id="gengraph_+3A_show.graph">show.graph</code></td>
<td>
<p>a <code>logical</code> indicating whether the found graph
should be drawn, only used in the interactive mode; this operation
can take time for large, highly-connected graphs; defaults to FALSE.</p>
</td></tr>
<tr><td><code id="gengraph_+3A_col.pal">col.pal</code></td>
<td>
<p>a color palette used to define group colors.</p>
</td></tr>
<tr><td><code id="gengraph_+3A_method">method</code></td>
<td>
<p>an <code>integer</code> ranging from 1 to 6 indicating the
type of method to be used to derive a matrix of pairwise distances
between populations; values from 1 to 5 are passed to the function
<code>dist.genpop</code>; other values are not supported.</p>
</td></tr>
<tr><td><code id="gengraph_+3A_truenames">truenames</code></td>
<td>
<p>a logical indicating whether original labels should
be used for plotting (TRUE), as opposed to indices of sequences
(FALSE).</p>
</td></tr>
<tr><td><code id="gengraph_+3A_nbreaks">nbreaks</code></td>
<td>
<p>an integer indicating the number of breaks used by the
heuristic when seeking an exact number of groups.</p>
</td></tr>
<tr><td><code id="gengraph_+3A_...">...</code></td>
<td>
<p>further arguments to be used by other functions;
currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The class <code>gengraph</code> is a list with the following
components:<br />
</p>
<table>
<tr><td><code>graph</code></td>
<td>
<p>a graph of class <code><a href="igraph.html#topic+igraph">igraph</a></code>.</p>
</td></tr>
<tr><td><code>clust</code></td>
<td>
<p>a list containing group information: <code>$membership</code>:
an integer giving group membership; <code>$csize</code>: the size of each
cluster; <code>$no</code>: the number of clusters</p>
</td></tr>
<tr><td><code>cutoff</code></td>
<td>
<p>the value used as a cutoff point</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>the color used to plot each group.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Original idea by Anne Cori and Christophe Fraser.
Implementation by Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>.
</p>


<h3>See Also</h3>

<p>The <code><a href="igraph.html#topic+igraph">igraph</a></code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(ape)){
    data(woodmouse)
    g &lt;- gengraph(woodmouse, cutoff=5)
    g
    plot(g$graph)

}
</code></pre>

<hr>
<h2 id='genind+20class'>adegenet formal class (S4) for individual genotypes</h2><span id='topic+genind-class'></span><span id='topic+print+2Cgenind-method'></span><span id='topic+show+2Cgenind-method'></span><span id='topic+names+2Cgenind-method'></span><span id='topic+summary+2Cgenind-method'></span><span id='topic+print+2CgenindSummary-method'></span><span id='topic+print.genindSummary'></span><span id='topic+is.genind'></span><span id='topic+.valid.genind'></span>

<h3>Description</h3>

<p>The S4 class <code>genind</code> is used to store individual genotypes.<br />
It contains several components described in the 'slots' section).<br />
The <code>summary</code> of a <code>genind</code> object invisibly returns a list of component.
The function <code>.valid.genind</code> is for internal use.
The function <code>genind</code> creates a genind object from a valid table
of alleles corresponding to the <code>@tab</code> slot.
Note that as in other S4 classes, slots are accessed using @ instead
of $.
</p>


<h3>Slots</h3>


<dl>
<dt><code>tab</code>:</dt><dd> <p><strong>(accessor: <code><a href="#topic+tab">tab</a></code>)</strong>
matrix integers containing genotypes data for
individuals (in rows) for all alleles (in columns). The table
differs depending on the <code>@type</code> slot:<br />
- 'codom': values
are numbers of alleles, summing up to the
individuals' ploidies.<br />
- 'PA': values are presence/absence of alleles.<br />
In all cases, rows and columns are given generic names.</p>
</dd>
<dt><code>loc.fac</code>:</dt><dd><p><strong>(accessor: <code><a href="#topic+locFac">locFac</a></code>)</strong> locus 
factor for the columns of <code>tab</code></p>
</dd>
<dt><code>loc.n.all</code>:</dt><dd><p><strong>(accessor: <code><a href="#topic+nAll">nAll</a></code>)</strong> integer 
vector giving the number of observed alleles per locus (see note)</p>
</dd>
<dt><code>all.names</code>:</dt><dd><p><strong>(accessor: <code><a href="#topic+alleles">alleles</a></code>)</strong> list 
having one component per locus, each containing a character vector of allele
names</p>
</dd>
<dt><code>ploidy</code>:</dt><dd><p><strong>(accessor: <code><a href="#topic+ploidy">ploidy</a></code>)</strong> an integer 
vector indicating the degree of ploidy of the genotypes. Beware: 2 is not 
an integer, but 2L or as.integer(2) is.</p>
</dd>
<dt><code>type</code>:</dt><dd><p> a character string indicating the type of
marker: 'codom' stands for 'codominant' (e.g. microstallites,
allozymes); 'PA' stands for 'presence/absence' (e.g. AFLP).</p>
</dd>
<dt><code>call</code>:</dt><dd><p>the matched call</p>
</dd>
<dt><code>strata</code>:</dt><dd><p><strong>(accessor: <code><a href="#topic+strata">strata</a></code>)</strong> (optional) 
data frame giving levels of population stratification for each individual</p>
</dd>
<dt><code>hierarchy</code>:</dt><dd><p><strong>(accessor: <code><a href="#topic+hier">hier</a></code>)</strong> (optional, 
currently unused) a hierarchical <code><a href="stats.html#topic+formula">formula</a></code> defining the 
hierarchical levels in the <code>@@strata</code> slot.</p>
</dd>
<dt><code>pop</code>:</dt><dd><p><strong>(accessor: <code><a href="#topic+pop">pop</a></code>)</strong> (optional) factor 
giving the population of each individual</p>
</dd>
<dt><code>other</code>:</dt><dd><p><strong>(accessor: <code><a href="#topic+other">other</a></code>)</strong> (optional) a 
list containing other information</p>
</dd>
</dl>



<h3>Note:</h3>

<p>The <code>loc.n.all</code> slot will reflect the number of columns per locus that 
contain at least one observation. This means that the sum of the this vector 
will not necessarily equal the number of columns in the data unless you use 
<code>drop = TRUE</code> when subsetting. 
</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+gen-class">gen</a>"</code>, directly.
Class <code>"<a href="#topic+indInfo-class">indInfo</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>names</dt><dd><p><code>signature(x = "genind")</code>: give the names of the
components of a genind object</p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "genind")</code>: prints a genind object</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "genind")</code>: shows a genind
object (same as print)</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "genind")</code>: summarizes a
genind object, invisibly returning its content or suppress printing of auxiliary information by specifying <code>verbose = FALSE</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+as.genind">as.genind</a></code>, <code><a href="#topic+genind2genpop">genind2genpop</a></code>,
<code><a href="#topic+genpop">genpop</a></code>, <code><a href="#topic+import2genind">import2genind</a></code>,
<code><a href="#topic+read.genetix">read.genetix</a></code>, <code><a href="#topic+read.genepop">read.genepop</a></code>,
<code><a href="#topic+read.fstat">read.fstat</a></code><br />
</p>
<p>Related classes:<br />
- <a href="#topic+genpop-class">genpop</a> for storing data per populations<br />
</p>
<p>- <a href="#topic+genlight-class">genlight</a> for an efficient storage of binary SNPs genotypes<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("genind")

obj &lt;- read.genetix(system.file("files/nancycats.gtx",package="adegenet"))
obj
validObject(obj)
summary(obj)

## Not run: 
# test inter-colonies structuration
if(require(hierfstat)){
gtest &lt;- gstat.randtest(obj,nsim=99)
gtest
plot(gtest)
}

# perform a between-class PCA
pca1 &lt;- dudi.pca(scaleGen(obj, NA.method="mean"),scannf=FALSE,scale=FALSE)
pcabet1 &lt;- between(pca1,obj@pop,scannf=FALSE)
pcabet1

s.class(pcabet1$ls,obj@pop,sub="Inter-class PCA",possub="topleft",csub=2)
add.scatter.eig(pcabet1$eig,2,xax=1,yax=2)


## End(Not run)
</code></pre>

<hr>
<h2 id='genind2df'>Convert a genind object to a data.frame.</h2><span id='topic+genind2df'></span>

<h3>Description</h3>

<p>The function <code>genind2df</code> converts a <a href="#topic+genind-class">genind</a> back to a
data.frame of raw allelic data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genind2df(x, pop = NULL, sep = "", usepop = TRUE, oneColPerAll = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genind2df_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+genind-class">genind</a> object</p>
</td></tr>
<tr><td><code id="genind2df_+3A_pop">pop</code></td>
<td>
<p>an optional factor giving the population of each individual.</p>
</td></tr>
<tr><td><code id="genind2df_+3A_sep">sep</code></td>
<td>
<p>a character string separating alleles. See details.</p>
</td></tr>
<tr><td><code id="genind2df_+3A_usepop">usepop</code></td>
<td>
<p>a logical stating whether the population (argument <code>pop</code>
or <code>x@pop</code> should be used (TRUE, default) or not (FALSE)).</p>
</td></tr>
<tr><td><code id="genind2df_+3A_onecolperall">oneColPerAll</code></td>
<td>
<p>a logical stating whether or not alleles should be split
into columns (defaults to <code>FALSE</code>). This will only work with data with
consistent ploidies.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame of raw allelic data, with individuals in rows and loci in column
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+df2genind">df2genind</a></code>, <code><a href="#topic+import2genind">import2genind</a></code>, <code><a href="#topic+read.genetix">read.genetix</a></code>,
<code><a href="#topic+read.fstat">read.fstat</a></code>, <code><a href="#topic+read.structure">read.structure</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## simple example
df &lt;- data.frame(locusA=c("11","11","12","32"),
locusB=c(NA,"34","55","15"),locusC=c("22","22","21","22"))
row.names(df) &lt;- .genlab("genotype",4)
df

obj &lt;- df2genind(df, ploidy=2, ncode=1)
obj
obj@tab


## converting a genind as data.frame
genind2df(obj)
genind2df(obj, sep="/")

</code></pre>

<hr>
<h2 id='genind2genpop'>Conversion from a genind to a genpop object</h2><span id='topic+genind2genpop'></span>

<h3>Description</h3>

<p>The function <code>genind2genpop</code> converts genotypes data (genind) into 
alleles counts per population (genpop).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genind2genpop(
  x,
  pop = NULL,
  quiet = FALSE,
  process.other = FALSE,
  other.action = mean
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genind2genpop_+3A_x">x</code></td>
<td>
<p>an object of class <code>genind</code>.</p>
</td></tr>
<tr><td><code id="genind2genpop_+3A_pop">pop</code></td>
<td>
<p>a factor giving the population of each genotype in 'x' OR a
formula specifying which strata are to be used when converting to a genpop
object. If none provided, population factors are sought in x@pop, but if
given, the argument prevails on x@pop.</p>
</td></tr>
<tr><td><code id="genind2genpop_+3A_quiet">quiet</code></td>
<td>
<p>logical stating whether a conversion message must be printed 
(TRUE,default) or not (FALSE).</p>
</td></tr>
<tr><td><code id="genind2genpop_+3A_process.other">process.other</code></td>
<td>
<p>a logical indicating whether the <code>@other</code> slot 
should be processed (see details).</p>
</td></tr>
<tr><td><code id="genind2genpop_+3A_other.action">other.action</code></td>
<td>
<p>a function to be used when processing the <code>@other</code> 
slot. By default, 'mean' is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>=== 'missing' argument ===<br /> The values of the 'missing' argument in 
<code>genind2genpop</code> have the following effects:<br /> - &quot;NA&quot;: if all genotypes 
of a population for a given allele are missing, count value will be NA<br />
</p>
<p>- &quot;0&quot;: if all genotypes of a population for a given allele are missing, count
value will be 0<br />
</p>
<p>- &quot;chi2&quot;: if all genotypes of a population for a given allele are missing, 
count value will be that of a theoretical count in of a Chi-squared test. 
This is obtained by the product of the margins sums divided by the total 
number of alleles.<br />
</p>
<p>=== processing the <code>@other</code> slot ===<br /> Essentially, 
<code>genind2genpop</code> is about aggregating data per population. The function 
can do the same for all numeric items in the <code>@other</code> slot provided 
they have the same length (for vectors) or the same number of rows 
(matrix-like objects) as the number of genotypes. When the case is 
encountered and if <code>process.other</code> is TRUE, then these objects are 
processed using the function defined in <code>other.action</code> per population. 
For instance, spatial coordinates of genotypes would be averaged to obtain 
population coordinates.
</p>


<h3>Value</h3>

<p>A genpop object. The component @other in 'x' is passed to the 
created genpop object.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+genind-class">genind</a>, <a href="#topic+genpop-class">genpop</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## simple conversion
data(nancycats)
nancycats
catpop &lt;- genind2genpop(nancycats)
catpop
summary(catpop)

## processing the @other slot
data(sim2pop)
sim2pop$other$foo &lt;- letters
sim2pop
dim(sim2pop$other$xy) # matches the number of genotypes
sim2pop$other$foo # does not match the number of genotypes

obj &lt;- genind2genpop(sim2pop, process.other=TRUE)
obj$other # the new xy is the populations' centre

pch &lt;- as.numeric(pop(sim2pop))
col &lt;- pop(sim2pop)
levels(col) &lt;- c("blue","red")
col &lt;- as.character(col)
plot(sim2pop$other$xy, pch=pch, col=col)
text(obj$other$xy, lab=row.names(obj$other$xy), col=c("blue","red"), cex=2, font=2)
## Not run: 
data(microbov)
strata(microbov) &lt;- data.frame(other(microbov))
summary(genind2genpop(microbov)) # Conversion based on population factor
summary(genind2genpop(microbov, ~coun)) # Conversion based on country
summary(genind2genpop(microbov, ~coun/spe)) # Conversion based on country and species


## End(Not run)

</code></pre>

<hr>
<h2 id='genlight+20auxiliary+20functions'>Auxiliary functions for genlight objects</h2><span id='topic+glSum'></span><span id='topic+glNA'></span><span id='topic+glMean'></span><span id='topic+glVar'></span><span id='topic+glDotProd'></span>

<h3>Description</h3>

<p>These functions provide facilities for usual computations using
<a href="#topic+genlight-class">genlight</a> objects. When ploidy varies across individuals,
the outputs of these functions depend on whether the information
units are individuals, or alleles within individuals (see details).
</p>
<p>These functions are:
</p>
<p>- <code>glSum</code>: computes the sum of the number of second allele in each SNP.
</p>
<p>- <code>glNA</code>: computes the number of missing values in each SNP.
</p>
<p>- <code>glMean</code>: computes the mean number of second allele in each SNP.
</p>
<p>- <code>glVar</code>: computes the variance of the number of second allele in each SNP.
</p>
<p>- <code>glDotProd</code>: computes dot products between (possibly
centred/scaled) vectors of individuals - uses compiled C code - used
by glPca.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glSum(x, alleleAsUnit = TRUE, useC = FALSE)
glNA(x, alleleAsUnit = TRUE)
glMean(x, alleleAsUnit = TRUE)
glVar(x, alleleAsUnit = TRUE)
glDotProd(x, center = FALSE, scale = FALSE, alleleAsUnit = FALSE,
                parallel = FALSE, n.cores = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genlight+2B20auxiliary+2B20functions_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+genlight-class">genlight</a> object</p>
</td></tr>
<tr><td><code id="genlight+2B20auxiliary+2B20functions_+3A_alleleasunit">alleleAsUnit</code></td>
<td>
<p>a logical indicating whether alleles are
considered as units (i.e., a diploid genotype equals two samples, a
triploid, three, etc.) or whether individuals are considered as
units of information.</p>
</td></tr>
<tr><td><code id="genlight+2B20auxiliary+2B20functions_+3A_center">center</code></td>
<td>
<p>a logical indicating whether SNPs should be centred to
mean zero.</p>
</td></tr>
<tr><td><code id="genlight+2B20auxiliary+2B20functions_+3A_scale">scale</code></td>
<td>
<p>a logical indicating whether SNPs should be scaled to
unit variance.</p>
</td></tr>
<tr><td><code id="genlight+2B20auxiliary+2B20functions_+3A_usec">useC</code></td>
<td>
<p>a logical indicating whether compiled C code should be
used (TRUE) or not (FALSE, default).</p>
</td></tr>
<tr><td><code id="genlight+2B20auxiliary+2B20functions_+3A_parallel">parallel</code></td>
<td>
<p>a logical indicating whether multiple cores -if
available- should be used for the computations (TRUE, default), or
not (FALSE); requires the package <code>parallel</code> to be installed
(see details); this option cannot be used alongside useCoption.</p>
</td></tr>
<tr><td><code id="genlight+2B20auxiliary+2B20functions_+3A_n.cores">n.cores</code></td>
<td>
<p>if <code>parallel</code> is TRUE, the number of cores to
be used in the computations; if NULL, then the maximum number of
cores available on the computer is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>=== On the unit of information ===
</p>
<p>In the cases where individuals can have different ploidy, computation
of sums, means, etc. of allelic data depends on what we consider as a
unit of information.
</p>
<p>To estimate e.g. allele frequencies, unit of information can be
considered as the allele, so that a diploid genotype contains two
samples, a triploid individual, three samples, etc. In such a case,
all computations are done directly on the number of alleles. This
corresponds to <code>alleleAsUnit = TRUE</code>.
</p>
<p>However, when the focus is put on studying differences/similarities
between individuals, the unit of information is the individual, and
all genotypes possess the same information no matter what their ploidy
is. In this case, computations are made after standardizing
individual genotypes to relative allele frequencies. This
corresponds to <code>alleleAsUnit = FALSE</code>.
</p>
<p>Note that when all individuals have the same ploidy, this distinction
does not hold any more.
</p>


<h3>Value</h3>

<p>A numeric vector containing the requested information.
</p>


<h3>Author(s)</h3>

<p> Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a> </p>


<h3>See Also</h3>

<p>- <code><a href="#topic+genlight-class">genlight</a></code>: class of object for storing massive binary
SNP data.
</p>
<p>- <code><a href="#topic+dapc">dapc</a></code>: Discriminant Analysis of Principal Components.
</p>
<p>- <code><a href="#topic+glPca">glPca</a></code>: PCA for <a href="#topic+genlight-class">genlight</a> objects.
</p>
<p>- <code><a href="#topic+glSim">glSim</a></code>: a simple simulator for <a href="#topic+genlight-class">genlight</a> objects.
</p>
<p>- <code><a href="#topic+glPlot">glPlot</a></code>: plotting <a href="#topic+genlight-class">genlight</a> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- new("genlight", list(c(0,0,1,1,0), c(1,1,1,0,0,1), c(2,1,1,1,1,NA)))
x
as.matrix(x)
ploidy(x)

## compute statistics - allele as unit ##
glNA(x)
glSum(x)
glMean(x)

## compute statistics - individual as unit ##
glNA(x, FALSE)
glSum(x, FALSE)
glMean(x, FALSE)

## explanation: data are taken as relative frequencies
temp &lt;- as.matrix(x)/ploidy(x)
apply(temp,2, function(e) sum(is.na(e))) # NAs
apply(temp,2,sum, na.rm=TRUE) # sum
apply(temp,2,mean, na.rm=TRUE) # mean

## End(Not run)
</code></pre>

<hr>
<h2 id='genlight-class'>Formal class &quot;genlight&quot;</h2><span id='topic+genlight'></span><span id='topic+genlight-class'></span><span id='topic++5B+2Cgenlight-method'></span><span id='topic++5B+2Cgenlight+2CANY+2CANY-method'></span><span id='topic++5B+2Cgenlight+2CANY+2CANY+2CANY-method'></span><span id='topic+initialize+2Cgenlight-method'></span><span id='topic+show+2Cgenlight-method'></span><span id='topic+tab+2Cgenlight-method'></span><span id='topic+nLoc+2Cgenlight-method'></span><span id='topic+nInd+2Cgenlight-method'></span><span id='topic+dim+2Cgenlight-method'></span><span id='topic+nPop+2Cgenlight-method'></span><span id='topic++24+2Cgenlight-method'></span><span id='topic++24+3C-+2Cgenlight-method'></span><span id='topic+names+2Cgenlight-method'></span><span id='topic+ploidy+2Cgenlight-method'></span><span id='topic+ploidy+3C-+2Cgenlight-method'></span><span id='topic+locNames+2Cgenlight-method'></span><span id='topic+locNames+3C-+2Cgenlight-method'></span><span id='topic+indNames+2Cgenlight-method'></span><span id='topic+indNames+3C-+2Cgenlight-method'></span><span id='topic+popNames+2Cgenlight-method'></span><span id='topic+popNames+3C-+2Cgenlight-method'></span><span id='topic+alleles+2Cgenlight-method'></span><span id='topic+alleles+3C-+2Cgenlight-method'></span><span id='topic+chromosome'></span><span id='topic+chromosome+3C-'></span><span id='topic+chromosome+2Cgenlight-method'></span><span id='topic+chromosome+3C-+2Cgenlight-method'></span><span id='topic+chr'></span><span id='topic+chr+3C-'></span><span id='topic+chr+2Cgenlight-method'></span><span id='topic+chr+3C-+2Cgenlight-method'></span><span id='topic+position'></span><span id='topic+position+3C-'></span><span id='topic+position+2Cgenlight-method'></span><span id='topic+position+3C-+2Cgenlight-method'></span><span id='topic+pop+2Cgenlight-method'></span><span id='topic+pop+3C-+2Cgenlight-method'></span><span id='topic+NA.posi'></span><span id='topic+NA.posi+2Cgenlight-method'></span><span id='topic+other+2Cgenlight-method'></span><span id='topic+other+3C-+2Cgenlight-method'></span><span id='topic+as.matrix.genlight'></span><span id='topic+as.data.frame.genlight'></span><span id='topic+as+2Cmatrix+2Cgenlight-method'></span><span id='topic+as+2Cdata.frame+2Cgenlight-method'></span><span id='topic+as+2Clist+2Cgenlight-method'></span><span id='topic+coerce+2Cmatrix+2Cgenlight-method'></span><span id='topic+coerce+2Cdata.frame+2Cgenlight-method'></span><span id='topic+coerce+2Clist+2Cgenlight-method'></span><span id='topic+as.list.genlight'></span><span id='topic+cbind.genlight'></span><span id='topic+rbind.genlight'></span>

<h3>Description</h3>

<p>The class <code>genlight</code> is a formal (S4) class for storing a genotypes
of binary SNPs in a compact way, using a bit-level coding scheme.
This storage is most efficient with haploid data, where the memory
taken to represent data can be reduced more than 50 times. However,
<code>genlight</code> can be used for any level of ploidy, and still remain an
efficient storage mode.
</p>
<p>A <code>genlight</code> object can be constructed from vectors of integers
giving the number of the second allele for each locus and each
individual (see 'Objects of the class genlight' below).
</p>
<p><code>genlight</code> stores multiple genotypes. Each genotype is stored
as a <a href="#topic+SNPbin-class">SNPbin</a> object.
</p>


<h3>Details</h3>

<p>=== On the subsetting using <code>[</code> ===
</p>
<p>The function <code>[</code> accepts the following extra arguments:
</p>

<dl>
<dt>treatOther</dt><dd><p>a logical stating whether elements of the
<code>@other</code> slot should be treated as well (TRUE), or not
(FALSE). If treated, elements of the list are examined for a
possible match of length (vectors, lists) or number of rows
(matrices, data frames) with the number of individuals. Those who
match are subsetted accordingly. Others are left as is, issuing a
warning unless the argument <code>quiet</code> is set to TRUE.</p>
</dd>
<dt>quiet</dt><dd><p>a logical indicating whether warnings should be issued
when trying to subset components of the <code>@other</code> slot which
do not match the number of individuals (TRUE), or not (FALSE,
default). </p>
</dd>
<dt>...</dt><dd><p>further arguments passed to the genlight constructor.</p>
</dd>
</dl>



<h3>Objects from the class genlight</h3>

<p><code>genlight</code> objects can be created by calls to <code>new("genlight",
    ...)</code>, where '...' can be the following arguments:
</p>

<dl>
<dt><code>gen</code></dt><dd><p>input genotypes, where each genotype is coded as a
vector of numbers of the second allele. If a list, each slot of the
list correspond to an individual; if a matrix or a data.frame, rows
correspond to individuals and columns to SNPs. If individuals or
loci are named in the input, these names will we stored in the
produced object. All individuals are expected to have the same
number of SNPs. Shorter genotypes are completed with NAs, issuing a
warning.</p>
</dd>
<dt><code>ploidy</code></dt><dd><p>an optional vector of integers indicating the ploidy of the
genotypes. Genotypes can therefore have different ploidy. If not
provided, ploidy will be guessed from the data (as the
maximum number of second alleles in each individual).</p>
</dd>
<dt><code>ind.names</code></dt><dd><p>an optional vector of characters giving the labels
of the genotypes.</p>
</dd>
<dt><code>loc.names</code></dt><dd><p>an optional vector of characters giving the labels
of the SNPs.</p>
</dd>
<dt><code>loc.all</code></dt><dd><p>an optional vector of characters indicating
the alleles of each SNP; for each SNP, alleles must be coded by two
letters separated by '/', e.g. 'a/t' is valid, but 'a  t' or 'a |t'
are not.</p>
</dd>
<dt><code>chromosome</code></dt><dd><p>an optional factor indicating the
chromosome to which each SNP belongs.</p>
</dd>
<dt><code>position</code></dt><dd><p>an optional vector of integers indicating the
position of the SNPs.</p>
</dd>
<dt><code>other</code></dt><dd><p>an optional list storing miscellaneous information.</p>
</dd>
</dl>



<h3>Slots</h3>

<p>The following slots are the content of instances of the class
<code>genlight</code>; note that in most cases, it is better to retrieve
information via accessors (see below), rather than by accessing the
slots manually.
</p>

<dl>
<dt><code>gen</code>:</dt><dd><p>a list of genotypes stored as  <a href="#topic+SNPbin-class">SNPbin</a> objects.</p>
</dd>
<dt><code>n.loc</code>:</dt><dd><p>an integer indicating the number of SNPs of the
genotype.</p>
</dd>
<dt><code>ind.names</code>:</dt><dd><p>a vector of characters indicating the names of
genotypes.</p>
</dd>
<dt><code>loc.names</code>:</dt><dd><p>a vector of characters indicating the names of
SNPs.</p>
</dd>
<dt><code>loc.all</code>:</dt><dd><p>a vector of characters indicating the alleles
of each SNP.</p>
</dd>
<dt><code>chromosome</code>:</dt><dd><p>an optional factor indicating the
chromosome to which each SNP belongs.</p>
</dd>
<dt><code>position</code>:</dt><dd><p>an optional vector of integers indicating the
position of the SNPs.</p>
</dd>
<dt><code>ploidy</code>:</dt><dd><p>a vector of integers indicating the ploidy of each individual.</p>
</dd>
<dt><code>pop</code>:</dt><dd><p>a factor indicating the population of each individual.</p>
</dd>
<dt><code>strata</code>:</dt><dd><p>a data frame containing different levels of population definition. (For methods, see <code><a href="#topic+addStrata">addStrata</a></code> and <code><a href="#topic+setPop">setPop</a></code>)</p>
</dd>
<dt><code>hierarchy</code>:</dt><dd><p>a hierarchical <code><a href="stats.html#topic+formula">formula</a></code> defining the hierarchical levels in the <code>@@strata</code> slot.</p>
</dd>
<dt><code>other</code>:</dt><dd><p>a list containing other miscellaneous information.</p>
</dd>
</dl>



<h3>Methods</h3>

<p>Here is a list of methods available for <code>genlight</code> objects. Most of
these methods are accessors, that is, functions which are used to
retrieve the content of the object. Specific manpages can exist for
accessors with more than one argument. These are indicated by a '*'
symbol next to the method's name. This list also contains methods
for conversion from <code>genlight</code> to other classes.
</p>

<dl>
<dt>[</dt><dd><p><code>signature(x = "genlight")</code>: usual method to subset
objects in R. Is to be applied as if the object was a matrix where
genotypes were rows and SNPs were columns. Indexing can be done via
vectors of signed integers or of logicals. See details for extra
supported arguments.</p>
</dd>
<dt>show</dt><dd><p><code>signature(x = "genlight")</code>: printing of the
object.</p>
</dd>
<dt>$</dt><dd><p><code>signature(x = "genlight")</code>: similar to the @ operator;
used to access the content of slots of the object.</p>
</dd>
<dt>$&lt;-</dt><dd><p><code>signature(x = "genlight")</code>: similar to the @ operator;
used to replace the content of slots of the object.</p>
</dd>
<dt>tab</dt><dd><p><code>signature(x = "genlight")</code>: returns a table of
allele counts (see <code><a href="#topic+tab">tab</a></code>; additional arguments are
<code>freq</code>, a logical stating if relative frequencies should be
returned (use for varying ploidy), and <code>NA.method</code>, a character
indicating if missing values should be replaced by the mean
frequency(&quot;mean&quot;), or left as is (&quot;asis&quot;).</p>
</dd>
<dt>nInd</dt><dd><p><code>signature(x = "genlight")</code>: returns the number of
individuals in the object.</p>
</dd>
<dt>nPop</dt><dd><p><code>signature(x = "genlight")</code>: returns the number of
populations in the object.</p>
</dd>
<dt>nLoc</dt><dd><p><code>signature(x = "genlight")</code>: returns the number of
SNPs in the object.</p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "genlight")</code>: returns the number of 
individuals and SNPs in the object, respectively.</p>
</dd>
<dt>names</dt><dd><p><code>signature(x = "genlight")</code>: returns the names of
the slots of the object.</p>
</dd>
<dt>indNames</dt><dd><p><code>signature(x = "genlight")</code>: returns the names of
the individuals, if provided when the object was constructed.</p>
</dd>
<dt>indNames&lt;-</dt><dd><p><code>signature(x = "genlight")</code>: sets the names of
the individuals using a character vector of length
<code>nInd(x)</code>.</p>
</dd>
<dt>popNames</dt><dd><p><code>signature(x = "genlight")</code>: returns the names of
the populations, if provided when the object was constructed.</p>
</dd>
<dt>popNames&lt;-</dt><dd><p><code>signature(x = "genlight")</code>: sets the names of
the populations using a character vector of length
<code>nPop(x)</code>.</p>
</dd>
<dt>locNames</dt><dd><p><code>signature(x = "genlight")</code>: returns the names of
the loci, if provided when the object was constructed.</p>
</dd>
<dt>locNames&lt;-</dt><dd><p><code>signature(x = "genlight")</code>: sets the names of
the SNPs using a character vector of length <code>nLoc(x)</code>.</p>
</dd>
<dt>ploidy</dt><dd><p><code>signature(x = "genlight")</code>: returns the ploidy of
the genotypes.</p>
</dd>
<dt>ploidy&lt;-</dt><dd><p><code>signature(x = "genlight")</code>: sets the ploidy of
the individuals using a vector of integers of size <code>nInd(x)</code>;
if a single value is provided, the same ploidy is assumed for all
individuals.</p>
</dd>
<dt>NA.posi</dt><dd><p><code>signature(x = "genlight")</code>: returns the indices
of missing values (NAs) as a list with one vector of integer for each individual.</p>
</dd>
<dt>alleles</dt><dd><p><code>signature(x = "genlight")</code>: returns the names
of the alleles of each SNPs, if provided when the object was
constructed.</p>
</dd>
<dt>alleles&lt;-</dt><dd><p><code>signature(x = "genlight")</code>: sets the names
of the alleles of each SNPs using a character vector of length
<code>nLoc(x)</code>; for each SNP, two alleles must be provided,
separated by a &quot;/&quot;, e.g. 'a/t', 'c/a', etc.</p>
</dd>
<dt>chromosome</dt><dd><p><code>signature(x = "genlight")</code>: returns a factor
indicating the chromosome of each SNPs, or NULL if the information
is missing.</p>
</dd>
<dt>chromosome&lt;-</dt><dd><p><code>signature(x = "genlight")</code>: sets the
chromosome to which SNPs belong using a factor of length
<code>nLoc(x)</code>.</p>
</dd>
<dt>chr</dt><dd><p><code>signature(x = "genlight")</code>: shortcut for
<code>chromosome</code>.</p>
</dd>
<dt>chr&lt;-</dt><dd><p><code>signature(x = "genlight")</code>: shortcut for
<code>chromosome&lt;-</code>.</p>
</dd>
<dt>position</dt><dd><p><code>signature(x = "genlight")</code>: returns an integer
vector indicating the position of each SNPs, or NULL if the
information is missing.</p>
</dd>
<dt>position&lt;-</dt><dd><p><code>signature(x = "genlight")</code>: sets the
positions of the SNPs using an integer vector of length
<code>nLoc(x)</code>.</p>
</dd>
<dt>pop</dt><dd><p><code>signature(x = "genlight")</code>: returns a factor
indicating the population of each individual, if provided when the
object was constructed.</p>
</dd>
<dt>pop&lt;-</dt><dd><p><code>signature(x = "genlight")</code>: sets the population
of each individual using a factor of length <code>nInd(x)</code>.</p>
</dd>
<dt>other</dt><dd><p><code>signature(x = "genlight")</code>: returns the content of
the slot <code>@other</code>.</p>
</dd>
<dt>other&lt;-</dt><dd><p><code>signature(x = "genlight")</code>: sets the content of
the slot <code>@other</code>.</p>
</dd>
<dt>as.matrix</dt><dd><p><code>signature(x = "genlight")</code>: converts a
<code>genlight</code> object into a matrix of integers, with individuals
in rows and SNPs in columns. The S4 method 'as' can be used as
well (e.g. as(x, &quot;matrix&quot;)).</p>
</dd>
<dt>as.data.frame</dt><dd><p><code>signature(x = "genlight")</code>: same as <code>as.matrix</code>.</p>
</dd>
<dt>as.list</dt><dd><p><code>signature(x = "genlight")</code>: converts a
<code>genlight</code> object into a list of genotypes coded as vector of
integers (numbers of second allele). The S4 method 'as' can be
used as well (e.g. as(x, &quot;list&quot;)).</p>
</dd>
<dt>cbind</dt><dd><p><code>signature(x = "genlight")</code>: merges several
<a href="#topic+genlight-class">genlight</a> objects by column, i.e. regroups data of
identical individuals genotyped for different SNPs.</p>
</dd>
<dt>rbind</dt><dd><p><code>signature(x = "genlight")</code>: merges several
<a href="#topic+genlight-class">genlight</a> objects by row, i.e. regroups data of
different individuals genotyped for the same SNPs.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thibaut Jombart (<a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>)<br />
Zhian N. Kamvar (<a href="mailto:kamvarz@science.oregonstate.edu">kamvarz@science.oregonstate.edu</a>)</p>


<h3>See Also</h3>

<p>Related class:<br />
-  <code><a href="#topic+SNPbin-class">SNPbin</a></code>, for storing individual genotypes of
binary SNPs<br />
</p>
<p>-  <code><a href="#topic+genind-class">genind</a></code>, for storing other types of genetic markers. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## TOY EXAMPLE ##
## create and convert data
dat &lt;- list(toto=c(1,1,0,0), titi=c(NA,1,1,0), tata=c(NA,0,3, NA))
x &lt;- new("genlight", dat)
x

## examine the content of the object
names(x)
x@gen
x@gen[[1]]@snp # bit-level coding for first individual

## conversions
as.list(x)
as.matrix(x)

## round trips - must return TRUE
identical(x, new("genlight", as.list(x))) # list
identical(x, new("genlight", as.matrix(x))) # matrix
identical(x, new("genlight", as.data.frame(x))) # data.frame

## test subsetting
x[c(1,3)] # keep individuals 1 and 3
as.list(x[c(1,3)])
x[c(1,3), 1:2] # keep individuals 1 and 3, loci 1 and 2
as.list(x[c(1,3), 1:2])
x[c(TRUE,FALSE), c(TRUE,TRUE,FALSE,FALSE)] # same, using logicals
as.list(x[c(TRUE,FALSE), c(TRUE,TRUE,FALSE,FALSE)])


## REAL-SIZE EXAMPLE ##
## 50 genotypes of 1,000,000 SNPs
dat &lt;- lapply(1:50, function(i) sample(c(0,1,NA), 1e6, prob=c(.5, .49, .01), replace=TRUE))
names(dat) &lt;- paste("indiv", 1:length(dat))
print(object.size(dat), unit="aut") # size of the original data

x &lt;- new("genlight", dat) # conversion
x
print(object.size(x), unit="au") # size of the genlight object
object.size(dat)/object.size(x) # conversion efficiency



#### cbind, rbind ####
a &lt;- new("genlight", list(toto=rep(1,10), tata=rep(c(0,1), each=5), titi=c(NA, rep(1,9)) ))

ara &lt;- rbind(a,a)
ara
as.matrix(ara)

aca &lt;- cbind(a,a)
aca
as.matrix(aca)


#### subsetting @other ####
x &lt;- new("genlight", list(a=1,b=0,c=1), other=list(1:3, letters,data.frame(2:4)))
x
other(x)
x[2:3]
other(x[2:3])
other(x[2:3, treatOther=FALSE])


#### seppop ####
pop(x) # no population info
pop(x) &lt;- c("pop1","pop1", "pop2") # set population memberships
pop(x)
seppop(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='genpop+20class'>adegenet formal class (S4) for allele counts in populations</h2><span id='topic+genpop-class'></span><span id='topic+dist+2Cgenpop+2CANY+2CANY+2CANY+2Cmissing-method'></span><span id='topic+names+2Cgenpop-method'></span><span id='topic+show+2Cgenpop-method'></span><span id='topic+summary+2Cgenpop-method'></span><span id='topic+print+2CgenpopSummary-method'></span><span id='topic+print.genpopSummary'></span><span id='topic+is.genpop'></span>

<h3>Description</h3>

<p>An object of class <code>genpop</code> contain alleles counts
for several loci.<br />
It contains several components (see 'slots' section).<br />
Such object is obtained using <code>genind2genpop</code> which converts
individuals genotypes of known population into a <code>genpop</code> object.
Note that the function <code>summary</code> of a <code>genpop</code> object
returns a list of components.
Note that as in other S4 classes, slots are accessed using @ instead
of $.
</p>


<h3>Slots</h3>


<dl>
<dt><code>tab</code>:</dt><dd><p>matrix of alleles counts for each combinaison of population
(in rows) and alleles (in columns).</p>
</dd>
<dt><code>loc.fac</code>:</dt><dd><p>locus factor for the columns of <code>tab</code></p>
</dd>
<dt><code>loc.n.all</code>:</dt><dd><p>integer vector giving the number of alleles per locus</p>
</dd>
<dt><code>all.names</code>:</dt><dd><p>list having one component per locus, each containing a character vector of alleles names</p>
</dd>
<dt><code>call</code>:</dt><dd><p>the matched call</p>
</dd>
<dt><code>ploidy</code>:</dt><dd><p> an integer indicating the degree of ploidy of
the genotypes. Beware: 2 is not an integer, but as.integer(2) is.</p>
</dd>
<dt><code>type</code>:</dt><dd><p> a character string indicating the type of
marker: 'codom' stands for 'codominant' (e.g. microstallites,
allozymes); 'PA' stands for 'presence/absence' (e.g. AFLP).</p>
</dd>
<dt><code>other</code>:</dt><dd><p>(optional) a list containing other information</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+gen-class">gen</a>"</code>, directly.
Class <code>"<a href="#topic+popInfo-class">popInfo</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>names</dt><dd><p><code>signature(x = "genpop")</code>: give the names of the
components of a genpop object</p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "genpop")</code>: prints a genpop object</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "genpop")</code>: shows a genpop
object (same as print)</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "genpop")</code>: summarizes a
genpop object, invisibly returning its content or suppress printing of auxiliary information by specifying <code>verbose = FALSE</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+as.genpop">as.genpop</a></code>, <code><a href="#topic+is.genpop">is.genpop</a></code>,<code><a href="#topic+makefreq">makefreq</a></code>, <code><a href="#topic+genind">genind</a></code>, <code><a href="#topic+import2genind">import2genind</a></code>, <code><a href="#topic+read.genetix">read.genetix</a></code>, <code><a href="#topic+read.genepop">read.genepop</a></code>, <code><a href="#topic+read.fstat">read.fstat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obj1 &lt;- import2genind(system.file("files/nancycats.gen",
package="adegenet"))
obj1


obj2 &lt;- genind2genpop(obj1)
obj2

## Not run: 
data(microsatt)
# use as.genpop to convert convenient count tab to genpop
obj3 &lt;- as.genpop(microsatt$tab)
obj3

all(obj3@tab==microsatt$tab)

# perform a correspondance analysis
obj4 &lt;- genind2genpop(obj1,missing="chi2")
ca1 &lt;- dudi.coa(as.data.frame(obj4@tab),scannf=FALSE)
s.label(ca1$li,sub="Correspondance Analysis",csub=2)
add.scatter.eig(ca1$eig,2,xax=1,yax=2,posi="top")


## End(Not run)
</code></pre>

<hr>
<h2 id='global.rtest'>Global and local tests</h2><span id='topic+global.rtest'></span><span id='topic+local.rtest'></span>

<h3>Description</h3>

<p>These two Monte Carlo tests are used to assess the existence of global
and local spatial structures. They can be used as an aid to interprete
global and local components of spatial Principal Component Analysis
(sPCA).<br />
</p>
<p>They rely on the decomposition of a data matrix X into global and local
components using multiple regression on Moran's Eigenvector Maps (MEMs).
They require a data matrix (X) and a list of weights derived from a
connection network. X is regressed onto global MEMs (U+) in the global
test and on local ones (U-) in the local test. One mean <code class="reqn">R^2</code>
is obtained for each MEM, the k highest being summed to form the test
statistic.
</p>
<p>The reference distribution of these statistics are obtained by
randomly permuting the rows of X.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>global.rtest(X, listw, k = 1, nperm = 499)
local.rtest(X, listw, k = 1, nperm = 499)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="global.rtest_+3A_x">X</code></td>
<td>
<p>a data matrix, with variables in columns</p>
</td></tr>
<tr><td><code id="global.rtest_+3A_listw">listw</code></td>
<td>
<p>a list of weights of class <code>listw</code>. Can be obtained
easily using the function <code>chooseCN</code>.</p>
</td></tr>
<tr><td><code id="global.rtest_+3A_k">k</code></td>
<td>
<p>integer: the number of highest <code class="reqn">R^2</code> summed to form the test statistics</p>
</td></tr>
<tr><td><code id="global.rtest_+3A_nperm">nperm</code></td>
<td>
<p>integer: the number of randomisations to be performed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This test is purely R code. A C or C++ version will be developped soon.
</p>


<h3>Value</h3>

<p>An object of class <code>randtest</code>.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a></p>


<h3>References</h3>

<p>Jombart, T., Devillard, S., Dufour, A.-B. and Pontier, D.
Revealing cryptic spatial patterns in genetic variability by a new
multivariate method. <em>Heredity</em>, <b>101</b>, 92&ndash;103.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+chooseCN">chooseCN</a></code>, <code><a href="#topic+spca">spca</a></code>, <code><a href="#topic+monmonier">monmonier</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 data(sim2pop)
if(require(spdep)){
cn &lt;- chooseCN(sim2pop@other$xy,ask=FALSE,type=1,plot=FALSE,res="listw")

# global test
Gtest &lt;- global.rtest(sim2pop@tab,cn)
Gtest

# local test
Ltest &lt;- local.rtest(sim2pop@tab,cn)
Ltest
}

## End(Not run)
</code></pre>

<hr>
<h2 id='glPca'>Principal Component Analysis for genlight objects</h2><span id='topic+glPca'></span><span id='topic+print.glPca'></span><span id='topic+scatter.glPca'></span><span id='topic+loadingplot.glPca'></span>

<h3>Description</h3>

<p>These functions implement Principal Component Analysis (PCA) for
massive SNP datasets stored as <a href="#topic+genlight-class">genlight</a> object. This
implementation has the advantage of never representing to complete data
matrix, therefore making huge economies in terms of rapid access
memory (RAM). When the <code>parallel</code> package is available,
<code>glPca</code> uses multiple-core ressources for more efficient
computations. <code>glPca</code> returns lists with the class <code>glPca</code>
(see 'value'). 
</p>
<p>Other functions are defined for objects of this class:
</p>
<p>- <code>print</code>: prints the content of a <code>glPca</code> object.
</p>
<p>- <code>scatter</code>: produces scatterplots of principal components,
with a screeplot of eigenvalues as inset.
</p>
<p>- <code>loadingplot</code>: plots the loadings of the analysis for one given
axis, using an adapted version of the generic function <code>loadingplot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glPca(x, center = TRUE, scale = FALSE, nf = NULL, loadings = TRUE, 
    alleleAsUnit = FALSE, useC = TRUE, parallel = FALSE,
  n.cores = NULL, returnDotProd=FALSE, matDotProd=NULL)

## S3 method for class 'glPca'
print(x, ...)

## S3 method for class 'glPca'
scatter(x, xax = 1, yax = 2, posi = "bottomleft", bg = "white", 
    ratio = 0.3, label = rownames(x$scores), clabel = 1, xlim = NULL, 
    ylim = NULL, grid = TRUE, addaxes = TRUE, origin = c(0, 0), 
    include.origin = TRUE, sub = "", csub = 1, possub = "bottomleft", 
    cgrid = 1, pixmap = NULL, contour = NULL, area = NULL, ...)

## S3 method for class 'glPca'
loadingplot(x, at=NULL, threshold=NULL, axis=1,
    fac=NULL, byfac=FALSE, lab=rownames(x$loadings), cex.lab=0.7, cex.fac=1,
    lab.jitter=0, main="Loading plot", xlab="SNP positions",
    ylab="Contributions", srt = 90, adj = c(0, 0.5), ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glPca_+3A_x">x</code></td>
<td>
<p>for <code>glPca</code>, a <a href="#topic+genlight-class">genlight</a> object; for
<code>print</code>, <code>scatter</code>, and <code>loadingplot</code>, a <code>glPca</code>
object.</p>
</td></tr>
<tr><td><code id="glPca_+3A_center">center</code></td>
<td>
<p>a logical indicating whether the numbers of alleles
should be centered; defaults to TRUE</p>
</td></tr>
<tr><td><code id="glPca_+3A_scale">scale</code></td>
<td>
<p>a logical indicating whether the numbers of alleles
should be scaled; defaults to FALSE</p>
</td></tr>
<tr><td><code id="glPca_+3A_nf">nf</code></td>
<td>
<p>an integer indicating the number of principal components to
be retained; if NULL, a screeplot of eigenvalues will be displayed
and the user will be asked for a number of retained axes.</p>
</td></tr>
<tr><td><code id="glPca_+3A_loadings">loadings</code></td>
<td>
<p>a logical indicating whether loadings of the alleles
should be computed (TRUE, default), or not (FALSE). Vectors of
loadings are not always useful, and can take a large amount of
RAM when millions of SNPs are considered.</p>
</td></tr>
<tr><td><code id="glPca_+3A_alleleasunit">alleleAsUnit</code></td>
<td>
<p>a logical indicating whether alleles are
considered as units (i.e., a diploid genotype equals two samples, a
triploid, three, etc.) or whether individuals are considered as
units of information.</p>
</td></tr>
<tr><td><code id="glPca_+3A_usec">useC</code></td>
<td>
<p>a logical indicating whether compiled C code should be
used for faster computations; this option cannot be used alongside
parallel option.</p>
</td></tr>
<tr><td><code id="glPca_+3A_parallel">parallel</code></td>
<td>
<p>a logical indicating whether multiple cores -if
available- should be used for the computations (TRUE), or
not (FALSE, default); requires the package <code>parallel</code> to be installed
(see details); this option cannot be used alongside useCoption.</p>
</td></tr>
<tr><td><code id="glPca_+3A_n.cores">n.cores</code></td>
<td>
<p>if <code>parallel</code> is TRUE, the number of cores to be
used in the computations; if NULL, then the maximum number of cores
available on the computer is used.</p>
</td></tr>
<tr><td><code id="glPca_+3A_returndotprod">returnDotProd</code></td>
<td>
<p>a logical indicating whether the matrix of dot
products between individuals should be returned (TRUE) or not
(FALSE, default).</p>
</td></tr>
<tr><td><code id="glPca_+3A_matdotprod">matDotProd</code></td>
<td>
<p>an optional matrix of dot products between
individuals, NULL by default. This option is used internally to
speed up computation time when re-running the same PCA several
times. Leave this argument as NULL unless you really know what you
are doing.</p>
</td></tr>
<tr><td><code id="glPca_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to other functions.</p>
</td></tr>
<tr><td><code id="glPca_+3A_xax">xax</code>, <code id="glPca_+3A_yax">yax</code></td>
<td>
<p><code>integers</code> specifying which principal components
should be shown in x and y axes. </p>
</td></tr>
<tr><td><code id="glPca_+3A_posi">posi</code>, <code id="glPca_+3A_bg">bg</code>, <code id="glPca_+3A_ratio">ratio</code></td>
<td>
<p>arguments used to customize the inset in scatterplots
of <code>glPca</code> results. See <code><a href="ade4.html#topic+add.scatter">add.scatter</a></code> documentation in the
ade4 package for more details.</p>
</td></tr>
<tr><td><code id="glPca_+3A_label">label</code>, <code id="glPca_+3A_clabel">clabel</code>, <code id="glPca_+3A_xlim">xlim</code>, <code id="glPca_+3A_ylim">ylim</code>, <code id="glPca_+3A_grid">grid</code>, <code id="glPca_+3A_addaxes">addaxes</code>, <code id="glPca_+3A_origin">origin</code>, <code id="glPca_+3A_include.origin">include.origin</code>, <code id="glPca_+3A_sub">sub</code>, <code id="glPca_+3A_csub">csub</code>, <code id="glPca_+3A_possub">possub</code>, <code id="glPca_+3A_cgrid">cgrid</code>, <code id="glPca_+3A_pixmap">pixmap</code>, <code id="glPca_+3A_contour">contour</code>, <code id="glPca_+3A_area">area</code></td>
<td>

<p>arguments passed to <code><a href="ade4.html#topic+s.class">s.class</a></code>; see <code>?s.label</code> for more information</p>
</td></tr>
<tr><td><code id="glPca_+3A_at">at</code></td>
<td>
<p>an optional numeric vector giving the abscissa at which
loadings are plotted. Useful when variates are SNPs with a known
position in an alignement.</p>
</td></tr>
<tr><td><code id="glPca_+3A_threshold">threshold</code></td>
<td>
<p>a threshold value above which values of x are
identified. By default, this is the third quartile of x.</p>
</td></tr>
<tr><td><code id="glPca_+3A_axis">axis</code></td>
<td>
<p>an integer indicating the column of x to be plotted; used
only if x is a matrix-like object.</p>
</td></tr>
<tr><td><code id="glPca_+3A_fac">fac</code></td>
<td>
<p>a factor defining groups of SNPs.</p>
</td></tr>
<tr><td><code id="glPca_+3A_byfac">byfac</code></td>
<td>
<p>a logical stating whether loadings should be averaged by
groups of SNPs, as defined by <code>fac</code>.</p>
</td></tr>
<tr><td><code id="glPca_+3A_lab">lab</code></td>
<td>
<p>a character vector giving the labels used to annotate
values above the threshold.</p>
</td></tr>
<tr><td><code id="glPca_+3A_cex.lab">cex.lab</code></td>
<td>
<p>a numeric value indicating the size of annotations.</p>
</td></tr>
<tr><td><code id="glPca_+3A_cex.fac">cex.fac</code></td>
<td>
<p>a numeric value indicating the size of annotations for
groups of observations.</p>
</td></tr>
<tr><td><code id="glPca_+3A_lab.jitter">lab.jitter</code></td>
<td>
<p>a numeric value indicating the factor of
randomisation for the position of annotations. Set to 0 (by default)
implies no randomisation.</p>
</td></tr>
<tr><td><code id="glPca_+3A_main">main</code></td>
<td>
<p>the main title of the figure.</p>
</td></tr>
<tr><td><code id="glPca_+3A_xlab">xlab</code></td>
<td>
<p>the title of the x axis.</p>
</td></tr>
<tr><td><code id="glPca_+3A_ylab">ylab</code></td>
<td>
<p>the title of the y axis.</p>
</td></tr>
<tr><td><code id="glPca_+3A_srt">srt</code></td>
<td>
<p>rotation of the labels; see ?text.</p>
</td></tr>
<tr><td><code id="glPca_+3A_adj">adj</code></td>
<td>
<p>adjustment of the labels; see ?text.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>=== Using multiple cores ===
</p>
<p>Most recent machines have one or several processors with multiple
cores. R processes usually use one single core. The package
<code>parallel</code> allows for parallelizing some computations on
multiple cores, which can decrease drastically computational time.
</p>
<p>Lastly, note that using compiled C code (<code>useC=TRUE</code>)is an
alternative for speeding up computations, but cannot be used together
with the parallel option.
</p>


<h3>Value</h3>

<p>=== glPca objects ===
</p>
<p>The class <code>glPca</code> is a list with the following
components:<br />
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>eig</code></td>
<td>
<p>a numeric vector of eigenvalues.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>a matrix of principal components, containing the
coordinates of each individual (in row) on each principal axis (in column).</p>
</td></tr>
<tr><td><code>loadings</code></td>
<td>
<p>(optional) a matrix of loadings, containing the loadings of each
SNP (in row) for each principal axis (in column).</p>
</td></tr>
</table>
<p>-
</p>
<p>=== other outputs ===
</p>
<p>Other functions have different outputs:<br />
- <code>scatter</code> return the matched call.<br />
- <code>loadingplot</code> returns information about the most contributing
SNPs (see <code><a href="#topic+loadingplot.default">loadingplot.default</a></code>)
</p>


<h3>Author(s)</h3>

<p> Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a> </p>


<h3>See Also</h3>

<p>- <code><a href="#topic+genlight-class">genlight</a></code>: class of object for storing massive binary
SNP data.
</p>
<p>- <code><a href="#topic+glSim">glSim</a></code>: a simple simulator for <a href="#topic+genlight-class">genlight</a> objects.
</p>
<p>- <code><a href="#topic+glPlot">glPlot</a></code>: plotting <a href="#topic+genlight-class">genlight</a> objects.
</p>
<p>- <code><a href="#topic+dapc">dapc</a></code>: Discriminant Analysis of Principal Components.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## simulate a toy dataset
x &lt;- glSim(50,4e3, 50, ploidy=2)
x
plot(x)

## perform PCA
pca1 &lt;- glPca(x, nf=2)

## plot eigenvalues
barplot(pca1$eig, main="eigenvalues", col=heat.colors(length(pca1$eig)))

## basic plot
scatter(pca1, ratio=.2)

## plot showing groups
s.class(pca1$scores, pop(x), col=colors()[c(131,134)])
add.scatter.eig(pca1$eig,2,1,2)

## End(Not run)
</code></pre>

<hr>
<h2 id='glPlot'>Plotting genlight objects</h2><span id='topic+glPlot'></span><span id='topic+plot.genlight'></span><span id='topic+plot+2Cgenlight-method'></span><span id='topic+plot+2Cgenlight+2CANY-method'></span>

<h3>Description</h3>

<p><a href="#topic+genlight-class">genlight</a> object can be plotted using the function
<code>glPlot</code>, which is also used as the dedicated <code>plot</code>
method. These functions relie on <code><a href="Matrix.html#topic+image">image</a></code> to represent SNPs
data. More specifically, colors are used to represent the number of
second allele for each locus and individual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glPlot(x, col=NULL, legend=TRUE, posi="bottomleft", bg=rgb(1,1,1,.5),...)

## S4 method for signature 'genlight'
plot(x, y=NULL, col=NULL, legend=TRUE, posi="bottomleft", bg=rgb(1,1,1,.5),...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glPlot_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+genlight-class">genlight</a> object.</p>
</td></tr>
<tr><td><code id="glPlot_+3A_col">col</code></td>
<td>
<p>an optional color vector; the first value corresponds to 0
alleles, the last value corresponds to the ploidy level of the
data. Therefore, the vector should have a length of (<code>ploidy(x)+1</code>).</p>
</td></tr>
<tr><td><code id="glPlot_+3A_legend">legend</code></td>
<td>
<p>a logical indicating whether a legend should be added to
the plot.</p>
</td></tr>
<tr><td><code id="glPlot_+3A_posi">posi</code></td>
<td>
<p>a character string indicating where the legend should be
positioned. Can be any concatenation of &quot;bottom&quot;/&quot;top&quot; and &quot;left&quot;/&quot;right&quot;.</p>
</td></tr>
<tr><td><code id="glPlot_+3A_bg">bg</code></td>
<td>
<p>a color used as a background for the legend; by default,
transparent white is used; this may not be supported on some
devices, and therefore background should be specified
(e.g. <code>bg="white"</code>).</p>
</td></tr>
<tr><td><code id="glPlot_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="Matrix.html#topic+image">image</a></code>.</p>
</td></tr>
<tr><td><code id="glPlot_+3A_y">y</code></td>
<td>
<p>ununsed argument, present for compatibility with the
<code>plot</code> generic.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a> </p>


<h3>See Also</h3>

<p>- <code><a href="#topic+genlight">genlight</a></code>: class of object for storing massive binary
SNP data.
</p>
<p>- <code><a href="#topic+glSim">glSim</a></code>: a simple simulator for <a href="#topic+genlight-class">genlight</a>
objects.
</p>
<p>- <code><a href="#topic+glPca">glPca</a></code>: PCA for <a href="#topic+genlight-class">genlight</a> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## simulate data
x &lt;- glSim(100, 1e3, n.snp.struc=100, ploid=2)

## default plot
glPlot(x)
plot(x) # identical plot

## disable legend
plot(x, leg=FALSE)

## use other colors
plot(x, col=heat.colors(3), bg="white")

## End(Not run)
</code></pre>

<hr>
<h2 id='glSim'>Simulation of simple genlight objects</h2><span id='topic+glSim'></span>

<h3>Description</h3>

<p>The function <code>glSim</code> simulates simple SNP data with the
possibility of contrasted structures between two groups
as well as background ancestral population structure. 
Returned objects are instances of the class <a href="#topic+genlight-class">genlight</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glSim(n.ind, n.snp.nonstruc, n.snp.struc = 0, grp.size = c(0.5, 0.5), k = NULL,
                    pop.freq = NULL, ploidy = 1, alpha = 0, parallel = FALSE,
                    LD = TRUE, block.minsize = 10, block.maxsize = 1000, theta = NULL,
                    sort.pop = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glSim_+3A_n.ind">n.ind</code></td>
<td>
<p>an integer indicating the number of individuals to be simulated.</p>
</td></tr>
<tr><td><code id="glSim_+3A_n.snp.nonstruc">n.snp.nonstruc</code></td>
<td>
<p>an integer indicating the number of
non-structured SNPs to be simulated; for these SNPs, all individuals
are drawn from the same binomial distribution.</p>
</td></tr>
<tr><td><code id="glSim_+3A_n.snp.struc">n.snp.struc</code></td>
<td>
<p>an integer indicating the number of
structured SNPs to be simulated; for these SNPs, different
binomial distributions are used for the two simulated groups;
frequencies of the derived alleles in groups A and B are built to
differ (see details).</p>
</td></tr>
<tr><td><code id="glSim_+3A_grp.size">grp.size</code></td>
<td>
<p>a vector of length 2 specifying the proportions of the two 
phenotypic groups (must sum to 1). By default, both groups have the same
size.</p>
</td></tr>
<tr><td><code id="glSim_+3A_k">k</code></td>
<td>
<p>an integer specifying the number of ancestral populations to be 
generated.</p>
</td></tr>
<tr><td><code id="glSim_+3A_pop.freq">pop.freq</code></td>
<td>
<p>a vector of length <code>k</code> specifying the proportions of the
k ancestral populations (must sum to 1). If, as by default, <code>pop.freq</code> 
is null, and <code>k</code> is non-null, <code>pop.freq</code> will be the result of
random sampling into k population groups.</p>
</td></tr>
<tr><td><code id="glSim_+3A_ploidy">ploidy</code></td>
<td>
<p>an integer indicating the ploidy of the simulated
genotypes.</p>
</td></tr>
<tr><td><code id="glSim_+3A_alpha">alpha</code></td>
<td>
<p>asymmetry parameter: a numeric value between 0 and 0.5,
used to enforce allelic differences between the groups. Differences
between groups are strongest when alpha = 0.5 and weakest when 
alpha = 0 (see details).</p>
</td></tr>
<tr><td><code id="glSim_+3A_parallel">parallel</code></td>
<td>
<p>a logical indicating whether multiple cores should be used in 
generating the simulated data (TRUE). This option can reduce the amount of 
computational time required to simulate the data, but is not supported on 
Windows.</p>
</td></tr>  
<tr><td><code id="glSim_+3A_ld">LD</code></td>
<td>
<p>a logical indicating whether loci should be displaying
linkage disequilibrium (TRUE) or be generated independently
(FALSE, default). When set to TRUE, data are generated by blocks of
correlated SNPs (see details).</p>
</td></tr>
<tr><td><code id="glSim_+3A_block.minsize">block.minsize</code></td>
<td>
<p>an optional integer indicating the minimum number of 
SNPs to be handled at a time during the simulation of linked SNPs (when 
<code>LD=TRUE</code>. Increasing the minimum block size will increase 
the RAM requirement but decrease the amount of computational time 
required to simulate the genotypes.</p>
</td></tr>
<tr><td><code id="glSim_+3A_block.maxsize">block.maxsize</code></td>
<td>
<p>an optional integer indicating the maximum number of SNPs
to be handled at a time during the simulation of linked SNPs. Note: if LD
blocks of equal size are desired, set block.minsize = block.maxsize.</p>
</td></tr>
<tr><td><code id="glSim_+3A_theta">theta</code></td>
<td>
<p>an optional numeric value between 0 and 0.5 specifying 
the extent to which linkage should be diluted.
Linkage is strongest when theta = 0 and weakest when theta = 0.5.</p>
</td></tr> 
<tr><td><code id="glSim_+3A_sort.pop">sort.pop</code></td>
<td>
<p>a logical specifying whether individuals should be ordered by
ancestral population (<code>sort.pop=TRUE</code>) or phenotypic population 
(<code>sort.pop=FALSE</code>).</p>
</td></tr>
<tr><td><code id="glSim_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the genlight constructor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>=== Allele frequencies in contrasted groups ===
</p>
<p>When <code>n.snp.struc</code> is greater than 0, some SNPs are simulated in
order to differ between groups (noted 'A' and 'B'). Different patterns 
between groups are achieved by using different
frequencies of the second allele for A and B, denoted <code class="reqn">p_A</code> and
<code class="reqn">p_B</code>. For a given SNP, <code class="reqn">p_A</code> is drawn from a uniform
distribution between 0 and (0.5 - alpha). <code class="reqn">p_B</code> is then computed
as 1 - <code class="reqn">p_A</code>. Therefore, differences between groups are mild for
alpha=0, and total for alpha = 0.5.
</p>
<p>=== Linked or independent loci ===
</p>
<p>Independent loci (<code>LD=FALSE</code>) are simulated using the standard
binomial distribution, with randomly generated allele
frequencies. Linked loci (<code>LD=FALSE</code>) are trickier towe need to
simulate discrete variables with pre-defined correlation structure.
</p>
<p>Here, we first generate deviates from multivariate normal
distributions with randomly generated correlation structures. These
variables are then discretized using the quantiles of the
distribution. Further improvement of the procedure will aim at i)
specifying the strength of the correlations between blocks of alleles
and ii) enforce contrasted structures between groups.
</p>


<h3>Value</h3>

<p>A <a href="#topic+genlight-class">genlight</a> object.
</p>


<h3>Author(s)</h3>

<p> Caitlin Collins <a href="mailto:caitlin.collins12@imperial.ac.uk">caitlin.collins12@imperial.ac.uk</a>,
Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a></p>


<h3>See Also</h3>

<p>- <code><a href="#topic+genlight-class">genlight</a></code>: class of object for storing massive binary
SNP data.
</p>
<p>- <code><a href="#topic+glPlot">glPlot</a></code>: plotting <a href="#topic+genlight-class">genlight</a> objects.
</p>
<p>- <code><a href="#topic+glPca">glPca</a></code>: PCA for <a href="#topic+genlight-class">genlight</a> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## no structure
x &lt;- glSim(100, 1e3, ploid=2)
plot(x)

## 1,000 non structured SNPs, 100 structured SNPs
x &lt;- glSim(100, 1e3, n.snp.struc=100, ploid=2)
plot(x)

## 1,000 non structured SNPs, 100 structured SNPs, ploidy=4
x &lt;- glSim(100, 1e3, n.snp.struc=100, ploid=4)
plot(x)

## same thing, stronger differences between groups
x &lt;- glSim(100, 1e3, n.snp.struc=100, ploid=2, alpha=0.4)
plot(x)

##  same thing, loci with LD structures
x &lt;- glSim(100, 1e3, n.snp.struc=100, ploid=2, alpha=0.4, LD=TRUE, block.minsize=100)
plot(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='H3N2'>Seasonal influenza (H3N2) HA segment data</h2><span id='topic+H3N2'></span><span id='topic+usflu'></span><span id='topic+usflu.fasta'></span><span id='topic+USflu'></span><span id='topic+USflu.fasta'></span>

<h3>Description</h3>

<p>The dataset <code>H3N2</code> consists of 1903 strains of seasonal influenza
(H3N2) distributed worldwide, and typed at 125 SNPs located in the
hemagglutinin (HA) segment. It is stored as an R object with class
<a href="#topic+genind-class">genind</a> and can be accessed as usual using <code>data(H3N2)</code>
(see example). These data were gathered from DNA sequences available from
Genbank (http://www.ncbi.nlm.nih.gov/Genbank/).
</p>


<h3>Format</h3>

<p><code>H3N2</code> is a genind object with several data frame as
supplementary components (<code>H3N2@other) slort</code>, which contains the
following items: </p>
 <dl>
<dt>x</dt><dd><p>a <code>data.frame</code> containing
miscellaneous annotations of the sequences.</p>
</dd> <dt>xy</dt><dd><p>a matrix with two
columns indicating the geographic coordinates of the strains, as longitudes
and latitudes.</p>
</dd> <dt>epid</dt><dd><p>a character vector indicating the epidemic of
the strains.</p>
</dd> </dl>



<h3>Details</h3>

<p>The data file <code>usflu.fasta</code> is a toy dataset also gathered from
Genbank, consisting of the aligned sequences of 80 seasonal influenza
isolates (HA segment) sampled in the US, in <code>fasta</code> format. This file
is installed alongside the package; the path to this file is automatically
determined by R using <code>system.file</code> (see example in this manpage and in
?fasta2genlight) as well.
</p>


<h3>Source</h3>

<p>This dataset was prepared by Thibaut Jombart
(t.jombart@imperia.ac.uk), from annotated sequences available on Genbank
(http://www.ncbi.nlm.nih.gov/Genbank/).
</p>


<h3>References</h3>

<p>Jombart, T., Devillard, S. and Balloux, F. Discriminant analysis
of principal components: a new method for the analysis of genetically
structured populations. Submitted to <em>BMC genetics</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
#### H3N2 ####
## LOAD DATA
data(H3N2)
H3N2

## set population to yearly epidemics
pop(H3N2) &lt;- factor(H3N2$other$epid)



## PERFORM DAPC - USE POPULATIONS AS CLUSTERS
## to reproduce exactly analyses from the paper, use "n.pca=1000"
dapc1 &lt;- dapc(H3N2, all.contrib=TRUE, scale=FALSE, n.pca=150, n.da=5)
dapc1

## (see ?dapc for details about the output)


## SCREEPLOT OF EIGENVALUES
barplot(dapc1$eig, main="H3N2 - DAPC eigenvalues")


## SCATTERPLOT (axes 1-2)
scatter(dapc1, posi.da="topleft", cstar=FALSE, cex=2, pch=17:22,
solid=.5, bg="white")




#### usflu.fasta ####
myPath &lt;- system.file("files/usflu.fasta",package="adegenet")
myPath

## extract SNPs from alignments using fasta2genlight
## see ?fasta2genlight for more details
obj &lt;- fasta2genlight(myPath, chunk=10) # process 10 sequences at a time
obj

## End(Not run)

</code></pre>

<hr>
<h2 id='haploGen'>Simulation of genealogies of haplotypes</h2><span id='topic+haploGen'></span><span id='topic+print.haploGen'></span><span id='topic++5B.haploGen'></span><span id='topic+labels.haploGen'></span><span id='topic+as.POSIXct.haploGen'></span><span id='topic+seqTrack.haploGen'></span><span id='topic+haploGen-class'></span><span id='topic+as.seqTrack.haploGen'></span><span id='topic+as.igraph.haploGen'></span><span id='topic+plot.haploGen'></span><span id='topic+plotHaploGen'></span><span id='topic+sample.haploGen'></span>

<h3>Description</h3>

<p>The function <code>haploGen</code> implements simulations of genealogies of
haplotypes. This forward-time, individual-based simulation tool allows
haplotypes to replicate and mutate according to specified parameters,
and keeps track of their genealogy.
</p>
<p>Simulations can be spatially explicit or not (see <code>geo.sim</code>
argument). In the first case, haplotypes are assigned to locations on
a regular grip. New haplotypes disperse from their ancestor's location
according to a random Poisson diffusion, or alternatively according to
a pre-specified migration scheme. This tool does not allow for
simulating selection or linkage disequilibrium.
</p>
<p>Produced objects are lists with the class <code>haploGen</code>; see 'value'
section for more information on this class. Other functions are
available to print, plot, subset, sample or convert <code>haploGen</code>
objects. A seqTrack method is also provided for analysing
<code>haploGen</code> objects.
</p>
<p>Note that for simulation of outbreaks, the new tool <code>simOutbreak</code>
in the <code>outbreaker</code> package should be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haploGen(seq.length=1e4, mu.transi=1e-4, mu.transv=mu.transi/2, t.max=20,
         gen.time=function(){1+rpois(1,0.5)},
         repro=function(){rpois(1,1.5)}, max.nb.haplo=200,
         geo.sim=FALSE, grid.size=10, lambda.xy=0.5,
         mat.connect=NULL,
         ini.n=1, ini.xy=NULL)
## S3 method for class 'haploGen'
print(x, ...)
## S3 method for class 'haploGen'
as.igraph(x, col.pal=redpal, ...)
## S3 method for class 'haploGen'
plot(x, y=NULL, col.pal=redpal, ...)
## S3 method for class 'haploGen'
x[i, j, drop=FALSE]
## S3 method for class 'haploGen'
labels(object, ...)
## S3 method for class 'haploGen'
as.POSIXct(x, tz="", origin=as.POSIXct("2000/01/01"), ...)
## S3 method for class 'haploGen'
seqTrack(x, best=c("min","max"), prox.mat=NULL, ...)
as.seqTrack.haploGen(x)
plotHaploGen(x, annot=FALSE, date.range=NULL, col=NULL, bg="grey", add=FALSE, ...)
sample.haploGen(x, n)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="haploGen_+3A_seq.length">seq.length</code></td>
<td>
<p>an integer indicating the length of the simulated
haplotypes, in number of nucleotides.</p>
</td></tr>
<tr><td><code id="haploGen_+3A_mu.transi">mu.transi</code></td>
<td>
<p>the rate of transitions, in number of mutation per site and per
time unit.</p>
</td></tr>
<tr><td><code id="haploGen_+3A_mu.transv">mu.transv</code></td>
<td>
<p>the rate of transversions, in number of mutation per site and per
time unit.</p>
</td></tr>
<tr><td><code id="haploGen_+3A_t.max">t.max</code></td>
<td>
<p>an integer indicating the maximum number of time units to
run the simulation for.</p>
</td></tr>
<tr><td><code id="haploGen_+3A_gen.time">gen.time</code></td>
<td>
<p>an integer indicating the generation time, in number
of time units. Can be a (fixed) number or a function returning a number
(then called for each reproduction event).</p>
</td></tr>
<tr><td><code id="haploGen_+3A_repro">repro</code></td>
<td>
<p>an integer indicating the number of descendents per
haplotype. Can be a (fixed) number or a function returning a number
(then called for each reproduction event).</p>
</td></tr>
<tr><td><code id="haploGen_+3A_max.nb.haplo">max.nb.haplo</code></td>
<td>
<p>an integer indicating the maximum number of
haplotypes handled at any time of the simulation, used to control the
size of the produced object. Larger number will lead to slower
simulations. If this number is exceeded, the genealogy is prunded to as
to keep this number of haplotypes.</p>
</td></tr>
<tr><td><code id="haploGen_+3A_geo.sim">geo.sim</code></td>
<td>
<p>a logical stating whether simulations should be
spatially explicit (TRUE) or not (FALSE, default). Spatially-explicit
simulations are slightly slower than their non-spatial counterpart.</p>
</td></tr>
<tr><td><code id="haploGen_+3A_grid.size">grid.size</code></td>
<td>
<p>the size of the square grid of possible locations for
spatial simulations. The total number of locations will be this number
squared.</p>
</td></tr>
<tr><td><code id="haploGen_+3A_lambda.xy">lambda.xy</code></td>
<td>
<p>the parameter of the Poisson distribution used to
determine dispersion in x and y axes.</p>
</td></tr>
<tr><td><code id="haploGen_+3A_mat.connect">mat.connect</code></td>
<td>
<p>a matrix of connectivity describing migration
amongts all pairs of locations. <code>mat.connect[i,j]</code> indicates the
probability, being in 'i', to migrate to 'j'. The rows of this matrix
thus sum to 1. It has as many rows and columns as there are locations,
with row 'i' / column 'j' corresponding to locations number 'i' and 'j'.
Locations are numbered as in a matrix in which rows and columns are
respectively x and y coordinates. For instance, in a 5x5 grid, locations
are numbered as in <code>matrix(1:25,5,5)</code>.</p>
</td></tr>
<tr><td><code id="haploGen_+3A_ini.n">ini.n</code></td>
<td>
<p>an integer specifying the number of (identical)
haplotypes to initiate the simulation</p>
</td></tr>
<tr><td><code id="haploGen_+3A_ini.xy">ini.xy</code></td>
<td>
<p>a vector of two integers giving the x/y coordinates of the initial haplotype.</p>
</td></tr>
<tr><td><code id="haploGen_+3A_x">x</code>, <code id="haploGen_+3A_object">object</code></td>
<td>
<p><code>haploGen</code> objects.</p>
</td></tr>
<tr><td><code id="haploGen_+3A_y">y</code></td>
<td>
<p>unused argument, for compatibility with 'plot'.</p>
</td></tr>
<tr><td><code id="haploGen_+3A_col.pal">col.pal</code></td>
<td>
<p>a color palette to be used to represent weights using
colors on the edges of the graph. See <code>?num2col</code>. Note that the
palette is inversed by default.</p>
</td></tr>
<tr><td><code id="haploGen_+3A_i">i</code>, <code id="haploGen_+3A_j">j</code>, <code id="haploGen_+3A_drop">drop</code></td>
<td>
<p><code>i</code> is a vector used for subsetting the object. For
instance, <code>i=1:3</code> will retain only the first three haplotypes of the
genealogy. <code>j</code> and <code>drop</code> are only provided for compatibility,
but not used.</p>
</td></tr>
<tr><td><code id="haploGen_+3A_best">best</code>, <code id="haploGen_+3A_prox.mat">prox.mat</code></td>
<td>
<p>arguments to be passed to the
<code><a href="#topic+seqTrack">seqTrack</a></code> function. See documentation of
<code><a href="#topic+seqTrack">seqTrack</a></code> for more information.</p>
</td></tr>
<tr><td><code id="haploGen_+3A_annot">annot</code>, <code id="haploGen_+3A_date.range">date.range</code>, <code id="haploGen_+3A_col">col</code>, <code id="haploGen_+3A_bg">bg</code>, <code id="haploGen_+3A_add">add</code></td>
<td>
<p>arguments to be passed to <code><a href="#topic+plotSeqTrack">plotSeqTrack</a></code>.</p>
</td></tr>
<tr><td><code id="haploGen_+3A_n">n</code></td>
<td>
<p>an integer indicating the number of haplotypes to be retained
in the sample</p>
</td></tr>


<tr><td><code id="haploGen_+3A_tz">tz</code>, <code id="haploGen_+3A_origin">origin</code></td>
<td>
<p> aguments to be passed to <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>
(see ?as.POSIXct)</p>
</td></tr>
<tr><td><code id="haploGen_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to other methods; for
'plot', arguments are passed to <code>plot.igraph</code>.</p>
</td></tr>



</table>


<h3>Details</h3>

<p>=== Dependencies with other packages ===<br />
- ape package is required as it implements efficient handling of DNA
sequences used in <code>haploGen</code> objects. To install this package,
simply type:<br />
<code>install.packages("ape")</code>
</p>
<p>- for various purposes including plotting, converting genealogies to
graphs can be useful. From adegenet version 1.3-5 onwards, this is
achieved using the package <code>igraph</code>. See below.
</p>
<p>=== Converting haploGen objects to graphs ===<br />
<code>haploGen</code> objects can be converted to <code>igraph</code>
objects (package <code>igraph</code>), which can in turn be plotted and manipulated using classical
graph tools. Simply use 'as.igraph(x)' where 'x' is a
<code>haploGen</code> object. This functionality requires the <code>igraph</code>
package. Graphs are time oriented (top=old, bottom=recent).
</p>


<h3>Value</h3>

<p>=== haploGen class ===<br />
<code>haploGen</code> objects are lists containing the following slots:<br />
- seq: DNA sequences in the DNAbin matrix format<br />
- dates: dates of appearance of the haplotypes<br />
- ances: a vector of integers giving the index of each haplotype's
ancestor<br />
- id: a vector of integers giving the index of each haplotype<br />
- xy: (optional) a matrix of spatial coordinates of haplotypes<br />
- call: the matched call
</p>
<p>=== misc functions ===<br />
- as.POSIXct: returns a vector of dates with POSIXct format<br />
- labels: returns the labels of the haplotypes<br />
- as.seqTrack: returns a seqTrack object. Note that this object is not a
proper seqTrack analysis, but just a format conversion convenient for
plotting <code>haploGen</code> objects.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a></p>


<h3>References</h3>

<p>Jombart T, Eggo R, Dodd P, Balloux F (2010) Reconstructing disease
outbreaks from genetic data: a graph approach. Heredity. doi:
10.1038/hdy.2010.78.
</p>


<h3>See Also</h3>

<p><code>simOutbreak</code> in the package 'outbreaker' for simulating disease
outbreaks under a realistic epidemiological model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(require(ape) &amp;&amp; require(igraph)){
## PERFORM SIMULATIONS
x &lt;- haploGen(geo.sim=TRUE)
x

## PLOT DATA
plot(x)

## PLOT SPATIAL SPREAD
plotHaploGen(x, bg="white")
title("Spatial dispersion")


## USE SEQTRACK RECONSTRUCTION
x.recons &lt;- seqTrack(x)
mean(x.recons$ances==x$ances, na.rm=TRUE) # proportion of correct reconstructions

g &lt;- as.igraph(x)
g
plot(g)
plot(g, vertex.size=0)


}

## End(Not run)
</code></pre>

<hr>
<h2 id='hier'>Access and manipulate the population hierarchy for genind or genlight objects.</h2><span id='topic+hier'></span><span id='topic+hier+2Cgenind-method'></span><span id='topic+hier+2Cgenlight-method'></span><span id='topic+hier+3C-'></span><span id='topic+hier+3C-+2Cgenind-method'></span><span id='topic+hier+3C-+2Cgenlight-method'></span>

<h3>Description</h3>

<p>The following methods allow the user to quickly change the hierarchy or
population of a genind or genlight object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hier(x, formula = NULL, combine = TRUE, value)

hier(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hier_+3A_x">x</code></td>
<td>
<p>a genind or genlight object</p>
</td></tr>
<tr><td><code id="hier_+3A_formula">formula</code></td>
<td>
<p>a nested formula indicating the order of the population 
hierarchy to be returned.</p>
</td></tr>
<tr><td><code id="hier_+3A_combine">combine</code></td>
<td>
<p>if <code>TRUE</code> (default), the levels will be combined
according to the formula argument. If it is <code>FALSE</code>, the levels will
not be combined.</p>
</td></tr>
<tr><td><code id="hier_+3A_value">value</code></td>
<td>
<p>a formula specifying the full hierarchy of columns in the strata
slot. <strong>(See Details below)</strong></p>
</td></tr>
</table>


<h3>Details</h3>

<p>You must first specify your strata before you can specify your 
hierarchies. Hierarchies are special cases of strata in that the levels 
must be nested within each other. An error will occur if you specify a 
hierarchy that is not truly hierarchical.
</p>


<h4>Details on Formulas</h4>

<p>The preferred use of these functions is with a <code><a href="stats.html#topic+formula">formula</a></code> 
object. Specifically, a hierarchical formula argument is used to name which
strata are hierarchical. An example of a hierarchical formula would
be:</p>

<table>
<tr>
 <td style="text-align: right;"> <code>~Country/City/Neighborhood</code></td>
</tr>

</table>
<p> This convention was
chosen as it becomes easier to type and makes intuitive sense when defining
a hierarchy. Note: it is important to use hierarchical formulas when
specifying hierarchies as other types of formulas (eg. 
<code>~Country*City*Neighborhood</code>) will give incorrect results.</p>



<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>See Also</h3>

<p><code><a href="#topic+strata">strata</a></code> <code><a href="#topic+genind">genind</a></code>
<code><a href="#topic+as.genind">as.genind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># let's look at the microbov data set:
data(microbov)
microbov

# We see that we have three vectors of different names in the 'other' slot. 
?microbov
# These are Country, Breed, and Species
names(other(microbov))

# Let's set the hierarchy
strata(microbov) &lt;- data.frame(other(microbov))
microbov

# And change the names so we know what they are
nameStrata(microbov) &lt;- ~Country/Breed/Species

# let's see what the hierarchy looks like by Species and Breed:
hier(microbov) &lt;- ~Species/Breed
head(hier(microbov, ~Species/Breed))

</code></pre>

<hr>
<h2 id='Hs'>Expected heterozygosity (Hs)</h2><span id='topic+Hs'></span>

<h3>Description</h3>

<p>This function computes the expected heterozygosity (Hs) within
populations of a <a href="#topic+genpop-class">genpop</a> object. This function is
available for codominant markers (<code>@type="codom"</code>) only. Hs is
commonly used for measuring within population genetic diversity (and
as such, it still has sense when computed from haploid data).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hs(x, pop = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hs_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+genind-class">genind</a> or <a href="#topic+genpop-class">genpop</a> object.</p>
</td></tr>
<tr><td><code id="Hs_+3A_pop">pop</code></td>
<td>
<p>only used if x is a <a href="#topic+genind-class">genind</a>; an optional factor to be used as population; if not provided, pop(x) is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <em>m(k)</em> be the number of alleles of locus <em>k</em>, with a
total of <em>K</em> loci. We note <code class="reqn">f_i</code> the allele frequency of
allele <em>i</em> in a given population. Then, <code class="reqn">Hs</code> is given for a
given population by:<br />
</p>
<p><code class="reqn">\frac{1}{K} \sum_{k=1}^K (1 - \sum_{i=1}^{m(k)} f_i^2)</code>
</p>


<h3>Value</h3>

<p>a vector of Hs values (one value per population)
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hs.test">Hs.test</a></code> to test differences in Hs between two groups
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(nancycats)
Hs(genind2genpop(nancycats))

## End(Not run)

</code></pre>

<hr>
<h2 id='Hs.test'>Test differences in expected heterozygosity (Hs)</h2><span id='topic+Hs.test'></span>

<h3>Description</h3>

<p>This procedure permits to test if two groups have
significant differences in expected heterozygosity (Hs).
The test statistic used is simply the difference in Hs
between the two groups 'x' and 'y':
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hs.test(x, y, n.sim = 999, alter = c("two-sided", "greater", "less"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hs.test_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+genind-class">genind</a> object.</p>
</td></tr>
<tr><td><code id="Hs.test_+3A_y">y</code></td>
<td>
<p>a <a href="#topic+genind-class">genind</a> object.</p>
</td></tr>
<tr><td><code id="Hs.test_+3A_n.sim">n.sim</code></td>
<td>
<p>the number of permutations to be used to generate the reference distribution.</p>
</td></tr>
<tr><td><code id="Hs.test_+3A_alter">alter</code></td>
<td>
<p>a character string indicating the alternative hypothesis</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code class="reqn">Hs(x) - Hs(y)</code>
</p>
<p>Individuals are randomly permuted between groups to obtain
a reference distribution of the test statistics.
</p>


<h3>Value</h3>

<p>an object of the class randtest
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hs">Hs</a></code> to compute Hs for different populations;
<code><a href="ade4.html#topic+as.randtest">as.randtest</a></code> for the class of Monte Carlo tests.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(microbov)
Hs(microbov)
test &lt;- Hs.test(microbov[pop="Borgou"],
                microbov[pop="Lagunaire"],
                n.sim=499)
test
plot(test)

## End(Not run)

</code></pre>

<hr>
<h2 id='HWE.test.genind'>Hardy-Weinberg Equilibrium test for multilocus data</h2><span id='topic+HWE.test.genind'></span>

<h3>Description</h3>

<p>The function <code>HWE.test</code> is a generic function to
perform Hardy-Weinberg Equilibrium tests defined by the
<code>genetics</code> package. adegenet proposes a method for <code>genind</code>
objects.<br />
</p>
<p>The output can be of two forms:<br />
- a list of tests (class <code>htest</code>) for each locus-population
combinaison <br />
- a population x locus matrix containing p-values of the tests  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'genind'
HWE.test(x,pop=NULL,permut=FALSE,nsim=1999,hide.NA=TRUE,res.type=c("full","matrix"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HWE.test.genind_+3A_x">x</code></td>
<td>
<p>an object of class <code>genind</code>.</p>
</td></tr>
<tr><td><code id="HWE.test.genind_+3A_pop">pop</code></td>
<td>
<p>a factor giving the population of each individual. If NULL,
pop is seeked from x$pop.</p>
</td></tr>
<tr><td><code id="HWE.test.genind_+3A_permut">permut</code></td>
<td>
<p>a logical passed to <code>HWE.test</code> stating whether
Monte Carlo version (TRUE) should be used or not (FALSE, default).</p>
</td></tr>
<tr><td><code id="HWE.test.genind_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations if Monte Carlo is used (passed to <code>HWE.test</code>).</p>
</td></tr>
<tr><td><code id="HWE.test.genind_+3A_hide.na">hide.NA</code></td>
<td>
<p>a logical stating whether non-tested loci (e.g., when
an allele is fixed) should be hidden in the results (TRUE, default)
or not (FALSE).</p>
</td></tr>
<tr><td><code id="HWE.test.genind_+3A_res.type">res.type</code></td>
<td>
<p>a character or a character vector whose only first
argument is considered giving the type of result to display. If
&quot;full&quot;, then a list of complete tests is returned. If &quot;matrix&quot;,
then a matrix of p-values is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Monte Carlo procedure is quiet computer-intensive when large
datasets are involved. For more precision on the performed test, read
<code>HWE.test</code> documentation (<code>genetics</code> package).
</p>


<h3>Value</h3>

<p>Returns either a list of tests or a matrix of p-values. In the
first case, each test is designated by locus first and then by
population. For instance if <code>res</code> is the &quot;full&quot; output of the
function, then the test for population &quot;PopA&quot; at locus &quot;Myloc&quot; is
given by res$Myloc$PopA. If <code>res</code> is a matrix of p-values,
populations are in rows and loci in columns. P-values are given for
the upper-tail: they correspond to the probability that an oberved
chi-square statistic as high as or higher than the one observed
occured under H0 (HWE).<br />  
</p>
<p>In all cases, NA values are likely to appear in fixed loci, or
entirely non-typed loci.
</p>


<h3>Author(s)</h3>

<p> Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a> </p>


<h3>See Also</h3>

<p><code>HWE.test</code> in the <code>genetics</code> package, <code><a href="stats.html#topic+chisq.test">chisq.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(nancycats)
obj &lt;- nancycats
if(require(genetics)){
obj.test &lt;- HWE.test(obj)

# pvalues matrix to have a preview
HWE.test(obj,res.type="matrix")

#more precise view to...
obj.test$fca90$P10
}

## End(Not run)
</code></pre>

<hr>
<h2 id='hybridize'>Function hybridize takes two genind in inputs
and generates hybrids individuals having one parent
in both objects.</h2><span id='topic+hybridize'></span>

<h3>Description</h3>

<p>The function <code>hybridize</code> performs hybridization between two set
of genotypes stored in <a href="#topic+genind-class">genind</a> objects (referred as the &quot;2
populations&quot;). Allelic frequencies are derived for each population,
and then gametes are sampled following a multinomial distribution. <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hybridize(
  x1,
  x2,
  n,
  pop = "hybrid",
  res.type = c("genind", "df", "STRUCTURE"),
  file = NULL,
  quiet = FALSE,
  sep = "/",
  hyb.label = "h"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hybridize_+3A_x1">x1</code></td>
<td>
<p>a <a href="#topic+genind-class">genind</a> object</p>
</td></tr>
<tr><td><code id="hybridize_+3A_x2">x2</code></td>
<td>
<p>a <a href="#topic+genind-class">genind</a> object</p>
</td></tr>
<tr><td><code id="hybridize_+3A_n">n</code></td>
<td>
<p>an integer giving the number of hybrids requested</p>
</td></tr>
<tr><td><code id="hybridize_+3A_pop">pop</code></td>
<td>
<p>a character string giving naming the population of the
created hybrids.</p>
</td></tr>
<tr><td><code id="hybridize_+3A_res.type">res.type</code></td>
<td>
<p>a character giving the type of output requested. Must
be &quot;genind&quot; (default), &quot;df&quot; (i.e. data.frame like in
<code><a href="#topic+genind2df">genind2df</a></code>), or &quot;STRUCTURE&quot; to generate a .str file
readable by STRUCTURE (in which case the 'file' must be supplied). See
'details' for STRUCTURE output.</p>
</td></tr>
<tr><td><code id="hybridize_+3A_file">file</code></td>
<td>
<p>a character giving the name of the file to be written
when 'res.type' is &quot;STRUCTURE&quot;; if NULL, a the created file is of the
form &quot;hybrids_[the current date].str&quot;.</p>
</td></tr>
<tr><td><code id="hybridize_+3A_quiet">quiet</code></td>
<td>
<p>a logical specifying whether the writing to a file (when
'res.type' is &quot;STRUCTURE&quot;) should be announced (FALSE, default) or
not (TRUE).</p>
</td></tr>
<tr><td><code id="hybridize_+3A_sep">sep</code></td>
<td>
<p>a character used to separate two alleles</p>
</td></tr>
<tr><td><code id="hybridize_+3A_hyb.label">hyb.label</code></td>
<td>
<p>a character string used to construct the hybrids
labels; by default, &quot;h&quot;, which gives labels: &quot;h01&quot;, &quot;h02&quot;, &quot;h03&quot;,...</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The result consists in a set of 'n' genotypes, with different possible
outputs (see 'res.type' argument).
</p>
<p>If the output is a STRUCTURE file, this file will have the following
caracteristics:<br />
- file contains the genotypes of the parents, and then the genotypes
of hybrids<br />
- the first column identifies genotypes<br />
- the second column identifies the population (1 and 2 for parents x1 and x2;
3 for hybrids)<br />
- the first line contains the names of the markers<br />
- one row = one genotype (onerowperind will be true)<br />
- missing values coded by &quot;-9&quot; (the software's default)<br />
</p>


<h3>Value</h3>

<p>A <a href="#topic+genind-class">genind</a> object (by default), or a data.frame of alleles
(res.type=&quot;df&quot;). No R output if res.type=&quot;STRUCTURE&quot; (results written
to the specified file).
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seploc">seploc</a></code>, <code><a href="#topic+seppop">seppop</a></code>, <code><a href="#topic+repool">repool</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Let's make some cattle hybrids
data(microbov)

## first, isolate each breed
temp &lt;- seppop(microbov)
names(temp)
salers &lt;- temp$Salers
zebu &lt;- temp$Zebu

## let's make some... Zeblers
zebler &lt;- hybridize(salers, zebu, n=40,
                    pop="Zebler")


## now let's merge all data into a single genind
newDat &lt;- repool(microbov, zebler)

## make a correspondance analysis
## and see where hybrids are placed
X &lt;- genind2genpop(newDat, quiet=TRUE)
coa1 &lt;- dudi.coa(tab(X),scannf=FALSE,nf=3)
s.label(coa1$li)
add.scatter.eig(coa1$eig,2,1,2)


## End(Not run)


</code></pre>

<hr>
<h2 id='hybridtoy'>Toy hybrid dataset</h2><span id='topic+hybridtoy'></span>

<h3>Description</h3>

<p>Toy hybrid dataset
</p>


<h3>Format</h3>

<p>a <a href="#topic+genind-class">genind</a> object
</p>


<h3>Author(s)</h3>

<p>Data simulated by  Marie-Pauline Beugin. Example by Thibaut Jombart.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hybridtoy)
x &lt;- hybridtoy
pca1 &lt;- dudi.pca(tab(x), scannf=FALSE, scale=FALSE)
s.class(pca1$li, pop(x))

if(require(ggplot2)) {
p &lt;- ggplot(pca1$li, aes(x=Axis1)) +
    geom_density(aes(fill=pop(x)), alpha=.4, adjust=1) +
    geom_point(aes(y=0, color=pop(x)), pch="|", size=10, alpha=.5)
p
}

## kmeans
km &lt;- find.clusters(x, n.pca=10, n.clust=2)
table(pop(x), km$grp)

## dapc
dapc1 &lt;- dapc(x, pop=km$grp, n.pca=10, n.da=1)
scatter(dapc1)
scatter(dapc1, grp=pop(x))
compoplot(dapc1, col.pal=spectral, n.col=2)

## ML-EM with hybrids
res &lt;- snapclust(x, k=2, hybrids=TRUE, detailed=TRUE)
compoplot(res, n.col=3)
table(res$group, pop(x))

</code></pre>

<hr>
<h2 id='import2genind'>Importing data from several softwares to a genind object</h2><span id='topic+import2genind'></span>

<h3>Description</h3>

<p>Their are several ways to import genotype data to a <a href="#topic+genind-class">genind</a>
object: i) from a data.frame with a given format (see
<code><a href="#topic+df2genind">df2genind</a></code>), ii) from a file with a recognized extension, or
iii) from an alignement of sequences (see <code><a href="#topic+DNAbin2genind">DNAbin2genind</a></code>).<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import2genind(file, quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import2genind_+3A_file">file</code></td>
<td>
<p>a character string giving the path to the file to convert, with
the appropriate extension.</p>
</td></tr>
<tr><td><code id="import2genind_+3A_quiet">quiet</code></td>
<td>
<p>logical stating whether a conversion message must be printed
(TRUE,default) or not (FALSE).</p>
</td></tr>
<tr><td><code id="import2genind_+3A_...">...</code></td>
<td>
<p>other arguments passed to the appropriate 'read' function
(currently passed to <code>read.structure</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>import2genind</code> detects the extension of the file given in
argument and seeks for an appropriate import function to create a
<code>genind</code> object.<br /> Current recognized formats are :<br /> - GENETIX files
(.gtx) <br /> - Genepop files (.gen) <br /> - Fstat files (.dat) <br /> - STRUCTURE
files (.str or .stru) <br />
</p>
<p>Beware: same data in different formats are not expected to produce exactly
the same <code>genind</code> objects.<br /> For instance, conversions made by GENETIX
to Fstat may change the the sorting of the genotypes; GENETIX stores
individual names whereas Fstat does not; Genepop chooses a sample's name
from the name of its last genotype; etc.
</p>


<h3>Value</h3>

<p>an object of the class <code>genind</code>
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>
</p>


<h3>References</h3>

<p>Belkhir K., Borsa P., Chikhi L., Raufaste N. &amp; Bonhomme F.
(1996-2004) GENETIX 4.05, logiciel sous Windows TM pour la genetique des
populations. Laboratoire Genome, Populations, Interactions, CNRS UMR 5000,
Universite de Montpellier II, Montpellier (France). <br />
</p>
<p>Pritchard, J.; Stephens, M. &amp; Donnelly, P. (2000) Inference of population
structure using multilocus genotype data. <em>Genetics</em>, <b>155</b>:
945-959
</p>
<p>Raymond M. &amp; Rousset F, (1995). GENEPOP (version 1.2): population genetics
software for exact tests and ecumenicism. <em>J. Heredity</em>,
<b>86</b>:248-249 <br />
</p>
<p>Fstat (version 2.9.3). Software by Jerome Goudet.
http://www2.unil.ch/popgen/softwares/fstat.htm<br />
</p>
<p>Excoffier L. &amp; Heckel G.(2006) Computer programs for population genetics
data analysis: a survival guide <em>Nature</em>, <b>7</b>: 745-758
</p>


<h3>See Also</h3>

<p><code><a href="#topic+import2genind">import2genind</a></code>, <code><a href="#topic+read.genetix">read.genetix</a></code>,
<code><a href="#topic+read.fstat">read.fstat</a></code>, <code><a href="#topic+read.structure">read.structure</a></code>,
<code><a href="#topic+read.genepop">read.genepop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
import2genind(system.file("files/nancycats.gtx",
package="adegenet"))

import2genind(system.file("files/nancycats.dat",
package="adegenet"))

import2genind(system.file("files/nancycats.gen",
package="adegenet"))

import2genind(system.file("files/nancycats.str",
package="adegenet"), onerowperind=FALSE, n.ind=237, n.loc=9, col.lab=1, col.pop=2, ask=FALSE)

</code></pre>

<hr>
<h2 id='Inbreeding+20estimation'>Likelihood-based estimation of inbreeding</h2><span id='topic+inbreeding'></span>

<h3>Description</h3>

<p>The function <code>inbreeding</code> estimates the inbreeding coefficient
of an individuals (F) by computing its likelihood function. It can
return either the density of probability of F, or a sample of F values
from this distribution. This operation is performed for all the
individuals of a <a href="#topic+genind-class">genind</a> object. Any ploidy greater than
1 is acceptable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inbreeding(x, pop = NULL, truenames = TRUE, 
           res.type = c("sample", "function", "estimate"), N = 200, M = N * 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Inbreeding+2B20estimation_+3A_x">x</code></td>
<td>
<p>an object of class <a href="#topic+genind-class">genind</a>.</p>
</td></tr>
<tr><td><code id="Inbreeding+2B20estimation_+3A_pop">pop</code></td>
<td>
<p>a factor giving the 'population' of each individual. If NULL,
pop is seeked from <code>pop(x)</code>. Note that the term population refers in
fact to any grouping of individuals'.</p>
</td></tr>
<tr><td><code id="Inbreeding+2B20estimation_+3A_truenames">truenames</code></td>
<td>
<p>a logical indicating whether true names should be
used (TRUE, default) instead of generic labels (FALSE); used if
res.type is &quot;matrix&quot;.</p>
</td></tr>
<tr><td><code id="Inbreeding+2B20estimation_+3A_res.type">res.type</code></td>
<td>
<p>a character string matching &quot;sample&quot;, &quot;function&quot;, or &quot;estimate&quot;
specifying whether the output should be a function giving the density
of probability of F values (&quot;function&quot;), the maximum likelihood estimate
of F from this distribution (&quot;estimate&quot;), or a sample of F values taken
from this distribution (&quot;sample&quot;, default).</p>
</td></tr>
<tr><td><code id="Inbreeding+2B20estimation_+3A_n">N</code></td>
<td>
<p>an integer indicating the size of the sample to be taken from
the distribution of F values.</p>
</td></tr>
<tr><td><code id="Inbreeding+2B20estimation_+3A_m">M</code></td>
<td>
<p>an integer indicating the number of different F values to be
used to generate the sample. Values larger than N are recommended to
avoid poor sampling of the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">F</code> denote the inbreeding coefficient, defined as the
probability for an individual to inherit two identical alleles from a
single ancestor.
</p>
<p>Let <code class="reqn">p_i</code> refer to the frequency of allele <code class="reqn">i</code> in the
population. Let <code class="reqn">h</code> be an variable which equates 1 if the
individual is homozygote, and 0 otherwise. For one locus, the
probability of being homozygote is computed as:
</p>
<p><code class="reqn"> F + (1-F) \sum_i p_i^2</code>
</p>
<p>The probability of being heterozygote is:
<code class="reqn">1 - (F + (1-F) \sum_i p_i^2)</code>
</p>
<p>The likelihood of a genotype is defined as the probability of being
the observed state (homozygote or heterozygote). In the case of
multilocus genotypes, log-likelihood are summed over the loci.
</p>


<h3>Value</h3>

<p>A named list with one component for each individual, each of which is
a function or a vector of sampled F values (see <code>res.type</code> argument).
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a><br />
Zhian N. Kamvar<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hs">Hs</a></code>: computation of expected heterozygosity.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## cattle breed microsatellite data
data(microbov)

## isolate Lagunaire breed
lagun &lt;- seppop(microbov)$Lagunaire

## estimate inbreeding - return sample of F values
Fsamp &lt;- inbreeding(lagun, N=30)

## plot the first 10 results
invisible(sapply(Fsamp[1:10], function(e) plot(density(e), xlab="F",
xlim=c(0,1), main="Density of the sampled F values")))

## compute means for all individuals
Fmean=sapply(Fsamp, mean)
hist(Fmean, col="orange", xlab="mean value of F",
main="Distribution of mean F across individuals")

## estimate inbreeding - return proba density functions
Fdens &lt;- inbreeding(lagun, res.type="function")

## view function for the first individual
Fdens[[1]]

## plot the first 10 functions
invisible(sapply(Fdens[1:10], plot, ylab="Density",
main="Density of probability of F values"))

## estimate inbreeding - return maximum likelihood estimates
Fest &lt;- inbreeding(lagun, res.type = "estimate")
mostInbred &lt;- which.max(Fest)
plot(Fdens[[mostInbred]], ylab = "Density", xlab = "F",
     main = paste("Probability density of F values\nfor", names(mostInbred)))
abline(v = Fest[mostInbred], col = "red", lty = 2)
legend("topright", legend = "MLE", col = "red", lty = 2)

## note that estimates and average samples are likely to be different.
plot(Fest, ylab = "F", col = "blue",
     main = "comparison of MLE and average sample estimates of F")
points(Fmean, pch = 2, col = "red")
arrows(x0 = 1:length(Fest), y0 = Fest, 
       y1 = Fmean, x1 = 1:length(Fest), length = 0.125)
legend("topleft", legend = c("estimate", "sample"), col = c("blue", "red"),
       pch = c(1, 2), title = "res.type")

## End(Not run)
</code></pre>

<hr>
<h2 id='initialize+2Cgenind-method'>genind constructor</h2><span id='topic+initialize+2Cgenind-method'></span><span id='topic+initialize+2Cgenind-methods'></span><span id='topic+genind'></span><span id='topic+as.genind'></span>

<h3>Description</h3>

<p>The function <code>new</code> has a method for building <a href="#topic+genind-class">genind</a> objects.
See the class description of <a href="#topic+genind-class">genind</a> for more information on this data structure.
The functions <code>genind</code> and <code>as.genind</code> are aliases for <code>new("genind", ...)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'genind'
initialize(
  .Object,
  tab,
  pop = NULL,
  prevcall = NULL,
  ploidy = 2L,
  type = c("codom", "PA"),
  strata = NULL,
  hierarchy = NULL,
  ...
)

genind(...)

as.genind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize+2B2Cgenind-method_+3A_.object">.Object</code></td>
<td>
<p>prototyped object (generated automatically when calling 'new')</p>
</td></tr>
<tr><td><code id="initialize+2B2Cgenind-method_+3A_tab">tab</code></td>
<td>
<p>A matrix of integers corresponding to the @tab slot of a genind
object, with individuals in rows and alleles in columns, and containing
either allele counts (if type=&quot;codom&quot;) or allele presence/absence (if
type=&quot;PA&quot;)</p>
</td></tr>
<tr><td><code id="initialize+2B2Cgenind-method_+3A_pop">pop</code></td>
<td>
<p>an optional factor with one value per row in <code>tab</code> indicating
the population of each individual</p>
</td></tr>
<tr><td><code id="initialize+2B2Cgenind-method_+3A_prevcall">prevcall</code></td>
<td>
<p>an optional call to be stored in the object</p>
</td></tr>
<tr><td><code id="initialize+2B2Cgenind-method_+3A_ploidy">ploidy</code></td>
<td>
<p>an integer vector indicating the ploidy of the individual; each
individual can have a different value; if only one value is provided, it is
recycled to generate a vector of the right length.</p>
</td></tr>
<tr><td><code id="initialize+2B2Cgenind-method_+3A_type">type</code></td>
<td>
<p>a character string indicating the type of marker: codominant
(&quot;codom&quot;) or presence/absence (&quot;PA&quot;)</p>
</td></tr>
<tr><td><code id="initialize+2B2Cgenind-method_+3A_strata">strata</code></td>
<td>
<p>a data frame containing population hierarchies or
stratifications in columns. This must be the same length as the number of
individuals in the data set.</p>
</td></tr>
<tr><td><code id="initialize+2B2Cgenind-method_+3A_hierarchy">hierarchy</code></td>
<td>
<p>a hierarchical formula defining the columns of the strata
slot that are hierarchical. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="initialize+2B2Cgenind-method_+3A_...">...</code></td>
<td>
<p>further arguments passed to other methods (currently not used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most users do not need using the constructor, but merely to convert raw allele data using <code><a href="#topic+df2genind">df2genind</a></code> and related functions.
</p>


<h3>Value</h3>

<p>a <a href="#topic+genind-class">genind</a> object
</p>


<h3>See Also</h3>

<p>the description of the <a href="#topic+genind-class">genind</a> class; <code><a href="#topic+df2genind">df2genind</a></code>
</p>

<hr>
<h2 id='initialize+2Cgenpop-method'>genpop constructor</h2><span id='topic+initialize+2Cgenpop-method'></span><span id='topic+initialize+2Cgenpop-methods'></span><span id='topic+genpop'></span><span id='topic+as.genpop'></span>

<h3>Description</h3>

<p>The function <code>new</code> has a method for building <a href="#topic+genpop-class">genpop</a> objects.
See the class description of <a href="#topic+genpop-class">genpop</a> for more information on this data structure.
The functions <code>genpop</code> and <code>as.genpop</code> are aliases for <code>new("genpop", ...)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'genpop'
initialize(
  .Object,
  tab,
  prevcall = NULL,
  ploidy = 2L,
  type = c("codom", "PA"),
  ...
)

genpop(...)

as.genpop(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize+2B2Cgenpop-method_+3A_.object">.Object</code></td>
<td>
<p>prototyped object (generated automatically when calling 'new')</p>
</td></tr>
<tr><td><code id="initialize+2B2Cgenpop-method_+3A_tab">tab</code></td>
<td>
<p>A matrix of integers corresponding to the @tab slot of a genpop object, with individuals in rows and alleles in columns, and containing either allele counts</p>
</td></tr>
<tr><td><code id="initialize+2B2Cgenpop-method_+3A_prevcall">prevcall</code></td>
<td>
<p>an optional call to be stored in the object</p>
</td></tr>
<tr><td><code id="initialize+2B2Cgenpop-method_+3A_ploidy">ploidy</code></td>
<td>
<p>an integer vector indicating the ploidy of the individual; each individual can have a different value; if only one value is provided, it is recycled to generate a vector of the right length.</p>
</td></tr>
<tr><td><code id="initialize+2B2Cgenpop-method_+3A_type">type</code></td>
<td>
<p>a character string indicating the type of marker: codominant (&quot;codom&quot;) or presence/absence (&quot;PA&quot;)</p>
</td></tr>
<tr><td><code id="initialize+2B2Cgenpop-method_+3A_...">...</code></td>
<td>
<p>further arguments passed to other methods (currently not used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most users do not need using the constructor, but merely to convert raw allele data using <code><a href="#topic+genind2genpop">genind2genpop</a></code>.
</p>


<h3>Value</h3>

<p>a <a href="#topic+genpop-class">genpop</a> object
</p>


<h3>See Also</h3>

<p>the description of the <a href="#topic+genpop-class">genpop</a> class; <code><a href="#topic+df2genind">df2genind</a></code> and related functions for reading raw allele data
</p>

<hr>
<h2 id='isPoly-methods'> Assess polymorphism in genind/genpop objects </h2><span id='topic+isPoly'></span><span id='topic+isPoly-methods'></span><span id='topic+isPoly+2Cgenind-method'></span><span id='topic+isPoly+2Cgenpop-method'></span>

<h3>Description</h3>

<p>The simple function <code>isPoly</code> can be used to check which loci are
polymorphic, or alternatively to check which alleles give rise to polymorphism.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'genind'
isPoly(x, by=c("locus","allele"), thres=1/100)
## S4 method for signature 'genpop'
isPoly(x, by=c("locus","allele"), thres=1/100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isPoly-methods_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+genind-class">genind</a> and <a href="#topic+genpop-class">genpop</a> object</p>
</td></tr>
<tr><td><code id="isPoly-methods_+3A_by">by</code></td>
<td>
<p>a character being &quot;locus&quot; or &quot;allele&quot;, indicating whether
results should indicate polymorphic loci (&quot;locus&quot;), or alleles giving
rise to polymorphism (&quot;allele&quot;).</p>
</td></tr>
<tr><td><code id="isPoly-methods_+3A_thres">thres</code></td>
<td>
<p>a numeric value giving the minimum frequency of an allele
giving rise to polymorphism (defaults to 0.01).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of logicals.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(nancycats)
isPoly(nancycats,by="loc", thres=0.1)
isPoly(nancycats[1:3],by="loc", thres=0.1)
genind2df(nancycats[1:3])

## End(Not run)
</code></pre>

<hr>
<h2 id='KIC'>Compute Akaike Information Criterion for small samples (AICc) for snapclust</h2><span id='topic+KIC'></span><span id='topic+KIC.snapclust'></span>

<h3>Description</h3>

<p>Do not use. We work on that stuff. Contact us if interested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KIC(object, ...)

## S3 method for class 'snapclust'
KIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KIC_+3A_object">object</code></td>
<td>
<p>An object returned by the function <code><a href="#topic+snapclust">snapclust</a></code>.</p>
</td></tr>
<tr><td><code id="KIC_+3A_...">...</code></td>
<td>
<p>Further arguments for compatibility with the <code>AIC</code> generic
(currently not used).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+snapclust">snapclust</a></code> to generate clustering solutions.
</p>

<hr>
<h2 id='loadingplot'>Represents a cloud of points with colors</h2><span id='topic+loadingplot'></span><span id='topic+loadingplot.default'></span>

<h3>Description</h3>

<p>The <code>loadingplot</code> function represents positive values of a vector
and identifies the values above a given threshold. It can also
indicate groups of observations provided as a factor. <br />
</p>
<p>Such graphics can be used, for instance, to assess the weight of each
variable (loadings) in a given analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadingplot(x, ...)

## Default S3 method:
loadingplot(x, at=NULL, threshold=quantile(x,0.75),
            axis=1, fac=NULL, byfac=FALSE,
            lab=NULL, cex.lab=0.7, cex.fac=1, lab.jitter=0,
            main="Loading plot", xlab="Variables", ylab="Loadings",
            srt = 0, adj = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadingplot_+3A_x">x</code></td>
<td>
<p>either a vector with numeric values to be plotted, or a
matrix-like object containing numeric values. In such case, the
<code>x[,axis]</code> is used as vector of values to be plotted.</p>
</td></tr>
<tr><td><code id="loadingplot_+3A_at">at</code></td>
<td>
<p>an optional numeric vector giving the abscissa at which
loadings are plotted. Useful when variates are SNPs with a known
position in an alignement.</p>
</td></tr>
<tr><td><code id="loadingplot_+3A_threshold">threshold</code></td>
<td>
<p>a threshold value above which values of x are
identified. By default, this is the third quartile of x.</p>
</td></tr>
<tr><td><code id="loadingplot_+3A_axis">axis</code></td>
<td>
<p>an integer indicating the column of x to be plotted; used
only if x is a matrix-like object.</p>
</td></tr>
<tr><td><code id="loadingplot_+3A_fac">fac</code></td>
<td>
<p>a factor defining groups of observations.</p>
</td></tr>
<tr><td><code id="loadingplot_+3A_byfac">byfac</code></td>
<td>
<p>a logical stating whether loadings should be averaged by
groups of observations, as defined by <code>fac</code>.</p>
</td></tr>
<tr><td><code id="loadingplot_+3A_lab">lab</code></td>
<td>
<p>a character vector giving the labels used to annotate
values above the threshold; if NULL, names are taken from the object.</p>
</td></tr>
<tr><td><code id="loadingplot_+3A_cex.lab">cex.lab</code></td>
<td>
<p>a numeric value indicating the size of annotations.</p>
</td></tr>
<tr><td><code id="loadingplot_+3A_cex.fac">cex.fac</code></td>
<td>
<p>a numeric value indicating the size of annotations for
groups of observations.</p>
</td></tr>
<tr><td><code id="loadingplot_+3A_lab.jitter">lab.jitter</code></td>
<td>
<p>a numeric value indicating the factor of
randomisation for the position of annotations. Set to 0 (by default)
implies no randomisation.</p>
</td></tr>
<tr><td><code id="loadingplot_+3A_main">main</code></td>
<td>
<p>the main title of the figure.</p>
</td></tr>
<tr><td><code id="loadingplot_+3A_xlab">xlab</code></td>
<td>
<p>the title of the x axis.</p>
</td></tr>
<tr><td><code id="loadingplot_+3A_ylab">ylab</code></td>
<td>
<p>the title of the y axis.</p>
</td></tr>
<tr><td><code id="loadingplot_+3A_srt">srt</code></td>
<td>
<p>rotation of the labels; see ?text.</p>
</td></tr>
<tr><td><code id="loadingplot_+3A_adj">adj</code></td>
<td>
<p>adjustment of the labels; see ?text.</p>
</td></tr>
<tr><td><code id="loadingplot_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the plot function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns a list with the following components:<br />
- threshold: the threshold used<br />
- var.names: the names of observations above the threshold<br />
- var.idx: the indices of observations above the threshold<br />
- var.values: the values above the threshold<br />
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(20)
names(x) &lt;- letters[1:20]
grp &lt;- factor(paste("group", rep(1:4,each=5)))

## basic plot
loadingplot(x)

## adding groups
loadingplot(x,fac=grp,main="My title",cex.lab=1)
</code></pre>

<hr>
<h2 id='makefreq'>Compute allelic frequencies</h2><span id='topic+makefreq'></span><span id='topic+makefreq+2Cgenind-method'></span><span id='topic+makefreq+2Cgenind-methods'></span><span id='topic+makefreq.genind'></span><span id='topic+makefreq+2Cgenpop-method'></span><span id='topic+makefreq+2Cgenpop-methods'></span><span id='topic+makefreq.genpop'></span>

<h3>Description</h3>

<p>The function <code>makefreq</code> is a generic to compute allele frequencies.
These can be derived for <a href="#topic+genind-class">genind</a> or <a href="#topic+genpop-class">genpop</a> objects.
In the case of <a href="#topic+genind-class">genind</a> objects, data are kept at the individual level, but standardised so that allele frequencies sum up to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makefreq(x, ...)

## S4 method for signature 'genind'
makefreq(x, quiet = FALSE, missing = NA, truenames = TRUE, ...)

## S4 method for signature 'genpop'
makefreq(x, quiet = FALSE, missing = NA, truenames = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makefreq_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+genind-class">genind</a> or <a href="#topic+genpop-class">genpop</a> object.</p>
</td></tr>
<tr><td><code id="makefreq_+3A_...">...</code></td>
<td>
<p>further arguments (curently unused)</p>
</td></tr>
<tr><td><code id="makefreq_+3A_quiet">quiet</code></td>
<td>
<p>logical stating whether a conversion message must be printed
(TRUE,default) or not (FALSE).</p>
</td></tr>
<tr><td><code id="makefreq_+3A_missing">missing</code></td>
<td>
<p>treatment for missing values. Can be NA, 0 or &quot;mean&quot; (see
details)</p>
</td></tr>
<tr><td><code id="makefreq_+3A_truenames">truenames</code></td>
<td>
<p>deprecated; there for backward compatibility</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are 3 treatments for missing values: <br /> - NA: kept as NA.<br /> - 0:
missing values are considered as zero. Recommended for a PCA on
compositionnal data.<br /> - &quot;mean&quot;: missing values are given the mean
frequency of the corresponding allele. Recommended for a centred PCA.
</p>
<p>Note that this function is now a simple wrapper for the accessor <code><a href="#topic+tab">tab</a></code>.
</p>


<h3>Value</h3>

<p>Returns a list with the following components: </p>
<table>
<tr><td><code>tab</code></td>
<td>
<p>matrix of
allelic frequencies (rows: populations; columns: alleles).</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of observations (i.e. alleles) for each population x
locus combinaison.</p>
</td></tr> <tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genpop">genpop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(microbov)
obj1 &lt;- microbov
obj2 &lt;- genind2genpop(obj1)

# perform a correspondance analysis on counts data
Xcount &lt;- tab(obj2, NA.method="zero")
ca1 &lt;- dudi.coa(Xcount,scannf=FALSE)
s.label(ca1$li,sub="Correspondance Analysis",csub=1.2)
add.scatter.eig(ca1$eig,nf=2,xax=1,yax=2,posi="topleft")

# perform a principal component analysis on frequency data
Xfreq &lt;- makefreq(obj2, missing="mean")
Xfreq &lt;- tab(obj2, NA.method="mean") # equivalent to line above
pca1 &lt;- dudi.pca(Xfreq,scale=FALSE,scannf=FALSE)
s.label(pca1$li,sub="Principal Component Analysis",csub=1.2)
add.scatter.eig(pca1$eig,nf=2,xax=1,yax=2,posi="top")

## End(Not run)

</code></pre>

<hr>
<h2 id='microbov'>Microsatellites genotypes of 15 cattle breeds</h2><span id='topic+microbov'></span>

<h3>Description</h3>

<p>This data set gives the genotypes of 704 cattle individuals for 30
microsatellites recommended by the FAO. The individuals are divided into two
countries (Afric, France), two species (Bos taurus, Bos indicus) and 15
breeds. Individuals were chosen in order to avoid pseudoreplication
according to their exact genealogy.
</p>


<h3>Format</h3>

<p><code>microbov</code> is a genind object with 3 supplementary components:
</p>
 <dl>
<dt>coun</dt><dd><p>a factor giving the country of each individual (AF:
Afric; FR: France).</p>
</dd> <dt>breed</dt><dd><p>a factor giving the breed of each
individual.</p>
</dd> <dt>spe</dt><dd><p>is a factor giving the species of each individual
(BT: Bos taurus; BI: Bos indicus).</p>
</dd> </dl>



<h3>Source</h3>

<p>Data prepared by Katayoun Moazami-Goudarzi and Denis Lalo\&quot;e (INRA,
Jouy-en-Josas, France)
</p>


<h3>References</h3>

<p>Lalo\&quot;e D., Jombart T., Dufour A.-B. and Moazami-Goudarzi K.
(2007) Consensus genetic structuring and typological value of markers using
Multiple Co-Inertia Analysis. <em>Genetics Selection Evolution</em>.
<b>39</b>: 545&ndash;567.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(microbov)
microbov
summary(microbov)

# make Y, a genpop object
Y &lt;- genind2genpop(microbov)

# make allelic frequency table
temp &lt;- makefreq(Y,missing="mean")
X &lt;- temp$tab
nsamp &lt;- temp$nobs

# perform 1 PCA per marker

kX &lt;- ktab.data.frame(data.frame(X),Y@loc.n.all)

kpca &lt;- list()
for(i in 1:30) {kpca[[i]] &lt;- dudi.pca(kX[[i]],scannf=FALSE,nf=2,center=TRUE,scale=FALSE)}


sel &lt;- sample(1:30,4)
col = rep('red',15)
col[c(2,10)] = 'darkred'
col[c(4,12,14)] = 'deepskyblue4'
col[c(8,15)] = 'darkblue'

# display %PCA
par(mfrow=c(2,2))
for(i in sel) {
s.multinom(kpca[[i]]$c1,kX[[i]],n.sample=nsamp[,i],coulrow=col,sub=locNames(Y)[i])
add.scatter.eig(kpca[[i]]$eig,3,xax=1,yax=2,posi="top")
}

# perform a Multiple Coinertia Analysis
kXcent &lt;- kX
for(i in 1:30) kXcent[[i]] &lt;- as.data.frame(scalewt(kX[[i]],center=TRUE,scale=FALSE))
mcoa1 &lt;- mcoa(kXcent,scannf=FALSE,nf=3, option="uniform")

# coordinated %PCA
mcoa.axes &lt;- split(mcoa1$axis, Y@loc.fac)
mcoa.coord &lt;- split(mcoa1$Tli,mcoa1$TL[,1])
var.coord &lt;- lapply(mcoa.coord,function(e) apply(e,2,var))

par(mfrow=c(2,2))
for(i in sel) {
s.multinom(mcoa.axes[[i]][,1:2],kX[[i]],n.sample=nsamp[,i],coulrow=col,sub=locNames(Y)[i])
add.scatter.eig(var.coord[[i]],2,xax=1,yax=2,posi="top")
}

# reference typology
par(mfrow=c(1,1))
s.label(mcoa1$SynVar,lab=popNames(microbov),sub="Reference typology",csub=1.5)
add.scatter.eig(mcoa1$pseudoeig,nf=3,xax=1,yax=2,posi="top")

# typologial values
tv &lt;- mcoa1$cov2
tv &lt;- apply(tv,2,function(c) c/sum(c))*100
rownames(tv) &lt;- locNames(Y)
tv &lt;- tv[order(locNames(Y)),]

par(mfrow=c(3,1),mar=c(5,3,3,4),las=3)
for(i in 1:3){
barplot(round(tv[,i],3),ylim=c(0,12),yaxt="n",main=paste("Typological value -
structure",i))
axis(side=2,at=seq(0,12,by=2),labels=paste(seq(0,12,by=2),"%"),cex=3)
abline(h=seq(0,12,by=2),col="grey",lty=2)
}

## End(Not run)

</code></pre>

<hr>
<h2 id='minorAllele'>Compute minor allele frequency</h2><span id='topic+minorAllele'></span>

<h3>Description</h3>

<p>This function computes the minor allele frequency for each locus in a <a href="#topic+genind-class">genind</a> object. To test if loci are polymorphic, see the function  <code><a href="#topic+isPoly">isPoly</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minorAllele(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minorAllele_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+genind-class">genind</a> object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isPoly">isPoly</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## LOAD DATA
data(nancycats)

## COMPUTE ALLELE FREQUENCIES
x &lt;- nancycats
apply(tab(x, freq=TRUE),2,mean, na.rm=TRUE)

## GET MINOR ALLELE FREQUENCY
m.freq &lt;- minorAllele(x)
m.freq

## End(Not run)

</code></pre>

<hr>
<h2 id='monmonier'>Boundary detection using Monmonier algorithm</h2><span id='topic+monmonier'></span><span id='topic+optimize.monmonier'></span><span id='topic+plot.monmonier'></span><span id='topic+print.monmonier'></span>

<h3>Description</h3>

<p>The Monmonier's algorithm detects boundaries among vertices of a
valuated graph. This is achieved by finding the path
exhibiting the largest distances between connected vertices.<br />
</p>
<p>The highest distance between two connected vertices (i.e. neighbours) is
found, giving the starting point of the path. Then, the algorithm
seeks the highest distance between immediate neighbours, and so on
until a threshold value is attained.
This threshold can be chosen from the plot of sorted distances between
connected vertices: a boundary will likely result in an abrupt decrease
of these values.<br />
</p>
<p>When several paths are looked for, the previous paths are taken into
account, and cannot be either crossed or redrawn. Monmonier's
algorithm can be used to assess the boundaries between patches of
homogeneous observations.<br />
</p>
<p>Although Monmonier algorithm was initially designed for Voronoi
tesselation, this implementation generalizes this algorithm to different
connection networks. The <code>optimize.monmonier</code> function produces a
<code>monmonier</code> object by trying several starting points, and
returning the best boundary (i.e. largest sum of local distances). This
is designed to avoid the algorithm to be trapped by a single strong
local difference inside an homogeneous patch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monmonier(xy, dist, cn, threshold=NULL, bd.length=NULL, nrun=1,
skip.local.diff=rep(0,nrun),scanthres=is.null(threshold), allowLoop=TRUE)

optimize.monmonier(xy, dist, cn, ntry=10, bd.length=NULL, return.best=TRUE,
display.graph=TRUE, threshold=NULL, scanthres=is.null(threshold), allowLoop=TRUE)

## S3 method for class 'monmonier'
plot(x, variable=NULL,
displayed.runs=1:x$nrun, add.arrows=TRUE,
col='blue', lty=1, bwd=4, clegend=1, csize=0.7,
method=c('squaresize','greylevel'), sub='', csub=1, possub='topleft',
cneig=1, pixmap=NULL, contour=NULL, area=NULL, add.plot=FALSE, ...)

## S3 method for class 'monmonier'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="monmonier_+3A_xy">xy</code></td>
<td>
<p>a matrix yielding the spatial coordinates of the objects, with two columns respectively giving X and Y</p>
</td></tr>
<tr><td><code id="monmonier_+3A_dist">dist</code></td>
<td>
<p>an object of class <code>dist</code>, giving the distances between the objects</p>
</td></tr>
<tr><td><code id="monmonier_+3A_cn">cn</code></td>
<td>
<p>a connection network of class <code>nb</code> (package <code>spdep</code>)</p>
</td></tr>
<tr><td><code id="monmonier_+3A_threshold">threshold</code></td>
<td>
<p>a number giving the minimal distance between two
neighbours crossed by the path; by default, this is the third quartile of all the distances between neighbours</p>
</td></tr>
<tr><td><code id="monmonier_+3A_bd.length">bd.length</code></td>
<td>
<p>an optional integer giving the requested length of
the boundaries (in number of local differences)</p>
</td></tr>
<tr><td><code id="monmonier_+3A_nrun">nrun</code></td>
<td>
<p>is a integer giving the number of runs of the algorithm, that is, the number of paths to search, being one by default</p>
</td></tr>
<tr><td><code id="monmonier_+3A_skip.local.diff">skip.local.diff</code></td>
<td>
<p>is a vector of integers, whose length is the number of paths (<code>nrun</code>); each integer gives the number of starting point to skip, to avoid being stuck in a local difference between two neighbours into an homogeneous patch; none are skipped by default</p>
</td></tr>
<tr><td><code id="monmonier_+3A_scanthres">scanthres</code></td>
<td>
<p>a logical stating whether the threshold sould be
chosen from the barplot of sorted distances between neighbours</p>
</td></tr>
<tr><td><code id="monmonier_+3A_allowloop">allowLoop</code></td>
<td>
<p>a logical specifying whether the boundary can loop
(TRUE, default) or not (FALSE)</p>
</td></tr>
<tr><td><code id="monmonier_+3A_ntry">ntry</code></td>
<td>
<p>an integer giving the number of different starting points
tried.</p>
</td></tr>
<tr><td><code id="monmonier_+3A_return.best">return.best</code></td>
<td>
<p>a logical stating whether the best monmonier object
should be returned (TRUE, default) or not (FALSE)</p>
</td></tr>
<tr><td><code id="monmonier_+3A_display.graph">display.graph</code></td>
<td>
<p>a logical whether the scores of each try should
be plotted (TRUE, default) or not</p>
</td></tr>
<tr><td><code id="monmonier_+3A_x">x</code></td>
<td>
<p>a monmonier object</p>
</td></tr>
<tr><td><code id="monmonier_+3A_variable">variable</code></td>
<td>
<p>a variable to be plotted using <code>s.value</code> (package
<code>ade4</code>)</p>
</td></tr>
<tr><td><code id="monmonier_+3A_displayed.runs">displayed.runs</code></td>
<td>
<p>an integer vector giving the rank of the paths to represent</p>
</td></tr>
<tr><td><code id="monmonier_+3A_add.arrows">add.arrows</code></td>
<td>
<p>a logical, stating whether arrows should indicate the direction of the path (TRUE) or not (FALSE, used by default)</p>
</td></tr>
<tr><td><code id="monmonier_+3A_col">col</code></td>
<td>
<p>a characters vector giving the colors to be used for each boundary; recycled is needed; 'blue' is used by default</p>
</td></tr>
<tr><td><code id="monmonier_+3A_lty">lty</code></td>
<td>
<p>a characters vector giving the type of line to be used for each boundary; 1 is used by default</p>
</td></tr>
<tr><td><code id="monmonier_+3A_bwd">bwd</code></td>
<td>
<p>a number giving the boundary width factor, applying to every segments of the paths; 4 is used by default</p>
</td></tr>
<tr><td><code id="monmonier_+3A_clegend">clegend</code></td>
<td>
<p>like in <code>s.value</code>, the size factor of the legend if a variable is represented</p>
</td></tr>
<tr><td><code id="monmonier_+3A_csize">csize</code></td>
<td>
<p>like in <code>s.value</code>, the size factor of the squares used to represent a variable</p>
</td></tr>
<tr><td><code id="monmonier_+3A_method">method</code></td>
<td>
<p>like in <code>s.value</code>, a character giving the method to be used to represent the variable, either 'squaresize' (by default) or 'greylevel'</p>
</td></tr>
<tr><td><code id="monmonier_+3A_sub">sub</code></td>
<td>
<p>a string of characters giving the subtitle of the plot</p>
</td></tr>
<tr><td><code id="monmonier_+3A_csub">csub</code></td>
<td>
<p>the size factor of the subtitle</p>
</td></tr>
<tr><td><code id="monmonier_+3A_possub">possub</code></td>
<td>
<p>the position of the subtitle; available choices are 'topleft' (by default), 'topright', 'bottomleft', and 'bottomright'</p>
</td></tr>
<tr><td><code id="monmonier_+3A_cneig">cneig</code></td>
<td>
<p>the size factor of the connection network</p>
</td></tr>
<tr><td><code id="monmonier_+3A_pixmap">pixmap</code></td>
<td>
<p>an object of the class <code>pixmap</code> displayed in the map background</p>
</td></tr>
<tr><td><code id="monmonier_+3A_contour">contour</code></td>
<td>
<p> a data frame with 4 columns to plot the contour of the map: each row gives a segment (x1,y1,x2,y2)</p>
</td></tr>
<tr><td><code id="monmonier_+3A_area">area</code></td>
<td>
<p>a data frame of class 'area' to plot a set of surface units in contour</p>
</td></tr>
<tr><td><code id="monmonier_+3A_add.plot">add.plot</code></td>
<td>
<p>a logical stating whether the plot should be added to the current one (TRUE), or displayed in a new window (FALSE, by default)</p>
</td></tr>
<tr><td><code id="monmonier_+3A_...">...</code></td>
<td>
<p>further arguments passed to other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>monmonier</code> returns a list of the class <code>monmonier</code>, which contains the general informations about the algorithm, and about each run.
When displayed, the width of the boundaries reflects their 'strength'.
Let a segment MN be part of the path, M being the middle of AB, N of CD.
Then the boundary width for MN is proportionnal to (d(AB)+d(CD))/2.<br />
</p>
<p>As there is no perfect method to display graphically a quantitative
variable (see for instance the differences between the two methods of
<code>s.value</code>), the boundaries provided by this algorithm seem
sometimes more reliable than the boundaries our eyes perceive (or miss).<br />
</p>


<h3>Value</h3>

<p>Returns an object of class <code>monmonier</code>, which contains the following elements :
</p>
<table>
<tr><td><code>run1 (run2</code>, <code>...)</code></td>
<td>
<p>for each run, a list containing a dataframe giving the path coordinates, and a vector of the distances between neighbours of the path</p>
</td></tr>
<tr><td><code>nrun</code></td>
<td>
<p>the number of runs performed, i.e. the number of boundaries in the monmonier object</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>
<p>the threshold value, minimal distance between
neighbours accounted for by the algorithm</p>
</td></tr>
<tr><td><code>xy</code></td>
<td>
<p>the matrix of spatial coordinates</p>
</td></tr>
<tr><td><code>cn</code></td>
<td>
<p>the connection network of class <code>nb</code></p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call of the function</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a></p>


<h3>References</h3>

<p>Monmonier, M. (1973) Maximum-difference barriers: an alternative numerical regionalization method. <em>Geographic Analysis</em>, <b>3</b>, 245&ndash;261.
</p>
<p>Manni, F., Guerard, E. and Heyer, E. (2004) Geographic patterns of (genetic, morphologic, linguistic) variation: how barriers can be detected by &quot;Monmonier's algorithm&quot;. <em>Human Biology</em>, <b>76</b>, 173&ndash;190
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spca">spca</a></code>,<code><a href="spdep.html#topic+edit.nb">edit.nb</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(spdep)){

### non-interactive example

# est-west separation
load(system.file("files/mondata1.rda",package="adegenet"))
cn1 &lt;- chooseCN(mondata1$xy,type=2,ask=FALSE)
mon1 &lt;- monmonier(mondata1$xy,dist(mondata1$x1),cn1,threshold=2)
plot(mon1,mondata1$x1)
plot(mon1,mondata1$x1,met="greylevel",add.arr=FALSE,col="red",bwd=6,lty=2)

# square in the middle
load(system.file("files/mondata2.rda",package="adegenet"))
cn2 &lt;- chooseCN(mondata2$xy,type=1,ask=FALSE)
mon2 &lt;- monmonier(mondata2$xy,dist(mondata2$x2),cn2,threshold=2)
plot(mon2,mondata2$x2,method="greylevel",add.arr=FALSE,bwd=6,col="red",csize=.5)

### genetic data example
## Not run: 
data(sim2pop)

if(require(hierfstat)){
## try and find the Fst
fstat(sim2pop,fst=TRUE)
# Fst = 0.038
}

## run monmonier algorithm

# build connection network
gab &lt;- chooseCN(sim2pop@other$xy,ask=FALSE,type=2)

# filter random noise 
pca1 &lt;- dudi.pca(sim2pop@tab,scale=FALSE, scannf=FALSE, nf=1)

# run the algorithm
mon1 &lt;- monmonier(sim2pop@other$xy,dist(pca1$l1[,1]),gab,scanthres=FALSE)

# graphical display 
plot(mon1,var=pca1$l1[,1])
temp &lt;- sim2pop@pop
levels(temp) &lt;- c(17,19)
temp &lt;- as.numeric(as.character(temp))
plot(mon1)
points(sim2pop@other$xy,pch=temp,cex=2)
legend("topright",leg=c("Pop A", "Pop B"),pch=c(17,19))


### interactive example

# north-south separation
xy &lt;- matrix(runif(120,0,10), ncol=2)
x1 &lt;- rnorm(60)
x1[xy[,2] &gt; 5] &lt;- x1[xy[,2] &gt; 5]+3
cn1 &lt;- chooseCN(xy,type=1,ask=FALSE)
mon1 &lt;- optimize.monmonier(xy,dist(x1)^2,cn1,ntry=10)

# graphics
plot(mon1,x1,met="greylevel",csize=.6)

# island in the middle
x2 &lt;- rnorm(60)
sel &lt;- (xy[,1]&gt;3.5 &amp; xy[,2]&gt;3.5 &amp; xy[,1]&lt;6.5 &amp; xy[,2]&lt;6.5)
x2[sel] &lt;- x2[sel]+4
cn2 &lt;- chooseCN(xy,type=1,ask=FALSE)
mon2 &lt;- optimize.monmonier(xy,dist(x2)^2,cn2,ntry=10)

# graphics
plot(mon2,x2,method="greylevel",add.arr=FALSE,bwd=6,col="red",csize=.5)

## End(Not run)
}
</code></pre>

<hr>
<h2 id='nancycats'>Microsatellites genotypes of 237 cats from 17 colonies of Nancy (France)</h2><span id='topic+nancycats'></span>

<h3>Description</h3>

<p>This data set gives the genotypes of 237 cats (<em>Felis catus</em> L.) for 9
microsatellites markers. The individuals are divided into 17 colonies whose
spatial coordinates are also provided.
</p>


<h3>Format</h3>

<p><code>nancycats</code> is a genind object with spatial coordinates of the
colonies as a supplementary components (@xy).
</p>


<h3>Source</h3>

<p>Dominique Pontier (UMR CNRS 5558, University Lyon1, France)
</p>


<h3>References</h3>

<p>Devillard, S.; Jombart, T. &amp; Pontier, D. Disentangling spatial
and genetic structure of stray cat (<em>Felis catus</em> L.) colonies in urban
habitat using: not all colonies are equal. submitted to <em>Molecular
Ecology</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(nancycats)
nancycats

# summary's results are stored in x
x &lt;- summary(nancycats)

# some useful graphics
barplot(x$loc.n.all,ylab="Alleles numbers",main="Alleles numbers
per locus")

plot(x$pop.eff,x$pop.nall,type="n",xlab="Sample size",ylab="Number of alleles")
text(x$pop.eff,y=x$pop.nall,lab=names(x$pop.nall))

par(las=3)
barplot(table(nancycats@pop),ylab="Number of genotypes",main="Number of genotypes per colony")

# are cats structured among colonies ?
if(require(hierfstat)){

gtest &lt;- gstat.randtest(nancycats,nsim=99)
gtest
plot(gtest)


dat &lt;- genind2hierfstat(nancycats)

Fstat &lt;- varcomp.glob(dat$pop,dat[,-1])
Fstat
}

## End(Not run)

</code></pre>

<hr>
<h2 id='old2new_genind'>Convert objects with obsolete classes into new objects</h2><span id='topic+old2new_genind'></span><span id='topic+old2new'></span><span id='topic+old2new_genlight'></span><span id='topic+old2new_genpop'></span>

<h3>Description</h3>

<p>The genind and genlight objects have changed in Adegenet version 2.0. They
have each gained strata and hierarchy slots. What's more is that the genind
objects have been optimized for storage and now store the tab slot as
integers instead of numerics. This function will convert old genind or
genlight objects to new ones seamlessly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>old2new_genind(object, donor = new("genind"))

old2new_genlight(object, donor = new("genlight"))

old2new_genpop(object, donor = new("genpop"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="old2new_genind_+3A_object">object</code></td>
<td>
<p>a genind or genlight object from version 1.4 or earlier.</p>
</td></tr>
<tr><td><code id="old2new_genind_+3A_donor">donor</code></td>
<td>
<p>a new object to place all the data into.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a><br />
Zhian N. Kamvar <a href="mailto:kamvarz@science.oregonstate.edu">kamvarz@science.oregonstate.edu</a>
</p>

<hr>
<h2 id='pairDistPlot'>Pairwise distance plots</h2><span id='topic+pairDist'></span><span id='topic+pairDist.default'></span><span id='topic+pairDistPlot'></span><span id='topic+pairDistPlot.default'></span><span id='topic+pairDistPlot.dist'></span><span id='topic+pairDistPlot.matrix'></span><span id='topic+pairDistPlot.genind'></span><span id='topic+pairDistPlot.DNAbin'></span>

<h3>Description</h3>

<p>The function <code>pairDistPlot</code> extracts and plots pairwise distances
between different groups (graphs use ggplot2). The function
<code>pairDistPlot</code> does the same, without the graphs.
</p>
<p><code>pairDistPlot</code> is a generic function with methods for the
following types of objects:<br />
- <code>dist</code> <br />
- <code>matrix</code> (only numeric data)<br />
- <code><a href="#topic+genind-class">genind</a></code> objects (genetic markers, individuals)<br />
-  <code><a href="ape.html#topic+DNAbin">DNAbin</a></code> objects (DNA sequences)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairDist(x, ...)

pairDistPlot(x, ...)

## S3 method for class 'dist'
pairDistPlot(x, grp, within=FALSE, sep="-", data=TRUE,
             violin=TRUE, boxplot=TRUE, jitter=TRUE, ...)

## S3 method for class 'matrix'
pairDistPlot(x, grp, within=FALSE, sep="-", data=TRUE,
             violin=TRUE, boxplot=TRUE, jitter=TRUE, ...)

## S3 method for class 'genind'
pairDistPlot(x, grp, within=FALSE, sep="-", data=TRUE,
             violin=TRUE, boxplot=TRUE, jitter=TRUE, ...)

## S3 method for class 'DNAbin'
pairDistPlot(x, grp, within=FALSE, sep="-", data=TRUE,
             violin=TRUE, boxplot=TRUE, jitter=TRUE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairDistPlot_+3A_x">x</code></td>
<td>
<p>pairwise distances provided as a <code>dist</code> or a symmetric
<code>matrix</code>, or <code><a href="#topic+genind-class">genind</a></code> or <code>DNAbin</code>
object. For <code><a href="#topic+genind-class">genind</a></code> objects, pairwise squared
Euclidean distances are computed from the allele data. For
<code>DNAbin</code> objects, distances are computed uing
<code><a href="ape.html#topic+dist.dna">dist.dna</a></code>, and '...' is used to pass arguments to the
function.  </p>
</td></tr>
<tr><td><code id="pairDistPlot_+3A_grp">grp</code></td>
<td>
<p>a factor defining a grouping of individuals.</p>
</td></tr>
<tr><td><code id="pairDistPlot_+3A_within">within</code></td>
<td>
<p>a logical indicating whether to keep within-group
comparisons.</p>
</td></tr>
<tr><td><code id="pairDistPlot_+3A_sep">sep</code></td>
<td>
<p>a character used as separator between group names</p>
</td></tr>
<tr><td><code id="pairDistPlot_+3A_data">data</code></td>
<td>
<p>a logical indicating whether data of the plot should be returned.</p>
</td></tr>
<tr><td><code id="pairDistPlot_+3A_violin">violin</code></td>
<td>
<p>a logical indicating whether a violinplot should be generated.</p>
</td></tr>
<tr><td><code id="pairDistPlot_+3A_boxplot">boxplot</code></td>
<td>
<p>a logical indicating whether a boxplot should be generated.</p>
</td></tr>
<tr><td><code id="pairDistPlot_+3A_jitter">jitter</code></td>
<td>
<p>a logical indicating whether a jitter-plot should be generated.</p>
</td></tr>
<tr><td><code id="pairDistPlot_+3A_...">...</code></td>
<td>
<p>further arguments to be used by other functions; used for
<code>DNAbin</code> object to pass argumetns to <code>dist.dna</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with different components, depending on the values of the
arguments. Plots are returned as <code>ggplot2</code> objects.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gengraph">gengraph</a></code> to identify connectivity based on distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## use a subset of influenza data
data(H3N2)
set.seed(1)
dat &lt;- H3N2[sample(1:nInd(H3N2), 100)]

## get pairwise distances
temp &lt;- pairDistPlot(dat, other(dat)$epid)

## see raw data
head(temp$data)

## see plots
temp$boxplot
temp$violin
temp$jitter


## End(Not run)
</code></pre>

<hr>
<h2 id='propShared'>Compute proportion of shared alleles</h2><span id='topic+propShared'></span>

<h3>Description</h3>

<p>The function <code>propShared</code> computes the proportion of
shared alleles in a set of genotypes (i.e. from a <a href="#topic+genind-class">genind</a>
object). Current implementation works for any level of ploidy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>propShared(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="propShared_+3A_obj">obj</code></td>
<td>
<p>a <a href="#topic+genind-class">genind</a> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computations of the numbers of shared alleles are done in C.
Proportions are computed from all available data, i.e. proportion can
be computed as far as there is at least one typed locus in common
between two genotypes.
</p>


<h3>Value</h3>

<p>Returns a matrix of proportions</p>


<h3>Author(s)</h3>

<p> Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+dist.genpop">dist.genpop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## make a small object
data(microbov)
obj &lt;- microbov[1:5, loc = locNames(microbov)[1:2]]

## verify results
propShared(obj)
genind2df(obj,sep="|")

## Use this similarity measure inside a PCoA
##  ! This is for illustration only !
## the distance should be rendered Euclidean before
## (e.g. using cailliez from package ade4).
matSimil &lt;- propShared(microbov)
matDist &lt;- exp(-matSimil)
D &lt;- cailliez(as.dist(matDist))
pcoa1 &lt;- dudi.pco(D,scannf=FALSE,nf=3)
s.class(pcoa1$li,microbov$pop,lab=popNames(microbov))


## End(Not run)
</code></pre>

<hr>
<h2 id='propTyped-methods'> Compute the proportion of typed elements </h2><span id='topic+propTyped'></span><span id='topic+propTyped-methods'></span><span id='topic+propTyped+2Cgenind-method'></span><span id='topic+propTyped+2Cgenpop-method'></span>

<h3>Description</h3>

<p>The generic function <code>propTyped</code> is devoted to investigating the
structure of missing data in adegenet objects.<br />
</p>
<p>Methods are defined for <a href="#topic+genind-class">genind</a> and <a href="#topic+genpop-class">genpop</a>
objects. They can return the proportion of available
(i.e. non-missing) data per individual/population, locus, or the
combination of both in with case the matrix indicates which entity
(individual or population) was typed on which locus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'genind'
propTyped(x,  by=c("ind","loc","both"))
## S4 method for signature 'genpop'
propTyped(x,  by=c("pop","loc","both"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="propTyped-methods_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+genind-class">genind</a> and <a href="#topic+genpop-class">genpop</a> object</p>
</td></tr>
<tr><td><code id="propTyped-methods_+3A_by">by</code></td>
<td>
<p>a character being &quot;ind&quot;,&quot;loc&quot;, or &quot;both&quot; for
<a href="#topic+genind-class">genind</a> object and &quot;pop&quot;,&quot;loc&quot;, or &quot;both&quot; for
<a href="#topic+genpop-class">genpop</a> object. It specifies whether proportion of typed
data are provided by entity (&quot;ind&quot;/&quot;pop&quot;), by locus (&quot;loc&quot;) or both
(&quot;both&quot;). See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>by</code> is set to &quot;both&quot;, the result is a matrix of binary data
with entities in rows (individuals or populations) and markers in
columns. The values of the matrix are 1 for typed data, and 0 for NA.
</p>


<h3>Value</h3>

<p>A vector of proportion (when <code>by</code> equals &quot;ind&quot;, &quot;pop&quot;, or
&quot;loc&quot;), or a matrix of binary data (when <code>by</code> equals &quot;both&quot;)
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(nancycats)
propTyped(nancycats,by="loc")
propTyped(genind2genpop(nancycats),by="both")

## End(Not run)
</code></pre>

<hr>
<h2 id='read.fstat'>Reading data from Fstat</h2><span id='topic+read.fstat'></span>

<h3>Description</h3>

<p>The function <code>read.fstat</code> reads Fstat data files (.dat) and convert
them into a <a href="#topic+genind-class">genind</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fstat(file, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fstat_+3A_file">file</code></td>
<td>
<p>a character string giving the path to the file to convert, with
the appropriate extension.</p>
</td></tr>
<tr><td><code id="read.fstat_+3A_quiet">quiet</code></td>
<td>
<p>logical stating whether a conversion message must be printed
(TRUE,default) or not (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: <code>read.fstat</code> is meant for DIPLOID DATA ONLY. Haploid data with
the Hierfstat format can be read into R using <code>read.table</code> or
<code>read.csv</code> after removing headers and 'POP' lines, and then converted
using <code><a href="#topic+df2genind">df2genind</a></code>.
</p>


<h3>Value</h3>

<p>an object of the class <code>genind</code>
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>
</p>


<h3>References</h3>

<p>Fstat (version 2.9.3). Software by Jerome Goudet.
http://www2.unil.ch/popgen/softwares/fstat.htm<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+import2genind">import2genind</a></code>, <code><a href="#topic+df2genind">df2genind</a></code>,
<code><a href="#topic+read.genetix">read.genetix</a></code>, <code><a href="#topic+read.structure">read.structure</a></code>,
<code><a href="#topic+read.genepop">read.genepop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
obj &lt;- read.fstat(system.file("files/nancycats.dat",package="adegenet"))
obj

</code></pre>

<hr>
<h2 id='read.genepop'>Reading data from Genepop</h2><span id='topic+read.genepop'></span>

<h3>Description</h3>

<p>The function <code>read.genepop</code> reads Genepop data files (.gen) and convert
them into a <a href="#topic+genind-class">genind</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.genepop(file, ncode = 2L, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.genepop_+3A_file">file</code></td>
<td>
<p>a character string giving the path to the file to convert, with
the appropriate extension.</p>
</td></tr>
<tr><td><code id="read.genepop_+3A_ncode">ncode</code></td>
<td>
<p>an integer indicating the number of characters used to code an allele.</p>
</td></tr>
<tr><td><code id="read.genepop_+3A_quiet">quiet</code></td>
<td>
<p>logical stating whether a conversion message must be printed
(TRUE,default) or not (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: <code>read.genepop</code> is meant for DIPLOID DATA ONLY. Haploid data with
the Genepop format can be read into R using <code>read.table</code> or
<code>read.csv</code> after removing headers and 'POP' lines, and then converted
using <code><a href="#topic+df2genind">df2genind</a></code>.
</p>


<h3>Value</h3>

<p>an object of the class <code>genind</code>
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>
</p>


<h3>References</h3>

<p>Raymond M. &amp; Rousset F, (1995). GENEPOP (version 1.2):
population genetics software for exact tests and ecumenicism. <em>J.
Heredity</em>, <b>86</b>:248-249 <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+import2genind">import2genind</a></code>, <code><a href="#topic+df2genind">df2genind</a></code>,
<code><a href="#topic+read.fstat">read.fstat</a></code>, <code><a href="#topic+read.structure">read.structure</a></code>,
<code><a href="#topic+read.genetix">read.genetix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
obj &lt;- read.genepop(system.file("files/nancycats.gen",package="adegenet"))
obj

</code></pre>

<hr>
<h2 id='read.genetix'>Reading data from GENETIX</h2><span id='topic+read.genetix'></span>

<h3>Description</h3>

<p>The function <code>read.genetix</code> reads GENETIX data files (.gtx) and convert
them into a <a href="#topic+genind-class">genind</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.genetix(file = NULL, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.genetix_+3A_file">file</code></td>
<td>
<p>a character string giving the path to the file to convert, with
the appropriate extension.</p>
</td></tr>
<tr><td><code id="read.genetix_+3A_quiet">quiet</code></td>
<td>
<p>logical stating whether a conversion message must be printed
(TRUE,default) or not (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: <code>read.genetix</code> is meant for DIPLOID DATA ONLY. Haploid data with
the GENETIX format can be read into R using <code>read.table</code> or
<code>read.csv</code> after removing headers and 'POP' lines, and then converted
using <code><a href="#topic+df2genind">df2genind</a></code>.
</p>


<h3>Value</h3>

<p>an object of the class <code>genind</code>
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>
</p>


<h3>References</h3>

<p>Belkhir K., Borsa P., Chikhi L., Raufaste N. &amp; Bonhomme F.
(1996-2004) GENETIX 4.05, logiciel sous Windows TM pour la genetique des
populations. Laboratoire Genome, Populations, Interactions, CNRS UMR 5000,
Universite de Montpellier II, Montpellier (France). <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+import2genind">import2genind</a></code>, <code><a href="#topic+df2genind">df2genind</a></code>,
<code><a href="#topic+read.fstat">read.fstat</a></code>, <code><a href="#topic+read.structure">read.structure</a></code>,
<code><a href="#topic+read.genepop">read.genepop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
obj &lt;- read.genetix(system.file("files/nancycats.gtx",package="adegenet"))
obj

</code></pre>

<hr>
<h2 id='read.snp'>Reading Single Nucleotide Polymorphism data</h2><span id='topic+read.snp'></span>

<h3>Description</h3>

<p>The function <code>read.snp</code> reads a SNP data file with extension '.snp' and
converts it into a <a href="#topic+genlight-class">genlight</a> object. This format is devoted to
handle biallelic SNP only, but can accommodate massive datasets such as
complete genomes with considerably less memory than other formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.snp(
  file,
  quiet = FALSE,
  chunkSize = 1000,
  parallel = FALSE,
  n.cores = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.snp_+3A_file">file</code></td>
<td>
<p>a character string giving the path to the file to convert, with
the extension &quot;.snp&quot;.</p>
</td></tr>
<tr><td><code id="read.snp_+3A_quiet">quiet</code></td>
<td>
<p>logical stating whether a conversion messages should be printed
(TRUE,default) or not (FALSE).</p>
</td></tr>
<tr><td><code id="read.snp_+3A_chunksize">chunkSize</code></td>
<td>
<p>an integer indicating the number of genomes to be read at a
time; larger values require more RAM but decrease the time needed to read
the data.</p>
</td></tr>
<tr><td><code id="read.snp_+3A_parallel">parallel</code></td>
<td>
<p>a logical indicating whether multiple cores -if available-
should be used for the computations (TRUE, default), or not (FALSE);
requires the package <code>parallel</code> to be installed (see details).</p>
</td></tr>
<tr><td><code id="read.snp_+3A_n.cores">n.cores</code></td>
<td>
<p>if <code>parallel</code> is TRUE, the number of cores to be used in
the computations; if NULL, then the maximum number of cores available on the
computer is used.</p>
</td></tr>
<tr><td><code id="read.snp_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to other functions - currently not
used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function reads data by chunks of a few genomes (minimum 1, no maximum)
at a time, which allows one to read massive datasets with negligible RAM
requirements (albeit at a cost of computational time). The argument
<code>chunkSize</code> indicates the number of genomes read at a time. Increasing
this value decreases the computational time required to read data in, while
increasing memory requirements.
</p>
<p>A description of the .snp format is provided in an example file distributed
with adegenet (see example below).
</p>
<p>=== The .snp format ===
</p>
<p>Details of the .snp format can be found in the example file distributed with
adegenet (see below), or on the adegenet website (type <code>adegenetWeb()</code>
in R).
</p>


<h3>Value</h3>

<p>an object of the class <code>"<a href="#topic+genlight-class">genlight</a>"</code>
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>
</p>


<h3>See Also</h3>

<p>- <code>?genlight</code> for a description of the class
<code>"<a href="#topic+genlight-class">genlight</a>"</code>.
</p>
<p>- <code><a href="#topic+read.PLINK">read.PLINK</a></code>: read SNPs in PLINK's '.raw' format.
</p>
<p>- <code><a href="#topic+fasta2genlight">fasta2genlight</a></code>: extract SNPs from alignments with fasta
format.
</p>
<p>- <code><a href="#topic+df2genind">df2genind</a></code>: convert any multiallelic markers into adegenet
<code>"<a href="#topic+genlight-class">genlight</a>"</code>.
</p>
<p>- <code><a href="#topic+import2genind">import2genind</a></code>: read multiallelic markers from various
software into adegenet.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## show the example file ##
## this is the path to the file:
system.file("files/exampleSnpDat.snp",package="adegenet")

## show its content:
file.show(system.file("files/exampleSnpDat.snp",package="adegenet"))


## read the file
obj &lt;-
read.snp(system.file("files/exampleSnpDat.snp",package="adegenet"), chunk=2)
obj
as.matrix(obj)
ploidy(obj)
alleles(obj)
locNames(obj)

## End(Not run)

</code></pre>

<hr>
<h2 id='read.structure'>Reading data from STRUCTURE</h2><span id='topic+read.structure'></span>

<h3>Description</h3>

<p>The function <code>read.structure</code> reads STRUCTURE data files (.str ou
.stru) and convert them into a <a href="#topic+genind-class">genind</a> object. By default, this
function is interactive and asks a few questions about data content. This
can be disabled (for optional questions) by turning the 'ask' argument to
FALSE. However, one has to know the number of genotypes, of markers and if
genotypes are coded on a single or on two rows before importing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.structure(
  file,
  n.ind = NULL,
  n.loc = NULL,
  onerowperind = NULL,
  col.lab = NULL,
  col.pop = NULL,
  col.others = NULL,
  row.marknames = NULL,
  NA.char = "-9",
  pop = NULL,
  sep = NULL,
  ask = TRUE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.structure_+3A_file">file</code></td>
<td>
<p>a character string giving the path to the file to convert, with
the appropriate extension.</p>
</td></tr>
<tr><td><code id="read.structure_+3A_n.ind">n.ind</code></td>
<td>
<p>an integer giving the number of genotypes (or 'individuals') in
the dataset</p>
</td></tr>
<tr><td><code id="read.structure_+3A_n.loc">n.loc</code></td>
<td>
<p>an integer giving the number of markers in the dataset</p>
</td></tr>
<tr><td><code id="read.structure_+3A_onerowperind">onerowperind</code></td>
<td>
<p>a STRUCTURE coding option: are genotypes coded on a
single row (TRUE), or on two rows (FALSE, default)</p>
</td></tr>
<tr><td><code id="read.structure_+3A_col.lab">col.lab</code></td>
<td>
<p>an integer giving the index of the column containing labels
of genotypes. '0' if absent.</p>
</td></tr>
<tr><td><code id="read.structure_+3A_col.pop">col.pop</code></td>
<td>
<p>an integer giving the index of the column containing
population to which genotypes belong. '0' if absent.</p>
</td></tr>
<tr><td><code id="read.structure_+3A_col.others">col.others</code></td>
<td>
<p>an vector of integers giving the indexes of the columns
containing other informations to be read. Will be available in @other of the
created object.</p>
</td></tr>
<tr><td><code id="read.structure_+3A_row.marknames">row.marknames</code></td>
<td>
<p>an integer giving the index of the row containing the
names of the markers. '0' if absent.</p>
</td></tr>
<tr><td><code id="read.structure_+3A_na.char">NA.char</code></td>
<td>
<p>the character string coding missing data. &quot;-9&quot; by default.
Note that in any case, series of zero (like &quot;000&quot;) are interpreted as NA
too.</p>
</td></tr>
<tr><td><code id="read.structure_+3A_pop">pop</code></td>
<td>
<p>an optional factor giving the population of each individual.</p>
</td></tr>
<tr><td><code id="read.structure_+3A_sep">sep</code></td>
<td>
<p>a character string used as separator between alleles.</p>
</td></tr>
<tr><td><code id="read.structure_+3A_ask">ask</code></td>
<td>
<p>a logical specifying if the function should ask for optional
informations about the dataset (TRUE, default), or try to be as quiet as
possible (FALSE).</p>
</td></tr>
<tr><td><code id="read.structure_+3A_quiet">quiet</code></td>
<td>
<p>logical stating whether a conversion message must be printed
(TRUE,default) or not (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: <code>read.structure</code> is meant for DIPLOID DATA ONLY. Haploid data
with the STRUCTURE format can easily be read into R using <code>read.table</code>
or <code>read.csv</code> and then converted using <code><a href="#topic+df2genind">df2genind</a></code>.
</p>


<h3>Value</h3>

<p>an object of the class <code>genind</code>
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>
</p>


<h3>References</h3>

<p>Pritchard, J.; Stephens, M. &amp; Donnelly, P. (2000) Inference of
population structure using multilocus genotype data. <em>Genetics</em>,
<b>155</b>: 945-959
</p>


<h3>See Also</h3>

<p><code><a href="#topic+import2genind">import2genind</a></code>, <code><a href="#topic+df2genind">df2genind</a></code>,
<code><a href="#topic+read.fstat">read.fstat</a></code>, <code><a href="#topic+read.genetix">read.genetix</a></code>,
<code><a href="#topic+read.genepop">read.genepop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
obj &lt;- read.structure(system.file("files/nancycats.str",package="adegenet"),
  onerowperind=FALSE, n.ind=237, n.loc=9, col.lab=1, col.pop=2, ask=FALSE)

obj

</code></pre>

<hr>
<h2 id='repool'>Pool several genotypes into a single dataset</h2><span id='topic+repool'></span>

<h3>Description</h3>

<p>The function <code>repool</code> allows to merge genotypes from different
<a href="#topic+genind-class">genind</a> objects into a single 'pool' (i.e. a new <a href="#topic+genind-class">genind</a>).
The markers have to be the same for all objects to be merged, but
there is no constraint on alleles.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repool(..., list = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repool_+3A_...">...</code></td>
<td>
<p>a list of <a href="#topic+genind-class">genind</a> objects, or a series of <a href="#topic+genind-class">genind</a> objects separated by commas</p>
</td></tr>
<tr><td><code id="repool_+3A_list">list</code></td>
<td>
<p>a logical indicating whether a list of objects with matched alleles shall be returned (TRUE), or a single <a href="#topic+genind-class">genind</a> object (FALSE, default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be useful, for instance, when hybrids are created
using <code><a href="#topic+hybridize">hybridize</a></code>, to merge hybrids with their parent
population for further analyses. Note that <code>repool</code> can also
reverse the action of <code><a href="#topic+seppop">seppop</a></code>.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seploc">seploc</a></code>, <code><a href="#topic+seppop">seppop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## use the cattle breeds dataset
data(microbov)
temp &lt;- seppop(microbov)
names(temp)
## hybridize salers and zebu -- nasty cattle
zebler &lt;- hybridize(temp$Salers, temp$Zebu, n=40)
zebler
## now merge zebler with other cattle breeds
nastyCattle &lt;- repool(microbov, zebler)
nastyCattle

## End(Not run)

</code></pre>

<hr>
<h2 id='rupica'>Microsatellites genotypes of 335 chamois (Rupicapra rupicapra) from the
Bauges mountains (France)</h2><span id='topic+rupica'></span>

<h3>Description</h3>

<p>This data set contains the genotypes of 335 chamois (<em>Rupicapra
rupicapra</em>) from the Bauges mountains, in France. No prior clustering about
individuals is known. Each genotype is georeferenced. These data also
contain a raster map of elevation of the sampling area.
</p>


<h3>Format</h3>

<p><code>rupica</code> is a genind object with 3 supplementary components
inside the <code>@other</code> slot: </p>
 <dl>
<dt>xy</dt><dd><p>a matrix containing the
spatial coordinates of the genotypes.</p>
</dd> <dt>mnt</dt><dd><p>a raster map of elevation,
with the <code>asc</code> format from the <code>adehabitat</code> package.</p>
</dd>
<dt>showBauges</dt><dd><p>a function to display the map of elevation with an
appropriate legend (use <code>showBauges()</code>).</p>
</dd> </dl>



<h3>Source</h3>

<p>Daniel Maillard, 'Office National de la Chasse et de la Faune
Sauvage' (ONCFS), France.
</p>


<h3>References</h3>

<p>Cassar S (2008) Organisation spatiale de la variabilité
génétique et phénotypique a l'échelle du paysage: le cas du chamois et du
chevreuil, en milieu de montagne. PhD Thesis. University Claude Bernard -
Lyon 1, France. <br />
</p>
<p>Cassar S, Jombart T, Loison A, Pontier D, Dufour A-B, Jullien J-M, Chevrier
T, Maillard D. Spatial genetic structure of Alpine chamois (<em>Rupicapra
rupicapra</em>): a consequence of landscape features and social factors?
submitted to <em>Molecular Ecology</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(rupica)
rupica


## Not run: 
required_packages &lt;- require(adehabitat) &amp;&amp;
  require(adespatial) &amp;&amp;
  require(spdep)
if (required_packages) {

## see the sampling area
showBauges &lt;- rupica$other$showBauges
showBauges()
points(rupica$other$xy,col="red")

## perform a sPCA
spca1 &lt;- spca(rupica,type=5,d1=0,d2=2300,plot=FALSE,scannf=FALSE,nfposi=2,nfnega=0)
barplot(spca1$eig,col=rep(c("black","grey"),c(2,100)),main="sPCA eigenvalues")
screeplot(spca1,main="sPCA eigenvalues: decomposition")

## data visualization
showBauges(,labcex=1)
s.value(spca1$xy,spca1$ls[,1],add.p=TRUE,csize=.5)
add.scatter.eig(spca1$eig,1,1,1,posi="topleft",sub="Eigenvalues")

showBauges(,labcex=1)
s.value(spca1$xy,spca1$ls[,2],add.p=TRUE,csize=.5)
add.scatter.eig(spca1$eig,2,2,2,posi="topleft",sub="Eigenvalues")

rupica$other$showBauges()
colorplot(spca1$xy,spca1$li,cex=1.5,add.plot=TRUE)

## global and local tests
Gtest &lt;- global.rtest(rupica@tab,spca1$lw,nperm=999)
Gtest
plot(Gtest)
Ltest &lt;- local.rtest(rupica@tab,spca1$lw,nperm=999)
Ltest
plot(Ltest)
}

## End(Not run)

</code></pre>

<hr>
<h2 id='scaleGen'>Compute scaled allele frequencies</h2><span id='topic+scaleGen'></span><span id='topic+scaleGen-methods'></span><span id='topic+scaleGen+2Cgenind-method'></span><span id='topic+scaleGen+2Cgenpop-method'></span>

<h3>Description</h3>

<p>The generic function <code>scaleGen</code> is an analogue to the <code>scale</code>
function, but is designed with further arguments giving scaling options.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleGen(x, ...)

## S4 method for signature 'genind'
scaleGen(
  x,
  center = TRUE,
  scale = TRUE,
  NA.method = c("asis", "mean", "zero"),
  truenames = TRUE
)

## S4 method for signature 'genpop'
scaleGen(
  x,
  center = TRUE,
  scale = TRUE,
  NA.method = c("asis", "mean", "zero"),
  truenames = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaleGen_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+genind-class">genind</a> and <a href="#topic+genpop-class">genpop</a> object</p>
</td></tr>
<tr><td><code id="scaleGen_+3A_...">...</code></td>
<td>
<p>further arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="scaleGen_+3A_center">center</code></td>
<td>
<p>a logical stating whether alleles frequencies should be
centred to mean zero (default to TRUE). Alternatively, a vector of numeric
values, one per allele, can be supplied: these values will be substracted
from the allele frequencies.</p>
</td></tr>
<tr><td><code id="scaleGen_+3A_scale">scale</code></td>
<td>
<p>a logical stating whether alleles frequencies should be scaled
(default to TRUE). Alternatively, a vector of numeric values, one per
allele, can be supplied: these values will be substracted from the allele
frequencies.</p>
</td></tr>
<tr><td><code id="scaleGen_+3A_na.method">NA.method</code></td>
<td>
<p>a method to replace NA; asis: leave NAs as is; mean: replace by the mean allele frequencies; zero: replace by zero</p>
</td></tr>
<tr><td><code id="scaleGen_+3A_truenames">truenames</code></td>
<td>
<p>no longer used; kept for backward compatibility</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods are defined for <a href="#topic+genind-class">genind</a> and <a href="#topic+genpop-class">genpop</a>
objects.  Both return data.frames of scaled allele frequencies.
</p>


<h3>Value</h3>

<p>A matrix of scaled allele frequencies with genotypes
(<a href="#topic+genind-class">genind</a>) or populations in (<a href="#topic+genpop-class">genpop</a>) in rows and
alleles in columns.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## load data
data(microbov)
obj &lt;- genind2genpop(microbov)

## apply scaling
X1 &lt;- scaleGen(obj)

## compute PCAs with and without scaling
pcaObj &lt;- dudi.pca(obj, scale = FALSE, scannf = FALSE) # pca with no scaling
pcaX1  &lt;- dudi.pca(X1, scale = FALSE, scannf = FALSE, nf = 100) # pca scaled using scaleGen()
pcaX2  &lt;- dudi.pca(obj, scale = TRUE, scannf = FALSE, nf = 100) # pca scaled in-PCA

## get the loadings of alleles for the two scalings
U1 &lt;- pcaObj$c1
U2 &lt;- pcaX1$c1
U3 &lt;- pcaX2$c1

## find an optimal plane to compare loadings
## use a procustean rotation of loadings tables
pro1 &lt;- procuste(U1, U2, nf = 2)
pro2 &lt;- procuste(U2, U3, nf = 2)
pro3 &lt;- procuste(U1, U3, nf = 2)

## graphics
par(mfrow=c(2, 3))
# eigenvalues
barplot(pcaObj$eig, main = "Eigenvalues\n no scaling")
barplot(pcaX1$eig, main = "Eigenvalues\n scaleGen scaling")
barplot(pcaX2$eig, main = "Eigenvalues\n in-PCA scaling")
# differences between loadings of alleles
s.match(pro1$scorX, pro1$scorY, clab = 0,
        sub = "no scaling -&gt; scaling (procustean rotation)")
s.match(pro2$scorX, pro2$scorY, clab = 0,
        sub = "scaling scaleGen -&gt; in-PCA scaling")
s.match(pro3$scorX, pro3$scorY, clab = 0,
        sub = "no scaling -&gt; in-PCA scaling")


## End(Not run)

</code></pre>

<hr>
<h2 id='selPopSize'> Select genotypes of well-represented populations</h2><span id='topic+selPopSize'></span><span id='topic+selPopSize-methods'></span><span id='topic+selPopSize+2CANY-method'></span><span id='topic+selPopSize+2Cgenind-method'></span>

<h3>Description</h3>

<p>The function <code>selPopSize</code> checks the sample size of each population in
a <a href="#topic+genind-class">genind</a> object and keeps only genotypes of populations
having a given minimum size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'genind'
selPopSize(x,pop=NULL,nMin=10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selPopSize_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+genind-class">genind</a> object</p>
</td></tr>
<tr><td><code id="selPopSize_+3A_pop">pop</code></td>
<td>
<p>a vector of characters or a factor giving the population of
each genotype in 'x'. If not provided, seeked from x$pop.</p>
</td></tr>
<tr><td><code id="selPopSize_+3A_nmin">nMin</code></td>
<td>
<p>the minimum sample size for a population to be
retained. Samples sizes strictly less than <code>nMin</code> will be
discarded, those equal to or greater than <code>nMin</code> are kept.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A  <a href="#topic+genind-class">genind</a> object.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+seploc">seploc</a></code>, <code><a href="#topic+repool">repool</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(microbov)

table(pop(microbov))
obj &lt;- selPopSize(microbov, n=50)

obj
table(pop(obj))

## End(Not run)
</code></pre>

<hr>
<h2 id='seploc'> Separate data per locus</h2><span id='topic+seploc'></span><span id='topic+seploc-methods'></span><span id='topic+seploc+2CANY-method'></span><span id='topic+seploc+2Cgenind-method'></span><span id='topic+seploc+2Cgenpop-method'></span><span id='topic+seploc+2Cgenlight-method'></span>

<h3>Description</h3>

<p>The function <code>seploc</code> splits an object (<a href="#topic+genind-class">genind</a>,
<a href="#topic+genpop-class">genpop</a> or <a href="#topic+genlight-class">genlight</a>) by marker. For
<a href="#topic+genind-class">genind</a> and <a href="#topic+genpop-class">genpop</a> objects, the method
returns a list of objects whose components each correspond to a
marker. For <a href="#topic+genlight-class">genlight</a> objects, the methods returns blocks
of SNPs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'genind'
seploc(x,truenames=TRUE,res.type=c("genind","matrix"))
## S4 method for signature 'genpop'
seploc(x,truenames=TRUE,res.type=c("genpop","matrix"))
## S4 method for signature 'genlight'
seploc(x, n.block=NULL, block.size=NULL, random=FALSE,
       parallel=FALSE, n.cores=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seploc_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+genind-class">genind</a> or a <a href="#topic+genpop-class">genpop</a> object.</p>
</td></tr>
<tr><td><code id="seploc_+3A_truenames">truenames</code></td>
<td>
<p>a logical indicating whether true names should be
used (TRUE, default) instead of generic labels (FALSE).</p>
</td></tr>
<tr><td><code id="seploc_+3A_res.type">res.type</code></td>
<td>
<p>a character indicating the type of returned results,
a genind or genpop object (default) or a matrix of data
corresponding to the 'tab' slot.</p>
</td></tr>
<tr><td><code id="seploc_+3A_n.block">n.block</code></td>
<td>
<p>an integer indicating the number of blocks of SNPs to
be returned.</p>
</td></tr>
<tr><td><code id="seploc_+3A_block.size">block.size</code></td>
<td>
<p>an integer indicating the size (in number of SNPs)
of the blocks to be returned.</p>
</td></tr>
<tr><td><code id="seploc_+3A_random">random</code></td>
<td>
<p>should blocks be formed of contiguous SNPs, or should
they be made or randomly chosen SNPs.</p>
</td></tr>
<tr><td><code id="seploc_+3A_parallel">parallel</code></td>
<td>
<p>a logical indicating whether multiple cores -if
available- should be used for the computations (TRUE, default), or
not (FALSE); requires the package <code>parallel</code> to be installed.</p>
</td></tr>
<tr><td><code id="seploc_+3A_n.cores">n.cores</code></td>
<td>
<p>if <code>parallel</code> is TRUE, the number of cores to be
used in the computations; if NULL, then the maximum number of cores
available on the computer is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>seploc</code> returns an list of objects of the
same class as the initial object, or a list of matrices similar to
x$tab.<br />
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+seppop">seppop</a></code>, <code><a href="#topic+repool">repool</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## example on genind objects
data(microbov)

# separate all markers
obj &lt;- seploc(microbov)
names(obj)

obj$INRA5


## example on genlight objects
x &lt;- glSim(100, 1000, 0, ploidy=2) # simulate data
x &lt;- x[,order(glSum(x))] # reorder loci by frequency of 2nd allele
glPlot(x, main="All data") # plot data
foo &lt;- seploc(x, n.block=3) # form 3 blocks
foo
glPlot(foo[[1]], main="1st block") # plot 1st block
glPlot(foo[[2]], main="2nd block") # plot 2nd block
glPlot(foo[[3]], main="3rd block") # plot 3rd block

foo &lt;- seploc(x, block.size=600, random=TRUE) # split data, randomize loci
foo # note the different block sizes
glPlot(foo[[1]])

## End(Not run)
</code></pre>

<hr>
<h2 id='seppop'> Separate genotypes per population</h2><span id='topic+seppop'></span><span id='topic+seppop-methods'></span><span id='topic+seppop+2CANY-method'></span><span id='topic+seppop+2Cgenind-method'></span><span id='topic+seppop+2Cgenlight-method'></span>

<h3>Description</h3>

<p>The function <code>seppop</code> splits a <a href="#topic+genind-class">genind</a> or a
<a href="#topic+genlight-class">genlight</a> object by population, returning a list of
objects whose components each correspond to a population.<br />
</p>
<p>For <a href="#topic+genind-class">genind</a> objects, the output can either be a list of
<a href="#topic+genind-class">genind</a> (default), or a list of matrices corresponding to
the <code>@tab</code> slot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'genind'
seppop(x,pop=NULL,truenames=TRUE,res.type=c("genind","matrix"),
  drop=FALSE, treatOther=TRUE, keepNA = FALSE, quiet=TRUE)

## S4 method for signature 'genlight'
seppop(x,pop=NULL, treatOther=TRUE, keepNA = FALSE, quiet=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seppop_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+genind-class">genind</a> object</p>
</td></tr>
<tr><td><code id="seppop_+3A_pop">pop</code></td>
<td>
<p>a factor giving the population of each genotype in 'x' OR a
formula specifying which strata are to be used when converting to a genpop
object. If none provided, population factors are sought in x@pop, but if
given, the argument prevails on x@pop.</p>
</td></tr>
<tr><td><code id="seppop_+3A_truenames">truenames</code></td>
<td>
<p>a logical indicating whether true names should be
used (TRUE, default) instead of generic labels (FALSE); used if
res.type is &quot;matrix&quot;.</p>
</td></tr>
<tr><td><code id="seppop_+3A_res.type">res.type</code></td>
<td>
<p>a character indicating the type of returned results,
a list of <a href="#topic+genind-class">genind</a> object (default) or a matrix of data
corresponding to the 'tab' slots.</p>
</td></tr>
<tr><td><code id="seppop_+3A_drop">drop</code></td>
<td>
<p>a logical stating whether alleles that are no longer
present in a subset of data should be discarded (TRUE) or kept anyway
(FALSE, default).</p>
</td></tr>
<tr><td><code id="seppop_+3A_treatother">treatOther</code></td>
<td>
<p>a logical stating whether elements of the
<code>@other</code> slot should be treated as well (TRUE), or not
(FALSE). See details in accessor documentations
(<code><a href="#topic+pop">pop</a></code>).</p>
</td></tr>
<tr><td><code id="seppop_+3A_keepna">keepNA</code></td>
<td>
<p>If there are individuals with missing population information,
should they be pooled into a separate population (TRUE), or excluded (FALSE,
default).</p>
</td></tr>
<tr><td><code id="seppop_+3A_quiet">quiet</code></td>
<td>
<p>a logical indicating whether warnings should be issued
when trying to subset components of the <code>@other</code> slot (TRUE),
or not (FALSE, default). </p>
</td></tr>
<tr><td><code id="seppop_+3A_...">...</code></td>
<td>
<p>further arguments passed to the genlight constructor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>According to 'res.type': a list of <a href="#topic+genind-class">genind</a> object
(default) or a matrix of data corresponding to the 'tab' slots.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+seploc">seploc</a></code>, <code><a href="#topic+repool">repool</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(microbov)
strata(microbov) &lt;- data.frame(other(microbov))

obj &lt;- seppop(microbov)
names(obj)

obj$Salers

### example using strata
obj2 &lt;- seppop(microbov, ~coun/spe)
names(obj2)

obj2$AF_BI

#### example for genlight objects ####
x &lt;- new("genlight", list(a=rep(1,1e3),b=rep(0,1e3),c=rep(1, 1e3)))
x

pop(x) # no population info
pop(x) &lt;- c("pop1","pop2", "pop1") # set population memberships
pop(x)
seppop(x)
as.matrix(seppop(x)$pop1)[,1:20]
as.matrix(seppop(x)$pop2)[,1:20,drop=FALSE]

## End(Not run)
</code></pre>

<hr>
<h2 id='seqTrack'>SeqTrack algorithm for reconstructing genealogies</h2><span id='topic+seqTrack'></span><span id='topic+seqTrack.default'></span><span id='topic+seqTrack.matrix'></span><span id='topic+plotSeqTrack'></span><span id='topic+get.likelihood'></span><span id='topic+get.likelihood.seqTrack'></span><span id='topic+seqTrack-class'></span><span id='topic+as.igraph.seqTrack'></span><span id='topic+plot.seqTrack'></span>

<h3>Description</h3>

<p>The SeqTrack algorithm [1] aims at reconstructing genealogies of sampled
haplotypes or genotypes for which a collection date is
available. Contrary to phylogenetic methods which aims at reconstructing
hypothetical ancestors for observed sequences, SeqTrack
considers that ancestors and descendents are sampled together, and
therefore infers ancestry relationships among the sampled sequences.
</p>
<p>This approach proved more efficient than phylogenetic approaches for
reconstructing transmission trees in densely sampled disease outbreaks
[1]. This implementation defines a generic function <code>seqTrack</code>
with methods for specific object classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqTrack(...)

## S3 method for class 'matrix'
seqTrack(x, x.names, x.dates, best = c("min", "max"),
    prox.mat = NULL, mu = NULL, haplo.length = NULL, ...)

## S3 method for class 'seqTrack'
as.igraph(x, col.pal=redpal, ...)

## S3 method for class 'seqTrack'
plot(x, y=NULL, col.pal=redpal, ...)

plotSeqTrack(x, xy, use.arrows=TRUE, annot=TRUE, labels=NULL, col=NULL,
                         bg="grey", add=FALSE, quiet=FALSE,
                         date.range=NULL, jitter.arrows=0, plot=TRUE, ...)

get.likelihood(...)

## S3 method for class 'seqTrack'
get.likelihood(x, mu, haplo.length, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqTrack_+3A_x">x</code></td>
<td>
<p>for seqTrack, a matrix giving weights to pairs of ancestries
such that x[i,j] is the weight of 'i ancestor of j'. For
plotSeqTrack and get.likelihood. seqTrack, a <code>seqTrack</code>
object.</p>
</td></tr>
<tr><td><code id="seqTrack_+3A_x.names">x.names</code></td>
<td>
<p>a character vector giving the labels of the haplotypes/genotypes</p>
</td></tr>
<tr><td><code id="seqTrack_+3A_x.dates">x.dates</code></td>
<td>
<p>a vector of collection dates for the sampled
haplotypes/genotypes. Dates must have the POSIXct format. See
<code>details</code> or <code>?as.POSIXct</code> for more information.</p>
</td></tr>
<tr><td><code id="seqTrack_+3A_best">best</code></td>
<td>
<p>a character string matching 'min' or 'max', indicating
whether genealogies should minimize or maximize the sum of weights
of ancestries.</p>
</td></tr>
<tr><td><code id="seqTrack_+3A_prox.mat">prox.mat</code></td>
<td>
<p>an optional matrix of proximities between
haplotypes/genotypes used to resolve ties in the choice of
ancestors, by picking up the 'closest' ancestor amongst possible
ancestors, in the sense of <code>prox.mat</code>. <code>prox.mat[i,j]</code>
must indicate a proximity for the relationship 'i ancestor to
j'. For instance, if <code>prox.mat</code> contains spatial proximities,
then <code>prox.mat[i,j]</code> gives a measure of how easy it is to
migrate from location 'i' to 'j'.
</p>
</td></tr>
<tr><td><code id="seqTrack_+3A_mu">mu</code></td>
<td>
<p>(optional) a mutation rate, per site and per day. When 'x'
contains numbers of mutations, used to resolve ties using a maximum
likelihood approach (requires <code>haplo.length</code> to be provided).</p>
</td></tr>
<tr><td><code id="seqTrack_+3A_haplo.length">haplo.length</code></td>
<td>
<p>(optional) the length of analysed sequences in
number of nucleotides. When 'x' contains numbers of mutations, used
to resolve ties using a maximum likelihood approach (requires
<code>mu</code> to be provided).</p>
</td></tr>
<tr><td><code id="seqTrack_+3A_y">y</code></td>
<td>
<p>unused argument, for compatibility with 'plot'.</p>
</td></tr>
<tr><td><code id="seqTrack_+3A_col.pal">col.pal</code></td>
<td>
<p>a color palette to be used to represent weights using
colors on the edges of the graph. See <code>?num2col</code>. Note that the
palette is inversed by default.</p>
</td></tr>
<tr><td><code id="seqTrack_+3A_xy">xy</code></td>
<td>
<p>spatial coordinates of the sampled haplotypes/genotypes.</p>
</td></tr>
<tr><td><code id="seqTrack_+3A_use.arrows">use.arrows</code></td>
<td>
<p>a logical indicating whether arrows should be used to
represented ancestries (pointing from ancestor to descendent, TRUE),
or whether segments shall be used (FALSE).</p>
</td></tr>
<tr><td><code id="seqTrack_+3A_annot">annot</code></td>
<td>
<p>a logical indicating whether arrows or segments
representing ancestries should be annotated (TRUE) or not (FALSE).</p>
</td></tr>
<tr><td><code id="seqTrack_+3A_labels">labels</code></td>
<td>
<p>a character vector containing annotations of the
ancestries. If left empty, ancestries are annotated by the descendent.</p>
</td></tr>
<tr><td><code id="seqTrack_+3A_col">col</code></td>
<td>
<p>a vector of colors to be used for plotting ancestries.</p>
</td></tr>
<tr><td><code id="seqTrack_+3A_bg">bg</code></td>
<td>
<p>a color to be used as background.</p>
</td></tr>
<tr><td><code id="seqTrack_+3A_add">add</code></td>
<td>
<p>a logical stating whether the plot should be added to
current figure (TRUE), or drawn as a new plot (FALSE, default).</p>
</td></tr>
<tr><td><code id="seqTrack_+3A_quiet">quiet</code></td>
<td>
<p>a logical stating whether messages other than errors
should be displayed (FALSE, default), or hidden (TRUE).</p>
</td></tr>
<tr><td><code id="seqTrack_+3A_date.range">date.range</code></td>
<td>
<p>a vector of length two with POSIXct format indicating
the time window for which ancestries should be displayed.</p>
</td></tr>
<tr><td><code id="seqTrack_+3A_jitter.arrows">jitter.arrows</code></td>
<td>
<p>a positive number indicating the amount of noise
to be added to coordinates of arrows; useful when several arrows
overlap. See <code><a href="base.html#topic+jitter">jitter</a></code>.</p>
</td></tr>
<tr><td><code id="seqTrack_+3A_plot">plot</code></td>
<td>
<p>a logical stating whether a plot should be drawn (TRUE,
default), or not (FALSE). In all cases, the
function invisibly returns plotting information.</p>
</td></tr>
<tr><td><code id="seqTrack_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>=== Maximum parsimony genealogies ===<br />
Maximum parsimony genealogies can be obtained easily using this
implementation of seqTrack. One has to provide in <code>x</code> a matrix of
genetic distances. The most straightforward distance is the number of
differing nucleotides. See <code><a href="ape.html#topic+dist.dna">dist.dna</a></code> in the ape
package for a wide range of genetic distances between aligned
sequences. The argument <code>best</code> should be set to &quot;min&quot; (its
default value), so that the identified genealogy minimizes the total
number of mutations. If <code>x</code> contains number of mutations, then
<code>mu</code> and <code>haplo.length</code> should also be provided for
resolving ties in equally parsimonious ancestors using maximum
likelihood.
</p>
<p>=== Likelihood of observed genetic differentiation ===<br />
The probability of oberving a given number of mutations between a
sequence and its ancestor can be computed using
<code>get.likelihood.seqTrack</code>. Note that this is only possible
if <code>x</code> contained number of mutations.
</p>
<p>=== Plotting/converting seqTrack objects to graphs ===<br />
seqTrack objects are best plotted as graphs. From adegenet_1.3-5
onwards, seqTrack objects can be converted to <code>igraph</code> objects (from the
package <code>igraph</code>), which can in turn be plotted and manipulated
using classical graph tools. The plot method does this operation
automatically, using colors to represent edge weights, and using
time-ordering of the data from top (ancient) to bottom (recent).
</p>


<h3>Value</h3>

<p>=== output of seqTrack ===<br />
seqTrack function returns data.frame with the class <code>seqTrack</code>,
in which each row is an inferred ancestry described by the following columns:
- id: indices identifying haplotypes/genotypes<br />
- ances: index of the inferred ancestor<br />
- weight: weight of the inferred ancestries<br />
- date: date of the haplotype/genotype<br />
- ances.date: date of the ancestor
</p>
<p>=== output of plotSeqTrack ===<br />
This graphical function invisibly returns the coordinates of the
arrows/segments drawn and their colors, as a data.frame.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>
</p>


<h3>References</h3>

<p>Jombart T, Eggo R, Dodd P, Balloux F (2010) Reconstructing disease
outbreaks from genetic data: a graph approach. Heredity. doi:
10.1038/hdy.2010.78.
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+dist.dna">dist.dna</a></code> in the ape package to compute pairwise
genetic distances in aligned sequences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(require(ape &amp;&amp; require(igraph))){
## ANALYSIS OF SIMULATED DATA ##
## SIMULATE A GENEALOGY
dat &lt;- haploGen(seq.l=1e4, repro=function(){sample(1:4,1)}, gen.time=1, t.max=3)
plot(dat, main="Simulated data")

## SEQTRACK ANALYSIS
res &lt;- seqTrack(dat, mu=0.0001, haplo.length=1e4) 
plot(res, main="seqTrack reconstruction")

## PROPORTION OF CORRECT RECONSTRUCTION
mean(dat$ances==res$ances,na.rm=TRUE)


## ANALYSIS OF PANDEMIC A/H1N1 INFLUENZA DATA ##
## note:
## this is for reproduction purpose only
## seqTrack is best kept for the analysis
## of densely sampled outbreaks, which
## is not the case of this dataset.
## 
dat &lt;- read.csv(system.file("files/pdH1N1-data.csv",package="adegenet"))
ha &lt;-  read.dna(system.file("files/pdH1N1-HA.fasta",package="adegenet"), format="fa")
na &lt;- read.dna(system.file("files/pdH1N1-NA.fasta",package="adegenet"), format="fa")


## COMPUTE NUCLEOTIDIC DISTANCES
nbNucl &lt;- ncol(as.matrix(ha)) + ncol(as.matrix(na))
D &lt;- dist.dna(ha,model="raw")*ncol(as.matrix(ha)) +
dist.dna(na,model="raw")*ncol(as.matrix(na))
D &lt;- round(as.matrix(D))


## MATRIX OF SPATIAL CONNECTIVITY
## (to promote local transmissions)
xy &lt;- cbind(dat$lon, dat$lat)
temp &lt;- as.matrix(dist(xy))
M &lt;- 1* (temp &lt; 1e-10)


## SEQTRACK ANALYSIS
dat$date &lt;- as.POSIXct(dat$date)
res &lt;- seqTrack(D, rownames(dat), dat$date, prox.mat=M, mu=.00502/365, haplo.le=nbNucl)


## COMPUTE GENETIC LIKELIHOOD
p &lt;- get.likelihood(res, mu=.00502/365, haplo.length=nbNucl)
# (these could be shown as colors when plotting results)
# (but mutations will be used instead)


## EXAMINE RESULTS
head(res)
tail(res)
range(res$weight, na.rm=TRUE)
barplot(table(res$weight)/sum(!is.na(res$weight)), ylab="Frequency",
xlab="Mutations between inferred ancestor and descendent", col="orange")


## DISPLAY SPATIO-TEMPORAL DYNAMICS 
if(require(maps)){
myDates &lt;- as.integer(difftime(dat$date, as.POSIXct("2009-01-21"), unit="day"))
myMonth &lt;- as.POSIXct(
c("2009-02-01", "2009-03-01","2009-04-01","2009-05-01","2009-06-01","2009-07-01"))
x.month &lt;-  as.integer(difftime(myMonth, as.POSIXct("2009-01-21"), unit="day"))


## FIRST STAGE:
## SPREAD TO THE USA AND CANADA
curRange &lt;- as.POSIXct(c("2009-03-29","2009-04-25"))
par(bg="deepskyblue")
map("world", fill=TRUE, col="grey")
opal &lt;- palette()
palette(rev(heat.colors(10)))
plotSeqTrack(res, round(xy), add=TRUE,annot=FALSE,lwd=2,date.range=curRange,
col=res$weight+1)
title(paste(curRange, collapse=" to "))
legend("bottom", lty=1, leg=0:8, title="number of mutations", col=1:9,
lwd=2, horiz=TRUE)


## SECOND STAGE:
## SPREAD WITHIN AMERICA, FIRST SEEDING OUTSIDE AMERICA
curRange &lt;- as.POSIXct(c("2009-04-30","2009-05-07"))
par(bg="deepskyblue")
map("world", fill=TRUE, col="grey")
opal &lt;- palette()
palette(rev(heat.colors(10)))
plotSeqTrack(res, round(xy), add=TRUE,annot=FALSE,lwd=2,
date.range=curRange, col=res$weight+1)
title(paste(curRange, collapse=" to "))
legend("bottom", lty=1, leg=0:8, title="number of mutations",
col=1:9,lwd=2, horiz=TRUE)


## THIRD STAGE:
## PANDEMIC
curRange &lt;- as.POSIXct(c("2009-05-15","2009-05-25"))
par(bg="deepskyblue")
map("world", fill=TRUE, col="grey")
opal &lt;- palette()
palette(rev(heat.colors(10)))
plotSeqTrack(res, round(xy), add=TRUE,annot=FALSE,lwd=2, date.range=curRange,
col=res$weight+1)
title(paste(curRange, collapse=" to "))
legend("bottom", lty=1, leg=0:8, title="number of mutations",
col=1:9,lwd=2, horiz=TRUE)

}
}

## End(Not run)
</code></pre>

<hr>
<h2 id='SequencesToGenind'> Importing data from an alignement of sequences to a genind object</h2><span id='topic+DNAbin2genind'></span><span id='topic+alignment2genind'></span>

<h3>Description</h3>

<p>These functions take an alignement of sequences and translate SNPs
into a <a href="#topic+genind-class">genind</a> object. Note that only polymorphic loci
are retained.<br />
</p>
<p>Currently, accepted sequence formats are:<br />
- DNAbin (ape package): function DNAbin2genind<br />
- alignment (seqinr package): function alignment2genind<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DNAbin2genind(x, pop=NULL, exp.char=c("a","t","g","c"), polyThres=1/100)

alignment2genind(x, pop=NULL, exp.char=c("a","t","g","c"), na.char="-",
                 polyThres=1/100)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SequencesToGenind_+3A_x">x</code></td>
<td>
<p>an object containing aligned sequences.</p>
</td></tr>
<tr><td><code id="SequencesToGenind_+3A_pop">pop</code></td>
<td>
<p>an optional factor giving the population to which each sequence belongs.</p>
</td></tr>
<tr><td><code id="SequencesToGenind_+3A_exp.char">exp.char</code></td>
<td>
<p>a vector of single character providing expected values;
all other characters will be turned to NA.</p>
</td></tr>
<tr><td><code id="SequencesToGenind_+3A_na.char">na.char</code></td>
<td>
<p>a vector of single characters providing values that should be
considered as NA. If not NULL, this is used instead of <code>exp.char</code>.</p>
</td></tr>
<tr><td><code id="SequencesToGenind_+3A_polythres">polyThres</code></td>
<td>
<p>the minimum frequency of a minor allele for a locus to
be considered as polymorphic (defaults to 0.01).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of the class <a href="#topic+genind-class">genind</a></p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+import2genind">import2genind</a></code>, <code><a href="#topic+read.genetix">read.genetix</a></code>,
<code><a href="#topic+read.fstat">read.fstat</a></code>, <code><a href="#topic+read.structure">read.structure</a></code>,
<code><a href="#topic+read.genepop">read.genepop</a></code>, <code><a href="ape.html#topic+DNAbin">DNAbin</a></code>,
<code><a href="seqinr.html#topic+as.alignment">as.alignment</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(woodmouse)
x &lt;- DNAbin2genind(woodmouse)
x
genind2df(x)

## End(Not run)

if(require(seqinr)){
mase.res   &lt;- read.alignment(file=system.file("sequences/test.mase",package="seqinr"),
format = "mase")
mase.res
x &lt;- alignment2genind(mase.res)
x
locNames(x) # list of polymorphic sites
genind2df(x)

## look at Euclidean distances
D &lt;- dist(tab(x))
D

## summarise with a PCoA
pco1 &lt;- dudi.pco(D, scannf=FALSE,nf=2)
scatter(pco1, posi="bottomright")
title("Principal Coordinate Analysis\n-based on proteic distances-")

}
</code></pre>

<hr>
<h2 id='setPop'>Manipulate the population factor of genind objects.</h2><span id='topic+setPop'></span><span id='topic+setPop+2Cgenind-method'></span><span id='topic+setPop+2Cgenlight-method'></span><span id='topic+setPop+3C-'></span><span id='topic+setPop+3C-+2Cgenind-method'></span><span id='topic+setPop+3C-+2Cgenlight-method'></span>

<h3>Description</h3>

<p>The following methods allow the user to quickly change the population of a 
genind object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPop(x, formula = NULL)

setPop(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setPop_+3A_x">x</code></td>
<td>
<p>a genind or genlight object</p>
</td></tr>
<tr><td><code id="setPop_+3A_formula">formula</code></td>
<td>
<p>a nested formula indicating the order of the population
strata.</p>
</td></tr>
<tr><td><code id="setPop_+3A_value">value</code></td>
<td>
<p>same as formula</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(microbov)

strata(microbov) &lt;- data.frame(other(microbov))

# Currently set on just 
head(pop(microbov)) 

# setting the strata to both Pop and Subpop
setPop(microbov) &lt;- ~coun/breed 
head(pop(microbov))

## Not run: 

# Can be used to create objects as well.
microbov.old &lt;- setPop(microbov, ~spe) 
head(pop(microbov.old))

## End(Not run)
</code></pre>

<hr>
<h2 id='showmekittens'>When you need a break...</h2><span id='topic+showmekittens'></span>

<h3>Description</h3>

<p>Genetic data analysis can be a harsh, tiring, daunting task.
Sometimes, a mere break will not cut it.
Sometimes, you need a kitten.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showmekittens(x = NULL, list = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showmekittens_+3A_x">x</code></td>
<td>
<p>the name or index of the video to display; if NULL, a random video is chosen</p>
</td></tr>
<tr><td><code id="showmekittens_+3A_list">list</code></td>
<td>
<p>a logical indicating if the list of available videos should be displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please send us more! Either pull request or submit an issue with a URL (use
<code>adegenetIssues()</code>).
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>
</p>

<hr>
<h2 id='sim2pop'>Simulated genotypes of two georeferenced populations</h2><span id='topic+sim2pop'></span>

<h3>Description</h3>

<p>This simple data set was obtained by sampling two populations evolving in a
island model, simulated using Easypop (2.0.1). See <code>source</code> for
simulation details. Sample sizes were respectively 100 and 30 genotypes. The
genotypes were given spatial coordinates so that both populations were
spatially differentiated.
</p>


<h3>Format</h3>

<p><code>sim2pop</code> is a genind object with a matrix of xy coordinates as
supplementary component.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>
</p>


<h3>Source</h3>

<p>Easypop version 2.0.1 was run with the following parameters:<br /> -
two diploid populations, one sex, random mating<br /> - 1000 individuals per
population<br /> - proportion of migration: 0.002<br /> - 20 loci<br /> - mutation
rate: 0.0001 (KAM model)<br /> - maximum of 50 allelic states<br /> - 1000
generations (last one taken)<br />
</p>


<h3>References</h3>

<p>Balloux F (2001) Easypop (version 1.7): a computer program for
oppulation genetics simulations <em>Journal of Heredity</em>, <b>92</b>:
301-302
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(sim2pop)

if(require(hierfstat)){
## try and find the Fst
temp &lt;- genind2hierfstat(sim2pop)
varcomp.glob(temp[,1],temp[,-1])
# Fst = 0.038
}

## run monmonier algorithm

# build connection network
gab &lt;- chooseCN(sim2pop@other$xy,ask=FALSE,type=2)

# filter random noise
pca1 &lt;- dudi.pca(sim2pop@tab,scale=FALSE, scannf=FALSE, nf=1)

# run the algorithm
mon1 &lt;- monmonier(sim2pop@other$xy,dist(pca1$l1[,1]),gab, scanthres=FALSE)

# graphical display
temp &lt;- sim2pop@pop
levels(temp) &lt;- c(17,19)
temp &lt;- as.numeric(as.character(temp))
plot(mon1)
points(sim2pop@other$xy,pch=temp,cex=2)
legend("topright",leg=c("Pop A", "Pop B"),pch=c(17,19))

## End(Not run)

</code></pre>

<hr>
<h2 id='snapclust'>Maximum-likelihood genetic clustering using EM algorithm</h2><span id='topic+snapclust'></span>

<h3>Description</h3>

<p>This function implements the fast maximum-likelihood genetic clustering
approach described in Beugin et al (2018). The underlying model is very close
to the model implemented by STRUCTURE, but allows for much faster estimation
of genetic clusters thanks to the use of the Expectation-Maximization (EM)
algorithm. Optionally, the model can explicitely account for hybridization
and detect different types of hybrids (see <code>hybrids</code> and
<code>hybrid.coef</code> arguments). The method is fully documented in a dedicated
tutorial which can be accessed using <code>adegenetTutorial("snapclust")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snapclust(
  x,
  k,
  pop.ini = "ward",
  max.iter = 100,
  n.start = 10,
  n.start.kmeans = 50,
  hybrids = FALSE,
  dim.ini = 100,
  hybrid.coef = NULL,
  parent.lab = c("A", "B"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snapclust_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+genind-class">genind</a> object</p>
</td></tr>
<tr><td><code id="snapclust_+3A_k">k</code></td>
<td>
<p>the number of clusters to look for</p>
</td></tr>
<tr><td><code id="snapclust_+3A_pop.ini">pop.ini</code></td>
<td>
<p>parameter indicating how the initial group membership should
be found. If <code>NULL</code>, groups are chosen at random, and the algorithm
will be run <code>n.start times</code>. If &quot;kmeans&quot;, then the function
<code>find.clusters</code> is used to define initial groups using the K-means
algorithm. If &quot;ward&quot;, then the function <code>find.clusters</code> is used to
define initial groups using the Ward algorithm. Alternatively, a factor
defining the initial cluster configuration can be provided.</p>
</td></tr>
<tr><td><code id="snapclust_+3A_max.iter">max.iter</code></td>
<td>
<p>the maximum number of iteration of the EM algorithm</p>
</td></tr>
<tr><td><code id="snapclust_+3A_n.start">n.start</code></td>
<td>
<p>the number of times the EM algorithm is run, each time with
different random starting conditions</p>
</td></tr>
<tr><td><code id="snapclust_+3A_n.start.kmeans">n.start.kmeans</code></td>
<td>
<p>the number of times the K-means algorithm is run to
define the starting point of the ML-EM algorithm, each time with
different random starting conditions</p>
</td></tr>
<tr><td><code id="snapclust_+3A_hybrids">hybrids</code></td>
<td>
<p>a logical indicating if hybrids should be modelled
explicitely; this is currently implemented for 2 groups only.</p>
</td></tr>
<tr><td><code id="snapclust_+3A_dim.ini">dim.ini</code></td>
<td>
<p>the number of PCA axes to retain in the dimension reduction
step for <code><a href="#topic+find.clusters">find.clusters</a></code>, if this method is used to define
initial group memberships (see argument <code>pop.ini</code>).</p>
</td></tr>
<tr><td><code id="snapclust_+3A_hybrid.coef">hybrid.coef</code></td>
<td>
<p>a vector of hybridization coefficients, defining the
proportion of hybrid gene pool coming from the first parental population;
this is symmetrized around 0.5, so that e.g. c(0.25, 0.5) will be
converted to c(0.25, 0.5, 0.75)</p>
</td></tr>
<tr><td><code id="snapclust_+3A_parent.lab">parent.lab</code></td>
<td>
<p>a vector of 2 character strings used to label the two
parental populations; only used if hybrids are detected (see argument
<code>hybrids</code>)</p>
</td></tr>
<tr><td><code id="snapclust_+3A_...">...</code></td>
<td>
<p>further arguments passed on to <code><a href="#topic+find.clusters">find.clusters</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method is described in Beugin et al (2018) A fast likelihood
solution to the genetic clustering problem. Methods in Ecology and
Evolution <a href="https://doi.org/10.1111/2041-210X.12968">doi:10.1111/2041-210X.12968</a>. A dedicated
tutorial is available by typing <code>adegenetTutorial("snapclust")</code>.
</p>


<h3>Value</h3>

<p>The function <code>snapclust</code> returns a list with the following
components:
</p>

<ul>
<li> <p><code>$group</code> a factor indicating the maximum-likelihood assignment of
individuals to groups; if identified, hybrids are labelled after
hybridization coefficients, e.g. 0.5_A - 0.5_B for F1, 0.75_A - 0.25_B for
backcross F1 / A, etc.
</p>
</li>
<li> <p><code>$ll</code>: the log-likelihood of the model
</p>
</li>
<li> <p><code>$proba</code>: a matrix of group membership probabilities, with
individuals in rows and groups in columns; each value correspond to the
probability that a given individual genotype was generated under a given
group, under Hardy-Weinberg hypotheses.
</p>
</li>
<li> <p><code>$converged</code> a logical indicating if the algorithm converged; if
FALSE, it is doubtful that the result is an actual Maximum Likelihood
estimate.
</p>
</li>
<li> <p><code>$n.iter</code> an integer indicating the number of iterations the EM
algorithm was run for.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a> and Marie-Pauline
Beugin
</p>


<h3>See Also</h3>

<p>The function <code><a href="#topic+snapclust.choose.k">snapclust.choose.k</a></code> to investigate the optimal
value number of clusters 'k'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(microbov)

## try function using k-means initialization
grp.ini &lt;- find.clusters(microbov, n.clust=15, n.pca=150)

## run EM algo
res &lt;- snapclust(microbov, 15, pop.ini = grp.ini$grp)
names(res)
res$converged
res$n.iter

## plot result
compoplot(res)

## flag potential hybrids
to.flag &lt;- apply(res$proba,1,max)&lt;.9
compoplot(res, subset=to.flag, show.lab=TRUE,
                 posi="bottomleft", bg="white")


## Simulate hybrids F1
zebu &lt;- microbov[pop="Zebu"]
salers &lt;- microbov[pop="Salers"]
hyb &lt;- hybridize(zebu, salers, n=30)
x &lt;- repool(zebu, salers, hyb)

## method without hybrids
res.no.hyb &lt;- snapclust(x, k=2, hybrids=FALSE)
compoplot(res.no.hyb, col.pal=spectral, n.col=2)

## method with hybrids
res.hyb &lt;- snapclust(x, k=2, hybrids=TRUE)
compoplot(res.hyb, col.pal =
          hybridpal(col.pal = spectral), n.col = 2)


## Simulate hybrids backcross (F1 / parental)
f1.zebu &lt;- hybridize(hyb, zebu, 20, pop = "f1.zebu")
f1.salers &lt;- hybridize(hyb, salers, 25, pop = "f1.salers")
y &lt;- repool(x, f1.zebu, f1.salers)

## method without hybrids
res2.no.hyb &lt;- snapclust(y, k = 2, hybrids = FALSE)
compoplot(res2.no.hyb, col.pal = hybridpal(), n.col = 2)

## method with hybrids F1 only
res2.hyb &lt;- snapclust(y, k = 2, hybrids = TRUE)
compoplot(res2.hyb, col.pal = hybridpal(), n.col = 2)

## method with back-cross
res2.back &lt;- snapclust(y, k = 2, hybrids = TRUE, hybrid.coef = c(.25,.5))
compoplot(res2.back, col.pal = hybridpal(), n.col = 2)


## End(Not run)
</code></pre>

<hr>
<h2 id='snapclust.choose.k'>Choose the number of clusters for snapclust using AIC, BIC or AICc</h2><span id='topic+snapclust.choose.k'></span>

<h3>Description</h3>

<p>This function implements methods for investigating the optimal number of
genetic clusters ('k') using the fast maximum-likelihood genetic clustering
approach described in Beugin et al (2018). The method runs
<code><a href="#topic+snapclust">snapclust</a></code> for varying values of 'k', and computes the requested
summary statistics for each clustering solution to assess goodness of
fit. The method is fully documented in a dedicated tutorial which can be
accessed using <code>adegenetTutorial("snapclust")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snapclust.choose.k(max, ..., IC = AIC, IC.only = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snapclust.choose.k_+3A_max">max</code></td>
<td>
<p>An integer indicating the maximum number of clusters to seek;
<code><a href="#topic+snapclust">snapclust</a></code> will be run for all k from 2 to max.</p>
</td></tr>
<tr><td><code id="snapclust.choose.k_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+snapclust">snapclust</a></code>.</p>
</td></tr>
<tr><td><code id="snapclust.choose.k_+3A_ic">IC</code></td>
<td>
<p>A function computing the information criterion for
<code><a href="#topic+snapclust">snapclust</a></code> objects. Available statistics are
<code>AIC</code> (default), <code>AICc</code>, and <code>BIC</code>.</p>
</td></tr>
<tr><td><code id="snapclust.choose.k_+3A_ic.only">IC.only</code></td>
<td>
<p>A logical (TRUE by default) indicating if IC values only
should be returned; if <code>FALSE</code>, full <code>snapclust</code> objects are
returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method is described in Beugin et al (2018) A fast likelihood
solution to the genetic clustering problem. Methods in Ecology and
Evolution <a href="https://doi.org/10.1111/2041-210X.12968">doi:10.1111/2041-210X.12968</a>. A dedicated
tutorial is available by typing <code>adegenetTutorial("snapclust")</code>.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+snapclust">snapclust</a></code> to generate individual clustering solutions,
and <code><a href="#topic+BIC.snapclust">BIC.snapclust</a></code> for computing BIC for <code>snapclust</code>
objects.
</p>

<hr>
<h2 id='SNPbin-class'>Formal class &quot;SNPbin&quot;</h2><span id='topic+SNPbin'></span><span id='topic+SNPbin-class'></span><span id='topic++5B+2CSNPbin-method'></span><span id='topic++5B+2CSNPbin+2CANY+2CANY-method'></span><span id='topic++5B+2CSNPbin+2CANY+2CANY+2CANY-method'></span><span id='topic+initialize+2CSNPbin-method'></span><span id='topic+show+2CSNPbin-method'></span><span id='topic+nLoc+2CSNPbin-method'></span><span id='topic++24+2CSNPbin-method'></span><span id='topic++24+3C-+2CSNPbin-method'></span><span id='topic+names+2CSNPbin-method'></span><span id='topic+ploidy+2CSNPbin-method'></span><span id='topic+ploidy+3C-+2CSNPbin-method'></span><span id='topic+coerce+2CSNPbin+2Cinteger-method'></span><span id='topic+as.integer.SNPbin'></span><span id='topic+NA.posi+2CSNPbin-method'></span><span id='topic+cbind.SNPbin'></span><span id='topic+c.SNPbin'></span><span id='topic+as+2Cinteger+2CSNPbin-method'></span><span id='topic+as+2Cnumeric+2CSNPbin-method'></span>

<h3>Description</h3>

<p>The class <code>SNPbin</code> is a formal (S4) class for storing a genotype
of binary SNPs in a compact way, using a bit-level coding scheme.
This storage is most efficient with haploid data, where the memory
taken to represent data can reduced more than 50 times. However,
<code>SNPbin</code> can be used for any level of ploidy, and still remain an
efficient storage mode.
</p>
<p>A <code>SNPbin</code> object can be constructed from
a vector of integers giving the number of the second allele for each
locus.
</p>
<p><code>SNPbin</code> stores a single genotype. To store multiple genotypes,
use the <a href="#topic+genlight-class">genlight</a> class.
</p>


<h3>Objects from the class SNPbin</h3>

<p><code>SNPbin</code> objects can be created by calls to <code>new("SNPbin",
    ...)</code>, where '...' can be the following arguments:
</p>

<dl>
<dt><code>snp</code></dt><dd><p>a vector of integers or numeric giving numbers of
copies of the second alleles for each locus. If only one unnamed
argument is provided to 'new', it is considered as this one.</p>
</dd>
<dt><code>ploidy</code></dt><dd><p>an integer indicating the ploidy of the
genotype; if not provided, will be guessed from the data (as the
maximum from the 'snp' input vector).</p>
</dd>
<dt><code>label</code></dt><dd><p>an optional character string serving as a label
for the genotype.</p>
</dd>
</dl>



<h3>Slots</h3>

<p>The following slots are the content of instances of the class
<code>SNPbin</code>; note that in most cases, it is better to retrieve
information via accessors (see below), rather than by accessing the
slots manually.
</p>

<dl>
<dt><code>snp</code>:</dt><dd><p>a list of vectors with the class <code>raw</code>.</p>
</dd>
<dt><code>n.loc</code>:</dt><dd><p>an integer indicating the number of SNPs of the
genotype.</p>
</dd>
<dt><code>NA.posi</code>:</dt><dd><p>a vector of integer giving the position of
missing data.</p>
</dd>
<dt><code>label</code>:</dt><dd><p>an optional character string serving as a label
for the genotype..</p>
</dd>
<dt><code>ploidy</code>:</dt><dd><p>an integer indicating the ploidy of the genotype.</p>
</dd>
</dl>



<h3>Methods</h3>

<p>Here is a list of methods available for <code>SNPbin</code> objects. Most of
these methods are accessors, that is, functions which are used to
retrieve the content of the object. Specific manpages can exist for
accessors with more than one argument. These are indicated by a '*'
symbol next to the method's name. This list also contains methods
for conversion from <code>SNPbin</code> to other classes.
</p>

<dl>
<dt>[</dt><dd><p><code>signature(x = "SNPbin")</code>: usual method to subset
objects in R. The argument indicates how SNPs are to be
subsetted. It can be a vector of signed integers or of logicals.</p>
</dd>
<dt>show</dt><dd><p><code>signature(x = "SNPbin")</code>: printing of the
object.</p>
</dd>
<dt>$</dt><dd><p><code>signature(x = "SNPbin")</code>: similar to the @ operator;
used to access the content of slots of the object.</p>
</dd>
<dt>$&lt;-</dt><dd><p><code>signature(x = "SNPbin")</code>: similar to the @ operator;
used to replace the content of slots of the object.</p>
</dd>
<dt>nLoc</dt><dd><p><code>signature(x = "SNPbin")</code>: returns the number of
SNPs in the object.</p>
</dd>
<dt>names</dt><dd><p><code>signature(x = "SNPbin")</code>: returns the names of
the slots of the object.</p>
</dd>
<dt>ploidy</dt><dd><p><code>signature(x = "SNPbin")</code>: returns the ploidy of
the genotype.</p>
</dd>
<dt>as.integer</dt><dd><p><code>signature(x = "SNPbin")</code>: converts a
<code>SNPbin</code> object to a vector of integers. The S4 method 'as' can
be used as well (e.g. as(x, &quot;integer&quot;)).</p>
</dd>
<dt>cbind</dt><dd><p><code>signature(x = "SNPbin")</code>: merges genotyping of
the same individual at different SNPs (all stored as
<a href="#topic+SNPbin-class">SNPbin</a> objects) into a single <a href="#topic+SNPbin-class">SNPbin</a>.</p>
</dd>
<dt>c</dt><dd><p><code>signature(x = "SNPbin")</code>: same as cbind.SNPbin.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thibaut Jombart (<a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>)</p>


<h3>See Also</h3>

<p>Related class:<br />
-  <code><a href="#topic+genlight-class">genlight</a></code>, for storing multiple binary SNP
genotypes. <br />
-  <code><a href="#topic+genind-class">genind</a></code>, for storing other types of genetic markers. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#### HAPLOID EXAMPLE ####
## create a genotype of 100,000 SNPs
dat &lt;- sample(c(0,1,NA), 1e5, prob=c(.495, .495, .01), replace=TRUE)
dat[1:10]
x &lt;- new("SNPbin", dat)
x
x[1:10] # subsetting
as.integer(x[1:10])

## try a few accessors
ploidy(x)
nLoc(x)
head(x$snp[[1]]) # internal bit-level coding

## check that conversion is OK
identical(as(x, "integer"),as.integer(dat)) # SHOULD BE TRUE

## compare the size of the objects
print(object.size(dat), unit="auto")
print(object.size(x), unit="auto")
object.size(dat)/object.size(x) # EFFICIENCY OF CONVERSION


#### TETRAPLOID EXAMPLE ####
## create a genotype of 100,000 SNPs
dat &lt;- sample(c(0:4,NA), 1e5, prob=c(rep(.995/5,5), 0.005), replace=TRUE)
x &lt;- new("SNPbin", dat)
identical(as(x, "integer"),as.integer(dat)) # MUST BE TRUE

## compare the size of the objects
print(object.size(dat), unit="auto")
print(object.size(x), unit="auto")
object.size(dat)/object.size(x) # EFFICIENCY OF CONVERSION


#### c, cbind ####
a &lt;- new("SNPbin", c(1,1,1,1,1))
b &lt;- new("SNPbin", c(0,0,0,0,0))
a
b
ab &lt;- c(a,b)
ab
identical(c(a,b),cbind(a,b))
as.integer(ab)

## End(Not run)
</code></pre>

<hr>
<h2 id='snpposi'>Analyse the position of polymorphic sites</h2><span id='topic+snpposi.plot'></span><span id='topic+snpposi.plot.integer'></span><span id='topic+snpposi.plot.numeric'></span><span id='topic+snpposi.plot.DNAbin'></span><span id='topic+snpposi.test'></span><span id='topic+snpposi.test.integer'></span><span id='topic+snpposi.test.numeric'></span><span id='topic+snpposi.test.DNAbin'></span>

<h3>Description</h3>

<p>These functions are used to describe the distribution of polymorphic
sites (SNPs) in an alignment.
</p>
<p>The function <code>snpposi.plot</code> plots the positions and density of
SNPs in the alignment.
</p>
<p>The function <code>snpposi.test</code> tests whether SNPs are randomly
distributed in the genome, the alternative hypothesis being that they
are clustered. This test is based on the distances of each SNP to the
closest SNP. This provides one measure of clustering for each SNP.
Different statistics can be used to summarise these values (argument
<code>stat</code>), but by default the statistics used is the median.
</p>
<p><code>snpposi.plot</code> and <code>snpposi.test</code> are generic functions with
methods for vectors of integers or numeric (indicating SNP position),
and for <code><a href="ape.html#topic+DNAbin">DNAbin</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snpposi.plot(...)

## S3 method for class 'integer'
snpposi.plot(x, genome.size, smooth=0.1,
              col="royalblue", alpha=.2, codon=TRUE, start.at=1, ...)

## S3 method for class 'numeric'
snpposi.plot(x, ...)

## S3 method for class 'DNAbin'
snpposi.plot(x, ...)


snpposi.test(...)

## S3 method for class 'integer'
snpposi.test(x, genome.size, n.sim=999, stat=median, ...)

## S3 method for class 'numeric'
snpposi.test(x, ...)

## S3 method for class 'DNAbin'
snpposi.test(x, ...)



</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snpposi_+3A_x">x</code></td>
<td>
<p>a vector of integers or numerics containing SNP positions, or
a set of aligned sequences in a <code>DNAbin</code> object.</p>
</td></tr>
<tr><td><code id="snpposi_+3A_genome.size">genome.size</code></td>
<td>
<p>an integer indicating the length of genomes.</p>
</td></tr>
<tr><td><code id="snpposi_+3A_smooth">smooth</code></td>
<td>
<p>a smoothing parameter for the density estimation;
smaller values will give more local peaks; values have to be
positive but can be less than 1.</p>
</td></tr>
<tr><td><code id="snpposi_+3A_col">col</code></td>
<td>
<p>the color to be used for the plot; ignored if codon
positions are represented.</p>
</td></tr>
<tr><td><code id="snpposi_+3A_alpha">alpha</code></td>
<td>
<p>the alpha level to be used for transparency (density curve).</p>
</td></tr>
<tr><td><code id="snpposi_+3A_codon">codon</code></td>
<td>
<p>a logical indicating if codon position should be
indicated (TRUE, default) or not.</p>
</td></tr>
<tr><td><code id="snpposi_+3A_start.at">start.at</code></td>
<td>
<p>an integer indicating at which base of a codon the
alignment starts (defaults to 1); values other than 1, 2 and 3 will
be ignored.</p>
</td></tr>
<tr><td><code id="snpposi_+3A_n.sim">n.sim</code></td>
<td>
<p>an integer indicating the number of randomizations to be
used in the Monte Carlo test.</p>
</td></tr>
<tr><td><code id="snpposi_+3A_stat">stat</code></td>
<td>
<p>a function used to summarize the measure of physical
proximity between SNPs; by default, the median is used.</p>
</td></tr>
<tr><td><code id="snpposi_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the <code>integer</code>
method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Monte Carlo test of the class <code>randtest</code>.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+fasta2DNAbin">fasta2DNAbin</a></code> to read fasta alignments with minimum
RAM use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(ape)){
data(woodmouse)
snpposi.plot(woodmouse, codon=FALSE)
snpposi.plot(woodmouse)

## Not run: 
snpposi.test(c(1,3,4,5), 100)
snpposi.test(woodmouse)

## End(Not run)
}
</code></pre>

<hr>
<h2 id='snpzip'>Identification of structural SNPs</h2><span id='topic+snpzip'></span>

<h3>Description</h3>

<p>The function <code>snpzip</code> identifies the set of alleles which contribute most
significantly to phenotypic structure.
</p>
<p>This procedure uses Discriminant Analysis of Principal Components (DAPC)
to quantify the contribution of individual alleles to between-population
structure. Then, defining contribution to DAPC as the measure of distance
between alleles, hierarchical clustering is used to identify two groups
of alleles: structural SNPs and non-structural SNPs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  snpzip(snps, y, plot = TRUE, xval.plot = FALSE, loading.plot = FALSE,
         method = c("complete", "single", "average", "centroid", 
                    "mcquitty", "median", "ward"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snpzip_+3A_snps">snps</code></td>
<td>
<p>a snps <code>matrix</code> used as input of DAPC.</p>
</td></tr>
<tr><td><code id="snpzip_+3A_y">y</code></td>
<td>
<p>either a <code>factor</code> indicating the group membership of individuals, 
or a dapc object.</p>
</td></tr>
<tr><td><code id="snpzip_+3A_plot">plot</code></td>
<td>
<p>a <code>logical</code> indicating whether a graphical representation of the 
DAPC results should be displayed.</p>
</td></tr>
<tr><td><code id="snpzip_+3A_xval.plot">xval.plot</code></td>
<td>
<p>a <code>logical</code> indicating whether the results of the 
cross-validation step should be displayed (iff <code>y</code> is a factor).</p>
</td></tr>
<tr><td><code id="snpzip_+3A_loading.plot">loading.plot</code></td>
<td>
<p>a <code>logical</code> indicating whether a loading.plot displaying 
the SNP selection threshold should be displayed.</p>
</td></tr>
<tr><td><code id="snpzip_+3A_method">method</code></td>
<td>
<p>the clustering method to be used. This should be 
(an unambiguous abbreviation of) one of <code>"complete", "single", "average", 
                                                              "centroid", "mcquitty", "median",</code> or <code>"ward"</code>.</p>
</td></tr> 
<tr><td><code id="snpzip_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>snpzip</code> provides an objective procedure to delineate between structural 
and non-structural SNPs identified by Discriminant Analysis of Principal Components 
(DAPC, Jombart et al. 2010). 
<code>snpzip</code> precedes the multivariate analysis with a cross-validation step 
to ensure that the subsequent DAPC is performed optimally.
The contributions of alleles to the DAPC are then submitted to <code>hclust</code>, 
where they define a distance matrix upon which hierarchical clustering is carried out.
To complete the procedure, <code>snpzip</code> uses <code>cutree</code> to automatically 
subdivide the set of SNPs fed into the analysis into two groups: 
those which contribute significantly to the phenotypic structure of interest, 
and those which do not.   
</p>


<h3>Value</h3>

<p>A <code>list</code> with four items if <code>y</code> is a factor, or two items if
<code>y</code> is a dapc object: 
The first cites the number of principal components (PCs) of PCA retained in the DAPC. 
</p>
<p>The second item is an embedded list which
first indicates the number of structural and non-structural SNPs identified by 
<code>snpzip</code>, second provides a list of the structuring alleles, third
gives the names of the selected alleles, and fourth details the 
contributions of these structuring alleles to the DAPC.
</p>
<p>The optional third item provides measures of discrimination success both overall 
and by group.
</p>
<p>The optional fourth item contains the dapc object generated if <code>y</code> was a factor.
</p>
<p>If <code>plot=TRUE</code>, a scatter plot will provide a visualization of the DAPC results.
</p>
<p>If <code>xval.plot=TRUE</code>, the results of the cross-validation step will be displayed 
as an <code>array</code> of the format generated by xvalDapc, and a scatter plot of 
the results of cross-validation will be provided.   
</p>
<p>If <code>loading.plot=TRUE</code>, a loading plot will be generated to show the 
contributions of alleles to the DAPC, and the SNP selection threshold will be indicated.
If the number of Discriminant Axes (<code>n.da</code>) in the DAPC is greater than 1, 
<code>loading.plot=TRUE</code> will generate one loading plot for each discriminant axis.
</p>


<h3>Author(s)</h3>

<p> Caitlin Collins <a href="mailto:caitlin.collins12@imperial.ac.uk">caitlin.collins12@imperial.ac.uk</a> </p>


<h3>References</h3>

<p>Jombart T, Devillard S and Balloux F (2010) Discriminant analysis of principal 
components: a new method for the analysis of genetically structured populations. 
BMC Genetics11:94. doi:10.1186/1471-2156-11-94
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    simpop &lt;- glSim(100, 10000, n.snp.struc = 10, grp.size = c(0.3,0.7), 
                    LD = FALSE, alpha = 0.4, k = 4)
    snps &lt;- as.matrix(simpop)
    phen &lt;- simpop@pop
    
    outcome &lt;- snpzip(snps, phen, method = "centroid")
    outcome
  
## End(Not run)
  ## Not run: 
    simpop &lt;- glSim(100, 10000, n.snp.struc = 10, grp.size = c(0.3,0.7), 
                    LD = FALSE, alpha = 0.4, k = 4)
    snps &lt;- as.matrix(simpop)
    phen &lt;- simpop@pop
    
    dapc1 &lt;- dapc(snps, phen, n.da = 1, n.pca = 30)
    
    features &lt;- snpzip(dapc1, loading.plot = TRUE, method = "average")
    features
  
## End(Not run)
</code></pre>

<hr>
<h2 id='spca'>Spatial principal component analysis</h2><span id='topic+spca'></span><span id='topic+spca.default'></span><span id='topic+spca.matrix'></span><span id='topic+spca.data.frame'></span><span id='topic+spca.genind'></span><span id='topic+spca.genpop'></span><span id='topic+print.spca'></span><span id='topic+summary.spca'></span><span id='topic+plot.spca'></span><span id='topic+screeplot.spca'></span><span id='topic+colorplot.spca'></span>

<h3>Description</h3>

<p>These functions implement the spatial principal component analysis
(sPCA). The function <code>spca</code> is a generic with methods for:
</p>

<ul>
<li> <p><code>matrix</code>: only numeric values are accepted
</p>
</li>
<li> <p><code>data.frame</code>: same as for matrices
</p>
</li>
<li> <p><code>genind</code>: any <a href="#topic+genind-class">genind</a> object is accepted
</p>
</li>
<li> <p><code>genpop</code>: any <a href="#topic+genpop-class">genpop</a> object is accepted
</p>
</li></ul>

<p>The core computation use <code>multispati</code> from the <code>ade4</code> package.<br />
</p>
<p>Besides the set of <code>spca</code> functions, other functions include:
</p>

<ul>
<li> <p><code>print.spca</code>: prints the spca content
</p>
</li>
<li> <p><code>summary.spca</code>: gives variance and autocorrelation
statistics
</p>
</li>
<li> <p><code>plot.spca</code>: usefull graphics (connection network, 3 different
representations of map of scores, eigenvalues barplot and
decomposition)
</p>
</li>
<li> <p><code>screeplot.spca</code>: decomposes spca eigenvalues into variance and
autocorrelation
</p>
</li>
<li> <p><code>colorplot.spca</code>: represents principal components of sPCA in
space using the RGB system.
</p>
</li></ul>

<p>A tutorial on sPCA can be opened using:<br />
<code>adegenetTutorial(which="spca")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spca(...)

## Default S3 method:
spca(x, ...)

## S3 method for class 'matrix'
spca(x, xy = NULL, cn = NULL, matWeight = NULL,
            center = TRUE, scale = FALSE, scannf = TRUE,
            nfposi = 1, nfnega = 1,
            type = NULL, ask = TRUE,
            plot.nb = TRUE, edit.nb = FALSE,
            truenames = TRUE,
            d1 = NULL, d2 = NULL, k = NULL,
            a = NULL, dmin = NULL, ...)

## S3 method for class 'data.frame'
spca(x, xy = NULL, cn = NULL, matWeight = NULL,
            center = TRUE, scale = FALSE, scannf = TRUE,
            nfposi = 1, nfnega = 1,
            type = NULL, ask = TRUE,
            plot.nb = TRUE, edit.nb = FALSE,
            truenames = TRUE,
            d1 = NULL, d2 = NULL, k = NULL,
            a = NULL, dmin = NULL, ...)

## S3 method for class 'genind'
spca(obj, xy = NULL, cn = NULL, matWeight = NULL,
            scale = FALSE, scannf = TRUE,
            nfposi = 1, nfnega = 1,
            type = NULL, ask = TRUE,
            plot.nb = TRUE, edit.nb = FALSE,
            truenames = TRUE,
            d1 = NULL, d2 = NULL, k = NULL,
            a = NULL, dmin = NULL, ...)

## S3 method for class 'genpop'
spca(obj, xy = NULL, cn = NULL, matWeight = NULL,
            scale = FALSE, scannf = TRUE,
            nfposi = 1, nfnega = 1,
            type = NULL, ask = TRUE,
            plot.nb = TRUE, edit.nb = FALSE,
            truenames = TRUE,
            d1 = NULL, d2 = NULL, k = NULL,
            a = NULL, dmin = NULL, ...)


## S3 method for class 'spca'
print(x, ...)

## S3 method for class 'spca'
summary(object, ..., printres=TRUE)

## S3 method for class 'spca'
plot(x, axis = 1, useLag=FALSE, ...)

## S3 method for class 'spca'
screeplot(x, ..., main=NULL)

## S3 method for class 'spca'
colorplot(x, axes=1:ncol(x$li), useLag=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spca_+3A_x">x</code></td>
<td>
<p>a <code>matrix</code> or a <code>data.frame</code> of numeric values,
with individuals in rows and variables in columns; categorical
variables with a binary coding are acceptable too; for <code>print</code>
and plotting functions, a spca object.</p>
</td></tr>
<tr><td><code id="spca_+3A_obj">obj</code></td>
<td>
<p>a <code>genind</code> or <code>genpop</code> object.</p>
</td></tr>
<tr><td><code id="spca_+3A_xy">xy</code></td>
<td>
<p>a matrix or data.frame with two columns for x and y
coordinates. Seeked from obj$other$xy if it exists when xy is not
provided. Can be NULL if a <code>nb</code> object is provided in
<code>cn</code>.<br /> Longitude/latitude coordinates should be converted
first by a given projection (see 'See Also' section).</p>
</td></tr>
<tr><td><code id="spca_+3A_cn">cn</code></td>
<td>
<p>a connection network of the class 'nb' (package spdep). Can
be NULL if xy is provided. Can be easily obtained using the function
chooseCN (see details).</p>
</td></tr>
<tr><td><code id="spca_+3A_matweight">matWeight</code></td>
<td>
<p>a square matrix of spatial weights, indicating the
spatial proximities between entities. If provided, this argument
prevails over <code>cn</code> (see details).</p>
</td></tr>
<tr><td><code id="spca_+3A_center">center</code></td>
<td>
<p>a logical indicating whether data should be centred to
a mean of zero; used implicitely for <a href="#topic+genind-class">genind</a> or
<a href="#topic+genpop-class">genpop</a> objects.</p>
</td></tr>
<tr><td><code id="spca_+3A_scale">scale</code></td>
<td>
<p>a logical indicating whether data should be scaled to
unit variance (TRUE) or not (FALSE, default).</p>
</td></tr>
<tr><td><code id="spca_+3A_scannf">scannf</code></td>
<td>
<p>a logical stating whether eigenvalues should be chosen
interactively (TRUE, default) or not (FALSE).</p>
</td></tr>
<tr><td><code id="spca_+3A_nfposi">nfposi</code></td>
<td>
<p>an integer giving the number of positive eigenvalues
retained ('global structures').</p>
</td></tr>
<tr><td><code id="spca_+3A_nfnega">nfnega</code></td>
<td>
<p>an integer giving the number of negative eigenvalues
retained ('local structures').</p>
</td></tr>
<tr><td><code id="spca_+3A_type">type</code></td>
<td>
<p>an integer giving the type of graph (see details in
<code>chooseCN</code> help page). If provided, <code>ask</code> is set to
FALSE.</p>
</td></tr>
<tr><td><code id="spca_+3A_ask">ask</code></td>
<td>
<p>a logical stating whether graph should be chosen
interactively (TRUE,default) or not (FALSE).</p>
</td></tr>
<tr><td><code id="spca_+3A_plot.nb">plot.nb</code></td>
<td>
<p>a logical stating whether the resulting graph should be
plotted (TRUE, default) or not (FALSE).</p>
</td></tr>
<tr><td><code id="spca_+3A_edit.nb">edit.nb</code></td>
<td>
<p>a logical stating whether the resulting graph should be
edited manually for corrections (TRUE) or not (FALSE, default).</p>
</td></tr>
<tr><td><code id="spca_+3A_truenames">truenames</code></td>
<td>
<p>a logical stating whether true names should be used
for 'obj' (TRUE, default) instead of generic labels (FALSE)</p>
</td></tr>
<tr><td><code id="spca_+3A_d1">d1</code></td>
<td>
<p>the minimum distance between any two neighbours. Used if
<code>type=5.</code></p>
</td></tr>
<tr><td><code id="spca_+3A_d2">d2</code></td>
<td>
<p>the maximum distance between any two neighbours. Used if
<code>type=5</code>.</p>
</td></tr>
<tr><td><code id="spca_+3A_k">k</code></td>
<td>
<p>the number of neighbours per point. Used if <code>type=6</code>.</p>
</td></tr>
<tr><td><code id="spca_+3A_a">a</code></td>
<td>
<p>the exponent of the inverse distance matrix. Used if
<code>type=7</code>.</p>
</td></tr>
<tr><td><code id="spca_+3A_dmin">dmin</code></td>
<td>
<p>the minimum distance between any two distinct points. Used
to avoid infinite spatial proximities (defined as the inversed
spatial distances). Used if <code>type=7</code>.</p>
</td></tr>
<tr><td><code id="spca_+3A_object">object</code></td>
<td>
<p>a <code>spca</code> object.</p>
</td></tr>
<tr><td><code id="spca_+3A_printres">printres</code></td>
<td>
<p>a logical stating whether results should be printed on
the screen (TRUE, default) or not (FALSE).</p>
</td></tr>
<tr><td><code id="spca_+3A_axis">axis</code></td>
<td>
<p>an integer between 1 and (nfposi+nfnega) indicating which
axis should be plotted.</p>
</td></tr>
<tr><td><code id="spca_+3A_main">main</code></td>
<td>
<p>a title for the screeplot; if NULL, a default one is
used.</p>
</td></tr>
<tr><td><code id="spca_+3A_...">...</code></td>
<td>
<p>further arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="spca_+3A_axes">axes</code></td>
<td>
<p>the index of the columns of X to be represented. Up to
three axes can be chosen.</p>
</td></tr>
<tr><td><code id="spca_+3A_uselag">useLag</code></td>
<td>
<p>a logical stating whether the lagged components
(<code>x$ls</code>) should be used instead of the components
(<code>x$li</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spatial principal component analysis (sPCA) is designed to
investigate spatial patterns in the genetic variability. Given
multilocus genotypes (individual level) or allelic frequency
(population level) and spatial coordinates, it finds individuals (or
population) scores maximizing the product of variance and spatial
autocorrelation (Moran's I). Large positive and negative eigenvalues
correspond to global and local structures.<br />
</p>
<p>Spatial weights can be obtained in several ways, depending how the
arguments <code>xy</code>, <code>cn</code>, and <code>matWeight</code> are set.<br />
When several acceptable ways are used at the same time, priority is as
follows:<br />
<code>matWeight</code> &gt;  <code>cn</code> &gt; <code>xy</code> <br />
</p>


<h3>Value</h3>

<p>The class <code>spca</code> are given to lists with the following
components:<br />
</p>
<table>
<tr><td><code>eig</code></td>
<td>
<p>a numeric vector of eigenvalues.</p>
</td></tr>
<tr><td><code>nfposi</code></td>
<td>
<p>an integer giving the number of global structures
retained.</p>
</td></tr>
<tr><td><code>nfnega</code></td>
<td>
<p>an integer giving the number of local structures retained.</p>
</td></tr>
<tr><td><code>c1</code></td>
<td>
<p>a data.frame of alleles loadings for each axis.</p>
</td></tr>
<tr><td><code>li</code></td>
<td>
<p>a data.frame of row (individuals or populations) coordinates
onto the sPCA axes.</p>
</td></tr>
<tr><td><code>ls</code></td>
<td>
<p>a data.frame of lag vectors of the row coordinates; useful
to clarify maps of global scores .</p>
</td></tr>
<tr><td><code>as</code></td>
<td>
<p>a data.frame giving the coordinates of the PCA axes onto the
sPCA axes.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>xy</code></td>
<td>
<p>a matrix of spatial coordinates.</p>
</td></tr>
<tr><td><code>lw</code></td>
<td>
<p>a list of spatial weights of class <code>listw</code>.</p>
</td></tr>
</table>
<p>Other functions have different outputs:<br />
- <code>summary.spca</code> returns a list with 3 components: <code>Istat</code>
giving the null, minimum and maximum Moran's I values; <code>pca</code>
gives variance and I statistics for the principal component analysis;
<code>spca</code> gives variance and I statistics for the sPCA.<br />
</p>
<p>- <code>plot.spca</code> returns the matched call.<br />
</p>
<p>- <code>screeplot.spca</code> returns the matched call.  
</p>


<h3>Author(s)</h3>

<p> Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a> </p>


<h3>References</h3>

<p>Jombart, T., Devillard, S., Dufour, A.-B. and Pontier, D.
Revealing cryptic spatial patterns in genetic variability by a new
multivariate method. <em>Heredity</em>, <b>101</b>, 92&ndash;103.
</p>
<p>Wartenberg, D. E. (1985) Multivariate spatial correlation: a method for
exploratory geographical analysis. <em>Geographical Analysis</em>,
<b>17</b>, 263&ndash;283.
</p>
<p>Moran, P.A.P. (1948) The interpretation of statistical
maps. <em>Journal of the Royal Statistical Society, B</em>
<b>10</b>, 243&ndash;251.
</p>
<p>Moran, P.A.P. (1950) Notes on continuous stochastic
phenomena. <em>Biometrika</em>, <b>37</b>, 17&ndash;23.
</p>
<p>de Jong, P. and Sprenger, C. and van Veen, F. (1984) On extreme values
of Moran's I and Geary's c. <em>Geographical Analysis</em>, <b>16</b>, 17&ndash;24.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spcaIllus">spcaIllus</a></code> and <code><a href="#topic+rupica">rupica</a></code> for datasets illustrating the sPCA <br />
<code><a href="#topic+global.rtest">global.rtest</a></code> and <code><a href="#topic+local.rtest">local.rtest</a></code> <br />
<code><a href="#topic+chooseCN">chooseCN</a></code>, <code><a href="ade4.html#topic+multispati">multispati</a></code>,
<code><a href="ade4.html#topic+multispati.randtest">multispati.randtest</a></code><br />
<code>convUL</code>, from the package 'PBSmapping' to convert longitude/latitude to
UTM coordinates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data(spcaIllus) illustrates the sPCA
## see ?spcaIllus
##
## Not run: 
example(spcaIllus)
example(rupica)

## End(Not run)
</code></pre>

<hr>
<h2 id='spca_randtest'>Monte Carlo test for sPCA</h2><span id='topic+spca_randtest'></span>

<h3>Description</h3>

<p>The function <code>spca_randtest</code> implements Monte-Carlo tests for the
presence of significant spatial structures in a sPCA object. Two tests are
run, for global (positive autocorrelation) and local (negative
autocorrelation) structures, respectively. The test statistics used are the
sum of the absolute values of the corresponding eigenvalues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spca_randtest(x, nperm = 499)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spca_randtest_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+spca">spca</a></code> object.</p>
</td></tr>
<tr><td><code id="spca_randtest_+3A_nperm">nperm</code></td>
<td>
<p>The number of permutations to be used for the test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two objects of the class 'randtest' (see
<code><a href="ade4.html#topic+as.randtest">as.randtest</a></code>), the first one for 'global' structures
(positivie autocorrelation) and the second for 'local' structures (negative
autocorrelation).
</p>


<h3>Author(s)</h3>

<p>Original code by Valeria Montano adapted by Thibaut Jombart.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## Load data
data(sim2pop)

## Make spca
spca1 &lt;- spca(sim2pop, type = 1, scannf = FALSE, plot.nb = FALSE)

spca1
plot(spca1)

## run tests (use more permutations in practice, e.g. 999)
tests &lt;- spca_randtest(spca1, nperm = 49)

## check results
tests
plot(tests[[1]]) # global structures


## End(Not run)

</code></pre>

<hr>
<h2 id='spcaIllus'>Simulated data illustrating the sPCA</h2><span id='topic+spcaIllus'></span>

<h3>Description</h3>

<p>Datasets illustrating the spatial Principal Component Analysis (Jombart et
al. 2009).  These data were simulated using various models using Easypop
(2.0.1).  Spatial coordinates were defined so that different spatial
patterns existed in the data. The <code>spca-illus</code> is a list containing the
following <a href="#topic+genind-class">genind</a> or <a href="#topic+genpop-class">genpop</a> objects:<br /> - dat2A:
2 patches <br /> - dat2B: cline between two pop <br /> - dat2C: repulsion among
individuals from the same gene pool <br /> - dat3: cline and repulsion <br /> -
dat4: patches and local alternance <br />
</p>


<h3>Format</h3>

<p><code>spcaIllus</code> is list of 5 components being either genind or
genpop objects.
</p>


<h3>Details</h3>

<p>See &quot;source&quot; for a reference providing simulation details.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>
</p>


<h3>Source</h3>

<p>Jombart, T., Devillard, S., Dufour, A.-B. and Pontier, D. Revealing
cryptic spatial patterns in genetic variability by a new multivariate
method. <em>Heredity</em>, <b>101</b>, 92&ndash;103.
</p>


<h3>References</h3>

<p>Jombart, T., Devillard, S., Dufour, A.-B. and Pontier, D.
Revealing cryptic spatial patterns in genetic variability by a new
multivariate method. <em>Heredity</em>, <b>101</b>, 92&ndash;103.
</p>
<p>Balloux F (2001) Easypop (version 1.7): a computer program for oppulation
genetics simulations <em>Journal of Heredity</em>, <b>92</b>: 301-302
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spca">spca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
required_packages &lt;- require(adespatial) &amp;&amp; require(spdep)
if (required_packages) {
data(spcaIllus)
attach(spcaIllus)
opar &lt;- par(no.readonly=TRUE)
## comparison PCA vs sPCA

# PCA
pca2A &lt;- dudi.pca(dat2A$tab,center=TRUE,scale=FALSE,scannf=FALSE)
pca2B &lt;- dudi.pca(dat2B$tab,center=TRUE,scale=FALSE,scannf=FALSE)
pca2C &lt;- dudi.pca(dat2C$tab,center=TRUE,scale=FALSE,scannf=FALSE)
pca3 &lt;- dudi.pca(dat3$tab,center=TRUE,scale=FALSE,scannf=FALSE,nf=2)
pca4 &lt;- dudi.pca(dat4$tab,center=TRUE,scale=FALSE,scannf=FALSE,nf=2)

# sPCA
spca2A &lt;-spca(dat2A,xy=dat2A$other$xy,ask=FALSE,type=1,
plot=FALSE,scannf=FALSE,nfposi=1,nfnega=0)

spca2B &lt;- spca(dat2B,xy=dat2B$other$xy,ask=FALSE,type=1,
plot=FALSE,scannf=FALSE,nfposi=1,nfnega=0)

spca2C &lt;- spca(dat2C,xy=dat2C$other$xy,ask=FALSE,
type=1,plot=FALSE,scannf=FALSE,nfposi=0,nfnega=1)

spca3 &lt;- spca(dat3,xy=dat3$other$xy,ask=FALSE,
type=1,plot=FALSE,scannf=FALSE,nfposi=1,nfnega=1)

spca4 &lt;- spca(dat4,xy=dat4$other$xy,ask=FALSE,
type=1,plot=FALSE,scannf=FALSE,nfposi=1,nfnega=1)

# an auxiliary function for graphics
plotaux &lt;- function(x,analysis,axis=1,lab=NULL,...){
neig &lt;- NULL
if(inherits(analysis,"spca")) neig &lt;- nb2neig(analysis$lw$neighbours)
xrange &lt;- range(x$other$xy[,1])
xlim &lt;- xrange + c(-diff(xrange)*.1 , diff(xrange)*.45)
yrange &lt;- range(x$other$xy[,2])
ylim &lt;- yrange + c(-diff(yrange)*.45 , diff(yrange)*.1)

s.value(x$other$xy,analysis$li[,axis],include.ori=FALSE,addaxes=FALSE,
cgrid=0,grid=FALSE,neig=neig,cleg=0,xlim=xlim,ylim=ylim,...)

par(mar=rep(.1,4))
if(is.null(lab)) lab = gsub("[P]","",x$pop)
text(x$other$xy, lab=lab, col="blue", cex=1.2, font=2)
add.scatter({barplot(analysis$eig,col="grey");box();
title("Eigenvalues",line=-1)},posi="bottomright",ratio=.3)
}

# plots
plotaux(dat2A,pca2A,sub="dat2A - PCA",pos="bottomleft",csub=2)
plotaux(dat2A,spca2A,sub="dat2A - sPCA glob1",pos="bottomleft",csub=2)

plotaux(dat2B,pca2B,sub="dat2B - PCA",pos="bottomleft",csub=2)
plotaux(dat2B,spca2B,sub="dat2B - sPCA glob1",pos="bottomleft",csub=2)

plotaux(dat2C,pca2C,sub="dat2C - PCA",pos="bottomleft",csub=2)
plotaux(dat2C,spca2C,sub="dat2C - sPCA loc1",pos="bottomleft",csub=2,axis=2)

par(mfrow=c(2,2))
plotaux(dat3,pca3,sub="dat3 - PCA axis1",pos="bottomleft",csub=2)
plotaux(dat3,spca3,sub="dat3 - sPCA glob1",pos="bottomleft",csub=2)
plotaux(dat3,pca3,sub="dat3 - PCA axis2",pos="bottomleft",csub=2,axis=2)
plotaux(dat3,spca3,sub="dat3 - sPCA loc1",pos="bottomleft",csub=2,axis=2)

plotaux(dat4,pca4,lab=dat4$other$sup.pop,sub="dat4 - PCA axis1",
pos="bottomleft",csub=2)
plotaux(dat4,spca4,lab=dat4$other$sup.pop,sub="dat4 - sPCA glob1",
pos="bottomleft",csub=2)
plotaux(dat4,pca4,lab=dat4$other$sup.pop,sub="dat4 - PCA axis2",
pos="bottomleft",csub=2,axis=2)
plotaux(dat4,spca4,lab=dat4$other$sup.pop,sub="dat4 - sPCA loc1",
pos="bottomleft",csub=2,axis=2)

# color plot
par(opar)
colorplot(spca3, cex=4, main="colorplot sPCA dat3")
text(spca3$xy[,1], spca3$xy[,2], dat3$pop)

colorplot(spca4, cex=4, main="colorplot sPCA dat4")
text(spca4$xy[,1], spca4$xy[,2], dat4$other$sup.pop)

# detach data
detach(spcaIllus)
}

</code></pre>

<hr>
<h2 id='strata'>Access and manipulate the population strata for genind or genlight objects.</h2><span id='topic+strata'></span><span id='topic+strata+2Cgenind-method'></span><span id='topic+strata+2Cgenlight-method'></span><span id='topic+strata+3C-'></span><span id='topic+strata+3C-+2Cgenind-method'></span><span id='topic+strata+3C-+2Cgenlight-method'></span><span id='topic+nameStrata'></span><span id='topic+nameStrata+2Cgenind-method'></span><span id='topic+nameStrata+2Cgenlight-method'></span><span id='topic+nameStrata+3C-'></span><span id='topic+nameStrata+3C-+2Cgenind-method'></span><span id='topic+nameStrata+3C-+2Cgenlight-method'></span><span id='topic+splitStrata'></span><span id='topic+splitStrata+2Cgenind-method'></span><span id='topic+splitStrata+2Cgenlight-method'></span><span id='topic+splitStrata+3C-'></span><span id='topic+splitStrata+3C-+2Cgenind-method'></span><span id='topic+splitStrata+3C-+2Cgenlight-method'></span><span id='topic+addStrata'></span><span id='topic+addStrata+2Cgenind-method'></span><span id='topic+addStrata+2Cgenlight-method'></span><span id='topic+addStrata+3C-'></span><span id='topic+addStrata+3C-+2Cgenind-method'></span><span id='topic+addStrata+3C-+2Cgenlight-method'></span>

<h3>Description</h3>

<p>The following methods allow the user to quickly change the strata of a genind
or genlight object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strata(x, formula = NULL, combine = TRUE, value)

strata(x) &lt;- value

nameStrata(x, value)

nameStrata(x) &lt;- value

splitStrata(x, value, sep = "_")

splitStrata(x, sep = "_") &lt;- value

addStrata(x, value, name = "NEW")

addStrata(x, name = "NEW") &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strata_+3A_x">x</code></td>
<td>
<p>a genind or genlight object</p>
</td></tr>
<tr><td><code id="strata_+3A_formula">formula</code></td>
<td>
<p>a nested formula indicating the order of the population
strata.</p>
</td></tr>
<tr><td><code id="strata_+3A_combine">combine</code></td>
<td>
<p>if <code>TRUE</code> (default), the levels will be combined according to the
formula argument. If it is <code>FALSE</code>, the levels will not be combined.</p>
</td></tr>
<tr><td><code id="strata_+3A_value">value</code></td>
<td>
<p>a data frame OR vector OR formula (see details).</p>
</td></tr>
<tr><td><code id="strata_+3A_sep">sep</code></td>
<td>
<p>a <code>character</code> indicating the character used to separate
hierarchical levels. This defaults to &quot;_&quot;.</p>
</td></tr>
<tr><td><code id="strata_+3A_name">name</code></td>
<td>
<p>an optional name argument for use with addStrata if supplying
a vector. Defaults to &quot;NEW&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Function Specifics</h4>

  <ul>
<li> <p><strong>strata()</strong> -
Use this function to view or define population stratification of a 
<a href="#topic+genind-class">genind</a> or <a href="#topic+genlight-class">genlight</a> object. </p>
</li>
<li> 
<p><strong>nameStrata()</strong> - View or rename the different levels of strata. 
</p>
</li>
<li> <p><strong>splitStrata()</strong> - Split strata that are combined with a common
separator. This function should only be used once during a workflow. 
</p>
 <ul>
<li> <p><em>Rationale:</em> It is often difficult to import files 
with several levels of strata as most data formats do not allow unlimited 
population levels. This is circumvented by collapsing all population strata
into a single population factor with a common separator for each 
observation. </p>
</li></ul>
 </li>
<li> <p><strong>addStrata()</strong> - Add levels to your population 
strata. This is ideal for adding groups defined by 
<code><a href="#topic+find.clusters">find.clusters</a></code>. You can input a data frame or a vector, but if
you put in a vector, you have the option to name it. </p>
</li></ul>



<h4>Argument Specifics</h4>

<p>These functions allow the user to seamlessly carry all possible population 
stratification with their <a href="#topic+genind-class">genind</a> or <a href="#topic+genlight-class">genlight</a> 
object. Note that there are two ways of performing all methods: </p>
 
<ul>
<li><p> modifying: <code>strata(myData) &lt;- myStrata</code> </p>
</li>
<li><p> preserving: 
<code>myNewData &lt;- strata(myData, value = myStrata)</code> </p>
</li></ul>
<p> They essentially do 
the same thing except that the modifying assignment method (the one with 
the &quot;<code>&lt;-</code>&quot;) will modify the object in place whereas the non-assignment
method will preserve the original object (unless you overwrite it). Due to 
convention, everything right of the assignment is termed <code>value</code>. To 
avoid confusion, here is a guide to the argument <strong><code>value</code></strong> for 
each function: </p>
 <ul>
<li> <p><strong>strata()</strong> <code>value = </code>a 
<code><a href="base.html#topic+data.frame">data.frame</a></code> that defines the strata for each individual in the
rows. </p>
</li>
<li> <p><strong>nameStrata()</strong> <code>value = </code>a <code><a href="base.html#topic+vector">vector</a></code> or 
a <code><a href="stats.html#topic+formula">formula</a></code> that will define the names. </p>
</li>
<li> 
<p><strong>splitStrata()</strong> <code>value = </code>a <code><a href="stats.html#topic+formula">formula</a></code> argument with
the same number of levels as the strata you wish to split. </p>
</li>
<li> 
<p><strong>addStrata()</strong> <code>value = </code>a <code><a href="base.html#topic+vector">vector</a></code> or 
<code><a href="base.html#topic+data.frame">data.frame</a></code> with the same length as the number of individuals 
in your data. </p>
</li></ul>



<h4>Details on Formulas</h4>

<p>The preferred use of these functions is with a <code><a href="stats.html#topic+formula">formula</a></code> 
object. Specifically, a hierarchical formula argument is used to assign the
levels of the strata. An example of a hierarchical formula would
be:</p>

<table>
<tr>
 <td style="text-align: right;"> <code>~Country/City/Neighborhood</code></td>
</tr>

</table>
<p> This convention was
chosen as it becomes easier to type and makes intuitive sense when defining
a <code><a href="igraph.html#topic+hierarchy">hierarchy</a></code>. Note: it is important to use hiearchical
formulas when specifying hierarchies as other types of formulas (eg. 
<code>~Country*City*Neighborhood</code>) will give incorrect results.</p>



<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setPop">setPop</a></code> <code><a href="#topic+genind">genind</a></code>
<code><a href="#topic+as.genind">as.genind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># let's look at the microbov data set:
data(microbov)
microbov

# We see that we have three vectors of different names in the 'other' slot. 
# ?microbov
# These are Country, Breed, and Species
names(other(microbov))

# Let's set the strata
strata(microbov) &lt;- data.frame(other(microbov))
microbov

# And change the names so we know what they are
nameStrata(microbov) &lt;- ~Country/Breed/Species

## Not run: 
# let's see what the strata looks like by Species and Breed:
head(strata(microbov, ~Breed/Species))

# If we didn't want the last column combined with the first, we can set
# combine = FALSE
head(strata(microbov, ~Breed/Species, combine = FALSE))

#### USING splitStrata ####

# For the sake of example, we'll imagine that we have imported our data set
# with all of the stratifications combined. 
setPop(microbov) &lt;- ~Country/Breed/Species
strata(microbov) &lt;- NULL

# This is what our data would look like after import.
microbov

# To set our strata here, we need to use the functions strata and splitStrata
strata(microbov) &lt;- data.frame(x = pop(microbov))
microbov # shows us that we have "one" level of stratification
head(strata(microbov)) # all strata are separated by "_"

splitStrata(microbov) &lt;- ~Country/Breed/Species
microbov # Now we have all of our strata named and split
head(strata(microbov)) # all strata are appropriately named and split.

## End(Not run)
</code></pre>

<hr>
<h2 id='swallowtails'>Microsatellites genotypes of 781 swallowtail butterflies from 40 populations in
Alberta and British Columbia, Canada</h2><span id='topic+swallowtails'></span>

<h3>Description</h3>

<p>This data set gives the genotypes of 781 swallowtail butterflies 
(<em>Papilio machaon</em> species group) for 10 microsatellites markers.
The individuals are divided into 40 populations.
</p>


<h3>Format</h3>

<p><code>swallowtails</code> is a genind object containing 781 individuals, 
10 microsatellite markers, and 40 populations.
</p>


<h3>Source</h3>

<p>Julian Dupuis (University of Hawaii, USA)
</p>


<h3>References</h3>

<p>Dupuis, J.R. &amp; Sperling, F.A.H. Hybrid dynamics in a species
group of swallowtail butterflies. <em>Journal of Evolutionary Biology</em>, 
<b>10</b>, 1932&ndash;1951.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(swallowtails)
swallowtails

# conducting a DAPC (n.pca determined using xvalDapc, see ??xvalDapc)

dapc1 &lt;- dapc(swallowtails, n.pca=40, n.da=200)

# read in swallowtails_loc.csv, which contains "key", "lat", and "lon"
# columns with column headers (this example contains additional columns
# containing species identifications, locality descriptions, and COI
# haplotype clades)

input_locs &lt;- system.file("files/swallowtails_loc.csv", package = "adegenet")
loc &lt;- read.csv(input_locs, header = TRUE)

# generate mvmapper input file, automatically write the output to a csv, and
# name the output csv "mvMapper_Data.csv"

out &lt;- export_to_mvmapper(dapc1, loc, write_file = TRUE, out_file = "mvMapper_Data.csv")

## End(Not run)
</code></pre>

<hr>
<h2 id='tab'>Access allele counts or frequencies</h2><span id='topic+tab'></span><span id='topic+tab+2Cgenind-method'></span><span id='topic+tab+2Cgenind-methods'></span><span id='topic+tab.genind'></span><span id='topic+tab+2Cgenpop-method'></span><span id='topic+tab+2Cgenpop-methods'></span><span id='topic+tab.genpop'></span>

<h3>Description</h3>

<p>This accessor is used to retrieve a matrix of allele data.
By default, a matrix of integers representing allele counts is returned.
If <code>freq</code> is TRUE, then data are standardised as frequencies, so that for any individual and any locus the data sum to 1.
The argument <code>NA.method</code> allows to replace missing data (NAs).
This accessor replaces the previous function <code>truenames</code> as well as the function <code>makefreq</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tab(x, ...)

## S4 method for signature 'genind'
tab(x, freq = FALSE, NA.method = c("asis", "mean", "zero"), ...)

## S4 method for signature 'genpop'
tab(x, freq = FALSE, NA.method = c("asis", "mean", "zero"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tab_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+genind-class">genind</a> or <a href="#topic+genpop-class">genpop</a> object.</p>
</td></tr>
<tr><td><code id="tab_+3A_...">...</code></td>
<td>
<p>further arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="tab_+3A_freq">freq</code></td>
<td>
<p>a logical indicating if data should be transformed into relative frequencies (TRUE); defaults to FALSE.</p>
</td></tr>
<tr><td><code id="tab_+3A_na.method">NA.method</code></td>
<td>
<p>a method to replace NA; asis: leave NAs as is; mean: replace by the mean allele frequencies; zero: replace by zero</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of integers or numeric
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(microbov)
head(tab(microbov))
head(tab(microbov,freq=TRUE))


</code></pre>

<hr>
<h2 id='truenames'> Restore true labels of an object</h2><span id='topic+truenames'></span><span id='topic+truenames-methods'></span><span id='topic+truenames+2CANY-method'></span><span id='topic+truenames+2Cgenind-method'></span><span id='topic+truenames+2Cgenpop-method'></span>

<h3>Description</h3>

<p>The function <code>truenames</code> returns some elements of an object
(<a href="#topic+genind-class">genind</a> or <a href="#topic+genpop-class">genpop</a>) using true names
(as opposed to generic labels) for individuals, markers, alleles, and
population.<br />
</p>
<p>Important: as of adegenet_2.0-0, these functions are deprecated as
true labels are used whenever possible. Please use the function
<code><a href="#topic+tab">tab</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'genind'
truenames(x)
## S4 method for signature 'genpop'
truenames(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="truenames_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+genind-class">genind</a> or a <a href="#topic+genpop-class">genpop</a> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If x$pop is empty (NULL), a matrix similar to the x$tab slot but
with true labels.
</p>
<p>If x$pop exists, a list with this matrix ($tab) and a population
vector with true names ($pop).<br />
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+tab">tab</a></code></p>

<hr>
<h2 id='virtualClasses'>Virtual classes for adegenet</h2><span id='topic+indInfo-class'></span><span id='topic+popInfo-class'></span><span id='topic+gen-class'></span><span id='topic+callOrNULL-class'></span><span id='topic+charOrNULL-class'></span><span id='topic+factorOrNULL-class'></span><span id='topic+intOrNum-class'></span><span id='topic+listOrNULL-class'></span><span id='topic+intOrNULL-class'></span><span id='topic+dfOrNULL-class'></span><span id='topic+formOrNULL-class'></span>

<h3>Description</h3>

<p>These virtual classes are only for internal use in adegenet</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a> </p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
