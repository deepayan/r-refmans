<!DOCTYPE html><html><head><title>Help for package nabor</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nabor}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#kcpoints'><p>List of 3 matrices containing 3D points from Drosophila neurons</p></a></li>
<li><a href='#knn'><p>Find K nearest neighbours for multiple query points</p></a></li>
<li><a href='#nabor-package'><p>Wrapper for libnabo K Nearest Neighbours C++ library</p></a></li>
<li><a href='#WKNNF-class'><p>Wrapper classes for k-NN searches enabling repeated queries of the same tree</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Wraps 'libnabo', a Fast K Nearest Neighbour Library for Low
Dimensions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Stephane Mangenat (for 'libnabo'), Gregory Jefferis</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gregory Jefferis &lt;jefferis@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An R wrapper for 'libnabo', an exact or approximate k nearest
    neighbour library which is optimised for low dimensional spaces (e.g. 3D).
    'libnabo' has speed and space advantages over the 'ANN' library wrapped by
    package 'RANN'. 'nabor' includes a knn function that is designed as a 
    drop-in replacement for 'RANN' function nn2. In addition, objects which 
    include the k-d tree search structure can be returned to speed up repeated 
    queries of the same set of target points.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Copyright:</td>
<td>libnabo is copyright 2010--2011, Stephane Magnenat, ASL,
ETHZ, Switzerland &lt;stephane at magnenat dot net&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jefferis/nabor">https://github.com/jefferis/nabor</a>
<a href="https://github.com/ethz-asl/libnabo">https://github.com/ethz-asl/libnabo</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jefferis/nabor/issues">https://github.com/jefferis/nabor/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.2), methods</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen (&ge; 0.3.2.2.0), BH (&ge; 1.54.0-4)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, RANN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-07-11 15:23:05 UTC; jefferis</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-07-11 16:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='kcpoints'>List of 3 matrices containing 3D points from Drosophila neurons</h2><span id='topic+kcpoints'></span>

<h3>Description</h3>

<p>This R list contains 3 skeletonized <em>Drosophila</em> Kenyon cells as
<code>dotprops</code> objects. Original data is due to Chiang et al. 2011, who have
generously shared their raw data at <a href="http://flycircuit.tw">http://flycircuit.tw</a>. Image
registration and further processing was carried out by Greg Jefferis.
</p>


<h3>References</h3>

<p>[1] Chiang A.S., Lin C.Y., Chuang C.C., Chang H.M., Hsieh C.H.,
Yeh C.W., Shih C.T., Wu J.J., Wang G.T., Chen Y.C., Wu C.C., Chen G.Y.,
Ching Y.T., Lee P.C., Lin C.Y., Lin H.H., Wu C.C., Hsu H.W., Huang Y.A.,
Chen J.Y., et al. (2011). Three-dimensional reconstruction of brain-wide
wiring networks in Drosophila at single-cell resolution. Curr Biol 21 (1),
1&ndash;11.
</p>

<hr>
<h2 id='knn'>Find K nearest neighbours for multiple query points</h2><span id='topic+knn'></span>

<h3>Description</h3>

<p>Find K nearest neighbours for multiple query points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knn(data, query = data, k, eps = 0, searchtype = 1L, radius = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knn_+3A_data">data</code></td>
<td>
<p>Mxd matrix of M target points with dimension d</p>
</td></tr>
<tr><td><code id="knn_+3A_query">query</code></td>
<td>
<p>Nxd matrix of N query points with dimension d (nb <code>data</code> 
and <code>query</code> must have same dimension). If missing defaults to 
<code>data</code> i.e. a self-query.</p>
</td></tr>
<tr><td><code id="knn_+3A_k">k</code></td>
<td>
<p>an integer number of nearest neighbours to find</p>
</td></tr>
<tr><td><code id="knn_+3A_eps">eps</code></td>
<td>
<p>An approximate error bound. The default of 0 implies exact 
matching.</p>
</td></tr>
<tr><td><code id="knn_+3A_searchtype">searchtype</code></td>
<td>
<p>A character vector or integer indicating the search type. 
The default value of <code>1L</code> is equivalent to &quot;auto&quot;. See details.</p>
</td></tr>
<tr><td><code id="knn_+3A_radius">radius</code></td>
<td>
<p>Maximum radius search bound. The default of 0 implies no radius
bound.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>searchtype="auto"</code>, the default, knn uses a k-d tree with a
linear heap when <code>k &lt; 30</code> nearest neighbours are requested (equivalent
to <code>searchtype="kd_linear_heap"</code>), a k-d tree with a tree heap 
otherwise (equivalent to <code>searchtype="kd_tree_heap"</code>). 
<code>searchtype="brute"</code> checks all point combinations and is intended for
validation only.
</p>
<p>Integer values of searchtype should be the 1-indexed position in the vector
<code>c("auto", "brute", "kd_linear_heap", "kd_tree_heap")</code>, i.e. a value 
between 1L and 4L.
</p>
<p>The underlying <a href="https://github.com/ethz-asl/libnabo">libnabo</a> does not
have a signalling value to identify indices for invalid query points (e.g. 
those containing an <code>NA</code>). In this situation, the index returned by 
libnabo will be 0 and <code>knn</code> will therefore return an index of 1. 
However the distance will be <code>Inf</code> signalling a failure to find a 
nearest neighbour.
</p>
<p>When radius&gt;0.0 and no point is found within the search bound, the index 
returned will be 0 but the reported distance will be Inf (in contrast 
RANN::nn2 returns 1.340781e+154).
</p>


<h3>Value</h3>

<p>A list with elements <code>nn.idx</code> (1-indexed indices) and 
<code>nn.dists</code> (distances), both of which are N x k matrices. See details
for the results obtained with1 invalid inputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Basic usage
# load sample data consisting of list of 3 separate 3d pointets
data(kcpoints)

# Nearest neighbour in first pointset of all points in second pointset 
nn1 &lt;- knn(data=kcpoints[[1]], query=kcpoints[[2]], k=1)
str(nn1)

# 5 nearest neighbours
nn5 &lt;-knn(data=kcpoints[[1]], query=kcpoints[[2]], k=5)
str(nn5)

# Self match within first pointset, all distances will be 0
nnself1 &lt;- knn(data=kcpoints[[1]], k=1)
str(nnself1)

# neighbour 2 will be the nearest point 
nnself2 &lt;- knn(data=kcpoints[[1]], k=2)

## Advanced usage
# nearest neighbour with radius bound
nn1.rad &lt;- knn(data=kcpoints[[1]], query=kcpoints[[2]], k=1, radius=5)
str(nn1.rad)

# approximate nearest neighbour with 10% error bound
nn1.approx &lt;- knn(data=kcpoints[[1]], query=kcpoints[[2]], k=1, eps=0.1)
str(nn1.approx)

# 5 nearest neighbours, brute force search
nn5.b &lt;-knn(data=kcpoints[[1]], query=kcpoints[[2]], k=5, searchtype='brute')
stopifnot(all.equal(nn5.b, nn5))

# 5 nearest neighbours, brute force search (specified by int)
nn5.b2 &lt;-knn(data=kcpoints[[1]], query=kcpoints[[2]], k=5, searchtype=2L)
stopifnot(all.equal(nn5.b2, nn5.b))
</code></pre>

<hr>
<h2 id='nabor-package'>Wrapper for libnabo K Nearest Neighbours C++ library</h2><span id='topic+nabor-package'></span><span id='topic+nabor'></span>

<h3>Description</h3>

<p>R package <b>nabor</b> wraps the 
<a href="https://github.com/ethz-asl/libnabo">libnabo</a> library, a fast K Nearest
Neighbour library for low-dimensional spaces written in templated C++. The 
package provides both a standalone function (see <code><a href="#topic+knn">knn</a></code> for basic 
queries along an option to produce an object containing the k-d tree search
(see <code><a href="#topic+WKNN">WKNN</a></code>) structure when making multiple queries against the
same target points.
</p>


<h3>Details</h3>

<p>libnabo uses the same approach as the ANN library (wrapped in R package 
<code>RANN</code>) but is generally faster and with a smaller memory footprint. 
Furthermore since it is templated on the underlying scalar type for 
coordinates (among other things), we have provided both float and double 
coordinate implementations of the classes wrapping the search tree 
structures. See the github repository and Elsenberg et al paper below for 
details.
</p>


<h3>References</h3>

<p>Elseberg J, Magnenat S, Siegwart R and Nuechter A (2012). 
&quot;Comparison of nearest-neighbor-search strategies and implementations for 
efficient shape registration.&quot; _Journal of Software Engineering for 
Robotics (JOSER)_, *3*(1), pp. 2-12. ISSN 2035-3928.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+knn">knn</a></code>, <code><a href="#topic+WKNN">WKNN</a></code>
</p>

<hr>
<h2 id='WKNNF-class'>Wrapper classes for k-NN searches enabling repeated queries of the same tree</h2><span id='topic+WKNNF-class'></span><span id='topic+WKNNF'></span><span id='topic+WKNN'></span><span id='topic+WKNND-class'></span><span id='topic+WKNND'></span>

<h3>Description</h3>

<p><code>WKNNF</code> and <code>WKNND</code> are reference classes that wrap 
C++ classes of the same name that include a space-efficient k-d tree along 
with the target data points. They have <code>query</code> methods with exactly 
the same interface as the <code>knn</code> function. One important point compared
with <code>knn</code> - they must be intialised with floating point data and you 
are responsible for this - see <code><a href="base.html#topic+storage.mode">storage.mode</a></code>) and the example 
below.
</p>


<h3>Details</h3>

<p><code>WKNNF</code> expects and returns matrices in R's standard (double, 8
bytes) data type but uses floats internally. <code>WKNND</code> uses doubles 
throughout. When retaining large numbers of points, the <code>WKNNF</code> 
objects will have a small memory saving, especially if tree building is 
delayed.
</p>
<p>The constructor for WKNN objects includes a logical flag indicating whether
to build the tree immediately (default: <code>TRUE</code>) or (when <code>FALSE</code>)
to delay building the tree until a query is made (this happens 
automatically when required).
</p>


<h3>Performance</h3>

<p>The use of <code>WKNN</code> objects will incur a performance
penalty for single queries of trees with &lt; ~1000 data points. This is 
because of the overhead associated with the R wrapper class. It therefore 
makes sense to use <code>knn</code> in these circumstances.
</p>
<p>If you wish to make repeated queries of the same target data, then using 
<code>WKNN</code> objects can give significant advantages. If you are going to 
make repeated queries with the same set of query points (presumably against
different target data), you can obtain benefits in some cases by converting
the query points into WKNNF objects without building the trees.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+knn">knn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Basic usage
# load sample data consisting of list of 3 separate 3d pointets
data(kcpoints)
# build a tree and query it with two different sets of points
w1 &lt;- WKNNF(kcpoints[[1]])
w1q2 &lt;- w1$query(kcpoints[[2]], k=5, eps=0, radius=0)
str(w1q2)
w1q3 &lt;- w1$query(kcpoints[[3]], k=5, eps=0, radius=0)
# note that there will be small difference between WKNNF and knn due to loss 
# of precision in the double to float conversion when a WKNNF tree is 
# built and queried.
stopifnot(all.equal(
 knn(data=kcpoints[[1]], query=kcpoints[[2]], k=5, eps=0, radius=0),
 w1q2, tolerance=1e-6))
 
## storage mode: must be double
m=matrix(1:24, ncol=3)
storage.mode(m)
# this will generate an error unless we change to a double
w=tools::assertCondition(WKNND(m), "error")
storage.mode(m)="double"
w=WKNND(matrix(m, ncol=3))

## construct wrapper objects but delay tree construction
w1 &lt;- WKNNF(kcpoints[[1]], FALSE)
# query triggers tree construction
w1q2 &lt;- w1$query(kcpoints[[2]], k=5, eps=0, radius=0)
str(w1q2)

## queries using wrapper objects
wkcpoints &lt;-lapply(kcpoints, WKNNF, FALSE)
# query all 3 point sets against first
# this will trigger tree construction only for pointset 1
qall &lt;- lapply(wkcpoints, 
  function(x) wkcpoints[[1]]$queryWKNN(x$.CppObject, k=5, eps=0, radius=0))
str(qall)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
