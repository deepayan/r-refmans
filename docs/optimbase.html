<!DOCTYPE html><html><head><title>Help for package optimbase</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {optimbase}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#optimbase-package'>
<p>R port of the Scilab optimbase module</p></a></li>
<li><a href='#asserts'>
<p>Check of Variable Class</p></a></li>
<li><a href='#Bound+20and+20constraint+20checks'>
<p>Point Estimate Comparison with Bounds and Constraints</p></a></li>
<li><a href='#Bounds+20+26amp+3B+20constraints'>
<p>Query for Bounds and Constraints</p></a></li>
<li><a href='#Log+20functions'>
<p>Optimbase Log functions</p></a></li>
<li><a href='#optimbase'>
<p>S3 optimbase classes</p></a></li>
<li><a href='#optimbase.checkbounds'>
<p>Check bounds.</p></a></li>
<li><a href='#optimbase.checkcostfun'>
<p>Check Cost Function</p></a></li>
<li><a href='#optimbase.checkshape'>
<p>Check the Dimensions of the Cost Function Output</p></a></li>
<li><a href='#optimbase.checkx0'>
<p>Check Consistency of Initial Guesses</p></a></li>
<li><a href='#optimbase.destroy'>
<p>Erase an optimization history.</p></a></li>
<li><a href='#optimbase.function'>
<p>Call Cost Function</p></a></li>
<li><a href='#optimbase.get'>
<p>Get the value for the given element</p></a></li>
<li><a href='#optimbase.gridsearch'>
<p>Grid evaluation of a constrained or unconstrained cost function</p></a></li>
<li><a href='#optimbase.incriter'>
<p>Iteration Log Incrementation</p></a></li>
<li><a href='#optimbase.isfeasible'>
<p>Check Point Estimate</p></a></li>
<li><a href='#optimbase.outputcmd'>
<p>Call user-defined output function</p></a></li>
<li><a href='#optimbase.outstruct'>
<p>Create Basic Optimization Data Object</p></a></li>
<li><a href='#optimbase.proj2bnds'>
<p>Projection of Point Estimate to Bounds</p></a></li>
<li><a href='#optimbase.set'>
<p>Optimization Object Configuration</p></a></li>
<li><a href='#optimbase.terminate'>
<p>Evaluation of Termation Status</p></a></li>
<li><a href='#size'>
<p>Vector, Matrix or Data.Frame Size</p></a></li>
<li><a href='#strvec'>
<p>Auto-collapse of Vectors</p></a></li>
<li><a href='#transpose'>
<p>Vector and Matrix Transpose</p></a></li>
<li><a href='#vec2matrix'>
<p>Vector to Matrix Conversion</p></a></li>
<li><a href='#zeros+20+26amp+3B+20ones'>
<p>Matrix of zeros or ones.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>R Port of the 'Scilab' Optimbase Module</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-10</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-01-24</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a set of commands to manage an abstract
        optimization method. The goal is to provide a building block
        for a large class of specialized optimization methods. This
        package manages: the number of variables, the minimum and
        maximum bounds, the number of non linear inequality
        constraints, the cost function, the logging system, various
        termination criteria, etc...</td>
</tr>
<tr>
<td>Depends:</td>
<td>Matrix, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr (&ge; 1.28), rmarkdown (&ge; 2.2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.cecill.info/licences/Licence_CeCILL_V2-en.txt">CeCILL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-24 22:03:46 UTC; sebastien</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastien Bihorel [aut, cre],
  Michael Baudin [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sebastien Bihorel &lt;sb.pmlab@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-26 19:22:48 UTC</td>
</tr>
</table>
<hr>
<h2 id='optimbase-package'>
R port of the Scilab optimbase module
</h2><span id='topic+optimbase-package'></span>

<h3>Description</h3>

<p>The goal of this package is to provide a building block for a large class of
specialized optimization methods. This packages manages: </p>

<ul>
<li><p> the number of variables,
</p>
</li>
<li><p> the minimum and maximum bounds,
</p>
</li>
<li><p> the number of non linear inequality constraints,
</p>
</li>
<li><p> the cost function,
</p>
</li>
<li><p> the logging system,
</p>
</li>
<li><p> various termination criteria,
</p>
</li>
<li><p> etc...
</p>
</li></ul>

<p><strong>Features</strong>
The following is a list of features the optimbase toolbox currently provided:
</p>

<ul>
<li><p> Manage cost function </p>

<ul>
<li><p> optionnal additionnal argument
</p>
</li>
<li><p> direct communication of the task to perform: cost function or
inequality  constraints
</p>
</li></ul>

</li>
<li><p> Manage various termination criteria, including: </p>

<ul>
<li><p> maximum number of iterations,
</p>
</li>
<li><p> tolerance on function value (relative or absolute),
</p>
</li>
<li><p> tolerance on the vector of estimated parameter <code>x</code> (relative or
absolute),
</p>
</li>
<li><p> maximum number of evaluations of the cost function,
</p>
</li></ul>

</li>
<li><p> Manage the history of the convergence, including: </p>

<ul>
<li><p> history of function values,
</p>
</li>
<li><p> history of optimum point.
</p>
</li></ul>

</li>
<li><p> Provide query features for </p>

<ul>
<li><p> the status of the optimization process,
</p>
</li>
<li><p> the number of iterations,
</p>
</li>
<li><p> the number of function evaluations,
</p>
</li>
<li><p> function value at initial point,
</p>
</li>
<li><p> function value at optimal point,
</p>
</li>
<li><p> the optimum parameters,
</p>
</li>
<li><p> etc...
</p>
</li></ul>

</li></ul>



<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
  Package: </td><td style="text-align: left;"> optimbase</td>
</tr>
<tr>
 <td style="text-align: left;">
  Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
  Version: </td><td style="text-align: left;"> 1.0-10</td>
</tr>
<tr>
 <td style="text-align: left;">
  Date: </td><td style="text-align: left;"> 2022-01-24</td>
</tr>
<tr>
 <td style="text-align: left;">
  License: </td><td style="text-align: left;"> CeCILL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
  LazyLoad: </td><td style="text-align: left;"> yes
  </td>
</tr>

</table>

<p>See <code>vignette('optimbase',package='optimbase')</code> for more information.
</p>


<h3>Author(s)</h3>

<p>Author of Scilab optimbase module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>

<hr>
<h2 id='asserts'>
Check of Variable Class
</h2><span id='topic+assert.classboolean'></span><span id='topic+assert.classfunction'></span><span id='topic+assert.classreal'></span><span id='topic+assert.classinteger'></span><span id='topic+assert.classstring'></span><span id='topic+unknownValueForOption'></span>

<h3>Description</h3>

<p>Utility functions in <span class="pkg">optimbase</span> meant to check variable class. Stop the
algorithm if the variable is not of the expected class.</p>

<dl>
<dt><code>assert.classboolean</code></dt><dd><p>for logical variables</p>
</dd>
<dt><code>assert.classfunction</code></dt><dd><p>for functions</p>
</dd>
<dt><code>assert.classreal</code></dt><dd><p>for numeric variables</p>
</dd>
<dt><code>assert.classinteger</code></dt><dd><p>for integer variables</p>
</dd>
<dt><code>assert.classstring</code></dt><dd><p>for character variables</p>
</dd>
</dl>

<p><code>unknownValueForOption</code> stops the algorithm and returns an error
message, when some checks in <code>optimbase</code> are not successful.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  assert.classboolean(var = NULL, varname = NULL, ivar = NULL)
  assert.classfunction(var = NULL, varname = NULL, ivar = NULL)
  assert.classreal(var = NULL, varname = NULL, ivar = NULL)
  assert.classinteger(var = NULL, varname = NULL, ivar = NULL)
  assert.classstring(var = NULL, varname = NULL, ivar = NULL)
  unknownValueForOption(value = NULL, optionname = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asserts_+3A_var">var</code></td>
<td>
<p>The variable name.</p>
</td></tr>
<tr><td><code id="asserts_+3A_varname">varname</code></td>
<td>
<p>The name of a variable to which <code>var</code> should have been
assigned to.</p>
</td></tr>
<tr><td><code id="asserts_+3A_ivar">ivar</code></td>
<td>
<p>A integer, meant to provide additional info on <code>varname</code> in
the error message.</p>
</td></tr>
<tr><td><code id="asserts_+3A_value">value</code></td>
<td>
<p>A numeric or a string.</p>
</td></tr>
<tr><td><code id="asserts_+3A_optionname">optionname</code></td>
<td>
<p>The name of a variable for which <code>value</code> is unknown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return an error message through the <code>stop</code> function.
</p>


<h3>Author(s)</h3>

<p>Author of Scilab optimbase module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>

<hr>
<h2 id='Bound+20and+20constraint+20checks'>
Point Estimate Comparison with Bounds and Constraints
</h2><span id='topic+optimbase.isinbounds'></span><span id='topic+optimbase.isinnonlincons'></span>

<h3>Description</h3>

<p><code>optimbase.isinbounds</code> checks that given parameter estimates are within
the defined minimum and maximum boundaries, while
<code>optimbase.isinnonlincons</code> checks that the given point estimate satisfies
the defined nonlinear constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  optimbase.isinbounds(this = NULL, x = NULL)
  optimbase.isinnonlincons(this=NULL,x=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bound+2B20and+2B20constraint+2B20checks_+3A_this">this</code></td>
<td>
<p>An optimization object.</p>
</td></tr>
<tr><td><code id="Bound+2B20and+2B20constraint+2B20checks_+3A_x">x</code></td>
<td>
<p>A column vector of parameter estimates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Both functions return a list with the following elements: </p>

<dl>
<dt>this</dt><dd><p>The optimization object.</p>
</dd>
<dt>isfeasible</dt><dd><p>TRUE if the parameter estimates satisfy the constraints,
FALSE otherwise.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Author of Scilab optimbase module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>

<hr>
<h2 id='Bounds+20+26amp+3B+20constraints'>
Query for Bounds and Constraints
</h2><span id='topic+optimbase.hasbounds'></span><span id='topic+optimbase.hasnlcons'></span><span id='topic+optimbase.hasconstraints'></span>

<h3>Description</h3>

<p><code>optimbase.hasbounds</code> and <code>optimbase.hascons</code> query an
optimization object and determine whether bounds and nonlinear constraints
have been specified. Bounds are defined in the <code>boundsmin</code> and
<code>boundsmax</code> elements of the optimization object. The number of
nonlinear constraints is defined in the <code>nbineqconst</code> element.
</p>
<p><code>optimbase.hasconstraints</code> determine whether any bound or constraint
has been specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  optimbase.hasbounds(this = NULL)
  optimbase.hasnlcons(this = NULL)
  optimbase.hasconstraints(this = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bounds+2B20+2B26amp+2B3B+2B20constraints_+3A_this">this</code></td>
<td>
<p>An optimization object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return TRUE if bounds or constraints are found, FALSE otherwise.
</p>


<h3>Author(s)</h3>

<p>Author of Scilab optimbase module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>

<hr>
<h2 id='Log+20functions'>
Optimbase Log functions
</h2><span id='topic+optimbase.logstartup'></span><span id='topic+optimbase.log'></span><span id='topic+optimbase.stoplog'></span><span id='topic+optimbase.logshutdown'></span>

<h3>Description</h3>

<p><code>optimbase.logstartup</code> initializes logging if verbose logging is enabled
(via the <code>verbose</code> element of the optimization object). If the logging
has already been initialized, it generates an error and stops the
optimization.
</p>
<p>If verbose logging is enabled, <code>optimbase.log</code> prints the given message
in the console. If  verbose logging is disabled, it does nothing. If the
<code>logfile</code> element of the optimization object has been  set, it writes the
message into the file instead of writing to the console.
</p>
<p><code>optimbase.stoplog</code> prints the given stopping rule message if verbose
termination is enabled (via the <code>verbosetermination</code> element of the
optimization object). If verbose termination is disabled, it does nothing.
</p>
<p><code>optimbase.logshutdown</code> turns verbose logging off.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  optimbase.logstartup(this = NULL)
  optimbase.log(this = NULL, msg = NULL)
  optimbase.stoplog(this = NULL, msg = NULL)
  optimbase.logshutdown(this = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Log+2B20functions_+3A_this">this</code></td>
<td>
<p>The optimization object.</p>
</td></tr>
<tr><td><code id="Log+2B20functions_+3A_msg">msg</code></td>
<td>
<p>The message to print.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All functions return the unchanged optimization object.
</p>


<h3>Author(s)</h3>

<p>Author of Scilab optimbase module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>

<hr>
<h2 id='optimbase'>
S3 optimbase classes
</h2><span id='topic+optimbase'></span><span id='topic+optimbase.outputargs'></span><span id='topic+optimbase.functionargs'></span><span id='topic+print.optimbase'></span><span id='topic+summary.optimbase'></span><span id='topic+is.optimbase'></span><span id='topic+is.optimbase.outputargs'></span><span id='topic+is.optimbase.functionargs'></span><span id='topic+as.optimbase.outputargs'></span><span id='topic+as.optimbase.functionargs'></span>

<h3>Description</h3>

<p>These functions support the S3 class 'optimbase' and related S3 classes 
'optimbase.outputargs' and 'optimbase.functionargs'. They are intended to 
either create objects of these classes, check if an object is of these classes, 
or coerce it to one of these classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  optimbase(verbose, x0, fx0, xopt, fopt, tolfunabsolute, 
    tolfunrelative, tolfunmethod, tolxabsolute, tolxrelative, tolxmethod, 
    maxfunevals, funevals, maxiter, iterations, fun, status, historyxopt,
    historyfopt, verbosetermination, outputcommand, outputcommandarg,
    numberofvariables, storehistory, costfargument, boundsmin, boundsmax,
    nbineqconst, logfile, logfilehandle, logstartup, withderivatives)
  
  optimbase.outputargs(...)
  
  optimbase.functionargs(...)
  
  ## S3 method for class 'optimbase'
print(x,verbose=FALSE,...)
  
  ## S3 method for class 'optimbase'
is(x=NULL)
  
  ## S3 method for class 'optimbase'
summary(object,showhistory,...)
  
  ## S3 method for class 'optimbase.outputargs'
is(x=NULL)
  
  ## S3 method for class 'optimbase.outputargs'
as(x=NULL)
  
  ## S3 method for class 'optimbase.functionargs'
is(x=NULL)
  
  ## S3 method for class 'optimbase.functionargs'
as(x=NULL)
  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimbase_+3A_verbose">verbose</code></td>
<td>
<p>The verbose option, controlling the amount of messages.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_x0">x0</code></td>
<td>
<p>The initial guess.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_fx0">fx0</code></td>
<td>
<p>The value of the function for the initial guess.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_xopt">xopt</code></td>
<td>
<p>The optimum parameter.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_fopt">fopt</code></td>
<td>
<p>The optimum function value.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_tolfunabsolute">tolfunabsolute</code></td>
<td>
<p>The absolute tolerance on function value.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_tolfunrelative">tolfunrelative</code></td>
<td>
<p>The relative tolerance on function value.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_tolfunmethod">tolfunmethod</code></td>
<td>
<p>Logical flag for the tolerance on function value in
the termination criteria. This criteria is suitable for functions which
minimum is associated with a function value equal to 0.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_tolxabsolute">tolxabsolute</code></td>
<td>
<p>The absolute tolerance on x..</p>
</td></tr>
<tr><td><code id="optimbase_+3A_tolxrelative">tolxrelative</code></td>
<td>
<p>The relative tolerance on x.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_tolxmethod">tolxmethod</code></td>
<td>
<p>Possible values: FALSE, TRUE.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_maxfunevals">maxfunevals</code></td>
<td>
<p>The maximum number of function evaluations.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_funevals">funevals</code></td>
<td>
<p>The number of function evaluations.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_maxiter">maxiter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_iterations">iterations</code></td>
<td>
<p>The number of iterations.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_fun">fun</code></td>
<td>
<p>The cost function.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_status">status</code></td>
<td>
<p>The status of the optimization.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_historyxopt">historyxopt</code></td>
<td>
<p>The list to store the history for xopt. The vectors of
estimates will be stored on separated levels of the list, so the length of
<code>historyfopt</code> at the end of the optimization should be the number of
iterations.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_historyfopt">historyfopt</code></td>
<td>
<p>The vector to store the history for fopt. The values of
the cost function will be stored at each iteration in a new element, so
the length of <code>historyfopt</code> at the end of the optimization should be
the number of iterations.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_verbosetermination">verbosetermination</code></td>
<td>
<p>The verbose option for termination criteria.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_outputcommand">outputcommand</code></td>
<td>
<p>The command called back for output. This must be a 
valid R function accepting the following arguments: </p>

<dl>
<dt>state</dt><dd><p>A character string, typically indicating the status of the
algorithm.</p>
</dd>
<dt>data</dt><dd><p>A list containing at least the following elements:
</p>

<dl>
<dt>x</dt><dd><p>the current point estimate,</p>
</dd>
<dt>fval</dt><dd><p>the value of the cost function at the current point
estimate,</p>
</dd>
<dt>iteration</dt><dd><p>the current iteration index,</p>
</dd>
<dt>funccount</dt><dd><p>the number of function evaluations.</p>
</dd>
</dl>

</dd>
<dt>fmsdata</dt><dd><p>An optional object of class 'optimbase.outputargs'.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="optimbase_+3A_outputcommandarg">outputcommandarg</code></td>
<td>
<p>The outputcommand argument is initialized as an empty
object of class 'optimbase.outputargs' passed to the command defined in 
the outputcommand element of the optimbase object. This object has no 
required structure or content but is typically a list which may be used to
provide some extra information to the output command.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_numberofvariables">numberofvariables</code></td>
<td>
<p>The number of variables to optimize.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_storehistory">storehistory</code></td>
<td>
<p>The flag which enables/disables the storing of the
history.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_costfargument">costfargument</code></td>
<td>
<p>The costf argument is initialized as an empty object of 
class 'optimbase.functionargs'. This object has no required structure or
content but is typically a list which may be used to provide some 
information to the cost function'.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_boundsmin">boundsmin</code></td>
<td>
<p>Minimum bounds for the parameters.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_boundsmax">boundsmax</code></td>
<td>
<p>Maximum bounds for the parameters.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_nbineqconst">nbineqconst</code></td>
<td>
<p>The number of nonlinear inequality constraints. </p>
</td></tr>
<tr><td><code id="optimbase_+3A_logfile">logfile</code></td>
<td>
<p>The name of the log file.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_logfilehandle">logfilehandle</code></td>
<td>
<p>The handle for the log file.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_logstartup">logstartup</code></td>
<td>
<p>Set to TRUE when the logging is started up.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_withderivatives">withderivatives</code></td>
<td>
<p>Set to TRUE when the method uses derivatives.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_...">...</code></td>
<td>
<p>optional arguments to 'print' or 'plot' methods.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_x">x</code></td>
<td>
<p>An object of class 'optimbase'.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_object">object</code></td>
<td>
<p>An object of class 'optimbase'.</p>
</td></tr>
<tr><td><code id="optimbase_+3A_showhistory">showhistory</code></td>
<td>
<p>Optional logical flag, to define whether optimization 
history must be summarized or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>optimbase</code> function returns a new object of class 'optimbase', i.e. 
a list containing the following elements:</p>

<dl>
<dt>verbose</dt><dd><p>Default is FALSE.</p>
</dd>
<dt>x0</dt><dd><p>Default is NULL.</p>
</dd>
<dt>fx0</dt><dd><p>Default is NULL.</p>
</dd>
<dt>xopt</dt><dd><p>Default is 0.</p>
</dd>
<dt>fopt</dt><dd><p>Default is 0.</p>
</dd>
<dt>tolfunabsolute</dt><dd><p>Default is 0.</p>
</dd>
<dt>tolfunrelative</dt><dd><p>Default is .Machine$double.eps.</p>
</dd>
<dt>tolfunmethod</dt><dd><p>Default is FALSE.</p>
</dd>
<dt>tolxabsolute</dt><dd><p>Default is 0.</p>
</dd>
<dt>tolxrelative</dt><dd><p>Default is .Machine$double.eps.</p>
</dd>
<dt>tolxmethod</dt><dd><p>Default is TRUE.</p>
</dd>
<dt>maxfunevals</dt><dd><p>Default is 100.</p>
</dd>
<dt>funevals</dt><dd><p>Default is 0.</p>
</dd>
<dt>maxiter</dt><dd><p>Default is 100.</p>
</dd>
<dt>iterations</dt><dd><p>Default is 0.</p>
</dd>
<dt>fun</dt><dd><p>Default is &rdquo;.</p>
</dd>
<dt>status</dt><dd><p>Default is &rdquo;.</p>
</dd>
<dt>historyfopt</dt><dd><p>Default is NULL.</p>
</dd>
<dt>historyxopt</dt><dd><p>Default is NULL.</p>
</dd>
<dt>verbosetermination</dt><dd><p>Default is FALSE.</p>
</dd>
<dt>outputcommand</dt><dd><p>Default is &rdquo;.</p>
</dd>
<dt>outputcommandarg</dt><dd><p>Default is &rdquo;. If the user configures this element, 
it is expected to be an object of class 'optimbase.outputargs' or will be
coerced to an object of class 'optimbase.outputargs'.</p>
</dd>
<dt>numberofvariables</dt><dd><p>Default is 0.</p>
</dd>
<dt>storehistory</dt><dd><p>Default is FALSE.</p>
</dd>
<dt>costfargument</dt><dd><p>Default is &rdquo;. If the user configures this element, 
it is expected to be an object of class 'optimbase.functionargs' or will 
be coerced to an object of class 'optimbase.functionargs'.</p>
</dd>
<dt>boundsmin</dt><dd><p>Default is NULL.</p>
</dd>
<dt>boundsmax</dt><dd><p>Default is NULL.</p>
</dd>
<dt>nbineqconst</dt><dd><p>Default is 0.</p>
</dd>
<dt>logfile</dt><dd><p>Default is &rdquo;.</p>
</dd>
<dt>logfilehandle</dt><dd><p>Default is 0.</p>
</dd>
<dt>logstartup</dt><dd><p>Default is FALSE.</p>
</dd>
<dt>withderivatives</dt><dd><p>Default is FALSE.</p>
</dd>
</dl>

<p>The <code>print.optimbase</code> and <code>is.optimbase</code> functions are S3 method for 
objects of class 'optimbase'. The <code>showhistory</code> argument can be provided 
to the <code>print.optimbase</code> function to indicate whether or not the history 
of optimization should be printed.
</p>
<p>The <code>optimbase.outputargs</code> function returns a new object of class
'optimbase.outputargs', i.e. a list of all arguments provided by the user. The 
<code>is.optimbase.outputargs</code> functions are S3 method for objects of class 
'optimbase.outputargs'.
</p>
<p>The <code>optimbase.functionargs</code> function returns a new object of class
'optimbase.functionargs', i.e. a list of all arguments provided by the user.
The <code>is.optimbase.functionargs</code> functions are S3 method for objects of 
class 'optimbase.functionargs'.
</p>


<h3>Author(s)</h3>

<p>Author of Scilab optimbase module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>

<hr>
<h2 id='optimbase.checkbounds'>
Check bounds.
</h2><span id='topic+optimbase.checkbounds'></span>

<h3>Description</h3>

<p>This function checks if the bounds defined in the optimization object are
consistent (same number of minimal and maximal bounds as the number of
variables, minimal bounds lower than maximal bounds) and puts an error
message in the returned object if not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  optimbase.checkbounds(this = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimbase.checkbounds_+3A_this">this</code></td>
<td>
<p>An optimization object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list with the following list: </p>

<dl>
<dt>this</dt><dd><p>The optimization object.</p>
</dd>
<dt>isok</dt><dd><p>TRUE if the bounds are consistent, FALSE otherwise.</p>
</dd>
<dt>errmsg</dt><dd><p>An error message if the bounds are not consistent.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Author of Scilab optimbase module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>

<hr>
<h2 id='optimbase.checkcostfun'>
Check Cost Function
</h2><span id='topic+optimbase.checkcostfun'></span>

<h3>Description</h3>

<p>This function checks that the cost function is correctly specified in the
optimization object, including that the elements of <code>this</code> used by the
cost function are consistent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  optimbase.checkcostfun(this = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimbase.checkcostfun_+3A_this">this</code></td>
<td>
<p>An optimization object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the definition of nonlinear constraints (<code>nbineqconst</code>
element &gt; 0) and the use of derivatives (<code>withderivatives</code> element set to
TRUE), this function makes several cost function calls with different
<code>index</code> value (see <code>vignette('optimbase',package='optimbase')</code> for
more details about <code>index</code>). If  at least one call fails, the function
stops the search algorithm.
</p>
<p>Following every successful cost function call, <code>optimbase.checkcostfun</code>
calls <code>optimbase.checkshape</code> to check the dimensions of the matrix
returned by the cost function against some expectations.
</p>


<h3>Value</h3>

<p>Return the optimization object or an error message if one check is not
successful.
</p>


<h3>Author(s)</h3>

<p>Author of Scilab optimbase module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimbase.checkshape">optimbase.checkshape</a></code>
</p>

<hr>
<h2 id='optimbase.checkshape'>
Check the Dimensions of the Cost Function Output
</h2><span id='topic+optimbase.checkshape'></span>

<h3>Description</h3>

<p>This function is called by <code>optimbase.checkcostfun</code> to check whether the
dimensions of a cost function output match the expectations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  optimbase.checkshape(this = NULL, varname = NULL, data = NULL, index = NULL,
                       expectednrows = NULL, expectedncols = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimbase.checkshape_+3A_this">this</code></td>
<td>
<p>An optimization object.</p>
</td></tr>
<tr><td><code id="optimbase.checkshape_+3A_varname">varname</code></td>
<td>
<p>The name of the output being checked, either 'f', 'c', or 'g'.</p>
</td></tr>
<tr><td><code id="optimbase.checkshape_+3A_data">data</code></td>
<td>
<p>A content of the output.</p>
</td></tr>
<tr><td><code id="optimbase.checkshape_+3A_index">index</code></td>
<td>
<p>The index (see <code>vignette('optimbase',package='optimbase')</code>
for more details).</p>
</td></tr>
<tr><td><code id="optimbase.checkshape_+3A_expectednrows">expectednrows</code></td>
<td>
<p>Number of expected rows.</p>
</td></tr>
<tr><td><code id="optimbase.checkshape_+3A_expectedncols">expectedncols</code></td>
<td>
<p>Number of expected columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return the optimization object or an error message if the dimensions are
inconsistent.
</p>


<h3>Author(s)</h3>

<p>Author of Scilab optimbase module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimbase.checkcostfun">optimbase.checkcostfun</a></code>
</p>

<hr>
<h2 id='optimbase.checkx0'>
Check Consistency of Initial Guesses
</h2><span id='topic+optimbase.checkx0'></span>

<h3>Description</h3>

<p>This function checks that the initial guesses defined in the optimization
object are consistent with the defined bounds and the non linear inequality
constraints. The actual work is delegated to <code>optimbase.isfeasible</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  optimbase.checkx0(this = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimbase.checkx0_+3A_this">this</code></td>
<td>
<p>An optimization object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list with the following elements: </p>

<dl>
<dt>this</dt><dd><p>The optimization object.</p>
</dd>
<dt>isok</dt><dd><p>TRUE if the initial guesses are consistent with the settings,
FALSE otherwise.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Author of Scilab optimbase module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimbase.isfeasible">optimbase.isfeasible</a></code>
</p>

<hr>
<h2 id='optimbase.destroy'>
Erase an optimization history.
</h2><span id='topic+optimbase.destroy'></span>

<h3>Description</h3>

<p>Erase the optimization history in an optimization object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  optimbase.destroy(this = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimbase.destroy_+3A_this">this</code></td>
<td>
<p>An optimization object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function erases the content of the <code>historyfopt</code> and
<code>historyxopt</code> elements in <code>this</code> and call the 
<code>optimbase.logshutdown</code> function if the <code>logstartup</code> element in
<code>this</code> is set to TRUE.
</p>


<h3>Value</h3>

<p>Return an updated optimization object.
</p>


<h3>Author(s)</h3>

<p>Author of Scilab optimbase module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimbase.logshutdown">optimbase.logshutdown</a></code>
</p>

<hr>
<h2 id='optimbase.function'>
Call Cost Function
</h2><span id='topic+optimbase.function'></span>

<h3>Description</h3>

<p>This function calls the cost function defined in the <code>fun</code> element of
the current object and returns the required results. If an additionnal
argument for the cost function is defined in current object, it is passed to
the function as the last argument. See 
<code>vignette('optimbase',package='optimbase')</code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  optimbase.function(this = NULL, x = NULL, index = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimbase.function_+3A_this">this</code></td>
<td>
<p>An optimization object.</p>
</td></tr>
<tr><td><code id="optimbase.function_+3A_x">x</code></td>
<td>
<p>The point estimate where the cost function should be evaluated, i.e.
a column vector.</p>
</td></tr>
<tr><td><code id="optimbase.function_+3A_index">index</code></td>
<td>
<p>An integer between 1 and 6 (see
<code>vignette('omptimbase',package='optimbase')</code> for more details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list with the following elements: </p>

<dl>
<dt>this</dt><dd><p>The updated optimization object.</p>
</dd>
<dt>f</dt><dd><p>The value of the cost function.</p>
</dd>
<dt>g</dt><dd><p>The gradient of the cost function.</p>
</dd>
<dt>c</dt><dd><p>The nonlinear, positive, inequality constraints.</p>
</dd>
<dt>gc</dt><dd><p>The gradient of the nonlinear, positive, inequality constraints.</p>
</dd>
<dt>index</dt><dd><p>An integer: </p>

<ul>
<li><p> if index &gt; 0, everything went fine,
</p>
</li>
<li><p> if index == 0, interrupts the optimization,
</p>
</li>
<li><p> if index &lt; 0, one of the function could not be evaluated.</p>
</li></ul>

</dd>
</dl>



<h3>Author(s)</h3>

<p>Author of Scilab optimbase module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>

<hr>
<h2 id='optimbase.get'>
Get the value for the given element
</h2><span id='topic+optimbase.get'></span><span id='topic+optimbase.histget'></span>

<h3>Description</h3>

<p>Get the value for the given element in an optimization object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  optimbase.get(this = NULL, key = NULL)
  optimbase.histget(this = NULL, iter = NULL, key = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimbase.get_+3A_this">this</code></td>
<td>
<p>An optimization object.</p>
</td></tr>
<tr><td><code id="optimbase.get_+3A_key">key</code></td>
<td>
<p>The name of the key to quiery. The list of available keys for
query with <code>optimbase.get</code> is: 'verbose', 'x0', 'fx0', 'xopt', 'fopt',
'tolfunabsolute', 'tolfunrelative', 'tolfunmethod', 'tolxabsolute',
'tolxrelative', 'tolxmethod', 'maxfunevals', 'maxiter', 'iterations',
'function', 'status', 'historyfopt', 'historyxopt', 'verbosetermination',
'outputcommand', 'outputcommandarg', 'numberofvariables', 'storehistory',
'costfargument', 'boundsmin', 'boundsmax', 'nbineqconst', 'logfile',
'logfilehandle', 'logstartup', and'withderivatives'.
</p>
<p>The list of available keys for query with <code>optimbase.histget</code> is:
'historyxopt' and 'historyfopt'.
</p>
</td></tr>
<tr><td><code id="optimbase.get_+3A_iter">iter</code></td>
<td>
<p>The iteration at which the data is stored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While <code>optimbase.get</code> extracts the entire content of the object element,
including <code>historyxopt</code> and <code>historyfopt</code>, <code>optimbase.histget</code>
only extracts the content of the history at the iteration <code>iter</code>.
</p>


<h3>Value</h3>

<p>Return the value of the list element <code>key</code>, or an error message if
<code>key</code> does not exist.
</p>


<h3>Author(s)</h3>

<p>Author of Scilab optimbase module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimbase">optimbase</a></code>,
<code><a href="#topic+optimbase.set">optimbase.set</a></code>
</p>

<hr>
<h2 id='optimbase.gridsearch'>
Grid evaluation of a constrained or unconstrained cost function
</h2><span id='topic+optimbase.gridsearch'></span>

<h3>Description</h3>

<p>Evaluate a constrained or unconstrained cost function on a grid of points 
around a given initial point estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  optimbase.gridsearch(fun = NULL, x0 = NULL, xmin = NULL, 
                       xmax = NULL, npts = 3, alpha = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimbase.gridsearch_+3A_fun">fun</code></td>
<td>
<p>A constrained or unconstrained cost function defined as described 
in the vignette (<code>vignette('optimbase',package='optimbase')</code>).</p>
</td></tr>
<tr><td><code id="optimbase.gridsearch_+3A_x0">x0</code></td>
<td>
<p>The initial point estimate, provided as a numeric vector.</p>
</td></tr>
<tr><td><code id="optimbase.gridsearch_+3A_xmin">xmin</code></td>
<td>
<p>Optional: a vector of lower bounds.</p>
</td></tr>
<tr><td><code id="optimbase.gridsearch_+3A_xmax">xmax</code></td>
<td>
<p>Optional: a vector of upper bounds.</p>
</td></tr>
<tr><td><code id="optimbase.gridsearch_+3A_npts">npts</code></td>
<td>
<p>A integer scalar greater than 2, indicating the number of 
evaluation points will be used on each dimension to build the search grid.</p>
</td></tr>
<tr><td><code id="optimbase.gridsearch_+3A_alpha">alpha</code></td>
<td>
<p>A vector of numbers greater than 1, which give the factor(s) used 
to calculate the evaluation range of each dimension of the search grid (see 
Details). If <code>alpha</code> length is lower than that of <code>x0</code>, elements 
of <code>alpha</code> are recycled. If its length is higher than that of 
<code>x0</code>, <code>alpha</code> is truncated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>optimbase.gridsearch</code> evaluates the cost function at each point 
of a grid of <code>npts^length(x0)</code> points. If lower (<code>xmin</code>) and upper 
(<code>xmax</code>) bounds are provided, the range of evaluation points is limited 
by those bounds and <code>alpha</code> is not used. Otherwise, the range of 
evaluation points is defined as <code>[x0/alpha,x0*alpha]</code>.
</p>
<p><code>optimbase.gridsearch</code> also determines if the cost function is
feasible at each evaluation point by calling <code>optimbase.isfeasible</code>.
</p>


<h3>Value</h3>

<p>Return a data.frame with the coordinates of the evaluation point, the value of
the cost function and its feasibility. The data.frame is ordered by 
feasibility and increasing value of the cost function.
</p>


<h3>Author(s)</h3>

<p>Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimbase.isfeasible">optimbase.isfeasible</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Problem: find x and y that maximize 3.6*x - 0.4*x^2 + 1.6*y - 0.2*y^2 and
#          satisfy the constrains:
#            2*x - y &lt;= 10
#            x &gt;= 0
#            y &gt;= 0
#

gridfun &lt;- function(x=NULL,index=NULL,fmsfundata=NULL,...){

  f &lt;- c()
  c &lt;- c()
  if (index == 2 | index == 6)
    f &lt;- -(3.6*x[1] - 0.4*x[1]*x[1] + 1.6*x[2] - 0.2*x[2]*x[2])
  if (index == 5 | index == 6)
    c &lt;- c(10 - 2*x[1] - x[2],
           x[1],
           x[2])
  varargout &lt;- list(f = f, g = c(), c = c, gc = c(), index = index)

  return(varargout)
}


x0 &lt;- c(0.35,0.3)
npts &lt;- 6
alpha &lt;- 10

res &lt;- optimbase.gridsearch(fun=gridfun,x0=x0,xmin=NULL,xmax=NULL,
                     npts=npts,alpha=alpha)

# 3.5 and 3 is the actual solution of the optimization problem
print(res)

</code></pre>

<hr>
<h2 id='optimbase.incriter'>
Iteration Log Incrementation
</h2><span id='topic+optimbase.incriter'></span>

<h3>Description</h3>

<p>This function increments the number of iterations stored in the
<code>iterations</code> element of the optimization object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  optimbase.incriter(this = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimbase.incriter_+3A_this">this</code></td>
<td>
<p>An optimization object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return the optimization object after increasing the content of the
<code>iterations</code> element by 1 unit.
</p>


<h3>Author(s)</h3>

<p>Author of Scilab optimbase module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>

<hr>
<h2 id='optimbase.isfeasible'>
Check Point Estimate
</h2><span id='topic+optimbase.isfeasible'></span>

<h3>Description</h3>

<p>This function checks that the point estimate is consistent with the bounds
and the non linear inequality constraints. It is usually called by  
<code>optimbase.checkx0</code> to check initial guesses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  optimbase.isfeasible(this = NULL, x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimbase.isfeasible_+3A_this">this</code></td>
<td>
<p>An optimization object.</p>
</td></tr>
<tr><td><code id="optimbase.isfeasible_+3A_x">x</code></td>
<td>
<p>The point estimate, i.e. a column vector of numerical values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns 1 if the given point satisfies bounds constraints and inequality
constraints.
</p>
<p>Returns 0 if the given point is not in the bounds.
</p>
<p>Returns -1 if the given point does not satisfies inequality constraints.
</p>


<h3>Value</h3>

<p>Return a list with the following elements: </p>

<dl>
<dt>this</dt><dd><p>The optimization object.</p>
</dd>
<dt>isfeasible</dt><dd><p>The feasibility flag, either -1, 0 or 1.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Author of Scilab optimbase module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimbase.checkx0">optimbase.checkx0</a></code>
</p>

<hr>
<h2 id='optimbase.outputcmd'>
Call user-defined output function
</h2><span id='topic+optimbase.outputcmd'></span>

<h3>Description</h3>

<p>Call user-defined output function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  optimbase.outputcmd(this = NULL, state = NULL, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimbase.outputcmd_+3A_this">this</code></td>
<td>
<p>An optimization object.</p>
</td></tr>
<tr><td><code id="optimbase.outputcmd_+3A_state">state</code></td>
<td>
<p>The current state of the algorithm: either 'init', 'iter', or
'done'.</p>
</td></tr>
<tr><td><code id="optimbase.outputcmd_+3A_data">data</code></td>
<td>
<p>A list containing at least the following elements:
</p>

<dl>
<dt>x</dt><dd><p>the current point estimate,</p>
</dd>
<dt>fval</dt><dd><p>the value of the cost function at the current point
estimate,</p>
</dd>
<dt>iteration</dt><dd><p>the current iteration index,</p>
</dd>
<dt>funccount</dt><dd><p>the number of function evaluations.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Details</h3>

<p>The <code>data</code> list argument may contain more levels than those presented
above. These additional levels may contain values which are specific to the
specialized algorithm, such as the simplex in a Nelder-Mead method, the
gradient of the cost function in a BFGS method, etc...
</p>


<h3>Value</h3>

<p>Do not return any data, but execute the output function defined in the
<code>outputcommand</code> element of <code>this</code>.
</p>


<h3>Author(s)</h3>

<p>Author of Scilab optimbase module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>

<hr>
<h2 id='optimbase.outstruct'>
Create Basic Optimization Data Object
</h2><span id='topic+optimbase.outstruct'></span>

<h3>Description</h3>

<p>This function creates a basic optimization data object by extracting the
content of specific fields of an optimization object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  optimbase.outstruct(this = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimbase.outstruct_+3A_this">this</code></td>
<td>
<p>An optimization object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return an object of class 'optimbase.data', i.e. a list with the following 
elements: </p>

<dl>
<dt>x</dt><dd><p>The current optimum point estimate (extracted from
<code>this$xopt</code>).</p>
</dd>
<dt>fval</dt><dd><p>The value of the cost function at the current optimum point
estimate (extracted from <code>this$fopt</code>).</p>
</dd>
<dt>iteration</dt><dd><p>The current number of iteration (extracted
from <code>this$iterations</code>).</p>
</dd>
<dt>funccount</dt><dd><p>The current number of function evaluations (extracted from
<code>this$funevals</code>).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Author of Scilab optimbase module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>

<hr>
<h2 id='optimbase.proj2bnds'>
Projection of Point Estimate to Bounds
</h2><span id='topic+optimbase.proj2bnds'></span>

<h3>Description</h3>

<p>This function determines if all elements of a point estimate are within the
defined bounds. In the case one or more parameter estimates are not, the
function projects those to their corresponding bounds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  optimbase.proj2bnds(this = NULL, x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimbase.proj2bnds_+3A_this">this</code></td>
<td>
<p>An optimization object.</p>
</td></tr>
<tr><td><code id="optimbase.proj2bnds_+3A_x">x</code></td>
<td>
<p>A point estimate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list with the following elements: </p>

<dl>
<dt>this</dt><dd><p>The optimization object.</p>
</dd>
<dt>p</dt><dd><p>A vector of updated paremeter estimes. The ith element of the
vector is: </p>

<ul>
<li> <p><code>x[i]</code> if <code>this$boundsmin[i]</code> &lt; <code>x[i]</code> &lt;
<code>this$boundsmax[i],</code>
</p>
</li>
<li> <p><code>this$boundsmin[i]</code> if x[i] &lt;= <code>this$boundsmin[i],</code>
</p>
</li>
<li> <p><code>this$boundsmax[i]</code> if <code>this$boundsmax[i]</code> &lt;= x[i].
</p>
</li></ul>

</dd>
</dl>



<h3>Author(s)</h3>

<p>Author of Scilab optimbase module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>

<hr>
<h2 id='optimbase.set'>
Optimization Object Configuration
</h2><span id='topic+optimbase.set'></span><span id='topic+optimbase.histset'></span>

<h3>Description</h3>

<p>This functions configures the current optimization object with the given
<code>value</code> for the given <code>key</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  optimbase.set(this = NULL, key = NULL, value = NULL)
  optimbase.histset(this = NULL, iter = NULL, key = NULL, value = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimbase.set_+3A_this">this</code></td>
<td>
<p>The current optimization object.</p>
</td></tr>
<tr><td><code id="optimbase.set_+3A_key">key</code></td>
<td>
<p>The key to configure. See details for the list of possible keys.</p>
</td></tr>
<tr><td><code id="optimbase.set_+3A_value">value</code></td>
<td>
<p>The value to assign to the key.</p>
</td></tr>
<tr><td><code id="optimbase.set_+3A_iter">iter</code></td>
<td>
<p>The iteration at which the data must be stored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>optimbase.set</code> set the content of the <code>key</code> element of the 
optimization object <code>this</code> to <code>value</code>.
</p>
<p>The only available keys in <code>optimbase.set</code> are the following:
</p>

<dl>
<dt>'verbose'</dt><dd><p>Set to 1 to enable verbose logging.</p>
</dd>
<dt>'x0'</dt><dd><p>The initial guesses, as a n x 1 column vector, where n is the
number of variables.</p>
</dd>
<dt>'fx0'</dt><dd><p>The value of the cost function at the initial point
estimate.</p>
</dd>
<dt>'xopt'</dt><dd><p>The optimum point estimate.</p>
</dd>
<dt>'fopt'</dt><dd><p>The value of the cost function at the optimum point 
estimate.</p>
</dd>
<dt>'tolfunabsolute'</dt><dd><p>The absolute tolerance for the function value.</p>
</dd>
<dt>'tolfunrelative'</dt><dd><p>The relative tolerance for the function value.</p>
</dd>
<dt>'tolfunmethod'</dt><dd><p>The method used for the tolerance on function value
in the termination criteria. The following values are available: TRUE,
FALSE. If this criteria is triggered, the status of the optimization is
set to 'tolf'.</p>
</dd>
<dt>'tolxabsolute'</dt><dd><p>The absolute tolerance on x.</p>
</dd>
<dt>'tolxrelative'</dt><dd><p>The relative tolerance on x.</p>
</dd>
<dt>'tolxmethod'</dt><dd><p>The method used for the tolerance on x in the
termination criteria. The following values are available: TRUE, FALSE. If
this criteria is triggered during optimization, the status of the
optimization is set to 'tolx'.</p>
</dd>
<dt>'maxfunevals'</dt><dd><p>The maximum number of function evaluations. If this
criteria is triggered during optimization, the status of the optimization
is set to 'maxfuneval' (see
<code>vignette('optimbase',package='optimbase')</code> for more details).</p>
</dd>
<dt>'funevals'</dt><dd><p>The number of function evaluations.</p>
</dd>
<dt>'maxiter'</dt><dd><p>The maximum number of iterations. If this criteria is
triggered during optimization, the status of the optimization is set to
'maxiter' (see <code>vignette('optimbase',package='optimbase')</code>
for more details).</p>
</dd>
<dt>'iterations'</dt><dd><p>The number of iterations.</p>
</dd>
<dt>'function'</dt><dd><p>The objective function, which computes the value of the
cost function and the non linear constraints, if any. See
<code>vignette('optimbase',package='optimbase')</code> for the details of
the communication between the optimization system and the cost function.</p>
</dd>
<dt>'status'</dt><dd><p>A string containing the status of the optimization.</p>
</dd>
<dt>'historyxopt'</dt><dd><p>A list, with nbiter element, containing the history
of x during the iterations. This list is available after optimization if
the history storing was enabled with the <code>storehistory</code>
element.</p>
</dd>
<dt>'historyfopt'</dt><dd><p>An vector, with nbiter values, containing the history
of the function value during the iterations. This vector is available
after optimization if the history storing was enabled with the
<code>storehistory</code> element.</p>
</dd>
<dt>'verbosetermination'</dt><dd><p>Set to 1 to enable verbose termination
logging.</p>
</dd>
<dt>'outputcommand'</dt><dd><p>A command which is called back for output. Details
of the communication between the optimization system and the output
command function are provided in      
<code>vignette('optimbase',package='optimbase')</code>.</p>
</dd>
<dt>'outputcommandarg'</dt><dd><p>An additionnal argument, passed to the output
command.</p>
</dd>
<dt>'numberofvariables'</dt><dd><p>The number of variables to optimize.</p>
</dd>
<dt>'storehistory'</dt><dd><p>Set to TRUE to enable the history storing.</p>
</dd>
<dt>'costfargument'</dt><dd><p>An additionnal argument, passed to the cost
function.</p>
</dd>
<dt>'boundsmin'</dt><dd><p>The minimum bounds for the parameters.</p>
</dd>
<dt>'boundsmax'</dt><dd><p>The maximum bounds for the parameters.</p>
</dd>
<dt>'nbineqconst'</dt><dd><p>The number of inequality constraints.</p>
</dd>
<dt>'logfile'</dt><dd><p>The name of the log file.</p>
</dd>
<dt>'logfilehandle'</dt><dd><p>Set to 1 if logging has been started</p>
</dd>
<dt>'logstartup'</dt><dd><p>Set to 1 if logging has been started</p>
</dd>
<dt>'withderivatives'</dt><dd><p>Set to TRUE if the algorithm uses derivatives.</p>
</dd>
</dl>

<p>The only available keys in <code>optimbase.histset</code> are 'historyxopt' and
'historyfopt'. Contrary to <code>optimbase.set</code>, this function only alters
the value of <code>historyxopt</code> and <code>historyfopt</code> at the specific
iteration <code>iter</code>.
</p>


<h3>Value</h3>

<p>An updated optimization object.
</p>


<h3>Author(s)</h3>

<p>Author of Scilab optimbase module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimbase">optimbase</a></code>
</p>

<hr>
<h2 id='optimbase.terminate'>
Evaluation of Termation Status
</h2><span id='topic+optimbase.terminate'></span>

<h3>Description</h3>

<p>This function determines whether the optimization must continue or terminate.
If the <code>verbosetermination</code> element of the optimization object is
enabled, messages are printed detailing the termination intermediate steps.
The <code>optimbase.terminate</code> function takes into account the number of
iterations, the number of evaluations of the cost function, the tolerance on x
and the tolerance on f. See the section &quot;Termination&quot; in
<code>vignette('optimbase',package='optimbase')</code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  optimbase.terminate(this = NULL, previousfopt = NULL, currentfopt = NULL,
                      previousxopt = NULL, currentxopt = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimbase.terminate_+3A_this">this</code></td>
<td>
<p>An optimization object.</p>
</td></tr>
<tr><td><code id="optimbase.terminate_+3A_previousfopt">previousfopt</code></td>
<td>
<p>The previous value of the objective function.</p>
</td></tr>
<tr><td><code id="optimbase.terminate_+3A_currentfopt">currentfopt</code></td>
<td>
<p>The current value of the objective function.</p>
</td></tr>
<tr><td><code id="optimbase.terminate_+3A_previousxopt">previousxopt</code></td>
<td>
<p>The previous value of the parameter estimate matrix.</p>
</td></tr>
<tr><td><code id="optimbase.terminate_+3A_currentxopt">currentxopt</code></td>
<td>
<p>The current value of the parameter estimate matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list with the following elements: </p>

<dl>
<dt>this</dt><dd><p>The updated optimization object.</p>
</dd>
<dt>terminate</dt><dd><p>TRUE if the algorithm terminates, FALSE if the algorithm
must continue.</p>
</dd>
<dt>status</dt><dd><p>The termination status could be 'maxiter', 'maxfuneval',
'tolf' or 'tolx' if <code>terminate</code> is set to TRUE, 'continue'
otherwise.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Author of Scilab optimbase module: Michael Baudin (INRIA - Digiteo)
</p>
<p>Author of R adaptation: Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>

<hr>
<h2 id='size'>
Vector, Matrix or Data.Frame Size
</h2><span id='topic+size'></span>

<h3>Description</h3>

<p><code>size</code> is a utility function which determines the dimensions of vectors
(coerced to matrices), matrices, arrays, data.frames, and list elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  size(x = NULL, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="size_+3A_x">x</code></td>
<td>
<p>A R object.</p>
</td></tr>
<tr><td><code id="size_+3A_n">n</code></td>
<td>
<p>A integer indicating the dimension of interest.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>size</code> is a wrapper function around <code>dim</code>. It returns the n^th
dimension of <code>x</code> if <code>n</code> is provided. If <code>n</code> is not provide,
all dimensions will be determined. If <code>x</code> is a list, <code>n</code> is ignored
and the dimensions of all elements of <code>x</code> are recursively determined.
</p>


<h3>Value</h3>

<p>Returns a vector or list of dimensions.
</p>


<h3>Author(s)</h3>

<p>Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+dim">dim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  a &lt;- 1
  b &lt;- letters[1:6]
  c &lt;- matrix(1:20,nrow=4,ncol=5)
  d &lt;- array(1:40, dim=c(2,5,2,2))
  e &lt;- data.frame(a,b)
  f &lt;- list(a,b,c,d,e)

  size(NULL) # 0 0
  size(NA)   # 1 1
  size(a)    # 1 1
  size(b,2)  # 6
  size(c)    # 4 5
  size(d)    # 2 5 2 2
  size(e,3)  # NA
  size(f)
</code></pre>

<hr>
<h2 id='strvec'>
Auto-collapse of Vectors
</h2><span id='topic+strvec'></span>

<h3>Description</h3>

<p><code>strvec</code> is a utility function which collapses all elements of a vector
into a character scalar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  strvec(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strvec_+3A_x">x</code></td>
<td>
<p>A string of characters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character scalar consisting of all the elements of <code>x</code> separated by a
single white space.
</p>


<h3>Author(s)</h3>

<p>Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  strvec(letters[1:10])
  strvec(1:10)
</code></pre>

<hr>
<h2 id='transpose'>
Vector and Matrix Transpose
</h2><span id='topic+transpose'></span>

<h3>Description</h3>

<p><code>transpose</code> is a wrapper function around the <code>t</code> function, which
tranposes matrices. Contrary to <code>t</code>, <code>transpose</code> processes vectors
as if they were row matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  transpose(object = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transpose_+3A_object">object</code></td>
<td>
<p>A vector or a matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a matrix which is the exact transpose of the vector or matrix <code>x</code>
</p>


<h3>Author(s)</h3>

<p>Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+t">t</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  1:6
  t(1:6)
  transpose(1:6)
  mat &lt;- matrix(1:15,nrow=5,ncol=3)
  mat
  transpose(mat)
</code></pre>

<hr>
<h2 id='vec2matrix'>
Vector to Matrix Conversion
</h2><span id='topic+vec2matrix'></span>

<h3>Description</h3>

<p>This function converts a vector into a row matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  vec2matrix(object = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec2matrix_+3A_object">object</code></td>
<td>
<p>A vector or a matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>object</code> is already a matrix, <code>object</code> is not modified. If
<code>object</code> is not a matrix or a vector, the algorithm is stopped.
</p>


<h3>Value</h3>

<p>Return a row matrix.
</p>


<h3>Author(s)</h3>

<p>Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>

<hr>
<h2 id='zeros+20+26amp+3B+20ones'>
Matrix of zeros or ones.
</h2><span id='topic+ones'></span><span id='topic+zeros'></span>

<h3>Description</h3>

<p>Creates a matrix of zeros or ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  zeros(nx = 1, ny = nx)
  ones(nx = 1, ny = nx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zeros+2B20+2B26amp+2B3B+2B20ones_+3A_nx">nx</code></td>
<td>
<p>The number of rows. Default is 1.</p>
</td></tr>
<tr><td><code id="zeros+2B20+2B26amp+2B3B+2B20ones_+3A_ny">ny</code></td>
<td>
<p>The number of columns. Default is <code>nx</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>zeros</code> and <code>ones</code> create full matrices of zeros and ones. If the
user only provides an input for <code>nx</code>, the produced matrices are nx x nx
square matrices.
</p>


<h3>Value</h3>

<p>Return of nx x ny matrix of zeros of ones.
</p>


<h3>Author(s)</h3>

<p>Sebastien Bihorel (<a href="mailto:sb.pmlab@gmail.com">sb.pmlab@gmail.com</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  zeros()
  zeros(3)
  ones(4,5)
  # Will fail
  try(ones('3','3'))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
