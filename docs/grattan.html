<!DOCTYPE html><html><head><title>Help for package grattan</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {grattan}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#grattan-package'><p>The grattan package.</p></a></li>
<li><a href='#age_grouper'><p>Age grouper</p></a></li>
<li><a href='#age_pension_age'><p>Age of eligibility for the Age Pension</p></a></li>
<li><a href='#apply_super_caps_and_div293'><p>Superannuation caps and Division 293 calculations</p></a></li>
<li><a href='#aus_pop_qtr'><p>Australia's population</p></a></li>
<li><a href='#aus_pop_qtr_age'><p>Australian estimated resident population by age and date</p></a></li>
<li><a href='#awote'><p>AWOTE</p></a></li>
<li><a href='#bto'><p>Beneficiary tax offset</p></a></li>
<li><a href='#CG_population_inflator'><p>Forecasting capital gains</p></a></li>
<li><a href='#compare_avg_tax_rates'><p>Compare average tax rates by percentile</p></a></li>
<li><a href='#cpi_inflator_general_date'><p>CPI for general dates</p></a></li>
<li><a href='#cpi_inflator_quarters'><p>CPI inflator when dates are nice</p></a></li>
<li><a href='#differentially_uprate_wage'><p>Differential uprating</p></a></li>
<li><a href='#gdp'><p>Gross Domestic Product, Australia</p></a></li>
<li><a href='#generic_inflator'><p>Generic inflator</p></a></li>
<li><a href='#gni'><p>Gross National Income, Australia</p></a></li>
<li><a href='#income_tax'><p>Income tax payable</p></a></li>
<li><a href='#inflator'><p>Inflate using a general index</p></a></li>
<li><a href='#install_taxstats'><p>Install 'taxstats' files</p></a></li>
<li><a href='#inverse_average_rate'><p>Inverse average tax rate</p></a></li>
<li><a href='#inverse_income'><p>Inverse income tax functions</p></a></li>
<li><a href='#is.fy'><p>Convenience functions for dealing with financial years</p></a></li>
<li><a href='#lf_inflator'><p>Objects exported from other packages</p></a></li>
<li><a href='#lito'><p>Low Income Tax Offset</p></a></li>
<li><a href='#max_super_contr_base'><p>Maximum superannuation contribution base</p></a></li>
<li><a href='#medicare_levy'><p>Medicare levy</p></a></li>
<li><a href='#model_income_tax'><p>Modelled Income Tax</p></a></li>
<li><a href='#model_new_caps_and_div293'><p>Modelling superannuation changes</p></a></li>
<li><a href='#npv'><p>Financial functions</p></a></li>
<li><a href='#progressivity'><p>Compute the progressivity</p></a></li>
<li><a href='#prohibit_length0_vectors'><p>Prohibit zero lengths</p></a></li>
<li><a href='#prohibit_unequal_length_vectors'><p>Prohibit unequal length vectors</p></a></li>
<li><a href='#project'><p>Simple projections of the annual 2% samples of Australian Taxation Office tax returns.</p></a></li>
<li><a href='#project_to'><p>Simple projections of the annual 2% samples of Australian Taxation Office tax returns.</p></a></li>
<li><a href='#rebate_income'><p>Rebate income</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#require_taxstats'><p>Attach a 'taxstats' package</p></a></li>
<li><a href='#residential_property_prices'><p>Residential property prices in Australia</p></a></li>
<li><a href='#revenue_foregone'><p>Revenue foregone from a modelled sample file</p></a></li>
<li><a href='#sapto'><p>Seniors and Pensioner Tax Offset</p></a></li>
<li><a href='#set_offset'><p>Set offsets</p></a></li>
<li><a href='#small_business_tax_offset'><p>Small Business Tax Offset</p></a></li>
<li><a href='#System'><p>FUNCTION_TITLE</p></a></li>
<li><a href='#validate_date'><p>Verifying validity of dates</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Australian Tax Policy Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>2024.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-27</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hugh Parsonage &lt;hugh.parsonage@gmail.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/HughParsonage/grattan">https://github.com/HughParsonage/grattan</a>,
<a href="https://hughparsonage.github.io/grattan/">https://hughparsonage.github.io/grattan/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/HughParsonage/grattan/issues">https://github.com/HughParsonage/grattan/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Utilities to cost and evaluate Australian tax policy, including fast
    projections of personal income tax collections, high-performance tax and 
    transfer calculators, and an interface to common indices from the Australian
    Bureau of Statistics.  Written to support Grattan Institute's Australian 
    Perspectives program, and related projects. Access to the Australian Taxation
    Office's sample files of personal income tax returns is assumed. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, data.table, grattanInflators (&ge; 0.4.0), hutils (&ge;
1.3.0), hutilscpp (&ge; 0.9.0), ineq (&ge; 0.2-10), fastmatch,
forecast, fy (&ge; 0.2.0), assertthat (&ge; 0.1), magrittr (&ge;
1.5), utils,</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>curl, fst (&ge; 0.8.4), knitr, rlang, rmarkdown, survey,
testthat, tibble, yaml, withr, covr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-27 05:07:03 UTC; hughp</td>
</tr>
<tr>
<td>Author:</td>
<td>Hugh Parsonage [aut, cre],
  Tim Cameron [aut],
  Brendan Coates [aut],
  Matthew Katzen [aut],
  William Young [aut],
  Ittima Cherastidtham [dtc],
  W. Karsten [ctb],
  M. Enrique Garcia [ctb],
  Matt Cowgill [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-27 13:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='grattan-package'>The grattan package.</h2><span id='topic+grattan-package'></span><span id='topic+_PACKAGE'></span><span id='topic+grattan'></span>

<h3>Description</h3>

<p>Grattan package
</p>


<h3>Details</h3>

<p>Tax modelling and other common tasks for Australian policy analysts, 
in support of the Grattan Institute, Melbourne. 
&lt;https://grattan.edu.au&gt;
</p>


<h3>Package options</h3>


<dl>
<dt><code>grattan.verbose</code></dt><dd><p>(<code>FALSE</code>) Emit diagnostic messages (via <code>cat()</code>))</p>
</dd>
<dt><code>grattan.assume1901_2100</code></dt><dd><p>(<code>TRUE</code>) Assume <code>yr2fy</code> receives an integer &gt;= 1901 and &lt;= 2100.</p>
</dd>
<dt><code>grattan.taxstats.lib</code></dt><dd><p>Package library into which <code>taxstats</code> packages will
be installed. If <code>NULL</code>, a temporary directory is used.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p><a href="mailto:hugh.parsonage+grattanpackage@grattan.edu.au">hugh.parsonage+grattanpackage@grattan.edu.au</a>
</p>
<p><a href="mailto:hugh.parsonage@gmail.com">hugh.parsonage@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/HughParsonage/grattan">https://github.com/HughParsonage/grattan</a>
</p>
</li>
<li> <p><a href="https://hughparsonage.github.io/grattan/">https://hughparsonage.github.io/grattan/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/HughParsonage/grattan/issues">https://github.com/HughParsonage/grattan/issues</a>
</p>
</li></ul>


<hr>
<h2 id='age_grouper'>Age grouper</h2><span id='topic+age_grouper'></span>

<h3>Description</h3>

<p>Age grouper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>age_grouper(
  age,
  interval = 10,
  min_age = 25,
  max_age = 75,
  breaks = NULL,
  labels = NULL,
  below = "Below\n",
  exp_min_age = 1L,
  exp_max_age = 100L,
  threshold = 10000L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="age_grouper_+3A_age">age</code></td>
<td>
<p>A numeric age (in years).</p>
</td></tr>
<tr><td><code id="age_grouper_+3A_interval">interval</code></td>
<td>
<p>How big should the age range be. 25-34 means interval = 10.</p>
</td></tr>
<tr><td><code id="age_grouper_+3A_min_age">min_age</code></td>
<td>
<p>What is the upper bound of the lowest bracket? (<code>min_age = 25</code> means 'Under 25' will be the lowest bracket.)</p>
</td></tr>
<tr><td><code id="age_grouper_+3A_max_age">max_age</code></td>
<td>
<p>What is the lower bound of the highest bracket? (<code>max_age = 75</code> means '75+' will be the bracket.)</p>
</td></tr>
<tr><td><code id="age_grouper_+3A_breaks">breaks</code></td>
<td>
<p>Specify breaks manually.</p>
</td></tr>
<tr><td><code id="age_grouper_+3A_labels">labels</code></td>
<td>
<p>Specify the labels manually.</p>
</td></tr>
<tr><td><code id="age_grouper_+3A_below">below</code></td>
<td>
<p>String giving the prefix for the lowest bin. (Only applicable
if <code>breaks</code> and <code>labels</code> are <code>NULL</code>.)</p>
</td></tr>
<tr><td><code id="age_grouper_+3A_exp_min_age">exp_min_age</code>, <code id="age_grouper_+3A_exp_max_age">exp_max_age</code></td>
<td>
<p>Integers specifying the lowest/highest expected 
age in <code>age</code>. If any values fall outside this range, ages will still work
though perhaps slow when <code>length(age) &gt;&gt; threshold</code>.</p>
</td></tr>
<tr><td><code id="age_grouper_+3A_threshold">threshold</code></td>
<td>
<p>An integer, the minimum length at which the calculation will
be accelerated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An ordered factor giving age ranges (separated by hyphens) as specified.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>age_grouper(42)
age_grouper(42, interval = 5, min_age = 20, max_age = 60)
</code></pre>

<hr>
<h2 id='age_pension_age'>Age of eligibility for the Age Pension</h2><span id='topic+age_pension_age'></span>

<h3>Description</h3>

<p>Age of eligibility for the Age Pension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>age_pension_age(when = Sys.Date(), sex = "male")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="age_pension_age_+3A_when">when</code></td>
<td>
<p>Either a Date (or a character vector coercible to such) or a financial year,
when the age of eligibility of Age Pension is requested. Defaults to current date.</p>
</td></tr>
<tr><td><code id="age_pension_age_+3A_sex">sex</code></td>
<td>
<p>A character vector the same length as <code>when</code>, containing strings <code>"male"</code> and <code>"female
"</code>. May be abbreviated to <code>"m"</code> or <code>"f"</code> and is case-insensitive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector, the age of eligiblity for the Age Pension for each <code>when</code>.
</p>


<h3>Source</h3>

<p><a href="https://guides.dss.gov.au/social-security-guide/3/4/1/10">https://guides.dss.gov.au/social-security-guide/3/4/1/10</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>age_pension_age()  # Current age of eligiblity
age_pension_age("1995-12-31")
age_pension_age("2013-14")
</code></pre>

<hr>
<h2 id='apply_super_caps_and_div293'>Superannuation caps and Division 293 calculations</h2><span id='topic+apply_super_caps_and_div293'></span>

<h3>Description</h3>

<p>Mutate a sample file to reflect particular caps on concessional contributions and applications of Division 293 tax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_super_caps_and_div293(
  .sample.file,
  colname_concessional = "concessional_contributions",
  colname_div293_tax = "div293_tax",
  colname_new_Taxable_Income = "Taxable_income_for_ECT",
  div293_threshold = 3e+05,
  cap = 30000,
  cap2 = 35000,
  age_based_cap = TRUE,
  cap2_age = 59,
  ecc = FALSE,
  use_other_contr = FALSE,
  scale_contr_match_ato = FALSE,
  .lambda = 0,
  reweight_late_lodgers = FALSE,
  .mu = 1.05,
  impute_zero_concess_contr = FALSE,
  .min.Sw.for.SG = 450 * 12,
  .SG_rate = 0.0925,
  warn_if_colnames_overwritten = TRUE,
  drop_helpers = FALSE,
  copyDT = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_super_caps_and_div293_+3A_.sample.file">.sample.file</code></td>
<td>
<p>A data.table containing at least the variables <code>sample_file_1314</code> from the taxstats package.</p>
</td></tr>
<tr><td><code id="apply_super_caps_and_div293_+3A_colname_concessional">colname_concessional</code></td>
<td>
<p>The name for concessional contributions.</p>
</td></tr>
<tr><td><code id="apply_super_caps_and_div293_+3A_colname_div293_tax">colname_div293_tax</code></td>
<td>
<p>The name of the column containing the values of Division 293 tax payable for that taxpayer.</p>
</td></tr>
<tr><td><code id="apply_super_caps_and_div293_+3A_colname_new_taxable_income">colname_new_Taxable_Income</code></td>
<td>
<p>The name of the column containing the new Taxable Income.</p>
</td></tr>
<tr><td><code id="apply_super_caps_and_div293_+3A_div293_threshold">div293_threshold</code></td>
<td>
<p>The Division 293 threshold.</p>
</td></tr>
<tr><td><code id="apply_super_caps_and_div293_+3A_cap">cap</code></td>
<td>
<p>The cap on concessional contributions for all taxpayers if <code>age_based_cap</code> is FALSE, or for those below the age threshold otherwise.</p>
</td></tr>
<tr><td><code id="apply_super_caps_and_div293_+3A_cap2">cap2</code></td>
<td>
<p>The cap on concessional contributions for those above the age threshold. No effect if <code>age_based_cap</code> is FALSE.</p>
</td></tr>
<tr><td><code id="apply_super_caps_and_div293_+3A_age_based_cap">age_based_cap</code></td>
<td>
<p>Is the cap on concessional contributions age-based?</p>
</td></tr>
<tr><td><code id="apply_super_caps_and_div293_+3A_cap2_age">cap2_age</code></td>
<td>
<p>The age above which <code>cap2</code> applies.</p>
</td></tr>
<tr><td><code id="apply_super_caps_and_div293_+3A_ecc">ecc</code></td>
<td>
<p>(logical) Should an excess concessional contributions charge be calculated? (Not implemented.)</p>
</td></tr>
<tr><td><code id="apply_super_caps_and_div293_+3A_use_other_contr">use_other_contr</code></td>
<td>
<p>Make a (poor) assumption that all 'Other contributions' (<code>MCS_Othr_Contr</code>) are concessional contributions. This may be a useful upper bound should such contributions be considered important.</p>
</td></tr>
<tr><td><code id="apply_super_caps_and_div293_+3A_scale_contr_match_ato">scale_contr_match_ato</code></td>
<td>
<p>(logical) Should concessional contributions be inflated to match aggregates in 2013-14? That is, should concessional contributions by multiplied by <code>grattan:::super_contribution_inflator_1314</code>, which was defined to be: </p>
<p style="text-align: center;"><code class="reqn">\frac{\textrm{Total assessable contributions in SMSF and funds}}{\textrm{Total contributions in 2013-14 sample file}}</code>
</p>
<p>.</p>
</td></tr>
<tr><td><code id="apply_super_caps_and_div293_+3A_.lambda">.lambda</code></td>
<td>
<p>Scalar weight applied to <code>concessional contributions</code>. <code class="reqn">\lambda = 0</code> means no (extra) weight. <code class="reqn">\lambda = 1</code> means contributions are inflated by the ratio of aggregates to the sample file's total. For <code class="reqn">R = \textrm{actual} / \textrm{apparent}</code> then the contributions are scaled by <code class="reqn">1 + \lambda(R - 1)</code>.</p>
</td></tr>
<tr><td><code id="apply_super_caps_and_div293_+3A_reweight_late_lodgers">reweight_late_lodgers</code></td>
<td>
<p>(logical) Should WEIGHT be inflated to account for late lodgers?</p>
</td></tr>
<tr><td><code id="apply_super_caps_and_div293_+3A_.mu">.mu</code></td>
<td>
<p>Scalar weight for WEIGHT. (<code class="reqn">w' = \mu w</code>) No effect if <code>reweight_late_lodgers</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="apply_super_caps_and_div293_+3A_impute_zero_concess_contr">impute_zero_concess_contr</code></td>
<td>
<p>Should zero concessional contributions be imputed using salary?</p>
</td></tr>
<tr><td><code id="apply_super_caps_and_div293_+3A_.min.sw.for.sg">.min.Sw.for.SG</code></td>
<td>
<p>The minimum salary required for super guarantee to be imputed.</p>
</td></tr>
<tr><td><code id="apply_super_caps_and_div293_+3A_.sg_rate">.SG_rate</code></td>
<td>
<p>The super guarantee rate for imputation.</p>
</td></tr>
<tr><td><code id="apply_super_caps_and_div293_+3A_warn_if_colnames_overwritten">warn_if_colnames_overwritten</code></td>
<td>
<p>(logical) Issue a warning if the construction of helper columns will overwrite existing column names in <code>.sample.file</code>.</p>
</td></tr>
<tr><td><code id="apply_super_caps_and_div293_+3A_drop_helpers">drop_helpers</code></td>
<td>
<p>(logical) Should columns used in the calculation be dropped before the sample file is returned?</p>
</td></tr>
<tr><td><code id="apply_super_caps_and_div293_+3A_copydt">copyDT</code></td>
<td>
<p>(logical) Should the data table be <code>copy()</code>d? If the action of this data table is being compared, possibly useful.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data table comprising the original sample file (<code>.sample.file</code>) with extra superannuation policy-relevant variables for the policy specified by the function.
</p>


<h3>Author(s)</h3>

<p>Hugh Parsonage, William Young
</p>

<hr>
<h2 id='aus_pop_qtr'>Australia's population</h2><span id='topic+aus_pop_qtr'></span>

<h3>Description</h3>

<p>Australia's population
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aus_pop_qtr(date_quarter, allow.projections = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aus_pop_qtr_+3A_date_quarter">date_quarter</code></td>
<td>
<p>A character string (YYYY-QQ).</p>
</td></tr>
<tr><td><code id="aus_pop_qtr_+3A_allow.projections">allow.projections</code></td>
<td>
<p>If the date is beyond the ABS's confirmed data, should a projection be used?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The population at <code>date_quarter</code>, or at the most recent year in the data if projections are disallowed.
</p>

<hr>
<h2 id='aus_pop_qtr_age'>Australian estimated resident population by age and date</h2><span id='topic+aus_pop_qtr_age'></span>

<h3>Description</h3>

<p>Australian estimated resident population by age and date
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aus_pop_qtr_age(
  date = NULL,
  age = NULL,
  tbl = FALSE,
  roll = TRUE,
  roll.beyond = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aus_pop_qtr_age_+3A_date">date</code></td>
<td>
<p>A vector of dates. If <code>NULL</code>, values for all dates are returned in a table. The dates need not be quarters, provided <code>roll != FALSE</code>,</p>
</td></tr>
<tr><td><code id="aus_pop_qtr_age_+3A_age">age</code></td>
<td>
<p>A vector of (integer) ages from 0 to 100 inclusive. If <code>NULL</code>, all ages are returned.</p>
</td></tr>
<tr><td><code id="aus_pop_qtr_age_+3A_tbl">tbl</code></td>
<td>
<p>Should a table be returned? If <code>FALSE</code>, a vector is returned.</p>
</td></tr>
<tr><td><code id="aus_pop_qtr_age_+3A_roll">roll</code></td>
<td>
<p>Should a rolling join be performed?</p>
</td></tr>
<tr><td><code id="aus_pop_qtr_age_+3A_roll.beyond">roll.beyond</code></td>
<td>
<p>Should inputs be allowed to go beyond the limits of data (without a warning)?
This is passed to <code>data.table</code>'s join, so options other than <code>TRUE</code> and <code>FALSE</code> are available. 
See <code>?data.table</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> or <code>vector</code> with values of the estimated resident population.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aus_pop_qtr_age(date = as.Date("2016-01-01"), age = 42)
</code></pre>

<hr>
<h2 id='awote'>AWOTE</h2><span id='topic+awote'></span>

<h3>Description</h3>

<p>Adult weekly ordinary-time earnings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>awote(
  Date = NULL,
  fy.year = NULL,
  rollDate = "nearest",
  isMale = NA,
  isAdult = TRUE,
  isOrdinary = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="awote_+3A_date">Date</code>, <code id="awote_+3A_fy.year">fy.year</code></td>
<td>
<p>When the AWOTE is desired.</p>
</td></tr>
<tr><td><code id="awote_+3A_rolldate">rollDate</code></td>
<td>
<p>How should the <code>Date</code> be joined to the source data?
Passed to <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="awote_+3A_ismale">isMale</code></td>
<td>
<p>(logical, default: <code>NA</code>) <code>TRUE</code> for male weekly earnings, 
<code>FALSE</code> for female, <code>NA</code> for the weekly earnings of both sexes.</p>
</td></tr>
<tr><td><code id="awote_+3A_isadult">isAdult</code></td>
<td>
<p>(logical, default: <code>TRUE</code>) Use adult weekly earnings?</p>
</td></tr>
<tr><td><code id="awote_+3A_isordinary">isOrdinary</code></td>
<td>
<p>Use ordinary weekly earnings?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>awote()  # Current AWOTE


</code></pre>

<hr>
<h2 id='bto'>Beneficiary tax offset</h2><span id='topic+bto'></span>

<h3>Description</h3>

<p>Beneficiary tax offset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bto(
  benefit_amount,
  fy.year = NULL,
  rate1 = 0.15,
  benefit_threshold = 6000,
  tax_threshold = 37000,
  rate2 = 0.15
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bto_+3A_benefit_amount">benefit_amount</code></td>
<td>
<p>The amount of Tax Offsetable benefit received by the taxpayer during the income year.</p>
</td></tr>
<tr><td><code id="bto_+3A_fy.year">fy.year</code></td>
<td>
<p>The income year. Not used by default.</p>
</td></tr>
<tr><td><code id="bto_+3A_rate1">rate1</code></td>
<td>
<p>The coefficient in Division 2, section 13(2) of the Income Tax Assessment (1936 Act) Regulation 2015
(the regulations).</p>
</td></tr>
<tr><td><code id="bto_+3A_benefit_threshold">benefit_threshold</code></td>
<td>
<p>The amount of benefits above which the offset applies.</p>
</td></tr>
<tr><td><code id="bto_+3A_tax_threshold">tax_threshold</code></td>
<td>
<p>The <em>threshold at the upper conclusion of the lowest marginal tax rate</em> in the
words of the section 13(3) of the regulations.</p>
</td></tr>
<tr><td><code id="bto_+3A_rate2">rate2</code></td>
<td>
<p>The second coefficient in section 13(3) of the regulations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The beneficiary tax offset.
</p>


<h3>WARNING</h3>

<p>This function disagrees with the ATO online calculator.
</p>

<hr>
<h2 id='CG_population_inflator'>Forecasting capital gains</h2><span id='topic+CG_population_inflator'></span><span id='topic+CG_inflator'></span>

<h3>Description</h3>

<p>Forecasting capital gains
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CG_population_inflator(
  x = 1,
  from_fy,
  to_fy,
  forecast.series = "mean",
  cg.series
)

CG_inflator(x = 1, from_fy, to_fy, forecast.series = "mean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CG_population_inflator_+3A_x">x</code></td>
<td>
<p>To be inflated.</p>
</td></tr>
<tr><td><code id="CG_population_inflator_+3A_from_fy">from_fy</code>, <code id="CG_population_inflator_+3A_to_fy">to_fy</code></td>
<td>
<p>Financial years designating the inflation period.</p>
</td></tr>
<tr><td><code id="CG_population_inflator_+3A_forecast.series">forecast.series</code></td>
<td>
<p>One of <code>"mean"</code>, <code>"lower"</code>, <code>"upper"</code>. What estimator to use in forecasts. <code>"lower"</code> and <code>"upper"</code> give the lower and upper boundaries of the 95% prediction interval.</p>
</td></tr>
<tr><td><code id="CG_population_inflator_+3A_cg.series">cg.series</code></td>
<td>
<p>(Not implemented.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>CG_population_inflator</code>, the number of individuals estimated to incur capital gains in <code>fy_year</code>. 
For <code>CG_inflator</code>, an estimate of the nominal value of (total) capital gains in <code>to_fy</code> relative to the nominal value in <code>from_fy</code>.
</p>

<hr>
<h2 id='compare_avg_tax_rates'>Compare average tax rates by percentile</h2><span id='topic+compare_avg_tax_rates'></span>

<h3>Description</h3>

<p>To determine the effects of bracket creep on a proposed tax policy,
a common task is calculate the change in the average tax rates for each percentile.
This function accepts a sample file and a baseline sample file, and returns a 100-row table
giving the mean change in average tax rates for each percentile, compared to the baseline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_avg_tax_rates(DT, baseDT, by = "id", ids = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_avg_tax_rates_+3A_dt">DT</code></td>
<td>
<p>A single <code>data.table</code> containing columns <code>new_tax</code>,
<code>Taxable_Income</code>, <code>baseline_tax</code>.</p>
</td></tr>
<tr><td><code id="compare_avg_tax_rates_+3A_basedt">baseDT</code></td>
<td>
<p>A <code>data.table</code> of a single cross-section of taxpayers from
which baseline percentiles can be produced.</p>
</td></tr>
<tr><td><code id="compare_avg_tax_rates_+3A_by">by</code></td>
<td>
<p>How to separate <code>DT</code></p>
</td></tr>
<tr><td><code id="compare_avg_tax_rates_+3A_ids">ids</code></td>
<td>
<p>Subset <code>DT</code> by <code>by</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='cpi_inflator_general_date'>CPI for general dates</h2><span id='topic+cpi_inflator_general_date'></span>

<h3>Description</h3>

<p>Deprecated in favour of <code>grattanInflators::cpi_inflator</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpi_inflator_general_date(from_nominal_price = 1, from_date, to_date, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpi_inflator_general_date_+3A_from_nominal_price">from_nominal_price</code></td>
<td>
<p>(numeric) the nominal prices to be converted to a real price</p>
</td></tr>
<tr><td><code id="cpi_inflator_general_date_+3A_from_date">from_date</code></td>
<td>
<p>(character, date-like) the 'date' contemporaneous to <code>from_nominal_price</code>. The acceptable forms are 'YYYY', 'YYYY-YY' (financial year), 'YYYY-MM-DD', and 'YYYY-Q[1-4]' (quarters). Note a vector cannot contain a mixture of date forms.</p>
</td></tr>
<tr><td><code id="cpi_inflator_general_date_+3A_to_date">to_date</code></td>
<td>
<p>(character, date-like) the date at which the real price is valued (where the nominal price equals the real price). Same forms as for <code>from_date</code></p>
</td></tr>
<tr><td><code id="cpi_inflator_general_date_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="#topic+cpi_inflator">cpi_inflator</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of real prices in <code>to_date</code> dollars.
</p>

<hr>
<h2 id='cpi_inflator_quarters'>CPI inflator when dates are nice</h2><span id='topic+cpi_inflator_quarters'></span>

<h3>Description</h3>

<p>CPI inflator when dates are nice
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpi_inflator_quarters(
  from_nominal_price = 1,
  from_qtr,
  to_qtr,
  adjustment = c("seasonal", "trimmed", "none"),
  useABSConnection = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpi_inflator_quarters_+3A_from_nominal_price">from_nominal_price</code></td>
<td>
<p>(numeric) the nominal prices to be converted to a real price</p>
</td></tr>
<tr><td><code id="cpi_inflator_quarters_+3A_from_qtr">from_qtr</code></td>
<td>
<p>(date in quarters) the dates contemporaneous to the prices in from_nominal_price. Must be of the form &quot;YYYY-Qq&quot; e.g. &quot;1066-Q2&quot;. Q1 = Mar, Q2 = Jun, Q3 = Sep, Q4 = Dec.</p>
</td></tr>
<tr><td><code id="cpi_inflator_quarters_+3A_to_qtr">to_qtr</code></td>
<td>
<p>(date in quarters) the date to be inflated to, where nominal price = real price. Must be of the form &quot;YYYY-Qq&quot; e.g. &quot;1066-Q2&quot;.</p>
</td></tr>
<tr><td><code id="cpi_inflator_quarters_+3A_adjustment">adjustment</code></td>
<td>
<p>Should there be an adjustment made to the index? Adjustments include 'none' (no adjustment), 'seasonal', or 'trimmed' [referring to trimmed mean]. By default, <code>seasonal</code>.</p>
</td></tr>
<tr><td><code id="cpi_inflator_quarters_+3A_useabsconnection">useABSConnection</code></td>
<td>
<p>Ignored.
The internal data was updated on 2022-01-03 to 2021-Q3.
Using <code>useABSConnection = TRUE</code> is no longer supported for server issues.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of real prices.
</p>

<hr>
<h2 id='differentially_uprate_wage'>Differential uprating</h2><span id='topic+differentially_uprate_wage'></span>

<h3>Description</h3>

<p>Apply differential uprating to projections of the <code>Sw_amt</code> variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>differentially_uprate_wage(wage = 1, from, to, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="differentially_uprate_wage_+3A_wage">wage</code></td>
<td>
<p>A numeric vector to be uprated.</p>
</td></tr>
<tr><td><code id="differentially_uprate_wage_+3A_from">from</code></td>
<td>
<p>The financial year contemporaneous to wage, which must be a financial year of an available sample file &ndash; in particular, not after 2016-17.</p>
</td></tr>
<tr><td><code id="differentially_uprate_wage_+3A_to">to</code></td>
<td>
<p>The target of the uprating. Passed to <code><a href="#topic+wage_inflator">wage_inflator</a></code>.</p>
</td></tr>
<tr><td><code id="differentially_uprate_wage_+3A_...">...</code></td>
<td>
<p>Other arguments passed <code><a href="#topic+wage_inflator">wage_inflator</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>vignette("differential-uprating")</code>.
</p>


<h3>Value</h3>

<p>The vector <code>wage</code> differentially uprated to <code>to_fy</code>.
</p>


<h3>Author(s)</h3>

<p>Hugh Parsonage and William Young
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ws &lt;- c(20e3, 50e3, 100e3)
from &lt;- "2013-14"
to &lt;- "2016-17"
differentially_uprate_wage(ws, from, to)
differentially_uprate_wage(ws, from, to) / (ws * wage_inflator(from, to))

</code></pre>

<hr>
<h2 id='gdp'>Gross Domestic Product, Australia</h2><span id='topic+gdp'></span><span id='topic+gdp_qtr'></span><span id='topic+gdp_fy'></span>

<h3>Description</h3>

<p>Gross domestic product, at contemporaneous prices (called &lsquo;current prices&rsquo; by the ABS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdp_qtr(date, roll = "nearest")

gdp_fy(fy_year)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gdp_+3A_date">date</code></td>
<td>
<p>A Date vector or character coercible thereto.</p>
</td></tr>
<tr><td><code id="gdp_+3A_roll">roll</code></td>
<td>
<p>Passed to <code>data.table</code> when joining.</p>
</td></tr>
<tr><td><code id="gdp_+3A_fy_year">fy_year</code></td>
<td>
<p>Character vector of financial years.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>gdp_qtr</code>, the quarterly GDP for the quarter date nearest (or otherwise using <code>roll</code>). 
For <code>gdp_fy</code> the sum over the quarters in the financial year provided. 
If <code>fy_year</code> would provide incomplete data (i.e. only sum three or fewer quarters), a warning is issued.
Dates or fy_year outside the available data is neither a warning nor an error, but <code>NA</code>.
</p>


<h3>Source</h3>

<p>Australian Bureau of Statistics, Catalogue 5206.0. Series A2304350J.
</p>

<hr>
<h2 id='generic_inflator'>Generic inflator</h2><span id='topic+generic_inflator'></span>

<h3>Description</h3>

<p>Used to inflate variables in the sample file when there is no clear existing index.
Note this is an unexported function: it is not available to the end-user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generic_inflator(
  vars,
  h,
  fy.year.of.sample.file = "2012-13",
  nonzero = FALSE,
  estimator = "mean",
  pred_interval = 80
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generic_inflator_+3A_vars">vars</code></td>
<td>
<p>A character vector of those variables within <code>.sample_file</code> for which forecasts are desired.</p>
</td></tr>
<tr><td><code id="generic_inflator_+3A_h">h</code></td>
<td>
<p>An integer, how many years ahead should the inflator be targeted.</p>
</td></tr>
<tr><td><code id="generic_inflator_+3A_fy.year.of.sample.file">fy.year.of.sample.file</code></td>
<td>
<p>A string representing the financial year of <code>.sample_file</code>.</p>
</td></tr>
<tr><td><code id="generic_inflator_+3A_nonzero">nonzero</code></td>
<td>
<p>Should the forecast be taken on all values, or just nonzero values?</p>
</td></tr>
<tr><td><code id="generic_inflator_+3A_estimator">estimator</code></td>
<td>
<p>What forecast element should be used: the point estimate (<code>"mean"</code>), or the <code>upper</code> or <code>lower</code> endpoint of a prediction interval?</p>
</td></tr>
<tr><td><code id="generic_inflator_+3A_pred_interval">pred_interval</code></td>
<td>
<p>If <code>estimator</code> is <code>upper</code> or <code>lower</code>, what prediction interval are these the end points of?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data table of two columns: <code>variable</code> containing <code>vars</code> and <code>inflator</code> equal to the inflator to be applied to that variable to inflate it ahead <code>h</code> years.
</p>

<hr>
<h2 id='gni'>Gross National Income, Australia</h2><span id='topic+gni'></span><span id='topic+gni_qtr'></span><span id='topic+gni_fy'></span>

<h3>Description</h3>

<p>Gross national income, at contemporaneous prices (called 'current prices' by the ABS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gni_qtr(date, roll = "nearest")

gni_fy(fy_year)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gni_+3A_date">date</code></td>
<td>
<p>A Date vector or character coercible thereto.</p>
</td></tr>
<tr><td><code id="gni_+3A_roll">roll</code></td>
<td>
<p>Passed to <code>data.table</code> when joining.</p>
</td></tr>
<tr><td><code id="gni_+3A_fy_year">fy_year</code></td>
<td>
<p>Character vector of financial years.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>gni_qtr</code>, the quarterly GNI for the nearest quarter date. 
For <code>gni_fy</code> the sum over the quarters in the financial year provided. 
If <code>fy_year</code> would provide incomplete data (i.e. only sum three or fewer quarters), a warning is issued.
Dates or fy_year outside the available data is neither a warning nor an error, but <code>NA</code>.
</p>


<h3>Source</h3>

<p>Australian Bureau of Statistics, Catalogue 5206.0. Series A2304354T.
</p>

<hr>
<h2 id='income_tax'>Income tax payable</h2><span id='topic+income_tax'></span>

<h3>Description</h3>

<p>Income tax payable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>income_tax(
  income,
  fy.year = NULL,
  age = NULL,
  .dots.ATO = NULL,
  System = NULL,
  return.mode = c("numeric", "integer", "sum", "mean"),
  nThread = getOption("grattan.nThread", 1L)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="income_tax_+3A_income">income</code></td>
<td>
<p>The individual assessable income.</p>
</td></tr>
<tr><td><code id="income_tax_+3A_fy.year">fy.year</code></td>
<td>
<p>The financial year in which the income was earned. Tax years 2000-01 to 2018-19 are supported, as well as the tax year 2019-20, for convenience. 
If <code>fy.year</code> is not given, the current financial year is used by default.</p>
</td></tr>
<tr><td><code id="income_tax_+3A_age">age</code></td>
<td>
<p>The individual's age. Ignored if <code>.dots.ATO</code> is provided (and contains
an age variable such as <code>age_range</code> or <code>Birth_year</code>).</p>
</td></tr>
<tr><td><code id="income_tax_+3A_.dots.ato">.dots.ATO</code></td>
<td>
<p>A data.frame that contains additional information about the individual's circumstances, with columns the same as in the ATO sample files.
</p>
<p>Age variables in <code>.dots.ATO</code> take precedence over <code>age</code> and providing both
is a warning.</p>
</td></tr>
<tr><td><code id="income_tax_+3A_system">System</code></td>
<td>
<p>A <code>tax-system</code> created by <code>System()</code> or <code>NULL</code>, the default,
corresponding to the tax system of the given year.</p>
</td></tr>
<tr><td><code id="income_tax_+3A_return.mode">return.mode</code></td>
<td>
<p>The mode (numeric or integer) of the returned vector.</p>
</td></tr>
<tr><td><code id="income_tax_+3A_nthread">nThread</code></td>
<td>
<p>Number of threads to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is inflexible by design.
It is designed to return the correct tax payable in a year, not to model the tax payable 
under different tax settings. (Use <code><a href="#topic+model_income_tax">model_income_tax</a></code> for that purpose.)
</p>
<p>The function aims to produce the personal income tax payable for the inputs given
in the tax year <code>fy.year</code>. The function is specified to produce the most accurate 
calculation of personal income tax given the variables in the ATO's 2% sample files.
However, many components are absent from these files, while other components could
not be computed reliably.
</p>
<p>For the 2018-19 tax year, the function calculates
</p>

<dl>
<dt>tax on ordinary taxable income</dt><dd><p>The tax as specified in Schedule 7 of the 
<em>Income Tax Rates Act 1986</em> (Cth).</p>
</dd>
<dt>Medicare levy</dt><dd><p>See <code><a href="#topic+medicare_levy">medicare_levy</a></code> for details.</p>
</dd>
<dt>LITO</dt><dd><p>See <code><a href="#topic+lito">lito</a></code> for details.</p>
</dd>
<dt>SAPTO</dt><dd><p>See <code><a href="#topic+sapto">sapto</a></code>. For years preceding the introduction of SAPTO, 
the maximum offset is assumed to apply to those above age 65 (since the sample files only provide 5-year 
age groups).</p>
</dd>
<dt>SBTO</dt><dd><p>See <code><a href="#topic+small_business_tax_offset">small_business_tax_offset</a></code> for details.</p>
</dd>
<dt>Historical levies</dt><dd><p>The flood levy and the temporary budget repair levy.</p>
</dd>
</dl>

<p>Notably, when used with a 2% sample file, the function will not be able to correctly account
for different tax rates and offsets among taxpayers with dependants since the sample files
(as of 2015-16) do not have this information.
</p>


<h3>Value</h3>

<p>The total personal income tax payable.
</p>


<h3>Author(s)</h3>

<p>Tim Cameron, Brendan Coates, Matthew Katzen, Hugh Parsonage, William Young
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Income tax payable on a taxable income of 50,000 
## for the 2013-14 tax year
income_tax(50e3, "2013-14")

## Calculate tax for each lodger in the 2013-14 sample file.

 # library(data.table)
 # library(taxstats)
  
 # s1314 &lt;- as.data.table(sample_file_1314)
 # s1314[, tax := income_tax(Taxable_Income, "2013-14", .dots.ATO = s1314)]

</code></pre>

<hr>
<h2 id='inflator'>Inflate using a general index</h2><span id='topic+inflator'></span>

<h3>Description</h3>

<p>Inflate using a general index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inflator(
  x = 1,
  from,
  to,
  inflator_table,
  index.col = "Index",
  time.col = "Time",
  roll = NULL,
  max.length = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inflator_+3A_x">x</code></td>
<td>
<p>The vector to be inflated.</p>
</td></tr>
<tr><td><code id="inflator_+3A_from">from</code></td>
<td>
<p>The contemporaneous time of x.</p>
</td></tr>
<tr><td><code id="inflator_+3A_to">to</code></td>
<td>
<p>The target time (in units of the <code>inflator_table</code>) to which x is to be inflated.</p>
</td></tr>
<tr><td><code id="inflator_+3A_inflator_table">inflator_table</code></td>
<td>
<p>A <code>data.table</code> having columns <code>index.col</code> and <code>time.col</code>.</p>
</td></tr>
<tr><td><code id="inflator_+3A_index.col">index.col</code></td>
<td>
<p>The column in <code>inflator_table</code> containing the index used for inflation.</p>
</td></tr>
<tr><td><code id="inflator_+3A_time.col">time.col</code></td>
<td>
<p>The column in <code>inflator_table</code> by which times are mapped.</p>
</td></tr>
<tr><td><code id="inflator_+3A_roll">roll</code></td>
<td>
<p>If <code>NULL</code>, inflation is calculated only on exact matches in <code>inflator_table</code>. Otherwise, uses a rolling join. See <code>data.table::data.table</code>.</p>
</td></tr>
<tr><td><code id="inflator_+3A_max.length">max.length</code></td>
<td>
<p>(Internal use only). If not <code>NULL</code>, the maximum length of <code>x</code>,
<code>from</code>, and <code>to</code> known in advance. May be provided to improve the performance
if known.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of inflated values. For example, <code>inflator_table = grattan:::cpi_seasonal_adjustment</code>, 
<code>index.col = "obsValue"</code>, <code>time.col = "obsTime"</code>, gives the CPI inflator.
</p>

<hr>
<h2 id='install_taxstats'>Install 'taxstats' files</h2><span id='topic+install_taxstats'></span>

<h3>Description</h3>

<p>The taxstats packages provide the sample files as released by the
ATO. These packages are used for testing, but are not available through CRAN 
as they are too large.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>install_taxstats(pkg = c("taxstats"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="install_taxstats_+3A_pkg">pkg</code></td>
<td>
<p>The package to install such as <code>"taxstats"</code> or <code>"taxstats1516"</code>.</p>
</td></tr>
<tr><td><code id="install_taxstats_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="utils.html#topic+install.packages">install.packages</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='inverse_average_rate'>Inverse average tax rate</h2><span id='topic+inverse_average_rate'></span>

<h3>Description</h3>

<p>Inverse average tax rate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inverse_average_rate(average_rate, ..., .max = 1e+08)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inverse_average_rate_+3A_average_rate">average_rate</code></td>
<td>
<p>The average tax rate (<code class="reqn">\frac{tax}{income}</code>)</p>
</td></tr>
<tr><td><code id="inverse_average_rate_+3A_...">...</code></td>
<td>
<p>Parameters passed to <code><a href="#topic+income_tax">income_tax</a></code>.</p>
</td></tr>
<tr><td><code id="inverse_average_rate_+3A_.max">.max</code></td>
<td>
<p>The maximum income to test before ending the search. (Used only to prevent infinite loops.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The minimum income at which the average tax rate exceeds <code>average_rate</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inverse_average_rate(0.2, fy.year = "2014-15")
</code></pre>

<hr>
<h2 id='inverse_income'>Inverse income tax functions</h2><span id='topic+inverse_income'></span>

<h3>Description</h3>

<p>Inverse income tax functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inverse_income(
  tax,
  fy.year = "2012-13",
  zero.tax.income = c("maximum", "zero", "uniform", numeric(1)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inverse_income_+3A_tax">tax</code></td>
<td>
<p>The tax payable.</p>
</td></tr>
<tr><td><code id="inverse_income_+3A_fy.year">fy.year</code></td>
<td>
<p>The relevant financial year.</p>
</td></tr>
<tr><td><code id="inverse_income_+3A_zero.tax.income">zero.tax.income</code></td>
<td>
<p>A character vector, (&quot;maximum&quot;, &quot;zero&quot;, &quot;uniform&quot;, numeric(1)) Given that many incomes map to zero taxes, the <code>income_tax</code> function is not invertible there. As a consequence, the inverse function's value must be specified for tax = 0. &quot;maximum&quot; returns the maximum integer income one can have with a zero tax liability; &quot;zero&quot; returns zero for any tax of zero; &quot;uniform&quot; provides a random integer from zero to the maximum income with a zero tax. The value can also be specified explicitly.</p>
</td></tr>
<tr><td><code id="inverse_income_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>income_tax</code>. If <code>tax</code> or <code>fy.year</code> are vectors, these should be named vectors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has an error of $2.
</p>


<h3>Value</h3>

<p>The approximate taxable income given the tax payable for the financial year. See Details.
</p>

<hr>
<h2 id='is.fy'>Convenience functions for dealing with financial years</h2><span id='topic+is.fy'></span><span id='topic+fy.year'></span><span id='topic+yr2fy'></span><span id='topic+fy2yr'></span><span id='topic+fy2date'></span><span id='topic+date2fy'></span>

<h3>Description</h3>

<p>From grattan v1.7.1.4, these are reexports from the <code><a href="fy.html#topic+fy-package">fy-package</a></code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.fy_+3A_yr_ending">yr_ending</code></td>
<td>
<p>An integer representing a year.</p>
</td></tr>
<tr><td><code id="is.fy_+3A_fy.yr">fy.yr</code></td>
<td>
<p>A string suspected to be a financial year.</p>
</td></tr>
<tr><td><code id="is.fy_+3A_date">date</code></td>
<td>
<p>A string or date for which the financial year is desired. Note that <code>yr2fy</code> does not check its argument is an integer.</p>
</td></tr>
<tr><td><code id="is.fy_+3A_assume1901_2100">assume1901_2100</code></td>
<td>
<p>For <code>yr2fy</code>, assume that <code>yr_ending</code> is between 1901 and 2100, 
for performance. By default, set to <code>getOption("grattan.assume1901_2100", TRUE)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following forms are permitted: <code>2012-13</code>, <code>201213</code>, <code>2012 13</code>, only.
However, the <code>2012-13</code> form is preferred and will improve performance.
</p>


<h3>Value</h3>

<p>For <code>is.fy</code>, a logical, whether its argument is a financial year.
The following forms are allowed: <code>2012-13</code>, <code>201213</code>, <code>2012 13</code>, only.
For <code>fy.year</code>, <code>yr2fy</code>, and <code>date2fy</code>, the financial year. 
For the inverses, a numeric corresponding to the year.
</p>
<p><code>fy.year</code> is a deprecated alias for <code>yr2fy</code>, the latter is slightly more efficient, as well as more declarative.
</p>
<p><code>fy2yr</code> converts a financial year to the year ending: <code>fy2yr("2016-17")</code> returns 2017. <code>yr2fy</code> is the inverse: <code>yr2fy(fy2yr("2016-17")) == "2016-17"</code>.
</p>
<p><code>fy2date</code> converts a financial year to the 30 June of the financial year ending.
</p>
<p><code>date2fy</code> converts a date to the corresponding financial year.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.fy("2012-13")
is.fy("2012-14")
yr2fy(2012)
fy2yr("2015-16")
date2fy("2014-08-09")
</code></pre>

<hr>
<h2 id='lf_inflator'>Objects exported from other packages</h2><span id='topic+lf_inflator'></span><span id='topic+lf_inflator_fy'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>grattanInflators</dt><dd><p><code><a href="grattanInflators.html#topic+lf_inflator">lf_inflator</a></code></p>
</dd>
</dl>


<h3>Usage</h3>

<pre><code class='language-R'>lf_inflator_fy(...)
</code></pre>

<hr>
<h2 id='lito'>Low Income Tax Offset</h2><span id='topic+lito'></span><span id='topic+lmito'></span>

<h3>Description</h3>

<p>The Low Income Tax Offset (LITO) is a non-refundable tax offset to reduce ordinary personal income tax for low-income earners.
</p>
<p>N.B. Since v2.0.0, <code>lito</code> only calculates the actual LITO, rather than
an offset with custom parameters. For such functionality, use (unexported) <code>Offset</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lito(income, fy.year = NULL)

lmito(income, fy.year = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lito_+3A_income">income</code></td>
<td>
<p>The income on which the offset is applied.</p>
</td></tr>
<tr><td><code id="lito_+3A_fy.year">fy.year</code></td>
<td>
<p>The financial year for which the LITO is desired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The LITO or LMITO for the given income and tax year.
</p>

<hr>
<h2 id='max_super_contr_base'>Maximum superannuation contribution base</h2><span id='topic+max_super_contr_base'></span>

<h3>Description</h3>

<p>Data maximum super contribution base.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_super_contr_base
</code></pre>


<h3>Format</h3>

<p>A data frame with 25 rows and 2 variables:
</p>

<dl>
<dt>fy_year</dt><dd><p>The financial year.</p>
</dd>
<dt>max_sg_per_qtr</dt><dd><p>Maximum superannuation guarantee per quarter.</p>
</dd>
</dl>



<h3>Source</h3>

<p>ATO.
</p>

<hr>
<h2 id='medicare_levy'>Medicare levy</h2><span id='topic+medicare_levy'></span>

<h3>Description</h3>

<p>The (actual) amount payable for the Medicare levy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>medicare_levy(
  income,
  fy.year = "2013-14",
  Spouse_income = 0L,
  sapto.eligible = FALSE,
  sato = NULL,
  pto = NULL,
  family_status = "individual",
  n_dependants = 0L,
  is_married = NULL,
  .checks = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="medicare_levy_+3A_income">income</code></td>
<td>

<dl>
<dt><code>numeric(N)</code></dt><dd><p>The income for medicare levy purposes of the taxpayer.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="medicare_levy_+3A_fy.year">fy.year</code></td>
<td>

<dl>
<dt><code>character(1)</code> or <code>character(N)</code> or <code>fy(N)</code> or <code>fy(1)</code></dt><dd>
<p>The tax year in which <code>income</code> was earned. A vector satisfying <code>fy::validate_fys_permitted</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="medicare_levy_+3A_spouse_income">Spouse_income</code></td>
<td>

<dl>
<dt><code>numeric(1)</code> or <code>numeric(N)</code></dt><dd><p>The income of the taxpayer's spouse. Missing values are
imputed to zeroes. Values are truncated to integer.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="medicare_levy_+3A_sapto.eligible">sapto.eligible</code></td>
<td>

<dl>
<dt><code>logical(1)</code> or <code>logical(N)</code></dt><dd><p>Is the taxpayer entitled to the SAPTO thresholds? Missing
values are imputed to <code>FALSE</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="medicare_levy_+3A_sato">sato</code>, <code id="medicare_levy_+3A_pto">pto</code></td>
<td>
<p>Is the taxpayer eligible for the Senior Australians Tax Offset or Pensions Tax Offset?
<code>pto = TRUE</code> not supported and will be set to <code>FALSE</code>, with a warning.</p>
</td></tr>
<tr><td><code id="medicare_levy_+3A_family_status">family_status</code></td>
<td>
<p>(Deprecated: use 'is_married' and 'n_dependants' instead)</p>
</td></tr>
<tr><td><code id="medicare_levy_+3A_n_dependants">n_dependants</code></td>
<td>

<dl>
<dt><code>integer(N)</code> or <code>integer(1)</code></dt><dd><p>Number of dependants the taxpayer has. If nonzero, 
the taxpayer is entitled to the family thresholds of the Medicare levy, and
each dependant child increases the thresholds.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="medicare_levy_+3A_is_married">is_married</code></td>
<td>

<dl>
<dt><code>logical(N)</code></dt><dd><p>Is the taxpayer married? Married individuals (or those 
whose <code>Spouse_income &gt; 0</code>) are deemed to be families when determining 
cut-off thresholds.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="medicare_levy_+3A_.checks">.checks</code></td>
<td>
<p>Whether or not to perform checks on inputs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Medicare levy for individuals is imposed by the <em>Medicare Levy Act 1986</em> (Cth).
The function only calculates the levy for individuals (not trusts).
It includes the s 7 <em>Levy in cases of small incomes</em>, including the differences for those
eligible for <code><a href="#topic+sapto">sapto</a></code>.
s 8 <em>Amount of levy&mdash;person who has spouse or dependants</em> (though the number of dependants
is not a variable in the sample files).
</p>
<p>The function does <strong>not</strong> include the Medicare levy surcharge; it assumes that all 
persons (who would potentially be liable for it) avoided it.
</p>
<p>The Seniors and Pensioners Tax Offset was formed in 2012-13 as an amalgam
of the Senior Australians Tax Offset and the Pensions Tax Offset. 
Medicare rates before 2012-13 were different based on these offsets. 
For most taxpayers, eligibility would be based on whether your age is over the pension age (currently 65).
If <code>sato</code> and <code>pto</code> are <code>NULL</code>, <code>sapto.eligible</code> stands for eligibility for the <code>sato</code> and not <code>pto</code>.
If <code>sato</code> or <code>pto</code> are not <code>NULL</code> for such years, only <code>sato</code> is currently considered. 
Supplying <code>pto</code> independently is currently a warning.
</p>
<p>See <a href="http://classic.austlii.edu.au/au/legis/cth/consol_act/mla1986131/">http://classic.austlii.edu.au/au/legis/cth/consol_act/mla1986131/</a>
for the <em>Medicare Levy Act 1986</em> (Cth).
</p>


<h3>Value</h3>

<p>The Medicare levy payable for that taxpayer.
</p>

<hr>
<h2 id='model_income_tax'>Modelled Income Tax</h2><span id='topic+model_income_tax'></span>

<h3>Description</h3>

<p>The income tax payable if tax settings are changed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_income_tax(
  sample_file,
  baseline_fy,
  elasticity_of_taxable_income = NULL,
  ordinary_tax_thresholds = NULL,
  ordinary_tax_rates = NULL,
  medicare_levy_taper = NULL,
  medicare_levy_rate = NULL,
  medicare_levy_lower_threshold = NULL,
  medicare_levy_upper_threshold = NULL,
  medicare_levy_lower_sapto_threshold = NULL,
  medicare_levy_upper_sapto_threshold = NULL,
  medicare_levy_lower_family_threshold = NULL,
  medicare_levy_upper_family_threshold = NULL,
  medicare_levy_lower_family_sapto_threshold = NULL,
  medicare_levy_upper_family_sapto_threshold = NULL,
  medicare_levy_lower_up_for_each_child = NULL,
  lito_max_offset = NULL,
  lito_taper = NULL,
  lito_min_bracket = NULL,
  lito_multi = NULL,
  offsets = NULL,
  Budget2018_lamington = FALSE,
  Budget2019_lamington = NA,
  Budget2018_lito_202223 = FALSE,
  Budget2018_watr = FALSE,
  Budget2019_watr = FALSE,
  sapto_eligible = NULL,
  sapto_max_offset = NULL,
  sapto_lower_threshold = NULL,
  sapto_taper = NULL,
  sapto_max_offset_married = NULL,
  sapto_lower_threshold_married = NULL,
  sapto_taper_married = NULL,
  sbto_discount = NULL,
  cgt_discount_rate = NULL,
  calc_baseline_tax = TRUE,
  return. = c("sample_file", "tax", "sample_file.int"),
  clear_tax_cols = TRUE,
  warn_upper_thresholds = TRUE,
  .debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_income_tax_+3A_sample_file">sample_file</code></td>
<td>
<p>A sample file having at least as many variables as the 2012-13 sample file.</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_baseline_fy">baseline_fy</code></td>
<td>
<p>If a parameter is not selected, the parameter's value in this tax year is used.
</p>
<p>Must be a valid tax year and one for which <code>income_tax</code> has been programmed.</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_elasticity_of_taxable_income">elasticity_of_taxable_income</code></td>
<td>
<p>Either <code>NULL</code> (the default), or a numeric vector the same length of <code>sample_file</code> (or length-1) providing the elasticity of taxable income for each observation in <code>sample_file</code>; 
</p>
<p style="text-align: center;"><code class="reqn">\frac{\Delta z / z}{\Delta \tau / (1 - \tau)}</code>
</p>
 
<p>where <code class="reqn">z</code> is taxable income and <code class="reqn">\tau</code> is tax payable.
</p>
<p>For example, if, for a given taxpayer,
the tax settings would otherwise result in a 2% decrease of disposable income
under the tax settings to be modelled, and <code>elasticity_of_taxable_income</code> is set to 0.1,
the <code>Taxable_Income</code> is reduced by 0.2% before the tax rates are applied.
</p>
<p>If <code>NULL</code>, an elasticity of 0 is used.</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_ordinary_tax_thresholds">ordinary_tax_thresholds</code></td>
<td>
<p>A numeric vector specifying the lower bounds of the brackets for &quot;ordinary tax&quot; as defined by the Regulations.
The first element should be zero if there is a tax-free threshold.</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_ordinary_tax_rates">ordinary_tax_rates</code></td>
<td>
<p>The marginal rates of ordinary tax. The first element should be zero if there is a tax-free threshold. 
Since the temporary budget repair levy was imposed on a discrete tax bracket when it applied, it is not included in this function.</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_medicare_levy_taper">medicare_levy_taper</code></td>
<td>
<p>The taper that applies between the <code>_lower</code> and <code>_upper</code> thresholds.</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_medicare_levy_rate">medicare_levy_rate</code></td>
<td>
<p>The ordinary rate of the Medicare levy for taxable incomes above <code>medicare_levy_upper_threshold</code>.</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_medicare_levy_lower_threshold">medicare_levy_lower_threshold</code></td>
<td>
<p>Minimum taxable income at which the Medicare levy will be applied.</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_medicare_levy_upper_threshold">medicare_levy_upper_threshold</code></td>
<td>
<p>Minimum taxable income at which the Medicare levy will be applied at the full Medicare levy rate (2% in 2015-16). Between this threshold and the <code>medicare_levy_lower_threshold</code>, a tapered rate applies, starting from zero and climbing to <code>medicare_levy_rate</code>.</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_medicare_levy_lower_sapto_threshold">medicare_levy_lower_sapto_threshold</code>, <code id="model_income_tax_+3A_medicare_levy_upper_sapto_threshold">medicare_levy_upper_sapto_threshold</code></td>
<td>
<p>The equivalent values for SAPTO-eligible individuals (not families).</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_medicare_levy_lower_family_threshold">medicare_levy_lower_family_threshold</code>, <code id="model_income_tax_+3A_medicare_levy_upper_family_threshold">medicare_levy_upper_family_threshold</code></td>
<td>
<p>The equivalent values for families.</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_medicare_levy_lower_family_sapto_threshold">medicare_levy_lower_family_sapto_threshold</code>, <code id="model_income_tax_+3A_medicare_levy_upper_family_sapto_threshold">medicare_levy_upper_family_sapto_threshold</code></td>
<td>
<p>The equivalent values for SAPTO-eligible individuals in a family.</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_medicare_levy_lower_up_for_each_child">medicare_levy_lower_up_for_each_child</code></td>
<td>
<p>The amount to add to the <code>_family_threshold</code>s for each dependant child.</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_lito_max_offset">lito_max_offset</code></td>
<td>
<p>(deprecated) The maximum offset available for low incomes.</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_lito_taper">lito_taper</code></td>
<td>
<p>(deprecated) The taper to apply beyond <code>lito_min_bracket</code>.</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_lito_min_bracket">lito_min_bracket</code></td>
<td>
<p>(deprecated) The taxable income at which the value of the offset starts to reduce (from <code>lito_max_offset</code>).</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_lito_multi">lito_multi</code></td>
<td>
<p>No longer supported.</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_offsets">offsets</code></td>
<td>
<p>A list of lists created by <code><a href="#topic+set_offsets">set_offsets</a></code>. If
<code>NULL</code>, the default, the list is populated by the offsets
in <code>baseline_fy</code>.</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_budget2018_lamington">Budget2018_lamington</code></td>
<td>
<p>No longer supported</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_budget2019_lamington">Budget2019_lamington</code></td>
<td>
<p>No longer supported.</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_budget2018_lito_202223">Budget2018_lito_202223</code></td>
<td>
<p>No longer supported.</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_budget2018_watr">Budget2018_watr</code></td>
<td>
<p>No longer supported</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_budget2019_watr">Budget2019_watr</code></td>
<td>
<p>No longer supported.</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_sapto_eligible">sapto_eligible</code></td>
<td>
<p>Whether or not each taxpayer in <code>sample_file</code> is eligible for <code>SAPTO</code>. 
If <code>NULL</code>, the default, then eligibility is determined by <code>age_range</code> in <code>sample_file</code>;
<em>i.e.</em>, if <code>age_range &lt;= 1</code> then the taxpayer is assumed to be eligible for SAPTO.</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_sapto_max_offset">sapto_max_offset</code></td>
<td>
<p>The maximum offset available through SAPTO.</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_sapto_lower_threshold">sapto_lower_threshold</code></td>
<td>
<p>The threshold at which SAPTO begins to reduce (from <code>sapto_max_offset</code>).</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_sapto_taper">sapto_taper</code></td>
<td>
<p>The taper rate beyond <code>sapto_lower_threshold</code>.</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_sapto_max_offset_married">sapto_max_offset_married</code>, <code id="model_income_tax_+3A_sapto_lower_threshold_married">sapto_lower_threshold_married</code>, <code id="model_income_tax_+3A_sapto_taper_married">sapto_taper_married</code></td>
<td>
<p>As above,
but applied to members of a couple</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_sbto_discount">sbto_discount</code></td>
<td>
<p>The <code>tax_discount</code> in <code><a href="#topic+small_business_tax_offset">small_business_tax_offset</a></code>.</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_cgt_discount_rate">cgt_discount_rate</code></td>
<td>
<p>(numeric(1)) The capital gains tax discount rate, currently 50%.</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_calc_baseline_tax">calc_baseline_tax</code></td>
<td>
<p>(logical, default: <code>TRUE</code>) Should the income tax in <code>baseline_fy</code> be included as a column in the result?</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_return.">return.</code></td>
<td>
<p>What should the function return? One of <code>tax</code>, <code>sample_file</code>, or <code>sample_file.int</code>. 
If <code>tax</code>, the tax payable under the settings; if <code>sample_file</code>, the <code>sample_file</code>,
but with variables <code>tax</code> and possibly <code>new_taxable_income</code>; if <code>sample_file.int</code>, same as <code>sample_file</code> but <code>new_tax</code> is coerced to integer.</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_clear_tax_cols">clear_tax_cols</code></td>
<td>
<p>If <code>TRUE</code>, the default, then <code>return. = sample_file</code> implies any columns called <code>new_tax</code> or <code>baseline_tax</code> in <code>sample_file</code> are dropped silently.</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_warn_upper_thresholds">warn_upper_thresholds</code></td>
<td>
<p>If <code>TRUE</code>, the default, then any inconsistency between <code>baseline_fy</code> and the upper thresholds result in a warning. Set to <code>FALSE</code>, if the <code>lower_threshold</code>s may take priority.</p>
</td></tr>
<tr><td><code id="model_income_tax_+3A_.debug">.debug</code></td>
<td>
<p>Return a data.table of <code>new_tax</code>. Experimental so cannot be relied in future versions.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(data.table)
library(hutils)

# With new tax-free threshold of $20,000:
# if (requireNamespace("taxstats", quietly = TRUE) &amp;&amp; FALSE) {
# library(taxstats)
# library(magrittr)
#    
# model_income_tax(sample_file_1314,
#                  "2013-14",
#                  ordinary_tax_thresholds = c(0, 20e3, 37e3, 80e3, 180e3)) %&gt;%
 #   select_grep("tax", "Taxable_Income")
#
# }

</code></pre>

<hr>
<h2 id='model_new_caps_and_div293'>Modelling superannuation changes</h2><span id='topic+model_new_caps_and_div293'></span><span id='topic+n_affected_from_new_cap_and_div293'></span><span id='topic+revenue_from_new_cap_and_div293'></span>

<h3>Description</h3>

<p>Model changes to the contributions cap, Division 293 threshold 
and related modelling. Note: defaults are relevant to pre-2017 for 
compatibility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_new_caps_and_div293(
  .sample.file,
  fy.year,
  new_cap = 30000,
  new_cap2 = 35000,
  new_age_based_cap = TRUE,
  new_cap2_age = 49,
  new_ecc = FALSE,
  new_contr_tax = "15%",
  new_div293_threshold = 3e+05,
  use_other_contr = FALSE,
  scale_contr_match_ato = FALSE,
  .lambda = 0,
  reweight_late_lodgers = TRUE,
  .mu = 1.05,
  impute_zero_concess_contr = TRUE,
  .min.Sw.for.SG = 450 * 12,
  .SG_rate = 0.0925,
  prv_cap = 30000,
  prv_cap2 = 35000,
  prv_age_based_cap = TRUE,
  prv_cap2_age = 49,
  prv_ecc = FALSE,
  prv_div293_threshold = 3e+05
)

n_affected_from_new_cap_and_div293(..., adverse_only = TRUE)

revenue_from_new_cap_and_div293(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_new_caps_and_div293_+3A_.sample.file">.sample.file</code></td>
<td>
<p>A <code>data.table</code> whose variables include those in <code>taxstats::sample_file_1314</code>.</p>
</td></tr>
<tr><td><code id="model_new_caps_and_div293_+3A_fy.year">fy.year</code></td>
<td>
<p>The financial year tax scales.</p>
</td></tr>
<tr><td><code id="model_new_caps_and_div293_+3A_new_cap">new_cap</code></td>
<td>
<p>The <strong>proposed</strong> cap on concessional contributions for all taxpayers if <code>age_based_cap</code> is FALSE, or for those below the age threshold otherwise.</p>
</td></tr>
<tr><td><code id="model_new_caps_and_div293_+3A_new_cap2">new_cap2</code></td>
<td>
<p>The <strong>proposed</strong> cap on concessional contributions for those above the age threshold. No effect if <code>age_based_cap</code> is FALSE.</p>
</td></tr>
<tr><td><code id="model_new_caps_and_div293_+3A_new_age_based_cap">new_age_based_cap</code></td>
<td>
<p>Is the <strong>proposed</strong> cap on concessional contributions age-based?</p>
</td></tr>
<tr><td><code id="model_new_caps_and_div293_+3A_new_cap2_age">new_cap2_age</code></td>
<td>
<p>The age above which <code>new_cap2</code> applies.</p>
</td></tr>
<tr><td><code id="model_new_caps_and_div293_+3A_new_ecc">new_ecc</code></td>
<td>
<p>(logical) Should an excess concessional contributions charge be calculated? (Not implemented.)</p>
</td></tr>
<tr><td><code id="model_new_caps_and_div293_+3A_new_contr_tax">new_contr_tax</code></td>
<td>
<p>A string to determine the contributions tax.</p>
</td></tr>
<tr><td><code id="model_new_caps_and_div293_+3A_new_div293_threshold">new_div293_threshold</code></td>
<td>
<p>The <strong>proposed</strong> Division 293 threshold.</p>
</td></tr>
<tr><td><code id="model_new_caps_and_div293_+3A_use_other_contr">use_other_contr</code></td>
<td>
<p>Should <code>MCS_Othr_Contr</code> be used to calculate Division 293 liabilities?</p>
</td></tr>
<tr><td><code id="model_new_caps_and_div293_+3A_scale_contr_match_ato">scale_contr_match_ato</code></td>
<td>
<p>(logical) Should concessional contributions be inflated to match aggregates in 2013-14? That is, should the concessional contributions by multiplied by the internal constant <code>grattan:::super_contribution_inflator_1314</code>, which was defined to be: </p>
<p style="text-align: center;"><code class="reqn">\frac{\textrm{Total assessable contributions in SMSF and funds}}{\textrm{Total contributions in 2013-14 sample file}}</code>
</p>
<p>.</p>
</td></tr>
<tr><td><code id="model_new_caps_and_div293_+3A_.lambda">.lambda</code></td>
<td>
<p>Scalar weight applied to <code>concessional contributions</code>. <code class="reqn">\lambda = 0</code> means no (extra) weight. <code class="reqn">\lambda = 1</code> means contributions are inflated by the ratio of aggregates to the sample file's total. For <code class="reqn">R = \textrm{actual} / \textrm{apparent}</code> then the contributions are scaled by <code class="reqn">1 + \lambda(R - 1)</code>.</p>
</td></tr>
<tr><td><code id="model_new_caps_and_div293_+3A_reweight_late_lodgers">reweight_late_lodgers</code></td>
<td>
<p>(logical) Should WEIGHT be inflated to account for late lodgers?</p>
</td></tr>
<tr><td><code id="model_new_caps_and_div293_+3A_.mu">.mu</code></td>
<td>
<p>Scalar weight for WEIGHT. (<code class="reqn">w' = \mu w</code>) No effect if <code>reweight_late_lodgers</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="model_new_caps_and_div293_+3A_impute_zero_concess_contr">impute_zero_concess_contr</code></td>
<td>
<p>Should zero concessional contributions be imputed using salary?</p>
</td></tr>
<tr><td><code id="model_new_caps_and_div293_+3A_.min.sw.for.sg">.min.Sw.for.SG</code></td>
<td>
<p>The minimum salary required for super guarantee to be imputed.</p>
</td></tr>
<tr><td><code id="model_new_caps_and_div293_+3A_.sg_rate">.SG_rate</code></td>
<td>
<p>The super guarantee rate for imputation.</p>
</td></tr>
<tr><td><code id="model_new_caps_and_div293_+3A_prv_cap">prv_cap</code></td>
<td>
<p>The <strong>comparator</strong> cap on concessional contributions for all taxpayers if <code>age_based_cap</code> is FALSE, or for those below the age threshold otherwise.</p>
</td></tr>
<tr><td><code id="model_new_caps_and_div293_+3A_prv_cap2">prv_cap2</code></td>
<td>
<p>The <strong>comparator</strong> cap on concessional contributions for those above the age threshold. No effect if <code>age_based_cap</code> is FALSE.</p>
</td></tr>
<tr><td><code id="model_new_caps_and_div293_+3A_prv_age_based_cap">prv_age_based_cap</code></td>
<td>
<p>Is the <strong>comparator</strong> cap on concessional contributions age-based?</p>
</td></tr>
<tr><td><code id="model_new_caps_and_div293_+3A_prv_cap2_age">prv_cap2_age</code></td>
<td>
<p>The age above which <code>new_cap2</code> applies.</p>
</td></tr>
<tr><td><code id="model_new_caps_and_div293_+3A_prv_ecc">prv_ecc</code></td>
<td>
<p>(logical) Should an excess concessional contributions charge be calculated? (Not implemented.)</p>
</td></tr>
<tr><td><code id="model_new_caps_and_div293_+3A_prv_div293_threshold">prv_div293_threshold</code></td>
<td>
<p>The <strong>comparator</strong> Division 293 threshold.</p>
</td></tr>
<tr><td><code id="model_new_caps_and_div293_+3A_...">...</code></td>
<td>
<p>Passed to <code>model_new_caps_and_div293</code>.</p>
</td></tr>
<tr><td><code id="model_new_caps_and_div293_+3A_adverse_only">adverse_only</code></td>
<td>
<p>Count only individuals who are adversely affected by the change.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>model_new_caps_and_div293</code>, a <code>data.frame</code>, comprising 
the variables in <code>.sample.file</code>, the superannuation variables generated by 
<code>apply_super_caps_and_div293</code>, and two variables, <code>prv_revenue</code> and <code>new_revenue</code>,
which give the tax (income tax, super tax, and division 293 tax) payable by 
that taxpayer in the comparator scenario and the proposed scenario, respectively.
</p>
<p>For <code>n_affected_from_new_cap_and_div293</code>, the number of individuals affected by the proposed changes.
</p>
<p>For <code>revenue_from_new_cap_and_div293</code>, the extra revenue expected from the proposed changes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# if (requireNamespace("taxstats", quietly = TRUE)) {
#   library(data.table)
#   s1314 &lt;- taxstats::sample_file_1314
#   s1314[, WEIGHT := 50L]
#   revenue_from_new_cap_and_div293(s1314, new_cap = 12e3, "2016-17")
#   revenue_from_new_cap_and_div293(s1314, new_contr_tax = "mr - 15%", "2016-17")
# }


</code></pre>

<hr>
<h2 id='npv'>Financial functions</h2><span id='topic+npv'></span><span id='topic+irr'></span><span id='topic+fv'></span><span id='topic+pv'></span><span id='topic+pmt'></span><span id='topic++5Curl+7Bhttp+3A+2F+2Fcvs.moodle.org+2Fcontrib+2Fpatches+2Fquestion_calculated_extended+2Fcalculated+2Fpackages+2Ffinancial+2Ffinancial_class.php+3Fview+3Dco+7D'></span>

<h3>Description</h3>

<p>Financial functions from Excel. These functions are equivalent to the Excel functions of the same name (in uppercase).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npv(rate, values)

irr(x, start = 0.1)

fv(rate, nper, pmt, pv = 0, type = 0)

pv(rate, nper, pmt, fv = 0, type = 0)

pmt(rate, nper, pv, fv = 0, type = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="npv_+3A_rate">rate</code></td>
<td>
<p>Discount or interest rate.</p>
</td></tr>
<tr><td><code id="npv_+3A_values">values</code></td>
<td>
<p>Income stream.</p>
</td></tr>
<tr><td><code id="npv_+3A_x">x</code></td>
<td>
<p>Cash flow.</p>
</td></tr>
<tr><td><code id="npv_+3A_start">start</code></td>
<td>
<p>Initial guess to start the iterative process.</p>
</td></tr>
<tr><td><code id="npv_+3A_nper">nper</code></td>
<td>
<p>Number of periods</p>
</td></tr>
<tr><td><code id="npv_+3A_pmt">pmt</code></td>
<td>
<p>Payments.</p>
</td></tr>
<tr><td><code id="npv_+3A_pv">pv</code></td>
<td>
<p>Present value.</p>
</td></tr>
<tr><td><code id="npv_+3A_type">type</code></td>
<td>
<p>Factor.</p>
</td></tr>
<tr><td><code id="npv_+3A_fv">fv</code></td>
<td>
<p>Future value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Enrique Garcia M. <a href="mailto:egarcia@egm.as">egarcia@egm.as</a>
</p>
<p>Karsten W. <a href="mailto:k.weinert@gmx.net">k.weinert@gmx.net</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>npv(0.07, c(1, 2))
irr(x = c(1, -1), start = 0.1)
fv(0.04, 7, 1, pv = 0.0, type = 0)
pv(rate = 0.08, nper = 7, pmt = 1, fv = 0.0, type = 0)
pmt(rate = 0.025, nper = 7, pv = 0, fv = 0.0, type = 0)
</code></pre>

<hr>
<h2 id='progressivity'>Compute the progressivity</h2><span id='topic+progressivity'></span>

<h3>Description</h3>

<p>Compute the progressivity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>progressivity(income, tax, measure = c("Reynolds-Smolensky", "Kakwani"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="progressivity_+3A_income">income</code></td>
<td>
<p>Pre-tax income.</p>
</td></tr>
<tr><td><code id="progressivity_+3A_tax">tax</code></td>
<td>
<p>Tax paid.</p>
</td></tr>
<tr><td><code id="progressivity_+3A_measure">measure</code></td>
<td>
<p>Currently, only &quot;Reynolds-Smolensky&quot; progressivity is calculated:
</p>
<p style="text-align: center;"><code class="reqn">G_Y - G_Z</code>
</p>
<p> where <code class="reqn">G_Y</code> is the Gini coefficient of <code>income</code>
and <code class="reqn">G_X</code> is the Gini coefficient of post-tax income.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The progressivity measure. Positive for progressive tax systems, and higher the
value the more progressive the system.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
I &lt;- c(10e3, 20e3, 50e3, 100e3, 150e3)
progressivity(I, 0.3 * I) # zero
progressivity(I, income_tax(I, "2017-18"))

</code></pre>

<hr>
<h2 id='prohibit_length0_vectors'>Prohibit zero lengths</h2><span id='topic+prohibit_length0_vectors'></span>

<h3>Description</h3>

<p>Tests whether any vectors have zero length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prohibit_length0_vectors(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prohibit_length0_vectors_+3A_...">...</code></td>
<td>
<p>A list of vectors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An error message if any of the vectors <code>...</code> have zero length.
</p>

<hr>
<h2 id='prohibit_unequal_length_vectors'>Prohibit unequal length vectors</h2><span id='topic+prohibit_unequal_length_vectors'></span>

<h3>Description</h3>

<p>Tests whether all vectors have the same length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prohibit_unequal_length_vectors(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prohibit_unequal_length_vectors_+3A_...">...</code></td>
<td>
<p>Vectors to test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An error message unless all of <code>...</code> have the same length in which case <code>NULL</code>, invisibly.
</p>

<hr>
<h2 id='project'>Simple projections of the annual 2% samples of Australian Taxation Office tax returns.</h2><span id='topic+project'></span>

<h3>Description</h3>

<p>Simple projections of the annual 2% samples of Australian Taxation Office tax returns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project(
  sample_file,
  h = 0L,
  fy.year.of.sample.file = NULL,
  WEIGHT = 50L,
  excl_vars = NULL,
  forecast.dots = list(estimator = "mean", pred_interval = 80),
  wage.series = NULL,
  lf.series = NULL,
  use_age_pop_forecast = FALSE,
  .recalculate.inflators = NA,
  .copyDT = TRUE,
  check_fy_sample_file = TRUE,
  differentially_uprate_Sw = NA,
  r_super_balance = 1.05,
  r_generic = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project_+3A_sample_file">sample_file</code></td>
<td>
<p>A <code>data.table</code> matching a 2% sample file from the ATO.
See package <code>taxstats</code> for an example.</p>
</td></tr>
<tr><td><code id="project_+3A_h">h</code></td>
<td>
<p>An integer. How many years should the sample file be projected?</p>
</td></tr>
<tr><td><code id="project_+3A_fy.year.of.sample.file">fy.year.of.sample.file</code></td>
<td>
<p>The financial year of <code>sample_file</code>. If <code>NULL</code>, the default, the number is inferred from the 
number of rows of <code>sample_file</code> to be one of <code>2012-13</code>, <code>2013-14</code>, <code>2014-15</code>, <code>2015-16</code>, or <code>2016-17</code>.</p>
</td></tr>
<tr><td><code id="project_+3A_weight">WEIGHT</code></td>
<td>
<p>The sample weight for the sample file. (So a 2% file has <code>WEIGHT</code> = 50.)</p>
</td></tr>
<tr><td><code id="project_+3A_excl_vars">excl_vars</code></td>
<td>
<p>A character vector of column names in <code>sample_file</code> that should not be inflated. Columns not present in the 2013-14 sample file are not inflated and nor are the columns <code>Ind</code>, <code>Gender</code>, <code>age_range</code>, <code>Occ_code</code>, <code>Partner_status</code>, <code>Region</code>, <code>Lodgment_method</code>, and <code>PHI_Ind</code>.</p>
</td></tr>
<tr><td><code id="project_+3A_forecast.dots">forecast.dots</code></td>
<td>
<p>A list containing parameters to be passed to <code>generic_inflator</code>.</p>
</td></tr>
<tr><td><code id="project_+3A_wage.series">wage.series</code></td>
<td>
<p>See <code><a href="#topic+wage_inflator">wage_inflator</a></code>. Note that the <code>Sw_amt</code>
will uprated by <code><a href="#topic+differentially_uprate_wage">differentially_uprate_wage</a></code> (if requested).</p>
</td></tr>
<tr><td><code id="project_+3A_lf.series">lf.series</code></td>
<td>
<p>See <code><a href="#topic+lf_inflator_fy">lf_inflator_fy</a></code>.</p>
</td></tr>
<tr><td><code id="project_+3A_use_age_pop_forecast">use_age_pop_forecast</code></td>
<td>
<p>Should the inflation of the number of taxpayers be 
moderated by the number of resident persons born in a certain year? If <code>TRUE</code>,
younger ages will grow at a slightly higher rate beyond 2018 than older ages.</p>
</td></tr>
<tr><td><code id="project_+3A_.recalculate.inflators">.recalculate.inflators</code></td>
<td>
<p>(logical, default: <code>NA</code>). 
Should <code>generic_inflator()</code> or <code>CG_inflator</code> be called to project the other variables? Adds time.
Default <code>NA</code> means <code>TRUE</code> if the pre-calculated inflators are available,
<code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="project_+3A_.copydt">.copyDT</code></td>
<td>
<p>(logical, default: <code>TRUE</code>) Should a <code>copy()</code> of <code>sample_file</code> be made?
If set to <code>FALSE</code>, will update <code>sample_file</code> in place, which may
be necessary when memory is constrained, but is dangerous as it modifies the
original data and its projection. (So if you run the same code twice you 
may end up with a projection <code>2h</code> years ahead, not <code>h</code> years.)</p>
</td></tr>
<tr><td><code id="project_+3A_check_fy_sample_file">check_fy_sample_file</code></td>
<td>
<p>(logical, default: <code>TRUE</code>) 
Should <code>fy.year.of.sample.file</code> be checked against <code>sample_file</code>?
By default, <code>TRUE</code>, an error is raised if the base is not 2012-13, 2013-14, 2014-15, 2015-16, 2016-17,
or 2017-18,
and a warning is raised if the 
number of rows in <code>sample_file</code> is different to the known number of rows in the sample files.</p>
</td></tr>
<tr><td><code id="project_+3A_differentially_uprate_sw">differentially_uprate_Sw</code></td>
<td>
<p>(logical, default: <code>NA</code>) 
Should the salary and wage column (<code>Sw_amt</code>) be differentially uprated 
using (<code><a href="#topic+differentially_uprate_wage">differentially_uprate_wage</a></code>)? Default of <code>NA</code> means
use differential uprating is used when <code>fy.year.of.sample.file &lt;= "2016-17"</code>.
It is known that the Treasury stopped using differential uprating by 2019.
</p>
<p>Selecting <code>TRUE</code> for <code>fy.year.of.sample.file &gt; "2016-17"</code> is an 
error as the precalculated values are not available.</p>
</td></tr>
<tr><td><code id="project_+3A_r_super_balance">r_super_balance</code></td>
<td>
<p>The factor to inflate super balances by (annualized).
Set to <code>1.05</code> for backwards compatibility. The annual superannuation 
bulletin of June 2019 from APRA reported 7.3% growth of funds with more than
fund members over the previous 5 years and 7.9% growth over the 
previous ten years.</p>
</td></tr>
<tr><td><code id="project_+3A_r_generic">r_generic</code></td>
<td>
<p>(Present from version 2024.1.0) The factor to inflate other
columns. Subject to change in future versions. If <code>NULL</code>, the default,
an internal factor is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently components of taxable income are individually inflated 
based on their historical trends in the ATO sample files, with the 
exception of:
</p>

<dl>
<dt>inflated using <code><a href="#topic+differentially_uprate_wage">differentially_uprate_wage</a></code>.</dt><dd><p><code>Sw_amt</code></p>
</dd>
<dt>inflated using <code><a href="#topic+wage_inflator">wage_inflator</a></code></dt><dd><p><code>Alow_ben_amt</code>, <code>ETP_txbl_amt</code>, <code>Rptbl_Empr_spr_cont_amt</code>, <code>Non_emp_spr_amt</code>, <code>MCS_Emplr_Contr</code>, <code>MCS_Prsnl_Contr</code>, <code>MCS_Othr_Contr</code></p>
</dd>
<dt>inflated using <code><a href="#topic+cpi_inflator">cpi_inflator</a></code></dt><dd><p><code>WRE_car_amt</code>, <code>WRE_trvl_amt</code>, <code>WRE_uniform_amt</code>, <code>WRE_self_amt</code>, <code>WRE_other_amt</code></p>
</dd>
<dt>inflated by <code><a href="#topic+lf_inflator_fy">lf_inflator_fy</a></code></dt><dd><p><code>WEIGHT</code></p>
</dd>
<dt>inflated by <code><a href="#topic+CG_inflator">CG_inflator</a></code></dt><dd><p><code>Net_CG_amt</code>, <code>Tot_CY_CG_amt</code></p>
</dd>
</dl>

<p>Superannuation balances are inflated by a fixed rate of 5% p.a.
</p>
<p>We recommend you use <code>sample_file_1213</code> over <code>sample_file_1314</code>,
unless you need the superannuation variables, 
as the latter suggests lower-than-recorded tax collections. 
However, more recent data is of course preferable.
</p>


<h3>Value</h3>

<p>A sample file with the same number of rows as <code>sample_file</code> but 
with inflated values as a forecast for the sample file in <code>to_fy</code>. 
If <code>WEIGHT</code> is not already a column of <code>sample_file</code>, it will be added and its sum
will be the predicted number of taxpayers in <code>to_fy</code>.
</p>

<hr>
<h2 id='project_to'>Simple projections of the annual 2% samples of Australian Taxation Office tax returns.</h2><span id='topic+project_to'></span>

<h3>Description</h3>

<p>Simple projections of the annual 2% samples of Australian Taxation Office tax returns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project_to(sample_file, to_fy, fy.year.of.sample.file = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project_to_+3A_sample_file">sample_file</code></td>
<td>
<p>A <code>data.table</code> matching a 2% sample file from the ATO.
See package <code>taxstats</code> for an example.</p>
</td></tr>
<tr><td><code id="project_to_+3A_to_fy">to_fy</code></td>
<td>
<p>A string like &quot;1066-67&quot; representing the financial year for which forecasts of the sample file are desired.</p>
</td></tr>
<tr><td><code id="project_to_+3A_fy.year.of.sample.file">fy.year.of.sample.file</code></td>
<td>
<p>The financial year of <code>sample_file</code>. See <code><a href="#topic+project">project</a></code> for the default.</p>
</td></tr>
<tr><td><code id="project_to_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+project">project</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sample file with the same number of rows as <code>sample_file</code> but 
with inflated values as a forecast for the sample file in <code>to_fy</code>. 
If <code>WEIGHT</code> is not already a column of <code>sample_file</code>, it will be added and its sum
will be the predicted number of taxpayers in <code>to_fy</code>.
</p>

<hr>
<h2 id='rebate_income'>Rebate income</h2><span id='topic+rebate_income'></span>

<h3>Description</h3>

<p>Rebate income
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rebate_income(
  Taxable_Income,
  Rptbl_Empr_spr_cont_amt = 0,
  All_deductible_super_contr = 0,
  Net_fincl_invstmt_lss_amt = 0,
  Net_rent_amt = 0,
  Rep_frng_ben_amt = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rebate_income_+3A_taxable_income">Taxable_Income</code></td>
<td>
<p>the taxable income</p>
</td></tr>
<tr><td><code id="rebate_income_+3A_rptbl_empr_spr_cont_amt">Rptbl_Empr_spr_cont_amt</code></td>
<td>
<p>The reportable employer superannuation contributions amount</p>
</td></tr>
<tr><td><code id="rebate_income_+3A_all_deductible_super_contr">All_deductible_super_contr</code></td>
<td>
<p>deductible personal superannuation contributions</p>
</td></tr>
<tr><td><code id="rebate_income_+3A_net_fincl_invstmt_lss_amt">Net_fincl_invstmt_lss_amt</code></td>
<td>
<p>Net financial investment loss</p>
</td></tr>
<tr><td><code id="rebate_income_+3A_net_rent_amt">Net_rent_amt</code></td>
<td>
<p>(for Rental deductions)</p>
</td></tr>
<tr><td><code id="rebate_income_+3A_rep_frng_ben_amt">Rep_frng_ben_amt</code></td>
<td>
<p>Reportable fringe-benefits</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Original URL was https://www.ato.gov.au/Individuals/Tax-return/2015/Tax-return/Tax-offset-questions-T1-T2/Rebate-income-2015/
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+cpi_inflator'></span><span id='topic+mutate_ntile'></span><span id='topic+pmaxC'></span><span id='topic+pmax3'></span><span id='topic+pminC'></span><span id='topic+pmaxV'></span><span id='topic+pminV'></span><span id='topic+wage_inflator'></span><span id='topic+weighted_ntile'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>grattanInflators</dt><dd><p><code><a href="grattanInflators.html#topic+cpi_inflator">cpi_inflator</a></code>, <code><a href="grattanInflators.html#topic+wage_inflator">wage_inflator</a></code></p>
</dd>
<dt>hutils</dt><dd><p><code><a href="hutils.html#topic+mutate_ntile">mutate_ntile</a></code>, <code><a href="hutils.html#topic+weighted_ntile">weighted_ntile</a></code></p>
</dd>
<dt>hutilscpp</dt><dd><p><code><a href="hutilscpp.html#topic+pmaxC">pmax3</a></code>, <code><a href="hutilscpp.html#topic+pmaxC">pmaxC</a></code>, <code><a href="hutilscpp.html#topic+pmaxC">pmaxV</a></code>, <code><a href="hutilscpp.html#topic+pmaxC">pminC</a></code>, <code><a href="hutilscpp.html#topic+pmaxC">pminV</a></code></p>
</dd>
</dl>

<hr>
<h2 id='require_taxstats'>Attach a 'taxstats' package</h2><span id='topic+require_taxstats'></span><span id='topic+require_taxstats1516'></span>

<h3>Description</h3>

<p>Used in lieu of simply <code>library(taxstats)</code> to 
handle cases where it is not installed, but should not be installed
to the user's default library (as during CRAN checks).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>require_taxstats()

require_taxstats1516()
</code></pre>


<h3>Value</h3>

<p><code>TRUE</code>, invisibly, for success. Used for its side-effect: attaching the taxstats 
package.
</p>

<hr>
<h2 id='residential_property_prices'>Residential property prices in Australia</h2><span id='topic+residential_property_prices'></span>

<h3>Description</h3>

<p>Residential property prices indexes for the capital cities of Australia, and a weighted average for the whole country. Last updated 2018-07-06.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residential_property_prices
</code></pre>


<h3>Format</h3>

<p>A <code>data.table</code> of three columns and 522 observations:
</p>

<dl>
<dt>Date</dt><dd><p>Date of the index</p>
</dd>
<dt>City</dt><dd><p>Capital city (or <code>Australia (weighted average)</code>)</p>
</dd>
<dt>Residential_property_price_index</dt><dd><p>An index (100 = 2011-12-01) measuring the price change in all residential dwellings.</p>
</dd>
</dl>



<h3>Source</h3>

<p>ABS Cat 6416.0. <a href="https://www.abs.gov.au/statistics/economy/price-indexes-and-inflation/residential-property-price-indexes-eight-capital-cities/latest-release">https://www.abs.gov.au/statistics/economy/price-indexes-and-inflation/residential-property-price-indexes-eight-capital-cities/latest-release</a>.
</p>

<hr>
<h2 id='revenue_foregone'>Revenue foregone from a modelled sample file</h2><span id='topic+revenue_foregone'></span>

<h3>Description</h3>

<p>Revenue foregone from a modelled sample file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>revenue_foregone(dt, revenue_positive = TRUE, digits = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="revenue_foregone_+3A_dt">dt</code></td>
<td>
<p>A <code>data.table</code> from <code><a href="#topic+model_income_tax">model_income_tax</a></code>.</p>
</td></tr>
<tr><td><code id="revenue_foregone_+3A_revenue_positive">revenue_positive</code></td>
<td>
<p>If <code>TRUE</code>, the default, tax increase (revenue) is positive and tax cuts are negative.</p>
</td></tr>
<tr><td><code id="revenue_foregone_+3A_digits">digits</code></td>
<td>
<p>If not <code>NULL</code>, affects the print method of the value.</p>
</td></tr>
</table>

<hr>
<h2 id='sapto'>Seniors and Pensioner Tax Offset</h2><span id='topic+sapto'></span>

<h3>Description</h3>

<p>Seniors and Pensioner Tax Offset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sapto(
  rebate_income,
  fy.year,
  fill = 0,
  sapto.eligible = TRUE,
  Spouse_income = 0,
  family_status = "single",
  on_sapto_cd = "A",
  .check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sapto_+3A_rebate_income">rebate_income</code></td>
<td>
<p>The rebate income of the individual.</p>
</td></tr>
<tr><td><code id="sapto_+3A_fy.year">fy.year</code></td>
<td>
<p>The financial year in which sapto is to be calculated.</p>
</td></tr>
<tr><td><code id="sapto_+3A_fill">fill</code></td>
<td>
<p>If SAPTO was not applicable, what value should be used?</p>
</td></tr>
<tr><td><code id="sapto_+3A_sapto.eligible">sapto.eligible</code></td>
<td>
<p>Is the individual eligible for sapto?</p>
</td></tr>
<tr><td><code id="sapto_+3A_spouse_income">Spouse_income</code></td>
<td>
<p>Spouse income whose unutilized SAPTO may be added to the current taxpayer. Must match <code>family_status</code>; i.e. can only be nonzero when <code>family_status != "single"</code>.</p>
</td></tr>
<tr><td><code id="sapto_+3A_family_status">family_status</code></td>
<td>
<p>Family status of the individual.</p>
</td></tr>
<tr><td><code id="sapto_+3A_on_sapto_cd">on_sapto_cd</code></td>
<td>
<p>SAPTO claim code type (for non-veterans). A 
letter A-E. A = single, B = lived apart due to illness and spouse was eligible,
C = lived apart but spouse ineligible, D = lived together, both eligible for sapto, 
E = lived together, spouse ineligible. Only <code>"A"</code> and <code>"D"</code> are supported.</p>
</td></tr>
<tr><td><code id="sapto_+3A_.check">.check</code></td>
<td>
<p>Run checks for consistency of values. For example, ensuring no 
single individuals have positive <code>Spouse_income</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='set_offset'>Set offsets</h2><span id='topic+set_offset'></span><span id='topic+set_offsets'></span><span id='topic+the_MAX_N_OFFSETN'></span>

<h3>Description</h3>

<p>Create parameters for tax offsets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_offset(
  offset_1st = integer(1),
  thresholds = integer(),
  tapers = double(),
  refundable = logical(1)
)

set_offsets(
  ...,
  yr = NULL,
  lito_max_offset = NULL,
  lito_taper = NULL,
  lito_min_bracket = NULL,
  lito_multi = NULL
)

the_MAX_N_OFFSETN()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_offset_+3A_offset_1st">offset_1st</code></td>
<td>
<p><code>integer(1)</code> The offset available for zero income.</p>
</td></tr>
<tr><td><code id="set_offset_+3A_thresholds">thresholds</code></td>
<td>
<p><code>integer(N)</code> An sorted integer vector, the thresholds
above which each taper applies.</p>
</td></tr>
<tr><td><code id="set_offset_+3A_tapers">tapers</code></td>
<td>
<p><code>double(N)</code> The tapers above each <code>threshold</code>. Positive
tapers mean that the offset reduces for every dollar above the corresponding
threshold.</p>
</td></tr>
<tr><td><code id="set_offset_+3A_refundable">refundable</code></td>
<td>
<p><code>bool(1)</code> If <code>FALSE</code>, the default, offsets are 
non-refundable, meaning that the offset cannot reduce the tax below zero.</p>
</td></tr>
<tr><td><code id="set_offset_+3A_...">...</code></td>
<td>
<p>A set of offsets created by <code>set_offset</code>. May not exceed
<code>the_MAX_N_OFFSETN()</code>.</p>
</td></tr>
<tr><td><code id="set_offset_+3A_yr">yr</code></td>
<td>
<p><code>NULL / integer(1)</code> If <code>NULL</code>, only the offsets created
by <code>...</code> are used. Otherwise, inherits offsets (such as LITO and LMITO)
from the corresponding year.</p>
</td></tr>
<tr><td><code id="set_offset_+3A_lito_max_offset">lito_max_offset</code>, <code id="set_offset_+3A_lito_taper">lito_taper</code>, <code id="set_offset_+3A_lito_min_bracket">lito_min_bracket</code>, <code id="set_offset_+3A_lito_multi">lito_multi</code></td>
<td>
<p>deprecated
arguments to adjust (single-threshold) LITO.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><code>set_offset</code></dt><dd><p>A list of four elements, <code>offset_1st</code>, 
<code>thresholds</code>, <code>tapers</code>, <code>refundable</code>.</p>
</dd>
<dt><code>set_offsets</code></dt><dd><p>A list of lists created by <code>set_offset</code>.</p>
</dd>
<dt><code>the_MAX_N_OFFSETN</code></dt><dd><p>The maximum number of offsets that may be used.</p>
</dd>
</dl>


<hr>
<h2 id='small_business_tax_offset'>Small Business Tax Offset</h2><span id='topic+small_business_tax_offset'></span>

<h3>Description</h3>

<p>Small Business Tax Offset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>small_business_tax_offset(
  taxable_income,
  basic_income_tax_liability,
  .dots.ATO = NULL,
  aggregated_turnover = NULL,
  total_net_small_business_income = NULL,
  fy_year = NULL,
  tax_discount = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="small_business_tax_offset_+3A_taxable_income">taxable_income</code></td>
<td>
<p>Individual's assessable income.</p>
</td></tr>
<tr><td><code id="small_business_tax_offset_+3A_basic_income_tax_liability">basic_income_tax_liability</code></td>
<td>
<p>Tax liability (in dollars) according to the method in the box in s 4.10(3) of the <em>Income Tax Assessment Act 1997</em> (Cth). In general, <code>basic_income_tax_liability</code> is the ordinary tax minus offsets. In particular, it does not include levies (such as the Medicare levy or the Temporary Budget Repair Levy). 

For example, in 2015-16, an individual with an assessable income of 100,000 had a basic tax liability of 
approximately 25,000.</p>
</td></tr>
<tr><td><code id="small_business_tax_offset_+3A_.dots.ato">.dots.ATO</code></td>
<td>
<p>A <code>data.table</code> of tax returns.
If provided, it must contain the variables
<code>Total_PP_BE_amt</code>,
<code>Total_PP_BI_amt</code>,
<code>Total_NPP_BE_amt</code>,
<code>Total_NPP_BI_amt</code>.
If both <code>.dots.ATO</code> and either <code>aggregated_turnover</code> or <code>total_net_small_business_income</code> are provided, 
<code>.dots.ATO</code> takes precedence, with a warning.
</p>
<p>If <code>.dots.ATO</code> contains the variable <code>Tot_net_small_business_inc</code>, it is used instead of the income variables.</p>
</td></tr>
<tr><td><code id="small_business_tax_offset_+3A_aggregated_turnover">aggregated_turnover</code></td>
<td>
<p>A numeric vector the same length as <code>taxable_income</code>.
Only used to determine whether or not the offset is applicable; that is, the offset only
applies if aggregated turnover is less than 2 million.
</p>
<p>Aggregated turnover of a taxpayer is the sum of the following:
</p>

<ul>
<li><p>the taxpayer's annual turnover for the income year,
</p>
</li>
<li><p>the annual turnover of any entity connected with the taxpayer's, for that part of the income year that the entity is connected with the taxpayer's
</p>
</li>
<li><p>the annual turnover of any entity that is an affiliate of the taxpayer, for that part of the income year that the entity is affiliated with the taxpayer's
</p>
</li>
<li><p>When you calculate aggregated turnover for an income year, do not include either:
</p>

<ul>
<li><p>the annual turnover of other entities for any period of time that the entities are either not connected with the taxpayer or are not the taxpayer's affiliate, or
</p>
</li>
<li><p>amounts resulting from any dealings between these entities for that part of the income year that the entity is connected or affiliated with the taxpayer.
</p>
</li></ul>

</li></ul>

<p>Original URL was https://www.ato.gov.au/Business/Research-and-development-tax-incentive/Claiming-the-tax-offset/Steps-to-claiming-the-tax-offset/Step-3&mdash;Calculate-your-aggregated-turnover/</p>
</td></tr>
<tr><td><code id="small_business_tax_offset_+3A_total_net_small_business_income">total_net_small_business_income</code></td>
<td>
<p>Total net business income within the meaning of the Act. For most taxpayers, this is simply any net income from a business they own (or their share of net income from a business in which they have an interest). The only difference being in the calculation of the net business income of some minors (vide Division 6AA of Part III of the Act).</p>
</td></tr>
<tr><td><code id="small_business_tax_offset_+3A_fy_year">fy_year</code></td>
<td>
<p>The financial year for which the small business tax offset is to apply.</p>
</td></tr>
<tr><td><code id="small_business_tax_offset_+3A_tax_discount">tax_discount</code></td>
<td>
<p>If you do not wish to use the legislated discount rate from a particular <code>fy_year</code>, 
you can specify it via <code>tax_discount</code>. If both are provided, <code>tax_discount</code> prevails, with a warning.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Basic income tax method s4-10(3) <a href="http://classic.austlii.edu.au/au/legis/cth/consol_act/itaa1997240/s4.10.html">http://classic.austlii.edu.au/au/legis/cth/consol_act/itaa1997240/s4.10.html</a>.
Explanatory memorandum <a href="https://github.com/HughParsonage/grattan/blob/master/data-raw/parlinfo/small-biz-explanatory-memo-2015.pdf">https://github.com/HughParsonage/grattan/blob/master/data-raw/parlinfo/small-biz-explanatory-memo-2015.pdf</a> from the original <code style="white-space: pre;">&#8288;http://parlinfo.aph.gov.au/parlInfo/download/legislation/ems/r5494_ems_0a26ca86-9c3f-4ffa-9b81-219ac09be454/upload_pdf/503041.pdf&#8288;</code>.
</p>

<hr>
<h2 id='System'>FUNCTION_TITLE</h2><span id='topic+System'></span>

<h3>Description</h3>

<p>FUNCTION_DESCRIPTION
</p>


<h3>Usage</h3>

<pre><code class='language-R'>System(
  yr,
  ordinary_tax_thresholds = NULL,
  ordinary_tax_rates = NULL,
  medicare_levy_taper = NULL,
  medicare_levy_rate = NULL,
  medicare_levy_lower_threshold = NULL,
  medicare_levy_lower_sapto_threshold = NULL,
  medicare_levy_lower_family_threshold = NULL,
  medicare_levy_lower_family_sapto_threshold = NULL,
  medicare_levy_lower_up_for_each_child = NULL,
  medicare_levy_upper_sapto_threshold = NULL,
  medicare_levy_upper_family_threshold = NULL,
  medicare_levy_upper_family_sapto_threshold = NULL,
  medicare_levy_upper_threshold = NULL,
  Offsets = NULL,
  sapto_max_offset = NULL,
  sapto_lower_threshold = NULL,
  sapto_taper = NULL,
  sapto_max_offset_married = NULL,
  sapto_lower_threshold_married = NULL,
  sapto_taper_married = NULL,
  sapto_max_offset_illness = NULL,
  sapto_lower_threshold_illness = NULL,
  sapto_pension_age = NULL,
  fix = 0L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="System_+3A_yr">yr</code></td>
<td>
<p><code>integer(1)</code> A year.</p>
</td></tr>
<tr><td><code id="System_+3A_ordinary_tax_thresholds">ordinary_tax_thresholds</code></td>
<td>
<p>A numeric vector specifying the lower bounds of the brackets for &quot;ordinary tax&quot; as defined by the Regulations.
The first element should be zero if there is a tax-free threshold.</p>
</td></tr>
<tr><td><code id="System_+3A_ordinary_tax_rates">ordinary_tax_rates</code></td>
<td>
<p>The marginal rates of ordinary tax. The first element should be zero if there is a tax-free threshold. 
Since the temporary budget repair levy was imposed on a discrete tax bracket when it applied, it is not included in this function.</p>
</td></tr>
<tr><td><code id="System_+3A_medicare_levy_taper">medicare_levy_taper</code></td>
<td>
<p>The taper that applies between the <code>_lower</code> and <code>_upper</code> thresholds.</p>
</td></tr>
<tr><td><code id="System_+3A_medicare_levy_rate">medicare_levy_rate</code></td>
<td>
<p>The ordinary rate of the Medicare levy for taxable incomes above <code>medicare_levy_upper_threshold</code>.</p>
</td></tr>
<tr><td><code id="System_+3A_medicare_levy_lower_threshold">medicare_levy_lower_threshold</code></td>
<td>
<p>Minimum taxable income at which the Medicare levy will be applied.</p>
</td></tr>
<tr><td><code id="System_+3A_medicare_levy_lower_sapto_threshold">medicare_levy_lower_sapto_threshold</code>, <code id="System_+3A_medicare_levy_upper_sapto_threshold">medicare_levy_upper_sapto_threshold</code></td>
<td>
<p>The equivalent values for SAPTO-eligible individuals (not families).</p>
</td></tr>
<tr><td><code id="System_+3A_medicare_levy_lower_family_threshold">medicare_levy_lower_family_threshold</code>, <code id="System_+3A_medicare_levy_upper_family_threshold">medicare_levy_upper_family_threshold</code></td>
<td>
<p>The equivalent values for families.</p>
</td></tr>
<tr><td><code id="System_+3A_medicare_levy_lower_family_sapto_threshold">medicare_levy_lower_family_sapto_threshold</code>, <code id="System_+3A_medicare_levy_upper_family_sapto_threshold">medicare_levy_upper_family_sapto_threshold</code></td>
<td>
<p>The equivalent values for SAPTO-eligible individuals in a family.</p>
</td></tr>
<tr><td><code id="System_+3A_medicare_levy_lower_up_for_each_child">medicare_levy_lower_up_for_each_child</code></td>
<td>
<p>The amount to add to the <code>_family_threshold</code>s for each dependant child.</p>
</td></tr>
<tr><td><code id="System_+3A_medicare_levy_upper_threshold">medicare_levy_upper_threshold</code></td>
<td>
<p>Minimum taxable income at which the Medicare levy will be applied at the full Medicare levy rate (2% in 2015-16). Between this threshold and the <code>medicare_levy_lower_threshold</code>, a tapered rate applies, starting from zero and climbing to <code>medicare_levy_rate</code>.</p>
</td></tr>
<tr><td><code id="System_+3A_offsets">Offsets</code></td>
<td>
<p>List of offsets created by <code>set_offsets</code>.</p>
</td></tr>
<tr><td><code id="System_+3A_sapto_max_offset">sapto_max_offset</code></td>
<td>
<p>The maximum offset available through SAPTO.</p>
</td></tr>
<tr><td><code id="System_+3A_sapto_lower_threshold">sapto_lower_threshold</code></td>
<td>
<p>The threshold at which SAPTO begins to reduce (from <code>sapto_max_offset</code>).</p>
</td></tr>
<tr><td><code id="System_+3A_sapto_taper">sapto_taper</code></td>
<td>
<p>The taper rate beyond <code>sapto_lower_threshold</code>.</p>
</td></tr>
<tr><td><code id="System_+3A_sapto_max_offset_married">sapto_max_offset_married</code>, <code id="System_+3A_sapto_lower_threshold_married">sapto_lower_threshold_married</code>, <code id="System_+3A_sapto_taper_married">sapto_taper_married</code>, <code id="System_+3A_sapto_lower_threshold_illness">sapto_lower_threshold_illness</code>, <code id="System_+3A_sapto_max_offset_illness">sapto_max_offset_illness</code></td>
<td>
<p>As above,
but applied to members of a couple.</p>
</td></tr>
<tr><td><code id="System_+3A_sapto_pension_age">sapto_pension_age</code></td>
<td>
<p>The age at and above which the SAPTO is to apply.</p>
</td></tr>
<tr><td><code id="System_+3A_fix">fix</code></td>
<td>
<p><code>integer(1)</code> If <code>0L</code>, the default, an error will be emitted if
parameters are inconsistent; if <code>1L</code>, inconsistencies will be fixed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A list describing a tax system
</p>

<hr>
<h2 id='validate_date'>Verifying validity of dates</h2><span id='topic+validate_date'></span>

<h3>Description</h3>

<p>Many functions expect Dates. 
Determining that they are validly entered is often quite 
computationally costly, relative to the core calculations.
These internal functions provide mechanisms to check validity
quickly, while still providing clear, accurate error messages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_date(date_to_verify, from = NULL, to = NULL, deparsed = "Date")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_date_+3A_date_to_verify">date_to_verify</code></td>
<td>
<p>(character) A user-provided value, purporting to be
character vector of dates.</p>
</td></tr>
<tr><td><code id="validate_date_+3A_from">from</code>, <code id="validate_date_+3A_to">to</code></td>
<td>
<p>Indicating the range of years valid for <code>date_to_verify</code>. Default set to -Inf and Inf respectively (i.e. there is no bound)</p>
</td></tr>
<tr><td><code id="validate_date_+3A_deparsed">deparsed</code></td>
<td>
<p>The name of variable to appear in error messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>date_to_verify</code> as a Date object, provided it can be converted 
to a Date and all elements are within the bounds <code>from</code> and <code>to</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
validate_date("2020-01-01")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
