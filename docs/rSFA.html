<!DOCTYPE html><html><head><title>Help for package rSFA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rSFA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rSFA-package'><p>Slow Feature Analysis</p></a></li>
<li><a href='#addNoisyCopies'><p>Add noisy copies for parametric bootstrap</p></a></li>
<li><a href='#customRep'><p>Custom Repeater Function</p></a></li>
<li><a href='#customRepmat'><p>Custom repmat Function</p></a></li>
<li><a href='#customSize'><p>Custom Size Function.</p></a></li>
<li><a href='#etaval'><p>Computes the eta value of a signal (slowness)</p></a></li>
<li><a href='#gaussClassifier'><p>Classifier for SFA demos</p></a></li>
<li><a href='#gaussCreate'><p>Create an Gaussian classifier object</p></a></li>
<li><a href='#gaussLoad'><p>Load a GAUSS object.</p></a></li>
<li><a href='#gaussSave'><p>Save a GAUSS object.</p></a></li>
<li><a href='#lcovCreate'><p>Create a new covariance object.</p></a></li>
<li><a href='#lcovFix'><p>Fix a covariance object</p></a></li>
<li><a href='#lcovPca'><p>Principal Component Analysis on a covariance object</p></a></li>
<li><a href='#lcovPca2'><p>Improved Principal Component Analysis on a covariance object</p></a></li>
<li><a href='#lcovTransform'><p>Transform a covariance object</p></a></li>
<li><a href='#lcovUpdate'><p>Update a covariance object</p></a></li>
<li><a href='#nlDim'><p>Custom Nonlinear Dimension Calculation</p></a></li>
<li><a href='#nlExpand'><p>Expand a signal in the for Nonlinear Expansion demo</p></a></li>
<li><a href='#sfa1'><p>The SFA1 algorithm, linear SFA.</p></a></li>
<li><a href='#sfa1Create'><p>Create structured list for linear SFA</p></a></li>
<li><a href='#sfa1Step'><p>A step in the SFA1 algorithm.</p></a></li>
<li><a href='#sfa2'><p>The SFA2 algorithm, SFA with degree 2 expansion.</p></a></li>
<li><a href='#sfa2Create'><p>Create structured list for expanded SFA</p></a></li>
<li><a href='#sfa2Step'><p>A step in the SFA2 algorithm.</p></a></li>
<li><a href='#sfaBSh'><p>Backslash operator.</p></a></li>
<li><a href='#sfaCheckCondition'><p>Check Condition of a matrix for SFA</p></a></li>
<li><a href='#sfaClassify'><p>Predict Class for SFA classification</p></a></li>
<li><a href='#sfaClassPredict'><p>Predict Class for SFA classification</p></a></li>
<li><a href='#sfaExecute'><p>Execute learned function for input data</p></a></li>
<li><a href='#sfaExpand'><p>Degree 2 Expansion</p></a></li>
<li><a href='#sfaGetHf'><p>Return a SFA function as a quadratic form.</p></a></li>
<li><a href='#sfaGetIntRange'><p>Helper Function of SFA.</p></a></li>
<li><a href='#sfaLoad'><p>Load a SFA object.</p></a></li>
<li><a href='#sfaNlRegress'><p>Perform non-linear regression</p></a></li>
<li><a href='#sfaPBootstrap'><p>Parametric Bootstrap</p></a></li>
<li><a href='#sfaPreproc'><p>Preprocessing for SFA classification</p></a></li>
<li><a href='#sfaSave'><p>Save a SFA object.</p></a></li>
<li><a href='#sfaStep'><p>Update a step of the SFA algorithm.</p></a></li>
<li><a href='#sfaTimediff'><p>Calculates the first derivative of signal data</p></a></li>
<li><a href='#xpDim'><p>Degree 2 Dimension Calculation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Maintainer:</td>
<td>Martin Zaefferer &lt;martin.zaefferer@gmx.de&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Title:</td>
<td>Slow Feature Analysis</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Author:</td>
<td>Wolfgang Konen &lt;wolfgang.konen@fh-koeln.de&gt;, Martin Zaefferer,
    Patrick Koch; Bug hunting and testing by Ayodele Fasika, Ashwin
    Kumar, Prawyn Jebakumar</td>
</tr>
<tr>
<td>Description:</td>
<td>Slow Feature Analysis (SFA), ported to R based on
    'matlab' implementations of SFA: 'SFA toolkit' 1.0 by Pietro Berkes and 'SFA toolkit'
    2.8 by Wolfgang Konen.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-03-29</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, MASS, graphics, grDevices</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-29 09:40:39 UTC; Martin</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-29 10:00:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='rSFA-package'>Slow Feature Analysis</h2><span id='topic+rSFA-package'></span><span id='topic+rSFA'></span>

<h3>Description</h3>

<p>Slow Feature Analysis
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> rSFA</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.5</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 29.03.2022</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Martin Zaefferer <a href="mailto:martin.zaefferer@gmx.de">martin.zaefferer@gmx.de</a></td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Slow Feature Analysis (SFA), ported to R based on the matlab implementations SFA toolkit 1.0 by Pietro Berkes and SFA
toolkit 2.8 by Wolfgang Konen.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Konen <a href="mailto:wolfgang.konen@fh-koeln.de">wolfgang.konen@fh-koeln.de</a>, Martin Zaefferer, Patrick Koch; 
Bug hunting and testing by Ayodele Fasika, Ashwin Kumar, Prawyn Jebakumar
</p>

<hr>
<h2 id='addNoisyCopies'>Add noisy copies for parametric bootstrap</h2><span id='topic+addNoisyCopies'></span>

<h3>Description</h3>

<p>Given training data X with true labels REALCLASS, 
add new records to X and REALCLASS, which are noisy copies of the training data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addNoisyCopies(realclass, x, pars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addNoisyCopies_+3A_realclass">realclass</code></td>
<td>
<p>true class of training data (can be vector, numerics, integers, factors)</p>
</td></tr>
<tr><td><code id="addNoisyCopies_+3A_x">x</code></td>
<td>
<p>a matrix containing the training data</p>
</td></tr>
<tr><td><code id="addNoisyCopies_+3A_pars">pars</code></td>
<td>
<p>list of parameters:<br />
<code>pars$ncopies</code>: Number of new records to add<br />
<code>pars$ncsort</code>: Defines if training data should be sorted by class. Default is FALSE<br />
<code>pars$ncsigma</code>: The noise in each column of x has the std.dev. pars$ncsigma*(standard deviation of column). Default Value: 0.8<br />
<code>pars$ncmethod</code>:  =1: each 'old' record from X in turn is the centroid for a new pattern;<br />
=2: the centroid is the average of all records from the same class, the std.dev. is the same for all classes;<br />
=3: centroid as in '2', the std.dev. is the std.dev. of all records from the same class  (*recommended*)<br /></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list <code>res</code> <br />
- <code>res</code> contains two list entries: realclass and x (including added copies)
</p>


<h3>References</h3>

<p><code><a href="#topic+sfaPBootstrap">sfaPBootstrap</a></code>
</p>

<hr>
<h2 id='customRep'>Custom Repeater Function</h2><span id='topic+customRep'></span>

<h3>Description</h3>

<p>Faster than customRepmat in matlab package, in certain cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>customRep(a, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="customRep_+3A_a">a</code></td>
<td>
<p>to be repeated</p>
</td></tr>
<tr><td><code id="customRep_+3A_n">n</code></td>
<td>
<p>repeat by</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the repeated dataset
</p>

<hr>
<h2 id='customRepmat'>Custom repmat Function</h2><span id='topic+customRepmat'></span>

<h3>Description</h3>

<p>R version of the matlab function repmat, repeating a by m x n
</p>


<h3>Usage</h3>

<pre><code class='language-R'>customRepmat(a, n, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="customRepmat_+3A_a">a</code></td>
<td>
<p>to be repeated</p>
</td></tr>
<tr><td><code id="customRepmat_+3A_n">n</code></td>
<td>
<p>repeater parameter</p>
</td></tr>
<tr><td><code id="customRepmat_+3A_m">m</code></td>
<td>
<p>repeater parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the repeated dataset
</p>

<hr>
<h2 id='customSize'>Custom Size Function.</h2><span id='topic+customSize'></span>

<h3>Description</h3>

<p>custom R version of matlabs size function. Calls length for vectors, or else calls dim.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>customSize(x, i = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="customSize_+3A_x">x</code></td>
<td>
<p>object to be checked for size</p>
</td></tr>
<tr><td><code id="customSize_+3A_i">i</code></td>
<td>
<p>1, 2 or NULL. Defines if both or which size information should be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector if i is null, an integer if i is 1 or 2.
</p>

<hr>
<h2 id='etaval'>Computes the eta value of a signal (slowness)</h2><span id='topic+etaval'></span>

<h3>Description</h3>

<p>Computes the eta value of a signal (slowness)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>etaval(x, T = length(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="etaval_+3A_x">x</code></td>
<td>
<p>The columns of signal correspond to different input components. Must be normalized (zero mean, unit variance)</p>
</td></tr>
<tr><td><code id="etaval_+3A_t">T</code></td>
<td>
<p>Time interval</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the eta value of the signal in a time interval T time units long.
</p>

<hr>
<h2 id='gaussClassifier'>Classifier for SFA demos</h2><span id='topic+gaussClassifier'></span>

<h3>Description</h3>

<p>Train or apply a Gaussian classifier..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussClassifier(gauss, y, realC, method = "train")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussClassifier_+3A_gauss">gauss</code></td>
<td>
<p>List created by gaussCreate. Contains also the elements: </p>

<dl>
<dt>aligned</dt><dd>
<p>=0: do not align the Gaussian classifiers with axes, use full covariance matrix <br />
=1 (default): set the off-diagonals in covariance matrix to 0,
i.e. the Gaussian classifier is forced to be aligned with the    
axes. This is more robust in the case where the data deviate
largely from a multivariate normal distribution.    </p>
</dd>
<dt>epsD</dt><dd>  
<p>[defaults to 0.04] replace diagonal elements of COV smaller than epsD with
epsD to avoid too small Gaussians </p>
</dd>
</dl>
</td></tr>
<tr><td><code id="gaussClassifier_+3A_y">y</code></td>
<td>
<p>K x M matrix where K is the total number of patterns and M is the
number of variables used for classification. I.e. each row of
y contains the data for one pattern.</p>
</td></tr>
<tr><td><code id="gaussClassifier_+3A_realc">realC</code></td>
<td>
<p>1 x K matrix with NCLASS distinct real class labels needed only
for method='train'. In case of method=&quot;apply&quot; realC is not 
used and can have any value</p>
</td></tr>
<tr><td><code id="gaussClassifier_+3A_method">method</code></td>
<td>
<p>either &quot;train&quot; (default) or &quot;apply&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list <code>gauss</code> containing
</p>
<table>
<tr><td><code>gauss$predC</code></td>
<td>
<p> 1 x K matrix: the predicted class  </p>
</td></tr>
<tr><td><code>gauss$prob</code></td>
<td>
<p> K x NCLASS matrix: prob(k,n) is the estimated probability that pattern k belongs to class m  </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+gaussCreate">gaussCreate</a></code>
</p>

<hr>
<h2 id='gaussCreate'>Create an Gaussian classifier object</h2><span id='topic+gaussCreate'></span>

<h3>Description</h3>

<p>Create an Gaussian classifier object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussCreate(nclass, dimY)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussCreate_+3A_nclass">nclass</code></td>
<td>
<p>number of classes</p>
</td></tr>
<tr><td><code id="gaussCreate_+3A_dimy">dimY</code></td>
<td>
<p>dimension</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of defaults for gauss classifier
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gaussClassifier">gaussClassifier</a></code>
</p>

<hr>
<h2 id='gaussLoad'>Load a GAUSS object.</h2><span id='topic+gaussLoad'></span>

<h3>Description</h3>

<p>Load a GAUSS object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussLoad(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussLoad_+3A_filename">filename</code></td>
<td>
<p>Load list <code>gauss</code> from this file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list <code>gauss</code>
</p>


<h3>References</h3>

<p><code><a href="#topic+gaussSave">gaussSave</a></code>
</p>

<hr>
<h2 id='gaussSave'>Save a GAUSS object.</h2><span id='topic+gaussSave'></span>

<h3>Description</h3>

<p>Save a GAUSS object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussSave(gauss, filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussSave_+3A_gauss">gauss</code></td>
<td>
<p>A list that contains all information about the handled gauss-structure</p>
</td></tr>
<tr><td><code id="gaussSave_+3A_filename">filename</code></td>
<td>
<p>Save list <code>gauss</code> to this file</p>
</td></tr>
</table>


<h3>References</h3>

<p><code><a href="#topic+gaussLoad">gaussLoad</a></code>
</p>

<hr>
<h2 id='lcovCreate'>Create a new covariance object.</h2><span id='topic+lcovCreate'></span>

<h3>Description</h3>

<p>Create a new covariance object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcovCreate(dim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcovCreate_+3A_dim">dim</code></td>
<td>
<p>dimension of the covariance object list to be created</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the COVMTX, avg and tlen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lcovUpdate">lcovUpdate</a></code>
</p>

<hr>
<h2 id='lcovFix'>Fix a covariance object</h2><span id='topic+lcovFix'></span>

<h3>Description</h3>

<p>Computes the definitive covariance matrix
and the average of the covariance object referenced by lcov
after a series of update operations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcovFix(lcov)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcovFix_+3A_lcov">lcov</code></td>
<td>
<p>A list that contains all information about the handled covariance-structure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the fixed covariance list structure
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lcovCreate">lcovCreate</a></code> <code><a href="#topic+lcovPca">lcovPca</a></code>
</p>

<hr>
<h2 id='lcovPca'>Principal Component Analysis on a covariance object</h2><span id='topic+lcovPca'></span>

<h3>Description</h3>

<p>Performs PCA _and_ whitening
on the covariance object referenced by lcov.
CAUTION: can be numerically instable if covariance matrix is singular,
better use LCOV_PCA2 instead /W. Konen/
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcovPca(lcov, dimRange = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcovPca_+3A_lcov">lcov</code></td>
<td>
<p>A list that contains all information about the handled covariance-structure</p>
</td></tr>
<tr><td><code id="lcovPca_+3A_dimrange">dimRange</code></td>
<td>
<p>A number or vector for dimensionality reduction: <br /> 
if it is a number: only the first components 1:dimRange are kept (those with largest eigenvalues)<br />            
if it is a range: only the components in the range dimRange[1]..dimRange[2] are kept</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list: 
$W is the whitening matrix, $DW the dewhitening matrix and $D an array
containing a list of the eigenvalues. $kvar contains the total
variance kept in percent.
</p>


<h3>Note</h3>

<p>lcovFix(lcov) has to be used before this function is applied
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lcovFix">lcovFix</a></code> <code><a href="#topic+lcovPca2">lcovPca2</a></code>
</p>

<hr>
<h2 id='lcovPca2'>Improved Principal Component Analysis on a covariance object</h2><span id='topic+lcovPca2'></span>

<h3>Description</h3>

<p>Performs PCA _and_ whitening
on the covariance object referenced by lcov. <br /> <br />
Difference to LCOV_PCA: null the rows of W (columns of DW) where the 
corresponding eigenvalue in D is close to zero (more precisely: if
lam/lam_max &lt; EPS = 1e-7). This is numerically stable in the case where
the covariance matrix is singular.<br />
- Author: Wolfgang Konen, Cologne Univ., May'2009
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcovPca2(lcov, dimRange = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcovPca2_+3A_lcov">lcov</code></td>
<td>
<p>A list that contains all information about the handled covariance-structure</p>
</td></tr>
<tr><td><code id="lcovPca2_+3A_dimrange">dimRange</code></td>
<td>
<p>A number or vector for dimensionality reduction: <br /> 
if it is a number: only the first components 1:dimRange are kept (those with largest eigenvalues)<br />            
if it is a range: only the components in the range dimRange[1]..dimRange[2] are kept</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list: 
$W is the whitening matrix, $DW the dewhitening matrix and $D an array
containing a list of the eigenvalues. $kvar contains the total
variance kept in percent.
</p>


<h3>Note</h3>

<p>lcovFix(lcov) has to be used before this function is applied
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lcovFix">lcovFix</a></code> <code><a href="#topic+lcovPca">lcovPca</a></code>
</p>

<hr>
<h2 id='lcovTransform'>Transform a covariance object</h2><span id='topic+lcovTransform'></span>

<h3>Description</h3>

<p>Computes the definitive covariance matrix
and the average of the covariance object referenced by lcov
after a series of update operations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcovTransform(lcov, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcovTransform_+3A_lcov">lcov</code></td>
<td>
<p>A list that contains all information about the handled covariance-structure to be transformed</p>
</td></tr>
<tr><td><code id="lcovTransform_+3A_a">A</code></td>
<td>
<p>linear function by which covariance object is to be transformed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the fixed covariance list structure
</p>


<h3>Note</h3>

<p>lcovFix(lcov) has to be used before this function is applied
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lcovFix">lcovFix</a></code>
</p>

<hr>
<h2 id='lcovUpdate'>Update a covariance object</h2><span id='topic+lcovUpdate'></span>

<h3>Description</h3>

<p>Updates the covariance object
referenced by lcov with a new chunk of data DATA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcovUpdate(lcov, DATA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcovUpdate_+3A_lcov">lcov</code></td>
<td>
<p>A list that contains all information about the handled covariance-structure</p>
</td></tr>
<tr><td><code id="lcovUpdate_+3A_data">DATA</code></td>
<td>
<p>Input Data: must be oriented so that each column is a variable and each row a new measurement</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the COVMTX, avg and tlen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lcovCreate">lcovCreate</a></code>
</p>

<hr>
<h2 id='nlDim'>Custom Nonlinear Dimension Calculation</h2><span id='topic+nlDim'></span>

<h3>Description</h3>

<p>Compute the dimension, used for the customexpansion demo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlDim(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlDim_+3A_n">n</code></td>
<td>
<p>Dimension of input vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dimension of expanded vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sfa2">sfa2</a></code> <code><a href="#topic+nlExpand">nlExpand</a></code>
</p>

<hr>
<h2 id='nlExpand'>Expand a signal in the for Nonlinear Expansion demo</h2><span id='topic+nlExpand'></span>

<h3>Description</h3>

<p>This is an optional expansion function, calculating the expanded data in [x; x^4].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlExpand(sfaList, DATA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlExpand_+3A_sfalist">sfaList</code></td>
<td>
<p>A list that contains all information about the handled sfa-structure</p>
</td></tr>
<tr><td><code id="nlExpand_+3A_data">DATA</code></td>
<td>
<p>Input data, each column a different variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>expanded matrix <code>DATA</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sfa2">sfa2</a></code> <code><a href="#topic+sfaExpand">sfaExpand</a></code> <code><a href="#topic+nlDim">nlDim</a></code>
</p>

<hr>
<h2 id='sfa1'>The SFA1 algorithm, linear SFA.</h2><span id='topic+sfa1'></span>

<h3>Description</h3>

<p>Y = sfa1(X) performs linear Slow Feature Analysis on the input data
X and returns the output signals Y ordered by increasing temporal
variation, i.e. the first signal Y[,1] is the slowest varying one,
Y[,2] the next slowest and so on. The input data have to be organized 
with each variable in a column and each data (time) point in a
row, i.e. X(t,i) is the value of variable nr. i at time t.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfa1(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfa1_+3A_x">x</code></td>
<td>
<p>Input data, each column a different variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list <code>sfaList</code> with all learned information, where <code>sfaList$y</code> contains the outputs
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sfaStep">sfaStep</a></code> <code><a href="#topic+sfa1Create">sfa1Create</a></code> <code><a href="#topic+sfaExecute">sfaExecute</a></code>
</p>

<hr>
<h2 id='sfa1Create'>Create structured list for linear SFA</h2><span id='topic+sfa1Create'></span>

<h3>Description</h3>

<p>Create structured list for linear SFA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfa1Create(sfaRange, axType = "ORD1", regCt = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfa1Create_+3A_sfarange">sfaRange</code></td>
<td>
<p>number of slowly-varying functions to be kept</p>
</td></tr>
<tr><td><code id="sfa1Create_+3A_axtype">axType</code></td>
<td>
<p>is the type of derivative approximation to be used, see <code><a href="#topic+sfaTimediff">sfaTimediff</a></code></p>
</td></tr>
<tr><td><code id="sfa1Create_+3A_regct">regCt</code></td>
<td>
<p>regularization constant, currently not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list <code>sfaList</code> contains all arguments passed into sfa1create plus
</p>
<table>
<tr><td><code>deg</code></td>
<td>
<p> 2</p>
</td></tr>
</table>
<p>This list will be expanded by other SFA functions with further SFa results
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sfa1">sfa1</a></code> <code><a href="#topic+sfaStep">sfaStep</a></code> <code><a href="#topic+sfa2Create">sfa2Create</a></code>
</p>

<hr>
<h2 id='sfa1Step'>A step in the SFA1 algorithm.</h2><span id='topic+sfa1Step'></span>

<h3>Description</h3>

<p>!!! Do not use this function directly, use sfaStep instead !!!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfa1Step(sfaList, arg = NULL, step = NULL, method = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfa1Step_+3A_sfalist">sfaList</code></td>
<td>
<p>A list that contains all information about the handled sfa-structure</p>
</td></tr>
<tr><td><code id="sfa1Step_+3A_arg">arg</code></td>
<td>
<p>Input data, each column a different variable</p>
</td></tr>
<tr><td><code id="sfa1Step_+3A_step">step</code></td>
<td>
<p>Specifies the current SFA step.  Must be given in the right sequence: 
for SFA1 objects:  &quot;preprocessing&quot;, &quot;sfa&quot;<br />
for SFA2 objects:  &quot;preprocessing&quot;, &quot;expansion&quot;, &quot;sfa&quot;        
Each time a new step is invoked, the previous one is closed, which
might take some time.</p>
</td></tr>
<tr><td><code id="sfa1Step_+3A_method">method</code></td>
<td>
<p>Method to be used: For <code>sfaList$step="expansion"</code> the choices are &quot;TIMESERIES&quot; or &quot;CLASSIF&quot;. <br />
For <code>sfaList$step="sfa"</code> currently no choices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list <code>sfaList</code> taken from the input, with new information added to this list. 
Among the new items are:
</p>
<table>
<tr><td><code>avg0</code></td>
<td>
<p>  mean vector in input space</p>
</td></tr>
<tr><td><code>SF</code></td>
<td>
<p>  (sfaRange x sfaRange)-matrix with rows which contain the directions in expanded space with slow signals. The rows are 
sorted acc. to increasing eigenvalues of time-diff covariance matrix</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+sfaStep">sfaStep</a></code> <code><a href="#topic+sfa1Create">sfa1Create</a></code> <code><a href="#topic+sfa2Step">sfa2Step</a></code>
</p>

<hr>
<h2 id='sfa2'>The SFA2 algorithm, SFA with degree 2 expansion.</h2><span id='topic+sfa2'></span>

<h3>Description</h3>

<p>Y = sfa2(X) performs expanded Slow Feature Analysis on the input data
X and returns the output signals Y ordered by increasing temporal
variation, i.e. the first signal Y[,1] is the slowest varying one,
Y[,2] the next slowest varying one and so on. The input data have to
be organized with each variable in a column and each data (time) point in a
row, i.e. X(t,i) is the value of variable i at time t.
By default an expansion to the space of 2nd degree polynomials is done,
this can be changed by using different functions for xpDimFun and sfaExpandFun.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfa2(
  x,
  method = "SVDSFA",
  ppType = "PCA",
  xpDimFun = xpDim,
  sfaExpandFun = sfaExpand
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfa2_+3A_x">x</code></td>
<td>
<p>input data</p>
</td></tr>
<tr><td><code id="sfa2_+3A_method">method</code></td>
<td>
<p>eigenvector calculation method:    =&quot;SVDSFA&quot; for singular value decomposition (recommended) or 
=&quot;GENEIG&quot; for generalized eigenvalues (unstable!).    GENEIG is not implemented in the current version, since
R lacks an easy option to calculate generalized eigenvalues.</p>
</td></tr>
<tr><td><code id="sfa2_+3A_pptype">ppType</code></td>
<td>
<p>preprocessing type: =&quot;PCA&quot; (principal component analysis) or =&quot;SFA1&quot; (linear sfa)</p>
</td></tr>
<tr><td><code id="sfa2_+3A_xpdimfun">xpDimFun</code></td>
<td>
<p>function to calculate dimension of expanded data</p>
</td></tr>
<tr><td><code id="sfa2_+3A_sfaexpandfun">sfaExpandFun</code></td>
<td>
<p>function to expand data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list <code>sfaList</code> with all SFA information, among them are
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p> a matrix containing  the output Y (as described above) </p>
</td></tr>
<tr><td><code>-</code></td>
<td>
<p> all input parameters to <code><a href="#topic+sfa2Create">sfa2Create</a></code>  </p>
</td></tr>
<tr><td><code>-</code></td>
<td>
<p> all elements of <code>sfaList</code>  as specified in <code><a href="#topic+sfa2Step">sfa2Step</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+sfa2Step">sfa2Step</a></code> <code><a href="#topic+sfa2Create">sfa2Create</a></code> <code><a href="#topic+sfaExecute">sfaExecute</a></code> <code><a href="#topic+sfa1">sfa1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## prepare input data for simple demo
t=seq.int(from=0,by=0.011,to=2*pi)
x1=sin(t)+cos(11*t)^2
x2=cos(11*t)
x=data.frame(x1,x2)
## perform sfa2 algorithm with data
res = sfa2(x)
## plot slowest varying function of result
plot(t, res$y[,1],type="l",main="output of the slowest varying function")
## see http://www.scholarpedia.org/article/Slow_feature_analysis#The_algorithm
## for detailed description of this example
</code></pre>

<hr>
<h2 id='sfa2Create'>Create structured list for expanded SFA</h2><span id='topic+sfa2Create'></span>

<h3>Description</h3>

<p>'Expanded' SFA means that the input data are expanded into a higher-dimensional
space with the function sfaExpandFun. See <code><a href="#topic+sfaExpand">sfaExpand</a></code> for the default 
expansion function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfa2Create(
  ppRange,
  sfaRange,
  ppType = "SFA1",
  axType = "ORD1",
  regCt = 0,
  opts = NULL,
  xpDimFun = xpDim,
  sfaExpandFun = sfaExpand
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfa2Create_+3A_pprange">ppRange</code></td>
<td>
<p>umber of dimensions to be kept after preprocessing step - or - 
a two-number vector with lower and upper dimension number</p>
</td></tr>
<tr><td><code id="sfa2Create_+3A_sfarange">sfaRange</code></td>
<td>
<p>umber of slowly-varying functions to be kept</p>
</td></tr>
<tr><td><code id="sfa2Create_+3A_pptype">ppType</code></td>
<td>
<p>preprocessing type: =&quot;PCA&quot;, &quot;PCA2&quot; (principal component analysis) or =&quot;SFA1&quot; (linear sfa)</p>
</td></tr>
<tr><td><code id="sfa2Create_+3A_axtype">axType</code></td>
<td>
<p>is the type of derivative approximation to be used, see <code><a href="#topic+sfaTimediff">sfaTimediff</a></code></p>
</td></tr>
<tr><td><code id="sfa2Create_+3A_regct">regCt</code></td>
<td>
<p>regularization constant, currently not used</p>
</td></tr>
<tr><td><code id="sfa2Create_+3A_opts">opts</code></td>
<td>
<p>optional list of additional options</p>
</td></tr>
<tr><td><code id="sfa2Create_+3A_xpdimfun">xpDimFun</code></td>
<td>
<p>Function to calculate dimension of expanded data</p>
</td></tr>
<tr><td><code id="sfa2Create_+3A_sfaexpandfun">sfaExpandFun</code></td>
<td>
<p>Function to expand data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list <code>sfaList</code> contains all arguments passed into sfa2create plus
</p>
<table>
<tr><td><code>xpRange</code></td>
<td>
<p> evaluates to <code>xpDimFun(ppRange)</code>  </p>
</td></tr>
<tr><td><code>deg</code></td>
<td>
<p> 2</p>
</td></tr>
</table>
<p>This list will be expanded by other SFA functions with further SFa results
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sfa2">sfa2</a></code> <code><a href="#topic+sfaStep">sfaStep</a></code> <code><a href="#topic+sfa1Create">sfa1Create</a></code>
</p>

<hr>
<h2 id='sfa2Step'>A step in the SFA2 algorithm.</h2><span id='topic+sfa2Step'></span>

<h3>Description</h3>

<p>!!! Do not use this function directly, use sfaStep instead !!!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfa2Step(sfaList, arg = NULL, step = NULL, method = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfa2Step_+3A_sfalist">sfaList</code></td>
<td>
<p>A list that contains all information about the handled sfa-structure</p>
</td></tr>
<tr><td><code id="sfa2Step_+3A_arg">arg</code></td>
<td>
<p>Input data, each column a different variable</p>
</td></tr>
<tr><td><code id="sfa2Step_+3A_step">step</code></td>
<td>
<p>Specifies the current SFA step.  Must be given in the right sequence: 
for SFA1 objects:  &quot;preprocessing&quot;, &quot;sfa&quot;<br />
for SFA2 objects:  &quot;preprocessing&quot;, &quot;expansion&quot;, &quot;sfa&quot;        
Each time a new step is invoked, the previous one is closed, which
might take some time.</p>
</td></tr>
<tr><td><code id="sfa2Step_+3A_method">method</code></td>
<td>
<p>Method to be used: For <code>sfaList$step="expansion"</code> the choices are &quot;TIMESERIES&quot; or &quot;CLASSIF&quot;. <br />
For <code>sfaList$step="sfa"</code> the choices are &quot;SVDSFA&quot; (recommended) or &quot;GENEIG&quot; (unstable).
GENEIG is not implemented in the current version, since
R lacks the option to calculate generalized eigenvalues easily.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list <code>sfaList</code> taken from the input, with new information added to this list. 
Among the new items are:
</p>
<table>
<tr><td><code>avg0</code></td>
<td>
<p>  mean vector in input space</p>
</td></tr>
<tr><td><code>avg1</code></td>
<td>
<p>  mean vector in expanded space</p>
</td></tr>
<tr><td><code>W0</code></td>
<td>
<p> (ppRange x ppRange)-matrix, the whitening matrix for the input data</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p> covariance matrix of the time-diff of expanded and sphered data</p>
</td></tr>
<tr><td><code>SF</code></td>
<td>
<p>  (sfaRange x sfaRange)-matrix with rows which contain the directions in expanded space with slow signals. The rows are 
sorted acc. to increasing eigenvalues of C</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+sfaStep">sfaStep</a></code> <code><a href="#topic+sfa2Create">sfa2Create</a></code> <code><a href="#topic+sfa1Step">sfa1Step</a></code>
</p>

<hr>
<h2 id='sfaBSh'>Backslash operator.</h2><span id='topic+sfaBSh'></span>

<h3>Description</h3>

<p>Reproduce what MATLAB's backslash operator can do, using qr() and qr.coef().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfaBSh(X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfaBSh_+3A_x">X</code></td>
<td>
<p>X matrix</p>
</td></tr>
<tr><td><code id="sfaBSh_+3A_y">Y</code></td>
<td>
<p>Y vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns coefficients
</p>

<hr>
<h2 id='sfaCheckCondition'>Check Condition of a matrix for SFA</h2><span id='topic+sfaCheckCondition'></span>

<h3>Description</h3>

<p>Creates warnings with recommendations for different settings, if given matrix is ill-conditioned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfaCheckCondition(matr, datatype)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfaCheckCondition_+3A_matr">matr</code></td>
<td>
<p>matrix to be checked</p>
</td></tr>
<tr><td><code id="sfaCheckCondition_+3A_datatype">datatype</code></td>
<td>
<p>string to identify &quot;input&quot; or &quot;expanded&quot; data</p>
</td></tr>
</table>

<hr>
<h2 id='sfaClassify'>Predict Class for SFA classification</h2><span id='topic+sfaClassify'></span>

<h3>Description</h3>

<p>Create a SFA classification mode, predict &amp; evaluate on new data (xtst,realc_tst).<br />
Author of orig. matlab version: Wolfgang Konen, May 2009 - Jan 2010<br />
See also [Berkes05] Pietro Berkes: Pattern recognition with Slow Feature Analysis. 
Cognitive Sciences EPrint Archive (CogPrint) 4104, http://cogprints.org/4104/ (2005)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfaClassify(x, realclass, xtst = 0, realcTst = 0, opts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfaClassify_+3A_x">x</code></td>
<td>
<p>NREC x IDIM, training input data</p>
</td></tr>
<tr><td><code id="sfaClassify_+3A_realclass">realclass</code></td>
<td>
<p>1 x NREC, training class labels</p>
</td></tr>
<tr><td><code id="sfaClassify_+3A_xtst">xtst</code></td>
<td>
<p>NTST x IDIM, test input data</p>
</td></tr>
<tr><td><code id="sfaClassify_+3A_realctst">realcTst</code></td>
<td>
<p>1 x NTST, test class labels</p>
</td></tr>
<tr><td><code id="sfaClassify_+3A_opts">opts</code></td>
<td>
<p>list with several parameter settings: </p>

<dl>
<dt>gaussdim</dt><dd></dd>
<dt>    ... </dt><dd></dd>
<dt> *Filename</dt><dd><p> [* = s,g,x] from where to load the models (see <code><a href="#topic+sfaClassify">sfaClassify</a></code>)   </p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>list <code>res</code> containing <br />
</p>
<table>
<tr><td><code>res$errtrn</code></td>
<td>
<p> 1 x 2 matrix: error rate with / w/o SFA on training set </p>
</td></tr>
<tr><td><code>res$errtst</code></td>
<td>
<p> 1 x 2 matrix: error rate with / w/o SFA on test set </p>
</td></tr>
<tr><td><code>res$y</code></td>
<td>
<p> output from SFA when applied to training data  </p>
</td></tr>
<tr><td><code>res$ytst</code></td>
<td>
<p> output from SFA when applied to test data  </p>
</td></tr>
<tr><td><code>res$predT</code></td>
<td>
<p> predictions with SFA + GaussClassifier on test set </p>
</td></tr>
<tr><td><code>res$predX</code></td>
<td>
<p> predictions w/o SFA (only GaussClassifier) on test set (only if opts.xFilename exists) </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+sfaClassPredict">sfaClassPredict</a></code> <code><a href="#topic+sfaExecute">sfaExecute</a></code>
</p>

<hr>
<h2 id='sfaClassPredict'>Predict Class for SFA classification</h2><span id='topic+sfaClassPredict'></span>

<h3>Description</h3>

<p>Use a SFA classification model (stored in opts$*Filename), predict &amp; evaluate on new data (xtst,realc_tst).<br />
Author of orig. matlab version: Wolfgang Konen, Jan 2011-Mar 2011.<br />
See also [Berkes05] Pietro Berkes: Pattern recognition with Slow Feature Analysis. 
Cognitive Sciences EPrint Archive (CogPrint) 4104, http://cogprints.org/4104/ (2005)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfaClassPredict(xtst, realcTst, opts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfaClassPredict_+3A_xtst">xtst</code></td>
<td>
<p>NTST x IDIM, test input data</p>
</td></tr>
<tr><td><code id="sfaClassPredict_+3A_realctst">realcTst</code></td>
<td>
<p>1 x NTST, test class labels</p>
</td></tr>
<tr><td><code id="sfaClassPredict_+3A_opts">opts</code></td>
<td>
<p>list with several parameter settings: </p>

<dl>
<dt>gaussdim</dt><dd></dd>
<dt>    ... </dt><dd></dd>
<dt> *Filename</dt><dd><p> [* = s,g,x] from where to load the models (see <code><a href="#topic+sfaClassify">sfaClassify</a></code>)   </p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>list <code>res</code> containing <br />
</p>
<table>
<tr><td><code>res$errtst</code></td>
<td>
<p> 1 x 2 matrix: error rate with / w/o SFA on test set </p>
</td></tr>
<tr><td><code>res$ytst</code></td>
<td>
<p> output from SFA when applied to test data  </p>
</td></tr>
<tr><td><code>res$predT</code></td>
<td>
<p> predictions with SFA + GaussClassifier on test set </p>
</td></tr>
<tr><td><code>res$predX</code></td>
<td>
<p> predictions w/o SFA (only GaussClassifier) on test set (only if opts.xFilename exists) </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+sfaClassify">sfaClassify</a></code> <code><a href="#topic+sfaExecute">sfaExecute</a></code>
</p>

<hr>
<h2 id='sfaExecute'>Execute learned function for input data</h2><span id='topic+sfaExecute'></span>

<h3>Description</h3>

<p>After completion of the learning phase (step=&quot;sfa&quot;) this function can be used
to apply the learned function to the input data. <br />
The execution is completed in 4 steps:<br />
1. projection on the input principal components (dimensionality
reduction)<br />
2. expansion (if necessary)<br />
3. projection on the whitened (expanded) space<br />
4. projection on the slow functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfaExecute(sfaList, DATA, prj = NULL, ncomp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfaExecute_+3A_sfalist">sfaList</code></td>
<td>
<p>A list that contains all information about the handled sfa-structure</p>
</td></tr>
<tr><td><code id="sfaExecute_+3A_data">DATA</code></td>
<td>
<p>Input data, each column a different variable</p>
</td></tr>
<tr><td><code id="sfaExecute_+3A_prj">prj</code></td>
<td>
<p>If not NULL, the preprocessing step 1 is skipped for SFA2</p>
</td></tr>
<tr><td><code id="sfaExecute_+3A_ncomp">ncomp</code></td>
<td>
<p>number of learned functions to be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix <code>DATA</code> containing the calculated output <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sfa2">sfa2</a></code> <code><a href="#topic+sfa1">sfa1</a></code> <code><a href="#topic+sfaStep">sfaStep</a></code>
</p>

<hr>
<h2 id='sfaExpand'>Degree 2 Expansion</h2><span id='topic+sfaExpand'></span>

<h3>Description</h3>

<p>Expand a signal in the space of polynomials of degree 2. 
This is the default expansion function used by rSFA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfaExpand(sfaList, DATA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfaExpand_+3A_sfalist">sfaList</code></td>
<td>
<p>A list that contains all information about the handled sfa-structure</p>
</td></tr>
<tr><td><code id="sfaExpand_+3A_data">DATA</code></td>
<td>
<p>Input data, each column a different variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>expanded matrix <code>DATA</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sfa2">sfa2</a></code> <code><a href="#topic+nlExpand">nlExpand</a></code> <code><a href="#topic+xpDim">xpDim</a></code>
</p>

<hr>
<h2 id='sfaGetHf'>Return a SFA function as a quadratic form.</h2><span id='topic+sfaGetHf'></span>

<h3>Description</h3>

<p>sfaGetHf returns function number NR in the
sfa object referenced by HDL in the form of a quadratic form<br />
q(x) = 1/2*x'*H*x + f'*x + c<br />
Of course, this only works if a quadratic expansion was used during
training.
The quadratic form can lie in different spaces, i.e. it can receive
as input preprocessed or non-preprocessed vectors. This is specified
by setting the argument WHERE. The quadratic form lies
- in the preprocessed space for WHERE==0 (e.g. the whitened space if
the preprocessing type is PCA)
- in the PCA space (i.e. projected on the principal components but
not whitened, works only if PCA was used for preprocessing) for
WHERE==1
- in the input, mean-free space for WHERE==2
- in the input space for WHERE==3
In general you will need to set WHERE to 2 or 3, but working in the
preprocessed spaces can often drastically improve the speed of
analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfaGetHf(sfaList, nr, where)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfaGetHf_+3A_sfalist">sfaList</code></td>
<td>
<p>A list that contains all information about the handled sfa-structure</p>
</td></tr>
<tr><td><code id="sfaGetHf_+3A_nr">nr</code></td>
<td>
<p>function number</p>
</td></tr>
<tr><td><code id="sfaGetHf_+3A_where">where</code></td>
<td>
<p>WHERE parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list <code>res</code> <br />
- <code>res</code> contains:
<code>res$H</code>
<code>res$f</code>
<code>res$c</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sfa2Create">sfa2Create</a></code>
</p>

<hr>
<h2 id='sfaGetIntRange'>Helper Function of SFA.</h2><span id='topic+sfaGetIntRange'></span>

<h3>Description</h3>

<p>Helper Function of SFA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfaGetIntRange(range)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfaGetIntRange_+3A_range">range</code></td>
<td>
<p>Range</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector <code>int</code>
</p>

<hr>
<h2 id='sfaLoad'>Load a SFA object.</h2><span id='topic+sfaLoad'></span>

<h3>Description</h3>

<p>Load a SFA object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfaLoad(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfaLoad_+3A_filename">filename</code></td>
<td>
<p>Load list <code>sfaList</code> from this file name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list <code>sfaList</code>
</p>


<h3>References</h3>

<p><code><a href="#topic+sfaSave">sfaSave</a></code>
</p>

<hr>
<h2 id='sfaNlRegress'>Perform non-linear regression</h2><span id='topic+sfaNlRegress'></span>

<h3>Description</h3>

<p>Given the data in arg, expand them nonlinearly in the same way as it was
done in the SFA-object sfaList (expanded dimension M) and search the vector
RCOEF of M constant coefficients, such that the sum of squared residuals 
between a given function in time FUNC and the function<br />
R(t) = (v(t) - v0)' * RCOEF,        t=1,...,T,<br />
is minimal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfaNlRegress(sfaList, arg, func)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfaNlRegress_+3A_sfalist">sfaList</code></td>
<td>
<p>A list that contains all information about the handled sfa-structure</p>
</td></tr>
<tr><td><code id="sfaNlRegress_+3A_arg">arg</code></td>
<td>
<p>Input data, each column a different variable</p>
</td></tr>
<tr><td><code id="sfaNlRegress_+3A_func">func</code></td>
<td>
<p>(T x 1) the function to be fitted nonlinearly</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list <code>res</code> with elements<br />
</p>
<table>
<tr><td><code>res$R</code></td>
<td>
<p> (T x 1) the function fitted by NL-regression  </p>
</td></tr>
<tr><td><code>res$rcoef</code></td>
<td>
<p> (M x 1) the coefficients for the NL-expanded dimensions  </p>
</td></tr>
</table>

<hr>
<h2 id='sfaPBootstrap'>Parametric Bootstrap</h2><span id='topic+sfaPBootstrap'></span>

<h3>Description</h3>

<p>If training set too small, augment it with parametric bootstrap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfaPBootstrap(realclass, x, sfaList)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfaPBootstrap_+3A_realclass">realclass</code></td>
<td>
<p>true class of training data (can be vector, numerics, integers, factors)</p>
</td></tr>
<tr><td><code id="sfaPBootstrap_+3A_x">x</code></td>
<td>
<p>matrix containing the training data</p>
</td></tr>
<tr><td><code id="sfaPBootstrap_+3A_sfalist">sfaList</code></td>
<td>
<p>list with several parameter settings, e.g. as created by <code><a href="#topic+sfa2Create">sfa2Create</a></code><br />
<code>sfaList$xpDimFun</code> (=xpDim by default) calculated dimension of expaned SFA space<br />
<code>sfaList$deg</code> degree of expansion (should not be 1, not implemented)<br />
<code>sfaList$ppRange</code> ppRange for SFA algorithm<br />
<code>sfaList$nclass</code> number of unique classes<br />
<code>sfaList$doPB</code> do (1) or do no (0) param. bootstrap.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list <code>list</code> containing:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p> training set extended to minimu number of recors1.5*(xpdim+nclass), if necessary </p>
</td></tr>
<tr><td><code>realclass</code></td>
<td>
<p> training class labels, extended analogously  </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+addNoisyCopies">addNoisyCopies</a></code>
</p>

<hr>
<h2 id='sfaPreproc'>Preprocessing for SFA classification</h2><span id='topic+sfaPreproc'></span>

<h3>Description</h3>

<p>Helper function for  <code><a href="#topic+sfaClassify">sfaClassify</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfaPreproc(sfaList, x, opts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfaPreproc_+3A_sfalist">sfaList</code></td>
<td>
<p>A list that contains all information about the handled sfa-structure</p>
</td></tr>
<tr><td><code id="sfaPreproc_+3A_x">x</code></td>
<td>
<p>Input data, each column a different variable</p>
</td></tr>
<tr><td><code id="sfaPreproc_+3A_opts">opts</code></td>
<td>
<p>list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>preprocessed data
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sfaClassPredict">sfaClassPredict</a></code> <code><a href="#topic+sfaClassify">sfaClassify</a></code>
</p>

<hr>
<h2 id='sfaSave'>Save a SFA object.</h2><span id='topic+sfaSave'></span>

<h3>Description</h3>

<p>Save a SFA object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfaSave(sfaList, filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfaSave_+3A_sfalist">sfaList</code></td>
<td>
<p>A list that contains all information about the handled sfa-structure</p>
</td></tr>
<tr><td><code id="sfaSave_+3A_filename">filename</code></td>
<td>
<p>Save list <code>sfaList</code> to this file</p>
</td></tr>
</table>


<h3>References</h3>

<p><code><a href="#topic+sfaLoad">sfaLoad</a></code>
</p>

<hr>
<h2 id='sfaStep'>Update a step of the SFA algorithm.</h2><span id='topic+sfaStep'></span>

<h3>Description</h3>

<p>sfaStep() updates the current step of the SFA algorithm. Depending on <code>sfaList$deg</code>
it calls either <code><a href="#topic+sfa1Step">sfa1Step</a></code> or <code><a href="#topic+sfa2Step">sfa2Step</a></code> to do the main work. 
See further documentation there
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfaStep(sfaList, arg, step = NULL, method = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfaStep_+3A_sfalist">sfaList</code></td>
<td>
<p>A list that contains all information about the handled sfa-structure</p>
</td></tr>
<tr><td><code id="sfaStep_+3A_arg">arg</code></td>
<td>
<p>Input data, each column a different variable</p>
</td></tr>
<tr><td><code id="sfaStep_+3A_step">step</code></td>
<td>
<p>Specifies the current SFA step.  Must be given in the right sequence: 
for SFA1 objects:  &quot;preprocessing&quot;, &quot;sfa&quot;<br />
for SFA2 objects:  &quot;preprocessing&quot;, &quot;expansion&quot;, &quot;sfa&quot;        
Each time a new step is invoked, the previous one is closed, which
might take some time.</p>
</td></tr>
<tr><td><code id="sfaStep_+3A_method">method</code></td>
<td>
<p>Method to be used: For <code>sfaList$step="expansion"</code> the choices are &quot;TIMESERIES&quot; or &quot;CLASSIF&quot;. <br />
For <code>sfaList$step="sfa"</code> (<code><a href="#topic+sfa2Step">sfa2Step</a></code> only) the choices are &quot;SVDSFA&quot; (recommended) or &quot;GENEIG&quot; (unstable).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list <code>sfaList</code> taken from the input, with new information added to this list. 
See <code><a href="#topic+sfa1Step">sfa1Step</a></code> or <code><a href="#topic+sfa2Step">sfa2Step</a></code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sfa1Step">sfa1Step</a></code> <code><a href="#topic+sfa2Step">sfa2Step</a></code>  <code><a href="#topic+sfa1Create">sfa1Create</a></code> <code><a href="#topic+sfa2Create">sfa2Create</a></code> <code><a href="#topic+sfaExecute">sfaExecute</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   ## Suppose you have divided your training data into two chunks,
   ## DATA1 and DATA2. Let the number of input dimensions be N. To apply
   ## SFA on them write:
   ## Not run:  
   sfaList = sfa2Create(N,xpDim(N))
   sfaList = sfaStep(sfaList, DATA1, "preprocessing")
   sfaList = sfaStep(sfaList, DATA2)
   sfaList = sfaStep(sfaList, DATA1, "expansion")
   sfaList = sfaStep(sfaList, DATA2)
   sfaList = sfaStep(sfaList, NULL, "sfa")
   output1 = sfaExecute(sfaList, DATA1)
   output2 = sfaExecute(sfaList, DATA2)
   
## End(Not run)

</code></pre>

<hr>
<h2 id='sfaTimediff'>Calculates the first derivative of signal data</h2><span id='topic+sfaTimediff'></span>

<h3>Description</h3>

<p>Calculates the first derivative of signal data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfaTimediff(DATA, axType = "ORD1")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfaTimediff_+3A_data">DATA</code></td>
<td>
<p>The matrix of signals for which the derivative is calculated (one column per signal)</p>
</td></tr>
<tr><td><code id="sfaTimediff_+3A_axtype">axType</code></td>
<td>
<p>Type of interpolation: &quot;ORD1&quot; (default) first order, &quot;SCD&quot; second ,&quot;TRD&quot; third, &quot;ORD3a&quot; cubic polynom</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix <code>DATA</code> <br />
- <code>DATA</code> contains the derivative signals, with the same structure as the input data.
</p>


<h3>Note</h3>

<p>setting axType to invalid values will lead to first order interpolation.
</p>

<hr>
<h2 id='xpDim'>Degree 2 Dimension Calculation</h2><span id='topic+xpDim'></span>

<h3>Description</h3>

<p>Compute the dimension of a vector expanded in the space of
polynomials of 2nd degree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xpDim(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xpDim_+3A_n">n</code></td>
<td>
<p>Dimension of input vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dimension of expanded vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sfa2">sfa2</a></code> <code><a href="#topic+sfaExpand">sfaExpand</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
