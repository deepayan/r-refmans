<!DOCTYPE html><html><head><title>Help for package PLRModels</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PLRModels}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#PLRModels-package'>
<p>Statistical inference in partial linear regression models</p></a></li>
<li><a href='#barnacles1'>
<p>Sales of barnacles in Cedeira</p></a></li>
<li><a href='#barnacles2'>
<p>Sales of barnacles in Cangas</p></a></li>
<li><a href='#best.arima'><p>Best Arima model according some information criterion</p></a></li>
<li><a href='#Epanechnikov'><p>The Epanechnikov kernel</p></a></li>
<li><a href='#gaussian'><p>The gaussian kernel</p></a></li>
<li><a href='#np.ancova'>
<p>Nonparametric analysis of covariance</p></a></li>
<li><a href='#np.cv'>
<p>Cross-validation bandwidth selection in nonparametric regression models</p></a></li>
<li><a href='#np.est'><p>Nonparametric estimate of the regression function</p></a></li>
<li><a href='#np.gcv'>
<p>Generalized cross-validation bandwidth selection in nonparametric regression models</p></a></li>
<li><a href='#np.gof'>
<p>Goodness-of-Fit tests in nonparametric regression models</p></a></li>
<li><a href='#par.ancova'>
<p>Parametric analysis of covariance (based on linear models)</p></a></li>
<li><a href='#par.ci'>
<p>Confidence intervals estimation in linear regression models</p></a></li>
<li><a href='#par.est'>
<p>Estimation in linear regression models</p></a></li>
<li><a href='#par.gof'>
<p>Goodness-of-Fit tests in linear regression models</p></a></li>
<li><a href='#plrm.ancova'>
<p>Semiparametric analysis of covariance (based on PLR models)</p></a></li>
<li><a href='#plrm.beta'>
<p>Semiparametric estimate for the parametric component of the regression function in PLR models</p></a></li>
<li><a href='#plrm.ci'>
<p>Confidence intervals estimation in partial linear regression models</p></a></li>
<li><a href='#plrm.cv'>
<p>Cross-validation bandwidth selection in PLR models</p></a></li>
<li><a href='#plrm.est'>
<p>Semiparametric estimates for the unknown components of the regression function in PLR models</p></a></li>
<li><a href='#plrm.gcv'>
<p>Generalized cross-validation bandwidth selection in PLR models</p></a></li>
<li><a href='#plrm.gof'>
<p>Goodness-of-Fit tests in PLR models</p></a></li>
<li><a href='#quadratic'><p>The quadratic kernel</p></a></li>
<li><a href='#symsolve'><p>Solution of a system of linear equations</p></a></li>
<li><a href='#triweight'><p>The triweight kernel</p></a></li>
<li><a href='#uniform'><p>The uniform kernel</p></a></li>
<li><a href='#var.cov.matrix'><p>Estimated variance-covariance matrix from time series</p></a></li>
<li><a href='#var.cov.sum'><p>Estimated sum of autocovariances from time series</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Inference in Partial Linear Regression Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-19</td>
</tr>
<tr>
<td>Author:</td>
<td>German Aneiros Perez and Ana Lopez-Cheda</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ana Lopez-Cheda &lt;ana.lopez.cheda@udc.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains statistical inference tools applied to Partial Linear Regression (PLR) models. Specifically, point estimation, confidence intervals estimation, bandwidth selection, goodness-of-fit tests and analysis of covariance are considered. Kernel-based methods, combined with ordinary least squares estimation, are used and time series errors are allowed. In addition, these techniques are also implemented for both parametric (linear) and nonparametric regression models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-19 10:19:59 UTC; Ana</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-19 10:42:44 UTC</td>
</tr>
</table>
<hr>
<h2 id='PLRModels-package'>
Statistical inference in partial linear regression models
</h2><span id='topic+PLRModels-package'></span><span id='topic+PLRModels'></span>

<h3>Description</h3>

<p>This package provides statistical inference tools applied to Partial Linear Regression (PLR) models. Specifically, point estimation, confidence intervals estimation, bandwidth selection, goodness-of-fit tests and analysis of covariance are considered. Kernel-based methods, combined with ordinary least squares estimation, are used and time series errors are allowed. In addition, these techniques are also implemented for both parametric (linear) and nonparametric regression models.
</p>


<h3>Details</h3>

<p>The most important functions are those directly related with the PLR models; that is, <code>plrm.gcv</code>, <code>plrm.cv</code>, <code>plrm.beta</code>, <code>plrm.est</code>, <code>plrm.gof</code>, <code>plrm.ancova</code> and <code>plrm.ci</code>. Although the other functions included in the package are auxiliary ones, they can be used independiently.
</p>


<h3>Author(s)</h3>

<p>Authors: 
German Aneiros Perez &lt;ganeiros@udc.es&gt;
</p>
<p>Ana Lopez Cheda &lt;ana.lopez.cheda@udc.es&gt;
</p>
<p>Maintainer: Ana Lopez Cheda &lt;ana.lopez.cheda@udc.es&gt;
</p>

<hr>
<h2 id='barnacles1'>
Sales of barnacles in Cedeira
</h2><span id='topic+barnacles1'></span>

<h3>Description</h3>

<p>Information about sales and prices of barnacles in two galician towns for each month from 2004 to 2013. The data have been transformed using the logarithm function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(barnacles1)</code></pre>


<h3>Format</h3>

<p>A matrix containing 3 columns: 
</p>
<p><code>barnacles1[, 1]</code> contains the number of sales (in kg) of barnacles in Cedeira's fish market;
</p>
<p><code>barnacles1[, 2]</code> contains the prices (in euro/kg) of the barnacles in Cedeira's fish market;
</p>
<p><code>barnacles1[, 3]</code> contains the number of sales (in kg) of barnacles in Carino's fish market.
</p>


<h3>Source</h3>

<p><a href="http://dm.udc.es/modes/sites/default/files/barnacles1.rar">http://dm.udc.es/modes/sites/default/files/barnacles1.rar</a>
<a href="http://dm.udc.es/modes/sites/default/files/barnacles1.zip">http://dm.udc.es/modes/sites/default/files/barnacles1.zip</a>
</p>

<hr>
<h2 id='barnacles2'>
Sales of barnacles in Cangas
</h2><span id='topic+barnacles2'></span>

<h3>Description</h3>

<p>Information about sales and prices of barnacles in two galician towns for each month from 2004 to 2013. The data have been transformed using the logarithm function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(barnacles2)</code></pre>


<h3>Format</h3>

<p>A matrix containing 3 columns: 
</p>
<p><code>barnacles1[, 1]</code> contains the number of sales (in kg) of barnacles in Cangas' fish market;
</p>
<p><code>barnacles1[, 2]</code> contains the prices (in euro/kg) of the barnacles in Cangas' fish market;
</p>
<p><code>barnacles1[, 3]</code> contains the number of sales (in kg) of barnacles in Baiona's fish market.
</p>


<h3>Source</h3>

<p><a href="http://dm.udc.es/modes/sites/default/files/barnacles2.rar">http://dm.udc.es/modes/sites/default/files/barnacles2.rar</a> 
<a href="http://dm.udc.es/modes/sites/default/files/barnacles2.zip">http://dm.udc.es/modes/sites/default/files/barnacles2.zip</a>
</p>

<hr>
<h2 id='best.arima'>Best Arima model according some information criterion
</h2><span id='topic+best.arima'></span>

<h3>Description</h3>

<p>Obtains the orders p, q, P and Q of the best ARIMA (p, d, q)x(P, D, Q)_s according one of the following information criteria: AIC, AICC, BIC.
It allows ARIMAs with both constant term and differentiation (d+D!=0), besides the ordinary cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>best.arima(x = x, order.max = c(0, 0, 0), seasonal = list(order.max = c(0, 0, 0), 
period = 1), include.mean = NULL, criterio = NULL, dist.max.crit = NULL, 
method = NULL)
</code></pre>

<hr>
<h2 id='Epanechnikov'>The Epanechnikov kernel
</h2><span id='topic+Epanechnikov'></span>

<h3>Description</h3>

<p>The Epanechnikov kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Epanechnikov(u)
</code></pre>

<hr>
<h2 id='gaussian'>The gaussian kernel
</h2><span id='topic+gaussian'></span>

<h3>Description</h3>

<p>The gaussian kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian(u)
</code></pre>

<hr>
<h2 id='np.ancova'>
Nonparametric analysis of covariance
</h2><span id='topic+np.ancova'></span>

<h3>Description</h3>

<p>This routine tests the equality of <code class="reqn">L</code> nonparametric regression curves (<code class="reqn">m_1, ..., m_L</code>) from samples <code class="reqn">{(Y_{ki}, t_i): i=1,...,n}</code>, <code class="reqn">k=1,...,L</code>, where:
</p>
<p style="text-align: center;"><code class="reqn">Y_{ki}= m_k(t_i) + \epsilon_{ki}.</code>
</p>

<p>The unknown functions <code class="reqn">m_k</code> are smooth, fixed equally spaced design is considered, and the random errors, <code class="reqn">\epsilon_{ki}</code>, are allowed to be time series. The test statistic used for testing the null hypothesis, <code class="reqn">H0: m_1 = ...= m_L</code>, derives from a Cramer-von-Mises-type functional based on different distances between nonparametric estimators of the regression functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>np.ancova(data = data, h.seq = NULL, w = NULL, estimator = "NW", 
kernel = "quadratic", time.series = FALSE, Tau.eps = NULL, 
h0 = NULL, lag.max = 50, p.max = 3, q.max = 3, ic = "BIC", 
num.lb = 10, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="np.ancova_+3A_data">data</code></td>
<td>

<p><code>data[, k]</code> contains the values of the response variable, <code class="reqn">Y_k</code>, for each model <code class="reqn">k</code> (<code class="reqn">k=1, ..., L</code>);
</p>
<p><code>data[, L+1]</code> contains the values of the explanatory (common) variable, <code class="reqn">t</code>, for each model <code class="reqn">k</code> (<code class="reqn">k=1, ..., L</code>).
</p>
</td></tr>
<tr><td><code id="np.ancova_+3A_h.seq">h.seq</code></td>
<td>
<p>the statistic test is performed using each bandwidth in the vector <code>h.seq</code> (the same bandwidth is used to estimate all the regression functions). If <code>NULL</code> (the default), 10 equidistant values between 0 and the first half of the range of <code class="reqn">{t_i}</code> are considered.</p>
</td></tr>
<tr><td><code id="np.ancova_+3A_w">w</code></td>
<td>
<p>support interval of the weigth function in the test statistic. If <code>NULL</code> (the default), <code class="reqn">(q_{0.1}, q_{0.9})</code> is considered, where <code class="reqn">q_p</code> denotes the quantile of order <code class="reqn">p</code> of <code class="reqn">{t_i}</code>.</p>
</td></tr>
<tr><td><code id="np.ancova_+3A_estimator">estimator</code></td>
<td>
<p>allows us the choice between &ldquo;NW&rdquo; (Nadaraya-Watson) or &ldquo;LLP&rdquo; (Local Linear Polynomial). The default is &ldquo;NW&rdquo;.</p>
</td></tr>
<tr><td><code id="np.ancova_+3A_kernel">kernel</code></td>
<td>
<p>allows us the choice between &ldquo;gaussian&rdquo;, &ldquo;quadratic&rdquo; (Epanechnikov kernel), &ldquo;triweight&rdquo; or &ldquo;uniform&rdquo; kernel. The default is &ldquo;quadratic&rdquo;.</p>
</td></tr>
<tr><td><code id="np.ancova_+3A_time.series">time.series</code></td>
<td>
<p>it denotes whether the data are independent (FALSE) or if data is a time series (TRUE). The default is FALSE.</p>
</td></tr>
<tr><td><code id="np.ancova_+3A_tau.eps">Tau.eps</code></td>
<td>
<p><code>Tau.eps[k]</code> contains the sum of autocovariances associated to the random errors of the regression model <code class="reqn">k</code> (<code class="reqn">k=1, ..., L</code>). If NULL (the default), the function tries to estimate it: it fits an ARMA model (selected according to an information criterium) to the residuals from the fitted nonparametric regression model and, then, it obtains the sum of the autocovariances of such ARMA model.</p>
</td></tr>
<tr><td><code id="np.ancova_+3A_h0">h0</code></td>
<td>
<p>if <code>Tau.eps=NULL</code>, <code>h0</code> contains the pilot bandwidth used for obtaining the residuals to construct the default for <code>Tau.eps</code>. If <code>NULL</code> (the default), a quarter of the range of <code class="reqn">{t_i}</code> is considered.</p>
</td></tr>
<tr><td><code id="np.ancova_+3A_lag.max">lag.max</code></td>
<td>
<p>if <code>Tau.eps=NULL</code>, <code>lag.max</code> contains the maximum delay used to construct the default for <code>Tau.eps</code>. The default is 50.</p>
</td></tr>
<tr><td><code id="np.ancova_+3A_p.max">p.max</code></td>
<td>
<p>if <code>Tau.eps=NULL</code>, the ARMA models are selected between the models ARMA(p,q) with 0&lt;=p&lt;=<code>p.max</code> and 0&lt;=q&lt;=<code>q.max</code>. The default is 3.</p>
</td></tr>
<tr><td><code id="np.ancova_+3A_q.max">q.max</code></td>
<td>
<p>if <code>Tau.eps=NULL</code>, the ARMA models are selected between the models ARMA(p,q) with 0&lt;=p&lt;=<code>p.max</code> and 0&lt;=q&lt;=<code>q.max</code>. The default is 3.</p>
</td></tr>
<tr><td><code id="np.ancova_+3A_ic">ic</code></td>
<td>
<p>if <code>Tau.eps=NULL</code>, <code>ic</code> contains the information criterion used to suggest the ARMA models. It allows us to choose between: &quot;AIC&quot;, &quot;AICC&quot; or &quot;BIC&quot; (the default).</p>
</td></tr>
<tr><td><code id="np.ancova_+3A_num.lb">num.lb</code></td>
<td>
<p>if <code>Tau.eps=NULL</code>, it checks the suitability of the selected ARMA models according to the Ljung-Box test and the t-test. It uses up to <code>num.lb</code> delays in the Ljung-Box test. The default is 10.</p>
</td></tr>
<tr><td><code id="np.ancova_+3A_alpha">alpha</code></td>
<td>
<p>if <code>Tau.eps=NULL</code>, <code>alpha</code> contains the significance level which the ARMA models are checked. The default is 0.05.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A weight function (specifically, the indicator function <b>1</b><code class="reqn">_{[w[1] , w[2]]}</code>) is introduced in the test statistic to allow elimination (or at least significant reduction) of boundary effects from the estimate of <code class="reqn">m(t_i)</code>.
</p>
<p>If <code>Tau.eps=NULL</code> and the routine is not able to suggest an approximation for <code>Tau.eps</code>, it warns the user with a message saying that the model could be not appropriate and then it shows the results. In order to construct <code>Tau.eps</code>, the procedures suggested in Muller and Stadmuller (1988) and Herrmann <em>et al.</em> (1992) can be followed.
</p>
<p>For more details, see Vilar-Fernandez and Gonzalez-Manteiga (2004).
</p>


<h3>Value</h3>

<p>A list with a dataframe containing:
</p>
<table>
<tr><td><code>h.seq</code></td>
<td>
<p>sequence of bandwidths used in the test statistic.</p>
</td></tr>
<tr><td><code>Q.m</code></td>
<td>
<p>values of the test statistic (one for each bandwidth in <code>h.seq</code>).</p>
</td></tr>
<tr><td><code>Q.m.normalised</code></td>
<td>
<p>normalised value of Q.m.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>p-values of the corresponding statistic tests (one for each bandwidth in <code>h.seq</code>).</p>
</td></tr>
</table>
<p>Moreover, if <code>data</code> is a time series and <code>Tau.eps</code> is not especified:
</p>
<table>
<tr><td><code>pv.Box.test</code></td>
<td>
<p>p-values of the Ljung-Box test for the model fitted to the residuals.</p>
</td></tr>
<tr><td><code>pv.t.test</code></td>
<td>
<p>p-values of the t.test for the model fitted to the residuals.</p>
</td></tr>
<tr><td><code>ar.ma</code></td>
<td>
<p>ARMA orders for the model fitted to the residuals.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>German Aneiros Perez <a href="mailto:ganeiros@udc.es">ganeiros@udc.es</a> 
</p>
<p>Ana Lopez Cheda <a href="mailto:ana.lopez.cheda@udc.es">ana.lopez.cheda@udc.es</a></p>


<h3>References</h3>

<p>Dette, H. and Neumeyer, N. (2001) Nonparametric analysis of covariance.
<em>Ann. Statist.</em> <b>29</b>, no. 5, 1361-1400.
</p>
<p>Herrmann, E., Gasser, T. and Kneip, A. (1992) Choice of bandwidth for kernel regression when residuals are correlated. <em>Biometrika</em> <b>79</b>, 783-795
</p>
<p>Muller, H.G. and Stadmuller, U. (1988) Detecting dependencies in smooth regression models. <em>Biometrika</em> <b>75</b>, 639-650
</p>
<p>Vilar-Fernandez, J.M. and Gonzalez-Manteiga, W. (2004) Nonparametric comparison of curves with dependent errors. <em>Statistics</em> <b>38</b>, 81-99.
</p>


<h3>See Also</h3>

<p>Other related functions are <code><a href="#topic+np.est">np.est</a></code>, <code><a href="#topic+par.ancova">par.ancova</a></code> and <code><a href="#topic+plrm.ancova">plrm.ancova</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># EXAMPLE 1: REAL DATA
data &lt;- matrix(10,120,2)
data(barnacles1)
barnacles1 &lt;- as.matrix(barnacles1)
data[,1] &lt;- barnacles1[,1]
data &lt;- diff(data, 12)
data[,2] &lt;- 1:nrow(data)

data2 &lt;- matrix(10,120,2)
data(barnacles2)
barnacles2 &lt;- as.matrix(barnacles2)
data2[,1] &lt;- barnacles2[,1]
data2 &lt;- diff(data2, 12)
data2[,2] &lt;- 1:nrow(data2)

data3 &lt;- matrix(0, nrow(data),ncol(data)+1)
data3[,1] &lt;- data[,1]
data3[,2:3] &lt;- data2

np.ancova(data=data3)



# EXAMPLE 2: SIMULATED DATA
## Example 2.1: dependent data: true null hypothesis

set.seed(1234)
# We generate the data
n &lt;- 100
t &lt;- ((1:n)-0.5)/n
m1 &lt;- function(t) {0.25*t*(1-t)}
f &lt;- m1(t)

epsilon1 &lt;- arima.sim(list(order = c(1,0,0), ar=0.7), sd = 0.01, n = n)
y1 &lt;-  f + epsilon1

epsilon2 &lt;- arima.sim(list(order = c(0,0,1), ma=0.5), sd = 0.02, n = n)
y2 &lt;- f + epsilon2

data_eq &lt;- cbind(y1, y2, t)

# We apply the test
np.ancova(data_eq, time.series=TRUE)


## Example 2.2: dependent data: false null hypothesis
# We generate the data
n &lt;- 100
t &lt;- ((1:n)-0.5)/n
m3 &lt;- function(t) {0.25*t*(1-t)}
m4 &lt;- function(t) {0.25*t*(1-t)*0.75}

f3 &lt;- m3(t)
epsilon3 &lt;- arima.sim(list(order = c(1,0,0), ar=0.7), sd = 0.01, n = n)
y3 &lt;-  f3 + epsilon3

f4 &lt;- m4(t)
epsilon4 &lt;- arima.sim(list(order = c(0,0,1), ma=0.5), sd = 0.02, n = n)
y4 &lt;-  f4 + epsilon4

data_neq&lt;- cbind(y3, y4, t)

# We apply the test
np.ancova(data_neq, time.series=TRUE)

</code></pre>

<hr>
<h2 id='np.cv'>
Cross-validation bandwidth selection in nonparametric regression models
</h2><span id='topic+np.cv'></span>

<h3>Description</h3>

<p>From a sample <code class="reqn">{(Y_i, t_i): i=1,...,n}</code>, this routine computes, for each <code class="reqn">l_n</code> considered, an optimal bandwidth for estimating <code class="reqn">m</code> in the regression model
</p>
<p style="text-align: center;"><code class="reqn">Y_i= m(t_i) + \epsilon_i.</code>
</p>

<p>The regression function, <code class="reqn">m</code>, is a smooth but unknown function, and the random errors, <code class="reqn">{\epsilon_i}</code>, are allowed to be time series. The optimal bandwidth is selected by means of the leave-(<code class="reqn">2l_n + 1</code>)-out cross-validation procedure. Kernel smoothing is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>np.cv(data = data, h.seq = NULL, num.h = 50, w = NULL, num.ln = 1, 
ln.0 = 0, step.ln = 2, estimator = "NW", kernel = "quadratic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="np.cv_+3A_data">data</code></td>
<td>

<p><code>data[, 1]</code> contains the values of the response variable, <code class="reqn">Y</code>;
</p>
<p><code>data[, 2]</code> contains the values of the explanatory variable, <code class="reqn">t</code>.
</p>
</td></tr>
<tr><td><code id="np.cv_+3A_h.seq">h.seq</code></td>
<td>
<p>sequence of considered bandwidths in the CV function. If <code>NULL</code> (the default), <code>num.h</code> equidistant values between zero and a quarter of the range of <code class="reqn">t_i</code> are considered.</p>
</td></tr>
<tr><td><code id="np.cv_+3A_num.h">num.h</code></td>
<td>
<p>number of values used to build the sequence of considered bandwidths. If <code>h.seq</code> is not <code>NULL</code>, <code>num.h=length(h.seq)</code>. Otherwise, the default is 50.</p>
</td></tr>
<tr><td><code id="np.cv_+3A_w">w</code></td>
<td>
<p>support interval of the weigth function in the CV function. If <code>NULL</code> (the default), <code class="reqn">(q_{0.1}, q_{0.9})</code> is considered, where <code class="reqn">q_p</code> denotes the quantile of order <code class="reqn">p</code> of <code class="reqn">{t_i}</code>.</p>
</td></tr>
<tr><td><code id="np.cv_+3A_num.ln">num.ln</code></td>
<td>
<p>number of values for <code class="reqn">l_n</code>: <code class="reqn">2l_{n} + 1</code> observations around each point <code class="reqn">t_i</code> are eliminated to estimate <code class="reqn">m(t_i)</code> in the CV function. The default is 1.</p>
</td></tr>
<tr><td><code id="np.cv_+3A_ln.0">ln.0</code></td>
<td>
<p>minimum value for <code class="reqn">l_n</code>. The default is 0.</p>
</td></tr>
<tr><td><code id="np.cv_+3A_step.ln">step.ln</code></td>
<td>
<p>distance between two consecutives values of <code class="reqn">l_n</code>. The default is 2.</p>
</td></tr>
<tr><td><code id="np.cv_+3A_estimator">estimator</code></td>
<td>
<p>allows us the choice between &ldquo;NW&rdquo; (Nadaraya-Watson) or &ldquo;LLP&rdquo; (Local Linear Polynomial). The default is &ldquo;NW&rdquo;.</p>
</td></tr>
<tr><td><code id="np.cv_+3A_kernel">kernel</code></td>
<td>
<p>allows us the choice between &ldquo;gaussian&rdquo;, &ldquo;quadratic&rdquo; (Epanechnikov kernel), &ldquo;triweight&rdquo; or &ldquo;uniform&rdquo; kernel. The default is &ldquo;quadratic&rdquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A weight function (specifically, the indicator function <b>1</b><code class="reqn">_{[w[1] , w[2]]}</code>) is introduced in the CV function to allow elimination (or at least significant reduction) of boundary effects from the estimate of <code class="reqn">m(t_i)</code>.
</p>
<p>For more details, see Chu and Marron (1991).
</p>


<h3>Value</h3>

<table>
<tr><td><code>h.opt</code></td>
<td>
<p>dataframe containing, for each <code>ln</code> considered, the selected value for the bandwidth.</p>
</td></tr>
<tr><td><code>CV.opt</code></td>
<td>
<p><code>CV.opt[k]</code> is the minimum value of the CV function when de k-th value of <code>ln</code> is considered.</p>
</td></tr>
<tr><td><code>CV</code></td>
<td>
<p>matrix containing the values of the CV function for each bandwidth and <code>ln</code> considered.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>support interval of the weigth function in the CV function.</p>
</td></tr>
<tr><td><code>h.seq</code></td>
<td>
<p>sequence of considered bandwidths in the CV function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>German Aneiros Perez <a href="mailto:ganeiros@udc.es">ganeiros@udc.es</a>
</p>
<p>Ana Lopez Cheda <a href="mailto:ana.lopez.cheda@udc.es">ana.lopez.cheda@udc.es</a></p>


<h3>References</h3>

<p>Chu, C-K and Marron, J.S. (1991) Comparison of two bandwidth selectors with dependent errors. <em>The Annals of Statistics</em> <b>19</b>, 1906-1918.
</p>


<h3>See Also</h3>

<p>Other related functions are: <code><a href="#topic+np.est">np.est</a></code>, <code><a href="#topic+np.gcv">np.gcv</a></code>, <code><a href="#topic+plrm.est">plrm.est</a></code>, <code><a href="#topic+plrm.gcv">plrm.gcv</a></code> and <code><a href="#topic+plrm.cv">plrm.cv</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># EXAMPLE 1: REAL DATA
data &lt;- matrix(10,120,2)
data(barnacles1)
barnacles1 &lt;- as.matrix(barnacles1)
data[,1] &lt;- barnacles1[,1]
data &lt;- diff(data, 12)
data[,2] &lt;- 1:nrow(data)

aux &lt;- np.cv(data, ln.0=1,step.ln=1, num.ln=2)
aux$h.opt
plot.ts(aux$CV)

par(mfrow=c(2,1))
plot(aux$h.seq,aux$CV[,1], xlab="h", ylab="CV", type="l", main="ln=1")
plot(aux$h.seq,aux$CV[,2], xlab="h", ylab="CV", type="l", main="ln=2")



# EXAMPLE 2: SIMULATED DATA
## Example 2a: independent data

set.seed(1234)
# We generate the data
n &lt;- 100
t &lt;- ((1:n)-0.5)/n
m &lt;- function(t) {0.25*t*(1-t)}
f &lt;- m(t)

epsilon &lt;- rnorm(n, 0, 0.01)
y &lt;-  f + epsilon
data_ind &lt;- matrix(c(y,t),nrow=100)

# We apply the function
a &lt;-np.cv(data_ind)
a$CV.opt

CV &lt;- a$CV
h &lt;- a$h.seq
plot(h,CV,type="l")

</code></pre>

<hr>
<h2 id='np.est'>Nonparametric estimate of the regression function</h2><span id='topic+np.est'></span>

<h3>Description</h3>

<p>This routine computes estimates for <code class="reqn">m(newt_j)</code> (<code class="reqn">j=1,...,J</code>) from a sample <code class="reqn">{(Y_i, t_i): i=1,...,n}</code>, where:
</p>
<p style="text-align: center;"><code class="reqn">Y_i= m(t_i) + \epsilon_i.</code>
</p>

<p>The regression function, <code class="reqn">m</code>, is a smooth but unknown function, and the random errors, <code class="reqn">{\epsilon_i}</code>, are allowed to be time series. Kernel smoothing is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>np.est(data = data, h.seq = NULL, newt = NULL,
estimator = "NW", kernel = "quadratic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="np.est_+3A_data">data</code></td>
<td>

<p><code>data[, 1]</code> contains the values of the response variable, <code class="reqn">Y</code>;
</p>
<p><code>data[, 2]</code> contains the values of the explanatory variable, <code class="reqn">t</code>.
</p>
</td></tr>
<tr><td><code id="np.est_+3A_h.seq">h.seq</code></td>
<td>
<p>the considered bandwidths. If <code>NULL</code> (the default), only one bandwidth, selected by means of the cross-validation procedure, is used.</p>
</td></tr>
<tr><td><code id="np.est_+3A_newt">newt</code></td>
<td>
<p>values of the explanatory variable where the estimates are obtained. If NULL (the default), the considered values will be the values of <code>data[,2]</code>.</p>
</td></tr>
<tr><td><code id="np.est_+3A_estimator">estimator</code></td>
<td>
<p>allows us the choice between &ldquo;NW&rdquo; (Nadaraya-Watson) or &ldquo;LLP&rdquo; (Local Linear Polynomial). The default is &ldquo;NW&rdquo;.</p>
</td></tr>
<tr><td><code id="np.est_+3A_kernel">kernel</code></td>
<td>
<p>allows us the choice between &ldquo;gaussian&rdquo;, &ldquo;quadratic&rdquo; (Epanechnikov kernel), &ldquo;triweight&rdquo; or &ldquo;uniform&rdquo; kernel. The default is &ldquo;quadratic&rdquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Fan and Gijbels (1996) and Francisco-Fernandez and Vilar-Fernandez (2001).
</p>


<h3>Value</h3>

<p>YHAT: a length(<code>newt</code>) x length(<code>h.seq</code>) matrix containing the estimates for <code class="reqn">m(newt_j)</code> 
</p>
<p>(<code class="reqn">j=1,...,</code>length(<code>newt</code>)) using the different bandwidths in <code>h.seq</code>.
</p>


<h3>Author(s)</h3>

<p>German Aneiros Perez <a href="mailto:ganeiros@udc.es">ganeiros@udc.es</a> 
</p>
<p>Ana Lopez Cheda <a href="mailto:ana.lopez.cheda@udc.es">ana.lopez.cheda@udc.es</a></p>


<h3>References</h3>

<p>Fan, J.  and Gijbels, I. (1996) <em>Local Polynomial Modelling and its Applications</em>. Chapman and Hall, London.
</p>
<p>Francisco-Fernandez, M. and Vilar-Fernandez, J. M. (2001) Local polynomial regression estimation with correlated errors. <em>Comm. Statist. Theory Methods</em> <b>30</b>, 1271-1293.
</p>


<h3>See Also</h3>

<p>Other related functions are: <code><a href="#topic+np.gcv">np.gcv</a></code>, <code><a href="#topic+np.cv">np.cv</a></code>, <code><a href="#topic+plrm.est">plrm.est</a></code>, <code><a href="#topic+plrm.gcv">plrm.gcv</a></code> and <code><a href="#topic+plrm.cv">plrm.cv</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># EXAMPLE 1: REAL DATA
data &lt;- matrix(10,120,2)
data(barnacles1)
barnacles1 &lt;- as.matrix(barnacles1)
data[,1] &lt;- barnacles1[,1]
data &lt;- diff(data, 12)
data[,2] &lt;- 1:nrow(data)

aux &lt;- np.gcv(data)
h &lt;- aux$h.opt
ajuste &lt;- np.est(data=data, h=h)
plot(data[,2], ajuste, type="l", xlab="t", ylab="m(t)")
plot(data[,1], ajuste, xlab="y", ylab="y.hat", main="y.hat vs y")
abline(0,1)
residuos &lt;- data[,1] - ajuste
mean(residuos^2)/var(data[,1])



# EXAMPLE 2: SIMULATED DATA
## Example 2a: independent data

set.seed(1234)
# We generate the data
n &lt;- 100
t &lt;- ((1:n)-0.5)/n
m &lt;- function(t) {0.25*t*(1-t)}
f &lt;- m(t)

epsilon &lt;- rnorm(n, 0, 0.01)
y &lt;-  f + epsilon
data_ind &lt;- matrix(c(y,t),nrow=100)

# We estimate the nonparametric component of the PLR model
# (CV bandwidth)
est &lt;- np.est(data_ind)
plot(t, est, type="l", lty=2, ylab="")
points(t, 0.25*t*(1-t), type="l")
legend(x="topleft", legend = c("m", "m hat"), col=c("black", "black"), lty=c(1,2))

</code></pre>

<hr>
<h2 id='np.gcv'>
Generalized cross-validation bandwidth selection in nonparametric regression models
</h2><span id='topic+np.gcv'></span>

<h3>Description</h3>

<p>From a sample <code class="reqn">{(Y_i, t_i): i=1,...,n}</code>, this routine computes an optimal bandwidth for estimating <code class="reqn">m</code> in the regression model
</p>
<p style="text-align: center;"><code class="reqn">Y_i= m(t_i) + \epsilon_i.</code>
</p>

<p>The regression function, <code class="reqn">m</code>, is a smooth but unknown function. The optimal bandwidth is selected by means of the generalized cross-validation procedure. Kernel smoothing is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>np.gcv(data = data, h.seq=NULL, num.h = 50, estimator = "NW", 
kernel = "quadratic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="np.gcv_+3A_data">data</code></td>
<td>

<p><code>data[, 1]</code> contains the values of the response variable, <code class="reqn">Y</code>;
</p>
<p><code>data[, 2]</code> contains the values of the explanatory variable, <code class="reqn">t</code>.
</p>
</td></tr>
<tr><td><code id="np.gcv_+3A_h.seq">h.seq</code></td>
<td>
<p>sequence of considered bandwidths in the GCV function. If <code>NULL</code> (the default), <code>num.h</code> equidistant values between zero and a quarter of the range of <code class="reqn">t_i</code> are considered.</p>
</td></tr>
<tr><td><code id="np.gcv_+3A_num.h">num.h</code></td>
<td>
<p>number of values used to build the sequence of considered bandwidths. If <code>h.seq</code> is not <code>NULL</code>, <code>num.h=length(h.seq)</code>. Otherwise, the default is 50.</p>
</td></tr>
<tr><td><code id="np.gcv_+3A_estimator">estimator</code></td>
<td>
<p>allows us the choice between &ldquo;NW&rdquo; (Nadaraya-Watson) or &ldquo;LLP&rdquo; (Local Linear Polynomial). The default is &ldquo;NW&rdquo;.</p>
</td></tr>
<tr><td><code id="np.gcv_+3A_kernel">kernel</code></td>
<td>
<p>allows us the choice between &ldquo;gaussian&rdquo;, &ldquo;quadratic&rdquo; (Epanechnikov kernel), &ldquo;triweight&rdquo; or &ldquo;uniform&rdquo; kernel. The default is &ldquo;quadratic&rdquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Craven and Wahba (1979) and Rice (1984).
</p>


<h3>Value</h3>

<table>
<tr><td><code>h.opt</code></td>
<td>
<p>selected value for the bandwidth.</p>
</td></tr>
<tr><td><code>GCV.opt</code></td>
<td>
<p>minimum value of the GCV function.</p>
</td></tr>
<tr><td><code>GCV</code></td>
<td>
<p>vector containing the values of the GCV function for each considered bandwidth.</p>
</td></tr>
<tr><td><code>h.seq</code></td>
<td>
<p>sequence of considered bandwidths in the GCV function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>German Aneiros Perez <a href="mailto:ganeiros@udc.es">ganeiros@udc.es</a>
</p>
<p>Ana Lopez Cheda <a href="mailto:ana.lopez.cheda@udc.es">ana.lopez.cheda@udc.es</a></p>


<h3>References</h3>

<p>Craven, P. and Wahba, G. (1979) Smoothing noisy data with spline functions. <em>Numer. Math.</em> <b>31</b>, 377-403.
</p>
<p>Rice, J. (1984) Bandwidth choice for nonparametric regression. <em>Ann. Statist.</em> <b>12</b>, 1215-1230.
</p>


<h3>See Also</h3>

<p>Other related functions are: <code><a href="#topic+np.est">np.est</a></code>, <code><a href="#topic+np.cv">np.cv</a></code>, <code><a href="#topic+plrm.est">plrm.est</a></code>, <code><a href="#topic+plrm.gcv">plrm.gcv</a></code> and <code><a href="#topic+plrm.cv">plrm.cv</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># EXAMPLE 1: REAL DATA
data &lt;- matrix(10,120,2)
data(barnacles1)
barnacles1 &lt;- as.matrix(barnacles1)
data[,1] &lt;- barnacles1[,1]
data &lt;- diff(data, 12)
data[,2] &lt;- 1:nrow(data)

aux &lt;- np.gcv(data)
aux$h.opt
plot(aux$h.seq, aux$GCV, xlab="h", ylab="GCV", type="l")



# EXAMPLE 2: SIMULATED DATA
## Example 2a: independent data

set.seed(1234)
# We generate the data
n &lt;- 100
t &lt;- ((1:n)-0.5)/n
m &lt;- function(t) {0.25*t*(1-t)}
f &lt;- m(t)

epsilon &lt;- rnorm(n, 0, 0.01)
y &lt;-  f + epsilon
data_ind &lt;- matrix(c(y,t),nrow=100)

# We apply the function
a &lt;-np.gcv(data_ind)
a$GCV.opt

GCV &lt;- a$GCV
h &lt;- a$h.seq
plot(h, GCV, type="l")

</code></pre>

<hr>
<h2 id='np.gof'>
Goodness-of-Fit tests in nonparametric regression models
</h2><span id='topic+np.gof'></span>

<h3>Description</h3>

<p>This routine tests the equality of a nonparametric regression curve, <code class="reqn">m</code>, and a given function, <code class="reqn">m_0</code>, from a sample <code class="reqn">{(Y_i, t_i): i=1,...,n}</code>, where:
</p>
<p style="text-align: center;"><code class="reqn">Y_i= m(t_i) + \epsilon_i.</code>
</p>

<p>The unknown function <code class="reqn">m</code> is smooth, fixed equally spaced design is considered, and the random errors, <code class="reqn">{\epsilon_i}</code>, are allowed to be time series. The test statistic used for testing the null hypothesis, <code class="reqn">H0: m = m_0</code>, derives from a Cramer-von-Mises-type functional distance between a nonparametric estimator of <code class="reqn">m</code> and <code class="reqn">m_0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>np.gof(data = data, m0 = NULL, h.seq = NULL, w = NULL, 
estimator = "NW", kernel = "quadratic", time.series = FALSE, 
Tau.eps = NULL, h0 = NULL, lag.max = 50, p.max = 3, 
q.max = 3, ic = "BIC", num.lb = 10, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="np.gof_+3A_data">data</code></td>
<td>

<p><code>data[, 1]</code> contains the values of the response variable, <code class="reqn">Y</code>;
</p>
<p><code>data[, 2]</code> contains the values of the explanatory variable, <code class="reqn">t</code>.
</p>
</td></tr>
<tr><td><code id="np.gof_+3A_m0">m0</code></td>
<td>
<p>the considered function in the null hypothesis. If <code>NULL</code> (the default), the zero function is considered.</p>
</td></tr>
<tr><td><code id="np.gof_+3A_h.seq">h.seq</code></td>
<td>
<p>the statistic test is performed using each bandwidth in the vector <code>h.seq</code>. If <code>NULL</code> (the default), 10 equidistant values between zero and a quarter of the range of <code class="reqn">{t_i}</code> are considered.</p>
</td></tr>
<tr><td><code id="np.gof_+3A_w">w</code></td>
<td>
<p>support interval of the weigth function in the test statistic. If <code>NULL</code> (the default), <code class="reqn">(q_{0.1}, q_{0.9})</code> is considered, where <code class="reqn">q_p</code> denotes the quantile of order <code class="reqn">p</code> of <code class="reqn">{t_i}</code>.</p>
</td></tr>
<tr><td><code id="np.gof_+3A_estimator">estimator</code></td>
<td>
<p>allows us the choice between &ldquo;NW&rdquo; (Nadaraya-Watson) or &ldquo;LLP&rdquo; (Local Linear Polynomial). The default is &ldquo;NW&rdquo;.</p>
</td></tr>
<tr><td><code id="np.gof_+3A_kernel">kernel</code></td>
<td>
<p>allows us the choice between &ldquo;gaussian&rdquo;, &ldquo;quadratic&rdquo; (Epanechnikov kernel), &ldquo;triweight&rdquo; or &ldquo;uniform&rdquo; kernel. The default is &ldquo;quadratic&rdquo;.</p>
</td></tr>
<tr><td><code id="np.gof_+3A_time.series">time.series</code></td>
<td>
<p>it denotes whether the data are independent (FALSE) or if data is a time series (TRUE). The default is FALSE.</p>
</td></tr>
<tr><td><code id="np.gof_+3A_tau.eps">Tau.eps</code></td>
<td>
<p>it contains the sum of autocovariances associated to the random errors of the regression model. If NULL (the default), the function tries to estimate it: it fits an ARMA model (selected according to an information criterium) to the residuals from the fitted nonparametric regression model and, then, it obtains the sum of the autocovariances of such ARMA model.</p>
</td></tr>
<tr><td><code id="np.gof_+3A_h0">h0</code></td>
<td>
<p>if <code>Tau.eps=NULL</code>, <code>h0</code> contains the pilot bandwidth used for obtaining the residuals to construct the default for <code>Tau.eps</code>. If <code>NULL</code> (the default), a quarter of the range of <code class="reqn">{t_i}</code> is considered.</p>
</td></tr>
<tr><td><code id="np.gof_+3A_lag.max">lag.max</code></td>
<td>
<p>if <code>Tau.eps=NULL</code>, <code>lag.max</code> contains the maximum delay used to construct the default for <code>Tau.eps</code>. The default is 50.</p>
</td></tr>
<tr><td><code id="np.gof_+3A_p.max">p.max</code></td>
<td>
<p>if <code>Tau.eps=NULL</code>, the ARMA model is selected between the models ARMA(p,q) with 0&lt;=p&lt;=<code>p.max</code> and 0&lt;=q&lt;=<code>q.max</code>. The default is 3.</p>
</td></tr>
<tr><td><code id="np.gof_+3A_q.max">q.max</code></td>
<td>
<p>if <code>Tau.eps=NULL</code>, the ARMA model is selected between the models ARMA(p,q) with 0&lt;=p&lt;=<code>p.max</code> and 0&lt;=q&lt;=<code>q.max</code>. The default is 3.</p>
</td></tr>
<tr><td><code id="np.gof_+3A_ic">ic</code></td>
<td>
<p>if <code>Tau.eps=NULL</code>, <code>ic</code> contains the information criterion used to suggest the ARMA model. It allows us to choose between: &quot;AIC&quot;, &quot;AICC&quot; or &quot;BIC&quot; (the default).</p>
</td></tr>
<tr><td><code id="np.gof_+3A_num.lb">num.lb</code></td>
<td>
<p>if <code>Tau.eps=NULL</code>, it checks the suitability of the selected ARMA model according to the Ljung-Box test and the t-test. It uses up to <code>num.lb</code> delays in the Ljung-Box test. The default is 10.</p>
</td></tr>
<tr><td><code id="np.gof_+3A_alpha">alpha</code></td>
<td>
<p>if <code>Tau.eps=NULL</code>, <code>alpha</code> contains the significance level which the ARMA model is checked. The default is 0.05.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A weight function (specifically, the indicator function <b>1</b><code class="reqn">_{[w[1] , w[2]]}</code>) is introduced in the test statistic to allow elimination (or at least significant reduction) of boundary effects from the estimate of <code class="reqn">m(t_i)</code>.
</p>
<p>If <code>Tau.eps=NULL</code> and the routine is not able to suggest an approximation for <code>Tau.eps</code>, it warns the user with a message saying that the model could be not appropriate and then it shows the results. In order to construct <code>Tau.eps</code>, the procedures suggested in Muller and Stadmuller (1988) and Herrmann <em>et al.</em> (1992) can be followed.
</p>
<p>The implemented statistic test particularizes that one in Gonzalez Manteiga and Vilar Fernandez (1995) to the case where the considered class in the null hypothesis has only one element.
</p>


<h3>Value</h3>

<p>A list with a dataframe containing:
</p>
<table>
<tr><td><code>h.seq</code></td>
<td>
<p>sequence of bandwidths used in the test statistic.</p>
</td></tr>
<tr><td><code>Q.m</code></td>
<td>
<p>values of the test statistic (one for each bandwidth in <code>h.seq</code>).</p>
</td></tr>
<tr><td><code>Q.m.normalised</code></td>
<td>
<p>normalised value of Q.m.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>p-values of the corresponding statistic tests (one for each bandwidth in <code>h.seq</code>).</p>
</td></tr>
</table>
<p>Moreover, if <code>data</code> is a time series and <code>Tau.eps</code> is not especified:
</p>
<table>
<tr><td><code>pv.Box.test</code></td>
<td>
<p>p-values of the Ljung-Box test for the model fitted to the residuals.</p>
</td></tr>
<tr><td><code>pv.t.test</code></td>
<td>
<p>p-values of the t.test for the model fitted to the residuals.</p>
</td></tr>
<tr><td><code>ar.ma</code></td>
<td>
<p>ARMA orders for the model fitted to the residuals.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>German Aneiros Perez <a href="mailto:ganeiros@udc.es">ganeiros@udc.es</a>
</p>
<p>Ana Lopez Cheda <a href="mailto:ana.lopez.cheda@udc.es">ana.lopez.cheda@udc.es</a></p>


<h3>References</h3>

<p>Biedermann, S. and Dette, H. (2000) Testing linearity of regression models with dependent errors by kernel based methods. <em>Test</em> <b>9</b>, 417-438.
</p>
<p>Gonzalez-Manteiga, W. and Aneiros-Perez, G. (2003) Testing in partial linear regression models with dependent errors. <em>J. Nonparametr. Statist.</em> <b>15</b>, 93-111.
</p>
<p>Gonzalez-Manteiga, W. and Cao, R. (1993) Testing the hypothesis of a general linear model using nonparametric regression estimation. <em>Test</em> <b>2</b>, 161-188.
</p>
<p>Gonzalez Manteiga, W. and Vilar Fernandez, J. M. (1995) Testing linear regression models using non-parametric regression estimators when errors are non-independent. <em>Comput. Statist. Data Anal.</em> <b>20</b>, 521-541.
</p>
<p>Herrmann, E., Gasser, T. and Kneip, A. (1992) Choice of bandwidth for kernel regression when residuals are correlated. <em>Biometrika</em> <b>79</b>, 783-795
</p>
<p>Muller, H.G. and Stadmuller, U. (1988) Detecting dependencies in smooth regression models. <em>Biometrika</em> <b>75</b>, 639-650
</p>


<h3>See Also</h3>

<p>Other related functions are <code><a href="#topic+np.est">np.est</a></code>, <code><a href="#topic+par.gof">par.gof</a></code> and <code><a href="#topic+plrm.gof">plrm.gof</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># EXAMPLE 1: REAL DATA
data &lt;- matrix(10,120,2)
data(barnacles1)
barnacles1 &lt;- as.matrix(barnacles1)
data[,1] &lt;- barnacles1[,1]
data &lt;- diff(data, 12)
data[,2] &lt;- 1:nrow(data)

np.gof(data)



# EXAMPLE 2: SIMULATED DATA
## Example 2a: dependent data

set.seed(1234)
# We generate the data
n &lt;- 100
t &lt;- ((1:n)-0.5)/n
m &lt;- function(t) {0.25*t*(1-t)}
f &lt;- m(t)
f.function &lt;- function(u) {0.25*u*(1-u)}

epsilon &lt;- arima.sim(list(order = c(1,0,0), ar=0.7), sd = 0.01, n = n)
y &lt;-  f + epsilon
data &lt;- cbind(y,t)

## Example 2a.1: true null hypothesis
np.gof(data, m0=f.function, time.series=TRUE)

## Example 2a.2: false null hypothesis
np.gof(data, time.series=TRUE) 

</code></pre>

<hr>
<h2 id='par.ancova'>
Parametric analysis of covariance (based on linear models)
</h2><span id='topic+par.ancova'></span>

<h3>Description</h3>

<p>This routine tests the equality of <code class="reqn">L</code> vector coefficients, (<code class="reqn">\beta_1, ..., \beta_L</code>), from samples <code class="reqn">{(Y_{ki}, X_{ki1},...,X_{kip})}</code>: 
<code class="reqn">i=1,...,n</code>, <code class="reqn">k=1,...,L</code>, where:
</p>
<p style="text-align: center;"><code class="reqn">\beta_k = (\beta_{k1},...,\beta_{kp})</code>
</p>

<p>is an unknown vector parameter and
</p>
<p style="text-align: center;"><code class="reqn">Y_{ki} = X_{ki1}*\beta_{k1}+ ... + X_{kip}*\beta_{kp} + \epsilon_{ki}.</code>
</p>

<p>The random errors, <code class="reqn">\epsilon_{ki}</code>, are allowed to be time series. The test statistic used for testing the null hypothesis, <code class="reqn">H0: \beta_1 = ...= \beta_L</code>, derives from the asymptotic normality of the ordinary least squares estimator of <code class="reqn">\beta_k</code> (<code class="reqn">k=1,...,L</code>), this result giving a <code class="reqn">\chi^2</code>-test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par.ancova(data = data, time.series = FALSE, Var.Cov.eps = NULL, 
p.max = 3, q.max = 3, ic = "BIC", num.lb = 10, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="par.ancova_+3A_data">data</code></td>
<td>

<p><code>data[, 1, k]</code> contains the values of the response variable, <code class="reqn">Y_k</code>, for each model k (<code class="reqn">k=1, ..., L</code>);
</p>
<p><code>data[, 2:(p+1), k]</code> contains the values of the explanatory variables, 
</p>
<p><code class="reqn">X_{k1}, ..., X_{kp}</code>, for each model k (<code class="reqn">k=1, ..., L</code>).
</p>
</td></tr>
<tr><td><code id="par.ancova_+3A_time.series">time.series</code></td>
<td>
<p>it denotes whether the data is independent (FALSE) or if data is a time series (TRUE). The default is FALSE.</p>
</td></tr>
<tr><td><code id="par.ancova_+3A_var.cov.eps">Var.Cov.eps</code></td>
<td>
<p><code>Var.Cov.eps[, , k]</code> contains the <code>n x n</code> matrix of variances-covariances associated to the random errors of the regression model k (<code class="reqn">k=1, ..., L</code>). If NULL (the default), the function tries to estimate it: it fits an ARMA model (selected according to an information criterium) to the residuals from the fitted linear regression model and, then, it obtains the var-cov matrix of such ARMA model.</p>
</td></tr>
<tr><td><code id="par.ancova_+3A_p.max">p.max</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code>, the ARMA models are selected between the models ARMA(p,q) with 0&lt;=p&lt;=p.max and 0&lt;=q&lt;=q.max. The default is 3.</p>
</td></tr>
<tr><td><code id="par.ancova_+3A_q.max">q.max</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code>, the ARMA models are selected between the models ARMA(p,q) with 0&lt;=p&lt;=p.max and 0&lt;=q&lt;=q.max. The default is 3.</p>
</td></tr>
<tr><td><code id="par.ancova_+3A_ic">ic</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code>, <code>ic</code> contains the information criterion used to suggest the ARMA models. It allows us to choose between: &quot;AIC&quot;, &quot;AICC&quot; or &quot;BIC&quot; (the default).</p>
</td></tr>
<tr><td><code id="par.ancova_+3A_num.lb">num.lb</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code>, it checks the suitability of the ARMA models according to the Ljung-Box and the t.test. It uses up to <code>num.lb</code> delays in the Ljung-Box test. The default is 10.</p>
</td></tr>
<tr><td><code id="par.ancova_+3A_alpha">alpha</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code>, <code>alpha</code> contains the significance level (default is 0.05) which the ARMA models are checked.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>Var.Cov.eps=NULL</code> and the routine is not able to suggest an approximation for <code>Var.Cov.eps</code>, it warns the user with a message saying that the model could be not appropriate and then it shows the results. In order to construct <code>Var.Cov.eps</code>, the procedure suggested in Domowitz (1982) can be followed.
</p>
<p>The implemented procedure particularizes the parametric test in the routine <code>plrm.ancova</code> to the case where is known that the nonparametric components in the corresponding PLR models are null.
</p>


<h3>Value</h3>

<p>A list with a dataframe containing:
</p>
<table>
<tr><td><code>Q.beta</code></td>
<td>
<p>value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>p-value of the corresponding statistic test.</p>
</td></tr>
</table>
<p>Moreover, if <code>data</code> is a time series and <code>Var.Cov.eps</code> is not especified:
</p>
<table>
<tr><td><code>pv.Box.test</code></td>
<td>
<p>p-values of the Ljung-Box test for the model fitted to the residuals.</p>
</td></tr>
<tr><td><code>pv.t.test</code></td>
<td>
<p>p-values of the t.test for the model fitted to the residuals.</p>
</td></tr>
<tr><td><code>ar.ma</code></td>
<td>
<p>ARMA orders for the model fitted to the residuals.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>German Aneiros Perez <a href="mailto:ganeiros@udc.es">ganeiros@udc.es</a>
</p>
<p>Ana Lopez Cheda <a href="mailto:ana.lopez.cheda@udc.es">ana.lopez.cheda@udc.es</a></p>


<h3>References</h3>

<p>Domowitz, J. (1982) The linear model with stochastic regressors and heteroscedastic dependent errors. Discussion paper No 543, Center for Mathematical studies in Economic and Management Science, Northwestern University, Evanston, Illinois.
</p>
<p>Judge, G.G., Griffiths, W.E., Carter Hill, R., Lutkepohl, H. and Lee, T-C. (1980) <em>The Theory and Practice of Econometrics</em>. Wiley.
</p>
<p>Seber, G.A.F. (1977) <em>Linear Regression Analysis</em>. Wiley.
</p>


<h3>See Also</h3>

<p>Other related functions are <code><a href="#topic+np.ancova">np.ancova</a></code> and <code><a href="#topic+plrm.ancova">plrm.ancova</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># EXAMPLE 1: REAL DATA
data(barnacles1)
data &lt;- as.matrix(barnacles1)
data &lt;- diff(data, 12)
data &lt;- cbind(data[,1],1,data[,-1])

data(barnacles2)
data2 &lt;- as.matrix(barnacles2)
data2 &lt;- diff(data2, 12)
data2 &lt;- cbind(data2[,1],1,data2[,-1])

data3 &lt;- array(0, c(nrow(data),ncol(data),2))
data3[,,1] &lt;- data
data3[,,2] &lt;- data2

par.ancova(data=data3)



# EXAMPLE 2: SIMULATED DATA
## Example 2a: dependent data - true null hypothesis

set.seed(1234)
# We generate the data
n &lt;- 100
t &lt;- ((1:n)-0.5)/n
beta &lt;- c(0.05, 0.01)

x1 &lt;- matrix(rnorm(200,0,1), nrow=n)
sum1 &lt;- x1%*%beta
epsilon1 &lt;- arima.sim(list(order = c(1,0,0), ar=0.7), sd = 0.01, n = n)
y1 &lt;-  sum1 + epsilon1
data1 &lt;- cbind(y1,x1)

x2 &lt;- matrix(rnorm(200,1,2), nrow=n)
sum2 &lt;- x2%*%beta
epsilon2 &lt;- arima.sim(list(order = c(0,0,1), ma=0.5), sd = 0.02, n = n)
y2 &lt;- sum2 + epsilon2
data2 &lt;- cbind(y2,x2)

data_eq &lt;- array(cbind(data1,data2),c(100,3,2))

# We apply the test
par.ancova(data_eq, time.series=TRUE)


## Example 2a: dependent data - false null hypothesis
# We generate the data
n &lt;- 100
beta3 &lt;- c(0.05, 0.01)
beta4 &lt;- c(0.05, 0.02)

x3 &lt;- matrix(rnorm(200,0,1), nrow=n)
sum3 &lt;- x3%*%beta3
epsilon3 &lt;- arima.sim(list(order = c(1,0,0), ar=0.7), sd = 0.01, n = n)
y3 &lt;-  sum3 + epsilon3
data3 &lt;- cbind(y3,x3)

x4 &lt;- matrix(rnorm(200,1,2), nrow=n)
sum4 &lt;- x4%*%beta4
epsilon4 &lt;- arima.sim(list(order = c(0,0,1), ma=0.5), sd = 0.02, n = n)
y4 &lt;-  sum4 + epsilon4
data4 &lt;- cbind(y4,x4)

data_neq &lt;- array(cbind(data3,data4),c(100,3,2))

# We apply the test
par.ancova(data_neq, time.series=TRUE) 

</code></pre>

<hr>
<h2 id='par.ci'>
Confidence intervals estimation in linear regression models
</h2><span id='topic+par.ci'></span>

<h3>Description</h3>

<p>This routine obtains a confidence interval for the value <code class="reqn">a^T * \beta</code>, by asymptotic distribution and bootstrap, from a sample <code class="reqn">(Y_i, X_{i1},...,X_{ip}):</code>
<code class="reqn">i=1,...,n</code>, where:
</p>
<p style="text-align: center;"><code class="reqn">a = (a_1,...,a_p)^T</code>
</p>

<p>is an unknown vector, 
</p>
<p style="text-align: center;"><code class="reqn">\beta = (\beta_1,...,\beta_p)^T</code>
</p>

<p>is an unknown vector parameter and
</p>
<p style="text-align: center;"><code class="reqn">Y_i = X_{i1}*\beta_1+ ... + X_{ip}*\beta_p + \epsilon_i.</code>
</p>

<p>The random errors, <code class="reqn">\epsilon_i</code>, are allowed to be time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par.ci(data=data, seed=123, CI="AD", B=1000, N=50, a=NULL, 
p.arima=NULL, q.arima=NULL, p.max=3, q.max=3, alpha=0.05, 
alpha2=0.05, num.lb=10, ic="BIC", Var.Cov.eps=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="par.ci_+3A_data">data</code></td>
<td>

<p><code>data[, 1]</code> contains the values of the response variable, <code class="reqn">Y</code>;
</p>
<p><code>data[, 2:(p+1)]</code> contains the values of the explanatory variables, <code class="reqn">X_1, ..., X_p</code>.
</p>
</td></tr>
<tr><td><code id="par.ci_+3A_seed">seed</code></td>
<td>
<p>the considered seed.</p>
</td></tr>
<tr><td><code id="par.ci_+3A_ci">CI</code></td>
<td>
<p>method to obtain the confidence interval. It allows us to choose between: &ldquo;AD&rdquo; (asymptotic distribution), &ldquo;B&rdquo; (bootstrap) or &ldquo;all&rdquo; (both). The default is &ldquo;AD&rdquo;.</p>
</td></tr>
<tr><td><code id="par.ci_+3A_b">B</code></td>
<td>
<p>number of bootstrap replications. The default is 1000.</p>
</td></tr>
<tr><td><code id="par.ci_+3A_n">N</code></td>
<td>
<p>Truncation parameter used in the finite approximation of the MA(infinite) expression of <code class="reqn">\epsilon</code>.</p>
</td></tr>
<tr><td><code id="par.ci_+3A_a">a</code></td>
<td>
<p>Vector which, multiplied by <code>beta</code>, is used for obtaining the confidence interval of this result.</p>
</td></tr>
<tr><td><code id="par.ci_+3A_p.arima">p.arima</code></td>
<td>
<p>the considered p to fit the model ARMA(p,q).</p>
</td></tr>
<tr><td><code id="par.ci_+3A_q.arima">q.arima</code></td>
<td>
<p>the considered q to fit the model ARMA(p,q).</p>
</td></tr>
<tr><td><code id="par.ci_+3A_p.max">p.max</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code>, the ARMA models are selected between the models ARMA(p,q) with 0&lt;=p&lt;=<code>p.max</code> and 0&lt;=q&lt;=<code>q.max</code>. The default is 3.</p>
</td></tr>
<tr><td><code id="par.ci_+3A_q.max">q.max</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code>, the ARMA models are selected between the models ARMA(p,q) with 0&lt;=p&lt;=<code>p.max</code> and 0&lt;=q&lt;=<code>q.max</code>. The default is 3.</p>
</td></tr>
<tr><td><code id="par.ci_+3A_alpha">alpha</code></td>
<td>
<p>1 - <code>alpha</code> is the confidence level of the confidence interval. The default is 0.05.</p>
</td></tr>
<tr><td><code id="par.ci_+3A_alpha2">alpha2</code></td>
<td>
<p>significance level used to check (if needed) the ARMA model fitted to the residuals. The default is 0.05.</p>
</td></tr>
<tr><td><code id="par.ci_+3A_num.lb">num.lb</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code>, it checks the suitability of the selected ARMA model according to the Ljung-Box test and the t-test. It uses up to <code>num.lb</code> delays in the Ljung-Box test. The default is 10.</p>
</td></tr>
<tr><td><code id="par.ci_+3A_ic">ic</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code>, <code>ic</code> contains the information criterion used to suggest the ARMA model. It allows us to choose between: &quot;AIC&quot;, &quot;AICC&quot; or &quot;BIC&quot; (the default).</p>
</td></tr>
<tr><td><code id="par.ci_+3A_var.cov.eps">Var.Cov.eps</code></td>
<td>
 <p><code>n x n</code> matrix of variances-covariances associated to the random errors of the regression model. If NULL (the default), the function tries to estimate it: it fits an ARMA model (selected according to an information criterium) to the residuals from the fitted regression model and, then, it obtains the var-cov matrix of such ARMA model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>Bootstrap</code></td>
<td>
<p>a dataframe containing <code>ci_inf</code> and <code>ci_sup</code>, the confidence intervals using bootstrap and <code>p_opt</code> and <code>q_opt</code> (the orders for the ARMA model fitted to the residuals).</p>
</td></tr>
<tr><td><code>AD</code></td>
<td>
<p>a dataframe containing <code>ci_inf</code> and <code>ci_sup</code>, the confidence intervals using the asymptotic distribution and <code>p_opt</code> and <code>q_opt</code> (the orders for the ARMA model fitted to the residuals).</p>
</td></tr>
<tr><td><code>pv.Box.test</code></td>
<td>
<p>p-values of the Ljung-Box test for the model fitted to the residuals.</p>
</td></tr>
<tr><td><code>pv.t.test</code></td>
<td>
<p>p-values of the t.test for the model fitted to the residuals.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>German Aneiros Perez <a href="mailto:ganeiros@udc.es">ganeiros@udc.es</a>
</p>
<p>Ana Lopez Cheda <a href="mailto:ana.lopez.cheda@udc.es">ana.lopez.cheda@udc.es</a>
</p>


<h3>References</h3>

<p>Liang, H., Hardle, W., Sommerfeld, V. (2000) Bootstrap approximation in a partially linear regression model. <em>Journal of Statistical Planning and Inference</em> <b>91</b>, 413-426.
</p>
<p>You, J., Zhou, X. (2005) Bootstrap of a semiparametric partially linear model with autoregressive errors. <em>Statistica Sinica</em> <b>15</b>, 117-133.
</p>


<h3>See Also</h3>

<p>A related function is <code><a href="#topic+plrm.ci">plrm.ci</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># EXAMPLE 1: REAL DATA
data(barnacles1)
data &lt;- as.matrix(barnacles1)
data &lt;- diff(data, 12)
data &lt;- cbind(data[,1],1,data[,-1])

## Not run: par.ci(data, a=c(1,0,0), CI="all")
## Not run: par.ci(data, a=c(0,1,0), CI="all")
## Not run: par.ci(data, a=c(0,0,1), CI="all")



# EXAMPLE 2: SIMULATED DATA
## Example 2a: dependent data

set.seed(123)
# We generate the data
n &lt;- 100
beta &lt;- c(0.5, 2)

x &lt;- matrix(rnorm(200,0,3), nrow=n)
sum &lt;- x%*%beta
sum &lt;- as.matrix(sum)
eps &lt;- arima.sim(list(order = c(1,0,0), ar=0.7), sd = 0.1, n = n)
eps &lt;- as.matrix(eps)
y &lt;-  sum + eps
data_parci &lt;- cbind(y,x)

# We estimate the confidence interval of a^T * beta in the PLR model
## Not run: par.ci(data, a=c(1,0), CI="all")
## Not run: par.ci(data, a=c(0,1), CI="all")

</code></pre>

<hr>
<h2 id='par.est'>
Estimation in linear regression models
</h2><span id='topic+par.est'></span>

<h3>Description</h3>

<p>This routine computes the ordinary least squares estimate for <code class="reqn">\beta</code> from a sample <code class="reqn">(Y_i, X_{i1},...,X_{ip}),</code>
<code class="reqn">i=1,...,n</code>, where:
</p>
<p style="text-align: center;"><code class="reqn">\beta = (\beta_1,...,\beta_p)</code>
</p>

<p>is an unknown vector parameter and
</p>
<p style="text-align: center;"><code class="reqn">Y_i = X_{i1}*\beta_1+ ... + X_{ip}*\beta_p + \epsilon_i.</code>
</p>

<p>The random errors, <code class="reqn">\epsilon_i</code>, are allowed to be time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par.est(data = data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="par.est_+3A_data">data</code></td>
<td>

<p><code>data[, 1]</code> contains the values of the response variable, <code class="reqn">Y</code>;
</p>
<p><code>data[, 2:(p+1)]</code> contains the values of the explanatory variables, <code class="reqn">X_1, ..., X_p</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Seber (1977) and Judge <em>et al.</em> (1980).
</p>


<h3>Value</h3>

<p>A vector containing the corresponding estimate.
</p>


<h3>Author(s)</h3>

<p>German Aneiros Perez <a href="mailto:ganeiros@udc.es">ganeiros@udc.es</a>
</p>
<p>Ana Lopez Cheda <a href="mailto:ana.lopez.cheda@udc.es">ana.lopez.cheda@udc.es</a></p>


<h3>References</h3>

<p>Judge, G.G., Griffiths, W.E., Carter Hill, R., Lutkepohl, H. and Lee, T-C. (1980) <em>The Theory and Practice of Econometrics</em>. Wiley.
</p>
<p>Seber, G.A.F. (1977) <em>Linear Regression Analysis</em>. Wiley.
</p>


<h3>See Also</h3>

<p>Other related functions are <code><a href="#topic+plrm.beta">plrm.beta</a></code> and <code><a href="#topic+plrm.est">plrm.est</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># EXAMPLE 1: REAL DATA
data(barnacles1)
data &lt;- as.matrix(barnacles1)
data &lt;- diff(data, 12)
data &lt;- cbind(data[,1],1,data[,-1])

beta &lt;- par.est(data=data)
beta
residuos &lt;- data[,1] - data[,-1]%*%beta
mean(residuos^2)/var(data[,1])

fitted.values &lt;- data[,-1]%*%beta
plot(data[,1], fitted.values, xlab="y", ylab="y.hat", main="y.hat vs y")
abline(0,1)



# EXAMPLE 2: SIMULATED DATA
## Example 2a: independent data

set.seed(1234)
# We generate the data
n &lt;- 100
beta &lt;- c(0.05, 0.01)

x &lt;- matrix(rnorm(200,0,1), nrow=n)
sum &lt;- x%*%beta
epsilon &lt;- rnorm(n, 0, 0.01)
y &lt;-  sum + epsilon
data_ind &lt;- matrix(c(y,x),nrow=100)

# We estimate the parametric component of the PLR model
par.est(data_ind)


## Example 2b: dependent data

set.seed(1234)
# We generate the data
x &lt;- matrix(rnorm(200,0,1), nrow=n)
sum &lt;- x%*%beta
epsilon &lt;- arima.sim(list(order = c(1,0,0), ar=0.7), sd = 0.01, n = n)
y &lt;-  sum + epsilon
data_dep &lt;- matrix(c(y,x),nrow=100)

# We estimate the parametric component of the PLR model
par.est(data_dep)

</code></pre>

<hr>
<h2 id='par.gof'>
Goodness-of-Fit tests in linear regression models
</h2><span id='topic+par.gof'></span>

<h3>Description</h3>

<p>This routine tests the equality of the vector of coefficients, <code class="reqn">\beta</code>, in a linear regression model and a given parameter vector, <code class="reqn">\beta_0</code>, from a sample <code class="reqn">{(Y_i, X_{i1},...,X_{ip}): i=1,...,n}</code>, where:
</p>
<p style="text-align: center;"><code class="reqn">\beta = (\beta_1,...,\beta_p)</code>
</p>

<p>is an unknown vector parameter and
</p>
<p style="text-align: center;"><code class="reqn">Y_i = X_{i1}*\beta_1+ ... + X_{ip}*\beta_p + \epsilon_i.</code>
</p>

<p>The random errors, <code class="reqn">\epsilon_i</code>, are allowed to be time series. The test statistic used for testing the null hypothesis, <code class="reqn">H0: \beta = \beta_0</code>, derives from the asymptotic normality of the ordinary least squares estimator of <code class="reqn">\beta</code>, this result giving a <code class="reqn">\chi^2</code>-test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par.gof(data = data, beta0 = NULL, time.series = FALSE, 
Var.Cov.eps = NULL, p.max = 3, q.max = 3, ic = "BIC", 
num.lb = 10, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="par.gof_+3A_data">data</code></td>
<td>

<p><code>data[, 1]</code> contains the values of the response variable, <code class="reqn">Y</code>;
</p>
<p><code>data[, 2:(p+1)]</code> contains the values of the explanatory variables, <code class="reqn">X_1, ..., X_p</code>.
</p>
</td></tr>
<tr><td><code id="par.gof_+3A_beta0">beta0</code></td>
<td>
<p>the considered parameter vector in the null hypothesis. If <code>NULL</code> (the default), the zero vector is considered.</p>
</td></tr>
<tr><td><code id="par.gof_+3A_time.series">time.series</code></td>
<td>
<p>it denotes whether the data are independent (FALSE) or if data is a time series (TRUE). The default is FALSE.</p>
</td></tr>
<tr><td><code id="par.gof_+3A_var.cov.eps">Var.Cov.eps</code></td>
<td>
 <p><code>n x n</code> matrix of variances-covariances associated to the random errors of the regression model. If NULL (the default), the function tries to estimate it: it fits an ARMA model (selected according to an information criterium) to the residuals from the fitted linear regression model and, then, it obtains the var-cov matrix of such ARMA model.</p>
</td></tr>
<tr><td><code id="par.gof_+3A_p.max">p.max</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code>, the ARMA model is selected between the models ARMA(p,q) with 0&lt;=p&lt;=<code>p.max</code> and 0&lt;=q&lt;=<code>q.max</code>. The default is 3.</p>
</td></tr>
<tr><td><code id="par.gof_+3A_q.max">q.max</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code>, the ARMA model is selected between the models ARMA(p,q) with 0&lt;=p&lt;=<code>p.max</code> and 0&lt;=q&lt;=<code>q.max</code>. The default is 3.</p>
</td></tr>
<tr><td><code id="par.gof_+3A_ic">ic</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code>, <code>ic</code> contains the information criterion used to suggest the ARMA model. It allows us to choose between: &quot;AIC&quot;, &quot;AICC&quot; or &quot;BIC&quot; (the default).</p>
</td></tr>
<tr><td><code id="par.gof_+3A_num.lb">num.lb</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code>, it checks the suitability of the selected ARMA model according to the Ljung-Box test and the t-test. It uses up to <code>num.lb</code> delays in the Ljung-Box test. The default is 10.</p>
</td></tr>
<tr><td><code id="par.gof_+3A_alpha">alpha</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code>, <code>alpha</code> contains the significance level which the ARMA model is checked. The default is 0.05.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>If <code>Var.Cov.eps=NULL</code> and the routine is not able to suggest an approximation for <code>Var.Cov.eps</code>, it warns the user with a message saying that the model could be not appropriate and then it shows the results. In order to construct <code>Var.Cov.eps</code>, the procedure suggested in Domowitz (1982) can be followed.
</p>
<p>The implemented procedure particularizes the parametric test in the routine <code>plrm.gof</code> to the case where is known that the nonparametric component in the corresponding PLR model is null.
</p>


<h3>Value</h3>

<p>A list with a dataframe containing:
</p>
<table>
<tr><td><code>Q.beta</code></td>
<td>
<p>value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>p-value of the corresponding statistic test.</p>
</td></tr>
</table>
<p>Moreover, if <code>data</code> is a time series and <code>Var.Cov.eps</code> is not especified:
</p>
<table>
<tr><td><code>pv.Box.test</code></td>
<td>
<p>p-values of the Ljung-Box test for the model fitted to the residuals.</p>
</td></tr>
<tr><td><code>pv.t.test</code></td>
<td>
<p>p-values of the t.test for the model fitted to the residuals.</p>
</td></tr>
<tr><td><code>ar.ma</code></td>
<td>
<p>ARMA orders for the model fitted to the residuals.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>German Aneiros Perez <a href="mailto:ganeiros@udc.es">ganeiros@udc.es</a>
</p>
<p>Ana Lopez Cheda <a href="mailto:ana.lopez.cheda@udc.es">ana.lopez.cheda@udc.es</a></p>


<h3>References</h3>

<p>Domowitz, J. (1982) The linear model with stochastic regressors and heteroscedastic dependent errors. Discussion paper No 543, Center for Mathematical studies in Economic and Management Science, Northwestern University, Evanston, Illinois.
</p>
<p>Judge, G.G., Griffiths, W.E., Carter Hill, R., Lutkepohl, H. and Lee, T-C. (1980) <em>The Theory and Practice of Econometrics</em>. Wiley.
</p>
<p>Seber, G.A.F. (1977) <em>Linear Regression Analysis</em>. Wiley.
</p>


<h3>See Also</h3>

<p>Other related functions are <code><a href="#topic+np.gof">np.gof</a></code> and <code><a href="#topic+plrm.gof">plrm.gof</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># EXAMPLE 1: REAL DATA
data(barnacles1)
data &lt;- as.matrix(barnacles1)
data &lt;- diff(data, 12)
data &lt;- cbind(data[,1],1,data[,-1])

## Example 1.1: false null hypothesis
par.gof(data)
## Example 1.2: true null hypothesis
par.gof(data, beta0=c(0,0.15,0.4))



# EXAMPLE 2: SIMULATED DATA
## Example 2a: dependent data

set.seed(1234)
# We generate the data
n &lt;- 100
beta &lt;- c(0.05, 0.01)

x &lt;- matrix(rnorm(200,0,1), nrow=n)
sum &lt;- x%*%beta
epsilon &lt;- arima.sim(list(order = c(1,0,0), ar=0.7), sd = 0.01, n = n)
y &lt;-  sum + epsilon
data &lt;- cbind(y,x)

## Example 2a.1: true null hypothesis
par.gof(data, beta0=c(0.05, 0.01))

## Example 2a.2: false null hypothesis
par.gof(data) 

</code></pre>

<hr>
<h2 id='plrm.ancova'>
Semiparametric analysis of covariance (based on PLR models)
</h2><span id='topic+plrm.ancova'></span>

<h3>Description</h3>

<p>From samples <code class="reqn">{(Y_{ki}, X_{ki1}, ..., X_{kip}, t_i): i=1,...,n}</code>, <code class="reqn">k=1,...,L</code>, this routine tests the null hypotheses <code class="reqn">H0: \beta_1 = ... = \beta_L</code> and <code class="reqn">H0: m_1 = ... = m_L</code>, where:
</p>
<p style="text-align: center;"><code class="reqn">\beta_k = (\beta_{k1},...,\beta_{kp})</code>
</p>

<p>is an unknown vector parameter;
</p>
<p style="text-align: center;"><code class="reqn">m_k(.)</code>
</p>

<p>is a smooth but unknown function and
</p>
<p style="text-align: center;"><code class="reqn">Y_{ki}= X_{ki1}*\beta_{k1} +...+ X_{kip}*\beta_{kp} + m(t_i) + \epsilon_{ki}.</code>
</p>

<p>Fixed equally spaced design is considered for the &quot;nonparametric&quot; explanatory variable, <code class="reqn">t</code>, and the random errors, <code class="reqn">\epsilon_{ki}</code>, are allowed to be time series. The test statistic used for testing <code class="reqn">H0: \beta_1 = ...= \beta_L</code> derives from the asymptotic normality of an estimator of <code class="reqn">\beta_k</code> (<code class="reqn">k=1,...,L</code>) based on both ordinary least squares and kernel smoothing (this result giving a <code class="reqn">\chi^2</code>-test). The test statistic used for testing <code class="reqn">H0: m_1 = ...= m_L</code> derives from a Cramer-von-Mises-type functional based on different distances between nonparametric estimators of <code class="reqn">m_k</code> (<code class="reqn">k=1,...,L</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plrm.ancova(data = data, t = t, b.seq = NULL, h.seq = NULL, 
w = NULL, estimator = "NW", kernel = "quadratic", 
time.series = FALSE, Var.Cov.eps = NULL, Tau.eps = NULL, 
b0 = NULL, h0 = NULL, lag.max = 50, p.max = 3, q.max = 3,
ic = "BIC", num.lb = 10, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plrm.ancova_+3A_data">data</code></td>
<td>

<p><code>data[, 1, k]</code> contains the values of the response variable, <code class="reqn">Y_k</code>, for each model <code class="reqn">k</code> (<code class="reqn">k=1, ..., L</code>);
</p>
<p><code>data[, 2:(p+1), k]</code> contains the values of the &quot;linear&quot; explanatory variables, <code class="reqn">X_{k1}, ..., X_{kp}</code>, for each model k (<code class="reqn">k=1, ..., L</code>).
</p>
</td></tr>
<tr><td><code id="plrm.ancova_+3A_t">t</code></td>
<td>
<p>contains the values of the &quot;nonparametric&quot; explanatory (common) variable, <code class="reqn">t</code>, for each model <code class="reqn">k</code> (<code class="reqn">k=1, ..., L</code>).</p>
</td></tr>
<tr><td><code id="plrm.ancova_+3A_b.seq">b.seq</code></td>
<td>
<p>the statistic test for <code class="reqn">H0: \beta_1 = ... = \beta_L</code> is performed using each bandwidth in the vector <code>b.seq</code>. If <code>NULL</code> (the default) but <code>h.seq</code> is not <code>NULL</code>, it takes <code>b.seq=h.seq</code>. If both <code>b.seq</code> and <code>h.seq</code> are <code>NULL</code>, 10 equidistant values between zero and a quarter of the range of <code class="reqn">{t_i}</code> are considered.</p>
</td></tr>
<tr><td><code id="plrm.ancova_+3A_h.seq">h.seq</code></td>
<td>
<p>the statistic test for <code class="reqn">H0: m_1 = ... = m_L</code> is performed using each pair of bandwidths (<code>b.seq[j], h.seq[j]</code>). If <code>NULL</code> (the default) but <code>b.seq</code> is not <code>NULL</code>, it takes <code>h.seq=b.seq</code>. If both <code>b.seq</code> and <code>h.seq</code> are <code>NULL</code>, 10 equidistant values between zero and a quarter of the range of <code class="reqn">{t_i}</code> are considered for both <code>b.seq</code> and  <code>h.seq</code>.</p>
</td></tr> 
<tr><td><code id="plrm.ancova_+3A_w">w</code></td>
<td>
<p>support interval of the weigth function in the test statistic for <code class="reqn">H0: m_1 = ... = m_L</code>. If <code>NULL</code> (the default), <code class="reqn">(q_{0.1}, q_{0.9})</code> is considered, where <code class="reqn">q_p</code> denotes the quantile of order <code class="reqn">p</code> of <code class="reqn">{t_i}</code>.</p>
</td></tr>
<tr><td><code id="plrm.ancova_+3A_estimator">estimator</code></td>
<td>
<p>allows us the choice between &ldquo;NW&rdquo; (Nadaraya-Watson) or &ldquo;LLP&rdquo; (Local Linear Polynomial). The default is &ldquo;NW&rdquo;.</p>
</td></tr>
<tr><td><code id="plrm.ancova_+3A_kernel">kernel</code></td>
<td>
<p>allows us the choice between &ldquo;gaussian&rdquo;, &ldquo;quadratic&rdquo; (Epanechnikov kernel), &ldquo;triweight&rdquo; or &ldquo;uniform&rdquo; kernel. The default is &ldquo;quadratic&rdquo;.</p>
</td></tr>
<tr><td><code id="plrm.ancova_+3A_time.series">time.series</code></td>
<td>
<p>it denotes whether the data are independent (FALSE) or if data is a time series (TRUE). The default is FALSE.</p>
</td></tr>
<tr><td><code id="plrm.ancova_+3A_var.cov.eps">Var.Cov.eps</code></td>
<td>
<p><code>Var.Cov.eps[, , k]</code> contains the <code>n x n</code> matrix of variances-covariances associated to the random errors of the regression model k (<code class="reqn">k=1, ..., L</code>). If NULL (the default), the function tries to estimate it: it fits an ARMA model (selected according to an information criterium) to the residuals from the fitted regression model and, then, it obtains the var-cov matrix of such ARMA model.</p>
</td></tr>
<tr><td><code id="plrm.ancova_+3A_tau.eps">Tau.eps</code></td>
<td>
<p><code>Tau.eps[k]</code> contains the sum of autocovariances associated to the random errors of the regression model <code class="reqn">k</code> (<code class="reqn">k=1, ..., L</code>). If NULL (the default), the function tries to estimate it: it fits an ARMA model (selected according to an information criterium) to the residuals from the fitted regression model and, then, it obtains the sum of the autocovariances of such ARMA model.</p>
</td></tr>
<tr><td><code id="plrm.ancova_+3A_b0">b0</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code> and/or <code>Tau.eps=NULL</code>, <code>b0</code> contains the pilot bandwidth for the estimator of <code class="reqn">\beta_k</code> (<code class="reqn">k=1, ..., L</code>) used for obtaining the residuals to construct the default for <code>Var.Cov.eps</code> and/or <code>Tau.eps</code>. If <code>NULL</code> (the default) but <code>h0</code> is not <code>NULL</code>, it takes <code>b0=h0</code>. If both <code>b0</code> and <code>h0</code> are <code>NULL</code>, a quarter of the range of <code class="reqn">{t_i}</code> is considered.</p>
</td></tr>
<tr><td><code id="plrm.ancova_+3A_h0">h0</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code> and/or <code>Tau.eps=NULL</code>, (<code>b0, h0</code>) contains the pair of pilot bandwidths  for the estimator of <code class="reqn">m_k</code> (<code class="reqn">k=1, ..., L</code>) used for obtaining the residuals to construct the default for <code>Var.Cov.eps</code> and/or <code>Tau.eps</code>. If <code>NULL</code> (the default) but <code>b0</code> is not <code>NULL</code>, it takes <code>h0=b0</code>. If both <code>b0</code> and <code>h0</code> are <code>NULL</code>, a quarter of the range of <code class="reqn">{t_i}</code> is considered for both <code>b0</code> and  <code>h0</code>.</p>
</td></tr>
<tr><td><code id="plrm.ancova_+3A_lag.max">lag.max</code></td>
<td>
<p>if <code>Tau.eps=NULL</code>, <code>lag.max</code> contains the maximum delay used to construct the default for <code>Tau.eps</code>. The default is 50.</p>
</td></tr>
<tr><td><code id="plrm.ancova_+3A_p.max">p.max</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code> and/or <code>Tau.eps=NULL</code>, the ARMA models are selected between the models ARMA(p,q) with 0&lt;=p&lt;=<code>p.max</code> and 0&lt;=q&lt;=<code>q.max</code>. The default is 3.</p>
</td></tr>
<tr><td><code id="plrm.ancova_+3A_q.max">q.max</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code> and/or <code>Tau.eps=NULL</code>, the ARMA models are selected between the models ARMA(p,q) with 0&lt;=p&lt;=<code>p.max</code> and 0&lt;=q&lt;=<code>q.max</code>. The default is 3.</p>
</td></tr>
<tr><td><code id="plrm.ancova_+3A_ic">ic</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code> and/or <code>Tau.eps=NULL</code>, <code>ic</code> contains the information criterion used to suggest the ARMA models. It allows us to choose between: &quot;AIC&quot;, &quot;AICC&quot; or &quot;BIC&quot; (the default).</p>
</td></tr>
<tr><td><code id="plrm.ancova_+3A_num.lb">num.lb</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code> and/or <code>Tau.eps=NULL</code>, it checks the suitability of the selected ARMA models according to the Ljung-Box test and the t-test. It uses up to <code>num.lb</code> delays in the Ljung-Box test. The default is 10.</p>
</td></tr>
<tr><td><code id="plrm.ancova_+3A_alpha">alpha</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code> and/or <code>Tau.eps=NULL</code>, <code>alpha</code> contains the significance level which the ARMA models are checked. The default is 0.05.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A weight function (specifically, the indicator function <b>1</b><code class="reqn">_{[w[1] , w[2]]}</code>) is introduced in the test statistic for testing <code class="reqn">H0: m_1 = ... = m_L</code> to allow elimination (or at least significant reduction) of boundary effects from the estimate of <code class="reqn">m_k(t_i)</code>.
</p>
<p>If <code>Var.Cov.eps=NULL</code> and the routine is not able to suggest an approximation for <code>Var.Cov.eps</code>, it warns the user with a message saying that the model could be not appropriate and then it shows the results. In order to construct <code>Var.Cov.eps</code>, the procedure suggested in Aneiros-Perez and Vieu (2013) can be followed.
</p>
<p>If <code>Tau.eps=NULL</code> and the routine is not able to suggest an approximation for <code>Tau.eps</code>, it warns the user with a message saying that the model could be not appropriate and then it shows the results. In order to construct <code>Tau.eps</code>, the procedures suggested in Aneiros-Perez (2008) can be followed.
</p>
<p>Expressions for the implemented statistic tests can be seen in (15) and (16) in Aneiros-Perez (2008).
</p>


<h3>Value</h3>

<p>A list with two dataframes:
</p>
<table>
<tr><td><code>parametric.test</code></td>
<td>
<p>a dataframe containing the bandwidths, the statistics and the p-values when one tests <code class="reqn">H0: \beta_1 = ...= \beta_L</code>.</p>
</td></tr>
<tr><td><code>nonparametric.test</code></td>
<td>
<p>a dataframe containing the bandwidths b and h, the statistics, the normalised statistics and the p-values when one tests <code class="reqn">H0: m_1 = ...= m_L</code>.</p>
</td></tr>
</table>
<p>Moreover, if <code>data</code> is a time series and <code>Tau.eps</code> or <code>Var.Cov.eps</code> are not especified:
</p>
<table>
<tr><td><code>pv.Box.test</code></td>
<td>
<p>p-values of the Ljung-Box test for the model fitted to the residuals.</p>
</td></tr>
<tr><td><code>pv.t.test</code></td>
<td>
<p>p-values of the t.test for the model fitted to the residuals.</p>
</td></tr>
<tr><td><code>ar.ma</code></td>
<td>
<p>ARMA orders for the model fitted to the residuals.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>German Aneiros Perez <a href="mailto:ganeiros@udc.es">ganeiros@udc.es</a>
</p>
<p>Ana Lopez Cheda <a href="mailto:ana.lopez.cheda@udc.es">ana.lopez.cheda@udc.es</a></p>


<h3>References</h3>

<p>Aneiros-Perez, G. (2008) Semi-parametric analysis of covariance under dependence conditions within each group. <em>Aust. N. Z. J. Stat.</em> <b>50</b>, 97-123.
</p>
<p>Aneiros-Perez, G. and Vieu, P. (2013) Testing linearity in semi-parametric functional data analysis. <em>Comput. Stat.</em> <b>28</b>, 413-434. 
</p>


<h3>See Also</h3>

<p>Other related functions are <code><a href="#topic+plrm.est">plrm.est</a></code>, <code><a href="#topic+par.ancova">par.ancova</a></code> and <code><a href="#topic+np.ancova">np.ancova</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># EXAMPLE 1: REAL DATA
data(barnacles1)
data &lt;- as.matrix(barnacles1)
data &lt;- diff(data, 12)
data &lt;- cbind(data,1:nrow(data))

data(barnacles2)
data2 &lt;- as.matrix(barnacles2)
data2 &lt;- diff(data2, 12)
data2 &lt;- cbind(data2,1:nrow(data2))

data3 &lt;- array(0, c(nrow(data),ncol(data)-1,2))
data3[,,1] &lt;- data[,-4]
data3[,,2] &lt;- data2[,-4]
t &lt;- data[,4]

plrm.ancova(data=data3, t=t)



# EXAMPLE 2: SIMULATED DATA
## Example 2a: dependent data - true null hypotheses

set.seed(1234)
# We generate the data
n &lt;- 100
t &lt;- ((1:n)-0.5)/n
beta &lt;- c(0.05, 0.01)

m1 &lt;- function(t) {0.25*t*(1-t)}
f &lt;- m1(t)
x1 &lt;- matrix(rnorm(200,0,1), nrow=n)
sum1 &lt;- x1%*%beta
epsilon1 &lt;- arima.sim(list(order = c(1,0,0), ar=0.7), sd = 0.01, n = n)
y1 &lt;-  sum1 + f + epsilon1
data1 &lt;- cbind(y1,x1)

x2 &lt;- matrix(rnorm(200,1,2), nrow=n)
sum2 &lt;- x2%*%beta
epsilon2 &lt;- arima.sim(list(order = c(0,0,1), ma=0.5), sd = 0.02, n = n)
y2 &lt;- sum2 + f + epsilon2
data2 &lt;- cbind(y2,x2)

data_eq &lt;- array(c(data1,data2), c(n,3,2))

# We apply the tests
plrm.ancova(data=data_eq, t=t, time.series=TRUE)


## Example 2b: dependent data - false null hypotheses

set.seed(1234)
# We generate the data
n &lt;- 100
t &lt;- ((1:n)-0.5)/n
m3 &lt;- function(t) {0.25*t*(1-t)}
m4 &lt;- function(t) {0.25*t*(1-t)*0.75}
beta3 &lt;- c(0.05, 0.01)
beta4 &lt;- c(0.05, 0.02)

x3 &lt;- matrix(rnorm(200,0,1), nrow=n)
sum3 &lt;- x3%*%beta3
f3 &lt;- m3(t)
epsilon3 &lt;- arima.sim(list(order = c(1,0,0), ar=0.7), sd = 0.01, n = n)
y3 &lt;-  sum3 + f3 + epsilon3
data3 &lt;- cbind(y3,x3)

x4 &lt;- matrix(rnorm(200,1,2), nrow=n)
sum4 &lt;- x4%*%beta4
f4 &lt;- m4(t)
epsilon4 &lt;- arima.sim(list(order = c(0,0,1), ma=0.5), sd = 0.02, n = n)
y4 &lt;-  sum4 + f4 + epsilon4
data4 &lt;- cbind(y4,x4)

data_neq &lt;- array(c(data3,data4), c(n,3,2))

# We apply the tests
plrm.ancova(data=data_neq, t=t, time.series=TRUE)

</code></pre>

<hr>
<h2 id='plrm.beta'>
Semiparametric estimate for the parametric component of the regression function in PLR models
</h2><span id='topic+plrm.beta'></span>

<h3>Description</h3>

<p>This routine computes estimates for <code class="reqn">\beta</code> from a sample <code class="reqn">{(Y_i, X_{i1}, ..., X_{ip}, t_i): i=1,...,n}</code>, where:
</p>
<p style="text-align: center;"><code class="reqn">\beta = (\beta_1,...,\beta_p)</code>
</p>

<p>is an unknown vector parameter and
</p>
<p style="text-align: center;"><code class="reqn">Y_i= X_{i1}*\beta_1 +...+ X_{ip}*\beta_p + m(t_i) + \epsilon_i.</code>
</p>

<p>The nonparametric component, <code class="reqn">m</code>, is a smooth but unknown function, and the random errors, <code class="reqn">\epsilon_i</code>, are allowed to be time series. Ordinary least squares estimation, combined with kernel smoothing, is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plrm.beta(data = data, b.seq = NULL, estimator = "NW", kernel = "quadratic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plrm.beta_+3A_data">data</code></td>
<td>

<p><code>data[, 1]</code> contains the values of the response variable, <code class="reqn">Y</code>;
</p>
<p><code>data[, 2:(p+1)]</code> contains the values of the &quot;linear&quot; explanatory variables,
</p>
<p><code class="reqn">X_1, ..., X_p</code>;
</p>
<p><code>data[, p+2]</code> contains the values of the &quot;nonparametric&quot; explanatory variable, <code class="reqn">t</code>.
</p>
</td></tr>
<tr><td><code id="plrm.beta_+3A_b.seq">b.seq</code></td>
<td>
<p>vector of bandwidths for estimating <code class="reqn">\beta</code>. If <code>NULL</code> (the default), only one estimate of <code class="reqn">\beta</code> is computed, the corresponding bandwidth being selected by means of the cross-validation procedure.</p>
</td></tr>
<tr><td><code id="plrm.beta_+3A_estimator">estimator</code></td>
<td>
<p>allows us the choice between &ldquo;NW&rdquo; (Nadaraya-Watson) or &ldquo;LLP&rdquo; (Local Linear Polynomial). The default is &ldquo;NW&rdquo;.</p>
</td></tr>
<tr><td><code id="plrm.beta_+3A_kernel">kernel</code></td>
<td>
<p>allows us the choice between &ldquo;gaussian&rdquo;, &ldquo;quadratic&rdquo; (Epanechnikov kernel), &ldquo;triweight&rdquo; or &ldquo;uniform&rdquo; kernel. The default is &ldquo;quadratic&rdquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expression for the estimator of <code class="reqn">\beta</code> can be seen in page 52 in Aneiros-Perez <em>et al.</em> (2004).
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>BETA</code></td>
<td>
<p><code>p x length(b.seq)</code> matrix containing the estimate of <code class="reqn">\beta</code> for each bandwidth in <code>h.seq</code>.</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p><code>n x p x length(b.seq)</code> array containing the nonparametric estimate of
</p>
<p><code>E(X_{ij} | t_i)</code> (<code class="reqn">i=1,...,n; j=1,...,p</code>) for each bandwidth in <code>b.seq</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>German Aneiros Perez <a href="mailto:ganeiros@udc.es">ganeiros@udc.es</a>
</p>
<p>Ana Lopez Cheda <a href="mailto:ana.lopez.cheda@udc.es">ana.lopez.cheda@udc.es</a></p>


<h3>References</h3>

<p>Aneiros-Perez, G., Gonzalez-Manteiga, W. and Vieu, P. (2004) Estimation and testing in a partial linear regression model under long memory dependence. <em>Bernoulli</em> <b>10</b>, 49-78.
</p>
<p>Hardle, W., Liang, H. and Gao, J. (2000) <em>Partially Linear Models</em>. Physica-Verlag.
</p>
<p>Speckman, P. (1988) Kernel smoothing in partial linear models. <em>J. R. Statist. Soc. B</em> <b>50</b>, 413-436.
</p>


<h3>See Also</h3>

<p>Other related functions are: <code><a href="#topic+plrm.est">plrm.est</a></code>, <code><a href="#topic+plrm.gcv">plrm.gcv</a></code>, <code><a href="#topic+plrm.cv">plrm.cv</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># EXAMPLE 1: REAL DATA
data(barnacles1)
data &lt;- as.matrix(barnacles1)
data &lt;- diff(data, 12)
data &lt;- cbind(data,1:nrow(data))

b.h &lt;- plrm.gcv(data)$bh.opt
ajuste &lt;- plrm.beta(data=data, b=b.h[1])
ajuste$BETA



# EXAMPLE 2: SIMULATED DATA
## Example 2a: independent data

set.seed(1234)
# We generate the data
n &lt;- 100
t &lt;- ((1:n)-0.5)/n
beta &lt;- c(0.05, 0.01)
m &lt;- function(t) {0.25*t*(1-t)}
f &lt;- m(t)

x &lt;- matrix(rnorm(200,0,1), nrow=n)
sum &lt;- x%*%beta
epsilon &lt;- rnorm(n, 0, 0.01)
y &lt;-  sum + f + epsilon
data_ind &lt;- matrix(c(y,x,t),nrow=100)

# We estimate the parametric component of the PLR model
# (GCV bandwidth)
a &lt;- plrm.beta(data_ind)

a$BETA


## Example 2b: dependent data

set.seed(1234)
# We generate the data
x &lt;- matrix(rnorm(200,0,1), nrow=n)
sum &lt;- x%*%beta
epsilon &lt;- arima.sim(list(order = c(1,0,0), ar=0.7), sd = 0.01, n = n)
y &lt;-  sum + f + epsilon
data_dep &lt;- matrix(c(y,x,t),nrow=100)


# We estimate the parametric component of the PLR model
# (CV bandwidth)
b &lt;- plrm.cv(data_dep, ln.0=2)$bh.opt[2,1]
a &lt;-plrm.beta(data_dep, b=b)

a$BETA

</code></pre>

<hr>
<h2 id='plrm.ci'>
Confidence intervals estimation in partial linear regression models
</h2><span id='topic+plrm.ci'></span>

<h3>Description</h3>

<p>This routine obtains a confidence interval for the value <code class="reqn">a^T * \beta</code>, by asymptotic distribution and bootstrap, <code class="reqn">{(Y_i, X_{i1}, ..., X_{ip}, t_i): i=1,...,n}</code>, where:
</p>
<p style="text-align: center;"><code class="reqn">a = (a_1,...,a_p)^T</code>
</p>

<p>is an unknown vector, 
</p>
<p style="text-align: center;"><code class="reqn">\beta = (\beta_1,...,\beta_p)^T</code>
</p>

<p>is an unknown vector parameter and
</p>
<p style="text-align: center;"><code class="reqn">Y_i= X_{i1}*\beta_1 +...+ X_{ip}*\beta_p + m(t_i) + \epsilon_i.</code>
</p>

<p>The nonparametric component, <code class="reqn">m</code>, is a smooth but unknown function, and the random errors, <code class="reqn">\epsilon_i</code>, are allowed to be time series. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plrm.ci(data=data, seed=123, CI="AD", B=1000, N=50, a=NULL, 
        b1=NULL, b2=NULL, estimator="NW", 
        kernel="quadratic", p.arima=NULL, q.arima=NULL, 
        p.max=3, q.max=3, alpha=0.05, alpha2=0.05, num.lb=10, 
        ic="BIC", Var.Cov.eps=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plrm.ci_+3A_data">data</code></td>
<td>

<p><code>data[, 1]</code> contains the values of the response variable, <code class="reqn">Y</code>;
</p>
<p><code>data[, 2:(p+1)]</code> contains the values of the &quot;linear&quot; explanatory variables, <code class="reqn">X_1, ..., X_p</code>;
</p>
<p><code>data[, p+2]</code> contains the values of the &quot;nonparametric&quot; explanatory variable, <code class="reqn">t</code>.
</p>
</td></tr>
<tr><td><code id="plrm.ci_+3A_seed">seed</code></td>
<td>
<p>the considered seed.</p>
</td></tr>
<tr><td><code id="plrm.ci_+3A_ci">CI</code></td>
<td>
<p>method to obtain the confidence interval. It allows us to choose between: &ldquo;AD&rdquo; (asymptotic distribution), &ldquo;B&rdquo; (bootstrap) or &ldquo;all&rdquo; (both). The default is &ldquo;AD&rdquo;.</p>
</td></tr>
<tr><td><code id="plrm.ci_+3A_b">B</code></td>
<td>
<p>number of bootstrap replications. The default is 1000.</p>
</td></tr>
<tr><td><code id="plrm.ci_+3A_n">N</code></td>
<td>
<p>Truncation parameter used in the finite approximation of the MA(infinite) expression of <code class="reqn">\epsilon</code>.</p>
</td></tr>
<tr><td><code id="plrm.ci_+3A_a">a</code></td>
<td>
<p>Vector which, multiplied by <code>beta</code>, is used for obtaining the confidence interval of this result.</p>
</td></tr>
<tr><td><code id="plrm.ci_+3A_b1">b1</code></td>
<td>
<p>the considered bandwidth to estimate the confidence interval by asymptotic distribution. If NULL (the default), it is obtained using cross-validation.</p>
</td></tr>
<tr><td><code id="plrm.ci_+3A_b2">b2</code></td>
<td>
<p>the considered bandwidth to estimate the confidence interval by bootstrap. If NULL (the default), it is obtained using cross-validation.</p>
</td></tr>
<tr><td><code id="plrm.ci_+3A_estimator">estimator</code></td>
<td>
<p>allows us the choice between &ldquo;NW&rdquo; (Nadaraya-Watson) or &ldquo;LLP&rdquo; (Local Linear Polynomial). The default is &ldquo;NW&rdquo;.</p>
</td></tr>
<tr><td><code id="plrm.ci_+3A_kernel">kernel</code></td>
<td>
<p>allows us the choice between &ldquo;gaussian&rdquo;, &ldquo;quadratic&rdquo; (Epanechnikov kernel), &ldquo;triweight&rdquo; or &ldquo;uniform&rdquo; kernel. The default is &ldquo;quadratic&rdquo;.</p>
</td></tr>
<tr><td><code id="plrm.ci_+3A_p.arima">p.arima</code></td>
<td>
<p>the considered p to fit the model ARMA(p,q).</p>
</td></tr>
<tr><td><code id="plrm.ci_+3A_q.arima">q.arima</code></td>
<td>
<p>the considered q to fit the model ARMA(p,q).</p>
</td></tr>
<tr><td><code id="plrm.ci_+3A_p.max">p.max</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code>, the ARMA models are selected between the models ARMA(p,q) with 0&lt;=p&lt;=<code>p.max</code> and 0&lt;=q&lt;=<code>q.max</code>. The default is 3.</p>
</td></tr>
<tr><td><code id="plrm.ci_+3A_q.max">q.max</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code>, the ARMA models are selected between the models ARMA(p,q) with 0&lt;=p&lt;=<code>p.max</code> and 0&lt;=q&lt;=<code>q.max</code>. The default is 3.</p>
</td></tr>
<tr><td><code id="plrm.ci_+3A_alpha">alpha</code></td>
<td>
<p>1 - <code>alpha</code> is the confidence level of the confidence interval. The default is 0.05.</p>
</td></tr>
<tr><td><code id="plrm.ci_+3A_alpha2">alpha2</code></td>
<td>
<p>significance level used to check (if needed) the ARMA model fitted to the residuals. The default is 0.05.</p>
</td></tr>
<tr><td><code id="plrm.ci_+3A_num.lb">num.lb</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code>, it checks the suitability of the selected ARMA model according to the Ljung-Box test and the t-test. It uses up to <code>num.lb</code> delays in the Ljung-Box test. The default is 10.</p>
</td></tr>
<tr><td><code id="plrm.ci_+3A_ic">ic</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code>, <code>ic</code> contains the information criterion used to suggest the ARMA model. It allows us to choose between: &quot;AIC&quot;, &quot;AICC&quot; or &quot;BIC&quot; (the default).</p>
</td></tr>
<tr><td><code id="plrm.ci_+3A_var.cov.eps">Var.Cov.eps</code></td>
<td>
 <p><code>n x n</code> matrix of variances-covariances associated to the random errors of the regression model. If NULL (the default), the function tries to estimate it: it fits an ARMA model (selected according to an information criterium) to the residuals from the fitted regression model and, then, it obtains the var-cov matrix of such ARMA model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>Bootstrap</code></td>
<td>
<p>a dataframe containing <code>ci_inf</code> and <code>ci_sup</code>, the confidence intervals using bootstrap; <code>p_opt</code> and <code>q_opt</code> (the orders for the ARMA model fitted to the residuals) and <code>b1</code> and <code>b2</code>, the considered bandwidths.</p>
</td></tr>
<tr><td><code>AD</code></td>
<td>
<p>a dataframe containing <code>ci_inf</code> and <code>ci_sup</code>, the confidence intervals using the asymptotic distribution; <code>p_opt</code> and <code>q_opt</code> (the orders for the ARMA model fitted to the residuals) and <code>b1</code>, the considered bandwidth.</p>
</td></tr>
<tr><td><code>pv.Box.test</code></td>
<td>
<p>p-values of the Ljung-Box test for the model fitted to the residuals.</p>
</td></tr>
<tr><td><code>pv.t.test</code></td>
<td>
<p>p-values of the t.test for the model fitted to the residuals.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>German Aneiros Perez <a href="mailto:ganeiros@udc.es">ganeiros@udc.es</a>
</p>
<p>Ana Lopez Cheda <a href="mailto:ana.lopez.cheda@udc.es">ana.lopez.cheda@udc.es</a>
</p>


<h3>References</h3>

<p>Liang, H., Hardle, W., Sommerfeld, V. (2000) Bootstrap approximation in a partially linear regression model. <em>Journal of Statistical Planning and Inference</em> <b>91</b>, 413-426.
</p>
<p>You, J., Zhou, X. (2005) Bootstrap of a semiparametric partially linear model with autoregressive errors. <em>Statistica Sinica</em> <b>15</b>, 117-133.
</p>


<h3>See Also</h3>

<p>A related functions is <code><a href="#topic+par.ci">par.ci</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># EXAMPLE 1: REAL DATA
data(barnacles1)
data &lt;- as.matrix(barnacles1)
data &lt;- diff(data, 12)
data &lt;- cbind(data,1:nrow(data))

b.h &lt;- plrm.gcv(data)$bh.opt
b1 &lt;- b.h[1]

## Not run: plrm.ci(data, b1=b1, b2=b1, a=c(1,0), CI="all")
## Not run: plrm.ci(data, b1=b1, b2=b1, a=c(0,1), CI="all")



# EXAMPLE 2: SIMULATED DATA
## Example 2a: dependent data

set.seed(123)
# We generate the data
n &lt;- 100
t &lt;- ((1:n)-0.5)/n
m &lt;- function(t) {t+0.5}
f &lt;- m(t)

beta &lt;- c(0.5, 2)
x &lt;- matrix(rnorm(200,0,3), nrow=n)
sum &lt;- x%*%beta
sum &lt;- as.matrix(sum)
eps &lt;- arima.sim(list(order = c(1,0,0), ar=0.7), sd = 0.1, n = n)
eps &lt;- as.matrix(eps)

y &lt;-  sum + f + eps
data_plrmci &lt;- cbind(y,x,t)

## Not run: plrm.ci(data, a=c(1,0), CI="all")
## Not run: plrm.ci(data, a=c(0,1), CI="all")
</code></pre>

<hr>
<h2 id='plrm.cv'>
Cross-validation bandwidth selection in PLR models
</h2><span id='topic+plrm.cv'></span>

<h3>Description</h3>

<p>From a sample <code class="reqn">{(Y_i, X_{i1}, ..., X_{ip}, t_i): i=1,...,n}</code>, this routine computes, for each <code class="reqn">l_n</code> considered, an optimal pair of bandwidths for estimating the regression function of the model
</p>
<p style="text-align: center;"><code class="reqn">Y_i= X_{i1}*\beta_1 +...+ X_{ip}*\beta_p + m(t_i) + \epsilon_i,</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\beta = (\beta_1,...,\beta_p)</code>
</p>

<p>is an unknown vector parameter and
</p>
<p style="text-align: center;"><code class="reqn">m(.)</code>
</p>

<p>is a smooth but unknown function.
The random errors, <code class="reqn">\epsilon_i</code>, are allowed to be time series. The optimal pair of bandwidths, (<code>b.opt, h.opt</code>), is selected by means of the leave-(<code class="reqn">2l_n + 1</code>)-out cross-validation procedure. The bandwidth <code>b.opt</code> is used in the estimate of <code class="reqn">\beta</code>, while the pair of bandwidths <code>(b.opt, h.opt)</code> is considered in the estimate of <code class="reqn">m</code>. Kernel smoothing, combined with ordinary least squares estimation, is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plrm.cv(data = data, b.equal.h = TRUE, b.seq=NULL, h.seq=NULL, 
num.b = NULL, num.h = NULL, w = NULL, num.ln = 1, ln.0 = 0, 
step.ln = 2, estimator = "NW", kernel = "quadratic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plrm.cv_+3A_data">data</code></td>
<td>

<p><code>data[,1]</code> contains the values of the response variable, <code class="reqn">Y</code>;
</p>
<p><code>data[, 2:(p+1)]</code> contains the values of the &quot;linear&quot; explanatory variables,
</p>
<p><code class="reqn">X_1, ..., X_p</code>;
</p>
<p><code>data[, p+2]</code> contains the values of the &quot;nonparametric&quot; explanatory variable, <code class="reqn">t</code>.
</p>
</td></tr>
<tr><td><code id="plrm.cv_+3A_b.equal.h">b.equal.h</code></td>
<td>
<p>if TRUE (the default), the same bandwidth is used for estimating both <code class="reqn">\beta</code> and <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="plrm.cv_+3A_b.seq">b.seq</code></td>
<td>
<p>sequence of considered bandwidths, <code>b</code>, in the CV function for estimating <code class="reqn">\beta</code>. If <code>NULL</code> (the default), <code>num.b</code> equidistant values between zero and a quarter of the range of <code class="reqn">{t_i}</code> are considered.</p>
</td></tr>
<tr><td><code id="plrm.cv_+3A_h.seq">h.seq</code></td>
<td>
<p>sequence of considered bandwidths, <code>h</code>, in the pair of bandwidths <code>(b, h)</code> used in the CV function for estimating <code class="reqn">m</code>. If <code>NULL</code> (the default), <code>num.h</code> equidistant values between zero and a quarter of the range of <code class="reqn">t_i</code> are considered.</p>
</td></tr>
<tr><td><code id="plrm.cv_+3A_num.b">num.b</code></td>
<td>
<p>number of values used to build the sequence of considered bandwidths for estimating <code class="reqn">\beta</code>. If <code>b.seq</code> is not <code>NULL</code>, <code>num.b=length(b.seq)</code>. Otherwise, if both <code>num.b</code> and <code>num.h</code> are <code>NULL</code> (the default), <code>num.b=50</code> is considered; if <code>num.b</code> is <code>NULL</code> (the default) but <code>num.h</code> is not <code>NULL</code>, then <code>num.b=num.h</code> is considered; if <code>b.equal.h=TRUE</code> (the default) and both <code>num.b</code> and <code>num.h</code> are not <code>NULL</code> and different, the maximum value of <code>num.b</code> and <code>num.h</code> is considered for both.</p>
</td></tr>
<tr><td><code id="plrm.cv_+3A_num.h">num.h</code></td>
<td>
<p>pairs of bandwidths (<code>b, h</code>) are used for estimating <code class="reqn">m</code>, <code>num.h</code> being the number of values considered for <code>h</code>. If <code>h.seq</code> is not <code>NULL</code>, <code>num.h=length(h.seq)</code>. Otherwise, if both <code>num.b</code> and <code>num.h</code> are <code>NULL</code> (the default), <code>num.h=50</code> is considered; if <code>num.h</code> is <code>NULL</code> (the default) but <code>num.b</code> is not <code>NULL</code>, <code>num.h=num.b</code> is considered; if <code>b.equal.h=TRUE</code> (the default) and both <code>num.b</code> and <code>num.h</code> are not <code>NULL</code> and different, the maximum value of <code>num.b</code> and <code>num.h</code> is considered for both.</p>
</td></tr>
<tr><td><code id="plrm.cv_+3A_w">w</code></td>
<td>
<p>support interval of the weigth function in the CV function. If <code>NULL</code> (the default), <code class="reqn">(q_{0.1}, q_{0.9})</code> is considered, where <code class="reqn">q_p</code> denotes the quantile of order <code class="reqn">p</code> of <code class="reqn">{t_i}</code>.</p>
</td></tr>
<tr><td><code id="plrm.cv_+3A_num.ln">num.ln</code></td>
<td>
<p>number of values for <code class="reqn">l_n</code>: after estimating <code class="reqn">\beta</code>, <code class="reqn">2l_{n} + 1</code> observations around each point <code class="reqn">t_i</code> are eliminated to estimate <code class="reqn">m(t_i)</code> in the CV function. The default is 1.</p>
</td></tr>
<tr><td><code id="plrm.cv_+3A_ln.0">ln.0</code></td>
<td>
<p>minimum value for <code class="reqn">l_n</code>. The default is 0.</p>
</td></tr>
<tr><td><code id="plrm.cv_+3A_step.ln">step.ln</code></td>
<td>
<p>distance between two consecutives values of <code class="reqn">l_n</code>. The default is 2.</p>
</td></tr>
<tr><td><code id="plrm.cv_+3A_estimator">estimator</code></td>
<td>
<p>allows us the choice between &ldquo;NW&rdquo; (Nadaraya-Watson) or &ldquo;LLP&rdquo; (Local Linear Polynomial). The default is &ldquo;NW&rdquo;.</p>
</td></tr>
<tr><td><code id="plrm.cv_+3A_kernel">kernel</code></td>
<td>
<p>allows us the choice between &ldquo;gaussian&rdquo;, &ldquo;quadratic&rdquo; (Epanechnikov kernel), &ldquo;triweight&rdquo; or &ldquo;uniform&rdquo; kernel. The default is &ldquo;quadratic&rdquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A weight function (specifically, the indicator function <b>1</b><code class="reqn">_{[w[1] , w[2]]}</code>) is introduced in the CV function to allow elimination (or at least significant reduction) of boundary effects from the estimate of <code class="reqn">m(t_i)</code>.
</p>
<p>As noted in the definition of <code>num.ln</code>, the estimate of <code class="reqn">\beta</code> in the CV function is obtained from all data while, once <code class="reqn">\beta</code> is estimated, <code class="reqn">2l_{n} + 1</code> observations around each <code class="reqn">t_i</code> are eliminated to estimate <code class="reqn">m(t_i)</code> in the CV function. Actually, the estimate of <code class="reqn">\beta</code> to be used in time <code class="reqn">i</code> in the CV function could be done eliminating such <code class="reqn">2l_{n} + 1</code> observations too; that possibility was not implemented because both their computational cost and the known fact that the estimate of <code class="reqn">\beta</code> is quite insensitive to the bandwidth selection.
</p>
<p>The implemented procedure generalizes that one in expression (8) in Aneiros-Perez and Quintela-del-Rio (2001) by including a weight function (see above) and allowing two smoothing parameters instead of only one (see Aneiros-Perez <em>et al.</em>, 2004).
</p>


<h3>Value</h3>

<table>
<tr><td><code>bh.opt</code></td>
<td>
<p>dataframe containing, for each <code>ln</code> considered, the selected value for <code>(b,h)</code>.</p>
</td></tr>
<tr><td><code>CV.opt</code></td>
<td>
<p><code>CV.opt[k]</code> is the minimum value of the CV function when de k-th value of <code>ln</code> is considered.</p>
</td></tr>
<tr><td><code>CV</code></td>
<td>
<p>an array containing the values of the CV function for each pair of bandwidths and <code>ln</code> considered.</p>
</td></tr>
<tr><td><code>b.seq</code></td>
<td>
<p>sequence of considered bandwidths, <code>b</code>, in the CV function for estimating <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code>h.seq</code></td>
<td>
<p>sequence of considered bandwidths, <code>h</code>, in the pair of bandwidths <code>(b, h)</code> used in the CV function for estimating <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>support interval of the weigth function in the CV function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>German Aneiros Perez <a href="mailto:ganeiros@udc.es">ganeiros@udc.es</a>
</p>
<p>Ana Lopez Cheda <a href="mailto:ana.lopez.cheda@udc.es">ana.lopez.cheda@udc.es</a></p>


<h3>References</h3>

<p>Aneiros-Perez, G., Gonzalez-Manteiga, W. and Vieu, P. (2004) Estimation and testing in a partial linear regression under long-memory dependence. <em>Bernoulli</em> <b>10</b>, 49-78.
</p>
<p>Aneiros-Perez, G. and Quintela-del-Rio, A. (2001) Modified cross-validation in semiparametric regression models with dependent errors. <em>Comm. Statist. Theory Methods</em> <b>30</b>, 289-307.
</p>
<p>Chu, C-K and Marron, J.S. (1991) Comparison of two bandwidth selectors with dependent errors. <em>The Annals of Statistics</em> <b>19</b>, 1906-1918.
</p>


<h3>See Also</h3>

<p>Other related functions are: <code><a href="#topic+plrm.beta">plrm.beta</a></code>, <code><a href="#topic+plrm.est">plrm.est</a></code>, <code><a href="#topic+plrm.gcv">plrm.gcv</a></code>, <code><a href="#topic+np.est">np.est</a></code>, <code><a href="#topic+np.gcv">np.gcv</a></code> and <code><a href="#topic+np.cv">np.cv</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># EXAMPLE 1: REAL DATA
data(barnacles1)
data &lt;- as.matrix(barnacles1)
data &lt;- diff(data, 12)
data &lt;- cbind(data,1:nrow(data))

aux &lt;- plrm.cv(data, step.ln=1, num.ln=2)
aux$bh.opt
plot.ts(aux$CV[,-2,])

par(mfrow=c(2,1))
plot(aux$b.seq,aux$CV[,-2,1], xlab="h", ylab="CV", type="l", main="ln=0")
plot(aux$b.seq,aux$CV[,-2,2], xlab="h", ylab="CV", type="l", main="ln=1")



# EXAMPLE 2: SIMULATED DATA
## Example 2a: independent data

set.seed(1234)
# We generate the data
n &lt;- 100
t &lt;- ((1:n)-0.5)/n
beta &lt;- c(0.05, 0.01)
m &lt;- function(t) {0.25*t*(1-t)}
f &lt;- m(t)

x &lt;- matrix(rnorm(200,0,1), nrow=n)
sum &lt;- x%*%beta
epsilon &lt;- rnorm(n, 0, 0.01)
y &lt;-  sum + f + epsilon
data_ind &lt;- matrix(c(y,x,t),nrow=100)

# We apply the function
a &lt;-plrm.cv(data_ind)
a$CV.opt

CV &lt;- a$CV
h &lt;- a$h.seq
plot(h, CV,type="l")


## Example 2b: dependent data and ln.0 &gt; 0

set.seed(1234)
# We generate the data
x &lt;- matrix(rnorm(200,0,1), nrow=n)
sum &lt;- x%*%beta
epsilon &lt;- arima.sim(list(order = c(1,0,0), ar=0.7), sd = 0.01, n = n)
y &lt;-  sum + f + epsilon
data_dep &lt;- matrix(c(y,x,t),nrow=100)

# We apply the function
a &lt;-plrm.cv(data_dep, ln.0=2)
a$CV.opt

CV &lt;- a$CV
h &lt;- a$h.seq
plot(h, CV,type="l")

</code></pre>

<hr>
<h2 id='plrm.est'>
Semiparametric estimates for the unknown components of the regression function in PLR models
</h2><span id='topic+plrm.est'></span>

<h3>Description</h3>

<p>This routine computes estimates for <code class="reqn">\beta</code> and <code class="reqn">m(newt_j)</code> (<code class="reqn">j=1,...,J</code>) from a sample 
<code class="reqn">{(Y_i, X_{i1}, ..., X_{ip}, t_i)}</code>: 
<code class="reqn">i=1,...,n</code>, where:
</p>
<p style="text-align: center;"><code class="reqn">\beta = (\beta_1,...,\beta_p)</code>
</p>

<p>is an unknown vector parameter,
</p>
<p style="text-align: center;"><code class="reqn">m(.)</code>
</p>

<p>is a smooth but unknown function and
</p>
<p style="text-align: center;"><code class="reqn">Y_i= X_{i1}*\beta_1 +...+ X_{ip}*\beta_p + m(t_i) + \epsilon_i.</code>
</p>

<p>The random errors, <code class="reqn">\epsilon_i</code>, are allowed to be time series. Kernel smoothing, combined with ordinary least squares estimation, is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plrm.est(data = data, b = NULL, h = NULL, newt = NULL, estimator = "NW", 
kernel = "quadratic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plrm.est_+3A_data">data</code></td>
<td>

<p><code>data[, 1]</code> contains the values of the response variable, <code class="reqn">Y</code>;
</p>
<p><code>data[, 2:(p+1)]</code> contains the values of the &quot;linear&quot; explanatory variables,
</p>
<p><code class="reqn">X_1, ..., X_p</code>;
</p>
<p><code>data[, p+2]</code> contains the values of the &quot;nonparametric&quot; explanatory variable, <code class="reqn">t</code>.
</p>
</td></tr>
<tr><td><code id="plrm.est_+3A_b">b</code></td>
<td>
<p>bandwidth for estimating the parametric part of the model. If both <code>b</code> and <code>h</code> are <code>NULL</code> (the default), it is selected by means of the cross-validation procedure (fixing <code>b=h</code>); if <code>b</code> is <code>NULL</code> (the default) but <code>h</code> is not <code>NULL</code>, <code>b=h</code> is considered.</p>
</td></tr>
<tr><td><code id="plrm.est_+3A_h">h</code></td>
<td>
<p><code>(b,h)</code> is the pair of bandwidths for estimating the nonparametric part of the model. If both <code>b</code> and <code>h</code> are <code>NULL</code> (the default), it is selected by means of the cross-validation procedure (fixing <code>b=h</code>); if <code>b</code> is <code>NULL</code> (the default) but <code>h</code> is not <code>NULL</code>, <code>b=h</code> is considered; if <code>h</code> is <code>NULL</code> (the default) but <code>b</code> is not <code>NULL</code>, <code>h=b</code> is considered.</p>
</td></tr>
<tr><td><code id="plrm.est_+3A_newt">newt</code></td>
<td>
<p>values of the &quot;nonparametric&quot; explanatory variable where the estimator of <code class="reqn">m</code> is evaluated. If NULL (the default), the considered values will be the values of <code>data[,p+2]</code>.</p>
</td></tr>
<tr><td><code id="plrm.est_+3A_estimator">estimator</code></td>
<td>
<p>allows us the choice between &ldquo;NW&rdquo; (Nadaraya-Watson) or &ldquo;LLP&rdquo; (Local Linear Polynomial). The default is &ldquo;NW&rdquo;.</p>
</td></tr>
<tr><td><code id="plrm.est_+3A_kernel">kernel</code></td>
<td>
<p>allows us the choice between &ldquo;gaussian&rdquo;, &ldquo;quadratic&rdquo; (Epanechnikov kernel), &ldquo;triweight&rdquo; or &ldquo;uniform&rdquo; kernel. The default is &ldquo;quadratic&rdquo;.</p>
</td></tr>   
</table>


<h3>Details</h3>

<p>Expressions for the estimators of <code class="reqn">\beta</code> and <code class="reqn">m</code> can be seen in page 52 in Aneiros-Perez <em>et al.</em> (2004).
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>a vector containing the estimate of <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code>m.t</code></td>
<td>
<p>a vector containing the estimator of the non-parametric part, <code class="reqn">m</code>, evaluated in the design points.</p>
</td></tr>
<tr><td><code>m.newt</code></td>
<td>
<p>a vector containing the estimator of the non-parametric part, <code class="reqn">m</code>, evaluated in <code>newt</code>.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector containing the residuals: <code>Y - X*beta - m.t</code>.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the values obtained from the expression: <code>X*beta + m.t</code></p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>the considered bandwidth for estimating <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p><code>(b,h)</code> is the pair of bandwidths considered for estimating <code class="reqn">m</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>German Aneiros Perez <a href="mailto:ganeiros@udc.es">ganeiros@udc.es</a>
</p>
<p>Ana Lopez Cheda <a href="mailto:ana.lopez.cheda@udc.es">ana.lopez.cheda@udc.es</a></p>


<h3>References</h3>

<p>Aneiros-Perez, G., Gonzalez-Manteiga, W. and Vieu, P. (2004) Estimation and testing in a partial linear regression under long-memory dependence. <em>Bernoulli</em> <b>10</b>, 49-78.
</p>
<p>Hardle, W., Liang, H. and Gao, J. (2000) <em>Partially Linear Models</em>. Physica-Verlag.
</p>
<p>Speckman, P. (1988) Kernel smoothing in partial linear models. <em>J. R. Statist. Soc. B</em> <b>50</b>, 413-436.
</p>


<h3>See Also</h3>

<p>Other related functions are: <code><a href="#topic+plrm.beta">plrm.beta</a></code>, <code><a href="#topic+plrm.gcv">plrm.gcv</a></code>, <code><a href="#topic+plrm.cv">plrm.cv</a></code>, <code><a href="#topic+np.est">np.est</a></code>, <code><a href="#topic+np.gcv">np.gcv</a></code> and <code><a href="#topic+np.cv">np.cv</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># EXAMPLE 1: REAL DATA
data(barnacles1)
data &lt;- as.matrix(barnacles1)
data &lt;- diff(data, 12)
data &lt;- cbind(data,1:nrow(data))

b.h &lt;- plrm.gcv(data)$bh.opt
ajuste &lt;- plrm.est(data=data, b=b.h[1], h=b.h[2])
ajuste$beta
plot(data[,4], ajuste$m, type="l", xlab="t", ylab="m(t)")

plot(data[,1], ajuste$fitted.values, xlab="y", ylab="y.hat", main="y.hat vs y")
abline(0,1)

mean(ajuste$residuals^2)/var(data[,1])



# EXAMPLE 2: SIMULATED DATA
## Example 2a: independent data

set.seed(1234)
# We generate the data
n &lt;- 100
t &lt;- ((1:n)-0.5)/n
beta &lt;- c(0.05, 0.01)
m &lt;- function(t) {0.25*t*(1-t)}
f &lt;- m(t)

x &lt;- matrix(rnorm(200,0,1), nrow=n)
sum &lt;- x%*%beta
epsilon &lt;- rnorm(n, 0, 0.01)
y &lt;-  sum + f + epsilon
data_ind &lt;- matrix(c(y,x,t),nrow=100)

# We estimate the components of the PLR model
# (CV bandwidth)
a &lt;- plrm.est(data_ind)

a$beta

est &lt;- a$m.t
plot(t, est, type="l", lty=2, ylab="")
points(t, 0.25*t*(1-t), type="l")
legend(x="topleft", legend = c("m", "m hat"), col=c("black", "black"), lty=c(1,2))


## Example 2b: dependent data
# We generate the data
x &lt;- matrix(rnorm(200,0,1), nrow=n)
sum &lt;- x%*%beta
epsilon &lt;- arima.sim(list(order = c(1,0,0), ar=0.7), sd = 0.01, n = n)
y &lt;-  sum + f + epsilon
data_dep &lt;- matrix(c(y,x,t),nrow=100)

# We estimate the components of the PLR model
# (CV bandwidth)
h &lt;- plrm.cv(data_dep, ln.0=2)$bh.opt[3,1]
a &lt;- plrm.est(data_dep, h=h)

a$beta

est &lt;- a$m.t
plot(t, est, type="l", lty=2, ylab="")
points(t, 0.25*t*(1-t), type="l")
legend(x="topleft", legend = c("m", "m hat"), col=c("black", "black"), lty=c(1,2))

</code></pre>

<hr>
<h2 id='plrm.gcv'>
Generalized cross-validation bandwidth selection in PLR models
</h2><span id='topic+plrm.gcv'></span>

<h3>Description</h3>

<p>From a sample <code class="reqn">{(Y_i, X_{i1}, ..., X_{ip}, t_i): i=1,...,n}</code>, this routine computes an optimal pair of bandwidths for estimating the regression function of the model
</p>
<p style="text-align: center;"><code class="reqn">Y_i= X_{i1}*\beta_1 +...+ X_{ip}*\beta_p + m(t_i) + \epsilon_i,</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\beta = (\beta_1,...,\beta_p)</code>
</p>

<p>is an unknown vector parameter and
</p>
<p style="text-align: center;"><code class="reqn">m(.)</code>
</p>

<p>is a smooth but unknown function.
The optimal pair of bandwidths, <code>(b.opt, h.opt)</code>, is selected by means of the generalized cross-validation procedure. The bandwidth <code>b.opt</code> is used in the estimate of <code class="reqn">\beta</code>, while the pair of bandwidths <code>(b.opt, h.opt)</code> is considered in the estimate of <code class="reqn">m</code>. Kernel smoothing, combined with ordinary least squares estimation, is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plrm.gcv(data = data, b.equal.h = TRUE, b.seq=NULL, h.seq=NULL, 
num.b = NULL, num.h = NULL, estimator = "NW", kernel = "quadratic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plrm.gcv_+3A_data">data</code></td>
<td>

<p><code>data[,1]</code> contains the values of the response variable, <code class="reqn">Y</code>; 
</p>
<p><code>data[, 2:(p+1)]</code> contains the values of the &quot;linear&quot; explanatory variables,
</p>
<p><code class="reqn">X_1, ..., X_p</code>;
</p>
<p><code>data[, p+2]</code> contains the values of the &quot;nonparametric&quot; explanatory variable, <code class="reqn">t</code>.
</p>
</td></tr>
<tr><td><code id="plrm.gcv_+3A_b.equal.h">b.equal.h</code></td>
<td>
<p>if TRUE (the default), the same bandwidth is used for estimating both <code class="reqn">\beta</code> and <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="plrm.gcv_+3A_b.seq">b.seq</code></td>
<td>
<p>sequence of considered bandwidths, <code>b</code>, in the GCV function for estimating <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code id="plrm.gcv_+3A_h.seq">h.seq</code></td>
<td>
<p>sequence of considered bandwidths, <code>h</code>, in the pair of bandwidths <code>(b, h)</code> used in the GCV function for estimating <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="plrm.gcv_+3A_num.b">num.b</code></td>
<td>
<p>number of values used to build the sequence of considered bandwidths for estimating <code class="reqn">\beta</code>. If <code>b.seq</code> is not <code>NULL</code>, <code>num.b=length(b.seq)</code>. Otherwise, if both <code>num.b</code> and <code>num.h</code> are <code>NULL</code> (the default), <code>num.b=50</code> is considered; if <code>num.b</code> is <code>NULL</code> (the default) but <code>num.h</code> is not <code>NULL</code>, then <code>num.b=num.h</code> is considered; if <code>b.equal.h=TRUE</code> (the default) and both <code>num.b</code> and <code>num.h</code> are not <code>NULL</code> and different, the maximum value of <code>num.b</code> and <code>num.h</code> is considered for both.</p>
</td></tr>
<tr><td><code id="plrm.gcv_+3A_num.h">num.h</code></td>
<td>
<p>pairs of bandwidths (<code>b, h</code>) are used for estimating <code class="reqn">m</code>, <code>num.h</code> being the number of values considered for <code>h</code>. If <code>h.seq</code> is not <code>NULL</code>, <code>num.h=length(h.seq)</code>. Otherwise, if both <code>num.b</code> and <code>num.h</code> are <code>NULL</code> (the default), <code>num.h=50</code> is considered; if <code>num.h</code> is <code>NULL</code> (the default) but <code>num.b</code> is not <code>NULL</code>, <code>num.h=num.b</code> is considered; if <code>b.equal.h=TRUE</code> (the default) and both <code>num.b</code> and <code>num.h</code> are not <code>NULL</code> and different, the maximum value of <code>num.b</code> and <code>num.h</code> is considered for both.</p>
</td></tr>
<tr><td><code id="plrm.gcv_+3A_estimator">estimator</code></td>
<td>
<p>allows us the choice between &ldquo;NW&rdquo; (Nadaraya-Watson) or &ldquo;LLP&rdquo; (Local Linear Polynomial). The default is &ldquo;NW&rdquo;.</p>
</td></tr>
<tr><td><code id="plrm.gcv_+3A_kernel">kernel</code></td>
<td>
<p>allows us the choice between &ldquo;gaussian&rdquo;, &ldquo;quadratic&rdquo; (Epanechnikov kernel), &ldquo;triweight&rdquo; or &ldquo;uniform&rdquo; kernel. The default is &ldquo;quadratic&rdquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implemented procedure generalizes that one in page 423 in Speckman (1988) by allowing two smoothing parameters instead of only one (see Aneiros-Perez <em>et al.</em>, 2004).
</p>


<h3>Value</h3>

<table>
<tr><td><code>bh.opt</code></td>
<td>
<p>selected value for <code>(b,h)</code>.</p>
</td></tr>
<tr><td><code>GCV.opt</code></td>
<td>
<p>minimum value of the GCV function.</p>
</td></tr>
<tr><td><code>GCV</code></td>
<td>
<p>matrix containing the values of the GCV function for each pair of bandwidths considered.</p>
</td></tr>
<tr><td><code>b.seq</code></td>
<td>
<p>sequence of considered bandwidths, <code>b</code>, in the GCV function for estimating <code class="reqn">\beta</code>. If <code>b.seq</code> was not input by the user, it is composed by <code>num.b</code> equidistant values between zero and a quarter of the range of <code class="reqn">{t_i}</code>.</p>
</td></tr>
<tr><td><code>h.seq</code></td>
<td>
<p>sequence of considered bandwidths, <code>h</code>, in the pair of bandwidths <code>(b, h)</code> used in the GCV function for estimating <code class="reqn">m</code>. If <code>h.seq</code> was not input by the user, it is composed by <code>num.h</code> equidistant values between zero and a quarter of the range of <code class="reqn">{t_i}</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>German Aneiros Perez <a href="mailto:ganeiros@udc.es">ganeiros@udc.es</a>
</p>
<p>Ana Lopez Cheda <a href="mailto:ana.lopez.cheda@udc.es">ana.lopez.cheda@udc.es</a></p>


<h3>References</h3>

<p>Aneiros-Perez, G., Gonzalez-Manteiga, W. and Vieu, P. (2004) Estimation and testing in a partial linear regression under long-memory dependence. <em>Bernoulli</em> <b>10</b>, 49-78.
</p>
<p>Green, P. (1985) Linear models for field trials, smoothing and cross-validation. <em>Biometrika</em> <b>72</b>, 527-537.
</p>
<p>Speckman, P. (1988) Kernel smoothing in partial linear models <em>J. R. Statist. Soc. B</em> <b>50</b>, 413-436.
</p>


<h3>See Also</h3>

<p>Other related functions are: <code><a href="#topic+plrm.beta">plrm.beta</a></code>, <code><a href="#topic+plrm.est">plrm.est</a></code>, <code><a href="#topic+plrm.cv">plrm.cv</a></code>, <code><a href="#topic+np.est">np.est</a></code>, <code><a href="#topic+np.gcv">np.gcv</a></code> and <code><a href="#topic+np.cv">np.cv</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># EXAMPLE 1: REAL DATA

data(barnacles1)
data &lt;- as.matrix(barnacles1)
data &lt;- diff(data, 12)
data &lt;- cbind(data,1:nrow(data))

aux &lt;- plrm.gcv(data)
aux$bh.opt
plot(aux$b.seq, aux$GCV, xlab="h", ylab="GCV", type="l")



# EXAMPLE 2: SIMULATED DATA
## Example 2a: independent data

set.seed(1234)

# We generate the data
n &lt;- 100
t &lt;- ((1:n)-0.5)/n
beta &lt;- c(0.05, 0.01)
m &lt;- function(t) {0.25*t*(1-t)}
f &lt;- m(t)

x &lt;- matrix(rnorm(200,0,1), nrow=n)
sum &lt;- x%*%beta
epsilon &lt;- rnorm(n, 0, 0.01)
y &lt;-  sum + f + epsilon
data_ind &lt;- matrix(c(y,x,t),nrow=100)

# We obtain the optimal bandwidths
a &lt;-plrm.gcv(data_ind)
a$GCV.opt

GCV &lt;- a$GCV
h &lt;- a$h.seq
plot(h, GCV,type="l")

</code></pre>

<hr>
<h2 id='plrm.gof'>
Goodness-of-Fit tests in PLR models
</h2><span id='topic+plrm.gof'></span>

<h3>Description</h3>

<p>From a sample <code class="reqn">{(Y_i, X_{i1}, ..., X_{ip}, t_i): i=1,...,n}</code>, this routine tests the null hypotheses <code class="reqn">H_0: \beta=\beta_0</code> and <code class="reqn">H_0: m=m_0</code>, where:
</p>
<p style="text-align: center;"><code class="reqn">\beta = (\beta_1,...,\beta_p)</code>
</p>

<p>is an unknown vector parameter,
</p>
<p style="text-align: center;"><code class="reqn">m(.)</code>
</p>

<p>is a smooth but unknown function and
</p>
<p style="text-align: center;"><code class="reqn">Y_i= X_{i1}*\beta_1 +...+ X_{ip}*\beta_p + m(t_i) + \epsilon_i.</code>
</p>

<p>Fixed equally spaced design is considered for the &quot;nonparametric&quot; explanatory variable, <code class="reqn">t</code>, and the random errors, <code class="reqn">\epsilon_i</code>, are allowed to be time series. The test statistic used for testing <code class="reqn">H0: \beta = \beta_0</code> derives from the asymptotic normality of an estimator of <code class="reqn">\beta</code> based on both ordinary least squares and kernel smoothing (this result giving a <code class="reqn">\chi^2</code>-test). The test statistic used for testing <code class="reqn">H0: m = m_0</code> derives from a Cramer-von-Mises-type functional distance between a nonparametric estimator of <code class="reqn">m</code> and <code class="reqn">m_0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plrm.gof(data = data, beta0 = NULL, m0 = NULL, b.seq = NULL, 
h.seq = NULL, w = NULL, estimator = "NW", kernel = "quadratic", 
time.series = FALSE, Var.Cov.eps = NULL, Tau.eps = NULL, 
b0 = NULL, h0 = NULL, lag.max = 50, p.max = 3, q.max = 3, 
ic = "BIC", num.lb = 10, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plrm.gof_+3A_data">data</code></td>
<td>

<p><code>data[,1]</code> contains the values of the response variable, <code class="reqn">Y</code>;
</p>
<p><code>data[, 2:(p+1)]</code> contains the values of the &quot;linear&quot; explanatory variables
</p>
<p><code class="reqn">X_1, ... X_p</code>;
</p>
<p><code>data[, p+2]</code> contains the values of the &quot;nonparametric&quot; explanatory variable, <code class="reqn">t</code>.</p>
</td></tr>
<tr><td><code id="plrm.gof_+3A_beta0">beta0</code></td>
<td>
<p>the considered parameter vector in the parametric null hypothesis. If <code>NULL</code> (the default), the zero vector is considered.</p>
</td></tr>
<tr><td><code id="plrm.gof_+3A_m0">m0</code></td>
<td>
<p>the considered function in the nonparametric null hypothesis. If <code>NULL</code> (the default), the zero function is considered.</p>
</td></tr>
<tr><td><code id="plrm.gof_+3A_b.seq">b.seq</code></td>
<td>
<p>the statistic test for <code class="reqn">H0: \beta=\beta_0</code> is performed using each bandwidth in the vector <code>b.seq</code>. If <code>NULL</code> (the default) but <code>h.seq</code> is not <code>NULL</code>, it takes <code>b.seq=h.seq</code>. If both <code>b.seq</code> and <code>h.seq</code> are <code>NULL</code>, 10 equidistant values between zero and a quarter of the range of <code class="reqn">{t_i}</code> are considered.</p>
</td></tr>
<tr><td><code id="plrm.gof_+3A_h.seq">h.seq</code></td>
<td>
<p>the statistic test for <code class="reqn">H0: m=m_0</code> is performed using each pair of bandwidths (<code>b.seq[j], h.seq[j]</code>). If <code>NULL</code> (the default) but <code>b.seq</code> is not <code>NULL</code>, it takes <code>h.seq=b.seq</code>. If both <code>b.seq</code> and <code>h.seq</code> are <code>NULL</code>, 10 equidistant values between zero and a quarter of the range of <code class="reqn">{t_i}</code> are considered for both <code>b.seq</code> and  <code>h.seq</code>.</p>
</td></tr> 
<tr><td><code id="plrm.gof_+3A_w">w</code></td>
<td>
<p>support interval of the weigth function in the test statistic for <code class="reqn">H0: m = m_0</code>. If <code>NULL</code> (the default), <code class="reqn">(q_{0.1}, q_{0.9})</code> is considered, where <code class="reqn">q_p</code> denotes the quantile of order <code class="reqn">p</code> of <code class="reqn">{t_i}</code>.</p>
</td></tr>
<tr><td><code id="plrm.gof_+3A_estimator">estimator</code></td>
<td>
<p>allows us the choice between &ldquo;NW&rdquo; (Nadaraya-Watson) or &ldquo;LLP&rdquo; (Local Linear Polynomial). The default is &ldquo;NW&rdquo;.</p>
</td></tr>
<tr><td><code id="plrm.gof_+3A_kernel">kernel</code></td>
<td>
<p>allows us the choice between &ldquo;gaussian&rdquo;, &ldquo;quadratic&rdquo; (Epanechnikov kernel), &ldquo;triweight&rdquo; or &ldquo;uniform&rdquo; kernel. The default is &ldquo;quadratic&rdquo;.</p>
</td></tr>
<tr><td><code id="plrm.gof_+3A_time.series">time.series</code></td>
<td>
<p>it denotes whether the data are independent (FALSE) or if data is a time series (TRUE). The default is FALSE.</p>
</td></tr>
<tr><td><code id="plrm.gof_+3A_var.cov.eps">Var.Cov.eps</code></td>
<td>
 <p><code>n x n</code> matrix of variances-covariances associated to the random errors of the regression model. If NULL (the default), the function tries to estimate it: it fits an ARMA model (selected according to an information criterium) to the residuals from the fitted regression model and, then, it obtains the var-cov matrix of such ARMA model.</p>
</td></tr>
<tr><td><code id="plrm.gof_+3A_tau.eps">Tau.eps</code></td>
<td>
<p>it contains the sum of autocovariances associated to the random errors of the regression model. If NULL (the default), the function tries to estimate it: it fits an ARMA model (selected according to an information criterium) to the residuals from the fitted regression model and, then, it obtains the sum of the autocovariances of such ARMA model.</p>
</td></tr>
<tr><td><code id="plrm.gof_+3A_b0">b0</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code> and/or <code>Tau.eps=NULL</code>, <code>b0</code> contains the pilot bandwidth for the estimator of <code class="reqn">\beta</code> used for obtaining the residuals to construct the default for <code>Var.Cov.eps</code> and/or <code>Tau.eps</code>. If <code>NULL</code> (the default) but <code>h0</code> is not <code>NULL</code>, it takes <code>b0=h0</code>. If both <code>b0</code> and <code>h0</code> are <code>NULL</code>, a quarter of the range of <code class="reqn">{t_i}</code> is considered.</p>
</td></tr>
<tr><td><code id="plrm.gof_+3A_h0">h0</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code> and/or <code>Tau.eps=NULL</code>, (<code>b0, h0</code>) contains the pair of pilot bandwidths  for the estimator of <code class="reqn">m</code> used for obtaining the residuals to construct the default for <code>Var.Cov.eps</code> and/or <code>Tau.eps</code>. If <code>NULL</code> (the default) but <code>b0</code> is not <code>NULL</code>, it takes <code>h0=b0</code>. If both <code>b0</code> and <code>h0</code> are <code>NULL</code>, a quarter of the range of <code class="reqn">{t_i}</code> is considered for both <code>b0</code> and  <code>h0</code>.</p>
</td></tr>
<tr><td><code id="plrm.gof_+3A_lag.max">lag.max</code></td>
<td>
<p>if <code>Tau.eps=NULL</code>, <code>lag.max</code> contains the maximum delay used to construct the default for <code>Tau.eps</code>. The default is 50.</p>
</td></tr>
<tr><td><code id="plrm.gof_+3A_p.max">p.max</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code> and/or <code>Tau.eps=NULL</code>, the ARMA model is selected between the models ARMA(p,q) with 0&lt;=p&lt;=<code>p.max</code> and 0&lt;=q&lt;=<code>q.max</code>. The default is 3.</p>
</td></tr>
<tr><td><code id="plrm.gof_+3A_q.max">q.max</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code> and/or <code>Tau.eps=NULL</code>, the ARMA model is selected between the models ARMA(p,q) with 0&lt;=p&lt;=<code>p.max</code> and 0&lt;=q&lt;=<code>q.max</code>. The default is 3.</p>
</td></tr>
<tr><td><code id="plrm.gof_+3A_ic">ic</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code> and/or <code>Tau.eps=NULL</code>, <code>ic</code> contains the information criterion used to suggest the ARMA model. It allows us to choose between: &quot;AIC&quot;, &quot;AICC&quot; or &quot;BIC&quot; (the default).</p>
</td></tr>
<tr><td><code id="plrm.gof_+3A_num.lb">num.lb</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code> and/or <code>Tau.eps=NULL</code>, it checks the suitability of the selected ARMA model according to the Ljung-Box test and the t-test. It uses up to <code>num.lb</code> delays in the Ljung-Box test. The default is 10.</p>
</td></tr>
<tr><td><code id="plrm.gof_+3A_alpha">alpha</code></td>
<td>
<p>if <code>Var.Cov.eps=NULL</code> and/or <code>Tau.eps=NULL</code>, <code>alpha</code> contains the significance level which the ARMA model is checked. The default is 0.05.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A weight function (specifically, the indicator function <b>1</b><code class="reqn">_{[w[1] , w[2]]}</code>) is introduced in the test statistic for testing <code class="reqn">H0: m = m_0</code> to allow elimination (or at least significant reduction) of boundary effects from the estimate of <code class="reqn">m(t_i)</code>.
</p>
<p>If <code>Var.Cov.eps=NULL</code> and the routine is not able to suggest an approximation for <code>Var.Cov.eps</code>, it warns the user with a message saying that the model could be not appropriate and then it shows the results. In order to construct <code>Var.Cov.eps</code>, the procedure suggested in Aneiros-Perez and Vieu (2013) can be followed.
</p>
<p>If <code>Tau.eps=NULL</code> and the routine is not able to suggest an approximation for <code>Tau.eps</code>, it warns the user with a message saying that the model could be not appropriate and then it shows the results. In order to construct <code>Tau.eps</code>, the procedures suggested in Aneiros-Perez (2008) can be followed.
</p>
<p>The implemented procedures generalize those ones in expressions (9) and (10) in Gonzalez-Manteiga and Aneiros-Perez (2003) by allowing some dependence condition in <code class="reqn">{(X_{i1}, ..., X_{ip}): i=1,...,n}</code> and including a weight function (see above), respectively.
</p>


<h3>Value</h3>

<p>A list with two dataframes:
</p>
<table>
<tr><td><code>parametric.test</code></td>
<td>
<p>a dataframe containing the bandwidths, the statistics and the p-values when one tests <code class="reqn">H0: \beta = \beta_0</code></p>
</td></tr>
<tr><td><code>nonparametric.test</code></td>
<td>
<p>a dataframe containing the bandwidths b and h, the statistics, the normalised statistics and the p-values when one tests <code class="reqn">H0: m = m_0</code></p>
</td></tr>
</table>
<p>Moreover, if <code>data</code> is a time series and <code>Tau.eps</code> or <code>Var.Cov.eps</code> are not especified:
</p>
<table>
<tr><td><code>pv.Box.test</code></td>
<td>
<p>p-values of the Ljung-Box test for the model fitted to the residuals.</p>
</td></tr>
<tr><td><code>pv.t.test</code></td>
<td>
<p>p-values of the t.test for the model fitted to the residuals.</p>
</td></tr>
<tr><td><code>ar.ma</code></td>
<td>
<p>ARMA orders for the model fitted to the residuals.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>German Aneiros Perez <a href="mailto:ganeiros@udc.es">ganeiros@udc.es</a>
</p>
<p>Ana Lopez Cheda <a href="mailto:ana.lopez.cheda@udc.es">ana.lopez.cheda@udc.es</a></p>


<h3>References</h3>

<p>Aneiros-Perez, G. (2008) Semi-parametric analysis of covariance under dependence conditions within each group. <em>Aust. N. Z. J. Stat.</em> <b>50</b>, 97-123.
</p>
<p>Aneiros-Perez, G., Gonzalez-Manteiga, W. and Vieu, P. (2004) Estimation and testing in a partial linear regression under long-memory dependence. <em>Bernoulli</em> <b>10</b>, 49-78.
</p>
<p>Aneiros-Perez, G. and Vieu, P. (2013) Testing linearity in semi-parametric functional data analysis. <em>Comput. Stat.</em> <b>28</b>, 413-434. 
</p>
<p>Gao, J. (1997) Adaptive parametric test in a semiparametric regression model. <em>Comm. Statist. Theory Methods</em> <b>26</b>, 787-800.
</p>
<p>Gonzalez-Manteiga, W. and Aneiros-Perez, G. (2003) Testing in partial linear regression models with dependent errors. <em>J. Nonparametr. Statist.</em> <b>15</b>, 93-111.
</p>


<h3>See Also</h3>

<p>Other related functions are <code><a href="#topic+plrm.est">plrm.est</a></code>, <code><a href="#topic+par.gof">par.gof</a></code> and <code><a href="#topic+np.gof">np.gof</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># EXAMPLE 1: REAL DATA
data(barnacles1)
data &lt;- as.matrix(barnacles1)
data &lt;- diff(data, 12)
data &lt;- cbind(data,1:nrow(data))

plrm.gof(data)
plrm.gof(data, beta0=c(-0.1, 0.35))



# EXAMPLE 2: SIMULATED DATA
## Example 2a: dependent data

set.seed(1234)
# We generate the data
n &lt;- 100
t &lt;- ((1:n)-0.5)/n
beta &lt;- c(0.05, 0.01)
m &lt;- function(t) {0.25*t*(1-t)}
f &lt;- m(t)
f.function &lt;- function(u) {0.25*u*(1-u)}

x &lt;- matrix(rnorm(200,0,1), nrow=n)
sum &lt;- x%*%beta
epsilon &lt;- arima.sim(list(order = c(1,0,0), ar=0.7), sd = 0.01, n = n)
y &lt;-  sum + f + epsilon
data &lt;- cbind(y,x,t)

## Example 2a.1: true null hypotheses
plrm.gof(data, beta0=c(0.05, 0.01), m0=f.function, time.series=TRUE)

## Example 2a.2: false null hypotheses
plrm.gof(data, time.series=TRUE)

</code></pre>

<hr>
<h2 id='quadratic'>The quadratic kernel
</h2><span id='topic+quadratic'></span>

<h3>Description</h3>

<p>The quadratic kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadratic(u)
</code></pre>

<hr>
<h2 id='symsolve'>Solution of a system of linear equations
</h2><span id='topic+symsolve'></span>

<h3>Description</h3>

<p>Solves the system ASYM X = BMAT for X, where ASYM is a symmetric matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symsolve(Asym, Bmat)
</code></pre>

<hr>
<h2 id='triweight'>The triweight kernel
</h2><span id='topic+triweight'></span>

<h3>Description</h3>

<p>The triweight kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triweight(u)
</code></pre>

<hr>
<h2 id='uniform'>The uniform kernel
</h2><span id='topic+uniform'></span>

<h3>Description</h3>

<p>The uniform kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniform(u)
</code></pre>

<hr>
<h2 id='var.cov.matrix'>Estimated variance-covariance matrix from time series
</h2><span id='topic+var.cov.matrix'></span>

<h3>Description</h3>

<p>Selects an optimal ARMA model (according to an information criteria) for the time series in the data vector, <code>x</code>; then, fits such model and analyses the corresponding residuals. If the ARMA model is suitable, returns the <code>n x n</code> variance-covariance matrix corresponding to <code>n</code> consecutive variables in the ARMA process. If the ARMA model is not suitable, it informs the user with a message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.cov.matrix(x = 1:100, n = 4, p.max = 3, q.max = 3, ic = "BIC",  p.arima=NULL, 
q.arima=NULL, alpha = 0.05, num.lb = 10)
</code></pre>

<hr>
<h2 id='var.cov.sum'>Estimated sum of autocovariances from time series
</h2><span id='topic+var.cov.sum'></span>

<h3>Description</h3>

<p>For each time series in the columns of the data matrix, <code>X</code>, selects an optimal ARMA model (according to an information criteria); then, fits such model and analyses the corresponding residuals. If all the ARMA models are suitable, returns a vector containing the corresponding sums the autocovariances. If some ARMA model is not suitable, it informs the user with a message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.cov.sum(X = 1:100, lag.max = 50, p.max = 3, q.max = 3, ic = "BIC", 
alpha = 0.05, num.lb = 10)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
