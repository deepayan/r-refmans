<!DOCTYPE html><html><head><title>Help for package smmR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {smmR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#smmR-package'><p>smmR : Semi-Markov Models, Markov Models and Reliability</p></a></li>
<li><a href='#aic'><p>Akaike Information Criterion (AIC)</p></a></li>
<li><a href='#availability'><p>Availability Function</p></a></li>
<li><a href='#bic'><p>Bayesian Information Criterion (BIC)</p></a></li>
<li><a href='#failureRate'><p>Failure Rate Function</p></a></li>
<li><a href='#fitmm'><p>Maximum Likelihood Estimation (MLE) of a k-th order Markov chain</p></a></li>
<li><a href='#fitsmm'><p>Maximum Likelihood Estimation (MLE) of a semi-Markov chain</p></a></li>
<li><a href='#getKernel'><p>Method to get the semi-Markov kernel <code class="reqn">q</code></p></a></li>
<li><a href='#is.mm'><p>Function to check if an object is of class <code>mm</code></p></a></li>
<li><a href='#is.mmfit'><p>Function to check if an object is of class <code>mmfit</code></p></a></li>
<li><a href='#is.smm'><p>Function to check if an object is of class <code>smm</code></p></a></li>
<li><a href='#is.smmfit'><p>Function to check if an object is of class <code>smmfit</code></p></a></li>
<li><a href='#is.smmnonparametric'><p>Function to check if an object is of class <code>smmnonparametric</code></p></a></li>
<li><a href='#is.smmparametric'><p>Function to check if an object is of class <code>smmparametric</code></p></a></li>
<li><a href='#loglik'><p>Log-likelihood Function</p></a></li>
<li><a href='#maintainability'><p>Maintainability Function</p></a></li>
<li><a href='#meanRecurrenceTimes'><p>Method to get the mean recurrence times <code class="reqn">\mu</code></p></a></li>
<li><a href='#meanSojournTimes'><p>Mean Sojourn Times Function</p></a></li>
<li><a href='#mm'><p>Markov model specification</p></a></li>
<li><a href='#mttf'><p>Mean Time To Failure (MTTF) Function</p></a></li>
<li><a href='#mttr'><p>Mean Time To Repair (MTTR) Function</p></a></li>
<li><a href='#plot.smm'><p>Plot function for an object of class smm</p></a></li>
<li><a href='#plot.smmfit'><p>Plot function for an object of class smmfit</p></a></li>
<li><a href='#reliability'><p>Reliability Function</p></a></li>
<li><a href='#setSeed'><p>Set the RNG Seed from within Rcpp</p></a></li>
<li><a href='#simulate.mm'><p>Simulates k-th order Markov chains</p></a></li>
<li><a href='#simulate.mmfit'><p>Simulates Markov chains</p></a></li>
<li><a href='#simulate.smm'><p>Simulates semi-Markov chains</p></a></li>
<li><a href='#simulate.smmfit'><p>Simulates semi-Markov chains</p></a></li>
<li><a href='#smmnonparametric'><p>Non-parametric semi-Markov model specification</p></a></li>
<li><a href='#smmparametric'><p>Parametric semi-Markov model specification</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulation, Estimation and Reliability of Semi-Markov Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-07-30</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs parametric and non-parametric estimation and simulation 
    for multi-state discrete-time semi-Markov processes. For the parametric 
    estimation, several discrete distributions are considered for the sojourn 
    times: Uniform, Geometric, Poisson, Discrete Weibull and Negative Binomial.
    The non-parametric estimation concerns the sojourn time distributions, 
    where no assumptions are done on the shape of distributions. Moreover, the 
    estimation can be done on the basis of one or several sample paths, with or
    without censoring at the beginning or/and at the end of the sample paths. 
    Reliability indicators such as reliability, maintainability, availability, 
    BMP-failure rate, RG-failure rate, mean time to failure and mean time to 
    repair are available as well. The implemented methods are described in 
    Barbu, V.S., Limnios, N. (2008) &lt;<a href="https://doi.org/10.1007%2F978-0-387-73173-5">doi:10.1007/978-0-387-73173-5</a>&gt;, 
    Barbu, V.S., Limnios, N. (2008) &lt;<a href="https://doi.org/10.1080%2F10485250701261913">doi:10.1080/10485250701261913</a>&gt; and 
    Trevezas, S., Limnios, N. (2011) &lt;<a href="https://doi.org/10.1080%2F10485252.2011.555543">doi:10.1080/10485252.2011.555543</a>&gt;.
    Estimation and simulation of discrete-time k-th order Markov chains are 
    also considered.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Imports:</td>
<td>DiscreteWeibull, Rcpp, seqinr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>utils, knitr, rmarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-07-30 17:26:35 UTC; florianlecocq</td>
</tr>
<tr>
<td>Author:</td>
<td>Vlad Stefan Barbu <a href="https://orcid.org/0000-0002-0840-016X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Caroline Berard [aut],
  Dominique Cellier [aut],
  Florian Lecocq [aut],
  Corentin Lothode [aut],
  Mathilde Sautreuil [aut],
  Nicolas Vergne [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nicolas Vergne &lt;nicolas.vergne@univ-rouen.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-08-03 12:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='smmR-package'>smmR : Semi-Markov Models, Markov Models and Reliability</h2><span id='topic+smmR'></span><span id='topic+smmR-package'></span>

<h3>Description</h3>

<p>This package performs parametric and non-parametric estimation
and simulation for multi-state discrete-time semi-Markov processes. For the
parametric estimation, several discrete distributions are considered for the
sojourn times: Uniform, Geometric, Poisson, Discrete Weibull and Negative
Binomial. The non-parametric estimation concerns the sojourn time
distributions, where no assumptions are done on the shape of distributions.
Moreover, the estimation can be done on the basis of one or several sample
paths, with or without censoring at the beginning or/and at the end of the
sample paths. Estimation and simulation of discrete-time k-th order Markov
chains are also considered.
</p>
<p>Semi-Markov models are specified by using the functions <code>smmparametric()</code>
and <code>smmnonparametric()</code> for parametric and non-parametric specifications
respectively. These functions return objects of S3 class (<code>smm</code>,
<code>smmparametric</code>) and (<code>smm</code>, <code>smmnonparametric</code>) respectively (<code>smm</code> class
inherits from S3 classes <code>smmparametric</code> or <code>smmnonparametric</code>). Thus, <code>smm</code>
is like a wrapper class for semi-Markov model specifications.
</p>
<p>Based on a model specification (an object of class <code>smm</code>), it is possible to:
</p>

<ul>
<li> <p><strong>simulate</strong> one or several sequences with the method
<code>simulate.smm()</code>;
</p>
</li>
<li> <p><strong>plot</strong> conditional sojourn time distributions (method
<code>plot.smm()</code>);
</p>
</li>
<li><p> compute <strong>log-likelihood</strong>, <strong>AIC</strong> and <strong>BIC</strong> criteria (methods
<code>loglik()</code>, <code>aic()</code>, <code>bic()</code>);
</p>
</li>
<li><p> compute <strong>reliability</strong>, <strong>maintainability</strong>, <strong>availability</strong>,
<strong>failure rates</strong> (methods <code>reliability()</code>, <code>maintainability()</code>,
<code>availability()</code>, <code>failureRate()</code>).
</p>
</li></ul>

<p>Estimations of parametric and non-parametric semi-Markov models can be done
by using the function <code>fitsmm()</code>. This function returns an
object of S3 class <code>smmfit</code>. The class <code>smmfit</code> inherits from classes
(<code>smm</code>, <code>smmparametric</code>) or (<code>smm</code>, <code>smmnonparametric</code>).
</p>
<p>Based on a fitted/estimated semi-Markov model (an object of class <code>smmfit</code>),
it is possible to:
</p>

<ul>
<li> <p><strong>simulate</strong> one or several sequences with the method
<code>simulate.smmfit()</code>;
</p>
</li>
<li> <p><strong>plot</strong> estimated conditional sojourn time distributions
(method <code>plot.smmfit()</code>);
</p>
</li>
<li><p> compute <strong>log-likelihood</strong>, <strong>AIC</strong> and <strong>BIC</strong> criteria (methods
<code>loglik()</code>, <code>aic()</code>, <code>bic()</code>);
</p>
</li>
<li><p> compute estimated <strong>reliability</strong>, <strong>maintainability</strong>,
<strong>availability</strong>, <strong>failure rates</strong> and their <strong>confidence intervals</strong>
(methods <code>reliability()</code>, <code>maintainability()</code>, <code>availability()</code>,
<code>failureRate()</code>).
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Nicolas Vergne <a href="mailto:nicolas.vergne@univ-rouen.fr">nicolas.vergne@univ-rouen.fr</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Vlad Stefan Barbu (<a href="https://orcid.org/0000-0002-0840-016X">ORCID</a>)
</p>
</li>
<li><p> Caroline Berard
</p>
</li>
<li><p> Dominique Cellier
</p>
</li>
<li><p> Florian Lecocq
</p>
</li>
<li><p> Corentin Lothode
</p>
</li>
<li><p> Mathilde Sautreuil
</p>
</li></ul>



<h3>References</h3>

<p>V. S. Barbu, N. Limnios. (2008). Semi-Markov Chains and Hidden Semi-Markov
Models Toward Applications - Their Use in Reliability and DNA Analysis.
New York: Lecture Notes in Statistics, vol. 191, Springer.
</p>
<p>R.E. Barlow, A.W. Marshall, and F. Prochan. (1963). Properties of probability
distributions with monotone hazard rate. Ann. Math. Statist., 34, 375-389.
</p>
<p>T. Nakagawa and S. Osaki. (1975). The discrete Weibull distribution.
IEEE Trans. Reliabil., R-24, 300-301.
</p>
<p>D. Roy and R. Gupta. (1992). Classification of discrete lives.
Microelectron. Reliabil., 32 (10), 1459-1473.
</p>
<p>I. Votsi &amp; A. Brouste (2019) Confidence interval for the mean time to
failure in semi-Markov models: an application to wind energy production,
Journal of Applied Statistics, 46:10, 1756-1773.
</p>

<hr>
<h2 id='aic'>Akaike Information Criterion (AIC)</h2><span id='topic+aic'></span>

<h3>Description</h3>

<p>Generic function computing the Akaike Information Criterion of
the model <code>x</code>, with the list of sequences <code>sequences</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aic(x, sequences = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aic_+3A_x">x</code></td>
<td>
<p>An object for which there exists a <code>loglik</code> attribute if
<code>sequences = NULL</code> or a <code>loglik</code> method otherwise.</p>
</td></tr>
<tr><td><code id="aic_+3A_sequences">sequences</code></td>
<td>
<p>Optional. A list of vectors representing the sequences for
which the AIC will be computed based on <code>x</code> using the method <code>loglik</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of the AIC.
</p>

<hr>
<h2 id='availability'>Availability Function</h2><span id='topic+availability'></span>

<h3>Description</h3>

<p>The pointwise (or instantaneous) availability of a system
<code class="reqn">S_{ystem}</code> at time <code class="reqn">k \in N</code> is the probability that the system
is operational at time <code class="reqn">k</code> (independently of the fact that the system
has failed or not in <code class="reqn">[0, k)</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>availability(x, k, upstates = x$states, level = 0.95, klim = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="availability_+3A_x">x</code></td>
<td>
<p>An object of S3 class <code>smmfit</code> or <code>smm</code>.</p>
</td></tr>
<tr><td><code id="availability_+3A_k">k</code></td>
<td>
<p>A positive integer giving the time at which the availability
should be computed.</p>
</td></tr>
<tr><td><code id="availability_+3A_upstates">upstates</code></td>
<td>
<p>Vector giving the subset of operational states <code class="reqn">U</code>.</p>
</td></tr>
<tr><td><code id="availability_+3A_level">level</code></td>
<td>
<p>Confidence level of the asymptotic confidence interval. Helpful
for an object <code>x</code> of class <code>smmfit</code>.</p>
</td></tr>
<tr><td><code id="availability_+3A_klim">klim</code></td>
<td>
<p>Optional. The time horizon used to approximate the series in the
computation of the mean sojourn times vector <code class="reqn">m</code> (cf.
<a href="#topic+meanSojournTimes">meanSojournTimes</a> function) for the asymptotic variance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider a system (or a component) <code class="reqn">S_{ystem}</code> whose possible
states during its evolution in time are <code class="reqn">E = \{1,\dots,s\}</code>.
Denote by <code class="reqn">U = \{1,\dots,s_1\}</code> the subset of operational states of
the system (the up states) and by <code class="reqn">D = \{s_1 + 1,\dots,s\}</code> the
subset of failure states (the down states), with <code class="reqn">0 &lt; s_1 &lt; s</code>
(obviously, <code class="reqn">E = U \cup D</code> and <code class="reqn">U \cap D = \emptyset</code>,
<code class="reqn">U \neq \emptyset,\ D \neq \emptyset</code>). One can think of the states
of <code class="reqn">U</code> as different operating modes or performance levels of the
system, whereas the states of <code class="reqn">D</code> can be seen as failures of the
systems with different modes.
</p>
<p>We are interested in investigating the availability of a discrete-time
semi-Markov system <code class="reqn">S_{ystem}</code>. Consequently, we suppose that the
evolution in time of the system is governed by an E-state space
semi-Markov chain <code class="reqn">(Z_k)_{k \in N}</code>. The state of the system is given
at each instant <code class="reqn">k \in N</code> by <code class="reqn">Z_k</code>: the event <code class="reqn">\{Z_k = i\}</code>,
for a certain <code class="reqn">i \in U</code>, means that the system <code class="reqn">S_{ystem}</code> is in
operating mode <code class="reqn">i</code> at time <code class="reqn">k</code>, whereas <code class="reqn">\{Z_k = j\}</code>, for a
certain <code class="reqn">j \in D</code>, means that the system is not operational at time
<code class="reqn">k</code> due to the mode of failure <code class="reqn">j</code> or that the system is under the
repairing mode <code class="reqn">j</code>.
</p>
<p>The pointwise (or instantaneous) availability of a system <code class="reqn">S_{ystem}</code>
at time <code class="reqn">k \in N</code> is the probability that the system is operational
at time <code class="reqn">k</code> (independently of the fact that the system has failed or
not in <code class="reqn">[0, k)</code>).
</p>
<p>Thus, the pointwise availability of a semi-Markov system at time
<code class="reqn">k \in N</code> is
</p>
<p style="text-align: center;"><code class="reqn">A(k) = P(Z_k \in U) = \sum_{i \in E} \alpha_i A_i(k),</code>
</p>

<p>where we have denoted by <code class="reqn">A_i(k)</code> the conditional availability of the
system at time <code class="reqn">k \in N</code>, given that it starts in state <code class="reqn">i \in E</code>,
</p>
<p style="text-align: center;"><code class="reqn">A_i(k) = P(Z_k \in U | Z_0 = i).</code>
</p>



<h3>Value</h3>

<p>A matrix with <code class="reqn">k + 1</code> rows, and with columns giving values of
the availability, variances, lower and upper asymptotic confidence limits
(if <code>x</code> is an object of class <code>smmfit</code>).
</p>


<h3>References</h3>

<p>V. S. Barbu, N. Limnios. (2008). Semi-Markov Chains and Hidden Semi-Markov
Models Toward Applications - Their Use in Reliability and DNA Analysis.
New York: Lecture Notes in Statistics, vol. 191, Springer.
</p>

<hr>
<h2 id='bic'>Bayesian Information Criterion (BIC)</h2><span id='topic+bic'></span>

<h3>Description</h3>

<p>Generic function computing the Bayesian Information Criterion
of the model <code>x</code>, with the list of sequences <code>sequences</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bic(x, sequences = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bic_+3A_x">x</code></td>
<td>
<p>An object for which there exists a <code>loglik</code> attribute if
<code>sequences = NULL</code> or a <code>loglik</code> method otherwise.</p>
</td></tr>
<tr><td><code id="bic_+3A_sequences">sequences</code></td>
<td>
<p>Optional. A list of vectors representing the sequences for
which the AIC will be computed based on <code>x</code> using the method <code>loglik</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of the BIC.
</p>

<hr>
<h2 id='failureRate'>Failure Rate Function</h2><span id='topic+failureRate'></span>

<h3>Description</h3>

<p>Function to compute the BMP-failure rate or the RG-failure rate.
</p>
<p>Consider a system <code class="reqn">S_{ystem}</code> starting to work at time
<code class="reqn">k = 0</code>. The BMP-failure rate at time <code class="reqn">k \in N</code> is the conditional
probability that the failure of the system occurs at time <code class="reqn">k</code>, given
that the system has worked until time <code class="reqn">k - 1</code>.
</p>
<p>The RG-failure rate is a discrete-time adapted failure rate, proposed by
D. Roy and R. Gupta. Classification of discrete lives. Microelectronics
Reliability, 32(10):1459&ndash;1473, 1992. We call it the RG-failure rate and
denote it by <code class="reqn">r(k),\ k \in N</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>failureRate(
  x,
  k,
  upstates = x$states,
  failure.rate = c("BMP", "RG"),
  level = 0.95,
  epsilon = 0.001,
  klim = 10000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="failureRate_+3A_x">x</code></td>
<td>
<p>An object of S3 class <code>smmfit</code> or <code>smm</code>.</p>
</td></tr>
<tr><td><code id="failureRate_+3A_k">k</code></td>
<td>
<p>A positive integer giving the period <code class="reqn">[0, k]</code> on which the
BMP-failure rate should be computed.</p>
</td></tr>
<tr><td><code id="failureRate_+3A_upstates">upstates</code></td>
<td>
<p>Vector giving the subset of operational states <code class="reqn">U</code>.</p>
</td></tr>
<tr><td><code id="failureRate_+3A_failure.rate">failure.rate</code></td>
<td>
<p>Type of failure rate to compute. If <code>failure.rate = "BMP"</code>
(default value), then BMP-failure-rate is computed. If <code>failure.rate = "RG"</code>,
the RG-failure rate is computed.</p>
</td></tr>
<tr><td><code id="failureRate_+3A_level">level</code></td>
<td>
<p>Confidence level of the asymptotic confidence interval. Helpful
for an object <code>x</code> of class <code>smmfit</code>.</p>
</td></tr>
<tr><td><code id="failureRate_+3A_epsilon">epsilon</code></td>
<td>
<p>Value of the reliability above which the latter is supposed
to be 0 because of computation errors (see Details).</p>
</td></tr>
<tr><td><code id="failureRate_+3A_klim">klim</code></td>
<td>
<p>Optional. The time horizon used to approximate the series in the
computation of the mean sojourn times vector <code class="reqn">m</code> (cf.
<a href="#topic+meanSojournTimes">meanSojournTimes</a> function) for the asymptotic variance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider a system (or a component) <code class="reqn">S_{ystem}</code> whose possible
states during its evolution in time are <code class="reqn">E = \{1,\dots,s\}</code>.
Denote by <code class="reqn">U = \{1,\dots,s_1\}</code> the subset of operational states of
the system (the up states) and by <code class="reqn">D = \{s_1 + 1,\dots,s\}</code> the
subset of failure states (the down states), with <code class="reqn">0 &lt; s_1 &lt; s</code>
(obviously, <code class="reqn">E = U \cup D</code> and <code class="reqn">U \cap D = \emptyset</code>,
<code class="reqn">U \neq \emptyset,\ D \neq \emptyset</code>). One can think of the states
of <code class="reqn">U</code> as different operating modes or performance levels of the
system, whereas the states of <code class="reqn">D</code> can be seen as failures of the
systems with different modes.
</p>
<p>We are interested in investigating the failure rate of a discrete-time
semi-Markov system <code class="reqn">S_{ystem}</code>. Consequently, we suppose that the
evolution in time of the system is governed by an E-state space
semi-Markov chain <code class="reqn">(Z_k)_{k \in N}</code>. The system starts to work at
instant <code class="reqn">0</code> and the state of the system is given at each instant
<code class="reqn">k \in N</code> by <code class="reqn">Z_k</code>: the event <code class="reqn">\{Z_k = i\}</code>, for a certain
<code class="reqn">i \in U</code>, means that the system <code class="reqn">S_{ystem}</code> is in operating mode
<code class="reqn">i</code> at time <code class="reqn">k</code>, whereas <code class="reqn">\{Z_k = j\}</code>, for a certain
<code class="reqn">j \in D</code>, means that the system is not operational at time <code class="reqn">k</code>
due to the mode of failure <code class="reqn">j</code> or that the system is under the
repairing mode <code class="reqn">j</code>.
</p>
<p>The BMP-failure rate at time <code class="reqn">k \in N</code> is the conditional probability
that the failure of the system occurs at time <code class="reqn">k</code>, given that the
system has worked until time <code class="reqn">k - 1</code>.
</p>
<p>Let <code class="reqn">T_D</code> denote the first passage time in subset <code class="reqn">D</code>, called
the lifetime of the system, i.e.,
</p>
<p style="text-align: center;"><code class="reqn">T_D := \textrm{inf}\{ n \in N;\ Z_n \in D\}\ \textrm{and}\ \textrm{inf}\ \emptyset := \infty.</code>
</p>

<p>For a discrete-time semi-Markov system, the failure rate at time
<code class="reqn">k \geq 1</code> has the expression:
</p>
<p style="text-align: center;"><code class="reqn">\lambda(k) := P(T_{D} = k | T_{D} \geq k)</code>
</p>

<p>We can rewrite it as follows :
</p>
<p style="text-align: center;"><code class="reqn">\lambda(k) = 1 - \frac{R(k)}{R(k - 1)},\ \textrm{if } R(k - 1) \neq 0;\ \lambda(k) = 0, \textrm{otherwise}</code>
</p>

<p>The failure rate at time <code class="reqn">k = 0</code> is defined by <code class="reqn">\lambda(0) := 1 - R(0)</code>,
with <code class="reqn">R</code> being the reliability function (see <a href="#topic+reliability">reliability</a> function).
</p>
<p>The calculation of the reliability <code class="reqn">R</code> involves the computation of
many convolutions. It implies that the computation error, may be higher
(in value) than the &quot;true&quot; reliability itself for reliability close to 0.
In order to avoid inconsistent values of the BMP-failure rate, we use the
following formula:
</p>
<p style="text-align: center;"><code class="reqn">\lambda(k) = 1 - \frac{R(k)}{R(k - 1)},\ \textrm{if } R(k - 1) \geq \epsilon;\ \lambda(k) = 0, \textrm{otherwise}</code>
</p>

<p>with <code class="reqn">\epsilon</code>, the threshold, the parameter <code>epsilon</code> in the
function <code>failureRate</code>.
</p>
<p>Expressing the RG-failure rate <code class="reqn">r(k)</code> in terms of the reliability
<code class="reqn">R</code> we obtain that the RG-failure rate function for a discrete-time
system is given by:
</p>
<p style="text-align: center;"><code class="reqn">r(k) = - \ln \frac{R(k)}{R(k - 1)},\ \textrm{if } k \geq 1;\ r(k) = - \ln R(0),\ \textrm{if } k = 0</code>
</p>

<p>for <code class="reqn">R(k) \neq 0</code>. If <code class="reqn">R(k) = 0</code>, we set <code class="reqn">r(k) := 0</code>.
</p>
<p>Note that the RG-failure rate is related to the BMP-failure rate by:
</p>
<p style="text-align: center;"><code class="reqn">r(k) = - \ln (1 - \lambda(k)),\ k \in N</code>
</p>



<h3>Value</h3>

<p>A matrix with <code class="reqn">k + 1</code> rows, and with columns giving values of
the BMP-failure rate or RG-failure rate, variances, lower and upper
asymptotic confidence limits (if <code>x</code> is an object of class <code>smmfit</code>).
</p>


<h3>References</h3>

<p>V. S. Barbu, N. Limnios. (2008). Semi-Markov Chains and Hidden Semi-Markov
Models Toward Applications - Their Use in Reliability and DNA Analysis.
New York: Lecture Notes in Statistics, vol. 191, Springer.
</p>
<p>R.E. Barlow, A.W. Marshall, and F. Prochan. (1963). Properties of probability
distributions with monotone hazard rate. Ann. Math. Statist., 34, 375-389.
</p>
<p>D. Roy and R. Gupta. (1992). Classification of discrete lives.
Microelectron. Reliabil., 32 (10), 1459-1473.
</p>

<hr>
<h2 id='fitmm'>Maximum Likelihood Estimation (MLE) of a k-th order Markov chain</h2><span id='topic+fitmm'></span>

<h3>Description</h3>

<p>Maximum Likelihood Estimation of the transition matrix and
initial distribution of a k-th order Markov chain starting from one or
several sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitmm(sequences, states, k = 1, init.estim = "mle")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitmm_+3A_sequences">sequences</code></td>
<td>
<p>A list of vectors representing the sequences.</p>
</td></tr>
<tr><td><code id="fitmm_+3A_states">states</code></td>
<td>
<p>Vector of state space (of length s).</p>
</td></tr>
<tr><td><code id="fitmm_+3A_k">k</code></td>
<td>
<p>Order of the Markov chain.</p>
</td></tr>
<tr><td><code id="fitmm_+3A_init.estim">init.estim</code></td>
<td>
<p>Optional. <code>init.estim</code> gives the method used to estimate
the initial distribution. The following methods are proposed:
</p>

<ul>
<li> <p><code>init.estim = "mle"</code>: the classical Maximum Likelihood Estimator
is used to estimate the initial distribution <code>init</code>;
</p>
</li>
<li> <p><code>init.estim = "stationary"</code>: the initial distribution is replaced by
the stationary distribution of the Markov chain (if the order of the
Markov chain is more than one, the transition matrix is converted
into a square block matrix in order to estimate the stationary
distribution);
</p>
</li>
<li> <p><code>init.estim = "freq"</code>: the initial distribution is estimated by
taking the frequencies of the words of length <code>k</code> for all sequences;
</p>
</li>
<li> <p><code>init.estim = "prod"</code>: <code>init</code> is estimated by using the product
of the frequencies of each letter (for all the sequences) in the word
of length <code>k</code>;
</p>
</li>
<li> <p><code>init.estim = "unif"</code>: the initial probability of each state is
equal to <code class="reqn">1 / s</code>, with <code class="reqn">s</code> the number of states.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">X_1, X_2, ..., X_n</code> be a trajectory of length <code class="reqn">n</code> of
the Markov chain <code class="reqn">X = (X_m)_{m \in N}</code> of order <code class="reqn">k = 1</code> with
transition matrix <code class="reqn">p_{trans}(i,j) = P(X_{m+1} = j | X_m = i)</code>. The
maximum likelihood estimation of the transition matrix is
<code class="reqn">\widehat{p_{trans}}(i,j) = \frac{N_{ij}}{N_{i.}}</code>, where <code class="reqn">N_{ij}</code>
is the number of transitions from state <code class="reqn">i</code> to state <code class="reqn">j</code> and
<code class="reqn">N_{i.}</code> is the number of transition from state <code class="reqn">i</code> to any state.
For <code class="reqn">k &gt; 1</code> we have similar expressions.
</p>
<p>The initial distribution of a k-th order Markov chain is defined as
<code class="reqn">\mu_i = P(X_1 = i)</code>. Five methods are proposed for the estimation
of the latter :
</p>

<dl>
<dt>Maximum Likelihood Estimator: </dt><dd><p>The Maximum Likelihood Estimator
for the initial distribution. The formula is:
<code class="reqn">\widehat{\mu_i} = \frac{Nstart_i}{L}</code>, where <code class="reqn">Nstart_i</code> is
the number of occurences of the word <code class="reqn">i</code> (of length <code class="reqn">k</code>) at
the beginning of each sequence and <code class="reqn">L</code> is the number of sequences.
This estimator is reliable when the number of sequences <code class="reqn">L</code> is high.</p>
</dd>
<dt>Stationary distribution: </dt><dd><p>The stationary distribution is used as
a surrogate of the initial distribution. If the order of the Markov
chain is more than one, the transition matrix is converted into a
square block matrix in order to estimate the stationary distribution.
This method may take time if the order of the Markov chain is high
(more than three (3)).</p>
</dd>
<dt>Frequencies of each word: </dt><dd><p>The initial distribution is estimated
by taking the frequencies of the words of length <code>k</code> for all sequences.
The formula is <code class="reqn">\widehat{\mu_i} = \frac{N_i}{N}</code>, where <code class="reqn">N_i</code>
is the number of occurences of the word <code class="reqn">i</code> (of length <code class="reqn">k</code>) in
the sequences and <code class="reqn">N</code> is the sum of the lengths of the sequences.</p>
</dd>
<dt>Product of the frequencies of each state: </dt><dd><p>The initial distribution
is estimated by using the product of the frequencies of each state
(for all the sequences) in the word of length <code class="reqn">k</code>.</p>
</dd>
<dt>Uniform distribution: </dt><dd><p>The initial probability of each state is
equal to <code class="reqn">1 / s</code>, with <code class="reqn">s</code>, the number of states.</p>
</dd>
</dl>



<h3>Value</h3>

<p>An object of class S3 <code>mmfit</code> (inheriting from the S3 class <a href="#topic+mm">mm</a>).
The S3 class <code>mmfit</code> contains:
</p>

<ul>
<li><p> All the attributes of the S3 class <a href="#topic+mm">mm</a>;
</p>
</li>
<li><p> An attribute <code>M</code> which is an integer giving the total length of
the set of sequences <code>sequences</code> (sum of all the lengths of the list
<code>sequences</code>);
</p>
</li>
<li><p> An attribute <code>loglik</code> which is a numeric value giving the value
of the log-likelihood of the specified Markov model based on the
<code>sequences</code>;
</p>
</li>
<li><p> An attribute <code>sequences</code> which is equal to the parameter
<code>sequences</code> of the function <code>fitmm</code> (i.e. a list of sequences used to
estimate the Markov model).
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+mm">mm</a>, <a href="#topic+simulate.mm">simulate.mm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>states &lt;- c("a", "c", "g", "t")
s &lt;- length(states)
k &lt;- 2
init &lt;- rep.int(1 / s ^ k, s ^ k)
p &lt;- matrix(0.25, nrow = s ^ k, ncol = s)

# Specify a Markov model of order 2
markov &lt;- mm(states = states, init = init, ptrans = p, k = k)

seqs &lt;- simulate(object = markov, nsim = c(1000, 10000, 2000), seed = 150)

est &lt;- fitmm(sequences = seqs, states = states, k = 2)

</code></pre>

<hr>
<h2 id='fitsmm'>Maximum Likelihood Estimation (MLE) of a semi-Markov chain</h2><span id='topic+fitsmm'></span>

<h3>Description</h3>

<p>Maximum Likelihood Estimation of a semi-Markov chain starting
from one or several sequences. This estimation can be parametric or
non-parametric, non-censored, censored at the beginning and/or at the end
of the sequence, with one or several trajectories. Several parametric
distributions are considered (Uniform, Geometric, Poisson, Discrete
Weibull and Negative Binomial).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitsmm(
  sequences,
  states,
  type.sojourn = c("fij", "fi", "fj", "f"),
  distr = "nonparametric",
  init.estim = "mle",
  cens.beg = FALSE,
  cens.end = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitsmm_+3A_sequences">sequences</code></td>
<td>
<p>A list of vectors representing the sequences.</p>
</td></tr>
<tr><td><code id="fitsmm_+3A_states">states</code></td>
<td>
<p>Vector of state space (of length s).</p>
</td></tr>
<tr><td><code id="fitsmm_+3A_type.sojourn">type.sojourn</code></td>
<td>
<p>Type of sojourn time (for more explanations, see Details).</p>
</td></tr>
<tr><td><code id="fitsmm_+3A_distr">distr</code></td>
<td>
<p>By default <code>"nonparametric"</code> for the non-parametric estimation
case.
</p>
<p>If the parametric estimation case is desired, <code>distr</code> should be:
</p>

<ul>
<li><p> A matrix of distributions of dimension <code class="reqn">(s, s)</code> if <code>type.sojourn = "fij"</code>;
</p>
</li>
<li><p> A vector of distributions of length <code class="reqn">s</code> if <code>type.sojourn = "fi"</code> or <code>"fj"</code>;
</p>
</li>
<li><p> A distribution if <code>type.sojourn = "f"</code>.
</p>
</li></ul>

<p>The distributions to be used in <code>distr</code> must be one of <code>"unif"</code>, <code>"geom"</code>,
<code>"pois"</code>, <code>"dweibull"</code>, <code>"nbinom"</code>.</p>
</td></tr>
<tr><td><code id="fitsmm_+3A_init.estim">init.estim</code></td>
<td>
<p>Optional. <code>init.estim</code> gives the method used to estimate
the initial distribution. The following methods are proposed:
</p>

<ul>
<li> <p><code>init.estim = "mle"</code>: the classical Maximum Likelihood Estimator
is used to estimate the initial distribution <code>init</code>;
</p>
</li>
<li> <p><code>init.estim = "limit"</code>: the initial distribution is replaced by
the limit (stationary) distribution of the semi-Markov chain;
</p>
</li>
<li> <p><code>init.estim = "freq"</code>: the initial distribution is replaced by
the frequencies of each state in the sequences;
</p>
</li>
<li> <p><code>init.estim = "unif"</code>: the initial probability of each state is
equal to <code class="reqn">1 / s</code>, with <code class="reqn">s</code> the number of states.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fitsmm_+3A_cens.beg">cens.beg</code></td>
<td>
<p>Optional. A logical value indicating whether or not
sequences are censored at the beginning.</p>
</td></tr>
<tr><td><code id="fitsmm_+3A_cens.end">cens.end</code></td>
<td>
<p>Optional. A logical value indicating whether or not
sequences are censored at the end.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates a semi-Markov model in parametric or
non-parametric case, taking into account the type of sojourn time and the
censoring described in references. The non-parametric estimation concerns
sojourn time distributions defined by the user. For the parametric
estimation, several discrete distributions are considered (see below).
</p>
<p>The difference between the Markov model and the semi-Markov model concerns
the modeling of the sojourn time. With a Markov chain, the sojourn time
distribution is modeled by a Geometric distribution (in discrete time).
With a semi-Markov chain, the sojourn time can be any arbitrary distribution.
In this package, the available distribution for a semi-Markov model are :
</p>

<ul>
<li><p> Uniform: <code class="reqn">f(x) = \frac{1}{n}</code> for <code class="reqn">1 \le x \le n</code>. <code class="reqn">n</code> is the parameter;
</p>
</li>
<li><p> Geometric: <code class="reqn">f(x) = \theta (1-\theta)^{x - 1}</code> for <code class="reqn">x = 1, 2,\ldots,n</code>, <code class="reqn">0 &lt; \theta &lt; 1</code>, <code class="reqn">\theta</code> is the probability of success.
<code class="reqn">\theta</code> is the parameter;
</p>
</li>
<li><p> Poisson: <code class="reqn">f(x) = \frac{\lambda^x exp(-\lambda)}{x!}</code> for <code class="reqn">x = 0, 1, 2,\ldots,n</code>, with <code class="reqn">\lambda &gt; 0</code>.
<code class="reqn">\lambda</code> is the parameter;
</p>
</li>
<li><p> Discrete Weibull of type 1: <code class="reqn">f(x)=q^{(x-1)^{\beta}}-q^{x^{\beta}}</code>, <code class="reqn">x = 1, 2,\ldots,n</code>,
with <code class="reqn">0 &lt; q &lt; 1</code>, the first parameter and <code class="reqn">\beta &gt; 0</code> the second parameter.
<code class="reqn">(q, \beta)</code> are the parameters;
</p>
</li>
<li><p> Negative binomial: <code class="reqn">f(x)=\frac{\Gamma(x+\alpha)}{\Gamma(\alpha) x!} p^{\alpha} (1 - p)^x</code>,
for <code class="reqn">x = 0, 1, 2,\ldots,n</code>, <code class="reqn">\Gamma</code> is the Gamma function,
<code class="reqn">\alpha</code> is the parameter of overdispersion and <code class="reqn">p</code> is the
probability of success, <code class="reqn">0 &lt; p &lt; 1</code>. <code class="reqn">(\alpha, p)</code> are the parameters;
</p>
</li>
<li><p> Non-parametric.
</p>
</li></ul>

<p>We define :
</p>

<ul>
<li><p> the semi-Markov kernel <code class="reqn">q_{ij}(k) = P( J_{m+1} = j, T_{m+1} - T_{m} = k | J_{m} = i )</code>;
</p>
</li>
<li><p> the transition matrix <code class="reqn">(p_{trans}(i,j))_{i,j} \in states</code> of the
embedded Markov chain <code class="reqn">J = (J_m)_m</code>, <code class="reqn">p_{trans}(i,j) = P( J_{m+1} = j | J_m = i )</code>;
</p>
</li>
<li><p> the initial distribution <code class="reqn">\mu_i = P(J_1 = i) = P(Z_1 = i)</code>, <code class="reqn">i \in 1, 2, \dots, s</code>;
</p>
</li>
<li><p> the conditional sojourn time distributions <code class="reqn">(f_{ij}(k))_{i,j} \in states,\ k \in N ,\ f_{ij}(k) = P(T_{m+1} - T_m = k | J_m = i, J_{m+1} = j )</code>,
<code class="reqn">f</code> is specified by the argument <code>param</code> in the parametric case
and by <code>distr</code> in the non-parametric case.
</p>
</li></ul>

<p>The maximum likelihood estimation of the transition matrix of the embedded
Markov chain is <code class="reqn">\widehat{p_{trans}}(i,j) = \frac{N_{ij}}{N_{i.}}</code>.
</p>
<p>Five methods are proposed for the estimation of the initial distribution :
</p>

<dl>
<dt>Maximum Likelihood Estimator: </dt><dd><p>The Maximum Likelihood Estimator
for the initial distribution. The formula is:
<code class="reqn">\widehat{\mu_i} = \frac{Nstart_i}{L}</code>, where <code class="reqn">Nstart_i</code> is
the number of occurences of the word <code class="reqn">i</code> (of length <code class="reqn">k</code>) at
the beginning of each sequence and <code class="reqn">L</code> is the number of sequences.
This estimator is reliable when the number of sequences <code class="reqn">L</code> is high.</p>
</dd>
<dt>Limit (stationary) distribution: </dt><dd><p>The limit (stationary)
distribution of the semi-Markov chain is used as a surrogate of the
initial distribution.</p>
</dd>
<dt>Frequencies of each state: </dt><dd><p>The initial distribution is replaced
by taking the frequencies of each state in the sequences.</p>
</dd>
<dt>Uniform distribution: </dt><dd><p>The initial probability of each state is
equal to <code class="reqn">1 / s</code>, with <code class="reqn">s</code>, the number of states.</p>
</dd>
</dl>

<p>Note that <code class="reqn">q_{ij}(k) = p_{trans}(i,j) \ f_{ij}(k)</code> in the general case
(depending on the present state and on the next state). For particular cases,
we replace <code class="reqn">f_{ij}(k)</code> by <code class="reqn">f_{i.}(k)</code> (depending on the present
state <code class="reqn">i</code>), <code class="reqn">f_{.j}(k)</code> (depending on the next state <code class="reqn">j</code>) and
<code class="reqn">f_{..}(k)</code> (depending neither on the present state nor on the next
state).
</p>
<p>In this package we can choose different types of sojourn time.
Four options are available for the sojourn times:
</p>

<ul>
<li><p> depending on the present state and on the next state (<code>fij</code>);
</p>
</li>
<li><p> depending only on the present state (<code>fi</code>);
</p>
</li>
<li><p> depending only on the next state (<code>fj</code>);
</p>
</li>
<li><p> depending neither on the current, nor on the next state (<code>f</code>).
</p>
</li></ul>

<p>If  <code>type.sojourn = "fij"</code>, <code>distr</code> is a matrix of dimension <code class="reqn">(s, s)</code>
(e.g., if the 1st element of the 2nd column is <code>"pois"</code>, that is to say we
go from the first state to the second state following a Poisson distribution).
If <code>type.sojourn = "fi"</code> or <code>"fj"</code>, <code>distr</code> must be a vector (e.g., if the
first element of vector is <code>"geom"</code>, that is to say we go from (or to) the
first state to (or from) any state according to a Geometric distribution).
If <code>type.sojourn = "f"</code>, <code>distr</code> must be one of <code>"unif"</code>, <code>"geom"</code>, <code>"pois"</code>,
<code>"dweibull"</code>, <code>"nbinom"</code> (e.g., if <code>distr</code> is equal to <code>"nbinom"</code>, that is
to say that the sojourn time when going from one state to another state
follows a Negative Binomial distribution).
For the non-parametric case, <code>distr</code> is equal to <code>"nonparametric"</code> whatever
type of sojourn time given.
</p>
<p>If the sequence is censored at the beginning and/or at the end, <code>cens.beg</code>
must be equal to <code>TRUE</code> and/or <code>cens.end</code> must be equal to <code>TRUE</code>.
All the sequences must be censored in the same way.
</p>


<h3>Value</h3>

<p>Returns an object of S3 class <code>smmfit</code> (inheriting from the S3
class <code>smm</code> and <a href="#topic+smmnonparametric">smmnonparametric</a> class if <code>distr = "nonparametric"</code>
or <a href="#topic+smmparametric">smmparametric</a> otherwise). The S3 class <code>smmfit</code> contains:
</p>

<ul>
<li><p> All the attributes of the S3 class <a href="#topic+smmnonparametric">smmnonparametric</a> or
<a href="#topic+smmparametric">smmparametric</a> depending on the type of estimation;
</p>
</li>
<li><p> An attribute <code>M</code> which is an integer giving the total length of
the set of sequences <code>sequences</code> (sum of all the lengths of the list
<code>sequences</code>);
</p>
</li>
<li><p> An attribute <code>loglik</code> which is a numeric value giving the value
of the log-likelihood of the specified semi-Markov model based on the
<code>sequences</code>;
</p>
</li>
<li><p> An attribute <code>sequences</code> which is equal to the parameter
<code>sequences</code> of the function <code>fitsmm</code> (i.e. a list of sequences used to
estimate the Markov model).
</p>
</li></ul>



<h3>References</h3>

<p>V. S. Barbu, N. Limnios. (2008). Semi-Markov Chains and Hidden Semi-Markov
Models Toward Applications - Their Use in Reliability and DNA Analysis.
New York: Lecture Notes in Statistics, vol. 191, Springer.
</p>


<h3>See Also</h3>

<p><a href="#topic+smmnonparametric">smmnonparametric</a>, <a href="#topic+smmparametric">smmparametric</a>, <a href="#topic+simulate.smm">simulate.smm</a>,
<a href="#topic+simulate.smmfit">simulate.smmfit</a>, <a href="#topic+plot.smm">plot.smm</a>, <a href="#topic+plot.smmfit">plot.smmfit</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>states &lt;- c("a", "c", "g", "t")
s &lt;- length(states)

# Creation of the initial distribution
vect.init &lt;- c(1 / 4, 1 / 4, 1 / 4, 1 / 4)

# Creation of the transition matrix
pij &lt;- matrix(c(0, 0.2, 0.5, 0.3, 
                0.2, 0, 0.3, 0.5, 
                0.3, 0.5, 0, 0.2, 
                0.4, 0.2, 0.4, 0), 
              ncol = s, byrow = TRUE)

# Creation of the distribution matrix

distr.matrix &lt;- matrix(c(NA, "pois", "geom", "nbinom", 
                         "geom", NA, "pois", "dweibull",
                         "pois", "pois", NA, "geom", 
                         "pois", "geom", "geom", NA), 
                       nrow = s, ncol = s, byrow = TRUE)

# Creation of an array containing the parameters
param1.matrix &lt;- matrix(c(NA, 2, 0.4, 4, 
                          0.7, NA, 5, 0.6, 
                          2, 3, NA, 0.6, 
                          4, 0.3, 0.4, NA), 
                        nrow = s, ncol = s, byrow = TRUE)

param2.matrix &lt;- matrix(c(NA, NA, NA, 0.6, 
                          NA, NA, NA, 0.8, 
                          NA, NA, NA, NA, 
                          NA, NA, NA, NA), 
                        nrow = s, ncol = s, byrow = TRUE)

param.array &lt;- array(c(param1.matrix, param2.matrix), c(s, s, 2))

# Specify the semi-Markov model
semimarkov &lt;- smmparametric(states = states, init = vect.init, ptrans = pij, 
                            type.sojourn = "fij", distr = distr.matrix, 
                            param = param.array)

seqs &lt;- simulate(object = semimarkov, nsim = c(1000, 10000, 2000), seed = 100)

# Estimation of simulated sequences
est &lt;- fitsmm(sequences = seqs, states = states, type.sojourn = "fij", 
              distr = distr.matrix)

</code></pre>

<hr>
<h2 id='getKernel'>Method to get the semi-Markov kernel <code class="reqn">q</code></h2><span id='topic+getKernel'></span>

<h3>Description</h3>

<p>Computes the semi-Markov kernel <code class="reqn">q_{ij}(k)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getKernel(x, k, var = FALSE, klim = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getKernel_+3A_x">x</code></td>
<td>
<p>An object of S3 class <code>smmfit</code> or <code>smm</code>.</p>
</td></tr>
<tr><td><code id="getKernel_+3A_k">k</code></td>
<td>
<p>A positive integer giving the time horizon.</p>
</td></tr>
<tr><td><code id="getKernel_+3A_var">var</code></td>
<td>
<p>Logical. If <code>TRUE</code> the asymptotic variance is computed.</p>
</td></tr>
<tr><td><code id="getKernel_+3A_klim">klim</code></td>
<td>
<p>Optional. The time horizon used to approximate the series in the
computation of the mean sojourn times vector <code class="reqn">m</code> (cf.
<a href="#topic+meanSojournTimes">meanSojournTimes</a> function) for the asymptotic variance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array giving the value of <code class="reqn">q_{ij}(k)</code> at each time between 0
and <code>k</code> if <code>var = FALSE</code>. If <code>var = TRUE</code>, a list containing the
following components:
</p>

<ul>
<li><p>x: an array giving the value of <code class="reqn">q_{ij}(k)</code> at each time
between 0 and <code>k</code>;
</p>
</li>
<li><p>sigma2: an array giving the asymptotic variance of the estimator
<code class="reqn">\sigma_{q}^{2}(i, j, k)</code>.
</p>
</li></ul>


<hr>
<h2 id='is.mm'>Function to check if an object is of class <code>mm</code></h2><span id='topic+is.mm'></span>

<h3>Description</h3>

<p><code>is.mm</code> returns <code>TRUE</code> if <code>x</code> is an object of
class <code>mm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.mm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.mm_+3A_x">x</code></td>
<td>
<p>An arbitrary R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is.mm</code> returns <code>TRUE</code> or <code>FALSE</code> depending on whether <code>x</code> is an
object of class <code>mm</code> or not.
</p>

<hr>
<h2 id='is.mmfit'>Function to check if an object is of class <code>mmfit</code></h2><span id='topic+is.mmfit'></span>

<h3>Description</h3>

<p><code>is.mmfit</code> returns <code>TRUE</code> if <code>x</code> is an object of
class <code>mmfit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.mmfit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.mmfit_+3A_x">x</code></td>
<td>
<p>An arbitrary R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is.mmfit</code> returns <code>TRUE</code> or <code>FALSE</code> depending on whether <code>x</code> is an
object of class <code>mmfit</code> or not.
</p>

<hr>
<h2 id='is.smm'>Function to check if an object is of class <code>smm</code></h2><span id='topic+is.smm'></span>

<h3>Description</h3>

<p><code>is.smm</code> returns <code>TRUE</code> if <code>x</code> is an object of class <code>smm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.smm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.smm_+3A_x">x</code></td>
<td>
<p>An arbitrary R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is.smm</code> returns <code>TRUE</code> or <code>FALSE</code> depending on whether <code>x</code> is an
object of class <code>smm</code> or not.
</p>

<hr>
<h2 id='is.smmfit'>Function to check if an object is of class <code>smmfit</code></h2><span id='topic+is.smmfit'></span>

<h3>Description</h3>

<p><code>is.smmfit</code> returns <code>TRUE</code> if <code>x</code> is an object of class <code>smmfit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.smmfit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.smmfit_+3A_x">x</code></td>
<td>
<p>An arbitrary R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is.smmfit</code> returns <code>TRUE</code> or <code>FALSE</code> depending on whether <code>x</code> is an
object of class <code>smmfit</code> or not.
</p>

<hr>
<h2 id='is.smmnonparametric'>Function to check if an object is of class <code>smmnonparametric</code></h2><span id='topic+is.smmnonparametric'></span>

<h3>Description</h3>

<p><code>is.smmnonparametric</code> returns <code>TRUE</code> if <code>x</code> is an object of
class <code>smmnonparametric</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.smmnonparametric(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.smmnonparametric_+3A_x">x</code></td>
<td>
<p>An arbitrary R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is.smmnonparametric</code> returns <code>TRUE</code> or <code>FALSE</code> depending on whether
<code>x</code> is an object of class <code>smmnonparametric</code> or not.
</p>

<hr>
<h2 id='is.smmparametric'>Function to check if an object is of class <code>smmparametric</code></h2><span id='topic+is.smmparametric'></span>

<h3>Description</h3>

<p><code>is.smmparametric</code> returns <code>TRUE</code> if <code>x</code> is an object of
class <code>smmparametric</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.smmparametric(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.smmparametric_+3A_x">x</code></td>
<td>
<p>An arbitrary R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is.smmparametric</code> returns <code>TRUE</code> or <code>FALSE</code> depending on whether
<code>x</code> is an object of class <code>smmparametric</code> or not.
</p>

<hr>
<h2 id='loglik'>Log-likelihood Function</h2><span id='topic+loglik'></span>

<h3>Description</h3>

<p>Generic function computing the log-likelihood of the model <code>x</code>,
with the list of sequences <code>sequences</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik(x, sequences = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglik_+3A_x">x</code></td>
<td>
<p>An object for which there exists a <code>loglik</code> attribute if
<code>sequences = NULL</code>. Otherwise, the log-likelihood will be computed using
the model <code>x</code> and the sequences <code>sequences</code>.</p>
</td></tr>
<tr><td><code id="loglik_+3A_sequences">sequences</code></td>
<td>
<p>Optional. A list of vectors representing the sequences for
which the log-likelihood will be computed based on <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of the log-likelihood.
</p>

<hr>
<h2 id='maintainability'>Maintainability Function</h2><span id='topic+maintainability'></span>

<h3>Description</h3>

<p>For a reparable system <code class="reqn">S_{ystem}</code> for which the failure
occurs at time <code class="reqn">k = 0</code>, its maintainability at time <code class="reqn">k \in N</code> is
the probability that the system is repaired up to time <code class="reqn">k</code>, given that
it has failed at time <code class="reqn">k = 0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maintainability(x, k, upstates = x$states, level = 0.95, klim = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maintainability_+3A_x">x</code></td>
<td>
<p>An object of S3 class <code>smmfit</code> or <code>smm</code>.</p>
</td></tr>
<tr><td><code id="maintainability_+3A_k">k</code></td>
<td>
<p>A positive integer giving the period <code class="reqn">[0, k]</code> on which the
maintainability should be computed.</p>
</td></tr>
<tr><td><code id="maintainability_+3A_upstates">upstates</code></td>
<td>
<p>Vector giving the subset of operational states <code class="reqn">U</code>.</p>
</td></tr>
<tr><td><code id="maintainability_+3A_level">level</code></td>
<td>
<p>Confidence level of the asymptotic confidence interval. Helpful
for an object <code>x</code> of class <code>smmfit</code>.</p>
</td></tr>
<tr><td><code id="maintainability_+3A_klim">klim</code></td>
<td>
<p>Optional. The time horizon used to approximate the series in the
computation of the mean sojourn times vector <code class="reqn">m</code> (cf.
<a href="#topic+meanSojournTimes">meanSojournTimes</a> function) for the asymptotic variance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider a system (or a component) <code class="reqn">S_{ystem}</code> whose possible
states during its evolution in time are <code class="reqn">E = \{1,\dots,s\}</code>.
Denote by <code class="reqn">U = \{1,\dots,s_1\}</code> the subset of operational states of
the system (the up states) and by <code class="reqn">D = \{s_1 + 1,\dots, s\}</code> the
subset of failure states (the down states), with <code class="reqn">0 &lt; s_1 &lt; s</code>
(obviously, <code class="reqn">E = U \cup D</code> and <code class="reqn">U \cap D = \emptyset</code>,
<code class="reqn">U \neq \emptyset,\ D \neq \emptyset</code>). One can think of the states
of <code class="reqn">U</code> as different operating modes or performance levels of the
system, whereas the states of <code class="reqn">D</code> can be seen as failures of the
systems with different modes.
</p>
<p>We are interested in investigating the maintainability of a discrete-time
semi-Markov system <code class="reqn">S_{ystem}</code>. Consequently, we suppose that the
evolution in time of the system is governed by an E-state space
semi-Markov chain <code class="reqn">(Z_k)_{k \in N}</code>. The system starts to fail at
instant <code class="reqn">0</code> and the state of the system is given at each instant
<code class="reqn">k \in N</code> by <code class="reqn">Z_k</code>: the event <code class="reqn">\{Z_k = i\}</code>, for a certain
<code class="reqn">i \in U</code>, means that the system <code class="reqn">S_{ystem}</code> is in operating mode
<code class="reqn">i</code> at time <code class="reqn">k</code>, whereas <code class="reqn">\{Z_k = j\}</code>, for a certain
<code class="reqn">j \in D</code>, means that the system is not operational at time <code class="reqn">k</code>
due to the mode of failure <code class="reqn">j</code> or that the system is under the
repairing mode <code class="reqn">j</code>.
</p>
<p>Thus, we take <code class="reqn">(\alpha_{i} := P(Z_{0} = i))_{i \in U} = 0</code> and we
denote by <code class="reqn">T_U</code> the first hitting time of subset <code class="reqn">U</code>, called the
duration of repair or repair time, that is,
</p>
<p style="text-align: center;"><code class="reqn">T_U := \textrm{inf}\{ n \in N;\ Z_n \in U\}\ \textrm{and}\ \textrm{inf}\ \emptyset := \infty.</code>
</p>

<p>The maintainability at time <code class="reqn">k \in N</code> of a discrete-time semi-Markov
system is
</p>
<p style="text-align: center;"><code class="reqn">M(k) = P(T_U \leq k) = 1 - P(T_{U} &gt; k) = 1 - P(Z_{n} \in D,\ n = 0,\dots,k).</code>
</p>



<h3>Value</h3>

<p>A matrix with <code class="reqn">k + 1</code> rows, and with columns giving values of
the maintainability, variances, lower and upper asymptotic confidence limits
(if <code>x</code> is an object of class <code>smmfit</code>).
</p>


<h3>References</h3>

<p>V. S. Barbu, N. Limnios. (2008). Semi-Markov Chains and Hidden Semi-Markov
Models Toward Applications - Their Use in Reliability and DNA Analysis.
New York: Lecture Notes in Statistics, vol. 191, Springer.
</p>

<hr>
<h2 id='meanRecurrenceTimes'>Method to get the mean recurrence times <code class="reqn">\mu</code></h2><span id='topic+meanRecurrenceTimes'></span>

<h3>Description</h3>

<p>Method to get the mean recurrence times <code class="reqn">\mu</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanRecurrenceTimes(x, klim = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanRecurrenceTimes_+3A_x">x</code></td>
<td>
<p>An object of S3 class <code>smmfit</code> or <code>smm</code>.</p>
</td></tr>
<tr><td><code id="meanRecurrenceTimes_+3A_klim">klim</code></td>
<td>
<p>Optional. The time horizon used to approximate the series in the
computation of the mean sojourn times vector <code class="reqn">m</code> (cf.
<a href="#topic+meanSojournTimes">meanSojournTimes</a> function).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider a system (or a component) <code class="reqn">S_{ystem}</code> whose possible
states during its evolution in time are <code class="reqn">E = \{1,\dots,s\}</code>.
</p>
<p>We are interested in investigating the mean recurrence times of a
discrete-time semi-Markov system <code class="reqn">S_{ystem}</code>. Consequently, we suppose
that the evolution in time of the system is governed by an E-state space
semi-Markov chain <code class="reqn">(Z_k)_{k \in N}</code>. The state of the system is given
at each instant <code class="reqn">k \in N</code> by <code class="reqn">Z_k</code>: the event <code class="reqn">\{Z_k = i\}</code>.
</p>
<p>Let <code class="reqn">T = (T_{n})_{n \in N}</code> denote the successive time points when
state changes in <code class="reqn">(Z_{n})_{n \in N}</code> occur and let also
<code class="reqn">J = (J_{n})_{n \in N}</code> denote the successively visited states at
these time points.
</p>
<p>The mean recurrence of an arbitrary state <code class="reqn">j \in E</code> is given by:
</p>
<p style="text-align: center;"><code class="reqn">\mu_{jj} = \frac{\sum_{i \in E} \nu(i) m_{i}}{\nu(j)}</code>
</p>

<p>where <code class="reqn">(\nu(1),\dots,\nu(s))</code> is the stationary distribution of the
embedded Markov chain <code class="reqn">(J_{n})_{n \in N}</code> and <code class="reqn">m_{i}</code> is the mean
sojourn time in state <code class="reqn">i \in E</code> (see <a href="#topic+meanSojournTimes">meanSojournTimes</a> function for
the computation).
</p>


<h3>Value</h3>

<p>A vector giving the mean recurrence time
<code class="reqn">(\mu_{i})_{i \in [1,\dots,s]}</code>.
</p>

<hr>
<h2 id='meanSojournTimes'>Mean Sojourn Times Function</h2><span id='topic+meanSojournTimes'></span>

<h3>Description</h3>

<p>The mean sojourn time is the mean time spent in each state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanSojournTimes(x, states = x$states, klim = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanSojournTimes_+3A_x">x</code></td>
<td>
<p>An object of S3 class <code>smmfit</code> or <code>smm</code>.</p>
</td></tr>
<tr><td><code id="meanSojournTimes_+3A_states">states</code></td>
<td>
<p>Vector giving the states for which the mean sojourn time
should be computed. <code>states</code> is a subset of <code class="reqn">E</code>.</p>
</td></tr>
<tr><td><code id="meanSojournTimes_+3A_klim">klim</code></td>
<td>
<p>Optional. The time horizon used to approximate the series in the
computation of the mean sojourn times vector <code class="reqn">m</code> (cf.
<a href="#topic+meanSojournTimes">meanSojournTimes</a> function).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider a system (or a component) <code class="reqn">S_{ystem}</code> whose possible
states during its evolution in time are <code class="reqn">E = \{1,\dots,s\}</code>.
</p>
<p>We are interested in investigating the mean sojourn times of a
discrete-time semi-Markov system <code class="reqn">S_{ystem}</code>. Consequently, we suppose
that the evolution in time of the system is governed by an E-state space
semi-Markov chain <code class="reqn">(Z_k)_{k \in N}</code>. The state of the system is given
at each instant <code class="reqn">k \in N</code> by <code class="reqn">Z_k</code>: the event <code class="reqn">\{Z_k = i\}</code>.
</p>
<p>Let <code class="reqn">T = (T_{n})_{n \in N}</code> denote the successive time points when
state changes in <code class="reqn">(Z_{n})_{n \in N}</code> occur and let also
<code class="reqn">J = (J_{n})_{n \in N}</code> denote the successively visited states at
these time points.
</p>
<p>The mean sojourn times vector is defined as follows:
</p>
<p style="text-align: center;"><code class="reqn">m_{i} = E[T_{1} | Z_{0} = j] = \sum_{k \geq 0} (1 - P(T_{n + 1} - T_{n} \leq k | J_{n} = j)) = \sum_{k \geq 0} (1 - H_{j}(k)),\ i \in E</code>
</p>



<h3>Value</h3>

<p>A vector of length <code class="reqn">\textrm{card}(E)</code> giving the values of the
mean sojourn times for each state <code class="reqn">i \in E</code>.
</p>

<hr>
<h2 id='mm'>Markov model specification</h2><span id='topic+mm'></span>

<h3>Description</h3>

<p>Creates a model specification of a Markov model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mm(states, init, ptrans, k = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mm_+3A_states">states</code></td>
<td>
<p>Vector of state space of length s.</p>
</td></tr>
<tr><td><code id="mm_+3A_init">init</code></td>
<td>
<p>Vector of initial distribution of length s ^ k.</p>
</td></tr>
<tr><td><code id="mm_+3A_ptrans">ptrans</code></td>
<td>
<p>Matrix of transition probabilities of dimension <code class="reqn">(s, s)</code>.</p>
</td></tr>
<tr><td><code id="mm_+3A_k">k</code></td>
<td>
<p>Order of the Markov chain.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+mm">mm</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+simulate.mm">simulate.mm</a>, <a href="#topic+fitmm">fitmm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>states &lt;- c("a", "c", "g", "t")
s &lt;- length(states)
k &lt;- 1
init &lt;- rep.int(1 / s, s)
p &lt;- matrix(c(0, 0, 0.3, 0.4, 0, 0, 0.5, 0.2, 0.7, 0.5, 
              0, 0.4, 0.3, 0.5, 0.2, 0), ncol = s)

# Specify a Markov model of order 1
markov &lt;- mm(states = states, init = init, ptrans = p, k = k)

</code></pre>

<hr>
<h2 id='mttf'>Mean Time To Failure (MTTF) Function</h2><span id='topic+mttf'></span>

<h3>Description</h3>

<p>Consider a system <code class="reqn">S_{ystem}</code> starting to work at time
<code class="reqn">k = 0</code>. The mean time to failure (MTTF) is defined as the mean
lifetime.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mttf(x, upstates = x$states, level = 0.95, klim = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mttf_+3A_x">x</code></td>
<td>
<p>An object of S3 class <code>smmfit</code> or <code>smm</code>.</p>
</td></tr>
<tr><td><code id="mttf_+3A_upstates">upstates</code></td>
<td>
<p>Vector giving the subset of operational states <code class="reqn">U</code>.</p>
</td></tr>
<tr><td><code id="mttf_+3A_level">level</code></td>
<td>
<p>Confidence level of the asymptotic confidence interval. Helpful
for an object <code>x</code> of class <code>smmfit</code>.</p>
</td></tr>
<tr><td><code id="mttf_+3A_klim">klim</code></td>
<td>
<p>Optional. The time horizon used to approximate the series in the
computation of the mean sojourn times vector <code class="reqn">m</code> (cf.
<a href="#topic+meanSojournTimes">meanSojournTimes</a> function) for the asymptotic variance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider a system (or a component) <code class="reqn">S_{ystem}</code> whose possible
states during its evolution in time are <code class="reqn">E = \{1,\dots,s\}</code>.
Denote by <code class="reqn">U = \{1,\dots,s_1\}</code> the subset of operational states of
the system (the up states) and by <code class="reqn">D = \{s_1 + 1,\dots,s\}</code> the
subset of failure states (the down states), with <code class="reqn">0 &lt; s_1 &lt; s</code>
(obviously, <code class="reqn">E = U \cup D</code> and <code class="reqn">U \cap D = \emptyset</code>,
<code class="reqn">U \neq \emptyset,\ D \neq \emptyset</code>). One can think of the states
of <code class="reqn">U</code> as different operating modes or performance levels of the
system, whereas the states of <code class="reqn">D</code> can be seen as failures of the
systems with different modes.
</p>
<p>We are interested in investigating the mean time to failure of a
discrete-time semi-Markov system <code class="reqn">S_{ystem}</code>. Consequently, we suppose
that the evolution in time of the system is governed by an E-state space
semi-Markov chain <code class="reqn">(Z_k)_{k \in N}</code>. The system starts to work at
instant <code class="reqn">0</code> and the state of the system is given at each instant
<code class="reqn">k \in N</code> by <code class="reqn">Z_k</code>: the event <code class="reqn">\{Z_k = i\}</code>, for a certain
<code class="reqn">i \in U</code>, means that the system <code class="reqn">S_{ystem}</code> is in operating mode
<code class="reqn">i</code> at time <code class="reqn">k</code>, whereas <code class="reqn">\{Z_k = j\}</code>, for a certain
<code class="reqn">j \in D</code>, means that the system is not operational at time <code class="reqn">k</code>
due to the mode of failure <code class="reqn">j</code> or that the system is under the
repairing mode <code class="reqn">j</code>.
</p>
<p>Let <code class="reqn">T_D</code> denote the first passage time in subset <code class="reqn">D</code>, called
the lifetime of the system, i.e.,
</p>
<p style="text-align: center;"><code class="reqn">T_D := \textrm{inf}\{ n \in N;\ Z_n \in D\}\ \textrm{and}\ \textrm{inf}\ \emptyset := \infty.</code>
</p>

<p>The mean time to failure (MTTF) is defined as the mean lifetime, i.e., the
expectation of the hitting time to down set <code class="reqn">D</code>,
</p>
<p style="text-align: center;"><code class="reqn">MTTF = E[T_{D}]</code>
</p>



<h3>Value</h3>

<p>A matrix with <code class="reqn">\textrm{card}(U) = s_{1}</code> rows, and with columns
giving values of the mean time to failure for each state <code class="reqn">i \in U</code>,
variances, lower and upper asymptotic confidence limits (if <code>x</code> is an
object of class <code>smmfit</code>).
</p>


<h3>References</h3>

<p>V. S. Barbu, N. Limnios. (2008). Semi-Markov Chains and Hidden Semi-Markov
Models Toward Applications - Their Use in Reliability and DNA Analysis.
New York: Lecture Notes in Statistics, vol. 191, Springer.
</p>
<p>I. Votsi &amp; A. Brouste (2019) Confidence interval for the mean time to
failure in semi-Markov models: an application to wind energy production,
Journal of Applied Statistics, 46:10, 1756-1773
</p>

<hr>
<h2 id='mttr'>Mean Time To Repair (MTTR) Function</h2><span id='topic+mttr'></span>

<h3>Description</h3>

<p>Consider a system <code class="reqn">S_{ystem}</code> that has just failed at time
<code class="reqn">k = 0</code>. The mean time to repair (MTTR) is defined as the mean of the
repair duration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mttr(x, upstates = x$states, level = 0.95, klim = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mttr_+3A_x">x</code></td>
<td>
<p>An object of S3 class <code>smmfit</code> or <code>smm</code>.</p>
</td></tr>
<tr><td><code id="mttr_+3A_upstates">upstates</code></td>
<td>
<p>Vector giving the subset of operational states <code class="reqn">U</code>.</p>
</td></tr>
<tr><td><code id="mttr_+3A_level">level</code></td>
<td>
<p>Confidence level of the asymptotic confidence interval. Helpful
for an object <code>x</code> of class <code>smmfit</code>.</p>
</td></tr>
<tr><td><code id="mttr_+3A_klim">klim</code></td>
<td>
<p>Optional. The time horizon used to approximate the series in the
computation of the mean sojourn times vector <code class="reqn">m</code> (cf.
<a href="#topic+meanSojournTimes">meanSojournTimes</a> function) for the asymptotic variance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider a system (or a component) <code class="reqn">S_{ystem}</code> whose possible
states during its evolution in time are <code class="reqn">E = \{1,\dots,s\}</code>.
Denote by <code class="reqn">U = \{1,\dots,s_1\}</code> the subset of operational states of
the system (the up states) and by <code class="reqn">D = \{s_1 + 1,\dots,s\}</code> the
subset of failure states (the down states), with <code class="reqn">0 &lt; s_1 &lt; s</code>
(obviously, <code class="reqn">E = U \cup D</code> and <code class="reqn">U \cap D = \emptyset</code>,
<code class="reqn">U \neq \emptyset,\ D \neq \emptyset</code>). One can think of the states
of <code class="reqn">U</code> as different operating modes or performance levels of the
system, whereas the states of <code class="reqn">D</code> can be seen as failures of the
systems with different modes.
</p>
<p>We are interested in investigating the mean time to repair of a
discrete-time semi-Markov system <code class="reqn">S_{ystem}</code>. Consequently, we suppose
that the evolution in time of the system is governed by an E-state space
semi-Markov chain <code class="reqn">(Z_k)_{k \in N}</code>. The system has just failed at
instant 0 and the state of the system is given at each instant
<code class="reqn">k \in N</code> by <code class="reqn">Z_k</code>: the event <code class="reqn">\{Z_k = i\}</code>, for a certain
<code class="reqn">i \in U</code>, means that the system <code class="reqn">S_{ystem}</code> is in operating mode
<code class="reqn">i</code> at time <code class="reqn">k</code>, whereas <code class="reqn">\{Z_k = j\}</code>, for a certain
<code class="reqn">j \in D</code>, means that the system is not operational at time <code class="reqn">k</code>
due to the mode of failure <code class="reqn">j</code> or that the system is under the
repairing mode <code class="reqn">j</code>.
</p>
<p>Let <code class="reqn">T_U</code> denote the first passage time in subset <code class="reqn">U</code>, called the
duration of repair or repair time, i.e.,
</p>
<p style="text-align: center;"><code class="reqn">T_U := \textrm{inf}\{ n \in N;\ Z_n \in U\}\ \textrm{and}\ \textrm{inf}\ \emptyset := \infty.</code>
</p>

<p>The mean time to repair (MTTR) is defined as the mean of the repair
duration, i.e., the expectation of the hitting time to up set <code class="reqn">U</code>,
</p>
<p style="text-align: center;"><code class="reqn">MTTR = E[T_{U}]</code>
</p>



<h3>Value</h3>

<p>A matrix with <code class="reqn">\textrm{card}(U) = s_{1}</code> rows, and with columns
giving values of the mean time to repair for each state <code class="reqn">i \in U</code>,
variances, lower and upper asymptotic confidence limits (if <code>x</code> is an
object of class <code>smmfit</code>).
</p>


<h3>References</h3>

<p>V. S. Barbu, N. Limnios. (2008). Semi-Markov Chains and Hidden Semi-Markov
Models Toward Applications - Their Use in Reliability and DNA Analysis.
New York: Lecture Notes in Statistics, vol. 191, Springer.
</p>
<p>I. Votsi &amp; A. Brouste (2019) Confidence interval for the mean time to
failure in semi-Markov models: an application to wind energy production,
Journal of Applied Statistics, 46:10, 1756-1773
</p>

<hr>
<h2 id='plot.smm'>Plot function for an object of class smm</h2><span id='topic+plot.smm'></span>

<h3>Description</h3>

<p>Displays the densities for the conditional sojourn time
distributions depending on the current state <code>i</code> and on the next state
<code>j</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smm'
plot(x, i, j, klim = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.smm_+3A_x">x</code></td>
<td>
<p>An object of S3 class <code>smm</code> (inheriting from the S3 class
<a href="#topic+smmnonparametric">smmnonparametric</a> or <a href="#topic+smmparametric">smmparametric</a>).</p>
</td></tr>
<tr><td><code id="plot.smm_+3A_i">i</code></td>
<td>
<p>An element of the state space vector <code>x$states</code> giving the current
state in the following cases: <code>type.sojourn = "fij"</code> or <code>type.sojourn = "fi"</code>,
otherwise, <code>i</code> is ignored.</p>
</td></tr>
<tr><td><code id="plot.smm_+3A_j">j</code></td>
<td>
<p>An element of the state space vector <code>x$states</code> giving the next
state in the following cases: <code>type.sojourn = "fij"</code> or <code>type.sojourn = "fj"</code>,
otherwise, <code>j</code> is ignored.</p>
</td></tr>
<tr><td><code id="plot.smm_+3A_klim">klim</code></td>
<td>
<p>An integer giving the limit value for which the density will be
plotted. If <code>klim</code> is <code>NULL</code>, then quantile or order 0.95 is used.</p>
</td></tr>
<tr><td><code id="plot.smm_+3A_...">...</code></td>
<td>
<p>Arguments passed to plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>

<hr>
<h2 id='plot.smmfit'>Plot function for an object of class smmfit</h2><span id='topic+plot.smmfit'></span>

<h3>Description</h3>

<p>Displays the densities for the conditional sojourn time
distributions depending on the current state <code>i</code> and on the next state
<code>j</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smmfit'
plot(x, i, j, klim = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.smmfit_+3A_x">x</code></td>
<td>
<p>An object of class <code>smmfit</code> (inheriting from the S3 classes
<code>smm</code>, <a href="#topic+smmnonparametric">smmnonparametric</a> or <a href="#topic+smmparametric">smmparametric</a>).</p>
</td></tr>
<tr><td><code id="plot.smmfit_+3A_i">i</code></td>
<td>
<p>An element of the state space vector <code>x$states</code> giving the current
state in the following cases: <code>type.sojourn = "fij"</code> or <code>type.sojourn = "fi"</code>,
otherwise, <code>i</code> is ignored.</p>
</td></tr>
<tr><td><code id="plot.smmfit_+3A_j">j</code></td>
<td>
<p>An element of the state space vector <code>x$states</code> giving the next
state in the following cases: <code>type.sojourn = "fij"</code> or <code>type.sojourn = "fj"</code>,
otherwise, <code>j</code> is ignored.</p>
</td></tr>
<tr><td><code id="plot.smmfit_+3A_klim">klim</code></td>
<td>
<p>An integer giving the limit value for which the density will be
plotted. If <code>klim</code> is <code>NULL</code>, then quantile or order 0.95 is used.</p>
</td></tr>
<tr><td><code id="plot.smmfit_+3A_...">...</code></td>
<td>
<p>Arguments passed to plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>References</h3>

<p>V. S. Barbu, N. Limnios. (2008). Semi-Markov Chains and Hidden Semi-Markov
Models Toward Applications - Their Use in Reliability and DNA Analysis.
New York: Lecture Notes in Statistics, vol. 191, Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>states &lt;- c("a", "c", "g", "t")
</code></pre>

<hr>
<h2 id='reliability'>Reliability Function</h2><span id='topic+reliability'></span>

<h3>Description</h3>

<p>Consider a system <code class="reqn">S_{ystem}</code> starting to function at time
<code class="reqn">k = 0</code>. The reliability or the survival function of <code class="reqn">S_{ystem}</code>
at time <code class="reqn">k \in N</code> is the probability that the system has functioned
without failure in the period <code class="reqn">[0, k]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reliability(x, k, upstates = x$states, level = 0.95, klim = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reliability_+3A_x">x</code></td>
<td>
<p>An object of S3 class <code>smmfit</code> or <code>smm</code>.</p>
</td></tr>
<tr><td><code id="reliability_+3A_k">k</code></td>
<td>
<p>A positive integer giving the period <code class="reqn">[0, k]</code> on which the
reliability should be computed.</p>
</td></tr>
<tr><td><code id="reliability_+3A_upstates">upstates</code></td>
<td>
<p>Vector giving the subset of operational states <code class="reqn">U</code>.</p>
</td></tr>
<tr><td><code id="reliability_+3A_level">level</code></td>
<td>
<p>Confidence level of the asymptotic confidence interval. Helpful
for an object <code>x</code> of class <code>smmfit</code>.</p>
</td></tr>
<tr><td><code id="reliability_+3A_klim">klim</code></td>
<td>
<p>Optional. The time horizon used to approximate the series in the
computation of the mean sojourn times vector <code class="reqn">m</code> (cf.
<a href="#topic+meanSojournTimes">meanSojournTimes</a> function) for the asymptotic
variance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider a system (or a component) <code class="reqn">S_{ystem}</code> whose possible
states during its evolution in time are <code class="reqn">E = \{1,\dots,s\}</code>.
Denote by <code class="reqn">U = \{1,\dots,s_1\}</code> the subset of operational states of
the system (the up states) and by <code class="reqn">D = \{s_1 + 1,\dots, s\}</code> the
subset of failure states (the down states), with <code class="reqn">0 &lt; s_1 &lt; s</code>
(obviously, <code class="reqn">E = U \cup D</code> and <code class="reqn">U \cap D = \emptyset</code>,
<code class="reqn">U \neq \emptyset,\ D \neq \emptyset</code>). One can think of the states
of <code class="reqn">U</code> as different operating modes or performance levels of the
system, whereas the states of <code class="reqn">D</code> can be seen as failures of the
systems with different modes.
</p>
<p>We are interested in investigating the reliability of a discrete-time
semi-Markov system <code class="reqn">S_{ystem}</code>. Consequently, we suppose that the
evolution in time of the system is governed by an E-state space
semi-Markov chain <code class="reqn">(Z_k)_{k \in N}</code>. The system starts to work at
instant <code class="reqn">0</code> and the state of the system is given at each instant
<code class="reqn">k \in N</code> by <code class="reqn">Z_k</code>: the event <code class="reqn">\{Z_k = i\}</code>, for a certain
<code class="reqn">i \in U</code>, means that the system <code class="reqn">S_{ystem}</code> is in operating mode
<code class="reqn">i</code> at time <code class="reqn">k</code>, whereas <code class="reqn">\{Z_k = j\}</code>, for a certain
<code class="reqn">j \in D</code>, means that the system is not operational at time <code class="reqn">k</code>
due to the mode of failure <code class="reqn">j</code> or that the system is under the
repairing mode <code class="reqn">j</code>.
</p>
<p>Let <code class="reqn">T_D</code> denote the first passage time in subset <code class="reqn">D</code>, called
the lifetime of the system, i.e.,
</p>
<p style="text-align: center;"><code class="reqn">T_D := \textrm{inf}\{ n \in N;\ Z_n \in D\}\ \textrm{and}\ \textrm{inf}\ \emptyset := \infty.</code>
</p>

<p>The reliability or the survival function at time <code class="reqn">k \in N</code> of a
discrete-time semi-Markov system is:
</p>
<p style="text-align: center;"><code class="reqn">R(k) := P(T_D &gt; k) = P(Zn \in U,n = 0,\dots,k)</code>
</p>

<p>which can be rewritten as follows:
</p>
<p style="text-align: center;"><code class="reqn">R(k) = \sum_{i \in U} P(Z_0 = i) P(T_D &gt; k | Z_0 = i) = \sum_{i \in U} \alpha_i P(T_D &gt; k | Z_0 = i)</code>
</p>



<h3>Value</h3>

<p>A matrix with <code class="reqn">k + 1</code> rows, and with columns giving values of
the reliability, variances, lower and upper asymptotic confidence limits
(if <code>x</code> is an object of class <code>smmfit</code>).
</p>


<h3>References</h3>

<p>V. S. Barbu, N. Limnios. (2008). Semi-Markov Chains and Hidden Semi-Markov
Models Toward Applications - Their Use in Reliability and DNA Analysis.
New York: Lecture Notes in Statistics, vol. 191, Springer.
</p>

<hr>
<h2 id='setSeed'>Set the RNG Seed from within Rcpp</h2><span id='topic+setSeed'></span>

<h3>Description</h3>

<p>Set the RNG Seed from within Rcpp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setSeed(seed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setSeed_+3A_seed">seed</code></td>
<td>
<p>An <code>unsigned int</code> that is the seed one wishes to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A set RNG scope.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
x &lt;- rnorm(5, 0, 1)
setSeed(10)
y &lt;- rnorm(5, 0, 1)
all.equal(x, y, check.attributes = FALSE)

</code></pre>

<hr>
<h2 id='simulate.mm'>Simulates k-th order Markov chains</h2><span id='topic+simulate.mm'></span>

<h3>Description</h3>

<p>Simulates k-th order Markov chains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mm'
simulate(object, nsim = 1, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.mm_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+mm">mm</a>.</p>
</td></tr>
<tr><td><code id="simulate.mm_+3A_nsim">nsim</code></td>
<td>
<p>An integer or vector of integers (for multiple sequences)
specifying the length of the sequence(s).</p>
</td></tr>
<tr><td><code id="simulate.mm_+3A_seed">seed</code></td>
<td>
<p>Optional. <code>seed</code> for the random number generator.
If no <code>seed</code> is given, then seed is set by using the command
<code style="white-space: pre;">&#8288;set.seed(round(as.numeric(Sys.time()))&#8288;</code>.</p>
</td></tr>
<tr><td><code id="simulate.mm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>nsim</code> is a single integer then a chain of that length is
produced. If <code>nsim</code> is a vector of integers, then <code>length(nsim)</code>
sequences are generated with respective lengths.
</p>


<h3>Value</h3>

<p>A list of vectors representing the sequences.
</p>


<h3>See Also</h3>

<p><a href="#topic+mm">mm</a>, <a href="#topic+fitmm">fitmm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>states &lt;- c("a", "c", "g", "t")
s &lt;- length(states)
k &lt;- 2
init &lt;- rep.int(1 / s ^ k, s ^ k)
p &lt;- matrix(0.25, nrow = s ^ k, ncol = s)

# Specify a Markov model of order 1
markov &lt;- mm(states = states, init = init, ptrans = p, k = k)

seqs &lt;- simulate(object = markov, nsim = c(1000, 10000, 2000), seed = 150)

</code></pre>

<hr>
<h2 id='simulate.mmfit'>Simulates Markov chains</h2><span id='topic+simulate.mmfit'></span>

<h3>Description</h3>

<p>Simulates sequences from a fitted Markov model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmfit'
simulate(object, nsim = 1, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.mmfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>mmfit</code>.</p>
</td></tr>
<tr><td><code id="simulate.mmfit_+3A_nsim">nsim</code></td>
<td>
<p>An integer or vector of integers (for multiple sequences)
specifying the length of the sequence(s).</p>
</td></tr>
<tr><td><code id="simulate.mmfit_+3A_seed">seed</code></td>
<td>
<p>Optional. <code>seed</code> for the random number generator.
If no <code>seed</code> is given, then seed is set by using the command
<code style="white-space: pre;">&#8288;set.seed(round(as.numeric(Sys.time()))&#8288;</code>.</p>
</td></tr>
<tr><td><code id="simulate.mmfit_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>nsim</code> is a single integer then a chain of that length is
produced. If <code>nsim</code> is a vector of integers, then <code>length(nsim)</code>
sequences are generated with respective lengths.
</p>


<h3>Value</h3>

<p>A list of vectors representing the sequences.
</p>


<h3>See Also</h3>

<p><a href="#topic+mm">mm</a>, <a href="#topic+fitmm">fitmm</a>
</p>

<hr>
<h2 id='simulate.smm'>Simulates semi-Markov chains</h2><span id='topic+simulate.smm'></span>

<h3>Description</h3>

<p>Simulates sequences from a semi-Markov model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smm'
simulate(object, nsim = 1, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.smm_+3A_object">object</code></td>
<td>
<p>An object of S3 class <code>smm</code> (inheriting from the S3 class
<a href="#topic+smmnonparametric">smmnonparametric</a> or <a href="#topic+smmparametric">smmparametric</a>).</p>
</td></tr>
<tr><td><code id="simulate.smm_+3A_nsim">nsim</code></td>
<td>
<p>An integer or vector of integers (for multiple sequences)
specifying the length of the sequence(s).</p>
</td></tr>
<tr><td><code id="simulate.smm_+3A_seed">seed</code></td>
<td>
<p>Optional. <code>seed</code> for the random number generator.
If no <code>seed</code> is given, then seed is set by using the command
<code style="white-space: pre;">&#8288;set.seed(round(as.numeric(Sys.time()))&#8288;</code>.</p>
</td></tr>
<tr><td><code id="simulate.smm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>nsim</code> is a single integer then a chain of that length is
produced. If <code>nsim</code> is a vector of integers, then <code>length(nsim)</code>
sequences are generated with respective lengths.
</p>


<h3>Value</h3>

<p>A list of vectors representing the sequences.
</p>


<h3>References</h3>

<p>V. S. Barbu, N. Limnios. (2008). Semi-Markov Chains and Hidden Semi-Markov
Models Toward Applications - Their Use in Reliability and DNA Analysis.
New York: Lecture Notes in Statistics, vol. 191, Springer.
</p>


<h3>See Also</h3>

<p><a href="#topic+smmparametric">smmparametric</a>, <a href="#topic+smmnonparametric">smmnonparametric</a>, <a href="#topic+fitsmm">fitsmm</a>
</p>

<hr>
<h2 id='simulate.smmfit'>Simulates semi-Markov chains</h2><span id='topic+simulate.smmfit'></span>

<h3>Description</h3>

<p>Simulates sequences from a fitted semi-Markov model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smmfit'
simulate(object, nsim = 1, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.smmfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>smmfit</code> (inheriting from the S3 classes
<code>smm</code>, <a href="#topic+smmnonparametric">smmnonparametric</a> or <a href="#topic+smmparametric">smmparametric</a>).</p>
</td></tr>
<tr><td><code id="simulate.smmfit_+3A_nsim">nsim</code></td>
<td>
<p>An integer or vector of integers (for multiple sequences)
specifying the length of the sequence(s).</p>
</td></tr>
<tr><td><code id="simulate.smmfit_+3A_seed">seed</code></td>
<td>
<p><code>seed</code> for the random number generator.</p>
</td></tr>
<tr><td><code id="simulate.smmfit_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>nsim</code> is a single integer then a chain of that length is
produced. If <code>nsim</code> is a vector of integers, then <code>length(nsim)</code>
sequences are generated with respective lengths.
</p>


<h3>Value</h3>

<p>A list of vectors representing the sequences.
</p>


<h3>References</h3>

<p>V. S. Barbu, N. Limnios. (2008). Semi-Markov Chains and Hidden Semi-Markov
Models Toward Applications - Their Use in Reliability and DNA Analysis.
New York: Lecture Notes in Statistics, vol. 191, Springer.
</p>


<h3>See Also</h3>

<p><a href="#topic+smmnonparametric">smmnonparametric</a>, <a href="#topic+smmparametric">smmparametric</a>, <a href="#topic+fitsmm">fitsmm</a>
</p>

<hr>
<h2 id='smmnonparametric'>Non-parametric semi-Markov model specification</h2><span id='topic+smmnonparametric'></span>

<h3>Description</h3>

<p>Creates a non-parametric model specification for a semi-Markov model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smmnonparametric(
  states,
  init,
  ptrans,
  type.sojourn = c("fij", "fi", "fj", "f"),
  distr,
  cens.beg = FALSE,
  cens.end = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smmnonparametric_+3A_states">states</code></td>
<td>
<p>Vector of state space of length <code class="reqn">s</code>.</p>
</td></tr>
<tr><td><code id="smmnonparametric_+3A_init">init</code></td>
<td>
<p>Vector of initial distribution of length <code class="reqn">s</code>.</p>
</td></tr>
<tr><td><code id="smmnonparametric_+3A_ptrans">ptrans</code></td>
<td>
<p>Matrix of transition probabilities of the embedded Markov
chain <code class="reqn">J=(J_m)_{m}</code> of dimension <code class="reqn">(s, s)</code>.</p>
</td></tr>
<tr><td><code id="smmnonparametric_+3A_type.sojourn">type.sojourn</code></td>
<td>
<p>Type of sojourn time (for more explanations, see Details).</p>
</td></tr>
<tr><td><code id="smmnonparametric_+3A_distr">distr</code></td>
<td>

<ul>
<li><p> Array of dimension <code class="reqn">(s, s, kmax)</code> if <code>type.sojourn = "fij"</code>;
</p>
</li>
<li><p> Matrix of dimension <code class="reqn">(s, kmax)</code> if <code>type.sojourn = "fi"</code> or <code>"fj"</code>;
</p>
</li>
<li><p> Vector of length <code class="reqn">kmax</code> if the <code>type.sojourn = "f"</code>.
</p>
</li></ul>

<p><code class="reqn">kmax</code> is the maximum length of the sojourn times.</p>
</td></tr>
<tr><td><code id="smmnonparametric_+3A_cens.beg">cens.beg</code></td>
<td>
<p>Optional. A logical value indicating whether or not
sequences are censored at the beginning.</p>
</td></tr>
<tr><td><code id="smmnonparametric_+3A_cens.end">cens.end</code></td>
<td>
<p>Optional. A logical value indicating whether or not
sequences are censored at the end.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a semi-Markov model object in the
non-parametric case, taking into account the type of sojourn time and the
censoring described in references. The non-parametric specification concerns
sojourn time distributions defined by the user.
</p>
<p>The difference between the Markov model and the semi-Markov model concerns
the modeling of the sojourn time. With a Markov chain, the sojourn time
distribution is modeled by a Geometric distribution (in discrete time).
With a semi-Markov chain, the sojourn time can be any arbitrary distribution.
</p>
<p>We define :
</p>

<ul>
<li><p> the semi-Markov kernel <code class="reqn">q_{ij}(k) = P( J_{m+1} = j, T_{m+1} - T_{m} = k | J_{m} = i )</code>;
</p>
</li>
<li><p> the transition matrix <code class="reqn">(p_{trans}(i,j))_{i,j} \in states</code> of the embedded Markov chain <code class="reqn">J = (J_m)_m</code>, <code class="reqn">p_{trans}(i,j) = P( J_{m+1} = j | J_m = i )</code>;
</p>
</li>
<li><p> the initial distribution <code class="reqn">\mu_i = P(J_1 = i) = P(Z_1 = i)</code>, <code class="reqn">i \in 1, 2, \dots, s</code>;
</p>
</li>
<li><p> the conditional sojourn time distributions <code class="reqn">(f_{ij}(k))_{i,j} \in states,\ k \in N ,\ f_{ij}(k) = P(T_{m+1} - T_m = k | J_m = i, J_{m+1} = j )</code>,
f is specified by the argument <code>distr</code> in the non-parametric case.
</p>
</li></ul>

<p>In this package we can choose different types of sojourn time.
Four options are available for the sojourn times:
</p>

<ul>
<li><p> depending on the present state and on the next state (<code class="reqn">f_{ij}</code>);
</p>
</li>
<li><p> depending only on the present state (<code class="reqn">f_{i}</code>);
</p>
</li>
<li><p> depending only on the next state (<code class="reqn">f_{j}</code>);
</p>
</li>
<li><p> depending neither on the current, nor on the next state (<code class="reqn">f</code>).
</p>
</li></ul>

<p>Let define <code class="reqn">kmax</code> the maximum length of the sojourn times.
If  <code>type.sojourn = "fij"</code>, <code>distr</code> is an array of dimension <code class="reqn">(s, s, kmax)</code>.
If <code>type.sojourn = "fi"</code> or <code>"fj"</code>, <code>distr</code> must be a matrix of dimension <code class="reqn">(s, kmax)</code>.
If <code>type.sojourn = "f"</code>, <code>distr</code> must be a vector of length <code class="reqn">kmax</code>.
</p>
<p>If the sequence is censored at the beginning and/or at the end, <code>cens.beg</code>
must be equal to <code>TRUE</code> and/or <code>cens.end</code> must be equal to <code>TRUE</code>.
All the sequences must be censored in the same way.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>smm</code>, <a href="#topic+smmnonparametric">smmnonparametric</a>.
</p>


<h3>References</h3>

<p>V. S. Barbu, N. Limnios. (2008). Semi-Markov Chains and Hidden Semi-Markov
Models Toward Applications - Their Use in Reliability and DNA Analysis.
New York: Lecture Notes in Statistics, vol. 191, Springer.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+simulate">simulate</a>, <a href="#topic+fitsmm">fitsmm</a>, <a href="#topic+smmparametric">smmparametric</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>states &lt;- c("a", "c", "g", "t")
s &lt;- length(states)

# Creation of the initial distribution
vect.init &lt;- c(1 / 4, 1 / 4, 1 / 4, 1 / 4)

# Creation of the transition matrix
pij &lt;- matrix(c(0, 0.2, 0.5, 0.3, 
                0.2, 0, 0.3, 0.5, 
                0.3, 0.5, 0, 0.2, 
                0.4, 0.2, 0.4, 0), 
              ncol = s, byrow = TRUE)

# Creation of a matrix corresponding to the 
# conditional sojourn time distributions
kmax &lt;- 6
nparam.matrix &lt;- matrix(c(0.2, 0.1, 0.3, 0.2, 
                          0.2, 0, 0.4, 0.2, 
                          0.1, 0, 0.2, 0.1, 
                          0.5, 0.3, 0.15, 0.05, 
                          0, 0, 0.3, 0.2, 
                          0.1, 0.2, 0.2, 0), 
                        nrow = s, ncol = kmax, byrow = TRUE)

semimarkov &lt;- smmnonparametric(states = states, init = vect.init, ptrans = pij, 
                               type.sojourn = "fj", distr = nparam.matrix)

semimarkov
</code></pre>

<hr>
<h2 id='smmparametric'>Parametric semi-Markov model specification</h2><span id='topic+smmparametric'></span>

<h3>Description</h3>

<p>Creates a parametric model specification for a semi-Markov model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smmparametric(
  states,
  init,
  ptrans,
  type.sojourn = c("fij", "fi", "fj", "f"),
  distr,
  param,
  cens.beg = FALSE,
  cens.end = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smmparametric_+3A_states">states</code></td>
<td>
<p>Vector of state space of length <code class="reqn">s</code>.</p>
</td></tr>
<tr><td><code id="smmparametric_+3A_init">init</code></td>
<td>
<p>Vector of initial distribution of length <code class="reqn">s</code>.</p>
</td></tr>
<tr><td><code id="smmparametric_+3A_ptrans">ptrans</code></td>
<td>
<p>Matrix of transition probabilities of the embedded Markov
chain <code class="reqn">J=(J_m)_{m}</code> of dimension <code class="reqn">(s, s)</code>.</p>
</td></tr>
<tr><td><code id="smmparametric_+3A_type.sojourn">type.sojourn</code></td>
<td>
<p>Type of sojourn time (for more explanations, see Details).</p>
</td></tr>
<tr><td><code id="smmparametric_+3A_distr">distr</code></td>
<td>

<ul>
<li><p> Matrix of distributions of dimension <code class="reqn">(s, s)</code> if <code>type.sojourn = "fij"</code>;
</p>
</li>
<li><p> Vector of distributions of length <code class="reqn">s</code> if <code>type.sojourn = "fi"</code> or <code style="white-space: pre;">&#8288;"fj&#8288;</code>;
</p>
</li>
<li><p> A distribution if <code>type.sojourn = "f"</code>.
</p>
</li></ul>

<p>where the distributions to be used can be one of <code>unif</code>, <code>geom</code>, <code>pois</code>, <code>dweibull</code> or <code>nbinom</code>.</p>
</td></tr>
<tr><td><code id="smmparametric_+3A_param">param</code></td>
<td>
<p>Parameters of sojourn time distributions:
</p>

<ul>
<li><p> Array of distribution parameters of dimension <code class="reqn">(s, s, 2)</code>
(2 corresponds to the maximal number of distribution parameters) if <code>type.sojourn = "fij"</code>;
</p>
</li>
<li><p> Matrix of distribution parameters of dimension <code class="reqn">(s, 2)</code> if <code>type.sojourn = "fi"</code> or <code>"fj"</code>;
</p>
</li>
<li><p> Vector of distribution parameters of length 2 if <code>type.sojourn = "f"</code>.
</p>
</li></ul>

<p>When parameters/values are not necessary (e.g. the Poisson distribution has
only one parameter that is <code class="reqn">\lambda</code>, leave the value <code>NA</code> for the
second parameter in the argument <code>param</code>).</p>
</td></tr>
<tr><td><code id="smmparametric_+3A_cens.beg">cens.beg</code></td>
<td>
<p>Optional. A logical value indicating whether or not
sequences are censored at the beginning.</p>
</td></tr>
<tr><td><code id="smmparametric_+3A_cens.end">cens.end</code></td>
<td>
<p>Optional. A logical value indicating whether or not
sequences are censored at the end.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a semi-Markov model object in the parametric
case, taking into account the type of sojourn time and the censoring
described in references. For the parametric specification, several discrete
distributions are considered (see below).
</p>
<p>The difference between the Markov model and the semi-Markov model concerns
the modeling of the sojourn time. With a Markov chain, the sojourn time
distribution is modeled by a Geometric distribution (in discrete time).
With a semi-Markov chain, the sojourn time can be any arbitrary distribution.
In this package, the available distribution for a semi-Markov model are :
</p>

<ul>
<li><p> Uniform: <code class="reqn">f(x) = 1/n</code> for <code class="reqn">a \le x \le b</code>, with <code class="reqn">n = b-a+1</code>;
</p>
</li>
<li><p> Geometric: <code class="reqn">f(x) = \theta (1-\theta)^x</code> for <code class="reqn">x = 0, 1, 2,\ldots,n</code>, <code class="reqn">0 &lt; \theta &lt; 1</code>, with <code class="reqn">n &gt; 0</code> and <code class="reqn">\theta</code> is the probability of success;
</p>
</li>
<li><p> Poisson: <code class="reqn">f(x) = (\lambda^x exp(-\lambda))/x!</code> for <code class="reqn">x = 0, 1, 2,\ldots,n</code>, with <code class="reqn">n &gt; 0</code> and <code class="reqn">\lambda &gt; 0</code>;
</p>
</li>
<li><p> Discrete Weibull of type 1: <code class="reqn">f(x)=q^{(x-1)^{\beta}}-q^{x^{\beta}}, x=1,2,3,\ldots,n</code>, with <code class="reqn">n &gt; 0</code>, <code class="reqn">q</code> is the first parameter and <code class="reqn">\beta</code> is the second parameter;
</p>
</li>
<li><p> Negative binomial: <code class="reqn">f(x)=\frac{\Gamma(x+\alpha)}{\Gamma(\alpha) x!} p^{\alpha} (1 - p)^x</code>,
for <code class="reqn">x = 0, 1, 2,\ldots,n</code>, <code class="reqn">\Gamma</code> is the Gamma function,
<code class="reqn">\alpha</code> is the parameter of overdispersion and <code class="reqn">p</code> is the
probability of success, <code class="reqn">0 &lt; p &lt; 1</code>;
</p>
</li>
<li><p> Non-parametric.
</p>
</li></ul>

<p>We define :
</p>

<ul>
<li><p> the semi-Markov kernel <code class="reqn">q_{ij}(k) = P( J_{m+1} = j, T_{m+1} - T_{m} = k | J_{m} = i )</code>;
</p>
</li>
<li><p> the transition matrix <code class="reqn">(p_{trans}(i,j))_{i,j} \in states</code> of the embedded Markov chain <code class="reqn">J = (J_m)_m</code>, <code class="reqn">p_{trans}(i,j) = P( J_{m+1} = j | J_m = i )</code>;
</p>
</li>
<li><p> the initial distribution <code class="reqn">\mu_i = P(J_1 = i) = P(Z_1 = i)</code>, <code class="reqn">i \in 1, 2, \dots, s</code>;
</p>
</li>
<li><p> the conditional sojourn time distributions <code class="reqn">(f_{ij}(k))_{i,j} \in states,\ k \in N ,\ f_{ij}(k) = P(T_{m+1} - T_m = k | J_m = i, J_{m+1} = j )</code>,
<code class="reqn">f</code> is specified by the argument <code>param</code> in the parametric case.
</p>
</li></ul>

<p>In this package we can choose different types of sojourn time.
Four options are available for the sojourn times:
</p>

<ul>
<li><p> depending on the present state and on the next state (<code class="reqn">f_{ij}</code>);
</p>
</li>
<li><p> depending only on the present state (<code class="reqn">f_{i}</code>);
</p>
</li>
<li><p> depending only on the next state (<code class="reqn">f_{j}</code>);
</p>
</li>
<li><p> depending neither on the current, nor on the next state (<code class="reqn">f</code>).
</p>
</li></ul>

<p>If  <code>type.sojourn = "fij"</code>, <code>distr</code> is a matrix of dimension <code class="reqn">(s, s)</code>
(e.g., if the row 1 of the 2nd column is <code>"pois"</code>, that is to say we go from
the first state to the second state following a Poisson distribution).
If <code>type.sojourn = "fi"</code> or <code>"fj"</code>, <code>distr</code> must be a vector (e.g., if the
first element of vector is <code>"geom"</code>, that is to say we go from the first
state to any state according to a Geometric distribution).
If <code>type.sojourn = "f"</code>, <code>distr</code> must be one of <code>"unif"</code>, <code>"geom"</code>, <code>"pois"</code>,
<code>"dweibull"</code>, <code>"nbinom"</code> (e.g., if <code>distr</code> is equal to <code>"nbinom"</code>, that is
to say that the sojourn times when going from any state to any state follows
a Negative Binomial distribution).
For the non-parametric case, <code>distr</code> is equal to <code>"nonparametric"</code> whatever
type of sojourn time given.
</p>
<p>If the sequence is censored at the beginning and/or at the end, <code>cens.beg</code>
must be equal to <code>TRUE</code> and/or <code>cens.end</code> must be equal to <code>TRUE</code>.
All the sequences must be censored in the same way.
</p>


<h3>Value</h3>

<p>Returns an object of class <a href="#topic+smmparametric">smmparametric</a>.
</p>


<h3>References</h3>

<p>V. S. Barbu, N. Limnios. (2008). Semi-Markov Chains and Hidden Semi-Markov
Models Toward Applications - Their Use in Reliability and DNA Analysis.
New York: Lecture Notes in Statistics, vol. 191, Springer.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+simulate">simulate</a>, <a href="#topic+fitsmm">fitsmm</a>, <a href="#topic+smmnonparametric">smmnonparametric</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>states &lt;- c("a", "c", "g", "t")
s &lt;- length(states)

# Creation of the initial distribution
vect.init &lt;- c(1 / 4, 1 / 4, 1 / 4, 1 / 4)

# Creation of the transition matrix
pij &lt;- matrix(c(0, 0.2, 0.5, 0.3,
                0.2, 0, 0.3, 0.5,
                0.3, 0.5, 0, 0.2,
                0.4, 0.2, 0.4, 0),
              ncol = s, byrow = TRUE)

# Creation of the distribution matrix

distr.matrix &lt;- matrix(c(NA, "pois", "geom", "nbinom",
                         "geom", NA, "pois", "dweibull",
                         "pois", "pois", NA, "geom",
                         "pois", "geom", "geom", NA),
                       nrow = s, ncol = s, byrow = TRUE)

# Creation of an array containing the parameters
param1.matrix &lt;- matrix(c(NA, 2, 0.4, 4,
                          0.7, NA, 5, 0.6,
                          2, 3, NA, 0.6,
                          4, 0.3, 0.4, NA),
                        nrow = s, ncol = s, byrow = TRUE)

param2.matrix &lt;- matrix(c(NA, NA, NA, 0.6,
                          NA, NA, NA, 0.8,
                          NA, NA, NA, NA,
                          NA, NA, NA, NA),
                        nrow = s, ncol = s, byrow = TRUE)

param.array &lt;- array(c(param1.matrix, param2.matrix), c(s, s, 2))

# Specify the semi-Markov model
semimarkov &lt;- smmparametric(states = states, init = vect.init, ptrans = pij, 
                            type.sojourn = "fij", distr = distr.matrix, 
                            param = param.array)
semimarkov

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
