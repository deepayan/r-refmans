<!DOCTYPE html><html lang="en"><head><title>Help for package casebase</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {casebase}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#absoluteRisk.CompRisk'><p>Compute absolute risks using the fitted hazard function.</p></a></li>
<li><a href='#bmtcrr'><p>Data on transplant patients</p></a></li>
<li><a href='#brcancer'><p>German Breast Cancer Study Group 2</p></a></li>
<li><a href='#checkArgsEventIndicator'><p>Check that Event is in Correct Format</p></a></li>
<li><a href='#CompRisk-class'><p>An S4 class to store the output of fitSmoothHazard</p></a></li>
<li><a href='#confint.absRiskCB'><p>Compute confidence intervals for risks</p></a></li>
<li><a href='#eprchd'><p>Estrogen plus Progestin and the Risk of Coronary Heart Disease (eprchd)</p></a></li>
<li><a href='#ERSPC'><p>Data on the men in the European Randomized Study of Prostate Cancer Screening</p></a></li>
<li><a href='#fitSmoothHazard'><p>Fit smooth-in-time parametric hazard functions.</p></a></li>
<li><a href='#hazardPlot'><p>Plot Fitted Hazard Curve as a Function of Time</p></a></li>
<li><a href='#plot.popTime'><p>Population Time Plot</p></a></li>
<li><a href='#plotHazardRatio'><p>Plot Hazards and Hazard Ratios</p></a></li>
<li><a href='#sampleCaseBase'><p>Create case-base dataset for use in fitting parametric hazard functions</p></a></li>
<li><a href='#simdat'><p>Simulated data under Weibull model with Time-Dependent Treatment Effect</p></a></li>
<li><a href='#support'><p>Study to Understand Prognoses Preferences Outcomes and Risks of Treatment</p>
(SUPPORT)</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fitting Flexible Smooth-in-Time Hazards and Risk Functions via
Logistic and Multinomial Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>0.10.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-08-06</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit flexible and fully parametric hazard regression models to survival data with single event type or multiple 
    competing causes via logistic and multinomial regression. Our formulation allows for arbitrary functional forms 
    of time and its interactions with other predictors for time-dependent hazards and hazard ratios. From the 
    fitted hazard model, we provide functions to readily calculate and plot cumulative incidence and survival 
    curves for a given covariate profile. This approach accommodates any log-linear hazard function of 
    prognostic time, treatment, and covariates, and readily allows for non-proportionality. We also provide 
    a plot method for visualizing incidence density via population time plots. Based on the case-base sampling 
    approach of Hanley and Miettinen (2009) &lt;<a href="https://doi.org/10.2202%2F1557-4679.1125">doi:10.2202/1557-4679.1125</a>&gt;, Saarela and Arjas (2015) &lt;<a href="https://doi.org/10.1111%2Fsjos.12125">doi:10.1111/sjos.12125</a>&gt;, 
    and Saarela (2015) &lt;<a href="https://doi.org/10.1007%2Fs10985-015-9352-x">doi:10.1007/s10985-015-9352-x</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, ggplot2 (&ge; 3.4.0), methods, mgcv, stats,
survival, VGAM</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Suggests:</td>
<td>colorspace, covr, dplyr, eha, glmnet, knitr, lubridate,
progress, rmarkdown, splines, testthat (&ge; 3.0.0), visreg</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://sahirbhatnagar.com/casebase/">https://sahirbhatnagar.com/casebase/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/sahirbhatnagar/casebase/issues">https://github.com/sahirbhatnagar/casebase/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-17 22:57:52 UTC; rstudio</td>
</tr>
<tr>
<td>Author:</td>
<td>Sahir Bhatnagar [aut, cre] (https://sahirbhatnagar.com/),
  Maxime Turgeon [aut] (https://www.maxturgeon.ca/),
  Jesse Islam [aut] (https://www.jesseislam.com/),
  Olli Saarela [aut]
    (https://www.dlsph.utoronto.ca/faculty-profile/saarela-olli/),
  James Hanley [aut] (https://jhanley.biostat.mcgill.ca/)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sahir Bhatnagar &lt;sahir.bhatnagar@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-17 23:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='absoluteRisk.CompRisk'>Compute absolute risks using the fitted hazard function.</h2><span id='topic+absoluteRisk.CompRisk'></span><span id='topic+absoluteRisk'></span><span id='topic+print.absRiskCB'></span><span id='topic+plot.absRiskCB'></span>

<h3>Description</h3>

<p>Using the output of the function <code>fitSmoothHazard</code>, we can compute
absolute risks by integrating the fitted hazard function over a time period
and then converting this to an estimated survival for each individual.
</p>
<p>Plot method for objects returned by the <code>absoluteRisk</code>
function. Current plot types are cumulative incidence and survival
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>absoluteRisk.CompRisk(
  object,
  time,
  newdata,
  method = c("numerical", "montecarlo"),
  nsamp = 100,
  onlyMain = TRUE,
  type = c("CI", "survival"),
  addZero = TRUE
)

absoluteRisk(
  object,
  time,
  newdata,
  method = c("numerical", "montecarlo"),
  nsamp = 100,
  s = c("lambda.1se", "lambda.min"),
  onlyMain = TRUE,
  type = c("CI", "survival"),
  addZero = TRUE,
  ntimes = 100,
  ...
)

## S3 method for class 'absRiskCB'
print(x, ...)

## S3 method for class 'absRiskCB'
plot(
  x,
  ...,
  xlab = "time",
  ylab = ifelse(attr(x, "type") == "CI", "cumulative incidence", "survival probability"),
  type = "l",
  gg = TRUE,
  id.names,
  legend.title
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="absoluteRisk.CompRisk_+3A_object">object</code></td>
<td>
<p>Output of function <code><a href="#topic+fitSmoothHazard">fitSmoothHazard</a></code>.</p>
</td></tr>
<tr><td><code id="absoluteRisk.CompRisk_+3A_time">time</code></td>
<td>
<p>A vector of time points at which we should compute the absolute
risks.</p>
</td></tr>
<tr><td><code id="absoluteRisk.CompRisk_+3A_newdata">newdata</code></td>
<td>
<p>Optionally, a data frame in which to look for variables with
which to predict. If omitted, the mean absolute risk is returned.
Alternatively, if <code>newdata = "typical"</code>, the absolute risk will be
computed at a &quot;typical&quot; covariate profile (see Details).</p>
</td></tr>
<tr><td><code id="absoluteRisk.CompRisk_+3A_method">method</code></td>
<td>
<p>Method used for integration. Defaults to <code>"numerical"</code>,
which uses the trapezoidal rule to integrate over all time points together.
The only other option is <code>"montecarlo"</code>, which implements Monte-Carlo
integration.</p>
</td></tr>
<tr><td><code id="absoluteRisk.CompRisk_+3A_nsamp">nsamp</code></td>
<td>
<p>Maximal number of subdivisions (if <code>method = "numerical"</code>)
or number of sampled points (if <code>method = "montecarlo"</code>).</p>
</td></tr>
<tr><td><code id="absoluteRisk.CompRisk_+3A_onlymain">onlyMain</code></td>
<td>
<p>Logical. For competing risks, should we return absolute risks
only for the main event of interest? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="absoluteRisk.CompRisk_+3A_type">type</code></td>
<td>
<p>Line type. Only used if <code>gg = FALSE</code>. This argument gets passed
to <code><a href="graphics.html#topic+matplot">graphics::matplot()</a></code>. Default: 'l'</p>
</td></tr>
<tr><td><code id="absoluteRisk.CompRisk_+3A_addzero">addZero</code></td>
<td>
<p>Logical. Should we add time = 0 at the beginning of the
output? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="absoluteRisk.CompRisk_+3A_s">s</code></td>
<td>
<p>Value of the penalty parameter lambda at which predictions are
required (for class <code>cv.glmnet</code>).</p>
</td></tr>
<tr><td><code id="absoluteRisk.CompRisk_+3A_ntimes">ntimes</code></td>
<td>
<p>Number of time points (only used if <code>time</code> is missing).</p>
</td></tr>
<tr><td><code id="absoluteRisk.CompRisk_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>matplot</code>. Only used if
<code>gg=FALSE</code>.</p>
</td></tr>
<tr><td><code id="absoluteRisk.CompRisk_+3A_x">x</code></td>
<td>
<p>Fitted object of class <code>absRiskCB</code>. This is the result from the
<code><a href="#topic+absoluteRisk">absoluteRisk()</a></code> function.</p>
</td></tr>
<tr><td><code id="absoluteRisk.CompRisk_+3A_xlab">xlab</code></td>
<td>
<p>xaxis label, Default: 'time'</p>
</td></tr>
<tr><td><code id="absoluteRisk.CompRisk_+3A_ylab">ylab</code></td>
<td>
<p>yaxis label. By default, this will use the <code>"type"</code> attribute of
the <code>absRiskCB</code> object</p>
</td></tr>
<tr><td><code id="absoluteRisk.CompRisk_+3A_gg">gg</code></td>
<td>
<p>Logical for whether the <code>ggplot2</code> package should be used for
plotting. Default: TRUE</p>
</td></tr>
<tr><td><code id="absoluteRisk.CompRisk_+3A_id.names">id.names</code></td>
<td>
<p>Optional character vector used as legend key when <code>gg=TRUE</code>.
If missing, defaults to V1, V2, ...</p>
</td></tr>
<tr><td><code id="absoluteRisk.CompRisk_+3A_legend.title">legend.title</code></td>
<td>
<p>Optional character vector of the legend title. Only used
if <code>gg = FALSE</code>. Default is <code>'ID'</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>newdata = "typical"</code>, we create a typical covariate profile for the
absolute risk computation. This means that we take the median for numerical
and date variables, and we take the most common level for factor variables.
</p>
<p>In general, the output will include a column corresponding to the provided
time points. Some modifications of the <code>time</code> vector are done:
<code>time=0</code> is added, the time points are ordered, and duplicates are
removed. All these modifications simplify the computations and give an output
that can easily be used to plot risk curves.
</p>
<p>If there is no competing risk, the output is a matrix where each column
corresponds to the several covariate profiles, and where each row corresponds
to a time point. If there are competing risks, the output will be a
3-dimensional array, with the third dimension corresponding to the different
events.
</p>
<p>The numerical method should be good enough in most situation, but Monte Carlo
integration can give more accurate results when the estimated hazard function
is not smooth (e.g. when modeling with time-varying covariates).
</p>


<h3>Value</h3>

<p>If <code>time</code> was provided, returns the estimated absolute risk for
the user-supplied covariate profiles. This will be stored in a matrix or a
higher dimensional array, depending on the input (see details). If both
<code>time</code> and <code>newdata</code> are missing, returns the original data
with a new column containing the risk estimate at failure times.
</p>
<p>A plot of the cumulative incidence or survival curve
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+matplot">matplot</a></code>,
<code><a href="#topic+absoluteRisk">absoluteRisk</a></code>,
<code><a href="data.table.html#topic+as.data.table">as.data.table</a></code>, <code><a href="data.table.html#topic+setattr">setattr</a></code>,
<code><a href="data.table.html#topic+melt.data.table">melt.data.table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate censored survival data for two outcome types
library(data.table)
set.seed(12345)
nobs &lt;- 1000
tlim &lt;- 20

# simulation parameters
b1 &lt;- 200
b2 &lt;- 50

# event type 0-censored, 1-event of interest, 2-competing event
# t observed time/endpoint
# z is a binary covariate
DT &lt;- data.table(z = rbinom(nobs, 1, 0.5))
DT[,`:=` ("t_event" = rweibull(nobs, 1, b1),
          "t_comp" = rweibull(nobs, 1, b2))]
DT[,`:=`("event" = 1 * (t_event &lt; t_comp) + 2 * (t_event &gt;= t_comp),
         "time" = pmin(t_event, t_comp))]
DT[time &gt;= tlim, `:=`("event" = 0, "time" = tlim)]

out_linear &lt;- fitSmoothHazard(event ~ time + z, DT, ratio = 10)

linear_risk &lt;- absoluteRisk(out_linear, time = 10,
                            newdata = data.table("z" = c(0,1)))
# Plot CI curves----
library(ggplot2)
data("brcancer")
mod_cb_tvc &lt;- fitSmoothHazard(cens ~ estrec*log(time) +
                                horTh +
                                age +
                                menostat +
                                tsize +
                                tgrade +
                                pnodes +
                                progrec,
                              data = brcancer,
                              time = "time", ratio = 1)
smooth_risk_brcancer &lt;- absoluteRisk(object = mod_cb_tvc,
                                     newdata = brcancer[c(1,50),])

class(smooth_risk_brcancer)
plot(smooth_risk_brcancer)
</code></pre>

<hr>
<h2 id='bmtcrr'>Data on transplant patients</h2><span id='topic+bmtcrr'></span>

<h3>Description</h3>

<p>Data on patients who underwent haematopoietic stem cell transplantation for
acute leukemia.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmtcrr
</code></pre>


<h3>Format</h3>

<p>A dataframe with 177 observations and 7 variables: </p>

<dl>
<dt>Sex</dt><dd><p>Gender of the individual</p>
</dd> <dt>D</dt><dd><p>Disease: lymphoblastic or
myeloblastic leukemia, abbreviated as ALL and AML, respectively</p>
</dd>
<dt>Phase</dt><dd><p>Phase at transplant (Relapse, CR1, CR2, CR3)</p>
</dd> <dt>Age</dt><dd><p>Age
at the beginning of follow-up</p>
</dd> <dt>Status</dt><dd><p>Status indicator: 0=censored,
1=relapse, 2=competing event</p>
</dd> <dt>Source</dt><dd><p>Source of stem cells: bone
marrow and peripheral blood, coded as BM+PB, or peripheral blood only,
coded as PB</p>
</dd> <dt>ftime</dt><dd><p>Failure time in months</p>
</dd> </dl>



<h3>References</h3>

<p>Scrucca L, Santucci A, Aversa F. Competing risk analysis using R:
an easy guide for clinicians. Bone Marrow Transplant. 2007 Aug;40(4):381-7.
<a href="https://doi.org/10.1038/sj.bmt.1705727">doi:10.1038/sj.bmt.1705727</a>.
</p>

<hr>
<h2 id='brcancer'>German Breast Cancer Study Group 2</h2><span id='topic+brcancer'></span>

<h3>Description</h3>

<p>A data frame containing the observations from the  GBSG2 study.
This is taken almost verbatim from the <code>TH.data</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brcancer
</code></pre>


<h3>Format</h3>

<p>This data frame contains the observations of 686 women: </p>

<dl>
<dt>horTh</dt><dd><p>hormonal therapy, a factor at two levels <code>no</code> and
<code>yes</code>.</p>
</dd> <dt>hormon</dt><dd><p>numeric version of <code>horTh</code></p>
</dd> <dt>age</dt><dd><p>of the
patients in years.</p>
</dd> <dt>menostat</dt><dd><p>menopausal status, a factor at two
levels <code>pre</code> (premenopausal) and <code>post</code> (postmenopausal).</p>
</dd>
<dt>meno</dt><dd><p>Numeric version of <code>menostat</code></p>
</dd> <dt>tsize</dt><dd><p>tumor size (in
mm).</p>
</dd> <dt>tgrade</dt><dd><p>tumor grade, a ordered factor at levels <code>I &lt; II &lt;
  III</code>.</p>
</dd> <dt>pnodes</dt><dd><p>number of positive nodes.</p>
</dd> <dt>progrec</dt><dd><p>progesterone
receptor (in fmol).</p>
</dd> <dt>estrec</dt><dd><p>estrogen receptor (in fmol).</p>
</dd>
<dt>time</dt><dd><p>recurrence free survival time (in days).</p>
</dd> <dt>cens</dt><dd><p>censoring
indicator (0- censored, 1- event).</p>
</dd> </dl>



<h3>Source</h3>

<p>Torsten Hothorn (2019). TH.data: TH's Data Archive. R package version
1.0-10. https://CRAN.R-project.org/package=TH.data
</p>


<h3>References</h3>

<p>M. Schumacher, G. Basert, H. Bojar,  K. Huebner, M. Olschewski,
W. Sauerbrei, C. Schmoor, C. Beyerle, R.L.A. Neumann and H.F. Rauschecker
for the German Breast Cancer Study Group (1994), Randomized <code class="reqn">2\times2</code>
trial evaluating hormonal treatment and the duration of chemotherapy in
node-positive breast cancer patients. <em>Journal of Clinical Oncology</em>,
<b>12</b>, 2086&ndash;2093.
</p>

<hr>
<h2 id='checkArgsEventIndicator'>Check that Event is in Correct Format</h2><span id='topic+checkArgsEventIndicator'></span>

<h3>Description</h3>

<p>Checks for event categories and gives a warning message indicating which
level is assumed to be the reference level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkArgsEventIndicator(data, event, censored.indicator)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkArgsEventIndicator_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> or <code>data.table</code> containing the source
dataset.</p>
</td></tr>
<tr><td><code id="checkArgsEventIndicator_+3A_event">event</code></td>
<td>
<p>a character string giving the name of the event variable
contained in <code>data</code>. See Details. If <code>event</code> is a numeric
variable, then 0 needs to represent a censored observation, 1 needs to be
the event of interest. Integers 2, 3, ... and so on are treated as
competing events. If event is a <code>factor</code> or <code>character</code> and
<code>censored.indicator</code> is not specified, this function will assume the
reference level is the censored indicator</p>
</td></tr>
<tr><td><code id="checkArgsEventIndicator_+3A_censored.indicator">censored.indicator</code></td>
<td>
<p>a character string of length 1 indicating which
value in <code>event</code> is the censored. This function will use
<code><a href="stats.html#topic+relevel">relevel</a></code> to set <code>censored.indicator</code> as the
reference level. This argument is ignored if the <code>event</code> variable is a
numeric</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length two. The first element is the factored event, and
the second element is the numeric representation of the event
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("survival", quietly = TRUE)) {
library(survival) # for veteran data
checkArgsEventIndicator(data = veteran, event = "celltype",
                        censored.indicator = "smallcell")
checkArgsEventIndicator(data = veteran, event = "status")
}
data("bmtcrr") # from casebase
checkArgsEventIndicator(data = bmtcrr, event = "Sex",
                        censored.indicator = "M")
checkArgsEventIndicator(data = bmtcrr, event = "D",
                        censored.indicator = "AML")
checkArgsEventIndicator(data = bmtcrr, event = "Status")
</code></pre>

<hr>
<h2 id='CompRisk-class'>An S4 class to store the output of fitSmoothHazard</h2><span id='topic+CompRisk-class'></span><span id='topic+CompRisk'></span><span id='topic+summary'></span><span id='topic+summary+2CCompRisk-method'></span>

<h3>Description</h3>

<p>This class inherits from <code>vglm-class</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary(object, ...)

## S4 method for signature 'CompRisk'
summary(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CompRisk-class_+3A_object">object</code></td>
<td>
<p>Object of class <code>CompRisk</code></p>
</td></tr>
<tr><td><code id="CompRisk-class_+3A_...">...</code></td>
<td>
<p>Extra parameters</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>originalData</code></dt><dd><p>Data.frame containing the original data (i.e. before
case-base sampling). This is used by the <code><a href="#topic+absoluteRisk">absoluteRisk</a></code>
function.</p>
</dd>
<dt><code>typeEvents</code></dt><dd><p>Numeric factor which encodes the type of events being
considered (including censoring).</p>
</dd>
<dt><code>timeVar</code></dt><dd><p>Character string giving the name of the time variable, as
appearing in <code>originalData</code></p>
</dd>
<dt><code>eventVar</code></dt><dd><p>Character string giving the name of the event variable, as
appearing in <code>originalData</code></p>
</dd>
</dl>

<hr>
<h2 id='confint.absRiskCB'>Compute confidence intervals for risks</h2><span id='topic+confint.absRiskCB'></span>

<h3>Description</h3>

<p>This function uses parametric bootstrap to compute confidence intervals for
the risk estimates. Since it relies on MLE theory for the validity of these
intervals, this function only works for <code>fit_obj</code> that was fitted using
<code>family = "glm"</code> (i.e. the default).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'absRiskCB'
confint(object, parm, level = 0.95, nboot = 500, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.absRiskCB_+3A_object">object</code></td>
<td>
<p>Output of function <code>absoluteRisk</code>.</p>
</td></tr>
<tr><td><code id="confint.absRiskCB_+3A_parm">parm</code></td>
<td>
<p>Output of function <code>fitSmoothHazard</code> that was used to
compute <code>object</code>.</p>
</td></tr>
<tr><td><code id="confint.absRiskCB_+3A_level">level</code></td>
<td>
<p>The confidence level required.</p>
</td></tr>
<tr><td><code id="confint.absRiskCB_+3A_nboot">nboot</code></td>
<td>
<p>The number of bootstrap samples to use.</p>
</td></tr>
<tr><td><code id="confint.absRiskCB_+3A_...">...</code></td>
<td>
<p>Additional arguments for methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the package <code>progress</code> is available, the function also reports on
progress of the sampling (which can take some time if there are many
covariate profiles and/or time points).
</p>


<h3>Value</h3>

<p>If there is only one covariate profile, the function returns a matrix
with the time points, the risk estimates, and the confidence intervals. If
there are more than one covariate profile, the function returns a list with
three components.
</p>

<hr>
<h2 id='eprchd'>Estrogen plus Progestin and the Risk of Coronary Heart Disease (eprchd)</h2><span id='topic+eprchd'></span>

<h3>Description</h3>

<p>This data was reconstructed from the curves in figure 2
(Manson 2003).Compares placebo to hormone treatment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eprchd
</code></pre>


<h3>Format</h3>

<p>A dataframe with 16608 observations and 3 variables:
</p>
 <dl>
<dt>time</dt><dd><p> Years (continuous) </p>
</dd> <dt>status</dt><dd>
<p>0=censored, 1=event </p>
</dd> <dt>treatment</dt><dd><p> placebo,
estPro</p>
</dd></dl>



<h3>References</h3>

<p>Manson, J. E., Hsia, J., Johnson, K. C., Rossouw, J. E., Assaf,
A. R., Lasser, N. L., ... &amp; Strickland, O. L. (2003). Estrogen plus
progestin and the risk of coronary heart disease. New England Journal of
Medicine, 349(6), 523-534.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("eprchd")
fit &lt;- fitSmoothHazard(status ~ time + treatment, data = eprchd)
</code></pre>

<hr>
<h2 id='ERSPC'>Data on the men in the European Randomized Study of Prostate Cancer Screening</h2><span id='topic+ERSPC'></span>

<h3>Description</h3>

<p>This data set lists the individual observations for 159,893 men
in the core age group between the ages of 55 and 69 years at entry.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ERSPC
</code></pre>


<h3>Format</h3>

<p>A data frame with 159,893 observations on the following 3 variables:
</p>
 <dl>
<dt>ScrArm</dt><dd><p>Whether in Screening Arm (1) or non-Screening arm
(0) (<code>numeric</code>)</p>
</dd> <dt>Follow.Up.Time</dt><dd><p>The time, measured in years
from randomization, at which follow-up was terminated</p>
</dd>
<dt>DeadOfPrCa</dt><dd><p>Whether follow-up was terminated by Death from Prostate
Cancer (1) or by death from other causes, or administratively (0)</p>
</dd> </dl>



<h3>Details</h3>

<p>The men were recruited from seven European countries (centers). Each
centre began recruitment at a different time, ranging from 1991 to 1998.
The last entry was in December 2003. The uniform censoring date was
December 31, 2006. The randomization ratio was 1:1 in six of the seven
centres. In the seventh, Finland, the size of the screening group was fixed
at 32,000 subjects. Because the whole birth cohort underwent randomization,
this led to a ratio, for the screening group to the control group, of
approximately 1 to 1.5, and to the non-screening arm being larger than the
screening arm.
</p>
<p>The randomization of the Finnish cohorts were carried out on January 1 of
each of the 4 years 1996 to 1999. This, coupled with the uniform December
31 2006 censoring date, lead to large numbers of men with exactly 11, 10, 9
or 8 years of follow-up.
</p>
<p>Tracked backwards in time (i.e. from right to left), the Population-Time
plot shows the recruitment pattern from its beginning in 1991, and in
particular the Jan 1 entries in successive years.
</p>
<p>Tracked forwards in time (i.e. from left to right), the plot for the first
3 years shows attrition due entirely to death (mainly from other causes).
Since the Swedish and Belgian centres were the last to close their
recruitment - in December 2003 - the minimum potential follow-up is three
years. Tracked further forwards in time (i.e. after year 3) the attrition
is a combination of deaths and staggered entries.
</p>


<h3>Source</h3>

<p>The individual censored values were recovered by James Hanley from
the Postcript code that the NEJM article (Schroder et al., 2009) used to
render Figure 2 (see Liu et al., 2014, for details). The uncensored values
were more difficult to recover exactly, as the 'jumps' in the Nelson-Aalen
plot are not as monotonic as first principles would imply. Thus, for each
arm, the numbers of deaths in each 1-year time-bin were estimated from the
differences in the cumulative incidence curves at years 1, 2, ... , applied
to the numbers at risk within the time-interval. The death times were then
distributed at random within each bin.
</p>
<p>The interested reader can 'see' the large numbers of individual censored
values by zooming in on the original pdf Figure, and watching the Figure
being re-rendered, or by printing the graph and watching the printer
'pause' while it superimposes several thousand dots (censored values) onto
the curve. Watching these is what prompted JH to look at what lay 'behind'
the curve. The curve itself can be drawn using fewer than 1000 line
segments, and unless on peers into the PostScript) the almost 160,000 dots
generated by Stata are invisible.
</p>


<h3>References</h3>

<p>Liu Z, Rich B, Hanley JA. Recovering the raw data behind a
non-parametric survival curve. Systematic Reviews 2014; 3:151.
<a href="https://doi.org/10.1186/2046-4053-3-151">doi:10.1186/2046-4053-3-151</a>.
</p>
<p>Schroder FH, et al., for the ERSPC Investigators. Screening and
Prostate-Cancer Mortality in a Randomized European Study. N Engl J Med
2009; 360:1320-8. <a href="https://doi.org/10.1056/NEJMoa0810084">doi:10.1056/NEJMoa0810084</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("ERSPC")
set.seed(12345)
pt_object_strat &lt;- casebase::popTime(ERSPC[sample(1:nrow(ERSPC), 10000),],
                                     event = "DeadOfPrCa",
                                     exposure = "ScrArm")

plot(pt_object_strat,
     facet.params = list(ncol = 2))
</code></pre>

<hr>
<h2 id='fitSmoothHazard'>Fit smooth-in-time parametric hazard functions.</h2><span id='topic+fitSmoothHazard'></span><span id='topic+fitSmoothHazard.fit'></span><span id='topic+prepareX'></span>

<h3>Description</h3>

<p>Miettinen and Hanley (2009) explained how case-base sampling can be used to
estimate smooth-in-time parametric hazard functions. The idea is to sample
person-moments, which may or may not correspond to an event, and then fit the
hazard using logistic regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitSmoothHazard(
  formula,
  data,
  time,
  family = c("glm", "gam", "glmnet"),
  censored.indicator,
  ratio = 100,
  ...
)

fitSmoothHazard.fit(
  x,
  y,
  formula_time,
  time,
  event,
  family = c("glm", "glmnet"),
  censored.indicator,
  ratio = 100,
  ...
)

prepareX(formula, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitSmoothHazard_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that can be coerced to
that class): a symbolic description of the model to be fitted. The details
of model specification are given under Details.</p>
</td></tr>
<tr><td><code id="fitSmoothHazard_+3A_data">data</code></td>
<td>
<p>a data frame, list or environment containing the variables in the
model. If not found in data, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>fitSmoothHazard</code> is called.</p>
</td></tr>
<tr><td><code id="fitSmoothHazard_+3A_time">time</code></td>
<td>
<p>a character string giving the name of the time variable. See
Details.</p>
</td></tr>
<tr><td><code id="fitSmoothHazard_+3A_family">family</code></td>
<td>
<p>a character string specifying the family of regression models
used to fit the hazard.</p>
</td></tr>
<tr><td><code id="fitSmoothHazard_+3A_censored.indicator">censored.indicator</code></td>
<td>
<p>a character string of length 1 indicating which
value in <code>event</code> is the censored. This function will use
<code><a href="stats.html#topic+relevel">relevel</a></code> to set <code>censored.indicator</code> as the
reference level. This argument is ignored if the <code>event</code> variable is a
numeric.</p>
</td></tr>
<tr><td><code id="fitSmoothHazard_+3A_ratio">ratio</code></td>
<td>
<p>integer, giving the ratio of the size of the base series to that
of the case series. Defaults to 100.</p>
</td></tr>
<tr><td><code id="fitSmoothHazard_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to fitting functions (e.g.
<code>glm</code>, <code>glmnet</code>, <code>gam</code>).</p>
</td></tr>
<tr><td><code id="fitSmoothHazard_+3A_x">x</code></td>
<td>
<p>Matrix containing covariates.</p>
</td></tr>
<tr><td><code id="fitSmoothHazard_+3A_y">y</code></td>
<td>
<p>Matrix containing two columns: one corresponding to time, the other
to the event type.</p>
</td></tr>
<tr><td><code id="fitSmoothHazard_+3A_formula_time">formula_time</code></td>
<td>
<p>A formula describing how the hazard depends on time.
Defaults to linear.</p>
</td></tr>
<tr><td><code id="fitSmoothHazard_+3A_event">event</code></td>
<td>
<p>a character string giving the name of the event variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The object <code>data</code> should either be the output of the function
<code><a href="#topic+sampleCaseBase">sampleCaseBase</a></code> or the source dataset on which case-base
sampling will be performed. In the latter case, it is assumed that
<code>data</code> contains the two columns corresponding to the supplied time and
event variables. The variable <code>time</code> is used for the sampling the base
series, and therefore it should represent the time variable on its original
(i.e. non transformed) scale. If <code>time</code> is missing, the function looks
for a column named <code>"time"</code> in the data. Note that the event variable is
inferred from <code>formula</code>, since it is the left hand side.
</p>
<p>For single-event survival analysis, it is also possible to fit the hazard
function using <code>glmnet</code> or <code>gam</code>. The choice of fitting family is
controlled by the parameter <code>family</code>. The default value is <code>glm</code>,
which corresponds to logistic regression. For competing risk analysis, only
<code>glm</code> and <code>glmnet</code> are allowed.
</p>
<p>We also provide a matrix interface through <code>fitSmoothHazard.fit</code>, which
mimics <code>glm.fit</code>. This is mostly convenient for <code>family =
"glmnet"</code>, since a formula interface becomes quickly cumbersome as the number
of variables increases. In this setting, the matrix <code>y</code> should have two
columns and contain the time and event variables (e.g. like the output of
<code>survival::Surv</code>). We need this linear function of time in order to
perform case-base sampling. Therefore, nonlinear functions of time should be
specified as a one-sided formula through the argument <code>formula_time</code>
(the left-hand side is always ignored).
</p>
<p><code>prepareX</code> is a slightly modified version of the same function from
the <code>glmnet</code> package. It can be used to convert a data.frame to a matrix
with categorical variables converted to dummy variables using one-hot
encoding
</p>


<h3>Value</h3>

<p>An object of <code>glm</code> and <code>lm</code> when there is only one event of
interest, or of class <code><a href="#topic+CompRisk">CompRisk</a></code>, which inherits from
<code>vglm</code>, for a competing risk analysis. As such, functions like
<code>summary</code>, <code>deviance</code> and <code>coefficients</code> give familiar
results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate censored survival data for two outcome types from exponential
# distributions
library(data.table)
nobs &lt;- 500
tlim &lt;- 20

# simulation parameters
b1 &lt;- 200
b2 &lt;- 50

# event type 0-censored, 1-event of interest, 2-competing event
# t observed time/endpoint
# z is a binary covariate
DT &lt;- data.table(z = rbinom(nobs, 1, 0.5))
DT[, `:=`(
  "t_event" = rweibull(nobs, 1, b1),
  "t_comp" = rweibull(nobs, 1, b2)
)]
DT[, `:=`(
  "event" = 1 * (t_event &lt; t_comp) + 2 * (t_event &gt;= t_comp),
  "time" = pmin(t_event, t_comp)
)]
DT[time &gt;= tlim, `:=`("event" = 0, "time" = tlim)]

out_linear &lt;- fitSmoothHazard(event ~ time + z, DT, ratio = 10)
out_log &lt;- fitSmoothHazard(event ~ log(time) + z, DT, ratio = 10)

# Use GAMs
library(mgcv)
DT[event == 2, event := 1]
out_gam &lt;- fitSmoothHazard(event ~ s(time) + z, DT,
                           ratio = 10, family = "gam")
</code></pre>

<hr>
<h2 id='hazardPlot'>Plot Fitted Hazard Curve as a Function of Time</h2><span id='topic+hazardPlot'></span>

<h3>Description</h3>

<p>Visualize estimated hazard curves as a function of time with
confidence intervals. This function takes as input, the result from the
<code><a href="#topic+fitSmoothHazard">fitSmoothHazard()</a></code> function. The user can also specify a
sequence of times at which to estimate the hazard function. These plots are
useful to visualize the non-proportional hazards, i.e., time dependent
interactions with a covariate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hazardPlot(
  object,
  newdata,
  type = c("hazard"),
  xlab = NULL,
  breaks = 100,
  ci.lvl = 0.95,
  ylab = NULL,
  line.col = 1,
  ci.col = "grey",
  lty = par("lty"),
  add = FALSE,
  ci = !add,
  rug = !add,
  s = c("lambda.1se", "lambda.min"),
  times = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hazardPlot_+3A_object">object</code></td>
<td>
<p>Fitted object of class <code>glm</code>, <code>gam</code>, <code>cv.glmnet</code> or <code>gbm</code>. This
is the result from the <code><a href="#topic+fitSmoothHazard">fitSmoothHazard()</a></code> function.</p>
</td></tr>
<tr><td><code id="hazardPlot_+3A_newdata">newdata</code></td>
<td>
<p>A data frame in which to look for variables with which to
predict. This is required and must contain all the variables used in the
model. Only one covariate profile can be used. If more than one row is
provided, only the first row will be used.</p>
</td></tr>
<tr><td><code id="hazardPlot_+3A_type">type</code></td>
<td>
<p>Type of plot. Currently, only &quot;hazard&quot; has been implemented.
Default: c(&quot;hazard&quot;)</p>
</td></tr>
<tr><td><code id="hazardPlot_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label. Default: the name of the time variable from the
fitted <code>object</code>.</p>
</td></tr>
<tr><td><code id="hazardPlot_+3A_breaks">breaks</code></td>
<td>
<p>Number of points at which to estimate the hazard. This argument
is only used if argument <code>times=NULL</code>. This function will calculate a
sequence of times between the minimum and maximum of observed event times.
Default: 100.</p>
</td></tr>
<tr><td><code id="hazardPlot_+3A_ci.lvl">ci.lvl</code></td>
<td>
<p>Confidence level. Must be in (0,1), Default: 0.95</p>
</td></tr>
<tr><td><code id="hazardPlot_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label. Default: NULL which means the function will put
sensible defaults.</p>
</td></tr>
<tr><td><code id="hazardPlot_+3A_line.col">line.col</code></td>
<td>
<p>Line color, Default: 1. See <code><a href="graphics.html#topic+par">graphics::par()</a></code> for details.</p>
</td></tr>
<tr><td><code id="hazardPlot_+3A_ci.col">ci.col</code></td>
<td>
<p>Confidence band color. Only used if argument <code>ci=TRUE</code>,
Default: 'grey'</p>
</td></tr>
<tr><td><code id="hazardPlot_+3A_lty">lty</code></td>
<td>
<p>Line type. See <code><a href="graphics.html#topic+par">graphics::par()</a></code> for details, Default: par(&quot;lty&quot;)</p>
</td></tr>
<tr><td><code id="hazardPlot_+3A_add">add</code></td>
<td>
<p>Logical; if TRUE add to an already existing plot; Default: FALSE</p>
</td></tr>
<tr><td><code id="hazardPlot_+3A_ci">ci</code></td>
<td>
<p>Logical; if TRUE confidence bands are calculated. Only available
for <code>family="glm"</code> and <code>family="gam"</code>, Default: !add</p>
</td></tr>
<tr><td><code id="hazardPlot_+3A_rug">rug</code></td>
<td>
<p>Logical. Adds a rug representation (1-d plot) of the event times
(only for <code>status=1</code>), Default: !add</p>
</td></tr>
<tr><td><code id="hazardPlot_+3A_s">s</code></td>
<td>
<p>Value of the penalty parameter lambda at which predictions are
required (for class <code>cv.glmnet</code> only). Only the first entry will be
used if more than one numeric value is provided, Default: c(&quot;lambda.1se&quot;,
&quot;lambda.min&quot;)</p>
</td></tr>
<tr><td><code id="hazardPlot_+3A_times">times</code></td>
<td>
<p>Vector of numeric values at which the hazard should be
calculated. Default: NULL which means this function will use the minimum
and maximum of observed event times with the <code>breaks</code> argument.</p>
</td></tr>
<tr><td><code id="hazardPlot_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="graphics.html#topic+matplot">graphics::matplot()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an earlier version of a function to plot hazards. We
recommend instead using the plot method for objects returned by
<code><a href="#topic+fitSmoothHazard">fitSmoothHazard()</a></code>. See <code><a href="#topic+plot.singleEventCB">plot.singleEventCB()</a></code>.
</p>


<h3>Value</h3>

<p>a plot of the hazard function and a data.frame of original data used
in the fitting along with the data used to create the plots including
<code>predictedhazard</code> which is the predicted hazard for a given covariate
pattern and time <code>predictedloghazard</code> is the predicted hazard on the log
scale. <code>lowerbound</code> and <code>upperbound</code> are the lower and upper confidence
interval bounds on the hazard scale (i.e. used to plot the confidence
bands). <code>standarderror</code> is the standard error of the log hazard (only if
<code>family="glm"</code> or <code>family="gam"</code>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitSmoothHazard">fitSmoothHazard()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("simdat")
mod_cb &lt;- fitSmoothHazard(status ~ trt * eventtime,
                                    time = "eventtime",
                                    data = simdat[1:200,],
                                    ratio = 1,
                                    family = "glm")

results0 &lt;- hazardPlot(object = mod_cb, newdata = data.frame(trt = 0),
           ci.lvl = 0.95, ci = FALSE, lty = 1, line.col = 1, lwd = 2)
head(results0)
hazardPlot(object = mod_cb, newdata = data.frame(trt = 1), ci = FALSE,
           ci.lvl = 0.95, add = TRUE, lty = 2, line.col = 2, lwd = 2)
legend("topleft", c("trt=0","trt=1"),lty=1:2,col=1:2,bty="y", lwd = 2)
</code></pre>

<hr>
<h2 id='plot.popTime'>Population Time Plot</h2><span id='topic+plot.popTime'></span><span id='topic+popTime'></span><span id='topic+checkArgsTimeEvent'></span>

<h3>Description</h3>

<p><code>plot</code> method for objects of class <code>popTime</code>
</p>
<p>Create a data frame for population time plots to give a visual representation
of incidence density
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'popTime'
plot(
  x,
  ...,
  xlab = "Follow-up time",
  ylab = "Population",
  add.case.series = TRUE,
  add.base.series = FALSE,
  add.competing.event = FALSE,
  casebase.theme = TRUE,
  ribbon.params = list(),
  case.params = list(),
  base.params = list(),
  competing.params = list(),
  color.params = list(),
  fill.params = list(),
  theme.params = list(),
  facet.params = list(),
  ratio = 1,
  censored.indicator,
  comprisk = FALSE,
  legend = TRUE,
  ncol,
  legend.position,
  line.width,
  line.colour,
  point.size,
  point.colour
)

popTime(data, time, event, censored.indicator, exposure, percentile_number)

checkArgsTimeEvent(data, time, event)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.popTime_+3A_x">x</code></td>
<td>
<p>an object of class <code>popTime</code> or <code>popTimeExposure</code>.</p>
</td></tr>
<tr><td><code id="plot.popTime_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="plot.popTime_+3A_xlab">xlab</code>, <code id="plot.popTime_+3A_ylab">ylab</code></td>
<td>
<p>The title of the respective axis. Default: 'Follow-up time'
for xlab and 'Population' for ylab</p>
</td></tr>
<tr><td><code id="plot.popTime_+3A_add.case.series">add.case.series</code></td>
<td>
<p>Logical indicating if the case series should be added
to the plot. Default: TRUE</p>
</td></tr>
<tr><td><code id="plot.popTime_+3A_add.base.series">add.base.series</code></td>
<td>
<p>Logical indicating if the base series should be added
to the plot. Default: FALSE</p>
</td></tr>
<tr><td><code id="plot.popTime_+3A_add.competing.event">add.competing.event</code></td>
<td>
<p>Logical indicating if the competing event should
be added to the plot. Default: FALSE</p>
</td></tr>
<tr><td><code id="plot.popTime_+3A_casebase.theme">casebase.theme</code></td>
<td>
<p>Logical indication if the casebase theme be used. The
casebase theme uses <code><a href="ggplot2.html#topic+ggtheme">ggplot2::theme_minimal()</a></code>. Default: TRUE.</p>
</td></tr>
<tr><td><code id="plot.popTime_+3A_ribbon.params">ribbon.params</code></td>
<td>
<p>A list containing arguments that are passed to
<code><a href="ggplot2.html#topic+geom_ribbon">ggplot2::geom_ribbon()</a></code> which is used to plot the
population-time area. These arguments will override the function defaults.
For example, you can set <code>ribbon.params = list(colour = 'green')</code> if
you want the area to be green.</p>
</td></tr>
<tr><td><code id="plot.popTime_+3A_case.params">case.params</code>, <code id="plot.popTime_+3A_base.params">base.params</code>, <code id="plot.popTime_+3A_competing.params">competing.params</code></td>
<td>
<p>A list containing arguments
that are passed to <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code> which is used to plot
the case series, base series, competing events. These arguments will
override the function defaults. For example, you can set <code>case.params
  = list(size = 1.5)</code> if you want to increase the point size for the case
series points. Note: do not use this argument to change the color of the
points. Doing so will result in unexpected results for the legend. See the
<code>color.params</code> and <code>fill.params</code> arguments, if you want to change
the color of the points.</p>
</td></tr>
<tr><td><code id="plot.popTime_+3A_color.params">color.params</code></td>
<td>
<p>A list containing arguments that are passed to
<code><a href="ggplot2.html#topic+scale_manual">ggplot2::scale_color_manual()</a></code> which is used to plot the legend.
Only used if <code>legend=TRUE</code>. These arguments will override the function
defaults. Use this argument if you want to change the color of the points.
See examples for more details.</p>
</td></tr>
<tr><td><code id="plot.popTime_+3A_fill.params">fill.params</code></td>
<td>
<p>A list containing arguments that are passed to
<code><a href="ggplot2.html#topic+scale_manual">ggplot2::scale_fill_manual()</a></code> which is used to plot the legend.
Only used if <code>legend=TRUE</code>. These arguments will override the function
defaults. Use this argument if you want to change the color of the points.
See examples for more details.</p>
</td></tr>
<tr><td><code id="plot.popTime_+3A_theme.params">theme.params</code></td>
<td>
<p>A list containing arguments that are passed to
<code><a href="ggplot2.html#topic+theme">ggplot2::theme()</a></code>. For example <code>theme.params =
  list(legend.position = 'none')</code>.</p>
</td></tr>
<tr><td><code id="plot.popTime_+3A_facet.params">facet.params</code></td>
<td>
<p>A list containing arguments that are passed to
<code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code> which is used to create facet plots. Only
used if plotting exposure stratified population time plots. These arguments
will override the function defaults.</p>
</td></tr>
<tr><td><code id="plot.popTime_+3A_ratio">ratio</code></td>
<td>
<p>If <code>add.base.series=TRUE</code>, integer, giving the ratio of the
size of the base series to that of the case series. This argument is passed
to the <code><a href="#topic+sampleCaseBase">sampleCaseBase</a></code> function. Default: 10.</p>
</td></tr>
<tr><td><code id="plot.popTime_+3A_censored.indicator">censored.indicator</code></td>
<td>
<p>a character string of length 1 indicating which
value in <code>event</code> is the censored. This function will use
<code><a href="stats.html#topic+relevel">relevel</a></code> to set <code>censored.indicator</code> as the
reference level. This argument is ignored if the <code>event</code> variable is a
numeric</p>
</td></tr>
<tr><td><code id="plot.popTime_+3A_comprisk">comprisk</code></td>
<td>
<p>If <code>add.base.series=TRUE</code>, logical indicating whether we
have multiple event types and that we want to consider some of them as
competing risks. This argument is passed to the
<code><a href="#topic+sampleCaseBase">sampleCaseBase</a></code> function. Note: should be <code>TRUE</code> if your
data has competing risks, even if you don't want to add competing risk
points (<code>add.competing.event=FALSE</code>). Default: FALSE</p>
</td></tr>
<tr><td><code id="plot.popTime_+3A_legend">legend</code></td>
<td>
<p>Logical indicating if a legend should be added to the plot.
Note that if you want to change the colors of the points, through the
<code>color.params</code> and <code>fill.params</code> arguments, then set
<code>legend=TRUE</code>. If you want to change the color of the points but not
have a legend, then set <code>legend=TRUE</code> and <code>theme.params =
  list(legend.position = 'none'</code>. Default: FALSE</p>
</td></tr>
<tr><td><code id="plot.popTime_+3A_ncol">ncol</code></td>
<td>
<p>Deprecated. Use <code>facet.params</code> instead.</p>
</td></tr>
<tr><td><code id="plot.popTime_+3A_legend.position">legend.position</code></td>
<td>
<p>Deprecated. Specify the legend.position argument
instead in the <code>theme.params</code> argument. e.g. <code>theme.params =
  list(legend.position = 'bottom')</code>.</p>
</td></tr>
<tr><td><code id="plot.popTime_+3A_line.width">line.width</code></td>
<td>
<p>Deprecated.</p>
</td></tr>
<tr><td><code id="plot.popTime_+3A_line.colour">line.colour</code></td>
<td>
<p>Deprecated. specify the fill argument instead in
<code>ribbon.params</code>. e.g. <code>ribbon.params = list(fill = 'red')</code>.</p>
</td></tr>
<tr><td><code id="plot.popTime_+3A_point.size">point.size</code></td>
<td>
<p>Deprecated. specify the size argument instead in the
<code>case.params</code> or <code>base.params</code> or <code>competing.params</code>
argument. e.g. <code>case.params = list(size = 1.5)</code>.</p>
</td></tr>
<tr><td><code id="plot.popTime_+3A_point.colour">point.colour</code></td>
<td>
<p>Deprecated. Specify the values argument instead in the
<code>color.params</code> and <code>fill.params</code> argument. See examples for
details.</p>
</td></tr>
<tr><td><code id="plot.popTime_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> or <code>data.table</code> containing the source
dataset.</p>
</td></tr>
<tr><td><code id="plot.popTime_+3A_time">time</code></td>
<td>
<p>a character string giving the name of the time variable. See
Details.</p>
</td></tr>
<tr><td><code id="plot.popTime_+3A_event">event</code></td>
<td>
<p>a character string giving the name of the event variable
contained in <code>data</code>. See Details. If <code>event</code> is a numeric
variable, then 0 needs to represent a censored observation, 1 needs to be
the event of interest. Integers 2, 3, ... and so on are treated as
competing events. If event is a <code>factor</code> or <code>character</code> and
<code>censored.indicator</code> is not specified, this function will assume the
reference level is the censored indicator</p>
</td></tr>
<tr><td><code id="plot.popTime_+3A_exposure">exposure</code></td>
<td>
<p>a character string of length 1 giving the name of the
exposure variable which must be contained in <code>data</code>. Default is
<code>NULL</code>. This is used to produced exposure stratified plots. If an
<code>exposure</code> is specified, <code>popTime</code> returns an <code>exposure</code>
attribute which contains the name of the exposure variable in the dataset.
The plot method for objects of class <code>popTime</code> will use this exposure
attribute to create exposure stratified population time plots.</p>
</td></tr>
<tr><td><code id="plot.popTime_+3A_percentile_number">percentile_number</code></td>
<td>
<p>Default=0.5. Give a value between 0-1. if the
percentile number of available subjects at any given point is less than 10,
then sample regardless of case status. Depending on distribution of
survival times and events event points may not be evenly distributed with
default value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function leverages the <code>ggplot2</code> package to build
population time plots. It builds the plot by adding layers, starting with a
layer for the area representing the population time. It then sequentially
adds points to the plots to show the casebase sampling mechanism. This
function gives user the flexibility to add any combination of the
case.series, base.series and competing events. The case series and
competing events are sampled at random vertically on the plot in order to
visualise the incidence density using the <code><a href="#topic+popTime">popTime</a></code> function.
That is, imagine we draw a vertical line at a specific event time. We then
plot the point at a randomly sampled y-coordinate along this vertical line.
This is done to avoid having all points along the upper edge of the plot
(because the subjects with the least amount of observation time are plotted
at the top of the y-axis). By randomly distributing them, we can get a
better sense of the incidence density. The base series is sampled
horizontally on the plot using the <code><a href="#topic+sampleCaseBase">sampleCaseBase</a></code> function.
</p>
<p>It is assumed that <code>data</code> contains the two columns
corresponding to the supplied time and event variables. If either the
<code>time</code> or <code>event</code> argument is missing, the function looks for
columns that contain the words <code>"time"</code>, <code>"event"</code>, or
<code>"status"</code> in them (case insensitive). The function first looks for
the time variable, then it looks for the event variable. This order of
operation is important if for example the time variable is named
<code>"event time"</code> and the event variable is named <code>"event
  indicator"</code>. This function will first (automatically) find the time
variable and remove this as a possibility from subsequent searches of the
event variable. The following regular expressions are used for the time and
event variables: </p>
 <dl>
<dt>time</dt><dd><p><code>"[\s\W_]+time|^time\b"</code></p>
</dd>
<dt>event</dt><dd><p><code>"[\s\W_]+event|^event\b|[\s\W_]+status|^status\b"</code></p>
</dd>
</dl>
<p> This allows for <code>"time"</code> to be preceded or followed by one or more
white space characters, one or more non-word characters or one or more
underscores. For example, the following column names would be recognized by
the function as the <code>"time"</code> variable: <code>"time of death",
  "death_time", "Time", "time", "diagnosis_time", "time.diag", "diag__time"</code>.
But the following will not be recognized: <code>"diagtime","eventtime",
  "Timediag"</code>
</p>


<h3>Value</h3>

<p>The methods for <code>plot</code> return a population time plot, stratified
by exposure status in the case of <code>popTimeExposure</code>. Note that these
are <code>ggplot2</code> objects and can therefore be used in subsequent ggplot2
type plots. See examples and vignette for details.
</p>
<p>An object of class <code>popTime</code> (or <code>popTimeExposure</code> if
exposure is specified), <code>data.table</code> and <code>data.frame</code> in this
order! The output of this function is to be used with the plot method for
objects of class <code>popTime</code> or of class <code>popTimeExposure</code>, which
will produce population time plots. This dataset augments the original data
with the following columns: </p>
<dl>
<dt>original.time</dt><dd><p>value of the
time variable in the original dataset - the one specified by the
<code>time</code> user argument to this function</p>
</dd><dt>original.event</dt><dd><p>value of
the event variable in the original dataset - the one specified by the
<code>event</code> user argument to this function</p>
</dd><dt>time</dt><dd><p>renames the user
specified time column to time</p>
</dd><dt>event</dt><dd><p>renames the user specified event
argument to event</p>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code>,<code><a href="ggplot2.html#topic+geom_ribbon">ggplot2::geom_ribbon()</a></code>,<code><a href="ggplot2.html#topic+theme">ggplot2::theme()</a></code>,
<code><a href="ggplot2.html#topic+scale_manual">ggplot2::scale_colour_manual()</a></code>, <code><a href="ggplot2.html#topic+scale_manual">ggplot2::scale_fill_manual()</a></code>,
<a href="#topic+sampleCaseBase">sampleCaseBase</a>
</p>
<p><code><a href="#topic+plot.popTime">plot.popTime</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># change color of points
library(ggplot2)
data("bmtcrr")
popTimeData &lt;- popTime(data = bmtcrr, time = "ftime", event = "Status")
fill_cols &lt;- c("Case series" = "black", "Competing event" = "#009E73",
               "Base series" = "#0072B2")
color_cols &lt;- c("Case series" = "black", "Competing event" = "black",
                "Base series" = "black")

plot(popTimeData,
  add.case.series = TRUE,
  add.base.series = TRUE,
  add.competing.event = FALSE,
  legend = TRUE,
  comprisk = TRUE,
  fill.params = list(
    name = element_blank(),
    breaks = c("Case series", "Competing event", "Base series"),
    values = fill_cols
  ),
  color.params = list(
    name = element_blank(),
    breaks = c("Case series", "Competing event", "Base series"),
    values = color_cols
  )
)
data("bmtcrr")
popTimeData &lt;- popTime(data = bmtcrr, time = "ftime")
class(popTimeData)
popTimeData &lt;- popTime(data = bmtcrr, time = "ftime", exposure = "D")
attr(popTimeData, "exposure")
</code></pre>

<hr>
<h2 id='plotHazardRatio'>Plot Hazards and Hazard Ratios</h2><span id='topic+plotHazardRatio'></span><span id='topic+plot.singleEventCB'></span><span id='topic+incrVar'></span>

<h3>Description</h3>

<p>Plot method for objects returned by the <code>fitSmoothHazard</code>
function. Current plot types are hazard function and hazard ratio. The
<code>visreg</code> package must be installed for <code>type="hazard"</code>. This
function accounts for the possible time-varying exposure effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotHazardRatio(x, newdata, newdata2, ci, ci.lvl, ci.col, rug, xvar, ...)

## S3 method for class 'singleEventCB'
plot(
  x,
  ...,
  type = c("hazard", "hr"),
  hazard.params = list(),
  newdata,
  exposed,
  increment = 1,
  var,
  xvar = NULL,
  ci = FALSE,
  ci.lvl = 0.95,
  rug = !ci,
  ci.col = "grey"
)

incrVar(var, increment = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotHazardRatio_+3A_x">x</code></td>
<td>
<p>Fitted object of class <code>glm</code>, <code>gam</code>, <code>cv.glmnet</code> or <code>gbm</code>. This is
the result from the <code><a href="#topic+fitSmoothHazard">fitSmoothHazard()</a></code> function.</p>
</td></tr>
<tr><td><code id="plotHazardRatio_+3A_newdata">newdata</code></td>
<td>
<p>Required for <code>type="hr"</code>. The <code>newdata</code> argument is
the &quot;unexposed&quot; group, while the exposed group is defined by either: (i) a
change (defined by the <code>increment</code> argument) in a variable in newdata
defined by the <code>var</code> argument ; or (ii) an exposed function that takes
a data-frame and returns the &quot;exposed&quot; group (e.g. <code>exposed =
  function(data) transform(data, treat=1)</code>). This is a generalization of the
behavior of the rstpm2 plot function. It allows both numeric and factor
variables to be incremented or decremented. See references for rstpm2
package. Only used for <code>type="hr"</code></p>
</td></tr>
<tr><td><code id="plotHazardRatio_+3A_newdata2">newdata2</code></td>
<td>
<p><code>data.frame</code> for exposed group. calculated and passed
internally to <code>plotHazardRatio</code> function</p>
</td></tr>
<tr><td><code id="plotHazardRatio_+3A_ci">ci</code></td>
<td>
<p>Logical; if TRUE confidence bands are calculated. Only available
for <code>family="glm"</code> and <code>family="gam"</code>, and only used for <code>type="hr"</code>,
Default: !add. Confidence intervals for hazard ratios are calculated using
the Delta Method.</p>
</td></tr>
<tr><td><code id="plotHazardRatio_+3A_ci.lvl">ci.lvl</code></td>
<td>
<p>Confidence level. Must be in (0,1), Default: 0.95. Only used
for <code>type="hr"</code>.</p>
</td></tr>
<tr><td><code id="plotHazardRatio_+3A_ci.col">ci.col</code></td>
<td>
<p>Confidence band color. Only used if argument <code>ci=TRUE</code>,
Default: 'grey'. Only used for <code>type="hr"</code>.</p>
</td></tr>
<tr><td><code id="plotHazardRatio_+3A_rug">rug</code></td>
<td>
<p>Logical. Adds a rug representation (1-d plot) of the event times
(only for <code>status=1</code>), Default: !ci. Only used for <code>type="hr"</code>.</p>
</td></tr>
<tr><td><code id="plotHazardRatio_+3A_xvar">xvar</code></td>
<td>
<p>Variable to be used on x-axis for hazard ratio plots. If NULL,
the function defaults to using the time variable used in the call to
<code>fitSmoothHazard</code>. In general, this should be any continuous variable
which has an interaction term with another variable. Only used for
<code>type="hr"</code>.</p>
</td></tr>
<tr><td><code id="plotHazardRatio_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>plot</code>. Only used if <code>type="hr"</code>.
Any of <code>lwd</code>,<code>lty</code>,<code>col</code>,<code>pch</code>,<code>cex</code> will be applied to the hazard ratio
line, or point (if only one time point is supplied to <code>newdata</code>).</p>
</td></tr>
<tr><td><code id="plotHazardRatio_+3A_type">type</code></td>
<td>
<p>plot type. Choose one of either <code>"hazard"</code> for hazard
function or <code>"hr"</code> for hazard ratio.  Default: <code>type = "hazard"</code>.</p>
</td></tr>
<tr><td><code id="plotHazardRatio_+3A_hazard.params">hazard.params</code></td>
<td>
<p>Named list of arguments which will override the defaults
passed to <code><a href="visreg.html#topic+visreg">visreg::visreg()</a></code>, The default arguments are <code>list(fit = x,
  trans = exp, plot = TRUE, rug = FALSE, alpha = 1, partial = FALSE, overlay
  = TRUE)</code>. For example, if you want a 95% confidence band, specify
<code>hazard.params = list(alpha = 0.05)</code>. Note that The <code>cond</code> argument
must be provided as a named list. Each element of that list specifies the
value for one of the terms in the model; any elements left unspecified are
filled in with the median/most common category. Only used for
<code>type="hazard"</code>. All other argument are used for <code>type="hr"</code>. Note that the
<code>visreg</code> package must be installed for <code>type="hazard"</code>.</p>
</td></tr>
<tr><td><code id="plotHazardRatio_+3A_exposed">exposed</code></td>
<td>
<p>function that takes <code>newdata</code> and returns the exposed
dataset (e.g. function(data) transform(data, treat = 1)). This argument
takes precedence over the <code>var</code> argument, i.e., if both <code>var</code> and
<code>exposed</code> are correctly specified, only the <code>exposed</code> argument
will be used. Only used for <code>type="hr"</code>.</p>
</td></tr>
<tr><td><code id="plotHazardRatio_+3A_increment">increment</code></td>
<td>
<p>Numeric value indicating how much to increment (if positive)
or decrement (if negative) the <code>var</code> variable in <code>newdata</code>. See
<code>var</code> argument for more details. Default is 1. Only used for
<code>type="hr"</code>.</p>
</td></tr>
<tr><td><code id="plotHazardRatio_+3A_var">var</code></td>
<td>
<p>specify the variable name for the exposed/unexposed (name is given
as a character variable). If this argument is missing, then the
<code>exposed</code> argument must be specified. This is the variable which will
be incremented by the <code>increment</code> argument to give the exposed
category. If <code>var</code> is coded as a factor variable, then
<code>increment=1</code> will return the next level of the variable in
<code>newdata</code>. <code>increment=2</code> will return two levels above, and so on.
If the value supplied to <code>increment</code> is greater than the number of
levels, this will simply return the max level. You can also decrement the
categorical variable by specifying a negative value, e.g.,
<code>increment=-1</code> will return one level lower than the value in
<code>newdata</code>. If <code>var</code> is a numeric, than <code>increment</code> will
increment (if positive) or decrement (if negative) by the supplied value.
Only used for <code>type="hr"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has only been thoroughly tested for <code>family="glm"</code>. If
the user wants more customized plot aesthetics, we recommend saving the
results to a <code>data.frame</code> and using  the graphical package of their choice.
</p>


<h3>Value</h3>

<p>a plot of the hazard function or hazard ratio. For <code>type="hazard"</code>, a
<code>data.frame</code> (returned invisibly) of the original data used in the fitting
along with the data used to create the plots including <code>predictedhazard</code>
which is the predicted hazard for a given covariate pattern and time.
<code>predictedloghazard</code> is the predicted hazard on the log scale. <code>lowerbound</code>
and <code>upperbound</code> are the lower and upper confidence interval bounds on the
hazard scale (i.e. used to plot the confidence bands). <code>standarderror</code> is
the standard error of the log hazard or log hazard ratio (only if
<code>family="glm"</code> or <code>family="gam"</code>). For <code>type="hr"</code>, <code>log_hazard_ratio</code> and
<code>hazard_ratio</code> is returned, and if <code>ci=TRUE</code>, <code>standarderror</code> (on the log
scale) and <code>lowerbound</code> and <code>upperbound</code> of the <code>hazard_ratio</code> are
returned.
</p>


<h3>References</h3>

<p>Mark Clements and Xing-Rong Liu (2019). rstpm2: Smooth Survival
Models, Including Generalized Survival Models. R package version 1.5.1.
https://CRAN.R-project.org/package=rstpm2
</p>
<p>Breheny P and Burchett W (2017). Visualization of Regression Models Using
visreg. The R Journal, 9: 56-71.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+modifyList">modifyList</a></code>, <code><a href="#topic+fitSmoothHazard">fitSmoothHazard()</a></code>,
<code><a href="graphics.html#topic+par">graphics::par()</a></code>, <code><a href="visreg.html#topic+visreg">visreg::visreg()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("splines", quietly = TRUE)) {
data("simdat") # from casebase package
library(splines)
simdat &lt;- transform(simdat[sample(1:nrow(simdat), size = 200),],
                    treat = factor(trt, levels = 0:1,
                    labels = c("control","treatment")))

fit_numeric_exposure &lt;- fitSmoothHazard(status ~ trt*bs(eventtime),
                                        data = simdat,
                                        ratio = 1,
                                        time = "eventtime")

fit_factor_exposure &lt;- fitSmoothHazard(status ~ treat*bs(eventtime),
                                       data = simdat,
                                       ratio = 1,
                                       time = "eventtime")

newtime &lt;- quantile(fit_factor_exposure[["data"]][[fit_factor_exposure[["timeVar"]]]],
                    probs = seq(0.05, 0.95, 0.01))

par(mfrow = c(1,3))
plot(fit_numeric_exposure,
     type = "hr",
     newdata = data.frame(trt = 0, eventtime = newtime),
     exposed = function(data) transform(data, trt = 1),
     xvar = "eventtime",
     ci = TRUE)

#by default this will increment `var` by 1 for exposed category
plot(fit_factor_exposure,
     type = "hr",
     newdata = data.frame(treat = factor("control",
              levels = c("control","treatment")), eventtime = newtime),
     var = "treat",
     increment = 1,
     xvar = "eventtime",
     ci = TRUE,
     ci.col = "lightblue",
     xlab = "Time",
     main = "Hazard Ratio for Treatment",
     ylab = "Hazard Ratio",
     lty = 5,
     lwd = 7,
     rug = TRUE)


# we can also decrement `var` by 1 to give hazard ratio for control/treatment
result &lt;- plot(fit_factor_exposure,
               type = "hr",
               newdata = data.frame(treat = factor("treatment",
                                    levels = c("control","treatment")),
                                    eventtime = newtime),
               var = "treat",
               increment = -1,
               xvar = "eventtime",
               ci = TRUE)

# see data used to create plot
head(result)
}
</code></pre>

<hr>
<h2 id='sampleCaseBase'>Create case-base dataset for use in fitting parametric hazard functions</h2><span id='topic+sampleCaseBase'></span>

<h3>Description</h3>

<p>This function implements the case-base sampling approach described in Hanley
and Miettinen (2009). It can be used to fit smooth-in-time parametric
functions easily via logistic regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleCaseBase(
  data,
  time,
  event,
  ratio = 10,
  comprisk = FALSE,
  censored.indicator
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleCaseBase_+3A_data">data</code></td>
<td>
<p>a data.frame or data.table containing the source dataset.</p>
</td></tr>
<tr><td><code id="sampleCaseBase_+3A_time">time</code></td>
<td>
<p>a character string giving the name of the time variable. See
Details.</p>
</td></tr>
<tr><td><code id="sampleCaseBase_+3A_event">event</code></td>
<td>
<p>a character string giving the name of the event variable. See
Details.</p>
</td></tr>
<tr><td><code id="sampleCaseBase_+3A_ratio">ratio</code></td>
<td>
<p>Integer, giving the ratio of the size of the base series to that
of the case series. Defaults to 10.</p>
</td></tr>
<tr><td><code id="sampleCaseBase_+3A_comprisk">comprisk</code></td>
<td>
<p>Logical. Indicates whether we have multiple event types and
that we want to consider some of them as competing risks.</p>
</td></tr>
<tr><td><code id="sampleCaseBase_+3A_censored.indicator">censored.indicator</code></td>
<td>
<p>a character string of length 1 indicating which
value in <code>event</code> is the censored. This function will use
<code><a href="stats.html#topic+relevel">relevel</a></code> to set <code>censored.indicator</code> as the
reference level. This argument is ignored if the <code>event</code> variable is a
numeric</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The base series is sampled using a multinomial scheme: individuals are
sampled proportionally to their follow-up time.
</p>
<p>It is assumed that <code>data</code> contains the two columns corresponding to the
supplied time and event variables. If either the <code>time</code> or <code>event</code>
argument is missing, the function looks for columns with appropriate-looking
names (see <code><a href="#topic+checkArgsTimeEvent">checkArgsTimeEvent</a></code>).
</p>


<h3>Value</h3>

<p>The function returns a dataset, with the same format as the source
dataset, and where each row corresponds to a person-moment sampled from the
case or the base series.
</p>


<h3>Warning</h3>

<p>The offset is calculated using the total follow-up time for
all individuals in the study. Therefore, we need <code>time</code> to be on the
original scale, not a transformed scale (e.g. logarithmic). Otherwise, the
offset and the estimation will be wrong.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate censored survival data for two outcome types from exponential
library(data.table)
set.seed(12345)
nobs &lt;- 500
tlim &lt;- 10

# simulation parameters
b1 &lt;- 200
b2 &lt;- 50

# event type 0-censored, 1-event of interest, 2-competing event
# t observed time/endpoint
# z is a binary covariate
DT &lt;- data.table(z = rbinom(nobs, 1, 0.5))
DT[, `:=`(
  "t_event" = rweibull(nobs, 1, b1),
  "t_comp" = rweibull(nobs, 1, b2)
)]
DT[, `:=`(
  "event" = 1 * (t_event &lt; t_comp) + 2 * (t_event &gt;= t_comp),
  "time" = pmin(t_event, t_comp)
)]
DT[time &gt;= tlim, `:=`("event" = 0, "time" = tlim)]

out &lt;- sampleCaseBase(DT, time = "time", event = "event", comprisk = TRUE)
</code></pre>

<hr>
<h2 id='simdat'>Simulated data under Weibull model with Time-Dependent Treatment Effect</h2><span id='topic+simdat'></span>

<h3>Description</h3>

<p>This simulated data is and description is taken verbatim from the
<code>simsurv</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simdat
</code></pre>


<h3>Format</h3>

<p>A dataframe with 1000 observations and 4 variables: </p>

<dl>
<dt>id</dt><dd><p>patient id</p>
</dd> <dt>eventtime</dt><dd><p>time of event</p>
</dd> <dt>status</dt><dd><p>event
indicator (1 = event, 0 = censored)</p>
</dd> <dt>trt</dt><dd><p>binary treatment
indicator</p>
</dd></dl>



<h3>Details</h3>

<p>Simulated data under a standard Weibull survival model that incorporates a
time-dependent treatment effect (i.e. non-proportional hazards). For the
time-dependent effect we included a single binary covariate (e.g. a treatment
indicator) with a protective effect (i.e. a negative log hazard ratio), but
we will allow the effect of the covariate to diminish over time. The data
generating model will be </p>
<p style="text-align: center;"><code class="reqn">h_i(t) = \gamma \lambda (t ^{\gamma - 1})
exp(\beta_0 X_i + \beta_1 X_i x log(t))</code>
</p>
<p> where where Xi is the binary
treatment indicator for individual i, <code class="reqn">\lambda</code> and <code class="reqn">\gamma</code> are the
scale and shape parameters for the Weibull baseline hazard, <code class="reqn">\beta_0</code> is
the log hazard ratio for treatment when t=1 (i.e. when log(t)=0), and
<code class="reqn">\beta_1</code> quantifies the amount by which the log hazard ratio for
treatment changes for each one unit increase in log(t). Here we are assuming
the time-dependent effect is induced by interacting the log hazard ratio with
log time. The true parameters are 1. <code class="reqn">\beta_0</code> = -0.5 2. <code class="reqn">\beta_1</code> =
0.15 3. <code class="reqn">\lambda</code> = 0.1 4. <code class="reqn">\gamma</code> = 1.5
</p>


<h3>Source</h3>

<p>See <code>simsurv</code> vignette:
<a href="https://cran.r-project.org/package=simsurv/vignettes/simsurv_usage.html">https://cran.r-project.org/package=simsurv/vignettes/simsurv_usage.html</a>
</p>


<h3>References</h3>

<p>Sam Brilleman (2019). simsurv: Simulate Survival Data. R package
version 0.2.3. https://CRAN.R-project.org/package=simsurv
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("splines", quietly = TRUE)) {
library(splines)
data("simdat")
mod_cb &lt;- casebase::fitSmoothHazard(status ~ trt + ns(log(eventtime),
                                                      df = 3) +
                                   trt:ns(log(eventtime),df=1),
                                   time = "eventtime",
                                   data = simdat,
                                   ratio = 1)
}
</code></pre>

<hr>
<h2 id='support'>Study to Understand Prognoses Preferences Outcomes and Risks of Treatment
(SUPPORT)</h2><span id='topic+support'></span>

<h3>Description</h3>

<p>The SUPPORT dataset tracks four response variables: hospital
death, severe functional disability, hospital costs, and time until death
and death itself. The patients are followed for up to 5.56 years. Data
included only tracks follow-up time and death.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>support
</code></pre>


<h3>Format</h3>

<p>A dataframe with 9104 observations and 34 variables after imputation
and the removal of response variables like hospital charges, patient ratio
of costs to charges and micro-costs. Ordinal variables, namely functional
disability and income, were also removed. Finally, Surrogate activities of
daily living were removed due to sparsity. There were 6 other model scores
in the data-set and they were removed; only aps and sps were kept.
</p>
 <dl>
<dt>Age</dt><dd><p> Stores a double representing age. </p>
</dd> <dt>death</dt><dd>
<p>Death at any time up to NDI date: 31DEC94. </p>
</dd> <dt>sex</dt><dd><p> 0=female, 1=male.
</p>
</dd> <dt>slos</dt><dd><p> Days from study entry to discharge. </p>
</dd> <dt>d.time</dt><dd><p> days of
follow-up. </p>
</dd> <dt>dzgroup</dt><dd><p> Each level of dzgroup: ARF/MOSF w/Sepsis,
COPD, CHF, Cirrhosis, Coma, Colon Cancer, Lung Cancer, MOSF with
malignancy. </p>
</dd> <dt>dzclass</dt><dd><p> ARF/MOSF, COPD/CHF/Cirrhosis, Coma and cancer
disease classes. </p>
</dd> <dt>num.co</dt><dd><p> the number of comorbidities. </p>
</dd>
<dt>edu</dt><dd><p> years of education of patient. </p>
</dd> <dt>scoma</dt><dd><p> The SUPPORT coma
score based on Glasgow D3. </p>
</dd> <dt>avtisst</dt><dd><p> Average TISS, days 3-25. </p>
</dd>
<dt>race</dt><dd><p> Indicates race. White, Black, Asian, Hispanic or other. </p>
</dd>
<dt>hday</dt><dd><p>Day in Hospital at Study Admit</p>
</dd> <dt>diabetes</dt><dd><p>Diabetes (Com
27-28, Dx 73)</p>
</dd> <dt>dementia</dt><dd><p>Dementia (Comorbidity 6) </p>
</dd> <dt>ca</dt><dd><p>Cancer
State</p>
</dd> <dt>meanbp</dt><dd><p> Mean Arterial Blood Pressure Day 3. </p>
</dd> <dt>wblc</dt><dd>
<p>White blood cell count on day 3. </p>
</dd> <dt>hrt</dt><dd><p> Heart rate day 3. </p>
</dd>
<dt>resp</dt><dd><p> Respiration Rate day 3. </p>
</dd> <dt>temp</dt><dd><p> Temperature, in
Celsius, on day 3. </p>
</dd> <dt>pafi</dt><dd><p> PaO2/(0.01*FiO2) Day 3. </p>
</dd> <dt>alb</dt><dd>
<p>Serum albumin day 3. </p>
</dd> <dt>bili</dt><dd><p> Bilirubin Day 3. </p>
</dd> <dt>crea</dt><dd><p> Serum
creatinine day 3. </p>
</dd> <dt>sod</dt><dd><p> Serum sodium day 3. </p>
</dd> <dt>ph</dt><dd><p> Serum pH
(in arteries) day 3. </p>
</dd> <dt>glucose</dt><dd><p> Serum glucose day 3. </p>
</dd> <dt>bun</dt><dd>
<p>BUN day 3. </p>
</dd> <dt>urine</dt><dd><p> urine output day 3. </p>
</dd> <dt>adlp</dt><dd><p> ADL patient
day 3. </p>
</dd>  <dt>adlsc</dt><dd><p> Imputed ADL calibrated to surrogate, if a surrogate
was used for a follow up.</p>
</dd> <dt>sps</dt><dd><p>SUPPORT physiology score</p>
</dd>
<dt>aps</dt><dd><p>Apache III physiology score</p>
</dd> </dl>



<h3>Details</h3>

<p>Some of the original data was missing. Before imputation, there were
a total of 9105 individuals and 47 variables. Of those variables, a few
were removed before imputation. We removed three response variables:
hospital charges, patient ratio of costs to charge,s and patient
micro-costs. Next, we removed hospital death as it was directly informative
of our event of interest, namely death. We also removed functional
disability and income as they are ordinal covariates. Finally, we removed 8
covariates related to the results of previous findings: we removed SUPPORT
day 3 physiology score (<code>sps</code>), APACHE III day 3 physiology score
(<code>aps</code>), SUPPORT model 2-month survival estimate, SUPPORT model
6-month survival estimate, Physician's 2-month survival estimate for pt.,
Physician's 6-month survival estimate for pt., Patient had Do Not
Resuscitate (DNR) order, and Day of DNR order (&lt;0 if before study). Of
these, <code>sps</code> and <code>aps</code> were added on after imputation, as they
were missing only 1 observation. First we imputed manually using the normal
values for physiological measures recommended by Knaus et al. (1995). Next,
we imputed a single dataset using <span class="pkg">mice</span> with default settings. After
imputation, we noted that the covariate for surrogate activities of daily
living was not imputed. This is due to collinearity between the other two
covariates for activities of daily living. Therefore, surrogate activities
of daily living was removed.
</p>


<h3>Source</h3>

<p>Available at the following website:
<a href="https://biostat.app.vumc.org/wiki/Main/SupportDesc">https://biostat.app.vumc.org/wiki/Main/SupportDesc</a>.
note: must unzip and process this data before use.
</p>


<h3>References</h3>

<p>Knaus WA, Harrell FE, Lynn J et al. (1995): The SUPPORT
prognostic model: Objective estimates of survival for seriously ill
hospitalized adults. Annals of Internal Medicine 122:191-203.
<a href="https://doi.org/10.7326/0003-4819-122-3-199502010-00007">doi:10.7326/0003-4819-122-3-199502010-00007</a>.
</p>
<p>http://biostat.mc.vanderbilt.edu/wiki/Main/SupportDesc
</p>
<p>http://biostat.mc.vanderbilt.edu/wiki/pub/Main/DataSets/Csupport.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("support")
# Using the matrix interface and log of time
x &lt;- model.matrix(death ~ . - d.time - 1, data = support)
y &lt;- with(support, cbind(death, d.time))

fit_cb &lt;- casebase::fitSmoothHazard.fit(x, y, time = "d.time",
                                        event = "death",
                                        formula_time = ~ log(d.time),
                                        ratio = 1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
