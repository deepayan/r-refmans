<!DOCTYPE html><html><head><title>Help for package incidence2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {incidence2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#incidence2-package'><p>incidence2: Compute, Handle and Plot Incidence of Dated Events</p></a></li>
<li><a href='#accessors'><p>Access various elements of an incidence object</p></a></li>
<li><a href='#as_incidence'><p>Coerce to an incidence object</p></a></li>
<li><a href='#as_tibble.incidence2'><p>Coerce to a tibble</p></a></li>
<li><a href='#as.data.frame.incidence2'><p>Convert incident object to a data frame</p></a></li>
<li><a href='#as.data.table.incidence2'><p>Coerce to a data.table</p></a></li>
<li><a href='#bootstrap_incidence'><p>Bootstrap incidence time series</p></a></li>
<li><a href='#complete_dates'><p>Complete dates for all group combinations</p></a></li>
<li><a href='#covidregionaldataUK'><p>Regional data for COVID-19 cases in the UK</p></a></li>
<li><a href='#cumulate'><p>Compute cumulative 'incidence'</p></a></li>
<li><a href='#estimate_peak'><p>Estimate the peak date of an incidence curve</p></a></li>
<li><a href='#incidence'><p>Compute the incidence of events</p></a></li>
<li><a href='#incidence_'><p>Compute the incidence of events (tidyselect compatible)</p></a></li>
<li><a href='#incidence2-defunct'><p>Functions now defunct in package incidence2</p></a></li>
<li><a href='#keep'><p>Keep first, last and peak occurences</p></a></li>
<li><a href='#mutate.incidence2'><p>Create, modify, and delete incidence2 columns</p></a></li>
<li><a href='#nest.incidence2'><p>Nest rows into a list-column of data frames</p></a></li>
<li><a href='#plot.incidence2'><p>Plot an incidence object</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#regroup'><p>Regroup 'incidence' objects</p></a></li>
<li><a href='#regroup_'><p>Regroup 'incidence' objects (tidyselect compatible)</p></a></li>
<li><a href='#split.incidence2'><p>Divide an incidence2 object in to it's implicit groupings</p></a></li>
<li><a href='#summarise.incidence2'><p>Summarise each grouping down to one row</p></a></li>
<li><a href='#summary.incidence2'><p>Summary of an incidence object</p></a></li>
<li><a href='#vibrant'><p>Color palettes used in incidence</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Compute, Handle and Plot Incidence of Dated Events</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions and classes to compute, handle and visualise 
  incidence from dated events for a defined time interval. Dates can be 
  provided in various standard formats. The class 'incidence2' is used to store
  computed incidence and can be easily manipulated, subsetted, and plotted.
  This package is part of the RECON (<a href="https://www.repidemicsconsortium.org/">https://www.repidemicsconsortium.org/</a>) 
  toolkit for outbreak analysis (<a href="https://www.reconverse.org">https://www.reconverse.org</a>).</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.reconverse.org/incidence2/">https://www.reconverse.org/incidence2/</a>,
<a href="https://github.com/reconverse/incidence2">https://github.com/reconverse/incidence2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/reconverse/incidence2/issues">https://github.com/reconverse/incidence2/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>grates (&ge; 1.0.0), R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, data.table, pillar, utils, stats, tibble, tidyr,
dplyr (&ge; 1.1.0), tidyselect, rlang, vctrs</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>outbreaks, ggplot2, scales, knitr, markdown, testthat (&ge;
3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/runiverse/noindex:</td>
<td>true</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-31 08:57:19 UTC; tim</td>
</tr>
<tr>
<td>Author:</td>
<td>Tim Taylor <a href="https://orcid.org/0000-0002-8587-7113"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Thibaut Jombart [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tim Taylor &lt;tim.taylor@hiddenelephants.co.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-31 09:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='incidence2-package'>incidence2: Compute, Handle and Plot Incidence of Dated Events</h2><span id='topic+incidence2'></span><span id='topic+incidence2-package'></span>

<h3>Description</h3>

<p>Provides functions and classes to compute, handle and visualise incidence from dated events for a defined time interval. Dates can be provided in various standard formats. The class 'incidence2' is used to store computed incidence and can be easily manipulated, subsetted, and plotted. This package is part of the RECON (<a href="https://www.repidemicsconsortium.org/">https://www.repidemicsconsortium.org/</a>) toolkit for outbreak analysis (<a href="https://www.reconverse.org">https://www.reconverse.org</a>).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Tim Taylor <a href="mailto:tim.taylor@hiddenelephants.co.uk">tim.taylor@hiddenelephants.co.uk</a> (<a href="https://orcid.org/0000-0002-8587-7113">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://www.reconverse.org/incidence2/">https://www.reconverse.org/incidence2/</a>
</p>
</li>
<li> <p><a href="https://github.com/reconverse/incidence2">https://github.com/reconverse/incidence2</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/reconverse/incidence2/issues">https://github.com/reconverse/incidence2/issues</a>
</p>
</li></ul>


<hr>
<h2 id='accessors'>Access various elements of an incidence object</h2><span id='topic+accessors'></span><span id='topic+get_date_index_name'></span><span id='topic+get_date_index_name.default'></span><span id='topic+get_date_index_name.incidence2'></span><span id='topic+get_dates_name'></span><span id='topic+get_count_variable_name'></span><span id='topic+get_count_variable_name.default'></span><span id='topic+get_count_variable_name.incidence2'></span><span id='topic+get_count_value_name'></span><span id='topic+get_count_value_name.default'></span><span id='topic+get_count_value_name.incidence2'></span><span id='topic+get_group_names'></span><span id='topic+get_group_names.default'></span><span id='topic+get_group_names.incidence2'></span><span id='topic+get_date_index'></span><span id='topic+get_date_index.default'></span><span id='topic+get_date_index.incidence2'></span><span id='topic+get_dates'></span><span id='topic+get_count_variable'></span><span id='topic+get_count_variable.default'></span><span id='topic+get_count_variable.incidence2'></span><span id='topic+get_count_value'></span><span id='topic+get_count_value.default'></span><span id='topic+get_count_value.incidence2'></span><span id='topic+get_groups'></span><span id='topic+get_groups.default'></span><span id='topic+get_groups.incidence2'></span>

<h3>Description</h3>

<p>Access various elements of an incidence object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_date_index_name(x, ...)

## Default S3 method:
get_date_index_name(x, ...)

## S3 method for class 'incidence2'
get_date_index_name(x, ...)

get_dates_name(x, ...)

get_count_variable_name(x, ...)

## Default S3 method:
get_count_variable_name(x, ...)

## S3 method for class 'incidence2'
get_count_variable_name(x, ...)

get_count_value_name(x, ...)

## Default S3 method:
get_count_value_name(x, ...)

## S3 method for class 'incidence2'
get_count_value_name(x, ...)

get_group_names(x, ...)

## Default S3 method:
get_group_names(x, ...)

## S3 method for class 'incidence2'
get_group_names(x, ...)

get_date_index(x, ...)

## Default S3 method:
get_date_index(x, ...)

## S3 method for class 'incidence2'
get_date_index(x, ...)

get_dates(x, ...)

get_count_variable(x, ...)

## Default S3 method:
get_count_variable(x, ...)

## S3 method for class 'incidence2'
get_count_variable(x, ...)

get_count_value(x, ...)

## Default S3 method:
get_count_value(x, ...)

## S3 method for class 'incidence2'
get_count_value(x, ...)

get_groups(x, ...)

## Default S3 method:
get_groups(x, ...)

## S3 method for class 'incidence2'
get_groups(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accessors_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="accessors_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>get_date_index_name()</code>: The name of the date_index variable of x.
</p>
</li>
<li> <p><code>get_dates_name()</code>: Alias for <code>get_date_index_name()</code>.
</p>
</li>
<li> <p><code>get_count_variable_name()</code>: The name of the count variable of x.
</p>
</li>
<li> <p><code>get_count_value_name()</code>: The name of the count value of x.
</p>
</li>
<li> <p><code>get_group_names()</code>: The name(s) of the group variable(s) of x.
</p>
</li>
<li> <p><code>get_date_index()</code>: The date_index variable of x.
</p>
</li>
<li> <p><code>get_dates()</code>: Alias for <code>get_date_index()</code>.
</p>
</li>
<li> <p><code>get_count_variable()</code>: The count variable of x.
</p>
</li>
<li> <p><code>get_count_value()</code>: The count value of x.
</p>
</li>
<li> <p><code>get_groups()</code>: List of the group variable(s) of x.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("outbreaks", quietly = TRUE)) {
    data(ebola_sim_clean, package = "outbreaks")
    dat &lt;- ebola_sim_clean$linelist
    i &lt;- incidence(dat, date_index = "date_of_onset",
                   groups = c("gender", "hospital"))

    get_count_variable_name(i)
    get_group_names(i)
    get_dates_name(i)
}


</code></pre>

<hr>
<h2 id='as_incidence'>Coerce to an incidence object</h2><span id='topic+as_incidence'></span><span id='topic+as_incidence.default'></span><span id='topic+as_incidence.incidence2'></span>

<h3>Description</h3>

<p>Generic for coercion to an <code style="white-space: pre;">&#8288;&lt;incidence2&gt;&#8288;</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_incidence(x, ...)

## Default S3 method:
as_incidence(x, ...)

## S3 method for class 'incidence2'
as_incidence(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_incidence_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="as_incidence_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code style="white-space: pre;">&#8288;&lt;incidence2&gt;&#8288;</code> object.
</p>

<hr>
<h2 id='as_tibble.incidence2'>Coerce to a tibble</h2><span id='topic+as_tibble.incidence2'></span>

<h3>Description</h3>

<p>Coerce to a tibble
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'incidence2'
as_tibble(x, ..., .rows, .name_repair, rownames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_tibble.incidence2_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+incidence">incidence2</a> object.</p>
</td></tr>
<tr><td><code id="as_tibble.incidence2_+3A_...">...</code></td>
<td>
<p>Unused, for extensibility.</p>
</td></tr>
<tr><td><code id="as_tibble.incidence2_+3A_.rows">.rows</code></td>
<td>
<p>The number of rows, useful to create a 0-column tibble or
just as an additional check.</p>
</td></tr>
<tr><td><code id="as_tibble.incidence2_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Treatment of problematic column names:
</p>

<ul>
<li> <p><code>"minimal"</code>: No name repair or checks, beyond basic existence,
</p>
</li>
<li> <p><code>"unique"</code>: Make sure names are unique and not empty,
</p>
</li>
<li> <p><code>"check_unique"</code>: (default value), no name repair, but check they are
<code>unique</code>,
</p>
</li>
<li> <p><code>"universal"</code>: Make the names <code>unique</code> and syntactic
</p>
</li>
<li><p> a function: apply custom name repair (e.g., <code>.name_repair = make.names</code>
for names in the style of base R).
</p>
</li>
<li><p> A purrr-style anonymous function, see <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>
</p>
</li></ul>

<p>This argument is passed on as <code>repair</code> to <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>.
See there for more details on these terms and the strategies used
to enforce them.</p>
</td></tr>
<tr><td><code id="as_tibble.incidence2_+3A_rownames">rownames</code></td>
<td>
<p>How to treat existing row names of a data frame or matrix:
</p>

<ul>
<li> <p><code>NULL</code>: remove row names. This is the default.
</p>
</li>
<li> <p><code>NA</code>: keep row names.
</p>
</li>
<li><p> A string: the name of a new column. Existing rownames are transferred
into this column and the <code>row.names</code> attribute is deleted.
No name repair is applied to the new column name, even if <code>x</code> already contains
a column of that name.
Use <code>as_tibble(rownames_to_column(...))</code> to safeguard against this case.
</p>
</li></ul>

<p>Read more in <a href="tibble.html#topic+rownames">rownames</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tibble">tibble</a> of the original input but with no
additional attributes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("outbreaks", quietly = TRUE)) {
    data(ebola_sim_clean, package = "outbreaks")
    dat &lt;- ebola_sim_clean$linelist
    x &lt;- incidence(dat, "date_of_onset")
    as_tibble(x)
}


</code></pre>

<hr>
<h2 id='as.data.frame.incidence2'>Convert incident object to a data frame</h2><span id='topic+as.data.frame.incidence2'></span>

<h3>Description</h3>

<p>Convert incident object to a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'incidence2'
as.data.frame(x, row.names, optional, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.incidence2_+3A_x">x</code></td>
<td>
<p><a href="#topic+incidence">incidence2</a> object.</p>
</td></tr>
<tr><td><code id="as.data.frame.incidence2_+3A_row.names">row.names</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="as.data.frame.incidence2_+3A_optional">optional</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="as.data.frame.incidence2_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="base.html#topic+as.data.frame">as.data.frame</a> for the underlying generic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- data.frame(
    dates = Sys.Date() + 1:100,
    names = rep(c("Jo", "John"), 5)
)

dat &lt;- incidence(dat, date_index = "dates", groups = "names")
as.data.frame(dat)


</code></pre>

<hr>
<h2 id='as.data.table.incidence2'>Coerce to a data.table</h2><span id='topic+as.data.table.incidence2'></span>

<h3>Description</h3>

<p>Coerce to a data.table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'incidence2'
as.data.table(x, keep.rownames, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.table.incidence2_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+incidence">incidence2</a> object.</p>
</td></tr>
<tr><td><code id="as.data.table.incidence2_+3A_keep.rownames">keep.rownames</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="as.data.table.incidence2_+3A_...">...</code></td>
<td>
<p>Passed to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="data.table.html#topic+data.table">data.table</a> of the original input but with no
additional attributes.
</p>


<h3>See Also</h3>

<p><a href="data.table.html#topic+as.data.table">data.table::as.data.table</a> for the underlying generic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("outbreaks", quietly = TRUE)) {
    data(ebola_sim_clean, package = "outbreaks")
    dat &lt;- ebola_sim_clean$linelist
    x &lt;- incidence(dat, "date_of_onset")
    as.data.table(x)
}


</code></pre>

<hr>
<h2 id='bootstrap_incidence'>Bootstrap incidence time series</h2><span id='topic+bootstrap_incidence'></span>

<h3>Description</h3>

<p>This function can be used to bootstrap <a href="#topic+incidence">incidence2</a>
objects. Bootstrapping is done by sampling with replacement the original
input dates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap_incidence(x, randomise_groups = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap_incidence_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+incidence">incidence2</a> object.</p>
</td></tr>
<tr><td><code id="bootstrap_incidence_+3A_randomise_groups">randomise_groups</code></td>
<td>
<p><code>bool</code>.
</p>
<p>Should groups be randomised as well in the resampling procedure; respective
group sizes will be preserved, but this can be used to remove any
group-specific temporal dynamics.
</p>
<p>If <code>FALSE</code> (default), data are resampled within groups.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As original data are not stored in <a href="#topic+incidence">incidence2</a>
objects, the bootstrapping is achieved by multinomial sampling of date bins
weighted by their relative incidence.
</p>


<h3>Value</h3>

<p>An <a href="#topic+incidence">incidence2</a> object.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart, Tim Taylor
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("outbreaks", quietly = TRUE)) {
    data(fluH7N9_china_2013, package = "outbreaks")
    i &lt;- incidence(
        fluH7N9_china_2013,
        date_index = "date_of_onset",
        groups = "gender"
   )
   bootstrap_incidence(i)
}


</code></pre>

<hr>
<h2 id='complete_dates'>Complete dates for all group combinations</h2><span id='topic+complete_dates'></span>

<h3>Description</h3>

<p>This function ensures that an incidence object has the same range of dates
for each grouping. By default missing counts will be filled with <code>0L</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete_dates(x, expand = TRUE, fill = 0L, by = 1L, allow_POSIXct = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complete_dates_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;incidence2&gt;&#8288;</code> object.</p>
</td></tr>
<tr><td><code id="complete_dates_+3A_expand">expand</code></td>
<td>
<p><code>logical</code>.
</p>
<p>Should a range of dates from the minimum to maximum value of the date index
also be created.
</p>
<p>If <code>expand</code> is TRUE (default) then complete_dates will attempt to use
<code>function(x) seq(min(x), max(x), by = 1)</code> to generate a complete sequence of
dates.</p>
</td></tr>
<tr><td><code id="complete_dates_+3A_fill">fill</code></td>
<td>
<p><code>numeric</code>.
</p>
<p>The value to replace missing counts by.
</p>
<p>Defaults to <code>0L</code>.</p>
</td></tr>
<tr><td><code id="complete_dates_+3A_by">by</code></td>
<td>
<p><code>Defunct</code>.
</p>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="complete_dates_+3A_allow_posixct">allow_POSIXct</code></td>
<td>
<p><code>logical</code>.
</p>
<p>Should this function work with POSIXct dates?
</p>
<p>Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+incidence">incidence2</a> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- data.frame(
    dates = Sys.Date() + c(1,3,4),
    groups = c("grp1","grp2", "grp1"),
    counts = 1:3
)

i &lt;- incidence(x, date_index = "dates", groups = "groups", counts = "counts")
complete_dates(i)


</code></pre>

<hr>
<h2 id='covidregionaldataUK'>Regional data for COVID-19 cases in the UK</h2><span id='topic+covidregionaldataUK'></span>

<h3>Description</h3>

<p>A dataset containing the daily time-series of cases, tests, hospitalisations,
and deaths for UK.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covidregionaldataUK
</code></pre>


<h3>Format</h3>

<p>A data frame with 6370 rows and 26 variables:
</p>

<dl>
<dt>date</dt><dd><p>the date that the counts were reported (YYYY-MM-DD)</p>
</dd>
<dt>region</dt><dd><p>the region name</p>
</dd>
<dt>region_code</dt><dd><p>the region code</p>
</dd>
<dt>cases_new</dt><dd><p>new reported cases for that day</p>
</dd>
<dt>cases_total</dt><dd><p>total reported cases up to and including that day</p>
</dd>
<dt>deaths_new</dt><dd><p>new reported deaths for that day</p>
</dd>
<dt>deaths_total</dt><dd><p>total reported deaths up to and including that day</p>
</dd>
<dt>recovered_new</dt><dd><p>new reported recoveries for that day</p>
</dd>
<dt>recovered_total</dt><dd><p>total reported coveries up to and including that day</p>
</dd>
<dt>hosp_new</dt><dd><p>new reported hospitalisations for that day</p>
</dd>
<dt>hosp_total</dt><dd><p>total reported hospitalisations up to and including that day (note this is cumulative total of new reported, not total currently in hospital).</p>
</dd>
<dt>tested_new</dt><dd><p>tests for that day</p>
</dd>
<dt>tested_total</dt><dd><p>total tests completed up to and including that day</p>
</dd>
</dl>



<h3>Details</h3>

<p>Extracted using the
<a href="https://CRAN.R-project.org/package=covidregionaldata">covidregionaldata</a>
package on 2021-06-03.
</p>


<h3>Source</h3>

<p><a href="https://CRAN.R-project.org/package=covidregionaldata">https://CRAN.R-project.org/package=covidregionaldata</a>
</p>

<hr>
<h2 id='cumulate'>Compute cumulative 'incidence'</h2><span id='topic+cumulate'></span>

<h3>Description</h3>

<p><code>cumulate()</code> computes the cumulative incidence over time for an
<a href="#topic+incidence">incidence2</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumulate(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumulate_+3A_x">x</code></td>
<td>
<p><a href="#topic+incidence">incidence2</a> object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- data.frame(
  dates = as.integer(c(0,1,2,2,3,5,7)),
  groups = factor(c(1, 2, 3, 3, 3, 3, 1))
)

i &lt;- incidence(dat, date_index = "dates", groups = "groups")
cumulate(i)


</code></pre>

<hr>
<h2 id='estimate_peak'>Estimate the peak date of an incidence curve</h2><span id='topic+estimate_peak'></span><span id='topic+estimate_peaks'></span>

<h3>Description</h3>

<p>This function can be used to estimate the peak of an epidemic curve using
bootstrapped samples of the available data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_peak(x, n = 100L, alpha = 0.05, first_only = TRUE, progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_peak_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+incidence">incidence2</a> object.</p>
</td></tr>
<tr><td><code id="estimate_peak_+3A_n">n</code></td>
<td>
<p><code>integer</code>.
</p>
<p>The number of bootstrap datasets to be generated; defaults to 100.
</p>
<p><code style="white-space: pre;">&#8288;[double]&#8288;</code> vectors will be converted via <code>as.integer(n)</code>.</p>
</td></tr>
<tr><td><code id="estimate_peak_+3A_alpha">alpha</code></td>
<td>
<p><code>numeric</code>.
</p>
<p>The type 1 error chosen for the confidence interval; defaults to 0.05.</p>
</td></tr>
<tr><td><code id="estimate_peak_+3A_first_only">first_only</code></td>
<td>
<p><code>bool</code>.
</p>
<p>Should only the first peak (by date) be kept.
</p>
<p>Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="estimate_peak_+3A_progress">progress</code></td>
<td>
<p><code>bool</code>.
</p>
<p>Should a progress bar be displayed (default = TRUE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input dates are resampled with replacement to form bootstrapped datasets;
the peak is reported for each, resulting in a distribution of peak times.
When there are ties for peak incidence, only the first date is reported.
</p>
<p>Note that the bootstrapping approach used for estimating the peak time makes
the following assumptions:
</p>

<ul>
<li><p> the total number of event is known (no uncertainty on total incidence)
</p>
</li>
<li><p> dates with no events (zero incidence) will never be in bootstrapped
datasets
</p>
</li>
<li><p> the reporting is assumed to be constant over time, i.e. every case is
equally likely to be reported
</p>
</li></ul>



<h3>Value</h3>

<p>A data frame with the the following columns:
</p>

<ul>
<li> <p><code>observed_date</code>: the date of peak incidence of the original dataset.
</p>
</li>
<li> <p><code>observed_count</code>: the peak incidence of the original dataset.
</p>
</li>
<li> <p><code>estimated</code>: the median peak time of the bootstrap datasets.
</p>
</li>
<li> <p><code>lower_ci/upper_ci</code>: the confidence interval based on bootstrap datasets.
</p>
</li>
<li> <p><code>bootstrap_peaks</code>: a nested tibble containing the the peak times of the
bootstrapped datasets.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thibaut Jombart and Tim Taylor, with inputs on caveats from Michael HÃ¶hle.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bootstrap_incidence">bootstrap_incidence()</a></code> for the bootstrapping underlying this approach and
<code><a href="#topic+keep_peaks">keep_peaks()</a></code> to get the peaks in a single
<a href="#topic+incidence">incidence2</a> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("outbreaks", quietly = TRUE)) {

  # load data and create incidence
  data(fluH7N9_china_2013, package = "outbreaks")
  i &lt;- incidence(fluH7N9_china_2013, date_index = "date_of_onset")

  # find 95% CI for peak time using bootstrap
  estimate_peak(i)
}


</code></pre>

<hr>
<h2 id='incidence'>Compute the incidence of events</h2><span id='topic+incidence'></span>

<h3>Description</h3>

<p><code>incidence()</code> calculates the <em>incidence</em> of different events across specified
time periods and groupings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incidence(
  x,
  date_index,
  groups = NULL,
  counts = NULL,
  count_names_to = "count_variable",
  count_values_to = "count",
  date_names_to = "date_index",
  rm_na_dates = TRUE,
  interval = NULL,
  offset = NULL,
  complete_dates = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="incidence_+3A_x">x</code></td>
<td>
<p>A data frame object representing a linelist or pre-aggregated dataset.</p>
</td></tr>
<tr><td><code id="incidence_+3A_date_index">date_index</code></td>
<td>
<p><code>character</code>.
</p>
<p>The time index(es) of the given data.
</p>
<p>This should be the name(s) corresponding to the desired date column(s) in x.
</p>
<p>A named vector can be used for convenient relabelling of the resultant output.
</p>
<p>Multiple indices only make sense when  <code>x</code> is a linelist.</p>
</td></tr>
<tr><td><code id="incidence_+3A_groups">groups</code></td>
<td>
<p><code>character</code>.
</p>
<p>An optional vector giving the names of the groups of observations for which
incidence should be grouped.
</p>
<p>A named vector can be used for convenient relabelling of the resultant output.</p>
</td></tr>
<tr><td><code id="incidence_+3A_counts">counts</code></td>
<td>
<p><code>character</code>.
</p>
<p>The count variables of the given data.  If NULL (default) the data is taken
to be a linelist of individual observations.
</p>
<p>A named vector can be used for convenient relabelling of the resultant output.</p>
</td></tr>
<tr><td><code id="incidence_+3A_count_names_to">count_names_to</code></td>
<td>
<p><code>character</code>.
</p>
<p>The column to create which will store the <code>counts</code> column names provided that
<code>counts</code> is not NULL.</p>
</td></tr>
<tr><td><code id="incidence_+3A_count_values_to">count_values_to</code></td>
<td>
<p><code>character</code>.
</p>
<p>The name of the column to store the resultant count values in.</p>
</td></tr>
<tr><td><code id="incidence_+3A_date_names_to">date_names_to</code></td>
<td>
<p><code>character</code>.
</p>
<p>The name of the column to store the date variables in.</p>
</td></tr>
<tr><td><code id="incidence_+3A_rm_na_dates">rm_na_dates</code></td>
<td>
<p><code>bool</code>.
</p>
<p>Should <code>NA</code> dates be removed prior to aggregation?</p>
</td></tr>
<tr><td><code id="incidence_+3A_interval">interval</code></td>
<td>
<p>An optional scalar integer or string indicating the (fixed) size of
the desired time interval you wish to use for for computing the incidence.
</p>
<p>Defaults to NULL in which case the date_index columns are left unchanged.
</p>
<p>Numeric values are coerced to integer and treated as a number of days to
group.
</p>
<p>Text strings can be one of:
</p>
<div class="sourceCode"><pre>* day or daily
* week(s) or weekly
* epiweek(s)
* isoweek(s)
* month(s) or monthly
* yearmonth(s)
* quarter(s) or quarterly
* yearquarter(s)
* year(s) or yearly
</pre></div>
<p>More details can be found in the &quot;Interval specification&quot; section.</p>
</td></tr>
<tr><td><code id="incidence_+3A_offset">offset</code></td>
<td>
<p>Only applicable when <code>interval</code> is not NULL.
</p>
<p>An optional scalar integer or date indicating the value you wish to start
counting periods from relative to the Unix Epoch:
</p>

<ul>
<li><p> Default value of NULL corresponds to 0L.
</p>
</li>
<li><p> For other integer values this is stored scaled by <code>n</code>
(<code>offset &lt;- as.integer(offset) %% n</code>).
</p>
</li>
<li><p> For date values this is first converted to an integer offset
(<code>offset &lt;- floor(as.numeric(offset))</code>) and then scaled via <code>n</code> as above.
</p>
</li></ul>
</td></tr>
<tr><td><code id="incidence_+3A_complete_dates">complete_dates</code></td>
<td>
<p><code>bool</code>.
</p>
<p>Should the resulting object have the same range of dates for each grouping.
</p>
<p>Missing counts will be filled with <code>0L</code>.
</p>
<p>Will attempt to use <code>function(x) seq(min(x), max(x), by = 1)</code> on the
resultant date_index column to generate a complete sequence of dates.
</p>
<p>More flexible completion is possible by using the <code>complete_dates()</code>
function.</p>
</td></tr>
<tr><td><code id="incidence_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>incidence2</code> objects are a sub class of data frame with some
additional invariants. That is, an <code>incidence2</code> object must:
</p>

<ul>
<li><p> have one column representing the date index (this does not need to be a
<code>date</code> object but must have an inherent ordering over time);
</p>
</li>
<li><p> have one column representing the count variable (i.e. what is being
counted) and one variable representing the associated count;
</p>
</li>
<li><p> have zero or more columns representing groups;
</p>
</li>
<li><p> not have duplicated rows with regards to the date and group variables.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code> with subclass <code>incidence2</code>.
</p>


<h3>Interval specification</h3>

<p>Where <code>interval</code> is specified, <code>incidence()</code>, predominantly uses the
<a href="https://cran.r-project.org/package=grates"><code>grates</code></a> package to generate
appropriate date groupings. The grouping used depends on the value of
<code>interval</code>. This can be specified as either an integer value or a string
corresponding to one of the classes:
</p>

<ul>
<li><p> integer values:                     <code><a href="grates.html#topic+new_period">&lt;grates_period&gt;</a></code> object, grouped by the specified number of days.
</p>
</li>
<li><p> day, daily:                         <code><a href="base.html#topic+Dates">&lt;Date&gt;</a></code> objects.
</p>
</li>
<li><p> week(s), weekly, isoweek:           <code><a href="grates.html#topic+isoweek">&lt;grates_isoweek&gt;</a></code> objects.
</p>
</li>
<li><p> epiweek(s):                         <code><a href="grates.html#topic+epiweek">&lt;grates_epiweek&gt;</a></code> objects.
</p>
</li>
<li><p> month(s), monthly, yearmonth:       <code><a href="grates.html#topic+yearmonth">&lt;grates_yearmonth&gt;</a></code> objects.
</p>
</li>
<li><p> quarter(s), quarterly, yearquarter: <code><a href="grates.html#topic+yearquarter">&lt;grates_yearquarter&gt;</a></code> objects.
</p>
</li>
<li><p> year(s) and yearly:                 <code><a href="grates.html#topic+year">&lt;grates_year&gt;</a></code> objects.
</p>
</li></ul>

<p>For &quot;day&quot; or &quot;daily&quot; interval, we provide a thin wrapper around <code>as.Date()</code>
that ensures the underlying data are whole numbers and that time zones are
respected. Note that additional arguments are not forwarded to <code>as.Date()</code>
so for greater flexibility users are advised to modifying your input prior to
calling <code>incidence()</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code>browseVignettes("grates")</code> for more details on the grate object classes.
</p>
</li>
<li> <p><code>incidence_()</code> for a version supporting
<a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a> semantics in some arguments.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("outbreaks", quietly = TRUE)) {
    data(ebola_sim_clean, package = "outbreaks")
    dat &lt;- ebola_sim_clean$linelist
    incidence(dat, "date_of_onset")
    incidence(dat, "date_of_onset", groups = c("gender", "hospital"))
}


</code></pre>

<hr>
<h2 id='incidence_'>Compute the incidence of events (tidyselect compatible)</h2><span id='topic+incidence_'></span>

<h3>Description</h3>

<p><code>incidence_()</code> calculates the <em>incidence</em> of different events across
specified time periods and groupings. It differs from <code>incidence()</code> only in
its support for <a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a>
semantics in some of its arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incidence_(
  x,
  date_index,
  groups = NULL,
  counts = NULL,
  count_names_to = "count_variable",
  count_values_to = "count",
  date_names_to = "date_index",
  rm_na_dates = TRUE,
  interval = NULL,
  offset = NULL,
  complete_dates = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="incidence__+3A_x">x</code></td>
<td>
<p>A data frame object representing a linelist or pre-aggregated dataset.</p>
</td></tr>
<tr><td><code id="incidence__+3A_date_index">date_index</code></td>
<td>
<p><a href="dplyr.html#topic+dplyr_tidy_select">tidyselect</a>.
</p>
<p>The time index(es) of the given data.
</p>
<p>This should be the name(s) corresponding to the desired date column(s) in x.
</p>
<p>A named vector can be used for convenient relabelling of the resultant output.
</p>
<p>Multiple indices only make sense when  <code>x</code> is a linelist.</p>
</td></tr>
<tr><td><code id="incidence__+3A_groups">groups</code></td>
<td>
<p><a href="dplyr.html#topic+dplyr_tidy_select">tidyselect</a>.
</p>
<p>An optional vector giving the names of the groups of observations for which
incidence should be grouped.
</p>
<p>A named vector can be used for convenient relabelling of the resultant output.</p>
</td></tr>
<tr><td><code id="incidence__+3A_counts">counts</code></td>
<td>
<p><a href="dplyr.html#topic+dplyr_tidy_select">tidyselect</a>.
</p>
<p>The count variables of the given data.  If NULL (default) the data is taken
to be a linelist of individual observations.
</p>
<p>A named vector can be used for convenient relabelling of the resultant output.</p>
</td></tr>
<tr><td><code id="incidence__+3A_count_names_to">count_names_to</code></td>
<td>
<p><code>character</code>.
</p>
<p>The column to create which will store the <code>counts</code> column names provided that
<code>counts</code> is not NULL.</p>
</td></tr>
<tr><td><code id="incidence__+3A_count_values_to">count_values_to</code></td>
<td>
<p><code>character</code>.
</p>
<p>The name of the column to store the resultant count values in.</p>
</td></tr>
<tr><td><code id="incidence__+3A_date_names_to">date_names_to</code></td>
<td>
<p><code>character</code>.
</p>
<p>The name of the column to store the date variables in.</p>
</td></tr>
<tr><td><code id="incidence__+3A_rm_na_dates">rm_na_dates</code></td>
<td>
<p><code>bool</code>.
</p>
<p>Should <code>NA</code> dates be removed prior to aggregation?</p>
</td></tr>
<tr><td><code id="incidence__+3A_interval">interval</code></td>
<td>
<p>An optional scalar integer or string indicating the (fixed) size of
the desired time interval you wish to use for for computing the incidence.
</p>
<p>Defaults to NULL in which case the date_index columns are left unchanged.
</p>
<p>Numeric values are coerced to integer and treated as a number of days to
group.
</p>
<p>Text strings can be one of:
</p>
<div class="sourceCode"><pre>* day or daily
* week(s) or weekly
* epiweek(s)
* isoweek(s)
* month(s) or monthly
* yearmonth(s)
* quarter(s) or quarterly
* yearquarter(s)
* year(s) or yearly
</pre></div>
<p>More details can be found in the &quot;Interval specification&quot; section.</p>
</td></tr>
<tr><td><code id="incidence__+3A_offset">offset</code></td>
<td>
<p>Only applicable when <code>interval</code> is not NULL.
</p>
<p>An optional scalar integer or date indicating the value you wish to start
counting periods from relative to the Unix Epoch:
</p>

<ul>
<li><p> Default value of NULL corresponds to 0L.
</p>
</li>
<li><p> For other integer values this is stored scaled by <code>n</code>
(<code>offset &lt;- as.integer(offset) %% n</code>).
</p>
</li>
<li><p> For date values this is first converted to an integer offset
(<code>offset &lt;- floor(as.numeric(offset))</code>) and then scaled via <code>n</code> as above.
</p>
</li></ul>
</td></tr>
<tr><td><code id="incidence__+3A_complete_dates">complete_dates</code></td>
<td>
<p><code>bool</code>.
</p>
<p>Should the resulting object have the same range of dates for each grouping.
</p>
<p>Missing counts will be filled with <code>0L</code>.
</p>
<p>Will attempt to use <code>function(x) seq(min(x), max(x), by = 1)</code> on the
resultant date_index column to generate a complete sequence of dates.
</p>
<p>More flexible completion is possible by using the <code>complete_dates()</code></p>
</td></tr>
<tr><td><code id="incidence__+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code style="white-space: pre;">&#8288;&lt;incidence2&gt;&#8288;</code> objects are a sub class of data frame with some
additional invariants. That is, an <code style="white-space: pre;">&#8288;&lt;incidence2&gt;&#8288;</code> object must:
</p>

<ul>
<li><p> have one column representing the date index (this does not need to be a
<code>date</code> object but must have an inherent ordering over time);
</p>
</li>
<li><p> have one column representing the count variable (i.e. what is being
counted) and one variable representing the associated count;
</p>
</li>
<li><p> have zero or more columns representing groups;
</p>
</li>
<li><p> not have duplicated rows with regards to the date and group variables.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code> with subclass <code>incidence2</code>.
</p>


<h3>Interval specification</h3>

<p>Where <code>interval</code> is specified, <code>incidence_()</code>, predominantly uses the
<a href="https://cran.r-project.org/package=grates"><code>grates</code></a> package to generate
appropriate date groupings. The grouping used depends on the value of
<code>interval</code>. This can be specified as either an integer value or a string
corresponding to one of the classes:
</p>

<ul>
<li><p> integer values:                     <code><a href="grates.html#topic+new_period">&lt;grates_period&gt;</a></code> object, grouped by the specified number of days.
</p>
</li>
<li><p> day, daily:                         <code><a href="base.html#topic+Dates">&lt;Date&gt;</a></code> objects.
</p>
</li>
<li><p> week(s), weekly, isoweek:           <code><a href="grates.html#topic+isoweek">&lt;grates_isoweek&gt;</a></code> objects.
</p>
</li>
<li><p> epiweek(s):                         <code><a href="grates.html#topic+epiweek">&lt;grates_epiweek&gt;</a></code> objects.
</p>
</li>
<li><p> month(s), monthly, yearmonth:       <code><a href="grates.html#topic+yearmonth">&lt;grates_yearmonth&gt;</a></code> objects.
</p>
</li>
<li><p> quarter(s), quarterly, yearquarter: <code><a href="grates.html#topic+yearquarter">&lt;grates_yearquarter&gt;</a></code> objects.
</p>
</li>
<li><p> year(s) and yearly:                 <code><a href="grates.html#topic+year">&lt;grates_year&gt;</a></code> objects.
</p>
</li></ul>

<p>For &quot;day&quot; or &quot;daily&quot; interval, we provide a thin wrapper around <code>as.Date()</code>
that ensures the underlying data are whole numbers and that time zones are
respected. Note that additional arguments are not forwarded to <code>as.Date()</code>
so for greater flexibility users are advised to modifying your input prior to
calling <code>incidence_()</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code>browseVignettes("grates")</code> for more details on the grate object classes.
</p>
</li>
<li> <p><code>incidence()</code> for a the underlying function without support for tidyselect
semantics. This may be preferable for programatic usage.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("outbreaks", quietly = TRUE)) {
    data(ebola_sim_clean, package = "outbreaks")
    dat &lt;- ebola_sim_clean$linelist
    incidence_(dat, date_of_onset)
    incidence_(dat, date_of_onset, groups = c(gender, hospital))
}


</code></pre>

<hr>
<h2 id='incidence2-defunct'>Functions now defunct in package incidence2</h2><span id='topic+incidence2-defunct'></span><span id='topic+new_incidence'></span><span id='topic+validate_incidence'></span><span id='topic+build_incidence'></span><span id='topic+get_n'></span><span id='topic+get_interval'></span><span id='topic+get_timespan'></span><span id='topic+facet_plot'></span>

<h3>Description</h3>

<p>These functions are now defunct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_incidence(
  x,
  date,
  groups = NULL,
  counts,
  measurements = NULL,
  validate = TRUE
)

validate_incidence(x)

build_incidence(
  x,
  date_index,
  groups = NULL,
  counts = NULL,
  na_as_group = TRUE,
  FUN = identity,
  args = list()
)

get_n(x)

get_interval(x, ...)

get_timespan(x, ...)

facet_plot(x, ...)
</code></pre>

<hr>
<h2 id='keep'>Keep first, last and peak occurences</h2><span id='topic+keep'></span><span id='topic+keep_first'></span><span id='topic+keep_last'></span><span id='topic+keep_peaks'></span><span id='topic+first_peak'></span>

<h3>Description</h3>

<p><code>keep_first()</code> and <code>keep_last()</code> keep the first and last <code>n</code> rows to occur
for each grouping when in ascending date order. <code>keep_peaks()</code> keeps the rows
with the maximum count value for each group. <code>first_peak()</code> is a convenience
wrapper around <code>keep_peaks()</code> with the <code>first_only</code> argument set to <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keep_first(x, n, complete_dates = TRUE, ...)

keep_last(x, n, complete_dates = TRUE, ...)

keep_peaks(x, complete_dates = TRUE, first_only = FALSE, ...)

first_peak(x, complete_dates = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keep_+3A_x">x</code></td>
<td>
<p><a href="#topic+incidence">incidence2</a> object.</p>
</td></tr>
<tr><td><code id="keep_+3A_n">n</code></td>
<td>
<p><code>integer</code>.
</p>
<p>Number of entries to keep.
</p>
<p><code>double</code> vectors will be converted via <code>as.integer(n)</code>.</p>
</td></tr>
<tr><td><code id="keep_+3A_complete_dates">complete_dates</code></td>
<td>
<p><code>bool</code>.
</p>
<p>Should <code>complete_dates()</code> be called on the data prior to keeping the first
entries.
</p>
<p>Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="keep_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>complete_dates()</code>.</p>
</td></tr>
<tr><td><code id="keep_+3A_first_only">first_only</code></td>
<td>
<p><code>bool</code>.
</p>
<p>Should only the first peak (by date) be kept.
</p>
<p>Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+incidence">incidence2</a> object with the chosen entries.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("outbreaks", quietly = TRUE)) {
    data(ebola_sim_clean, package = "outbreaks")
    dat &lt;- ebola_sim_clean$linelist
    inci &lt;- incidence(dat, "date_of_onset")
    keep_first(inci, 3)
    keep_last(inci, 3)
}


</code></pre>

<hr>
<h2 id='mutate.incidence2'>Create, modify, and delete incidence2 columns</h2><span id='topic+mutate.incidence2'></span>

<h3>Description</h3>

<p>Method for <a href="dplyr.html#topic+mutate">dplyr::mutate</a> that implicitly accounts for the inherent
grouping structure of incidence2 objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'incidence2'
mutate(
  .data,
  ...,
  .by,
  .keep = c("all", "used", "unused", "none"),
  .before = NULL,
  .after = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate.incidence2_+3A_.data">.data</code></td>
<td>
<p>An <a href="#topic+incidence">incidence2</a> object.</p>
</td></tr>
<tr><td><code id="mutate.incidence2_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs.
The name gives the name of the column in the output.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li><p> A vector the same length as the current group (or the whole data frame
if ungrouped).
</p>
</li>
<li> <p><code>NULL</code>, to remove the column.
</p>
</li>
<li><p> A data frame or tibble, to create multiple columns in the output.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mutate.incidence2_+3A_.by">.by</code></td>
<td>
<p>Not used as grouping structure implicit.</p>
</td></tr>
<tr><td><code id="mutate.incidence2_+3A_.keep">.keep</code></td>
<td>
<p>Control which columns from <code>.data</code> are retained in the output. Grouping
columns and columns created by <code>...</code> are always kept.
</p>

<ul>
<li> <p><code>"all"</code> retains all columns from <code>.data</code>. This is the default.
</p>
</li>
<li> <p><code>"used"</code> retains only the columns used in <code>...</code> to create new
columns. This is useful for checking your work, as it displays inputs
and outputs side-by-side.
</p>
</li>
<li> <p><code>"unused"</code> retains only the columns <em>not</em> used in <code>...</code> to create new
columns. This is useful if you generate new columns, but no longer need
the columns used to generate them.
</p>
</li>
<li> <p><code>"none"</code> doesn't retain any extra columns from <code>.data</code>. Only the grouping
variables and columns created by <code>...</code> are kept.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mutate.incidence2_+3A_.before">.before</code>, <code id="mutate.incidence2_+3A_.after">.after</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, control where new columns
should appear (the default is to add to the right hand side). See
<code><a href="dplyr.html#topic+relocate">relocate()</a></code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified <a href="#topic+incidence">incidence2</a> object if the necessary
invariants are preserved, otherwise a <a href="tibble.html#topic+tibble">tibble</a>.
</p>


<h3>See Also</h3>

<p><a href="dplyr.html#topic+mutate">dplyr::mutate</a> for the underlying generic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("outbreaks", quietly = TRUE) &amp;&amp; requireNamespace("ggplot2", quietly = TRUE)) {
    data(ebola_sim_clean, package = "outbreaks")
    ebola_sim_clean$linelist |&gt;
        subset(!is.na(hospital)) |&gt;
        incidence_(date_of_onset, hospital, interval = "isoweek") |&gt;
        mutate(ave = data.table::frollmean(count, n = 3L, align = "right")) |&gt;
        plot(border_colour = "white", angle = 45) +
        ggplot2::geom_line(ggplot2::aes(x = date_index, y = ave))
}


</code></pre>

<hr>
<h2 id='nest.incidence2'>Nest rows into a list-column of data frames</h2><span id='topic+nest.incidence2'></span>

<h3>Description</h3>

<p>Method for <a href="tidyr.html#topic+nest">tidyr::nest</a> that implicitly accounts for the inherent
grouping structure of incidence2 objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'incidence2'
nest(.data, ..., .by, .key, .names_sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest.incidence2_+3A_.data">.data</code></td>
<td>
<p>An <a href="#topic+incidence">incidence2</a> object.</p>
</td></tr>
<tr><td><code id="nest.incidence2_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="nest.incidence2_+3A_.by">.by</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="nest.incidence2_+3A_.key">.key</code></td>
<td>
<p>The name of the resulting nested column. Only applicable when
<code>...</code> isn't specified, i.e. in the case of <code>df %&gt;% nest(.by = x)</code>.
</p>
<p>If <code>NULL</code>, then <code>"data"</code> will be used by default.</p>
</td></tr>
<tr><td><code id="nest.incidence2_+3A_.names_sep">.names_sep</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nested <a href="tibble.html#topic+tibble">tibble</a> with rows corresponding to the count
variable and (optionally) group columns of the input object.
</p>


<h3>See Also</h3>

<p><a href="tidyr.html#topic+nest">tidyr::nest</a> for the underlying generic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("outbreaks", quietly = TRUE)) {
    data(ebola_sim_clean, package = "outbreaks")
    ebola_sim_clean$linelist |&gt;
        subset(!is.na(hospital)) |&gt;
        incidence_(date_of_onset, hospital, interval = "isoweek") |&gt;
        nest()
}


</code></pre>

<hr>
<h2 id='plot.incidence2'>Plot an incidence object</h2><span id='topic+plot.incidence2'></span>

<h3>Description</h3>

<p><code>plot()</code> can be used to provide a bar plot of an incidence object. Due
to the complexities with automating plotting it is some what experimental in
nature and it may be better to use ggplot2 directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'incidence2'
plot(
  x,
  y,
  width = 1,
  colour_palette = vibrant,
  border_colour = NA,
  na_colour = "grey",
  alpha = 0.7,
  fill = NULL,
  legend = c("right", "left", "bottom", "top", "none"),
  title = NULL,
  angle = 0,
  size = NULL,
  nrow = NULL,
  n_breaks = 6L,
  show_cases = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.incidence2_+3A_x">x</code></td>
<td>
<p><a href="#topic+incidence">incidence2</a> object.</p>
</td></tr>
<tr><td><code id="plot.incidence2_+3A_y">y</code></td>
<td>
<p>Not used.
</p>
<p>Required for compatibility with the <code>plot()</code> generic.</p>
</td></tr>
<tr><td><code id="plot.incidence2_+3A_width">width</code></td>
<td>
<p><code>numeric</code>.
</p>
<p>Value between 0 and 1 indicating the relative size of the bars to the
interval.
</p>
<p>Default 1.</p>
</td></tr>
<tr><td><code id="plot.incidence2_+3A_colour_palette">colour_palette</code></td>
<td>
<p><code>function</code>.
</p>
<p>The color palette to be used for the different count variables.
</p>
<p>Defaults to <code>vibrant</code> (see <code>?palettes</code>).</p>
</td></tr>
<tr><td><code id="plot.incidence2_+3A_border_colour">border_colour</code></td>
<td>
<p><code>character</code>.
</p>
<p>The color to be used for the borders of the bars.
</p>
<p>Use <code>NA</code> (default) for invisible borders.</p>
</td></tr>
<tr><td><code id="plot.incidence2_+3A_na_colour">na_colour</code></td>
<td>
<p><code>character</code>.
</p>
<p>The colour to plot <code>NA</code> values in graphs.
</p>
<p>Defaults to <code>grey</code>.</p>
</td></tr>
<tr><td><code id="plot.incidence2_+3A_alpha">alpha</code></td>
<td>
<p><code>numeric</code>.
</p>
<p>The alpha level for color transparency, with 1 being fully opaque and
0 fully transparent
</p>
<p>Defaults to 0.7.</p>
</td></tr>
<tr><td><code id="plot.incidence2_+3A_fill">fill</code></td>
<td>
<p><code>character</code>.
</p>
<p>Which variable to colour plots by.
</p>
<p>Must be a <code>group</code> or <code>count</code> variable and will mean that variable is not used
for facetting.
</p>
<p>If NULL no distinction if made for plot colours.</p>
</td></tr>
<tr><td><code id="plot.incidence2_+3A_legend">legend</code></td>
<td>
<p><code>character</code>.
</p>
<p>Position of legend in plot.
</p>
<p>Only applied if <code>fill</code> is not NULL.
</p>
<p>One of &quot;right&quot; (default), &quot;left&quot;, &quot;bottom&quot;, &quot;top&quot; or &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="plot.incidence2_+3A_title">title</code></td>
<td>
<p><code>character</code>.
</p>
<p>Optional title for the graph.</p>
</td></tr>
<tr><td><code id="plot.incidence2_+3A_angle">angle</code></td>
<td>
<p><code>numeric</code>.
</p>
<p>Rotation angle for text.</p>
</td></tr>
<tr><td><code id="plot.incidence2_+3A_size">size</code></td>
<td>
<p><code>numeric</code>.
</p>
<p>text size in pts.</p>
</td></tr>
<tr><td><code id="plot.incidence2_+3A_nrow">nrow</code></td>
<td>
<p><code>integer</code>.
</p>
<p>Number of rows used for facetting if there are group variables present and
just one count in the incidence object.
</p>
<p>Numeric values are coerced to integer via <code>as.integer()</code>.</p>
</td></tr>
<tr><td><code id="plot.incidence2_+3A_n_breaks">n_breaks</code></td>
<td>
<p><code>integer</code>.
</p>
<p>Approximate number of breaks calculated using <code>scales::breaks_pretty()</code>.
</p>
<p>Numeric values are coerced to integer via <code>as.integer()</code>.
</p>
<p>Default 6L.</p>
</td></tr>
<tr><td><code id="plot.incidence2_+3A_show_cases">show_cases</code></td>
<td>
<p><code>logical</code>.
</p>
<p>if <code>TRUE</code>, then each observation will be shown individually in a square
format.
</p>
<p>Normally only used for outbreaks with a small number of cases.
</p>
<p>Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.incidence2_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Faceting will occur automatically if either grouping variables or
multiple counts are present.
</p>
</li>
<li><p> If there are multiple count variables, each count will occupy a different
row of the resulting plot.
</p>
</li>
<li><p> Utilises ggplot2 so this must be installed to use.
</p>
</li></ul>



<h3>Value</h3>


<ul>
<li><p> A <code>ggplot2::ggplot()</code> object.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("outbreaks", quietly = TRUE) &amp;&amp; requireNamespace("ggplot2", quietly = TRUE)) {
    data(ebola_sim_clean, package = "outbreaks")
    dat &lt;- ebola_sim_clean$linelist

    inci &lt;- incidence(dat, date_index = "date_of_onset", groups = "hospital")
    plot(inci, angle = 45)

    inci2 &lt;- regroup(inci)
    plot(inci2)
}


</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+as.data.table'></span><span id='topic+as_tibble'></span><span id='topic+mutate'></span><span id='topic+nest'></span><span id='topic+summarise'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>data.table</dt><dd><p><code><a href="data.table.html#topic+as.data.table">as.data.table</a></code></p>
</dd>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+mutate">mutate</a></code>, <code><a href="dplyr.html#topic+summarise">summarise</a></code></p>
</dd>
<dt>tibble</dt><dd><p><code><a href="tibble.html#topic+as_tibble">as_tibble</a></code></p>
</dd>
<dt>tidyr</dt><dd><p><code><a href="tidyr.html#topic+nest">nest</a></code></p>
</dd>
</dl>

<hr>
<h2 id='regroup'>Regroup 'incidence' objects</h2><span id='topic+regroup'></span>

<h3>Description</h3>

<p>This function regroups an <a href="#topic+incidence">incidence2</a> object across
the specified groups. The resulting <a href="#topic+incidence">incidence2</a>
object will contains counts aggregated over the specified groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regroup(x, groups = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regroup_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;incidence2&gt;&#8288;</code> object.</p>
</td></tr>
<tr><td><code id="regroup_+3A_groups">groups</code></td>
<td>
<p><code>character</code>.
</p>
<p>The groups to sum over.
</p>
<p>If <code>NULL</code> (default) then the function returns the corresponding object with
no groupings.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code>regroup_()</code> for a version supporting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("outbreaks", quietly = TRUE)) {
    data(ebola_sim_clean, package = "outbreaks")
    dat &lt;- ebola_sim_clean$linelist
    i &lt;- incidence(
        dat,
        date_index = "date_of_onset",
        groups = c("gender", "hospital")
    )
    regroup(i)
    regroup(i, "hospital")
}


</code></pre>

<hr>
<h2 id='regroup_'>Regroup 'incidence' objects (tidyselect compatible)</h2><span id='topic+regroup_'></span>

<h3>Description</h3>

<p>This function regroups an <code style="white-space: pre;">&#8288;&lt;incidence2&gt;&#8288;</code> object across the specified groups.
The resulting <code style="white-space: pre;">&#8288;&lt;incidence2&gt;&#8288;</code> object will contains counts summed over the
groups present in the input.  It differs from <code>regroup()</code> only in
support for <code><a href="dplyr.html#topic+dplyr_tidy_select">&lt;tidy-select&gt;</a></code>
semantics in the <code>groups</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regroup_(x, groups = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regroup__+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;incidence2&gt;&#8288;</code> object.</p>
</td></tr>
<tr><td><code id="regroup__+3A_groups">groups</code></td>
<td>
<p><code><a href="dplyr.html#topic+dplyr_tidy_select">&lt;tidyselect&gt;</a></code>
</p>
<p>The groups to sum over.
</p>
<p>If <code>NULL</code> (default) then the function returns the corresponding object with
no groupings.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code>regroup()</code> for a version without tidyselect semantics. This may be
preferable for programatic usage.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("outbreaks", quietly = TRUE)) {
    data(ebola_sim_clean, package = "outbreaks")
    dat &lt;- ebola_sim_clean$linelist
    i &lt;- incidence_(
        dat,
        date_index = date_of_onset,
        groups = c(gender, hospital)
    )
    regroup_(i)
    regroup_(i, hospital)
}


</code></pre>

<hr>
<h2 id='split.incidence2'>Divide an incidence2 object in to it's implicit groupings</h2><span id='topic+split.incidence2'></span>

<h3>Description</h3>

<p>Split divides and <a href="#topic+incidence">incidence2</a> object in to it's
underlying groupings (count variable and optionally groups).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'incidence2'
split(x, f, drop, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split.incidence2_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+incidence">incidence2</a> object.</p>
</td></tr>
<tr><td><code id="split.incidence2_+3A_f">f</code></td>
<td>
<p>Not used. Present only for generic compatibility.</p>
</td></tr>
<tr><td><code id="split.incidence2_+3A_drop">drop</code></td>
<td>
<p>Not used. Present only for generic compatibility.</p>
</td></tr>
<tr><td><code id="split.incidence2_+3A_...">...</code></td>
<td>
<p>Not used. Present only for generic compatibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of tibbles contained the split data. This list also has a &quot;key&quot;
attribute which is a tibble with rows corresponding to the grouping of
each split.
</p>


<h3>See Also</h3>

<p><code><a href="vctrs.html#topic+vec_split">vctrs::vec_split()</a></code> on which <code>split.incidence2()</code> is built.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("outbreaks", quietly = TRUE)) {
    data(ebola_sim_clean, package = "outbreaks")
    ebola_sim_clean$linelist |&gt;
        subset(!is.na(hospital)) |&gt;
        incidence_(date_of_onset, hospital, interval = "isoweek") |&gt;
        split()
}


</code></pre>

<hr>
<h2 id='summarise.incidence2'>Summarise each grouping down to one row</h2><span id='topic+summarise.incidence2'></span>

<h3>Description</h3>

<p>Method for <a href="dplyr.html#topic+summarise">dplyr::summarise</a> that implicitly accounts for the inherent
grouping structure of <a href="#topic+incidence">incidence2</a> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'incidence2'
summarise(.data, ..., .by, .groups)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarise.incidence2_+3A_.data">.data</code></td>
<td>
<p>An <a href="#topic+incidence">incidence2</a> object.</p>
</td></tr>
<tr><td><code id="summarise.incidence2_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs.
The name gives the name of the column in the output.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li><p> A vector the same length as the current group (or the whole data frame
if ungrouped).
</p>
</li>
<li> <p><code>NULL</code>, to remove the column.
</p>
</li>
<li><p> A data frame or tibble, to create multiple columns in the output.
</p>
</li></ul>
</td></tr>
<tr><td><code id="summarise.incidence2_+3A_.by">.by</code></td>
<td>
<p>Not used as grouping structure implicit.</p>
</td></tr>
<tr><td><code id="summarise.incidence2_+3A_.groups">.groups</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tibble">tibble</a>.
</p>


<h3>See Also</h3>

<p><a href="dplyr.html#topic+summarise">dplyr::summarise</a> for the underlying grouping.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("outbreaks", quietly = TRUE)) {
    data(ebola_sim_clean, package = "outbreaks")
    ebola_sim_clean$linelist |&gt;
        subset(!is.na(hospital)) |&gt;
        incidence_(date_of_onset, hospital, interval = "isoweek") |&gt;
        summarise(model = list(glm(count ~ date_index, family = "poisson")))
}


</code></pre>

<hr>
<h2 id='summary.incidence2'>Summary of an incidence object</h2><span id='topic+summary.incidence2'></span>

<h3>Description</h3>

<p>Summary of an incidence object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'incidence2'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.incidence2_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+incidence">incidence2</a> object.</p>
</td></tr>
<tr><td><code id="summary.incidence2_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object (invisibly).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ebola_sim_clean, package = "outbreaks")
dat &lt;- ebola_sim_clean$linelist
inci &lt;- incidence(dat, "date_of_onset", groups = c("gender", "hospital"))
summary(inci)


</code></pre>

<hr>
<h2 id='vibrant'>Color palettes used in incidence</h2><span id='topic+vibrant'></span><span id='topic+palettes'></span><span id='topic+muted'></span>

<h3>Description</h3>

<p>These functions are color palettes used in incidence. The palettes come from
https://personal.sron.nl/~pault/#sec:qualitative and exclude <code>grey</code>, which
is reserved for missing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vibrant(n)

muted(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vibrant_+3A_n">n</code></td>
<td>
<p><code>integer</code>.
</p>
<p>Number of colours.
</p>
<p><code>double</code> vectors will be converted via <code>as.integer(n)</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>vibrant(5)
muted(10)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
