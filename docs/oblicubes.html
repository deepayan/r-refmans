<!DOCTYPE html><html><head><title>Help for package oblicubes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {oblicubes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cheap_darken'><p>'light' effect helper functions</p></a></li>
<li><a href='#geom_oblicubes'><p>Draw 2D/3D cubes with ggplot2</p></a></li>
<li><a href='#geom_oblicuboids'><p>Draw 2D/3D cuboids with ggplot2</p></a></li>
<li><a href='#oblicubes-package'><p>oblicubes: 3D Rendering Using Obliquely Projected Cubes and Cuboids</p></a></li>
<li><a href='#oblicubesGrob'><p>Render 2D/3D cubes via an oblique projection</p></a></li>
<li><a href='#oblicuboidsGrob'><p>Render 2D/3D cuboids via an oblique projection</p></a></li>
<li><a href='#xyz_heightmap'><p>Calculate x,y,z coordinates from a height matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>3D Rendering Using Obliquely Projected Cubes and Cuboids</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Three-dimensional rendering for 'grid' and 'ggplot2' graphics using cubes and cuboids drawn with an oblique projection.  As a special case also supports primary view orthographic projections.  Can be viewed as an extension to the 'isocubes' package <a href="https://github.com/coolbutuseless/isocubes">https://github.com/coolbutuseless/isocubes</a>.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://trevorldavis.com/R/oblicubes/">https://trevorldavis.com/R/oblicubes/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/trevorld/oblicubes/issues">https://github.com/trevorld/oblicubes/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, grid, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>datasets, dplyr, ggplot2, knitr, rmarkdown, testthat (&ge;
3.0.0), vdiffr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-24 16:18:59 UTC; trevor</td>
</tr>
<tr>
<td>Author:</td>
<td>Trevor L Davis <a href="https://orcid.org/0000-0001-6341-4639"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Mike FC [aut] (Some code adapted from isocubes)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Trevor L Davis &lt;trevor.l.davis@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-27 14:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cheap_darken'>'light' effect helper functions</h2><span id='topic+cheap_darken'></span><span id='topic+darken_face'></span>

<h3>Description</h3>

<p>Helper functions to generate a &ldquo;light&rdquo; effect
for <code><a href="#topic+oblicubesGrob">oblicubesGrob()</a></code>, <code><a href="#topic+grid.oblicubes">grid.oblicubes()</a></code>, <code><a href="#topic+oblicuboidsGrob">oblicuboidsGrob()</a></code>, and <code><a href="#topic+grid.oblicuboids">grid.oblicuboids()</a></code>.
<code>darken_face()</code> is the default <code>light</code> argument for <code><a href="#topic+oblicubesGrob">oblicubesGrob()</a></code>, <code><a href="#topic+grid.oblicubes">grid.oblicubes()</a></code>,
<code><a href="#topic+oblicuboidsGrob">oblicuboidsGrob()</a></code>, and <code><a href="#topic+grid.oblicuboids">grid.oblicuboids()</a></code>.
<code>cheap_darken()</code> is the default darkening function used by <code>darken_face()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cheap_darken(col, amount)

darken_face(
  face,
  col,
  top = 0,
  west = 0.2,
  east = 0.2,
  south = 0.4,
  north = 0.4,
  darken_fn = cheap_darken
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cheap_darken_+3A_col">col</code></td>
<td>
<p>Vector of colors to darken</p>
</td></tr>
<tr><td><code id="cheap_darken_+3A_amount">amount</code></td>
<td>
<p>Fraction to darken by</p>
</td></tr>
<tr><td><code id="cheap_darken_+3A_face">face</code></td>
<td>
<p>Cube/cuboid face to color.  One of &quot;top&quot;, &quot;west&quot;, &quot;east&quot;, &quot;south&quot;, or &quot;north&quot;.</p>
</td></tr>
<tr><td><code id="cheap_darken_+3A_top">top</code></td>
<td>
<p>Amount to darken the &quot;top&quot; face.</p>
</td></tr>
<tr><td><code id="cheap_darken_+3A_west">west</code></td>
<td>
<p>Amount to darken the &quot;west&quot; face.</p>
</td></tr>
<tr><td><code id="cheap_darken_+3A_east">east</code></td>
<td>
<p>Amount to darken the &quot;east&quot; face.</p>
</td></tr>
<tr><td><code id="cheap_darken_+3A_south">south</code></td>
<td>
<p>Amount to darken the &quot;south&quot; face.</p>
</td></tr>
<tr><td><code id="cheap_darken_+3A_north">north</code></td>
<td>
<p>Amount to darken the &quot;north&quot; face.</p>
</td></tr>
<tr><td><code id="cheap_darken_+3A_darken_fn">darken_fn</code></td>
<td>
<p>Function to darken with.  Should take two arguments:
the first should be the colour and the second should be numeric amount to darken by.
Default will be to use <code><a href="#topic+cheap_darken">cheap_darken()</a></code>.
<code>colorspace::darken()</code> is a slower, &ldquo;better&rdquo; alternative.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>light</code> argument of <code><a href="#topic+oblicubesGrob">oblicubesGrob()</a></code>, <code><a href="#topic+grid.oblicubes">grid.oblicubes()</a></code>, <code><a href="#topic+geom_oblicubes">geom_oblicubes()</a></code>,
<code><a href="#topic+oblicuboidsGrob">oblicuboidsGrob()</a></code>, <code><a href="#topic+grid.oblicuboids">grid.oblicuboids()</a></code>, and <code><a href="#topic+geom_oblicuboids">geom_oblicuboids()</a></code>
needs a function that that takes two arguments: the first is <code>face</code> one of its five faces:
&quot;top&quot;, &quot;west&quot;, &quot;east&quot;, &quot;south&quot;, or &quot;north&quot; and the second is <code>col</code> the cube/cuboid's fill color
</p>


<h3>Value</h3>

<p>Vector of darkened colors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>demo_light &lt;- function(light = darken_face, ...) {
  df &lt;- data.frame(x=1, y=1, z=1)
  grid::grid.newpage()
  grid.oblicubes(df, ..., light=light, angle=45, lwd=4,
                 vp = grid::viewport(0.25, 0.25, 0.5, 0.5))
  grid.oblicubes(df, ..., light=light, angle=135, lwd=4,
                 vp = grid::viewport(0.75, 0.25, 0.5, 0.5))
  grid.oblicubes(df, ..., light=light, angle=-45, lwd=4,
                 vp = grid::viewport(0.25, 0.75, 0.5, 0.5))
  grid.oblicubes(df, ..., light=light, angle=-135, lwd=4,
                 vp = grid::viewport(0.75, 0.75, 0.5, 0.5))
}
demo_light()
demo_light(fill = "gold")
demo_light(light = function(face, col)
             darken_face(face, col, top = 0.3,
                         west = 0.6, east = 0.6,
                         south = 0.0, north = 0.0)
)
demo_light(light = function(face, col) {
             n &lt;- length(col)
             switch(face,
               top = rep_len("grey90", n),
               west = rep_len("red", n),
               east = rep_len("green", n),
               south = rep_len("blue", n),
               north = rep_len("yellow", n))
           })
</code></pre>

<hr>
<h2 id='geom_oblicubes'>Draw 2D/3D cubes with ggplot2</h2><span id='topic+geom_oblicubes'></span>

<h3>Description</h3>

<p><code>geom_oblicubes()</code> creates a <code>ggplot2</code> geom that draws cubes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_oblicubes(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  angle = 45,
  scale = 0.5,
  xoffset = 0,
  yoffset = 0,
  zoffset = 0,
  light = darken_face,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_oblicubes_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code> or
<code><a href="ggplot2.html#topic+aes_">aes_()</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_oblicubes_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_oblicubes_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, as a string.</p>
</td></tr>
<tr><td><code id="geom_oblicubes_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_oblicubes_+3A_...">...</code></td>
<td>
<p>Aesthetics, used to set an aesthetic to a fixed value.</p>
</td></tr>
<tr><td><code id="geom_oblicubes_+3A_angle">angle</code></td>
<td>
<p>Oblique projection angle.</p>
</td></tr>
<tr><td><code id="geom_oblicubes_+3A_scale">scale</code></td>
<td>
<p>Oblique projection foreshortening factor.
0.5 corresponds to the &ldquo;cabinet projection&rdquo;.
1.0 corresponds to the &ldquo;cavalier projection&rdquo;.
0.0 corresponds to a &ldquo;primary view orthographic projection&rdquo;.</p>
</td></tr>
<tr><td><code id="geom_oblicubes_+3A_xoffset">xoffset</code>, <code id="geom_oblicubes_+3A_yoffset">yoffset</code>, <code id="geom_oblicubes_+3A_zoffset">zoffset</code></td>
<td>
<p>By default the x,y,z values are assumed to be the <strong>center</strong> of the cube.
Use <code>xoffset</code>, <code>yoffset</code>, and/or <code>zoffset</code> to shift the x,y,z values a fixed amount.</p>
</td></tr>
<tr><td><code id="geom_oblicubes_+3A_light">light</code></td>
<td>
<p>If <code>FALSE</code> don't perform a &quot;light&quot; effect.
Otherwise a function that takes two arguments:
the first <code>face</code> of the cube/cuboid face
(one of &quot;top&quot;, &quot;west&quot;, &quot;east&quot;, &quot;south&quot;, &quot;north&quot;).
the second <code>col</code> of the fill color.
By default we use <code><a href="#topic+darken_face">darken_face()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_oblicubes_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_oblicubes_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>geom_oblicubes()</code> requires a fixed scale coordinate system with an aspect
ratio of 1 as provided by <code>ggplot2::coord_fixed()</code>.
</p>


<h3>Value</h3>

<p>A ggplot2 geom.
</p>


<h3>Aesthetics</h3>

<p><code>geom_oblicubes()</code> understands the following aesthetics (required aesthetics are in bold).
See <code><a href="#topic+oblicubesGrob">oblicubesGrob()</a></code> for more details.
</p>

<ul>
<li> <p><strong><code>x</code></strong>
</p>
</li>
<li> <p><strong><code>y</code></strong>
</p>
</li>
<li> <p><code>z</code>
</p>
</li>
<li> <p><code>fill</code>
</p>
</li>
<li> <p><code>colour</code>
</p>
</li>
<li> <p><code>linetype</code>
</p>
</li>
<li> <p><code>linewidth</code>
</p>
</li></ul>



<h3>See Also</h3>

<p><code>geom_oblicubes()</code> is a wrapper around <code><a href="#topic+oblicubesGrob">oblicubesGrob()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("ggplot2")) {
  data("volcano", package = "datasets")
  df &lt;- xyz_heightmap(volcano, scale = 0.3, min = 1)
  g &lt;- ggplot(df, aes(x, y, z = z, fill = raw)) +
         geom_oblicubes(light = FALSE) +
         coord_fixed() +
         scale_fill_gradientn(name = "Height (m)",
                              colours=terrain.colors(256)) +
         labs(x = "East (10m)", y = "North (10m)",
              title = "Maungawhau (`datasets::volcano`)")
  plot(g)
}

if (require("ggplot2")) {
  # Using `scale_fill_identity()` if using `xyz_heightmap()`'s `fill` column
  df &lt;- xyz_heightmap(volcano, scale = 0.3, min = 1,
                      col = grDevices::heat.colors)
  g &lt;- ggplot(df, aes(x, y, z = z, fill = fill)) +
         geom_oblicubes() +
         coord_fixed() +
         scale_fill_identity()
  plot(g)
}

if (require("ggplot2") &amp;&amp; require("dplyr")) {
  # Note you probably should not do 3D bar charts...
  df &lt;- as.data.frame(datasets::Titanic) |&gt;
          filter(Age == "Child", Freq &gt; 0) |&gt;
          group_by(Sex, Survived, Class) |&gt;
          summarize(Freq = seq.int(sum(Freq)), .groups = "drop")
  g &lt;- ggplot(df, aes(x = Survived, y = Freq, fill = Survived)) +
      facet_grid(cols = vars(Class, Sex)) +
      coord_fixed() +
      geom_oblicubes(yoffset = -0.5, zoffset = -0.5, angle = -45, scale = 0.7) +
      scale_fill_manual(values = c("Yes" = "lightblue", "No" = "red")) +
      scale_y_continuous(expand = expansion(), name = "") +
      scale_x_discrete(name = "", breaks = NULL) +
      labs(title = "Children on the Titanic (by ticket class)")
  plot(g)
}
</code></pre>

<hr>
<h2 id='geom_oblicuboids'>Draw 2D/3D cuboids with ggplot2</h2><span id='topic+geom_oblicuboids'></span>

<h3>Description</h3>

<p><code>geom_oblicuboids()</code> creates a <code>ggplot2</code> geom that draws cuboids
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_oblicuboids(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  angle = 45,
  scale = 0.5,
  xoffset = 0,
  yoffset = 0,
  zoffset = 0,
  light = darken_face,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_oblicuboids_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code> or
<code><a href="ggplot2.html#topic+aes_">aes_()</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_oblicuboids_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_oblicuboids_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, as a string.</p>
</td></tr>
<tr><td><code id="geom_oblicuboids_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_oblicuboids_+3A_...">...</code></td>
<td>
<p>Aesthetics, used to set an aesthetic to a fixed value.</p>
</td></tr>
<tr><td><code id="geom_oblicuboids_+3A_angle">angle</code></td>
<td>
<p>Oblique projection angle.</p>
</td></tr>
<tr><td><code id="geom_oblicuboids_+3A_scale">scale</code></td>
<td>
<p>Oblique projection foreshortening factor.
0.5 corresponds to the &ldquo;cabinet projection&rdquo;.
1.0 corresponds to the &ldquo;cavalier projection&rdquo;.
0.0 corresponds to a &ldquo;primary view orthographic projection&rdquo;.</p>
</td></tr>
<tr><td><code id="geom_oblicuboids_+3A_xoffset">xoffset</code>, <code id="geom_oblicuboids_+3A_yoffset">yoffset</code>, <code id="geom_oblicuboids_+3A_zoffset">zoffset</code></td>
<td>
<p>By default the x,y values are assumed to be the <strong>center</strong> of the cuboid
and the z value is assumed to be the <strong>top</strong> of the cuboid.
Use <code>xoffset</code>, <code>yoffset</code>, and/or <code>zoffset</code> to shift the x,y,z values a fixed amount.</p>
</td></tr>
<tr><td><code id="geom_oblicuboids_+3A_light">light</code></td>
<td>
<p>If <code>FALSE</code> don't perform a &quot;light&quot; effect.
Otherwise a function that takes two arguments:
the first <code>face</code> of the cube/cuboid face
(one of &quot;top&quot;, &quot;west&quot;, &quot;east&quot;, &quot;south&quot;, &quot;north&quot;).
the second <code>col</code> of the fill color.
By default we use <code><a href="#topic+darken_face">darken_face()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_oblicuboids_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_oblicuboids_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>geom_oblicuboids()</code> requires a fixed scale coordinate system with an aspect
ratio of 1 as provided by <code>ggplot2::coord_fixed()</code>.
</p>


<h3>Value</h3>

<p>A ggplot2 geom.
</p>


<h3>Aesthetics</h3>

<p><code>geom_oblicuboids()</code> understands the following aesthetics (required aesthetics are in bold).
See <code><a href="#topic+oblicuboidsGrob">oblicuboidsGrob()</a></code> for more details.
</p>

<ul>
<li> <p><strong><code>x</code></strong>
</p>
</li>
<li> <p><strong><code>y</code></strong>
</p>
</li>
<li> <p><code>z</code>
</p>
</li>
<li> <p><code>fill</code>
</p>
</li>
<li> <p><code>colour</code>
</p>
</li>
<li> <p><code>linetype</code>
</p>
</li>
<li> <p><code>linewidth</code>
</p>
</li></ul>



<h3>See Also</h3>

<p><code>geom_oblicuboids()</code> is a wrapper around <code><a href="#topic+oblicuboidsGrob">oblicuboidsGrob()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("ggplot2")) {
  data("volcano", package = "datasets")
  df &lt;- xyz_heightmap(volcano, scale = 0.3, min = 1)
  g &lt;- ggplot(df, aes(x, y, z = z, fill = raw)) +
         geom_oblicuboids(light = FALSE) +
         coord_fixed() +
         scale_fill_gradientn(name = "Height (m)",
                              colours=terrain.colors(256)) +
         labs(x = "East (10m)", y = "North (10m)",
              title = "Maungawhau (`datasets::volcano`)")
  plot(g)
}
if (require("ggplot2")) {
  # Using `scale_fill_identity()` if using `xyz_heightmap()`'s `fill` column
  df &lt;- xyz_heightmap(volcano, scale = 0.3, min = 1,
                      col = grDevices::heat.colors)
  g &lt;- ggplot(df, aes(x, y, z = z, fill = fill)) +
         geom_oblicuboids() +
         coord_fixed() +
         scale_fill_identity()
  plot(g)
}
if (require("ggplot2") &amp;&amp; require("dplyr")) {
  # Note you probably should not do 3D bar charts...
  df &lt;- as.data.frame(datasets::Titanic) |&gt;
          filter(Age == "Child", Freq &gt; 0) |&gt;
          group_by(Sex, Survived, Class) |&gt;
          summarize(Freq = seq.int(sum(Freq)), .groups = "drop")
  g &lt;- ggplot(df, aes(x = Survived, y = Freq, fill = Survived)) +
      facet_grid(cols = vars(Class, Sex)) +
      coord_fixed() +
      geom_oblicuboids(yoffset = -0.5, scale = 0.7, angle = -45) +
      scale_fill_manual(values = c("Yes" = "lightblue", "No" = "red")) +
      scale_y_continuous(expand = expansion(), name = "") +
      scale_x_discrete(name = "", breaks = NULL) +
      labs(title = "Children on the Titanic (by ticket class)")
  plot(g)
}
</code></pre>

<hr>
<h2 id='oblicubes-package'>oblicubes: 3D Rendering Using Obliquely Projected Cubes and Cuboids</h2><span id='topic+oblicubes'></span><span id='topic+oblicubes-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Three-dimensional rendering for 'grid' and 'ggplot2' graphics using cubes and cuboids drawn with an oblique projection. As a special case also supports primary view orthographic projections. Can be viewed as an extension to the 'isocubes' package <a href="https://github.com/coolbutuseless/isocubes">https://github.com/coolbutuseless/isocubes</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Trevor L Davis <a href="mailto:trevor.l.davis@gmail.com">trevor.l.davis@gmail.com</a> (<a href="https://orcid.org/0000-0001-6341-4639">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Mike FC (Some code adapted from isocubes)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://trevorldavis.com/R/oblicubes/">https://trevorldavis.com/R/oblicubes/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/trevorld/oblicubes/issues">https://github.com/trevorld/oblicubes/issues</a>
</p>
</li></ul>


<hr>
<h2 id='oblicubesGrob'>Render 2D/3D cubes via an oblique projection</h2><span id='topic+oblicubesGrob'></span><span id='topic+grid.oblicubes'></span>

<h3>Description</h3>

<p><code>oblicubesGrob()</code> / <code>grid.oblicubes()</code> renders cubes using a 3D oblique projection.
<code>oblicubesGrob()</code> returns a grid grob object while
<code>grid.oblicubes()</code> also draws the grob to the graphic device.
As a special case may also render a 2D primary view orthographic projection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oblicubesGrob(
  x,
  y = NULL,
  z = NULL,
  ...,
  fill = NULL,
  light = darken_face,
  scale = 0.5,
  angle = 45,
  xo = NULL,
  yo = NULL,
  width = NULL,
  default.units = "snpc",
  name = NULL,
  gp = gpar(),
  vp = NULL
)

grid.oblicubes(
  x,
  y = NULL,
  z = NULL,
  ...,
  fill = NULL,
  light = darken_face,
  scale = 0.5,
  angle = 45,
  xo = NULL,
  yo = NULL,
  width = NULL,
  default.units = "snpc",
  name = NULL,
  gp = gpar(),
  vp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oblicubesGrob_+3A_x">x</code></td>
<td>
<p>Integer vector of x coordinates (if necessary will be rounded to integers).
May be a <code>data.frame</code> of x,y,z coordinates (and maybe fill color).</p>
</td></tr>
<tr><td><code id="oblicubesGrob_+3A_y">y</code></td>
<td>
<p>Integer vector of y coordinates (if necessary will be rounded to integers).
If <code>NULL</code> and <code>x</code> is a data frame with a <code>y</code> column then we use that instead.</p>
</td></tr>
<tr><td><code id="oblicubesGrob_+3A_z">z</code></td>
<td>
<p>Integer vector of z coordinates (if necessary will be rounded to integers).
If <code>NULL</code> and <code>x</code> is a data frame with a <code>z</code> column then we use that instead.</p>
</td></tr>
<tr><td><code id="oblicubesGrob_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="grid.html#topic+gpar">grid::gpar()</a></code>.  Will override any values set in <code>gp</code>.</p>
</td></tr>
<tr><td><code id="oblicubesGrob_+3A_fill">fill</code></td>
<td>
<p>Fill color(s) for the cubes.
If <code>NULL</code> and <code>x</code> is a data frame with a <code>fill</code> or <code>col</code> column then we use that column;
if no such column but <code>gp</code> has a <code>fill</code> value we use that;
otherwise we fall back to &quot;grey90&quot;.</p>
</td></tr>
<tr><td><code id="oblicubesGrob_+3A_light">light</code></td>
<td>
<p>If <code>FALSE</code> don't perform a &quot;light&quot; effect.
Otherwise a function that takes two arguments:
the first <code>face</code> of the cube/cuboid face
(one of &quot;top&quot;, &quot;west&quot;, &quot;east&quot;, &quot;south&quot;, &quot;north&quot;).
the second <code>col</code> of the fill color.
By default we use <code><a href="#topic+darken_face">darken_face()</a></code>.</p>
</td></tr>
<tr><td><code id="oblicubesGrob_+3A_scale">scale</code></td>
<td>
<p>Oblique projection foreshortening factor.
0.5 corresponds to the &ldquo;cabinet projection&rdquo;.
1.0 corresponds to the &ldquo;cavalier projection&rdquo;.
0.0 corresponds to a &ldquo;primary view orthographic projection&rdquo;.</p>
</td></tr>
<tr><td><code id="oblicubesGrob_+3A_angle">angle</code></td>
<td>
<p>Oblique projection angle.</p>
</td></tr>
<tr><td><code id="oblicubesGrob_+3A_xo">xo</code>, <code id="oblicubesGrob_+3A_yo">yo</code></td>
<td>
<p>The origin of the oblique projection coordinate system in grid units.
The default is to try to guess a &ldquo;good&rdquo; value.</p>
</td></tr>
<tr><td><code id="oblicubesGrob_+3A_width">width</code></td>
<td>
<p>Width of the cube's (non-foreshortened) sides.
The default will be to try to guess a &ldquo;good&rdquo; value.</p>
</td></tr>
<tr><td><code id="oblicubesGrob_+3A_default.units">default.units</code></td>
<td>
<p>Default units for the <code>xo</code>, <code>yo</code>, and <code>width</code> arguments.</p>
</td></tr>
<tr><td><code id="oblicubesGrob_+3A_name">name</code></td>
<td>
<p>A character identifier (for grid).</p>
</td></tr>
<tr><td><code id="oblicubesGrob_+3A_gp">gp</code></td>
<td>
<p>A &lsquo;grid&rsquo; gpar object.  See <code><a href="grid.html#topic+gpar">grid::gpar()</a></code>.
Will be merged with the values in <code>...</code> and the value of <code>fill</code>.</p>
</td></tr>
<tr><td><code id="oblicubesGrob_+3A_vp">vp</code></td>
<td>
<p>A &lsquo;grid&rsquo; viewport object.  See <code><a href="grid.html#topic+viewport">grid::viewport()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid grob.  As a side effect <code>grid.oblicubes()</code> also draws to the active graphics device.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("grid")) {
  # we support arbitrary oblique projection angles
  mat &lt;- matrix(c(1, 2, 1, 2, 3, 2, 1, 2, 1), nrow = 3, ncol = 3, byrow = TRUE)
  coords &lt;- xyz_heightmap(mat, col = c("red", "yellow", "green"))

  angles &lt;- c(135, 90, 45, 180, 45, 0, -135, -90, -45)
  scales &lt;- c(0.5, 0.5, 0.5, 0.5, 0.0, 0.5, 0.5, 0.5, 0.5)
  vp_x &lt;- rep(1:3/3 - 1/6, 3)
  vp_y &lt;- rep(3:1/3 - 1/6, each = 3)
  grid.newpage()
  for (i in 1:9) {
      pushViewport(viewport(x=vp_x[i], y=vp_y[i], width=1/3, height=1/3))
      grid.rect(gp = gpar(lty = "dashed"))
      grid.oblicubes(coords, width = 0.15, xo = 0.25, yo = 0.15,
                     angle = angles[i], scale = scales[i],
                     gp = gpar(lwd=4))
      if(i != 5)
          grid.text(paste("angle =", angles[i]), y=0.92, gp = gpar(cex = 1.2))
      else
          grid.text(paste("scale = 0"), y=0.92, gp = gpar(cex = 1.2))
      popViewport()
  }
}
# volcano example
mat &lt;- datasets::volcano
mat &lt;- 0.3 * (mat - min(mat)) + 1.0
coords &lt;- xyz_heightmap(mat, col = grDevices::terrain.colors)
grid::grid.newpage()
grid.oblicubes(coords)
</code></pre>

<hr>
<h2 id='oblicuboidsGrob'>Render 2D/3D cuboids via an oblique projection</h2><span id='topic+oblicuboidsGrob'></span><span id='topic+grid.oblicuboids'></span>

<h3>Description</h3>

<p><code>oblicuboidsGrob()</code> / <code>grid.oblicuboids()</code> renders cuboids using a 3D oblique projection.
<code>oblicuboidsGrob()</code> returns a grid grob object while
<code>grid.oblicuboids()</code> also draws the grob to the graphic device.
As a special case may also render a 2D primary view orthographic projection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oblicuboidsGrob(
  x,
  y = NULL,
  z = NULL,
  ...,
  fill = NULL,
  light = darken_face,
  scale = 0.5,
  angle = 45,
  xo = NULL,
  yo = NULL,
  width = NULL,
  default.units = "snpc",
  name = NULL,
  gp = gpar(),
  vp = NULL
)

grid.oblicuboids(
  x,
  y = NULL,
  z = NULL,
  ...,
  fill = NULL,
  scale = 0.5,
  angle = 45,
  xo = NULL,
  yo = NULL,
  width = NULL,
  default.units = "snpc",
  name = NULL,
  gp = gpar(),
  vp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oblicuboidsGrob_+3A_x">x</code></td>
<td>
<p>Integer vector of x coordinates (if necessary will be rounded to integers).
May be a <code>data.frame</code> of x,y,z coordinates (and maybe fill color).
This will be the x-value at the <em>center</em> of the cuboid.</p>
</td></tr>
<tr><td><code id="oblicuboidsGrob_+3A_y">y</code></td>
<td>
<p>Integer vector of y coordinates (if necessary will be rounded to integers).
If <code>NULL</code> and <code>x</code> is a data frame with a <code>y</code> column then we use that instead.
This will be the x-value at the <em>center</em> of the cuboid.</p>
</td></tr>
<tr><td><code id="oblicuboidsGrob_+3A_z">z</code></td>
<td>
<p>Integer vector of z coordinates (if necessary will be rounded to integers).
If <code>NULL</code> and <code>x</code> is a data frame with a <code>z</code> column then we use that instead.
This will be the z-value at the <em>top</em> of the cuboid.</p>
</td></tr>
<tr><td><code id="oblicuboidsGrob_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="grid.html#topic+gpar">grid::gpar()</a></code>.  Will override any values set in <code>gp</code>.</p>
</td></tr>
<tr><td><code id="oblicuboidsGrob_+3A_fill">fill</code></td>
<td>
<p>Fill color(s) for the cuboids.
If <code>NULL</code> and <code>x</code> is a data frame with a <code>fill</code> or <code>col</code> column then we use that column;
if no such column but <code>gp</code> has a <code>fill</code> value we use that;
otherwise we fall back to &quot;grey90&quot;.</p>
</td></tr>
<tr><td><code id="oblicuboidsGrob_+3A_light">light</code></td>
<td>
<p>If <code>FALSE</code> don't perform a &quot;light&quot; effect.
Otherwise a function that takes two arguments:
the first <code>face</code> of the cube/cuboid face
(one of &quot;top&quot;, &quot;west&quot;, &quot;east&quot;, &quot;south&quot;, &quot;north&quot;).
the second <code>col</code> of the fill color.
By default we use <code><a href="#topic+darken_face">darken_face()</a></code>.</p>
</td></tr>
<tr><td><code id="oblicuboidsGrob_+3A_scale">scale</code></td>
<td>
<p>Oblique projection foreshortening factor.
0.5 corresponds to the &ldquo;cabinet projection&rdquo;.
1.0 corresponds to the &ldquo;cavalier projection&rdquo;.
0.0 corresponds to a &ldquo;primary view orthographic projection&rdquo;.</p>
</td></tr>
<tr><td><code id="oblicuboidsGrob_+3A_angle">angle</code></td>
<td>
<p>Oblique projection angle.</p>
</td></tr>
<tr><td><code id="oblicuboidsGrob_+3A_xo">xo</code>, <code id="oblicuboidsGrob_+3A_yo">yo</code></td>
<td>
<p>The origin of the oblique projection coordinate system in grid units.
The default is to try to guess a &ldquo;good&rdquo; value.</p>
</td></tr>
<tr><td><code id="oblicuboidsGrob_+3A_width">width</code></td>
<td>
<p>Width of the cuboids's (non-foreshortened) side.
The default will be to try to guess a &ldquo;good&rdquo; value.</p>
</td></tr>
<tr><td><code id="oblicuboidsGrob_+3A_default.units">default.units</code></td>
<td>
<p>Default units for the <code>xo</code>, <code>yo</code>, and <code>width</code> arguments.</p>
</td></tr>
<tr><td><code id="oblicuboidsGrob_+3A_name">name</code></td>
<td>
<p>A character identifier (for grid).</p>
</td></tr>
<tr><td><code id="oblicuboidsGrob_+3A_gp">gp</code></td>
<td>
<p>A &lsquo;grid&rsquo; gpar object.  See <code><a href="grid.html#topic+gpar">grid::gpar()</a></code>.
Will be merged with the values in <code>...</code> and the value of <code>fill</code>.</p>
</td></tr>
<tr><td><code id="oblicuboidsGrob_+3A_vp">vp</code></td>
<td>
<p>A &lsquo;grid&rsquo; viewport object.  See <code><a href="grid.html#topic+viewport">grid::viewport()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid grob.  As a side effect <code>grid.oblicubes()</code> also draws to the active graphics device.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("grid")) {
  # we support arbitrary oblique projection angles
  mat &lt;- matrix(c(1, 2, 1, 2, 3, 2, 1, 2, 1), nrow = 3, ncol = 3, byrow = TRUE)
  coords &lt;- xyz_heightmap(mat, col = c("red", "yellow", "green"),
                          solid = FALSE)
  angles &lt;- c(135, 90, 45, 180, 45, 0, -135, -90, -45)
  scales &lt;- c(0.5, 0.5, 0.5, 0.5, 0.0, 0.5, 0.5, 0.5, 0.5)
  vp_x &lt;- rep(1:3/3 - 1/6, 3)
  vp_y &lt;- rep(3:1/3 - 1/6, each = 3)
  grid.newpage()
  for (i in 1:9) {
      pushViewport(viewport(x=vp_x[i], y=vp_y[i], width=1/3, height=1/3))
      grid.rect(gp = gpar(lty = "dashed"))
      grid.oblicuboids(coords, width = 0.15, xo = 0.25, yo = 0.15,
                     angle = angles[i], scale = scales[i],
                     gp = gpar(lwd=4))
      if(i != 5)
          grid.text(paste("angle =", angles[i]), y=0.92, gp = gpar(cex = 1.2))
      else
          grid.text(paste("scale = 0"), y=0.92, gp = gpar(cex = 1.2))
      popViewport()
  }
}
# volcano example
mat &lt;- datasets::volcano
mat &lt;- 0.3 * (mat - min(mat)) + 1.0
coords &lt;- xyz_heightmap(mat, col = grDevices::terrain.colors,
                        solid = FALSE)
grid::grid.newpage()
grid.oblicuboids(coords)
</code></pre>

<hr>
<h2 id='xyz_heightmap'>Calculate x,y,z coordinates from a height matrix</h2><span id='topic+xyz_heightmap'></span>

<h3>Description</h3>

<p>Calculate x,y,z coordinates from a height matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xyz_heightmap(
  mat,
  col = NULL,
  scale = 1,
  min = NULL,
  flipx = FALSE,
  flipy = TRUE,
  ground = "xy",
  solid = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xyz_heightmap_+3A_mat">mat</code></td>
<td>
<p>integer matrix. The matrix will be interpreted as cubes (or cuboids) flat on the
page, with the value in the matrix interpreted as the height above the page.</p>
</td></tr>
<tr><td><code id="xyz_heightmap_+3A_col">col</code></td>
<td>
<p>matrix, vector, or (palette) function of colours.
If a matrix it must be the same dimensions as the <code>mat</code> argument;
each cube/cuboid corresponding to that x,y value will have that color.
If a vector then if the max of <code>z</code> values is less than equal to the number
of colors we will use the <code>z</code> integers
as indices else we will use <code><a href="base.html#topic+cut">base::cut()</a></code> to assign z values to colors.
If a function we will call it with the argument <code>max(z)</code> to create a
a vector of colors and then use the z values as indices.
If <code>col</code> is not NULL then a <code>fill</code> column will be included in the final returned coordinates.</p>
</td></tr>
<tr><td><code id="xyz_heightmap_+3A_scale">scale</code></td>
<td>
<p>scale factor for values in matrix. Default = 1</p>
</td></tr>
<tr><td><code id="xyz_heightmap_+3A_min">min</code></td>
<td>
<p>Minimum target <code>z</code> value.  If <code>NULL</code> ignore else we &quot;translate&quot;
the z-values so the minimum z-value is equal to this value.</p>
</td></tr>
<tr><td><code id="xyz_heightmap_+3A_flipx">flipx</code>, <code id="xyz_heightmap_+3A_flipy">flipy</code></td>
<td>
<p>Should the matrix be flipped in the horizontal/vertical directions (respectively)?
Note: <code>flipy</code> defaults to <code>TRUE</code> as matrices are indexed
from the top-down, but the coordinate space is increasing
from the bottom up.   Flipping the matrix vertically is usually
what you want.</p>
</td></tr>
<tr><td><code id="xyz_heightmap_+3A_ground">ground</code></td>
<td>
<p>Orientation of the ground plane. Default: &quot;xy&quot;.  Possible
values &quot;xy&quot;, &quot;xz&quot;, &quot;zy&quot;</p>
</td></tr>
<tr><td><code id="xyz_heightmap_+3A_solid">solid</code></td>
<td>
<p>Should the heightmap be made 'solid' i.e. without holes?
This can be an expensive operation in terms of
both memory and CPU, but should be OK for simple examples.
Set to FALSE if things take too long or you will be rendering cuboids.
This operation works by extruding cubes down from the top of the height map to the floor to
ensure gaps do not appear when the slope is too great.</p>
</td></tr>
<tr><td><code id="xyz_heightmap_+3A_verbose">verbose</code></td>
<td>
<p>Be verbose? default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of <code>x</code>, <code>y</code>, <code>z</code>, <code>raw</code>, and possibly <code>fill</code> columns.
The &quot;raw&quot; column is the (original) &quot;z&quot; column before any <code>scale</code>, <code>min</code>, and <code>ground</code>
transformations have been performed (it may be repeated &quot;down&quot; if <code>solid = TRUE</code>).
The &quot;raw&quot; column can be useful as the <code>fill</code> value in <code>ggplot2</code> plots especially
when adding a legend.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("grDevices") &amp;&amp; require("grid")) {
  mat &lt;- datasets::volcano
  mat &lt;- 0.3 * (mat - min(mat)) + 1.0

  grid.newpage()
  grid.rect(gp=gpar(col=NA, fill="grey5"))
  width &lt;- convertWidth(unit(0.007, "snpc"), "cm")

  # Top view
  pushViewport(viewport(width = 0.7, height = 0.7, x = 0.65, y = 0.65))
  coords &lt;- xyz_heightmap(mat, col = terrain.colors, solid = FALSE)
  grid.oblicubes(coords, scale = 0, width = width, gp = gpar(col=NA))
  popViewport()

  # South view
  pushViewport(viewport(width = 0.7, height = 0.3, x = 0.65, y = 0.15))
  coords &lt;- xyz_heightmap(mat, col = terrain.colors, ground = "xz")
  grid.oblicubes(coords, scale = 0, width = width, gp = gpar(col=NA))
  popViewport()

  # West view
  pushViewport(viewport(width = 0.3, height = 0.7, x = 0.15, y = 0.65))
  coords &lt;- xyz_heightmap(mat, col = terrain.colors, ground = "zy")
  grid.oblicubes(coords, scale = 0, width = width, gp = gpar(col=NA))
  popViewport()
}
if (require("grDevices") &amp;&amp; require("ggplot2")) {
  data("volcano", package = "datasets")
  df &lt;- xyz_heightmap(volcano, scale = 0.3, min = 1, solid = FALSE)
  g &lt;- ggplot(df, aes(x, y, z = z, fill = raw)) +
         geom_oblicuboids(light = FALSE) +
         coord_fixed() +
         scale_fill_gradientn(name = "Height (m)", colours=terrain.colors(256)) +
         labs(x = "East (10m)", y = "North (10m)", title = "Maungawhau (`datasets::volcano`)")
  plot(g)
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
