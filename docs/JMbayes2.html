<!DOCTYPE html><html><head><title>Help for package JMbayes2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {JMbayes2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#JMbayes2'>
<p>Extended Joint Models for Longitudinal and Time-to-Event Data</p></a></li>
<li><a href='#Accuracy+20Measures'><p>Time-Dependent Predictive Accuracy Measures for Joint Models</p></a></li>
<li><a href='#aids'><p>Didanosine versus Zalcitabine in HIV Patients</p></a></li>
<li><a href='#crisk_setup'><p> Transform Competing Risks Data in Long Format</p></a></li>
<li><a href='#jm'>
<p>Joint Models for Longitudinal and Time-to-Event Data</p></a></li>
<li><a href='#jm+20coda+20Methods'>
<p>Various Methods for Functions from the <em>coda</em> Package</p></a></li>
<li><a href='#jm+20Methods'>
<p>Various Methods for Standard Generics</p></a></li>
<li><a href='#pbc2'><p>Mayo Clinic Primary Biliary Cirrhosis Data</p></a></li>
<li><a href='#Predictions'>
<p>Predictions from Joint Models</p></a></li>
<li><a href='#prothro'><p>Prednisone versus Placebo in Liver Cirrhosis Patients</p></a></li>
<li><a href='#rc_setup'><p> Combine Recurring and Terminal Event Data in Long Format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Extended Joint Models for Longitudinal and Time-to-Event Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4-5</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dimitris Rizopoulos &lt;d.rizopoulos@erasmusmc.nl&gt;</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-06-23</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/drizopoulos/JMbayes2/issues">https://github.com/drizopoulos/JMbayes2/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Fit joint models for longitudinal and time-to-event data under the Bayesian approach. Multiple longitudinal outcomes of mixed type (continuous/categorical) and multiple event times (competing risks and multi-state processes) are accommodated. Rizopoulos (2012, ISBN:9781439872864).</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lattice, knitr, rmarkdown, pkgdown</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>survival, nlme, GLMMadaptive, splines</td>
</tr>
<tr>
<td>Imports:</td>
<td>coda, Rcpp, parallel, parallelly, matrixStats, ggplot2,
gridExtra</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://drizopoulos.github.io/JMbayes2/">https://drizopoulos.github.io/JMbayes2/</a>,
<a href="https://github.com/drizopoulos/JMbayes2">https://github.com/drizopoulos/JMbayes2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-26 11:50:46 UTC; drizo</td>
</tr>
<tr>
<td>Author:</td>
<td>Dimitris Rizopoulos
    <a href="https://orcid.org/0000-0001-9397-0900"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Grigorios Papageorgiou [aut],
  Pedro Miranda Afonso [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-26 13:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='JMbayes2'>
Extended Joint Models for Longitudinal and Time-to-Event Data
</h2><span id='topic+JMbayes2-package'></span><span id='topic+JMbayes2'></span>

<h3>Description</h3>

<p>Fit joint models for longitudinal and time-to-event data under the Bayesian approach. Multiple longitudinal outcomes of mixed type (continuous/categorical) and multiple event times (competing risks and multi-state processes) are accommodated.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> JMbayes2</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.4-5</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-06-23</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=3)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>This package fits joint models for longitudinal and time-to-event data. It can accommodate multiple longitudinal outcomes of different type (e.g., continuous, dichotomous, ordinal, counts), and assuming different distributions, i.e., Gaussian, Student's-t, Gamma, Beta, unit Lindley, censored Normal, Binomial, Poisson, Negative Binomial, and Beta-Binomial. For the event time process, right, left and interval censored data can be handled, while competing risks and multi-sate processes are also covered.
</p>
<p><span class="pkg">JMbayes2</span> fits joint models using Markov chain Monte Carlo algorithms implemented in C++. The package also offers several utility functions that can extract useful information from
fitted joint models. The most important of those are included in the
<b>See also</b> Section below.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos, Grigorios Papageorgiou, Pedro Miranda Afonso
</p>
<p>Maintainer: Dimitris Rizopoulos &lt;d.rizopoulos@erasmusmc.nl&gt;
</p>


<h3>References</h3>

<p>Rizopoulos, D. (2012). Joint Models for Longitudinal and Time-to-Event Data With Applications in R. Boca Raton: Chapman &amp; Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jm">jm</a></code>,
<code><a href="#topic+methods.jm">methods.jm</a></code>,
<code><a href="#topic+coda_methods.jm">coda_methods.jm</a></code>
</p>

<hr>
<h2 id='Accuracy+20Measures'>Time-Dependent Predictive Accuracy Measures for Joint Models</h2><span id='topic+tvAUC'></span><span id='topic+tvROC'></span><span id='topic+tvAUC.jm'></span><span id='topic+tvAUC.tvROC'></span><span id='topic+tvROC.jm'></span><span id='topic+calibration_plot'></span><span id='topic+calibration_metrics'></span><span id='topic+tvBrier'></span><span id='topic+tvEPCE'></span><span id='topic+create_folds'></span>

<h3>Description</h3>

<p>Using the available longitudinal information up to a starting time point, these functions compute estimates of the ROC curve and the AUC, the Brier score and expected predictive cross-entropy at a horizon time point based on joint models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvROC(object, newdata, Tstart, ...)

## S3 method for class 'jm'
tvROC(object, newdata, Tstart, Thoriz = NULL,
    Dt = NULL, ...)

tvAUC(object, newdata, Tstart, ...)

## S3 method for class 'jm'
tvAUC(object, newdata, Tstart, Thoriz = NULL,
    Dt = NULL, ...)

## S3 method for class 'tvROC'
tvAUC(object, ...)

calibration_plot(object, newdata, Tstart, Thoriz = NULL,
    Dt = NULL, df_ns = 3, plot = TRUE, add_density = TRUE,
    col = "red", lty = 1, lwd = 1,
    col_dens = "grey", xlab = "Predicted Probabilities",
    ylab = "Observed Probabilities", main = "", ...)

calibration_metrics(object, newdata, Tstart, Thoriz = NULL,
    Dt = NULL, df_ns = 3, ...)

tvBrier(object, newdata, Tstart, Thoriz = NULL, Dt = NULL,
    integrated = FALSE, type_weights = c("model-based", "IPCW"),
    model_weights = NULL, eventData_fun = NULL,
    parallel = c("snow", "multicore"),
    cores = parallelly::availableCores(omit = 1L), ...)

tvEPCE(object, newdata, Tstart, Thoriz = NULL, Dt = NULL, eps = 0.001,
    model_weights = NULL, eventData_fun = NULL,
    parallel = c("snow", "multicore"),
    cores = parallelly::availableCores(omit = 1L), ...)

create_folds(data, V = 5, id_var = "id", seed = 123L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Accuracy+2B20Measures_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>jm</code>, except for <code>tvAUC.tvROC()</code> where this is an object of class <code>tvROC</code>. For <code>tvBrier()</code> and <code>tvEPCE()</code> it can also be a library of joint models.</p>
</td></tr>
<tr><td><code id="Accuracy+2B20Measures_+3A_newdata">newdata</code></td>
<td>
<p>a data.frame that contains the longitudinal and covariate information for the subjects for which prediction of survival probabilities is required. The names of the variables in this data.frame must be the same as in the data.frames that were used to fit the linear mixed effects and the event process model that were supplied as the two first argument of <code><a href="#topic+jm">jm</a></code>.</p>
</td></tr>
<tr><td><code id="Accuracy+2B20Measures_+3A_tstart">Tstart</code></td>
<td>
<p>numeric scalar denoting the time point up to which longitudinal information is to be used to derive predictions.</p>
</td></tr>
<tr><td><code id="Accuracy+2B20Measures_+3A_thoriz">Thoriz</code></td>
<td>
<p>numeric scalar denoting the time point for which a prediction of the survival status is of interest; <code>Thoriz</code> must be later than <code>Tstart</code> and either <code>Dt</code> or <code>Thoriz</code> must be specified. If <code>Thoriz</code> is <code>NULL</code> is set equal to <code>Tstart + Dt</code>.</p>
</td></tr>
<tr><td><code id="Accuracy+2B20Measures_+3A_dt">Dt</code></td>
<td>
<p>numeric scalar denoting the length of the time interval of prediction; either <code>Dt</code> or <code>Thoriz</code> must be specified.</p>
</td></tr>
<tr><td><code id="Accuracy+2B20Measures_+3A_integrated">integrated</code></td>
<td>
<p>logical; if <code>TRUE</code> the integrated Brier score is calculated.</p>
</td></tr>
<tr><td><code id="Accuracy+2B20Measures_+3A_type_weights">type_weights</code></td>
<td>
<p>character string denoting the type of weights to use to account for censorting. Options are model-based (default) and inverse probability of censoring weighting (using the Kaplan-Meier estimate of the censoring distribution).</p>
</td></tr>
<tr><td><code id="Accuracy+2B20Measures_+3A_eps">eps</code></td>
<td>
<p>numeric scalar used in the approximation of the hazard function.</p>
</td></tr>
<tr><td><code id="Accuracy+2B20Measures_+3A_model_weights">model_weights</code></td>
<td>
<p>a numeric vector of weights to combine predictions when <code>object</code> is a list of joint models of class <code>"jmList"</code>.</p>
</td></tr>
<tr><td><code id="Accuracy+2B20Measures_+3A_eventdata_fun">eventData_fun</code></td>
<td>
<p>a function that takes as input the <code>newdata</code> and produces the dataset used for the event process model. This is useful when, for example, the event process model contains other time-varying covariates.
It is important that this function does not alter the ordering of the subjects in <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="Accuracy+2B20Measures_+3A_parallel">parallel</code></td>
<td>
<p>character string; what type of parallel computing to use.</p>
</td></tr>
<tr><td><code id="Accuracy+2B20Measures_+3A_cores">cores</code></td>
<td>
<p>integer denoting the number of cores to be used when a library of joint models has been provided in
<code>object</code>. If <code>cores = 1</code>, no parallel computing is used.</p>
</td></tr>
<tr><td><code id="Accuracy+2B20Measures_+3A_df_ns">df_ns</code></td>
<td>
<p>the degrees of freedom for the natural cubic spline of the cloglog transformation of the
predicted probabilities used in the Cox model that assess calibration.</p>
</td></tr>
<tr><td><code id="Accuracy+2B20Measures_+3A_plot">plot</code></td>
<td>
<p>logical; should a plot be produced. If <code>FALSE</code>, a list is returned with the observed and predicted probabilities.</p>
</td></tr>
<tr><td><code id="Accuracy+2B20Measures_+3A_add_density">add_density</code></td>
<td>
<p>logical; should the kernal density estimation of the predicted probabilities be superimposed in the calibration plot.</p>
</td></tr>
<tr><td><code id="Accuracy+2B20Measures_+3A_col">col</code>, <code id="Accuracy+2B20Measures_+3A_lwd">lwd</code>, <code id="Accuracy+2B20Measures_+3A_lty">lty</code>, <code id="Accuracy+2B20Measures_+3A_col_dens">col_dens</code>, <code id="Accuracy+2B20Measures_+3A_xlab">xlab</code>, <code id="Accuracy+2B20Measures_+3A_ylab">ylab</code>, <code id="Accuracy+2B20Measures_+3A_main">main</code></td>
<td>
<p>graphical parameters.</p>
</td></tr>
<tr><td><code id="Accuracy+2B20Measures_+3A_data">data</code></td>
<td>
<p>the data.frame to split in folds.</p>
</td></tr>
<tr><td><code id="Accuracy+2B20Measures_+3A_v">V</code></td>
<td>
<p>numeric scalar denoting the number of folds.</p>
</td></tr>
<tr><td><code id="Accuracy+2B20Measures_+3A_id_var">id_var</code></td>
<td>
<p>character string denoting the name of the subject id variable in <code>data</code>.</p>
</td></tr>
<tr><td><code id="Accuracy+2B20Measures_+3A_seed">seed</code></td>
<td>
<p>integer denoting the seed.</p>
</td></tr>
<tr><td><code id="Accuracy+2B20Measures_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>predict.jm()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>tvAUC</code> with components:
</p>
<table>
<tr><td><code>auc</code></td>
<td>
<p>a numeric scalar denoting the estimated prediction error.</p>
</td></tr>
<tr><td><code>Tstart</code></td>
<td>
<p>a copy of the <code>Tstart</code> argument.</p>
</td></tr>
<tr><td><code>Thoriz</code></td>
<td>
<p>a copy of the <code>Thoriz</code> argument.</p>
</td></tr>
<tr><td><code>nr</code></td>
<td>
<p>a numeric scalar denoting the number of subjects at risk at time <code>Tstart</code>.</p>
</td></tr>
<tr><td><code>classObject</code></td>
<td>
<p>the class of <code>object</code>.</p>
</td></tr>
<tr><td><code>nameObject</code></td>
<td>
<p>the name of <code>object</code>.</p>
</td></tr>
</table>
<p>A list of class <code>tvROC</code> with components:
</p>
<table>
<tr><td><code>TP</code>, <code>FP</code>, <code>nTP</code>, <code>nFN</code>, <code>nTN</code>, <code>qSN</code>, <code>qSP</code>, <code>qOverall</code></td>
<td>
<p>accuracy indexes.</p>
</td></tr>
<tr><td><code>F1score</code>, <code>Youden</code></td>
<td>
<p>numeric scalars with the optimal cut-point using the F1 score and the Youden index.</p>
</td></tr>
<tr><td><code>thr</code></td>
<td>
<p>numeric vector of thresholds.</p>
</td></tr>
<tr><td><code>Tstart</code></td>
<td>
<p>a copy of the <code>Tstart</code> argument.</p>
</td></tr>
<tr><td><code>Thoriz</code></td>
<td>
<p>a copy of the <code>Thoriz</code> argument.</p>
</td></tr>
<tr><td><code>nr</code></td>
<td>
<p>a numeric scalar denoting the number of subjects at risk at time <code>Tstart</code>.</p>
</td></tr>
<tr><td><code>classObject</code></td>
<td>
<p>the class of <code>object</code>.</p>
</td></tr>
<tr><td><code>nameObject</code></td>
<td>
<p>the name of <code>object</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>References</h3>

<p>Antolini, L., Boracchi, P., and Biganzoli, E. (2005). A time-dependent discrimination index
for survival data. <em>Statistics in Medicine</em> <b>24</b>, 3927&ndash;3944.
</p>
<p>Commenges, D., Liquet, B., and Proust-Lima, C. (2012). Choice of prognostic estimators
in joint models by estimating differences of expected conditional Kullback-Leibler risks.
<em>Biometrics</em> <b>68</b>, 380&ndash;387.
</p>
<p>Harrell, F., Kerry, L. and Mark, D. (1996). Multivariable prognostic models: issues in
developing models, evaluating assumptions and adequacy, and measuring and reducing errors.
<em>Statistics in Medicine</em> <b>15</b>, 361&ndash;387.
</p>
<p>Heagerty, P. and Zheng, Y. (2005). Survival model predictive accuracy and ROC curves.
<em>Biometrics</em> <b>61</b>, 92&ndash;105.
</p>
<p>Rizopoulos, D. (2016). The R package JMbayes for fitting joint models for longitudinal and
time-to-event data using MCMC. <em>Journal of Statistical Software</em> <b>72(7)</b>, 1&ndash;45.
doi:10.18637/jss.v072.i07.
</p>
<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: with
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>
<p>Rizopoulos, D. (2011). Dynamic predictions and prospective accuracy in joint models for
longitudinal and time-to-event data. <em>Biometrics</em> <b>67</b>, 819&ndash;829.
</p>
<p>Rizopoulos, D., Molenberghs, G. and Lesaffre, E.M.E.H. (2017). Dynamic predictions with time-dependent covariates in survival analysis using joint modeling and landmarking. <em>Biometrical Journal</em> <b>59</b>, 1261&ndash;1276.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="#topic+jm">jm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# We fit a multivariate joint model
pbc2.id$status2 &lt;- as.numeric(pbc2.id$status != 'alive')
CoxFit &lt;- coxph(Surv(years, status2) ~ sex, data = pbc2.id)
fm1 &lt;- lme(log(serBilir) ~ ns(year, 3) * sex, data = pbc2,
           random = ~ ns(year, 3) | id, control = lmeControl(opt = 'optim'))
fm2 &lt;- lme(prothrombin ~ ns(year, 2) * sex, data = pbc2,
           random = ~ ns(year, 2) | id, control = lmeControl(opt = 'optim'))
fm3 &lt;- mixed_model(ascites ~ year * sex, data = pbc2,
                   random = ~ year | id, family = binomial())

jointFit &lt;- jm(CoxFit, list(fm1, fm2, fm3), time_var = "year", n_chains = 1L)

roc &lt;- tvROC(jointFit, newdata = pbc2, Tstart = 4, Dt = 3, cores = 1L)
roc
tvAUC(roc)
plot(roc, legend = TRUE, optimal_cutoff = "Youden")

</code></pre>

<hr>
<h2 id='aids'>Didanosine versus Zalcitabine in HIV Patients</h2><span id='topic+aids'></span><span id='topic+aids.id'></span>

<h3>Description</h3>

<p>A randomized clinical trial in which both longitudinal and survival data were collected to compare the efficacy and 
safety of two antiretroviral drugs in treating patients who had failed or were intolerant of zidovudine (AZT) therapy.
</p>


<h3>Format</h3>

<p>A data frame with 1408 observations on the following 9 variables.
</p>

<dl>
<dt><code>patient</code></dt><dd><p>patients identifier; in total there are 467 patients.</p>
</dd>
<dt><code>Time</code></dt><dd><p>the time to death or censoring.</p>
</dd>
<dt><code>death</code></dt><dd><p>a numeric vector with 0 denoting censoring and 1 death.</p>
</dd>
<dt><code>CD4</code></dt><dd><p>the CD4 cells count.</p>
</dd>
<dt><code>obstime</code></dt><dd><p>the time points at which the CD4 cells count was recorded.</p>
</dd>
<dt><code>drug</code></dt><dd><p>a factor with levels <code>ddC</code> denoting zalcitabine and <code>ddI</code> denoting didanosine.</p>
</dd>
<dt><code>gender</code></dt><dd><p>a factor with levels <code>female</code> and <code>male</code>.</p>
</dd>
<dt><code>prevOI</code></dt><dd><p>a factor with levels <code>AIDS</code> denoting previous opportunistic infection (AIDS 
diagnosis) at study entry, and <code>noAIDS</code> denoting no previous infection.</p>
</dd>
<dt><code>AZT</code></dt><dd><p>a factor with levels <code>intolerance</code> and <code>failure</code> denoting AZT intolerance and 
AZT failure, respectively.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The data frame <code>aids.id</code> contains the first CD4 cell count measurement for each patient. This data frame is used to 
fit the survival model.
</p>


<h3>References</h3>

<p>Goldman, A., Carlin, B., Crane, L., Launer, C., Korvick, J., Deyton, L. and Abrams, D. (1996) Response of CD4+ and
clinical consequences to treatment using ddI or ddC in patients with advanced HIV infection. <em>Journal of Acquired
Immune Deficiency Syndromes and Human Retrovirology</em> <b>11</b>, 161&ndash;169.
</p>
<p>Guo, X. and Carlin, B. (2004) Separate and joint modeling of longitudinal and event time data using standard
computer packages. <em>The American Statistician</em> <b>58</b>, 16&ndash;24.
</p>

<hr>
<h2 id='crisk_setup'> Transform Competing Risks Data in Long Format </h2><span id='topic+crisk_setup'></span>

<h3>Description</h3>

<p>In a competing risks setting this function expands the data frame with a
single row per subject to a data frame in the long format in which each
subject has as many rows as the number of competing events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crisk_setup(data, statusVar, censLevel,
    nameStrata = "strata", nameStatus = "status2")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crisk_setup_+3A_data">data</code></td>
<td>
<p>the data frame containing the competing risk data with a single
row per subject.</p>
</td></tr>
<tr><td><code id="crisk_setup_+3A_statusvar">statusVar</code></td>
<td>
<p>a character string denoting the name of the variable in
<code>data</code> that identifies the status variable which equals 1 if the
subject had any of the competing events and 0 otherwise.</p>
</td></tr>
<tr><td><code id="crisk_setup_+3A_censlevel">censLevel</code></td>
<td>
<p>a character string or a scalar denoting the censoring level
in the <code>statusVar</code> variable of <code>data</code>.</p>
</td></tr>
<tr><td><code id="crisk_setup_+3A_namestrata">nameStrata</code></td>
<td>
<p>a character string denoting the variable that will be added
in the long version of <code>data</code> denoting the various causes of event.</p>
</td></tr>
<tr><td><code id="crisk_setup_+3A_namestatus">nameStatus</code></td>
<td>
<p>a character string denoting the variable that will be added
in the long version of <code>data</code> denoting if the subject experience any
of the competing events.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame in the long format with multiple rows per subject.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a>
</p>


<h3>References</h3>

<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: with
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>
<p>Putter, H., Fiocco, M., and Geskus, R. (2007). Tutorial in biostatistics:
Competing risks and multi-state models. <em>Statistics in Medicine</em> <b>26</b>,
2389&ndash;2430.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(crisk_setup(pbc2.id, "status", "alive"))
</code></pre>

<hr>
<h2 id='jm'>
Joint Models for Longitudinal and Time-to-Event Data
</h2><span id='topic+jm'></span><span id='topic+value'></span><span id='topic+slope'></span><span id='topic+area'></span><span id='topic+velocity'></span><span id='topic+acceleration'></span><span id='topic+coefs'></span><span id='topic+vexpit'></span><span id='topic+Dexpit'></span><span id='topic+vexp'></span><span id='topic+vabs'></span><span id='topic+Dexp'></span><span id='topic+vlog'></span><span id='topic+vlog2'></span><span id='topic+vlog10'></span><span id='topic+vsqrt'></span><span id='topic+poly2'></span><span id='topic+poly3'></span><span id='topic+poly4'></span><span id='topic+tv'></span>

<h3>Description</h3>

<p>Fits multivariate joint models for longitudinal and time-to-event data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jm(Surv_object, Mixed_objects, time_var, recurrent = FALSE,
  functional_forms = NULL, data_Surv = NULL, id_var = NULL, priors = NULL,
  control = NULL, ...)

value(x)
coefs(x, zero_ind = NULL)
slope(x, eps = 0.001, direction = "both")
velocity(x, eps = 0.001, direction = "both")
acceleration(x)
area(x, time_window = NULL)

vexpit(x)
Dexpit(x)

vexp(x)
Dexp(x)

vabs(x)

vlog(x)
vlog2(x)
vlog10(x)

vsqrt(x)
poly2(x)
poly3(x)
poly4(x)

tv(x, knots = NULL, ord = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jm_+3A_surv_object">Surv_object</code></td>
<td>
<p>an object: <br />
</p>

<ul>
<li><p> of class 'coxph' fitted by function <code>coxph()</code> from package <b>survival</b>, or
</p>
</li>
<li><p> of class 'survreg' fitted by function <code>survreg()</code> from package <b>survival</b>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="jm_+3A_mixed_objects">Mixed_objects</code></td>
<td>
<p>a <code>list</code> of objects or a single object. Objects may be: <br />
</p>

<ul>
<li><p> of class 'lme' fitted by function <code>lme()</code> from package <b>nlme</b>, or
</p>
</li>
<li><p> of class 'MixMod' fitted by function <code>mixed_model()</code> from package <b>GLMMadaptive</b>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="jm_+3A_time_var">time_var</code></td>
<td>
<p>a <code>character</code> string indicating the time variable in the mixed-effects model(s).</p>
</td></tr>
<tr><td><code id="jm_+3A_recurrent">recurrent</code></td>
<td>
<p>a <code>character</code> string indicating &quot;calendar&quot; or &quot;gap&quot; timescale to fit a recurrent event model.</p>
</td></tr>
<tr><td><code id="jm_+3A_functional_forms">functional_forms</code></td>
<td>
<p>a <code>list</code> of formulas. Each formula corresponds to one longitudinal outcome and specifies the association structure between that outcome and the survival submodel as well as any interaction terms between the components of the longitudinal outcome and the survival submodel. See <b>Examples</b>.</p>
</td></tr>
<tr><td><code id="jm_+3A_data_surv">data_Surv</code></td>
<td>
<p>the <code>data.frame</code> used to fit the Cox/AFT survival submodel.</p>
</td></tr>
<tr><td><code id="jm_+3A_id_var">id_var</code></td>
<td>
<p>a <code>character</code> string indicating the id variable in the survival submodel.</p>
</td></tr>
<tr><td><code id="jm_+3A_priors">priors</code></td>
<td>
<p>a named <code>list</code> of user-specified prior parameters:
</p>

<dl>
<dt><code>mean_betas_HC</code></dt><dd><p>the prior mean vector of the normal prior for the regression coefficients of the covariates of the longitudinal model(s), which were hierarchically centered.</p>
</dd>
<dt><code>Tau_betas_HC</code></dt><dd><p>the prior precision matrix of the normal prior for the regression coefficients of the longitudinal model(s), which were hierarchically centered.</p>
</dd>
<dt><code>mean_betas_nHC</code></dt><dd><p>a <code>list</code> of the prior mean vector(s) of the normal prior(s) for the regression coefficients of the covariates of the longitudinal model(s), which were not hierarchically centered.</p>
</dd>
<dt><code>Tau_betas_nHC</code></dt><dd><p>a <code>list</code> of the prior precision matrix(ces) of the normal prior(s) for the regression coefficients of the longitudinal model(s), which were not Hierarchically Centered.</p>
</dd>
<dt><code>mean_bs_gammas</code></dt><dd><p>the prior mean vector of the normal prior for the B-splines
coefficients used to approximate the baseline hazard.</p>
</dd>
<dt><code>Tau_bs_gammas</code></dt><dd><p>the prior precision matrix of the normal prior for the B-splines
coefficients used to approximate the baseline hazard.</p>
</dd>
<dt><code>A_tau_bs_gammas</code></dt><dd><p>the prior shape parameter of the gamma prior for the
precision parameter of the penalty term for the B-splines coefficients for
the baseline hazard.</p>
</dd>
<dt><code>B_tau_bs_gammas</code></dt><dd><p>the prior rate parameter of the gamma prior for the
precision parameter of the penalty term for the B-splines coefficients for
the baseline hazard.</p>
</dd>
<dt><code>rank_Tau_bs_gammas</code></dt><dd><p>the prior rank parameter for the precision matrix of the normal prior for the B-splines coefficients used to approximate the baseline hazard.</p>
</dd>
<dt><code>mean_gammas</code></dt><dd><p>the prior mean vector of the normal prior for the regression
coefficients of baseline covariates.</p>
</dd>
<dt><code>Tau_gammas</code></dt><dd><p>the prior precision matrix of the normal prior for the regression
coefficients of baseline covariates.</p>
</dd>
<dt><code>penalty_gammas</code></dt><dd><p>a character string with value 'none', 'ridge', or 'horseshoe' indicating whether the coefficients of the baseline covariates included in the survival submodel should not be shrunk, shrank using ridge prior, or shrank using horseshoe prior, respectively.</p>
</dd>
<dt><code>A_lambda_gammas</code></dt><dd><p>the prior shape parameter of the gamma prior for the
precision parameter of the local penalty term for the baseline regression coefficients. Only relevant when <code>penalty_gammas = 'ridge'</code> or when <code>penalty_gammas = 'horseshoe'</code>.</p>
</dd>
<dt><code>B_lambda_gammas</code></dt><dd><p>the prior rate parameter of the gamma prior for the
precision parameter of the local penalty term for the baseline regression coefficients. Only relevant when <code>penalty_gammas = 'ridge'</code> or when <code>penalty_gammas = 'horseshoe'</code>.</p>
</dd>
<dt><code>A_tau_gammas</code></dt><dd><p>the prior shape parameter of the gamma prior for the
precision parameter of the global penalty term for the baseline regression coefficients. Only relevant when <code>penalty_gammas = 'ridge'</code> or when <code>penalty_gammas = 'horseshoe'</code>.</p>
</dd>
<dt><code>B_tau_gammas</code></dt><dd><p>the prior rate parameter of the gamma prior for the
precision parameter of the global penalty term for the baseline regression coefficients. Only relevant when <code>penalty_gammas = 'ridge'</code> or when <code>penalty_gammas = 'horseshoe'</code>.</p>
</dd>
<dt><code>A_nu_gammas</code></dt><dd><p>the prior shape parameter of the gamma prior for the variance hyperparameter for the precision parameter of the local penalty term for the baseline regression coefficients. Only relevant when <code>penalty_gammas = 'ridge'</code> or when <code>penalty_gammas = 'horseshoe'</code>.</p>
</dd>
<dt><code>B_nu_gammas</code></dt><dd><p>the prior rate parameter of the gamma prior for the variance hyperparameter for the precision parameter of the local penalty term for the baseline regression coefficients. Only relevant when <code>penalty_gammas = 'ridge'</code> or when <code>penalty_gammas = 'horseshoe'</code>.</p>
</dd>
<dt><code>A_xi_gammas</code></dt><dd><p>the prior shape parameter of the gamma prior for the variance hyperparameter for the precision parameter of the global penalty term for the baseline regression coefficients. Only relevant when <code>penalty_gammas = 'ridge'</code> or when <code>penalty_gammas = 'horseshoe'</code>.</p>
</dd>
<dt><code>B_xi_gammas</code></dt><dd><p>the prior rate parameter of the gamma prior for the variance hyperparameter for the precision parameter of the global penalty term for the baseline regression coefficients. Only relevant when <code>penalty_gammas = 'ridge'</code> or when <code>penalty_gammas = 'horseshoe'</code>.</p>
</dd>
<dt><code>mean_alphas</code></dt><dd><p>the prior mean vector of the normal prior for the association
parameter(s).</p>
</dd>
<dt><code>Tau_alphas</code></dt><dd><p>the prior mean vector of the normal prior for the association
parameter(s).</p>
</dd>
<dt><code>penalty_alphas</code></dt><dd><p>a character string with value 'none', 'ridge', 'horseshoe' indicating whether the coefficients association parameters should not be shrunk, shrank using ridge prior, or shrank using horseshoe prior, respectively.</p>
</dd>
<dt><code>A_lambda_alphas</code></dt><dd><p>the prior shape parameter of the gamma prior for the
precision parameter of the local penalty term for the association parameters. Only relevant when <code>penalty_gammas = 'ridge'</code> or when <code>penalty_gammas = 'horseshoe'</code>.</p>
</dd>
<dt><code>B_lambda_alphas</code></dt><dd><p>the prior rate parameter of the gamma prior for the
precision parameter of the local penalty term for the association parameters. Only relevant when <code>penalty_gammas = 'ridge'</code> or when <code>penalty_gammas = 'horseshoe'</code>.</p>
</dd>
<dt><code>A_tau_alphas</code></dt><dd><p>the prior shape parameter of the gamma prior for the
precision parameter of the global penalty term for the association parameters. Only relevant when <code>penalty_gammas = 'ridge'</code> or when <code>penalty_gammas = 'horseshoe'</code>.</p>
</dd>
<dt><code>B_tau_alphas</code></dt><dd><p>the prior rate parameter of the gamma prior for the
precision parameter of the global penalty term for the association parameters. Only relevant when <code>penalty_gammas = 'ridge'</code> or <code>penalty_gammas = 'horseshoe'</code>.</p>
</dd>
<dt><code>A_nu_alphas</code></dt><dd><p>the prior shape parameter of the gamma prior for the variance hyperparameter for the precision parameter of the local penalty term for the association parameters. Only relevant when <code>penalty_gammas = 'ridge'</code>, or <code>penalty_gammas = 'horseshoe'</code>.</p>
</dd>
<dt><code>B_nu_alphas</code></dt><dd><p>the prior rate parameter of the gamma prior for the variance hyperparameter for the precision parameter of the local penalty term for the association parameters. Only relevant when <code>penalty_gammas = 'ridge'</code> or when <code>penalty_gammas = 'horseshoe'</code>.</p>
</dd>
<dt><code>A_xi_alphas</code></dt><dd><p>the prior shape parameter of the gamma prior for the variance hyperparameter for the precision parameter of the global penalty term for the association parameters. Only relevant when <code>penalty_gammas = 'ridge'</code> or when <code>penalty_gammas = 'horseshoe'</code>.</p>
</dd>
<dt><code>B_xi_alphas</code></dt><dd><p>the prior rate parameter of the gamma prior for the variance hyperparameter for the precision parameter of the global penalty term for the association parameters. Only relevant when <code>penalty_gammas = 'ridge'</code> or when <code>penalty_gammas = 'horseshoe'</code>.</p>
</dd>
<dt><code>gamma_prior_D_sds</code></dt><dd><p>logical; if <code>TRUE</code>, a gamma prior will be used for the standard deviations of the D matrix (variance-covariance matrix of the random effects). Defaults to <code>TRUE</code></p>
</dd>
<dt><code>D_sds_df</code></dt><dd><p>the prior degrees of freedom parameter for the half-t prior for the standard deviations of the D matrix (variance-covariance matrix of the random effects).</p>
</dd>
<dt><code>D_sds_sigma</code></dt><dd><p>the prior sigma parameter vector for the half-t prior for the standard deviations of the D matrix (variance-covariance matrix of the random effects).</p>
</dd>
<dt><code>D_sds_shape</code></dt><dd><p>the prior shape parameter for the gamma prior for the standard deviations of the D matrix (variance-covariance matrix of the random effects).</p>
</dd>
<dt><code>D_sds_mean</code></dt><dd><p>the prior mean parameter vector for the gamma prior for the standard deviations of the D matrix (variance-covariance matrix of the random effects).</p>
</dd>
<dt><code>D_L_etaLKJ</code></dt><dd><p>the prior eta parameter for the LKJ prior for the correlation matrix of the random effects.</p>
</dd>
<dt><code>sigmas_df</code></dt><dd><p>the prior degrees of freedom parameter for the half-t prior for the error term(s).</p>
</dd>
<dt><code>sigmas_sigma</code></dt><dd><p>the prior sigma parameter for the half-t prior for the error term(s).</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="jm_+3A_control">control</code></td>
<td>
<p>a list of control values with components:
</p>

<dl>
<dt><code>GK_k</code></dt><dd><p>the number of quadrature points for the Gauss Kronrod rule; options 15 and 7.</p>
</dd>
<dt><code>Bsplines_degree</code></dt><dd><p>the degree of the splines in each basis; default quadratic splines.</p>
</dd>
<dt><code>base_hazard_segments</code></dt><dd><p>the number of segments to split the follow-up period.
Defaults to 10.</p>
</dd>
<dt><code>diff</code></dt><dd><p>the order of the difference used in the penalty matrix for the B-splines for
h_0. Defaults to 2.</p>
</dd>
<dt><code>n_chains</code></dt><dd><p>an integer specifying the number of chains for the MCMC. Defaults to 3.</p>
</dd>
<dt><code>n_burnin</code></dt><dd><p>an integer specifying the number of burn-in iterations. Defaults to 500.</p>
</dd>
<dt><code>n_iter</code></dt><dd><p>an integer specifying the number of total iterations per chain. Defaults to 3500.</p>
</dd>
<dt><code>n_thin</code></dt><dd><p>an integer specifying the thinning of the chains. Defaults to 1.</p>
</dd>
<dt><code>seed</code></dt><dd><p>the seed used in the sampling procedures. Defaults to 123.</p>
</dd>
<dt><code>MALA</code></dt><dd><p>a <code>logical</code>; if TRUE, the MALA algorithm is used when updating the elements
of the Cholesky factor of the D matrix. Defaults to <code>FALSE</code>.</p>
</dd>
<dt><code>save_random_effects</code></dt><dd><p>a <code>logical</code>; if TRUE, the full MCMC results of the random
effects will be saved and returned with the <code>jm</code> object. Defaults to <code>FALSE</code>.</p>
</dd>
<dt><code>cores</code></dt><dd><p>an integer specifying the number of cores to use for running the chains in
parallel; no point of setting this greater than <code>n_chains</code>.</p>
</dd>
<dt><code>knots</code></dt><dd><p>a numeric vector with the position of the knots for the B-spline approximation
of the log baseline hazard function.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="jm_+3A_x">x</code></td>
<td>
<p>a numeric input variable.</p>
</td></tr>
<tr><td><code id="jm_+3A_knots">knots</code></td>
<td>
<p>a numeric vector of knots.</p>
</td></tr>
<tr><td><code id="jm_+3A_ord">ord</code></td>
<td>
<p>an integer denoting the order of the spline.</p>
</td></tr>
<tr><td><code id="jm_+3A_zero_ind">zero_ind</code></td>
<td>
<p>a list with integer vectors indicating which coefficients are set to zero in the calculation of the value  term. This can be used to include for example only the random intercept; default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="jm_+3A_eps">eps</code></td>
<td>
<p>numeric scalar denoting the step-size for the finite difference approximation.</p>
</td></tr>
<tr><td><code id="jm_+3A_direction">direction</code></td>
<td>
<p>character string for the direction of the numerical derivative, options are <code>"both"</code>,
and <code>"backward"</code>.</p>
</td></tr>
<tr><td><code id="jm_+3A_time_window">time_window</code></td>
<td>
<p>numeric scalar denoting the lower limit for calculating the integral.</p>
</td></tr>
<tr><td><code id="jm_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>control</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mathematical details regarding the definition of the multivariate joint model, and the capabilities of the package can be found in the vignette in the doc directory.
</p>


<h3>Value</h3>

<p>A list of class <code>jm</code> with components:
</p>
<table>
<tr><td><code>mcmc</code></td>
<td>
<p>a <code>list</code> of the MCMC samples for each parameter.</p>
</td></tr>
<tr><td><code>acc_rates</code></td>
<td>
<p>a <code>list</code> of the acceptance rates for each parameter.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>a <code>matrix</code> of dimensions [<code>((n_iter - n_burnin)/n_thin)*n_thin</code>, number of individuals], with element [i, j] being the conditional log-Likelihood value of the <code class="reqn">i^{th}</code> iteration for the <code class="reqn">j^{th}</code> individual.</p>
</td></tr>
<tr><td><code>mlogLik</code></td>
<td>
<p>a <code>matrix</code> of dimensions [<code>((n_iter - n_burnin)/n_thin)*n_thin</code>, number of individuals], with element [i, j] being the marginal log-Likelihood value of the <code class="reqn">i^{th}</code> iteration for the <code class="reqn">j^{th}</code> individual.</p>
</td></tr>
<tr><td><code>running_time</code></td>
<td>
<p>an object of class <code>proc_time</code> with the time used to run <code>jm</code>.</p>
</td></tr>
<tr><td><code>statistics</code></td>
<td>
<p>a <code>list</code> with posterior estimates of the parameters (means, medians, standard deviations, standard errors, effective sample sizes, tail probabilities, upper and lower bounds of credible intervals, etc.).</p>
</td></tr>
<tr><td><code>fit_stats</code></td>
<td>
<p>a <code>list</code> of lists with fit statistics (DIC, pD, LPML, CPO, WAIC) for both conditional and marginal formulations.</p>
</td></tr>
<tr><td><code>model_data</code></td>
<td>
<p>a <code>list</code> of data used to fit the model.</p>
</td></tr>
<tr><td><code>model_info</code></td>
<td>
<p>a <code>list</code> of components of the fit useful to other functions.</p>
</td></tr>
<tr><td><code>initial_values</code></td>
<td>
<p>a <code>list</code> with the initial values of the parameters.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>a copy of the <code>control</code> values used to fit the model.</p>
</td></tr>
<tr><td><code>priors</code></td>
<td>
<p>a copy of the <code>priors</code> used to fit the model.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+methods.jm">methods.jm</a></code>,
<code><a href="#topic+coda_methods.jm">coda_methods.jm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
################################################################################

##############################################
# Univariate joint model for serum bilirubin #
# 1 continuous outcome                       #
##############################################

# [1] Fit the mixed model using lme().
fm1 &lt;- lme(fixed = log(serBilir) ~ year * sex + I(year^2) +
           age + prothrombin, random =  ~ year | id, data = pbc2)

# [2] Fit a Cox model, specifying the baseline covariates to be included in the
# joint model.
fCox1 &lt;- coxph(Surv(years, status2) ~ drug + age, data = pbc2.id)

# [3] The basic joint model is fitted using a call to jm() i.e.,
joint_model_fit_1 &lt;- jm(fCox1, fm1, time_var = "year",
        n_chains = 1L, n_iter = 11000L, n_burnin = 1000L)
summary(joint_model_fit_1)
traceplot(joint_model_fit_1)

################################################################################

##########################################################################
# Multivariate joint model for serum bilirubin, hepatomegaly and ascites #
# 1 continuous outcome, 2 categorical outcomes                           #
##########################################################################

# [1] Fit the mixed-effects models using lme() for continuous
# outcomes and mixed_model() for categorical outcomes.
fm1 &lt;- lme(fixed = log(serBilir) ~ year * sex,
           random = ~ year | id, data = pbc2)

fm2 &lt;- mixed_model(hepatomegaly ~ sex + age + year, data = pbc2,
                   random = ~ year | id, family = binomial())

fm3 &lt;- mixed_model(ascites ~ year + age, data = pbc2,
                   random = ~ year | id, family = binomial())

# [2] Save all the fitted mixed-effects models in a list.
Mixed &lt;- list(fm1, fm2, fm3)

# [3] Fit a Cox model, specifying the baseline covariates to be included in the
# joint model.
fCox1 &lt;- coxph(Surv(years, status2) ~ drug + age, data = pbc2.id)

# [4] The joint model is fitted using a call to jm() i.e.,
joint_model_fit_2 &lt;- jm(fCox1, Mixed, time_var = "year",
      n_chains = 1L, n_iter = 11000L, n_burnin = 1000L)
summary(joint_model_fit_2)
traceplot(joint_model_fit_2)

################################################################################

######################
# Slope &amp; Area Terms #
######################

# We extend model 'joint_model_fit_2' by including the value and slope term for
# bilirubin, the area term for hepatomegaly (in the log-odds scale), and the
# value and area term for spiders (in the log-odds scale).
# To include these terms into the model, we specify the 'functional_forms'
# argument. This should be a list of right side formulas. Each component of the
# list should have as name the name of the corresponding outcome variable. In
# the right side formula we specify the functional form of the association using
# functions 'value()', 'slope()' and 'area()'.
# Notes: (1) For terms not specified in the 'functional_forms' list, the default
# value functional form is used.

# [1] Fit the mixed-effects models using lme() for continuous outcomes
# and mixed_model() for categorical outcomes.
fm1 &lt;- lme(fixed = log(serBilir) ~ year * sex, random = ~ year | id, data = pbc2)

fm2 &lt;- mixed_model(hepatomegaly ~ sex + age + year, data = pbc2,
                   random = ~ year | id, family = binomial())

fm3 &lt;- mixed_model(ascites ~ year + age, data = pbc2,
                   random = ~ year | id, family = binomial())

# [2] Save all the fitted mixed-effects models in a list.
Mixed &lt;- list(fm1, fm2, fm3)

# [3] Fit a Cox model, specifying the baseline covariates to be included in the
# joint model.
fCox1 &lt;- coxph(Surv(years, status2) ~ drug + age, data = pbc2.id)

# [4] Specify the list of formulas to be passed to the functional_forms argument
# of jm().
fForms &lt;- list("log(serBilir)" = ~ value(log(serBilir)) + slope(log(serBilir)),
               "hepatomegaly" = ~ area(hepatomegaly),
               "ascites" = ~ value(ascites) + area(ascites))

# [5] The joint model is fitted using a call to jm() and passing the list
# to the functional_forms argument.
joint_model_fit_2 &lt;- jm(fCox1, Mixed, time_var = "year",
                        functional_forms = fForms, n_chains = 1L,
                        n_iter = 11000L, n_burnin = 1000L)
summary(joint_model_fit_2)


</code></pre>

<hr>
<h2 id='jm+20coda+20Methods'>
Various Methods for Functions from the <em>coda</em> Package
</h2><span id='topic+coda_methods.jm'></span><span id='topic+traceplot'></span><span id='topic+traceplot.jm'></span><span id='topic+ggtraceplot'></span><span id='topic+ggtraceplot.jm'></span><span id='topic+gelman_diag'></span><span id='topic+gelman_diag.jm'></span><span id='topic+densplot'></span><span id='topic+densplot.jm'></span><span id='topic+ggdensityplot'></span><span id='topic+ggdensityplot.jm'></span><span id='topic+cumuplot'></span><span id='topic+cumuplot.jm'></span>

<h3>Description</h3>

<p>Methods for an object of class <code>"jm"</code> for diagnostic functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
traceplot(object, ...)

## S3 method for class 'jm'
traceplot(object,
  parm = c("all", "betas", "sigmas", "D", "bs_gammas",
           "tau_bs_gammas", "gammas", "alphas"), ...)

ggtraceplot(object, ...)

## S3 method for class 'jm'
ggtraceplot(object,
  parm = c("all", "betas", "sigmas", "D", "bs_gammas",
           "tau_bs_gammas", "gammas", "alphas"),
  size = 1, alpha = 0.8,
  theme = c('standard', 'catalog', 'metro',
                'pastel', 'beach', 'moonlight', 'goo', 'sunset', 'custom'),
  grid = FALSE, gridrows = 3, gridcols = 1, custom_theme = NULL, ...)

gelman_diag(object, ...)

## S3 method for class 'jm'
gelman_diag(object,
  parm = c("all", "betas", "sigmas", "D", "bs_gammas",
           "tau_bs_gammas", "gammas", "alphas"), ...)

densplot(object, ...)

## S3 method for class 'jm'
densplot(object,
  parm = c("all", "betas", "sigmas", "D", "bs_gammas",
           "tau_bs_gammas", "gammas", "alphas"), ...)

ggdensityplot(object, ...)

## S3 method for class 'jm'
ggdensityplot(object,
  parm = c("all", "betas", "sigmas", "D", "bs_gammas",
           "tau_bs_gammas", "gammas", "alphas"),
  size = 1, alpha = 0.6,
  theme = c('standard', 'catalog', 'metro', 'pastel',
                'beach', 'moonlight', 'goo', 'sunset', 'custom'),
  grid = FALSE, gridrows = 3, gridcols = 1, custom_theme = NULL, ...)

cumuplot(object, ...)

## S3 method for class 'jm'
cumuplot(object,
  parm = c("all", "betas", "sigmas", "D", "bs_gammas",
           "tau_bs_gammas", "gammas", "alphas"), ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jm+2B20coda+2B20Methods_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"jm"</code>.</p>
</td></tr>
<tr><td><code id="jm+2B20coda+2B20Methods_+3A_parm">parm</code></td>
<td>
<p>a character string specifying which parameters of the joint model to plot. Possible options are <code>'all'</code>, <code>'betas'</code>, <code>'alphas'</code>, <code>'sigmas'</code>, <code>'D'</code>, <code>'bs_gammas'</code>, <code>'tau_bs_gammas'</code>, or <code>'gammas'</code>.<br /></p>
</td></tr>
<tr><td><code id="jm+2B20coda+2B20Methods_+3A_size">size</code></td>
<td>
<p>the width of the traceplot line in mm. Defaults to 1.</p>
</td></tr>
<tr><td><code id="jm+2B20coda+2B20Methods_+3A_alpha">alpha</code></td>
<td>
<p>the opacity level of the traceplot line. Defaults to 0.8.</p>
</td></tr>
<tr><td><code id="jm+2B20coda+2B20Methods_+3A_theme">theme</code></td>
<td>
<p>a character string specifying the color theme to be used. Possible options are <code>'standard'</code>, <code>'catalog'</code>, <code>'metro'</code>, <code>'pastel'</code>, <code>'beach'</code>, <code>'moonlight'</code>, <code>'goo'</code>, or <code>'sunset'</code>. Note that this option supports fitted objects with three chains. If the object was fitted using a different number of chains then the colors are either automatically chosen, or can be specified by the user via the argument <code>custom_theme</code>. <br /></p>
</td></tr>
<tr><td><code id="jm+2B20coda+2B20Methods_+3A_grid">grid</code></td>
<td>
<p>logical; defaults to <code>FALSE</code>. If <code>TRUE</code>, the plots are returned in grids split over multiple pages. For more details see the documentation for <code><a href="gridExtra.html#topic+arrangeGrob">gridExtra::marrangeGrob()</a></code>. <br /></p>
</td></tr>
<tr><td><code id="jm+2B20coda+2B20Methods_+3A_gridrows">gridrows</code></td>
<td>
<p>number of rows per page for the grid. Only relevant when using <code>grid = TRUE</code>. Defaults to 3.</p>
</td></tr>
<tr><td><code id="jm+2B20coda+2B20Methods_+3A_gridcols">gridcols</code></td>
<td>
<p>number of columns per page for the grid. Only relevant when using <code>grid = TRUE</code>. Defaults to 1.</p>
</td></tr>
<tr><td><code id="jm+2B20coda+2B20Methods_+3A_custom_theme">custom_theme</code></td>
<td>
<p>A named character vector with elements equal to the number of chains (<code>n_chains</code>). The name of each element should be the number corresponding to the respective chain. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="jm+2B20coda+2B20Methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to the corresponding function from the <b>coda</b> package.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><code>traceplot()</code></dt><dd><p>Plots the evolution of the estimated parameter vs. iterations in a fitted joint model.</p>
</dd>
<dt><code>ggtraceplot()</code></dt><dd><p>Plots the evolution of the estimated parameter vs. iterations in a fitted joint model using <span class="pkg">ggplot2</span>.</p>
</dd>
<dt><code>gelman_diag()</code></dt><dd><p>Calculates the potential scale reduction factor for the estimated parameters in a fitted joint model, together with the upper confidence limits.</p>
</dd>
<dt><code>densplot()</code></dt><dd><p>Plots the density estimate for the estimated parameters in a fitted joint model.</p>
</dd>
<dt><code>ggdensityplot()</code></dt><dd><p>Plots the evolution of the estimated parameter vs. iterations in a fitted joint model using <span class="pkg">ggplot2</span>.</p>
</dd>
<dt><code>cumuplot()</code></dt><dd><p>Plots the evolution of the sample quantiles vs. iterations in a fitted joint model.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jm">jm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# linear mixed model fits
fit_lme1 &lt;- lme(log(serBilir) ~ year:sex + age,
                random = ~ year | id, data = pbc2)

fit_lme2 &lt;- lme(prothrombin ~ sex,
                random = ~ year | id, data = pbc2)

# cox model fit
fit_cox &lt;- coxph(Surv(years, status2) ~ age, data = pbc2.id)

# joint model fit
fit_jm &lt;- jm(fit_cox, list(fit_lme1, fit_lme2), time_var = "year", n_chains = 1L)

# trace plot for the fixed effects in the linear mixed submodels
traceplot(fit_jm, parm = "betas")

# density plot for the fixed effects in the linear mixed submodels
densplot(fit_jm, parm = "betas")

# cumulative quantile plot for the fixed effects in the linear mixed submodels
cumuplot(fit_jm, parm = "betas")

# trace plot for the fixed effects in the linear mixed submodels
ggtraceplot(fit_jm, parm = "betas")
ggtraceplot(fit_jm, parm = "betas", grid = TRUE)
ggtraceplot(fit_jm, parm = "betas", custom_theme = c('1' = 'black'))

# trace plot for the fixed effects in the linear mixed submodels
ggdensityplot(fit_jm, parm = "betas")
ggdensityplot(fit_jm, parm = "betas", grid = TRUE)
ggdensityplot(fit_jm, parm = "betas", custom_theme = c('1' = 'black'))

</code></pre>

<hr>
<h2 id='jm+20Methods'>
Various Methods for Standard Generics
</h2><span id='topic+methods.jm'></span><span id='topic+coef'></span><span id='topic+coef.jm'></span><span id='topic+fixef'></span><span id='topic+fixef.jm'></span><span id='topic+ranef'></span><span id='topic+ranef.jm'></span><span id='topic+terms'></span><span id='topic+terms.jm'></span><span id='topic+model.matrix'></span><span id='topic+model.matrix.jm'></span><span id='topic+model.frame'></span><span id='topic+model.frame.jm'></span><span id='topic+family'></span><span id='topic+family.jm'></span><span id='topic+get_links'></span><span id='topic+get_links.jm'></span><span id='topic+compare_jm'></span>

<h3>Description</h3>

<p>Methods for object of class <code>"jm"</code> for standard generic functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
coef(object, ...)

## S3 method for class 'jm'
coef(object, ...)

fixef(object, ...)

## S3 method for class 'jm'
fixef(object, outcome = Inf, ...)

ranef(object, ...)

## S3 method for class 'jm'
ranef(object, outcome = Inf, post_vars = FALSE, ...)

terms(x, ...)

## S3 method for class 'jm'
terms(x, process = c("longitudinal", "event"),
                      type = c("fixed", "random"), ...)

model.frame(formula, ...)

## S3 method for class 'jm'
model.frame(formula, process = c("longitudinal", "event"),
                            type = c("fixed", "random"), ...)

model.matrix(object, ...)

## S3 method for class 'jm'
model.matrix(object, ...)

family(object, ...)

## S3 method for class 'jm'
family(object, ...)

compare_jm(..., type = c("marginal", "conditional"),
  order = c("WAIC", "DIC", "LPML", "none"))

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jm+2B20Methods_+3A_object">object</code>, <code id="jm+2B20Methods_+3A_x">x</code>, <code id="jm+2B20Methods_+3A_formula">formula</code></td>
<td>
<p>object inheriting from class <code>"jm"</code>.</p>
</td></tr>
<tr><td><code id="jm+2B20Methods_+3A_outcome">outcome</code></td>
<td>
<p>the index of the linear mixed submodel to extract the estimated fixed effects. If greater
than the total number of submodels, extracts from all of them.</p>
</td></tr>
<tr><td><code id="jm+2B20Methods_+3A_post_vars">post_vars</code></td>
<td>
<p>logical; if <code>TRUE</code>, returns the variance of the posterior distribution.</p>
</td></tr>
<tr><td><code id="jm+2B20Methods_+3A_process">process</code></td>
<td>
<p>which submodel(s) to extract the terms: <br />
</p>

<ul>
<li><p> if <code>"longitudinal"</code>, the linear mixed model(s), or
</p>
</li>
<li><p> if <code>"event"</code>, the survival model.
</p>
</li></ul>

</td></tr>
<tr><td><code id="jm+2B20Methods_+3A_type">type</code></td>
<td>
<p>in <code>terms()</code> and <code>model.frame()</code>, which effects to select in the longitudinal process: <br />
</p>

<ul>
<li><p> if <code>"fixed"</code>, the fixed-effects, or
</p>
</li>
<li><p> if <code>"random"</code>, the random-efects.
</p>
</li></ul>

<p>in <code>compare_jm()</code>, which log-likelihood function use to calculate the criteria: <br />
</p>

<ul>
<li><p> if <code>"marginal"</code>, the marginal log-likelihood, or
</p>
</li>
<li><p> if <code>"conditional"</code>, the conditional log-likelihood.
</p>
</li></ul>

</td></tr>
<tr><td><code id="jm+2B20Methods_+3A_...">...</code></td>
<td>
<p>further arguments; currently, none is used. <br /> in <code>compare_jm()</code>, a series of <code>jm</code> objects.</p>
</td></tr>
<tr><td><code id="jm+2B20Methods_+3A_order">order</code></td>
<td>
<p>which criteria use to sort the models in the output.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><code>coef()</code></dt><dd><p>Extracts estimated fixed effects for the event process from a fitted joint model.</p>
</dd>
<dt><code>fixef()</code></dt><dd><p>Extracts estimated fixed effects for the longitudinal processes from a fitted joint model.</p>
</dd>
<dt><code>ranef()</code></dt><dd><p>Extracts estimated random effects from a fitted joint model.</p>
</dd>
<dt><code>terms()</code></dt><dd><p>Extracts the terms object(s) from a fitted joint model.</p>
</dd>
<dt><code>model.frame()</code></dt><dd><p>Creates the model frame from a fitted joint model.</p>
</dd>
<dt><code>model.matrix()</code></dt><dd><p>Creates the design matrices for linear mixed submodels from a fitted joint model.</p>
</dd>
<dt><code>family()</code></dt><dd><p>Extracts the error distribution and link function used in the linear mixed submodel(s) from a fitted joint model.</p>
</dd>
<dt><code>compare_jm()</code></dt><dd><p>Compares two or more fitted joint models using the criteria WAIC, DIC, and LPML.</p>
</dd>
</dl>



<h3>Value</h3>


<dl>
<dt><code>coef()</code></dt><dd><p>a list with the elements: <br />
</p>

<ul>
<li> <p><code>gammas</code>: estimated baseline fixed effects, and
</p>
</li>
<li> <p><code>association</code>: estimated association parameters.
</p>
</li></ul>

</dd>
<dt><code>fixef()</code></dt><dd><p>a numeric vector of the estimated fixed effects for the <code>outcome</code> selected. If the <code>outcome</code> is greater than the number of linear mixed submodels, it returns a list of numeric vectors for all outcomes.</p>
</dd>
<dt><code>ranef()</code></dt><dd><p>a numeric matrix with rows denoting the individuals and columns the random effects. If <code>postVar = TRUE</code>, the numeric matrix has the extra attribute &quot;postVar&quot;.</p>
</dd>
<dt><code>terms()</code></dt><dd><p>if <code>process = "longitudinal"</code>, a list of the terms object(s) for the linear mixed model(s).
<br /> if <code>process = "event"</code>, the terms object for the survival model.
</p>
</dd>
<dt><code>model.frame()</code></dt><dd><p>if <code>process = "longitudinal"</code>, a list of the model frames used in the linear mixed model(s). <br /> if <code>process = "event"</code>, the model frame used in the survival model.
</p>
</dd>
<dt><code>model.matrix()</code></dt><dd><p>a list of the design matrix(ces) for the linear mixed submodel(s).</p>
</dd>
<dt><code>family()</code></dt><dd><p>a list of <code>family</code> objects.</p>
</dd>
<dt><code>compare_jm()</code></dt><dd><p>a list with the elements: <br />
</p>

<ul>
<li> <p><code>table</code>: a table with the criteria calculated for each joint model, and
</p>
</li>
<li> <p><code>type</code>: the log-likelihood function used to calculate the criteria.
</p>
</li></ul>

</dd>
</dl>



<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jm">jm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# linear mixed model fits
fit_lme1 &lt;- lme(log(serBilir) ~ year:sex + age,
                random = ~ year | id, data = pbc2)

fit_lme2 &lt;- lme(prothrombin ~ sex,
                random = ~ year | id, data = pbc2)

# cox model fit
fit_cox &lt;- coxph(Surv(years, status2) ~ age, data = pbc2.id)

# joint model fit
fit_jm &lt;- jm(fit_cox, list(fit_lme1, fit_lme2), time_var = "year",
    n_chains = 1L, n_iter = 11000L, n_burnin = 1000L)

# coef(): fixed effects for the event process
coef(fit_jm)

# fixef(): fixed effects for the first linear mixed submodel
fixef(fit_jm, outcome = 1)

# ranef(): random effects from all linear mixed submodels
head(ranef(fit_jm))

# terms(): random effects terms for the first linear mixed submodel
terms(fit_jm, process = "longitudinal", type = "random")[[1]]

# mode.frame(): model frame for the fixed effects in the second
# linear mixed submodel
head(model.frame(fit_jm, process = "longitudinal", type = "fixed")[[2]])

# model.matrix(): fixed effects design matrix for the first linear
# mixed submodel
head(model.matrix(fit_jm)[[1]])

# family(): family objects from both linear mixed submodels
family(fit_jm)

# compare_jm(): compare two fitted joint models
fit_lme1b &lt;- lme(log(serBilir) ~ 1,
                  random = ~ year | id, data = pbc2)

fit_jm2 &lt;- jm(fit_cox, list(fit_lme1b, fit_lme2), time_var = "year",
    n_chains = 1L, n_iter = 11000L, n_burnin = 1000L)

compare_jm(fit_jm, fit_jm2)

</code></pre>

<hr>
<h2 id='pbc2'>Mayo Clinic Primary Biliary Cirrhosis Data</h2><span id='topic+pbc2'></span><span id='topic+pbc2.id'></span>

<h3>Description</h3>

<p>Follow up of 312 randomised patients with primary biliary cirrhosis, a rare autoimmune liver disease, at Mayo Clinic.
</p>


<h3>Format</h3>

<p>A data frame with 1945 observations on the following 20 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>patients identifier; in total there are 312 patients.</p>
</dd>
<dt><code>years</code></dt><dd><p>number of years between registration and the earlier of death, transplantion, or study 
analysis time.</p>
</dd>
<dt><code>status</code></dt><dd><p>a factor with levels <code>alive</code>, <code>transplanted</code> and <code>dead</code>.</p>
</dd>
<dt><code>drug</code></dt><dd><p>a factor with levels <code>placebo</code> and <code>D-penicil</code>.</p>
</dd>
<dt><code>age</code></dt><dd><p>at registration in years.</p>
</dd>
<dt><code>sex</code></dt><dd><p>a factor with levels <code>male</code> and <code>female</code>.</p>
</dd>
<dt><code>year</code></dt><dd><p>number of years between enrollment and this visit date, remaining values on the line of 
data refer to this visit.</p>
</dd>
<dt><code>ascites</code></dt><dd><p>a factor with levels <code>No</code> and <code>Yes</code>.</p>
</dd>
<dt><code>hepatomegaly</code></dt><dd><p>a factor with levels <code>No</code> and <code>Yes</code>.</p>
</dd>
<dt><code>spiders</code></dt><dd><p>a factor with levels <code>No</code> and <code>Yes</code>.</p>
</dd>
<dt><code>edema</code></dt><dd><p>a factor with levels <code>No edema</code> (i.e., no edema and no diuretic therapy for edema),
<code>edema no diuretics</code> (i.e., edema present without diuretics, or edema resolved by diuretics), and 
<code>edema despite diuretics</code> (i.e., edema despite diuretic therapy).</p>
</dd>
<dt><code>serBilir</code></dt><dd><p>serum bilirubin in mg/dl.</p>
</dd>
<dt><code>serChol</code></dt><dd><p>serum cholesterol in mg/dl.</p>
</dd>
<dt><code>albumin</code></dt><dd><p>albumin in g/dl.</p>
</dd>
<dt><code>alkaline</code></dt><dd><p>alkaline phosphatase in U/liter.</p>
</dd>
<dt><code>SGOT</code></dt><dd><p>SGOT in U/ml.</p>
</dd>
<dt><code>platelets</code></dt><dd><p>platelets per cubic ml / 1000.</p>
</dd>
<dt><code>prothrombin</code></dt><dd><p>prothrombin time in seconds.</p>
</dd>
<dt><code>histologic</code></dt><dd><p>histologic stage of disease.</p>
</dd>
<dt><code>status2</code></dt><dd><p>a numeric vector with the value 1 denoting if the patient was dead,
and 0 if the patient was alive or transplanted.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The data frame <code>pbc2.id</code> contains the first measurement for each patient. This data frame is used to 
fit the survival model. 
</p>


<h3>References</h3>

<p>Fleming, T. and Harrington, D. (1991) <em>Counting Processes and Survival Analysis</em>. Wiley, New York.
</p>
<p>Therneau, T. and Grambsch, P. (2000) <em>Modeling Survival Data: Extending the Cox Model</em>. Springer-Verlag, New York.
</p>

<hr>
<h2 id='Predictions'>
Predictions from Joint Models
</h2><span id='topic+predict.jm'></span><span id='topic+predict.jmList'></span><span id='topic+plot.predict_jm'></span>

<h3>Description</h3>

<p>Predict method for object of class <code>"jm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'jm'
predict(object, newdata = NULL, newdata2 = NULL, times = NULL,
  times_per_id = FALSE, process = c("longitudinal", "event"),
  type_pred = c("response", "link"),
  type = c("subject_specific", "mean_subject"),
  level = 0.95, return_newdata = FALSE, return_mcmc = FALSE,
  n_samples = 200L, n_mcmc = 55L, parallel = c("snow", "multicore"),
  cores = NULL, seed = 123L,
  ...)

## S3 method for class 'predict_jm'
plot(x, x2 = NULL, subject = 1, outcomes = 1,
  fun_long = NULL, fun_event = NULL, CI_long = TRUE, CI_event = TRUE,
  xlab = "Follow-up Time", ylab_long = NULL, ylab_event = "Cumulative Risk",
  main = "", lwd_long = 2, lwd_event = 2, ylim_long_outcome_range = TRUE,
  col_line_long = "#0000FF",
  col_line_event = c("#FF0000", "#03BF3D", "#8000FF"), pch_points = 16,
  col_points = "blue", cex_points = 1, fill_CI_long = "#0000FF4D",
  fill_CI_event = c("#FF00004D", "#03BF3D4D", "#8000FF4D"), cex_xlab = 1,
  cex_ylab_long = 1, cex_ylab_event = 1, cex_main = 1, cex_axis = 1,
  col_axis = "black", pos_ylab_long = c(0.1, 2, 0.08), bg = "white",
  ...)

## S3 method for class 'jmList'
predict(object, weights, newdata = NULL, newdata2 = NULL,
 times = NULL, times_per_id = FALSE, process = c("longitudinal", "event"),
 type_pred = c("response", "link"),
 type = c("subject_specific", "mean_subject"),
 level = 0.95, return_newdata = FALSE,
 return_mcmc = FALSE, n_samples = 200L, n_mcmc = 55L,
 parallel = c("snow", "multicore"),
 cores = parallelly::availableCores(omit = 1L), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Predictions_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"jm"</code> or a list of <code>"jm"</code> objects.</p>
</td></tr>
<tr><td><code id="Predictions_+3A_weights">weights</code></td>
<td>
<p>a numeric vector of model weights.</p>
</td></tr>
<tr><td><code id="Predictions_+3A_newdata">newdata</code>, <code id="Predictions_+3A_newdata2">newdata2</code></td>
<td>
<p>data.frames.</p>
</td></tr>
<tr><td><code id="Predictions_+3A_times">times</code></td>
<td>
<p>a numeric vector of future times to calculate predictions.</p>
</td></tr>
<tr><td><code id="Predictions_+3A_times_per_id">times_per_id</code></td>
<td>
<p>logical; if <code>TRUE</code> the <code>times</code> argument is a vector of times equal to the number of
subjects in <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="Predictions_+3A_process">process</code></td>
<td>
<p>for which process to calculation predictions, for the longitudinal outcomes or the event times.</p>
</td></tr>
<tr><td><code id="Predictions_+3A_type_pred">type_pred</code></td>
<td>
<p>type of predictions; options are <code>"response"</code> using the inverse link function in GLMMs, and <code>"link"</code> that correspond to the linear predictor.</p>
</td></tr>
<tr><td><code id="Predictions_+3A_type">type</code></td>
<td>
<p>level of predictions; only relevant when <code>type_pred = "longitudinal"</code>. Option <code>type = "subject_specific"</code> combines the fixed- and random-effects parts, whereas <code>type = "mean_subject"</code> uses only the fixed effects.</p>
</td></tr>
<tr><td><code id="Predictions_+3A_level">level</code></td>
<td>
<p>the level of the credible interval.</p>
</td></tr>
<tr><td><code id="Predictions_+3A_return_newdata">return_newdata</code></td>
<td>
<p>logical; should <code>predict()</code> return the predictions as extra columns in <code>newdata</code> and <code>newdata2</code>.</p>
</td></tr>
<tr><td><code id="Predictions_+3A_return_mcmc">return_mcmc</code></td>
<td>
<p>logical; if <code>TRUE</code> the mcmc sample for the predictions is returned. It can be <code>TRUE</code> only in conjuction with <code>return_newdata</code> being <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Predictions_+3A_n_samples">n_samples</code></td>
<td>
<p>the number of samples to use from the original MCMC sample of <code>object</code>.</p>
</td></tr>
<tr><td><code id="Predictions_+3A_n_mcmc">n_mcmc</code></td>
<td>
<p>the number of Metropolis-Hastings iterations for sampling the random effects per iteration of <code>n_samples</code>; only the last iteration is retained.</p>
</td></tr>
<tr><td><code id="Predictions_+3A_parallel">parallel</code></td>
<td>
<p>character string; what type of parallel computing to use.</p>
</td></tr>
<tr><td><code id="Predictions_+3A_cores">cores</code></td>
<td>
<p>how many number of cores to use. If there more than 20 subjects in <code>newdata</code>, parallel computing is invoked with four cores by default. If <code>cores = 1</code>, no parallel computing is used.</p>
</td></tr>
<tr><td><code id="Predictions_+3A_seed">seed</code></td>
<td>
<p>an integer denoting the seed.</p>
</td></tr>
<tr><td><code id="Predictions_+3A_x">x</code>, <code id="Predictions_+3A_x2">x2</code></td>
<td>
<p>objects returned by <code>predict.jm()</code> with argument <code>return_data</code> set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="Predictions_+3A_subject">subject</code></td>
<td>
<p>when multiple subjects are included in the data.frames <code>x</code> and <code>x2</code>, it selects which one to plot. Only a single subject can be plotted each time.</p>
</td></tr>
<tr><td><code id="Predictions_+3A_outcomes">outcomes</code></td>
<td>
<p>when multiple longitudinal outcomes are included in the data.frames <code>x</code> and <code>x2</code>, it selects which ones to plot. A maximum of three outcomes can be plotted each time.</p>
</td></tr>
<tr><td><code id="Predictions_+3A_fun_long">fun_long</code>, <code id="Predictions_+3A_fun_event">fun_event</code></td>
<td>
<p>function to apply to the predictions for the longitudinal and event outcomes, respectively. When multiple longitudinal outcomes are plotted, <code>fun_long</code> can be a list of functions; see examples below.</p>
</td></tr>
<tr><td><code id="Predictions_+3A_ci_long">CI_long</code>, <code id="Predictions_+3A_ci_event">CI_event</code></td>
<td>
<p>logical; should credible interval areas be plotted.</p>
</td></tr>
<tr><td><code id="Predictions_+3A_xlab">xlab</code>, <code id="Predictions_+3A_ylab_long">ylab_long</code>, <code id="Predictions_+3A_ylab_event">ylab_event</code></td>
<td>
<p>characture strings or a chracter vector for <code>ylab_long</code> when multiple longitudinal outcomes are considered with the labels for the horizontal axis, and the two vertical axes.</p>
</td></tr>
<tr><td><code id="Predictions_+3A_lwd_long">lwd_long</code>, <code id="Predictions_+3A_lwd_event">lwd_event</code>, <code id="Predictions_+3A_col_line_long">col_line_long</code>, <code id="Predictions_+3A_col_line_event">col_line_event</code>, <code id="Predictions_+3A_main">main</code>, <code id="Predictions_+3A_fill_ci_long">fill_CI_long</code>, <code id="Predictions_+3A_fill_ci_event">fill_CI_event</code>, <code id="Predictions_+3A_cex_xlab">cex_xlab</code>, <code id="Predictions_+3A_cex_ylab_long">cex_ylab_long</code>, <code id="Predictions_+3A_cex_ylab_event">cex_ylab_event</code>, <code id="Predictions_+3A_cex_main">cex_main</code>, <code id="Predictions_+3A_cex_axis">cex_axis</code>, <code id="Predictions_+3A_pch_points">pch_points</code>, <code id="Predictions_+3A_col_points">col_points</code>, <code id="Predictions_+3A_cex_points">cex_points</code>, <code id="Predictions_+3A_col_axis">col_axis</code>, <code id="Predictions_+3A_bg">bg</code></td>
<td>
<p>graphical parameters; see <code>par</code>.</p>
</td></tr>
<tr><td><code id="Predictions_+3A_pos_ylab_long">pos_ylab_long</code></td>
<td>
<p>controls the position of the y-axis labels when multiple
longitudinal outcomes are plotted.</p>
</td></tr>
<tr><td><code id="Predictions_+3A_ylim_long_outcome_range">ylim_long_outcome_range</code></td>
<td>
<p>logical; if <code>TRUE</code>, the range of the y-axis spans across the range of the outcome in the data used to fit the model; not only the range of values of the specific subject being plotted.</p>
</td></tr>
<tr><td><code id="Predictions_+3A_...">...</code></td>
<td>
<p>extra aguments; currently none is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A detailed description of the methodology behind these predictions is given here: <a href="https://drizopoulos.github.io/JMbayes2/articles/Dynamic_Predictions.html">https://drizopoulos.github.io/JMbayes2/articles/Dynamic_Predictions.html</a>.
</p>


<h3>Value</h3>

<p>Method <code>predict()</code> returns a list or a data.frame (if <code>return_newdata</code> was set to <code>TRUE</code>) with the predictions.
</p>
<p>Method <code>plot()</code> produces figures of the predictions from a single subject.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jm">jm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# We fit a multivariate joint model
pbc2.id$status2 &lt;- as.numeric(pbc2.id$status != 'alive')
CoxFit &lt;- coxph(Surv(years, status2) ~ sex, data = pbc2.id)
fm1 &lt;- lme(log(serBilir) ~ ns(year, 3) * sex, data = pbc2,
           random = ~ ns(year, 3) | id, control = lmeControl(opt = 'optim'))
fm2 &lt;- lme(prothrombin ~ ns(year, 2) * sex, data = pbc2,
           random = ~ ns(year, 2) | id, control = lmeControl(opt = 'optim'))
fm3 &lt;- mixed_model(ascites ~ year * sex, data = pbc2,
                   random = ~ year | id, family = binomial())

jointFit &lt;- jm(CoxFit, list(fm1, fm2, fm3), time_var = "year", n_chains = 1L)

# we select the subject for whom we want to calculate predictions
# we use measurements up to follow-up year 3; we also set that the patients
# were alive up to this time point
t0 &lt;- 3
ND &lt;- pbc2[pbc2$id %in% c(2, 25), ]
ND &lt;- ND[ND$year &lt; t0, ]
ND$status2 &lt;- 0
ND$years &lt;- t0

# predictions for the longitudinal outcomes using newdata
predLong1 &lt;- predict(jointFit, newdata = ND, return_newdata = TRUE)

# predictions for the longitudinal outcomes at future time points
# from year 3 to 10
predLong2 &lt;- predict(jointFit, newdata = ND,
                     times = seq(t0, 10, length.out = 51),
                     return_newdata = TRUE)

# predictions for the event outcome at future time points
# from year 3 to 10
predSurv &lt;- predict(jointFit, newdata = ND, process = "event",
                    times = seq(t0, 10, length.out = 51),
                    return_newdata = TRUE)

plot(predLong1)
# for subject 25, outcomes in reverse order
plot(predLong2, outcomes = 3:1, subject = 25)

# prediction for the event outcome
plot(predSurv)

# combined into one plot, the first longitudinal outcome and cumulative risk
plot(predLong2, predSurv, outcomes = 1)

# the first two longitudinal outcomes
plot(predLong1, predSurv, outcomes = 1:2)

# all three longitudinal outcomes, we display survival probabilities instead
# of cumulative risk, and we transform serum bilirubin to the original scale
plot(predLong2, predSurv, outcomes = 1:3, fun_event = function (x) 1 - x,
     fun_long = list(exp, identity, identity),
     ylab_event = "Survival Probabilities",
     ylab_long = c("Serum Bilirubin", "Prothrombin", "Ascites"),
     pos_ylab_long = c(1.9, 1.9, 0.08))

</code></pre>

<hr>
<h2 id='prothro'>Prednisone versus Placebo in Liver Cirrhosis Patients</h2><span id='topic+prothro'></span><span id='topic+prothros'></span>

<h3>Description</h3>

<p>A randomized trial on 488 liver cirrhosis patients.
</p>


<h3>Format</h3>

<p>Two data frames with the following variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>patients identifier; in total there are 467 patients.</p>
</dd>
<dt><code>pro</code></dt><dd><p>prothrobin measurements.</p>
</dd>
<dt><code>time</code></dt><dd><p>for data frame <code>prothro</code> the time points at which the prothrobin measurements were taken; 
for data frame <code>prothros</code> the time to death or censoring.</p>
</dd>
<dt><code>death</code></dt><dd><p>a numeric vector with 0 denoting censoring and 1 death.</p>
</dd>
<dt><code>treat</code></dt><dd><p>randomized treatment; a factor with levels &quot;placebo&quot; and &quot;prednisone&quot;.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="http://www.gllamm.org/books/readme.html#14.6">http://www.gllamm.org/books/readme.html#14.6</a>.
</p>


<h3>References</h3>

<p>Andersen, P. K., Borgan, O., Gill, R. D. and Keiding, N. (1993). 
<em>Statistical Models Based on Counting Processes</em>. New York: Springer. 
</p>

<hr>
<h2 id='rc_setup'> Combine Recurring and Terminal Event Data in Long Format </h2><span id='topic+rc_setup'></span>

<h3>Description</h3>

<p>This function combines two data frames, the recurring event and terminal event 
datasets, into one. Each subject has as many rows in the new data frame as the 
number of recurrent risk periods plus one for the terminal event.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc_setup(rc_data, trm_data,
    rc_idVar = "id", rc_statusVar = "status",
    rc_startVar = "start", rc_stopVar = "stop",
    trm_idVar = "id", trm_statusVar = "status",
    trm_stopVar = "stop",
    nameStrata = "strata", nameStatus = "status")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rc_setup_+3A_rc_data">rc_data</code></td>
<td>
<p>the data frame containing the recurring event data with 
multiple rows per subject.</p>
</td></tr>
<tr><td><code id="rc_setup_+3A_trm_data">trm_data</code></td>
<td>
<p>the data frame containing the terminal event data with 
a single row per subject.</p>
</td></tr>
<tr><td><code id="rc_setup_+3A_rc_idvar">rc_idVar</code></td>
<td>
<p>a character string denoting the name of the variable in
<code>rc_data</code> that identifies the subject.</p>
</td></tr>
<tr><td><code id="rc_setup_+3A_rc_statusvar">rc_statusVar</code></td>
<td>
<p>a character string denoting the name of the variable in
<code>rc_data</code> that identifies the status variable which equals 1 if the
subject had an event and 0 otherwise.</p>
</td></tr>
<tr><td><code id="rc_setup_+3A_rc_startvar">rc_startVar</code></td>
<td>
<p>a character string denoting the name of the variable in
<code>rc_data</code> that identifies the starting time for the interval.</p>
</td></tr>
<tr><td><code id="rc_setup_+3A_rc_stopvar">rc_stopVar</code></td>
<td>
<p>a character string denoting the name of the variable in
<code>rc_data</code> that identifies the stopping time for the interval.</p>
</td></tr>
<tr><td><code id="rc_setup_+3A_trm_idvar">trm_idVar</code></td>
<td>
<p>a character string denoting the name of the variable in
<code>trm_data</code> that identifies the subject.</p>
</td></tr>
<tr><td><code id="rc_setup_+3A_trm_statusvar">trm_statusVar</code></td>
<td>
<p>a character string denoting the name of the variable in
<code>trm_data</code> that identifies the status variable which equals 1 if the
subject had the event and 0 otherwise.</p>
</td></tr>
<tr><td><code id="rc_setup_+3A_trm_stopvar">trm_stopVar</code></td>
<td>
<p>a character string denoting the name of the variable in
<code>trm_data</code> that identifies the follow up time.</p>
</td></tr>
<tr><td><code id="rc_setup_+3A_namestrata">nameStrata</code></td>
<td>
<p>a character string denoting the variable that will be added
in the long version of <code>data</code> denoting the various causes of event.</p>
</td></tr>
<tr><td><code id="rc_setup_+3A_namestatus">nameStatus</code></td>
<td>
<p>a character string denoting the variable that will be added
in the long version of <code>data</code> denoting if the subject had an event.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame in the long format with multiple rows per subject.
</p>


<h3>Author(s)</h3>

<p>Pedro Miranda Afonso <a href="mailto:p.mirandaafonso@erasmusmc.nl">p.mirandaafonso@erasmusmc.nl</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
