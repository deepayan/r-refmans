<!DOCTYPE html><html><head><title>Help for package inlinedocs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {inlinedocs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#apply.parsers'><p>apply parsers</p></a></li>
<li><a href='#classic.parsers'><p>classic parsers</p></a></li>
<li><a href='#combine'><p>combine</p></a></li>
<li><a href='#combine.character'><p>combine character</p></a></li>
<li><a href='#combine.list'><p>combine list</p></a></li>
<li><a href='#combine.NULL'><p>combine NULL</p></a></li>
<li><a href='#decomment'><p>decomment</p></a></li>
<li><a href='#default.parsers'><p>default parsers</p></a></li>
<li><a href='#descfile.names'><p>descfile names</p></a></li>
<li><a href='#do.not.generate'><p>do not generate</p></a></li>
<li><a href='#DocLink-class'><p>Link documentation among related functions</p></a></li>
<li><a href='#escape_dots'><p>escape dots</p></a></li>
<li><a href='#extra.code.docs'><p>Extract documentation from code chunks</p></a></li>
<li><a href='#extract.docs.file'><p>extract docs file</p></a></li>
<li><a href='#extract.docs.setClass'><p>S4 class inline documentation</p></a></li>
<li><a href='#extract.file.parse'><p>File content analysis</p></a></li>
<li><a href='#extract.xxx.chunks'><p>Extract documentation from a function</p></a></li>
<li><a href='#fake_package_env'><p>fake package env</p></a></li>
<li><a href='#findGeneric'><p>findGeneric</p></a></li>
<li><a href='#fixPackageFileNames'><p>fixPackageFileNames</p></a></li>
<li><a href='#forall'><p>forall</p></a></li>
<li><a href='#forall.parsers'><p>forall parsers</p></a></li>
<li><a href='#forfun'><p>forfun</p></a></li>
<li><a href='#forfun.parsers'><p>forfun parsers</p></a></li>
<li><a href='#get_internal_S3_generics'><p>get internal S3 generics</p></a></li>
<li><a href='#get_S3_primitive_generics'><p>get S3 primitive generics</p></a></li>
<li><a href='#getKnownS3generics'><p>getKnownS3generics</p></a></li>
<li><a href='#getSource'><p>getSource</p></a></li>
<li><a href='#is_primitive_in_base'><p>is primitive in base</p></a></li>
<li><a href='#kill.prefix.whitespace'><p>kill prefix whitespace</p></a></li>
<li><a href='#leadingS3generic'><p>check whether function name is an S3 generic</p></a></li>
<li><a href='#lonely'><p>lonely</p></a></li>
<li><a href='#make.package.and.check'><p>make package and check</p></a></li>
<li><a href='#modify.Rd.file'><p>modify Rd file</p></a></li>
<li><a href='#non.descfile.names'><p>non descfile names</p></a></li>
<li><a href='#nondesc.parsers'><p>nondesc parsers</p></a></li>
<li><a href='#package.skeleton.dx'><p>Package skeleton deluxe</p></a></li>
<li><a href='#prefix'><p>prefix</p></a></li>
<li><a href='#prefixed.lines'><p>prefixed lines</p></a></li>
<li><a href='#print.allfun'><p>print allfun</p></a></li>
<li><a href='#removeAliasesfrom.Rd.file'><p>removeAliasesfrom Rd file</p></a></li>
<li><a href='#replace.one'><p>replace one</p></a></li>
<li><a href='#save.test.result'><p>save test result</p></a></li>
<li><a href='#test.file'><p>test file</p></a></li>
<li><a href='#test.parsers'><p>test parsers</p></a></li>
<li><a href='#whole.word'><p>whole word</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Convert Inline Comments to Documentation</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>2023.9.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Generates Rd files from R source code with comments.
 The main features of the default syntax are that
 (1) docs are defined in comments near the relevant code,
 (2) function argument names are not repeated in comments, and
 (3) examples are defined in R code, not comments.
 It is also easy to define a new syntax.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tdhock/inlinedocs">https://github.com/tdhock/inlinedocs</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tdhock/inlinedocs/issues">https://github.com/tdhock/inlinedocs/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>methods, utils, R (&ge; 2.9)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>future.apply, future, R.methodsS3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-17 21:32:29 UTC; tdhock</td>
</tr>
<tr>
<td>Author:</td>
<td>Toby Dylan Hocking [aut, cre],
  Keith Ponting [aut],
  Thomas Wutzler [aut],
  Philippe Grosjean [aut],
  Markus Müller [aut],
  R Core Team [ctb, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-18 18:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='apply.parsers'>apply parsers</h2><span id='topic+apply.parsers'></span>

<h3>Description</h3>

<p>Parse <code>code</code> to r objs, then run all the <code>parsers</code> and return the
documentation list.</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply.parsers(code, parsers = default.parsers, 
    verbose = FALSE, 
    ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply.parsers_+3A_code">code</code></td>
<td>
<p>Character vector of <code>code</code> lines.</p>
</td></tr>
<tr><td><code id="apply.parsers_+3A_parsers">parsers</code></td>
<td>
<p>List of Parser Functions.</p>
</td></tr>
<tr><td><code id="apply.parsers_+3A_verbose">verbose</code></td>
<td>
<p>Echo names of Parser Functions?</p>
</td></tr>
<tr><td><code id="apply.parsers_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to Parser Functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of extracted documentation from <code>code</code>.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

<hr>
<h2 id='classic.parsers'>classic parsers</h2><span id='topic+classic.parsers'></span>

<h3>Description</h3>

<p>List of classic parsers which were default before 2018.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"classic.parsers"</code></pre>

<hr>
<h2 id='combine'>combine</h2><span id='topic+combine'></span>

<h3>Description</h3>

<p>combine lists or character strings</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine(x, y)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_+3A_x">x</code></td>
<td>
<p>x </p>
</td></tr>
<tr><td><code id="combine_+3A_y">y</code></td>
<td>
<p>y </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

<hr>
<h2 id='combine.character'>combine character</h2><span id='topic+combine.character'></span>

<h3>Description</h3>

<p><code><a href="#topic+combine">combine</a></code> character strings by pasting them together</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'character'
combine(x, 
    y)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine.character_+3A_x">x</code></td>
<td>
<p>x </p>
</td></tr>
<tr><td><code id="combine.character_+3A_y">y</code></td>
<td>
<p>y </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

<hr>
<h2 id='combine.list'>combine list</h2><span id='topic+combine.list'></span>

<h3>Description</h3>

<p><code><a href="#topic+combine">combine</a></code> lists by adding elements or adding to existing elements</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
combine(x, y)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine.list_+3A_x">x</code></td>
<td>
<p>x </p>
</td></tr>
<tr><td><code id="combine.list_+3A_y">y</code></td>
<td>
<p>y </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, same type as <code>x</code>, but with added elements from <code>y</code>.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

<hr>
<h2 id='combine.NULL'>combine NULL</h2><span id='topic+combine.NULL'></span>

<h3>Description</h3>

<p><code><a href="#topic+combine">combine</a></code> NULL objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NULL'
combine(x, y)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine.NULL_+3A_x">x</code></td>
<td>
<p>x </p>
</td></tr>
<tr><td><code id="combine.NULL_+3A_y">y</code></td>
<td>
<p>y </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

<hr>
<h2 id='decomment'>decomment</h2><span id='topic+decomment'></span>

<h3>Description</h3>

<p>Remove comment <code><a href="#topic+prefix">prefix</a></code> and join lines of code to form a
documentation string.</p>


<h3>Usage</h3>

<pre><code class='language-R'>decomment(comments)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decomment_+3A_comments">comments</code></td>
<td>
<p>Character vector of prefixed comment lines.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String without prefixes or newlines.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

<hr>
<h2 id='default.parsers'>default parsers</h2><span id='topic+default.parsers'></span>

<h3>Description</h3>

<p>List of parsers to use by default with <code><a href="#topic+package.skeleton.dx">package.skeleton.dx</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"default.parsers"</code></pre>

<hr>
<h2 id='descfile.names'>descfile names</h2><span id='topic+descfile.names'></span>

<h3>Description</h3>

<p>Names of Parser Functions that operate on the desc arg.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"descfile.names"</code></pre>

<hr>
<h2 id='do.not.generate'>do not generate</h2><span id='topic+do.not.generate'></span>

<h3>Description</h3>

<p>Make a Parser Function used to indicate that certain Rd files
should not be generated.</p>


<h3>Usage</h3>

<pre><code class='language-R'>do.not.generate(...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do.not.generate_+3A_...">...</code></td>
<td>
<p>Character strings indicating Rd files without the .Rd suffix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Parser Function that will delete items from the outer
Documentation List.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>


<h3>Examples</h3>

<pre><code class='language-R'>
silly.pkg &lt;- system.file("silly",package="inlinedocs")
owd &lt;- setwd(tempdir())
file.copy(silly.pkg,".",recursive=TRUE)

## define a custom Parser Function that will not generate some Rd
## files
custom &lt;- do.not.generate("SillyTest-class")
parsers &lt;- c(default.parsers,list(exclude=custom))

## At first, no Rd files in the man subdirectory.
man.dir &lt;- file.path("silly","man")
dir(man.dir)

## Running package.skeleton.dx will generate bare-bones files for
## those specified in do.not.generate, if they do not exist.
package.skeleton.dx("silly",parsers)
Rd.files &lt;- c("SillyTest-class.Rd","silly.example.Rd")
Rd.paths &lt;- file.path(man.dir,Rd.files)
stopifnot(all(file.exists(Rd.paths)))

## Save the modification times of the Rd files
old &lt;- file.info(Rd.paths)$mtime

## make sure there is at least 2 seconds elapsed, which is the
## resolution for recording times on windows file systems.
Sys.sleep(4)

## However, it will NOT generate Rd for files specified in
## do.not.generate, if they DO exist already.
package.skeleton.dx("silly",parsers)
mtimes &lt;- data.frame(old,new=file.info(Rd.paths)$mtime)
rownames(mtimes) &lt;- Rd.files
mtimes$changed &lt;- mtimes$old != mtimes$new
print(mtimes)
stopifnot(mtimes["SillyTest-class.Rd","changed"]==FALSE)
stopifnot(mtimes["silly.example.Rd","changed"]==TRUE)

unlink("silly",recursive=TRUE)
setwd(owd)

</code></pre>

<hr>
<h2 id='DocLink-class'>Link documentation among related functions</h2><span id='topic+DocLink-class'></span><span id='topic+DocLink'></span>

<h3>Description</h3>

<p>The <code>.DocLink</code> class provides the basis for hooking together
documentation of related classes/functions/objects. The aim is that
documentation sections missing from the child are inherited from
the parent class.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new(DocLink ...)</code></p>


<h3>Slots</h3>


<dl>
<dt><code>name</code>:</dt><dd><p>(<code>character</code>) name of object</p>
</dd>
<dt><code>created</code>:</dt><dd><p>(<code>character</code>) how created</p>
</dd>
<dt><code>parent</code>:</dt><dd><p>(<code>character</code>) parent class or NA</p>
</dd>
<dt><code>code</code>:</dt><dd><p>(<code>character</code>) actual source lines</p>
</dd>
<dt><code>description</code>:</dt><dd><p>(<code>character</code>) preceding description block</p>
</dd>
</dl>



<h3>Methods</h3>

<p>No methods defined with class &quot;DocLink&quot; in the signature.
</p>

<hr>
<h2 id='escape_dots'>escape dots</h2><span id='topic+escape_dots'></span>

<h3>Description</h3>

<p>Convert ... to \dots</p>


<h3>Usage</h3>

<pre><code class='language-R'>escape_dots(arg)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="escape_dots_+3A_arg">arg</code></td>
<td>
<p>arg </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

<hr>
<h2 id='extra.code.docs'>Extract documentation from code chunks</h2><span id='topic+extra.code.docs'></span>

<h3>Description</h3>

<p>Parse R <code>code</code> to extract inline documentation from comments around
each function. These are not able to be retreived simply by
looking at the &quot;source&quot; attribute. This is a Parser Function that
can be used in the parser list of package.skeleton.dx(). TODO:
Modularize this into separate Parsers Functions for S4 classes,
prefixes, ##&lt;&lt;blocks, etc. Right now it is not very clean!</p>


<h3>Usage</h3>

<pre><code class='language-R'>extra.code.docs(code, 
    objs, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extra.code.docs_+3A_code">code</code></td>
<td>
<p>Code lines in a character vector containing multiple R objects to
parse for documentation.</p>
</td></tr>
<tr><td><code id="extra.code.docs_+3A_objs">objs</code></td>
<td>
<p>The objects defined in the <code>code</code>.</p>
</td></tr>
<tr><td><code id="extra.code.docs_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list of lists, one for each object to document.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

<hr>
<h2 id='extract.docs.file'>extract docs file</h2><span id='topic+extract.docs.file'></span>

<h3>Description</h3>

<p>Apply all <code>parsers</code> relevant to extract info from just 1 code file.</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract.docs.file(f, 
    parsers = NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.docs.file_+3A_f">f</code></td>
<td>
<p>File name of R code to read and parse.</p>
</td></tr>
<tr><td><code id="extract.docs.file_+3A_parsers">parsers</code></td>
<td>
<p>Parser Functions to use to parse the code and extract
documentation.</p>
</td></tr>
<tr><td><code id="extract.docs.file_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to Parser Functions.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- system.file("silly","R","silly.R",package="inlinedocs")
extract.docs.file(f)

</code></pre>

<hr>
<h2 id='extract.docs.setClass'>S4 class inline documentation</h2><span id='topic+extract.docs.setClass'></span>

<h3>Description</h3>

<p>Using the same conventions as for functions, definitions of S4 classes
in the form <code>setClass("classname",...)</code> are also located and
scanned for inline comments.</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract.docs.setClass(doc.link)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.docs.setClass_+3A_doc.link">doc.link</code></td>
<td>
<p>DocLink object as created by <code>extract.file.parse</code>.
Note that <code>source</code> statements are <em>ignored</em> when scanning for
class definitions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extraction of S4 class documentation is currently limited to expressions
within the source code which have first line starting with
<code>setClass("classname"</code>. These are located from the source file
(allowing also for white space around the <code>setClass</code> and <code>(</code>).
Note that <code>"classname"</code> must be a quoted character string;
expressions returning such a string are not matched.
</p>
<p>For class definitions, the slots (elements of the
<code>representation</code> list) fill the role of function
arguments, so may be documented by <code>##&lt;&lt;</code> comments on
the same line or <code>### </code> comments at the beginning of the
following line.
</p>
<p>If there is no explicit title on the first line of setClass, then
one is made up from the class name.
</p>
<p>The class definition skeleton includes an <code>Objects from the Class</code>
section, to which any <code>##details&lt;&lt;</code> documentation chunks are
written. It is given a vanilla content if there are no specific
<code>##details&lt;&lt;</code> documentation chunks.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

<hr>
<h2 id='extract.file.parse'>File content analysis</h2><span id='topic+extract.file.parse'></span>

<h3>Description</h3>

<p>Using the base <code>parse</code> function, analyse the file to link
preceding &quot;prefix&quot; comments to each active chunk. Those comments form
the default description for that chunk. The analysis also looks for
S4 class &quot;setClass&quot; calls and R.oo setConstructorS3 and <code><a href="R.methodsS3.html#topic+setMethodS3">setMethodS3</a></code>
calls in order to link the documentation of those properly.</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract.file.parse(code)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.file.parse_+3A_code">code</code></td>
<td>
<p>Lines of R source <code>code</code> in a character vector - note that any
nested <code>source</code> statements are <em>ignored</em> when scanning
for class definitions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the definition chunk does not contain a
description, any immediately preceding sequence consecutive
&quot;prefix&quot; lines will be used instead.
</p>
<p>Class and method definitions can take several forms,
determined by expression type: </p>

<dl>
<dt>assignment (&lt;-)</dt><dd><p>Ordinary assignment of value/function;</p>
</dd>
<dt>setClass</dt><dd><p>Definition of S4 class;</p>
</dd>
<dt>setConstructorS3</dt><dd><p>Definition of S3 class using R.oo package;</p>
</dd>
<dt>R.methodsS3::setMethodS3</dt><dd><p>Definition of method for S3 class using R.oo package.</p>
</dd></dl>

<p>Additionally, the value may be a name of a function defined elsewhere,
in which case the documentation should be copied from that other definition.
This is handled using the concept of documentation links.
</p>
<p>The <code>R.methodsS3::setMethodS3</code> calls introduce additional
complexity: they will define an additional S3 generic (which
needs documentation to avoid warnings at package build time)
unless one already exists. This also is handled by &quot;linking&quot;
documentation. A previously unseen generic is linked to the
first defining instances, subsequent definitions of that generic
also link back to the first defining instance.</p>


<h3>Value</h3>

<p>Returns an invisible list of .DocLink objects.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

<hr>
<h2 id='extract.xxx.chunks'>Extract documentation from a function</h2><span id='topic+extract.xxx.chunks'></span>

<h3>Description</h3>

<p>Given source code of a function, return a list describing inline
documentation in that source code.</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract.xxx.chunks(src, 
    name.fun = "(unnamed function)", 
    ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.xxx.chunks_+3A_src">src</code></td>
<td>
<p>The source lines of the function to examine, as a character
vector.</p>
</td></tr>
<tr><td><code id="extract.xxx.chunks_+3A_name.fun">name.fun</code></td>
<td>
<p>The name of the function/chunk to use in warning messages.</p>
</td></tr>
<tr><td><code id="extract.xxx.chunks_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For simple functions/arguments, the argument may also be
documented by appending <code>##&lt;&lt;</code> comments on the same line as the
argument name. Mixing this mechanism with <code>###</code> comment lines for
the same argument is likely to lead to confusion, as the <code>###</code>
lines are processed first.
</p>
<p>Additionally, consecutive sections of <code>##</code> comment
lines beginning with <code>##</code><em>xxx</em><code>&lt;&lt;</code> (where
<em>xxx</em> is one of the fields: <code>alias</code>, <code>details</code>,
<code>keyword</code>, <code>references</code>, <code>author</code>, <code>note</code>,
<code>seealso</code>, <code>value</code>, <code>title</code> or <code>description</code>)
are accumulated and inserted in the relevant part of the .Rd
file.
</p>
<p>For <code>value</code>, <code>title</code>, <code>description</code> and function
arguments, these <em>append</em> to any text from &quot;prefix&quot;
(<code>^### </code>) comment lines, irrespective of the order in the
source.
</p>
<p>When documenting S4 classes, documentation from <code>details</code>
sections will appear under a section <code>Objects from the Class</code>. That
section typically includes information about construction methods
as well as other description of class objects (but note that the
class Slots are documented in a separate section).
</p>
<p>Each separate extra section appears as a new
paragraph except that: </p>
<ul>
<li><p> empty sections (no
matter how many lines) are ignored;</p>
</li>
<li> <p><code>alias</code> and
<code>keyword</code> sections have special rules;</p>
</li>
<li>
<p><code>description</code> should be brief, so all such sections
are concatenated as one paragraph;</p>
</li>
<li> <p><code>title</code> should
be one line, so any extra <code>title</code> sections are
concatenated as a single line with spaces separating the
sections.</p>
</li></ul>

<p>As a special case, the construct <code>##describe&lt;&lt;</code> causes
similar processing to the main function arguments to be
applied in order to construct a describe block within the
documentation, for example to describe the members of a
list. All subsequent &quot;same line&quot; <code>##&lt;&lt;</code> comments go into that
block until terminated by a subsequent <code>##</code><em>xxx</em><code>&lt;&lt;</code> line.
</p>
<p>Such regions may be nested, but not in such a way
that the first element in a <code>describe</code> is another
<code>describe</code>.  Thus there must be at least one
<code>##&lt;&lt;</code> comment between each pair of
<code>##describe&lt;&lt;</code> comments.
</p>
<p>When nested <code>describe</code> blocks are used, a comment-only
line with <code>##end&lt;&lt;</code> terminates the current level only; any
other valid <code>##</code><em>xxx</em><code>&lt;&lt;</code> line terminates
all open describe blocks.</p>


<h3>Value</h3>

<p>Named list of character strings extracted from comments. For each
name N we will look for N{...} in the Rd file and replace it
with the string in this list (implemented in <code><a href="#topic+modify.Rd.file">modify.Rd.file</a></code>).</p>


<h3>Note</h3>

<p><code>alias</code> extras are automatically split at new lines.
</p>
<p><code>keyword</code> extras are automatically split at white space,
as all the valid keywords are single words.
</p>
<p>The &quot;value&quot; section of a .Rd file is implicitly a describe
block and <code>##</code><code>value</code><code>&lt;&lt;</code> acts accordingly. Therefore
it automatically enables the describe block itemization (##&lt;&lt; after
list entries).</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

<hr>
<h2 id='fake_package_env'>fake package env</h2><span id='topic+fake_package_env'></span>

<h3>Description</h3>

<p>Create a fake package environment in a way that keeps S4 working (so
there is a .packageName) and also conforms to byte-code interpreter
requirements on environment structure, particularly ensuring that the
created environment is a namespace.  A similar procedure (with the
exception of not deleting objects) is now in testthat (test_pkg_env).</p>


<h3>Usage</h3>

<pre><code class='language-R'>fake_package_env()</code></pre>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

<hr>
<h2 id='findGeneric'>findGeneric</h2><span id='topic+findGeneric'></span>

<h3>Description</h3>

<p>Copied from R-3.0.1, to support findGeneric.</p>


<h3>Usage</h3>

<pre><code class='language-R'>findGeneric(fname, envir)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findGeneric_+3A_fname">fname</code></td>
<td>
<p>fname </p>
</td></tr>
<tr><td><code id="findGeneric_+3A_envir">envir</code></td>
<td>
<p>envir </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

<hr>
<h2 id='fixPackageFileNames'>fixPackageFileNames</h2><span id='topic+fixPackageFileNames'></span>

<h3>Description</h3>

<p>Copied from R-3.0.1, to support fixPackageFileNames.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixPackageFileNames(list)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixPackageFileNames_+3A_list">list</code></td>
<td>
<p>list </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

<hr>
<h2 id='forall'>forall</h2><span id='topic+forall'></span>

<h3>Description</h3>

<p>For each object in the package that satisfies the criterion
checked by <code>subfun</code>, parse source using <code>FUN</code> and return the resulting
documentation list.</p>


<h3>Usage</h3>

<pre><code class='language-R'>forall(FUN, subfun = function(x) TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forall_+3A_fun">FUN</code></td>
<td>
<p>Function to apply to each element in the package.</p>
</td></tr>
<tr><td><code id="forall_+3A_subfun">subfun</code></td>
<td>
<p>Function to select subsets of elements of the package, such as
is.function. subfun(x)==TRUE means <code>FUN</code> will be applied to x and
the result will be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Parser Function.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

<hr>
<h2 id='forall.parsers'>forall parsers</h2><span id='topic+forall.parsers'></span>

<h3>Description</h3>

<p>List of Parser Functions that can be applied to any object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"forall.parsers"</code></pre>

<hr>
<h2 id='forfun'>forfun</h2><span id='topic+forfun'></span>

<h3>Description</h3>

<p>For each function in the package, do something.</p>


<h3>Usage</h3>

<pre><code class='language-R'>forfun(FUN)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forfun_+3A_fun">FUN</code></td>
<td>
<p>FUN </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

<hr>
<h2 id='forfun.parsers'>forfun parsers</h2><span id='topic+forfun.parsers'></span>

<h3>Description</h3>

<p>Parsers for each function that are constructed automatically. This
is a named list, and each element is a parser function for an
individual object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"forfun.parsers"</code></pre>

<hr>
<h2 id='get_internal_S3_generics'>get internal S3 generics</h2><span id='topic+get_internal_S3_generics'></span>

<h3>Description</h3>

<p>Copied from R-3.0.1, to support <code><a href="#topic+getKnownS3generics">getKnownS3generics</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_internal_S3_generics(primitive = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_internal_S3_generics_+3A_primitive">primitive</code></td>
<td>
<p>primitive </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

<hr>
<h2 id='get_S3_primitive_generics'>get S3 primitive generics</h2><span id='topic+get_S3_primitive_generics'></span>

<h3>Description</h3>

<p>Copied from R-3.0.1, to support <code><a href="#topic+getKnownS3generics">getKnownS3generics</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_S3_primitive_generics(include_group_generics = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_S3_primitive_generics_+3A_include_group_generics">include_group_generics</code></td>
<td>
<p>include_group_generics </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

<hr>
<h2 id='getKnownS3generics'>getKnownS3generics</h2><span id='topic+getKnownS3generics'></span>

<h3>Description</h3>

<p>Copied from R-3.0.1, to support getKnownS3generics.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getKnownS3generics()</code></pre>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

<hr>
<h2 id='getSource'>getSource</h2><span id='topic+getSource'></span>

<h3>Description</h3>

<p>Extract a function's source code.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSource(fun.obj)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSource_+3A_fun.obj">fun.obj</code></td>
<td>
<p>A function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Source code lines as a character vector.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

<hr>
<h2 id='is_primitive_in_base'>is primitive in base</h2><span id='topic+is_primitive_in_base'></span>

<h3>Description</h3>

<p>Copied from R-3.0.1, to support <code><a href="#topic+getKnownS3generics">getKnownS3generics</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_primitive_in_base(fname)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_primitive_in_base_+3A_fname">fname</code></td>
<td>
<p>fname </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

<hr>
<h2 id='kill.prefix.whitespace'>kill prefix whitespace</h2><span id='topic+kill.prefix.whitespace'></span>

<h3>Description</h3>

<p>Figure out what the whitespace preceding the example code is, and
then delete that from every line.</p>


<h3>Usage</h3>

<pre><code class='language-R'>kill.prefix.whitespace(ex)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kill.prefix.whitespace_+3A_ex">ex</code></td>
<td>
<p>character vector of example code lines.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of code lines with preceding whitespace removed.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

<hr>
<h2 id='leadingS3generic'>check whether function name is an S3 generic</h2><span id='topic+leadingS3generic'></span>

<h3>Description</h3>

<p>Determines whether a function <code>name</code> looks like an S3 generic function</p>


<h3>Usage</h3>

<pre><code class='language-R'>leadingS3generic(name, 
    env, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leadingS3generic_+3A_name">name</code></td>
<td>
<p><code>name</code> of function</p>
</td></tr>
<tr><td><code id="leadingS3generic_+3A_env">env</code></td>
<td>
<p>environment to search for additional generics</p>
</td></tr>
<tr><td><code id="leadingS3generic_+3A_...">...</code></td>
<td>
<p>ignored here</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is one of the default parsers, but exposed as
possibly of more general interest. Given a function <code>name</code> of the form
x.y.z it looks for the generic function x applying to objects of class
y.z and also for generic function x.y applying to objects of class z.
</p>
<p>Assumes that the first <code>name</code> which matches any known
generics is the target generic function, so if both x and x.y
are generic functions, will assume generic x applying to objects
of class y.z</p>


<h3>Value</h3>

<p>If a matching generic found returns a list with a single component:
</p>
<table>
<tr><td><code>.s3method</code></td>
<td>
<p>a character vector containing generic <code>name</code> and object <code>name</code>.
</p>
</td></tr>
</table>
<p>If no matching generic functions are found, returns an empty list.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

<hr>
<h2 id='lonely'>lonely</h2><span id='topic+lonely'></span>

<h3>Description</h3>

<p>List of parser functions that operate on single objects. This list
is useful for testing these functions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"lonely"</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>
  f &lt;- function # title
### description
  (x, ##&lt;&lt; arg x
   y
### arg y
   ){
    ##value&lt;&lt; a list with elements
    list(x=x, ##&lt;&lt; original x value
         y=y, ##&lt;&lt; original y value
         sum=x+y) ##&lt;&lt; their sum
    ##end&lt;&lt;
  }
  src &lt;- getSource(f)
  lonely$extract.xxx.chunks(src)
  lonely$prefixed.lines(src)

</code></pre>

<hr>
<h2 id='make.package.and.check'>make package and check</h2><span id='topic+make.package.and.check'></span>

<h3>Description</h3>

<p>Assemble some R code into a package and process it using R CMD
check, stopping with an error if the check resulted in any errors
or warnings.</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.package.and.check(f, 
    parsers = default.parsers, 
    verbose = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.package.and.check_+3A_f">f</code></td>
<td>
<p>R code file name from which we will make a package</p>
</td></tr>
<tr><td><code id="make.package.and.check_+3A_parsers">parsers</code></td>
<td>
<p>Parsers to use to make the package documentation.</p>
</td></tr>
<tr><td><code id="make.package.and.check_+3A_verbose">verbose</code></td>
<td>
<p>print the check command line?</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

<hr>
<h2 id='modify.Rd.file'>modify Rd file</h2><span id='topic+modify.Rd.file'></span>

<h3>Description</h3>

<p>Add inline documentation from comments to an Rd file
automatically-generated by package.skeleton.</p>


<h3>Usage</h3>

<pre><code class='language-R'>modify.Rd.file(N, pkg, 
    docs, verbose = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modify.Rd.file_+3A_n">N</code></td>
<td>
<p>Name of function/file to which we will add documentation.</p>
</td></tr>
<tr><td><code id="modify.Rd.file_+3A_pkg">pkg</code></td>
<td>
<p>Package name.</p>
</td></tr>
<tr><td><code id="modify.Rd.file_+3A_docs">docs</code></td>
<td>
<p>Named list of documentation in extracted comments.</p>
</td></tr>
<tr><td><code id="modify.Rd.file_+3A_verbose">verbose</code></td>
<td>
<p>Cat messages?</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

<hr>
<h2 id='non.descfile.names'>non descfile names</h2><span id='topic+non.descfile.names'></span>

<h3>Description</h3>

<p>Names of Parser Functions that do NOT use the desc arg.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"non.descfile.names"</code></pre>

<hr>
<h2 id='nondesc.parsers'>nondesc parsers</h2><span id='topic+nondesc.parsers'></span>

<h3>Description</h3>

<p>Parsers that operate only on R code, independently of the
description file.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"nondesc.parsers"</code></pre>

<hr>
<h2 id='package.skeleton.dx'>Package skeleton deluxe</h2><span id='topic+package.skeleton.dx'></span>

<h3>Description</h3>

<p>Generates Rd files for a package based on R code and DESCRIPTION
metadata. After reading the pkgdir/R/*.R code files to find inline
documentation (by default R code in *.r files will not be used for
inlinedocs), writes docs to pkgdir/man/*.Rd files, possibly
overwriting the previous files there.</p>


<h3>Usage</h3>

<pre><code class='language-R'>package.skeleton.dx(pkgdir = "..", 
    parsers = NULL, namespace = FALSE, 
    excludePattern = "[.][rsqS]$", 
    verbose = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="package.skeleton.dx_+3A_pkgdir">pkgdir</code></td>
<td>
<p>Package directory where the DESCRIPTION file lives. Your code
should be in pkgdir/R.</p>
</td></tr>
<tr><td><code id="package.skeleton.dx_+3A_parsers">parsers</code></td>
<td>
<p>List of Parser functions, which will be applied in sequence to
extract documentation from your code. Default NULL means to first
search for a definition in the variable &quot;parsers&quot; in
pkgdir/R/.inlinedocs.R, if that file exists. If not, we use the
list defined in options(&quot;inlinedocs.parsers&quot;), if that is
defined. If not, we use the package global default in the variable
<code><a href="#topic+default.parsers">default.parsers</a></code>.</p>
</td></tr>
<tr><td><code id="package.skeleton.dx_+3A_namespace">namespace</code></td>
<td>
<p>A logical indicating whether a NAMESPACE file should be generated
for this package. If <code>TRUE</code>, all objects whose name starts
with a letter, plus all S4 methods and classes are exported.</p>
</td></tr>
<tr><td><code id="package.skeleton.dx_+3A_excludepattern">excludePattern</code></td>
<td>
<p>A regular expression matching the files that are not to be
processed e.g. because inlinedocs can not handle them yet (like
generic function definitions). Default value means to only process
inlinedocs in .R files. Set excludePattern=NULL to process all
code files, e.g. *.r files.</p>
</td></tr>
<tr><td><code id="package.skeleton.dx_+3A_verbose">verbose</code></td>
<td>
<p>show messages about parser functions used?</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>


<h3>Examples</h3>

<pre><code class='language-R'>
owd &lt;- setwd(tempdir())

## get the path to the silly example package that is provided with
## package inlinedocs
testPackagePath &lt;- file.path(system.file(package="inlinedocs"),"silly")
## copy example project to the current unlocked workspace that can
## be modified
file.copy(testPackagePath,".",recursive=TRUE)

## generate documentation .Rd files for this package
package.skeleton.dx("silly")

## check the package to see if generated documentation passes
## without WARNINGs.
if(interactive()){
  cmd &lt;- sprintf("%s CMD check --as-cran silly",file.path(R.home("bin"), "R"))
  print(cmd)
  system(cmd)
}
## cleanup: remove the test package from current workspace again
unlink("silly",recursive=TRUE)
setwd(owd)

</code></pre>

<hr>
<h2 id='prefix'>prefix</h2><span id='topic+prefix'></span>

<h3>Description</h3>

<p>Prefix for code comments used with grep and gsub.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"prefix"</code></pre>

<hr>
<h2 id='prefixed.lines'>prefixed lines</h2><span id='topic+prefixed.lines'></span>

<h3>Description</h3>

<p>The primary mechanism of inline documentation is via consecutive
groups of lines matching the specified <code><a href="#topic+prefix">prefix</a></code> regular expression
&quot;<code>^### </code>&quot; (i.e. lines beginning with &quot;<code>### </code>&quot;) are
collected as follows into documentation sections:</p>

<dl>
<dt>description</dt><dd><p>group starting at line 2 in the code</p>
</dd>
<dt>arguments</dt><dd><p>group following each function argument</p>
</dd>
<dt>value</dt><dd><p>group ending at the penultimate line of the code</p>
</dd></dl>

<p>These may be added to by use of the <code>##&lt;&lt;</code> constructs
described below.</p>


<h3>Usage</h3>

<pre><code class='language-R'>prefixed.lines(src, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prefixed.lines_+3A_src">src</code></td>
<td>
<p>src </p>
</td></tr>
<tr><td><code id="prefixed.lines_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>


<h3>Examples</h3>

<pre><code class='language-R'>
test &lt;- function
### the description
(x,
### the first argument
 y ##&lt;&lt; another argument
 ){
  5
### the return value
##seealso&lt;&lt; foobar
}
src &lt;- getSource(test)
prefixed.lines(src)
extract.xxx.chunks(src)

</code></pre>

<hr>
<h2 id='print.allfun'>print allfun</h2><span id='topic+print.allfun'></span>

<h3>Description</h3>

<p>Print method for functions constructed using <code><a href="#topic+forall">forall</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'allfun'
print(x, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.allfun_+3A_x">x</code></td>
<td>
<p>x </p>
</td></tr>
<tr><td><code id="print.allfun_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

<hr>
<h2 id='removeAliasesfrom.Rd.file'>removeAliasesfrom Rd file</h2><span id='topic+removeAliasesfrom.Rd.file'></span>

<h3>Description</h3>

<p>remove aliases to methodnames from the Rd file of a class
automatically-generated by package.skeleton.</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeAliasesfrom.Rd.file(N, 
    pkg, code)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeAliasesfrom.Rd.file_+3A_n">N</code></td>
<td>
<p>Name of function/file to which we will add documentation.</p>
</td></tr>
<tr><td><code id="removeAliasesfrom.Rd.file_+3A_pkg">pkg</code></td>
<td>
<p>Package name.</p>
</td></tr>
<tr><td><code id="removeAliasesfrom.Rd.file_+3A_code">code</code></td>
<td>
<p>The <code>code</code> of the package</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

<hr>
<h2 id='replace.one'>replace one</h2><span id='topic+replace.one'></span>

<h3>Description</h3>

<p>Do find and replace for one element of an inner documentation list
on 1 Rd file.</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace.one(torep, REP, 
    txt, verbose = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace.one_+3A_torep">torep</code></td>
<td>
<p>tag to find.</p>
</td></tr>
<tr><td><code id="replace.one_+3A_rep">REP</code></td>
<td>
<p>contents of tag to put inside.</p>
</td></tr>
<tr><td><code id="replace.one_+3A_txt">txt</code></td>
<td>
<p>text in which to search.</p>
</td></tr>
<tr><td><code id="replace.one_+3A_verbose">verbose</code></td>
<td>
<p>cat messages?</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

<hr>
<h2 id='save.test.result'>save test result</h2><span id='topic+save.test.result'></span>

<h3>Description</h3>

<p>For unit tests, this is an easy way of getting a text
representation of the list result of <code><a href="#topic+extract.docs.file">extract.docs.file</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>save.test.result(f)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save.test.result_+3A_f">f</code></td>
<td>
<p>R code file with inlinedocs to process with <code><a href="#topic+extract.docs.file">extract.docs.file</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

<hr>
<h2 id='test.file'>test file</h2><span id='topic+test.file'></span>

<h3>Description</h3>

<p>Check an R code file with inlinedocs to see if the
<code><a href="#topic+extract.docs.file">extract.docs.file</a></code> parser accurately extracts all the code inside!
The code file should contain a variable .result which is the
documentation list that you should get when you apply
<code><a href="#topic+extract.docs.file">extract.docs.file</a></code> to the file. We check for identity of elements
of elements of the list, so the order of elements should not
matter, and thus this should be a good robust unit test.</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.file(f, CRAN.checks = TRUE, 
    verbose = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.file_+3A_f">f</code></td>
<td>
<p>File name of R code file with inlinedocs to parse and check.</p>
</td></tr>
<tr><td><code id="test.file_+3A_cran.checks">CRAN.checks</code></td>
<td>
<p>try to make a package and run CRAN checks?</p>
</td></tr>
<tr><td><code id="test.file_+3A_verbose">verbose</code></td>
<td>
<p>Show output?</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>


<h3>See Also</h3>

<p><code><a href="#topic+save.test.result">save.test.result</a></code></p>

<hr>
<h2 id='test.parsers'>test parsers</h2><span id='topic+test.parsers'></span>

<h3>Description</h3>

<p>List of classic parsers which were default before 2018.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"test.parsers"</code></pre>

<hr>
<h2 id='whole.word'>whole word</h2><span id='topic+whole.word'></span>

<h3>Description</h3>

<p>Regex for a whole word to code/link tags.</p>


<h3>Usage</h3>

<pre><code class='language-R'>whole.word(...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="whole.word_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre], Keith Ponting [aut], Thomas Wutzler [aut], Philippe Grosjean [aut], Markus Müller [aut], R Core Team [ctb, cph]</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
