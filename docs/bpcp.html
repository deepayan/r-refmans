<!DOCTYPE html><html><head><title>Help for package bpcp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bpcp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#betaMeldTest'>
<p>Melded Beta Test</p></a></li>
<li><a href='#bpcp-internal'>
<p>Internal functions</p></a></li>
<li><a href='#bpcp-package'>
<p>Pointwise Confidence Intervals Associated with the Survival Distribution for Right Censored Data</p></a></li>
<li><a href='#bpcp2samp'>
<p>Melded BPCP test</p></a></li>
<li><a href='#bpcp2sampControl'>
<p>Control function for <code>bpcp2samp</code></p></a></li>
<li><a href='#bpcpControl'>
<p>Inputs for adjusting numerical calculations in <code>bpcp</code></p></a></li>
<li><a href='#fixtdiff'>
<p>Two sample test for Difference in Survival at Fixed Time</p></a></li>
<li><a href='#kmci.object'>
<p>Kaplan-Meier (Survival Curve) Confidence Interval Object</p></a></li>
<li><a href='#kmciLR.object'>
<p>Kaplan-Meier (Survival Curve) Confidence Interval LR Tidy Object</p></a></li>
<li><a href='#kmciLRgroup.object'>
<p>Kaplan-Meier (Survival Curve) Confidence Interval LR Group Object</p></a></li>
<li><a href='#kmciLRtidy.object'>
<p>Kaplan-Meier (Survival Curve) Confidence Interval LR Tidy Object</p></a></li>
<li><a href='#kmtestALL'>
<p>Pointwise confidence intervals for survival for right censored data.</p></a></li>
<li><a href='#leuk'>
<p>Acute Leukemia data (treatment only) from Freireich et al (1963).</p></a></li>
<li><a href='#leuk2'>
<p>Acute Leukemia data from Freireich et al (1963).</p></a></li>
<li><a href='#mdiffmedian.test'>
<p>Melded Difference in Medians Test</p></a></li>
<li><a href='#plot.kmciLR'>
<p>Plot and lines methods for <code>kmci</code>, <code>kmciLR</code>, <code>kmciLRtidy</code>, and <code>kmciLRgroup</code> objects.</p></a></li>
<li><a href='#print.kmciLRtidy'>

<p>Print A Short Summary of a kmciLRtidy, kmciLRgroup, or kmciLR Object</p></a></li>
<li><a href='#quantile.kmciLR'>
<p>Quantiles or Medians from <code>kmci</code>, <code>kmciLR</code>, <code>kmciLRtidy</code>, or <code>kmciLRgroup</code> objects.</p></a></li>
<li><a href='#sclerosis'>
<p>Pilot study of treatment of severe systemic sclerosis (Nash, et al, 2007).</p></a></li>
<li><a href='#StCI'><p>Get survival and confidence interval at t from <code>kmci</code>, <code>kmciLR</code>, or <code>survfit</code> object</p></a></li>
<li><a href='#summary.kmciLR'>
<p>Summary method for <code>kmci</code>, <code>kmciLR</code>, <code>kmciLRtidy</code>, or <code>kmciLRgroup</code> object.</p></a></li>
<li><a href='#tidykmciLR'>

<p>Dataframe of <code>kmciLRtidy</code>, <code>kmciLRgroup</code>, or a <code>kmciLR</code> object.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Beta Product Confidence Procedure for Right Censored Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-03-11</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael P. Fay [aut, cre], Allyson Mateja [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael P. Fay &lt;mfay@niaid.nih.gov&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>stats, survival, ggplot2, methods</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculates nonparametric pointwise confidence intervals for the survival distribution for right censored data, and for medians [Fay and Brittain &lt;<a href="https://doi.org/10.1002%2Fsim.6905">doi:10.1002/sim.6905</a>&gt;]. Has two-sample tests for dissimilarity (e.g., difference, ratio or odds ratio) in survival at a fixed time, and differences in medians [Fay, Proschan, and Brittain &lt;<a href="https://doi.org/10.1111%2Fbiom.12231">doi:10.1111/biom.12231</a>&gt;]. Basically, the package gives exact inference methods for one- and two-sample exact inferences for Kaplan-Meier curves (e.g., generalizing Fisher's exact test to allow for right censoring), which are especially important for latter parts of the survival curve, small sample sizes or heavily censored data. Includes mid-p options.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-11 20:40:05 UTC; faym</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-11 23:10:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='betaMeldTest'>
Melded Beta Test
</h2><span id='topic+betaMeldTest'></span>

<h3>Description</h3>

<p>This function gives a two sample melded beta test together with the associated melded confidence intervals. It can be used when the confidence distributions (or upper and lower confidence distributions) for the one sample parameters are beta, and one is interested in either the difference, odds ratio, or ratio of those two one sample parameters. The betaMeldTest is usually called by <code><a href="#topic+bpcp2samp">bpcp2samp</a></code>, and not called directly by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betaMeldTest(betaParms1, betaParms2,
    nullparm = NULL, 
    parmtype = c("difference", "oddsratio", "ratio","cdfratio"), 
    conf.level = 0.95, conf.int = TRUE, 
    alternative = c("two.sided", "less", "greater"), 
    eps = 10^-8, dname = "", estimate1 = NA, estimate2 = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betaMeldTest_+3A_betaparms1">betaParms1</code></td>
<td>

<p>a list of the beta parameters for group 1
</p>
</td></tr>
<tr><td><code id="betaMeldTest_+3A_betaparms2">betaParms2</code></td>
<td>

<p>a list of the beta parameters for group 2
</p>
</td></tr>
<tr><td><code id="betaMeldTest_+3A_nullparm">nullparm</code></td>
<td>

<p>null value of the parameter of interest, default of NULL gives 0 if parmtype='difference' and 1 otherwise
</p>
</td></tr>
<tr><td><code id="betaMeldTest_+3A_parmtype">parmtype</code></td>
<td>

<p>parameter type for comparing the survival function of the two groups, either 'difference' 'ratio' 'oddsratio' or 'cdfratio'
</p>
</td></tr>
<tr><td><code id="betaMeldTest_+3A_conf.level">conf.level</code></td>
<td>

<p>confidence level, e.g., 0.95
</p>
</td></tr>
<tr><td><code id="betaMeldTest_+3A_conf.int">conf.int</code></td>
<td>

<p>logical, calculate confidence interval?
</p>
</td></tr>
<tr><td><code id="betaMeldTest_+3A_alternative">alternative</code></td>
<td>

<p>character, either 'two.sided','less', or 'greater' 
</p>
</td></tr>
<tr><td><code id="betaMeldTest_+3A_eps">eps</code></td>
<td>

<p>small value to make integration tractable
</p>
</td></tr>
<tr><td><code id="betaMeldTest_+3A_dname">dname</code></td>
<td>

<p>name describing data
</p>
</td></tr>
<tr><td><code id="betaMeldTest_+3A_estimate1">estimate1</code></td>
<td>

<p>estimate of mean for beta parameter of group 1 (statistic of htest object)
</p>
</td></tr>
<tr><td><code id="betaMeldTest_+3A_estimate2">estimate2</code></td>
<td>

<p>estimate of mean for beta parameter for group 2 (parameter of htest object)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the upper and lower confidence distributions for both samples are described by beta distributions, then you can create a CD test using this function. For example,
if you have sample 1 is binomial with x (with 0&lt;x&lt;n) out of n positive responses, then the 100(1-alpha) confidence interval is qbeta(alpha/2, x, n-x+1) and 
qbeta(1-alpha/2, x+1, n-x). So the lower confidence distribution is beta with parameters a=x and b=n-x+1, and the upper CD is beta with parameters a=x+1 and b=n-x. 
</p>
<p>See <code><a href="#topic+bpcp2samp">bpcp2samp</a></code> for a full description of the parmtypes.
</p>


<h3>Value</h3>

<p>an object of class 'htest'



</p>


<h3>Examples</h3>

<pre><code class='language-R'>fisher.test(matrix(c(4,5,2,22),2,2),alternative="greater")

betaMeldTest(
    betaParms1=list(alower=2,blower=22+1,aupper=2+1,bupper=22),
    betaParms2=list(alower=4,blower=5+1,aupper=4+1,bupper=5),
    alternative="greater",parmtype="oddsratio",
    estimate1=2/24,estimate2=4/9)

</code></pre>

<hr>
<h2 id='bpcp-internal'>
Internal functions
</h2><span id='topic+abmm'></span><span id='topic+kmgw.calc'></span><span id='topic+kmci.mid'></span><span id='topic+kmci.cons'></span><span id='topic+kmConstrain'></span><span id='topic+kmcilog'></span><span id='topic+kmConstrainBeta.calc'></span><span id='topic+bpcp.mm'></span><span id='topic+bpcp.mc'></span><span id='topic+bpcpMidp.mm'></span><span id='topic+getmarks'></span><span id='topic+getmarks.x'></span><span id='topic+intChar'></span><span id='topic+citoLR'></span><span id='topic+meldMC'></span><span id='topic+betaMeldTestMidp.mc'></span><span id='topic+borkowf.calc'></span><span id='topic+qqbeta'></span><span id='topic+uvab'></span><span id='topic+rejectFromInt'></span>

<h3>Description</h3>

<p>Functions  called by other functions. Not to be directly called by user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abmm(a1,b1,a2,b2)
kmgw.calc(time, status, keepCens = TRUE)
borkowf.calc(x, type = "log", alpha = 0.05)
kmConstrain(tstar, pstar, x, alpha = 0.05)
kmConstrainBeta.calc(tstar, pstar, x, alpha = 0.05)
bpcp.mm(x,alpha=0.05)
bpcp.mc(x,nmc=100,alpha=0.05, testtime=0, DELTA=0, midp=FALSE)
bpcpMidp.mm(x,alpha=0.05, midptol=.Machine$double.eps^0.25)
kmcilog(x, alpha = 0.05)

qqbeta(x, a, b)
rejectFromInt(theta,interval,thetaParm=FALSE)
uvab(u, v)
citoLR(x)

getmarks(time, status)
getmarks.x(x)


intChar(L, R, Lin = rep(FALSE, length(L)), Rin = rep(TRUE, length(L)), digits = NULL)


meldMC(T1,T2, nullparm=NULL, 
    parmtype=c("difference","oddsratio","ratio","cdfratio"),
    conf.level=0.95, 
    alternative=c("two.sided","less","greater"),
    dname="",estimate1=NA, estimate2=NA)

betaMeldTestMidp.mc(betaParms1,
    betaParms2,nullparm=NULL, 
    parmtype=c("difference","oddsratio","ratio","cdfratio"),
    conf.level=0.95, conf.int=TRUE,
    alternative=c("two.sided","less","greater"),
    dname="",
    estimate1=NA, estimate2=NA, nmc=10^6)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bpcp-internal_+3A_a">a</code></td>
<td>
<p> beta shape1 parameter</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_b">b</code></td>
<td>
<p> beta shape2 parameter </p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_a1">a1</code></td>
<td>
<p>first beta shape1 parameter, first of two beta distributions</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_a2">a2</code></td>
<td>
<p>second beta shape1 parameter, second of two beta distributions</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_b1">b1</code></td>
<td>
<p>first beta shape2 parameter, first of two beta distributions</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_b2">b2</code></td>
<td>
<p>second beta shape2 parameter, second of two beta distributions</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_u">u</code></td>
<td>
<p>vector of means of beta distributions</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_v">v</code></td>
<td>
<p>vector of variances of beta distributions</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_time">time</code></td>
<td>
<p>time to event or censoring</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_status">status</code></td>
<td>
<p>vector of event status, 1 for events 0 for censoring</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_keepcens">keepCens</code></td>
<td>
<p>logical, keep times with only censored values?</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_x">x</code></td>
<td>
<p>output from kmgw.calc</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_theta">theta</code></td>
<td>
<p>either the parameter under the null (if thetaParm=TRUE) or an estimate of theta (if thetaParm=FALSE)</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_thetaparm">thetaParm</code></td>
<td>
<p>logical, is theta a parameter?</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_interval">interval</code></td>
<td>
<p>either a confidence interval (if thetaParm=TRUE) or quantiles from a null distribution (if thetaParm=FALSE)</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_alpha">alpha</code></td>
<td>
<p>1-conf.level</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_testtime">testtime</code></td>
<td>
<p>time for test, needed for output for two-sample test</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_midp">midp</code></td>
<td>
<p>logical, do mid-p tests and/or confidence intervals?</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_midptol">midptol</code></td>
<td>
<p>tol value passed to uniroot in function</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_delta">DELTA</code></td>
<td>
<p>same at Delta in bpcp</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_tstar">tstar</code></td>
<td>
<p>time for survival distribution</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_pstar">pstar</code></td>
<td>
<p>null value for survival</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_type">type</code></td>
<td>
<p>character describing method, either 'log' transformation, 'logs' log transformation with shift, 'norm' no transformation, 'norms' no transformation with shift </p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_nmc">nmc</code></td>
<td>
<p>number of Monte Carlo reps</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_l">L</code></td>
<td>
<p>left end of  intervals associated with each surv and ci value</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_r">R</code></td>
<td>
<p>right end of  intervals associated with each surv and ci value</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_lin">Lin</code></td>
<td>
<p>logical vector, include left end in interval?</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_rin">Rin</code></td>
<td>
<p>logical vector, include right end in  interval?</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_digits">digits</code></td>
<td>
<p>how many significant digits to use</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_t1">T1</code></td>
<td>
<p>vector of nmc simulated values for parameter from group 1</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_t2">T2</code></td>
<td>
<p>vector of nmc simulated values for parameter from group 2</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_nullparm">nullparm</code></td>
<td>
<p>null value of the 2 sample parameter, when NULL gives values appropriate for parmtype</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_parmtype">parmtype</code></td>
<td>
<p>type of parameter for the two sample test, for details see <code><a href="#topic+bpcp2samp">bpcp2samp</a></code>  </p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_conf.int">conf.int</code></td>
<td>
<p>logical, calculate confidence interval?</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_alternative">alternative</code></td>
<td>
<p>alternative hypothesis</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_dname">dname</code></td>
<td>
<p>data name for 'htest' class of the result</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_estimate1">estimate1</code></td>
<td>
<p>estimate of parameter from group 1</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_estimate2">estimate2</code></td>
<td>
<p>estimate of parameter from group 2</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_betaparms1">betaParms1</code></td>
<td>
<p>named list of beta parameters from group 1 (usually come from method of moments), names: alower,blower, aupper, bupper</p>
</td></tr>
<tr><td><code id="bpcp-internal_+3A_betaparms2">betaParms2</code></td>
<td>
<p>named list of beta parameters from group 2, names: alower,blower, aupper, bupper</p>
</td></tr>
</table>


<h3>Details</h3>

<p>abmm uses method of moments to find a,b parameters from beta distribution that is product of two other beta RVs.   
</p>
<p>kmgw.calc calculates the Kaplan-Meier and Greenwood variances.
</p>
<p>kmci.mid and kmci.cons calculate confidence intervals using a new method with either mid-p-like intervals or a conservative interval
from input from kmgw.calc.
</p>
<p>borkowf.calc calculates the Borkowf intervals from output from kmgw.calc.
</p>
<p>kmcilog gives normal approximation confidence interval using log transformation.
</p>
<p>bpcp.mm and bpcp.mc are the main calculation functions (.mm for method of moments, .mc for Monte Carlo simulation) 
for bpcp (repeated Beta method). Both output a list with two vectors, upper and lower. bpcpMidp.mm and bpcpMidp.mc are the mid-p versions of these functions. 
</p>
<p>kmConstrain gives constrained K-M estimate, and kmConstrainBeta.calc gives ci and tests using Beta distribution. 
</p>
<p>qqbeta is like qbeta, but allows a=0 (giving a value of 0 when b&gt;0) and b=0 (giving a value of 1 when a&gt;0).
</p>
<p>rejectFromInt inputs theta and an interval and gives a vector with 3 terms, estGTnull=1 if reject and estimate is greater than null value,
estLTnull=1 if reject and estimate is less than null value, two.sided=1 if reject in either direction. 
The thetaParm=TRUE means that theta is the parameter under the null so that interval is a confidence interval,
while thetaParm=FALSE means that theta is an estimate of the parameter and interval are quantiles from the null distribution. 
</p>
<p>uvab takes means and variances of beta distributions and returns shape parameters. 
</p>


<h3>Author(s)</h3>

<p>Michael Fay</p>

<hr>
<h2 id='bpcp-package'>
Pointwise Confidence Intervals Associated with the Survival Distribution for Right Censored Data
</h2><span id='topic+bpcp-package'></span>

<h3>Description</h3>

<p>The package has functions to give several different methods for calculating pointwise confidence intervals for a single survival distribution for right censored data. There is also a two-sample test for dissimilarity (measured by difference, ratio, or odds ratio) between two survival distributions at a fixed point in time. 
</p>
<p>The recommended confidence interval for a single sample is the beta product confidence procedure  (using <code><a href="#topic+bpcp">bpcp</a></code>), and the recommended test for the two-sample test is the melded BPCP test (using <code><a href="#topic+bpcp2samp">bpcp2samp</a></code>).
</p>
<p>Other confidence intervals and two sample tests are included in the package primarily to compare them to the recommended ones. (And justify the recommendations). 
</p>
<p>Also included is a difference in medians test that applies only to non-censored data and is designed to guarantee coverage for all sample sizes (see <code><a href="#topic+mdiffmedian.test">mdiffmedian.test</a></code>). The test makes no assumptions about the distributions, so that, unlike the Hodges-Lehmann method, tied data are allowed and a shift assumption is not needed.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> bpcp</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.4.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-03-11</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL2</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The most important function for the single sample case is the  <code><a href="#topic+bpcp">bpcp</a></code> which gives confidence intervals for the survival distribution for right censored data with nice small sample 
properties. That function creates an <code>kmciLR</code> object which has 6 methods: <code>summary</code> (create a data frame with estimates and confidence intervals), 
<code>plot</code> (plot Kaplan-Meier with confidence intervals), <code>lines</code> (add confidence intervals to a plot),  
<code>StCI</code> (pick out survival and confidence interval at specific times),
<code>median</code> (pick out median and confidence interval on median), and <code>quantile</code> (pick out any quantile and its confidence interval). A mid-p option for <code><a href="#topic+bpcp">bpcp</a></code> is now available. It gives closer to nominal coverage than the standard (midp=FALSE) BPCP. For details see Fay et al (2013) on the standard BPCP and Fay and Brittain (2016) on the mid-p option. 
</p>
<p>For the two-sample test see <code><a href="#topic+bpcp2samp">bpcp2samp</a></code>. This test for equality reduces to Fisher's exact test when there is no censoring. When there is censoring, the test is expected to maintain at least nominal coverage.  For details see Fay et al (2015). 
</p>


<h3>Author(s)</h3>

<p>Michael P. Fay
</p>
<p>Maintainer: Michael P. Fay &lt;mfay@niaid.nih.gov&gt;
</p>


<h3>References</h3>

<p>Fay, MP, Brittain, E, and Proschan, MA. (2013). Pointwise Confidence Intervals for a Survival Distribution with Small Samples or Heavy Censoring.  Biostatistics 14(4): 723-736
doi: 10.1093/biostatistics/kxt016. (copy available at http://www.niaid.nih.gov/about/organization/dcr/brb/staff/Pages/michael.aspx).  
</p>
<p>Fay, MP, Proschan, MA, and Brittain, E (2015). Combining One Sample Confidence Procedures for Inference in the Two Sample Case. Biometrics 71:146-156.
</p>
<p>Fay, MP, and Brittain, E (2016). Finite Sample Pointwise Confidence Intervals for a Survival Distribution with Right-Censored Data. Statistics in Medicine. doi: 10.1002/sim.6905.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bpcp">bpcp</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(leuk)
## since there are ties at time=6
## and the data are truncated to the nearest integer, use Delta=1
bfit&lt;-bpcp(leuk$time,leuk$status,Delta=1)
## plot Kaplan-Meier and 95 pct Beta Product Confidence Intervals 
plot(bfit,xlab="time (weeks)")
## details
summary(bfit)
quantile(bfit)
StCI(bfit,2)
</code></pre>

<hr>
<h2 id='bpcp2samp'>
Melded BPCP test
</h2><span id='topic+bpcp2samp'></span>

<h3>Description</h3>

<p>Tests for dissimilarity between two groups in their survival distributions at a fixed point in time. Can operationalize that dissimilarity as 'difference', 'ratio' or 
'oddsratio'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bpcp2samp(time, status, group, testtime, 
    parmtype = c("difference", "oddsratio", "ratio","cdfratio",
        "one.minus.ratio","one.minus.cdfratio"), 
    nullparm = NULL, 
    alternative = c("two.sided", "less", "greater"), 
    conf.level = 0.95, 
    midp=FALSE,
    changeGroupOrder=FALSE,
    control = bpcp2sampControl())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bpcp2samp_+3A_time">time</code></td>
<td>

<p>time to event for each observation
</p>
</td></tr>
<tr><td><code id="bpcp2samp_+3A_status">status</code></td>
<td>

<p>status of event time, 1 is observed, 0 is right censored
</p>
</td></tr>
<tr><td><code id="bpcp2samp_+3A_group">group</code></td>
<td>

<p>group for test, should have two levels, to change order use as factor and change order of levels
</p>
</td></tr>
<tr><td><code id="bpcp2samp_+3A_testtime">testtime</code></td>
<td>

<p>fixed time when you want to test for a difference
</p>
</td></tr>
<tr><td><code id="bpcp2samp_+3A_parmtype">parmtype</code></td>
<td>

<p>parameter type for comparing the survival function of the two groups, either 'difference' 'ratio' 'oddsratio' 'cdfratio' 'one.minus.ratio' or 'one.minus.cdfratio'
</p>
</td></tr>
<tr><td><code id="bpcp2samp_+3A_nullparm">nullparm</code></td>
<td>

<p>null value of the parameter of interest, default of NULL gives 0 if parmtype='difference' and 1 otherwise
</p>
</td></tr>
<tr><td><code id="bpcp2samp_+3A_alternative">alternative</code></td>
<td>

<p>character, either 'two.sided','less', or 'greater' 
</p>
</td></tr>
<tr><td><code id="bpcp2samp_+3A_conf.level">conf.level</code></td>
<td>

<p>confidence level, e.g., 0.95
</p>
</td></tr>
<tr><td><code id="bpcp2samp_+3A_midp">midp</code></td>
<td>
<p>logical, do mid-p tests and confidence intervals?</p>
</td></tr>
<tr><td><code id="bpcp2samp_+3A_changegrouporder">changeGroupOrder</code></td>
<td>
<p>logical, change the order of the groups?</p>
</td></tr>
<tr><td><code id="bpcp2samp_+3A_control">control</code></td>
<td>

<p>list of control parameters, see <code><a href="#topic+bpcp2sampControl">bpcp2sampControl</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The melded confidence interval method is a very general procedure to create confidence intervals for the two sample tests by combining one sample confidence intervals. If S1 and S2 are the survival value at <code>testtime</code> from sample 1 (first value of <code>group</code>) and sample 2 (second value of <code>group</code>) respectively, then 
we can get confidence intervals on the S2-S1 (<code>parmtype='difference'</code>), S2/S1 (<code>parmtype='ratio'</code>), 
(S2*(1-S1))/(S1*(1-S2)) (<code>parmtype='oddsratio'</code>), (1-S1))/(1-S2)=F1/F2 (<code>parmtype='cdfratio'</code>),  1-S2/S1 (<code>parmtype='one.minus.ratio'</code>), 
or 1-(1-S1))/(1-S2)=1-F1/F2(<code>parmtype='one.minus.cdfratio'</code>). 
</p>
<p>The resulting melded CIs appear to guarantee coverage as long as the one sample confidence intervals from which the melded CIs are derived have guaranteed coverage themselves. So since we use the BPCP for the one sample intervals and they appear to guarantee coverage (see Fay, Brittain, and Proschan, 2013), we expect the melded BPCP intervals to have at least nominal coverage. Note that when there is no censoring the melded CIs derived from the one-sample BPCPs, give matching inferences to Fisher's exact test (i.e., give theoretically identical p-values) when testing the null hypothesis of equality (S1=S2).  For details see Fay, Proschan and Brittain (2015).   
</p>
<p>The original melded CIs focused on combining one sample CIs that that guarantee coverage. We can apply the melding to other CIs as well, such as the mid-p style CIs. The mid-p CIs are not designed to guarantee coverage, but are designed to have close to the nominal coverage 'on average' over all the possible values of the parameters. The usual p-value is derived from Pr[ see observed data or more extreme under null], while the mid p-value version comes from (1/2) Pr[see obs data] + Pr[ see more extreme data]. Mid-p CIs come from inverting the test that uses the mid p-value instead of the usual p-value. 
</p>


<h3>Value</h3>

<p>A list with class &quot;htest&quot; containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>estimate of S1, survival at testtime for group 1</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>estimate of S2, survival at testtime for group 2</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>p-value for the test</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>a confidence interval for the parameter determined by <code>parmtype</code></p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>estimate of parameter determined by <code>parmtype</code></p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the specificed null hypothesized value of the parameter determined by <code>parmtype</code></p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>type of alternative with respect to the null.value, either 'two.sided', 'greater' or 'less'</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string describing the test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string describing the parameter determined by <code>parmtype</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael P. Fay
</p>


<h3>References</h3>

<p>Fay, MP, Brittain, E, and Proschan, MA. (2013). Pointwise Confidence Intervals for a Survival Distribution with Small Samples or Heavy Censoring.  Biostatistics 14(4): 723-736
doi: 10.1093/biostatistics/kxt016. (copy available at http://www.niaid.nih.gov/about/organization/dcr/brb/staff/Pages/michael.aspx).  
</p>
<p>Fay, MP, Proschan, MA, and Brittain, E (2015) Combining One Sample Confidence Procedures for Inferences in the Two Sample Case. Biometrics 71:146-156. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(leuk2)
# test difference of S(20) values
# S(20)=survival function at 20 weeks 
bpcp2samp(leuk2$time,leuk2$status,leuk2$treatment,
   20,parmtype="difference")
# test ratio of S(20) in two treatment groups, 
bpcp2samp(leuk2$time,leuk2$status,leuk2$treatment,
   20,parmtype="ratio")
# change the order of the group variable to get the other ratio 
bpcp2samp(leuk2$time,leuk2$status,leuk2$treatment,20,
   parmtype="ratio",changeGroupOrder=TRUE)
# estimate treatment effect= 1 - F(20,trt)/F(20,plac), 
#   where F(20)=1-S(20) = Pr(T &lt;=20) is the 
#   cumulative distribution function 
# Test whether treatment effect is greater than 30 pct
bpcp2samp(leuk2$time,leuk2$status,leuk2$treatment,20,
    parmtype="one.minus.cdfratio",nullparm=0.30,
    alternative="greater",
    changeGroupOrder=FALSE)
</code></pre>

<hr>
<h2 id='bpcp2sampControl'>
Control function for <code><a href="#topic+bpcp2samp">bpcp2samp</a></code>
</h2><span id='topic+bpcp2sampControl'></span>

<h3>Description</h3>

<p>Call function to change any one of options, and outputs a list with all defaults except argument that you changed. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bpcp2sampControl(Delta = 0, stype = "km", eps = 10^-8,
    nmc=10^6, method="mm.mc", seed=391291)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bpcp2sampControl_+3A_delta">Delta</code></td>
<td>

<p>width of grouped confidence intervals, defaults to 0
</p>
</td></tr>
<tr><td><code id="bpcp2sampControl_+3A_stype">stype</code></td>
<td>

<p>type of survival estimate, either &quot;km&quot; for Kaplan-Meier or &quot;mue&quot; for median unbiased estimator
</p>
</td></tr>
<tr><td><code id="bpcp2sampControl_+3A_eps">eps</code></td>
<td>

<p>small value to make integration tractable
</p>
</td></tr>
<tr><td><code id="bpcp2sampControl_+3A_nmc">nmc</code></td>
<td>
<p>number of Monte Carlo replications</p>
</td></tr>
<tr><td><code id="bpcp2sampControl_+3A_method">method</code></td>
<td>
<p>either 'mm.mc' (method of moments for one sample, meld with Monte Carlo) or 'mc.mc' (Monte Carlo for one sample and melding), see details. </p>
</td></tr>
<tr><td><code id="bpcp2sampControl_+3A_seed">seed</code></td>
<td>
<p>random number seed, if NULL do not set random number seed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We set the seed by default, so that the same data set will always give the same results. If you are doing simulations, this setting of the seed will give problems. So use seed=NULL. 
</p>
<p>For method='mm.mc' this is shorthand for calculate the method of moments for one sample, and meld together the two sampling using Monte Carlo methodss; however, technically, that is only done when midp=TRUE, if midp=FALSE then the melding uses numeric integration. 
</p>


<h3>Value</h3>

<p>A list containing the 6 arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bpcp2samp">bpcp2samp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bpcp2sampControl(Delta=1)
</code></pre>

<hr>
<h2 id='bpcpControl'>
Inputs for adjusting numerical calculations in <code>bpcp</code>
</h2><span id='topic+bpcpControl'></span>

<h3>Description</h3>

<p>Function that returns a list of arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bpcpControl(midpMMTol = .Machine$double.eps^0.25, 
    seed=49911,
    tolerance=.Machine$double.eps^0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bpcpControl_+3A_midpmmtol">midpMMTol</code></td>
<td>

<p>value used for tol argument in <code>uniroot</code> call for calculating the midp method of moments method.
</p>
</td></tr>
<tr><td><code id="bpcpControl_+3A_seed">seed</code></td>
<td>
<p>seed for set.seed() when using Monte Carlo method.
If is.null(seed) then do not set the seed.
</p>
</td></tr>
<tr><td><code id="bpcpControl_+3A_tolerance">tolerance</code></td>
<td>
<p>lowest positive value, such that abs(x-y)&lt;tolerance treats x as equal to y. Used in bpcp for seeing if  difference between times are equal to Delta or not.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>When doing simulations on the Monte Carlo method, set seed=NULL. Then the seed will not be set at each replication. The default is to set the seed to 49911, so two analyses of the same data on the same version of R will give identical results.
</p>


<h3>Value</h3>

<p>A list with components named as the arguments.
</p>

<hr>
<h2 id='fixtdiff'>
Two sample test for Difference in Survival at Fixed Time
</h2><span id='topic+fixtdiff'></span>

<h3>Description</h3>

<p>Asymptotic two sample tests for difference in survival at a fixed time, using normal approximations and transformations.  See Klien, et al (2007) for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixtdiff(time,status,group, testtime, 
    trans=c("identity","cloglog","log"),
    varpooled=TRUE, correct=FALSE, doall=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixtdiff_+3A_time">time</code></td>
<td>

<p>time to event for each observation
</p>
</td></tr>
<tr><td><code id="fixtdiff_+3A_status">status</code></td>
<td>

<p>status of event time, 1 is observed, 0 is right censored
</p>
</td></tr>
<tr><td><code id="fixtdiff_+3A_group">group</code></td>
<td>

<p>group for test, should have two levels, to change order use as factor and change order of levels
</p>
</td></tr>
<tr><td><code id="fixtdiff_+3A_testtime">testtime</code></td>
<td>

<p>fixed time when you want to test for a difference
</p>
</td></tr>
<tr><td><code id="fixtdiff_+3A_trans">trans</code></td>
<td>
<p>type of transformation, one of 'identity', 'cloglog' or 'log'</p>
</td></tr>
<tr><td><code id="fixtdiff_+3A_varpooled">varpooled</code></td>
<td>
<p>logical, pool the variance?</p>
</td></tr>
<tr><td><code id="fixtdiff_+3A_correct">correct</code></td>
<td>
<p>logical, do continuity correction? Continuity correction for when trans='identity' and varpooled (see Warning) </p>
</td></tr>
<tr><td><code id="fixtdiff_+3A_doall">doall</code></td>
<td>
<p>logical, do all transformations and corrections</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides p-values for the two sample tests that the survival distributions are equal at time <code>testtime</code>. The tests are asymptotically normal tests and are described in Klein, et al (2007). These functions are mostly for simulations to evaluate the melded BPCP tests, see <code><a href="#topic+bpcp2samp">bpcp2samp</a></code> and Fay et al (2015).  
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>plo</code></td>
<td>
<p>one-sided p-value, alternative: S1(testtime)&gt;S2(testtime)</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>one-sided p-value, alternative: S1(testtime)&lt;S2(testtime</p>
</td></tr>
<tr><td><code>p2</code></td>
<td>
<p>two-sided p-value, min(1,2*plo,2*phi)</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>Continuity correction derived from the case with no censoriing (see Fleiss et al 3rd edition, pp. 50-55).  May not make sense when there is censoring. Use at own risk. 
</p>


<h3>Author(s)</h3>

<p>Michael P. Fay
</p>


<h3>References</h3>

<p>Fay, MP, Proschan, MA, and Brittain, E (2015) Combining One Sample Confidence Procedures for Inferences in the Two Sample Case. Biometrics 71:146-156. 
</p>
<p>Fleiss, Levin, Paik (2003) Statistical Methods for Rates and Proportions, 3rd edition.
</p>
<p>Klein, Logan, Harhoff, and Andersen (2007). Analyzing survival curves at a fixed point in time. Statistics in Medicine 26(24): 4505-4519.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(leuk2)
# Note that since the Kaplan-Meier survival at time=35 goes to 
# zero for one group, the results for the log and cloglog 
# transformations are undefined
fixtdiff(leuk2$time,leuk2$status,leuk2$treatment,35,doall=TRUE)

</code></pre>

<hr>
<h2 id='kmci.object'>
Kaplan-Meier (Survival Curve) Confidence Interval Object 
</h2><span id='topic+kmci.object'></span><span id='topic+kmci'></span>

<h3>Description</h3>

<p>The <code>kmci</code> class is returned by the functions  <code><a href="#topic+kmciTG">kmciTG</a></code> or <code><a href="#topic+kmciSW">kmciSW</a></code>. The  class 
represents a fitted survival curve with pointwise confidence intervals. 
</p>
<p>Unlike the <code><a href="#topic+kmciLR">kmciLR</a></code> class, which  allows for confidence intervals to change at  any time point, 
the <code>kmci</code> class only has the confidence intervals change at observed failures.
</p>
<p>Objects of this class has methods for the functions <code>summary</code>, <code>plot</code>, <code>lines</code>. 
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmci.object_+3A_time">time</code></td>
<td>

<p>the time points of observed failures (assumed surv and lower and upper steps that these times) 
</p>
</td></tr>
<tr><td><code id="kmci.object_+3A_cens">cens</code></td>
<td>

<p>time points where there is censoring but no observed failure
</p>
</td></tr>
<tr><td><code id="kmci.object_+3A_surv">surv</code></td>
<td>

<p>the estimate of survival at time t+0. 
This is a vector. 
</p>
</td></tr>
<tr><td><code id="kmci.object_+3A_upper">upper</code></td>
<td>

<p>upper confidence limit for the survival curve. 
</p>
</td></tr>
<tr><td><code id="kmci.object_+3A_lower">lower</code></td>
<td>

<p>lower confidence limit for the survival curve. 
</p>
</td></tr>
<tr><td><code id="kmci.object_+3A_conf.level">conf.level</code></td>
<td>

<p>the level of the confidence limits, e.g., 0.95. 
</p>
</td></tr>
</table>


<h3>Structure</h3>

<p>The following components must be included in a legitimate 
<code>kmci</code> 
object. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kmciLR.object">kmciLR.object</a></code>
<code><a href="#topic+plot.kmci">plot.kmci</a></code>,  
<code><a href="#topic+summary.kmci">summary.kmci</a></code>,
<code><a href="#topic+StCI.kmci">StCI.kmci</a></code>,
<code><a href="#topic+median.kmci">median.kmci</a></code>,
<code><a href="#topic+quantile.kmci">quantile.kmci</a></code>.   
</p>

<hr>
<h2 id='kmciLR.object'>
Kaplan-Meier (Survival Curve) Confidence Interval LR Tidy Object 
</h2><span id='topic+kmciLR.object'></span><span id='topic+kmciLR'></span>

<h3>Description</h3>

<p>The <code>kmciLR</code> class allows for confidence intervals to change at  any time point, 
while the <code><a href="#topic+kmci">kmci</a></code> class only has the confidence intervals change at observed failures.
</p>
<p>Objects of this class has methods for the functions <code>summary</code>, <code>plot</code>. 
</p>
<p>formula, data, nmc=0, alpha=.05, Delta=0, stype=&quot;km&quot;, midp=FALSE,
monotonic=NULL, control=bpcpControl()
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmciLR.object_+3A_cens">cens</code></td>
<td>

<p>time points where there is censoring but no observed failure
</p>
</td></tr>
<tr><td><code id="kmciLR.object_+3A_surv">surv</code></td>
<td>

<p>the estimate of survival in the interval described by L and R. This is a vector. 
</p>
</td></tr>
<tr><td><code id="kmciLR.object_+3A_upper">upper</code></td>
<td>

<p>upper confidence limit for the survival curve in the interval described by L and R. 
</p>
</td></tr>
<tr><td><code id="kmciLR.object_+3A_lower">lower</code></td>
<td>

<p>lower confidence limit for the survival curve in the interval described by L and R. 
</p>
</td></tr>
<tr><td><code id="kmciLR.object_+3A_l">L</code></td>
<td>
 
<p>vector of left ends of interval associated with lower and upper
</p>
</td></tr>
<tr><td><code id="kmciLR.object_+3A_lin">Lin</code></td>
<td>
 
<p>vector of logicals, should left end of interval be included?
</p>
</td></tr>
<tr><td><code id="kmciLR.object_+3A_r">R</code></td>
<td>
 
<p>vector of right ends of interval associated with lower and upper
</p>
</td></tr>
<tr><td><code id="kmciLR.object_+3A_rin">Rin</code></td>
<td>
 
<p>vector of logicals, should right end of interval be included?
</p>
</td></tr>
<tr><td><code id="kmciLR.object_+3A_interval">Interval</code></td>
<td>
 
<p>character vector describing intervals
</p>
</td></tr>
<tr><td><code id="kmciLR.object_+3A_stype">stype</code></td>
<td>
 
<p>character vector giving type of survival estimate, either 'km' or 'mue'
</p>
</td></tr>
<tr><td><code id="kmciLR.object_+3A_conf.level">conf.level</code></td>
<td>

<p>the level of the confidence limits, e.g., 0.95. 
</p>
</td></tr>
</table>


<h3>Structure</h3>

<p>The following components must be included in a legitimate 
<code>kmciLR</code> 
object. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.kmciLR">plot.kmciLR</a></code>,  
<code><a href="#topic+summary.kmciLR">summary.kmciLR</a></code>,
<code><a href="#topic+bpcp">bpcp</a></code>.
</p>

<hr>
<h2 id='kmciLRgroup.object'>
Kaplan-Meier (Survival Curve) Confidence Interval LR Group Object 
</h2><span id='topic+kmciLRgroup.object'></span><span id='topic+kmciLRgroup'></span>

<h3>Description</h3>

<p>The <code>kmciLRgroup</code> class is returned by the function <code><a href="#topic+bpcpfit">bpcpfit</a></code> when the plotstyle = &quot;standard&quot;, and
represents a fitted survival curve with pointwise confidence intervals. This object will contain more than one
fitted survival curve with the corresponding pointwise confidence intervals based on a treatment/grouping variable.
</p>
<p>The <code>kmciLRgroup</code> class allows for confidence intervals to change at any time point (similar to the <code><a href="#topic+kmciLR">kmciLR</a></code> class), 
while the <code><a href="#topic+kmci">kmci</a></code> class only has the confidence intervals change at observed failures.
</p>
<p>Objects of this class has methods for the functions <code>summary</code>, <code>plot</code>, <code>print</code>, <code>quantile</code>, and <code>median</code>.
</p>
<p>When printed, objects of this class will display the total number of subjects, total number of events, median survival time, and the confidence limits(for the pre-specified confidence level), by treatment group if applicable.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmciLRgroup.object_+3A_cens">cens</code></td>
<td>

<p>time points where there is censoring but no observed failure
</p>
</td></tr>
<tr><td><code id="kmciLRgroup.object_+3A_surv">surv</code></td>
<td>

<p>the estimate of survival in the interval described by L and R. This is a vector. 
</p>
</td></tr>
<tr><td><code id="kmciLRgroup.object_+3A_upper">upper</code></td>
<td>

<p>upper confidence limit for the survival curve in the interval described by L and R. 
</p>
</td></tr>
<tr><td><code id="kmciLRgroup.object_+3A_lower">lower</code></td>
<td>

<p>lower confidence limit for the survival curve in the interval described by L and R. 
</p>
</td></tr>
<tr><td><code id="kmciLRgroup.object_+3A_l">L</code></td>
<td>
 
<p>vector of left ends of interval associated with lower and upper
</p>
</td></tr>
<tr><td><code id="kmciLRgroup.object_+3A_lin">Lin</code></td>
<td>
 
<p>vector of logicals, should left end of interval be included?
</p>
</td></tr>
<tr><td><code id="kmciLRgroup.object_+3A_r">R</code></td>
<td>
 
<p>vector of right ends of interval associated with lower and upper
</p>
</td></tr>
<tr><td><code id="kmciLRgroup.object_+3A_rin">Rin</code></td>
<td>
 
<p>vector of logicals, should right end of interval be included?
</p>
</td></tr>
<tr><td><code id="kmciLRgroup.object_+3A_interval">Interval</code></td>
<td>
 
<p>character vector describing intervals
</p>
</td></tr>
<tr><td><code id="kmciLRgroup.object_+3A_stype">stype</code></td>
<td>
 
<p>character vector giving type of survival estimate, either 'km' or 'mue'
</p>
</td></tr>
<tr><td><code id="kmciLRgroup.object_+3A_conf.level">conf.level</code></td>
<td>

<p>the level of the confidence limits, e.g., 0.95. 
</p>
</td></tr>
<tr><td><code id="kmciLRgroup.object_+3A_num">num</code></td>
<td>
 
<p>total number of subjects at the start of that survival curve.
</p>
</td></tr>
<tr><td><code id="kmciLRgroup.object_+3A_events">events</code></td>
<td>
 
<p>total number of events (observed failures) for that survival curve. 
</p>
</td></tr>
</table>


<h3>Structure</h3>

<p>A <code>kmciLRgroup</code> object is a list of kmciLR objects (also lists). The length of the kmciLRgroup object corresponds to the number of treatment/grouping variables; each item in the list is a kmciLR object for the given treatment (the name of each item in the list is the name of each group). If no grouping variable is given, the output is a <code>kmciLR</code> object. 
</p>
<p>The following components must be included in each element of a legitimate 
<code>kmciLRgroup</code> 
object. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.kmciLRgroup">plot.kmciLRgroup</a></code>,  
<code><a href="#topic+summary.kmciLRgroup">summary.kmciLRgroup</a></code>,
<code><a href="#topic+print.kmciLRgroup">print.kmciLRgroup</a></code>, 
<code><a href="#topic+quantile.kmciLRgroup">quantile.kmciLRgroup</a></code>,
<code><a href="#topic+median.kmciLRgroup">median.kmciLRgroup</a></code>,
<code><a href="#topic+bpcpfit">bpcpfit</a></code>.
</p>

<hr>
<h2 id='kmciLRtidy.object'>
Kaplan-Meier (Survival Curve) Confidence Interval LR Tidy Object 
</h2><span id='topic+kmciLRtidy.object'></span><span id='topic+kmciLRtidy'></span>

<h3>Description</h3>

<p>The <code>kmciLRtidy</code> class is returned by the function <code><a href="#topic+bpcpfit">bpcpfit</a></code> when the plotstyle = &quot;ggplot&quot;, and
represents a fitted survival curve with pointwise confidence intervals. This object may contain more than one
fitted survival curve with the corresponding pointwise confidence intervals based on a treatment/grouping variable, 
if one is specified in the formula of <code><a href="#topic+bpcpfit">bpcpfit</a></code>.
</p>
<p>The <code>kmciLRtidy</code> class allows for confidence intervals to change at any time point (similar to the <code><a href="#topic+kmciLR">kmciLR</a></code> class), 
while the <code><a href="#topic+kmci">kmci</a></code> class only has the confidence intervals change at observed failures.
</p>
<p>Objects of this class has methods for the functions <code>summary</code>, <code>plot</code>, <code>print</code>, <code>quantile</code>, and <code>median</code>.
</p>
<p>When printed, objects of this class will display the total number of subjects, total number of events, median survival time, and the confidence limits(for the pre-specified confidence level), by treatment group if applicable.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmciLRtidy.object_+3A_cens">cens</code></td>
<td>

<p>time points where there is censoring but no observed failure
</p>
</td></tr>
<tr><td><code id="kmciLRtidy.object_+3A_surv">surv</code></td>
<td>

<p>the estimate of survival in the interval described by L and R. This is a vector. 
</p>
</td></tr>
<tr><td><code id="kmciLRtidy.object_+3A_upper">upper</code></td>
<td>

<p>upper confidence limit for the survival curve in the interval described by L and R. 
</p>
</td></tr>
<tr><td><code id="kmciLRtidy.object_+3A_lower">lower</code></td>
<td>

<p>lower confidence limit for the survival curve in the interval described by L and R. 
</p>
</td></tr>
<tr><td><code id="kmciLRtidy.object_+3A_l">L</code></td>
<td>
 
<p>vector of left ends of interval associated with lower and upper
</p>
</td></tr>
<tr><td><code id="kmciLRtidy.object_+3A_lin">Lin</code></td>
<td>
 
<p>vector of logicals, should left end of interval be included?
</p>
</td></tr>
<tr><td><code id="kmciLRtidy.object_+3A_r">R</code></td>
<td>
 
<p>vector of right ends of interval associated with lower and upper
</p>
</td></tr>
<tr><td><code id="kmciLRtidy.object_+3A_rin">Rin</code></td>
<td>
 
<p>vector of logicals, should right end of interval be included?
</p>
</td></tr>
<tr><td><code id="kmciLRtidy.object_+3A_interval">Interval</code></td>
<td>
 
<p>character vector describing intervals
</p>
</td></tr>
<tr><td><code id="kmciLRtidy.object_+3A_stype">stype</code></td>
<td>
 
<p>character vector giving type of survival estimate, either 'km' or 'mue'
</p>
</td></tr>
<tr><td><code id="kmciLRtidy.object_+3A_conf.level">conf.level</code></td>
<td>

<p>the level of the confidence limits, e.g., 0.95. 
</p>
</td></tr>
<tr><td><code id="kmciLRtidy.object_+3A_num">num</code></td>
<td>
 
<p>total number of subjects at the start of that survival curve.
</p>
</td></tr>
<tr><td><code id="kmciLRtidy.object_+3A_events">events</code></td>
<td>
 
<p>total number of events (observed failures) for that survival curve. 
</p>
</td></tr>
</table>


<h3>Structure</h3>

<p>A <code>kmciLRtidy</code> object is a list of kmciLR objects (also lists). The length of the kmciLRtidy object corresponds to the number of treatment/grouping variables; each item in the list is a kmciLR object for the given treatment (the name of each item in the list is the name of each group). If no grouping variable is given, the output is a list of 1 kmciLR object. 
</p>
<p>The following components must be included in each element of a legitimate 
<code>kmciLRtidy</code> 
object. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.kmciLRtidy">plot.kmciLRtidy</a></code>,  
<code><a href="#topic+summary.kmciLRtidy">summary.kmciLRtidy</a></code>,
<code><a href="#topic+print.kmciLRtidy">print.kmciLRtidy</a></code>, 
<code><a href="#topic+quantile.kmciLRtidy">quantile.kmciLRtidy</a></code>,
<code><a href="#topic+median.kmciLRtidy">median.kmciLRtidy</a></code>,
<code><a href="#topic+bpcpfit">bpcpfit</a></code>.
</p>

<hr>
<h2 id='kmtestALL'>
Pointwise confidence intervals for survival for right censored data.
</h2><span id='topic+kmtestALL'></span><span id='topic+kmciBorkowf'></span><span id='topic+kmtestConstrainBoot'></span><span id='topic+kmtestConstrainBeta'></span><span id='topic+bpcp'></span><span id='topic+kmciSW'></span><span id='topic+kmciTG'></span><span id='topic+kmci1TG'></span><span id='topic+kmtestBoot'></span><span id='topic+bpcpfit'></span><span id='topic+bpcpfit.formula'></span><span id='topic+bpcpfit.default'></span>

<h3>Description</h3>

<p>These functions give several different methods for calculating pointwise confidence intervals for the survival distribution for right censored data. 
The recommended confidence intervals are the beta product ones given by <code>bpcp</code> or  <code>bpcpfit</code>. 
</p>
<p>The other confidence intervals are included primarily to show that the beta product confidence procedure (using <code>bpcp</code>) has better coverage than the best alternatives. 
See details for a description of all the methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bpcp(time,status,nmc=0,alpha=.05,Delta=0,stype="km",midp=FALSE,
    monotonic=NULL, control=bpcpControl())

bpcpfit(time, ...)

## Default S3 method:
bpcpfit(time, status = NULL, group = NULL, formula=NULL, nmc=0, alpha=NULL, 
  conf.level=0.95, Delta=0, stype="km", midp=FALSE,
  monotonic=NULL, control=bpcpControl(), plotstyle = "ggplot", 
  data=NULL, subset=NULL, na.action=NULL, ...)

## S3 method for class 'formula'
bpcpfit(formula, data, subset, na.action, ...)

kmciBorkowf(time, status, type="log", alpha = 0.05)
kmtestBoot(time, status, tstar, pstar, M = 1000, alpha = 0.05)
kmtestConstrainBoot(time, status, tstar, pstar, M = 1000, alpha = 0.05)
kmtestConstrainBeta(time,status,tstar,pstar,alpha=.05)
kmciSW(time, status, alpha = 0.05)
kmciTG(time, status, alpha = 0.05)
kmci1TG(time, status, tstar, alpha = 0.05)

kmtestALL(time,status,t0,S0,cens=NULL,M=1000,NMC=10^5,alpha=0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmtestALL_+3A_time">time</code></td>
<td>

<p>time to event or censoring
</p>
</td></tr>
<tr><td><code id="kmtestALL_+3A_status">status</code></td>
<td>
<p> status vector,
1 is event, 0 is censoring (if NULL assumes all are events)
</p>
</td></tr>
<tr><td><code id="kmtestALL_+3A_group">group</code></td>
<td>
<p>vector of treatments or groups, if applicable</p>
</td></tr>
<tr><td><code id="kmtestALL_+3A_formula">formula</code></td>
<td>

<p>a formula object, which must have a Surv object as the response on the left of the ~ operator and, 
if desired, a grouping/treatment variable on the right. 
For a single survival curve the right hand side should be ~ 1.
</p>
</td></tr>
<tr><td><code id="kmtestALL_+3A_data">data</code></td>
<td>

<p>a data frame in which to interpret the variables named in the formula.
</p>
</td></tr>
<tr><td><code id="kmtestALL_+3A_subset">subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to be used.
</p>
</td></tr>
<tr><td><code id="kmtestALL_+3A_na.action">na.action</code></td>
<td>

<p>a function which indicates what should happen when the data contain NAs.
</p>
</td></tr>
<tr><td><code id="kmtestALL_+3A_alpha">alpha</code></td>
<td>

<p>1- conf.level
</p>
</td></tr>
<tr><td><code id="kmtestALL_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level. To be used in place of alpha starting in version 1.4</p>
</td></tr>
<tr><td><code id="kmtestALL_+3A_nmc">nmc</code></td>
<td>
<p>number of Monte Carlo replications from each beta distribution, nmc=0 means use method of moments for beta parameters instead</p>
</td></tr>
<tr><td><code id="kmtestALL_+3A_nmc">NMC</code></td>
<td>
<p>same as nmc</p>
</td></tr>
<tr><td><code id="kmtestALL_+3A_delta">Delta</code></td>
<td>
<p>width of grouped confidence intervals, defaults to 0 (rarely need to change this, even with ties, see details)</p>
</td></tr>
<tr><td><code id="kmtestALL_+3A_stype">stype</code></td>
<td>
<p>type of survival estimate, either &quot;km&quot; for Kaplan-Meier or &quot;mue&quot; for median unbiased estimator</p>
</td></tr> 
<tr><td><code id="kmtestALL_+3A_midp">midp</code></td>
<td>
<p>logical, calculate the mid-p type of interval?</p>
</td></tr>
<tr><td><code id="kmtestALL_+3A_monotonic">monotonic</code></td>
<td>
<p>logical, force lower and upper confidence limits to be monotonic over time? If NULL: nmc=0 gives TRUE, nmc&gt;0 gives FALSE</p>
</td></tr> 
<tr><td><code id="kmtestALL_+3A_control">control</code></td>
<td>
<p>list with arguments for adjusting numeric calculation. Generally does not need to be changed. See 
<code><a href="#topic+bpcpControl">bpcpControl</a></code>
</p>
</td></tr>
<tr><td><code id="kmtestALL_+3A_plotstyle">plotstyle</code></td>
<td>
<p>which type of plot to use, &quot;ggplot&quot; will produce a kmciLRtidy object that will be plotted with ggplot. &quot;standard&quot; will procude a kmciLRgroup object (if there are groups) which will be plotted with base R. If there are no groups, &quot;standard&quot; will produce a kmciLR object.</p>
</td></tr>
<tr><td><code id="kmtestALL_+3A_tstar">tstar</code></td>
<td>
<p> time to test survival distribution</p>
</td></tr>
<tr><td><code id="kmtestALL_+3A_pstar">pstar</code></td>
<td>
<p>null survival distribution</p>
</td></tr>
<tr><td><code id="kmtestALL_+3A_m">M</code></td>
<td>
<p>number of bootstrap replications</p>
</td></tr>
<tr><td><code id="kmtestALL_+3A_t0">t0</code></td>
<td>
<p>null hypothesis time for survival test </p>
</td></tr>
<tr><td><code id="kmtestALL_+3A_s0">S0</code></td>
<td>
<p>null hypothesis value of survival at t0</p>
</td></tr>
<tr><td><code id="kmtestALL_+3A_cens">cens</code></td>
<td>
<p>vector of censoring times (even those with failures before it), used for Binomial test. If NULL gives NA for binom test</p>
</td></tr>
<tr><td><code id="kmtestALL_+3A_type">type</code></td>
<td>
<p>see details</p>
</td></tr>
<tr><td><code id="kmtestALL_+3A_...">...</code></td>
<td>
<p>Extra parameters to be passed.</p>
</td></tr> 
</table>


<h3>Details</h3>

 
<p>The recommended functions to calculate beta product confidence intervals are either  <code>bpcp</code> or  <code>bpcpfit</code>. 
The function <code>bpcp</code> has the original function arguments, while 
the <code>bpcpfit</code> function  allows formulas similar to those used in the <code>survival</code> package, allowing separate analyses by group, and allowing easier use of <code>ggplot2</code> methods. The numerical output for the <code>bpcpfit</code> function is the same as multiple calls of <code>bpcp</code> for each group level. 
</p>
<p>The standard beta product confidence procedure (i.e., with midp=FALSE) will give pointwise confidence intervals for the survival function, S, with right censored data. This means that for any given t, we get confidence intervals for S(t) with the following properties. When there is no censoring or Progressive Type II censoring the BPCP guarantees central coverage (e.g., the error rate on either side of the 95 percent confidence interval is guaranteed to be less than 2.5 percent). For general independent censoring the BPCP is asymptotically equivalent to standard methods such as the normal approximation with Greenwood variance, and 
hence the BPCP (as with the other confidence intervals given here) has asymptotically accurate coverage of S(t) for any t&gt;0.   
</p>
<p>The <code>bpcpfit</code> function will produce multiple survival curves with the pointwise confidence intervals for right censored data for different treatment/grouping variables. Only a treatment/grouping variable can be specified in this function. No other covariates should be included. Data can be input as either a formula or as a default method. If the plotstyle argument is &quot;ggplot&quot; (the default), then <code>bpcpfit</code> will return a <code><a href="#topic+kmciLRtidy">kmciLRtidy</a></code> object that can be passed into <code>"<a href="#topic+plot.kmciLRtidy">plot</a>"</code>, and it will return a generic ggplot. If there is no group variable, a <code><a href="#topic+kmciLRtidy">kmciLRtidy</a></code> object will still be created. The <code><a href="#topic+kmciLRtidy">kmciLRtidy</a></code> object can also be passed to <code><a href="#topic+tidykmciLR">tidykmciLR</a></code>, which returns a dataframe that can be passed into ggplot for custom plotting. If the plotstyle argument is &quot;standard&quot;, then <code>bpcpfit</code> will return a <code><a href="#topic+kmciLRgroup">kmciLRgroup</a></code> object that can be passed into <code>"<a href="#topic+plot.kmciLRgroup">plot</a>"</code>, which will return a base R plot. If there is no treatment variable, a <code><a href="#topic+kmciLR">kmciLR</a></code> object will be created. 
</p>
<p>There is also a mid-p version of the BPCP. The BPCP is derived from using the known distribution of the failure times, and acting conservatively between the failure times (see Fay, Brittain, and Proschan, 2013 for details). Instead of acting conservatively between the failure times, the midp=TRUE version combines the distributions for the previous failure and the future failure time (see Fay and Brittain, 2016). 
</p>
<p>For description of how <code>bpcp</code> with different values of Delta works, see &quot;Beta Product Confidence Intervals for Discrete Failure Times&quot; vignette (especially Section 2.2). Note especially that confidence intervals exactly at the failure times when Delta=0 are handled differently before Version 1.3.0 than from Version&gt;=1.3.0. For users not interested in details who only want to know the recommended confidence intervals on right censored data when ties are allowed, we recommend the <code> bpcp</code> function version 1.3.0 or greater using the default Delta=0 argument. That recommendation will give pointwise confidence intervals that treats ties similarly to the way that the Kaplan-Meier estimator treats ties, and hence will give confidence intervals that enclose the Kaplan-Meier estimate.
</p>
<p>Now we describe the other methods.
</p>
<p>In general the functions are of three naming types: kmtestXX, kmci1XX and kmciXX, where XX changes for different methods. 
Functions kmtestXX only test whether S(tstar)=pstar and return a vector of 1s for reject and 0s for fail to rejecting either of the one-sided or the two-sided hypotheses. 
Functions kmci1XX only give confidence intervals at  S(tstar), while kmciXX give confidence intervals for all values of t.
The standard methods calculate the confidence intervals at the observed failure times and carry them forward (e.g., kmciTG, kmciSW)
and the results are objects of class kmci. More involved methods allow confidence intervals to change after censored objects (e.g., kmciBorkowf, bpcp)
and the results are objects of class kmciLR.  
</p>
<p>The function kmtestBoot tests S(tstar)=pstar using the nonparametric bootstrap (sampling vectors of (time,status) with replacement) with the percentile method as described in Efron (1981). 
The function kmtestConstrainBoot and kmtestConstrainBeta tests S(tstar)=pstar using the constrained Bootstrap or constrained Beta method described 
in Barber and Jennison (1999). 
</p>
<p>The function kmci1TG does a confidence interval only at tstar, while kmciTG does a confidence interval 
at all the observed event times. The method can be derived as a likelihood ratio test and is described in  Thomas and Grunkemeier (1975). 
It has asymptoticly correct coverage, which is  rigorously proved in 
Murphy (1995). You can also think of the method as the empirical likelihood applied to the survival distribution for 
right censored  data (see Owen, 2001, p. 144-145).
</p>
<p>The function <code>kmciSW</code> calculates confidence intervals using Edgeworth expansions as described in 
Strawderman and Wells (1997). Note, Strawderman, Parzen and Wells (1997) is easier to understand than  Strawderman and Wells (1997). 
</p>
<p>Borkowf (2005) creates confidence intervals for the Kaplan-Meier survival estimate for right censored data. 
He allows the confidence interval to change at censoring times as well as at failure times.  
</p>
<p>Four types of confidence intervals may be selected. The asymptotic normal approximation (type=&quot;norm&quot;), the shifted K-M 
estimate with normal approximation (type=&quot;norms&quot;), the log transformed normal approximation using the delta method (type=&quot;log&quot;), 
and the log transformed normal approximation using the delta method with the shifted K-M  (type=&quot;logs&quot;). 
</p>
<p>The function <code>kmtestALL</code> performs hypothesis tests on all the methods except the unconstrained bootstrap method (unless M=0 then it does not test the constrained bootstrap method either). 
The output is a matrix with three columns with a value of 1 representing either (1) rejection for two-sided test implying the estimate is greater than the null, 
(2) rejection for two-sided test implying the estimate less than the null, or (3) any rejection of the two-sided test. 
Each row represents a different test.
</p>
<p>The <code><a href="#topic+kmci">kmci</a></code>, <code><a href="#topic+kmciLR">kmciLR</a></code>, <code><a href="#topic+kmciLRtidy">kmciLRtidy</a></code>, or <code><a href="#topic+kmciLRgroup">kmciLRgroup</a></code> classes have the following methods:
<code>"<a href="#topic+plot.kmci">plot</a>"</code>,<code>"<a href="#topic+lines.kmci">lines</a>"</code>, <code>"<a href="#topic+summary.kmci">summary</a>"</code>, <code>"<a href="#topic+quantile.kmci">quantile</a>"</code>, and <code>"<a href="#topic+median.kmci">median</a>"</code>. Additionally, you can pull out survival and confidence intervals from these objects at specific times using <code>"<a href="#topic+StCI.kmci">StCI</a>"</code>. </p>


<h3>Value</h3>

<p>The functions return an object of class either <code><a href="#topic+kmci">kmci</a></code>, <code><a href="#topic+kmciLR">kmciLR</a></code>, <code><a href="#topic+kmciLRtidy">kmciLRtidy</a></code> or <code><a href="#topic+kmciLRgroup">kmciLRgroup</a></code> see details). 
</p>
<p>kmci, kmciLR, kmciLRtidy, and kmciLRgroup objects are lists. kmciLRtidy and kmciLRgroup are lists of kmciLR objects, one element for each treatment/group. They contain elements


</p>
<table>
<tr><td><code>surv</code></td>
<td>
<p>survival distribution in interval/at time point</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>lower pointwise confidence limit in interval/at time point</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>upper pointwise confidence limit in interval/at time point</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>time of survival or confidence interval</p>
</td></tr>
</table>
<p>while the kmciLR have intervals represented by the four elements
</p>
<table>
<tr><td><code>L</code></td>
<td>
<p>left endpoint of interval</p>
</td></tr>
<tr><td><code>Lin</code></td>
<td>
<p>logical vector, include left endpoint?</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>right endpoint of interval</p>
</td></tr>
<tr><td><code>Rin</code></td>
<td>
<p>logical vector, include right endpoint?</p>
</td></tr>
</table>
<p>and results from bpcp additionally have an element
</p>
<table>
<tr><td><code>betaParms</code></td>
<td>
<p>list with 4 elements of beta parameters associated with the CIs: alower, blower, aupper, bupper</p>
</td></tr> 
</table>
<p>kmciLR objects contained in the kmciLRgroup and kmciLRgroup have the elements
</p>
<table>
<tr><td><code>num</code></td>
<td>
<p>total number of subjects</p>
</td></tr>
<tr><td><code>events</code></td>
<td>
<p>total number of events (observed failures)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Fay
</p>


<h3>References</h3>

<p>Fay, MP, Brittain, E, and Proschan, MA. (2013). Pointwise Confidence Intervals for a Survival Distribution with Small Samples or Heavy Censoring.  Biostatistics 14 (4): 723-736. (copy available at http://www.niaid.nih.gov/about/organization/dcr/brb/staff/Pages/michael.aspx).  
</p>
<p>Fay, MP, and Brittain, E (2016). Finite Sample Pointwise Confidence Intervals for a Survival Distribution with Right-Censored Data. Statistics in Medicine.35: 2726-2740. 
</p>
<p>Barber and Jennison (1999) Biometrics, 55: 430-436.
</p>
<p>Borkowf (2005) Statistics in Medicine, 24: 827-851.
</p>
<p>Efron (1981) JASA 76:312-319.
</p>
<p>Murphy (1995) JASA 90: 1399-1405.
</p>
<p>Owen (2001) Empirical Likelihood. Chapman and Hall: New York.
</p>
<p>Strawderman and Wells (1997) JASA 92:1356-1374.
</p>
<p>Strawderman, Parzen and Wells (1997) Biometrics 53: 1399-1415.
</p>
<p>Thomas and Grunkemeier (1975) JASA 70: 865-871.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+kmci">kmci</a></code>, <code><a href="#topic+kmciLR">kmciLR</a></code>, <code><a href="#topic+kmciLRtidy">kmciLRtidy</a></code>, or <code><a href="#topic+kmciLRgroup">kmciLRgroup</a></code> objects have methods: <code>"<a href="#topic+plot.kmci">plot</a>"</code>,<code>"<a href="#topic+lines.kmci">lines</a>"</code>, <code>"<a href="#topic+summary.kmci">summary</a>"</code>, <code>"<a href="#topic+quantile.kmci">quantile</a>"</code>, and <code>"<a href="#topic+median.kmci">median</a>"</code>,<code>"<a href="#topic+StCI.kmci">StCI</a>"</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(bpcp)
data(leuk)
data(leuk2)

### Recommended method is bpcp
### since the data are truncated to the nearest integer
### use Delta=1 option
out&lt;-bpcp(leuk$time,leuk$status,Delta=1)
summary(out)
median(out)
plot(out)


### bpcpfit for multiple survival curves
a &lt;- bpcpfit(Surv(time, status)~treatment, data=leuk2)
b &lt;- bpcpfit(Surv(time, status)~1, data=leuk2)
fitBPsurv &lt;- bpcpfit(Surv(time, status)~treatment, data=leuk2)
fitBPsurv

bpcpfit(leuk2$time, leuk2$status, leuk2$treatment)
bpcpfit(leuk2$time, leuk2$status, plotstyle = "standard")

### Borkowf 2005 method
norm&lt;-kmciBorkowf(leuk$time,leuk$status,type="norm")
norms&lt;-kmciBorkowf(leuk$time,leuk$status,type="norms")
## check Table VII of Borkowf
I&lt;-c(1,2,3,5,7,8,9,11,13,15,17,19,21,23,25,27,29,31,33)
round(data.frame(lowerNorm=norm$lower[I],
    upperNorm=norm$upper[I],lowerNormS=norms$lower[I],
    upperNorms=norms$upper[I],row.names=norm$Interval[I]),3)

### Strawderman and Wells (1997) method
swci&lt;-kmciSW(leuk$time,leuk$status)
summary(swci)


### Thomas and Grunkemeier 1975 method
x&lt;-kmciTG(leuk$time,leuk$status)
summary(x)
## compare to Table 1, Sample 2, of Thomas and Grunkemeier (1975)
StCI(x,c(10,20))


</code></pre>

<hr>
<h2 id='leuk'>
Acute Leukemia data (treatment only) from Freireich et al (1963).
</h2><span id='topic+leuk'></span>

<h3>Description</h3>

<p>This is only the 21 patients who received 6-mercaptopurine (6-MP). There
were 21 patients who got placebo (see <code><a href="#topic+leuk2">leuk2</a></code> for complete data). 
</p>
<p>See also Borkowf (2005)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(leuk)</code></pre>


<h3>Format</h3>

<p>A data frame with 21 observations on the following 2 variables.
</p>

<dl>
<dt><code>time</code></dt><dd><p>time in remission (in weeks)</p>
</dd>
<dt><code>status</code></dt><dd><p>event status, 1 is relapse, 0 is censored</p>
</dd>
</dl>



<h3>References</h3>

<p>Borkowf (2005) Statistics in Medicine, 24: 827-851.
</p>
<p>Freireich et al (1963) Blood 21(6):699-716.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+leuk2">leuk2</a></code> for complete data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(leuk)
</code></pre>

<hr>
<h2 id='leuk2'>
Acute Leukemia data from Freireich et al (1963).
</h2><span id='topic+leuk2'></span>

<h3>Description</h3>

<p>In this study there were 21 pairs of subjects, and within each pair one subject received 6-mercaptopurine (6-MP) and one got placebo. The data are right censored. 
</p>
<p>See also Gehan (1965) who used the data ignoring the pairing so that he could illustrate his famous two-sample (non-paired) rank test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(leuk2)</code></pre>


<h3>Format</h3>

<p>A data frame with 42 observations on the following variables.
</p>

<dl>
<dt><code>time</code></dt><dd><p>time in remission (in weeks)</p>
</dd>
<dt><code>status</code></dt><dd><p>event status, 1 is relapse, 0 is censored</p>
</dd>
<dt><code>treatment</code></dt><dd><p>treatment group: either 'placebo' or '6-MP'</p>
</dd>
<dt><code>pair</code></dt><dd><p>pair id number</p>
</dd>
</dl>



<h3>References</h3>

<p>Gehan (1965) Biometrika 52:203-223.
</p>
<p>Freireich et al (1963) Blood 21(6):699-716.
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+leuk">leuk</a></code> is only the treated group
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(leuk2)
</code></pre>

<hr>
<h2 id='mdiffmedian.test'>
Melded Difference in Medians Test
</h2><span id='topic+mdiffmedian.test'></span>

<h3>Description</h3>

<p>Tests for a difference in two medians. No assumptions about the two distributions are needed (may be discrete with ties allowed, no shift assumption is required). Uses the melded confidence interval derived from the one sample confidence intervals associated with the sign test (a version that allows for ties). Derivation of the test does not require large samples, and confidence intervals are intended to guarantee coverage regardless of sample size. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mdiffmedian.test(x1, x2, nulldiff = 0, 
    alternative = c("two.sided", "less", "greater"), 
    conf.level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mdiffmedian.test_+3A_x1">x1</code></td>
<td>

<p>vector of numeric responses from group 1
</p>
</td></tr>
<tr><td><code id="mdiffmedian.test_+3A_x2">x2</code></td>
<td>

<p>vector of numeric responses from group 2
</p>
</td></tr>
<tr><td><code id="mdiffmedian.test_+3A_nulldiff">nulldiff</code></td>
<td>

<p>difference in medians under the null, median(x2)-median(x1)
</p>
</td></tr>
<tr><td><code id="mdiffmedian.test_+3A_alternative">alternative</code></td>
<td>

<p>a character string specifying the alternative hypothesis, must be one of &quot;two.sided&quot; (default), &quot;greater&quot; or &quot;less&quot;. You can specify just the initial letter.
</p>
</td></tr>
<tr><td><code id="mdiffmedian.test_+3A_conf.level">conf.level</code></td>
<td>

<p>confidence level of the interval.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The melded confidence interval method is a general method for combining two one-sample confidence intervals (CIs). In this function, we use the melded CI method on the two one-sample CIs from the sign test that allows for ties. This creates CIs for the difference in medians that requires very few assumptions. In particular, ties are allowed and no shift assumption is needed.  For details see Fay, Proschan and Brittain (2015). 
</p>


<h3>Value</h3>

<p>a list of class 'htest' with elements:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>median of x1</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>median of x2</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>p-value of the test</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>confidence interval for the difference in medians</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>median(x2)-median(x1)</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>null hypothesis value for difference in medians</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>type of alternative hypothesis</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>description of test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>description of input</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function does not allow censoring. Also, there is a price for not needing large samples nor assumptions about the distributions: if you do not have enough data, your confidence intervals may be the entire real line. For example, if you have continuous data with equal sample sizes in both groups, then if you have 6 or fewer observations in each group, then the 95 percent confidence interval on the difference in medians will be (-Inf,Inf).  </p>


<h3>Author(s)</h3>

<p>Michael P. Fay
</p>


<h3>References</h3>

<p>Fay, MP, Proschan, MA, Brittain, E (2015). Combining One-sample confidence procedures for inference in the two-sample case. Biometrics. 71: 146-156.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
trtA&lt;-rpois(20,1.5)
trtB&lt;-rpois(23,5.5)
mdiffmedian.test(trtA,trtB)
</code></pre>

<hr>
<h2 id='plot.kmciLR'>
Plot and lines methods for <code>kmci</code>, <code>kmciLR</code>, <code>kmciLRtidy</code>, and <code>kmciLRgroup</code> objects. 
</h2><span id='topic+plot.kmci'></span><span id='topic+plot.kmciLR'></span><span id='topic+plot.kmciLRtidy'></span><span id='topic+plot.kmciLRgroup'></span><span id='topic+lines.kmci'></span><span id='topic+lines.kmciLR'></span>

<h3>Description</h3>

<p>Plots survival curves and/or confidence intervals. <code>kmciLR</code> objects from the bpcp function will plot using base R plot. 
If a <code>kmciLRtidy</code> object is created using bpcpfit (plotstyle = &quot;ggplot&quot;), the plot will display using ggplot. 
If a <code>kmciLRgroup</code> object is created using bpcpfit (plotstyle = &quot;standard&quot;), the plot will display using base R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'kmci'
plot(x, ...)

## S3 method for class 'kmciLR'
plot(x, XLAB = "time", YLAB = "Survival", YLIM = c(0, 1), 
    ciLTY = 2, ciCOL = gray(0.8), mark.time = NULL, 
    linetype = "both", ...)

## S3 method for class 'kmciLR'
lines(x, lty = c(2, 1), col = c(gray(0.8), gray(0)), 
    linetype = "both", mark.time = NULL, ...)

## S3 method for class 'kmci'
lines(x, ...)

## S3 method for class 'kmciLRtidy'
plot(x, ...)
                          
## S3 method for class 'kmciLRgroup'
plot(x,XLAB="Time",YLAB="Survival",
 YLIM=c(0,1),ciLTY=2,ciCOL=gray(.8), linetype="both", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.kmciLR_+3A_x">x</code></td>
<td>

<p><code>kmci</code>, <code>kmciLR</code>, <code>kmciLRtidy</code>, or <code>kmciLRgroup</code> object (created by functions described in <code><a href="#topic+kmtestALL">kmtestALL</a></code>) 
</p>
</td></tr>
<tr><td><code id="plot.kmciLR_+3A_xlab">XLAB</code></td>
<td>

<p>label for x axis
</p>
</td></tr>
<tr><td><code id="plot.kmciLR_+3A_ylab">YLAB</code></td>
<td>

<p>label for y axis
</p>
</td></tr>
<tr><td><code id="plot.kmciLR_+3A_ylim">YLIM</code></td>
<td>

<p>limits for y axis
</p>
</td></tr>
<tr><td><code id="plot.kmciLR_+3A_cilty">ciLTY</code></td>
<td>

<p>lty (line type) for confidence intervals
</p>
</td></tr>
<tr><td><code id="plot.kmciLR_+3A_cicol">ciCOL</code></td>
<td>

<p>col (color) for confidence intervals
</p>
</td></tr>
<tr><td><code id="plot.kmciLR_+3A_col">col</code></td>
<td>

<p>vector of colors, first element used for ci second for survival curve
</p>
</td></tr>
<tr><td><code id="plot.kmciLR_+3A_lty">lty</code></td>
<td>

<p>vector of line types, first element used for ci second for survival curve
</p>
</td></tr>
<tr><td><code id="plot.kmciLR_+3A_mark.time">mark.time</code></td>
<td>

<p>put hash marks for censored objects (default puts marks of stype=&quot;km&quot; but not if stype=&quot;mue&quot;)
</p>
</td></tr>
<tr><td><code id="plot.kmciLR_+3A_linetype">linetype</code></td>
<td>

<p>character, which lines to draw: either 'both', 'surv' or 'ci'
</p>
</td></tr>
<tr><td><code id="plot.kmciLR_+3A_...">...</code></td>
<td>

<p>Extra parameters to be passed. Any argument in <code>plot.kmciLR</code> can be passed from <code>plot.kmci</code>, similarly for <code>line</code>. 
Other parameters are usually graphical parameters passed to plot and segment calls within function.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(leuk)
## kmciTG creates kmci object
fitTG&lt;-kmciTG(leuk$time,leuk$status)
plot(fitTG)
## bpcp creates kmciLR object 
fitBP&lt;-bpcp(leuk$time,leuk$status)
lines(fitBP,lwd=3,lty=1,col=gray(.5),linetype="ci")
legend(0,.2,legend=c("Kaplan-Meier","Thomas-Grunkemeier 95 pct C
I","Beta Product 95 pct CI"),
    lwd=c(1,1,3),lty=c(1,2,1),col=c(gray(0),gray(.8),gray(.5)))
data(leuk2)
## bpcpfit creates kmciLR object which is plotted with ggplot
fitBPsurv &lt;- bpcpfit(Surv(time, status)~treatment, data=leuk2)
plot(fitBPsurv)
## this works even if no treatment variable is specified
plot(bpcpfit(Surv(time, status)~1, data=leuk2))

## if plotstyle "standard" is specified, a base R plot is produced
a &lt;- bpcpfit(leuk2$time, leuk2$status, leuk2$treatment, plotstyle = "standard")
plot(a)

#can also create a tidy object to customize ggplot further
tidy &lt;- tidykmciLR(fitBPsurv)
ggplot(tidy, aes(x = time, y = surv, ymin = lower, ymax = upper, col = group)) + 
  geom_line(show.legend=FALSE) + geom_ribbon(alpha = .2, aes(fill=group)) + 
  xlab("Time") + ylab("Survival") + 
  ggtitle("K-M curves with bpcp CIs") 
</code></pre>

<hr>
<h2 id='print.kmciLRtidy'>

Print A Short Summary of a kmciLRtidy, kmciLRgroup, or kmciLR Object
</h2><span id='topic+print.kmciLRtidy'></span><span id='topic+print.kmciLRgroup'></span><span id='topic+print.kmciLR'></span>

<h3>Description</h3>


<p>Print number of observations, number of events, and the median survival with confidence limits for the median of a kmciLRtidy, kmciLRgroup, or kmciLR object with pointwise confidence intervals. The confidence limits will match those specified in the bpcp or bpcpfit function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kmciLR'
print(x, ...)
## S3 method for class 'kmciLRtidy'
print(x, ...)
## S3 method for class 'kmciLRgroup'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.kmciLRtidy_+3A_x">x</code></td>
<td>

<p>a kmciLRtidy, kmciLRgroup, or kmciLR obejct
</p>
</td></tr>
<tr><td><code id="print.kmciLRtidy_+3A_...">...</code></td>
<td>

<p>extra arguments
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(bpcp)
data(leuk2)
practice &lt;- bpcpfit(Surv(time, status)~treatment, data=leuk2)
practice

bpcpfit(Surv(time, status)~1, data=leuk2)

bpcpfit(Surv(time, status)~1, data=leuk2, plotstyle = "standard")
bpcpfit(leuk2$time, leuk2$status, leuk2$treatment, plotstyle = "standard")
</code></pre>

<hr>
<h2 id='quantile.kmciLR'>
Quantiles or Medians from <code>kmci</code>, <code>kmciLR</code>, <code>kmciLRtidy</code>, or <code>kmciLRgroup</code> objects.
</h2><span id='topic+quantile.kmciLR'></span><span id='topic+quantile.kmci'></span><span id='topic+quantile.kmciLRtidy'></span><span id='topic+quantile.kmciLRgroup'></span><span id='topic+median.kmciLR'></span><span id='topic+median.kmci'></span><span id='topic+median.kmciLRtidy'></span><span id='topic+median.kmciLRgroup'></span>

<h3>Description</h3>

<p>Get quantiles or median with the associated confidence intervals from a <code>kmci</code>, <code>kmciLR</code>, <code>kmciLRtidy</code>, or <code>kmciLRgroup</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kmciLR'
quantile(x, probs = c(0.25, 0.5, 0.75), ...)
## S3 method for class 'kmci'
quantile(x, probs = c(0.25, 0.5, 0.75), ...)
## S3 method for class 'kmciLRtidy'
quantile(x, probs = c(0.25, 0.5, 0.75), ...)
## S3 method for class 'kmciLRgroup'
quantile(x, probs = c(0.25, 0.5, 0.75), ...)
## S3 method for class 'kmciLR'
median(x, ...)
## S3 method for class 'kmci'
median(x, ...)
## S3 method for class 'kmciLRtidy'
median(x, ...)
## S3 method for class 'kmciLRgroup'
median(x, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.kmciLR_+3A_x">x</code></td>
<td>

<p>a <code>kmci</code>, <code>kmciLR</code>, <code>kmciLRtidy</code>, or <code>kmciLRgroup</code> object
</p>
</td></tr>
<tr><td><code id="quantile.kmciLR_+3A_probs">probs</code></td>
<td>

<p>vector of probability to calculate quantiles 
</p>
</td></tr>
<tr><td><code id="quantile.kmciLR_+3A_...">...</code></td>
<td>

<p>parameters passed
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>kmciLRtidy</code> or <code>kmciLRgroup</code> object will produce a list of matricies. 
</p>
<p>The matrix has same number of rows as probs and 4 columns
</p>
<table>
<tr><td><code>S(q)</code></td>
<td>
<p>probs, survival estimate at quantile</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>quantile</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>lower confidence limit of q</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>upper confidence limit of q</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(leuk)
data(leuk2)
## kmciTG creates kmci object
fitTG&lt;-kmciTG(leuk$time,leuk$status)
quantile(fitTG)
## bpcp creates kmciLR object 
fitBP&lt;-bpcp(leuk$time,leuk$status)
median(fitBP)

## kmciLRtidy and kmciLRgroups from bpcpfit
practice &lt;- bpcpfit(Surv(time, status)~treatment, data=leuk2)
quantile(practice)
median(practice)

quantile(bpcpfit(leuk2$time, leuk2$status, leuk2$treatment, plotstyle = "standard"))
</code></pre>

<hr>
<h2 id='sclerosis'>
Pilot study of treatment of severe systemic sclerosis (Nash, et al, 2007).
</h2><span id='topic+sclerosis'></span>

<h3>Description</h3>

<p>Severe systemic sclerosis  is a serious autoimmune disease affecting multiple organs including the heart, lungs, kidney, and skin.  
Between 1997 and 2005, a cohort of 34 patients was enrolled in a single arm pilot study of high-dose immunosuppressive therapy and autologous hetapoietic cell  transplantation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sclerosis)</code></pre>


<h3>Format</h3>

<p>A data frame with 34 observations on the following 3 variables.
</p>



<dl>
<dt><code>day</code></dt><dd><p>time to death or censoring, in days</p>
</dd>
<dt><code>year</code></dt><dd><p>time to death or censoring, in years (day/365.25)</p>
</dd>
<dt><code>status</code></dt><dd><p>0 is censored, 1 is event</p>
</dd>
</dl>



<h3>References</h3>

<p>Nash, R.A., McSweeney, P.A., Crofford, L.J., Abidi, M., Chen, C.S., Godwin, J.D., Gooley, T.A., Holmberg, L., Henstorf, G., LeMaistre, C.F., others (2007).
&quot;High-dose immunosuppressive therapy and autologous hematopoietic cell transplantation for severe systemic sclerosis: long-term follow-up of the US multicenter pilot study&quot;
Blood 110 (4): 1388-.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sclerosis)
plot(bpcp(sclerosis$year,sclerosis$status))
</code></pre>

<hr>
<h2 id='StCI'>Get survival and confidence interval at t from <code>kmci</code>, <code>kmciLR</code>, or <code>survfit</code> object</h2><span id='topic+StCI'></span><span id='topic+StCI.default'></span><span id='topic+StCI.kmci'></span><span id='topic+StCI.kmciLR'></span>

<h3>Description</h3>

<p>Just picks out the survival function and confidence interval in a different way depending on the type of object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## Default S3 method:
StCI(x,tstar, afterMax = "continue", ...)


## S3 method for class 'kmciLR'
StCI(x,tstar, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StCI_+3A_x">x</code></td>
<td>
<p>a kmci or kmciLR object</p>
</td></tr>
<tr><td><code id="StCI_+3A_tstar">tstar</code></td>
<td>
<p>a vector of times that you want survival and CI values</p>
</td></tr>
<tr><td><code id="StCI_+3A_aftermax">afterMax</code></td>
<td>
<p>character, what to do after tmax (see details)</p>
</td></tr>
<tr><td><code id="StCI_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since the Kaplan-Meier estimator is undefined after the last observation if it is censored and many confidence interval methods are not defined there either, 
we need to explicitly define what to do. (For objects of the <code>kmciLR</code> class, the confidence intervals are defined over the positive real line and the <code>afterMax</code> is ignored.) The <code>afterMax</code> has four options for this: 'continue' (keep surv and ci values the same as the last calculated one), 
'zero' (surv and lower go to zero, upper stays same), 'zeroNoNA'
(surv and lower go to zero, upper stays same unless it is NA, then it takes on the last non-missing upper value), 
'half' (surv goes to half value, lower goes to zero, upper stays same).
</p>


<h3>Value</h3>

<p>The function <code>StCI</code> returns a data frame with the following variables. (It also has an attribute: 'conf.level'). 
</p>
<table>
<tr><td><code>time</code></td>
<td>
<p>this is tstar</p>
</td></tr>
<tr><td><code>survival</code></td>
<td>
<p>survival at tstar</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>lower confidence limit at tstar</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>upper confidence limit at tstar</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Fay
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+kmci">kmci</a></code>, <code><a href="#topic+kmciLR">kmciLR</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(leuk)
## compare to table 1 of Thomas and Grunkmeier (1975)
StCI(kmciTG(leuk$time,leuk$status),c(10,20))
</code></pre>

<hr>
<h2 id='summary.kmciLR'>
Summary method for <code>kmci</code>, <code>kmciLR</code>, <code>kmciLRtidy</code>, or <code>kmciLRgroup</code> object.
</h2><span id='topic+summary.kmciLR'></span><span id='topic+summary.kmci'></span><span id='topic+summary.kmciLRtidy'></span><span id='topic+summary.kmciLRgroup'></span>

<h3>Description</h3>

<p>Creates a data frame with time (for kmci) or time interval (for kmciLR, kmciLRtidy, and kmciLRgroup), survival, lower and upper pointwise confidence intervals. For kmciLRtidy and kmciLRgroup objects, the group (treatment) variable is also included. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kmciLR'
summary(object, ...)
## S3 method for class 'kmci'
summary(object, ...)
## S3 method for class 'kmciLRtidy'
summary(object, ...)
## S3 method for class 'kmciLRgroup'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.kmciLR_+3A_object">object</code></td>
<td>

<p>kmci, kmciLR, kmciLRtidy, or kmciLRgroup object
</p>
</td></tr>
<tr><td><code id="summary.kmciLR_+3A_...">...</code></td>
<td>

<p>extra arguments
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>creates a data frame. See description.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(leuk)
## kmciTG creates kmci object
fitTG&lt;-kmciTG(leuk$time,leuk$status)
summary(fitTG)
## bpcp creates kmciLR object 
fitBP&lt;-bpcp(leuk$time,leuk$status)
summary(fitBP)
data(leuk2)
## bpcpfit creates kmciLRtidy or kmciLRgroup object
fitBPsurv &lt;- bpcpfit(Surv(time, status)~treatment, data=leuk2)
summary(fitBPsurv)
summary(Surv(time, status)~treatment, data=leuk2, plotstyle = "standard")
</code></pre>

<hr>
<h2 id='tidykmciLR'>

Dataframe of <code>kmciLRtidy</code>, <code>kmciLRgroup</code>, or a <code>kmciLR</code> object.
</h2><span id='topic+tidykmciLR'></span>

<h3>Description</h3>


<p>Takes a <code>kmciLRtidy</code>, <code>kmciLRgroup</code>, or a <code>kmciLR</code> object (a list) and converts it into a drameframe, which can further be used in plotting. Every two time points represents a time interval.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidykmciLR(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidykmciLR_+3A_x">x</code></td>
<td>

<p>a kmciLRtidy, kmciLRgroup, or kmciLR object
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>creates a dataframe. See description. 
</p>


<h3>Value</h3>

<p>This function returns a dataframe with the following columns:
</p>
<table>
<tr><td><code>time</code></td>
<td>
<p>Time</p>
</td></tr>
<tr><td><code>surv</code></td>
<td>
<p>Value of survival curve at that time point</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p> Lower bound of the CI for the survival curve</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p> Upper bound of the CI for the survival curve</p>
</td></tr> 
<tr><td><code>group</code></td>
<td>
<p>treatment or grouping variable (if applicable)</p>
</td></tr>
</table>
<p>There are two rows per time point representing the change in either the survival function or confidence bands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(bpcp)
data(leuk2)
practice &lt;- bpcpfit(Surv(time, status)~treatment, data=leuk2)

tidy &lt;- tidykmciLR(practice)
ggplot(tidy, aes(x = time, y = surv, ymin = lower, ymax = upper, col = group)) + 
  geom_line(show.legend=FALSE) + geom_ribbon(alpha = .2, aes(fill=group)) + xlab("Time") + 
  ylab("Survival") + ggtitle("K-M curves with bpcp CIs") 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
