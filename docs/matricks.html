<!DOCTYPE html><html><head><title>Help for package matricks</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {matricks}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#antidiag'><p>Matrix antidiagonals</p></a></li>
<li><a href='#at'><p>Set or get matrix value at index vector</p></a></li>
<li><a href='#binding'><p>Bind vector, single values and matrices</p></a></li>
<li><a href='#is_idx_possible'><p>Is idx possible in given matrix?</p></a></li>
<li><a href='#m'><p>A shortcut to create matrix defining rows</p></a></li>
<li><a href='#matrix_idx'><p>Get available marix indices</p></a></li>
<li><a href='#neighbour_idx'><p>Get all indices in neighbourhood</p></a></li>
<li><a href='#neighbour_idx_matrix'><p>Create matrix of lists, where each one contains list of neighbour field coordinates</p></a></li>
<li><a href='#operators'><p>Binary operations on matrices/vectors</p></a></li>
<li><a href='#plot_matrix'><p>Plot a matrix</p></a></li>
<li><a href='#rboolm'><p>Create matrix of random choosen boolean values</p></a></li>
<li><a href='#repetitions'><p>Repeat columns or rows</p></a></li>
<li><a href='#runif_same_dims'><p>Create matrix of random values with dimensions copied from an existing matrix</p></a></li>
<li><a href='#runifm'><p>Create matrix of random values drawn from uniform distribution</p></a></li>
<li><a href='#seq_matrix'><p>Return a sequence of pairs (value, index vector)</p></a></li>
<li><a href='#set_values'><p>Set multiple values useing one function call</p></a></li>
<li><a href='#v'><p>A shortcut to create a vertical vector</p></a></li>
<li><a href='#with_same_dims'><p>Create new matrix copying dimensions from the existing one</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Useful Tricks for Matrix Manipulation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions, which make matrix creation conciser 
             (such as the core package's function m() for rowwise matrix definition or 
             runifm() for random value matrices).
             Allows to set multiple matrix values at once, by using list of formulae. 
             Provides additional matrix operators and dedicated plotting function.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/krzjoa/matricks/issues">https://github.com/krzjoa/matricks/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/krzjoa/matricks">https://github.com/krzjoa/matricks</a>,
<a href="https://krzjoa.github.io/matricks/">https://krzjoa.github.io/matricks/</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), knitr, rmarkdown, covr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, rlang, ggplot2, reshape2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-12 22:40:10 UTC; krzysztof</td>
</tr>
<tr>
<td>Author:</td>
<td>Krzysztof Joachimiak
    <a href="https://orcid.org/0000-0003-4780-7947"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Krzysztof Joachimiak &lt;joachimiak.krzysztof@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-02-23 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='antidiag'>Matrix antidiagonals</h2><span id='topic+antidiag'></span><span id='topic+antidiag+3C-'></span>

<h3>Description</h3>

<p>Extract or replace the antidiagonal of a matrix,
or construct a antidiagonal matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>antidiag(x = as.numeric(c(1)), nrow = NULL, ncol = NULL)

antidiag(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="antidiag_+3A_x">x</code></td>
<td>
<p>matrix, vector or 1D array, or missing.</p>
</td></tr>
<tr><td><code id="antidiag_+3A_nrow">nrow</code></td>
<td>
<p>number of rows (optional; when x is not a matrix)</p>
</td></tr>
<tr><td><code id="antidiag_+3A_ncol">ncol</code></td>
<td>
<p>number of columns (optional; when x is not a matrix)</p>
</td></tr>
<tr><td><code id="antidiag_+3A_value">value</code></td>
<td>
<p>either a single value or a vector of length equal to that of the current antidiagonal.
Should be of a mode which can be coerced to that of x.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Extracting antidiag
antidiag(diag(3))
# Creating antidiagonal matrix
antidiag(7, 3, 3)
antidiag(1:5, 3, 3)
# Assigning antidiagonal
mat &lt;- matrix(0, 3, 3)
antidiag(mat) &lt;- c(3, 4, 5)
mat
</code></pre>

<hr>
<h2 id='at'>Set or get matrix value at index vector</h2><span id='topic+at'></span><span id='topic+at+3C-'></span>

<h3>Description</h3>

<p>This function allows to access matrix values by passing indices as vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>at(mat, idx)

at(mat, idx) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="at_+3A_mat">mat</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="at_+3A_idx">idx</code></td>
<td>
<p>two-element integer vector</p>
</td></tr>
<tr><td><code id="at_+3A_value">value</code></td>
<td>
<p>a value to be assign at index</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'at' function: value from matrix at index idx
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(0, 3, 3)
idx &lt;- c(1, 2)
# Typically, given matrix and row-column indices as two-element vector, we should do it like this:
mat[idx[1], idx[2]]
mat[idx[1], idx[2]] &lt;- 8
# Using `at`, we can do it simplier!
at(mat, idx)
at(mat, idx) &lt;- 7
mat
at(mat, idx)
</code></pre>

<hr>
<h2 id='binding'>Bind vector, single values and matrices</h2><span id='topic+binding'></span><span id='topic+col_bind'></span><span id='topic+row_bind'></span>

<h3>Description</h3>

<p>This functions works very similar to well-known base
'cbind' or 'rbind'  function. However, there is one big difference
between these functions. If you pass a vector, each value
will be get individually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_bind(...)

row_bind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binding_+3A_...">...</code></td>
<td>
<p>single values, vectors, matrices or data.frames</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix being a product of matrix/vector/values binding
</p>


<h3>Examples</h3>

<pre><code class='language-R'># `col_bind` vs `cbind`
cbind(1,2,3,4,5)
col_bind(1,2,3,4,5)
cbind(1:5)
col_bind(1:5)
cbind(matrix(3, 3, 3), 0.33, 4:7)
col_bind(matrix(3, 3, 3), 0.33, 4:7)
# `row_bind` vs `rbind`
rbind(1,2,3,4,5)
row_bind(1,2,3,4,5)
rbind(1:5)
row_bind(1:5)
rbind(matrix(3, 3, 3), 0.33, 4:7)
row_bind(matrix(3, 3, 3), 0.33, 4:7)
</code></pre>

<hr>
<h2 id='is_idx_possible'>Is idx possible in given matrix?</h2><span id='topic+is_idx_possible'></span>

<h3>Description</h3>

<p>Is idx possible in given matrix?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_idx_possible(mat, idx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_idx_possible_+3A_mat">mat</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="is_idx_possible_+3A_idx">idx</code></td>
<td>
<p>two-element vector</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>is_idx_possible(matrix(0, 3, 3), c(4, 5))
is_idx_possible(matrix(0, 3, 3), c(3, 2))
</code></pre>

<hr>
<h2 id='m'>A shortcut to create matrix defining rows</h2><span id='topic+m'></span>

<h3>Description</h3>

<p>One of the main functionalities of the package.
It is an alternative to standard way we define
matrices in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="m_+3A_...">...</code></td>
<td>
<p>Single values, vectors, matrices
and '|' as special symbol which breaks input on
the rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with defines elements
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Typically, we define matrices like this:
x &lt;- matrix(c(1, 2, 3,
              4, 5, 6,
              7, 8, 9), nrow=3, byrow=TRUE)
x
# However, this way of ceating matices seems to be
# a little bit clunky. Using `matricks`, we can do
# it in more staightforward way dividing our input
# into rows by using special symbol `|`
x &lt;- m(1, 2, 3|
       4, 5, 6|
       7, 8, 9)
x
# Moreover, we can pass to the `m` function
# whole sequences or even matrices.
x &lt;- m(1:5 | 6:10 | 11:15 )
x
# We can combine multiple matrices into one
m(diag(3),     diag(3) * 3|
  diag(3) * 3, diag(3)    )
</code></pre>

<hr>
<h2 id='matrix_idx'>Get available marix indices</h2><span id='topic+matrix_idx'></span>

<h3>Description</h3>

<p>Get available marix indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_idx(mat, n.row = NULL, n.col = NULL, mask = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_idx_+3A_mat">mat</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="matrix_idx_+3A_n.row">n.row</code></td>
<td>
<p>number of rows; default: NULL</p>
</td></tr>
<tr><td><code id="matrix_idx_+3A_n.col">n.col</code></td>
<td>
<p>number of columns; default: NULL</p>
</td></tr>
<tr><td><code id="matrix_idx_+3A_mask">mask</code></td>
<td>
<p>logical matrix; default: NULL</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- TRUE; F &lt;- FALSE
mat &lt;- matrix(0, 3, 3)
mask &lt;- m(T, T, F | T, F, T | F, F, T)
# All poss
matrix_idx(mat)
matrix_idx(mat, mask = mask)
matrix_idx(mask = mask)
</code></pre>

<hr>
<h2 id='neighbour_idx'>Get all indices in neighbourhood</h2><span id='topic+neighbour_idx'></span>

<h3>Description</h3>

<p>Get all indices in neighbourhood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighbour_idx(mat, idx, mask = NULL, diagonal = TRUE,
  include.idx = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neighbour_idx_+3A_mat">mat</code></td>
<td>
<p>matrix or data.frame</p>
</td></tr>
<tr><td><code id="neighbour_idx_+3A_idx">idx</code></td>
<td>
<p>two-element vector</p>
</td></tr>
<tr><td><code id="neighbour_idx_+3A_mask">mask</code></td>
<td>
<p>logical matrix; optional</p>
</td></tr>
<tr><td><code id="neighbour_idx_+3A_diagonal">diagonal</code></td>
<td>
<p>include diagonal neighbours</p>
</td></tr>
<tr><td><code id="neighbour_idx_+3A_include.idx">include.idx</code></td>
<td>
<p>include current index</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(0, 3, 3)
neighbour_idx(mat, c(1, 2))
neighbour_idx(mat, c(1, 2), diagonal = FALSE)
neighbour_idx(mat, c(1, 2), diagonal = FALSE, include.idx = TRUE)
# With mask
mat &lt;- matrix(0, 3, 4)
mask &lt;- m(FALSE, FALSE, TRUE, TRUE |
          FALSE, FALSE, FALSE, FALSE |
          TRUE, TRUE, FALSE, TRUE)
neighbour_idx(mat, c(1, 2), mask = mask)
</code></pre>

<hr>
<h2 id='neighbour_idx_matrix'>Create matrix of lists, where each one contains list of neighbour field coordinates</h2><span id='topic+neighbour_idx_matrix'></span>

<h3>Description</h3>

<p>Create matrix of lists, where each one contains list of neighbour field coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighbour_idx_matrix(mat, mask = NULL, diagonal = TRUE,
  random.select = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neighbour_idx_matrix_+3A_mat">mat</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="neighbour_idx_matrix_+3A_mask">mask</code></td>
<td>
<p>logical matrix. Its dimensions must be identical with dimensions of mat</p>
</td></tr>
<tr><td><code id="neighbour_idx_matrix_+3A_diagonal">diagonal</code></td>
<td>
<p>logical. get diagonal neighbours</p>
</td></tr>
<tr><td><code id="neighbour_idx_matrix_+3A_random.select">random.select</code></td>
<td>
<p>select one random neighbour</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- TRUE; F &lt;- FALSE
mat &lt;- matrix(0, 3, 3)
mask &lt;- m(T, T, F | T, F, T | F, F, T)
nimat &lt;- neighbour_idx_matrix(mat, mask, diagonal = TRUE)
neighbour_idx_matrix(mat, mask, diagonal = TRUE, random.select = 1)
</code></pre>

<hr>
<h2 id='operators'>Binary operations on matrices/vectors</h2><span id='topic+operators'></span><span id='topic++25m+25'></span><span id='topic++25d+25'></span><span id='topic++25-+25'></span><span id='topic++25+2B+25'></span>

<h3>Description</h3>

<p>This operator allows to do elementwise operation of
two algebraic object i.e. matrices/vectors. There is one required condition
to perform such operation: at least one domension values from both objects
must be the same
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a %m% b

a %d% b

a %-% b

a %+% b
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="operators_+3A_a">a</code></td>
<td>
<p>matrix/vector</p>
</td></tr>
<tr><td><code id="operators_+3A_b">b</code></td>
<td>
<p>matrix/vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix/vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Multiply
m(1, 2, 3 | 4, 5, 6 | 7, 8, 9) %m% v(5,4,3)
# Divide
m(1, 2, 3 | 4, 5, 6 | 7, 8, 9) %d% v(5,4,3)
# Add
m(1, 2, 3 | 4, 5, 6 | 7, 8, 9) %+% v(5,4,3)
# Subtract
m(1, 2, 3 | 4, 5, 6 | 7, 8, 9) %-% v(5,4,3)
</code></pre>

<hr>
<h2 id='plot_matrix'>Plot a matrix</h2><span id='topic+plot_matrix'></span><span id='topic+plot.matrix'></span>

<h3>Description</h3>

<p>This function allows us to plot matrices easily
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_matrix(x, ...)

## S3 method for class 'matrix'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_matrix_+3A_x">x</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="plot_matrix_+3A_...">...</code></td>
<td>
<p>for S3 generic API consistency; does nothing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- TRUE; F &lt;- FALSE
x1 &lt;- m(T, T, T, F, T |
        T, T, F, T, T |
        F, T, T, T, F |
        T, T, T, T, T |
        F, F, T, T, T |
        F, T, T, T, F)
plot_matrix(x1)
x2 &lt;- m(T, T, T, F, T |
        T, T, F, T, T )
plot(x2)
x3 &lt;- m(runif(3) | runif(3) | runif(3))
plot(x3)
</code></pre>

<hr>
<h2 id='rboolm'>Create matrix of random choosen boolean values</h2><span id='topic+rboolm'></span>

<h3>Description</h3>

<p>Create matrix of random choosen boolean values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rboolm(nrow, ncol, true.proba = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rboolm_+3A_nrow">nrow</code></td>
<td>
<p>number of rows</p>
</td></tr>
<tr><td><code id="rboolm_+3A_ncol">ncol</code></td>
<td>
<p>numer of columns</p>
</td></tr>
<tr><td><code id="rboolm_+3A_true.proba">true.proba</code></td>
<td>
<p>probability of true values; default: 0.5</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rboolm(3, 3)
rboolm(4, 5, true.proba = 0.3)
</code></pre>

<hr>
<h2 id='repetitions'>Repeat columns or rows</h2><span id='topic+repetitions'></span><span id='topic+crep'></span><span id='topic+rrep'></span>

<h3>Description</h3>

<p>Repeat matrix object respectively to its shape and orientation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crep(x, times)

rrep(x, times)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repetitions_+3A_x">x</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="repetitions_+3A_times">times</code></td>
<td>
<p>number of repetitions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>crep = columnwise repetition
</p>
<p>rrep = rowwise repetition
</p>


<h3>Value</h3>

<p>matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Columnwise repetition
crep(v(1:3), 4)
crep(t(v(1:5)), 4)
# Rowwise repetition
rrep(v(1:3), 4)
rrep(t(v(1:5)), 4)
</code></pre>

<hr>
<h2 id='runif_same_dims'>Create matrix of random values with dimensions copied from an existing matrix</h2><span id='topic+runif_same_dims'></span>

<h3>Description</h3>

<p>Create matrix of random values with dimensions copied from an existing matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runif_same_dims(mat, min = 0, max = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runif_same_dims_+3A_mat">mat</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="runif_same_dims_+3A_min">min</code></td>
<td>
<p>lower limit of the distribution. Must be finite.</p>
</td></tr>
<tr><td><code id="runif_same_dims_+3A_max">max</code></td>
<td>
<p>upper limit of the distribution. Must be finite.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(0, 3, 3)
runif_same_dims(mat)
</code></pre>

<hr>
<h2 id='runifm'>Create matrix of random values drawn from uniform distribution</h2><span id='topic+runifm'></span>

<h3>Description</h3>

<p>Create matrix of random values drawn from uniform distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runifm(nrow, ncol, min = 0, max = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runifm_+3A_nrow">nrow</code></td>
<td>
<p>number of rows</p>
</td></tr>
<tr><td><code id="runifm_+3A_ncol">ncol</code></td>
<td>
<p>numer of columns</p>
</td></tr>
<tr><td><code id="runifm_+3A_min">min</code></td>
<td>
<p>lower limit of the distribution. Must be finite.</p>
</td></tr>
<tr><td><code id="runifm_+3A_max">max</code></td>
<td>
<p>upper limit of the distribution. Must be finite.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>runifm(3, 3)
runifm(4, 5, min = -1, max = 3)
</code></pre>

<hr>
<h2 id='seq_matrix'>Return a sequence of pairs (value, index vector)</h2><span id='topic+seq_matrix'></span>

<h3>Description</h3>

<p>Facilitates iterating over matrix, returning a sequence of pairs,
where the first element is a value at index (x, y) and the second one is the index (x, y)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_matrix(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_matrix_+3A_mat">mat</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of two-element list (single value, two-element vector)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(1:9, 3, 3)
seq_matrix(mat)
</code></pre>

<hr>
<h2 id='set_values'>Set multiple values useing one function call</h2><span id='topic+set_values'></span><span id='topic+sv'></span>

<h3>Description</h3>

<p>This functions allows to set multiple elements of a matrix
instead of using annoying step-by-step assignment by
mat[1,2] &lt;- 2
mat[2,3] &lt;- 0.5
etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_values(mat, ...)

sv(mat, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_values_+3A_mat">mat</code></td>
<td>
<p>a matrix object</p>
</td></tr>
<tr><td><code id="set_values_+3A_...">...</code></td>
<td>
<p>formulae; left hand values should be two-element interger vectors and right-hand: a single-value numeric</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(0, 4, 5)
set_values(mat, c(1,1) ~ 5, c(3, 4) ~ 0.3)
</code></pre>

<hr>
<h2 id='v'>A shortcut to create a vertical vector</h2><span id='topic+v'></span>

<h3>Description</h3>

<p>This function provides convenient shortcut
to create a vertical (column) vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>v(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="v_+3A_...">...</code></td>
<td>
<p>arbitrary number of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with dims n_elements x 1
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Enumerating all the values with commas
v(1, 2, 3)
# Passing whole sequence as an argument
v(1:5)
</code></pre>

<hr>
<h2 id='with_same_dims'>Create new matrix copying dimensions from the existing one</h2><span id='topic+with_same_dims'></span>

<h3>Description</h3>

<p>Create new matrix copying dimensions from the existing one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_same_dims(mat, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_same_dims_+3A_mat">mat</code></td>
<td>
<p>a matrix with desired dimensions</p>
</td></tr>
<tr><td><code id="with_same_dims_+3A_data">data</code></td>
<td>
<p>sigle numeric value or numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(7, 3, 6)
x
with_same_dims(x, 0)
with_same_dims(x, c(1, 2))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
