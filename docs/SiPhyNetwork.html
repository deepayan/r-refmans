<!DOCTYPE html><html><head><title>Help for package SiPhyNetwork</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SiPhyNetwork}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#biconnectedComponents'><p>Biconnected Components</p></a></li>
<li><a href='#deleteTips'><p>Remove tips from a phylogenetic Network</p></a></li>
<li><a href='#getNetworkLevel'><p>Get the level of a Network</p></a></li>
<li><a href='#incompleteSampling'><p>Sample Tips on a Phylogenetic Network</p></a></li>
<li><a href='#isFUstable'><p>Determine whether a phylogeny is FU-stable</p></a></li>
<li><a href='#isNormal'><p>#' Determine whether a phylogeny is Normal</p></a></li>
<li><a href='#isTreeBased'><p>Determine whether a network is tree-based</p></a></li>
<li><a href='#isTreeChild'><p>Determine whether a network is tree-child</p></a></li>
<li><a href='#ltt.network'><p>Lineages thru time on a network</p></a></li>
<li><a href='#make.beta.draw'><p>Function that makes a draw from a beta distribution</p></a></li>
<li><a href='#make.categorical.draw'><p>Function that makes a draw from a categorical distribution</p></a></li>
<li><a href='#make.exp.decay'><p>Make an exponential decay function</p></a></li>
<li><a href='#make.linear.decay'><p>Make a linear decay function</p></a></li>
<li><a href='#make.polynomial.decay'><p>Make a polynomial decay function</p></a></li>
<li><a href='#make.stepwise'><p>Make a stepwise decay function</p></a></li>
<li><a href='#make.trait.model'><p>Model for trait evolution across the phylogeny</p></a></li>
<li><a href='#make.uniform.draw'><p>Function that makes a draw from a uniform distribution</p></a></li>
<li><a href='#network.gsa'><p>Sample under the Generalized Sampling Approach</p></a></li>
<li><a href='#plottable.net'><p>Create a more Plotting-Friendly phylogenetic Network</p></a></li>
<li><a href='#read.net'><p>Read a Network from Parenthetic Format</p></a></li>
<li><a href='#reconstructedNetwork'><p>Remove Extinct Lineages from a Phylogenetic Network</p></a></li>
<li><a href='#sim.bdh.age'><p>Simulate a Phylogenetic Network to a Specified Number of Taxa</p></a></li>
<li><a href='#sim.bdh.taxa.gsa'><p>Simulate a Phylogenetic Network to a Specified Number of Taxa</p></a></li>
<li><a href='#sim.bdh.taxa.ssa'><p>Simulate a Phylogenetic Network to a Specified Number of Taxa</p></a></li>
<li><a href='#write.net'><p>Write a Network in Parenthetic Format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>A Phylogenetic Simulator for Reticulate Evolution</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A simulator for reticulate evolution under a birth-death-hybridization process. Here the birth-death process is extended to consider reticulate Evolution by allowing hybridization events to occur. The general purpose simulator allows the modeling of three different reticulate patterns: lineage generative hybridization, lineage neutral hybridization, and lineage degenerative hybridization. Users can also specify hybridization events to be dependent on a trait value or genetic distance. We also extend some phylogenetic tree utility and plotting functions for networks. We allow two different stopping conditions: simulated to a fixed time or number of taxa. When simulating to a fixed number of taxa, the user can simulate under the Generalized Sampling Approach that properly simulates phylogenies when assuming a uniform prior on the root age. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, markdown</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, ape, Rcpp, rstackdeque, lifecycle</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp,</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-14 19:59:56 UTC; justison</td>
</tr>
<tr>
<td>Author:</td>
<td>Joshua Justison [aut, cre, cph],
  Claudia Solis-Lemus [aut, cph],
  Tracy A. Heath [aut, cph],
  Klaus Schliep [cph] (modified code from ape in 'write.net.R' and
    'read.net.R'. Crediting original copyright holder),
  Emmanuel Paradis [cph] (modified code from ape in 'write.net.R' and
    'read.net.R'. Crediting original copyright holder),
  Daniel Lawson [cph] (modified code from ape in 'write.net.R' and
    'read.net.R'. Crediting original copyright holder)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joshua Justison &lt;justisnojo@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-14 20:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='biconnectedComponents'>Biconnected Components</h2><span id='topic+biconnectedComponents'></span>

<h3>Description</h3>

<p>Find the biconnected components of a phylogeny
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biconnectedComponents(edges, rt, nNode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biconnectedComponents_+3A_edges">edges</code></td>
<td>
<p>The <code>edge</code> matrix of a <code>phylo</code> object.</p>
</td></tr>
<tr><td><code id="biconnectedComponents_+3A_rt">rt</code></td>
<td>
<p>The root node of the phylogeny</p>
</td></tr>
<tr><td><code id="biconnectedComponents_+3A_nnode">nNode</code></td>
<td>
<p>The number of nodes in the tree</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Find the biconnected components of a phylogeny
</p>
<p>biconnected components
</p>


<h3>Value</h3>

<p>A list with containing a vector of nodes for each biconnected component
</p>

<hr>
<h2 id='deleteTips'>Remove tips from a phylogenetic Network</h2><span id='topic+deleteTips'></span>

<h3>Description</h3>

<p>This function removes certain tips from a phylogenetic network, returning the pruned network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deleteTips(net, tips)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deleteTips_+3A_net">net</code></td>
<td>
<p>An object of class 'evonet.'</p>
</td></tr>
<tr><td><code id="deleteTips_+3A_tips">tips</code></td>
<td>
<p>A numeric vector specifying the tip numbers to delete</p>
</td></tr>
</table>


<h3>Value</h3>

<p>net The network tips removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(17) ##Set seed with smallest Quartran Prime
net&lt;-sim.bdh.age(1,1,5,2,1,c(1/3,1/3,1/3),hyb.inher.fxn = make.uniform.draw(),complete=FALSE)[[1]]
net&lt;- deleteTips(net,c(1,6)) ##drop tips 1 and 6


</code></pre>

<hr>
<h2 id='getNetworkLevel'>Get the level of a Network</h2><span id='topic+getNetworkLevel'></span>

<h3>Description</h3>

<p>This function gets the level of the network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNetworkLevel(net)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNetworkLevel_+3A_net">net</code></td>
<td>
<p>A phylogenetic network of class <code>evonet</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric with the level of the network
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net&lt;- read.net(text= "((A:7,((B:2,C:2):3)#H1:2::0.6):3,(D:6,#H1:1::0.4):4);")
getNetworkLevel(net) ##returns 1
</code></pre>

<hr>
<h2 id='incompleteSampling'>Sample Tips on a Phylogenetic Network</h2><span id='topic+incompleteSampling'></span>

<h3>Description</h3>

<p>This function samples tips from a network. Only extant tips are downsampled from the network. Extinct tips, if they are present, will be unchanged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incompleteSampling(net, rho, stochastic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="incompleteSampling_+3A_net">net</code></td>
<td>
<p>An object of class 'evonet.'</p>
</td></tr>
<tr><td><code id="incompleteSampling_+3A_rho">rho</code></td>
<td>
<p>The sampling probability.</p>
</td></tr>
<tr><td><code id="incompleteSampling_+3A_stochastic">stochastic</code></td>
<td>
<p>If stochastic=FALSE then for a network with n tips we sample n*rho tips. If stochastic=TRUE then each tip probability rho of being sampled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>net A network with sampled tips
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(23) ##set seed with the smallest Pillai prime
net&lt;-sim.bdh.age(1,1,3,2,0.125,c(1/3,1/3,1/3),
hyb.inher.fxn = make.uniform.draw(),complete = FALSE)[[1]]
net&lt;-incompleteSampling(net,0.5,stochastic=FALSE) ##randomly sample half of the extant taxa
</code></pre>

<hr>
<h2 id='isFUstable'>Determine whether a phylogeny is FU-stable</h2><span id='topic+isFUstable'></span>

<h3>Description</h3>

<p>This function assesses whether a network is FU-stable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isFUstable(net)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isFUstable_+3A_net">net</code></td>
<td>
<p>A phylogenetic network of class <code>evonet</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical that is <code>TRUE</code> if the network is FU-stable
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net&lt;- read.net(text= "((A:7,((B:2,C:2):3)#H1:2::0.6):3,(D:6,#H1:1::0.4):4);")
isFUstable(net) ##returns TRUE
</code></pre>

<hr>
<h2 id='isNormal'>#' Determine whether a phylogeny is Normal</h2><span id='topic+isNormal'></span>

<h3>Description</h3>

<p>This function assesses whether a network is Normal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isNormal(net)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isNormal_+3A_net">net</code></td>
<td>
<p>A phylogenetic network of class <code>evonet</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical that is <code>TRUE</code> if the network is Normal
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net&lt;- read.net(text= "((A:7,((B:2,C:2):3)#H1:2::0.6):3,(D:6,#H1:1::0.4):4);")
isNormal(net) ##returns TRUE
</code></pre>

<hr>
<h2 id='isTreeBased'>Determine whether a network is tree-based</h2><span id='topic+isTreeBased'></span>

<h3>Description</h3>

<p>This function determines whether a network is tree-based
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isTreeBased(net)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isTreeBased_+3A_net">net</code></td>
<td>
<p>A phylogenetic network of class <code>evonet</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A phylogenetic network is said to be tree-based if it can be constructed with a base tree that has additional linking arcs added. See jetten 2016 Corollary 2.11 for the algorithm used to determine whether the network is tree-based
</p>


<h3>Value</h3>

<p>A logical that is <code>TRUE</code> if the network is tree-based
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net&lt;- read.net(text= "((A:7,((B:2,C:2):3)#H1:2::0.6):3,(D:6,#H1:1::0.4):4);")
isTreeBased(net) ##returns TRUE
</code></pre>

<hr>
<h2 id='isTreeChild'>Determine whether a network is tree-child</h2><span id='topic+isTreeChild'></span>

<h3>Description</h3>

<p>This function determines whether a network is tree-child
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isTreeChild(net)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isTreeChild_+3A_net">net</code></td>
<td>
<p>A phylogenetic network of class <code>evonet</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A phylogenetic network is said to be tree-child if all internal nodes have at least one tree-like or leaf node as children.
</p>


<h3>Value</h3>

<p>A logical that is <code>TRUE</code> if the network is tree-child
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net&lt;- read.net(text= "((A:7,((B:2,C:2):3)#H1:2::0.6):3,(D:6,#H1:1::0.4):4);")
isTreeChild(net) ##returns TRUE
</code></pre>

<hr>
<h2 id='ltt.network'>Lineages thru time on a network</h2><span id='topic+ltt.network'></span>

<h3>Description</h3>

<p>This function Computes the number of lineages thru time on a network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ltt.network(phy, node_times = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ltt.network_+3A_phy">phy</code></td>
<td>
<p>An object of class 'evonet.'</p>
</td></tr>
<tr><td><code id="ltt.network_+3A_node_times">node_times</code></td>
<td>
<p>A numeric vector specifying times of each node. If left NULL then the function will use the output from node.depth.edgelength(phy)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe that consists of intervals. The first column denotes the start time of the interval while the second column denotes the end time. The third column depicts the number of lineages present in that interval.
NOTE: due to computational precision, two nodes that appear to occur on the same time (as in the case of lineage neutral and generative hybridization) may be part of different intervals in the output data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(17) ##smallest Quartan prime as seed
##Generate a tree with extinct leaves
net&lt;-sim.bdh.age(1,1,5,2,1,c(1/3,1/3,1/3),hyb.inher.fxn = make.uniform.draw(),complete=TRUE)[[1]]
ltt.network(net)
</code></pre>

<hr>
<h2 id='make.beta.draw'>Function that makes a draw from a beta distribution</h2><span id='topic+make.beta.draw'></span>

<h3>Description</h3>

<p>Create a function that makes draws from a beta distribution. Function calls <code>rbeta(1,alpha,beta)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.beta.draw(alpha, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.beta.draw_+3A_alpha">alpha</code></td>
<td>
<p>The first shape parameter of the beta distribution</p>
</td></tr>
<tr><td><code id="make.beta.draw_+3A_beta">beta</code></td>
<td>
<p>The second shape parameter of the beta distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that makes draws from a beta distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(17)
inher_func&lt;-make.beta.draw(10,10)
net&lt;-sim.bdh.age(1,1,5,2,1,c(1/3,1/3,1/3),hyb.inher.fxn = inher_func,
complete=TRUE)[[1]]

</code></pre>

<hr>
<h2 id='make.categorical.draw'>Function that makes a draw from a categorical distribution</h2><span id='topic+make.categorical.draw'></span>

<h3>Description</h3>

<p>Create a function that makes draws from a categorical distribution. Function calls <code>sample(x=inheritances,size=1,prob=weights)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.categorical.draw(inheritances, weights)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.categorical.draw_+3A_inheritances">inheritances</code></td>
<td>
<p>A vector of inheritance probabilities</p>
</td></tr>
<tr><td><code id="make.categorical.draw_+3A_weights">weights</code></td>
<td>
<p>A vector of weights for each inheritance probability</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that makes draws from a categorical distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(17)
inher_func&lt;-make.categorical.draw(inheritances=c(0.25,0.50,0.75),weights=c(0.25,0.5,0.25))
net&lt;-sim.bdh.age(1,1,5,2,1,c(1/3,1/3,1/3),hyb.inher.fxn = inher_func,
complete=TRUE)[[1]]
</code></pre>

<hr>
<h2 id='make.exp.decay'>Make an exponential decay function</h2><span id='topic+make.exp.decay'></span>

<h3>Description</h3>

<p>Create an exponential decay function for genetic distance of two taxa and the probability of success of a hybridization event
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.exp.decay(t = 1, s = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.exp.decay_+3A_t">t</code></td>
<td>
<p>A numeric representing how quickly the hybridization success decays. Samaller values denote a quicker decay</p>
</td></tr>
<tr><td><code id="make.exp.decay_+3A_s">s</code></td>
<td>
<p>A numeric for the power that the genetic distance is raised.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes: </p>
<p style="text-align: center;"><code class="reqn">e^{- \frac{d^{s}}{t}}</code>
</p>

<p>where d is the genetic distance between taxa
</p>


<h3>Value</h3>

<p>An exponential decay function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(17)
dist_func&lt;- make.exp.decay(1,1)
net&lt;-sim.bdh.age(1,1,5,2,2,c(1/3,1/3,1/3),hyb.inher.fxn = make.uniform.draw(),
hyb.rate.fxn=dist_func,complete=TRUE)[[1]]
</code></pre>

<hr>
<h2 id='make.linear.decay'>Make a linear decay function</h2><span id='topic+make.linear.decay'></span>

<h3>Description</h3>

<p>Create a linear decay function for genetic distance of two taxa and the probability of success of a hybridization event
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.linear.decay(threshold)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.linear.decay_+3A_threshold">threshold</code></td>
<td>
<p>A numeric representing how quickly the hybridization success decays. Smaller values denote a quicker decay</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes: </p>
<p style="text-align: center;"><code class="reqn">1-\frac{d}{t} </code>
</p>

<p>where d is the genetic distance between taxa
</p>


<h3>Value</h3>

<p>A linear decay function
</p>


<h3>Note</h3>

<p>a distance <code class="reqn">d</code> greater than <code class="reqn">t</code> will return 0
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(17)
dist_func&lt;- make.linear.decay(0.5)
net&lt;-sim.bdh.age(1,1,5,2,2,c(1/3,1/3,1/3),hyb.inher.fxn = make.uniform.draw(),
hyb.rate.fxn=dist_func,complete=TRUE)[[1]]
</code></pre>

<hr>
<h2 id='make.polynomial.decay'>Make a polynomial decay function</h2><span id='topic+make.polynomial.decay'></span>

<h3>Description</h3>

<p>Create a polynomial decay function for genetic distance of two taxa and the probability of success of a hybridization event
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.polynomial.decay(threshold, degree = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.polynomial.decay_+3A_threshold">threshold</code></td>
<td>
<p>A numeric denoting how quickly the polynomial function decays. Distances greater than the threshold will return a success probability of 0.</p>
</td></tr>
<tr><td><code id="make.polynomial.decay_+3A_degree">degree</code></td>
<td>
<p>The degree of the polynomial</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes: </p>
<p style="text-align: center;"><code class="reqn">1- {\frac{d}{t}}^degree</code>
</p>

<p>Where d is the distance and t is the threshold
</p>


<h3>Value</h3>

<p>An polynomial decay function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(17)
dist_func&lt;- make.polynomial.decay(0.5,2)
net&lt;-sim.bdh.age(1,1,5,2,2,c(1/3,1/3,1/3),hyb.inher.fxn = make.uniform.draw(),
hyb.rate.fxn=dist_func,complete=TRUE)[[1]]
</code></pre>

<hr>
<h2 id='make.stepwise'>Make a stepwise decay function</h2><span id='topic+make.stepwise'></span>

<h3>Description</h3>

<p>Create a stepwise decay function for genetic distance of two taxa and the probability of success of a hybridization event
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.stepwise(probs, distances)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.stepwise_+3A_probs">probs</code></td>
<td>
<p>Vector of dimension k, where k is the number of different probabilities of success. An individual time between (distances[i-1],distances[i]] has probability of success prob[i]</p>
</td></tr>
<tr><td><code id="make.stepwise_+3A_distances">distances</code></td>
<td>
<p>Vector of k, containing the end of each interval where success probabilities shift. The first interval where success is prob[1] is [0,distances[1]]. For all i&gt;1, the probability of success is prob[i] over the interval (distance[i-1],distances[i]].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An stepwise decay function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(17)
dist_func&lt;- make.stepwise(probs=c(1,0.5,0),distances=c(0.25,0.5,Inf))
net&lt;-sim.bdh.age(1,1,5,2,2,c(1/3,1/3,1/3),hyb.inher.fxn = make.uniform.draw(),
hyb.rate.fxn=dist_func,complete=TRUE)[[1]]
</code></pre>

<hr>
<h2 id='make.trait.model'>Model for trait evolution across the phylogeny</h2><span id='topic+make.trait.model'></span>

<h3>Description</h3>

<p>Create a model that dictates how a discrete or continuous trait evolves and affects the diversification of the phylogeny. This function creates a list that dictates how the trait affects hybridizations, how the trait is changes over time, and how the trait is inherited across speciation and hybridization events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.trait.model(
  initial_states,
  hyb.event.fxn,
  hyb.compatibility.fxn,
  time.fxn = NULL,
  spec.fxn = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.trait.model_+3A_initial_states">initial_states</code></td>
<td>
<p>the initial state on the phylogeny. if simulating networks with <code>twolineages=TRUE</code> then a vector of length two will be required.</p>
</td></tr>
<tr><td><code id="make.trait.model_+3A_hyb.event.fxn">hyb.event.fxn</code></td>
<td>
<p>A function that describes how the trait changes after hybridization events. See Details for more information</p>
</td></tr>
<tr><td><code id="make.trait.model_+3A_hyb.compatibility.fxn">hyb.compatibility.fxn</code></td>
<td>
<p>A function that describes whether hybridization events can occur between taxa based on their trait values. See Details for more information</p>
</td></tr>
<tr><td><code id="make.trait.model_+3A_time.fxn">time.fxn</code></td>
<td>
<p>A function that describes how trait values changes over time. See Details for more information</p>
</td></tr>
<tr><td><code id="make.trait.model_+3A_spec.fxn">spec.fxn</code></td>
<td>
<p>A function that describes how trait values change at speciation events. See Details for more information</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>hyb.event.fxn</code> is a function that denotes the trait value of a hybrid child after a hybridization event. The function should have the argument <code>parent_states</code>, a vector with the trait states of the two parents to the hybrid child and <code>inheritance</code>. <code>parent_states</code> is vector with the states of the hybrid parents while <code>inheritance</code> is the inheritance probability of the first lineage denoted in <code>parent_states</code>. The function should return a single value for the trait state of the hybrid child.
</p>
<p><code>hyb.compatibility.fxn</code> describes when hybridization events can occur between two taxa based on their trait values. The function should have the arguments <code>parent_states</code>.  The function should return <code>TRUE</code> for when a hybridization event is allowed to proceed and <code>FALSE</code> otherwise.
</p>
<p><code>time.fxn</code> is a function that describes how trait values change over time. The function should have the arguments <code>trait_states</code> and <code>timestep</code> in that order. <code>trait_states</code> is a vector containing the ploidy of all taxa while <code>timestep</code> is the amount of time given for ploidy evolution. The function should return a vector with the updated ploidy states of all taxa.
The default value of <code>NULL</code> indicates that trait values will not evolve within a lineage over time. <strong>NOTE:</strong> Values can still change at speciation or hybridization events if allowed.
</p>
<p><code>spec.fxn</code> is a function that describes how trait values change at speciation events. The function should have the argument <code>tip_state</code> which has the state of the lineage just before speciation. The function should return a vector with two values, one denoting the trait of each of the two new species after the event.
The default value of <code>NULL</code> causes the two children lineage to inherit the same trait value as the parental lineage
</p>


<h3>Value</h3>

<p>A model for trait evolution to be used as the <code>trait.model</code> argument in a 'sim.bdh function&ldquo;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>initial_val&lt;-2 ## The root starts off at 2N

###function for what happens at hybridization event
hyb_e_fxn &lt;- function(parent_states,inheritance){
 ##For allopolyploidy we add the ploidy of both parents
 return(sum(parent_states))
}

##Function for determining whether hybridization occurs
hyb_c_fxn &lt;-function(parent_states,hybrid_state){
 ##Hybridization occurs only when the ploidy is the same
 return(parent_states[1]==parent_states[2])
}


##Function for how the trait changes over time
t_fxn &lt;- function(trait_states,timestep){
 ##We assume that autopolyploidy occur exponentially with rate lambda
 lambda&lt;- 2 ##Rate of autopolyploidy

 ##The number of autopolyploidy events that occur on each lineage over the timestep
 nevents&lt;-rpois(length(trait_states),timestep)

 ##each event doubles the ploidy
 new_states&lt;- trait_states * (2^nevents)
 return(new_states)
}

##Function for how the trait changes at speciation events
s_fxn &lt;-function(tip_state){
 ##Ploidy doesn't change at speciation events.
 ##Both daughter lineages have the same ploidy as the parent
 return(c(tip_state,tip_state))
}

trait_model&lt;-make.trait.model(initial_states = initial_val,
                             hyb.event.fxn = hyb_e_fxn,
                             hyb.compatibility.fxn = hyb_c_fxn,
                             time.fxn = t_fxn,
                             spec.fxn = s_fxn)

</code></pre>

<hr>
<h2 id='make.uniform.draw'>Function that makes a draw from a uniform distribution</h2><span id='topic+make.uniform.draw'></span>

<h3>Description</h3>

<p>Create a function that makes draws from a uniform distribution. Function calls <code>runif(1)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.uniform.draw()
</code></pre>


<h3>Value</h3>

<p>A function that makes draws from a uniform distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(17)
net&lt;-sim.bdh.age(1,1,5,2,1,c(1/3,1/3,1/3),hyb.inher.fxn = make.uniform.draw(),
complete=TRUE)[[1]]
</code></pre>

<hr>
<h2 id='network.gsa'>Sample under the Generalized Sampling Approach</h2><span id='topic+network.gsa'></span>

<h3>Description</h3>

<p>Takes a phylogeny and samples a period where n lineages exist. This method properly samples n taxa under the GSA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network.gsa(net, ntaxa, complete = TRUE, frac = 1, stochsampling = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.gsa_+3A_net">net</code></td>
<td>
<p>A network to sample phylogenies.</p>
</td></tr>
<tr><td><code id="network.gsa_+3A_ntaxa">ntaxa</code></td>
<td>
<p>The number of desired taxa.</p>
</td></tr>
<tr><td><code id="network.gsa_+3A_complete">complete</code></td>
<td>
<p>If complete = TRUE, the tree with the extinct lineages is returned. If complete = FALSE, the extinct lineages are suppressed.</p>
</td></tr>
<tr><td><code id="network.gsa_+3A_frac">frac</code></td>
<td>
<p>Sampling fraction: The proportion of extant tips included in the phylogeny (incomplete sampling).</p>
</td></tr>
<tr><td><code id="network.gsa_+3A_stochsampling">stochsampling</code></td>
<td>
<p>When <code>stochsampling=TRUE</code>: Each extant tip is included into the final tree with probability frac.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A network with n extant taxa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
ssa_net &lt;-sim.bdh.taxa.ssa(n=20,numbsim=1,
lambda=1,mu=0.2,
nu=0.25, hybprops = c(1/3,1/3,1/3),
hyb.inher.fxn = make.beta.draw(1,1),
)[[1]]
gsa_net&lt;-network.gsa(ssa_net,5)


</code></pre>

<hr>
<h2 id='plottable.net'>Create a more Plotting-Friendly phylogenetic Network</h2><span id='topic+plottable.net'></span>

<h3>Description</h3>

<p>This function creates a more plotting-friendly <code>evonet</code> object to be used with the <code>plot()</code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plottable.net(net, tol = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plottable.net_+3A_net">net</code></td>
<td>
<p>An object of class <code>evonet</code>.</p>
</td></tr>
<tr><td><code id="plottable.net_+3A_tol">tol</code></td>
<td>
<p>a tolerance to account for floating point imprecision. any values smaller than <code>tol</code> are considered to be zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a network to be used with the <code>plot()</code> function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' set.seed(17) ##smallest Quartan prime as seed
##Generate a tree with extinct leaves
net&lt;-sim.bdh.age(1,1,5,2,1,c(1/3,1/3,1/3),hyb.inher.fxn = make.uniform.draw(),complete=TRUE)[[1]]
plot(plottable.net(net))
</code></pre>

<hr>
<h2 id='read.net'>Read a Network from Parenthetic Format</h2><span id='topic+read.net'></span>

<h3>Description</h3>

<p>This function reads a network from file using the Rich Newick format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.net(file = "", text = NULL, comment.char = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.net_+3A_file">file</code></td>
<td>
<p>a file name specified by either a variable of mode character, or a double-quoted string; if <code>file = ""</code> (the default) then the tree is input on the keyboard, the entry being terminated with a blank line.</p>
</td></tr>
<tr><td><code id="read.net_+3A_text">text</code></td>
<td>
<p>alternatively, the name of a variable of mode character which contains the tree(s) in parenthetic format. By default, this is ignored (set to <code>NULL</code>, meaning that the tree is read in a file); if text is not <code>NULL</code>, then the argument file is ignored.</p>
</td></tr>
<tr><td><code id="read.net_+3A_comment.char">comment.char</code></td>
<td>
<p>a single character, the remaining of the line after this character is ignored (this is passed directly to <code>scan()</code>).</p>
</td></tr>
<tr><td><code id="read.net_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>scan()</code> and <code>read.tree</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If inheritance probabilities are included in the string, the returned <code>evonet</code> object will include an <code>inheritance</code> element. <code>inheritance[i]</code> corresponds to the inheritance probability of the hybrid edge denoted in <code>reticulation[i,]</code>
</p>
<p>This function also accepts the optional arguments <code>skip</code> and <code>tree.names</code>. <code>tree.names</code> is used  if there are several trees to be read and is a vector of mode character that gives names to the individual trees; if <code>NULL</code> (the default), the trees are named <code>"tree1"</code>, <code>"tree2"</code>, ...
The optional argument <code>skip</code> denotes the number of lines of the input file to skip before beginning to read data (this is passed directly to <code>scan()</code>).
</p>


<h3>Value</h3>

<p>A phylogenetic network of class <code>evonet</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net&lt;-read.net(text="((A:7,((B:2,C:2):3)#H1:2::0.6):3,(D:6,#H1:1::0.4):4);")
</code></pre>

<hr>
<h2 id='reconstructedNetwork'>Remove Extinct Lineages from a Phylogenetic Network</h2><span id='topic+reconstructedNetwork'></span>

<h3>Description</h3>

<p>This function removes all extinct tips from a phylogenetic network, returning the reconstructed network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconstructedNetwork(net)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reconstructedNetwork_+3A_net">net</code></td>
<td>
<p>An object of class 'evonet.'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>net The reconstructed network with all extinct tips removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(17) ##smallest Quartan prime as seed
##Generate a tree with extinct leaves
net&lt;-sim.bdh.age(1,1,5,2,1,c(1/3,1/3,1/3),hyb.inher.fxn = make.uniform.draw(),complete=TRUE)[[1]]
recon_net&lt;-reconstructedNetwork(net)
plot(net)
plot(recon_net)
</code></pre>

<hr>
<h2 id='sim.bdh.age'>Simulate a Phylogenetic Network to a Specified Number of Taxa</h2><span id='topic+sim.bdh.age'></span>

<h3>Description</h3>

<p>Simulates a Phylogenetic Network under a birth-death-hybridization model. Simulates to a specified ages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.bdh.age(
  age,
  numbsim,
  lambda,
  mu,
  nu,
  hybprops,
  hyb.inher.fxn,
  frac = 1,
  twolineages = FALSE,
  complete = TRUE,
  stochsampling = FALSE,
  hyb.rate.fxn = NULL,
  trait.model = NULL,
  mrca = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.bdh.age_+3A_age">age</code></td>
<td>
<p>The time for each simulation.</p>
</td></tr>
<tr><td><code id="sim.bdh.age_+3A_numbsim">numbsim</code></td>
<td>
<p>Number of networks to simulate.</p>
</td></tr>
<tr><td><code id="sim.bdh.age_+3A_lambda">lambda</code></td>
<td>
<p>Speciation rate.</p>
</td></tr>
<tr><td><code id="sim.bdh.age_+3A_mu">mu</code></td>
<td>
<p>Extinction rate.</p>
</td></tr>
<tr><td><code id="sim.bdh.age_+3A_nu">nu</code></td>
<td>
<p>Hybridization rate.</p>
</td></tr>
<tr><td><code id="sim.bdh.age_+3A_hybprops">hybprops</code></td>
<td>
<p>Vector that represents the proportion of Hybridizations that are lineage generative, lineage degenerative, and lineage neutral respectively.</p>
</td></tr>
<tr><td><code id="sim.bdh.age_+3A_hyb.inher.fxn">hyb.inher.fxn</code></td>
<td>
<p>A function for drawing the hybrid inheritance probabilities.</p>
</td></tr>
<tr><td><code id="sim.bdh.age_+3A_frac">frac</code></td>
<td>
<p>Sampling fraction: The proportion of extant tips included in the phylogeny (incomplete sampling).</p>
</td></tr>
<tr><td><code id="sim.bdh.age_+3A_twolineages">twolineages</code></td>
<td>
<p>If <code>twolineages=TRUE</code>: The process originates with two lineages that share a common ancestor. If <code>twolineages=FALSE</code>: The process originates with two lineages.</p>
</td></tr>
<tr><td><code id="sim.bdh.age_+3A_complete">complete</code></td>
<td>
<p>If complete = TRUE, the tree with the extinct lineages is returned. If complete = FALSE, the extinct lineages are suppressed.</p>
</td></tr>
<tr><td><code id="sim.bdh.age_+3A_stochsampling">stochsampling</code></td>
<td>
<p>When <code>stochsampling=TRUE</code>: Each extant tip is included into the final tree with probability frac.</p>
</td></tr>
<tr><td><code id="sim.bdh.age_+3A_hyb.rate.fxn">hyb.rate.fxn</code></td>
<td>
<p>The probability of a successful hybridization as a function of genetic distance between taxa. The default value of 'NULL&ldquo; assumes that hybridization success is independent of genetic distance between taxa.</p>
</td></tr>
<tr><td><code id="sim.bdh.age_+3A_trait.model">trait.model</code></td>
<td>
<p>A list that dictates how a trait affects the hybridization process. The default value of <code>NULL</code> doesn't take a trait into account for simulation. See Details for more information.</p>
</td></tr>
<tr><td><code id="sim.bdh.age_+3A_mrca">mrca</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use the <code>twolineages</code> argument</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>hyb.inher.fxn</code> should return values between 0 and 1 and shouldn't require any arguments. E.g. <a href="#topic+make.beta.draw">make.beta.draw</a> and <a href="#topic+make.uniform.draw">make.uniform.draw</a> create functions that fit these specifications
</p>
<p><code>hyb.rate.fxn</code> should take one argument for the genetic distance. The function should be defined on the range <code class="reqn">[0,Inf)</code> and return values between <code class="reqn">[0,1]</code>
</p>
<p><code>trait.model</code> is a list with the following named elements:
</p>

<ul>
<li><p><code>initial</code> The initial trait state on the phylogeny
</p>
</li>
<li><p><code>hyb.event.fxn</code> A function that denotes the trait of a hybrid child after a hybridization event. The function should have the arguments <code>parent_states</code> and <code>inheritance</code>. <code>parent_states</code> is vector with the ploidy states of the hybrid parents while <code>inheritance</code> is the inheritance probability of the first lineage denoted in <code>parent_states</code>.
</p>
</li>
<li><p><code>hyb.compatibility.fxn</code> A function that describes when hybridization events can occur between two taxa based on their traits. The function should have the argument <code>parent_states</code>, a vector with the trait states of the two parents to the hybrid child. The function should return <code>TRUE</code> for when a hybridization event is allowed to proceed and <code>FALSE</code> otherwise.
</p>
</li>
<li><p><code>time.fxn</code> A function that describes how traits change over time. The function should have the arguments <code>trait_states</code> and <code>timestep</code> in that order. <code>trait_states</code> is a vector containing the ploidy of all taxa while <code>timestep</code> is the amount of time given for trait evolution. The function should return a vector with the updated ploidy states of all taxa.
</p>
</li>
<li><p><code>spec.fxn</code> A function that describes how the trait changes at speciation events.The function should have the argument <code>tip_state</code> which has the state of the lineage just before speciation. The function should return a vector with two values, one denoting the trait of each of the two new species after the event.
</p>
</li></ul>



<h3>Value</h3>

<p>out Returns a list of numbsim networks with the time since origin / most recent common ancestor being 'age.' If tree goes extinct or no tips are sampled, return value is '0'. If only one extant and no extinct tips are sampled, return value is '1'. Each network has an additional attribute &quot;inheritance&quot; that represents the inheritance probabilities on the edges in the &quot;reticulation&quot; attribute.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##smallest Quartan prime as seed for reproducibility
set.seed(17)
#Generate a tree with extinct leaves
net&lt;-sim.bdh.age(1,1,5,2,1,c(1/3,1/3,1/3),hyb.inher.fxn = make.uniform.draw(),complete=TRUE)[[1]]
</code></pre>

<hr>
<h2 id='sim.bdh.taxa.gsa'>Simulate a Phylogenetic Network to a Specified Number of Taxa</h2><span id='topic+sim.bdh.taxa.gsa'></span>

<h3>Description</h3>

<p>Simulates a Phylogenetic Network under a birth-death-hybridization model. Simulates to a specified number of extant tips under the General Sampling Approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.bdh.taxa.gsa(
  m,
  n,
  numbsim,
  lambda,
  mu,
  nu,
  hybprops,
  hyb.inher.fxn,
  frac = 1,
  twolineages = FALSE,
  complete = TRUE,
  stochsampling = FALSE,
  hyb.rate.fxn = NULL,
  trait.model = NULL,
  mrca = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.bdh.taxa.gsa_+3A_m">m</code></td>
<td>
<p>The number of taxa to simulate under the SSA</p>
</td></tr>
<tr><td><code id="sim.bdh.taxa.gsa_+3A_n">n</code></td>
<td>
<p>The number of taxa.</p>
</td></tr>
<tr><td><code id="sim.bdh.taxa.gsa_+3A_numbsim">numbsim</code></td>
<td>
<p>Number of networks to simulate.</p>
</td></tr>
<tr><td><code id="sim.bdh.taxa.gsa_+3A_lambda">lambda</code></td>
<td>
<p>Speciation rate.</p>
</td></tr>
<tr><td><code id="sim.bdh.taxa.gsa_+3A_mu">mu</code></td>
<td>
<p>Extinction rate.</p>
</td></tr>
<tr><td><code id="sim.bdh.taxa.gsa_+3A_nu">nu</code></td>
<td>
<p>Hybridization rate.</p>
</td></tr>
<tr><td><code id="sim.bdh.taxa.gsa_+3A_hybprops">hybprops</code></td>
<td>
<p>Vector that represents the proportion of Hybridizations that are lineage generative, lineage degenerative, and lineage neutral respectively.</p>
</td></tr>
<tr><td><code id="sim.bdh.taxa.gsa_+3A_hyb.inher.fxn">hyb.inher.fxn</code></td>
<td>
<p>A function for drawing the hybrid inheritance probabilities.</p>
</td></tr>
<tr><td><code id="sim.bdh.taxa.gsa_+3A_frac">frac</code></td>
<td>
<p>Sampling fraction: The proportion of extant tips included in the phylogeny (incomplete sampling).</p>
</td></tr>
<tr><td><code id="sim.bdh.taxa.gsa_+3A_twolineages">twolineages</code></td>
<td>
<p>If <code>twolineages=TRUE</code>: The process originates with two lineages that share a common ancestor. If <code>twolineages=FALSE</code>: The process originates with two lineages.</p>
</td></tr>
<tr><td><code id="sim.bdh.taxa.gsa_+3A_complete">complete</code></td>
<td>
<p>If complete = TRUE, the tree with the extinct lineages is returned. If complete = FALSE, the extinct lineages are suppressed.</p>
</td></tr>
<tr><td><code id="sim.bdh.taxa.gsa_+3A_stochsampling">stochsampling</code></td>
<td>
<p>When <code>stochsampling=TRUE</code>: Each extant tip is included into the final tree with probability frac.</p>
</td></tr>
<tr><td><code id="sim.bdh.taxa.gsa_+3A_hyb.rate.fxn">hyb.rate.fxn</code></td>
<td>
<p>The probability of a successful hybridization as a function of genetic distance between taxa. The default value of 'NULL&ldquo; assumes that hybridization success is independent of genetic distance between taxa.</p>
</td></tr>
<tr><td><code id="sim.bdh.taxa.gsa_+3A_trait.model">trait.model</code></td>
<td>
<p>A list that dictates how a trait affects the hybridization process. The default value of <code>NULL</code> doesn't take a trait into account for simulation. See Details for more information.</p>
</td></tr>
<tr><td><code id="sim.bdh.taxa.gsa_+3A_mrca">mrca</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use the <code>twolineages</code> argument</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>hyb.inher.fxn</code> should return values between 0 and 1 and shouldn't require any arguments. E.g. <a href="#topic+make.beta.draw">make.beta.draw</a> and <a href="#topic+make.uniform.draw">make.uniform.draw</a> create functions that fit these specifications
</p>
<p><code>hyb.rate.fxn</code> should take one argument for the genetic distance. The function should be defined on the range <code class="reqn">[0,Inf)</code> and return values between <code class="reqn">[0,1]</code>
</p>
<p><code>trait.model</code> is a list with the following named elements:
</p>

<ul>
<li><p><code>initial</code> The initial trait state on the phylogeny
</p>
</li>
<li><p><code>hyb.event.fxn</code> A function that denotes the trait of a hybrid child after a hybridization event. The function should have the arguments <code>parent_states</code> and <code>inheritance</code>. <code>parent_states</code> is vector with the ploidy states of the hybrid parents while <code>inheritance</code> is the inheritance probability of the first lineage denoted in <code>parent_states</code>.
</p>
</li>
<li><p><code>hyb.compatibility.fxn</code> A function that describes when hybridization events can occur between two taxa based on their traits. The function should have the argument <code>parent_states</code>, a vector with the trait states of the two parents to the hybrid child. The function should return <code>TRUE</code> for when a hybridization event is allowed to proceed and <code>FALSE</code> otherwise.
</p>
</li>
<li><p><code>time.fxn</code> A function that describes how traits change over time. The function should have the arguments <code>trait_states</code> and <code>timestep</code> in that order. <code>trait_states</code> is a vector containing the ploidy of all taxa while <code>timestep</code> is the amount of time given for trait evolution. The function should return a vector with the updated ploidy states of all taxa.
</p>
</li>
<li><p><code>spec.fxn</code> A function that describes how the trait changes at speciation events.The function should have the argument <code>tip_state</code> which has the state of the lineage just before speciation. The function should return a vector with two values, one denoting the trait of each of the two new species after the event.
</p>
</li></ul>



<h3>Value</h3>

<p>out Returns a list of numbsim networks with the time since origin / most recent common ancestor being 'age.' If tree goes extinct or no tips are sampled, return value is '0'. If only one extant and no extinct tips are sampled, return value is '1'. Each network has an additional attribute &quot;inheritance&quot; that represents the inheritance probabilities on the edges in the &quot;reticulation&quot; attribute.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##smallest Quartan prime as seed for reproducibility
set.seed(17)
##Generate a tree with extinct leaves
net&lt;-sim.bdh.taxa.gsa(m=21,n=5,1,3,2,0.5,c(1/3,1/3,1/3),
hyb.inher.fxn = make.uniform.draw(),complete=TRUE)[[1]]
</code></pre>

<hr>
<h2 id='sim.bdh.taxa.ssa'>Simulate a Phylogenetic Network to a Specified Number of Taxa</h2><span id='topic+sim.bdh.taxa.ssa'></span>

<h3>Description</h3>

<p>Simulates a Phylogenetic Network under a birth-death-hybridization model. Simulates to a specified number of extant tips under the Simple Sampling Approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.bdh.taxa.ssa(
  n,
  numbsim,
  lambda,
  mu,
  nu,
  hybprops,
  hyb.inher.fxn,
  frac = 1,
  twolineages = FALSE,
  complete = TRUE,
  stochsampling = FALSE,
  hyb.rate.fxn = NULL,
  trait.model = NULL,
  mrca = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.bdh.taxa.ssa_+3A_n">n</code></td>
<td>
<p>The number of taxa.</p>
</td></tr>
<tr><td><code id="sim.bdh.taxa.ssa_+3A_numbsim">numbsim</code></td>
<td>
<p>Number of networks to simulate.</p>
</td></tr>
<tr><td><code id="sim.bdh.taxa.ssa_+3A_lambda">lambda</code></td>
<td>
<p>Speciation rate.</p>
</td></tr>
<tr><td><code id="sim.bdh.taxa.ssa_+3A_mu">mu</code></td>
<td>
<p>Extinction rate.</p>
</td></tr>
<tr><td><code id="sim.bdh.taxa.ssa_+3A_nu">nu</code></td>
<td>
<p>Hybridization rate.</p>
</td></tr>
<tr><td><code id="sim.bdh.taxa.ssa_+3A_hybprops">hybprops</code></td>
<td>
<p>Vector that represents the proportion of Hybridizations that are lineage generative, lineage degenerative, and lineage neutral respectively.</p>
</td></tr>
<tr><td><code id="sim.bdh.taxa.ssa_+3A_hyb.inher.fxn">hyb.inher.fxn</code></td>
<td>
<p>A function for drawing the hybrid inheritance probabilities.</p>
</td></tr>
<tr><td><code id="sim.bdh.taxa.ssa_+3A_frac">frac</code></td>
<td>
<p>Sampling fraction: The proportion of extant tips included in the phylogeny (incomplete sampling).</p>
</td></tr>
<tr><td><code id="sim.bdh.taxa.ssa_+3A_twolineages">twolineages</code></td>
<td>
<p>If <code>twolineages=TRUE</code>: The process originates with two lineages that share a common ancestor. If <code>twolineages=FALSE</code>: The process originates with two lineages.</p>
</td></tr>
<tr><td><code id="sim.bdh.taxa.ssa_+3A_complete">complete</code></td>
<td>
<p>If complete = TRUE, the tree with the extinct lineages is returned. If complete = FALSE, the extinct lineages are suppressed.</p>
</td></tr>
<tr><td><code id="sim.bdh.taxa.ssa_+3A_stochsampling">stochsampling</code></td>
<td>
<p>When <code>stochsampling=TRUE</code>: Each extant tip is included into the final tree with probability frac.</p>
</td></tr>
<tr><td><code id="sim.bdh.taxa.ssa_+3A_hyb.rate.fxn">hyb.rate.fxn</code></td>
<td>
<p>The probability of a successful hybridization as a function of genetic distance between taxa. The default value of 'NULL&ldquo; assumes that hybridization success is independent of genetic distance between taxa.</p>
</td></tr>
<tr><td><code id="sim.bdh.taxa.ssa_+3A_trait.model">trait.model</code></td>
<td>
<p>A list that dictates how a trait affects the hybridization process. The default value of <code>NULL</code> doesn't take a trait into account for simulation. See Details for more information.</p>
</td></tr>
<tr><td><code id="sim.bdh.taxa.ssa_+3A_mrca">mrca</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use the <code>twolineages</code> argument</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>hyb.inher.fxn</code> should return values between 0 and 1 and shouldn't require any arguments. E.g. <a href="#topic+make.beta.draw">make.beta.draw</a> and <a href="#topic+make.uniform.draw">make.uniform.draw</a> create functions that fit these specifications
</p>
<p><code>hyb.rate.fxn</code> should take one argument for the genetic distance. The function should be defined on the range <code class="reqn">[0,Inf)</code> and return values between <code class="reqn">[0,1]</code>
</p>
<p><code>trait.model</code> is a list with the following named elements:
</p>

<ul>
<li><p><code>initial</code> The initial trait state on the phylogeny
</p>
</li>
<li><p><code>hyb.event.fxn</code> A function that denotes the trait of a hybrid child after a hybridization event. The function should have the arguments <code>parent_states</code> and <code>inheritance</code>. <code>parent_states</code> is vector with the ploidy states of the hybrid parents while <code>inheritance</code> is the inheritance probability of the first lineage denoted in <code>parent_states</code>.
</p>
</li>
<li><p><code>hyb.compatibility.fxn</code> A function that describes when hybridization events can occur between two taxa based on their traits. The function should have the argument <code>parent_states</code>, a vector with the trait states of the two parents to the hybrid child. The function should return <code>TRUE</code> for when a hybridization event is allowed to proceed and <code>FALSE</code> otherwise.
</p>
</li>
<li><p><code>time.fxn</code> A function that describes how traits change over time. The function should have the arguments <code>trait_states</code> and <code>timestep</code> in that order. <code>trait_states</code> is a vector containing the ploidy of all taxa while <code>timestep</code> is the amount of time given for trait evolution. The function should return a vector with the updated ploidy states of all taxa.
</p>
</li>
<li><p><code>spec.fxn</code> A function that describes how the trait changes at speciation events.The function should have the argument <code>tip_state</code> which has the state of the lineage just before speciation. The function should return a vector with two values, one denoting the trait of each of the two new species after the event.
</p>
</li></ul>



<h3>Value</h3>

<p>out Returns a list of numbsim networks with the time since origin / most recent common ancestor being 'age.' If tree goes extinct or no tips are sampled, return value is '0'. If only one extant and no extinct tips are sampled, return value is '1'. Each network has an additional attribute &quot;inheritance&quot; that represents the inheritance probabilities on the edges in the &quot;reticulation&quot; attribute.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##smallest Quartan prime as seed for reproducibility
set.seed(17)
##Generate a tree with extinct leaves
net&lt;-sim.bdh.taxa.ssa(5,1,5,2,1.5,c(1/3,1/3,1/3),
hyb.inher.fxn = make.uniform.draw(),complete=TRUE)[[1]]
</code></pre>

<hr>
<h2 id='write.net'>Write a Network in Parenthetic Format</h2><span id='topic+write.net'></span>

<h3>Description</h3>

<p>This function writes a network to file in the Extended Newick format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.net(
  net,
  file = "",
  append = FALSE,
  digits = 10,
  tree.names = FALSE,
  tol = 1e-08,
  swap.minor = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.net_+3A_net">net</code></td>
<td>
<p>A phylogenetic network of class <code>evonet</code>. The network may include an optional attribute &lsquo;inheritance&ldquo; that represents the inheritance probabilities on the edges found in the &rsquo;reticulation' attribute</p>
</td></tr>
<tr><td><code id="write.net_+3A_file">file</code></td>
<td>
<p>a file name specified by either a variable of mode character, or a double-quoted string; if 'file = &quot;&quot;&ldquo; (the default) then the tree is written on the standard output connection (i.e. the console).</p>
</td></tr>
<tr><td><code id="write.net_+3A_append">append</code></td>
<td>
<p>a logical, if TRUE the tree is appended to the file without erasing the data possibly existing in the file, otherwise the file (if it exists) is overwritten ('FALSE&ldquo; the default).</p>
</td></tr>
<tr><td><code id="write.net_+3A_digits">digits</code></td>
<td>
<p>a numeric giving the number of digits used for printing branch lengths.</p>
</td></tr>
<tr><td><code id="write.net_+3A_tree.names">tree.names</code></td>
<td>
<p>either a logical or a vector of mode character. If TRUE then any tree names will be written prior to the tree on each line. If character, specifies the name of &quot;phylo&quot; objects which can be written to the file.</p>
</td></tr>
<tr><td><code id="write.net_+3A_tol">tol</code></td>
<td>
<p>a numeric value giving the tolerance to consider a branch as length 0.</p>
</td></tr>
<tr><td><code id="write.net_+3A_swap.minor">swap.minor</code></td>
<td>
<p>a logical, TRUE swaps hybrid edges around such that edges with inheritance &lt;0.5 are always written as leaves</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The node labels and the root edge length, if available, are written in the file.
</p>
<p>If inheritance probabilities are included in the network object as the 'inheritance' attribute, they are also written to file.
</p>
<p>If tree.names == TRUE then a variant of the Newick format is written for which the name of a tree precedes the Newick format tree (parentheses are eventually deleted beforehand). The tree names are taken from the names attribute if present (they are ignored if tree.names is a character vector).
</p>
<p>The tip labels (and the node labels if present) are checked before being printed: the leading and trailing spaces, and the leading left and trailing right parentheses are deleted; the other spaces are replaced by underscores; the commas, colons, semicolons, and the other parentheses are replaced with dashes
</p>


<h3>Value</h3>

<p>a vector of mode character if file = &quot;&quot;, none (invisible NULL) otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net&lt;-read.net(text="((A:7,((B:2,C:2):3)#H1:2::0.6):3,(D:6,#H1:1::0.4):4);")
write.net(net)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
