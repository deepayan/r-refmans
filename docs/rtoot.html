<!DOCTYPE html><html><head><title>Help for package rtoot</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rtoot}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#auth_setup'><p>Authenticate with a Mastodon instance</p></a></li>
<li><a href='#convert_token_to_envvar'><p>Convert token to environment variable</p></a></li>
<li><a href='#create_token'><p>get a bearer token for the mastodon api</p></a></li>
<li><a href='#get_account'><p>Query the instance for a specific user</p></a></li>
<li><a href='#get_account_blocks'><p>Get blocks of user</p></a></li>
<li><a href='#get_account_bookmarks'><p>Get bookmarks of user</p></a></li>
<li><a href='#get_account_favourites'><p>Get favourites of user</p></a></li>
<li><a href='#get_account_featured_tags'><p>Get featured tags of a user</p></a></li>
<li><a href='#get_account_followers'><p>Get followers of a user</p></a></li>
<li><a href='#get_account_following'><p>Get accounts a user follows</p></a></li>
<li><a href='#get_account_lists'><p>Get lists containing the user</p></a></li>
<li><a href='#get_account_mutes'><p>Get mutes of user</p></a></li>
<li><a href='#get_account_relationships'><p>Find out whether a given account is followed, blocked, muted, etc.</p></a></li>
<li><a href='#get_account_statuses'><p>Get statuses from a user</p></a></li>
<li><a href='#get_client'><p>register a mastodon client</p></a></li>
<li><a href='#get_context'><p>View statuses above and below this status in the thread</p></a></li>
<li><a href='#get_fedi_instances'><p>Get a list of fediverse servers</p></a></li>
<li><a href='#get_instance'><p>Get various information about a specific instance</p></a></li>
<li><a href='#get_list_accounts'><p>View accounts in a list</p></a></li>
<li><a href='#get_lists'><p>View your lists</p></a></li>
<li><a href='#get_poll'><p>View a poll</p></a></li>
<li><a href='#get_status'><p>View information about a specific status</p></a></li>
<li><a href='#get_timeline_hashtag'><p>Get hashtag timeline</p></a></li>
<li><a href='#get_timeline_home'><p>Get home and list timelines</p></a></li>
<li><a href='#get_timeline_public'><p>Get the public timeline</p></a></li>
<li><a href='#parse_stream'><p>Parser of Mastodon stream</p></a></li>
<li><a href='#post_list_accounts'><p>Add accounts to a list</p></a></li>
<li><a href='#post_list_create'><p>Create a list</p></a></li>
<li><a href='#post_status'><p>Perform actions on a status</p></a></li>
<li><a href='#post_toot'><p>Post status update to user's Mastodon account</p></a></li>
<li><a href='#post_user'><p>Perform actions on an account</p></a></li>
<li><a href='#rtoot'><p>Query Mastodon API</p></a></li>
<li><a href='#rtoot-package'><p>rtoot: Collect Mastodon data from R</p></a></li>
<li><a href='#save_auth_rtoot'><p>save a bearer token to file</p></a></li>
<li><a href='#search_accounts'><p>Search the instance for a specific user</p></a></li>
<li><a href='#stream_timeline'><p>Collect live streams of Mastodon data</p></a></li>
<li><a href='#verify_credentials'><p>Verify mastodon credentials</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Collecting and Analyzing Mastodon Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.4</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of calls designed to collect and organize Mastodon data via its Application Program Interfaces (API), which can be found at the following URL: <a href="https://docs.joinmastodon.org/">https://docs.joinmastodon.org/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gesistsa.github.io/rtoot/">https://gesistsa.github.io/rtoot/</a>,
<a href="https://github.com/gesistsa/rtoot/">https://github.com/gesistsa/rtoot/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gesistsa/rtoot/issues">https://github.com/gesistsa/rtoot/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>clipr, curl, dplyr, httr, jsonlite, tibble</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0), rstudioapi, vcr (&ge;
0.6.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-08 20:43:38 UTC; david</td>
</tr>
<tr>
<td>Author:</td>
<td>David Schoch <a href="https://orcid.org/0000-0003-2952-4812"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Chung-hong Chan <a href="https://orcid.org/0000-0002-6232-7530"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Johannes Gruber <a href="https://orcid.org/0000-0001-9177-1772"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Schoch &lt;david@schochastics.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-09 01:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='auth_setup'>Authenticate with a Mastodon instance</h2><span id='topic+auth_setup'></span>

<h3>Description</h3>

<p>Authenticate with a Mastodon instance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auth_setup(
  instance = NULL,
  type = NULL,
  name = NULL,
  path = NULL,
  clipboard = FALSE,
  verbose = TRUE,
  browser = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auth_setup_+3A_instance">instance</code></td>
<td>
<p>a public instance of Mastodon (e.g., mastodon.social).</p>
</td></tr>
<tr><td><code id="auth_setup_+3A_type">type</code></td>
<td>
<p>Either &quot;public&quot; to create a public authentication or &quot;user&quot; to
create authentication for your user (e.g., if you want to post from R or
query your followers).</p>
</td></tr>
<tr><td><code id="auth_setup_+3A_name">name</code></td>
<td>
<p>give the token a name, in case you want to store more than one.</p>
</td></tr>
<tr><td><code id="auth_setup_+3A_path">path</code></td>
<td>
<p>path to store the token in. The default is to store tokens in the
path returned by <code>tools::R_user_dir("rtoot", "config")</code>.</p>
</td></tr>
<tr><td><code id="auth_setup_+3A_clipboard">clipboard</code></td>
<td>
<p>logical, whether to export the token to the clipboard</p>
</td></tr>
<tr><td><code id="auth_setup_+3A_verbose">verbose</code></td>
<td>
<p>logical whether to display messages</p>
</td></tr>
<tr><td><code id="auth_setup_+3A_browser">browser</code></td>
<td>
<p>if <code>TRUE</code> (default) a browser window will be opened to authenticate, else the URL will be provided so you can copy/paste this into the browser yourself</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If either <code>name</code> or <code>path</code> are set to <code>FALSE</code>, the token is only
returned and not saved. If you would like to save your token as an environment variable,
please set <code>clipboard</code> to <code>TRUE</code>. Your token will be copied to clipboard in the environment variable
format. Please paste it into your environment file, e.g. &quot;.Renviron&quot;, and restart
your R session.
</p>


<h3>Value</h3>

<p>A bearer token
</p>


<h3>See Also</h3>

<p><code><a href="#topic+verify_credentials">verify_credentials()</a></code>, <code><a href="#topic+convert_token_to_envvar">convert_token_to_envvar()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
auth_setup("mastodon.social", "public")

## End(Not run)
</code></pre>

<hr>
<h2 id='convert_token_to_envvar'>Convert token to environment variable</h2><span id='topic+convert_token_to_envvar'></span>

<h3>Description</h3>

<p>Convert token to environment variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_token_to_envvar(token, clipboard = TRUE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_token_to_envvar_+3A_token">token</code></td>
<td>
<p>bearer token, either public or user level</p>
</td></tr>
<tr><td><code id="convert_token_to_envvar_+3A_clipboard">clipboard</code></td>
<td>
<p>logical, whether to export the token to the clipboard</p>
</td></tr>
<tr><td><code id="convert_token_to_envvar_+3A_verbose">verbose</code></td>
<td>
<p>logical whether to display messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Token (in environment variable format), invisibily
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- auth_setup("mastodon.social", "public")
envvar &lt;- convert_token_to_envvar(x)
envvar

## End(Not run)
</code></pre>

<hr>
<h2 id='create_token'>get a bearer token for the mastodon api</h2><span id='topic+create_token'></span>

<h3>Description</h3>

<p>get a bearer token for the mastodon api
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_token(client, type = "public", browser = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_token_+3A_client">client</code></td>
<td>
<p>rtoot client object created with <a href="#topic+get_client">get_client</a></p>
</td></tr>
<tr><td><code id="create_token_+3A_type">type</code></td>
<td>
<p>one of &quot;public&quot; or &quot;user&quot;. See details</p>
</td></tr>
<tr><td><code id="create_token_+3A_browser">browser</code></td>
<td>
<p>if <code>TRUE</code> (default) a browser window will be opened to authenticate, else the URL will be provided so you can copy/paste this into the browser yourself</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TBA
</p>


<h3>Value</h3>

<p>a mastodon bearer token
</p>


<h3>References</h3>

<p>https://docs.joinmastodon.org/client/authorized/
</p>

<hr>
<h2 id='get_account'>Query the instance for a specific user</h2><span id='topic+get_account'></span>

<h3>Description</h3>

<p>Query the instance for a specific user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_account(id, instance = NULL, token = NULL, anonymous = FALSE, parse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_account_+3A_id">id</code></td>
<td>
<p>character, Local ID of a user (this is not the username)</p>
</td></tr>
<tr><td><code id="get_account_+3A_instance">instance</code></td>
<td>
<p>character, the server name of the instance where the status is located. If <code>NULL</code>, the same instance used to obtain the token is used.</p>
</td></tr>
<tr><td><code id="get_account_+3A_token">token</code></td>
<td>
<p>user bearer token (read from file by default)</p>
</td></tr>
<tr><td><code id="get_account_+3A_anonymous">anonymous</code></td>
<td>
<p>some API calls do not need a token. Setting anonymous to TRUE allows to make an anonymous call if possible.</p>
</td></tr>
<tr><td><code id="get_account_+3A_parse">parse</code></td>
<td>
<p>logical, if <code>TRUE</code>, the default, returns a tibble. Use <code>FALSE</code>  to return the &quot;raw&quot; list corresponding to the JSON returned from the Mastodon API.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an account
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
get_account("109302436954721982")

## End(Not run)
</code></pre>

<hr>
<h2 id='get_account_blocks'>Get blocks of user</h2><span id='topic+get_account_blocks'></span>

<h3>Description</h3>

<p>Get blocks of user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_account_blocks(
  max_id,
  since_id,
  limit = 40L,
  token = NULL,
  parse = TRUE,
  retryonratelimit = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_account_blocks_+3A_max_id">max_id</code></td>
<td>
<p>character, Return results older than this id</p>
</td></tr>
<tr><td><code id="get_account_blocks_+3A_since_id">since_id</code></td>
<td>
<p>character, Return results newer than this id</p>
</td></tr>
<tr><td><code id="get_account_blocks_+3A_limit">limit</code></td>
<td>
<p>integer, Maximum number of results to return</p>
</td></tr>
<tr><td><code id="get_account_blocks_+3A_token">token</code></td>
<td>
<p>user bearer token (read from file by default)</p>
</td></tr>
<tr><td><code id="get_account_blocks_+3A_parse">parse</code></td>
<td>
<p>logical, if <code>TRUE</code>, the default, returns a tibble. Use <code>FALSE</code>  to return the &quot;raw&quot; list corresponding to the JSON returned from the Mastodon API.</p>
</td></tr>
<tr><td><code id="get_account_blocks_+3A_retryonratelimit">retryonratelimit</code></td>
<td>
<p>If TRUE, and a rate limit is exhausted, will wait until it refreshes. Most Mastodon rate limits refresh every 5 minutes. If FALSE, and the rate limit is exceeded, the function will terminate early with a warning; you'll still get back all results received up to that point.</p>
</td></tr>
<tr><td><code id="get_account_blocks_+3A_verbose">verbose</code></td>
<td>
<p>logical whether to display messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this functions needs a user level auth token. If limit&gt;40, automatic pagination is used. You may get more results than requested.
</p>


<h3>Value</h3>

<p>tibble or list of blocked users
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# needs user level token
get_account_blocks()

## End(Not run)
</code></pre>

<hr>
<h2 id='get_account_bookmarks'>Get bookmarks of user</h2><span id='topic+get_account_bookmarks'></span>

<h3>Description</h3>

<p>Get bookmarks of user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_account_bookmarks(
  max_id,
  since_id,
  min_id,
  limit = 40L,
  token = NULL,
  parse = TRUE,
  retryonratelimit = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_account_bookmarks_+3A_max_id">max_id</code></td>
<td>
<p>character, Return results older than this id</p>
</td></tr>
<tr><td><code id="get_account_bookmarks_+3A_since_id">since_id</code></td>
<td>
<p>character, Return results newer than this id</p>
</td></tr>
<tr><td><code id="get_account_bookmarks_+3A_min_id">min_id</code></td>
<td>
<p>character, Return results younger than this id</p>
</td></tr>
<tr><td><code id="get_account_bookmarks_+3A_limit">limit</code></td>
<td>
<p>integer, Maximum number of results to return</p>
</td></tr>
<tr><td><code id="get_account_bookmarks_+3A_token">token</code></td>
<td>
<p>user bearer token (read from file by default)</p>
</td></tr>
<tr><td><code id="get_account_bookmarks_+3A_parse">parse</code></td>
<td>
<p>logical, if <code>TRUE</code>, the default, returns a tibble. Use <code>FALSE</code>  to return the &quot;raw&quot; list corresponding to the JSON returned from the Mastodon API.</p>
</td></tr>
<tr><td><code id="get_account_bookmarks_+3A_retryonratelimit">retryonratelimit</code></td>
<td>
<p>If TRUE, and a rate limit is exhausted, will wait until it refreshes. Most Mastodon rate limits refresh every 5 minutes. If FALSE, and the rate limit is exceeded, the function will terminate early with a warning; you'll still get back all results received up to that point.</p>
</td></tr>
<tr><td><code id="get_account_bookmarks_+3A_verbose">verbose</code></td>
<td>
<p>logical whether to display messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this functions needs a user level auth token. If limit&gt;40, automatic pagination is used. You may get more results than requested.
</p>


<h3>Value</h3>

<p>bookmarked statuses
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
get_account_followers("109302436954721982")

## End(Not run)
</code></pre>

<hr>
<h2 id='get_account_favourites'>Get favourites of user</h2><span id='topic+get_account_favourites'></span>

<h3>Description</h3>

<p>Get favourites of user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_account_favourites(
  max_id,
  min_id,
  limit = 40L,
  token = NULL,
  parse = TRUE,
  retryonratelimit = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_account_favourites_+3A_max_id">max_id</code></td>
<td>
<p>character, Return results older than this id</p>
</td></tr>
<tr><td><code id="get_account_favourites_+3A_min_id">min_id</code></td>
<td>
<p>character, Return results younger than this id</p>
</td></tr>
<tr><td><code id="get_account_favourites_+3A_limit">limit</code></td>
<td>
<p>integer, Maximum number of results to return</p>
</td></tr>
<tr><td><code id="get_account_favourites_+3A_token">token</code></td>
<td>
<p>user bearer token (read from file by default)</p>
</td></tr>
<tr><td><code id="get_account_favourites_+3A_parse">parse</code></td>
<td>
<p>logical, if <code>TRUE</code>, the default, returns a tibble. Use <code>FALSE</code>  to return the &quot;raw&quot; list corresponding to the JSON returned from the Mastodon API.</p>
</td></tr>
<tr><td><code id="get_account_favourites_+3A_retryonratelimit">retryonratelimit</code></td>
<td>
<p>If TRUE, and a rate limit is exhausted, will wait until it refreshes. Most Mastodon rate limits refresh every 5 minutes. If FALSE, and the rate limit is exceeded, the function will terminate early with a warning; you'll still get back all results received up to that point.</p>
</td></tr>
<tr><td><code id="get_account_favourites_+3A_verbose">verbose</code></td>
<td>
<p>logical whether to display messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this functions needs a user level auth token. If limit&gt;40, automatic pagination is used. You may get more results than requested.
</p>


<h3>Value</h3>

<p>tibble or list of favourited statuses
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# needs user level token
get_account_favourites()

## End(Not run)
</code></pre>

<hr>
<h2 id='get_account_featured_tags'>Get featured tags of a user</h2><span id='topic+get_account_featured_tags'></span>

<h3>Description</h3>

<p>Get featured tags of a user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_account_featured_tags(id, token = NULL, parse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_account_featured_tags_+3A_id">id</code></td>
<td>
<p>character, local ID of a user (this is not the username)</p>
</td></tr>
<tr><td><code id="get_account_featured_tags_+3A_token">token</code></td>
<td>
<p>user bearer token (read from file by default)</p>
</td></tr>
<tr><td><code id="get_account_featured_tags_+3A_parse">parse</code></td>
<td>
<p>logical, if <code>TRUE</code>, the default, returns a tibble. Use <code>FALSE</code>  to return the &quot;raw&quot; list corresponding to the JSON returned from the Mastodon API.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this functions needs a user level auth token
</p>


<h3>Value</h3>

<p>tibble or list of featured_tags
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
get_account_featured_tags("109302436954721982")

## End(Not run)
</code></pre>

<hr>
<h2 id='get_account_followers'>Get followers of a user</h2><span id='topic+get_account_followers'></span>

<h3>Description</h3>

<p>Get followers of a user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_account_followers(
  id,
  max_id,
  since_id,
  limit = 40L,
  token = NULL,
  parse = TRUE,
  retryonratelimit = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_account_followers_+3A_id">id</code></td>
<td>
<p>character, local ID of a user (this is not the username)</p>
</td></tr>
<tr><td><code id="get_account_followers_+3A_max_id">max_id</code></td>
<td>
<p>character, Return results older than this id</p>
</td></tr>
<tr><td><code id="get_account_followers_+3A_since_id">since_id</code></td>
<td>
<p>character, Return results newer than this id</p>
</td></tr>
<tr><td><code id="get_account_followers_+3A_limit">limit</code></td>
<td>
<p>integer, maximum number of results to return. Defaults to 40.</p>
</td></tr>
<tr><td><code id="get_account_followers_+3A_token">token</code></td>
<td>
<p>user bearer token (read from file by default)</p>
</td></tr>
<tr><td><code id="get_account_followers_+3A_parse">parse</code></td>
<td>
<p>logical, if <code>TRUE</code>, the default, returns a tibble. Use <code>FALSE</code>  to return the &quot;raw&quot; list corresponding to the JSON returned from the Mastodon API.</p>
</td></tr>
<tr><td><code id="get_account_followers_+3A_retryonratelimit">retryonratelimit</code></td>
<td>
<p>If TRUE, and a rate limit is exhausted, will wait until it refreshes. Most Mastodon rate limits refresh every 5 minutes. If FALSE, and the rate limit is exceeded, the function will terminate early with a warning; you'll still get back all results received up to that point.</p>
</td></tr>
<tr><td><code id="get_account_followers_+3A_verbose">verbose</code></td>
<td>
<p>logical whether to display messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this functions needs a user level auth token. If limit&gt;40, automatic pagination is used. You may get more results than requested.
</p>


<h3>Value</h3>

<p>tibble or list of followers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
get_account_followers("109302436954721982")

## End(Not run)
</code></pre>

<hr>
<h2 id='get_account_following'>Get accounts a user follows</h2><span id='topic+get_account_following'></span>

<h3>Description</h3>

<p>Get accounts a user follows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_account_following(
  id,
  max_id,
  since_id,
  limit = 40L,
  token = NULL,
  parse = TRUE,
  retryonratelimit = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_account_following_+3A_id">id</code></td>
<td>
<p>character, local ID of a user (this is not the username)</p>
</td></tr>
<tr><td><code id="get_account_following_+3A_max_id">max_id</code></td>
<td>
<p>character, Return results older than this id</p>
</td></tr>
<tr><td><code id="get_account_following_+3A_since_id">since_id</code></td>
<td>
<p>character, Return results newer than this id</p>
</td></tr>
<tr><td><code id="get_account_following_+3A_limit">limit</code></td>
<td>
<p>integer, Maximum number of results to return</p>
</td></tr>
<tr><td><code id="get_account_following_+3A_token">token</code></td>
<td>
<p>user bearer token (read from file by default)</p>
</td></tr>
<tr><td><code id="get_account_following_+3A_parse">parse</code></td>
<td>
<p>logical, if <code>TRUE</code>, the default, returns a tibble. Use <code>FALSE</code>  to return the &quot;raw&quot; list corresponding to the JSON returned from the Mastodon API.</p>
</td></tr>
<tr><td><code id="get_account_following_+3A_retryonratelimit">retryonratelimit</code></td>
<td>
<p>If TRUE, and a rate limit is exhausted, will wait until it refreshes. Most Mastodon rate limits refresh every 5 minutes. If FALSE, and the rate limit is exceeded, the function will terminate early with a warning; you'll still get back all results received up to that point.</p>
</td></tr>
<tr><td><code id="get_account_following_+3A_verbose">verbose</code></td>
<td>
<p>logical whether to display messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this functions needs a user level auth token. If limit&gt;40, automatic pagination is used. You may get more results than requested.
</p>


<h3>Value</h3>

<p>tibble or list of accounts a user follows
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
get_account_following("109302436954721982")

## End(Not run)
</code></pre>

<hr>
<h2 id='get_account_lists'>Get lists containing the user</h2><span id='topic+get_account_lists'></span>

<h3>Description</h3>

<p>Get lists containing the user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_account_lists(id, token = NULL, parse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_account_lists_+3A_id">id</code></td>
<td>
<p>character, local ID of a user (this is not the username)</p>
</td></tr>
<tr><td><code id="get_account_lists_+3A_token">token</code></td>
<td>
<p>user bearer token (read from file by default)</p>
</td></tr>
<tr><td><code id="get_account_lists_+3A_parse">parse</code></td>
<td>
<p>logical, if <code>TRUE</code>, the default, returns a tibble. Use <code>FALSE</code>  to return the &quot;raw&quot; list corresponding to the JSON returned from the Mastodon API.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this functions needs a user level auth token
</p>


<h3>Value</h3>

<p>tibble or list of lists
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
get_account_lists("109302436954721982")

## End(Not run)
</code></pre>

<hr>
<h2 id='get_account_mutes'>Get mutes of user</h2><span id='topic+get_account_mutes'></span>

<h3>Description</h3>

<p>Get mutes of user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_account_mutes(
  max_id,
  since_id,
  limit = 40L,
  token = NULL,
  parse = TRUE,
  retryonratelimit = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_account_mutes_+3A_max_id">max_id</code></td>
<td>
<p>character, Return results older than this id</p>
</td></tr>
<tr><td><code id="get_account_mutes_+3A_since_id">since_id</code></td>
<td>
<p>character, Return results newer than this id</p>
</td></tr>
<tr><td><code id="get_account_mutes_+3A_limit">limit</code></td>
<td>
<p>integer, Maximum number of results to return</p>
</td></tr>
<tr><td><code id="get_account_mutes_+3A_token">token</code></td>
<td>
<p>user bearer token (read from file by default)</p>
</td></tr>
<tr><td><code id="get_account_mutes_+3A_parse">parse</code></td>
<td>
<p>logical, if <code>TRUE</code>, the default, returns a tibble. Use <code>FALSE</code>  to return the &quot;raw&quot; list corresponding to the JSON returned from the Mastodon API.</p>
</td></tr>
<tr><td><code id="get_account_mutes_+3A_retryonratelimit">retryonratelimit</code></td>
<td>
<p>If TRUE, and a rate limit is exhausted, will wait until it refreshes. Most Mastodon rate limits refresh every 5 minutes. If FALSE, and the rate limit is exceeded, the function will terminate early with a warning; you'll still get back all results received up to that point.</p>
</td></tr>
<tr><td><code id="get_account_mutes_+3A_verbose">verbose</code></td>
<td>
<p>logical whether to display messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this functions needs a user level auth token. If limit&gt;40, automatic pagination is used. You may get more results than requested.
</p>


<h3>Value</h3>

<p>tibble or list of muted users
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# needs user level token
get_account_mutes()

## End(Not run)
</code></pre>

<hr>
<h2 id='get_account_relationships'>Find out whether a given account is followed, blocked, muted, etc.</h2><span id='topic+get_account_relationships'></span>

<h3>Description</h3>

<p>Find out whether a given account is followed, blocked, muted, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_account_relationships(ids, token = NULL, parse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_account_relationships_+3A_ids">ids</code></td>
<td>
<p>vector of account ids</p>
</td></tr>
<tr><td><code id="get_account_relationships_+3A_token">token</code></td>
<td>
<p>user bearer token (read from file by default)</p>
</td></tr>
<tr><td><code id="get_account_relationships_+3A_parse">parse</code></td>
<td>
<p>logical, if <code>TRUE</code>, the default, returns a tibble. Use <code>FALSE</code>  to return the &quot;raw&quot; list corresponding to the JSON returned from the Mastodon API.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this functions needs a user level auth token
</p>


<h3>Value</h3>

<p>tibble or list of relationships
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fol &lt;- get_account_followers("109302436954721982")
get_account_relationships(fol$id)

## End(Not run)
</code></pre>

<hr>
<h2 id='get_account_statuses'>Get statuses from a user</h2><span id='topic+get_account_statuses'></span>

<h3>Description</h3>

<p>Get statuses from a user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_account_statuses(
  id,
  max_id,
  since_id,
  min_id,
  limit = 20L,
  exclude_reblogs = FALSE,
  hashtag,
  instance = NULL,
  token = NULL,
  anonymous = FALSE,
  parse = TRUE,
  retryonratelimit = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_account_statuses_+3A_id">id</code></td>
<td>
<p>character, local ID of a user (this is not the username)</p>
</td></tr>
<tr><td><code id="get_account_statuses_+3A_max_id">max_id</code></td>
<td>
<p>character, Return results older than this id</p>
</td></tr>
<tr><td><code id="get_account_statuses_+3A_since_id">since_id</code></td>
<td>
<p>character, Return results newer than this id</p>
</td></tr>
<tr><td><code id="get_account_statuses_+3A_min_id">min_id</code></td>
<td>
<p>character, Return results immediately newer than this id</p>
</td></tr>
<tr><td><code id="get_account_statuses_+3A_limit">limit</code></td>
<td>
<p>integer, Maximum number of results to return</p>
</td></tr>
<tr><td><code id="get_account_statuses_+3A_exclude_reblogs">exclude_reblogs</code></td>
<td>
<p>logical, Whether to filter out boosts from the response.</p>
</td></tr>
<tr><td><code id="get_account_statuses_+3A_hashtag">hashtag</code></td>
<td>
<p>character, filter for statuses using a specific hashtag.</p>
</td></tr>
<tr><td><code id="get_account_statuses_+3A_instance">instance</code></td>
<td>
<p>character, the server name of the instance where the status is located. If <code>NULL</code>, the same instance used to obtain the token is used.</p>
</td></tr>
<tr><td><code id="get_account_statuses_+3A_token">token</code></td>
<td>
<p>user bearer token (read from file by default)</p>
</td></tr>
<tr><td><code id="get_account_statuses_+3A_anonymous">anonymous</code></td>
<td>
<p>some API calls do not need a token. Setting anonymous to TRUE allows to make an anonymous call if possible.</p>
</td></tr>
<tr><td><code id="get_account_statuses_+3A_parse">parse</code></td>
<td>
<p>logical, if <code>TRUE</code>, the default, returns a tibble. Use <code>FALSE</code>  to return the &quot;raw&quot; list corresponding to the JSON returned from the Mastodon API.</p>
</td></tr>
<tr><td><code id="get_account_statuses_+3A_retryonratelimit">retryonratelimit</code></td>
<td>
<p>If TRUE, and a rate limit is exhausted, will wait until it refreshes. Most Mastodon rate limits refresh every 5 minutes. If FALSE, and the rate limit is exceeded, the function will terminate early with a warning; you'll still get back all results received up to that point.</p>
</td></tr>
<tr><td><code id="get_account_statuses_+3A_verbose">verbose</code></td>
<td>
<p>logical whether to display messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For anonymous calls only public statuses are returned. If a user token is supplied also private statuses the user is authorized to see are returned
</p>


<h3>Value</h3>

<p>tibble or list of statuses
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
get_account_statuses("109302436954721982")

## End(Not run)
</code></pre>

<hr>
<h2 id='get_client'>register a mastodon client</h2><span id='topic+get_client'></span>

<h3>Description</h3>

<p>register a mastodon client
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_client(instance = "mastodon.social")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_client_+3A_instance">instance</code></td>
<td>
<p>server name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an rtoot client object
</p>


<h3>References</h3>

<p>https://docs.joinmastodon.org/client/token/#creating-our-application
</p>

<hr>
<h2 id='get_context'>View statuses above and below this status in the thread</h2><span id='topic+get_context'></span>

<h3>Description</h3>

<p>Query the instance for information about the context of a specific status. A context contains statuses above and below a status in a thread.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_context(id, instance = NULL, token = NULL, anonymous = FALSE, parse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_context_+3A_id">id</code></td>
<td>
<p>character, local ID of a status in the database</p>
</td></tr>
<tr><td><code id="get_context_+3A_instance">instance</code></td>
<td>
<p>character, the server name of the instance where the status is located. If <code>NULL</code>, the same instance used to obtain the token is used.</p>
</td></tr>
<tr><td><code id="get_context_+3A_token">token</code></td>
<td>
<p>user bearer token (read from file by default)</p>
</td></tr>
<tr><td><code id="get_context_+3A_anonymous">anonymous</code></td>
<td>
<p>some API calls do not need a token. Setting anonymous to TRUE allows to make an anonymous call if possible.</p>
</td></tr>
<tr><td><code id="get_context_+3A_parse">parse</code></td>
<td>
<p>logical, if <code>TRUE</code>, the default, returns a named list of two tibbles, representing the ancestors (statuses above the status) and descendants (statuses below the status). Use <code>FALSE</code>  to return the &quot;raw&quot; list corresponding to the JSON returned from the Mastodon API.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>context of a toot as tibble or list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
get_context(id = "109294719267373593", instance = "mastodon.social")

## End(Not run)
</code></pre>

<hr>
<h2 id='get_fedi_instances'>Get a list of fediverse servers</h2><span id='topic+get_fedi_instances'></span>

<h3>Description</h3>

<p>Get a list of fediverse servers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_fedi_instances(token = NA, n = 20, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_fedi_instances_+3A_token">token</code></td>
<td>
<p>token from instances.social (this is different from your Mastodon token!)</p>
</td></tr>
<tr><td><code id="get_fedi_instances_+3A_n">n</code></td>
<td>
<p>number of servers to show</p>
</td></tr>
<tr><td><code id="get_fedi_instances_+3A_...">...</code></td>
<td>
<p>additional parameters for the instances.social API. See <a href="https://instances.social/api/doc/">https://instances.social/api/doc/</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the API at instances.social and needs a separate token. Results are sorted by number of users
</p>


<h3>Value</h3>

<p>tibble of fediverse instances
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
get_fedi_instances(n = 5)

## End(Not run)
</code></pre>

<hr>
<h2 id='get_instance'>Get various information about a specific instance</h2><span id='topic+get_instance'></span><span id='topic+get_instance_general'></span><span id='topic+get_instance_peers'></span><span id='topic+get_instance_activity'></span><span id='topic+get_instance_emoji'></span><span id='topic+get_instance_directory'></span><span id='topic+get_instance_trends'></span><span id='topic+get_instance_rules'></span><span id='topic+get_instance_blocks'></span>

<h3>Description</h3>

<p>Get various information about a specific instance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_instance_general(instance = NULL, token = NULL, anonymous = TRUE)

get_instance_peers(instance = NULL, token = NULL, anonymous = TRUE)

get_instance_activity(instance = NULL, token = NULL, anonymous = TRUE)

get_instance_emoji(instance = NULL, token = NULL, anonymous = TRUE)

get_instance_directory(
  instance = NULL,
  token = NULL,
  offset = 0,
  limit = 40,
  order = "active",
  local = FALSE,
  anonymous = TRUE,
  parse = TRUE
)

get_instance_trends(
  instance = NULL,
  token = NULL,
  limit = 10,
  anonymous = TRUE
)

get_instance_rules(instance = NULL, token = NULL, anonymous = FALSE)

get_instance_blocks(instance = NULL, token = NULL, anonymous = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_instance_+3A_instance">instance</code></td>
<td>
<p>character, the server name of the instance where the status is located. If <code>NULL</code>, the same instance used to obtain the token is used.</p>
</td></tr>
<tr><td><code id="get_instance_+3A_token">token</code></td>
<td>
<p>user bearer token (read from file by default)</p>
</td></tr>
<tr><td><code id="get_instance_+3A_anonymous">anonymous</code></td>
<td>
<p>logical, should the API call be made anonymously? Defaults to TRUE but some instances might need authentication here</p>
</td></tr>
<tr><td><code id="get_instance_+3A_offset">offset</code></td>
<td>
<p>How many accounts to skip before returning results. Default 0.</p>
</td></tr>
<tr><td><code id="get_instance_+3A_limit">limit</code></td>
<td>
<p>integer, Maximum number of results to return</p>
</td></tr>
<tr><td><code id="get_instance_+3A_order">order</code></td>
<td>
<p>'active' to sort by most recently posted statuses (default) or 'new' to sort by most recently created profiles.</p>
</td></tr>
<tr><td><code id="get_instance_+3A_local">local</code></td>
<td>
<p>logical, show only local accounts?</p>
</td></tr>
<tr><td><code id="get_instance_+3A_parse">parse</code></td>
<td>
<p>logical, if <code>TRUE</code>, the default, returns a tibble. Use <code>FALSE</code>  to return the &quot;raw&quot; list corresponding to the JSON returned from the Mastodon API.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>get_instance_general</dt><dd><p>Returns general information about the instance</p>
</dd>
<dt>get_instance_peers</dt><dd><p>Returns the peers of an instance</p>
</dd>
<dt>get_instance_activity</dt><dd><p>Shows the weekly activity of the instance (3 months)</p>
</dd>
<dt>get_instance_emoji</dt><dd><p>Lists custom emojis available on the instance</p>
</dd>
<dt>get_instance_directory</dt><dd><p>A directory of profiles that the instance is aware of</p>
</dd>
<dt>get_instance_trends</dt><dd><p>Tags that are being used more frequently within the past week</p>
</dd>
<dt>get_instance_rules</dt><dd><p>Prints the rules of an instance</p>
</dd>
<dt>get_instance_blocks</dt><dd><p>List of domains that are blocked by an instance.</p>
</dd>
</dl>



<h3>Value</h3>

<p>instance details as list or tibble depending on call function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 get_instance_general("mastodon.social")
 get_instance_activity("mastodon.social")
 get_instance_emoji("mastodon.social")
 get_instance_peers("mastodon.social")
 get_instance_directory("mastodon.social",limit = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='get_list_accounts'>View accounts in a list</h2><span id='topic+get_list_accounts'></span>

<h3>Description</h3>

<p>View accounts in a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_list_accounts(
  id,
  limit = 40L,
  token = NULL,
  parse = TRUE,
  retryonratelimit = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_list_accounts_+3A_id">id</code></td>
<td>
<p>character, id of the list</p>
</td></tr>
<tr><td><code id="get_list_accounts_+3A_limit">limit</code></td>
<td>
<p>integer, number of records to return</p>
</td></tr>
<tr><td><code id="get_list_accounts_+3A_token">token</code></td>
<td>
<p>bearer token created with <a href="#topic+create_token">create_token</a></p>
</td></tr>
<tr><td><code id="get_list_accounts_+3A_parse">parse</code></td>
<td>
<p>logical, if <code>TRUE</code>, the default, returns a tibble. Use <code>FALSE</code>  to return the &quot;raw&quot; list corresponding to the JSON returned from the Mastodon API</p>
</td></tr>
<tr><td><code id="get_list_accounts_+3A_retryonratelimit">retryonratelimit</code></td>
<td>
<p>If TRUE, and a rate limit is exhausted, will wait until it refreshes. Most Mastodon rate limits refresh every 5 minutes. If FALSE, and the rate limit is exceeded, the function will terminate early with a warning; you'll still get back all results received up to that point.</p>
</td></tr>
<tr><td><code id="get_list_accounts_+3A_verbose">verbose</code></td>
<td>
<p>logical, whether to display messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble or list of accounts
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
get_list_accounts(id = "test")

## End(Not run)
</code></pre>

<hr>
<h2 id='get_lists'>View your lists</h2><span id='topic+get_lists'></span>

<h3>Description</h3>

<p>Fetch all lists the user owns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_lists(id = "", token = NULL, parse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_lists_+3A_id">id</code></td>
<td>
<p>character, either the id of a list to return or &quot;&quot; to show all lists</p>
</td></tr>
<tr><td><code id="get_lists_+3A_token">token</code></td>
<td>
<p>bearer token created with <a href="#topic+create_token">create_token</a></p>
</td></tr>
<tr><td><code id="get_lists_+3A_parse">parse</code></td>
<td>
<p>logical, if <code>TRUE</code>, the default, returns a tibble. Use <code>FALSE</code>  to return the &quot;raw&quot; list corresponding to the JSON returned from the Mastodon API</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble or list of lists owned by the user
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
get_lists()

## End(Not run)
</code></pre>

<hr>
<h2 id='get_poll'>View a poll</h2><span id='topic+get_poll'></span>

<h3>Description</h3>

<p>View a polls attached to statuses. To discover poll ID, you will need to use <code><a href="#topic+get_status">get_status()</a></code> and look into the <code>poll</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_poll(id, instance = NULL, token = NULL, anonymous = FALSE, parse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_poll_+3A_id">id</code></td>
<td>
<p>character, ID of the poll in the database</p>
</td></tr>
<tr><td><code id="get_poll_+3A_instance">instance</code></td>
<td>
<p>character, the server name of the instance where the status is located. If <code>NULL</code>, the same instance used to obtain the token is used.</p>
</td></tr>
<tr><td><code id="get_poll_+3A_token">token</code></td>
<td>
<p>user bearer token (read from file by default)</p>
</td></tr>
<tr><td><code id="get_poll_+3A_anonymous">anonymous</code></td>
<td>
<p>some API calls do not need a token. Setting anonymous to TRUE allows to make an anonymous call if possible.</p>
</td></tr>
<tr><td><code id="get_poll_+3A_parse">parse</code></td>
<td>
<p>logical, if <code>TRUE</code>, the default, returns a tibble. Use <code>FALSE</code>  to return the &quot;raw&quot; list corresponding to the JSON returned from the Mastodon API.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a poll
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
get_poll(id = "105976")

## End(Not run)
</code></pre>

<hr>
<h2 id='get_status'>View information about a specific status</h2><span id='topic+get_status'></span><span id='topic+get_reblogged_by'></span><span id='topic+get_favourited_by'></span>

<h3>Description</h3>

<p>Query the instance for information about a specific status. <a href="#topic+get_status">get_status</a> returns complete information of a status.
<a href="#topic+get_reblogged_by">get_reblogged_by</a> returns who boosted a given status. <a href="#topic+get_favourited_by">get_favourited_by</a> returns who favourited a given status.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_status(id, instance = NULL, token = NULL, anonymous = FALSE, parse = TRUE)

get_reblogged_by(
  id,
  instance = NULL,
  token = NULL,
  anonymous = FALSE,
  parse = TRUE
)

get_favourited_by(
  id,
  instance = NULL,
  token = NULL,
  anonymous = FALSE,
  parse = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_status_+3A_id">id</code></td>
<td>
<p>character, local ID of a status in the database</p>
</td></tr>
<tr><td><code id="get_status_+3A_instance">instance</code></td>
<td>
<p>character, the server name of the instance where the status is located. If <code>NULL</code>, the same instance used to obtain the token is used.</p>
</td></tr>
<tr><td><code id="get_status_+3A_token">token</code></td>
<td>
<p>user bearer token (read from file by default)</p>
</td></tr>
<tr><td><code id="get_status_+3A_anonymous">anonymous</code></td>
<td>
<p>some API calls do not need a token. Setting anonymous to TRUE allows to make an anonymous call if possible.</p>
</td></tr>
<tr><td><code id="get_status_+3A_parse">parse</code></td>
<td>
<p>logical, if <code>TRUE</code>, the default, returns a tibble. Use <code>FALSE</code>  to return the &quot;raw&quot; list corresponding to the JSON returned from the Mastodon API.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a status or a list of users
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
get_status(id = "109326579599502650")
get_reblogged_by(id = "109326579599502650")
get_favourited_by(id = "109326579599502650")

## End(Not run)
</code></pre>

<hr>
<h2 id='get_timeline_hashtag'>Get hashtag timeline</h2><span id='topic+get_timeline_hashtag'></span>

<h3>Description</h3>

<p>Query the instance for the timeline of a specific hashtag
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_timeline_hashtag(
  hashtag = "rstats",
  local = FALSE,
  only_media = FALSE,
  max_id,
  since_id,
  min_id,
  limit = 20L,
  instance = NULL,
  token = NULL,
  anonymous = FALSE,
  parse = TRUE,
  retryonratelimit = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_timeline_hashtag_+3A_hashtag">hashtag</code></td>
<td>
<p>character, Content of a #hashtag. The hash is optional</p>
</td></tr>
<tr><td><code id="get_timeline_hashtag_+3A_local">local</code></td>
<td>
<p>logical, Show only local statuses?</p>
</td></tr>
<tr><td><code id="get_timeline_hashtag_+3A_only_media">only_media</code></td>
<td>
<p>logical, Show only statuses with media attached?</p>
</td></tr>
<tr><td><code id="get_timeline_hashtag_+3A_max_id">max_id</code></td>
<td>
<p>character, Return results older than this id</p>
</td></tr>
<tr><td><code id="get_timeline_hashtag_+3A_since_id">since_id</code></td>
<td>
<p>character, Return results newer than this id</p>
</td></tr>
<tr><td><code id="get_timeline_hashtag_+3A_min_id">min_id</code></td>
<td>
<p>character, Return results immediately newer than this id</p>
</td></tr>
<tr><td><code id="get_timeline_hashtag_+3A_limit">limit</code></td>
<td>
<p>integer, Maximum number of results to return</p>
</td></tr>
<tr><td><code id="get_timeline_hashtag_+3A_instance">instance</code></td>
<td>
<p>character, the server name of the instance where the status is located. If <code>NULL</code>, the same instance used to obtain the token is used.</p>
</td></tr>
<tr><td><code id="get_timeline_hashtag_+3A_token">token</code></td>
<td>
<p>user bearer token (read from file by default)</p>
</td></tr>
<tr><td><code id="get_timeline_hashtag_+3A_anonymous">anonymous</code></td>
<td>
<p>some API calls do not need a token. Setting anonymous to TRUE allows to make an anonymous call if possible.</p>
</td></tr>
<tr><td><code id="get_timeline_hashtag_+3A_parse">parse</code></td>
<td>
<p>logical, if <code>TRUE</code>, the default, returns a tibble. Use <code>FALSE</code>  to return the &quot;raw&quot; list corresponding to the JSON returned from the Mastodon API.</p>
</td></tr>
<tr><td><code id="get_timeline_hashtag_+3A_retryonratelimit">retryonratelimit</code></td>
<td>
<p>If TRUE, and a rate limit is exhausted, will wait until it refreshes. Most Mastodon rate limits refresh every 5 minutes. If FALSE, and the rate limit is exceeded, the function will terminate early with a warning; you'll still get back all results received up to that point.</p>
</td></tr>
<tr><td><code id="get_timeline_hashtag_+3A_verbose">verbose</code></td>
<td>
<p>logical whether to display messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>statuses
</p>


<h3>References</h3>

<p>https://docs.joinmastodon.org/methods/timelines/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
get_timeline_hashtag(hashtag = "#ichbinhanna")
## anonymously
get_timeline_hashtag(hashtag = "ichbinhanna", instance = "mastodon.social", anonymous = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='get_timeline_home'>Get home and list timelines</h2><span id='topic+get_timeline_home'></span><span id='topic+get_timeline_list'></span>

<h3>Description</h3>

<p>Query the instance for the timeline from either followed users or a specific list. These functions can only be called with a user token from <code><a href="#topic+create_token">create_token()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_timeline_home(
  local = FALSE,
  max_id,
  since_id,
  min_id,
  limit = 20L,
  token = NULL,
  parse = TRUE,
  retryonratelimit = TRUE,
  verbose = TRUE
)

get_timeline_list(
  list_id,
  max_id,
  since_id,
  min_id,
  limit = 20L,
  token = NULL,
  parse = TRUE,
  retryonratelimit = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_timeline_home_+3A_local">local</code></td>
<td>
<p>logical, Show only local statuses?</p>
</td></tr>
<tr><td><code id="get_timeline_home_+3A_max_id">max_id</code></td>
<td>
<p>character, Return results older than this id</p>
</td></tr>
<tr><td><code id="get_timeline_home_+3A_since_id">since_id</code></td>
<td>
<p>character, Return results newer than this id</p>
</td></tr>
<tr><td><code id="get_timeline_home_+3A_min_id">min_id</code></td>
<td>
<p>character, Return results immediately newer than this id</p>
</td></tr>
<tr><td><code id="get_timeline_home_+3A_limit">limit</code></td>
<td>
<p>integer, Maximum number of results to return</p>
</td></tr>
<tr><td><code id="get_timeline_home_+3A_token">token</code></td>
<td>
<p>user bearer token (read from file by default)</p>
</td></tr>
<tr><td><code id="get_timeline_home_+3A_parse">parse</code></td>
<td>
<p>logical, if <code>TRUE</code>, the default, returns a tibble. Use <code>FALSE</code>  to return the &quot;raw&quot; list corresponding to the JSON returned from the Mastodon API.</p>
</td></tr>
<tr><td><code id="get_timeline_home_+3A_retryonratelimit">retryonratelimit</code></td>
<td>
<p>If TRUE, and a rate limit is exhausted, will wait until it refreshes. Most Mastodon rate limits refresh every 5 minutes. If FALSE, and the rate limit is exceeded, the function will terminate early with a warning; you'll still get back all results received up to that point.</p>
</td></tr>
<tr><td><code id="get_timeline_home_+3A_verbose">verbose</code></td>
<td>
<p>logical whether to display messages</p>
</td></tr>
<tr><td><code id="get_timeline_home_+3A_list_id">list_id</code></td>
<td>
<p>character, Local ID of the list in the database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>statuses
</p>


<h3>References</h3>

<p>https://docs.joinmastodon.org/methods/timelines/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
get_timeline_home()

## End(Not run)
## Not run: 
get_timeline_list("&lt;listid&gt;")

## End(Not run)
</code></pre>

<hr>
<h2 id='get_timeline_public'>Get the public timeline</h2><span id='topic+get_timeline_public'></span>

<h3>Description</h3>

<p>Query the instance for the public timeline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_timeline_public(
  local = FALSE,
  remote = FALSE,
  only_media = FALSE,
  max_id,
  since_id,
  min_id,
  limit = 20L,
  instance = NULL,
  token = NULL,
  anonymous = FALSE,
  parse = TRUE,
  retryonratelimit = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_timeline_public_+3A_local">local</code></td>
<td>
<p>logical, Show only local statuses?</p>
</td></tr>
<tr><td><code id="get_timeline_public_+3A_remote">remote</code></td>
<td>
<p>logical, Show only remote statuses?</p>
</td></tr>
<tr><td><code id="get_timeline_public_+3A_only_media">only_media</code></td>
<td>
<p>logical, Show only statuses with media attached?</p>
</td></tr>
<tr><td><code id="get_timeline_public_+3A_max_id">max_id</code></td>
<td>
<p>character, Return results older than this id</p>
</td></tr>
<tr><td><code id="get_timeline_public_+3A_since_id">since_id</code></td>
<td>
<p>character, Return results newer than this id</p>
</td></tr>
<tr><td><code id="get_timeline_public_+3A_min_id">min_id</code></td>
<td>
<p>character, Return results immediately newer than this id</p>
</td></tr>
<tr><td><code id="get_timeline_public_+3A_limit">limit</code></td>
<td>
<p>integer, Maximum number of results to return</p>
</td></tr>
<tr><td><code id="get_timeline_public_+3A_instance">instance</code></td>
<td>
<p>character, the server name of the instance where the status is located. If <code>NULL</code>, the same instance used to obtain the token is used.</p>
</td></tr>
<tr><td><code id="get_timeline_public_+3A_token">token</code></td>
<td>
<p>user bearer token (read from file by default)</p>
</td></tr>
<tr><td><code id="get_timeline_public_+3A_anonymous">anonymous</code></td>
<td>
<p>some API calls do not need a token. Setting anonymous to TRUE allows to make an anonymous call if possible.</p>
</td></tr>
<tr><td><code id="get_timeline_public_+3A_parse">parse</code></td>
<td>
<p>logical, if <code>TRUE</code>, the default, returns a tibble. Use <code>FALSE</code>  to return the &quot;raw&quot; list corresponding to the JSON returned from the Mastodon API.</p>
</td></tr>
<tr><td><code id="get_timeline_public_+3A_retryonratelimit">retryonratelimit</code></td>
<td>
<p>If TRUE, and a rate limit is exhausted, will wait until it refreshes. Most Mastodon rate limits refresh every 5 minutes. If FALSE, and the rate limit is exceeded, the function will terminate early with a warning; you'll still get back all results received up to that point.</p>
</td></tr>
<tr><td><code id="get_timeline_public_+3A_verbose">verbose</code></td>
<td>
<p>logical whether to display messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>statuses
</p>


<h3>References</h3>

<p>https://docs.joinmastodon.org/methods/timelines/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## as tibble
get_timeline_public()
## as list
get_timeline_public(parse = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='parse_stream'>Parser of Mastodon stream</h2><span id='topic+parse_stream'></span>

<h3>Description</h3>

<p>Converts Mastodon stream data (JSON file) into a parsed tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_stream(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_stream_+3A_path">path</code></td>
<td>
<p>Character, name of JSON file with data collected by any <a href="#topic+stream_timeline">stream_timeline</a> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The stream sometimes returns invalid lines of json. These are automatically skipped. Parsing can be slow if your json contains a large amount of statuses
</p>


<h3>Value</h3>

<p>a tibble of statuses
</p>


<h3>See Also</h3>

<p><code>stream_timeline_public()</code>, <code>stream_timeline_hashtag()</code>,<code>stream_timeline_list()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
stream_timeline_public(1, file_name = "stream.json")
parse_stream("stream.json")

## End(Not run)
</code></pre>

<hr>
<h2 id='post_list_accounts'>Add accounts to a list</h2><span id='topic+post_list_accounts'></span>

<h3>Description</h3>

<p>Add accounts to a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_list_accounts(id, account_ids, token = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post_list_accounts_+3A_id">id</code></td>
<td>
<p>character, id of the list</p>
</td></tr>
<tr><td><code id="post_list_accounts_+3A_account_ids">account_ids</code></td>
<td>
<p>ids of accounts to add (this is not the username)</p>
</td></tr>
<tr><td><code id="post_list_accounts_+3A_token">token</code></td>
<td>
<p>user bearer token (read from file by default)</p>
</td></tr>
<tr><td><code id="post_list_accounts_+3A_verbose">verbose</code></td>
<td>
<p>logical whether to display messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value, called for site effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# add some accounts to a list
post_list_create(id = "1234", account_ids = c(1001, 1002))

## End(Not run)
</code></pre>

<hr>
<h2 id='post_list_create'>Create a list</h2><span id='topic+post_list_create'></span>

<h3>Description</h3>

<p>Create a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_list_create(title, replies_policy = "list", token = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post_list_create_+3A_title">title</code></td>
<td>
<p>character, The title of the list to be created</p>
</td></tr>
<tr><td><code id="post_list_create_+3A_replies_policy">replies_policy</code></td>
<td>
<p>character,  One of &quot;followed&quot;, &quot;list&quot;, or &quot;none&quot;. Defaults to &quot;list&quot;.</p>
</td></tr>
<tr><td><code id="post_list_create_+3A_token">token</code></td>
<td>
<p>user bearer token (read from file by default)</p>
</td></tr>
<tr><td><code id="post_list_create_+3A_verbose">verbose</code></td>
<td>
<p>logical whether to display messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value, called for site effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# create a list
post_list_create(title = "test")

## End(Not run)
</code></pre>

<hr>
<h2 id='post_status'>Perform actions on a status</h2><span id='topic+post_status'></span>

<h3>Description</h3>

<p>Perform actions on a status
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_status(id, action = "favourite", token = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post_status_+3A_id">id</code></td>
<td>
<p>character, status id to perform the action on</p>
</td></tr>
<tr><td><code id="post_status_+3A_action">action</code></td>
<td>
<p>character, one of &quot;(un)favourite&quot;,&quot;(un)reblog&quot;,&quot;(un)bookmark&quot;</p>
</td></tr>
<tr><td><code id="post_status_+3A_token">token</code></td>
<td>
<p>user bearer token (read from file by default)</p>
</td></tr>
<tr><td><code id="post_status_+3A_verbose">verbose</code></td>
<td>
<p>logical whether to display messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value, called for site effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# favourite a status
post_status("xxxxxx", action = "favourite")
# unfavourite a status
post_status("xxxxxx", action = "unfavourite")

## End(Not run)
</code></pre>

<hr>
<h2 id='post_toot'>Post status update to user's Mastodon account</h2><span id='topic+post_toot'></span>

<h3>Description</h3>

<p>Be aware that excessive automated posting is frowned upon (or even against the ToS) in many instances. Make sure to check the ToS of your instance and be mindful when using this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_toot(
  status = "my first rtoot #rstats",
  media = NULL,
  alt_text = NULL,
  token = NULL,
  in_reply_to_id = NULL,
  sensitive = FALSE,
  spoiler_text = NULL,
  visibility = "public",
  scheduled_at = NULL,
  language = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post_toot_+3A_status">status</code></td>
<td>
<p>character, toot status. Must be 500 characters or less.</p>
</td></tr>
<tr><td><code id="post_toot_+3A_media">media</code></td>
<td>
<p>character, path to media to add to post</p>
</td></tr>
<tr><td><code id="post_toot_+3A_alt_text">alt_text</code></td>
<td>
<p>character, a plain-text description of the media, for accessibility purposes.</p>
</td></tr>
<tr><td><code id="post_toot_+3A_token">token</code></td>
<td>
<p>user bearer token (read from file by default)</p>
</td></tr>
<tr><td><code id="post_toot_+3A_in_reply_to_id">in_reply_to_id</code></td>
<td>
<p>character, ID of the status being replied to, if status is a reply</p>
</td></tr>
<tr><td><code id="post_toot_+3A_sensitive">sensitive</code></td>
<td>
<p>logical, mark status and attached media as sensitive?</p>
</td></tr>
<tr><td><code id="post_toot_+3A_spoiler_text">spoiler_text</code></td>
<td>
<p>character, text to be shown as a warning or subject before the actual content. Statuses are generally collapsed behind this field.</p>
</td></tr>
<tr><td><code id="post_toot_+3A_visibility">visibility</code></td>
<td>
<p>character, Visibility of the posted status. One of public (default), unlisted, private, direct.</p>
</td></tr>
<tr><td><code id="post_toot_+3A_scheduled_at">scheduled_at</code></td>
<td>
<p>ISO 8601 Datetime at which to schedule a status. Must be at least 5 minutes in the future.</p>
</td></tr>
<tr><td><code id="post_toot_+3A_language">language</code></td>
<td>
<p>ISO 639 language code for this status.</p>
</td></tr>
<tr><td><code id="post_toot_+3A_verbose">verbose</code></td>
<td>
<p>logical whether to display messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value, called for site effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# post a simple status
post_toot("my first rtoot #rstats")
# post a media file with alt text
post_toot("look at this pic", media = "path/to/image", alt_text = "describe image")

## End(Not run)
</code></pre>

<hr>
<h2 id='post_user'>Perform actions on an account</h2><span id='topic+post_user'></span>

<h3>Description</h3>

<p>Perform actions on an account
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_user(id, action = "follow", comment = "", token = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post_user_+3A_id">id</code></td>
<td>
<p>character, user id to perform the action on</p>
</td></tr>
<tr><td><code id="post_user_+3A_action">action</code></td>
<td>
<p>character, one of &quot;(un)follow&quot;,&quot;(un)block&quot;, &quot;(un)mute&quot;, &quot;(un)pin&quot;,&quot;note&quot;</p>
</td></tr>
<tr><td><code id="post_user_+3A_comment">comment</code></td>
<td>
<p>character (if action=&quot;note&quot;), The comment to be set on that user. Provide an empty string or leave out this parameter to clear the currently set note.</p>
</td></tr>
<tr><td><code id="post_user_+3A_token">token</code></td>
<td>
<p>user bearer token (read from file by default)</p>
</td></tr>
<tr><td><code id="post_user_+3A_verbose">verbose</code></td>
<td>
<p>logical whether to display messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value, called for site effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# follow a user
post_user("xxxxxx", action = "follow")
# unfollow a user
post_user("xxxxxx", action = "unfollow")

## End(Not run)
</code></pre>

<hr>
<h2 id='rtoot'>Query Mastodon API</h2><span id='topic+rtoot'></span>

<h3>Description</h3>

<p>This is a minimalistic interface for querying the Mastodon API. This function is for advanced users who want to query
the Mastodon API for endpoints that the R functions are not yet implemented.
Please also note that the API responses will not be parsed as tibble. Refer to the official API documentation for endpoints and parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtoot(
  endpoint,
  ...,
  params = list(),
  token = NULL,
  instance = NULL,
  anonymous = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtoot_+3A_endpoint">endpoint</code></td>
<td>
<p>character, a Mastodon API endpoint. Currently, only endpoints using GET are supported</p>
</td></tr>
<tr><td><code id="rtoot_+3A_...">...</code></td>
<td>
<p>Name-value pairs giving API parameters.</p>
</td></tr>
<tr><td><code id="rtoot_+3A_params">params</code></td>
<td>
<p>list, API parameters to be submitted</p>
</td></tr>
<tr><td><code id="rtoot_+3A_token">token</code></td>
<td>
<p>user bearer token (read from file by default)</p>
</td></tr>
<tr><td><code id="rtoot_+3A_instance">instance</code></td>
<td>
<p>character, the server name of the instance where the status is located. If <code>NULL</code>, the same instance used to obtain the token is used.</p>
</td></tr>
<tr><td><code id="rtoot_+3A_anonymous">anonymous</code></td>
<td>
<p>some API calls do not need a token. Setting anonymous to TRUE allows to make an anonymous call if possible.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list
</p>


<h3>References</h3>

<p>https://docs.joinmastodon.org/methods/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rtoot(endpoint = "api/v1/notifications")
rtoot(endpoint = "api/v1/notifications", limit = 8)
## same
rtoot(endpoint = "api/v1/notifications", params = list(limit = 8))
rtoot(endpoint = "api/v1/followed_tags")
## reimplement `get_timeline_public`
rtoot(endpoint = "api/v1/timelines/public", instance = "emacs.ch", local = TRUE, anonymous = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='rtoot-package'>rtoot: Collect Mastodon data from R</h2><span id='topic+rtoot-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>rtoots provides a range of functions to interact with the Mastodon API.
It has five main groups of functions:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;get_account_&lt;type&gt;()&#8288;</code> to get account level data
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;get_timeline_&lt;type&gt;()&#8288;</code> to get series of statuses
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;get_instance_&lt;type&gt;()&#8288;</code> get information for Mastodon instances
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;stream_&lt;type&gt;()&#8288;</code> to stream statuses from different timeline
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;post_&lt;type&gt;()&#8288;</code> to push content to Mastodon from R
</p>
</li></ul>

<p>(Some auxiliary functions do not follow this naming scheme)
</p>
<p>Get started by reading <code>vignette("rtoot")</code>. and browse all vignettes with <code>browseVignettes(package = "rtoot")</code>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: David Schoch <a href="mailto:david@schochastics.net">david@schochastics.net</a> (<a href="https://orcid.org/0000-0003-2952-4812">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Chung-hong Chan <a href="mailto:chainsawtiney@gmail.com">chainsawtiney@gmail.com</a> (<a href="https://orcid.org/0000-0002-6232-7530">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Johannes Gruber <a href="mailto:JohannesB.Gruber@gmail.com">JohannesB.Gruber@gmail.com</a> (<a href="https://orcid.org/0000-0001-9177-1772">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://gesistsa.github.io/rtoot/">https://gesistsa.github.io/rtoot/</a>
</p>
</li>
<li> <p><a href="https://github.com/gesistsa/rtoot/">https://github.com/gesistsa/rtoot/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/gesistsa/rtoot/issues">https://github.com/gesistsa/rtoot/issues</a>
</p>
</li></ul>


<hr>
<h2 id='save_auth_rtoot'>save a bearer token to file</h2><span id='topic+save_auth_rtoot'></span>

<h3>Description</h3>

<p>save a bearer token to file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_auth_rtoot(token, name = NULL, path = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_auth_rtoot_+3A_token">token</code></td>
<td>
<p>bearer token created with <a href="#topic+create_token">create_token</a></p>
</td></tr>
<tr><td><code id="save_auth_rtoot_+3A_name">name</code></td>
<td>
<p>A file name (if you want to store more than one token).</p>
</td></tr>
<tr><td><code id="save_auth_rtoot_+3A_path">path</code></td>
<td>
<p>A path where the token is stored.</p>
</td></tr>
</table>

<hr>
<h2 id='search_accounts'>Search the instance for a specific user</h2><span id='topic+search_accounts'></span>

<h3>Description</h3>

<p>Search the instance for a specific user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_accounts(
  query,
  limit = 40,
  token = NULL,
  anonymous = FALSE,
  parse = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_accounts_+3A_query">query</code></td>
<td>
<p>character, search string</p>
</td></tr>
<tr><td><code id="search_accounts_+3A_limit">limit</code></td>
<td>
<p>number of search results to return. Defaults to 40</p>
</td></tr>
<tr><td><code id="search_accounts_+3A_token">token</code></td>
<td>
<p>user bearer token (read from file by default)</p>
</td></tr>
<tr><td><code id="search_accounts_+3A_anonymous">anonymous</code></td>
<td>
<p>some API calls do not need a token. Setting anonymous to TRUE allows to make an anonymous call if possible.</p>
</td></tr>
<tr><td><code id="search_accounts_+3A_parse">parse</code></td>
<td>
<p>logical, if <code>TRUE</code>, the default, returns a tibble. Use <code>FALSE</code>  to return the &quot;raw&quot; list corresponding to the JSON returned from the Mastodon API.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble ir list of accounts
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
search_accounts("schochastics")

## End(Not run)
</code></pre>

<hr>
<h2 id='stream_timeline'>Collect live streams of Mastodon data</h2><span id='topic+stream_timeline'></span><span id='topic+stream_timeline_public'></span><span id='topic+stream_timeline_hashtag'></span><span id='topic+stream_timeline_list'></span>

<h3>Description</h3>

<p>Collect live streams of Mastodon data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stream_timeline_public(
  timeout = 30,
  local = FALSE,
  file_name = NULL,
  append = TRUE,
  instance = NULL,
  token = NULL,
  anonymous = FALSE,
  verbose = TRUE
)

stream_timeline_hashtag(
  hashtag = "rstats",
  timeout = 30,
  local = FALSE,
  file_name = NULL,
  append = TRUE,
  instance = NULL,
  token = NULL,
  anonymous = FALSE,
  verbose = TRUE
)

stream_timeline_list(
  list_id,
  timeout = 30,
  file_name = NULL,
  append = TRUE,
  instance = NULL,
  token = NULL,
  anonymous = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stream_timeline_+3A_timeout">timeout</code></td>
<td>
<p>Integer, Number of seconds to stream toots for. Stream indefinitely with timeout = Inf. The stream can be interrupted at any time, and file_name will still be a valid file.</p>
</td></tr>
<tr><td><code id="stream_timeline_+3A_local">local</code></td>
<td>
<p>logical, Show only local statuses (either statuses from your instance or the one provided in <code>instance</code>)?</p>
</td></tr>
<tr><td><code id="stream_timeline_+3A_file_name">file_name</code></td>
<td>
<p>character, name of file. If not specified, will write to a temporary file stream_toots*.json.</p>
</td></tr>
<tr><td><code id="stream_timeline_+3A_append">append</code></td>
<td>
<p>logical, if TRUE will append to the end of file_name; if FALSE, will overwrite.</p>
</td></tr>
<tr><td><code id="stream_timeline_+3A_instance">instance</code></td>
<td>
<p>character, the server name of the instance where the status is located. If <code>NULL</code>, the same instance used to obtain the token is used.</p>
</td></tr>
<tr><td><code id="stream_timeline_+3A_token">token</code></td>
<td>
<p>user bearer token (read from file by default)</p>
</td></tr>
<tr><td><code id="stream_timeline_+3A_anonymous">anonymous</code></td>
<td>
<p>logical, should the API call be made anonymously? Defaults to TRUE but some instances might need authentication here</p>
</td></tr>
<tr><td><code id="stream_timeline_+3A_verbose">verbose</code></td>
<td>
<p>logical whether to display messages</p>
</td></tr>
<tr><td><code id="stream_timeline_+3A_hashtag">hashtag</code></td>
<td>
<p>character, hashtag to stream</p>
</td></tr>
<tr><td><code id="stream_timeline_+3A_list_id">list_id</code></td>
<td>
<p>character, id of list to stream</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>stream_timeline_public</dt><dd><p>stream all public statuses on any instance</p>
</dd>
<dt>stream_timeline_hashtag</dt><dd><p>stream all statuses containing a specific hashtag</p>
</dd>
<dt>stream_timeline_list</dt><dd><p>stream the statuses of a list</p>
</dd>
</dl>



<h3>Value</h3>

<p>does not return anything. Statuses are written to file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# stream public timeline for 30 seconds
stream_timeline_public(timeout = 30, file_name = "public.json")
# stream timeline of mastodon.social  for 30 seconds
stream_timeline_public(
    timeout = 30, local = TRUE,
    instance = "mastodon.social", file_name = "social.json"
)

# stream hashtag timeline for 30 seconds
stream_timeline_hashtag("rstats", timeout = 30, file_name = "rstats_public.json")
# stream hashtag timeline of mastodon.social  for 30 seconds
stream_timeline_hashtag("rstats",
    timeout = 30, local = TRUE,
    instance = "fosstodon.org", file_name = "rstats_foss.json"
)
# json files can be parsed with parse_stream()
parse_stream("rstats_foss.json")

## End(Not run)
</code></pre>

<hr>
<h2 id='verify_credentials'>Verify mastodon credentials</h2><span id='topic+verify_credentials'></span><span id='topic+verify_envvar'></span>

<h3>Description</h3>

<p>Verify mastodon credentials
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verify_credentials(token, verbose = TRUE)

verify_envvar(verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify_credentials_+3A_token">token</code></td>
<td>
<p>bearer token, either public or user level</p>
</td></tr>
<tr><td><code id="verify_credentials_+3A_verbose">verbose</code></td>
<td>
<p>logical whether to display messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you have created your token as an environment variable, use <code>verify_envvar</code> to verify your token.
</p>


<h3>Value</h3>

<p>Raise an error if the token is not valid. Return the response from the verification API invisibly otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# read a token from a file
verify_credentials(token)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
