<!DOCTYPE html><html lang="en"><head><title>Help for package spMC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spMC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#spMC-package'><p>Continuous Lag Spatial Markov Chains</p></a></li>
<li><a href='#ACM'><p>ACM Data</p></a></li>
<li><a href='#boxplot.lengths'><p>Stratum Lengths Boxplot</p></a></li>
<li><a href='#contour.pemt'><p>Display Contours with Multi-directional Transiograms</p></a></li>
<li><a href='#density.lengths'><p>Empirical Densities Estimation of Stratum Lengths</p></a></li>
<li><a href='#embed_MC'><p>Transition Probabilities Estimation for Embedded Markov Chain</p></a></li>
<li><a href='#getlen'><p>Estimation of Stratum Lengths for Embedded Markov Chain</p></a></li>
<li><a href='#hist.lengths'><p>Histograms of Stratum Lengths for Each Observed Category</p></a></li>
<li><a href='#image.multi_tpfit'><p>Images with Multidimensional Transiograms</p></a></li>
<li><a href='#image.pemt'><p>Images with Multi-directional Transiograms</p></a></li>
<li><a href='#is.lengths'><p>Object test for lengths class</p></a></li>
<li><a href='#is.multi_tpfit'><p>Object test for multi_tpfit class</p></a></li>
<li><a href='#is.multi_transiogram'><p>Object test for multi_transiogram class</p></a></li>
<li><a href='#is.pemt'><p>Images with Multi-direct'ional Transiograms</p></a></li>
<li><a href='#is.tpfit'><p>Object test for tpfit class</p></a></li>
<li><a href='#is.transiogram'><p>Object test for transiogram class</p></a></li>
<li><a href='#mixplot'><p>Plot of Multiple One-dimensional Transiograms</p></a></li>
<li><a href='#mlen'><p>Mean Length Estimation for Embedded Markov Chain</p></a></li>
<li><a href='#multi_tpfit'><p>Multidimensional Model Parameters Estimation</p></a></li>
<li><a href='#multi_tpfit_ils'><p>Iterated Least Squares Method for Multidimensional Model Parameters Estimation</p></a></li>
<li><a href='#multi_tpfit_me'><p>Maximum Entropy Method for Multidimensional Model Parameters Estimation</p></a></li>
<li><a href='#multi_tpfit_ml'><p>Mean Length Method for Multidimensional Model Parameters Estimation</p></a></li>
<li><a href='#pemt'><p>Multi-directional Transiograms Estimation</p></a></li>
<li><a href='#persp.multi_tpfit'><p>Perspective Plots with Multidimensional Transiograms</p></a></li>
<li><a href='#persp.pemt'><p>Perspective Plots with Multi-directional Transiograms</p></a></li>
<li><a href='#plot.density.lengths'><p>Plot Empirical Densities Estimates of Stratum Lengths</p></a></li>
<li><a href='#plot.hist.lengths'><p>Plot Histograms of Stratum Lengths</p></a></li>
<li><a href='#plot.lengths'><p>Plot Stratum Lengths</p></a></li>
<li><a href='#plot.transiogram'><p>Plot One-dimensional Transiograms</p></a></li>
<li><a href='#predict.multi_tpfit'><p>Compute Theoretical Multidimensional Transiograms</p></a></li>
<li><a href='#predict.tpfit'><p>Compute Theoretical One-dimensional Transiograms</p></a></li>
<li><a href='#print.density.lengths'><p>Printing Empirical Densities Estimates of Stratum Lengths</p></a></li>
<li><a href='#print.lengths'><p>Printing Stratum Lengths for Each Observed Category</p></a></li>
<li><a href='#print.multi_tpfit'><p>Printing Model Parameters for Multidimensional Continuous Lag Spatial MC</p></a></li>
<li><a href='#print.multi_transiogram'><p>Printing Theoretical Multidimensional Transiograms</p></a></li>
<li><a href='#print.summary.lengths'><p>Printing Stratum Lengths Summary for Each Observed Category</p></a></li>
<li><a href='#print.tpfit'><p>Printing Model Parameters for One-dimensional Continuous Lag Spatial MC</p></a></li>
<li><a href='#print.transiogram'><p>Printing Theoretical or Empirical One-dimensional Transiograms</p></a></li>
<li><a href='#quench'><p>Conditional Simulation Adjuster Via Quenching Algorithm</p></a></li>
<li><a href='#setCores'><p>Set the number of CPU cores for HPC</p></a></li>
<li><a href='#sim'><p>Random Field Simulation</p></a></li>
<li><a href='#sim_ck'><p>Conditional Simulation Based on Indicator Cokriging</p></a></li>
<li><a href='#sim_ik'><p>Conditional Simulation Based on Indicator Kriging</p></a></li>
<li><a href='#sim_mcs'><p>Multinomial Categorical Simulation</p></a></li>
<li><a href='#sim_path'><p>Conditional Simulation Based on Path Algorithms</p></a></li>
<li><a href='#summary.lengths'><p>Summarizing Stratum Lengths</p></a></li>
<li><a href='#tpfit'><p>One-dimensional Model Parameters Estimation</p></a></li>
<li><a href='#tpfit_ils'><p>Iterated Least Squares Method for One-dimensional Model Parameters Estimation</p></a></li>
<li><a href='#tpfit_me'><p>Maximum Entropy Method for One-dimensional Model Parameters Estimation</p></a></li>
<li><a href='#tpfit_ml'><p>Mean Length Method for One-dimensional Model Parameters Estimation</p></a></li>
<li><a href='#transiogram'><p>Empirical Transition Probabilities Estimation for 1-D MC</p></a></li>
<li><a href='#which_lines'><p>Points Classification through Directional Lines</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Continuous-Lag Spatial Markov Chains</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.15</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-30</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luca Sartore &lt;drwolf85@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of functions is provided for 1) the stratum lengths analysis along a chosen direction, 2) fast estimation of continuous lag spatial Markov chains model parameters and probability computing (also for large data sets), 3) transition probability maps and transiograms drawing, 4) simulation methods for categorical random fields. More details on the methodology are discussed in Sartore (2013) &lt;<a href="https://doi.org/10.32614%2FRJ-2013-022">doi:10.32614/RJ-2013-022</a>&gt; and Sartore et al. (2016) &lt;<a href="https://doi.org/10.1016%2Fj.cageo.2016.06.001">doi:10.1016/j.cageo.2016.06.001</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), base, methods, datasets, utils, grDevices,
graphics, stats</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-30 22:45:03 UTC; sartore</td>
</tr>
<tr>
<td>Author:</td>
<td>Luca Sartore <a href="https://orcid.org/0000-0002-0446-1328"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-03 04:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='spMC-package'>Continuous Lag Spatial Markov Chains</h2><span id='topic+spMC-package'></span><span id='topic+spMC'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.svg" style='float:right;' alt="logo.svg" />
The main goal of this package is to provide a set of functions for
</p>

<ol>
<li><p> the stratum lengths analysis along a chosen direction,
</p>
</li>
<li><p> fast estimation of continuous lag spatial Markov chains model parameters and probability computing (also for large data sets), 
</p>
</li>
<li><p> transition probability maps and transiograms drawing, 
</p>
</li>
<li><p> simulation methods for categorical random fields.
</p>
</li></ol>



<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> spMC</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.3.15</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-04-30</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Several functions are available for the stratum lengths analysis, in particular they compute the stratum lengths for each stratum category, they compute the empirical distributions and many other tools for a graphical analysis.
</p>
<p>Usually, the basic inputs for the most of the functions are a vector of categorical data and their location coordinates. They are used to estimate empirical transition probabilities (<a href="#topic+transiogram">transiogram</a>), to estimate model parameters (<a href="#topic+tpfit">tpfit</a> for one-dimensional Markov chains or <a href="#topic+multi_tpfit">multi_tpfit</a> for multidimensional Markov chains). Once parameters are estimated, it's possible to compute theoretical transition probabilities by the use of the function <a href="#topic+predict.tpfit">predict.tpfit</a> for one-dimensional Markov chains and <a href="#topic+predict.multi_tpfit">predict.multi_tpfit</a> for multidimensional ones.
</p>
<p>The function <a href="#topic+plot.transiogram">plot.transiogram</a> allows to plot one-dimensional transiograms, while <a href="#topic+image.multi_tpfit">image.multi_tpfit</a> permit to draw transition probability maps. A powerful tool to explore graphically the anisotropy of such process is given by the functions <a href="#topic+pemt">pemt</a> and <a href="#topic+image.pemt">image.pemt</a>, which let the user to draw &quot;quasi-empirical&quot; transition probability maps.
</p>
<p>Simulation methods are based on Indicator Kriging (<a href="#topic+sim_ik">sim_ik</a>), Indicator Cokriging (<a href="#topic+sim_ck">sim_ck</a>), Fixed or Random Path algorithms (<a href="#topic+sim_path">sim_path</a>) and Multinomial Categorical Simulation technique (<a href="#topic+sim_mcs">sim_mcs</a>).
</p>


<h3>Author(s)</h3>

<p>Luca Sartore
</p>
<p>Maintainer: Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a>
</p>


<h3>References</h3>

<p>Allard, D., D'Or, D., Froidevaux, R. (2011) An efficient maximum entropy approach for categorical variable prediction. <em>European Journal of Soil Science</em>, <b>62</b>(3), 381-393.
</p>
<p>Carle, S. F., Fogg, G. E. (1997) Modelling Spatial Variability with One and Multidimensional Continuous-Lag Markov Chains. <em>Mathematical Geology</em>, <b>29</b>(7), 891-918.
</p>
<p>Dynkin, E. B. (1961) <em>Theory of Markov Processes</em>. Englewood Cliffs, N.J.: Prentice-Hall, Inc.
</p>
<p>Higham, N. J. (2008) <em>Functions of Matrices: Theory and Computation</em>. Society for Industrial and Applied Mathematics.
</p>
<p>Li, W. (2007) A Fixed-Path Markov Chain Algorithm for Conditional Simulation of Discrete Spatial Variables. <em>Mathematical Geology</em>, <b>39</b>(2), 159-176.
</p>
<p>Li, W. (2007) Markov Chain Random Fields for Estimation of Categorical Variables. <em>Mathematical Geology</em>, <b>39</b>(June), 321-335.
</p>
<p>Li, W. (2007) Transiograms for Characterizing Spatial Variability of Soil Classes. <em>Soil Science Society of America Journal</em>, <b>71</b>(3), 881-893.
</p>
<p>Pickard, D. K. (1980) Unilateral Markov Fields. <em>Advances in Applied Probability</em>, <b>12</b>(3), 655-671.
</p>
<p>Sartore, L. (2010) Geostatistical models for 3-D data. M.Phil. thesis, Ca' Foscari University of Venice.
</p>
<p>Sartore, L. (2013). spMC: Modelling Spatial Random Fields with Continuous Lag Markov Chains. <em>The R Journal</em>, <b>5</b>(2), 16-28.
</p>
<p>Sartore, L., Fabbri, P. and Gaetan, C. (2016). spMC: an R-package for 3D lithological reconstructions based on spatial Markov chains. <em>Computers &amp; Geosciences</em>, <b>94</b>(September), 40-47.
</p>
<p>Weise, T. (2009) <em>Global Optimization Algorithms - Theory and Application</em>. <a href="https://archive.org/details/Thomas_Weise__Global_Optimization_Algorithms_Theory_and_Application">https://archive.org/details/Thomas_Weise__Global_Optimization_Algorithms_Theory_and_Application</a>.
</p>

<hr>
<h2 id='ACM'>ACM Data</h2><span id='topic+ACM'></span>

<h3>Description</h3>

<p>The data set refers to a sampled area which is located in the province of Venice. Its sample units report the geographical position of the perforation, the depth, the ground permeability and other two categorical variables which denote the soil composition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ACM)</code></pre>


<h3>Format</h3>

<p>A data frame with 2321 observations on the following 6 variables.
</p>

<dl>
<dt><code>X</code></dt><dd><p>a numeric vector (longitude)</p>
</dd>
<dt><code>Y</code></dt><dd><p>a numeric vector (latitude)</p>
</dd>
<dt><code>Z</code></dt><dd><p>a numeric vector (depth)</p>
</dd>
<dt><code>MAT5</code></dt><dd><p>a factor with levels <code>Clay</code>, <code>Gravel</code>, <code>Mix of Sand and Clay</code>, <code>Mix of Sand and Gravel</code> and <code>Sand</code></p>
</dd>
<dt><code>MAT3</code></dt><dd><p>a factor with levels <code>Clay</code>, <code>Gravel</code> and <code>Sand</code></p>
</dd>
<dt><code>PERM</code></dt><dd><p>a logical vector (symmetric dichotomous variable)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Fabbri, P. (2010) Professor at the Geosciences Department of the University of Padua.<br /><a href="mailto:paolo.fabbri@unipd.it">paolo.fabbri@unipd.it</a></p>


<h3>References</h3>

<p>Sartore, L. (2010) Geostatistical models for 3-D data. M.Phil. thesis, Ca' Foscari University of Venice.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)
str(ACM)
summary(ACM)
</code></pre>

<hr>
<h2 id='boxplot.lengths'>Stratum Lengths Boxplot</h2><span id='topic+boxplot.lengths'></span>

<h3>Description</h3>

<p>Produce box-and-whisker plots of the stratum lengths.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lengths'
boxplot(x, ..., log = FALSE, zeros.rm = TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boxplot.lengths_+3A_x">x</code></td>
<td>
<p>an object of the class <code>lengths</code>, typically with the output of the function <code><a href="#topic+getlen">getlen</a></code>.</p>
</td></tr>
<tr><td><code id="boxplot.lengths_+3A_...">...</code></td>
<td>
<p>other arguments to pass to the function <code><a href="graphics.html#topic+boxplot">boxplot</a></code>.</p>
</td></tr>
<tr><td><code id="boxplot.lengths_+3A_log">log</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the logarithm of the stratum lengths will be plotted. It is <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="boxplot.lengths_+3A_zeros.rm">zeros.rm</code></td>
<td>
<p>a logical value. If <code>FALSE</code>, the box-and-whisker will be drawn by including zero values. It is <code>TRUE</code> by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The box-and-whisker plots give some information about the distribution of the stratum lengths for the observed categories along a given direction.</p>


<h3>Value</h3>

<p>An image is produced on the current graphics device. The function returns a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>stats</code></td>
<td>
<p>a matrix containing the values used to plot the box-and-whisker plots.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>a vector with the number of observations for each category.</p>
</td></tr>
<tr><td><code>conf</code></td>
<td>
<p>a matrix containing further values to draw the lower and upper extremes of the notch.</p>
</td></tr>
<tr><td><code>out</code></td>
<td>
<p>a vectors with the values of the outlier points.</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>a vector whose elements indicate to which category the outlier belongs.</p>
</td></tr>
<tr><td><code>names</code></td>
<td>
<p>a character vector with the names of each category.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.lengths">plot.lengths</a></code>, <code><a href="graphics.html#topic+boxplot">boxplot</a></code>, <code><a href="#topic+getlen">getlen</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)
direction &lt;- c(0,0,1)

# Compute the appertaining directional line for each location
loc.id &lt;- which_lines(ACM[, 1:3], direction)

# Estimate stratum lengths
gl &lt;- getlen(ACM$MAT3, ACM[, 1:3], loc.id, direction)

# Make the boxplot of the object gl

boxplot(gl)
</code></pre>

<hr>
<h2 id='contour.pemt'>Display Contours with Multi-directional Transiograms</h2><span id='topic+contour.pemt'></span>

<h3>Description</h3>

<p>The function draws the <code class="reqn">2</code>-D sections contour plots of a multi-directional transiogram computed without any ellipsoidal interpolation and superpose the contour lines of the theoretical transition probabilities.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pemt'
contour(x, nlevels = 10, col = c("black", "blue"), main,
     mar, ask = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contour.pemt_+3A_x">x</code></td>
<td>
<p>an object of class <code>pemt</code>.</p>
</td></tr>
<tr><td><code id="contour.pemt_+3A_nlevels">nlevels</code></td>
<td>
<p>the number of levels to pass to the function <code><a href="graphics.html#topic+contour">contour</a></code>.</p>
</td></tr>
<tr><td><code id="contour.pemt_+3A_col">col</code></td>
<td>
<p>a vector of two colors to pass to the function <code><a href="graphics.html#topic+contour">contour</a></code>. The former color refers to the multi-directional transiogram, while the latter is used to draw contour lines of the theoretical transition probabilities.</p>
</td></tr>
<tr><td><code id="contour.pemt_+3A_main">main</code></td>
<td>
<p>the main title (on top) whose font and size are fixed.</p>
</td></tr>
<tr><td><code id="contour.pemt_+3A_mar">mar</code></td>
<td>
<p>a scalar or a numerical vector of the form <code>c(bottom, left, top, right)</code> which gives the number of margin lines to be specified on the four sides of image to plot. See <code><a href="graphics.html#topic+par">par</a></code>(<code>mar=</code>.).</p>
</td></tr>
<tr><td><code id="contour.pemt_+3A_ask">ask</code></td>
<td>
<p>a logical value; if <code>TRUE</code>, the user is asked for input, before each plot. See <code><a href="graphics.html#topic+par">par</a></code>(ask=.).</p>
</td></tr>
<tr><td><code id="contour.pemt_+3A_...">...</code></td>
<td>
<p>other arguments to pass to the function <code><a href="graphics.html#topic+contour">contour</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A multidimensional transiogram is a diagram which shows the transition probabilities for a single pair of categories. The probability is computed for any lag vector <code class="reqn">h</code> through 
</p>
<p style="text-align: center;"><code class="reqn">\mbox{expm} (\Vert h \Vert R_h),</code>
</p>

<p>where entries of <code class="reqn">R_h</code> are not ellipsoidally interpolated, but they are estimated for the direction specified by the vector <code class="reqn">h</code>.
</p>
<p>The exponential matrix is evaluated by the scaling and squaring algorithm.
</p>


<h3>Value</h3>

<p>An image is produced on the current graphics device. No values are returned.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>Carle, S. F., Fogg, G. E. (1997) Modelling Spatial Variability with One and Multidimensional Continuous-Lag Markov Chains. <em>Mathematical Geology</em>, <b>29</b>(7), 891-918.
</p>
<p>Higham, N. J. (2008) <em>Functions of Matrices: Theory and Computation</em>. Society for Industrial and Applied Mathematics.
</p>
<p>Sartore, L. (2010) Geostatistical models for 3-D data. M.Phil. thesis, Ca' Foscari University of Venice.</p>


<h3>See Also</h3>

<p><code><a href="#topic+image.pemt">image.pemt</a></code>, <code><a href="graphics.html#topic+contour">contour</a></code>, <code><a href="#topic+plot.transiogram">plot.transiogram</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Compute a 2-D section of a 
# multi-directional transiogram
psEmpTr &lt;- pemt(ACM$MAT3, ACM[, 1:3], 2,
                max.dist = c(200, 200, 20), 
                which.dire=c(1, 3), 
                mle = "avg")

# Contour plots of 2-D sections of 
# multi-directional transiograms
contour(psEmpTr, mar = .7)
</code></pre>

<hr>
<h2 id='density.lengths'>Empirical Densities Estimation of Stratum Lengths</h2><span id='topic+density.lengths'></span>

<h3>Description</h3>

<p>The function estimates the empirical conditional density of the stratum lengths given the category.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lengths'
density(x, ..., log = FALSE, zeros.rm = TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="density.lengths_+3A_x">x</code></td>
<td>
<p>an object of the class <code>lengths</code>, typically with the output of the function <code><a href="#topic+getlen">getlen</a></code>.</p>
</td></tr>
<tr><td><code id="density.lengths_+3A_...">...</code></td>
<td>
<p>other arguments to pass to the function <code><a href="stats.html#topic+density.default">density.default</a></code>.</p>
</td></tr>
<tr><td><code id="density.lengths_+3A_log">log</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the output density will be calculated for the logarithm of the lengths. It is <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="density.lengths_+3A_zeros.rm">zeros.rm</code></td>
<td>
<p>a logical value. If <code>FALSE</code>, the density will be estimated by including zero values. It is <code>TRUE</code> by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function estimates the empirical density of the stratum lengths for each category by the use of the kernel methodology.</p>


<h3>Value</h3>

<p>An object of class <code>density.lengths</code> is returned. It contains objects of class <code>density</code>, the given direction of the stratum lengths and a logical value which points out if the density is computed for the logarithm of stratum lengths.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>Simonoff, J. S. (1996) <em>Smoothing Methods in Statistics</em>. Springer-Verlag.</p>


<h3>See Also</h3>

<p><code><a href="#topic+getlen">getlen</a></code>, <code><a href="stats.html#topic+density.default">density.default</a></code>, <code><a href="#topic+plot.density.lengths">plot.density.lengths</a></code>, <code><a href="#topic+print.density.lengths">print.density.lengths</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)
direction &lt;- c(0,0,1)
     
# Compute the appertaining directional line for each location
loc.id &lt;- which_lines(ACM[, 1:3], direction)
     
# Estimate stratum lengths
gl &lt;- getlen(ACM$MAT3, ACM[, 1:3], loc.id, direction)

# Compute the empirical densities of stratum lengths
dgl &lt;- density(gl)
</code></pre>

<hr>
<h2 id='embed_MC'>Transition Probabilities Estimation for Embedded Markov Chain</h2><span id='topic+embed_MC'></span>

<h3>Description</h3>

<p>The function estimates the embedded transition probabilities matrix for a <code class="reqn">1</code>-D spatial embedded Markov chain.</p>


<h3>Usage</h3>

<pre><code class='language-R'>embed_MC(data, coords, loc.id, direction)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="embed_MC_+3A_data">data</code></td>
<td>
<p>a categorical data vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="embed_MC_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times d</code> matrix where each row denotes the <code class="reqn">d</code>-D coordinates of data locations.</p>
</td></tr>
<tr><td><code id="embed_MC_+3A_loc.id">loc.id</code></td>
<td>
<p>a vector of <code class="reqn">n</code> values which indicats the directional line of each location. It is usually the output of the function <code><a href="#topic+which_lines">which_lines</a></code>.</p>
</td></tr>
<tr><td><code id="embed_MC_+3A_direction">direction</code></td>
<td>
<p>a <code class="reqn">d</code>-D numerical vector (or versor) which represents the chosen direction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An embedded Markov chain is probabilistic model which defines the transition probabilities between embedded occurrences. 
</p>
<p>The resulting matrix is given by normalizing a transition count matrix, which doesn't depend on the length of embedded occurrences. Self-transitions of embedded occurrences are not observable, so diagonal entries are set to be <code>NA</code>.
</p>
<p>It's also possible to calculate the transition probabilities matrix for several directions in a <code class="reqn">d</code>-D space through arguments <code>direction</code> and <code>loc.id</code>. If the user has no previous knowledge about <code>loc.id</code>, the function <code><a href="#topic+which_lines">which_lines</a></code> provides a method to compute the right values.
</p>


<h3>Value</h3>

<p>A <code class="reqn">K \times K</code> transition probability matrix, where <code class="reqn">K</code> denotes the number of observed categories. Another <code class="reqn">K \times K</code> matrix with the counts of transitions is attached as an attribute.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>Carle, S. F., Fogg, G. E. (1997) Modelling Spatial Variability with One and Multidimensional Continuous-Lag Markov Chains. <em>Mathematical Geology</em>, <b>29</b>(7), 891-918.
</p>
<p>Dynkin, E. B. (1961) <em>Theory of Markov Processes. Englewood Cliffs</em>, N.J.: Prentice-Hall, Inc.
</p>
<p>Sartore, L. (2010) Geostatistical models for 3-D data. M.Phil. thesis, Ca' Foscari University of Venice.</p>


<h3>See Also</h3>

<p><code><a href="#topic+which_lines">which_lines</a></code>, <code><a href="#topic+predict.tpfit">predict.tpfit</a></code>, <code><a href="#topic+predict.multi_tpfit">predict.multi_tpfit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)
direction &lt;- c(0, 0, 1)

# Compute the appertaining directional line for each location
loc.id &lt;- which_lines(ACM[, 1:3], direction, pi/8)

# Estimate the embedded transition probabilities
# matrix for the categorical variable MAT5
embed_MC(ACM$MAT5, ACM[, 1:3], loc.id, direction)

# Estimate the embedded transition probabilities
# matrix for the categorical variable MAT3
embed_MC(ACM$MAT3, ACM[, 1:3], loc.id, direction)

# Estimate the embedded transition probabilities
# matrix for the categorical variable PERM
embed_MC(ACM$PERM, ACM[, 1:3], loc.id, direction)
</code></pre>

<hr>
<h2 id='getlen'>Estimation of Stratum Lengths for Embedded Markov Chain</h2><span id='topic+getlen'></span>

<h3>Description</h3>

<p>The function estimates the stratum lengths for a <code class="reqn">d</code>-D spatial embedded Markov chain for a specified direction <code class="reqn">\phi</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getlen(data, coords, loc.id, direction, zero.allowed = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getlen_+3A_data">data</code></td>
<td>
<p>a categorical data vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="getlen_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times d</code> matrix where each row denotes the <code class="reqn">d</code>-D coordinates of data locations.</p>
</td></tr>
<tr><td><code id="getlen_+3A_loc.id">loc.id</code></td>
<td>
<p>a vector of <code class="reqn">n</code> values which indicates the directional line of each location. It is usually the output of the function <code><a href="#topic+which_lines">which_lines</a></code>.</p>
</td></tr>
<tr><td><code id="getlen_+3A_direction">direction</code></td>
<td>
<p>a <code class="reqn">d</code>-D numerical vector (or versor) which represents the chosen direction.</p>
</td></tr>
<tr><td><code id="getlen_+3A_zero.allowed">zero.allowed</code></td>
<td>
<p>a logical value which allows to return zero stratum lengths. It is <code>FALSE</code> by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Stratum lengths are the lengths occupied by the same <code class="reqn">k</code>-th category along lines in the direction <code class="reqn">\phi</code>.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>length</code></td>
<td>
<p>a numerical vector with the stratum lengths along the given direction.</p>
</td></tr>
<tr><td><code>categories</code></td>
<td>
<p>a vector with the stratum categories.</p>
</td></tr>
<tr><td><code>maxcens</code></td>
<td>
<p>a vector with the maxima estimated censored lengths for each stratum.</p>
</td></tr>
<tr><td><code>directions</code></td>
<td>
<p>a <code class="reqn">d</code>-D numerical vector which represents the chosen direction.</p>
</td></tr>
<tr><td><code>zeros</code></td>
<td>
<p>a logical values which denotes the possible presence of zero lengths.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>Carle, S. F., Fogg, G. E. (1997) Modelling Spatial Variability with One and Multidimensional Continuous-Lag Markov Chains. <em>Mathematical Geology</em>, <b>29</b>(7), 891-918.
</p>
<p>Sartore, L. (2010) Geostatistical models for 3-D data. M.Phil. thesis, Ca' Foscari University of Venice.</p>


<h3>See Also</h3>

<p><code><a href="#topic+mlen">mlen</a></code>, <code><a href="#topic+which_lines">which_lines</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)
direction &lt;- c(0,0,1)

# Compute the appertaining directional line for each location
loc.id &lt;- which_lines(ACM[, 1:3], direction)

# Estimate stratum lengths
gl &lt;- getlen(ACM$MAT5, ACM[, 1:3], loc.id, direction)
</code></pre>

<hr>
<h2 id='hist.lengths'>Histograms of Stratum Lengths for Each Observed Category</h2><span id='topic+hist.lengths'></span>

<h3>Description</h3>

<p>The function compute the histograms of the stratum lengths for each category. If <code>plot = TRUE</code>, the resulting object of class <code>hist.lengths</code> is plotted before it is returned.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lengths'
hist(x, ..., log = FALSE, zeros.rm = TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hist.lengths_+3A_x">x</code></td>
<td>
<p>an object of the class <code>lengths</code>, typically with the output of the function <code><a href="#topic+getlen">getlen</a></code>.</p>
</td></tr>
<tr><td><code id="hist.lengths_+3A_...">...</code></td>
<td>
<p>further arguments to pass to the function <code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
<tr><td><code id="hist.lengths_+3A_log">log</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, histograms will be calculated for the logarithm of the lengths. It is <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="hist.lengths_+3A_zeros.rm">zeros.rm</code></td>
<td>
<p>a logical value. If <code>FALSE</code>, histograms will be computed by including zero values. It is <code>TRUE</code> by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>plot = TRUE</code>, an image is produced on the current graphics device. The function returns an object of class <code>hist.lengths</code>. It contains class <code>histogram</code> objects, the given direction of the stratum lengths and a logical value which points out if histograms are computed for the logarithm of stratum lengths.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+getlen">getlen</a></code>, <code><a href="graphics.html#topic+hist">hist</a></code>, <code><a href="#topic+density.lengths">density.lengths</a></code>, <code><a href="#topic+plot.density.lengths">plot.density.lengths</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)
direction &lt;- c(0,0,1)
     
# Compute the appertaining directional line for each location
loc.id &lt;- which_lines(ACM[, 1:3], direction)
     
# Estimate stratum lengths
gl &lt;- getlen(ACM$MAT3, ACM[, 1:3], loc.id, direction)

# Plot the histograms
hist(gl)
</code></pre>

<hr>
<h2 id='image.multi_tpfit'>Images with Multidimensional Transiograms</h2><span id='topic+image.multi_tpfit'></span>

<h3>Description</h3>

<p>The function plots <code class="reqn">2</code>-D sections of a predicted multidimensional transiograms computed through ellipsoidal interpolation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multi_tpfit'
image(x, mpoints, which.dire, max.dist, main,
      mar, ask = TRUE, ..., nlevels = 10, contour = TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="image.multi_tpfit_+3A_x">x</code></td>
<td>
<p>an object of the class <code>multi_tpfit</code>, typically with the output of the function <code><a href="#topic+multi_tpfit">multi_tpfit</a></code>.</p>
</td></tr>
<tr><td><code id="image.multi_tpfit_+3A_mpoints">mpoints</code></td>
<td>
<p>the number of points per axes. It controls the accuracy of images to plot.</p>
</td></tr>
<tr><td><code id="image.multi_tpfit_+3A_which.dire">which.dire</code></td>
<td>
<p>a vector with two chosen axial directions. If omitted, all <code class="reqn">2</code>-D sections are plotted.</p>
</td></tr>
<tr><td><code id="image.multi_tpfit_+3A_max.dist">max.dist</code></td>
<td>
<p>a scalar or a vector of maximum length for the chosen axial directions.</p>
</td></tr>
<tr><td><code id="image.multi_tpfit_+3A_main">main</code></td>
<td>
<p>the main title (on top) whose font and size are fixed.</p>
</td></tr>
<tr><td><code id="image.multi_tpfit_+3A_mar">mar</code></td>
<td>
<p>a scalar or a numerical vector of the form <code>c(bottom, left, top, right)</code> which gives the number of margin lines to be specified on the four sides of image to plot. See <code><a href="graphics.html#topic+par">par</a></code>(<code>mar=</code>.).</p>
</td></tr>
<tr><td><code id="image.multi_tpfit_+3A_ask">ask</code></td>
<td>
<p>a logical value; if <code>TRUE</code>, the user is asked for input, before each plot. See <code><a href="graphics.html#topic+par">par</a></code>(<code>ask=</code>.).</p>
</td></tr>
<tr><td><code id="image.multi_tpfit_+3A_...">...</code></td>
<td>
<p>other arguments to pass to the function <code><a href="graphics.html#topic+image">image</a></code>.</p>
</td></tr>
<tr><td><code id="image.multi_tpfit_+3A_nlevels">nlevels</code></td>
<td>
<p>the number of levels to pass to the function <code><a href="graphics.html#topic+contour">contour</a></code>.</p>
</td></tr>
<tr><td><code id="image.multi_tpfit_+3A_contour">contour</code></td>
<td>
<p>logical. If <code>TRUE</code>, the function <code><a href="graphics.html#topic+contour">contour</a></code> is used to draw contour lines over the image. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A multidimensional transiogram is a diagram which shows the transition probabilities for a single pair of categories. It is computed for any lag vector <code class="reqn">h</code> through 
</p>
<p style="text-align: center;"><code class="reqn">\mbox{expm} (\Vert h \Vert R),</code>
</p>

<p>where entries of <code class="reqn">R</code> are ellipsoidally interpolated (see <code><a href="#topic+multi_tpfit">multi_tpfit</a></code>).
</p>
<p>The exponential matrix is evaluated by the scaling and squaring algorithm.
</p>


<h3>Value</h3>

<p>An image is produced on the current graphics device. No values are returned.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>Carle, S. F., Fogg, G. E. (1997) Modelling Spatial Variability with One and Multidimensional Continuous-Lag Markov Chains. <em>Mathematical Geology</em>, <b>29</b>(7), 891-918.
</p>
<p>Higham, N. J. (2008) <em>Functions of Matrices: Theory and Computation</em>. Society for Industrial and Applied Mathematics.
</p>
<p>Sartore, L. (2010) Geostatistical models for 3-D data. M.Phil. thesis, Ca' Foscari University of Venice.</p>


<h3>See Also</h3>

<p><code><a href="#topic+multi_tpfit">multi_tpfit</a></code>, <code><a href="#topic+pemt">pemt</a></code>, <code><a href="#topic+image.pemt">image.pemt</a></code>, <code><a href="graphics.html#topic+image">image</a></code>, <code><a href="#topic+plot.transiogram">plot.transiogram</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Estimate model parameter
x &lt;- multi_tpfit(ACM$MAT5, ACM[, 1:3])

# Set short names for categories 3 and 4
names(x$prop)[3:4] &lt;- c("Clay and Sand", "Gravel and Sand")

# Plot 2-D theoretical sections of
# a multidimensional transiogram
image(x, 40, max.dist=c(200,200,20), which.dire=2:3,
    mar = .7, col=rev(heat.colors(500)),
    breaks=0:500/500, nlevels = 5)
</code></pre>

<hr>
<h2 id='image.pemt'>Images with Multi-directional Transiograms</h2><span id='topic+image.pemt'></span>

<h3>Description</h3>

<p>The function plots <code class="reqn">2</code>-D sections of a multidirectional transiogram computed without any ellipsoidal interpolation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pemt'
image(x, main, mar, ask = TRUE, ..., 
      nlevels = 10, contour = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="image.pemt_+3A_x">x</code></td>
<td>
<p>an object of class <code>pemt</code>.</p>
</td></tr>
<tr><td><code id="image.pemt_+3A_main">main</code></td>
<td>
<p>the main title (on top) whose font and size are fixed.</p>
</td></tr>
<tr><td><code id="image.pemt_+3A_mar">mar</code></td>
<td>
<p>a scalar or a numerical vector of the form <code>c(bottom, left, top, right)</code> which gives the number of margin lines to be specified on the four sides of image to plot. See <code><a href="graphics.html#topic+par">par</a></code>(<code>mar=</code>.).</p>
</td></tr>
<tr><td><code id="image.pemt_+3A_ask">ask</code></td>
<td>
<p>a logical value; if <code>TRUE</code>, the user is asked for input, before each plot. See <code><a href="graphics.html#topic+par">par</a></code>(ask=.).</p>
</td></tr>
<tr><td><code id="image.pemt_+3A_...">...</code></td>
<td>
<p>other arguments to pass to the function <code><a href="graphics.html#topic+image">image</a></code>.</p>
</td></tr>
<tr><td><code id="image.pemt_+3A_nlevels">nlevels</code></td>
<td>
<p>the number of levels to pass to the function <code><a href="graphics.html#topic+contour">contour</a></code>.</p>
</td></tr>
<tr><td><code id="image.pemt_+3A_contour">contour</code></td>
<td>
<p>logical. If <code>TRUE</code>, the function <code><a href="graphics.html#topic+contour">contour</a></code> is used to draw contour lines over images. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A multidimensional transiogram is a diagram which shows the transition probabilities for a single pair of categories. The probability is computed for any lag vector <code class="reqn">h</code> through 
</p>
<p style="text-align: center;"><code class="reqn">\mbox{expm} (\Vert h \Vert R_h),</code>
</p>

<p>where entries of <code class="reqn">R_h</code> are not ellipsoidally interpolated, but they are estimated for the direction specified by the vector <code class="reqn">h</code>.
</p>
<p>The exponential matrix is evaluated by the scaling and squaring algorithm.
</p>


<h3>Value</h3>

<p>An image is produced on the current graphics device. No values are returned.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>Carle, S. F., Fogg, G. E. (1997) Modelling Spatial Variability with One and Multidimensional Continuous-Lag Markov Chains. <em>Mathematical Geology</em>, <b>29</b>(7), 891-918.
</p>
<p>Higham, N. J. (2008) <em>Functions of Matrices: Theory and Computation</em>. Society for Industrial and Applied Mathematics.
</p>
<p>Sartore, L. (2010) Geostatistical models for 3-D data. M.Phil. thesis, Ca' Foscari University of Venice.</p>


<h3>See Also</h3>

<p><code><a href="#topic+image.multi_tpfit">image.multi_tpfit</a></code>, <code><a href="graphics.html#topic+image">image</a></code>, <code><a href="#topic+plot.transiogram">plot.transiogram</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Compute a 2-D section of a
# multi-directional transiogram
psEmpTr &lt;- pemt(ACM$MAT3, ACM[, 1:3], 2,
                max.dist = c(200, 200, 20), 
                which.dire=c(1, 3), 
                mle = "mlk")

# Plot 2-D sections of
# a multi-directional transiogram
image(psEmpTr, col = rev(heat.colors(500)), 
      breaks = 0:500 / 500, mar = .7,
      contour = FALSE)
</code></pre>

<hr>
<h2 id='is.lengths'>Object test for lengths class</h2><span id='topic+is.lengths'></span>

<h3>Description</h3>

<p>Function to test if an object is of the class <code>lengths</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.lengths(object)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.lengths_+3A_object">object</code></td>
<td>
<p>object to be tested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns <code>TRUE</code> if and only if its argument is a <code>lengths</code> object.</p>


<h3>Value</h3>

<p>A logical value.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+getlen">getlen</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)
direction &lt;- c(0,0,1)
     
# Compute the appertaining directional line for each location
loc.id &lt;- which_lines(ACM[, 1:3], direction)
     
# Estimate stratum lengths
gl &lt;- getlen(ACM$MAT3, ACM[, 1:3], loc.id, direction)

# Test the object gl
is.lengths(gl)

</code></pre>

<hr>
<h2 id='is.multi_tpfit'>Object test for multi_tpfit class</h2><span id='topic+is.multi_tpfit'></span>

<h3>Description</h3>

<p>Function to test if an object is of the class <code>multi_tpfit</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.multi_tpfit(object)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.multi_tpfit_+3A_object">object</code></td>
<td>
<p>object to be tested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns <code>TRUE</code> if and only if its argument is a <code>multi_tpfit</code> object.</p>


<h3>Value</h3>

<p>A logical value.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+multi_tpfit">multi_tpfit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Estimate the parameters of a 
# multidimensional MC models
MoPa &lt;- multi_tpfit(ACM$MAT5, ACM[, 1:3])

# Test the object MoPa
is.multi_tpfit(MoPa)
</code></pre>

<hr>
<h2 id='is.multi_transiogram'>Object test for multi_transiogram class</h2><span id='topic+is.multi_transiogram'></span>

<h3>Description</h3>

<p>Function to test if an object is of the class <code>multi_transiogram</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.multi_transiogram(object)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.multi_transiogram_+3A_object">object</code></td>
<td>
<p>object to be tested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns <code>TRUE</code> if and only if its argument is a <code>multi_transiogram</code> object.</p>


<h3>Value</h3>

<p>A logical value.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.multi_tpfit">predict.multi_tpfit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Estimate the parameters of a 
# multidimensional MC model
RTm &lt;- multi_tpfit(ACM$MAT3, ACM[, 1:3])

# Generate the matrix of 
# multidimensional lags
lags &lt;- expand.grid(X=-1:1, Y=-1:1, Z=-1:1)
lags &lt;- as.matrix(lags)

# Compute transition probabilities 
# from the multidimensional MC model
TrPr &lt;- predict(RTm, lags)

# Test the object TrPr
is.multi_transiogram(TrPr)
</code></pre>

<hr>
<h2 id='is.pemt'>Images with Multi-direct'ional Transiograms</h2><span id='topic+is.pemt'></span>

<h3>Description</h3>

<p>The function plots <code class="reqn">2</code>-D sections of a multi-directional transiogram computed without any ellipsoidal interpolation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.pemt(object)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.pemt_+3A_object">object</code></td>
<td>
<p>object to be tested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns <code>TRUE</code> if and only if its argument is a <code>pemt</code> object.</p>


<h3>Value</h3>

<p>A logical value.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+pemt">pemt</a></code>, <code><a href="#topic+image.pemt">image.pemt</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Compute a 2-D section of a
# multi-directional transiogram
psEmpTr &lt;- pemt(ACM$MAT3, ACM[, 1:3], 2,
                max.dist = c(20, 10, 5), 
                which.dire=c(1, 3), 
                mle = TRUE)

# Test the object psEmpTr
is.pemt(psEmpTr)
</code></pre>

<hr>
<h2 id='is.tpfit'>Object test for tpfit class</h2><span id='topic+is.tpfit'></span>

<h3>Description</h3>

<p>Function to test if an object is of the class <code>tpfit</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.tpfit(object)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.tpfit_+3A_object">object</code></td>
<td>
<p>object to be tested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns <code>TRUE</code> if and only if its argument is a <code>tpfit</code> object.</p>


<h3>Value</h3>

<p>A logical value.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+tpfit">tpfit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Estimate the parameters of a 
# one-dimensional MC model
MoPa &lt;- tpfit(ACM$MAT5, ACM[, 1:3], c(0, 0, 1))

# Test the object MoPa
is.tpfit(MoPa)
</code></pre>

<hr>
<h2 id='is.transiogram'>Object test for transiogram class</h2><span id='topic+is.transiogram'></span>

<h3>Description</h3>

<p>Function to test if an object is of the class <code>transiogram</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.transiogram(object)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.transiogram_+3A_object">object</code></td>
<td>
<p>object to be tested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns <code>TRUE</code> if and only if its argument is a <code>transiogram</code> object.</p>


<h3>Value</h3>

<p>A logical value.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+transiogram">transiogram</a></code>, <code><a href="#topic+predict.tpfit">predict.tpfit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Estimate the parameters of a 
# one-dimensional MC model
RTm &lt;- tpfit(ACM$MAT5, ACM[, 1:3], c(0, 0, 1))

# Compute theoretical transition probabilities 
# from the one-dimensional MC model
TTPr &lt;- predict(RTm, lags = 0:2/2)

# Compute empirical transition probabilities 
ETPr &lt;- transiogram(ACM$MAT5, ACM[, 1:3], c(0, 0, 1), 200, 20)

# Test the objects TTPr and ETPr
is.transiogram(TTPr)
is.transiogram(ETPr)
</code></pre>

<hr>
<h2 id='mixplot'>Plot of Multiple One-dimensional Transiograms</h2><span id='topic+mixplot'></span>

<h3>Description</h3>

<p>The function makes a graphical representation of transition probabilities by the use of multiple transiograms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixplot(x, main, legend = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixplot_+3A_x">x</code></td>
<td>
<p>a <code>list</code> object whose elements are of the class <code>transiogram</code> (typically with the output of the function <code><a href="#topic+transiogram">transiogram</a></code> or <code><a href="#topic+predict.tpfit">predict.tpfit</a></code>).</p>
</td></tr>
<tr><td><code id="mixplot_+3A_main">main</code></td>
<td>
<p>the main title (on top) whose font and size are fixed.</p>
</td></tr>
<tr><td><code id="mixplot_+3A_legend">legend</code></td>
<td>
<p>a logical value for printing the legend in the graphic. It is <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="mixplot_+3A_...">...</code></td>
<td>
<p>other arguments to pass to the function <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Transiogram is a diagram which is drawn for a single pair of categories in the direction <code class="reqn">\phi</code>. It shows the transition probabilities in the <code class="reqn">y</code>-axis for some specific lags in the <code class="reqn">x</code>-axis.
</p>
<p>This function permits a graphical approach to compare theoretical vs. empirical transition probabilities for multiple directions.
</p>


<h3>Value</h3>

<p>An image is produced on the current graphics device. No values are returned.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>Carle, S. F., Fogg, G. E. (1997) Modelling Spatial Variability with One and Multidimensional Continuous-Lag Markov Chains. <em>Mathematical Geology</em>, <b>29</b>(7), 891-918.
</p>
<p>Li, W. (2007) Transiograms for Characterizing Spatial Variability of Soil Classes. <em>Soil Science Society of America Journal</em>, <b>71</b>(3), 881-893.
</p>
<p>Sartore, L. (2010) Geostatistical models for 3-D data. M.Phil. thesis, Ca' Foscari University of Venice.</p>


<h3>See Also</h3>

<p><code><a href="#topic+transiogram">transiogram</a></code>, <code><a href="#topic+tpfit">tpfit</a></code>, <code><a href="#topic+predict.tpfit">predict.tpfit</a></code>, <code><a href="#topic+plot.transiogram">plot.transiogram</a></code>, <code><a href="#topic+image.multi_tpfit">image.multi_tpfit</a></code>, <code><a href="base.html#topic+plot">plot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Estimate empirical transition 
# probabilities by points
ETr &lt;- transiogram(ACM$MAT3, ACM[, 1:3], c(0, 0, 1), 100)

# Estimate the transition rate matrix
RTm &lt;- tpfit(ACM$MAT3, ACM[, 1:3], c(0, 0, 1))

# Compute transition probabilities 
# from the one-dimensional MC model
TPr &lt;- predict(RTm, lags = ETr$lags)

# Plot empirical vs. theoretical transition probabilities
mixplot(list(ETr, TPr), type = c("p", "l"), pch = "+", col = c(3, 1))
</code></pre>

<hr>
<h2 id='mlen'>Mean Length Estimation for Embedded Markov Chain</h2><span id='topic+mlen'></span>

<h3>Description</h3>

<p>The function estimates the mean length for a <code class="reqn">d</code>-D spatial embedded Markov chain for a specified direction <code class="reqn">\phi</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlen(data, coords, loc.id, direction, mle = "avg")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlen_+3A_data">data</code></td>
<td>
<p>a categorical data vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="mlen_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times d</code> matrix where each row denotes the <code class="reqn">d</code>-D coordinates of data locations.</p>
</td></tr>
<tr><td><code id="mlen_+3A_loc.id">loc.id</code></td>
<td>
<p>a vector of <code class="reqn">n</code> values which indicates the directional line of each location. It is usually the output of the function <code><a href="#topic+which_lines">which_lines</a></code>.</p>
</td></tr>
<tr><td><code id="mlen_+3A_direction">direction</code></td>
<td>
<p>a <code class="reqn">d</code>-D numerical vector (or versor) which represents the chosen direction.</p>
</td></tr>
<tr><td><code id="mlen_+3A_mle">mle</code></td>
<td>
<p>a character value. If <code>"trm"</code>, the trimmed arithmetic average will be used to calculate the mean lengths. If <code>"mdn"</code>, the trimmed median will be considered. If <code>"mlk"</code>, the maximum likelihood mean lengths will be computed. If <code>"avg"</code>, the arithmetic mean will be performed. For backward compatibility reasons, it can accept logical values, so that <code>TRUE</code> is equivalent to <code>"mlk"</code> and <code>FALSE</code> to <code>"avg"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean length is the total length occupied by the <code class="reqn">k</code>-th category divided by the number of its embedded occurrences along lines in the direction <code class="reqn">\phi</code>. More robust methods are implemented, such as the trimmed mean and the trimmed median.
</p>
<p>If the stratum lengths are censored, the maximum likelihood approach is more appropriate than the arithmetic mean. In this case, the stratum lengths are assumed to be independent realizations from a log-normal random variable. The quantity to maximize is
</p>
<p style="text-align: center;"><code class="reqn">L(\mu_1, \ldots, \mu_K, \sigma_1, \ldots, \sigma_K) = \prod_{i = 1}^m \prod_{k = 1}^K \left[ \int_{l_i}^{l_i+u_i} \frac{1}{x \sigma_k \sqrt{2}} \exp \left\lbrace - \frac{(\log x - \mu_k)^2}{2 \sigma_k^2} \right\rbrace \right]^{z_{k, i}} \mbox{d}x,</code>
</p>

<p>where <code class="reqn">\boldsymbol{\mu} = (\mu_1, \ldots, \mu_K)^\top</code> and <code class="reqn">\boldsymbol{\sigma} = (\sigma_1, \ldots, \sigma_K)^\top</code> are vectors of parameters, <code class="reqn">l_i</code> is the observed stratum length, <code class="reqn">u_i</code> denotes the upper bound of the censor and <code class="reqn">z_{k, i}</code> denotes a dummy variable which assumes value 1 if and only if the <code class="reqn">i</code>-th stratum is referred to the <code class="reqn">k</code>-th category.
</p>


<h3>Value</h3>

<p>A numeric vector containing the mean length for each observed category.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>Carle, S. F., Fogg, G. E. (1997) Modelling Spatial Variability with One and Multidimensional Continuous-Lag Markov Chains. <em>Mathematical Geology</em>, <b>29</b>(7), 891-918.
</p>
<p>Sartore, L. (2010) Geostatistical models for 3-D data. M.Phil. thesis, Ca' Foscari University of Venice.</p>


<h3>See Also</h3>

<p><code><a href="#topic+which_lines">which_lines</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)
direction &lt;- c(0,0,1)

# Compute the appartaining directional line for each location
loc.id &lt;- which_lines(ACM[, 1:3], direction)

# Estimate the mean lengths for each observed category
ml &lt;- mlen(ACM$MAT5, ACM[, 1:3], loc.id, direction, mle = "avg")

# Equivalently
gl &lt;- getlen(ACM$MAT5, ACM[, 1:3], loc.id, direction, zero.allowed = TRUE)
ml1 &lt;- tapply(gl$length, gl$categories, mean)
</code></pre>

<hr>
<h2 id='multi_tpfit'>Multidimensional Model Parameters Estimation</h2><span id='topic+multi_tpfit'></span>

<h3>Description</h3>

<p>The function estimates the model parameters of a <code class="reqn">d</code>-D continuous lag spatial Markov chain. Transition rates matrices along axial directions and proportions of categories are computed.</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_tpfit(data, coords, method = "ml", tolerance = pi/8,
            rotation = NULL, max.it = 9000, mle = "avg", ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multi_tpfit_+3A_data">data</code></td>
<td>
<p>a categorical data vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="multi_tpfit_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times d</code> matrix where each row denotes the <code class="reqn">d</code>-D coordinates of data locations.</p>
</td></tr>
<tr><td><code id="multi_tpfit_+3A_method">method</code></td>
<td>
<p>a character object specifying the method to estimate the transition rates. Possible choises are <code>"ml"</code> (by default) for the mean length method, <code>"ils"</code> for the iterated least squares and <code>"me"</code> for the maximum entropy method.</p>
</td></tr>
<tr><td><code id="multi_tpfit_+3A_tolerance">tolerance</code></td>
<td>
<p>a numerical value for the tolerance angle (in radians). It's <code>pi/8</code> by default.</p>
</td></tr>
<tr><td><code id="multi_tpfit_+3A_rotation">rotation</code></td>
<td>
<p>a numerical vector of length <code class="reqn">d - 1</code> with rotation angles (in radians), in order to perform the main axes rotation. No rotation is performed by default.</p>
</td></tr>
<tr><td><code id="multi_tpfit_+3A_max.it">max.it</code></td>
<td>
<p>a numerical value which denotes the maximum number of iterations to perform during the optimization phase. It is <code>9000</code> by default and used only when the method is <code>"me"</code>.</p>
</td></tr>
<tr><td><code id="multi_tpfit_+3A_mle">mle</code></td>
<td>
<p>a character value to pass to the function <code><a href="#topic+tpfit">tpfit</a></code>. It is <code>"avg"</code> by default and not use when the method is <code>"ils"</code>.</p>
</td></tr>
<tr><td><code id="multi_tpfit_+3A_...">...</code></td>
<td>
<p>other arguments to pass to the functions <code><a href="#topic+multi_tpfit_ml">multi_tpfit_ml</a></code>, <code><a href="#topic+multi_tpfit_ils">multi_tpfit_ils</a></code> or <code><a href="#topic+multi_tpfit_me">multi_tpfit_me</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code class="reqn">d</code>-D continuous-lag spatial Markov chain is probabilistic model which is developed by interpolation of the transition rate matrices computed for the main directions. It defines transition probabilities <code class="reqn">\Pr(Z(s + h) = z_k | Z(s) = z_j)</code> through
</p>
<p style="text-align: center;"><code class="reqn">\mbox{expm} (\Vert h \Vert R),</code>
</p>

<p>where <code class="reqn">h</code> is the lag vector and the entries of <code class="reqn">R</code> are ellipsoidally interpolated.
</p>
<p>The ellipsoidal interpolation is given by
</p>
<p style="text-align: center;"><code class="reqn">\vert r_{jk} \vert = \sqrt{\sum_{i = 1}^d \left( \frac{h_i}{\Vert h \Vert} r_{jk, \mathbf{e}_i} \right)^2},</code>
</p>

<p>where <code class="reqn">\mathbf{e}_i</code> is a standard basis for a <code class="reqn">d</code>-D space.
</p>
<p>If <code class="reqn">h_i &lt; 0</code> the respective entries <code class="reqn">r_{jk, \mathbf{e}_i}</code> are replaced by <code class="reqn">r_{jk, -\mathbf{e}_i}</code>, which is computed as
</p>
<p style="text-align: center;"><code class="reqn">r_{jk, -\mathbf{e}_i} = \frac{p_k}{p_j} \, r_{kj, \mathbf{e}_i},</code>
</p>

<p>where <code class="reqn">p_k</code> and <code class="reqn">p_j</code> respectively denote the proportions for the <code class="reqn">k</code>-th and <code class="reqn">j</code>-th categories. In so doing, the model may describe the anisotropy of the process.
</p>


<h3>Value</h3>

<p>An object of the class <code>multi_tpfit</code> is returned. The function <code><a href="#topic+print.multi_tpfit">print.multi_tpfit</a></code> is used to print the fitted model. The object is a list with the following components: 
</p>
<table role = "presentation">
<tr><td><code>coordsnames</code></td>
<td>
<p>a character vector containing the name of each axis.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a list containing the transition rates matrices computed for each axial direction.</p>
</td></tr>
<tr><td><code>prop</code></td>
<td>
<p>a vector containing the proportions of each observed category.</p>
</td></tr>
<tr><td><code>tolerance</code></td>
<td>
<p>a numerical value which denotes the tolerance angle (in radians).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>Carle, S. F., Fogg, G. E. (1997) Modelling Spatial Variability with One and Multidimensional Continuous-Lag Markov Chains. <em>Mathematical Geology</em>, <b>29</b>(7), 891-918.
</p>
<p>Sartore, L. (2010) Geostatistical models for 3-D data. M.Phil. thesis, Ca' Foscari University of Venice.</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.multi_tpfit">predict.multi_tpfit</a></code>, <code><a href="#topic+print.multi_tpfit">print.multi_tpfit</a></code>, <code><a href="#topic+image.multi_tpfit">image.multi_tpfit</a></code>, <code><a href="#topic+tpfit">tpfit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Estimate transition rates matrices and 
# proportions for the categorical variable MAT5
multi_tpfit(ACM$MAT5, ACM[, 1:3])

# Estimate transition rates matrices and
# proportions for the categorical variable MAT3
multi_tpfit(ACM$MAT3, ACM[, 1:3])

# Estimate transition rates matrices and
# proportions for the categorical variable PERM
multi_tpfit(ACM$PERM, ACM[, 1:3])
</code></pre>

<hr>
<h2 id='multi_tpfit_ils'>Iterated Least Squares Method for Multidimensional Model Parameters Estimation</h2><span id='topic+multi_tpfit_ils'></span>

<h3>Description</h3>

<p>The function estimates the model parameters of a <code class="reqn">d</code>-D continuous lag spatial Markov chain by the use of the iterated least squares and the bound-constrained Lagrangian methods. Transition rates matrices along axial directions and proportions of categories are computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_tpfit_ils(data, coords, max.dist = Inf, mpoints = 20,
                tolerance = pi/8, rotation = NULL, q = 10,
                echo = FALSE, ..., mtpfit)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multi_tpfit_ils_+3A_data">data</code></td>
<td>
<p>a categorical data vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="multi_tpfit_ils_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times d</code> matrix where each row denotes the <code class="reqn">d</code>-D coordinates of data locations.</p>
</td></tr>
<tr><td><code id="multi_tpfit_ils_+3A_max.dist">max.dist</code></td>
<td>
<p>a numerical value which defines the maximum lag value. It is <code>Inf</code> by default.</p>
</td></tr>
<tr><td><code id="multi_tpfit_ils_+3A_mpoints">mpoints</code></td>
<td>
<p>a numerical value which defines the number of lag intervals.</p>
</td></tr>
<tr><td><code id="multi_tpfit_ils_+3A_tolerance">tolerance</code></td>
<td>
<p>a numerical value for the tolerance angle (in radians). It is <code>pi/8</code> by default.</p>
</td></tr>
<tr><td><code id="multi_tpfit_ils_+3A_rotation">rotation</code></td>
<td>
<p>a numerical vector of length <code class="reqn">d - 1</code> with rotation angles (in radians), in order to perform the main axes rotation. No rotation is performed by default.</p>
</td></tr>
<tr><td><code id="multi_tpfit_ils_+3A_q">q</code></td>
<td>
<p>a numerical value greater than one for a constant which controls the growth of the penalization term in the loss function. It is equal to <code>10</code> by default.</p>
</td></tr>
<tr><td><code id="multi_tpfit_ils_+3A_echo">echo</code></td>
<td>
<p>a logical value; if <code>TRUE</code>, the function prints some information about the optimization. It is <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="multi_tpfit_ils_+3A_...">...</code></td>
<td>
<p>other arguments to pass to the function <code><a href="stats.html#topic+nlminb">nlminb</a></code>.</p>
</td></tr>
<tr><td><code id="multi_tpfit_ils_+3A_mtpfit">mtpfit</code></td>
<td>
<p>an object <code>multi_tpfit</code> to optimize. If missing, the algorithm starts with null transition rates matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code class="reqn">d</code>-D continuous-lag spatial Markov chain is probabilistic model which is developed by interpolation of the transition rate matrices computed for the main directions. It defines transition probabilities <code class="reqn">\Pr(Z(s + h) = z_k | Z(s) = z_j)</code> through
</p>
<p style="text-align: center;"><code class="reqn">\mbox{expm} (\Vert h \Vert R),</code>
</p>

<p>where <code class="reqn">h</code> is the lag vector and the entries of <code class="reqn">R</code> are ellipsoidally interpolated.
</p>
<p>The ellipsoidal interpolation is given by
</p>
<p style="text-align: center;"><code class="reqn">\vert r_{jk} \vert = \sqrt{\sum_{i = 1}^d \left( \frac{h_i}{\Vert h \Vert} r_{jk, \mathbf{e}_i} \right)^2},</code>
</p>

<p>where <code class="reqn">\mathbf{e}_i</code> is a standard basis for a <code class="reqn">d</code>-D space.
</p>
<p>If <code class="reqn">h_i &lt; 0</code> the respective entries <code class="reqn">r_{jk, \mathbf{e}_i}</code> are replaced by <code class="reqn">r_{jk, -\mathbf{e}_i}</code>, which is computed as
</p>
<p style="text-align: center;"><code class="reqn">r_{jk, -\mathbf{e}_i} = \frac{p_k}{p_j} \, r_{kj, \mathbf{e}_i},</code>
</p>

<p>where <code class="reqn">p_k</code> and <code class="reqn">p_j</code> respectively denote the proportions for the <code class="reqn">k</code>-th and <code class="reqn">j</code>-th categories. In so doing, the model may describe the anisotropy of the process.
</p>
<p>In particular, to estimate entries of transition rate matrices computed for the main axial directions, we need to minimize the discrepancies between the empirical transiograms (see <code><a href="#topic+transiogram">transiogram</a></code>) and the predicted transition probabilities.
</p>
<p>By the use of the iterated least squares, the diagonal entries of <code class="reqn">R</code> are constrained to be negative, while the off-diagonal transition rates are constrained to be positive. Further constraints are considered in order to obtain a proper transition rates matrix.
</p>


<h3>Value</h3>

<p>An object of the class <code>multi_tpfit</code> is returned. The function <code><a href="#topic+print.multi_tpfit">print.multi_tpfit</a></code> is used to print the fitted model. The object is a list with the following components: 
</p>
<table role = "presentation">
<tr><td><code>coordsnames</code></td>
<td>
<p>a character vector containing the name of each axis.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a list containing the transition rates matrices computed for each axial direction.</p>
</td></tr>
<tr><td><code>prop</code></td>
<td>
<p>a vector containing the proportions of each observed category.</p>
</td></tr>
<tr><td><code>tolerance</code></td>
<td>
<p>a numerical value which denotes the tolerance angle (in radians).</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>If the process is not stationary, the optimization algorithm does not converge.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>Sartore, L. (2010) Geostatistical models for 3-D data. M.Phil. thesis, Ca' Foscari University of Venice.</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.multi_tpfit">predict.multi_tpfit</a></code>, <code><a href="#topic+print.multi_tpfit">print.multi_tpfit</a></code>, <code><a href="#topic+image.multi_tpfit">image.multi_tpfit</a></code>, <code><a href="#topic+tpfit_ils">tpfit_ils</a></code>, <code><a href="#topic+transiogram">transiogram</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Estimate the parameters of a 
# multidimensional MC model
multi_tpfit_ils(ACM$MAT3, ACM[, 1:3], 100)
</code></pre>

<hr>
<h2 id='multi_tpfit_me'>Maximum Entropy Method for Multidimensional Model Parameters Estimation</h2><span id='topic+multi_tpfit_me'></span>

<h3>Description</h3>

<p>The function estimates the model parameters of a <code class="reqn">d</code>-D continuous lag spatial Markov chain. Transition rates matrices along axial directions and proportions of categories are computed.</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_tpfit_me(data, coords, tolerance = pi/8, max.it = 9000,
               rotation = NULL, mle = "avg")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multi_tpfit_me_+3A_data">data</code></td>
<td>
<p>a categorical data vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="multi_tpfit_me_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times d</code> matrix where each row denotes the <code class="reqn">d</code>-D coordinates of data locations.</p>
</td></tr>
<tr><td><code id="multi_tpfit_me_+3A_tolerance">tolerance</code></td>
<td>
<p>a numerical value for the tolerance angle (in radians). It is <code>pi/8</code> by default.</p>
</td></tr>
<tr><td><code id="multi_tpfit_me_+3A_max.it">max.it</code></td>
<td>
<p>a numerical value which denotes the maximum number of iterations to perform during the optimization phase. It is <code>9000</code> by default.</p>
</td></tr>
<tr><td><code id="multi_tpfit_me_+3A_rotation">rotation</code></td>
<td>
<p>a numerical vector of length <code class="reqn">d - 1</code> with rotation angles (in radians), in order to perform the main axes rotation. No rotation is performed by default.</p>
</td></tr>
<tr><td><code id="multi_tpfit_me_+3A_mle">mle</code></td>
<td>
<p>a character value to pass to the function <code><a href="#topic+tpfit">tpfit</a></code>. It is <code>"avg"</code> by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code class="reqn">d</code>-D continuous-lag spatial Markov chain is probabilistic model which is developed by interpolation of the transition rate matrices computed for the main directions by the use of the function <code><a href="#topic+tpfit_me">tpfit_me</a></code>. It defines transition probabilities <code class="reqn">\Pr(Z(s + h) = z_k | Z(s) = z_j)</code> through
</p>
<p style="text-align: center;"><code class="reqn">\mbox{expm} (\Vert h \Vert R),</code>
</p>

<p>where <code class="reqn">h</code> is the lag vector and the entries of <code class="reqn">R</code> are ellipsoidally interpolated.
</p>
<p>The ellipsoidal interpolation is given by
</p>
<p style="text-align: center;"><code class="reqn">\vert r_{jk} \vert = \sqrt{\sum_{i = 1}^d \left( \frac{h_i}{\Vert h \Vert} r_{jk, \mathbf{e}_i} \right)^2},</code>
</p>

<p>where <code class="reqn">\mathbf{e}_i</code> is a standard basis for a <code class="reqn">d</code>-D space.
</p>
<p>If <code class="reqn">h_i &lt; 0</code> the respective entries <code class="reqn">r_{jk, \mathbf{e}_i}</code> are replaced by <code class="reqn">r_{jk, -\mathbf{e}_i}</code>, which is computed as
</p>
<p style="text-align: center;"><code class="reqn">r_{jk, -\mathbf{e}_i} = \frac{p_k}{p_j} \, r_{kj, \mathbf{e}_i},</code>
</p>

<p>where <code class="reqn">p_k</code> and <code class="reqn">p_j</code> respectively denote the proportions for the <code class="reqn">k</code>-th and <code class="reqn">j</code>-th categories. In so doing, the model may describe the anisotropy of the process.
</p>
<p>When some entries of the rates matrices are not identifiable, it is suggested to vary the <code>tolerance</code> coefficient and the <code>rotation</code> angles. This problem may be also avoided if the input argument <code>mle</code> is to set to be <code>"mlk"</code>.
</p>


<h3>Value</h3>

<p>An object of the class <code>multi_tpfit</code> is returned. The function <code><a href="#topic+print.multi_tpfit">print.multi_tpfit</a></code> is used to print the fitted model. The object is a list with the following components: 
</p>
<table role = "presentation">
<tr><td><code>coordsnames</code></td>
<td>
<p>a character vector containing the name of each axis.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a list containing the transition rates matrices computed for each axial direction.</p>
</td></tr>
<tr><td><code>prop</code></td>
<td>
<p>a vector containing the proportions of each observed category.</p>
</td></tr>
<tr><td><code>tolerance</code></td>
<td>
<p>a numerical value which denotes the tolerance angle (in radians).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>Carle, S. F., Fogg, G. E. (1997) Modelling Spatial Variability with One and Multidimensional Continuous-Lag Markov Chains. <em>Mathematical Geology</em>, <b>29</b>(7), 891-918.</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.multi_tpfit">predict.multi_tpfit</a></code>, <code><a href="#topic+print.multi_tpfit">print.multi_tpfit</a></code>, <code><a href="#topic+image.multi_tpfit">image.multi_tpfit</a></code>, <code><a href="#topic+tpfit_me">tpfit_me</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Estimate transition rates matrices and 
# proportions for the categorical variable MAT5
multi_tpfit_me(ACM$MAT5, ACM[, 1:3])

# Estimate transition rates matrices and
# proportions for the categorical variable MAT3
multi_tpfit_me(ACM$MAT3, ACM[, 1:3])

# Estimate transition rates matrices and
# proportions for the categorical variable PERM
multi_tpfit_me(ACM$PERM, ACM[, 1:3])
</code></pre>

<hr>
<h2 id='multi_tpfit_ml'>Mean Length Method for Multidimensional Model Parameters Estimation</h2><span id='topic+multi_tpfit_ml'></span>

<h3>Description</h3>

<p>The function estimates the model parameters of a <code class="reqn">d</code>-D continuous lag spatial Markov chain. Transition rates matrices along axial directions and proportions of categories are computed.</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_tpfit_ml(data, coords, tolerance = pi/8,
               rotation = NULL, mle = "avg")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multi_tpfit_ml_+3A_data">data</code></td>
<td>
<p>a categorical data vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="multi_tpfit_ml_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times d</code> matrix where each row denotes the <code class="reqn">d</code>-D coordinates of data locations.</p>
</td></tr>
<tr><td><code id="multi_tpfit_ml_+3A_tolerance">tolerance</code></td>
<td>
<p>a numerical value for the tolerance angle (in radians). It's <code>pi/8</code> by default.</p>
</td></tr>
<tr><td><code id="multi_tpfit_ml_+3A_rotation">rotation</code></td>
<td>
<p>a numerical vector of length <code class="reqn">d - 1</code> with rotation angles (in radians), in order to perform the main axes rotation. No rotation is performed by default.</p>
</td></tr>
<tr><td><code id="multi_tpfit_ml_+3A_mle">mle</code></td>
<td>
<p>a character value to pass to the function <code><a href="#topic+tpfit">tpfit</a></code>. It is <code>"avg"</code> by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code class="reqn">d</code>-D continuous-lag spatial Markov chain is probabilistic model which is developed by interpolation of the transition rate matrices computed for the main directions. It defines transition probabilities <code class="reqn">\Pr(Z(s + h) = z_k | Z(s) = z_j)</code> through
</p>
<p style="text-align: center;"><code class="reqn">\mbox{expm} (\Vert h \Vert R),</code>
</p>

<p>where <code class="reqn">h</code> is the lag vector and the entries of <code class="reqn">R</code> are ellipsoidally interpolated.
</p>
<p>The ellipsoidal interpolation is given by
</p>
<p style="text-align: center;"><code class="reqn">\vert r_{jk} \vert = \sqrt{\sum_{i = 1}^d \left( \frac{h_i}{\Vert h \Vert} r_{jk, \mathbf{e}_i} \right)^2},</code>
</p>

<p>where <code class="reqn">\mathbf{e}_i</code> is a standard basis for a <code class="reqn">d</code>-D space.
</p>
<p>If <code class="reqn">h_i &lt; 0</code> the respective entries <code class="reqn">r_{jk, \mathbf{e}_i}</code> are replaced by <code class="reqn">r_{jk, -\mathbf{e}_i}</code>, which is computed as
</p>
<p style="text-align: center;"><code class="reqn">r_{jk, -\mathbf{e}_i} = \frac{p_k}{p_j} \, r_{kj, \mathbf{e}_i},</code>
</p>

<p>where <code class="reqn">p_k</code> and <code class="reqn">p_j</code> respectively denote the proportions for the <code class="reqn">k</code>-th and <code class="reqn">j</code>-th categories. In so doing, the model may describe the anisotropy of the process.
</p>
<p>When some entries of the rates matrices are not identifiable, it is suggested to vary the <code>tolerance</code> coefficient and the <code>rotation</code> angles. This problem may be also avoided if the input argument <code>mle</code> is to set to be <code>"mlk"</code>.
</p>


<h3>Value</h3>

<p>An object of the class <code>multi_tpfit</code> is returned. The function <code><a href="#topic+print.multi_tpfit">print.multi_tpfit</a></code> is used to print the fitted model. The object is a list with the following components: 
</p>
<table role = "presentation">
<tr><td><code>coordsnames</code></td>
<td>
<p>a character vector containing the name of each axis.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a list containing the transition rates matrices computed for each axial direction.</p>
</td></tr>
<tr><td><code>prop</code></td>
<td>
<p>a vector containing the proportions of each observed category.</p>
</td></tr>
<tr><td><code>tolerance</code></td>
<td>
<p>a numerical value which denotes the tolerance angle (in radians).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>Carle, S. F., Fogg, G. E. (1997) Modelling Spatial Variability with One and Multidimensional Continuous-Lag Markov Chains. <em>Mathematical Geology</em>, <b>29</b>(7), 891-918.
</p>
<p>Sartore, L. (2010) Geostatistical models for 3-D data. M.Phil. thesis, Ca' Foscari University of Venice.</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.multi_tpfit">predict.multi_tpfit</a></code>, <code><a href="#topic+print.multi_tpfit">print.multi_tpfit</a></code>, <code><a href="#topic+image.multi_tpfit">image.multi_tpfit</a></code>, <code><a href="#topic+tpfit_ml">tpfit_ml</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Estimate transition rates matrices and 
# proportions for the categorical variable MAT5
multi_tpfit_ml(ACM$MAT5, ACM[, 1:3])

# Estimate transition rates matrices and
# proportions for the categorical variable MAT3
multi_tpfit_ml(ACM$MAT3, ACM[, 1:3])

# Estimate transition rates matrices and
# proportions for the categorical variable PERM
multi_tpfit_ml(ACM$PERM, ACM[, 1:3])
</code></pre>

<hr>
<h2 id='pemt'>Multi-directional Transiograms Estimation</h2><span id='topic+pemt'></span>

<h3>Description</h3>

<p>The function computes the multi-directional transiograms without any ellipsoidal interpolation for <code class="reqn">2</code>-D sections.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pemt(data, coords, mpoints, which.dire, max.dist,
     tolerance = pi/8, rotation = NULL, mle = "avg")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pemt_+3A_data">data</code></td>
<td>
<p>a categorical data vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="pemt_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times d</code> matrix where each row denotes the <code class="reqn">d</code>-D coordinates of data locations.</p>
</td></tr>
<tr><td><code id="pemt_+3A_mpoints">mpoints</code></td>
<td>
<p>the number of points per axes. It controls the accuracy of images to plot.</p>
</td></tr>
<tr><td><code id="pemt_+3A_which.dire">which.dire</code></td>
<td>
<p>a vector with two chosen axial directions. If omitted, all <code class="reqn">2</code>-D sections are plotted.</p>
</td></tr>
<tr><td><code id="pemt_+3A_max.dist">max.dist</code></td>
<td>
<p>a scalar or a vector of maximum length for the chosen axial directions.</p>
</td></tr>
<tr><td><code id="pemt_+3A_tolerance">tolerance</code></td>
<td>
<p>a numerical value for the tolerance angle (in radians). It's <code>pi/8</code> by default.</p>
</td></tr>
<tr><td><code id="pemt_+3A_rotation">rotation</code></td>
<td>
<p>a numerical vector of length <code class="reqn">d - 1</code> with rotation angles (in radians), in order to perform the main axes rotation when multidimensional transiogram is estimated. No rotation is performed by default. See <code><a href="#topic+multi_tpfit_ml">multi_tpfit_ml</a></code>.</p>
</td></tr>
<tr><td><code id="pemt_+3A_mle">mle</code></td>
<td>
<p>a character value to pass to the function <code><a href="#topic+tpfit_ml">tpfit_ml</a></code>. It is <code>"avg"</code> by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A multidimensional transiogram is a diagram which shows the transition probabilities for a single pair of categories. The probability is computed for any lag vector <code class="reqn">h</code> through 
</p>
<p style="text-align: center;"><code class="reqn">\mbox{expm} (\Vert h \Vert R_h),</code>
</p>

<p>where entries of <code class="reqn">R_h</code> are not ellipsoidally interpolated, but they are estimated for the direction specified by the vector <code class="reqn">h</code>.
</p>
<p>In particular cases, some entries of the estimated matrix <code class="reqn">R_h</code> might be not finite, so that the exponential matrix is computable and the resulting transition probabilities are set to be <code>NaN</code>. If <code>mle = "mlk"</code>, this problem may be partially solved.
</p>
<p>The exponential matrix is evaluated by the scaling and squaring algorithm.
</p>


<h3>Value</h3>

<p>An object of class <code>pemt</code> is returned.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>Carle, S. F., Fogg, G. E. (1997) Modelling Spatial Variability with One and Multidimensional Continuous-Lag Markov Chains. <em>Mathematical Geology</em>, <b>29</b>(7), 891-918.
</p>
<p>Higham, N. J. (2008) <em>Functions of Matrices: Theory and Computation</em>. Society for Industrial and Applied Mathematics.
</p>
<p>Sartore, L. (2010) Geostatistical models for 3-D data. M.Phil. thesis, Ca' Foscari University of Venice.</p>


<h3>See Also</h3>

<p><code><a href="#topic+multi_tpfit_ml">multi_tpfit_ml</a></code>, <code><a href="#topic+tpfit_ml">tpfit_ml</a></code>, <code><a href="#topic+image.pemt">image.pemt</a></code>, <code><a href="#topic+plot.transiogram">plot.transiogram</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Compute a 2-D section of a
# multi-directional transiogram
pemt(ACM$MAT3, ACM[, 1:3], 2,
     max.dist = c(200, 200, 20), 
     which.dire=c(1, 3), mle = "mdn")
</code></pre>

<hr>
<h2 id='persp.multi_tpfit'>Perspective Plots with Multidimensional Transiograms</h2><span id='topic+persp.multi_tpfit'></span>

<h3>Description</h3>

<p>The function draws perspective-plots the <code class="reqn">2</code>-D sections of a predicted multidimensional transiograms computed through ellipsoidal interpolation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multi_tpfit'
persp(x, mpoints, which.dire, max.dist, main,
      mar, ask = TRUE, col = "white", ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="persp.multi_tpfit_+3A_x">x</code></td>
<td>
<p>an object of the class <code>multi_tpfit</code>, typically with the output of the function <code><a href="#topic+multi_tpfit">multi_tpfit</a></code>.</p>
</td></tr>
<tr><td><code id="persp.multi_tpfit_+3A_mpoints">mpoints</code></td>
<td>
<p>the number of points per axes. It controls the accuracy of images to plot.</p>
</td></tr>
<tr><td><code id="persp.multi_tpfit_+3A_which.dire">which.dire</code></td>
<td>
<p>a vector with two chosen axial directions. If omitted, all <code class="reqn">2</code>-D sections are plotted.</p>
</td></tr>
<tr><td><code id="persp.multi_tpfit_+3A_max.dist">max.dist</code></td>
<td>
<p>a scalar or a vector of maximum length for the chosen axial directions.</p>
</td></tr>
<tr><td><code id="persp.multi_tpfit_+3A_main">main</code></td>
<td>
<p>the main title (on top) whose font and size are fixed.</p>
</td></tr>
<tr><td><code id="persp.multi_tpfit_+3A_mar">mar</code></td>
<td>
<p>a scalar or a numerical vector of the form <code>c(bottom, left, top, right)</code> which gives the number of margin lines to be specified on the four sides of image to plot. See <code><a href="graphics.html#topic+par">par</a></code>(<code>mar=</code>.).</p>
</td></tr>
<tr><td><code id="persp.multi_tpfit_+3A_ask">ask</code></td>
<td>
<p>a logical value; if <code>TRUE</code>, the user is asked for input, before each plot. See <code><a href="graphics.html#topic+par">par</a></code>(<code>ask=</code>.).</p>
</td></tr>
<tr><td><code id="persp.multi_tpfit_+3A_col">col</code></td>
<td>
<p>a list of colors which is usually generated by <code>rev(<a href="grDevices.html#topic+heat.colors">heat.colors</a>())</code>, or with other function for <code><a href="grDevices.html#topic+colors">colors</a></code>.</p>
</td></tr>
<tr><td><code id="persp.multi_tpfit_+3A_...">...</code></td>
<td>
<p>other arguments to pass to the function <code><a href="graphics.html#topic+persp">persp</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A multidimensional transiogram is a diagram which shows the transition probabilities for a single pair of categories. It is computed for any lag vector <code class="reqn">h</code> through 
</p>
<p style="text-align: center;"><code class="reqn">\mbox{expm} (\Vert h \Vert R),</code>
</p>

<p>where entries of <code class="reqn">R</code> are ellipsoidally interpolated (see <code><a href="#topic+multi_tpfit">multi_tpfit</a></code>).
</p>
<p>The exponential matrix is evaluated by the scaling and squaring algorithm.
</p>


<h3>Value</h3>

<p>An image is produced on the current graphics device. No values are returned.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>Carle, S. F., Fogg, G. E. (1997) Modelling Spatial Variability with One and Multidimensional Continuous-Lag Markov Chains. <em>Mathematical Geology</em>, <b>29</b>(7), 891-918.
</p>
<p>Higham, N. J. (2008) <em>Functions of Matrices: Theory and Computation</em>. Society for Industrial and Applied Mathematics.
</p>
<p>Sartore, L. (2010) Geostatistical models for 3-D data. M.Phil. thesis, Ca' Foscari University of Venice.</p>


<h3>See Also</h3>

<p><code><a href="#topic+multi_tpfit">multi_tpfit</a></code>, <code><a href="#topic+persp.multi_tpfit">persp.multi_tpfit</a></code>, <code><a href="graphics.html#topic+persp">persp</a></code>, <code><a href="#topic+pemt">pemt</a></code>, <code><a href="#topic+persp.pemt">persp.pemt</a></code>, <code><a href="#topic+plot.transiogram">plot.transiogram</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Estimate model parameter
x &lt;- multi_tpfit(ACM$MAT5, ACM[, 1:3])

# Set short names for categories 3 and 4
names(x$prop)[3:4] &lt;- c("Clay and Sand", "Gravel and Sand")

# 3D-Plot for a 2-D theoretical sections of
# a multidimensional transiogram
persp(x, 15, max.dist = c(200, 200, 20), which.dire = 2:3,
    mar = .7, col = rainbow(500), theta = 15, phi = 45)
</code></pre>

<hr>
<h2 id='persp.pemt'>Perspective Plots with Multi-directional Transiograms</h2><span id='topic+persp.pemt'></span>

<h3>Description</h3>

<p>The function draws perspective-plots the <code class="reqn">2</code>-D sections of a multi-directional transiogram computed without any ellipsoidal interpolation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pemt'
persp(x, main, mar, ask = TRUE, col = "white", ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="persp.pemt_+3A_x">x</code></td>
<td>
<p>an object of the class <code>pemt</code>, typically with the output of the function <code><a href="#topic+pemt">pemt</a></code>.</p>
</td></tr>
<tr><td><code id="persp.pemt_+3A_main">main</code></td>
<td>
<p>the main title (on top) whose font and size are fixed.</p>
</td></tr>
<tr><td><code id="persp.pemt_+3A_mar">mar</code></td>
<td>
<p>a scalar or a numerical vector of the form <code>c(bottom, left, top, right)</code> which gives the number of margin lines to be specified on the four sides of image to plot. See <code><a href="graphics.html#topic+par">par</a></code>(<code>mar=</code>.).</p>
</td></tr>
<tr><td><code id="persp.pemt_+3A_ask">ask</code></td>
<td>
<p>a logical value; if <code>TRUE</code>, the user is asked for input, before each plot. See <code><a href="graphics.html#topic+par">par</a></code>(<code>ask=</code>.).</p>
</td></tr>
<tr><td><code id="persp.pemt_+3A_col">col</code></td>
<td>
<p>a list of colors which is usually generated by <code>rev(<a href="grDevices.html#topic+heat.colors">heat.colors</a>())</code>, or with other function for <code><a href="grDevices.html#topic+colors">colors</a></code>.</p>
</td></tr>
<tr><td><code id="persp.pemt_+3A_...">...</code></td>
<td>
<p>other arguments to pass to the function <code><a href="graphics.html#topic+persp">persp</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A multidimensional transiogram is a diagram which shows the transition probabilities for a single pair of categories. The probability is computed for any lag vector <code class="reqn">h</code> through 
</p>
<p style="text-align: center;"><code class="reqn">\mbox{expm} (\Vert h \Vert R_h),</code>
</p>

<p>where entries of <code class="reqn">R_h</code> are not ellipsoidally interpolated, but they are estimated for the direction specified by the vector <code class="reqn">h</code>.
</p>
<p>The exponential matrix is evaluated by the scaling and squaring algorithm.
</p>


<h3>Value</h3>

<p>An image is produced on the current graphics device. No values are returned.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>Carle, S. F., Fogg, G. E. (1997) Modelling Spatial Variability with One and Multidimensional Continuous-Lag Markov Chains. <em>Mathematical Geology</em>, <b>29</b>(7), 891-918.
</p>
<p>Higham, N. J. (2008) <em>Functions of Matrices: Theory and Computation</em>. Society for Industrial and Applied Mathematics.
</p>
<p>Sartore, L. (2010) Geostatistical models for 3-D data. M.Phil. thesis, Ca' Foscari University of Venice.</p>


<h3>See Also</h3>

<p><code><a href="#topic+pemt">pemt</a></code>, <code><a href="#topic+persp.multi_tpfit">persp.multi_tpfit</a></code>, <code><a href="graphics.html#topic+persp">persp</a></code>, <code><a href="#topic+multi_tpfit">multi_tpfit</a></code>, <code><a href="#topic+image.pemt">image.pemt</a></code>, <code><a href="#topic+plot.transiogram">plot.transiogram</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Compute a 2-D section of a
# multi-directional transiogram
psEmpTr &lt;- pemt(ACM$MAT3, ACM[, 1:3], 2,
                max.dist = c(200, 200, 20), 
                which.dire = c(1, 3))

# 3D-Plot for a 2-D sections of
# a multi-directional transiogram
persp(psEmpTr, col = rainbow(500), mar = .7,
      theta = 15, phi = 45)
</code></pre>

<hr>
<h2 id='plot.density.lengths'>Plot Empirical Densities Estimates of Stratum Lengths</h2><span id='topic+plot.density.lengths'></span>

<h3>Description</h3>

<p>The function plot the empirical densities of stratum lengths computed along a given direction.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'density.lengths'
plot(x, main = NULL, xlab = NULL, ylab = "Density", type = "l",
     zero.line = TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.density.lengths_+3A_x">x</code></td>
<td>
<p>an object of the class <code>density.lengths</code>, typically with the output of the function <code><a href="#topic+density.lengths">density.lengths</a></code>.</p>
</td></tr>
<tr><td><code id="plot.density.lengths_+3A_main">main</code></td>
<td>
<p>an overall title for the plot.</p>
</td></tr>
<tr><td><code id="plot.density.lengths_+3A_xlab">xlab</code></td>
<td>
<p>a title for the <code class="reqn">x</code>-axis.</p>
</td></tr>
<tr><td><code id="plot.density.lengths_+3A_ylab">ylab</code></td>
<td>
<p>a title for the <code class="reqn">y</code>-axis.</p>
</td></tr>
<tr><td><code id="plot.density.lengths_+3A_type">type</code></td>
<td>
<p>plotting parameter for the type of graphic (see <code><a href="base.html#topic+plot">plot</a></code>).</p>
</td></tr>
<tr><td><code id="plot.density.lengths_+3A_zero.line">zero.line</code></td>
<td>
<p>logical value. If <code>TRUE</code> (by default), the function adds a base line at <code class="reqn">y = 0</code>.</p>
</td></tr>
<tr><td><code id="plot.density.lengths_+3A_...">...</code></td>
<td>
<p>other plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An image is produced on the current graphics device. No values are returned.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density.default">density.default</a></code>, <code><a href="#topic+density.lengths">density.lengths</a></code>, <code><a href="base.html#topic+plot">plot</a></code>, <code><a href="#topic+print.density.lengths">print.density.lengths</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)
direction &lt;- c(0,0,1)
     
# Compute the appertaining directional line for each location
loc.id &lt;- which_lines(ACM[, 1:3], direction)
     
# Estimate stratum lengths
gl &lt;- getlen(ACM$MAT3, ACM[, 1:3], loc.id, direction)

# Compute the empirical densities of stratum log-lengths
dgl &lt;- density(gl, log = TRUE)

# Plot the empirical densities of stratum log-lengths
plot(dgl)
</code></pre>

<hr>
<h2 id='plot.hist.lengths'>Plot Histograms of Stratum Lengths</h2><span id='topic+plot.hist.lengths'></span>

<h3>Description</h3>

<p>The function plots objects of class <code>hist.lengths</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hist.lengths'
plot(x, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.hist.lengths_+3A_x">x</code></td>
<td>
<p>an object of the class <code>hist.lengths</code>, typically with the output of the function <code><a href="#topic+hist.lengths">hist.lengths</a></code>.</p>
</td></tr>
<tr><td><code id="plot.hist.lengths_+3A_...">...</code></td>
<td>
<p>further plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An image is produced on the current graphics device. No values are returned.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+hist">hist</a></code>, <code><a href="#topic+hist.lengths">hist.lengths</a></code>, <code><a href="base.html#topic+plot">plot</a></code>, <code><a href="#topic+print.density.lengths">print.density.lengths</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)
direction &lt;- c(0,0,1)
     
# Compute the appertaining directional line for each location
loc.id &lt;- which_lines(ACM[, 1:3], direction)
     
# Estimate stratum lengths
gl &lt;- getlen(ACM$MAT3, ACM[, 1:3], loc.id, direction)

# Compute the histograms
hgl &lt;- hist(gl, plot = FALSE)

# Plot the histograms
plot(hgl, col = "#efffef")
</code></pre>

<hr>
<h2 id='plot.lengths'>Plot Stratum Lengths</h2><span id='topic+plot.lengths'></span>

<h3>Description</h3>

<p>The function makes a graphical representation of the stratum lengths.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lengths'
plot(x, ..., log = FALSE, zeros.rm = TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.lengths_+3A_x">x</code></td>
<td>
<p>an object of the class <code>lengths</code>, typically with the output of the function <code><a href="#topic+getlen">getlen</a></code>.</p>
</td></tr>
<tr><td><code id="plot.lengths_+3A_...">...</code></td>
<td>
<p>other arguments to pass to the function <code><a href="graphics.html#topic+boxplot">boxplot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.lengths_+3A_log">log</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the logarithm of the stratum lengths will be plotted. It is <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="plot.lengths_+3A_zeros.rm">zeros.rm</code></td>
<td>
<p>a logical value. If <code>FALSE</code>, the image will be drawn by including zero values. It is <code>TRUE</code> by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The box-and-whisker plots give some information about the distribution of the stratum lengths for the observed categories along a given direction.</p>


<h3>Value</h3>

<p>An image is produced on the current graphics device; by the use of <code><a href="#topic+boxplot.lengths">boxplot.lengths</a></code>, the same image is produced. The function returns a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>stats</code></td>
<td>
<p>a matrix containing the values used to plot the box-and-whisker plots.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>a vector with the number of observations for each category.</p>
</td></tr>
<tr><td><code>conf</code></td>
<td>
<p>a matrix containing further values to draw the lower and upper extremes of the notch.</p>
</td></tr>
<tr><td><code>out</code></td>
<td>
<p>a vectors with the values of the outlier points.</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>a vector whose elements indicate to which category the outlier belongs.</p>
</td></tr>
<tr><td><code>names</code></td>
<td>
<p>a character vector with the names of each category.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+boxplot.lengths">boxplot.lengths</a></code>, <code><a href="graphics.html#topic+boxplot">boxplot</a></code>, <code><a href="#topic+getlen">getlen</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)
direction &lt;- c(0,0,1)
     
# Compute the appertaining directional line for each location
loc.id &lt;- which_lines(ACM[, 1:3], direction)
     
# Estimate stratum lengths
gl &lt;- getlen(ACM$MAT3, ACM[, 1:3], loc.id, direction)

# Plot the object gl

plot(gl)
</code></pre>

<hr>
<h2 id='plot.transiogram'>Plot One-dimensional Transiograms</h2><span id='topic+plot.transiogram'></span>

<h3>Description</h3>

<p>The function makes a graphical representation of transition probabilities by the use of transiogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'transiogram'
plot(x, ..., main, legend = FALSE, ci = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.transiogram_+3A_x">x</code></td>
<td>
<p>an object of the class <code>transiogram</code>, typically with the output of the function <code><a href="#topic+transiogram">transiogram</a></code> or <code><a href="#topic+predict.tpfit">predict.tpfit</a></code>.</p>
</td></tr>
<tr><td><code id="plot.transiogram_+3A_...">...</code></td>
<td>
<p>other arguments to pass to the function <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.transiogram_+3A_main">main</code></td>
<td>
<p>the main title (on top) whose font and size are fixed.</p>
</td></tr>
<tr><td><code id="plot.transiogram_+3A_legend">legend</code></td>
<td>
<p>a logical value; if <code>TRUE</code>, the legend is plot on the bottom.</p>
</td></tr>
<tr><td><code id="plot.transiogram_+3A_ci">ci</code></td>
<td>
<p>a numerical value in the interval (0, 1) denoting the confidence of the interval around transition probabilities. If <code>NULL</code> (by default), no confidence interval is plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Transiogram is a diagram which is drawn for a single pair of categories in the direction <code class="reqn">\phi</code>. It shows the transition probabilities in the <code class="reqn">y</code>-axis for some specific lags in the <code class="reqn">x</code>-axis.
</p>
<p>Confidence intervals are computed on the log odds of the transition probabilities. The approximation of the confidence bounds is based on the delta method applied on the logistic transformation.
</p>


<h3>Value</h3>

<p>An image is produced on the current graphics device. No values are returned.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>Carle, S. F., Fogg, G. E. (1997) Modelling Spatial Variability with One and Multidimensional Continuous-Lag Markov Chains. <em>Mathematical Geology</em>, <b>29</b>(7), 891-918.
</p>
<p>Li, W. (2007) Transiograms for Characterizing Spatial Variability of Soil Classes. <em>Soil Science Society of America Journal</em>, <b>71</b>(3), 881-893.
</p>
<p>Sartore, L. (2010) Geostatistical models for 3-D data. M.Phil. thesis, Ca' Foscari University of Venice.</p>


<h3>See Also</h3>

<p><code><a href="#topic+tpfit">tpfit</a></code>, <code><a href="#topic+predict.tpfit">predict.tpfit</a></code>, <code><a href="#topic+mixplot">mixplot</a></code>, <code><a href="#topic+image.multi_tpfit">image.multi_tpfit</a></code>, <code><a href="base.html#topic+plot">plot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Estimate empirical transition 
# probabilities by points
ETr &lt;- transiogram(ACM$MAT3, ACM[, 1:3], c(0, 0, 1), 100, 100)

# Estimate the transition rate matrix
RTm &lt;- tpfit(ACM$MAT3, ACM[, 1:3], c(0, 0, 1))

# Compute transition probabilities 
# from the one-dimensional MC model
TPr &lt;- predict(RTm, lags = ETr$lags)

# Plot empirical transition probabilities
plot(ETr, type = "l", ci = 0.99)

# Plot theoretical transition probabilities
plot(TPr, type = "l")
</code></pre>

<hr>
<h2 id='predict.multi_tpfit'>Compute Theoretical Multidimensional Transiograms</h2><span id='topic+predict.multi_tpfit'></span>

<h3>Description</h3>

<p>The function computes theoretical transition probabilities of a <code class="reqn">d</code>-D continuous-lag spatial Markov chain for a specified set of lags.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multi_tpfit'
predict(object, lags, byrow = TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.multi_tpfit_+3A_object">object</code></td>
<td>
<p>an object of the class <code>multi_tpfit</code>, typically with the output of the function <code><a href="#topic+multi_tpfit">multi_tpfit</a></code>.</p>
</td></tr>
<tr><td><code id="predict.multi_tpfit_+3A_lags">lags</code></td>
<td>
<p>a lag vector or matrix of <code class="reqn">d</code>-D lags.</p>
</td></tr>
<tr><td><code id="predict.multi_tpfit_+3A_byrow">byrow</code></td>
<td>
<p>a logical value; if <code>TRUE</code> (by default), each row of matrix argument <code>lags</code> will be considered as a lag vector.</p>
</td></tr>
<tr><td><code id="predict.multi_tpfit_+3A_...">...</code></td>
<td>
<p>further arguments passed from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code class="reqn">d</code>-D continuous-lag spatial Markov chain is probabilistic model which is developed by interpolation of the transition rate matrices computed for the main directions. It defines the transition probability <code class="reqn">\Pr(Z(s + h) = z_k | Z(s) = z_j)</code> through the entry <code class="reqn">t_{jk}</code> of the following matrix
</p>
<p style="text-align: center;"><code class="reqn">T = \mbox{expm} (\Vert h \Vert R),</code>
</p>

<p>where <code class="reqn">h</code> is the lag vector and the entries of <code class="reqn">R</code> are ellipsoidally interpolated.
</p>


<h3>Value</h3>

<p>An object of the class <code>multi_transiogram</code> is returned. The <code><a href="#topic+print.multi_transiogram">print.multi_transiogram</a></code> function is used to print computed probabilities. The object is a list with the following components: 
</p>
<table role = "presentation">
<tr><td><code>Tmat</code></td>
<td>
<p>a 3-D array containing the probabilities.</p>
</td></tr>
<tr><td><code>lags</code></td>
<td>
<p>a matrix containing the lag vectors.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>a character string which specifies that computed probabilities are theoretical.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>Carle, S. F., Fogg, G. E. (1997) Modelling Spatial Variability with One and Multidimensional Continuous-Lag Markov Chains. <em>Mathematical Geology</em>, <b>29</b>(7), 891-918.
</p>
<p>Sartore, L. (2010) Geostatistical models for 3-D data. M.Phil. thesis, Ca' Foscari University of Venice.</p>


<h3>See Also</h3>

<p><code><a href="#topic+multi_tpfit">multi_tpfit</a></code>, <code><a href="#topic+print.multi_tpfit">print.multi_tpfit</a></code>, <code><a href="#topic+image.multi_tpfit">image.multi_tpfit</a></code>, <code><a href="#topic+tpfit">tpfit</a></code>, <code><a href="#topic+transiogram">transiogram</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Estimate the parameters of a 
# multidimensional MC model
RTm &lt;- multi_tpfit(ACM$MAT3, ACM[, 1:3])

# Generate the matrix of 
# multidimensional lags
lags &lt;- expand.grid(X=-1:1, Y=-1:1, Z=-1:1)
lags &lt;- as.matrix(lags)

# Compute transition probabilities 
# from the multidimensional MC model
predict(RTm, lags)
</code></pre>

<hr>
<h2 id='predict.tpfit'>Compute Theoretical One-dimensional Transiograms</h2><span id='topic+predict.tpfit'></span>

<h3>Description</h3>

<p>The function computes theoretical transition probabilities of a 1-D continuous-lag spatial Markov chain for a specified set of lags.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tpfit'
predict(object, lags, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.tpfit_+3A_object">object</code></td>
<td>
<p>an object of the class <code>tpfit</code>, typically with the output of the function <code><a href="#topic+tpfit">tpfit</a></code>.</p>
</td></tr>
<tr><td><code id="predict.tpfit_+3A_lags">lags</code></td>
<td>
<p>a vector of 1-D lags.</p>
</td></tr>
<tr><td><code id="predict.tpfit_+3A_...">...</code></td>
<td>
<p>further arguments passed from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A 1-D continuous-lag spatial Markov chain is probabilistic model which involves a transition rate matrix <code class="reqn">R</code> computed for the direction <code class="reqn">\phi</code>. It defines the transition probability <code class="reqn">\Pr(Z(s + h) = z_k | Z(s) = z_j)</code> through the entry <code class="reqn">t_{jk}</code> of the following matrix
</p>
<p style="text-align: center;"><code class="reqn">T = \mbox{expm} (h R),</code>
</p>

<p>where <code class="reqn">h</code> is a positive lag value.
</p>


<h3>Value</h3>

<p>An object of the class <code>transiogram</code> is returned. The function <code><a href="#topic+print.transiogram">print.transiogram</a></code> is used to print computed probabilities. The object is a list with the following components: 
</p>
<table role = "presentation">
<tr><td><code>Tmat</code></td>
<td>
<p>a 3-D array containing the probabilities.</p>
</td></tr>
<tr><td><code>lags</code></td>
<td>
<p>a vector containing one-dimensional lags.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>a character string which specifies that computed probabilities are theoretical.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>Carle, S. F., Fogg, G. E. (1997) Modelling Spatial Variability with One and Multidimensional Continuous-Lag Markov Chains. <em>Mathematical Geology</em>, <b>29</b>(7), 891-918.
</p>
<p>Sartore, L. (2010) Geostatistical models for 3-D data. M.Phil. thesis, Ca' Foscari University of Venice.</p>


<h3>See Also</h3>

<p><code><a href="#topic+tpfit">tpfit</a></code>, <code><a href="#topic+print.tpfit">print.tpfit</a></code>, <code><a href="#topic+plot.transiogram">plot.transiogram</a></code>, <code><a href="#topic+transiogram">transiogram</a></code>, <code><a href="#topic+multi_tpfit">multi_tpfit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Estimate the parameters of a 
# one-dimensional MC model
RTm &lt;- tpfit(ACM$MAT3, ACM[, 1:3], c(0, 0, 1))

# Compute transition probabilities 
# from the one-dimensional MC model
predict(RTm, lags = 0:2/2)
</code></pre>

<hr>
<h2 id='print.density.lengths'>Printing Empirical Densities Estimates of Stratum Lengths</h2><span id='topic+print.density.lengths'></span>

<h3>Description</h3>

<p>he function a summary of the empirical density stratum lengths calculated by <code><a href="#topic+density.lengths">density.lengths</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'density.lengths'
print(x, digits = NULL, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.density.lengths_+3A_x">x</code></td>
<td>
<p>an object of the class <code>density.lengths</code>, typically with the output of the function <code><a href="#topic+density.lengths">density.lengths</a></code>.</p>
</td></tr>
<tr><td><code id="print.density.lengths_+3A_digits">digits</code></td>
<td>
<p>minimal number of digits, see <code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="print.density.lengths_+3A_...">...</code></td>
<td>
<p>further arguments to pass to the function <code><a href="base.html#topic+summary.data.frame">summary.data.frame</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary of the empirical distributions is printed on the screen or other output devices. No values are returned.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+density.lengths">density.lengths</a></code>, <code><a href="#topic+plot.density.lengths">plot.density.lengths</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)
direction &lt;- c(0,0,1)
     
# Compute the appartaining directional line for each location
loc.id &lt;- which_lines(ACM[, 1:3], direction)
     
# Estimate stratum lengths
gl &lt;- getlen(ACM$MAT3, ACM[, 1:3], loc.id, direction)

# Compute the empirical densities of stratum lengths
dgl &lt;- density(gl)

# Print the empirical densities of stratum lengths
print(dgl)
</code></pre>

<hr>
<h2 id='print.lengths'>Printing Stratum Lengths for Each Observed Category</h2><span id='topic+print.lengths'></span>

<h3>Description</h3>

<p>The function prints stratum lengths given by <code><a href="#topic+getlen">getlen</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lengths'
print(x, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.lengths_+3A_x">x</code></td>
<td>
<p>an object of the class <code>lengths</code>, typically with the output of the function <code><a href="#topic+getlen">getlen</a></code>.</p>
</td></tr>
<tr><td><code id="print.lengths_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Stratum lengths grouped by category are printed on the screen or other output devices. No values are returned.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+getlen">getlen</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)
direction &lt;- c(0,0,1)
     
# Compute the appertaining directional line for each location
loc.id &lt;- which_lines(ACM[, 1:3], direction)
     
# Estimate stratum lengths
gl &lt;- getlen(ACM$MAT3, ACM[, 1:3], loc.id, direction)

# Print stratum lengths
print(gl)
</code></pre>

<hr>
<h2 id='print.multi_tpfit'>Printing Model Parameters for Multidimensional Continuous Lag Spatial MC</h2><span id='topic+print.multi_tpfit'></span>

<h3>Description</h3>

<p>The function prints parameter estimation results given by <code><a href="#topic+multi_tpfit">multi_tpfit</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multi_tpfit'
print(x, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.multi_tpfit_+3A_x">x</code></td>
<td>
<p>an object of the class <code>multi_tpfit</code>, typically with the output of the function <code><a href="#topic+multi_tpfit">multi_tpfit</a></code>.</p>
</td></tr>
<tr><td><code id="print.multi_tpfit_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimation results are printed on the screen or other output devices. No values are returned.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+multi_tpfit">multi_tpfit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Estimate the parameters of a 
# multidimensional MC models
MoPa &lt;- multi_tpfit(ACM$MAT5, ACM[, 1:3])

# Print results
print(MoPa)
</code></pre>

<hr>
<h2 id='print.multi_transiogram'>Printing Theoretical Multidimensional Transiograms</h2><span id='topic+print.multi_transiogram'></span>

<h3>Description</h3>

<p>The function prints theoretical transition probabilities given by <code><a href="#topic+predict.multi_tpfit">predict.multi_tpfit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multi_transiogram'
print(x, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.multi_transiogram_+3A_x">x</code></td>
<td>
<p>an object of the class <code>multi_transiogram</code>, typically with the output of the function <code><a href="#topic+predict.multi_tpfit">predict.multi_tpfit</a></code>.</p>
</td></tr>
<tr><td><code id="print.multi_transiogram_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Transition probabilities are printed on the screen or other output devices. No values are returned.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.multi_tpfit">predict.multi_tpfit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Estimate the parameters of a 
# multidimensional MC model
RTm &lt;- multi_tpfit(ACM$MAT3, ACM[, 1:3])

# Generate the matrix of 
# multidimensional lags
lags &lt;- expand.grid(X=-1:1, Y=-1:1, Z=-1:1)
lags &lt;- as.matrix(lags)

# Compute transition probabilities 
# from the multidimensional MC model
TrPr &lt;- predict(RTm, lags)

# Print results
print(TrPr)
</code></pre>

<hr>
<h2 id='print.summary.lengths'>Printing Stratum Lengths Summary for Each Observed Category</h2><span id='topic+print.summary.lengths'></span>

<h3>Description</h3>

<p>The function prints the summary of stratum lengths given by <code><a href="#topic+summary.lengths">summary.lengths</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.lengths'
print(x, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.lengths_+3A_x">x</code></td>
<td>
<p>an object of the class <code>summary.lengths</code>, typically with the output of the function <code><a href="#topic+summary.lengths">summary.lengths</a></code>.</p>
</td></tr>
<tr><td><code id="print.summary.lengths_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The summary of stratum lengths grouped by category is printed on the screen or other output devices. No values are returned.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+getlen">getlen</a></code>, <code><a href="#topic+summary.lengths">summary.lengths</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)
direction &lt;- c(0,0,1)
     
# Compute the appartaining directional line for each location
loc.id &lt;- which_lines(ACM[, 1:3], direction)
     
# Estimate stratum lengths
gl &lt;- getlen(ACM$MAT3, ACM[, 1:3], loc.id, direction)

# Summarize the stratum lengths
sgl &lt;- summary(gl)

# Print the summary of stratum lengths
print(sgl)
</code></pre>

<hr>
<h2 id='print.tpfit'>Printing Model Parameters for One-dimensional Continuous Lag Spatial MC</h2><span id='topic+print.tpfit'></span>

<h3>Description</h3>

<p>The function prints parameter estimation results given by <code><a href="#topic+tpfit">tpfit</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tpfit'
print(x, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.tpfit_+3A_x">x</code></td>
<td>
<p>an object of the class <code>tpfit</code>, typically with the output of the function <code><a href="#topic+tpfit">tpfit</a></code>.</p>
</td></tr>
<tr><td><code id="print.tpfit_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimation results are printed on the screen or other output devices. No values are returned.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+tpfit">tpfit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Estimate the parameters of a 
# one-dimensional MC model
MoPa &lt;- tpfit(ACM$MAT5, ACM[, 1:3], c(0, 0, 1))

# Print results
print(MoPa)
</code></pre>

<hr>
<h2 id='print.transiogram'>Printing Theoretical or Empirical One-dimensional Transiograms</h2><span id='topic+print.transiogram'></span>

<h3>Description</h3>

<p>The function prints transition probabilities given by <code><a href="#topic+predict.multi_tpfit">predict.multi_tpfit</a></code> or <code><a href="#topic+transiogram">transiogram</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'transiogram'
print(x, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.transiogram_+3A_x">x</code></td>
<td>
<p>an object of the class <code>transiogram</code>, typically with the output of the function <code><a href="#topic+predict.tpfit">predict.tpfit</a></code> or <code><a href="#topic+transiogram">transiogram</a></code>.</p>
</td></tr>
<tr><td><code id="print.transiogram_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Transition probabilities are printed on the screen or other output devices. No values are returned.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+transiogram">transiogram</a></code>, <code><a href="#topic+predict.tpfit">predict.tpfit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Estimate the parameters of a 
# one-dimensional MC model
RTm &lt;- tpfit(ACM$MAT5, ACM[, 1:3], c(0, 0, 1))

# Compute theoretical transition probabilities 
# from the one-dimensional MC model
TTPr &lt;- predict(RTm, lags = 0:2/2)

# Compute empirical transition probabilities 
ETPr &lt;- transiogram(ACM$MAT5, ACM[, 1:3], c(0, 0, 1), 200, 20)

# Print results
print(TTPr)
print(ETPr)
</code></pre>

<hr>
<h2 id='quench'>Conditional Simulation Adjuster Via Quenching Algorithm</h2><span id='topic+quench'></span>

<h3>Description</h3>

<p>The function adjusts a simulated random field generated by the <code><a href="#topic+sim">sim</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quench(x, data, coords, sim, GA = FALSE, optype = c("param", 
       "fullprobs", "semiprobs", "coordprobs"), max.it = 1000,
       knn = 12)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quench_+3A_x">x</code></td>
<td>
<p>an object of the class <code>multi_tpfit</code>, typically with the output of the function <code><a href="#topic+multi_tpfit">multi_tpfit</a></code>.</p>
</td></tr>
<tr><td><code id="quench_+3A_data">data</code></td>
<td>
<p>a categorical data vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="quench_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times d</code> matrix where each row denotes the <code class="reqn">d</code>-D coordinates of data locations.</p>
</td></tr>
<tr><td><code id="quench_+3A_sim">sim</code></td>
<td>
<p>an object of the class <code>spsim</code>, it is usually the output of the function <code><a href="#topic+sim">sim</a></code>.</p>
</td></tr>
<tr><td><code id="quench_+3A_ga">GA</code></td>
<td>
<p>a logical value; if <code>TRUE</code>, the function performs the Genetic Algorithm instead of the Simulated Annealing.</p>
</td></tr>
<tr><td><code id="quench_+3A_optype">optype</code></td>
<td>
<p>a character which denotes the objective function to compute when the optimization is performed.</p>
</td></tr>
<tr><td><code id="quench_+3A_max.it">max.it</code></td>
<td>
<p>a numerical value which specifies the maximum number of iterations to stop the optimization algorithm. For proper results, it should be a multiple of the number of simulation points.</p>
</td></tr>
<tr><td><code id="quench_+3A_knn">knn</code></td>
<td>
<p>an integer value which specifies the number of k-nearest neighbours for each simulation point. An optimal number is between 4 and 12. If <code>NULL</code> all observations are considered (just for very small dataset!!). It is <code>12</code> by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method perform a simulated annealing or a genetic algorithm to modify the simulation results, in order to reduce artifacts effects. In practice, each simulated configuration is adjusted to reach a pattern similar to the observed sample data. There are several objective functions for this purpose, by setting <code>optype</code> equal to <code>"param"</code> the optimization is performed through parametric methods. The alternatives <code>"fullprobs"</code> and <code>"semiprobs"</code> are based on transition probabilities computed among simulation points, while the option <code>"coordprobs"</code> is based on transition probabilities calculated among observation and simulation points.
</p>
<p>This procedure should be executed by setting <code>max.it</code> equal at least to the simulation grid size, or its multiples.
</p>


<h3>Value</h3>

<p>A data frame containing the simulation grid, the simulated random field, predicted values and the approximated probabilities.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>Carle, S. F., Fogg, G. E. (1996) Transition Probability-Based Indicator Geostatistics. <em>Mathematical Geosciences</em>, <b>28</b>(4), 453-476.
</p>
<p>Carle, S. F. (1999) T-PROGS: Transition Probability Geostatistical Software. University of California, Davis.
</p>
<p>Sartore, L. (2010) Geostatistical models for 3-D data. M.Phil. thesis, Ca' Foscari University of Venice.
</p>
<p>Weise, T. (2009) <em>Global Optimization Algorithms - Theory and Application</em>. <a href="https://archive.org/details/Thomas_Weise__Global_Optimization_Algorithms_Theory_and_Application">https://archive.org/details/Thomas_Weise__Global_Optimization_Algorithms_Theory_and_Application</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_ck">sim_ck</a></code>, <code><a href="#topic+sim_ik">sim_ik</a></code>, <code><a href="#topic+sim_mcs">sim_mcs</a></code>, <code><a href="#topic+sim_path">sim_path</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Model parameters estimation for the
# multinomial categorical simulation
x &lt;- multi_tpfit(ACM$MAT5, ACM[, 1:3])

# Generate the simulation grid
mygrid &lt;- list()
mygrid$X &lt;- seq(min(ACM$X), max(ACM$X), length = 20)
mygrid$Y &lt;- seq(min(ACM$Y), max(ACM$Y), length = 20)
mygrid$Z &lt;- -40 * 0:9 - 1
mygrid &lt;- as.matrix(expand.grid(mygrid$X, mygrid$Y, mygrid$Z))

# Simulate the random field through
# Ordinary Indicator Kriging algorithm
myOIKSim &lt;- sim_ik(x, ACM$MAT5, ACM[, 1:3], mygrid)
 
# Perform the quenching algorithm 
# to adjust simulation
quench(x, ACM$MAT5, ACM[, 1:3], myOIKSim, optype = "coordprobs",
       max.it = 2, knn = 12) 
</code></pre>

<hr>
<h2 id='setCores'>Set the number of CPU cores for HPC</h2><span id='topic+setCores'></span>

<h3>Description</h3>

<p>The function set the number of CPU cores for parallel computation by the use of OpenMP library (<a href="https://www.openmp.org/">https://www.openmp.org/</a>). If the package was not complied with the library OpenMP (&gt;= 3.0), this function is disabled.</p>


<h3>Usage</h3>

<pre><code class='language-R'>setCores(n)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setCores_+3A_n">n</code></td>
<td>
<p>an integer value denoting the number of CPU cores to use; if it exceeds the total number of cores, all of them will be used. If missing, the number of CPU cores in use will be displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the package is loaded, only one CPU core is used.
</p>


<h3>Value</h3>

<p>The total number of CPU cores in use will be returned and a message will be displayed. If the package was not complied with the library OpenMP (&gt;= 3.0), the value one will be returned.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>SunTM ONE Studio 8 (2003) <em>OpenMP API User's Guide</em>. Sun Microsystems Inc., Santa Clara, U.S.A.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Display the number of CPU cores in use
setCores()

#Set 2 CPU cores for parallel computation
setCores(2)

#Set 1 CPU core for serial computation
setCores(1)
</code></pre>

<hr>
<h2 id='sim'>Random Field Simulation</h2><span id='topic+sim'></span>

<h3>Description</h3>

<p>The function simulates a random field. The simulation methods available are based on Indicator Kriging techniques (IK and CK), Fixed and Random Path (PATH) and Multinomial Categorical Simulation (MCS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim(x, data, coords, grid, method = "ik", ..., entropy = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_+3A_x">x</code></td>
<td>
<p>an object of the class <code>multi_tpfit</code>, typically with the output of the function <code><a href="#topic+multi_tpfit">multi_tpfit</a></code>.</p>
</td></tr>
<tr><td><code id="sim_+3A_data">data</code></td>
<td>
<p>a categorical data vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="sim_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times d</code> matrix where each row denotes the <code class="reqn">d</code>-D coordinates of data locations.</p>
</td></tr>
<tr><td><code id="sim_+3A_grid">grid</code></td>
<td>
<p>an <code class="reqn">m \times d</code> matrix where each row denotes the <code class="reqn">d</code>-D coordinates in the simulation grid.</p>
</td></tr>
<tr><td><code id="sim_+3A_method">method</code></td>
<td>
<p>a character object specifying the method to simulate the random field. Possible choises are <code>"ik"</code> (by default) for the indicator Kriging, <code>"ck"</code> for the indicator coKriging, <code>"path"</code> for the fixed and random path and <code>"mcs"</code> for the multinomial categorical simulation method.</p>
</td></tr>
<tr><td><code id="sim_+3A_...">...</code></td>
<td>
<p>other arguments to pass to the functions <code><a href="#topic+sim_ik">sim_ik</a></code>, <code><a href="#topic+sim_ck">sim_ck</a></code>, <code><a href="#topic+sim_path">sim_path</a></code> or <code><a href="#topic+sim_mcs">sim_mcs</a></code>.</p>
</td></tr>
<tr><td><code id="sim_+3A_entropy">entropy</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the prediction uncertainties are computed through the entropy (and standardized entropy). The default value is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The methods implemented compute the approximation of posterior probabilities
</p>
<p style="text-align: center;"><code class="reqn">\Pr\left(Z(\mathbf{s}_0) = z_k \left\vert \bigcap_{i = 1}^n Z(\mathbf{s}_i) = z(\mathbf{s}_i)\right.\right).</code>
</p>

<p><code class="reqn">\hspace{0cm}</code>
</p>
<p>Once the probabilities are calculated for all the points in the simulation grid, the predictions (based on most probable category) and simulations are returned.
</p>


<h3>Value</h3>

<p>A data frame containing the simulation grid, the simulated random field, predicted values and the approximated probabilities is returned. Two extra columns respectively denoting the entropy and standardized entorpy are bindend to the data frame when argument <code>entropy = TRUE</code>.</p>


<h3>References</h3>

<p>Allard, D., D'Or, D., Froidevaux, R. (2011) An efficient maximum entropy approach for categorical variable prediction. <em>European Journal of Soil Science</em>, <b>62</b>(3), 381-393.
</p>
<p>Carle, S. F., Fogg, G. E. (1996) Transition Probability-Based Indicator Geostatistics. <em>Mathematical Geosciences</em>, <b>28</b>(4), 453-476.
</p>
<p>Carle, S. F. (1999) T-PROGS: Transition Probability Geostatistical Software. University of California, Davis.
</p>
<p>Li, W. (2007) A Fixed-Path Markov Chain Algorithm for Conditional Simulation of Discrete Spatial Variables. <em>Mathematical Geology</em>, <b>39</b>(2), 159-176.
</p>
<p>Li, W. (2007) Markov Chain Random Fields for Estimation of Categorical Variables. <em>Mathematical Geology</em>, <b>39</b>(June), 321-335.
</p>
<p>Pickard, D. K. (1980) Unilateral Markov Fields. <em>Advances in Applied Probability</em>, <b>12</b>(3), 655-671.
</p>
<p>Sartore, L. (2010) Geostatistical models for 3-D data. M.Phil. thesis, Ca' Foscari University of Venice.
</p>
<p>Weise, T. (2009) <em>Global Optimization Algorithms - Theory and Application</em>. <a href="https://archive.org/details/Thomas_Weise__Global_Optimization_Algorithms_Theory_and_Application">https://archive.org/details/Thomas_Weise__Global_Optimization_Algorithms_Theory_and_Application</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_ik">sim_ik</a></code>, <code><a href="#topic+sim_ck">sim_ck</a></code>, <code><a href="#topic+sim_path">sim_path</a></code>, <code><a href="#topic+sim_mcs">sim_mcs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Model parameters estimation for the
# multinomial categorical simulation
x &lt;- multi_tpfit(ACM$MAT5, ACM[, 1:3])

# Generate the simulation grid
mygrid &lt;- list()
mygrid$X &lt;- seq(min(ACM$X), max(ACM$X), length = 20)
mygrid$Y &lt;- seq(min(ACM$Y), max(ACM$Y), length = 20)
mygrid$Z &lt;- -40 * 0:9 - 1
mygrid &lt;- as.matrix(expand.grid(mygrid$X, mygrid$Y, mygrid$Z))

# Simulate the random field through
# Simple Indicator Kriging algorithm and
mySim &lt;- sim(x, ACM$MAT5, ACM[, 1:3], mygrid)
</code></pre>

<hr>
<h2 id='sim_ck'>Conditional Simulation Based on Indicator Cokriging</h2><span id='topic+sim_ck'></span>

<h3>Description</h3>

<p>The function simulates a random field through the Indicator Cokriging technique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_ck(x, data, coords, grid, knn = 12, ordinary = TRUE, entropy = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_ck_+3A_x">x</code></td>
<td>
<p>an object of the class <code>multi_tpfit</code>, typically with the output of the function <code><a href="#topic+multi_tpfit">multi_tpfit</a></code>.</p>
</td></tr>
<tr><td><code id="sim_ck_+3A_data">data</code></td>
<td>
<p>a categorical data vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="sim_ck_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times d</code> matrix where each row denotes the <code class="reqn">d</code>-D coordinates of data locations.</p>
</td></tr>
<tr><td><code id="sim_ck_+3A_grid">grid</code></td>
<td>
<p>an <code class="reqn">m \times d</code> matrix where each row denotes the <code class="reqn">d</code>-D coordinates in the simulation grid.</p>
</td></tr>
<tr><td><code id="sim_ck_+3A_knn">knn</code></td>
<td>
<p>an integer value which specifies the number of k-nearest neighbours for each simulation point. An optimal number is between 4 and 12. If <code>NULL</code> all observations are considered (just for very small dataset!!). It is <code>12</code> by default.</p>
</td></tr>
<tr><td><code id="sim_ck_+3A_ordinary">ordinary</code></td>
<td>
<p>a logical value; if <code>FALSE</code>, the probabilities are computed through the Simple coKriging technique, otherwise the Ordinary coKriging method is used.</p>
</td></tr>
<tr><td><code id="sim_ck_+3A_entropy">entropy</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the prediction uncertainties are computed through the entropy (and standardized entropy). The default value is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method computes an approximation of posterior probabilities
</p>
<p style="text-align: center;"><code class="reqn">\Pr\left(Z(\mathbf{s}_0) = z_k \left\vert \bigcap_{i = 1}^n Z(\mathbf{s}_i) = z(\mathbf{s}_i)\right.\right).</code>
</p>

<p><code class="reqn">\hspace{0cm}</code>
</p>
<p>The probability is calculated as the weighted sum of indicator variables which denote the presence of the <code class="reqn">k</code>-th category in observed points <code class="reqn">\mathbf{s}_i</code>. Weights involved in the sum are the solution of a system of equations.
</p>
<p>Probabilities approximated are usually truncated and normalized with respect to the probability constraints, because such probabilities might lie outside the interval <code class="reqn">[0, 1]</code>. The normalization procedure is designed such that it is not possible to obtain vectors such that the sum of their probabilities is always equal to one.
</p>
<p>When an initial configuration is simulated, it should be modified to reach a pattern similar to the sample by the use of the <code><a href="#topic+quench">quench</a></code> function.
</p>


<h3>Value</h3>

<p>A data frame containing the simulation grid, the simulated random field, predicted values and the approximated probabilities is returned. Two extra columns respectively denoting the entropy and standardized entorpy are bindend to the data frame when argument <code>entropy = TRUE</code>.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>Carle, S. F., Fogg, G. E. (1996) Transition Probability-Based Indicator Geostatistics. <em>Mathematical Geosciences</em>, <b>28</b>(4), 453-476.
</p>
<p>Carle, S. F. (1999) T-PROGS: Transition Probability Geostatistical Software. University of California, Davis.
</p>
<p>Sartore, L. (2010) Geostatistical models for 3-D data. M.Phil. thesis, Ca' Foscari University of Venice.
</p>
<p>Weise, T. (2009) <em>Global Optimization Algorithms - Theory and Application</em>. <a href="https://archive.org/details/Thomas_Weise__Global_Optimization_Algorithms_Theory_and_Application">https://archive.org/details/Thomas_Weise__Global_Optimization_Algorithms_Theory_and_Application</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_ik">sim_ik</a></code>, <code><a href="#topic+sim_mcs">sim_mcs</a></code>, <code><a href="#topic+sim_path">sim_path</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Model parameters estimation for the
# multinomial categorical simulation
x &lt;- multi_tpfit(ACM$MAT5, ACM[, 1:3])

# Generate the simulation grid
mygrid &lt;- list()
mygrid$X &lt;- seq(min(ACM$X), max(ACM$X), length = 20)
mygrid$Y &lt;- seq(min(ACM$Y), max(ACM$Y), length = 20)
mygrid$Z &lt;- -40 * 0:9 - 1
mygrid &lt;- as.matrix(expand.grid(mygrid$X, mygrid$Y, mygrid$Z))

# Simulate the random field through
# Simple Indicator Cokriging algorithm
mySCKSim &lt;- sim_ck(x, ACM$MAT5, ACM[, 1:3], mygrid, ordinary = FALSE)

# Simulate the random field through
# Ordinary Indicator Cokriging algorithm
myOCKSim &lt;- sim_ck(x, ACM$MAT5, ACM[, 1:3], mygrid)
</code></pre>

<hr>
<h2 id='sim_ik'>Conditional Simulation Based on Indicator Kriging</h2><span id='topic+sim_ik'></span>

<h3>Description</h3>

<p>The function simulates a random field through the Indicator Kriging technique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_ik(x, data, coords, grid, knn = 12, ordinary = TRUE, entropy = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_ik_+3A_x">x</code></td>
<td>
<p>an object of the class <code>multi_tpfit</code>, typically with the output of the function <code><a href="#topic+multi_tpfit">multi_tpfit</a></code>.</p>
</td></tr>
<tr><td><code id="sim_ik_+3A_data">data</code></td>
<td>
<p>a categorical data vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="sim_ik_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times d</code> matrix where each row denotes the <code class="reqn">d</code>-D coordinates of data locations.</p>
</td></tr>
<tr><td><code id="sim_ik_+3A_grid">grid</code></td>
<td>
<p>an <code class="reqn">m \times d</code> matrix where each row denotes the <code class="reqn">d</code>-D coordinates in the simulation grid.</p>
</td></tr>
<tr><td><code id="sim_ik_+3A_knn">knn</code></td>
<td>
<p>an integer value which specifies the number of k-nearest neighbours for each simulation point. An optimal number is between 4 and 12. If <code>NULL</code> all observations are considered (just for very small dataset!!). It is <code>12</code> by default.</p>
</td></tr>
<tr><td><code id="sim_ik_+3A_ordinary">ordinary</code></td>
<td>
<p>a logical value; if <code>FALSE</code>, the probabilities are computed through the Simple Kriging technique, otherwise the Ordinary Kriging method is used.</p>
</td></tr>
<tr><td><code id="sim_ik_+3A_entropy">entropy</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the prediction uncertainties are computed through the entropy (and standardized entropy). The default value is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method computes an approximation of posterior probabilities
</p>
<p style="text-align: center;"><code class="reqn">\Pr\left(Z(\mathbf{s}_0) = z_k \left\vert \bigcap_{i = 1}^n Z(\mathbf{s}_i) = z(\mathbf{s}_i)\right.\right).</code>
</p>

<p><code class="reqn">\hspace{0cm}</code>
</p>
<p>The probability is calculated as the sum of the observed proportion and the weighted sum of indicator variables which denote the presence of the <code class="reqn">k</code>-th category in observed points <code class="reqn">\mathbf{s}_i</code>. Weights involved in the sum are the solution of a system of equations.
</p>
<p>Probabilities approximated are usually truncated and normalized with respect to the probability constraints, because such probabilities might lie outside the interval <code class="reqn">[0, 1]</code>. The normalization procedure is designed such that it is not possible to obtain vectors such that the sum of their probabilities is always equal to one.
</p>
<p>When an initial configuration is simulated, it should be modified to reach a pattern similar to the sample by the use of the <code><a href="#topic+quench">quench</a></code> function.
</p>


<h3>Value</h3>

<p>A data frame containing the simulation grid, the simulated random field, predicted values and the approximated probabilities is returned. Two extra columns respectively denoting the entropy and standardized entorpy are bindend to the data frame when argument <code>entropy = TRUE</code>.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>Carle, S. F., Fogg, G. E. (1996) Transition Probability-Based Indicator Geostatistics. <em>Mathematical Geosciences</em>, <b>28</b>(4), 453-476.
</p>
<p>Carle, S. F. (1999) T-PROGS: Transition Probability Geostatistical Software. University of California, Davis.
</p>
<p>Sartore, L. (2010) Geostatistical models for 3-D data. M.Phil. thesis, Ca' Foscari University of Venice.
</p>
<p>Weise, T. (2009) <em>Global Optimization Algorithms - Theory and Application</em>. <a href="https://archive.org/details/Thomas_Weise__Global_Optimization_Algorithms_Theory_and_Application">https://archive.org/details/Thomas_Weise__Global_Optimization_Algorithms_Theory_and_Application</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_ck">sim_ck</a></code>, <code><a href="#topic+sim_mcs">sim_mcs</a></code>, <code><a href="#topic+sim_path">sim_path</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Model parameters estimation for the
# multinomial categorical simulation
x &lt;- multi_tpfit(ACM$MAT5, ACM[, 1:3])

# Generate the simulation grid
mygrid &lt;- list()
mygrid$X &lt;- seq(min(ACM$X), max(ACM$X), length = 20)
mygrid$Y &lt;- seq(min(ACM$Y), max(ACM$Y), length = 20)
mygrid$Z &lt;- -40 * 0:9 - 1
mygrid &lt;- as.matrix(expand.grid(mygrid$X, mygrid$Y, mygrid$Z))

# Simulate the random field through
# Simple Indicator Kriging algorithm
mySIKSim &lt;- sim_ik(x, ACM$MAT5, ACM[, 1:3], mygrid, ordinary = FALSE)

# Simulate the random field through
# Ordinary Indicator Kriging algorithm
myOIKSim &lt;- sim_ik(x, ACM$MAT5, ACM[, 1:3], mygrid)
</code></pre>

<hr>
<h2 id='sim_mcs'>Multinomial Categorical Simulation</h2><span id='topic+sim_mcs'></span>

<h3>Description</h3>

<p>The function simulates a random field through the Multinomial Categorical Simulation technique (MCS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_mcs(x, data, coords, grid, knn = NULL, entropy = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_mcs_+3A_x">x</code></td>
<td>
<p>an object of the class <code>multi_tpfit</code>, typically with the output of the function <code><a href="#topic+multi_tpfit">multi_tpfit</a></code>.</p>
</td></tr>
<tr><td><code id="sim_mcs_+3A_data">data</code></td>
<td>
<p>a categorical data vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="sim_mcs_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times d</code> matrix where each row denotes the <code class="reqn">d</code>-D coordinates of data locations.</p>
</td></tr>
<tr><td><code id="sim_mcs_+3A_grid">grid</code></td>
<td>
<p>an <code class="reqn">m \times d</code> matrix where each row denotes the <code class="reqn">d</code>-D coordinates in the simulation grid.</p>
</td></tr>
<tr><td><code id="sim_mcs_+3A_knn">knn</code></td>
<td>
<p>an integer value which specifies the number of k-nearest neighbours for each simulation point. If <code>NULL</code> (by default), all observations are considered.</p>
</td></tr>
<tr><td><code id="sim_mcs_+3A_entropy">entropy</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the prediction uncertainties are computed through the entropy (and standardized entropy). The default value is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method computes an approximation of posterior probabilities 
</p>
<p style="text-align: center;"><code class="reqn">\Pr\left(Z(\mathbf{s}_0) = z_k \left\vert \bigcap_{i = 1}^n Z(\mathbf{s}_i) = z(\mathbf{s}_i)\right.\right).</code>
</p>

<p><code class="reqn">\hspace{0cm}</code> The algorithm is based on the Bayesian maximum entropy approach and it honours both the model structure and observed data.
</p>


<h3>Value</h3>

<p>A data frame containing the simulation grid, the simulated random field, predicted values and the approximated probabilities is returned. Two extra columns respectively denoting the entropy and standardized entorpy are bindend to the data frame when argument <code>entropy = TRUE</code>.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>Allard, D., D'Or, D., Froidevaux, R. (2011) An efficient maximum entropy approach for categorical variable prediction. <em>European Journal of Soil Science</em>, <b>62</b>(3), 381-393.
</p>
<p>Sartore, L. (2010) Geostatistical models for 3-D data. M.Phil. thesis, Ca' Foscari University of Venice.</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_ck">sim_ck</a></code>, <code><a href="#topic+sim_ik">sim_ik</a></code>, <code><a href="#topic+sim_path">sim_path</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Model parameters estimation for the
# multinomial categorical simulation
x &lt;- multi_tpfit(ACM$MAT5, ACM[, 1:3])

# Generate the simulation grid
mygrid &lt;- list()
mygrid$X &lt;- seq(min(ACM$X), max(ACM$X), length = 3)
mygrid$Y &lt;- seq(min(ACM$Y), max(ACM$Y), length = 3)
mygrid$Z &lt;- -40 * 0:9 - 1
mygrid &lt;- as.matrix(expand.grid(mygrid$X, mygrid$Y, mygrid$Z))

# Simulate the random field
myMCSim &lt;- sim_mcs(x, ACM$MAT5, ACM[, 1:3], mygrid)
</code></pre>

<hr>
<h2 id='sim_path'>Conditional Simulation Based on Path Algorithms</h2><span id='topic+sim_path'></span>

<h3>Description</h3>

<p>The function simulates a random field through the Fixed Path algorithm or Random Path technique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_path(x, data, coords, grid, radius, fixed = FALSE, entropy = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_path_+3A_x">x</code></td>
<td>
<p>an object of the class <code>multi_tpfit</code>, typically with the output of the function <code><a href="#topic+multi_tpfit">multi_tpfit</a></code>.</p>
</td></tr>
<tr><td><code id="sim_path_+3A_data">data</code></td>
<td>
<p>a categorical data vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="sim_path_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times d</code> matrix where each row denotes the <code class="reqn">d</code>-D coordinates of data locations.</p>
</td></tr>
<tr><td><code id="sim_path_+3A_grid">grid</code></td>
<td>
<p>an <code class="reqn">m \times d</code> matrix where each row denotes the <code class="reqn">d</code>-D coordinates in the simulation grid.</p>
</td></tr>
<tr><td><code id="sim_path_+3A_radius">radius</code></td>
<td>
<p>a numerical value that specifies a proper radius to search the nearest observed points within a <code class="reqn">d</code>-D sphere.</p>
</td></tr>
<tr><td><code id="sim_path_+3A_fixed">fixed</code></td>
<td>
<p>a logical value; if <code>TRUE</code>, the fixed path algorithm is performed. The random path algorithm is performed by default.</p>
</td></tr>
<tr><td><code id="sim_path_+3A_entropy">entropy</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the prediction uncertainties are computed through the entropy (and standardized entropy). The default value is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These methods compute an approximation of posterior probabilities
</p>
<p style="text-align: center;"><code class="reqn">\Pr\left(Z(\mathbf{s}_0) = z_k \left\vert \bigcap_{i = 1}^n Z(\mathbf{s}_i) = z(\mathbf{s}_i)\right.\right).</code>
</p>

<p><code class="reqn">\mbox{\hspace{0cm}}</code> Path algorithms are based on Pickard random fields, so that the states of such chain at any unsampled location depends on the state of its nearest known neighbours in axial directions.
</p>


<h3>Value</h3>

<p>A data frame containing the simulation grid, the simulated random field, predicted values and the approximated probabilities is returned. Two extra columns respectively denoting the entropy and standardized entorpy are bindend to the data frame when argument <code>entropy = TRUE</code>.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>Li, W. (2007) A Fixed-Path Markov Chain Algorithm for Conditional Simulation of Discrete Spatial Variables. <em>Mathematical Geology</em>, <b>39</b>(2), 159-176.
</p>
<p>Li, W. (2007) Markov Chain Random Fields for Estimation of Categorical Variables. <em>Mathematical Geology</em>, <b>39</b>(June), 321-335.
</p>
<p>Pickard, D. K. (1980) Unilateral Markov Fields. <em>Advances in Applied Probability</em>, <b>12</b>(3), 655-671.
</p>
<p>Sartore, L. (2010) Geostatistical models for 3-D data. M.Phil. thesis, Ca' Foscari University of Venice.</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_ck">sim_ck</a></code>, <code><a href="#topic+sim_ik">sim_ik</a></code>, <code><a href="#topic+sim_mcs">sim_mcs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Model parameters estimation for the
# multinomial categorical simulation
x &lt;- multi_tpfit(ACM$MAT5, ACM[, 1:3])

# Generate the simulation grid
mygrid &lt;- list()
mygrid$X &lt;- seq(min(ACM$X), max(ACM$X), length = 20)
mygrid$Y &lt;- seq(min(ACM$Y), max(ACM$Y), length = 20)
mygrid$Z &lt;- -40 * 0:9 - 1
mygrid &lt;- as.matrix(expand.grid(mygrid$X, mygrid$Y, mygrid$Z))

# Simulate the random field through
# the fixed path algorithm
myFixPathSim &lt;- sim_path(x, ACM$MAT5, ACM[, 1:3], mygrid,
                         radius = 50, fixed = TRUE)

# Simulate the random field through
# the random path algorithm
myRndPathSim &lt;- sim_path(x, ACM$MAT5, ACM[, 1:3], mygrid, radius = 50)
</code></pre>

<hr>
<h2 id='summary.lengths'>Summarizing Stratum Lengths</h2><span id='topic+summary.lengths'></span>

<h3>Description</h3>

<p>The function summarizes the stratum lengths for each observed category.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lengths'
summary(object, ..., zeros.rm = TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.lengths_+3A_object">object</code></td>
<td>
<p>an object of the class <code>lengths</code>, typically with the output of the function <code><a href="#topic+getlen">getlen</a></code>.</p>
</td></tr>
<tr><td><code id="summary.lengths_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.lengths_+3A_zeros.rm">zeros.rm</code></td>
<td>
<p>a logical values. If <code>FALSE</code>, summarizing statistics will be computed by including zero values. It is <code>TRUE</code> by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>summary.lengths</code> containing the minimum, the first quartile, the median, the mean, the third quartile and the maximum of the stratum lengths for each observed category.
</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+getlen">getlen</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)
direction &lt;- c(0,0,1)
     
# Compute the appertaining directional line for each location
loc.id &lt;- which_lines(ACM[, 1:3], direction)
     
# Estimate stratum lengths
gl &lt;- getlen(ACM$MAT3, ACM[, 1:3], loc.id, direction)

# Summarize the stratum lengths
sgl &lt;- summary(gl)
</code></pre>

<hr>
<h2 id='tpfit'>One-dimensional Model Parameters Estimation</h2><span id='topic+tpfit'></span>

<h3>Description</h3>

<p>The function estimates the model parameters of a 1-D continuous lag spatial Markov chain. Transition rates matrix along a user defined direction and proportions of categories are computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpfit(data, coords, direction, method = "ml",
      tolerance = pi/8, max.it = 9000, mle = "avg", ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tpfit_+3A_data">data</code></td>
<td>
<p>a categorical data vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="tpfit_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times d</code> matrix where each row denotes the <code class="reqn">d</code>-D coordinates of data locations.</p>
</td></tr>
<tr><td><code id="tpfit_+3A_direction">direction</code></td>
<td>
<p>a <code class="reqn">d</code>-D numerical vector (or versor) which represents the chosen direction.</p>
</td></tr>
<tr><td><code id="tpfit_+3A_method">method</code></td>
<td>
<p>a character object specifying the method to estimate the transition rates. Possible choises are <code>"ml"</code> (by default) for the mean length method, <code>"ils"</code> for the iterated least squares and <code>"me"</code> for the maximum entropy method.</p>
</td></tr>
<tr><td><code id="tpfit_+3A_tolerance">tolerance</code></td>
<td>
<p>a numerical value for the tolerance angle (in radians). It's <code>pi/8</code> by default.</p>
</td></tr>
<tr><td><code id="tpfit_+3A_max.it">max.it</code></td>
<td>
<p>a numerical value which denotes the maximum number of iterations to perform during the optimization phase. It is <code>9000</code> by default and used only when the method is <code>"me"</code>.</p>
</td></tr>
<tr><td><code id="tpfit_+3A_mle">mle</code></td>
<td>
<p>a character value to pass to the function <code><a href="#topic+mlen">mlen</a></code>. It is <code>"avg"</code> by default and not use when the method is <code>"ils"</code>.</p>
</td></tr>
<tr><td><code id="tpfit_+3A_...">...</code></td>
<td>
<p>other arguments to pass to the functions <code><a href="#topic+tpfit_ml">tpfit_ml</a></code>, <code><a href="#topic+tpfit_ils">tpfit_ils</a></code> or <code><a href="#topic+tpfit_me">tpfit_me</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A 1-D continuous-lag spatial Markov chain is probabilistic model which involves a transition rate matrix <code class="reqn">R</code> computed for the direction <code class="reqn">\phi</code>. It defines the transition probability <code class="reqn">\Pr(Z(s + h) = z_k | Z(s) = z_j)</code> through the entry <code class="reqn">t_{jk}</code> of the following matrix
</p>
<p style="text-align: center;"><code class="reqn">T = \mbox{expm} (h R),</code>
</p>

<p>where <code class="reqn">h</code> is a positive lag value.
</p>
<p>Three methods are available to calculate entries of the transition rate matrix. The mean length method is performed by the use of the function <code><a href="#topic+tpfit_ml">tpfit_ml</a></code>, the iterated least squares are applied through the function <code><a href="#topic+tpfit_ils">tpfit_ils</a></code>, while the function <code><a href="#topic+tpfit_me">tpfit_me</a></code> implements the maximum entropy method.
</p>


<h3>Value</h3>

<p>An object of the class <code>tpfit</code> is returned. The function <code><a href="#topic+print.tpfit">print.tpfit</a></code> is used to print the fitted model. The object is a list with the following components: 
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>the transition rates matrix computed for the user defined direction.</p>
</td></tr>
<tr><td><code>prop</code></td>
<td>
<p>a vector containing the proportions of each observed category.</p>
</td></tr>
<tr><td><code>tolerance</code></td>
<td>
<p>a numerical value which denotes the tolerance angle (in radians).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>Carle, S. F., Fogg, G. E. (1997) Modelling Spatial Variability with One and Multidimensional Continuous-Lag Markov Chains. <em>Mathematical Geology</em>, <b>29</b>(7), 891-918.
</p>
<p>Sartore, L. (2010) Geostatistical models for 3-D data. M.Phil. thesis, Ca' Foscari University of Venice.</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.tpfit">predict.tpfit</a></code>, <code><a href="#topic+print.tpfit">print.tpfit</a></code>, <code><a href="#topic+multi_tpfit">multi_tpfit</a></code>, <code><a href="#topic+transiogram">transiogram</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Estimate the parameters of a 
# one-dimensional MC model
tpfit(ACM$MAT5, ACM[, 1:3], c(0, 0, 1))
</code></pre>

<hr>
<h2 id='tpfit_ils'>Iterated Least Squares Method for One-dimensional Model Parameters Estimation</h2><span id='topic+tpfit_ils'></span>

<h3>Description</h3>

<p>The function estimates the model parameters of a 1-D continuous lag spatial Markov chain by the use of the iterated least squares and the bound-constrained Lagrangian methods. Transition rates matrix along a user defined direction and proportions of categories are computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpfit_ils(data, coords, direction, max.dist = Inf, mpoints = 20, 
          tolerance = pi/8, q = 10, echo = FALSE, ..., tpfit)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tpfit_ils_+3A_data">data</code></td>
<td>
<p>a categorical data vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="tpfit_ils_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times d</code> matrix where each row denotes the <code class="reqn">d</code>-D coordinates of data locations.</p>
</td></tr>
<tr><td><code id="tpfit_ils_+3A_direction">direction</code></td>
<td>
<p>a <code class="reqn">d</code>-D numerical vector (or versor) which represents the chosen direction.</p>
</td></tr>
<tr><td><code id="tpfit_ils_+3A_max.dist">max.dist</code></td>
<td>
<p>a numerical value which defines the maximum lag value. It's <code>Inf</code> by default.</p>
</td></tr>
<tr><td><code id="tpfit_ils_+3A_mpoints">mpoints</code></td>
<td>
<p>a numerical value which defines the number of lag intervals.</p>
</td></tr>
<tr><td><code id="tpfit_ils_+3A_tolerance">tolerance</code></td>
<td>
<p>a numerical value for the tolerance angle (in radians). It's <code>pi/8</code> by default.</p>
</td></tr>
<tr><td><code id="tpfit_ils_+3A_q">q</code></td>
<td>
<p>a numerical value greater than one for a constant which controls the growth of the penalization term in the loss function. It is equal to <code>10</code> by default.</p>
</td></tr>
<tr><td><code id="tpfit_ils_+3A_echo">echo</code></td>
<td>
<p>a logical value; if <code>TRUE</code>, the function prints some information about the optimization. It is <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="tpfit_ils_+3A_...">...</code></td>
<td>
<p>other arguments to pass to the function <code><a href="stats.html#topic+nlminb">nlminb</a></code>.</p>
</td></tr>
<tr><td><code id="tpfit_ils_+3A_tpfit">tpfit</code></td>
<td>
<p>an object <code>tpfit</code> to optimize. If missing, the algorithm starts with a null transition rates matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A 1-D continuous-lag spatial Markov chain is probabilistic model which involves a transition rate matrix <code class="reqn">R</code> computed for the direction <code class="reqn">\phi</code>. It defines the transition probability <code class="reqn">\Pr(Z(s + h) = z_k | Z(s) = z_j)</code> through the entry <code class="reqn">t_{jk}</code> of the following matrix
</p>
<p style="text-align: center;"><code class="reqn">T = \mbox{expm} (h R),</code>
</p>

<p>where <code class="reqn">h</code> is a positive lag value.
</p>
<p>To calculate entries of the transition rate matrix, we need to minimize the discrepancies between the empirical transiogram (see <code><a href="#topic+transiogram">transiogram</a></code>) and the predicted transition probabilities.
</p>
<p>By the use of the iterated least squares, the diagonal entries of <code class="reqn">R</code> are constrained to be negative,
while the off-diagonal transition rates are constrained to be positive. Further constraints are considered in order to obtain a proper transition rates matrix.
</p>


<h3>Value</h3>

<p>An object of the class <code>tpfit</code> is returned. The function <code><a href="#topic+print.tpfit">print.tpfit</a></code> is used to print the fitted model. The object is a list with the following components: 
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>the transition rates matrix computed for the user defined direction.</p>
</td></tr>
<tr><td><code>prop</code></td>
<td>
<p>a vector containing the proportions of each observed category.</p>
</td></tr>
<tr><td><code>tolerance</code></td>
<td>
<p>a numerical value which denotes the tolerance angle (in radians).</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>If the process is not stationary, the optimization algorithm does not converge.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>Sartore, L. (2010) Geostatistical models for 3-D data. M.Phil. thesis, Ca' Foscari University of Venice.</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.tpfit">predict.tpfit</a></code>, <code><a href="#topic+print.tpfit">print.tpfit</a></code>, <code><a href="#topic+multi_tpfit_ils">multi_tpfit_ils</a></code>, <code><a href="#topic+transiogram">transiogram</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Estimate the parameters of a 
# one-dimensional MC model
tpfit_ils(ACM$MAT3, ACM[, 1:3], c(0,0,1), 100)
</code></pre>

<hr>
<h2 id='tpfit_me'>Maximum Entropy Method for One-dimensional Model Parameters Estimation</h2><span id='topic+tpfit_me'></span>

<h3>Description</h3>

<p>The function estimates the model parameters of a 1-D continuous lag spatial Markov chain by the use of the maximum entropy method. Transition rates matrix along a user defined direction and proportions of categories are computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpfit_me(data, coords, direction, tolerance = pi/8,
         max.it = 9000, mle = "avg")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tpfit_me_+3A_data">data</code></td>
<td>
<p>a categorical data vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="tpfit_me_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times d</code> matrix where each row denotes the <code class="reqn">d</code>-D coordinates of data locations.</p>
</td></tr>
<tr><td><code id="tpfit_me_+3A_direction">direction</code></td>
<td>
<p>a <code class="reqn">d</code>-D numerical vector (or versor) which represents the chosen direction.</p>
</td></tr>
<tr><td><code id="tpfit_me_+3A_tolerance">tolerance</code></td>
<td>
<p>a numerical value for the tolerance angle (in radians). It is <code>pi/8</code> by default.</p>
</td></tr>
<tr><td><code id="tpfit_me_+3A_max.it">max.it</code></td>
<td>
<p>a numerical value which denotes the maximum number of iterations to perform during the optimization phase. It is <code>9000</code> by default.</p>
</td></tr>
<tr><td><code id="tpfit_me_+3A_mle">mle</code></td>
<td>
<p>a character value to pass to the function <code><a href="#topic+mlen">mlen</a></code>. It is <code>"avg"</code> by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A 1-D continuous-lag spatial Markov chain is probabilistic model which involves a transition rate matrix <code class="reqn">R</code> computed for the direction <code class="reqn">\phi</code>. It defines the transition probability <code class="reqn">\Pr(Z(s + h) = z_k | Z(s) = z_j)</code> through the entry <code class="reqn">t_{jk}</code> of the following matrix
</p>
<p style="text-align: center;"><code class="reqn">T = \mbox{expm} (h R),</code>
</p>

<p>where <code class="reqn">h</code> is a positive lag value.
</p>
<p>To calculate entries of the transition rate matrix, we need to maximize the entropy of the transition probabilities of embedded occurrences along a given direction <code class="reqn">\phi</code>. The entropy is defined as
</p>
<p style="text-align: center;"><code class="reqn">e = - \sum_{k}^K \sum_{j \neq k}^K \tau_{jk, \phi} \log \tau_{jk, \phi},</code>
</p>

<p>where <code class="reqn">\tau_{jk, \phi}</code> are transition probabilities of embedded occurrences. It is maximized by the use of the iterative proportion fitting method.
</p>
<p>When some entries of the matrix <code class="reqn">R</code> are not identifiable, it is suggested to vary the <code>tolerance</code> coefficient or to set the input argument <code>mle</code> to <code>"mlk"</code>.</p>


<h3>Value</h3>

<p>An object of the class <code>tpfit</code> is returned. The function <code><a href="#topic+print.tpfit">print.tpfit</a></code> is used to print the fitted model. The object is a list with the following components: 
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>the transition rates matrix computed for the user defined direction.</p>
</td></tr>
<tr><td><code>prop</code></td>
<td>
<p>a vector containing the proportions of each observed category.</p>
</td></tr>
<tr><td><code>tolerance</code></td>
<td>
<p>a numerical value which denotes the tolerance angle (in radians).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>Carle, S. F., Fogg, G. E. (1997) Modelling Spatial Variability with One and Multidimensional Continuous-Lag Markov Chains. <em>Mathematical Geology</em>, <b>29</b>(7), 891-918.</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.tpfit">predict.tpfit</a></code>, <code><a href="#topic+print.tpfit">print.tpfit</a></code>, <code><a href="#topic+multi_tpfit_me">multi_tpfit_me</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Estimate the parameters of a 
# one-dimensional MC model
tpfit_me(ACM$MAT5, ACM[, 1:3], c(0,0,1))
</code></pre>

<hr>
<h2 id='tpfit_ml'>Mean Length Method for One-dimensional Model Parameters Estimation</h2><span id='topic+tpfit_ml'></span>

<h3>Description</h3>

<p>The function estimates the model parameters of a 1-D continuous lag spatial Markov chain by the use of the mean length method. Transition rates matrix along a user defined direction and proportions of categories are computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpfit_ml(data, coords, direction, tolerance = pi/8, mle = "avg")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tpfit_ml_+3A_data">data</code></td>
<td>
<p>a categorical data vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="tpfit_ml_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times d</code> matrix where each row denotes the <code class="reqn">d</code>-D coordinates of data locations.</p>
</td></tr>
<tr><td><code id="tpfit_ml_+3A_direction">direction</code></td>
<td>
<p>a <code class="reqn">d</code>-D numerical vector (or versor) which represents the chosen direction.</p>
</td></tr>
<tr><td><code id="tpfit_ml_+3A_tolerance">tolerance</code></td>
<td>
<p>a numerical value for the tolerance angle (in radians). It's <code>pi/8</code> by default.</p>
</td></tr>
<tr><td><code id="tpfit_ml_+3A_mle">mle</code></td>
<td>
<p>a character value to pass to the function <code><a href="#topic+mlen">mlen</a></code>. It is <code>"avg"</code> by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A 1-D continuous-lag spatial Markov chain is probabilistic model which involves a transition rate matrix <code class="reqn">R</code> computed for the direction <code class="reqn">\phi</code>. It defines the transition probability <code class="reqn">\Pr(Z(s + h) = z_k | Z(s) = z_j)</code> through the entry <code class="reqn">t_{jk}</code> of the following matrix
</p>
<p style="text-align: center;"><code class="reqn">T = \mbox{expm} (h R),</code>
</p>

<p>where <code class="reqn">h</code> is a positive lag value.
</p>
<p>To calculate entries of the transition rate matrix, we need to compute the mean lengths and the embedded transition probabilities.
</p>
<p>By the use of the mean lengths, diagonal entries of <code class="reqn">R</code> are computed as
</p>
<p style="text-align: center;"><code class="reqn">\hat{r}_{kk} = \frac{1}{\bar{L}_k},</code>
</p>

<p>where <code class="reqn">\bar{L}_k</code> is the mean length of the <code class="reqn">k</code>-th category.
</p>
<p>The off-diagonal transition rates of the matrix <code class="reqn">R</code> are estimated by the use of embedded transition probabilities and mean lengths:
</p>
<p style="text-align: center;"><code class="reqn">\hat{r}_{jk} = \frac{\pi_{jk}}{\bar{L}_k}, \quad \forall j \neq k, </code>
</p>

<p>where <code class="reqn">\pi_{jk}</code> is a specific embedded transition probability.
</p>
<p>When some entries of the matrix <code class="reqn">R</code> are not identifiable, it is suggested to vary the <code>tolerance</code> coefficient or to set the input argument <code>mle</code> to <code>"mlk"</code>.
</p>


<h3>Value</h3>

<p>An object of the class <code>tpfit</code> is returned. The function <code><a href="#topic+print.tpfit">print.tpfit</a></code> is used to print the fitted model. The object is a list with the following components: 
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>the transition rates matrix computed for the user defined direction.</p>
</td></tr>
<tr><td><code>prop</code></td>
<td>
<p>a vector containing the proportions of each observed category.</p>
</td></tr>
<tr><td><code>tolerance</code></td>
<td>
<p>a numerical value which denotes the tolerance angle (in radians).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>Carle, S. F., Fogg, G. E. (1997) Modelling Spatial Variability with One and Multidimensional Continuous-Lag Markov Chains. <em>Mathematical Geology</em>, <b>29</b>(7), 891-918.
</p>
<p>Sartore, L. (2010) Geostatistical models for 3-D data. M.Phil. thesis, Ca' Foscari University of Venice.</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.tpfit">predict.tpfit</a></code>, <code><a href="#topic+print.tpfit">print.tpfit</a></code>, <code><a href="#topic+multi_tpfit_ml">multi_tpfit_ml</a></code>, <code><a href="#topic+transiogram">transiogram</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Estimate the parameters of a 
# one-dimensional MC model
tpfit_ml(ACM$MAT5, ACM[, 1:3], c(0, 0, 1))
</code></pre>

<hr>
<h2 id='transiogram'>Empirical Transition Probabilities Estimation for 1-D MC</h2><span id='topic+transiogram'></span>

<h3>Description</h3>

<p>The function estimates transition probabilities matrices for a <code class="reqn">1</code>-D continuous lag spatial Markov chain.</p>


<h3>Usage</h3>

<pre><code class='language-R'>transiogram(data, coords, direction, max.dist = Inf, 
            mpoints = 20, tolerance = pi / 8, reverse = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transiogram_+3A_data">data</code></td>
<td>
<p>a categorical data vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="transiogram_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times d</code> matrix where each row denotes the <code class="reqn">d</code>-D coordinates of data locations.</p>
</td></tr>
<tr><td><code id="transiogram_+3A_direction">direction</code></td>
<td>
<p>a <code class="reqn">d</code>-D numerical vector (or versor) which represents the chosen direction.</p>
</td></tr>
<tr><td><code id="transiogram_+3A_max.dist">max.dist</code></td>
<td>
<p>a numerical value which defines the maximum lag value. It's <code>Inf</code> by default.</p>
</td></tr>
<tr><td><code id="transiogram_+3A_mpoints">mpoints</code></td>
<td>
<p>a numerical value which defines the number of lag intervals.</p>
</td></tr>
<tr><td><code id="transiogram_+3A_tolerance">tolerance</code></td>
<td>
<p>a numerical value for the tolerance angle (in radians). It's <code>pi/8</code> by default.</p>
</td></tr>
<tr><td><code id="transiogram_+3A_reverse">reverse</code></td>
<td>
<p>a logical value. If <code>TRUE</code> the transition probabilities of the reversible chain are also computed. It's <code>FALSE</code> by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Empirical probabilities are estimated by counting such pairs of observations which satisfy some properties, and by normalizing the result.
</p>
<p>A generic pair of sample points <code class="reqn">s_i</code> and <code class="reqn">s_j</code>, where <code class="reqn">i \neq j</code>, must satisfy the following properties:
</p>

<ul>
<li> <p><code class="reqn">\Vert s_i - s_j \Vert \in [a, a+\frac{m}{n}],</code> where <code class="reqn">a</code> is a non negative real value, while <code class="reqn">m</code> denotes the maximum lag value (<code>max.dist</code>) and <code class="reqn">n</code> is the number of lag intervals (<code>mpoints</code>).
</p>
</li>
<li><p> the lag vector <code class="reqn">h = s_i - s_j</code> must have the same direction of the vector <code class="reqn">\phi</code> (<code>direction</code>) with a certain angular <code>tolerance</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of the class <code>transiogram</code> is returned. The function <code><a href="#topic+print.transiogram">print.transiogram</a></code> is used to print computed probabilities. The object is a list with the following components: 
</p>
<table role = "presentation">
<tr><td><code>Tmat</code></td>
<td>
<p>a 3-D array containing the probabilities.</p>
</td></tr>
<tr><td><code>LOSE</code></td>
<td>
<p>a 3-D array containing the standard error calculated for the log odds of the transition probabilities.</p>
</td></tr>
<tr><td><code>lags</code></td>
<td>
<p>a vector containing one-dimensional lags.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>a character string which specifies that computed probabilities are empirical.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>Carle, S. F., Fogg, G. E. (1997) Modelling Spatial Variability with One and Multidimensional Continuous-Lag Markov Chains. <em>Mathematical Geology</em>, <b>29</b>(7), 891-918.
</p>
<p>Sartore, L. (2010) Geostatistical models for 3-D data. M.Phil. thesis, Ca' Foscari University of Venice.</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.tpfit">predict.tpfit</a></code>, <code><a href="#topic+predict.tpfit">predict.tpfit</a></code>, <code><a href="#topic+plot.transiogram">plot.transiogram</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

# Estimate empirical transition 
# probabilities by points
transiogram(ACM$MAT3, ACM[, 1:3], c(0, 0, 1), 200, 5)
</code></pre>

<hr>
<h2 id='which_lines'>Points Classification through Directional Lines</h2><span id='topic+which_lines'></span>

<h3>Description</h3>

<p>The function classifies points which appertain to a same directional line.</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_lines(coords, direction, tolerance = pi / 8)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="which_lines_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times d</code> matrix where each row denotes the <code class="reqn">d</code>-D coordinates of data locations.</p>
</td></tr>
<tr><td><code id="which_lines_+3A_direction">direction</code></td>
<td>
<p>a <code class="reqn">d</code>-D numerical vector (or versor) which represents the chosen direction.</p>
</td></tr>
<tr><td><code id="which_lines_+3A_tolerance">tolerance</code></td>
<td>
<p>a numerical value for the tolerance angle (in radians). It's <code>pi/8</code> by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm used by this function searches the nearest points to a directional line. The function classifies such pairs of points that have the minimum distance and the same direction of the vector <code class="reqn">\phi</code>.
</p>
<p>This operation is done to order points, so that it's possible to compute mean lengths (<a href="#topic+mlen">mlen</a>) and embedded transition probabilities (<a href="#topic+embed_MC">embed_MC</a>).
</p>


<h3>Value</h3>

<p>A numerical vector containing the line number for each point.</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a></p>


<h3>References</h3>

<p>Sartore, L. (2010) Geostatistical models for 3-D data. M.Phil. thesis, Ca' Foscari University of Venice.</p>


<h3>See Also</h3>

<p><code><a href="#topic+embed_MC">embed_MC</a></code>, <code><a href="#topic+mlen">mlen</a></code>, <code><a href="#topic+getlen">getlen</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ACM)

direction &lt;- c(0,0,1)

loc.id &lt;- which_lines(ACM[, 1:3], direction)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
