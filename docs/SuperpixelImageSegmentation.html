<!DOCTYPE html><html><head><title>Help for package SuperpixelImageSegmentation</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SuperpixelImageSegmentation}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Image_Segmentation'><p>Segmentation of images based on Superpixels, Affinity propagation and Kmeans clustering</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Superpixel Image Segmentation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-02-06</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mlampros/SuperpixelImageSegmentation/issues">https://github.com/mlampros/SuperpixelImageSegmentation/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mlampros/SuperpixelImageSegmentation">https://github.com/mlampros/SuperpixelImageSegmentation</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Image Segmentation using Superpixels, Affinity Propagation and Kmeans Clustering. The R code is based primarily on the article "Image Segmentation using SLIC Superpixels and Affinity Propagation Clustering, Bao Zhou, International Journal of Science and Research (IJSR), 2013" <a href="https://www.ijsr.net/archive/v4i4/SUB152869.pdf">https://www.ijsr.net/archive/v4i4/SUB152869.pdf</a>. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.10), R6, OpenImageR, grDevices, lattice</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo (&ge; 0.9.1), ClusterR, OpenImageR</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr, knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-06 14:35:54 UTC; lampros</td>
</tr>
<tr>
<td>Author:</td>
<td>Lampros Mouselimis
    <a href="https://orcid.org/0000-0002-8024-1546"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lampros Mouselimis &lt;mouselimislampros@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-06 14:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Image_Segmentation'>Segmentation of images based on Superpixels, Affinity propagation and Kmeans clustering</h2><span id='topic+Image_Segmentation'></span>

<h3>Description</h3>

<p>Segmentation of images based on Superpixels, Affinity propagation and Kmeans clustering
</p>
<p>Segmentation of images based on Superpixels, Affinity propagation and Kmeans clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'># init &lt;- Image_Segmentation$new()
</code></pre>


<h3>Details</h3>

<p><em>sim_wL</em>, <em>sim_wA</em>, <em>sim_wB</em> are the weights of the three channels. They keep balance so as to be consistent with human perception.
</p>
<p>The quantity <em>colorradius</em> adjusts the number of clusters, and if its value is low, the number of targets would increase, which leads to more detailed segmentation results.
</p>
<p>If the <em>adjust_centroids_and_return_masks</em> parameter is set to FALSE then the output <em>kmeans_image_data</em> will be an RGB image, otherwise it will be a black-and-white image.
</p>
<p><em>colour_type</em> parameter: RGB (Red-Green-Blue), LAB (Lightness, A-colour-dimension, B-colour-dimension) or HSV (Hue, Saturation, Value) colour.
</p>
<p>Higher resolution images give better results.
</p>
<p>The <em>affinity propagation</em> algorithm is used here with default parameter values.
</p>
<p>By setting the <em>sim_normalize</em> parameter to TRUE, the affinity propagation algorithm requires less iterations to complete. However, the <em>colorradius</em> parameter does not have an
effect if the similarity matrix is normalized.
</p>
<p>Regarding the <em>use_median</em> parameter in the Rcpp I use the following steps: <em>1st.</em> I compute the superpixels and extract the labels, <em>2nd.</em> each superpixel label consists of multiple pixels and for these superpixels I have
to compute a dissimilarity matrix therefore each superpixel must correspond to a single value, <em>3rd.</em> to come to this single value for each superpixel the R user has the option to either use the 'mean' or the 'median of multiple
image pixels (per superpixel)
</p>
<p>&mdash;&mdash;&mdash;&mdash;&mdash;kmeans initializers&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-
</p>
<p><strong>optimal_init</strong>   : this initializer adds rows of the data incrementally, while checking that they do not already exist in the centroid-matrix
</p>
<p><strong>quantile_init</strong>  : initialization of centroids by using the cummulative distance between observations and by removing potential duplicates
</p>
<p><strong>kmeans++</strong>       : kmeans++ initialization. Reference : http://theory.stanford.edu/~sergei/papers/kMeansPP-soda.pdf AND http://stackoverflow.com/questions/5466323/how-exactly-does-k-means-work
</p>
<p><strong>random</strong>         : random selection of data rows as initial centroids
</p>


<h3>Methods</h3>


<dl>
<dt><code>Image_Segmentation$new()</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>spixel_segmentation()</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>spixel_masks_show()</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>spixel_clusters_show()</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
</dl>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>Image_Segmentation$new()</code></a>
</p>
</li>
<li> <p><a href="#method-spixel_segmentation"><code>Image_Segmentation$spixel_segmentation()</code></a>
</p>
</li>
<li> <p><a href="#method-spixel_masks_show"><code>Image_Segmentation$spixel_masks_show()</code></a>
</p>
</li>
<li> <p><a href="#method-spixel_clusters_show"><code>Image_Segmentation$spixel_clusters_show()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>Image_Segmentation$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Image_Segmentation$new()</pre></div>


<hr>
<a id="method-spixel_segmentation"></a>



<h4>Method <code>spixel_segmentation()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Image_Segmentation$spixel_segmentation(
  input_image,
  method = "slic",
  superpixel = 200,
  kmeans_method = "",
  AP_data = FALSE,
  use_median = TRUE,
  minib_kmeans_batch = 10,
  minib_kmeans_init_fraction = 0.5,
  kmeans_num_init = 3,
  kmeans_max_iters = 100,
  kmeans_initializer = "kmeans++",
  colour_type = "RGB",
  compactness_factor = 20,
  adjust_centroids_and_return_masks = FALSE,
  return_labels_2_dimensionsional = FALSE,
  sim_normalize = FALSE,
  sim_wL = 3,
  sim_wA = 10,
  sim_wB = 10,
  sim_color_radius = 20,
  ap_maxits = 1000,
  ap_convits = 100,
  ap_dampfact = 0.9,
  ap_nonoise = 0,
  verbose = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>input_image</code></dt><dd><p>a 3-dimensional input image (the range of the pixel values should be preferably in the range 0 to 255)</p>
</dd>
<dt><code>method</code></dt><dd><p>a character string specifying the superpixel method. It can be either &quot;slic&quot; or &quot;slico&quot;</p>
</dd>
<dt><code>superpixel</code></dt><dd><p>a numeric value specifying the number of superpixels</p>
</dd>
<dt><code>kmeans_method</code></dt><dd><p>a character string specifying the kmeans method. If not empty (&quot;&quot;) then it can be either &quot;kmeans&quot; or &quot;mini_batch_kmeans&quot;</p>
</dd>
<dt><code>AP_data</code></dt><dd><p>a boolean. If TRUE then the affinity propagation image data will be computed and returned</p>
</dd>
<dt><code>use_median</code></dt><dd><p>a boolean. If TRUE then the median will be used rather than the mean value for the inner computations (see the details section for more information)</p>
</dd>
<dt><code>minib_kmeans_batch</code></dt><dd><p>the size of the mini batches</p>
</dd>
<dt><code>minib_kmeans_init_fraction</code></dt><dd><p>percentage of data to use for the initialization centroids (applies if initializer is <em>kmeans++</em> or <em>optimal_init</em>). Should be a float number between 0.0 and 1.0.</p>
</dd>
<dt><code>kmeans_num_init</code></dt><dd><p>number of times the algorithm will be run with different centroid seeds</p>
</dd>
<dt><code>kmeans_max_iters</code></dt><dd><p>the maximum number of clustering iterations</p>
</dd>
<dt><code>kmeans_initializer</code></dt><dd><p>the method of initialization. One of, <em>optimal_init</em>, <em>quantile_init</em>, <em>kmeans++</em> and <em>random</em>. See details for more information</p>
</dd>
<dt><code>colour_type</code></dt><dd><p>a character string specifying the colour type. It can be one of &quot;RGB&quot;, &quot;LAB&quot; or &quot;HSV&quot;</p>
</dd>
<dt><code>compactness_factor</code></dt><dd><p>a numeric value specifying the compactness parameter in case that <em>method</em> is &quot;slic&quot;</p>
</dd>
<dt><code>adjust_centroids_and_return_masks</code></dt><dd><p>a boolean. If TRUE and the <em>kmeans_method</em> parameter is NOT empty (&quot;&quot;) then the centroids will be adjusted and image-masks will be returned. This will allow me to plot the masks using the <em>spixel_masks_show</em> method.</p>
</dd>
<dt><code>return_labels_2_dimensionsional</code></dt><dd><p>a boolean. If TRUE then a matrix of labels based on the output superpixels in combination with the Affinity Propagation clusters will be returned</p>
</dd>
<dt><code>sim_normalize</code></dt><dd><p>a boolean. If TRUE then the constructed similarity matrix will be normalised to have unit p-norm (see the armadillo documentation for more details)</p>
</dd>
<dt><code>sim_wL</code></dt><dd><p>a numeric value specifying the weight for the <em>&quot;L&quot;</em> channel of the image (see the details section for more information)</p>
</dd>
<dt><code>sim_wA</code></dt><dd><p>a numeric value specifying the weight for the <em>&quot;A&quot;</em> channel of the image (see the details section for more information)</p>
</dd>
<dt><code>sim_wB</code></dt><dd><p>a numeric value specifying the weight for the <em>&quot;B&quot;</em> channel of the image (see the details section for more information)</p>
</dd>
<dt><code>sim_color_radius</code></dt><dd><p>a numeric value specifying the <em>colorradius</em> (see the details section for more information)</p>
</dd>
<dt><code>ap_maxits</code></dt><dd><p>a numeric value specifying the maximum number of iterations for the Affinity Propagation Clustering (defaults to 1000)</p>
</dd>
<dt><code>ap_convits</code></dt><dd><p>a numeric value. If the estimated exemplars stay fixed for convits iterations, the affinity propagation algorithm terminates early (defaults to 100)</p>
</dd>
<dt><code>ap_dampfact</code></dt><dd><p>a float number specifying the update equation damping level in [0.5, 1). Higher values correspond to heavy damping, which may be needed if oscillations occur in the Affinity Propagation Clustering (defaults to 0.9)</p>
</dd>
<dt><code>ap_nonoise</code></dt><dd><p>a float number. The affinity propagation algorithm adds a small amount of noise to <em>data</em> to prevent degenerate cases; this disables that.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>a boolean. If TRUE then information will be printed in the console  (spixel_masks_show method)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-spixel_masks_show"></a>



<h4>Method <code>spixel_masks_show()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Image_Segmentation$spixel_masks_show(
  delay_display_seconds = 3,
  display_all = FALSE,
  margin_btw_plots = 0.15,
  verbose = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>delay_display_seconds</code></dt><dd><p>a numeric value specifying the seconds to delay the display of the next image (It displays the images consecutively). This parameter applies only if the <em>display_all</em> is set to FALSE (spixel_masks_show method)</p>
</dd>
<dt><code>display_all</code></dt><dd><p>a boolean. If TRUE then all images will be displayed in a grid  (spixel_masks_show method)</p>
</dd>
<dt><code>margin_btw_plots</code></dt><dd><p>a float number specifying the margins between the plots if the <em>display_all</em> parameter is set to TRUE  (spixel_masks_show method)</p>
</dd>
<dt><code>verbose</code></dt><dd><p>a boolean. If TRUE then information will be printed in the console  (spixel_masks_show method)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-spixel_clusters_show"></a>



<h4>Method <code>spixel_clusters_show()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Image_Segmentation$spixel_clusters_show(
  spix_labels,
  color_palette = grDevices::rainbow,
  parameter_list_png = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>spix_labels</code></dt><dd><p>a matrix. I can retrieve the &quot;spix_labels&quot; parameter by setting the &quot;return_labels_2_dimensionsional&quot; parameter to TRUE in the &quot;spixel_segmentation&quot; method  (spixel_clusters_show method)</p>
</dd>
<dt><code>color_palette</code></dt><dd><p>one of the color palettes. Use  ?grDevices::topo.colors  to see the available color palettes</p>
</dd>
<dt><code>parameter_list_png</code></dt><dd><p>either NULL or a list of parameters passed to the  ?grDevices::png  function, such as  list(filename = 'img.png', width = 100, height = 100, units = &quot;px&quot;, pointsize = 12, bg = &quot;white&quot;, type = &quot;quartz&quot;)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Image_Segmentation$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>https://www.ijsr.net/archive/v4i4/SUB152869.pdf , &quot;Image Segmentation using SLIC Superpixels and Affinity Propagation Clustering&quot;, Bao Zhou, 2013, International Journal of Science and Research (IJSR)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(SuperpixelImageSegmentation)

path = system.file("images", "BSR_bsds500_image.jpg", package = "SuperpixelImageSegmentation")

im = OpenImageR::readImage(path)

init = Image_Segmentation$new()

num_spix = 10           # for illustration purposes
# num_spix = 600        # recommended number of superpixels

spx = init$spixel_segmentation(input_image = im,
                               superpixel = num_spix,
                               AP_data = TRUE,
                               use_median = TRUE,
                               return_labels_2_dimensionsional = TRUE,
                               sim_color_radius = 10)


#...........................
# plot the superpixel labels
#...........................

plt = init$spixel_clusters_show(spix_labels = spx$spix_labels,
                                color_palette = grDevices::rainbow,
                                parameter_list_png = NULL)

# plt


#....................................................
# create a binary image for a specified cluster label
#....................................................

pix_values = spx$spix_labels

target_cluster = 3                               # determine clusters visually ('plt' variable)

pix_values[pix_values != target_cluster] = 0     # set all other values to 0 (background)
pix_values[pix_values == target_cluster] = 1     # set the target_cluster to 1 (binary image)

# OpenImageR::imageShow(pix_values)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
