<!DOCTYPE html><html><head><title>Help for package Superpower</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Superpower}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alpha_standardized'><p>Compute standardized alpha level based on unstandardized alpha level and the number of observations N.</p></a></li>
<li><a href='#ANCOVA_analytic'><p>Power Calculations for Factorial ANCOVAs</p></a></li>
<li><a href='#ANCOVA_contrast'><p>Power Calculations for ANCOVA Contrasts</p></a></li>
<li><a href='#ancova_power-methods'><p>Methods for ancova_power objects</p></a></li>
<li><a href='#ANOVA_compromise'><p>Justify your alpha level by minimizing or balancing Type 1 and Type 2 error rates for ANOVAs.</p></a></li>
<li><a href='#ANOVA_design'><p>Design function used to specify the parameters to be used in simulations</p></a></li>
<li><a href='#ANOVA_exact'><p>Simulates an exact dataset (mu, sd, and r represent empirical, not population, mean and covariance matrix) from the design to calculate power</p></a></li>
<li><a href='#ANOVA_power'><p>Simulation function used to estimate power</p></a></li>
<li><a href='#design_aov-methods'><p>Methods for design_aov objects</p></a></li>
<li><a href='#emmeans_power'><p>Compute power for <span class="pkg">emmeans</span> contrasts</p></a></li>
<li><a href='#morey_plot.ttest'><p>Plot out power sensitivity plots for t or F tests</p></a></li>
<li><a href='#mu_from_ES'><p>Convenience function to calculate the means for between designs with one factor (One-Way ANOVA). Can be used to determine the means that should yield a specified effect sizes (expressed in Cohen's f).</p></a></li>
<li><a href='#opt_alpha-methods'><p>Methods for opt_alpha objects</p></a></li>
<li><a href='#optimal_alpha'><p>Justify your alpha level by minimizing or balancing Type 1 and Type 2 error rates.</p></a></li>
<li><a href='#p_standardized'><p>Compute standardized alpha level based on unstandardized alpha level and the number of observations N.</p></a></li>
<li><a href='#plot_power'><p>Convenience function to plot power across a range of sample sizes.</p></a></li>
<li><a href='#power_oneway_ancova'><p>Power Calculations for a one-way ANCOVA</p></a></li>
<li><a href='#power_oneway_between'><p>Analytic power calculation for one-way between designs.</p></a></li>
<li><a href='#power_oneway_within'><p>Analytic power calculation for one-way within designs.</p></a></li>
<li><a href='#power_standardized_alpha'><p>Optimizing function to achieve desired power based on a standardized alpha level.</p></a></li>
<li><a href='#power_threeway_between'><p>Analytic power calculation for three-way between designs.</p></a></li>
<li><a href='#power_twoway_between'><p>Analytic power calculation for two-way between designs.</p></a></li>
<li><a href='#power.ftest'><p>Power Calculations for an F-test</p></a></li>
<li><a href='#sim_result-methods'><p>Methods for sim_result objects</p></a></li>
<li><a href='#Superpower_options'><p>Set/get global Superpower options</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Simulation-Based Power Analysis for Factorial Designs</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to perform simulations of ANOVA designs of up to three factors. Calculates the observed power and average observed effect size for all main effects and interactions in the ANOVA, and all simple comparisons between conditions. Includes functions for analytic power calculations and additional helper functions that compute effect sizes for ANOVA designs, observed error rates in the simulations, and functions to plot power curves. Please see Lakens, D., &amp; Caldwell, A. R. (2021). "Simulation-Based Power Analysis for Factorial Analysis of Variance Designs". &lt;<a href="https://doi.org/10.1177%2F2515245920951503">doi:10.1177/2515245920951503</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://aaroncaldwell.us/SuperpowerBook/">https://aaroncaldwell.us/SuperpowerBook/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/arcaldwell49/Superpower/issues">https://github.com/arcaldwell49/Superpower/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>mvtnorm, MASS, afex, emmeans, ggplot2, gridExtra, reshape2,
stats, dplyr, magrittr, tidyselect, tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, pwr, testthat, covr, jmvcore, spelling</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-16 17:37:49 UTC; aaroncaldwell</td>
</tr>
<tr>
<td>Author:</td>
<td>Aaron Caldwell [aut, cre],
  Daniel Lakens [aut],
  Lisa DeBruine [ctb],
  Jonathon Love [ctb],
  Frederik Aust <a href="https://orcid.org/0000-0003-4900-788X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aaron Caldwell &lt;arcaldwell49@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-17 13:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='alpha_standardized'>Compute standardized alpha level based on unstandardized alpha level and the number of observations N.</h2><span id='topic+alpha_standardized'></span>

<h3>Description</h3>

<p>Compute standardized alpha level based on unstandardized alpha level and the number of observations N.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alpha_standardized(alpha, N, standardize_N = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alpha_standardized_+3A_alpha">alpha</code></td>
<td>
<p>The unstandardized alpha level (e.g., 0.05), independent of the sample size.</p>
</td></tr>
<tr><td><code id="alpha_standardized_+3A_n">N</code></td>
<td>
<p>The number of observations (e.g., the sample size) in the dataset</p>
</td></tr>
<tr><td><code id="alpha_standardized_+3A_standardize_n">standardize_N</code></td>
<td>
<p>The number of observations (e.g., the sample size) you want to use to standardize the alpha level for. Defaults to 100 (base on Good, 1982).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Good, I. J. (1982). C140. Standardized tail-area probabilities. Journal of Statistical Computation and Simulation, 16(1), 65–66. &lt;https://doi.org/10.1080/00949658208810607&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Check it yields .05 for N = 100:
alpha_standardized(alpha = 0.05, N = 100)
## Check it yields .05 for N = 200:
alpha_standardized(alpha = 0.07071068, N = 200)
## Which alpha should we use with N = 200?
alpha_standardized(alpha = 0.05, N = 200)
## You can change the standardization N, repeating the example above:
alpha_standardized(alpha = 0.05, N = 100, standardize_N = 200)
</code></pre>

<hr>
<h2 id='ANCOVA_analytic'>Power Calculations for Factorial ANCOVAs</h2><span id='topic+ANCOVA_analytic'></span>

<h3>Description</h3>

<p>Complete power analyses for ANCOVA omnibus tests and contrasts. This function does not support within subjects factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ANCOVA_analytic(
  design,
  mu,
  n = NULL,
  sd,
  r2 = NULL,
  n_cov,
  alpha_level = Superpower_options("alpha_level"),
  beta_level = NULL,
  cmats = list(),
  label_list = NULL,
  design_result = NULL,
  round_up = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ANCOVA_analytic_+3A_design">design</code></td>
<td>
<p>Output from the ANOVA_design function</p>
</td></tr>
<tr><td><code id="ANCOVA_analytic_+3A_mu">mu</code></td>
<td>
<p>Vector specifying mean for each condition</p>
</td></tr>
<tr><td><code id="ANCOVA_analytic_+3A_n">n</code></td>
<td>
<p>Sample size in each condition</p>
</td></tr>
<tr><td><code id="ANCOVA_analytic_+3A_sd">sd</code></td>
<td>
<p>Standard deviation for all conditions (or a vector specifying the sd for each condition)</p>
</td></tr>
<tr><td><code id="ANCOVA_analytic_+3A_r2">r2</code></td>
<td>
<p>Coefficient of Determination of the model with only the covariates</p>
</td></tr>
<tr><td><code id="ANCOVA_analytic_+3A_n_cov">n_cov</code></td>
<td>
<p>Number of covariates</p>
</td></tr>
<tr><td><code id="ANCOVA_analytic_+3A_alpha_level">alpha_level</code></td>
<td>
<p>Alpha level used to determine statistical significance</p>
</td></tr>
<tr><td><code id="ANCOVA_analytic_+3A_beta_level">beta_level</code></td>
<td>
<p>Type II error probability (power/100-1)</p>
</td></tr>
<tr><td><code id="ANCOVA_analytic_+3A_cmats">cmats</code></td>
<td>
<p>List of matrices for specific contrasts of interest</p>
</td></tr>
<tr><td><code id="ANCOVA_analytic_+3A_label_list">label_list</code></td>
<td>
<p>An optional list to specify the factor names and condition (recommended, if not used factors and levels are indicated by letters and numbers).</p>
</td></tr>
<tr><td><code id="ANCOVA_analytic_+3A_design_result">design_result</code></td>
<td>
<p>Output from the ANOVA_design function</p>
</td></tr>
<tr><td><code id="ANCOVA_analytic_+3A_round_up">round_up</code></td>
<td>
<p>Logical indicator (default = TRUE) for whether to round up sample size calculations to nearest whole number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>One, or two, data frames containing the power analysis results from the power analysis for the omnibus ANCOVA (main_results) or contrast tests (contrast_results).
In addition, every F-test (aov_list and con_list) is included in a list of power.htest results. 
Lastly, a (design_param) list containing the design parameters is also included in the results.
</p>


<h3>References</h3>

<p>Shieh, G. (2020). Power analysis and sample size planning in ANCOVA designs. Psychometrika, 85(1), 101-120.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple 2x3 ANCOVA

ANCOVA_analytic(
design = "2b*3b",
mu = c(400, 450, 500,
      400, 500, 600),
n_cov = 3,
sd = 100,
r2 = .25,
alpha_level = .05,
beta_level = .2,
round_up = TRUE
)
</code></pre>

<hr>
<h2 id='ANCOVA_contrast'>Power Calculations for ANCOVA Contrasts</h2><span id='topic+ANCOVA_contrast'></span>

<h3>Description</h3>

<p>Complete power analyses for specific ANCOVA contrasts. This function does not support within subjects factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ANCOVA_contrast(
  cmat,
  mu,
  n = NULL,
  sd,
  r2 = NULL,
  n_cov,
  alpha_level = Superpower_options("alpha_level"),
  beta_level = NULL,
  round_up = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ANCOVA_contrast_+3A_cmat">cmat</code></td>
<td>
<p>Matrix of the specific contrasts of interest</p>
</td></tr>
<tr><td><code id="ANCOVA_contrast_+3A_mu">mu</code></td>
<td>
<p>Vector specifying mean for each condition</p>
</td></tr>
<tr><td><code id="ANCOVA_contrast_+3A_n">n</code></td>
<td>
<p>Sample size in each condition</p>
</td></tr>
<tr><td><code id="ANCOVA_contrast_+3A_sd">sd</code></td>
<td>
<p>Standard deviation for all conditions (or a vector specifying the sd for each condition)</p>
</td></tr>
<tr><td><code id="ANCOVA_contrast_+3A_r2">r2</code></td>
<td>
<p>Coefficient of Determination of the model with only the covariates</p>
</td></tr>
<tr><td><code id="ANCOVA_contrast_+3A_n_cov">n_cov</code></td>
<td>
<p>Number of covariates</p>
</td></tr>
<tr><td><code id="ANCOVA_contrast_+3A_alpha_level">alpha_level</code></td>
<td>
<p>Alpha level used to determine statistical significance</p>
</td></tr>
<tr><td><code id="ANCOVA_contrast_+3A_beta_level">beta_level</code></td>
<td>
<p>Type II error probability (power/100-1)</p>
</td></tr>
<tr><td><code id="ANCOVA_contrast_+3A_round_up">round_up</code></td>
<td>
<p>Logical indicator (default = TRUE) for whether to round up sample size calculations to nearest whole number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class &quot;power.htest&quot;, a list of the arguments (including the computed one) augmented with method and note elements.
</p>


<h3>References</h3>

<p>Shieh, G. (2020). Power analysis and sample size planning in ANCOVA designs. Psychometrika, 85(1), 101-120.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ANCOVA_contrast(cmat = c(-1,1),
n = 15,
mu = c(0,1),
sd = 1,
r2 = .2,
n_cov = 1)
</code></pre>

<hr>
<h2 id='ancova_power-methods'>Methods for ancova_power objects</h2><span id='topic+ancova_power-methods'></span><span id='topic+print.ancova_power'></span><span id='topic+plot.ancova_power'></span>

<h3>Description</h3>

<p>Methods defined for objects returned from the ANCOVA_analytic function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ancova_power'
print(x, ...)

## S3 method for class 'ancova_power'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ancova_power-methods_+3A_x">x</code></td>
<td>
<p>object of class <code>ancova_power</code> as returned from one of the simulation functions in Superpower.</p>
</td></tr>
<tr><td><code id="ancova_power-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed through, see description of return value</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><code>print</code></dt><dd><p>Prints short summary of the simulation result</p>
</dd>
<dt><code>plot</code></dt><dd><p>Returns a meansplot of from the defined design</p>
</dd>
</dl>


<hr>
<h2 id='ANOVA_compromise'>Justify your alpha level by minimizing or balancing Type 1 and Type 2 error rates for ANOVAs.</h2><span id='topic+ANOVA_compromise'></span>

<h3>Description</h3>

<p>Justify your alpha level by minimizing or balancing Type 1 and Type 2 error rates for ANOVAs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ANOVA_compromise(
  design_result,
  correction = Superpower_options("correction"),
  emm = Superpower_options("emm"),
  emm_model = Superpower_options("emm_model"),
  contrast_type = Superpower_options("contrast_type"),
  emm_comp,
  costT1T2 = 1,
  priorH1H0 = 1,
  error = "minimal",
  liberal_lambda = Superpower_options("liberal_lambda")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ANOVA_compromise_+3A_design_result">design_result</code></td>
<td>
<p>Output from the ANOVA_design function</p>
</td></tr>
<tr><td><code id="ANOVA_compromise_+3A_correction">correction</code></td>
<td>
<p>Set a correction of violations of sphericity. This can be set to &quot;none&quot;, &quot;GG&quot; Greenhouse-Geisser, and &quot;HF&quot; Huynh-Feldt</p>
</td></tr>
<tr><td><code id="ANOVA_compromise_+3A_emm">emm</code></td>
<td>
<p>Set to FALSE to not perform analysis of estimated marginal means</p>
</td></tr>
<tr><td><code id="ANOVA_compromise_+3A_emm_model">emm_model</code></td>
<td>
<p>Set model type (&quot;multivariate&quot;, or &quot;univariate&quot;) for estimated marginal means</p>
</td></tr>
<tr><td><code id="ANOVA_compromise_+3A_contrast_type">contrast_type</code></td>
<td>
<p>Select the type of comparison for the estimated marginal means. Default is pairwise. See ?emmeans::'contrast-methods' for more details on acceptable methods.</p>
</td></tr>
<tr><td><code id="ANOVA_compromise_+3A_emm_comp">emm_comp</code></td>
<td>
<p>Set the comparisons for estimated marginal means comparisons. This is a factor name (a), combination of factor names (a+b), or for simple effects a | sign is needed (a|b)</p>
</td></tr>
<tr><td><code id="ANOVA_compromise_+3A_costt1t2">costT1T2</code></td>
<td>
<p>Relative cost of Type 1 errors vs. Type 2 errors.</p>
</td></tr>
<tr><td><code id="ANOVA_compromise_+3A_priorh1h0">priorH1H0</code></td>
<td>
<p>How much more likely a-priori is H1 than H0? Default is 1: equally likely.</p>
</td></tr>
<tr><td><code id="ANOVA_compromise_+3A_error">error</code></td>
<td>
<p>Either &quot;minimal&quot; to minimize error rates, or &quot;balance&quot; to balance error rates.</p>
</td></tr>
<tr><td><code id="ANOVA_compromise_+3A_liberal_lambda">liberal_lambda</code></td>
<td>
<p>Logical indicator of whether to use the liberal (cohen_f^2\*(num_df+den_df)) or conservative (cohen_f^2\*den_df) calculation of the noncentrality (lambda) parameter estimate. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns dataframe with simulation data (power and effect sizes!), optimal alpha level, obtained beta error rate (1-power/100), and objective (see below for details). If NA is obtained in a alpha/beta/objective columns this indicates there is no effect for this particular comparison. Also returns alpha-beta compromise plots for all comparisons. Note: Cohen's f = sqrt(pes/1-pes) and the noncentrality parameter is = f^2*df(error)
</p>

<dl>
<dt><code>"aov_comp"</code></dt><dd><p>A dataframe of ANOVA-level results.</p>
</dd>
<dt><code>"aov_plotlist"</code></dt><dd><p>List of plots for ANOVA-level effects</p>
</dd>
<dt><code>"manova_comp"</code></dt><dd><p>A dataframe of MANOVA-level results.</p>
</dd>
<dt><code>"manova_plotlist"</code></dt><dd><p>List of plots for MANOVA-level effects.</p>
</dd>
<dt><code>"emmeans_comp"</code></dt><dd><p>A dataframe of ANOVA-level results.</p>
</dd>
<dt><code>"emm_plotlist"</code></dt><dd><p>List of plots for estimated marginal means contrasts.</p>
</dd>
</dl>

<p>alpha = alpha or Type 1 error that minimizes or balances combined error rates
beta = beta or Type 2 error that minimizes or balances combined error rates
objective = value that is the result of the minimization, either 0 (for balance) or the combined weighted error rates
</p>


<h3>References</h3>

<p>too be added
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
design_result &lt;- ANOVA_design(design = "3b*2w",
n = 6,
mu = c(1, 2, 2, 3, 3, 4),
sd = 3,
plot = FALSE)
example = ANOVA_compromise(design_result,emm = TRUE,emm_comp = "a")

## End(Not run)
</code></pre>

<hr>
<h2 id='ANOVA_design'>Design function used to specify the parameters to be used in simulations</h2><span id='topic+ANOVA_design'></span>

<h3>Description</h3>

<p>Design function used to specify the parameters to be used in simulations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ANOVA_design(
  design,
  n,
  mu,
  sd,
  r = 0,
  label_list = NULL,
  labelnames = NULL,
  plot = Superpower_options("plot")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ANOVA_design_+3A_design">design</code></td>
<td>
<p>String specifying the ANOVA design.</p>
</td></tr>
<tr><td><code id="ANOVA_design_+3A_n">n</code></td>
<td>
<p>Sample size in each condition</p>
</td></tr>
<tr><td><code id="ANOVA_design_+3A_mu">mu</code></td>
<td>
<p>Vector specifying mean for each condition</p>
</td></tr>
<tr><td><code id="ANOVA_design_+3A_sd">sd</code></td>
<td>
<p>standard deviation for all conditions (or a vector specifying the sd for each condition)</p>
</td></tr>
<tr><td><code id="ANOVA_design_+3A_r">r</code></td>
<td>
<p>Correlation between dependent variables (single value or matrix)</p>
</td></tr>
<tr><td><code id="ANOVA_design_+3A_label_list">label_list</code></td>
<td>
<p>An optional list to specify the factor names and condition (recommended, if not used factors and levels are indicated by letters and numbers).</p>
</td></tr>
<tr><td><code id="ANOVA_design_+3A_labelnames">labelnames</code></td>
<td>
<p>Optional vector to specifying factor and condition names. This parameter is deprecated and will be overridden by input from label_list.</p>
</td></tr>
<tr><td><code id="ANOVA_design_+3A_plot">plot</code></td>
<td>
<p>Should means plot be printed (defaults to TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns single list with simulated data, design, design list, factor names, formulas for ANOVA, means, sd, correlation, sample size per condition, correlation matrix, covariance matrix, design string, labelnames, labelnameslist, factor names, meansplot
</p>

<dl>
<dt><code>"dataframe"</code></dt><dd><p>A sample dataframe of what data could look like given the proposed parameters.</p>
</dd>
<dt><code>"design"</code></dt><dd><p><code>aov</code> The design string, e.g. &quot;2b*2w&quot;.</p>
</dd>
<dt><code>"design_list"</code></dt><dd><p>The list of variables in the design.</p>
</dd>
<dt><code>"frml1"</code></dt><dd><p>The first formula created for this design.</p>
</dd>
<dt><code>"frml2"</code></dt><dd><p>The second formula created for this design.</p>
</dd>
<dt><code>"mu"</code></dt><dd><p>Vector of means.</p>
</dd>
<dt><code>"sd"</code></dt><dd><p>Vector of standard deviations.</p>
</dd>
<dt><code>"r"</code></dt><dd><p>Common correlation coefficient.</p>
</dd>
<dt><code>"n"</code></dt><dd><p>Sample size per cell. Can be entered as a single value or list of sample sizes for each condition. If unequal n is entered then the design can only be passed onto ANOVA_power.</p>
</dd>
<dt><code>"cor_mat"</code></dt><dd><p>The correlation matrix.</p>
</dd>
<dt><code>"sigmatrix"</code></dt><dd><p>The variance-covariance matrix.</p>
</dd>
<dt><code>"design_factors"</code></dt><dd><p>Total number of within-subjects factors.</p>
</dd>
<dt><code>"labelnames"</code></dt><dd><p>List of the label names.</p>
</dd>
<dt><code>"labelnameslist"</code></dt><dd><p>Secondary list of labelnames</p>
</dd>
<dt><code>"factornames"</code></dt><dd><p>List of the factor titles.</p>
</dd>
<dt><code>"meansplot"</code></dt><dd><p>Plot of the experimental design.</p>
</dd>
</dl>



<h3>Warnings</h3>

<p>Varying the sd or r (e.g., entering multiple values) violates assumptions of homoscedascity and sphericity respectively
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Set up a within design with 2 factors, each with 2 levels,
## with correlation between observations of 0.8,
## 40 participants (who do all conditions), and standard deviation of 2
## with a mean pattern of 1, 0, 1, 0, conditions labeled 'condition' and
## 'voice', with names for levels of "cheerful", "sad", and "human", "robot"
ANOVA_design(design = "2w*2w", n = 40, mu = c(1, 0, 1, 0), sd = 2, r = 0.8,
      label_list= list(condition = c("cheerful", "sad"), 
      voice = c("human", "robot")))
</code></pre>

<hr>
<h2 id='ANOVA_exact'>Simulates an exact dataset (mu, sd, and r represent empirical, not population, mean and covariance matrix) from the design to calculate power</h2><span id='topic+ANOVA_exact'></span><span id='topic+ANOVA_exact2'></span>

<h3>Description</h3>

<p>Simulates an exact dataset (mu, sd, and r represent empirical, not population, mean and covariance matrix) from the design to calculate power
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ANOVA_exact(
  design_result,
  correction = Superpower_options("correction"),
  alpha_level = Superpower_options("alpha_level"),
  verbose = Superpower_options("verbose"),
  emm = Superpower_options("emm"),
  emm_model = Superpower_options("emm_model"),
  contrast_type = Superpower_options("contrast_type"),
  liberal_lambda = Superpower_options("liberal_lambda"),
  emm_comp
)

ANOVA_exact2(
  design_result,
  correction = Superpower_options("correction"),
  alpha_level = Superpower_options("alpha_level"),
  verbose = Superpower_options("verbose"),
  emm = Superpower_options("emm"),
  emm_model = Superpower_options("emm_model"),
  contrast_type = Superpower_options("contrast_type"),
  emm_comp,
  liberal_lambda = Superpower_options("liberal_lambda")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ANOVA_exact_+3A_design_result">design_result</code></td>
<td>
<p>Output from the ANOVA_design function</p>
</td></tr>
<tr><td><code id="ANOVA_exact_+3A_correction">correction</code></td>
<td>
<p>Set a correction of violations of sphericity. This can be set to &quot;none&quot;, &quot;GG&quot; Greenhouse-Geisser, and &quot;HF&quot; Huynh-Feldt</p>
</td></tr>
<tr><td><code id="ANOVA_exact_+3A_alpha_level">alpha_level</code></td>
<td>
<p>Alpha level used to determine statistical significance</p>
</td></tr>
<tr><td><code id="ANOVA_exact_+3A_verbose">verbose</code></td>
<td>
<p>Set to FALSE to not print results (default = TRUE)</p>
</td></tr>
<tr><td><code id="ANOVA_exact_+3A_emm">emm</code></td>
<td>
<p>Set to FALSE to not perform analysis of estimated marginal means</p>
</td></tr>
<tr><td><code id="ANOVA_exact_+3A_emm_model">emm_model</code></td>
<td>
<p>Set model type (&quot;multivariate&quot;, or &quot;univariate&quot;) for estimated marginal means</p>
</td></tr>
<tr><td><code id="ANOVA_exact_+3A_contrast_type">contrast_type</code></td>
<td>
<p>Select the type of comparison for the estimated marginal means. Default is pairwise. See ?emmeans::'contrast-methods' for more details on acceptable methods.</p>
</td></tr>
<tr><td><code id="ANOVA_exact_+3A_liberal_lambda">liberal_lambda</code></td>
<td>
<p>Logical indicator of whether to use the liberal (cohen_f^2\*(num_df+den_df)) or conservative (cohen_f^2\*den_df) calculation of the noncentrality (lambda) parameter estimate. Default is FALSE.</p>
</td></tr>
<tr><td><code id="ANOVA_exact_+3A_emm_comp">emm_comp</code></td>
<td>
<p>Set the comparisons for estimated marginal means comparisons. This is a factor name (a), combination of factor names (a+b), or for simple effects a | sign is needed (a|b)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns dataframe with simulation data (power and effect sizes!), anova results and simple effect results, plot of exact data, and alpha_level. Note: Cohen's f = sqrt(pes/1-pes) and the noncentrality parameter is = f^2*df(error)
</p>

<dl>
<dt><code>"dataframe"</code></dt><dd><p>A dataframe of the simulation result.</p>
</dd>
<dt><code>"aov_result"</code></dt><dd><p><code>aov</code> object returned from <code><a href="afex.html#topic+aov_car">aov_car</a></code>.</p>
</dd>
<dt><code>"aov_result"</code></dt><dd><p><code>emmeans</code> object returned from <code><a href="emmeans.html#topic+emmeans">emmeans</a></code>.</p>
</dd>
<dt><code>"main_result"</code></dt><dd><p>The power analysis results for ANOVA level effects.</p>
</dd>
<dt><code>"pc_results"</code></dt><dd><p>The power analysis results for the pairwise (t-test) comparisons.</p>
</dd>
<dt><code>"emm_results"</code></dt><dd><p>The power analysis results of the pairwise comparison results.</p>
</dd>
<dt><code>"manova_results"</code></dt><dd><p>Default is &quot;NULL&quot;. If a within-subjects factor is included, then the power of the multivariate (i.e. MANOVA) analyses will be provided.</p>
</dd>
<dt><code>"alpha_level"</code></dt><dd><p>The alpha level, significance cut-off, used for the power analysis.</p>
</dd>
<dt><code>"method"</code></dt><dd><p>Record of the function used to produce the simulation</p>
</dd>
<dt><code>"plot"</code></dt><dd><p>A plot of the dataframe from the simulation; should closely match the meansplot in <code><a href="#topic+ANOVA_design">ANOVA_design</a></code></p>
</dd>
</dl>



<h3>Functions</h3>


<ul>
<li> <p><code>ANOVA_exact2</code>: An extension of ANOVA_exact that uses the effect sizes calculated from very large sample size empirical simulation. This allows for small sample sizes, where ANOVA_exact cannot, while still accurately estimating power. However, model objects (emmeans and aov) are not included as output, and pairwise (t-test) results are not currently supported.
</p>
</li></ul>


<h3>Warnings</h3>

<p>Varying the sd or r (e.g., entering multiple values) violates assumptions of homoscedascity and sphericity respectively
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Set up a within design with 2 factors, each with 2 levels,
## with correlation between observations of 0.8,
## 40 participants (who do all conditions), and standard deviation of 2
## with a mean pattern of 1, 0, 1, 0, conditions labeled 'condition' and
## 'voice', with names for levels of "cheerful", "sad", amd "human", "robot"
design_result &lt;- ANOVA_design(design = "2w*2w", n = 40, mu = c(1, 0, 1, 0),
      sd = 2, r = 0.8, labelnames = c("condition", "cheerful",
      "sad", "voice", "human", "robot"))
exact_result &lt;- ANOVA_exact(design_result, alpha_level = 0.05)
</code></pre>

<hr>
<h2 id='ANOVA_power'>Simulation function used to estimate power</h2><span id='topic+ANOVA_power'></span>

<h3>Description</h3>

<p>Simulation function used to estimate power
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ANOVA_power(
  design_result,
  alpha_level = Superpower_options("alpha_level"),
  correction = Superpower_options("correction"),
  p_adjust = "none",
  nsims = 1000,
  seed = NULL,
  verbose = Superpower_options("verbose"),
  emm = Superpower_options("emm"),
  emm_model = Superpower_options("emm_model"),
  contrast_type = Superpower_options("contrast_type"),
  emm_p_adjust = "none",
  emm_comp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ANOVA_power_+3A_design_result">design_result</code></td>
<td>
<p>Output from the ANOVA_design function</p>
</td></tr>
<tr><td><code id="ANOVA_power_+3A_alpha_level">alpha_level</code></td>
<td>
<p>Alpha level used to determine statistical significance</p>
</td></tr>
<tr><td><code id="ANOVA_power_+3A_correction">correction</code></td>
<td>
<p>Set a correction of violations of sphericity. This can be set to &quot;none&quot;, &quot;GG&quot; Greenhouse-Geisser, and &quot;HF&quot; Huynh-Feldt</p>
</td></tr>
<tr><td><code id="ANOVA_power_+3A_p_adjust">p_adjust</code></td>
<td>
<p>Correction for multiple comparisons. This will adjust p values for ANOVA/MANOVA level effects; see ?p.adjust for options</p>
</td></tr>
<tr><td><code id="ANOVA_power_+3A_nsims">nsims</code></td>
<td>
<p>number of simulations to perform</p>
</td></tr>
<tr><td><code id="ANOVA_power_+3A_seed">seed</code></td>
<td>
<p>Set seed for reproducible results</p>
</td></tr>
<tr><td><code id="ANOVA_power_+3A_verbose">verbose</code></td>
<td>
<p>Set to FALSE to not print results (default = TRUE)</p>
</td></tr>
<tr><td><code id="ANOVA_power_+3A_emm">emm</code></td>
<td>
<p>Set to FALSE to not perform analysis of estimated marginal means</p>
</td></tr>
<tr><td><code id="ANOVA_power_+3A_emm_model">emm_model</code></td>
<td>
<p>Set model type (&quot;multivariate&quot;, or &quot;univariate&quot;) for estimated marginal means</p>
</td></tr>
<tr><td><code id="ANOVA_power_+3A_contrast_type">contrast_type</code></td>
<td>
<p>Select the type of comparison for the estimated marginal means. Default is pairwise. See ?emmeans::'contrast-methods' for more details on acceptable methods.</p>
</td></tr>
<tr><td><code id="ANOVA_power_+3A_emm_p_adjust">emm_p_adjust</code></td>
<td>
<p>Correction for multiple comparisons; default is &quot;none&quot;. See ?summary.emmGrid for more details on acceptable methods.</p>
</td></tr>
<tr><td><code id="ANOVA_power_+3A_emm_comp">emm_comp</code></td>
<td>
<p>Set the comparisons for estimated marginal means comparisons. This is a factor name (a), combination of factor names (a+b), or for simple effects a | sign is needed (a|b)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns dataframe with simulation data (p-values and effect sizes), anova results (type 3 sums of squares) and simple effect results, and plots of p-value distribution.
</p>

<dl>
<dt><code>"sim_data"</code></dt><dd><p>Output from every iteration of the simulation</p>
</dd>
<dt><code>"main_result"</code></dt><dd><p>The power analysis results for ANOVA effects.</p>
</dd>
<dt><code>"pc_results"</code></dt><dd><p>The power analysis results for pairwise comparisons.</p>
</dd>
<dt><code>"manova_results"</code></dt><dd><p>Default is &quot;NULL&quot;. If a within-subjects factor is included, then the power of the multivariate (i.e. MANOVA) analyses will be provided.</p>
</dd>
<dt><code>"emm_results"</code></dt><dd><p>The power analysis results of the estimated marginal means.</p>
</dd>
<dt><code>"plot1"</code></dt><dd><p>Distribution of p-values from the ANOVA results.</p>
</dd>
<dt><code>"plot2"</code></dt><dd><p>Distribution of p-values from the pairwise comparisons results.</p>
</dd>
<dt><code>"correction"</code></dt><dd><p>The correction for sphericity applied to the simulation results.</p>
</dd>
<dt><code>"p_adjust"</code></dt><dd><p>The p-value adjustment applied to the simulation results for ANOVA/MANOVA omnibus tests and t-tests.</p>
</dd>
<dt><code>"emm_p_adjust"</code></dt><dd><p>The p-value adjustment applied to the simulation results for the estimated marginal means.</p>
</dd>
<dt><code>"nsims"</code></dt><dd><p>The number of simulations run.</p>
</dd>
<dt><code>"alpha_level"</code></dt><dd><p>The alpha level, significance cut-off, used for the power analysis.</p>
</dd>
<dt><code>"method"</code></dt><dd><p>Record of the function used to produce the simulation</p>
</dd>
</dl>



<h3>References</h3>

<p>too be added
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Set up a within design with 2 factors, each with 2 levels,
## with correlation between observations of 0.8,
## 40 participants (who do all conditions), and standard deviation of 2
## with a mean pattern of 1, 0, 1, 0, conditions labeled 'condition' and
## 'voice', with names for levels of "cheerful", "sad", amd "human", "robot"
design_result &lt;- ANOVA_design(design = "2w*2w", n = 40, mu = c(1, 0, 1, 0),
      sd = 2, r = 0.8, labelnames = c("condition", "cheerful",
      "sad", "voice", "human", "robot"))
power_result &lt;- ANOVA_power(design_result, alpha_level = 0.05,
      p_adjust = "none", seed = 2019, nsims = 10)
      
## End(Not run)
</code></pre>

<hr>
<h2 id='design_aov-methods'>Methods for design_aov objects</h2><span id='topic+design_aov-methods'></span><span id='topic+print.design_aov'></span><span id='topic+plot.design_aov'></span>

<h3>Description</h3>

<p>Methods defined for objects returned from the ANOVA_design functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'design_aov'
print(x, ...)

## S3 method for class 'design_aov'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="design_aov-methods_+3A_x">x</code></td>
<td>
<p>object of class <code>design_aov</code> as returned from <code>ANOVA_design</code></p>
</td></tr>
<tr><td><code id="design_aov-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed through, see description of return value
for details.
<code><a href="#topic+ANOVA_design">ANOVA_design</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><code>print</code></dt><dd><p>Prints short summary of the study design created from <code>ANOVA_design</code> function</p>
</dd>
<dt><code>plot</code></dt><dd><p>Returns <code>meansplot</code> from created from the <code>ANOVA_design</code> function</p>
</dd>
</dl>


<hr>
<h2 id='emmeans_power'>Compute power for <span class="pkg">emmeans</span> contrasts</h2><span id='topic+emmeans_power'></span><span id='topic+emmeans_power.emmGrid'></span><span id='topic+emmeans_power.summary_em'></span><span id='topic+emmeans_power.data.frame'></span>

<h3>Description</h3>

<p>Computes power based on t value and degrees of freedom for contrasts.
<em>Do not use to calculate &quot;observed power&quot; for empirical datasets
(Hoenig &amp; Heisey, 2001).</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emmeans_power(x, ...)

## S3 method for class 'emmGrid'
emmeans_power(x, ...)

## S3 method for class 'summary_em'
emmeans_power(x, ...)

## S3 method for class 'data.frame'
emmeans_power(
  x,
  alpha_level = Superpower_options("alpha_level"),
  liberal_lambda = Superpower_options("liberal_lambda"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emmeans_power_+3A_x">x</code></td>
<td>
<p><code>emmGrid</code>. Grid of contrasts to estimate power from.</p>
</td></tr>
<tr><td><code id="emmeans_power_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the function if object is not already a <code>emmGrid</code> object.</p>
</td></tr>
<tr><td><code id="emmeans_power_+3A_alpha_level">alpha_level</code></td>
<td>
<p>Alpha level used to determine statistical significance</p>
</td></tr>
<tr><td><code id="emmeans_power_+3A_liberal_lambda">liberal_lambda</code></td>
<td>
<p>Logical indicator of whether to use the liberal (cohen_f^2\*(num_df+den_df)) or conservative (cohen_f^2\*den_df) calculation of the noncentrality (lambda) parameter estimate. Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that calculation of power is based on the F- and t-ratio assuming
two-sided testing. Thus, the function does not honor adjustments of the
testing procedure due to either one-sided testing (or two-one sided tests)
or corrections for multiple comparisons via the <code>p.adjust</code> option in 
<code>emmeans</code>.
</p>
<p>Power for one-sided tests can be calculated, if the means of the simulated
dataset are consistent with the directional hypothesis, by doubling
<code>alpha_level</code>. Similarly, power for Bonferroni-corrected contrasts can be
calculated by adjusting <code>alpha_level</code> accordingly (see examples).
<code>...</code> Other arguments passed onto the function
</p>


<h3>Value</h3>

<p>Returns dataframe with simulation data (power and effect sizes!), anova results and simple effect results, plot of exact data, and alpha_level. Note: Cohen's f = sqrt(pes/1-pes) and the noncentrality parameter is = f^2*df(error)
</p>

<dl>
<dt><code>"dataframe"</code></dt><dd><p>A dataframe of the simulation result.</p>
</dd>
<dt><code>"aov_result"</code></dt><dd><p><code>aov</code> object returned from <code><a href="afex.html#topic+aov_car">aov_car</a></code>.</p>
</dd>
<dt><code>"aov_result"</code></dt><dd><p><code>emmeans</code> object returned from <code><a href="emmeans.html#topic+emmeans">emmeans</a></code>.</p>
</dd>
<dt><code>"main_result"</code></dt><dd><p>The power analysis results for ANOVA level effects.</p>
</dd>
<dt><code>"pc_results"</code></dt><dd><p>The power analysis results for the pairwise (t-test) comparisons.</p>
</dd>
<dt><code>"emm_results"</code></dt><dd><p>The power analysis results of the pairwise comparison results.</p>
</dd>
<dt><code>"manova_results"</code></dt><dd><p>Default is &quot;NULL&quot;. If a within-subjects factor is included, then the power of the multivariate (i.e. MANOVA) analyses will be provided.</p>
</dd>
<dt><code>"alpha_level"</code></dt><dd><p>The alpha level, significance cut-off, used for the power analysis.</p>
</dd>
<dt><code>"method"</code></dt><dd><p>Record of the function used to produce the simulation</p>
</dd>
<dt><code>"plot"</code></dt><dd><p>A plot of the dataframe from the simulation; should closely match the meansplot in <code><a href="#topic+ANOVA_design">ANOVA_design</a></code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Frederik Aust
</p>


<h3>References</h3>

<p>Hoenig, J. M., &amp; Heisey, D. M. (2001). The Abuse of Power. The American Statistician, 55(1), 19–24. https://doi.org/10.1198/000313001300339897
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Set up a within design with 2 factors, each with 2 levels
design_result &lt;- ANOVA_design(design = "2w*2w",
n = 40, mu = c(1, 0, 1, 0),
sd = 2, r = 0.8,
labelnames = c("condition", "cheerful",
 "sad", "voice", "human", "robot"))
 
exact_result &lt;- ANOVA_exact(design_result, 
alpha_level = 0.05, verbose = FALSE, 
emm = TRUE, contrast_type = "pairwise")

# Power for pairwise contrasts
exact_result$emm_results

# Corresponding emmeans contrasts
exact_result$emmeans$contrasts

# Manually recalculate power
emmeans_power(exact_result$emmeans$contrasts, 
alpha_level = 0.05)

# Calculate power for Bonferroni-adjusted pairwise comparisons
n_contrasts &lt;- nrow(as.data.frame(exact_result$emmeans$contrasts))
emmeans_power(exact_result$emmeans$contrasts, 
alpha_level = 0.05 / n_contrasts)

# Calculate power for one-sided custom contrasts
exact_result$emmeans$emmeans
custom_contrast &lt;- contrast(exact_result$emmeans$emmeans, 
list(robot_vs_sad_human = c(0, 1, -0.5, -0.5)))
emmeans_power(custom_contrast,
 alpha_level = 0.05 * 2)

# Calculate power for follow-up ANOVA
follow_up &lt;- joint_tests(exact_result$emmeans$emmeans, 
by = "condition")
emmeans_power(follow_up, 
alpha_level = 0.05 / 2)
emmeans_power(emmeans(exact_result$emmeans$emmeans, 
pairwise ~ voice | condition)$contrasts, 
alpha_level = 0.05 / 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='morey_plot.ttest'>Plot out power sensitivity plots for t or F tests</h2><span id='topic+morey_plot.ttest'></span><span id='topic+morey_plot.ftest'></span>

<h3>Description</h3>

<p>Plot out power sensitivity plots for t or F tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>morey_plot.ttest(
  es = seq(0, 1, 0.05),
  n = NULL,
  type = c("two.sample", "one.sample", "paired"),
  alternative = c("two.sided", "one.sided"),
  alpha_level = Superpower_options("alpha_level")
)

morey_plot.ftest(
  es = seq(0, 1, 0.05),
  num_df = 1,
  den_df = NULL,
  alpha_level = Superpower_options("alpha_level"),
  liberal_lambda = Superpower_options("liberal_lambda")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="morey_plot.ttest_+3A_es">es</code></td>
<td>
<p>Effect size magnitudes to include on the plot; either cohen's f or cohen's d depending on whether it is an F-test or t-test</p>
</td></tr>
<tr><td><code id="morey_plot.ttest_+3A_n">n</code></td>
<td>
<p>Sample size (t-test only) per group (two sample), total number of pairs (paired samples), or total observations (one-sample); only applies to t-test</p>
</td></tr>
<tr><td><code id="morey_plot.ttest_+3A_type">type</code></td>
<td>
<p>string specifying the type of t test. Can be abbreviated. (t-test only)</p>
</td></tr>
<tr><td><code id="morey_plot.ttest_+3A_alternative">alternative</code></td>
<td>
<p>one- or two-sided test. Can be abbreviated. (t-test only)</p>
</td></tr>
<tr><td><code id="morey_plot.ttest_+3A_alpha_level">alpha_level</code></td>
<td>
<p>vector of alpha levels; default is 0.05</p>
</td></tr>
<tr><td><code id="morey_plot.ttest_+3A_num_df">num_df</code></td>
<td>
<p>Numerator degrees of freedom for an F-test.</p>
</td></tr>
<tr><td><code id="morey_plot.ttest_+3A_den_df">den_df</code></td>
<td>
<p>Denominator degrees of freedom for an F-test.</p>
</td></tr>
<tr><td><code id="morey_plot.ttest_+3A_liberal_lambda">liberal_lambda</code></td>
<td>
<p>Logical indicator of whether to use the liberal (cohen_f^2\*(num_df+den_df)) or conservative (cohen_f^2\*den_df) calculation of the noncentrality (lambda) parameter estimate. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns plots of effect size (x-axis)
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>morey_plot.ttest</code>: Power-sensitivity plot for t-tests
</p>
</li>
<li> <p><code>morey_plot.ftest</code>: Power-sensitivity plot for F-tests
</p>
</li></ul>


<h3>References</h3>

<p>Morey, R.D. (2020). Power and precision Why the push for replacing “power” with “precision” is misguided. Retrieved from: <a href="https://richarddmorey.medium.com/power-and-precision-47f644ddea5e">https://richarddmorey.medium.com/power-and-precision-47f644ddea5e</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# t-test example ------
# Sensitivity for cohen's d from .1 to .5
# sample sizes of 10 and 20
# alpha levels .05 and .075
# type will be paired and one sided
# Set effect sizes with seq function (?seq)

morey_plot.ttest(es = seq(.1,.5,.01),
n = c(10,20),
alpha_level = c(.05,.075),
type = "paired",
alternative = "one.sided")

## End(Not run)
</code></pre>

<hr>
<h2 id='mu_from_ES'>Convenience function to calculate the means for between designs with one factor (One-Way ANOVA). Can be used to determine the means that should yield a specified effect sizes (expressed in Cohen's f).</h2><span id='topic+mu_from_ES'></span>

<h3>Description</h3>

<p>Convenience function to calculate the means for between designs with one factor (One-Way ANOVA). Can be used to determine the means that should yield a specified effect sizes (expressed in Cohen's f).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mu_from_ES(K, ES)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mu_from_ES_+3A_k">K</code></td>
<td>
<p>Number of groups (2, 3, or 4)</p>
</td></tr>
<tr><td><code id="mu_from_ES_+3A_es">ES</code></td>
<td>
<p>Effect size (eta-squared)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns vector of means
</p>


<h3>References</h3>

<p>Albers, C., &amp; Lakens, D. (2018). When power analyses based on pilot data are biased: Inaccurate effect size estimators and follow-up bias. Journal of Experimental Social Psychology, 74, 187–195. https://doi.org/10.1016/j.jesp.2017.09.004
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Medium effect size (eta-squared), 2 groups
ES &lt;- 0.0588
K &lt;- 2
mu_from_ES(K = K, ES = ES)
</code></pre>

<hr>
<h2 id='opt_alpha-methods'>Methods for opt_alpha objects</h2><span id='topic+opt_alpha-methods'></span><span id='topic+print.opt_alpha'></span><span id='topic+plot.opt_alpha'></span>

<h3>Description</h3>

<p>Methods defined for objects returned from the optimal_alpha and ANOVA_compromise functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'opt_alpha'
print(x, ...)

## S3 method for class 'opt_alpha'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt_alpha-methods_+3A_x">x</code></td>
<td>
<p>object of class <code>opt_alpha</code> as returned from one of the optimal alpha functions in Superpower.</p>
</td></tr>
<tr><td><code id="opt_alpha-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed through, see description of return value
for details.
<code><a href="#topic+ANOVA_compromise">ANOVA_compromise</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><code>print</code></dt><dd><p>Prints short summary of the optimal alpha results</p>
</dd>
<dt><code>plot</code></dt><dd><p>Returns a plot</p>
</dd>
</dl>


<hr>
<h2 id='optimal_alpha'>Justify your alpha level by minimizing or balancing Type 1 and Type 2 error rates.</h2><span id='topic+optimal_alpha'></span>

<h3>Description</h3>

<p>Justify your alpha level by minimizing or balancing Type 1 and Type 2 error rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimal_alpha(
  power_function,
  costT1T2 = 1,
  priorH1H0 = 1,
  error = "minimal",
  plot = Superpower_options("plot")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimal_alpha_+3A_power_function">power_function</code></td>
<td>
<p>Function that outputs the power, calculated with an analytic function.</p>
</td></tr>
<tr><td><code id="optimal_alpha_+3A_costt1t2">costT1T2</code></td>
<td>
<p>Relative cost of Type 1 errors vs. Type 2 errors.</p>
</td></tr>
<tr><td><code id="optimal_alpha_+3A_priorh1h0">priorH1H0</code></td>
<td>
<p>How much more likely a-priori is H1 than H0?</p>
</td></tr>
<tr><td><code id="optimal_alpha_+3A_error">error</code></td>
<td>
<p>Either &quot;minimal&quot; to minimize error rates, or &quot;balance&quot; to balance error rate</p>
</td></tr>
<tr><td><code id="optimal_alpha_+3A_plot">plot</code></td>
<td>
<p>When set to TRUE, automatically outputs a plot of alpha (x-axis) and beta (y-axis) error rates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>alpha = alpha or Type 1 error that minimizes or balances combined error rates
beta = beta or Type 2 error that minimizes or balances combined error rates
objective = value that is the result of the minimization, either 0 (for balance) or the combined weighted error rates
plot =
</p>


<h3>References</h3>

<p>too be added
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Optimize power for a independent t-test, smallest effect of interest
## d = 0.5, 100 participants per condition
res &lt;- optimal_alpha(power_function = "pwr::pwr.t.test(d = 0.5, n = 100,
sig.level = x, type = 'two.sample', alternative = 'two.sided')$power")
res$alpha
res$beta
</code></pre>

<hr>
<h2 id='p_standardized'>Compute standardized alpha level based on unstandardized alpha level and the number of observations N.</h2><span id='topic+p_standardized'></span>

<h3>Description</h3>

<p>Compute standardized alpha level based on unstandardized alpha level and the number of observations N.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_standardized(p, N, standardize_N = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p_standardized_+3A_p">p</code></td>
<td>
<p>The observed p-value.</p>
</td></tr>
<tr><td><code id="p_standardized_+3A_n">N</code></td>
<td>
<p>The number of observations (e.g., the sample size) in the dataset</p>
</td></tr>
<tr><td><code id="p_standardized_+3A_standardize_n">standardize_N</code></td>
<td>
<p>The number of observations (e.g., the sample size) you want to use to standardize the alpha level for. Defaults to 100 (base on Good, 1982).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Good, I. J. (1982). C140. Standardized tail-area probabilities. Journal of Statistical Computation and Simulation, 16(1), 65–66. &lt;https://doi.org/10.1080/00949658208810607&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Check it yields .05 for N = 100:
p_standardized(p = 0.05, N = 100)
## Check it yields .05 for N = 200, p = 0.03535534:
p_standardized(p = 0.03535534, N = 200)
## What is a standardized p-value for p = .05 and N = 200?
p_standardized(p = 0.05, N = 200)
## You can change the standardization N, repeating the example above:
p_standardized(p = 0.05, N = 100, standardize_N = 200)
</code></pre>

<hr>
<h2 id='plot_power'>Convenience function to plot power across a range of sample sizes.</h2><span id='topic+plot_power'></span>

<h3>Description</h3>

<p>Convenience function to plot power across a range of sample sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_power(
  design_result,
  alpha_level = Superpower_options("alpha_level"),
  min_n = 7,
  max_n = 100,
  desired_power = 90,
  plot = Superpower_options("plot"),
  emm = Superpower_options("emm"),
  emm_model = Superpower_options("emm_model"),
  contrast_type = Superpower_options("contrast_type"),
  emm_comp,
  verbose = Superpower_options("verbose"),
  exact2 = FALSE,
  liberal_lambda = Superpower_options("liberal_lambda")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_power_+3A_design_result">design_result</code></td>
<td>
<p>Output from the ANOVA_design function</p>
</td></tr>
<tr><td><code id="plot_power_+3A_alpha_level">alpha_level</code></td>
<td>
<p>Alpha level used to determine statistical significance</p>
</td></tr>
<tr><td><code id="plot_power_+3A_min_n">min_n</code></td>
<td>
<p>Minimum sample size in power curve. Cannot be less than or equal to the product of factors. E.g., if design = &quot;2b*2b&quot; then min_n must be at least 5 (2\*2+1=5)</p>
</td></tr>
<tr><td><code id="plot_power_+3A_max_n">max_n</code></td>
<td>
<p>Maximum sample size in power curve.</p>
</td></tr>
<tr><td><code id="plot_power_+3A_desired_power">desired_power</code></td>
<td>
<p>Desired power (e.g., 80, 90). N per group will be highlighted to achieve this desired power in the plot. Defaults to 90.</p>
</td></tr>
<tr><td><code id="plot_power_+3A_plot">plot</code></td>
<td>
<p>Should power plot be printed automatically (defaults to TRUE)</p>
</td></tr>
<tr><td><code id="plot_power_+3A_emm">emm</code></td>
<td>
<p>Set to FALSE to not perform analysis of estimated marginal means</p>
</td></tr>
<tr><td><code id="plot_power_+3A_emm_model">emm_model</code></td>
<td>
<p>Set model type (&quot;multivariate&quot;, or &quot;univariate&quot;) for estimated marginal means</p>
</td></tr>
<tr><td><code id="plot_power_+3A_contrast_type">contrast_type</code></td>
<td>
<p>Select the type of comparison for the estimated marginal means</p>
</td></tr>
<tr><td><code id="plot_power_+3A_emm_comp">emm_comp</code></td>
<td>
<p>Set the comparisons for estimated marginal means comparisons. This is a factor name (a), combination of factor names (a+b), or for simple effects a | sign is needed (a|b)</p>
</td></tr>
<tr><td><code id="plot_power_+3A_verbose">verbose</code></td>
<td>
<p>Set to FALSE to not print results (default = TRUE)</p>
</td></tr>
<tr><td><code id="plot_power_+3A_exact2">exact2</code></td>
<td>
<p>Logical indicator for which <code>ANOVA_exact</code> function (<code>ANOVA_exact</code> or <code>ANOVA_exact2</code>) to use in the plots. Default is FALSE which uses <code>ANOVA_exact</code> which has sample size limitations.</p>
</td></tr>
<tr><td><code id="plot_power_+3A_liberal_lambda">liberal_lambda</code></td>
<td>
<p>Logical indicator of whether to use the liberal (cohen_f^2\*(num_df+den_df)) or conservative (cohen_f^2\*den_df) calculation of the noncentrality (lambda) parameter estimate. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns plot with power curves for the ANOVA, and a dataframe with the summary data.
</p>

<dl>
<dt><code>"plot_ANOVA"</code></dt><dd><p>Plot of power curves from ANOVA results.</p>
</dd>
<dt><code>"plot_MANOVA"</code></dt><dd><p>Plot of power curves from MANOVA results. Returns NULL if no within-subject factors.</p>
</dd>
<dt><code>"plot_emm"</code></dt><dd><p>Plot of power curves from MANOVA results. Returns NULL if emm = FALSE.</p>
</dd>
<dt><code>"anova_n"</code></dt><dd><p>Achieved Power and Sample Size for ANOVA-level effects.</p>
</dd>
<dt><code>"manova_n"</code></dt><dd><p>Achieved Power and Sample Size for MANOVA-level effects.</p>
</dd>
<dt><code>"emm_n"</code></dt><dd><p>Achieved Power and Sample Size for estimated marginal means.</p>
</dd>
<dt><code>"power_df"</code></dt><dd><p>The tabulated ANOVA power results.</p>
</dd>
<dt><code>"power_df_manova"</code></dt><dd><p>The tabulated MANOVA power results. Returns NULL if no within-subject factors.</p>
</dd>
<dt><code>"power_df_emm"</code></dt><dd><p>The tabulated Estimated Marginal Means power results. Returns NULL if emm = FALSE.</p>
</dd>
<dt><code>"effect_sizes"</code></dt><dd><p>Effect sizes (partial eta-squared) from ANOVA results.</p>
</dd>
<dt><code>"effect_sizes_manova"</code></dt><dd><p>Effect sizes (Pillai's Trace) from MANOVA results. Returns NULL if no within-subject factors.</p>
</dd>
<dt><code>"effect_sizes_emm"</code></dt><dd><p> Effect sizes (cohen's f) estimated marginal means results. Returns NULL if emm = FALSE.</p>
</dd>
</dl>



<h3>References</h3>

<p>too be added
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
design_result &lt;- ANOVA_design(design = "3b",
                             n = 20,
                             mu = c(0,0,0.3),
                             sd = 1,
                             labelnames = c("condition",
                             "cheerful", "neutral", "sad"))

plot_power(design_result, min_n = 50, max_n = 70, desired_power = 90)

## End(Not run)
</code></pre>

<hr>
<h2 id='power_oneway_ancova'>Power Calculations for a one-way ANCOVA</h2><span id='topic+power_oneway_ancova'></span>

<h3>Description</h3>

<p>Compute power of ANCOVA omnibus test (power_oneway_ancova) or contrast (power_oneway_ancova) for one-way (single factor), between subjects designs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_oneway_ancova(
  n = NULL,
  mu = NULL,
  n_cov = 1,
  r2 = NULL,
  sd = 1,
  alpha_level = Superpower_options("alpha_level"),
  beta_level = NULL,
  round_up = TRUE,
  type = "exact"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power_oneway_ancova_+3A_n">n</code></td>
<td>
<p>Sample size in each condition.</p>
</td></tr>
<tr><td><code id="power_oneway_ancova_+3A_mu">mu</code></td>
<td>
<p>Vector specifying mean for each condition.</p>
</td></tr>
<tr><td><code id="power_oneway_ancova_+3A_n_cov">n_cov</code></td>
<td>
<p>Number of covariates.</p>
</td></tr>
<tr><td><code id="power_oneway_ancova_+3A_r2">r2</code></td>
<td>
<p>Coefficient of determination (r^2) of the combined covariates.</p>
</td></tr>
<tr><td><code id="power_oneway_ancova_+3A_sd">sd</code></td>
<td>
<p>Standard deviation for all conditions (residual SD without covariate adjustment).</p>
</td></tr>
<tr><td><code id="power_oneway_ancova_+3A_alpha_level">alpha_level</code></td>
<td>
<p>Alpha level used to determine statistical significance.</p>
</td></tr>
<tr><td><code id="power_oneway_ancova_+3A_beta_level">beta_level</code></td>
<td>
<p>Type II error probability (power/100-1)</p>
</td></tr>
<tr><td><code id="power_oneway_ancova_+3A_round_up">round_up</code></td>
<td>
<p>Logical indicator for whether to round up the sample size(s) to a whole number. Default is TRUE.</p>
</td></tr>
<tr><td><code id="power_oneway_ancova_+3A_type">type</code></td>
<td>
<p>Sets the method for estimating power. &quot;exact&quot; will use the Shieh (2020) approach while &quot;approx&quot; will use the Keppel (1991) approach.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dfs = degrees of freedom, 
N = Total sample size,
n = Sample size per group/condition,
n_cov = Number of covariates, 
mu = Mean for each condition,
sd = Standard deviation,
r2 = Coefficient of determination of combined covariates.
alpha_level = Type 1 error probability, 
beta_level = Type 2 error probability,
power = Power of test (1-beta_level\*100
type = Method (Shieh or Keppel) for estimating power
</p>


<h3>References</h3>

<p>Keppel, G. (1991). Design and Analysis A Researcher's Handbook. 3rd Edition. Prentice Hall. Englewood Cliffs, New Jersey. See pages 323 - 324. 
Shieh, G. (2017). Power and sample size calculations for contrast analysis in ANCOVA. Multivariate behavioral research, 52(1), 1-11.
Shieh, G. (2020). Power analysis and sample size planning in ANCOVA designs. Psychometrika, 85(1), 101-120.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example from Table 1 Shieh 2020
power_oneway_ancova(mu = c(400, 450, 500), n = c(21,21,21),
r2 = .1^2, sd = 100)
</code></pre>

<hr>
<h2 id='power_oneway_between'>Analytic power calculation for one-way between designs.</h2><span id='topic+power_oneway_between'></span>

<h3>Description</h3>

<p>Analytic power calculation for one-way between designs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_oneway_between(design_result, alpha_level = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power_oneway_between_+3A_design_result">design_result</code></td>
<td>
<p>Output from the ANOVA_design function</p>
</td></tr>
<tr><td><code id="power_oneway_between_+3A_alpha_level">alpha_level</code></td>
<td>
<p>Alpha level used to determine statistical significance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mu = means
</p>
<p>sigma = standard deviation
</p>
<p>n = sample size
</p>
<p>alpha_level = alpha level
</p>
<p>Cohen_f = Cohen f
</p>
<p>f_2 = Cohen's f^2
</p>
<p>lambda = lambda
</p>
<p>F_critical = Critical F-value
</p>
<p>power = power
</p>
<p>df1 = degrees of freedom for the effect
</p>
<p>df2 = degrees of freedom of the error
</p>
<p>eta_p_2 = partial eta-squared
</p>
<p>mean_mat = matrix of the means
</p>


<h3>References</h3>

<p>too be added
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Set up a within design with one factor with 2 levels,
## 40 participants (woh do all conditions), and standard deviation of 2
## with a mean pattern of 1, 0, 1, conditions labeled 'condition'
## with names for levels of "cheerful", "neutral", "sad"
design_result &lt;- ANOVA_design(design = "3b", n = 40, mu = c(1, 0, 1),
      sd = 2, labelnames = c("condition", "cheerful", "neutral", "sad"))
power_result &lt;- power_oneway_between(design_result, alpha_level = 0.05)
</code></pre>

<hr>
<h2 id='power_oneway_within'>Analytic power calculation for one-way within designs.</h2><span id='topic+power_oneway_within'></span>

<h3>Description</h3>

<p>Analytic power calculation for one-way within designs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_oneway_within(design_result, alpha_level = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power_oneway_within_+3A_design_result">design_result</code></td>
<td>
<p>Output from the ANOVA_design function</p>
</td></tr>
<tr><td><code id="power_oneway_within_+3A_alpha_level">alpha_level</code></td>
<td>
<p>Alpha level used to determine statistical significance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mu = means
</p>
<p>sigma = standard deviation
</p>
<p>n = sample size
</p>
<p>alpha_level = alpha level
</p>
<p>Cohen_f = Cohen's f
</p>
<p>f_2 = Cohen's f squared
</p>
<p>lambda = lambda
</p>
<p>F_critical = Critical F-value
</p>
<p>power = power
</p>
<p>df1 = degrees of freedom for the effect
</p>
<p>df2 = degrees of freedom of the error
</p>
<p>eta_p_2 = partial eta-squared
</p>
<p>mean_mat = matrix of the means
</p>


<h3>References</h3>

<p>too be added
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Set up a within design with 3 factors,
## with correlation between observations of 0.8,
## 40 participants (who do all conditions), and standard deviation of 2
## with a mean pattern of 1, 0, 1, conditions labeled 'condition' and
## 'voice', with names for levels of "cheerful", "neutral", "sad".
design_result &lt;- ANOVA_design(design = "3w", n = 40, r = 0.8,
      mu = c(1, 0, 1), sd = 2,
      labelnames = c("condition", "cheerful", "neutral", "sad"))
power_result &lt;- power_oneway_within(design_result, alpha_level = 0.05)
</code></pre>

<hr>
<h2 id='power_standardized_alpha'>Optimizing function to achieve desired power based on a standardized alpha level.</h2><span id='topic+power_standardized_alpha'></span>

<h3>Description</h3>

<p>Because the standardized alpha depends on the sample size (N), and the power depends on the sample size, deciding upon the sample size to achieve a desired power requires an iterative procedure. Increasing the sample size reduces the standardized alpha, which requires an increase in the sample size for the power analysis, which reduces the standardized alpha. This function takes a power analysis function that outputs the power as a function of the desired power, the alpha level, as a function of N(x).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_standardized_alpha(
  power_function,
  alpha = 0.05,
  power = 0.8,
  standardize_N = 100,
  verbose = Superpower_options("verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power_standardized_alpha_+3A_power_function">power_function</code></td>
<td>
<p>Function that outputs the power, calculated with an analytic function.</p>
</td></tr>
<tr><td><code id="power_standardized_alpha_+3A_alpha">alpha</code></td>
<td>
<p>The unstandardized alpha level (e.g., 0.05), independent of the sample size.</p>
</td></tr>
<tr><td><code id="power_standardized_alpha_+3A_power">power</code></td>
<td>
<p>The desired power, i.e., the outcome of the power calculation you would like to achieve.</p>
</td></tr>
<tr><td><code id="power_standardized_alpha_+3A_standardize_n">standardize_N</code></td>
<td>
<p>The sample size you want to use to standardize the alpha level for. Defaults to 100 (based on Good, 1982).</p>
</td></tr>
<tr><td><code id="power_standardized_alpha_+3A_verbose">verbose</code></td>
<td>
<p>Set to FALSE to not print results (default = TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of 3 objects: a_stan = standardized alpha, N = sample size, and objective = for the weighted combined error rate.
</p>


<h3>References</h3>

<p>Good, I. J. (1982). C140. Standardized tail-area probabilities. Journal of Statistical Computation and Simulation, 16(1), 65–66. &lt;https://doi.org/10.1080/00949658208810607&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
res &lt;- power_standardized_alpha(power_function = "pwr::pwr.t.test(d = 0.3,
n = x, sig.level = a_stan, type = 'two.sample',
alternative = 'two.sided')$power", power = 0.9, alpha = 0.05)
res$N

</code></pre>

<hr>
<h2 id='power_threeway_between'>Analytic power calculation for three-way between designs.</h2><span id='topic+power_threeway_between'></span>

<h3>Description</h3>

<p>Analytic power calculation for three-way between designs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_threeway_between(design_result, alpha_level = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power_threeway_between_+3A_design_result">design_result</code></td>
<td>
<p>Output from the ANOVA_design function</p>
</td></tr>
<tr><td><code id="power_threeway_between_+3A_alpha_level">alpha_level</code></td>
<td>
<p>Alpha level used to determine statistical significance (default to 0.05)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mu = means
</p>
<p>sigma = standard deviation
</p>
<p>n = sample size
</p>
<p>alpha_level = alpha level
</p>
<p>Cohen_f_A = Cohen's f for main effect A
</p>
<p>Cohen_f_B = Cohen's f for main effect B
</p>
<p>Cohen_f_C = Cohen's f for main effect C
</p>
<p>Cohen_f_AB = Cohen's f for the A*B interaction
</p>
<p>Cohen_f_AC = Cohen's f for the A*C interaction
</p>
<p>Cohen_f_BC = Cohen's f for the B*C interaction
</p>
<p>Cohen_f_ABC = Cohen's f for the A*B*C interaction
</p>
<p>f_2_A = Cohen's f squared for main effect A
</p>
<p>f_2_B = Cohen's f squared for main effect B
</p>
<p>f_2_C = Cohen's f squared for main effect C
</p>
<p>f_2_AB = Cohen's f squared for A*B interaction
</p>
<p>f_2_AC = Cohen's f squared for A*C interaction
</p>
<p>f_2_BC = Cohen's f squared for B*C interaction
</p>
<p>f_2_ABC = Cohen's f squared for A*B*C interaction
</p>
<p>lambda_A = lambda for main effect A
</p>
<p>lambda_B = lambda for main effect B
</p>
<p>lambda_C = lambda for main effect C
</p>
<p>lambda_AB = lambda for A*B interaction
</p>
<p>lambda_AC = lambda for A*C interaction
</p>
<p>lambda_BC = lambda for B*C interaction
</p>
<p>lambda_ABC = lambda for A*B*C interaction
</p>
<p>critical_F_A = critical F-value for main effect A
</p>
<p>critical_F_B = critical F-value for main effect B
</p>
<p>critical_F_C = critical F-value for main effect C
</p>
<p>critical_F_AB = critical F-value for A*B interaction
</p>
<p>critical_F_AC = critical F-value for A*C interaction
</p>
<p>critical_F_BC = critical F-value for B*C interaction
</p>
<p>critical_F_ABC = critical F-value for A*B*C interaction
</p>
<p>power_A = power for main effect A
</p>
<p>power_B = power for main effect B
</p>
<p>power_C = power for main effect C
</p>
<p>power_AB = power for A*B interaction
</p>
<p>power_AC = power for A*C interaction
</p>
<p>power_BC = power for B*C interaction
</p>
<p>power_ABC = power for A*B*C interaction
</p>
<p>df_A = degrees of freedom for main effect A
</p>
<p>df_B = degrees of freedom for main effect B
</p>
<p>df_C = degrees of freedom for main effect C
</p>
<p>df_AB = degrees of freedom for A*B interaction
</p>
<p>df_AC = degrees of freedom for A*C interaction
</p>
<p>df_BC = degrees of freedom for B*C interaction
</p>
<p>df_ABC = degrees of freedom for A*B*C interaction
</p>
<p>df_error = degrees of freedom for error term
</p>
<p>eta_p_2_A = partial eta-squared for main effect A
</p>
<p>eta_p_2_B = partial eta-squared for main effect B
</p>
<p>eta_p_2_C = partial eta-squared for main effect C
</p>
<p>eta_p_2_AB = partial eta-squared for A*B interaction
</p>
<p>eta_p_2_AC = partial eta-squared for A*C interaction
</p>
<p>eta_p_2_BC = partial eta-squared for B*C interaction
</p>
<p>eta_p_2_ABC = partial eta-squared for A*B*C interaction
</p>
<p>mean_mat = matrix of the means
</p>


<h3>References</h3>

<p>to be added
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design_result &lt;- ANOVA_design(design = "2b*2b*2b", n = 40,
      mu = c(1, 0, 1, 0, 0, 1, 1, 0), sd = 2,
      labelnames = c("condition", "cheerful", "sad",
      "voice", "human", "robot", "color", "green", "red"))
power_result &lt;- power_threeway_between(design_result, alpha_level = 0.05)
</code></pre>

<hr>
<h2 id='power_twoway_between'>Analytic power calculation for two-way between designs.</h2><span id='topic+power_twoway_between'></span>

<h3>Description</h3>

<p>Analytic power calculation for two-way between designs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_twoway_between(design_result, alpha_level = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power_twoway_between_+3A_design_result">design_result</code></td>
<td>
<p>Output from the ANOVA_design function</p>
</td></tr>
<tr><td><code id="power_twoway_between_+3A_alpha_level">alpha_level</code></td>
<td>
<p>Alpha level used to determine statistical significance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mu = means
</p>
<p>sigma = standard deviation
</p>
<p>n = sample size
</p>
<p>alpha_level = alpha level
</p>
<p>Cohen_f_A = Cohen's f for main effect A
</p>
<p>Cohen_f_B = Cohen's f for main effect B
</p>
<p>Cohen_f_AB = Cohen's f for the A*B interaction
</p>
<p>f_2_A = Cohen's f squared for main effect A
</p>
<p>f_2_B = Cohen's f squared for main effect B
</p>
<p>f_2_AB = Cohen's f squared for A*B interaction
</p>
<p>lambda_A = lambda for main effect A
</p>
<p>lambda_B = lambda for main effect B
</p>
<p>lambda_AB = lambda for A*B interaction
</p>
<p>critical_F_A = critical F-value for main effect A
</p>
<p>critical_F_B = critical F-value for main effect B
</p>
<p>critical_F_AB = critical F-value for A*B interaction
</p>
<p>power_A = power for main effect A
</p>
<p>power_B = power for main effect B
</p>
<p>power_AB = power for A*B interaction
</p>
<p>df_A = degrees of freedom for main effect A
</p>
<p>df_B = degrees of freedom for main effect B
</p>
<p>df_AB = degrees of freedom for A*B interaction
</p>
<p>df_error = degrees of freedom for error term
</p>
<p>eta_p_2_A = partial eta-squared for main effect A
</p>
<p>eta_p_2_B = partial eta-squared for main effect B
</p>
<p>eta_p_2_AB = partial eta-squared for A*B interaction
</p>
<p>mean_mat = matrix of the means
</p>


<h3>References</h3>

<p>too be added
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design_result &lt;- ANOVA_design(design = "2b*2b", n = 40, mu = c(1, 0, 1, 0),
     sd = 2, labelnames = c("condition", "cheerful", "sad",
     "voice", "human", "robot"))
power_result &lt;- power_twoway_between(design_result, alpha_level = 0.05)
</code></pre>

<hr>
<h2 id='power.ftest'>Power Calculations for an F-test</h2><span id='topic+power.ftest'></span>

<h3>Description</h3>

<p>Compute power of test or determine parameters to obtain target power. Inspired by the pwr.f2.test function in the pwr package, but allows for varying noncentrality parameter estimates for a more liberal (default in pwr.f2.test) or conservative (default in this function) estimates (see Aberson, Chapter 5, pg 72).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power.ftest(
  num_df = NULL,
  den_df = NULL,
  cohen_f = NULL,
  alpha_level = Superpower_options("alpha_level"),
  beta_level = NULL,
  liberal_lambda = Superpower_options("liberal_lambda")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power.ftest_+3A_num_df">num_df</code></td>
<td>
<p>degrees of freedom for numerator</p>
</td></tr>
<tr><td><code id="power.ftest_+3A_den_df">den_df</code></td>
<td>
<p>degrees of freedom for denominator</p>
</td></tr>
<tr><td><code id="power.ftest_+3A_cohen_f">cohen_f</code></td>
<td>
<p>Cohen's f effect size. Note: this is the sqrt(f2) if you are used to using pwr.f2.test</p>
</td></tr>
<tr><td><code id="power.ftest_+3A_alpha_level">alpha_level</code></td>
<td>
<p>Alpha level used to determine statistical significance.</p>
</td></tr>
<tr><td><code id="power.ftest_+3A_beta_level">beta_level</code></td>
<td>
<p>Type II error probability (power/100-1)</p>
</td></tr>
<tr><td><code id="power.ftest_+3A_liberal_lambda">liberal_lambda</code></td>
<td>
<p>Logical indicator of whether to use the liberal (cohen_f^2\*(num_df+den_df)) or conservative (cohen_f^2\*den_df) calculation of the noncentrality (lambda) parameter estimate. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>num_df = degrees of freedom for numerator, 
den_df = degrees of freedom for denominator, 
cohen_f = Cohen's f effect size, 
alpha_level = Type 1 error probability, 
beta_level = Type 2 error probability,
power = Power of test (1-beta_level\*100
lambda = Noncentrality parameter estimate (default = cohen_f^2\*den_df, liberal = cohen_f^2\*(num_df+den_df))
</p>


<h3>References</h3>

<p>Cohen, J. (1988). Statistical power analysis for the behavioral sciences (2nd ed.). Hillsdale,NJ: Lawrence Erlbaum.
Aberson, C. (2019). Applied Power Analysis for the Behavioral Sciences (2nd ed.). New York,NY: Routledge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design_result &lt;- ANOVA_design(design = "2b",
n = 65,
mu = c(0,.5),
sd = 1,
plot = FALSE)
x1 = ANOVA_exact2(design_result, verbose = FALSE)
ex = power.ftest(num_df = x1$anova_table$num_df, 
den_df = x1$anova_table$den_df, 
cohen_f = x1$main_result$cohen_f,
alpha_level = 0.05,
liberal_lambda = FALSE)
</code></pre>

<hr>
<h2 id='sim_result-methods'>Methods for sim_result objects</h2><span id='topic+sim_result-methods'></span><span id='topic+print.sim_result'></span><span id='topic+plot.sim_result'></span><span id='topic+confint.sim_result'></span>

<h3>Description</h3>

<p>Methods defined for objects returned from the ANOVA_exact, ANOVA_exact2, and ANOVA_power functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sim_result'
print(x, ...)

## S3 method for class 'sim_result'
plot(x, ...)

## S3 method for class 'sim_result'
confint(object, parm = "main_results", level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_result-methods_+3A_x">x</code></td>
<td>
<p>object of class <code>sim_result</code> as returned from one of the simulation functions in Superpower.</p>
</td></tr>
<tr><td><code id="sim_result-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed through, see description of return value</p>
</td></tr>
<tr><td><code id="sim_result-methods_+3A_object">object</code></td>
<td>
<p>Result returned from ANOVA_power (only applicable argument for confint)</p>
</td></tr>
<tr><td><code id="sim_result-methods_+3A_parm">parm</code></td>
<td>
<p>Argument for confint. Select what results from the simulation to return with confidence intervals. Options currently include: main_results (default), pc_results, manova_results, and emm_results.</p>
</td></tr>
<tr><td><code id="sim_result-methods_+3A_level">level</code></td>
<td>
<p>Argument for confint. Confidence level for binomial proportion confidence intervals (Wilson, 1927). Default is .95.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><code>print</code></dt><dd><p>Prints short summary of the simulation result</p>
</dd>
<dt><code>plot</code></dt><dd><p>Returns <code>meansplot</code> or a plot of the distribution of p-values depending on whether an exact or Monte Carlo simulation was performed</p>
</dd>
<dt><code>confint</code></dt><dd><p>Returns confidence intervals for the selected result from ANOVA_power</p>
</dd>
</dl>



<h3>References</h3>

<p>Wilson, E. (1927). Probable Inference, the Law of Succession, and Statistical Inference. Journal of the American Statistical Association, 22(158), 209-212. doi:10.2307/2276774
</p>

<hr>
<h2 id='Superpower_options'>Set/get global Superpower options</h2><span id='topic+Superpower_options'></span>

<h3>Description</h3>

<p>Global Superpower options are used, for example, by <code><a href="#topic+ANOVA_exact">ANOVA_exact</a></code> (et al.)
and <code><a href="#topic+ANOVA_power">ANOVA_power</a></code>. But can be changed in each functions directly using
an argument (which has precedence over the global options).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Superpower_options(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Superpower_options_+3A_...">...</code></td>
<td>
<p>One of four: (1) nothing, then returns all options as a list; (2)
a name of an option element, then returns its' value; (3) a name-value pair
which sets the corresponding option to the new value (and returns nothing),
(4) a list with option-value pairs which sets all the corresponding
arguments. The example show all possible cases.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following arguments are currently set:
</p>

<ul>
<li> <p><code>verbose</code> should verbose (printed results) be set to true? Default is <code>TRUE</code>.
</p>
</li>
<li> <p><code>emm</code> Option to perform analysis of estimated marginal means. Default is <code>FALSE</code>.
</p>
</li>
<li> <p><code>emm_model</code> Model type (&quot;multivariate&quot;, or &quot;univariate&quot;) for estimated marginal means. Default is <code>"multivariate"</code>.
</p>
</li>
<li> <p><code>contrast_type</code> The type of comparison for the estimated marginal means. Default is <code>"pairwise"</code>. See ?emmeans::'contrast-methods' for more details on acceptable methods.
</p>
</li>
<li> <p><code>plot</code> Option to automatically print plots. Default is <code>FALSE</code>.
</p>
</li>
<li> <p><code>alpha_level</code> Alpha level used to determine statistical significance. Default is .05.
</p>
</li>
<li> <p><code>correction</code> Option to set a correction for sphericity violations. Default is no correction. This can be set to &quot;none&quot;, &quot;GG&quot; Greenhouse-Geisser, and &quot;HF&quot; Huynh-Feldt
</p>
</li>
<li> <p><code>liberal_lambda</code> Option to set a logical indicator of whether to use the liberal (cohen_f^2\*(num_df+den_df)) or conservative (cohen_f^2\*den_df) calculation of the noncentrality (lambda) parameter estimate. Default is FALSE.
</p>
</li></ul>



<h3>Value</h3>

<p>depends on input, see above.
</p>


<h3>Note</h3>

<p>All options are saved in the global R <code><a href="base.html#topic+options">options</a></code> with prefix
<code>Superpower.</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
