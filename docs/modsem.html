<!DOCTYPE html><html><head><title>Help for package modsem</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {modsem}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#modsem-package'><p>modsem: Latent Interaction (and Moderation) Analysis in Structural Equation Models (SEM)</p></a></li>
<li><a href='#compare_fit'><p>compare model fit for qml and lms models</p></a></li>
<li><a href='#default_settings_da'><p>default arguments fro LMS and QML approach</p></a></li>
<li><a href='#default_settings_pi'><p>default arguments for product indicator approaches</p></a></li>
<li><a href='#extract_lavaan'><p>extract lavaan object from modsem object estimated using product indicators</p></a></li>
<li><a href='#fit_modsem_da'><p>Fit measures for QML and LMS models</p></a></li>
<li><a href='#get_pi_data'><p>Get data with product indicators for different approaches</p></a></li>
<li><a href='#get_pi_syntax'><p>Get lavaan syntax for product indicator approaches</p></a></li>
<li><a href='#jordan'><p>Jordan subset of PISA 2006 data</p></a></li>
<li><a href='#modsem'><p>Interaction between latent variables</p></a></li>
<li><a href='#modsem_da'><p>Interaction between latent variables using lms and qml approaches</p></a></li>
<li><a href='#modsem_inspect'><p>Inspect model information</p></a></li>
<li><a href='#modsem_mplus'><p>Estimation latent interactions through mplus</p></a></li>
<li><a href='#modsem_pi'><p>Interaction between latent variables using product indicators</p></a></li>
<li><a href='#modsemify'><p>Generate parameter table for lavaan syntax</p></a></li>
<li><a href='#multiplyIndicatorsCpp'><p>Multiply indicators</p></a></li>
<li><a href='#oneInt'><p>oneInt</p></a></li>
<li><a href='#parameter_estimates'><p>Extract parameterEstimates from an estimated model</p></a></li>
<li><a href='#plot_interaction'><p>Plot Interaction Effects</p></a></li>
<li><a href='#standardized_estimates'><p>Get standardized estimates</p></a></li>
<li><a href='#summary.modsem_lms'><p>summary for modsem objects</p></a></li>
<li><a href='#TPB'><p>TPB</p></a></li>
<li><a href='#TPB_UK'><p>TPB_UK</p></a></li>
<li><a href='#trace_path'><p>Estimate formulas for (co-)variance paths using Wright's path tracing rules</p></a></li>
<li><a href='#var_interactions'><p>Extract or modify parTable from an estimated model with estimated variances of interaction terms</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Latent Interaction (and Moderation) Analysis in Structural
Equation Models (SEM)</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kjell Solem Slupphaug &lt;slupphaugkjell@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Estimation of interaction (i.e., moderation) effects between latent variables
    in structural equation models (SEM). 
    The supported methods are:
      The constrained approach (Algina &amp; Moulder, 2001).
      The unconstrained approach (Marsh et al., 2004).
      The residual centering approach (Little et al., 2006).
      The double centering approach (Lin et al., 2010).
      The latent moderated structural equations (LMS) approach (Klein &amp; Moosbrugger, 2000).
      The quasi-maximum likelihood (QML) approach (Klein &amp; Muthén, 2007) (temporarily unavailable)
    The constrained- unconstrained, residual- and double centering- approaches
    are estimated via 'lavaan' (Rosseel, 2012), whilst the LMS- and QML- approaches
    are estimated via by modsem it self. Alternatively model can be
    estimated via 'Mplus' (Muthén &amp; Muthén, 1998-2017).
    References:
    Algina, J., &amp; Moulder, B. C. (2001). 
      &lt;<a href="https://doi.org/10.1207%2FS15328007SEM0801_3">doi:10.1207/S15328007SEM0801_3</a>&gt;.
      "A note on estimating the Jöreskog-Yang model for latent variable interaction using 'LISREL' 8.3."
    Klein, A., &amp; Moosbrugger, H. (2000). 
      &lt;<a href="https://doi.org/10.1007%2FBF02296338">doi:10.1007/BF02296338</a>&gt;.
      "Maximum likelihood estimation of latent interaction effects with the LMS method."
    Klein, A. G., &amp; Muthén, B. O. (2007). 
      &lt;<a href="https://doi.org/10.1080%2F00273170701710205">doi:10.1080/00273170701710205</a>&gt;.
      "Quasi-maximum likelihood estimation of structural equation models with multiple interaction and quadratic effects."
    Lin, G. C., Wen, Z., Marsh, H. W., &amp; Lin, H. S. (2010). 
      &lt;<a href="https://doi.org/10.1080%2F10705511.2010.488999">doi:10.1080/10705511.2010.488999</a>&gt;.
      "Structural equation models of latent interactions: Clarification of orthogonalizing and double-mean-centering strategies."
    Little, T. D., Bovaird, J. A., &amp; Widaman, K. F. (2006). 
      &lt;<a href="https://doi.org/10.1207%2Fs15328007sem1304_1">doi:10.1207/s15328007sem1304_1</a>&gt;.
      "On the merits of orthogonalizing powered and product terms: Implications for modeling interactions among latent variables."
    Marsh, H. W., Wen, Z., &amp; Hau, K. T. (2004). 
      &lt;<a href="https://doi.org/10.1037%2F1082-989X.9.3.275">doi:10.1037/1082-989X.9.3.275</a>&gt;.
      "Structural equation models of latent interactions: evaluation of alternative estimation strategies and indicator construction."
    Muthén, L.K. and Muthén, B.O. (1998-2017).  
      "'Mplus' User’s Guide.  Eighth Edition."
      <a href="https://www.statmodel.com/">https://www.statmodel.com/</a>.
    Rosseel Y (2012). 
      &lt;<a href="https://doi.org/10.18637%2Fjss.v048.i02">doi:10.18637/jss.v048.i02</a>&gt;.
      "'lavaan': An R Package for Structural Equation Modeling." </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, purrr, stringr, lavaan, rlang, MplusAutomation, nlme,
R6, dplyr, mvnfast, stats, fastGHQuad, mvtnorm, ggplot2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.50)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Kss2k/modsem">https://github.com/Kss2k/modsem</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-03 09:15:18 UTC; kjell</td>
</tr>
<tr>
<td>Author:</td>
<td>Kjell Solem Slupphaug
    <a href="https://orcid.org/0009-0005-8324-2834"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-07 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='modsem-package'>modsem: Latent Interaction (and Moderation) Analysis in Structural Equation Models (SEM)</h2><span id='topic+modsem-package'></span>

<h3>Description</h3>

<p>Estimation of interaction (i.e., moderation) effects between latent variables in structural equation models (SEM). The supported methods are: The constrained approach (Algina &amp; Moulder, 2001). The unconstrained approach (Marsh et al., 2004). The residual centering approach (Little et al., 2006). The double centering approach (Lin et al., 2010). The latent moderated structural equations (LMS) approach (Klein &amp; Moosbrugger, 2000). The quasi-maximum likelihood (QML) approach (Klein &amp; Muthén, 2007) (temporarily unavailable) The constrained- unconstrained, residual- and double centering- approaches are estimated via 'lavaan' (Rosseel, 2012), whilst the LMS- and QML- approaches are estimated via by modsem it self. Alternatively model can be estimated via 'Mplus' (Muthén &amp; Muthén, 1998-2017). References: Algina, J., &amp; Moulder, B. C. (2001). <a href="https://doi.org/10.1207/S15328007SEM0801_3">doi:10.1207/S15328007SEM0801_3</a>. &quot;A note on estimating the Jöreskog-Yang model for latent variable interaction using 'LISREL' 8.3.&quot; Klein, A., &amp; Moosbrugger, H. (2000). <a href="https://doi.org/10.1007/BF02296338">doi:10.1007/BF02296338</a>. &quot;Maximum likelihood estimation of latent interaction effects with the LMS method.&quot; Klein, A. G., &amp; Muthén, B. O. (2007). <a href="https://doi.org/10.1080/00273170701710205">doi:10.1080/00273170701710205</a>. &quot;Quasi-maximum likelihood estimation of structural equation models with multiple interaction and quadratic effects.&quot; Lin, G. C., Wen, Z., Marsh, H. W., &amp; Lin, H. S. (2010). <a href="https://doi.org/10.1080/10705511.2010.488999">doi:10.1080/10705511.2010.488999</a>. &quot;Structural equation models of latent interactions: Clarification of orthogonalizing and double-mean-centering strategies.&quot; Little, T. D., Bovaird, J. A., &amp; Widaman, K. F. (2006). <a href="https://doi.org/10.1207/s15328007sem1304_1">doi:10.1207/s15328007sem1304_1</a>. &quot;On the merits of orthogonalizing powered and product terms: Implications for modeling interactions among latent variables.&quot; Marsh, H. W., Wen, Z., &amp; Hau, K. T. (2004). <a href="https://doi.org/10.1037/1082-989X.9.3.275">doi:10.1037/1082-989X.9.3.275</a>. &quot;Structural equation models of latent interactions: evaluation of alternative estimation strategies and indicator construction.&quot; Muthén, L.K. and Muthén, B.O. (1998-2017). &quot;'Mplus' User’s Guide. Eighth Edition.&quot; <a href="https://www.statmodel.com/">https://www.statmodel.com/</a>. Rosseel Y (2012). <a href="https://doi.org/10.18637/jss.v048.i02">doi:10.18637/jss.v048.i02</a>. &quot;'lavaan': An R Package for Structural Equation Modeling.&quot;
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Kjell Solem Slupphaug <a href="mailto:slupphaugkjell@gmail.com">slupphaugkjell@gmail.com</a> (<a href="https://orcid.org/0009-0005-8324-2834">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/Kss2k/modsem">https://github.com/Kss2k/modsem</a>
</p>
</li></ul>


<hr>
<h2 id='compare_fit'>compare model fit for qml and lms models</h2><span id='topic+compare_fit'></span>

<h3>Description</h3>

<p>Compare the fit of two models using the likelihood ratio test.
'estH0' representing the null 
hypothesis model, and 'estH1' the alternative hypothesis model. Importantly, 
the function assumes that 'estH0' does not have more free parameters 
(i.e., degrees of freedom) than 'estH1'.
alternative hypothesis model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_fit(estH0, estH1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_fit_+3A_esth0">estH0</code></td>
<td>
<p>object of class 'modsem_lms' or 'modsem_qml' representing the
null hypothesis model</p>
</td></tr>
<tr><td><code id="compare_fit_+3A_esth1">estH1</code></td>
<td>
<p>object of class 'modsem_lms' or 'modsem_qml' representing the</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
H0 &lt;- "
 # Outer Model
 X =~ x1 + x2 + x3
 Y =~ y1 + y2 + y3
 Z =~ z1 + z2 + z3

 # Inner model
 Y ~ X + Z
"

estH0 &lt;- modsem(m1, oneInt, "lms")

H1 &lt;- "
 # Outer Model
 X =~ x1 + x2 + x3
 Y =~ y1 + y2 + y3
 Z =~ z1 + z2 + z3

 # Inner model
 Y ~ X + Z + X:Z
"

estH1 &lt;- modsem(m1, oneInt, "lms")
compare_fit(estH0, estH1)

## End(Not run)
</code></pre>

<hr>
<h2 id='default_settings_da'>default arguments fro LMS and QML approach</h2><span id='topic+default_settings_da'></span>

<h3>Description</h3>

<p>This function returns the default settings for the LMS and QML approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_settings_da(method = c("lms", "qml"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="default_settings_da_+3A_method">method</code></td>
<td>
<p>which method to get the settings for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>modsem_lms or modsem_qml object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(modsem)
default_settings_da()
</code></pre>

<hr>
<h2 id='default_settings_pi'>default arguments for product indicator approaches</h2><span id='topic+default_settings_pi'></span>

<h3>Description</h3>

<p>This function returns the default settings for the product indicator approaches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_settings_pi(method = c("rca", "uca", "pind", "dblcent", "ca"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="default_settings_pi_+3A_method">method</code></td>
<td>
<p>which method to get the settings for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>modsem_lms or modsem_qml object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(modsem)
default_settings_pi()
</code></pre>

<hr>
<h2 id='extract_lavaan'>extract lavaan object from modsem object estimated using product indicators</h2><span id='topic+extract_lavaan'></span>

<h3>Description</h3>

<p>extract lavaan object from modsem object estimated using product indicators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_lavaan(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_lavaan_+3A_object">object</code></td>
<td>
<p>modsem object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>lavaan object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(modsem)
m1 &lt;- '
  # Outer Model
  X =~ x1 + x2 + x3
  Y =~ y1 + y2 + y3
  Z =~ z1 + z2 + z3
  
  # Inner model
  Y ~ X + Z + X:Z 
'
est &lt;- modsem_pi(m1, oneInt)
lav_est &lt;- extract_lavaan(est) 
</code></pre>

<hr>
<h2 id='fit_modsem_da'>Fit measures for QML and LMS models</h2><span id='topic+fit_modsem_da'></span>

<h3>Description</h3>

<p>Calculates chi-sq test and p-value, as well as RMSEA for 
the LMS and QML models. Note that the Chi-Square based fit measures should be calculated
for the baseline model, i.e., the model without the interaction effect
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_modsem_da(model, chisq = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_modsem_da_+3A_model">model</code></td>
<td>
<p>fitted model. Thereafter, you can use 'compare_fit()' 
to assess the comparative fit of the models. If the interaction effect makes 
the model better, and e.g., the RMSEA is good for the baseline model, 
the interaction model likely has a good RMSEA as well.</p>
</td></tr>
<tr><td><code id="fit_modsem_da_+3A_chisq">chisq</code></td>
<td>
<p>should Chi-Square based fit-measures be calculated?</p>
</td></tr>
</table>

<hr>
<h2 id='get_pi_data'>Get data with product indicators for different approaches</h2><span id='topic+get_pi_data'></span>

<h3>Description</h3>

<p>get_pi_syntax is a function for creating the lavaan syntax used for estimating 
latent interaction models using one of the product indiactors in lavaan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pi_data(model.syntax, data, method = "dblcent", match = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pi_data_+3A_model.syntax">model.syntax</code></td>
<td>
<p>lavaan syntax</p>
</td></tr>
<tr><td><code id="get_pi_data_+3A_data">data</code></td>
<td>
<p>data to create product indicators from</p>
</td></tr>
<tr><td><code id="get_pi_data_+3A_method">method</code></td>
<td>
<p>method to use:
&quot;rca&quot; = residual centering approach,
&quot;uca&quot; = unconstrained approach,
&quot;dblcent&quot; = double centering approach,
&quot;pind&quot; = prod ind approach, with no constraints or centering,
&quot;custom&quot; = use parameters specified in the function call</p>
</td></tr>
<tr><td><code id="get_pi_data_+3A_match">match</code></td>
<td>
<p>should product indicators be made using the match strategy</p>
</td></tr>
<tr><td><code id="get_pi_data_+3A_...">...</code></td>
<td>
<p>arguments passed to other functions (e.g., modsem_pi)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(modsem)
library(lavaan)
m1 &lt;- '
  # Outer Model
  X =~ x1 + x2 +x3
  Y =~ y1 + y2 + y3
  Z =~ z1 + z2 + z3
  
  # Inner model
  Y ~ X + Z + X:Z 
'
syntax &lt;- get_pi_syntax(m1)
data &lt;- get_pi_data(m1, oneInt)
est &lt;- sem(syntax, data)
</code></pre>

<hr>
<h2 id='get_pi_syntax'>Get lavaan syntax for product indicator approaches</h2><span id='topic+get_pi_syntax'></span>

<h3>Description</h3>

<p>get_pi_syntax is a function for creating the lavaan syntax used for estimating 
latent interaction models using one of the product indiactors in lavaan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pi_syntax(model.syntax, method = "dblcent", match = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pi_syntax_+3A_model.syntax">model.syntax</code></td>
<td>
<p>lavaan syntax</p>
</td></tr>
<tr><td><code id="get_pi_syntax_+3A_method">method</code></td>
<td>
<p>method to use:
&quot;rca&quot; = residual centering approach,
&quot;uca&quot; = unconstrained approach,
&quot;dblcent&quot; = double centering approach,
&quot;pind&quot; = prod ind approach, with no constraints or centering,
&quot;custom&quot; = use parameters specified in the function call</p>
</td></tr>
<tr><td><code id="get_pi_syntax_+3A_match">match</code></td>
<td>
<p>should product indicators be made using the match strategy</p>
</td></tr>
<tr><td><code id="get_pi_syntax_+3A_...">...</code></td>
<td>
<p>arguments passed to other functions (e.g., modsem_pi)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(modsem)
library(lavaan)
m1 &lt;- '
  # Outer Model
  X =~ x1 + x2 +x3
  Y =~ y1 + y2 + y3
  Z =~ z1 + z2 + z3
  
  # Inner model
  Y ~ X + Z + X:Z 
'
syntax &lt;- get_pi_syntax(m1)
data &lt;- get_pi_data(m1, oneInt)
est &lt;- sem(syntax, data)
</code></pre>

<hr>
<h2 id='jordan'>Jordan subset of PISA 2006 data</h2><span id='topic+jordan'></span>

<h3>Description</h3>

<p>The data stem from the large-scale assessment study PISA 2006 
(Organisation for Economic Co-Operation and Development, 2009) where 
competencies of 15-year-old students in reading, mathematics, and science 
are assessed using nationally representative samples in 3-year cycles. 
In this eacademicample, data from the student background questionnaire from the 
Jordan sample of PISA 2006 were used. Only data of students with complete
responses to all 15 items (N = 6,038) were considered.
</p>


<h3>Format</h3>

<p>A data frame of fifteen variables and 6,038 observations:
</p>
<p>enjoy1
indicator for enjoyment of science, item ST16Q01: I generally have fun when I am learning &lt;broad science&gt; topics.
</p>
<p>enjoy2
indicator for enjoyment of science, item ST16Q02: I like reading about &lt;broad science&gt;.
</p>
<p>enjoy3
indicator for enjoyment of science, item ST16Q03: I am happy doing &lt;broad science&gt; problems.
</p>
<p>enjoy4
indicator for enjoyment of science, item ST16Q04: I enjoy acquiring new knowledge in &lt;broad science&gt;.
</p>
<p>enjoy5
indicator for enjoyment of science, item ST16Q05: I am interested in learning about &lt;broad science&gt;.
</p>
<p>academic1
indicator for academic self-concept in science, item ST37Q01: I can easily understand new ideas in &lt;school science&gt;.
</p>
<p>academic2
indicator for academic self-concept in science, item ST37Q02: Learning advanced &lt;school science&gt; topics would be easy for me.
</p>
<p>academic3
indicator for academic self-concept in science, item ST37Q03: I can usually give good answers to &lt;test questions&gt; on &lt;school science&gt; topics.
</p>
<p>academic4
indicator for academic self-concept in science, item ST37Q04: I learn &lt;school science&gt; topics quickly.
</p>
<p>academic5
indicator for academic self-concept in science, item ST37Q05: &lt;School science&gt; topics are easy for me.
</p>
<p>academic6
indicator for academic self-concept in science, item ST37Q06: When I am being taught &lt;school science&gt;, I can understand the concepts very well.
</p>
<p>career1
indicator for career aspirations in science, item ST29Q01: I would like to work in a career involving &lt;broad science&gt;.
</p>
<p>career2
indicator for career aspirations in science, item ST29Q02: I would like to study &lt;broad science&gt; after &lt;secondary school&gt;.
</p>
<p>career3
indicator for career aspirations in science, item ST29Q03: I would like to spend my life doing advanced &lt;broad science&gt;.
</p>
<p>career4
indicator for career aspirations in science, item ST29Q04: I would like to work on &lt;broad science&gt; projects as an adult.
</p>


<h3>Source</h3>

<p>This version of the dataset, as well as the description was gathered from the 
documentation of the 'nlsem' package (https://cran.r-project.org/package=nlsem), 
where the only difference is that the names of the variables were changed
</p>
<p>Originally the dataset was gathered by the Organisation for Economic Co-Operation and Development (2009). 
Pisa 2006: Science competencies for tomorrow's world (Tech. Rep.). 
Paris, France. Obtained from: https://www.oecd.org/pisa/pisaproducts/database-pisa2006.htm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
m1 &lt;- '
  ENJ =~ enjoy1 + enjoy2 + enjoy3 + enjoy4 + enjoy5
  CAREER =~ career1 + career2 + career3 + career4
  SC =~ academic1 + academic2 + academic3 + academic4 + academic5 + academic6
  CAREER ~ ENJ + SC + ENJ:ENJ + SC:SC + ENJ:SC
'

est &lt;- modsem(m1, data = jordan)

## End(Not run)
</code></pre>

<hr>
<h2 id='modsem'>Interaction between latent variables</h2><span id='topic+modsem'></span>

<h3>Description</h3>

<p>modsem is a function for estimating interaction effects between latent variables, 
in structural equation models (SEM's).
Methods for estimating interaction effects in SEM's can basically be split into 
two frameworks: 1. Product Indicator based approaches (&quot;dblcent&quot;, &quot;rca&quot;, &quot;uca&quot;, 
&quot;ca&quot;, &quot;pind&quot;), and 2. Distributionally based approaches (&quot;lms&quot;, &quot;qml&quot;).
For the product indicator based approaces, modsem() is essentially a just 
a fancy wrapper for lavaan::sem()  which generates the 
necessary syntax, and variables for the estimation of models with latent product indicators.
The distributionally based approaches are implemented in seperately, and are 
are not estimated using lavaan::sem(), but rather using custom functions (largely)
written in C++ for performance reasons. For greater control, it is advised that 
you use one of the sub-functions (modsem_pi, modsem_da, modsem_mplus) directly, 
as passing additional arguments to them via modsem() can lead to unexpected behavior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modsem(model.syntax = NULL, data = NULL, method = "dblcent", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modsem_+3A_model.syntax">model.syntax</code></td>
<td>
<p>lavaan syntax</p>
</td></tr>
<tr><td><code id="modsem_+3A_data">data</code></td>
<td>
<p>dataframe</p>
</td></tr>
<tr><td><code id="modsem_+3A_method">method</code></td>
<td>
<p>method to use:
&quot;rca&quot; = residual centering approach (passed to lavaan),
&quot;uca&quot; = unconstrained approach (passed to lavaan),
&quot;dblcent&quot; = double centering approach (passed to lavaan),
&quot;pind&quot; = prod ind approach, with no constraints or centering (passed to lavaan),
&quot;lms&quot; = laten model structural equations (not passed to lavaan).
&quot;qml&quot; = quasi maximum likelihood estimation of laten model structural equations (not passed to lavaan).
&quot;custom&quot; = use parameters specified in the function call (passed to lavaan)</p>
</td></tr>
<tr><td><code id="modsem_+3A_...">...</code></td>
<td>
<p>arguments passed to other functions depending on method (see modsem_pi, modsem_da, and modsem_mplus)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>modsem object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(modsem)
# For more examples check README and/or GitHub.
# One interaction
m1 &lt;- '
  # Outer Model
  X =~ x1 + x2 +x3
  Y =~ y1 + y2 + y3
  Z =~ z1 + z2 + z3
  
  # Inner model
  Y ~ X + Z + X:Z 
'

# Double centering approach
est1 &lt;- modsem(m1, oneInt)
summary(est1)

## Not run: 
# The Constrained Approach 
est1_ca &lt;- modsem(m1, oneInt, method = "ca")
summary(est1_ca)

# LMS approach
est1_lms &lt;- modsem(m1, oneInt, method = "lms")
summary(est1_lms)

# QML approach
est1_qml &lt;- modsem(m1, oneInt, method = "qml")
summary(est1_qml)


## End(Not run)

# Theory Of Planned Behavior
tpb &lt;- ' 
# Outer Model (Based on Hagger et al., 2007)
  ATT =~ att1 + att2 + att3 + att4 + att5
  SN =~ sn1 + sn2
  PBC =~ pbc1 + pbc2 + pbc3
  INT =~ int1 + int2 + int3
  BEH =~ b1 + b2

# Inner Model (Based on Steinmetz et al., 2011)
  INT ~ ATT + SN + PBC
  BEH ~ INT + PBC 
  BEH ~ INT:PBC  
'

# double centering approach
est_tpb &lt;- modsem(tpb, data = TPB)
summary(est_tpb)

## Not run: 
# The Constrained Approach 
est_tpb_ca &lt;- modsem(tpb, data = TPB, method = "ca")
summary(est_tpb_ca)

# LMS approach
est_tpb_lms &lt;- modsem(tpb, data = TPB, method = "lms")
summary(est_tpb_lms)

# QML approach
est_tpb_qml &lt;- modsem(tpb, data = TPB, method = "qml")
summary(est_tpb_qml)

## End(Not run)
</code></pre>

<hr>
<h2 id='modsem_da'>Interaction between latent variables using lms and qml approaches</h2><span id='topic+modsem_da'></span>

<h3>Description</h3>

<p>modsem_da is a function for estimating interaction effects between latent variables,
in structural equation models (SEMs), using distributional analytic (DA) approaches.
Methods for estimating interaction effects in SEM's can basically be split into
two frameworks: 1. Product Indicator based approaches (&quot;dblcent&quot;, &quot;rca&quot;, &quot;uca&quot;,
&quot;ca&quot;, &quot;pind&quot;), and 2. Distributionally based approaches (&quot;lms&quot;, &quot;qml&quot;).
modsem_da() handles the latter, and can estimate models using both qml and lms
necessary syntax, and variables for the estimation of models with latent product indicators.
NOTE: run 'default_settings_da()' to see default arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modsem_da(
  model.syntax = NULL,
  data = NULL,
  method = "lms",
  verbose = NULL,
  optimize = NULL,
  nodes = NULL,
  convergence = NULL,
  optimizer = NULL,
  center.data = NULL,
  standardize.data = NULL,
  standardize.out = NULL,
  standardize = NULL,
  mean.observed = NULL,
  cov.syntax = NULL,
  double = NULL,
  calc.se = NULL,
  FIM = NULL,
  EFIM.S = NULL,
  OFIM.hessian = NULL,
  EFIM.parametric = NULL,
  robust.se = NULL,
  max.iter = NULL,
  max.step = NULL,
  fix.estep = NULL,
  start = NULL,
  epsilon = NULL,
  quad.range = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modsem_da_+3A_model.syntax">model.syntax</code></td>
<td>
<p>lavaan syntax</p>
</td></tr>
<tr><td><code id="modsem_da_+3A_data">data</code></td>
<td>
<p>dataframe</p>
</td></tr>
<tr><td><code id="modsem_da_+3A_method">method</code></td>
<td>
<p>method to use:
&quot;lms&quot; = laten model structural equations (not passed to lavaan).
&quot;qml&quot; = quasi maximum likelihood estimation of laten model structural equations (not passed to lavaan).</p>
</td></tr>
<tr><td><code id="modsem_da_+3A_verbose">verbose</code></td>
<td>
<p>should estimation progress be shown</p>
</td></tr>
<tr><td><code id="modsem_da_+3A_optimize">optimize</code></td>
<td>
<p>should starting parameters be optimized</p>
</td></tr>
<tr><td><code id="modsem_da_+3A_nodes">nodes</code></td>
<td>
<p>number of quadrature nodes (points of integration) used in lms,
increased number gives better estimates but slower computation. How many is needed, depends on the complexity of the model
For simple models you somwhere between 16-24 should be enough, for more complex higher numbers may be needed. 
For models where there is an interaction effects between and endogenous and exogenous variable 
the number of nodes should at least be 32, but practically (e.g., ordinal/skewed data) more than 32 is recommended. In cases, 
where data is non-normal it might be better to use the qml approach instead. For large
numbers of nodes, you might want to change the 'quad.range' argument.</p>
</td></tr>
<tr><td><code id="modsem_da_+3A_convergence">convergence</code></td>
<td>
<p>convergence criterion. Lower values give better estimates but slower computation.</p>
</td></tr>
<tr><td><code id="modsem_da_+3A_optimizer">optimizer</code></td>
<td>
<p>optimizer to use, can be either &quot;nlminb&quot; or &quot;L-BFGS-B&quot;. For LMS, &quot;nlminb&quot; is recommended. 
For QML, &quot;L-BFGS-B&quot; may be faster if there is a large number of iterations, but slower if there are few iterations.</p>
</td></tr>
<tr><td><code id="modsem_da_+3A_center.data">center.data</code></td>
<td>
<p>should data be centered before fitting model</p>
</td></tr>
<tr><td><code id="modsem_da_+3A_standardize.data">standardize.data</code></td>
<td>
<p>should data be scaled before fitting model, will be overridden by
standardize if standardize is set to TRUE.
NOTE: It is recommended that you estimate the model normally and then standardize the output using
'standardized_estimates()'.</p>
</td></tr>
<tr><td><code id="modsem_da_+3A_standardize.out">standardize.out</code></td>
<td>
<p>should output be standardized (note will alter the relationsships of
parameter constraints, since to parameters are scaled unevenly, even if they
have the same label). This does not alter the estimation of the model, only the
output.
NOTE: It is recommended that you estimate the model normally and then standardize the output using
'standardized_estimates()'.</p>
</td></tr>
<tr><td><code id="modsem_da_+3A_standardize">standardize</code></td>
<td>
<p>will standardize the data before fitting the model, remove the mean
structure of the observed variables, and standardize the output. Note that standardize.data
mean.observed, standardize.out will be overridden by standardize if standardize is set to TRUE.
NOTE: It is recommended that you estimate the model normally and then standardize the output using
'standardized_estimates()'.</p>
</td></tr>
<tr><td><code id="modsem_da_+3A_mean.observed">mean.observed</code></td>
<td>
<p>should mean structure of the observed variables be estimated,
will be overridden by standardize if standardize is set to TRUE.
NOTE: Not recommended unless you know what you are doing.</p>
</td></tr>
<tr><td><code id="modsem_da_+3A_cov.syntax">cov.syntax</code></td>
<td>
<p>model syntax for implied covariance matrix (see 'vignette(&quot;interaction_two_etas&quot;, &quot;modsem&quot;)')</p>
</td></tr>
<tr><td><code id="modsem_da_+3A_double">double</code></td>
<td>
<p>try to double the number of dimensions of integrations used in LMS,
this will be extremely slow, but should be more similar to mplus.</p>
</td></tr>
<tr><td><code id="modsem_da_+3A_calc.se">calc.se</code></td>
<td>
<p>should standard errros be computed, NOTE: If 'FALSE' information matrix will not be computed either</p>
</td></tr>
<tr><td><code id="modsem_da_+3A_fim">FIM</code></td>
<td>
<p>should fisher information matrix be calculated using observed of expected. must be either &quot;observed&quot; or &quot;expected&quot;</p>
</td></tr>
<tr><td><code id="modsem_da_+3A_efim.s">EFIM.S</code></td>
<td>
<p>if expected fisher information matrix is computed, EFIM.S selects the sample size of the generated data</p>
</td></tr>
<tr><td><code id="modsem_da_+3A_ofim.hessian">OFIM.hessian</code></td>
<td>
<p>should observed fisher information be computed using hessian? if FALSE, it is computed using gradient</p>
</td></tr>
<tr><td><code id="modsem_da_+3A_efim.parametric">EFIM.parametric</code></td>
<td>
<p>should data for calculating expected fisher information matrix be 
simulated parametrically (simulated based on the assumptions- and implied parameters
from the model), or non-parametrically (stochastically sampled). If you believe that 
normality assumptions are violated, 'EFIM.parametric = FALSE' might be the better option.</p>
</td></tr>
<tr><td><code id="modsem_da_+3A_robust.se">robust.se</code></td>
<td>
<p>should robust standard errors be computed? Meant to be used for QML, 
can be unreliable with the LMS-approach.</p>
</td></tr>
<tr><td><code id="modsem_da_+3A_max.iter">max.iter</code></td>
<td>
<p>max numebr of iterations</p>
</td></tr>
<tr><td><code id="modsem_da_+3A_max.step">max.step</code></td>
<td>
<p>max steps for the M-step in the EM algorithm (LMS)</p>
</td></tr>
<tr><td><code id="modsem_da_+3A_fix.estep">fix.estep</code></td>
<td>
<p>if TRUE, E-step will be fixed and the prior probabilities are set to the best prior probabilities, 
if loglikelihood is decreasing for more than 30 iterations.</p>
</td></tr>
<tr><td><code id="modsem_da_+3A_start">start</code></td>
<td>
<p>starting parameters</p>
</td></tr>
<tr><td><code id="modsem_da_+3A_epsilon">epsilon</code></td>
<td>
<p>finite difference for numerical derivatives</p>
</td></tr>
<tr><td><code id="modsem_da_+3A_quad.range">quad.range</code></td>
<td>
<p>range in z-scores to perform numerical integration in LMS using 
Gaussian-Hermite Quadratures. By default Inf, such that f(t) is integrated from -Inf to Inf, 
but this will likely be inefficient and pointless at large number of nodes. Nodes outside 
+/- quad.range will be ignored.</p>
</td></tr>
<tr><td><code id="modsem_da_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the estimation function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>modsem_lms or modsem_qml object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(modsem)
# For more examples check README and/or GitHub.
# One interaction
m1 &lt;- "
  # Outer Model
  X =~ x1 + x2 +x3
  Y =~ y1 + y2 + y3
  Z =~ z1 + z2 + z3

  # Inner model
  Y ~ X + Z + X:Z
"

## Not run: 
# QML Approach
est1 &lt;- modsem_da(m1, oneInt, method = "qml")
summary(est1)


# Theory Of Planned Behavior
tpb &lt;- "
# Outer Model (Based on Hagger et al., 2007)
  ATT =~ att1 + att2 + att3 + att4 + att5
  SN =~ sn1 + sn2
  PBC =~ pbc1 + pbc2 + pbc3
  INT =~ int1 + int2 + int3
  BEH =~ b1 + b2

# Inner Model (Based on Steinmetz et al., 2011)
  # Covariances
  ATT ~~ SN + PBC
  PBC ~~ SN
  # Causal Relationsships
  INT ~ ATT + SN + PBC
  BEH ~ INT + PBC
  BEH ~ INT:PBC
"

# lms approach
estTpb &lt;- modsem_da(tpb, data = TPB, method = lms)
summary(estTpb)

## End(Not run)

</code></pre>

<hr>
<h2 id='modsem_inspect'>Inspect model information</h2><span id='topic+modsem_inspect'></span>

<h3>Description</h3>

<p>function used to inspect fittet object. similar to 'lavInspect()'
argument 'what' decides what to inspect
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modsem_inspect(object, what = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modsem_inspect_+3A_object">object</code></td>
<td>
<p>fittet model to inspect</p>
</td></tr>
<tr><td><code id="modsem_inspect_+3A_what">what</code></td>
<td>
<p>what to inspect</p>
</td></tr>
<tr><td><code id="modsem_inspect_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>for 'modsem_lms', 'modsem_qml' and 'modsem_lavaan' 
for 'modsem_lavaan', it is just a wrapper for 'lavInspect()'
for 'modsem_lms' and 'modsem_qml' what can either be &quot;all&quot;, &quot;matrices&quot;, &quot;optim&quot;, 
or just the name of what to extract.
</p>

<hr>
<h2 id='modsem_mplus'>Estimation latent interactions through mplus</h2><span id='topic+modsem_mplus'></span>

<h3>Description</h3>

<p>Estimation latent interactions through mplus
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modsem_mplus(
  model.syntax,
  data,
  estimator = "ml",
  type = "random",
  algorithm = "integration",
  process = "8",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modsem_mplus_+3A_model.syntax">model.syntax</code></td>
<td>
<p>lavaan/modsem syntax</p>
</td></tr>
<tr><td><code id="modsem_mplus_+3A_data">data</code></td>
<td>
<p>dataset</p>
</td></tr>
<tr><td><code id="modsem_mplus_+3A_estimator">estimator</code></td>
<td>
<p>estimator argument passed to mplus</p>
</td></tr>
<tr><td><code id="modsem_mplus_+3A_type">type</code></td>
<td>
<p>type argument passed to mplus</p>
</td></tr>
<tr><td><code id="modsem_mplus_+3A_algorithm">algorithm</code></td>
<td>
<p>algorithm argument passed to mplus</p>
</td></tr>
<tr><td><code id="modsem_mplus_+3A_process">process</code></td>
<td>
<p>process argument passed to mplus</p>
</td></tr>
<tr><td><code id="modsem_mplus_+3A_...">...</code></td>
<td>
<p>arguments passed to other functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>modsem_mplus object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Theory Of Planned Behavior
tpb &lt;- ' 
# Outer Model (Based on Hagger et al., 2007)
  ATT =~ att1 + att2 + att3 + att4 + att5
  SN =~ sn1 + sn2
  PBC =~ pbc1 + pbc2 + pbc3
  INT =~ int1 + int2 + int3
  BEH =~ b1 + b2

# Inner Model (Based on Steinmetz et al., 2011)
  # Covariances
  ATT ~~ SN + PBC
  PBC ~~ SN 
  # Causal Relationsships
  INT ~ ATT + SN + PBC
  BEH ~ INT + PBC 
  BEH ~ INT:PBC  
'

## Not run: 
estTpbMplus &lt;- modsem_mplus(tpb, data = TPB)
summary(estTpbLMS)

## End(Not run)

</code></pre>

<hr>
<h2 id='modsem_pi'>Interaction between latent variables using product indicators</h2><span id='topic+modsem_pi'></span>

<h3>Description</h3>

<p>modsem_pi is a function for estimating interaction effects between latent variables, 
in structural equation models (SEMs), using product indicators.
Methods for estimating interaction effects in SEM's can basically be split into 
two frameworks: 1. Product Indicator based approaches (&quot;dblcent&quot;, &quot;rca&quot;, &quot;uca&quot;, 
&quot;ca&quot;, &quot;pind&quot;), and 2. Distributionally based approaches (&quot;lms&quot;, &quot;qml&quot;).
modsem_pi() is essentially a just 
a fancy wrapper for lavaan::sem()  which generates the 
necessary syntax, and variables for the estimation of models with latent product indicators.
use 'default_settings_pi()' to get the default settings for the different methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modsem_pi(
  model.syntax = NULL,
  data = NULL,
  method = "dblcent",
  match = NULL,
  standardize.data = FALSE,
  center.data = FALSE,
  first.loading.fixed = TRUE,
  center.before = NULL,
  center.after = NULL,
  residuals.prods = NULL,
  residual.cov.syntax = NULL,
  constrained.prod.mean = NULL,
  constrained.loadings = NULL,
  constrained.var = NULL,
  constrained.res.cov.method = NULL,
  auto.scale = "none",
  auto.center = "none",
  estimator = "ML",
  group = NULL,
  run = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modsem_pi_+3A_model.syntax">model.syntax</code></td>
<td>
<p>lavaan syntax</p>
</td></tr>
<tr><td><code id="modsem_pi_+3A_data">data</code></td>
<td>
<p>dataframe</p>
</td></tr>
<tr><td><code id="modsem_pi_+3A_method">method</code></td>
<td>
<p>method to use:
&quot;rca&quot; = residual centering approach (passed to lavaan),
&quot;uca&quot; = unconstrained approach (passed to lavaan),
&quot;dblcent&quot; = double centering approach (passed to lavaan),
&quot;pind&quot; = prod ind approach, with no constraints or centering (passed to lavaan),
&quot;custom&quot; = use parameters specified in the function call (passed to lavaan)</p>
</td></tr>
<tr><td><code id="modsem_pi_+3A_match">match</code></td>
<td>
<p>should the product indicators be created by using the match-strategy</p>
</td></tr>
<tr><td><code id="modsem_pi_+3A_standardize.data">standardize.data</code></td>
<td>
<p>should data be scaled before fitting model</p>
</td></tr>
<tr><td><code id="modsem_pi_+3A_center.data">center.data</code></td>
<td>
<p>should data be centered before fitting model</p>
</td></tr>
<tr><td><code id="modsem_pi_+3A_first.loading.fixed">first.loading.fixed</code></td>
<td>
<p>Sould the first factorloading in the latent prod be fixed to one?</p>
</td></tr>
<tr><td><code id="modsem_pi_+3A_center.before">center.before</code></td>
<td>
<p>should inds in prods be centered before computing prods (overwritten by method, if method != NULL)</p>
</td></tr>
<tr><td><code id="modsem_pi_+3A_center.after">center.after</code></td>
<td>
<p>should ind prods be centered after they have been computed?</p>
</td></tr>
<tr><td><code id="modsem_pi_+3A_residuals.prods">residuals.prods</code></td>
<td>
<p>should ind prods be centered using residuals (overwritten by method, if method != NULL)</p>
</td></tr>
<tr><td><code id="modsem_pi_+3A_residual.cov.syntax">residual.cov.syntax</code></td>
<td>
<p>should syntax for residual covariances be produced (overwritten by method, if method != NULL)</p>
</td></tr>
<tr><td><code id="modsem_pi_+3A_constrained.prod.mean">constrained.prod.mean</code></td>
<td>
<p>should syntax prod mean be produced (overwritten by method, if method != NULL)</p>
</td></tr>
<tr><td><code id="modsem_pi_+3A_constrained.loadings">constrained.loadings</code></td>
<td>
<p>should syntax for constrained loadings be produced (overwritten by method, if method != NULL)</p>
</td></tr>
<tr><td><code id="modsem_pi_+3A_constrained.var">constrained.var</code></td>
<td>
<p>should syntax for constrained variances be produced (overwritten by method, if method != NULL)</p>
</td></tr>
<tr><td><code id="modsem_pi_+3A_constrained.res.cov.method">constrained.res.cov.method</code></td>
<td>
<p>method for constraining residual covariances</p>
</td></tr>
<tr><td><code id="modsem_pi_+3A_auto.scale">auto.scale</code></td>
<td>
<p>methods which should be scaled automatically (usually not useful)</p>
</td></tr>
<tr><td><code id="modsem_pi_+3A_auto.center">auto.center</code></td>
<td>
<p>methods which should be centered automatically (usually not useful)</p>
</td></tr>
<tr><td><code id="modsem_pi_+3A_estimator">estimator</code></td>
<td>
<p>estimator to use in lavaan</p>
</td></tr>
<tr><td><code id="modsem_pi_+3A_group">group</code></td>
<td>
<p>group variable for multigroup analysis</p>
</td></tr>
<tr><td><code id="modsem_pi_+3A_run">run</code></td>
<td>
<p>should the model be run via lavaan, if FALSE only modified syntax and data is returned</p>
</td></tr>
<tr><td><code id="modsem_pi_+3A_...">...</code></td>
<td>
<p>arguments passed to other functions, e.g,. lavaan</p>
</td></tr>
</table>


<h3>Value</h3>

<p>modsem object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(modsem)
# For more examples check README and/or GitHub.
# One interaction
m1 &lt;- '
  # Outer Model
  X =~ x1 + x2 +x3
  Y =~ y1 + y2 + y3
  Z =~ z1 + z2 + z3
  
  # Inner model
  Y ~ X + Z + X:Z 
'

# Double centering approach
est1 &lt;- modsem_pi(m1, oneInt)
summary(est1)

## Not run: 
# The Constrained Approach 
est1Constrained &lt;- modsem_pi(m1, oneInt, method = "ca")
summary(est1Constrained)

## End(Not run)

# Theory Of Planned Behavior
tpb &lt;- ' 
# Outer Model (Based on Hagger et al., 2007)
  ATT =~ att1 + att2 + att3 + att4 + att5
  SN =~ sn1 + sn2
  PBC =~ pbc1 + pbc2 + pbc3
  INT =~ int1 + int2 + int3
  BEH =~ b1 + b2

# Inner Model (Based on Steinmetz et al., 2011)
  # Covariances
  ATT ~~ SN + PBC
  PBC ~~ SN 
  # Causal Relationsships
  INT ~ ATT + SN + PBC
  BEH ~ INT + PBC 
  BEH ~ INT:PBC  
'

# double centering approach
estTpb &lt;- modsem_pi(tpb, data = TPB)
summary(estTpb)

## Not run: 
# The Constrained Approach 
estTpbConstrained &lt;- modsem_pi(tpb, data = TPB, method = "ca")
summary(estTpbConstrained)

## End(Not run)
</code></pre>

<hr>
<h2 id='modsemify'>Generate parameter table for lavaan syntax</h2><span id='topic+modsemify'></span>

<h3>Description</h3>

<p>Generate parameter table for lavaan syntax
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modsemify(syntax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modsemify_+3A_syntax">syntax</code></td>
<td>
<p>model syntax</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with columns lhs, op, rhs, mod
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(modsem)
m1 &lt;- '
  # Outer Model
  X =~ x1 + x2 +x3
  Y =~ y1 + y2 + y3
  Z =~ z1 + z2 + z3

  # Inner model
  Y ~ X + Z + X:Z
'
modsemify(m1)
</code></pre>

<hr>
<h2 id='multiplyIndicatorsCpp'>Multiply indicators</h2><span id='topic+multiplyIndicatorsCpp'></span>

<h3>Description</h3>

<p>Multiply indicators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiplyIndicatorsCpp(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiplyIndicatorsCpp_+3A_df">df</code></td>
<td>
<p>A data DataFrame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A NumericVector
</p>

<hr>
<h2 id='oneInt'>oneInt</h2><span id='topic+oneInt'></span>

<h3>Description</h3>

<p>A simulated dataset with one interaction effect
</p>

<hr>
<h2 id='parameter_estimates'>Extract parameterEstimates from an estimated model</h2><span id='topic+parameter_estimates'></span>

<h3>Description</h3>

<p>Extract parameterEstimates from an estimated model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parameter_estimates(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parameter_estimates_+3A_object">object</code></td>
<td>
<p>An object of class 'modsem_pi', 'modsem_da', or 'modsem_mplus'</p>
</td></tr>
<tr><td><code id="parameter_estimates_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to other functions</p>
</td></tr>
</table>

<hr>
<h2 id='plot_interaction'>Plot Interaction Effects</h2><span id='topic+plot_interaction'></span>

<h3>Description</h3>

<p>Plot Interaction Effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_interaction(
  x,
  z,
  y,
  xz = NULL,
  vals_x = seq(-3, 3, 0.001),
  vals_z,
  model,
  alpha_se = 0.15,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_interaction_+3A_x">x</code></td>
<td>
<p>The name of the variable on the x-axis</p>
</td></tr>
<tr><td><code id="plot_interaction_+3A_z">z</code></td>
<td>
<p>The name of the moderator variable</p>
</td></tr>
<tr><td><code id="plot_interaction_+3A_y">y</code></td>
<td>
<p>The name of the outcome variable</p>
</td></tr>
<tr><td><code id="plot_interaction_+3A_xz">xz</code></td>
<td>
<p>The name of the interaction term. If the interaction term is not specified, it
it will be created using 'x' and 'z'.</p>
</td></tr>
<tr><td><code id="plot_interaction_+3A_vals_x">vals_x</code></td>
<td>
<p>The values of the x variable to plot, the more values the smoother the std.error-area will be</p>
</td></tr>
<tr><td><code id="plot_interaction_+3A_vals_z">vals_z</code></td>
<td>
<p>The values of the moderator variable to plot. A seperate regression 
line (&quot;y ~ x | z&quot;) will be plotted for each value of the moderator variable</p>
</td></tr>
<tr><td><code id="plot_interaction_+3A_model">model</code></td>
<td>
<p>An object of class 'modsem_pi', 'modsem_da', or 'modsem_mplus'</p>
</td></tr>
<tr><td><code id="plot_interaction_+3A_alpha_se">alpha_se</code></td>
<td>
<p>The alpha level for the std.error area</p>
</td></tr>
<tr><td><code id="plot_interaction_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to other functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(modsem)
## Not run: 
m1 &lt;- "
# Outer Model
  X =~ x1
  X =~ x2 + x3
  Z =~ z1 + z2 + z3
  Y =~ y1 + y2 + y3

# Inner model
  Y ~ X + Z + X:Z
"
est1 &lt;- modsem(m1, data = oneInt)
plot_interaction("X", "Z", "Y", "X:Z", -3:3, c(-0.2, 0), est1)

tpb &lt;- "
# Outer Model (Based on Hagger et al., 2007)
  ATT =~ att1 + att2 + att3 + att4 + att5
  SN =~ sn1 + sn2
  PBC =~ pbc1 + pbc2 + pbc3
  INT =~ int1 + int2 + int3
  BEH =~ b1 + b2

# Inner Model (Based on Steinmetz et al., 2011)
  # Causal Relationsships
  INT ~ ATT + SN + PBC
  BEH ~ INT + PBC
  # BEH ~ ATT:PBC
  BEH ~ PBC:INT
  # BEH ~ PBC:PBC
"

est2 &lt;- modsem(tpb, TPB, method = "lms")
plot_interaction(x = "INT", z = "PBC", y = "BEH", xz = "PBC:INT", 
                 vals_z = c(-0.5, 0.5), model = est2)

## End(Not run)
</code></pre>

<hr>
<h2 id='standardized_estimates'>Get standardized estimates</h2><span id='topic+standardized_estimates'></span>

<h3>Description</h3>

<p>Get standardized estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardized_estimates(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardized_estimates_+3A_object">object</code></td>
<td>
<p>An object of class 'modsem_da',  'modsem_mplus', 
or a parTable of class 'data.frame'</p>
</td></tr>
<tr><td><code id="standardized_estimates_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>for 'modsem_lms', 'modsem_qml' and 'modsem_mplus' objects, 
the interaction term is not standardized such that var(xz) = 1. 
The interaction term is not an actual variable in the model, meaning that it does not 
have a variance. It must therefore be calculated from the other parameters in the model.
Assuming normality and zero-means the variance is calculated as 
'var(xz) = var(x) * var(z) + cov(x, z)^2'. Thus setting the variance of the interaction 
term to 1, would only be 'correct' if the correlation between x and z is zero.
This means that the standardized estimates for the interaction term will 
be different from those using lavaan, since there the interaction term is an 
actual latent variable in the model, with a standardized variance of 1.
</p>

<hr>
<h2 id='summary.modsem_lms'>summary for modsem objects</h2><span id='topic+summary.modsem_lms'></span><span id='topic+summary.modsem_qml'></span><span id='topic+summary.modsem_mplus'></span><span id='topic+summary.modsem_pi'></span>

<h3>Description</h3>

<p>summary for modsem objects
</p>
<p>summary for modsem objects
</p>
<p>summary for modsem objects
</p>
<p>summary for modsem objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'modsem_lms'
summary(
  object,
  H0 = TRUE,
  verbose = TRUE,
  r.squared = TRUE,
  adjusted.stat = FALSE,
  digits = 3,
  scientific = FALSE,
  ci = FALSE,
  standardized = FALSE,
  loadings = TRUE,
  regressions = TRUE,
  covariances = TRUE,
  intercepts = TRUE,
  variances = TRUE,
  ...
)

## S3 method for class 'modsem_qml'
summary(
  object,
  H0 = TRUE,
  verbose = TRUE,
  r.squared = TRUE,
  adjusted.stat = FALSE,
  digits = 3,
  scientific = FALSE,
  ci = FALSE,
  standardized = FALSE,
  loadings = TRUE,
  regressions = TRUE,
  covariances = TRUE,
  intercepts = TRUE,
  variances = TRUE,
  ...
)

## S3 method for class 'modsem_mplus'
summary(
  object,
  scientific = FALSE,
  standardize = FALSE,
  ci = FALSE,
  digits = 3,
  loadings = TRUE,
  regressions = TRUE,
  covariances = TRUE,
  intercepts = TRUE,
  variances = TRUE,
  ...
)

## S3 method for class 'modsem_pi'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.modsem_lms_+3A_object">object</code></td>
<td>
<p>modsem object to summarized</p>
</td></tr>
<tr><td><code id="summary.modsem_lms_+3A_h0">H0</code></td>
<td>
<p>should a null model be estimated (used for comparison)</p>
</td></tr>
<tr><td><code id="summary.modsem_lms_+3A_verbose">verbose</code></td>
<td>
<p>print progress for the estimation of null model</p>
</td></tr>
<tr><td><code id="summary.modsem_lms_+3A_r.squared">r.squared</code></td>
<td>
<p>calculate R-squared</p>
</td></tr>
<tr><td><code id="summary.modsem_lms_+3A_adjusted.stat">adjusted.stat</code></td>
<td>
<p>should sample size corrected/adjustes AIC and BIC be reported?</p>
</td></tr>
<tr><td><code id="summary.modsem_lms_+3A_digits">digits</code></td>
<td>
<p>number of digits to print</p>
</td></tr>
<tr><td><code id="summary.modsem_lms_+3A_scientific">scientific</code></td>
<td>
<p>print p-values in scientific notation</p>
</td></tr>
<tr><td><code id="summary.modsem_lms_+3A_ci">ci</code></td>
<td>
<p>print confidence intervals</p>
</td></tr>
<tr><td><code id="summary.modsem_lms_+3A_standardized">standardized</code></td>
<td>
<p>print standardized estimates</p>
</td></tr>
<tr><td><code id="summary.modsem_lms_+3A_loadings">loadings</code></td>
<td>
<p>print loadings</p>
</td></tr>
<tr><td><code id="summary.modsem_lms_+3A_regressions">regressions</code></td>
<td>
<p>print regressions</p>
</td></tr>
<tr><td><code id="summary.modsem_lms_+3A_covariances">covariances</code></td>
<td>
<p>print covariances</p>
</td></tr>
<tr><td><code id="summary.modsem_lms_+3A_intercepts">intercepts</code></td>
<td>
<p>print intercepts</p>
</td></tr>
<tr><td><code id="summary.modsem_lms_+3A_variances">variances</code></td>
<td>
<p>print variances</p>
</td></tr>
<tr><td><code id="summary.modsem_lms_+3A_...">...</code></td>
<td>
<p>arguments passed to lavaan::summary()</p>
</td></tr>
<tr><td><code id="summary.modsem_lms_+3A_standardize">standardize</code></td>
<td>
<p>standardize estimates</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
m1 &lt;- "
 # Outer Model
 X =~ x1 + x2 + x3
 Y =~ y1 + y2 + y3
 Z =~ z1 + z2 + z3

 # Inner model
 Y ~ X + Z + X:Z
"

est1 &lt;- modsem(m1, oneInt, "lms")
summary(est1, ci = TRUE, scientific = TRUE)

## End(Not run)
## Not run: 
m1 &lt;- "
 # Outer Model
 X =~ x1 + x2 + x3
 Y =~ y1 + y2 + y3
 Z =~ z1 + z2 + z3

 # Inner model
 Y ~ X + Z + X:Z
"

est1 &lt;- modsem(m1, oneInt, "qml")
summary(est1, ci = TRUE, scientific = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='TPB'>TPB</h2><span id='topic+TPB'></span>

<h3>Description</h3>

<p>A simulated dataset based on the Theory of Planned Behaviour
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tpb &lt;- ' 
# Outer Model (Based on Hagger et al., 2007)
  ATT =~ att1 + att2 + att3 + att4 + att5
  SN =~ sn1 + sn2
  PBC =~ pbc1 + pbc2 + pbc3
  INT =~ int1 + int2 + int3
  BEH =~ b1 + b2

# Inner Model (Based on Steinmetz et al., 2011)
  INT ~ ATT + SN + PBC
  BEH ~ INT + PBC + INT:PBC  
'

est &lt;- modsem(tpb, data = TPB)
</code></pre>

<hr>
<h2 id='TPB_UK'>TPB_UK</h2><span id='topic+TPB_UK'></span>

<h3>Description</h3>

<p>A dataset based on the Theory of Planned Behaviour from a 
UK sample. 4 variables with high communality were selected for each 
latent variable (ATT, SN, PBC, INT, BEH), from two time points (t1 and t2).
</p>


<h3>Source</h3>

<p>Gathered from a replciation study of the original by Hagger et al. (2023).
Obtained from https://doi.org/10.23668/psycharchives.12187
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tpb_uk &lt;- ' 
# Outer Model (Based on Hagger et al., 2007)
 ATT =~ att3 + att2 + att1 + att4
 SN =~ sn4 + sn2 + sn3 + sn1
 PBC =~ pbc2 + pbc1 + pbc3 + pbc4
 INT =~ int2 + int1 + int3 + int4
 BEH =~ beh3 + beh2 + beh1 + beh4

# Inner Model (Based on Steinmetz et al., 2011)
 # Causal Relationsships
 INT ~ ATT + SN + PBC
 BEH ~ INT + PBC 
 BEH ~ INT:PBC  
'

est &lt;- modsem(tpb_uk, data = TPB_UK)
</code></pre>

<hr>
<h2 id='trace_path'>Estimate formulas for (co-)variance paths using Wright's path tracing rules</h2><span id='topic+trace_path'></span>

<h3>Description</h3>

<p>This function estimates the path from x to y using the path tracing rules, 
note that it only works with structural parameters, so &quot;=~&quot; are ignored. unless 
measurement.model = TRUE.
you want to use the measurement model, 
&quot;~&quot; in the mod column of pt.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trace_path(
  pt,
  x,
  y,
  parenthesis = TRUE,
  measurement.model = FALSE,
  maxlen = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trace_path_+3A_pt">pt</code></td>
<td>
<p>A data frame with columns lhs, op, rhs, and mod, from modsemify(syntax)</p>
</td></tr>
<tr><td><code id="trace_path_+3A_x">x</code></td>
<td>
<p>source variable</p>
</td></tr>
<tr><td><code id="trace_path_+3A_y">y</code></td>
<td>
<p>destination variable</p>
</td></tr>
<tr><td><code id="trace_path_+3A_parenthesis">parenthesis</code></td>
<td>
<p>if TRUE, the output will be enclosed in parenthesis</p>
</td></tr>
<tr><td><code id="trace_path_+3A_measurement.model">measurement.model</code></td>
<td>
<p>if TRUE, the function will use the measurement model</p>
</td></tr>
<tr><td><code id="trace_path_+3A_maxlen">maxlen</code></td>
<td>
<p>maximum length of a path before aborting</p>
</td></tr>
<tr><td><code id="trace_path_+3A_...">...</code></td>
<td>
<p>additional arguments passed to trace_path</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string with the estimated path (simplified if possible)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(modsem)
m1 &lt;- '
  # Outer Model
  X =~ x1 + x2 +x3
  Y =~ y1 + y2 + y3
  Z =~ z1 + z2 + z3

  # Inner model
  Y ~ X + Z + X:Z
'
pt &lt;- modsemify(m1)
trace_path(pt, "Y", "Y") # variance of Y
</code></pre>

<hr>
<h2 id='var_interactions'>Extract or modify parTable from an estimated model with estimated variances of interaction terms</h2><span id='topic+var_interactions'></span>

<h3>Description</h3>

<p>Extract or modify parTable from an estimated model with estimated variances of interaction terms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_interactions(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_interactions_+3A_object">object</code></td>
<td>
<p>An object of class 'modsem_da',  'modsem_mplus', 
or a parTable of class 'data.frame'</p>
</td></tr>
<tr><td><code id="var_interactions_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to other functions</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
