<!DOCTYPE html><html><head><title>Help for package counterfactuals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {counterfactuals}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CounterfactualMethod'><p>Base class for Counterfactual Explanation Methods</p></a></li>
<li><a href='#CounterfactualMethodClassif'><p>Base class for Counterfactual Explanation Methods for Classification Tasks</p></a></li>
<li><a href='#CounterfactualMethodRegr'><p>Base class for Counterfactual Explanation Methods for Regression Tasks</p></a></li>
<li><a href='#Counterfactuals'><p>Counterfactuals Class</p></a></li>
<li><a href='#dist_to_interval'><p>Computes the (absolute, pairwise) distance between the vector elements and an interval</p></a></li>
<li><a href='#eval_distance'><p>Evaluates a distance function and checks for correct output format</p></a></li>
<li><a href='#make_param_set'><p>Creates a ParamSet for the features of a data.table.</p></a></li>
<li><a href='#MOCClassif'><p>MOC (Multi-Objective Counterfactual Explanations) for Classification Tasks</p></a></li>
<li><a href='#MOCRegr'><p>MOC (Multi-Objective Counterfactual Explanations) for Regression Tasks</p></a></li>
<li><a href='#NICEClassif'><p>NICE (Nearest Instance Counterfactual Explanations) for Classification Tasks</p></a></li>
<li><a href='#NICERegr'><p>NICE (Nearest Instance Counterfactual Explanations) for Regression Tasks</p></a></li>
<li><a href='#RandomSearchClassif'><p>Random Search for Classification Tasks</p></a></li>
<li><a href='#RandomSearchRegr'><p>Random Search for Regression Tasks</p></a></li>
<li><a href='#smallest_n_indices'><p>Returns the indices of the n smallest elements in a vector</p></a></li>
<li><a href='#WhatIfClassif'><p>WhatIf for Classification Tasks</p></a></li>
<li><a href='#WhatIfRegr'><p>WhatIf for Regression Tasks</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Counterfactual Explanations</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Susanne Dandl &lt;dandls.datascience@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Modular and unified R6-based interface for counterfactual explanation methods.
    The following methods are currently implemented: Burghmans et al. (2022) &lt;<a href="https://arxiv.org/abs/2104.07411">arXiv:2104.07411</a>&gt;, 
    Dandl et al. (2020) &lt;<a href="https://doi.org/10.1007%2F978-3-030-58112-1_31">doi:10.1007/978-3-030-58112-1_31</a>&gt; and Wexler et al. (2019) &lt;<a href="https://doi.org/10.1109%2FTVCG.2019.2934619">doi:10.1109/TVCG.2019.2934619</a>&gt;.
    Optional extensions allow these methods to be applied to a variety of models and use cases.
    Once generated, the counterfactuals can be analyzed and visualized by provided functionalities.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dandls/counterfactuals">https://github.com/dandls/counterfactuals</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dandls/counterfactuals/issues">https://github.com/dandls/counterfactuals/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, checkmate, StatMatch, iml, data.table, paradox,
miesmuschel, bbotk</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gower, randomForest, GGally, trtf, testthat, MASS, R.rsp,
cowplot, covr, ggplot2, keras, rchallenge, gamlss.data,
partykit, rmarkdown, basefun, rpart, mlr3, mlr3learners,
mlr3pipelines, tidymodels, caret, mlr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-23 09:58:54 UTC; susanne</td>
</tr>
<tr>
<td>Author:</td>
<td>Susanne Dandl <a href="https://orcid.org/0000-0003-4324-4163"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Andreas Hofheinz [aut],
  Martin Binder [ctb],
  Giuseppe Casalicchio [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-23 11:32:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='CounterfactualMethod'>Base class for Counterfactual Explanation Methods</h2><span id='topic+CounterfactualMethod'></span>

<h3>Description</h3>

<p>Abstract base class for counterfactual explanation methods.
</p>


<h3>Inheritance</h3>

<p>Child classes: <a href="#topic+CounterfactualMethodClassif">CounterfactualMethodClassif</a>, <a href="#topic+CounterfactualMethodRegr">CounterfactualMethodRegr</a>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CounterfactualMethod-new"><code>CounterfactualMethod$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CounterfactualMethod-print"><code>CounterfactualMethod$print()</code></a>
</p>
</li>
<li> <p><a href="#method-CounterfactualMethod-clone"><code>CounterfactualMethod$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-CounterfactualMethod-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new <code>CounterfactualMethod</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>CounterfactualMethod$new(
  predictor,
  lower = NULL,
  upper = NULL,
  distance_function = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>predictor</code></dt><dd><p>(<a href="iml.html#topic+Predictor">Predictor</a>)<br />
The object (created with <code>iml::Predictor$new()</code>) holding the machine learning model and the data.</p>
</dd>
<dt><code>lower</code></dt><dd><p>(<code>numeric()</code> | <code>NULL</code>)<br />
Vector of minimum values for numeric features.
If <code>NULL</code> (default), the element for each numeric feature in <code>lower</code> is taken as its minimum value in <code>predictor$data$X</code>.
If not <code>NULL</code>, it should be named with the corresponding feature names.</p>
</dd>
<dt><code>upper</code></dt><dd><p>(<code>numeric()</code> | <code>NULL</code>)<br />
Vector of maximum values for numeric features.
If <code>NULL</code> (default), the element for each numeric feature in <code>upper</code> is taken as its maximum value in <code>predictor$data$X</code>.
If not <code>NULL</code>, it should be named with the corresponding feature names.</p>
</dd>
<dt><code>distance_function</code></dt><dd><p>(<code>character(1)</code> | <code style="white-space: pre;">&#8288;function()&#8288;</code>)<br />
Either the name of an already implemented distance function
(currently 'gower' or 'gower_c') or a function having three arguments:
<code>x</code>, <code>y</code>, and <code>data</code>. The function should return a <code>double</code> matrix with
<code>nrow(x)</code> rows and maximum <code>nrow(y)</code> columns.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-CounterfactualMethod-print"></a>



<h4>Method <code>print()</code></h4>

<p>Prints a <code>CounterfactualMethod</code> object.
The method calls a (private) <code style="white-space: pre;">&#8288;$print_parameters()&#8288;</code> method which should be implemented by the leaf classes.
</p>


<h5>Usage</h5>

<div class="r"><pre>CounterfactualMethod$print()</pre></div>


<hr>
<a id="method-CounterfactualMethod-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CounterfactualMethod$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='CounterfactualMethodClassif'>Base class for Counterfactual Explanation Methods for Classification Tasks</h2><span id='topic+CounterfactualMethodClassif'></span>

<h3>Description</h3>

<p>Abstract base class for counterfactual explanation methods for classifcation tasks.
</p>
<p><code>CounterfactualMethodClassif</code> can only be initialized for classification tasks. Child classes inherit the (public)
<code style="white-space: pre;">&#8288;$find_counterfactuals()&#8288;</code> method, which calls a (private) <code style="white-space: pre;">&#8288;$run()&#8288;</code> method. This <code style="white-space: pre;">&#8288;$run()&#8288;</code> method should be implemented
by the child classes and return the counterfactuals as a <code>data.table</code> (preferably) or a <code>data.frame</code>.
</p>


<h3>Inheritance</h3>

<p>Child classes: <a href="#topic+MOCClassif">MOCClassif</a>, <a href="#topic+WhatIfClassif">WhatIfClassif</a>, <a href="#topic+NICEClassif">NICEClassif</a>
</p>


<h3>Super class</h3>

<p><code><a href="#topic+CounterfactualMethod">counterfactuals::CounterfactualMethod</a></code> -&gt; <code>CounterfactualMethodClassif</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CounterfactualMethodClassif-new"><code>CounterfactualMethodClassif$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CounterfactualMethodClassif-find_counterfactuals"><code>CounterfactualMethodClassif$find_counterfactuals()</code></a>
</p>
</li>
<li> <p><a href="#method-CounterfactualMethodClassif-clone"><code>CounterfactualMethodClassif$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="counterfactuals" data-topic="CounterfactualMethod" data-id="print"><a href='../../counterfactuals/html/CounterfactualMethod.html#method-CounterfactualMethod-print'><code>counterfactuals::CounterfactualMethod$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-CounterfactualMethodClassif-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new <code>CounterfactualMethodClassif</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>CounterfactualMethodClassif$new(
  predictor,
  lower = NULL,
  upper = NULL,
  distance_function = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>predictor</code></dt><dd><p>(<a href="iml.html#topic+Predictor">Predictor</a>)<br />
The object (created with <code>iml::Predictor$new()</code>) holding the machine learning model and the data.</p>
</dd>
<dt><code>lower</code></dt><dd><p>(<code>numeric()</code> | <code>NULL</code>)<br />
Vector of minimum values for numeric features.
If <code>NULL</code> (default), the element for each numeric feature in <code>lower</code> is taken as its minimum value in <code>predictor$data$X</code>.
If not <code>NULL</code>, it should be named with the corresponding feature names.</p>
</dd>
<dt><code>upper</code></dt><dd><p>(<code>numeric()</code> | <code>NULL</code>)<br />
Vector of maximum values for numeric features.
If <code>NULL</code> (default), the element for each numeric feature in <code>upper</code> is taken as its maximum value in <code>predictor$data$X</code>.
If not <code>NULL</code>, it should be named with the corresponding feature names.</p>
</dd>
<dt><code>distance_function</code></dt><dd><p>(<code style="white-space: pre;">&#8288;function()&#8288;</code> | <code>NULL</code>)<br />
A distance function that may be used by the leaf classes.
If specified, the function must have three arguments: <code>x</code>, <code>y</code>, and <code>data</code> and return a <code>double</code> matrix with <code>nrow(x)</code>
rows and <code>nrow(y)</code> columns.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-CounterfactualMethodClassif-find_counterfactuals"></a>



<h4>Method <code>find_counterfactuals()</code></h4>

<p>Runs the counterfactual method and returns the counterfactuals.
It searches for counterfactuals that have a predicted probability in the interval <code>desired_prob</code> for the
<code>desired_class</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>CounterfactualMethodClassif$find_counterfactuals(
  x_interest,
  desired_class = NULL,
  desired_prob = c(0.5, 1)
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x_interest</code></dt><dd><p>(<code>data.table(1)</code> | <code>data.frame(1)</code>) <br />
A single row with the observation of interest.</p>
</dd>
<dt><code>desired_class</code></dt><dd><p>(<code>character(1)</code> | <code>NULL</code>) <br />
The desired class. If <code>NULL</code> (default) then <code>predictor$class</code> is taken.</p>
</dd>
<dt><code>desired_prob</code></dt><dd><p>(<code>numeric(1)</code> | <code>numeric(2)</code>) <br />
The desired predicted probability of the <code>desired_class</code>. It can be a numeric scalar or a vector with two
numeric values that specify a probability interval.
For hard classification tasks this can be set to <code>0</code> or <code>1</code>, respectively.
A scalar is internally converted to an interval.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="#topic+Counterfactuals">Counterfactuals</a> object containing the results.
</p>


<hr>
<a id="method-CounterfactualMethodClassif-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CounterfactualMethodClassif$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='CounterfactualMethodRegr'>Base class for Counterfactual Explanation Methods for Regression Tasks</h2><span id='topic+CounterfactualMethodRegr'></span>

<h3>Description</h3>

<p>Abstract base class for counterfactual explanation methods for regression tasks.
</p>
<p><code>CounterfactualMethodRegr</code> can only be initialized for regression tasks. Child classes inherit the (public)
<code style="white-space: pre;">&#8288;$find_counterfactuals()&#8288;</code> method, which calls a (private) <code style="white-space: pre;">&#8288;$run()&#8288;</code> method. This <code style="white-space: pre;">&#8288;$run()&#8288;</code> method should be implemented
by the child classes and return the counterfactuals as a <code>data.table</code> (preferably) or a <code>data.frame</code>.
</p>


<h3>Inheritance</h3>

<p>Child classes: <a href="#topic+MOCRegr">MOCRegr</a>, <a href="#topic+WhatIfRegr">WhatIfRegr</a>, <a href="#topic+NICERegr">NICERegr</a>
</p>


<h3>Super class</h3>

<p><code><a href="#topic+CounterfactualMethod">counterfactuals::CounterfactualMethod</a></code> -&gt; <code>CounterfactualMethodRegr</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CounterfactualMethodRegr-new"><code>CounterfactualMethodRegr$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CounterfactualMethodRegr-find_counterfactuals"><code>CounterfactualMethodRegr$find_counterfactuals()</code></a>
</p>
</li>
<li> <p><a href="#method-CounterfactualMethodRegr-clone"><code>CounterfactualMethodRegr$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="counterfactuals" data-topic="CounterfactualMethod" data-id="print"><a href='../../counterfactuals/html/CounterfactualMethod.html#method-CounterfactualMethod-print'><code>counterfactuals::CounterfactualMethod$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-CounterfactualMethodRegr-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new CounterfactualMethodRegr object.
</p>


<h5>Usage</h5>

<div class="r"><pre>CounterfactualMethodRegr$new(
  predictor,
  lower = NULL,
  upper = NULL,
  distance_function = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>predictor</code></dt><dd><p>(<a href="iml.html#topic+Predictor">Predictor</a>)<br />
The object (created with <code>iml::Predictor$new()</code>) holding the machine learning model and the data.</p>
</dd>
<dt><code>lower</code></dt><dd><p>(<code>numeric()</code> | <code>NULL</code>)<br />
Vector of minimum values for numeric features.
If <code>NULL</code> (default), the element for each numeric feature in <code>lower</code> is taken as its minimum value in <code>predictor$data$X</code>.
If not <code>NULL</code>, it should be named with the corresponding feature names.</p>
</dd>
<dt><code>upper</code></dt><dd><p>(<code>numeric()</code> | <code>NULL</code>)<br />
Vector of maximum values for numeric features.
If <code>NULL</code> (default), the element for each numeric feature in <code>upper</code> is taken as its maximum value in <code>predictor$data$X</code>.
If not <code>NULL</code>, it should be named with the corresponding feature names.</p>
</dd>
<dt><code>distance_function</code></dt><dd><p>(<code style="white-space: pre;">&#8288;function()&#8288;</code> | <code>NULL</code>)<br />
A distance function that may be used by the leaf classes.
If specified, the function must have three arguments: <code>x</code>, <code>y</code>, and <code>data</code> and return a <code>double</code> matrix with <code>nrow(x)</code>
rows and <code>nrow(y)</code> columns.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-CounterfactualMethodRegr-find_counterfactuals"></a>



<h4>Method <code>find_counterfactuals()</code></h4>

<p>Runs the counterfactual method and returns the counterfactuals.
It searches for counterfactuals that have a predicted outcome in the interval <code>desired_outcome</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>CounterfactualMethodRegr$find_counterfactuals(x_interest, desired_outcome)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x_interest</code></dt><dd><p>(<code>data.table(1)</code> | <code>data.frame(1)</code>) <br />
A single row with the observation of interest.</p>
</dd>
<dt><code>desired_outcome</code></dt><dd><p>(<code>numeric(1)</code> | <code>numeric(2)</code>) <br />
The desired predicted outcome. It can be a numeric scalar or a vector with two numeric values that specify an
outcome interval. A scalar is internally converted to an interval.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="#topic+Counterfactuals">Counterfactuals</a> object containing the results.
</p>


<hr>
<a id="method-CounterfactualMethodRegr-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CounterfactualMethodRegr$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='Counterfactuals'>Counterfactuals Class</h2><span id='topic+Counterfactuals'></span>

<h3>Description</h3>

<p>A <code>Counterfactuals</code> object should be created by the <code style="white-space: pre;">&#8288;$find_counterfactuals&#8288;</code> method of <a href="#topic+CounterfactualMethodRegr">CounterfactualMethodRegr</a>
or <a href="#topic+CounterfactualMethodClassif">CounterfactualMethodClassif</a>.
It contains the counterfactuals and has several methods for their evaluation and visualization.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>desired</code></dt><dd><p>(<code>list(1)</code> | <code>list(2)</code>)<br />
A <code>list</code> with the desired properties of the counterfactuals.
For regression tasks it has one element <code>desired_outcome</code> (<a href="#topic+CounterfactualMethodRegr">CounterfactualMethodRegr</a>) and for
classification tasks two elements <code>desired_class</code> and <code>desired_prob</code> (<a href="#topic+CounterfactualMethodClassif">CounterfactualMethodClassif</a>).</p>
</dd>
<dt><code>data</code></dt><dd><p>(<code>data.table</code>)<br />
The counterfactuals for <code>x_interest</code>.</p>
</dd>
<dt><code>x_interest</code></dt><dd><p>(<code>data.table(1)</code>) <br />
A single row with the observation of interest.</p>
</dd>
<dt><code>distance_function</code></dt><dd><p>(<code style="white-space: pre;">&#8288;function()&#8288;</code>) <br />
The distance function used in the second and fourth evaluation measure.
The function must have three arguments:
<code>x</code>, <code>y</code>, and <code>data</code> and return a <code>numeric</code> matrix. If set to <code>NULL</code> (default), then Gower distance (Gower 1971) is used.</p>
</dd>
<dt><code>method</code></dt><dd><p>(<code>character</code>) <br />
A single row with the observation of interest.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Counterfactuals-new"><code>Counterfactuals$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Counterfactuals-evaluate"><code>Counterfactuals$evaluate()</code></a>
</p>
</li>
<li> <p><a href="#method-Counterfactuals-evaluate_set"><code>Counterfactuals$evaluate_set()</code></a>
</p>
</li>
<li> <p><a href="#method-Counterfactuals-predict"><code>Counterfactuals$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-Counterfactuals-subset_to_valid"><code>Counterfactuals$subset_to_valid()</code></a>
</p>
</li>
<li> <p><a href="#method-Counterfactuals-revert_subset_to_valid"><code>Counterfactuals$revert_subset_to_valid()</code></a>
</p>
</li>
<li> <p><a href="#method-Counterfactuals-plot_parallel"><code>Counterfactuals$plot_parallel()</code></a>
</p>
</li>
<li> <p><a href="#method-Counterfactuals-plot_freq_of_feature_changes"><code>Counterfactuals$plot_freq_of_feature_changes()</code></a>
</p>
</li>
<li> <p><a href="#method-Counterfactuals-get_freq_of_feature_changes"><code>Counterfactuals$get_freq_of_feature_changes()</code></a>
</p>
</li>
<li> <p><a href="#method-Counterfactuals-plot_surface"><code>Counterfactuals$plot_surface()</code></a>
</p>
</li>
<li> <p><a href="#method-Counterfactuals-print"><code>Counterfactuals$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Counterfactuals-clone"><code>Counterfactuals$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Counterfactuals-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new <code>Counterfactuals</code> object.
This method should only be called by the <code style="white-space: pre;">&#8288;$find_counterfactuals&#8288;</code> methods of <a href="#topic+CounterfactualMethodRegr">CounterfactualMethodRegr</a>
and <a href="#topic+CounterfactualMethodClassif">CounterfactualMethodClassif</a>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Counterfactuals$new(
  cfactuals,
  predictor,
  x_interest,
  param_set,
  desired,
  method = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cfactuals</code></dt><dd><p>(<code>data.table</code>) <br />
The counterfactuals. Must have the same column names and types as <code>predictor$data$X</code>.</p>
</dd>
<dt><code>predictor</code></dt><dd><p>(<a href="iml.html#topic+Predictor">Predictor</a>)<br />
The object (created with <code>iml::Predictor$new()</code>) holding the machine learning model and the data.</p>
</dd>
<dt><code>x_interest</code></dt><dd><p>(<code>data.table(1)</code> | <code>data.frame(1)</code>) <br />
A single row with the observation of interest.</p>
</dd>
<dt><code>param_set</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">ParamSet</a>)<br />
A <a href="paradox.html#topic+ParamSet">ParamSet</a> based on the features of <code>predictor$data$X</code>.</p>
</dd>
<dt><code>desired</code></dt><dd><p>(<code>list(1)</code> | <code>list(2)</code>)<br />
A <code>list</code> with the desired properties of the counterfactuals. It should have one element <code>desired_outcome</code> for
regression tasks (<a href="#topic+CounterfactualMethodRegr">CounterfactualMethodRegr</a>) and two elements <code>desired_class</code> and <code>desired_prob</code>
for classification tasks (<a href="#topic+CounterfactualMethodClassif">CounterfactualMethodClassif</a>).</p>
</dd>
<dt><code>method</code></dt><dd><p>(<code>character</code>) <br />
Name of the method with which counterfactuals were generated. Default is
NULL which means that no name is provided.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Counterfactuals-evaluate"></a>



<h4>Method <code>evaluate()</code></h4>

<p>Evaluates the counterfactuals. It returns the counterfactuals together with the evaluation <code>measures</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Counterfactuals$evaluate(
  measures = c("dist_x_interest", "dist_target", "no_changed", "dist_train",
    "minimality"),
  show_diff = FALSE,
  k = 1L,
  weights = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>measures</code></dt><dd><p>(<code>character</code>) <br />
The name of one or more evaluation measures.
The following measures are available:
</p>

<ul>
<li> <p><code>dist_x_interest</code>: The distance of a counterfactual to <code>x_interest</code> measured by Gower's
dissimilarity measure (Gower 1971).
</p>
</li>
<li> <p><code>dist_target</code>: The absolute distance of the prediction for a counterfactual to the interval <code>desired_outcome</code>
(regression tasks) or <code>desired_prob</code> (classification tasks).
</p>
</li>
<li> <p><code>no_changed</code>: The number of feature changes w.r.t. <code>x_interest</code>.
</p>
</li>
<li> <p><code>dist_train</code>: The (weighted) distance to the <code>k</code> nearest training data points measured by Gower's
dissimilarity measure (Gower 1971).
</p>
</li>
<li> <p><code>minimality</code>: The number of changed features that each could be set to the
value of <code>x_interest</code> while keeping the desired prediction value.
</p>
</li></ul>
</dd>
<dt><code>show_diff</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should the counterfactuals be displayed as their differences to <code>x_interest</code>? Default is <code>FALSE</code>.
If set to <code>TRUE</code>, positive values for numeric features indicate an increase compared to the feature value in
<code>x_interest</code>, negative values indicate a decrease. For factors, the feature value is displayed if it differs
from <code>x_interest</code>; <code>NA</code> means &quot;no difference&quot; in both cases.</p>
</dd>
<dt><code>k</code></dt><dd><p>(<code>integerish(1)</code>) <br />
How many nearest training points should be considered for computing the <code>dist_train</code> measure? Default is <code>1L</code>.</p>
</dd>
<dt><code>weights</code></dt><dd><p>(<code>numeric(k)</code> | <code>NULL</code>) <br />
How should the <code>k</code> nearest training points be weighted when computing the <code>dist_train</code> measure? If <code>NULL</code>
(default) then all <code>k</code> points are weighted equally. If a numeric vector of length <code>k</code> is given, the i-th element
specifies the weight of the i-th closest data point.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Counterfactuals-evaluate_set"></a>



<h4>Method <code>evaluate_set()</code></h4>

<p>Evaluates a set of counterfactuals. It returns the evaluation <code>measures</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Counterfactuals$evaluate_set(
  measures = c("diversity", "no_nondom", "frac_nondom", "hypervolume"),
  nadir = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>measures</code></dt><dd><p>(<code>character</code>) <br />
The name of one or more evaluation measures.
The following measures are available:
</p>

<ul>
<li> <p><code>diversity</code>: Diversity of returned counterfactuals in the feature space
</p>
</li>
<li> <p><code>no_nondom</code>: Number of counterfactuals that are not dominated by other
counterfactuals.
</p>
</li>
<li> <p><code>frac_nondom</code>: Fraction of counterfactuals that are not dominated by
other counterfactuals
</p>
</li>
<li> <p><code>hypervolume</code>: Hypervolume of the induced Pareto front
</p>
</li></ul>
</dd>
<dt><code>nadir</code></dt><dd><p>(<code>numeric</code>) <br /> Max objective values to calculate dominated hypervolume.
Only considered, if <code>hypervolume</code> is one of the <code>measures</code>.
May be a scalar, in which case it is used for all four objectives,
or a vector of length 4.
Default is NULL, meaning the nadir point by Dandl et al. (2020) is used:
(min distance between prediction of <code>x_interest</code> to <code style="white-space: pre;">&#8288;desired_prob/_outcome&#8288;</code>,
1, number of features, 1).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Counterfactuals-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Returns the predictions for the counterfactuals.
</p>


<h5>Usage</h5>

<div class="r"><pre>Counterfactuals$predict()</pre></div>


<hr>
<a id="method-Counterfactuals-subset_to_valid"></a>



<h4>Method <code>subset_to_valid()</code></h4>

<p>Subset data to those meeting the desired prediction,
Process could be reverted using <code>revert_subset_to_valid()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Counterfactuals$subset_to_valid()</pre></div>


<hr>
<a id="method-Counterfactuals-revert_subset_to_valid"></a>



<h4>Method <code>revert_subset_to_valid()</code></h4>

<p>Subset data to those meeting the desired prediction,
Process could be reverted using <code>revert_subset_to_valid()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Counterfactuals$revert_subset_to_valid()</pre></div>


<hr>
<a id="method-Counterfactuals-plot_parallel"></a>



<h4>Method <code>plot_parallel()</code></h4>

<p>Plots a parallel plot that connects the (scaled) feature values of each counterfactual and highlights
<code>x_interest</code> in blue.
</p>


<h5>Usage</h5>

<div class="r"><pre>Counterfactuals$plot_parallel(
  feature_names = NULL,
  row_ids = NULL,
  digits_min_max = 2L
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>feature_names</code></dt><dd><p>(<code>character</code> | <code>NULL</code>)<br />
The names of the (numeric) features to display. If <code>NULL</code> (default) all features are displayed.</p>
</dd>
<dt><code>row_ids</code></dt><dd><p>(<code>integerish</code> | <code>NULL</code>)<br />
The row ids of the counterfactuals to display. If <code>NULL</code> (default) all counterfactuals are displayed.</p>
</dd>
<dt><code>digits_min_max</code></dt><dd><p>Maximum number of digits for the minimum and maximum features values. Default is <code>2L</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Counterfactuals-plot_freq_of_feature_changes"></a>



<h4>Method <code>plot_freq_of_feature_changes()</code></h4>

<p>Plots a bar chart with the frequency of feature changes across all counterfactuals.
</p>


<h5>Usage</h5>

<div class="r"><pre>Counterfactuals$plot_freq_of_feature_changes(subset_zero = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>subset_zero</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should unchanged features be excluded from the plot? Default is <code>FALSE</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Counterfactuals-get_freq_of_feature_changes"></a>



<h4>Method <code>get_freq_of_feature_changes()</code></h4>

<p>Returns the frequency of feature changes across all counterfactuals.
</p>


<h5>Usage</h5>

<div class="r"><pre>Counterfactuals$get_freq_of_feature_changes(subset_zero = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>subset_zero</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should unchanged features be excluded? Default is <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A (named) <code>numeric</code> vector with the frequency of feature changes.
</p>


<hr>
<a id="method-Counterfactuals-plot_surface"></a>



<h4>Method <code>plot_surface()</code></h4>

<p>Creates a surface plot for two features. <code>x_interest</code> is represented as a white dot and
all counterfactuals that differ from <code>x_interest</code> <strong>only</strong> in the two selected features are represented as black dots.
The tick marks next to the axes show the marginal distribution of the observed data (<code>predictor$data$X</code>). <br />
The exact plot type depends on the selected feature types and number of features:
</p>

<ul>
<li><p> 2 numeric features: surface plot
</p>
</li>
<li><p> 2 non-numeric features: heatmap
</p>
</li>
<li><p> 1 numeric or non-numeric feature: line graph
</p>
</li></ul>



<h5>Usage</h5>

<div class="r"><pre>Counterfactuals$plot_surface(feature_names, grid_size = 250L)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>feature_names</code></dt><dd><p>(<code>character(2)</code>)<br />
The names of the features to plot.</p>
</dd>
<dt><code>grid_size</code></dt><dd><p>(<code>integerish(1)</code>)<br />
The grid size of the plot. It is ignored in case of two <code>non-numeric</code> features. Default is <code>250L</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Counterfactuals-print"></a>



<h4>Method <code>print()</code></h4>

<p>Prints the <code>Counterfactuals</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Counterfactuals$print()</pre></div>


<hr>
<a id="method-Counterfactuals-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Counterfactuals$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Gower, J. C. (1971), &quot;A general coefficient of similarity and some of its properties&quot;. Biometrics, 27, 623–637.
</p>

<hr>
<h2 id='dist_to_interval'>Computes the (absolute, pairwise) distance between the vector elements and an interval</h2><span id='topic+dist_to_interval'></span>

<h3>Description</h3>

<p>Computes the (absolute, pairwise) distance between the vector elements and an interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_to_interval(x, interval)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_to_interval_+3A_x">x</code></td>
<td>
<p>(<code>numeric()</code>)<br />
A numeric vector.</p>
</td></tr>
<tr><td><code id="dist_to_interval_+3A_interval">interval</code></td>
<td>
<p>(<code>numeric(2)</code>)<br />
An interval.</p>
</td></tr>
</table>

<hr>
<h2 id='eval_distance'>Evaluates a distance function and checks for correct output format</h2><span id='topic+eval_distance'></span>

<h3>Description</h3>

<p>This function serves as an evaluation wrapper for some distance function. It checks that the output
of <code>distance_function</code> is a <code>numeric</code> matrix with <code>nrow(x)</code> rows and <code>nrow(y)</code> columns as expected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_distance(distance_function, x, y, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_distance_+3A_distance_function">distance_function</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;function()&#8288;</code>)<br />
A distance function to evaluate.</p>
</td></tr>
<tr><td><code id="eval_distance_+3A_x">x</code></td>
<td>
<p>(<code>data.frame() | numeric()</code>)<br />
A matrix or a data frame containing variables that should be used in the computation of the distance.</p>
</td></tr>
<tr><td><code id="eval_distance_+3A_y">y</code></td>
<td>
<p>(<code>data.frame() | numeric()</code>)<br />
A matrix or a data.frame containing variables that should be used in the computation of the distance.</p>
</td></tr>
<tr><td><code id="eval_distance_+3A_data">data</code></td>
<td>
<p>(<code>data.frame()</code> | <code>NULL</code>)<br />
A data.frame or data.table containing the entire data set. This can be used to compute statistics used in the
computation of the distance, e.g., standard deviation or range.</p>
</td></tr>
</table>

<hr>
<h2 id='make_param_set'>Creates a ParamSet for the features of a data.table.</h2><span id='topic+make_param_set'></span>

<h3>Description</h3>

<p>Creates a <a href="paradox.html#topic+ParamSet">ParamSet</a> for the columns of <code>dt</code>. Depending on the class of a column, a different
<a href="paradox.html#topic+Param">Param</a> is created:
</p>

<ul>
<li> <p><code>double</code>: <a href="paradox.html#topic+ParamDbl">ParamDbl</a>
</p>
</li>
<li> <p><code>integer</code>: <a href="paradox.html#topic+ParamInt">ParamInt</a>
</p>
</li>
<li> <p><code>character</code>: <a href="paradox.html#topic+ParamFct">ParamFct</a> (with unique values as levels)
</p>
</li>
<li> <p><code>factor</code>: <a href="paradox.html#topic+ParamFct">ParamFct</a> (with factor levels as levels)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>make_param_set(dt, lower = NULL, upper = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_param_set_+3A_dt">dt</code></td>
<td>
<p>(<code>data.table()</code>)<br />
The data for the <a href="paradox.html#topic+ParamSet">ParamSet</a>.</p>
</td></tr>
<tr><td><code id="make_param_set_+3A_lower">lower</code></td>
<td>
<p>(numeric() | NULL)<br />
Vector of minimum values for numeric features. If not NULL, it should be named with the corresponding feature names.
If NULL (default) lower is taken for each numeric feature as its minimum value in <code>dt</code>.</p>
</td></tr>
<tr><td><code id="make_param_set_+3A_upper">upper</code></td>
<td>
<p>(numeric() | NULL)<br />
Vector of maximum values for numeric features. If not NULL, it should be named with the corresponding feature names.
If NULL (default) upper is taken for each numeric feature as its maximum value in <code>dt</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="paradox.html#topic+ParamSet">ParamSet</a> for the features of <code>dt</code>.
</p>

<hr>
<h2 id='MOCClassif'>MOC (Multi-Objective Counterfactual Explanations) for Classification Tasks</h2><span id='topic+MOCClassif'></span>

<h3>Description</h3>

<p>MOC (Dandl et. al 2020) solves a multi-objective optimization problem to find counterfactuals. The four objectives
to minimize are:
</p>

<ol>
<li> <p><code>dist_target</code>: Distance to <code>desired_prob</code> (classification tasks) or <code>desired_prob</code> (regression tasks).
</p>
</li>
<li> <p><code>dist_x_interest</code>: Dissimilarity to <code>x_interest</code> measured by Gower's dissimilarity measure (Gower 1971).
</p>
</li>
<li> <p><code>no_changed</code>: Number of feature changes.
</p>
</li>
<li> <p><code>dist_train</code>: (Weighted) sum of dissimilarities to the <code>k</code> nearest data points in <code>predictor$data$X</code>.
</p>
</li></ol>

<p>For optimization, it uses the NSGA II algorithm (Deb et. al 2002) with mixed integer evolutionary
strategies (Li et al. 2013) and some tailored adjustments for the counterfactual search (Dandl et al. 2020).
Default values for the hyperparameters are based on Dandl et al. 2020.
</p>


<h3>Details</h3>

<p>Several population initialization strategies are available:
</p>

<ol>
<li> <p><code>random</code>: Feature values of new individuals are sampled from the feature value ranges in <code>predictor$data$X</code>.
Some features values are randomly reset to their initial value in <code>x_interest</code>.
</p>
</li>
<li> <p><code>sd</code>: Like <code>random</code>, except that the sample ranges of numerical features are limited to one standard
deviation from their initial value in <code>x_interest</code>.
</p>
</li>
<li> <p><code>icecurve</code>: As in <code>random</code>, feature values are sampled from the feature value ranges in <code>predictor$data$X</code>.
Then, however, features are reset with probabilities relative to their importance: the higher the importance
of a feature, the higher the probability that its values differ from its value in <code>x_interest</code>.
The feature importance is measured using ICE curves (Goldstein et al. 2015).
</p>
</li>
<li> <p><code>traindata</code>: Contrary to the other strategies, feature values are drawn from (non-dominated) data points
in <code>predictor$data$X</code>; if not enough non-dominated data points are available, remaining individuals
are initialized by random sampling. Subsequently, some features values are randomly reset to their initial value
in <code>x_interest</code> (as for <code>random</code>).
</p>
</li></ol>

<p>If <code>use_conditional_mutator</code> is set to TRUE, a conditional mutator samples
feature values from the conditional distribution given the other feature values
with the help of transformation trees (Hothorn and Zeileis 2017).
For details see Dandl et al. 2020.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+CounterfactualMethod">counterfactuals::CounterfactualMethod</a></code> -&gt; <code><a href="#topic+CounterfactualMethodClassif">counterfactuals::CounterfactualMethodClassif</a></code> -&gt; <code>MOCClassif</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>optimizer</code></dt><dd><p>(<a href="bbotk.html#topic+OptimInstanceMultiCrit">OptimInstanceMultiCrit</a>) <br />
The object used for optimization.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MOCClassif-new"><code>MOCClassif$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MOCClassif-plot_statistics"><code>MOCClassif$plot_statistics()</code></a>
</p>
</li>
<li> <p><a href="#method-MOCClassif-get_dominated_hv"><code>MOCClassif$get_dominated_hv()</code></a>
</p>
</li>
<li> <p><a href="#method-MOCClassif-plot_search"><code>MOCClassif$plot_search()</code></a>
</p>
</li>
<li> <p><a href="#method-MOCClassif-clone"><code>MOCClassif$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="counterfactuals" data-topic="CounterfactualMethod" data-id="print"><a href='../../counterfactuals/html/CounterfactualMethod.html#method-CounterfactualMethod-print'><code>counterfactuals::CounterfactualMethod$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="counterfactuals" data-topic="CounterfactualMethodClassif" data-id="find_counterfactuals"><a href='../../counterfactuals/html/CounterfactualMethodClassif.html#method-CounterfactualMethodClassif-find_counterfactuals'><code>counterfactuals::CounterfactualMethodClassif$find_counterfactuals()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-MOCClassif-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>MOCClassif</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>MOCClassif$new(
  predictor,
  epsilon = NULL,
  fixed_features = NULL,
  max_changed = NULL,
  mu = 20L,
  termination_crit = "gens",
  n_generations = 175L,
  p_rec = 0.71,
  p_rec_gen = 0.62,
  p_mut = 0.73,
  p_mut_gen = 0.5,
  p_mut_use_orig = 0.4,
  k = 1L,
  weights = NULL,
  lower = NULL,
  upper = NULL,
  init_strategy = "icecurve",
  use_conditional_mutator = FALSE,
  quiet = FALSE,
  distance_function = "gower"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>predictor</code></dt><dd><p>(<a href="iml.html#topic+Predictor">Predictor</a>)<br />
The object (created with <code>iml::Predictor$new()</code>) holding the machine learning model and the data.</p>
</dd>
<dt><code>epsilon</code></dt><dd><p>(<code>numeric(1)</code> | <code>NULL</code>)<br />
If not <code>NULL</code>, candidates whose prediction for the <code>desired_class</code> is farther away from the interval <code>desired_prob</code>
than <code>epsilon</code> are penalized. <code>NULL</code> (default) means no penalization.</p>
</dd>
<dt><code>fixed_features</code></dt><dd><p>(<code>character()</code> | <code>NULL</code>)<br />
Names of features that are not allowed to be changed. <code>NULL</code> (default) allows all features to be changed.</p>
</dd>
<dt><code>max_changed</code></dt><dd><p>(<code>integerish(1)</code> | <code>NULL</code>)<br />
Maximum number of feature changes. <code>NULL</code> (default) allows any number of changes.</p>
</dd>
<dt><code>mu</code></dt><dd><p>(<code>integerish(1)</code>)<br />
The population size. Default is <code>20L</code>.</p>
</dd>
<dt><code>termination_crit</code></dt><dd><p>(<code>character(1)</code>|<code>NULL</code>)<br />
Termination criterion, currently, two criterions are implemented: &quot;gens&quot; (default),
which stops after <code>n_generations</code> generations,  and &quot;genstag&quot;, which stops after
the hypervolume did not improve for <code>n_generations</code> generations
(the total number of generations is limited to 500).</p>
</dd>
<dt><code>n_generations</code></dt><dd><p>(<code>integerish(1)</code>)<br />
The number of generations. Default is <code>175L</code>.</p>
</dd>
<dt><code>p_rec</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Probability with which an individual is selected for recombination. Default is <code>0.71</code>.</p>
</dd>
<dt><code>p_rec_gen</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Probability with which a feature/gene is selected for recombination. Default is <code>0.62</code>.</p>
</dd>
<dt><code>p_mut</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Probability with which an individual is selected for mutation. Default is <code>0.73</code>.</p>
</dd>
<dt><code>p_mut_gen</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Probability with which a feature/gene is selected for mutation. Default is <code>0.5</code>.</p>
</dd>
<dt><code>p_mut_use_orig</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Probability with which a feature/gene is reset to its original value in <code>x_interest</code> after mutation. Default is <code>0.4</code>.</p>
</dd>
<dt><code>k</code></dt><dd><p>(<code>integerish(1)</code>)<br />
The number of data points to use for the forth objective. Default is <code>1L</code>.</p>
</dd>
<dt><code>weights</code></dt><dd><p>(<code>numeric(1) | numeric(k)</code> | <code>NULL</code>)<br />
The weights used to compute the weighted sum of dissimilarities for the forth objective. It is either a single value
or a vector of length <code>k</code>. If it has length <code>k</code>, the i-th element specifies the weight of the i-th closest data point.
The values should sum up to <code>1</code>. <code>NULL</code> (default) means all data points are weighted equally.</p>
</dd>
<dt><code>lower</code></dt><dd><p>(<code>numeric()</code> | <code>NULL</code>)<br />
Vector of minimum values for numeric features.
If <code>NULL</code> (default), the element for each numeric feature in <code>lower</code> is taken as its minimum value in <code>predictor$data$X</code>.
If not <code>NULL</code>, it should be named with the corresponding feature names.</p>
</dd>
<dt><code>upper</code></dt><dd><p>(<code>numeric()</code> | <code>NULL</code>)<br />
Vector of maximum values for numeric features.
If <code>NULL</code> (default), the element for each numeric feature in <code>upper</code> is taken as its maximum value in <code>predictor$data$X</code>.
If not <code>NULL</code>, it should be named with the corresponding feature names.</p>
</dd>
<dt><code>init_strategy</code></dt><dd><p>(<code>character(1)</code>)<br />
The population initialization strategy. Can be <code>icecurve</code> (default), <code>random</code>, <code>sd</code> or <code>traindata</code>. For more information,
see the <code>Details</code> section.</p>
</dd>
<dt><code>use_conditional_mutator</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should a conditional mutator be used? The conditional mutator generates plausible feature values based
on the values of the other feature. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>quiet</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should information about the optimization status be hidden? Default is <code>FALSE</code>.</p>
</dd>
<dt><code>distance_function</code></dt><dd><p>(<code style="white-space: pre;">&#8288;function()&#8288;</code> | <code>'gower'</code> | <code>'gower_c'</code>)<br />
The distance function to be used in the second and fourth objective.
Either the name of an already implemented distance function
('gower' or 'gower_c') or a function.
If set to 'gower' (default), then Gower's distance (Gower 1971) is used;
if set to 'gower_c', a C-based more efficient version of Gower's distance is used.
A function must have three arguments  <code>x</code>, <code>y</code>, and <code>data</code> and should
return a <code>double</code> matrix with <code>nrow(x)</code> rows and maximum <code>nrow(y)</code> columns.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MOCClassif-plot_statistics"></a>



<h4>Method <code>plot_statistics()</code></h4>

<p>Plots the evolution of the mean and minimum objective values together with the dominated hypervolume over
the generations. All values for a generation are computed based on all non-dominated individuals that emerged until
that generation.
</p>


<h5>Usage</h5>

<div class="r"><pre>MOCClassif$plot_statistics(centered_obj = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>centered_obj</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should the objective values be centered? If set to <code>FALSE</code>, each objective value is visualized in a separate plot,
since they (usually) have different scales. If set to <code>TRUE</code> (default), they are visualized in a single plot.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MOCClassif-get_dominated_hv"></a>



<h4>Method <code>get_dominated_hv()</code></h4>

<p>Calculates the dominated hypervolume of each generation.
</p>


<h5>Usage</h5>

<div class="r"><pre>MOCClassif$get_dominated_hv()</pre></div>



<h5>Returns</h5>

<p>A <code>data.table</code> with the dominated hypervolume of each generation.
</p>


<hr>
<a id="method-MOCClassif-plot_search"></a>



<h4>Method <code>plot_search()</code></h4>

<p>Visualizes two selected objective values of all emerged individuals in a scatter plot.
</p>


<h5>Usage</h5>

<div class="r"><pre>MOCClassif$plot_search(objectives = c("dist_target", "dist_x_interest"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>objectives</code></dt><dd><p>(<code>character(2)</code>)<br />
The two objectives to be shown in the plot. Possible values are &quot;dist_target&quot;, &quot;dist_x_interest, &quot;no_changed&quot;,
and &quot;dist_train&quot;.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MOCClassif-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MOCClassif$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Dandl, S., Molnar, C., Binder, M., and Bischl, B. (2020).
&quot;Multi-Objective Counterfactual Explanations&quot;. In: Parallel Problem
Solving from Nature – PPSN XVI, edited by Thomas Bäck, Mike Preuss,
André Deutz, Hao Wang, Carola Doerr, Michael Emmerich, and Heike Trautmann, 448–469,
Cham, Springer International Publishing, <a href="https://doi.org/10.1007/978-3-030-58112-1_31">doi:10.1007/978-3-030-58112-1_31</a>.
</p>
<p>Deb, K., Pratap, A., Agarwal, S., &amp; Meyarivan, T. A. M. T. (2002).
&quot;A fast and elitist multiobjective genetic algorithm: NSGA-II&quot;.
IEEE transactions on evolutionary computation, 6(2), 182-197.
</p>
<p>Goldstein, A., Kapelner, A., Bleich, J., and Pitkin, E. (2015).
&quot;Peeking Inside the Black Box: Visualizing
Statistical Learning with Plots of Individual Conditional Expectation&quot;.
Journal of Computational and Graphical Statistics 24 (1): 44–65.
<a href="https://doi.org/10.1080/10618600.2014.907095">doi:10.1080/10618600.2014.907095</a>.
</p>
<p>Gower, J. C. (1971). A general coefficient of similarity and some of its properties. Biometrics, 27, 623–637.
</p>
<p>Hothorn, T., Zeileis, A. (2017), &quot;Transformation Forests&quot;.
Technical Report, <a href="https://arxiv.org/abs/1701.02110">arXiv 1701.02110</a>.
</p>
<p>Li, Rui, L., Emmerich, M. T. M., Eggermont, J. Bäck, T., Schütz, M., Dijkstra, J., Reiber, J. H. C. (2013).
&quot;Mixed Integer Evolution Strategies for Parameter Optimization.&quot;
Evolutionary Computation 21 (1): 29–64. <a href="https://doi.org/10.1162/EVCO_a_00059">doi:10.1162/EVCO_a_00059</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("randomForest")) {
 
  # Train a model
  rf = randomForest(Species ~ ., data = iris)
  # Create a predictor object
  predictor = iml::Predictor$new(rf, type = "prob")
  # Find counterfactuals for x_interest
  moc_classif = MOCClassif$new(predictor, n_generations = 15L, quiet = TRUE)
 
  cfactuals = moc_classif$find_counterfactuals(
    x_interest = iris[150L, ], desired_class = "versicolor", desired_prob = c(0.5, 1)
  )
  # Print the counterfactuals
  cfactuals$data
  # Plot evolution of hypervolume and mean and minimum objective values
  moc_classif$plot_statistics()
  
}

</code></pre>

<hr>
<h2 id='MOCRegr'>MOC (Multi-Objective Counterfactual Explanations) for Regression Tasks</h2><span id='topic+MOCRegr'></span>

<h3>Description</h3>

<p>MOC (Dandl et. al 2020) solves a multi-objective optimization problem to find counterfactuals. The four objectives
to minimize are:
</p>

<ol>
<li> <p><code>dist_target</code>: Distance to <code>desired_prob</code> (classification tasks) or <code>desired_prob</code> (regression tasks).
</p>
</li>
<li> <p><code>dist_x_interest</code>: Dissimilarity to <code>x_interest</code> measured by Gower's dissimilarity measure (Gower 1971).
</p>
</li>
<li> <p><code>no_changed</code>: Number of feature changes.
</p>
</li>
<li> <p><code>dist_train</code>: (Weighted) sum of dissimilarities to the <code>k</code> nearest data points in <code>predictor$data$X</code>.
</p>
</li></ol>

<p>For optimization, it uses the NSGA II algorithm (Deb et. al 2002) with mixed integer evolutionary
strategies (Li et al. 2013) and some tailored adjustments for the counterfactual search (Dandl et al. 2020).
Default values for the hyperparameters are based on Dandl et al. 2020.
</p>


<h3>Details</h3>

<p>Several population initialization strategies are available:
</p>

<ol>
<li> <p><code>random</code>: Feature values of new individuals are sampled from the feature value ranges in <code>predictor$data$X</code>.
Some features values are randomly reset to their initial value in <code>x_interest</code>.
</p>
</li>
<li> <p><code>sd</code>: Like <code>random</code>, except that the sample ranges of numerical features are limited to one standard
deviation from their initial value in <code>x_interest</code>.
</p>
</li>
<li> <p><code>icecurve</code>: As in <code>random</code>, feature values are sampled from the feature value ranges in <code>predictor$data$X</code>.
Then, however, features are reset with probabilities relative to their importance: the higher the importance
of a feature, the higher the probability that its values differ from its value in <code>x_interest</code>.
The feature importance is measured using ICE curves (Goldstein et al. 2015).
</p>
</li>
<li> <p><code>traindata</code>: Contrary to the other strategies, feature values are drawn from (non-dominated) data points
in <code>predictor$data$X</code>; if not enough non-dominated data points are available, remaining individuals
are initialized by random sampling. Subsequently, some features values are randomly reset to their initial value
in <code>x_interest</code> (as for <code>random</code>).
</p>
</li></ol>

<p>If <code>use_conditional_mutator</code> is set to TRUE, a conditional mutator samples
feature values from the conditional distribution given the other feature values
with the help of transformation trees (Hothorn and Zeileis 2017).
For details see Dandl et al. 2020.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+CounterfactualMethod">counterfactuals::CounterfactualMethod</a></code> -&gt; <code><a href="#topic+CounterfactualMethodRegr">counterfactuals::CounterfactualMethodRegr</a></code> -&gt; <code>MOCRegr</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>optimizer</code></dt><dd><p>(<a href="bbotk.html#topic+OptimInstanceMultiCrit">OptimInstanceMultiCrit</a>) <br />
The object used for optimization.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MOCRegr-new"><code>MOCRegr$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MOCRegr-plot_statistics"><code>MOCRegr$plot_statistics()</code></a>
</p>
</li>
<li> <p><a href="#method-MOCRegr-get_dominated_hv"><code>MOCRegr$get_dominated_hv()</code></a>
</p>
</li>
<li> <p><a href="#method-MOCRegr-plot_search"><code>MOCRegr$plot_search()</code></a>
</p>
</li>
<li> <p><a href="#method-MOCRegr-clone"><code>MOCRegr$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="counterfactuals" data-topic="CounterfactualMethod" data-id="print"><a href='../../counterfactuals/html/CounterfactualMethod.html#method-CounterfactualMethod-print'><code>counterfactuals::CounterfactualMethod$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="counterfactuals" data-topic="CounterfactualMethodRegr" data-id="find_counterfactuals"><a href='../../counterfactuals/html/CounterfactualMethodRegr.html#method-CounterfactualMethodRegr-find_counterfactuals'><code>counterfactuals::CounterfactualMethodRegr$find_counterfactuals()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-MOCRegr-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>MOCRegr</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>MOCRegr$new(
  predictor,
  epsilon = NULL,
  fixed_features = NULL,
  max_changed = NULL,
  mu = 20L,
  termination_crit = "gens",
  n_generations = 175L,
  p_rec = 0.71,
  p_rec_gen = 0.62,
  p_mut = 0.73,
  p_mut_gen = 0.5,
  p_mut_use_orig = 0.4,
  k = 1L,
  weights = NULL,
  lower = NULL,
  upper = NULL,
  init_strategy = "icecurve",
  use_conditional_mutator = FALSE,
  quiet = FALSE,
  distance_function = "gower"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>predictor</code></dt><dd><p>(<a href="iml.html#topic+Predictor">Predictor</a>)<br />
The object (created with <code>iml::Predictor$new()</code>) holding the machine learning model and the data.</p>
</dd>
<dt><code>epsilon</code></dt><dd><p>(<code>numeric(1)</code> | <code>NULL</code>)<br />
If not <code>NULL</code>, candidates whose prediction is farther away from the interval <code>desired_outcome</code>
than <code>epsilon</code> are penalized. <code>NULL</code> (default) means no penalization.</p>
</dd>
<dt><code>fixed_features</code></dt><dd><p>(<code>character()</code> | <code>NULL</code>)<br />
Names of features that are not allowed to be changed. <code>NULL</code> (default) allows all features to be changed.</p>
</dd>
<dt><code>max_changed</code></dt><dd><p>(<code>integerish(1)</code> | <code>NULL</code>)<br />
Maximum number of feature changes. <code>NULL</code> (default) allows any number of changes.</p>
</dd>
<dt><code>mu</code></dt><dd><p>(<code>integerish(1)</code>)<br />
The population size. Default is <code>20L</code>.</p>
</dd>
<dt><code>termination_crit</code></dt><dd><p>(<code>character(1)</code>|<code>NULL</code>)<br />
Termination criterion, currently, two criterions are implemented: &quot;gens&quot; (default),
which stops after <code>n_generations</code> generations,  and &quot;genstag&quot;, which stops after
the hypervolume did not improve for <code>n_generations</code> generations
(the total number of generations is limited to 500).</p>
</dd>
<dt><code>n_generations</code></dt><dd><p>(<code>integerish(1)</code>)<br />
The number of generations. Default is <code>175L</code>.</p>
</dd>
<dt><code>p_rec</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Probability with which an individual is selected for recombination. Default is <code>0.71</code>.</p>
</dd>
<dt><code>p_rec_gen</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Probability with which a feature/gene is selected for recombination. Default is <code>0.62</code>.</p>
</dd>
<dt><code>p_mut</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Probability with which an individual is selected for mutation. Default is <code>0.73</code>.</p>
</dd>
<dt><code>p_mut_gen</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Probability with which a feature/gene is selected for mutation. Default is <code>0.5</code>.</p>
</dd>
<dt><code>p_mut_use_orig</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Probability with which a feature/gene is reset to its original value in <code>x_interest</code> after mutation. Default is <code>0.4</code>.</p>
</dd>
<dt><code>k</code></dt><dd><p>(<code>integerish(1)</code>)<br />
The number of data points to use for the forth objective. Default is <code>1L</code>.</p>
</dd>
<dt><code>weights</code></dt><dd><p>(<code>numeric(1) | numeric(k)</code> | <code>NULL</code>)<br />
The weights used to compute the weighted sum of dissimilarities for the forth objective. It is either a single value
or a vector of length <code>k</code>. If it has length <code>k</code>, the i-th element specifies the weight of the i-th closest data point.
The values should sum up to <code>1</code>. <code>NULL</code> (default) means all data points are weighted equally.</p>
</dd>
<dt><code>lower</code></dt><dd><p>(<code>numeric()</code> | <code>NULL</code>)<br />
Vector of minimum values for numeric features.
If <code>NULL</code> (default), the element for each numeric feature in <code>lower</code> is taken as its minimum value in <code>predictor$data$X</code>.
If not <code>NULL</code>, it should be named with the corresponding feature names.</p>
</dd>
<dt><code>upper</code></dt><dd><p>(<code>numeric()</code> | <code>NULL</code>)<br />
Vector of maximum values for numeric features.
If <code>NULL</code> (default), the element for each numeric feature in <code>upper</code> is taken as its maximum value in <code>predictor$data$X</code>.
If not <code>NULL</code>, it should be named with the corresponding feature names.</p>
</dd>
<dt><code>init_strategy</code></dt><dd><p>(<code>character(1)</code>)<br />
The population initialization strategy. Can be <code>icecurve</code> (default), <code>random</code>, <code>sd</code> or <code>traindata</code>. For more information,
see the <code>Details</code> section.</p>
</dd>
<dt><code>use_conditional_mutator</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should a conditional mutator be used? The conditional mutator generates plausible feature values based
on the values of the other feature. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>quiet</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should information about the optimization status be hidden? Default is <code>FALSE</code>.</p>
</dd>
<dt><code>distance_function</code></dt><dd><p>(<code style="white-space: pre;">&#8288;function()&#8288;</code> | <code>'gower'</code> | <code>'gower_c'</code>)<br />
The distance function to be used in the second and fourth objective.
Either the name of an already implemented distance function
('gower' or 'gower_c') or a function.
If set to 'gower' (default), then Gower's distance (Gower 1971) is used;
if set to 'gower_c', a C-based more efficient version of Gower's distance is used.
A function must have three arguments  <code>x</code>, <code>y</code>, and <code>data</code> and should
return a <code>double</code> matrix with <code>nrow(x)</code> rows and maximum <code>nrow(y)</code> columns.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MOCRegr-plot_statistics"></a>



<h4>Method <code>plot_statistics()</code></h4>

<p>Plots the evolution of the mean and minimum objective values together with the dominated hypervolume over
the generations. All values for a generation are computed based on all non-dominated individuals that emerged until
that generation.
</p>


<h5>Usage</h5>

<div class="r"><pre>MOCRegr$plot_statistics(centered_obj = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>centered_obj</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should the objective values be centered? If set to <code>FALSE</code>, each objective value is visualized in a separate plot,
since they (usually) have different scales. If set to <code>TRUE</code> (default), they are visualized in a single plot.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MOCRegr-get_dominated_hv"></a>



<h4>Method <code>get_dominated_hv()</code></h4>

<p>Calculates the dominated hypervolume of each generation.
</p>


<h5>Usage</h5>

<div class="r"><pre>MOCRegr$get_dominated_hv()</pre></div>



<h5>Returns</h5>

<p>A <code>data.table</code> with the dominated hypervolume of each generation.
</p>


<hr>
<a id="method-MOCRegr-plot_search"></a>



<h4>Method <code>plot_search()</code></h4>

<p>Visualizes two selected objective values of all emerged individuals in a scatter plot.
</p>


<h5>Usage</h5>

<div class="r"><pre>MOCRegr$plot_search(objectives = c("dist_target", "dist_x_interest"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>objectives</code></dt><dd><p>(<code>character(2)</code>)<br />
The two objectives to be shown in the plot. Possible values are &quot;dist_target&quot;, &quot;dist_x_interest, &quot;no_changed&quot;,
and &quot;dist_train&quot;.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MOCRegr-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MOCRegr$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Dandl, S., Molnar, C., Binder, M., and Bischl, B. (2020).
&quot;Multi-Objective Counterfactual Explanations&quot;. In: Parallel Problem
Solving from Nature – PPSN XVI, edited by Thomas Bäck, Mike Preuss,
André Deutz, Hao Wang, Carola Doerr, Michael Emmerich, and Heike Trautmann, 448–469,
Cham, Springer International Publishing, <a href="https://doi.org/10.1007/978-3-030-58112-1_31">doi:10.1007/978-3-030-58112-1_31</a>.
</p>
<p>Deb, K., Pratap, A., Agarwal, S., &amp; Meyarivan, T. A. M. T. (2002).
&quot;A fast and elitist multiobjective genetic algorithm: NSGA-II&quot;.
IEEE transactions on evolutionary computation, 6(2), 182-197.
</p>
<p>Goldstein, A., Kapelner, A., Bleich, J., and Pitkin, E. (2015).
&quot;Peeking Inside the Black Box: Visualizing
Statistical Learning with Plots of Individual Conditional Expectation&quot;.
Journal of Computational and Graphical Statistics 24 (1): 44–65.
<a href="https://doi.org/10.1080/10618600.2014.907095">doi:10.1080/10618600.2014.907095</a>.
</p>
<p>Gower, J. C. (1971). A general coefficient of similarity and some of its properties. Biometrics, 27, 623–637.
</p>
<p>Hothorn, T., Zeileis, A. (2017), &quot;Transformation Forests&quot;.
Technical Report, <a href="https://arxiv.org/abs/1701.02110">arXiv 1701.02110</a>.
</p>
<p>Li, Rui, L., Emmerich, M. T. M., Eggermont, J. Bäck, T., Schütz, M., Dijkstra, J., Reiber, J. H. C. (2013).
&quot;Mixed Integer Evolution Strategies for Parameter Optimization.&quot;
Evolutionary Computation 21 (1): 29–64. <a href="https://doi.org/10.1162/EVCO_a_00059">doi:10.1162/EVCO_a_00059</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("randomForest")) {
  # Train a model
  rf = randomForest(mpg ~ ., data = mtcars)
  # Create a predictor object
  predictor = iml::Predictor$new(rf)
  # Find counterfactuals for x_interest
  
  moc_regr = MOCRegr$new(predictor, n_generations = 15L, quiet = TRUE)
  cfactuals = moc_regr$find_counterfactuals(x_interest = mtcars[1L, ], desired_outcome = c(22, 26))
  # Print the counterfactuals
  cfactuals$data
  # Plot evolution of hypervolume and mean and minimum objective values 
  moc_regr$plot_statistics()
  
}

</code></pre>

<hr>
<h2 id='NICEClassif'>NICE (Nearest Instance Counterfactual Explanations) for Classification Tasks</h2><span id='topic+NICEClassif'></span>

<h3>Description</h3>

<p>NICE (Brughmans and Martens 2021) searches for counterfactuals by iteratively replacing feature values
of <code>x_interest</code> with the corresponding value of its most similar (optionally correctly classified) instance <code>x_nn</code>.
</p>


<h3>Details</h3>

<p>NICE starts the counterfactual search for <code>x_interest</code> by finding its most similar (optionally) correctly classified
neighbor <code>x_nn</code>. <br />
In the first iteration, NICE creates new instances by replacing a different feature value of <code>x_interest</code> with the corresponding
value of <code>x_nn</code> in each new instance. Thus, if <code>x_nn</code> differs from <code>x_interest</code> in <code>d</code> features, <code>d</code> new instances are created. <br />
Then, the reward values for the created instances are computed with the chosen reward function.
Available reward functions are <code>sparsity</code>, <code>proximity</code>, and <code>plausibility</code>. <br />
In the second iteration, NICE creates <code>d-1</code> new instances by replacing a different feature value of the highest
reward instance of the previous iteration with the corresponding value of <code>x_interest</code>, and so on. <br />
If <code>finish_early = TRUE</code>, the algorithm terminates when the predicted <code>desired_class</code> probability for
the highest reward instance is in the interval <code>desired_prob</code>; if <code>finish_early = FALSE</code>, the
algorithm continues until <code>x_nn</code> is recreated. <br />
Once the algorithm terminated, it depends on <code>return_multiple</code> which instances
are returned as counterfactuals: if <code>return_multiple = FALSE</code>, then only the highest reward instance in the
last iteration is returned as counterfactual; if <code>return_multiple = TRUE</code>, then all instances (of all iterations)
whose predicted <code>desired_class</code> probability is in the interval <code>desired_prob</code> are returned as counterfactuals.
</p>
<p>If <code>finish_early = FALSE</code> and <code>return_multiple = FALSE</code>, then <code>x_nn</code> is returned as single counterfactual.
</p>
<p>This NICE implementation corresponds to the original version of Brughmans and Martens (2021) when
<code>return_multiple = FALSE</code>, <code>finish_early = TRUE</code>, and <code>x_nn_correct = TRUE</code>.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+CounterfactualMethod">counterfactuals::CounterfactualMethod</a></code> -&gt; <code><a href="#topic+CounterfactualMethodClassif">counterfactuals::CounterfactualMethodClassif</a></code> -&gt; <code>NICEClassif</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>x_nn</code></dt><dd><p>(<code>logical(1)</code>) <br />
The most similar (optionally) correctly classified instance of <code>x_interest</code>.</p>
</dd>
<dt><code>archive</code></dt><dd><p>(<code>list()</code>) <br />
A list that stores the history of the algorithm run. For each algorithm iteration, it has one element containing
a <code>data.table</code>, which stores all created instances of this iteration together with their
reward values and their predictions.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-NICEClassif-new"><code>NICEClassif$new()</code></a>
</p>
</li>
<li> <p><a href="#method-NICEClassif-clone"><code>NICEClassif$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="counterfactuals" data-topic="CounterfactualMethod" data-id="print"><a href='../../counterfactuals/html/CounterfactualMethod.html#method-CounterfactualMethod-print'><code>counterfactuals::CounterfactualMethod$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="counterfactuals" data-topic="CounterfactualMethodClassif" data-id="find_counterfactuals"><a href='../../counterfactuals/html/CounterfactualMethodClassif.html#method-CounterfactualMethodClassif-find_counterfactuals'><code>counterfactuals::CounterfactualMethodClassif$find_counterfactuals()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-NICEClassif-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new NICEClassif object.
</p>


<h5>Usage</h5>

<div class="r"><pre>NICEClassif$new(
  predictor,
  optimization = "sparsity",
  x_nn_correct = TRUE,
  return_multiple = FALSE,
  finish_early = TRUE,
  distance_function = "gower"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>predictor</code></dt><dd><p>(<a href="iml.html#topic+Predictor">Predictor</a>)<br />
The object (created with <code>iml::Predictor$new()</code>) holding the machine learning model and the data.</p>
</dd>
<dt><code>optimization</code></dt><dd><p>(<code>character(1)</code>)<br />
The reward function to optimize. Can be <code>sparsity</code> (default), <code>proximity</code> or <code>plausibility</code>.</p>
</dd>
<dt><code>x_nn_correct</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should only <em>correctly</em> classified data points in <code>predictor$data$X</code> be considered for the most similar instance search?
Default is <code>TRUE</code>.</p>
</dd>
<dt><code>return_multiple</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should multiple counterfactuals be returned? If TRUE, the algorithm returns all created instances whose <code>desired_class</code>
prediction is in the interval <code>desired_prob</code>. For more information, see the <code>Details</code> section.</p>
</dd>
<dt><code>finish_early</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should the algorithm terminate after an iteration in which the <code>desired_class</code> prediction for the highest reward instance
is in the interval <code>desired_prob</code>. If <code>FALSE</code>, the algorithm continues until <code>x_nn</code> is recreated.</p>
</dd>
<dt><code>distance_function</code></dt><dd><p>(<code style="white-space: pre;">&#8288;function()&#8288;</code> | <code>'gower'</code> | <code>'gower_c'</code>)<br />
The distance function used to compute the distances between <code>x_interest</code>
and the training data points for finding <code>x_nn</code>. If <code>optimization</code> is set
to <code>proximity</code>, the distance function is also used for calculating the
distance between candidates and <code>x_interest</code>.
Either the name of an already implemented distance function
('gower' or 'gower_c') or a function is allowed as input.
If set to 'gower' (default), then Gower's distance (Gower 1971) is used;
if set to 'gower_c', a C-based more efficient version of Gower's distance is used.
A function must have three arguments  <code>x</code>, <code>y</code>, and <code>data</code> and should
return a <code>double</code> matrix with <code>nrow(x)</code> rows and maximum <code>nrow(y)</code> columns.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-NICEClassif-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>NICEClassif$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Brughmans, D., &amp; Martens, D. (2021). NICE: An Algorithm for Nearest Instance Counterfactual Explanations.
<a href="https://arxiv.org/abs/2104.07411">arXiv 2104.07411</a> v2.
</p>
<p>Gower, J. C. (1971), &quot;A general coefficient of similarity and some of its properties&quot;. Biometrics, 27, 623–637.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("randomForest")) {
  # Train a model
  rf = randomForest(Species ~ ., data = iris)
  # Create a predictor object
  predictor = iml::Predictor$new(rf, type = "prob")
  # Find counterfactuals
  nice_classif = NICEClassif$new(predictor)
  cfactuals = nice_classif$find_counterfactuals(
    x_interest = iris[150L, ], desired_class = "versicolor", desired_prob = c(0.5, 1)
  )
  # Print the results
  cfactuals$data
  # Print archive
  nice_classif$archive
}

</code></pre>

<hr>
<h2 id='NICERegr'>NICE (Nearest Instance Counterfactual Explanations) for Regression Tasks</h2><span id='topic+NICERegr'></span>

<h3>Description</h3>

<p>NICE (Brughmans and Martens 2021) searches for counterfactuals by iteratively replacing feature values
of <code>x_interest</code> with the corresponding value of its most similar (optionally correctly predicted) instance <code>x_nn</code>.
While the original method is only applicable to classification tasks (see <a href="#topic+NICEClassif">NICEClassif</a>), this implementation extend it to regression tasks.
</p>


<h3>Details</h3>

<p>NICE starts the counterfactual search for <code>x_interest</code> by finding its most similar (optionally) correctly predicted
neighbor <code>x_nn</code> with(in) the desired prediction (range). Correctly predicted means that the prediction of <code>x_nn</code> is less
than a user-specified <code>margin_correct</code> away from the true outcome of <code>x_nn</code>.
This is designed to mimic the search for <code>x_nn</code> for regression tasks.
If no <code>x_nn</code> satisfies this constraint, a warning is returned that no counterfactual could be found.
<br />
In the first iteration, NICE creates new instances by replacing a different feature value of <code>x_interest</code> with the corresponding
value of <code>x_nn</code> in each new instance. Thus, if <code>x_nn</code> differs from <code>x_interest</code> in <code>d</code> features, <code>d</code> new instances are created. <br />
Then, the reward values for the created instances are computed with the chosen reward function.
Available reward functions are <code>sparsity</code>, <code>proximity</code>, and <code>plausibility</code>. <br />
In the second iteration, NICE creates <code>d-1</code> new instances by replacing a different feature value of the highest
reward instance of the previous iteration with the corresponding value of <code>x_interest</code>, and so on. <br />
If <code>finish_early = TRUE</code>, the algorithm terminates when the predicted outcome for
the highest reward instance is in the interval <code>desired_outcome</code>; if <code>finish_early = FALSE</code>, the
algorithm continues until <code>x_nn</code> is recreated. <br />
Once the algorithm terminated, it depends on <code>return_multiple</code> which instances
are returned as counterfactuals: if <code>return_multiple = FALSE</code>, then only the highest reward instance in the
last iteration is returned as counterfactual; if <code>return_multiple = TRUE</code>, then all instances (of all iterations)
whose predicted outcome is in the interval <code>desired_outcome</code> are returned as counterfactuals.
</p>
<p>If <code>finish_early = FALSE</code> and <code>return_multiple = FALSE</code>, then <code>x_nn</code> is returned as single counterfactual.
</p>
<p>The function computes the dissimilarities using Gower's dissimilarity measure (Gower 1971).
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+CounterfactualMethod">counterfactuals::CounterfactualMethod</a></code> -&gt; <code><a href="#topic+CounterfactualMethodRegr">counterfactuals::CounterfactualMethodRegr</a></code> -&gt; <code>NICERegr</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>x_nn</code></dt><dd><p>(<code>logical(1)</code>) <br />
The most similar (optionally) correctly classified instance of <code>x_interest</code>.</p>
</dd>
<dt><code>archive</code></dt><dd><p>(<code>list()</code>) <br />
A list that stores the history of the algorithm run. For each algorithm iteration, it has one element containing
a <code>data.table</code>, which stores all created instances of this iteration together with their
reward values and their predictions.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-NICERegr-new"><code>NICERegr$new()</code></a>
</p>
</li>
<li> <p><a href="#method-NICERegr-clone"><code>NICERegr$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="counterfactuals" data-topic="CounterfactualMethod" data-id="print"><a href='../../counterfactuals/html/CounterfactualMethod.html#method-CounterfactualMethod-print'><code>counterfactuals::CounterfactualMethod$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="counterfactuals" data-topic="CounterfactualMethodRegr" data-id="find_counterfactuals"><a href='../../counterfactuals/html/CounterfactualMethodRegr.html#method-CounterfactualMethodRegr-find_counterfactuals'><code>counterfactuals::CounterfactualMethodRegr$find_counterfactuals()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-NICERegr-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new NICERegr object.
</p>


<h5>Usage</h5>

<div class="r"><pre>NICERegr$new(
  predictor,
  optimization = "sparsity",
  x_nn_correct = TRUE,
  margin_correct = NULL,
  return_multiple = FALSE,
  finish_early = TRUE,
  distance_function = "gower"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>predictor</code></dt><dd><p>(<a href="iml.html#topic+Predictor">Predictor</a>)<br />
The object (created with <code>iml::Predictor$new()</code>) holding the machine learning model and the data.</p>
</dd>
<dt><code>optimization</code></dt><dd><p>(<code>character(1)</code>)<br />
The reward function to optimize. Can be <code>sparsity</code> (default), <code>proximity</code> or <code>plausibility</code>.</p>
</dd>
<dt><code>x_nn_correct</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should only <em>correctly</em> classified data points in <code>predictor$data$X</code> be considered for the most similar instance search?
Default is <code>TRUE</code>.</p>
</dd>
<dt><code>margin_correct</code></dt><dd><p>(<code>numeric(1)</code> | <code>NULL</code>)<br />
The accepted margin for considering a prediction as &quot;correct&quot;.
Ignored if <code>x_nn_correct = FALSE</code>.
If NULL, the accepted margin is set to half the median absolute distance between the true and predicted outcomes in the data (<code>predictor$data</code>).</p>
</dd>
<dt><code>return_multiple</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should multiple counterfactuals be returned? If TRUE, the algorithm returns all created instances whose
prediction is in the interval <code>desired_outcome</code>. For more information, see the <code>Details</code> section.</p>
</dd>
<dt><code>finish_early</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should the algorithm terminate after an iteration in which the prediction for the highest reward instance
is in the interval <code>desired_outcome</code>. If <code>FALSE</code>, the algorithm continues until <code>x_nn</code> is recreated.</p>
</dd>
<dt><code>distance_function</code></dt><dd><p>(<code style="white-space: pre;">&#8288;function()&#8288;</code> | <code>'gower'</code> | <code>'gower_c'</code>)<br />
The distance function used to compute the distances between <code>x_interest</code>
and the training data points for finding <code>x_nn</code>. If <code>optimization</code> is set
to <code>proximity</code>, the distance function is also used for calculating the
distance between candidates and <code>x_interest</code>.
Either the name of an already implemented distance function
('gower' or 'gower_c') or a function is allowed as input.
If set to 'gower' (default), then Gower's distance (Gower 1971) is used;
if set to 'gower_c', a C-based more efficient version of Gower's distance is used.
A function must have three arguments  <code>x</code>, <code>y</code>, and <code>data</code> and should
return a <code>double</code> matrix with <code>nrow(x)</code> rows and maximum <code>nrow(y)</code> columns.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-NICERegr-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>NICERegr$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Brughmans, D., &amp; Martens, D. (2021). NICE: An Algorithm for Nearest Instance Counterfactual Explanations.
<a href="https://arxiv.org/abs/2104.07411">arXiv 2104.07411</a> v2.
</p>
<p>Gower, J. C. (1971), &quot;A general coefficient of similarity and some of its properties&quot;. Biometrics, 27, 623–637.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("randomForest")) {
  set.seed(123456)
  # Train a model
  rf = randomForest(mpg ~ ., data = mtcars)
  # Create a predictor object
  predictor = iml::Predictor$new(rf)
  # Find counterfactuals
  nice_regr = NICERegr$new(predictor)
  cfactuals = nice_regr$find_counterfactuals(
     x_interest = mtcars[1L, ], desired_outcome = c(22, 26)
  )
  # Print the results
  cfactuals$data
  # Print archive
  nice_regr$archive
}

</code></pre>

<hr>
<h2 id='RandomSearchClassif'>Random Search for Classification Tasks</h2><span id='topic+RandomSearchClassif'></span>

<h3>Description</h3>

<p>RandomSearch randomly samples a population of candidates and returns non-dominated candidates w.r.t to the objectives
of MOC (Dandl et. al 2020) as counterfactuals. RandomSearch is equivalent to MOC with zero generations and the <code>random</code>
initialization strategy.
</p>
<p>The four objectives of MOC (Dandl et. al 2020) to are:
</p>

<ol>
<li> <p>Distance to <code>desired_prob</code> (classification tasks) or <code>desired_prob</code> (regression tasks).
</p>
</li>
<li> <p>Dissimilarity to <code>x_interest</code> measured by Gower's dissimilarity measure (Gower 1971).
</p>
</li>
<li> <p>Number of feature changes.
</p>
</li>
<li> <p>(Weighted) sum of dissimilarities to the <code>k</code> nearest data points in <code>predictor$data$X</code>.
</p>
</li></ol>



<h3>Details</h3>

<p>RandomSearch is typically used as a baseline in benchmark comparisons with MOC.
The total number of samples drawn is <code>mu</code> * <code>n_generations</code>. Using separate parameters <code>mu</code> and <code>n_generations</code>
is only required to make certain statistics comparable with MOC (e.g. the evolution of the dominated hypervolume).
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+CounterfactualMethod">counterfactuals::CounterfactualMethod</a></code> -&gt; <code><a href="#topic+CounterfactualMethodClassif">counterfactuals::CounterfactualMethodClassif</a></code> -&gt; <code>RandomSearchClassif</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>optimizer</code></dt><dd><p>(<a href="bbotk.html#topic+OptimInstanceMultiCrit">OptimInstanceMultiCrit</a>) <br />
The object used for optimization.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RandomSearchClassif-new"><code>RandomSearchClassif$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RandomSearchClassif-plot_statistics"><code>RandomSearchClassif$plot_statistics()</code></a>
</p>
</li>
<li> <p><a href="#method-RandomSearchClassif-get_dominated_hv"><code>RandomSearchClassif$get_dominated_hv()</code></a>
</p>
</li>
<li> <p><a href="#method-RandomSearchClassif-plot_search"><code>RandomSearchClassif$plot_search()</code></a>
</p>
</li>
<li> <p><a href="#method-RandomSearchClassif-clone"><code>RandomSearchClassif$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="counterfactuals" data-topic="CounterfactualMethod" data-id="print"><a href='../../counterfactuals/html/CounterfactualMethod.html#method-CounterfactualMethod-print'><code>counterfactuals::CounterfactualMethod$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="counterfactuals" data-topic="CounterfactualMethodClassif" data-id="find_counterfactuals"><a href='../../counterfactuals/html/CounterfactualMethodClassif.html#method-CounterfactualMethodClassif-find_counterfactuals'><code>counterfactuals::CounterfactualMethodClassif$find_counterfactuals()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-RandomSearchClassif-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>RandomSearchClassif</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>RandomSearchClassif$new(
  predictor,
  fixed_features = NULL,
  max_changed = NULL,
  mu = 20L,
  n_generations = 175L,
  p_use_orig = 0.5,
  k = 1L,
  weights = NULL,
  lower = NULL,
  upper = NULL,
  distance_function = "gower"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>predictor</code></dt><dd><p>(<a href="iml.html#topic+Predictor">Predictor</a>)<br />
The object (created with <code>iml::Predictor$new()</code>) holding the machine learning model and the data.</p>
</dd>
<dt><code>fixed_features</code></dt><dd><p>(<code>character()</code> | <code>NULL</code>)<br />
Names of features that are not allowed to be changed. <code>NULL</code> (default) allows all features to be changed.</p>
</dd>
<dt><code>max_changed</code></dt><dd><p>(<code>integerish(1)</code> | <code>NULL</code>)<br />
Maximum number of feature changes. <code>NULL</code> (default) allows any number of changes.</p>
</dd>
<dt><code>mu</code></dt><dd><p>(<code>integerish(1)</code>)<br />
The population size. Default is <code>20L</code>. The total number of random samples is set to <code>mu * n_generations</code>.
See the <code>Details</code> for further details.</p>
</dd>
<dt><code>n_generations</code></dt><dd><p>(<code>integerish(1)</code>)<br />
The number of generations. Default is <code>175L</code>. The total number of random samples is set to <code>mu * n_generations</code>.
See the <code>Details</code> section for further details.</p>
</dd>
<dt><code>p_use_orig</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Probability with which a feature/gene is reset to its original value in <code>x_interest</code> after random sampling. Default is <code>0.5</code>.</p>
</dd>
<dt><code>k</code></dt><dd><p>(<code>integerish(1)</code>)<br />
The number of data points to use for the forth objective. Default is <code>1L</code>.</p>
</dd>
<dt><code>weights</code></dt><dd><p>(<code>numeric(1) | numeric(k)</code> | <code>NULL</code>)<br />
The weights used to compute the weighted sum of dissimilarities for the forth objective. It is either a single value
or a vector of length <code>k</code>. If it has length <code>k</code>, the i-th element specifies the weight of the i-th closest data point.
The values should sum up to <code>1</code>. <code>NULL</code> (default) means all data points are weighted equally.</p>
</dd>
<dt><code>lower</code></dt><dd><p>(<code>numeric()</code> | <code>NULL</code>)<br />
Vector of minimum values for numeric features.
If <code>NULL</code> (default), the element for each numeric feature in <code>lower</code> is taken as its minimum value in <code>predictor$data$X</code>.
If not <code>NULL</code>, it should be named with the corresponding feature names.</p>
</dd>
<dt><code>upper</code></dt><dd><p>(<code>numeric()</code> | <code>NULL</code>)<br />
Vector of maximum values for numeric features.
If <code>NULL</code> (default), the element for each numeric feature in <code>upper</code> is taken as its maximum value in <code>predictor$data$X</code>.
If not <code>NULL</code>, it should be named with the corresponding feature names.</p>
</dd>
<dt><code>distance_function</code></dt><dd><p>(<code style="white-space: pre;">&#8288;function()&#8288;</code> | <code>'gower'</code> | <code>'gower_c'</code>)<br />
The distance function to be used in the second and fourth objective.
Either the name of an already implemented distance function
('gower' or 'gower_c') or a function.
If set to 'gower' (default), then Gower's distance (Gower 1971) is used;
if set to 'gower_c', a C-based more efficient version of Gower's distance is used.
A function must have three arguments  <code>x</code>, <code>y</code>, and <code>data</code> and should
return a <code>double</code> matrix with <code>nrow(x)</code> rows and maximum <code>nrow(y)</code> columns.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RandomSearchClassif-plot_statistics"></a>



<h4>Method <code>plot_statistics()</code></h4>

<p>Plots the evolution of the mean and minimum objective values together with the dominated hypervolume over
the generations. All values for a generation are computed based on all non-dominated individuals that emerged until
that generation. The randomly drawn samples are therefore split into <code>n_generations</code> folds of size <code>mu.</code>
This function mimics MOCs <code>plot_statistics()</code> method. See the <code>Details</code> section for further information.
</p>


<h5>Usage</h5>

<div class="r"><pre>RandomSearchClassif$plot_statistics(centered_obj = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>centered_obj</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should the objective values be centered? If set to <code>FALSE</code>, each objective value is visualized in a separate plot,
since they (usually) have different scales. If set to <code>TRUE</code> (default), they are visualized in a single plot.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RandomSearchClassif-get_dominated_hv"></a>



<h4>Method <code>get_dominated_hv()</code></h4>

<p>Calculates the dominated hypervolume of each generation. The randomly drawn samples are therefore split
into <code>n_generations</code> folds of size <code>mu.</code>
This function mimics MOCs <code>get_dominated_hv()</code> method. See the <code>Details</code> section for further information.
</p>


<h5>Usage</h5>

<div class="r"><pre>RandomSearchClassif$get_dominated_hv()</pre></div>



<h5>Returns</h5>

<p>A <code>data.table</code> with the dominated hypervolume of each generation.
</p>


<hr>
<a id="method-RandomSearchClassif-plot_search"></a>



<h4>Method <code>plot_search()</code></h4>

<p>Visualizes two selected objective values of all emerged individuals in a scatter plot.
The randomly drawn samples are therefore split into <code>n_generations</code> folds of size <code>mu.</code>
This function mimics MOCs <code>plot_search()</code> method. See the <code>Details</code> section for further information.
</p>


<h5>Usage</h5>

<div class="r"><pre>RandomSearchClassif$plot_search(
  objectives = c("dist_target", "dist_x_interest")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>objectives</code></dt><dd><p>(<code>character(2)</code>)<br />
The two objectives to be shown in the plot. Possible values are &quot;dist_target&quot;, &quot;dist_x_interest, &quot;no_changed&quot;,
and &quot;dist_train&quot;.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RandomSearchClassif-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RandomSearchClassif$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Dandl, S., Molnar, C., Binder, M., and Bischl, B. (2020).
&quot;Multi-Objective Counterfactual Explanations&quot;. In: Parallel Problem
Solving from Nature – PPSN XVI, edited by Thomas Bäck, Mike Preuss,
André Deutz, Hao Wang, Carola Doerr, Michael Emmerich, and Heike Trautmann, 448–469,
Cham, Springer International Publishing, <a href="https://doi.org/10.1007/978-3-030-58112-1_31">doi:10.1007/978-3-030-58112-1_31</a>.
</p>
<p>Deb, K., Pratap, A., Agarwal, S., &amp; Meyarivan, T. A. M. T. (2002).
&quot;A fast and elitist multiobjective genetic algorithm: NSGA-II&quot;.
IEEE transactions on evolutionary computation, 6(2), 182-197.
</p>
<p>Goldstein, A., Kapelner, A., Bleich, J., and Pitkin, E. (2015).
&quot;Peeking Inside the Black Box: Visualizing
Statistical Learning with Plots of Individual Conditional Expectation&quot;.
Journal of Computational and Graphical Statistics 24 (1): 44–65.
<a href="https://doi.org/10.1080/10618600.2014.907095">doi:10.1080/10618600.2014.907095</a>.
</p>
<p>Gower, J. C. (1971). A general coefficient of similarity and some of its properties. Biometrics, 27, 623–637.
</p>
<p>Li, Rui, L., Emmerich, M. T. M., Eggermont, J. Bäck, T., Schütz, M., Dijkstra, J., Reiber, J. H. C. (2013).
&quot;Mixed Integer Evolution Strategies for Parameter Optimization.&quot;
Evolutionary Computation 21 (1): 29–64. <a href="https://doi.org/10.1162/EVCO_a_00059">doi:10.1162/EVCO_a_00059</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("randomForest")) {
  # Train a model
  rf = randomForest(Species ~ ., data = iris)
  # Create a predictor object
  predictor = iml::Predictor$new(rf, type = "prob")
  # Find counterfactuals for x_interest
  rs_classif = RandomSearchClassif$new(predictor, n_generations = 30L)
  cfactuals = rs_classif$find_counterfactuals(
    x_interest = iris[150L, ], desired_class = "versicolor", desired_prob = c(0.5, 1)
  )
  # Print the counterfactuals
  cfactuals$data
  # Plot evolution of hypervolume and mean and minimum objective values
  rs_classif$plot_statistics()
}

</code></pre>

<hr>
<h2 id='RandomSearchRegr'>Random Search for Regression Tasks</h2><span id='topic+RandomSearchRegr'></span>

<h3>Description</h3>

<p>RandomSearch randomly samples a population of candidates and returns non-dominated candidates w.r.t to the objectives
of MOC (Dandl et. al 2020) as counterfactuals. RandomSearch is equivalent to MOC with zero generations and the <code>random</code>
initialization strategy.
</p>
<p>The four objectives of MOC (Dandl et. al 2020) to are:
</p>

<ol>
<li> <p>Distance to <code>desired_prob</code> (classification tasks) or <code>desired_prob</code> (regression tasks).
</p>
</li>
<li> <p>Dissimilarity to <code>x_interest</code> measured by Gower's dissimilarity measure (Gower 1971).
</p>
</li>
<li> <p>Number of feature changes.
</p>
</li>
<li> <p>(Weighted) sum of dissimilarities to the <code>k</code> nearest data points in <code>predictor$data$X</code>.
</p>
</li></ol>



<h3>Details</h3>

<p>RandomSearch is typically used as a baseline in benchmark comparisons with MOC.
The total number of samples drawn is <code>mu</code> * <code>n_generations</code>. Using separate parameters <code>mu</code> and <code>n_generations</code>
is only required to make certain statistics comparable with MOC (e.g. the evolution of the dominated hypervolume).
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+CounterfactualMethod">counterfactuals::CounterfactualMethod</a></code> -&gt; <code><a href="#topic+CounterfactualMethodRegr">counterfactuals::CounterfactualMethodRegr</a></code> -&gt; <code>RandomSearchRegr</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>optimizer</code></dt><dd><p>(<a href="bbotk.html#topic+OptimInstanceMultiCrit">OptimInstanceMultiCrit</a>) <br />
The object used for optimization.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RandomSearchRegr-new"><code>RandomSearchRegr$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RandomSearchRegr-plot_statistics"><code>RandomSearchRegr$plot_statistics()</code></a>
</p>
</li>
<li> <p><a href="#method-RandomSearchRegr-get_dominated_hv"><code>RandomSearchRegr$get_dominated_hv()</code></a>
</p>
</li>
<li> <p><a href="#method-RandomSearchRegr-plot_search"><code>RandomSearchRegr$plot_search()</code></a>
</p>
</li>
<li> <p><a href="#method-RandomSearchRegr-clone"><code>RandomSearchRegr$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="counterfactuals" data-topic="CounterfactualMethod" data-id="print"><a href='../../counterfactuals/html/CounterfactualMethod.html#method-CounterfactualMethod-print'><code>counterfactuals::CounterfactualMethod$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="counterfactuals" data-topic="CounterfactualMethodRegr" data-id="find_counterfactuals"><a href='../../counterfactuals/html/CounterfactualMethodRegr.html#method-CounterfactualMethodRegr-find_counterfactuals'><code>counterfactuals::CounterfactualMethodRegr$find_counterfactuals()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-RandomSearchRegr-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>RandomSearchRegr</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>RandomSearchRegr$new(
  predictor,
  fixed_features = NULL,
  max_changed = NULL,
  mu = 20L,
  n_generations = 175L,
  p_use_orig = 0.5,
  k = 1L,
  weights = NULL,
  lower = NULL,
  upper = NULL,
  distance_function = "gower"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>predictor</code></dt><dd><p>(<a href="iml.html#topic+Predictor">Predictor</a>)<br />
The object (created with <code>iml::Predictor$new()</code>) holding the machine learning model and the data.</p>
</dd>
<dt><code>fixed_features</code></dt><dd><p>(<code>character()</code> | <code>NULL</code>)<br />
Names of features that are not allowed to be changed. <code>NULL</code> (default) allows all features to be changed.</p>
</dd>
<dt><code>max_changed</code></dt><dd><p>(<code>integerish(1)</code> | <code>NULL</code>)<br />
Maximum number of feature changes. <code>NULL</code> (default) allows any number of changes.</p>
</dd>
<dt><code>mu</code></dt><dd><p>(<code>integerish(1)</code>)<br />
The population size. Default is <code>20L</code>. The total number of random samples is set to <code>mu * n_generations</code>.
See the <code>Details</code> section for further details.</p>
</dd>
<dt><code>n_generations</code></dt><dd><p>(<code>integerish(1)</code>)<br />
The number of generations. Default is <code>175L</code>. The total number of random samples is set to <code>mu * n_generations</code>.
See the <code>Details</code> section for further details.</p>
</dd>
<dt><code>p_use_orig</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Probability with which a feature/gene is reset to its original value in <code>x_interest</code> after random sampling. Default is <code>0.5</code>.</p>
</dd>
<dt><code>k</code></dt><dd><p>(<code>integerish(1)</code>)<br />
The number of data points to use for the forth objective. Default is <code>1L</code>.</p>
</dd>
<dt><code>weights</code></dt><dd><p>(<code>numeric(1) | numeric(k)</code> | <code>NULL</code>)<br />
The weights used to compute the weighted sum of dissimilarities for the forth objective. It is either a single value
or a vector of length <code>k</code>. If it has length <code>k</code>, the i-th element specifies the weight of the i-th closest data point.
The values should sum up to <code>1</code>. <code>NULL</code> (default) means all data points are weighted equally.</p>
</dd>
<dt><code>lower</code></dt><dd><p>(<code>numeric()</code> | <code>NULL</code>)<br />
Vector of minimum values for numeric features.
If <code>NULL</code> (default), the element for each numeric feature in <code>lower</code> is taken as its minimum value in <code>predictor$data$X</code>.
If not <code>NULL</code>, it should be named with the corresponding feature names.</p>
</dd>
<dt><code>upper</code></dt><dd><p>(<code>numeric()</code> | <code>NULL</code>)<br />
Vector of maximum values for numeric features.
If <code>NULL</code> (default), the element for each numeric feature in <code>upper</code> is taken as its maximum value in <code>predictor$data$X</code>.
If not <code>NULL</code>, it should be named with the corresponding feature names.</p>
</dd>
<dt><code>distance_function</code></dt><dd><p>(<code style="white-space: pre;">&#8288;function()&#8288;</code> | <code>'gower'</code> | <code>'gower_c'</code>)<br />
The distance function to be used in the second and fourth objective.
Either the name of an already implemented distance function
('gower' or 'gower_c') or a function.
If set to 'gower' (default), then Gower's distance (Gower 1971) is used;
if set to 'gower_c', a C-based more efficient version of Gower's distance is used.
A function must have three arguments  <code>x</code>, <code>y</code>, and <code>data</code> and should
return a <code>double</code> matrix with <code>nrow(x)</code> rows and maximum <code>nrow(y)</code> columns.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RandomSearchRegr-plot_statistics"></a>



<h4>Method <code>plot_statistics()</code></h4>

<p>Plots the evolution of the mean and minimum objective values together with the dominated hypervolume over
the generations. All values for a generation are computed based on all non-dominated individuals that emerged until
that generation. The randomly drawn samples are therefore split into <code>n_generations</code> folds of size <code>mu.</code>
This function mimics MOCs <code>plot_statistics()</code> method. See the <code>Details</code> section for further information.
</p>


<h5>Usage</h5>

<div class="r"><pre>RandomSearchRegr$plot_statistics(centered_obj = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>centered_obj</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should the objective values be centered? If set to <code>FALSE</code>, each objective value is visualized in a separate plot,
since they (usually) have different scales. If set to <code>TRUE</code> (default), they are visualized in a single plot.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RandomSearchRegr-get_dominated_hv"></a>



<h4>Method <code>get_dominated_hv()</code></h4>

<p>Calculates the dominated hypervolume of each generation. The randomly drawn samples are therefore split
into <code>n_generations</code> folds of size <code>mu.</code>
This function mimics MOCs <code>get_dominated_hv()</code> method. See the <code>Details</code> section for further information.
</p>


<h5>Usage</h5>

<div class="r"><pre>RandomSearchRegr$get_dominated_hv()</pre></div>



<h5>Returns</h5>

<p>A <code>data.table</code> with the dominated hypervolume of each generation.
</p>


<hr>
<a id="method-RandomSearchRegr-plot_search"></a>



<h4>Method <code>plot_search()</code></h4>

<p>Visualizes two selected objective values of all emerged individuals in a scatter plot.
The randomly drawn samples are therefore split into <code>n_generations</code> folds of size <code>mu.</code>
This function mimics MOCs <code>plot_search()</code> method. See the <code>Details</code> section for further information.
</p>


<h5>Usage</h5>

<div class="r"><pre>RandomSearchRegr$plot_search(objectives = c("dist_target", "dist_x_interest"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>objectives</code></dt><dd><p>(<code>character(2)</code>)<br />
The two objectives to be shown in the plot. Possible values are &quot;dist_target&quot;, &quot;dist_x_interest, &quot;no_changed&quot;,
and &quot;dist_train&quot;.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RandomSearchRegr-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RandomSearchRegr$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Dandl, S., Molnar, C., Binder, M., and Bischl, B. (2020).
&quot;Multi-Objective Counterfactual Explanations&quot;. In: Parallel Problem
Solving from Nature – PPSN XVI, edited by Thomas Bäck, Mike Preuss,
André Deutz, Hao Wang, Carola Doerr, Michael Emmerich, and Heike Trautmann, 448–469,
Cham, Springer International Publishing, <a href="https://doi.org/10.1007/978-3-030-58112-1_31">doi:10.1007/978-3-030-58112-1_31</a>.
</p>
<p>Deb, K., Pratap, A., Agarwal, S., &amp; Meyarivan, T. A. M. T. (2002).
&quot;A fast and elitist multiobjective genetic algorithm: NSGA-II&quot;.
IEEE transactions on evolutionary computation, 6(2), 182-197.
</p>
<p>Goldstein, A., Kapelner, A., Bleich, J., and Pitkin, E. (2015).
&quot;Peeking Inside the Black Box: Visualizing
Statistical Learning with Plots of Individual Conditional Expectation&quot;.
Journal of Computational and Graphical Statistics 24 (1): 44–65.
<a href="https://doi.org/10.1080/10618600.2014.907095">doi:10.1080/10618600.2014.907095</a>.
</p>
<p>Gower, J. C. (1971). A general coefficient of similarity and some of its properties. Biometrics, 27, 623–637.
</p>
<p>Li, Rui, L., Emmerich, M. T. M., Eggermont, J. Bäck, T., Schütz, M., Dijkstra, J., Reiber, J. H. C. (2013).
&quot;Mixed Integer Evolution Strategies for Parameter Optimization.&quot;
Evolutionary Computation 21 (1): 29–64. <a href="https://doi.org/10.1162/EVCO_a_00059">doi:10.1162/EVCO_a_00059</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("randomForest")) {
  # Train a model
  rf = randomForest(mpg ~ ., data = mtcars)
  # Create a predictor object
  predictor = iml::Predictor$new(rf)
  # Find counterfactuals for x_interest
  rs_regr = RandomSearchRegr$new(predictor, n_generations = 30L)
  cfactuals = rs_regr$find_counterfactuals(x_interest = mtcars[1L, ], desired_outcome = c(22, 26))
  # Print the counterfactuals
  cfactuals$data
  # Plot evolution of hypervolume and mean and minimum objective values 
  rs_regr$plot_statistics()
}

</code></pre>

<hr>
<h2 id='smallest_n_indices'>Returns the indices of the n smallest elements in a vector</h2><span id='topic+smallest_n_indices'></span>

<h3>Description</h3>

<p>Returns the indices of the n smallest elements in a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smallest_n_indices(x, n = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smallest_n_indices_+3A_x">x</code></td>
<td>
<p>(<code>numeric()</code>)<br />
A numeric vector.</p>
</td></tr>
<tr><td><code id="smallest_n_indices_+3A_n">n</code></td>
<td>
<p>(<code>numeric(1)</code>)<br />
A integer indicating how many elements should be returned</p>
</td></tr>
</table>

<hr>
<h2 id='WhatIfClassif'>WhatIf for Classification Tasks</h2><span id='topic+WhatIfClassif'></span>

<h3>Description</h3>

<p>WhatIf returns the <code>n_counterfactual</code> most similar observations to <code>x_interest</code> from observations in <code>predictor$data$X</code>
whose prediction for the <code>desired_class</code> is in the <code>desired_prob</code> interval.
</p>


<h3>Details</h3>

<p>By default, the dissimilarities are computed using Gower's dissimilarity measure (Gower 1971). <br />
Only observations whose features values lie between the corresponding values in <code>lower</code> and <code>upper</code> are considered
counterfactual candidates.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+CounterfactualMethod">counterfactuals::CounterfactualMethod</a></code> -&gt; <code><a href="#topic+CounterfactualMethodClassif">counterfactuals::CounterfactualMethodClassif</a></code> -&gt; <code>WhatIfClassif</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-WhatIfClassif-new"><code>WhatIfClassif$new()</code></a>
</p>
</li>
<li> <p><a href="#method-WhatIfClassif-clone"><code>WhatIfClassif$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="counterfactuals" data-topic="CounterfactualMethod" data-id="print"><a href='../../counterfactuals/html/CounterfactualMethod.html#method-CounterfactualMethod-print'><code>counterfactuals::CounterfactualMethod$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="counterfactuals" data-topic="CounterfactualMethodClassif" data-id="find_counterfactuals"><a href='../../counterfactuals/html/CounterfactualMethodClassif.html#method-CounterfactualMethodClassif-find_counterfactuals'><code>counterfactuals::CounterfactualMethodClassif$find_counterfactuals()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-WhatIfClassif-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new WhatIfClassif object.
</p>


<h5>Usage</h5>

<div class="r"><pre>WhatIfClassif$new(
  predictor,
  n_counterfactuals = 1L,
  lower = NULL,
  upper = NULL,
  distance_function = "gower"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>predictor</code></dt><dd><p>(<a href="iml.html#topic+Predictor">Predictor</a>)<br />
The object (created with <code>iml::Predictor$new()</code>) holding the machine learning model and the data.</p>
</dd>
<dt><code>n_counterfactuals</code></dt><dd><p>(<code>integerish(1)</code>)<br />
The number of counterfactuals to return. Default is <code>1L</code>.</p>
</dd>
<dt><code>lower</code></dt><dd><p>(<code>numeric()</code> | <code>NULL</code>)<br />
Vector of minimum values for numeric features.
If <code>NULL</code> (default), the element for each numeric feature in <code>lower</code> is taken as its minimum value in <code>predictor$data$X</code>.
If not <code>NULL</code>, it should be named with the corresponding feature names.</p>
</dd>
<dt><code>upper</code></dt><dd><p>(<code>numeric()</code> | <code>NULL</code>)<br />
Vector of maximum values for numeric features.
If <code>NULL</code> (default), the element for each numeric feature in <code>upper</code> is taken as its maximum value in <code>predictor$data$X</code>.
If not <code>NULL</code>, it should be named with the corresponding feature names.</p>
</dd>
<dt><code>distance_function</code></dt><dd><p>(<code style="white-space: pre;">&#8288;function()&#8288;</code> | <code>'gower'</code> | <code>'gower_c'</code>)<br />
The distance function used to compute the distances between <code>x_interest</code>
and the training data points for finding <code>x_nn</code>.
Either the name of an already implemented distance function
('gower' or 'gower_c') or a function.
If set to 'gower' (default), then Gower's distance (Gower 1971) is used;
if set to 'gower_c', a C-based more efficient version of Gower's distance is used.
A function must have three arguments  <code>x</code>, <code>y</code>, and <code>data</code> and should
return a <code>double</code> matrix with <code>nrow(x)</code> rows and maximum <code>nrow(y)</code> columns.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-WhatIfClassif-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>WhatIfClassif$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Gower, J. C. (1971), &quot;A general coefficient of similarity and some of its properties&quot;. Biometrics, 27, 623–637.
</p>
<p>Wexler, J., Pushkarna, M., Bolukbasi, T., Wattenberg, M., Viégas, F., &amp; Wilson, J. (2019). The what-if tool:
Interactive probing of machine learning models. IEEE transactions on visualization and computer graphics, 26(1), 56–65.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("randomForest")) {
  # Train a model
  rf = randomForest(Species ~ ., data = iris)
  # Create a predictor object
  predictor = iml::Predictor$new(rf, type = "prob")
  # Find counterfactuals for x_interest
  wi_classif = WhatIfClassif$new(predictor, n_counterfactuals = 5L)
  cfactuals = wi_classif$find_counterfactuals(
    x_interest = iris[150L, ], desired_class = "versicolor", desired_prob = c(0.5, 1)
  )
  # Print the results
  cfactuals$data
}

</code></pre>

<hr>
<h2 id='WhatIfRegr'>WhatIf for Regression Tasks</h2><span id='topic+WhatIfRegr'></span>

<h3>Description</h3>

<p>WhatIf returns the <code>n_counterfactual</code> most similar observations to <code>x_interest</code> from observations in <code>predictor$data$X</code>
whose prediction is in the <code>desired_outcome</code> interval.
</p>


<h3>Details</h3>

<p>Only observations whose features values lie between the corresponding values in <code>lower</code> and <code>upper</code> are considered
counterfactual candidates.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+CounterfactualMethod">counterfactuals::CounterfactualMethod</a></code> -&gt; <code><a href="#topic+CounterfactualMethodRegr">counterfactuals::CounterfactualMethodRegr</a></code> -&gt; <code>WhatIfRegr</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-WhatIfRegr-new"><code>WhatIfRegr$new()</code></a>
</p>
</li>
<li> <p><a href="#method-WhatIfRegr-clone"><code>WhatIfRegr$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="counterfactuals" data-topic="CounterfactualMethod" data-id="print"><a href='../../counterfactuals/html/CounterfactualMethod.html#method-CounterfactualMethod-print'><code>counterfactuals::CounterfactualMethod$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="counterfactuals" data-topic="CounterfactualMethodRegr" data-id="find_counterfactuals"><a href='../../counterfactuals/html/CounterfactualMethodRegr.html#method-CounterfactualMethodRegr-find_counterfactuals'><code>counterfactuals::CounterfactualMethodRegr$find_counterfactuals()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-WhatIfRegr-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new WhatIfRegr object.
</p>


<h5>Usage</h5>

<div class="r"><pre>WhatIfRegr$new(
  predictor,
  n_counterfactuals = 1L,
  lower = NULL,
  upper = NULL,
  distance_function = "gower"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>predictor</code></dt><dd><p>(<a href="iml.html#topic+Predictor">Predictor</a>)<br />
The object (created with <code>iml::Predictor$new()</code>) holding the machine learning model and the data.</p>
</dd>
<dt><code>n_counterfactuals</code></dt><dd><p>(<code>integerish(1)</code>)<br />
The number of counterfactuals to return Default is <code>1L</code>.</p>
</dd>
<dt><code>lower</code></dt><dd><p>(<code>numeric()</code> | <code>NULL</code>)<br />
Vector of minimum values for numeric features.
If <code>NULL</code> (default), the element for each numeric feature in <code>lower</code> is taken as its minimum value in <code>predictor$data$X</code>.
If not <code>NULL</code>, it should be named with the corresponding feature names.</p>
</dd>
<dt><code>upper</code></dt><dd><p>(<code>numeric()</code> | <code>NULL</code>)<br />
Vector of maximum values for numeric features.
If <code>NULL</code> (default), the element for each numeric feature in <code>upper</code> is taken as its maximum value in <code>predictor$data$X</code>.
If not <code>NULL</code>, it should be named with the corresponding feature names.</p>
</dd>
<dt><code>distance_function</code></dt><dd><p>(<code style="white-space: pre;">&#8288;function()&#8288;</code> | <code>'gower'</code> | <code>'gower_c'</code>)<br />
The distance function used to compute the distances between <code>x_interest</code>
and the training data points for finding <code>x_nn</code>.
Either the name of an already implemented distance function
('gower' or 'gower_c') or a function.
If set to 'gower' (default), then Gower's distance (Gower 1971) is used;
if set to 'gower_c', a C-based more efficient version of Gower's distance is used.
A function must have three arguments  <code>x</code>, <code>y</code>, and <code>data</code> and should
return a <code>double</code> matrix with <code>nrow(x)</code> rows and maximum <code>nrow(y)</code> columns.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-WhatIfRegr-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>WhatIfRegr$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Gower, J. C. (1971), &quot;A general coefficient of similarity and some of its properties&quot;. Biometrics, 27, 623–637.
</p>
<p>Wexler, J., Pushkarna, M., Bolukbasi, T., Wattenberg, M., Viégas, F., &amp; Wilson, J. (2019). The what-if tool:
Interactive probing of machine learning models. IEEE transactions on visualization and computer graphics, 26(1), 56–65.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("randomForest")) {
  set.seed(123456)
  # Train a model
  rf = randomForest(mpg ~ ., data = mtcars)
  # Create a predictor object
  predictor = iml::Predictor$new(rf)
  # Find counterfactuals for x_interest
  wi_regr = WhatIfRegr$new(predictor, n_counterfactuals = 5L)
  cfactuals = wi_regr$find_counterfactuals(
    x_interest = mtcars[1L, ], desired_outcome = c(22, 26)
  )
  # Print the results
  cfactuals
}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
