<!DOCTYPE html><html lang="en"><head><title>Help for package goric</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {goric}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#constrMat'><p>Generate Constraint Matrices</p></a></li>
<li><a href='#constrSet'><p>Generate Constraint Sets</p></a></li>
<li><a href='#goric'><p>Calculate GORIC</p></a></li>
<li><a href='#goric_penalty'><p>GORIC penalty term</p></a></li>
<li><a href='#orglm'><p>Fitting Order-Restricted Generalised Linear Models</p></a></li>
<li><a href='#orgls'><p>Fitting generalized least squares regression models with order restrictions</p></a></li>
<li><a href='#orglsSet'><p>Set of generalised least-squares models</p></a></li>
<li><a href='#orlm'><p>Fitting multivariate regression models with order restrictions</p></a></li>
<li><a href='#orlmcontrol'><p>Control arguments for the orlm function.</p></a></li>
<li><a href='#orlmSet'><p>Set of multivariate regression models</p></a></li>
<li><a href='#sim'><p>Simulation from order restricted linear models</p></a></li>
<li><a href='#vinylidene'><p>Effect of vinylidene fluoride on liver cancer</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized Order-Restricted Information Criterion</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-04-19</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Gerhard &lt;00gerhard@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Generalized Order-Restricted Information Criterion (GORIC) value for a set of hypotheses in multivariate linear models and generalised linear models.</td>
</tr>
<tr>
<td>Depends:</td>
<td>nlme</td>
</tr>
<tr>
<td>Imports:</td>
<td>quadprog, mvtnorm, MASS, Matrix, parallel</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-04-18 22:48:34 UTC; daniel</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Gerhard [aut, cre],
  Rebecca M. Kuiper [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-04-19 15:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='constrMat'>Generate Constraint Matrices</h2><span id='topic+constrMat'></span>

<h3>Description</h3>

<p>Generate a constraint matrix with a predefined structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constrMat(n, type = c("monotone", "control", "average", "laverage",
  "uaverage", "caverage"), base = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="constrMat_+3A_n">n</code></td>
<td>
<p>a (possibly named) vector of sample sizes for each group</p>
</td></tr>
<tr><td><code id="constrMat_+3A_type">type</code></td>
<td>
<p>character string defining the type of constraints; one of &quot;monotone&quot;, &quot;control&quot;,&quot;average&quot;,&quot;laverage&quot;,&quot;uaverage&quot;, or &quot;caverage&quot;</p>
</td></tr>
<tr><td><code id="constrMat_+3A_base">base</code></td>
<td>
<p>column of the constraint matrix representing a control group (when type = &quot;control&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a constraint matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orlm">orlm</a></code>, <code><a href="#topic+constrSet">constrSet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- c(10,20,30,40)
constrMat(n, type="monotone")
constrMat(n, type="control", base=2)
constrMat(n, type="average")
constrMat(n, type="laverage")
constrMat(n, type="uaverage")
constrMat(n, type="caverage", base=2)
</code></pre>

<hr>
<h2 id='constrSet'>Generate Constraint Sets</h2><span id='topic+constrSet'></span>

<h3>Description</h3>

<p>Generate sets of constraint matrices (constr), right hand side elements, and numbers of equality constraints (nec) with a predefined structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constrSet(n, set = c("sequence", "seqcontrol", "lplateau", "uplateau",
  "downturn", "williams"), direction = c("increase", "decrease"), base = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="constrSet_+3A_n">n</code></td>
<td>
<p>a (possibly named) vector of sample sizes for each group.</p>
</td></tr>
<tr><td><code id="constrSet_+3A_set">set</code></td>
<td>
<p>character string defining the type of constraints; one of &quot;sequence&quot;, &quot;seqcontrol&quot;, &quot;lplateau&quot;, &quot;uplateau&quot;, or &quot;downturn&quot;</p>
</td></tr>
<tr><td><code id="constrSet_+3A_direction">direction</code></td>
<td>
<p>direction of the inequality constraints, either &quot;increase&quot; or &quot;decrease&quot;</p>
</td></tr>
<tr><td><code id="constrSet_+3A_base">base</code></td>
<td>
<p>column of the constraint matrix representing a control group</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with slots constr, rhs, and nec for each constraint definition
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orlm">orlm</a></code>, <code><a href="#topic+constrMat">constrMat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- c(10,20,30,40)
constrSet(n, set="sequence")
constrSet(n, set="seqcontrol")
constrSet(n, set="lplateau")
constrSet(n, set="uplateau")
constrSet(n, set="downturn")
constrSet(n, set="williams")
</code></pre>

<hr>
<h2 id='goric'>Calculate GORIC</h2><span id='topic+goric'></span><span id='topic+goric.orlm'></span><span id='topic+goric.orgls'></span><span id='topic+goric.list'></span><span id='topic+goric.orglm'></span>

<h3>Description</h3>

<p>The goric function calculates the order-restricted log likelihood, the penalty of the generalised order restricted information criterion (GORIC), the GORIC values, differences to the minimum GORIC value, and the GORIC weights for a set of hypotheses, where the penalty is based on <code class="reqn">iter</code> iterations.
The hypothesis with the lowest GORIC value is the preferred one. 
The GORIC weights reflect the support of each hypothesis in the set. To compare two hypotheses (and not one to the whole set), one should examine the ratio of the two corresponding GORIC weights.
To safequard for weak hypotheses (i.e., hypotheses not supported by the data), one should include a model with no constraints (the so-called unconstrained model).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>goric(object, ..., iter = 1e+05, type = "GORIC", dispersion = 1,
  mc.cores = 1)

## S3 method for class 'orlm'
goric(object, ..., iter = 1e+05, type = "GORIC",
  mc.cores = 1)

## S3 method for class 'orgls'
goric(object, ..., iter = 1e+05, type = "GORIC",
  mc.cores = 1)

## S3 method for class 'list'
goric(object, ..., iter = 1e+05, type = "GORIC",
  dispersion = 1, mc.cores = 1)

## S3 method for class 'orglm'
goric(object, ..., iter = 1e+05, type = "GORIC",
  dispersion = 1, mc.cores = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="goric_+3A_object">object</code></td>
<td>
<p>an object of class orlm, orgls, orglm, or a list of these objects</p>
</td></tr>
<tr><td><code id="goric_+3A_...">...</code></td>
<td>
<p>further objects of class orlm, orgls, or orglm</p>
</td></tr>
<tr><td><code id="goric_+3A_iter">iter</code></td>
<td>
<p>number of iterations to calculate GORIC penalty terms</p>
</td></tr>
<tr><td><code id="goric_+3A_type">type</code></td>
<td>
<p>if <code>"GORIC"</code> (default), the penalty term for the generalized order restriction information criterion is computed; with <code>"GORICCa"</code> or <code>"GORICCb"</code> small sample corrections for the penalty term are applied</p>
</td></tr>
<tr><td><code id="goric_+3A_dispersion">dispersion</code></td>
<td>
<p>dispersion parameter to scale GORIC analogously to QAIC in generalized linear models</p>
</td></tr>
<tr><td><code id="goric_+3A_mc.cores">mc.cores</code></td>
<td>
<p>number of cores using a socket cluster implemented in package <code>parallel</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with the information criteria or a single penalty term
</p>


<h3>References</h3>


<ul>
<li><p> Kuiper R.M., Hoijtink H., Silvapulle M.J. (2011). An Akaike-type Information Criterion for Model Selection Under Inequality Constraints. <em>Biometrika</em>, <b>98</b>, 495&ndash;501.
</p>
</li>
<li><p> Kuiper R.M., Hoijtink H., Silvapulle M.J. (2012). Generalization of the Order-Restricted Information Criterion for Multivariate Normal Linear Models. <em>Journal of Statistical Planning and Inference</em>, <b>142</b>, 2454-2463. doi:10.1016/j.jspi.2012.03.007.
</p>
</li>
<li><p> Kuiper R.M. and Hoijtink H. (submitted). A Fortran 90 Program for the Generalization of the Order-Restricted Information Criterion. Journal of Statictical Software.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+orlm">orlm</a></code>, <code><a href="#topic+orgls">orgls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Kuiper, R.M. and Hoijtink, H. (Unpublished).
# A Fortran 90 program for the generalization of the 
# order restricted information criterion.
# constraint definition
cmat &lt;- cbind(diag(3), 0) + cbind(0, -diag(3))
constr &lt;- kronecker(diag(3), cmat)
constr

# no effect model
(fm0 &lt;- orlm(cbind(SDH, SGOT, SGPT) ~ dose-1, data=vinylidene,
            constr=constr, rhs=rep(0, nrow(constr)), nec=nrow(constr)))

# order constrained model (increasing serum levels with increasing doses)
fm1 &lt;- orlm(cbind(SDH, SGOT, SGPT) ~ dose-1, data=vinylidene,
            constr=constr, rhs=rep(0, nrow(constr)), nec=0)
summary(fm1)

# unconstrained model
(fmunc &lt;- orlm(cbind(SDH, SGOT, SGPT) ~ dose-1, data=vinylidene,
              constr=matrix(0, nrow=1, ncol=12), rhs=0, nec=0))

# calculate GORIC
# (only small number of iterations to decrease computation time, default: iter=100000)
goric(fm0, fm1, fmunc, iter=1000)
</code></pre>

<hr>
<h2 id='goric_penalty'>GORIC penalty term</h2><span id='topic+goric_penalty'></span><span id='topic+orglm_penalty'></span>

<h3>Description</h3>

<p>Calculates the GORIC penalty term (level probability) by Monte-Carlo simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>goric_penalty(object, iter = 1e+05, type = "GORIC", mc.cores = 1)

orglm_penalty(object, iter = 1e+05, type = "GORIC", mc.cores = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="goric_penalty_+3A_object">object</code></td>
<td>
<p>an object of class orlm, orgls (or orglm for function <code>orglm_penalty</code>)</p>
</td></tr>
<tr><td><code id="goric_penalty_+3A_iter">iter</code></td>
<td>
<p>number of iterations to calculate GORIC penalty terms</p>
</td></tr>
<tr><td><code id="goric_penalty_+3A_type">type</code></td>
<td>
<p>if <code>"GORIC"</code> (default), the penalty term for the generalized order restriction information criterion is computed; with <code>"GORICCa"</code> or <code>"GORICCb"</code> small sample corrections for the penalty term are applied</p>
</td></tr>
<tr><td><code id="goric_penalty_+3A_mc.cores">mc.cores</code></td>
<td>
<p>number of cores using a socket cluster implemented in package <code>parallel</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+orlm">orlm</a></code>, <code><a href="#topic+orgls">orgls</a></code>, <code><a href="#topic+orglm">orglm</a></code>
</p>

<hr>
<h2 id='orglm'>Fitting Order-Restricted Generalised Linear Models</h2><span id='topic+orglm'></span><span id='topic+orglm.fit'></span>

<h3>Description</h3>

<p><code>orglm</code> is used to fit generalised linear models with restrictions on the parameters, specified by giving a description of the linear predictor, a description of the error distribution, and a description of a matrix with linear constraints. The <code>quadprog</code> package is used to apply linear constraints on the parameter vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orglm(formula, family = gaussian, data, weights, subset, na.action,
  start = NULL, etastart, mustart, offset, control = list(...),
  model = TRUE, method = "orglm.fit", x = FALSE, y = TRUE,
  contrasts = NULL, constr, rhs, nec, ...)

orglm.fit(x, y, weights = rep(1, nobs), start = NULL, etastart = NULL,
  mustart = NULL, offset = rep(0, nobs), family = gaussian(),
  control = list(), intercept = TRUE, constr, rhs, nec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orglm_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>"<a href="stats.html#topic+formula">formula</a>"</code> (or one that can be coerced to that class): a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="orglm_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to be used in the model. This can be a character string naming a family function, a family function or the result of a call to a family function.  (See <code><a href="stats.html#topic+family">family</a></code> for details of family functions.)</p>
</td></tr>
<tr><td><code id="orglm_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the variables in the model. If not found in <code>data</code>, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>orglm</code> is called.</p>
</td></tr>
<tr><td><code id="orglm_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;prior weights&rsquo; to be used in the fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="orglm_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="orglm_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data contain <code>NA</code>s.  The default is set by the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, and is <code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset. The &lsquo;factory-fresh&rsquo; default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>.  Another possible value is <code>NULL</code>, no action.  Value <code><a href="stats.html#topic+na.exclude">na.exclude</a></code> can be useful.</p>
</td></tr>
<tr><td><code id="orglm_+3A_start">start</code></td>
<td>
<p>starting values for the parameters in the linear predictor.</p>
</td></tr>
<tr><td><code id="orglm_+3A_etastart">etastart</code></td>
<td>
<p>starting values for the linear predictor.</p>
</td></tr>
<tr><td><code id="orglm_+3A_mustart">mustart</code></td>
<td>
<p>starting values for the vector of means.</p>
</td></tr>
<tr><td><code id="orglm_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known component to be included in the linear predictor during fitting. This should be <code>NULL</code> or a numeric vector of length equal to the number of cases. One or more <code><a href="stats.html#topic+offset">offset</a></code> terms can be included in the formula instead or as well, and if more than one is specified their sum is used. See <code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="orglm_+3A_control">control</code></td>
<td>
<p>a list of parameters for controlling the fitting process. For <code>orglm</code> this is passed to <code><a href="stats.html#topic+glm.control">glm.control</a></code>.</p>
</td></tr>
<tr><td><code id="orglm_+3A_model">model</code></td>
<td>
<p>a logical value indicating whether <em>model frame</em> should be included as a component of the returned value.</p>
</td></tr>
<tr><td><code id="orglm_+3A_method">method</code></td>
<td>
<p>the method to be used in fitting the model. The default method <code>"orglm.fit"</code> uses iteratively reweighted least squares with a quadradic programming step included at each iteration.</p>
</td></tr>
<tr><td><code id="orglm_+3A_x">x</code></td>
<td>
<p>is a design matrix of dimension <code>n * p</code></p>
</td></tr>
<tr><td><code id="orglm_+3A_y">y</code></td>
<td>
<p>is a vector of observations of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="orglm_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code> of <code>model.matrix.default</code>.</p>
</td></tr>
<tr><td><code id="orglm_+3A_constr">constr</code></td>
<td>
<p>a matrix with linear constraints. The columns of this matrix should correspond to the columns of the design matrix.</p>
</td></tr>
<tr><td><code id="orglm_+3A_rhs">rhs</code></td>
<td>
<p>right hand side of the linear constraint formulation. A numeric vector with a length corresponding to the rows of <code>constr</code>.</p>
</td></tr>
<tr><td><code id="orglm_+3A_nec">nec</code></td>
<td>
<p>Number of equality constrints. The first <code>nec</code> constraints defined in <code>constr</code> are treated as equality constraints; the remaining ones are inequality constraints.</p>
</td></tr>
<tr><td><code id="orglm_+3A_...">...</code></td>
<td>
<p>For <code>orglm</code>: arguments to be used to form the default <code>control</code> argument if it is not supplied directly.</p>
</td></tr>
<tr><td><code id="orglm_+3A_intercept">intercept</code></td>
<td>
<p>logical. Should an intercept be included in the <em>null</em> model?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Non-<code>NULL</code> <code>weights</code> can be used to indicate that different observations have different dispersions (with the values in <code>weights</code> being inversely proportional to the dispersions); or equivalently, when the elements of <code>weights</code> are positive integers <code class="reqn">w_i</code>, that each response <code class="reqn">y_i</code> is the mean of <code class="reqn">w_i</code> unit-weight observations.  For a binomial GLM prior weights are used to give the number of trials when the response is the proportion of successes: they would rarely be used for a Poisson GLM.
If more than one of <code>etastart</code>, <code>start</code> and <code>mustart</code> is specified, the first in the list will be used.  It is often advisable to supply starting values for a <code><a href="stats.html#topic+quasi">quasi</a></code> family, and also for families with unusual links such as <code>gaussian("log")</code>.
For the background to warning messages about &lsquo;fitted probabilities numerically 0 or 1 occurred&rsquo; for binomial GLMs, see Venables &amp; Ripley (2002, pp. 197&ndash;8).
</p>


<h3>Value</h3>

<p>An object of class <code>"orglm"</code> is a list containing at least the following components:
</p>

<dl>
<dt>coefficients</dt><dd><p>a named vector of coefficients</p>
</dd>
<dt>residuals</dt><dd><p>the <em>working</em> residuals, that is the residuals in the final iteration of the IWLS fit. Since cases with zero weights are omitted, their working residuals are <code>NA</code>.</p>
</dd>
<dt>fitted.values</dt><dd><p>the fitted mean values, obtained by transforming the linear predictors by the inverse of the link function.</p>
</dd>
<dt>rank</dt><dd><p>the numeric rank of the fitted linear model.</p>
</dd>
<dt>family</dt><dd><p>the <code><a href="stats.html#topic+family">family</a></code> object used.</p>
</dd>
<dt>linear.predictors</dt><dd><p>the linear fit on link scale.</p>
</dd>
<dt>deviance</dt><dd><p>up to a constant, minus twice the maximized log-likelihood.  Where sensible, the constant is chosen so that a saturated model has deviance zero.</p>
</dd>
<dt>null.deviance</dt><dd><p>The deviance for the null model, comparable with <code>deviance</code>. The null model will include the offset, and an intercept if there is one in the model. Note that this will be incorrect if the link function depends on the data other than through the fitted mean: specify a zero offset to force a correct calculation.</p>
</dd>
<dt>iter</dt><dd><p>the number of iterations of IWLS used.</p>
</dd>
<dt>weights</dt><dd><p>the <em>working</em> weights, that is the weights in the final iteration of the IWLS fit.</p>
</dd>
<dt>prior.weights</dt><dd><p>the weights initially supplied, a vector of <code>1</code>s if none were.</p>
</dd>
<dt>df.residual</dt><dd><p>the residual degrees of freedom of the unconstrained model.</p>
</dd>
<dt>df.null</dt><dd><p>the residual degrees of freedom for the null model.</p>
</dd>
<dt>y</dt><dd><p>if requested (the default) the <code>y</code> vector used. (It is a vector even for a binomial model.)</p>
</dd>
<dt>converged</dt><dd><p>logical. Was the IWLS algorithm judged to have converged?</p>
</dd>
<dt>boundary</dt><dd><p>logical. Is the fitted value on the boundary of the attainable values?</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Modification of the original glm.fit by Daniel Gerhard.
The original <span class="rlang"><b>R</b></span> implementation of <code>glm</code> was written by Simon Davies working for Ross Ihaka at the University of Auckland, but has since been extensively re-written by members of the R Core team.
The design was inspired by the S function of the same name described in Hastie &amp; Pregibon (1992).
</p>


<h3>References</h3>


<ul>
<li><p> Dobson, A. J. (1990) <em>An Introduction to Generalized Linear Models.</em> London: Chapman and Hall.
</p>
</li>
<li><p> Hastie, T. J. and Pregibon, D. (1992) <em>Generalized linear models.</em> Chapter 6 of <em>Statistical Models in S</em> eds J. M. Chambers and T. J. Hastie, Wadsworth &amp; Brooks//Cole.
</p>
</li>
<li><p> McCullagh P. and Nelder, J. A. (1989) <em>Generalized Linear Models.</em> London: Chapman and Hall.
</p>
</li>
<li><p> Venables, W. N. and Ripley, B. D. (2002) <em>Modern Applied Statistics with S.</em> New York: Springer.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="quadprog.html#topic+solve.QP">solve.QP</a></code>
</p>

<hr>
<h2 id='orgls'>Fitting generalized least squares regression models with order restrictions</h2><span id='topic+orgls'></span><span id='topic+orgls.formula'></span>

<h3>Description</h3>

<p><code>orgls</code> is used to fit generalised least square models analogously to the function <code>gls</code> in package <code>nlme</code> but with order restrictions on the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orgls(formula, data, constr, rhs, nec, weights = NULL, correlation = NULL,
  control = orlmcontrol())

## S3 method for class 'formula'
orgls(formula, data, constr, rhs, nec, weights = NULL,
  correlation = NULL, control = orlmcontrol())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orgls_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that can be coerced to that class): a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="orgls_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by as.data.frame to a data frame) containing the variables in the model. If not found in data, the variables are taken from environment(formula), typically the environment from which orgls is called.</p>
</td></tr>
<tr><td><code id="orgls_+3A_constr">constr</code></td>
<td>
<p>matrix with constraints; with rows as constraint definition, columns should be in line with the parameters of the model</p>
</td></tr>
<tr><td><code id="orgls_+3A_rhs">rhs</code></td>
<td>
<p>vector of right hand side elements; <code class="reqn">Constr \; \theta \geq rhs</code>; number should equal the number of rows of the constr matrix</p>
</td></tr>
<tr><td><code id="orgls_+3A_nec">nec</code></td>
<td>
<p>number of equality constraints; a numeric value treating the first nec constr rows as equality constraints, or a logical vector with <code>TRUE</code> for equality- and <code>FALSE</code> for inequality constraints.</p>
</td></tr>
<tr><td><code id="orgls_+3A_weights">weights</code></td>
<td>
<p>a <code><a href="nlme.html#topic+varClasses">varClasses</a></code> object; more details are provided on the help pages in R package <code>nlme</code></p>
</td></tr>
<tr><td><code id="orgls_+3A_correlation">correlation</code></td>
<td>
<p>a <code><a href="nlme.html#topic+corClasses">corClasses</a></code> object; more details are provided on the help pages in R package <code>nlme</code></p>
</td></tr>
<tr><td><code id="orgls_+3A_control">control</code></td>
<td>
<p>a list of control arguments; see <code><a href="#topic+orlmcontrol">orlmcontrol</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The contraints in the hypothesis of interest are defined by <code class="reqn">constr</code>, <code class="reqn">rhs</code>, and <code class="reqn">nec</code>. The first <code class="reqn">nec</code> constraints are the equality contraints: <code class="reqn">Constr[1:nec, 1:tk] \theta = rhs[1:nec]</code>; and the remaing ones are the inequality contraints: <code class="reqn">Constr[nec+1:c_m, 1:tk] \theta \geq rhs[nec+1:c_m]</code>.
Two requirements should be met:
</p>

<ol>
<li><p> The first <code class="reqn">nec</code> constraints must be the equality contraints (i.e., <code class="reqn">Constr[1:nec, 1:tk] \theta = rhs[1:nec]</code>) and the remaining ones the inequality contraints (i.e., <code class="reqn">Constr[nec+1:c_m, 1:tk] \theta \geq rhs[nec+1:c_m]</code>).
</p>
</li>
<li><p> When <code class="reqn">rhs</code> is not zero, <code class="reqn">Constr</code> should be of full rank (after discarding redundant restrictions).
</p>
</li></ol>



<h3>Value</h3>

<p>an object of class orgls
</p>


<h3>References</h3>


<ul>
<li><p> Kuiper R.M., Hoijtink H., Silvapulle M.J. (2011). An Akaike-type Information Criterion for Model Selection Under Inequality Constraints. <em>Biometrika</em>, <b>98</b>, 495&ndash;501.
</p>
</li>
<li><p> Kuiper R.M., Hoijtink H., Silvapulle M.J. (2012). Generalization of the Order-Restricted Information Criterion for Multivariate Normal Linear Models. <em>Journal of Statistical Planning and Inference</em>, <b>142</b>, 2454-2463. doi:10.1016//j.jspi.2012.03.007.
</p>
</li>
<li><p> Kuiper R.M. and Hoijtink H. (submitted). A Fortran 90 Program for the Generalization of the Order-Restricted Information Criterion. Journal of Statictical Software.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="quadprog.html#topic+solve.QP">solve.QP</a></code>, <code><a href="#topic+goric">goric</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generating example data
library(mvtnorm)
# group means
m &lt;- c(0,5,5,7)
# compound symmetry structure of residuals
# (10 individuals per group, rho=0.7) 
cormat &lt;- kronecker(diag(length(m)*10), matrix(0.7, nrow=length(m), ncol=length(m)))
diag(cormat) &lt;- 1
# different variances per group
sds &lt;- rep(c(1,2,0.5,1), times=10*length(m))
sigma &lt;- crossprod(diag(sds), crossprod(cormat, diag(sds)))
response &lt;- as.vector(rmvnorm(1, rep(m, times=10*length(m)), sigma=sigma))
dat &lt;- data.frame(response,
                  grp=rep(LETTERS[1:length(m)], times=10*length(m)), 
                  ID=as.factor(rep(1:(10*length(m)), each=length(m))))
                  
## set of gls models:
# unconstrained model
m1 &lt;- orgls(response ~ grp-1, data = dat,
            constr=rbind(c(0,0,0,0)), rhs=0, nec=0,
            weights=varIdent(form=~1|grp),
            correlation=corCompSymm(form=~1|ID))

# simple order
m2 &lt;- orgls(response ~ grp-1, data = dat,
            constr=rbind(c(-1,1,0,0),c(0,-1,1,0),c(0,0,-1,1)), rhs=c(0,0,0), nec=0,
            weights=varIdent(form=~1|grp),
            correlation=corCompSymm(form=~1|ID))

# equality constraints
m3 &lt;- orgls(response ~ grp-1, data = dat,
            constr=rbind(c(-1,1,0,0),c(0,-1,1,0),c(0,0,-1,1)), rhs=c(0,0,0), nec=3,
            weights=varIdent(form=~1|grp),
            correlation=corCompSymm(form=~1|ID))
</code></pre>

<hr>
<h2 id='orglsSet'>Set of generalised least-squares models</h2><span id='topic+orglsSet'></span>

<h3>Description</h3>

<p>Fitting a specific set of generalisd least-squares models with order restrictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orglsSet(formula, data, weights = NULL, correlation = NULL, set,
  direction = "increase", n = NULL, base = 1, control = orlmcontrol())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orglsSet_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that can be coerced to that class): a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="orglsSet_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by as.data.frame to a data frame) containing the variables in the model. If not found in data, the variables are taken from environment(formula), typically the environment from which lm is called.</p>
</td></tr>
<tr><td><code id="orglsSet_+3A_weights">weights</code></td>
<td>
<p>a <code><a href="nlme.html#topic+varClasses">varClasses</a></code> object; more details are provided on the help pages in R package <code>nlme</code></p>
</td></tr>
<tr><td><code id="orglsSet_+3A_correlation">correlation</code></td>
<td>
<p>a <code><a href="nlme.html#topic+corClasses">corClasses</a></code> object; more details are provided on the help pages in R package <code>nlme</code></p>
</td></tr>
<tr><td><code id="orglsSet_+3A_set">set</code></td>
<td>
<p>either a character string (see <code><a href="#topic+constrSet">constrSet</a></code>), or a list with slots for constr, rhs, and nec similarly defined as in <code><a href="#topic+orlm">orlm</a></code></p>
</td></tr>
<tr><td><code id="orglsSet_+3A_direction">direction</code></td>
<td>
<p>direction of the order constraints</p>
</td></tr>
<tr><td><code id="orglsSet_+3A_n">n</code></td>
<td>
<p>a (possibly named) vector of sample sizes for each group</p>
</td></tr>
<tr><td><code id="orglsSet_+3A_base">base</code></td>
<td>
<p>column of the constraint matrix representing a control group</p>
</td></tr>
<tr><td><code id="orglsSet_+3A_control">control</code></td>
<td>
<p>a list of control arguments; see <code><a href="#topic+orlmcontrol">orlmcontrol</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is just a wrapper for repeated calls of <code><a href="#topic+orgls">orgls</a></code> with different constraint definitions. Predefined lists with constraint-sets can be constructed with function <code><a href="#topic+constrSet">constrSet</a></code>.
</p>


<h3>Value</h3>

<p>a list with orgls objects
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orgls">orgls</a></code>, <code><a href="#topic+constrSet">constrSet</a></code>, <code><a href="#topic+goric">goric</a></code>
</p>

<hr>
<h2 id='orlm'>Fitting multivariate regression models with order restrictions</h2><span id='topic+orlm'></span><span id='topic+orlm.formula'></span>

<h3>Description</h3>

<p>This is a modification of the <code>lm</code> function, fitting (multivariate) linear models with order constraints on the model coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orlm(formula, data, constr, rhs, nec, control = orlmcontrol())

## S3 method for class 'formula'
orlm(formula, data, constr, rhs, nec,
  control = orlmcontrol())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orlm_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that can be coerced to that class): a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="orlm_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by as.data.frame to a data frame) containing the variables in the model. If not found in data, the variables are taken from environment(formula), typically the environment from which lm is called.</p>
</td></tr>
<tr><td><code id="orlm_+3A_constr">constr</code></td>
<td>
<p>matrix with constraints; with rows as constraint definition, columns should be in line with the parameters of the model</p>
</td></tr>
<tr><td><code id="orlm_+3A_rhs">rhs</code></td>
<td>
<p>vector of right hand side elements; <code class="reqn">Constr \; \theta \geq rhs</code>; number should equal the number of rows of the constr matrix</p>
</td></tr>
<tr><td><code id="orlm_+3A_nec">nec</code></td>
<td>
<p>number of equality constraints; a numeric value treating the first nec constr rows as equality constraints, or a logical vector with <code>TRUE</code> for equality- and <code>FALSE</code> for inequality constraints.</p>
</td></tr>
<tr><td><code id="orlm_+3A_control">control</code></td>
<td>
<p>a list of control arguments; see <code><a href="#topic+orlmcontrol">orlmcontrol</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The contraints in the hypothesis of interest are defined by <code class="reqn">Constr</code>, <code class="reqn">rhs</code>, and <code class="reqn">nec</code>. The first <code class="reqn">nec</code> constraints are the equality contraints: <code class="reqn">Constr[1:nec, 1:tk] \theta = rhs[1:nec]</code>; and the remaing ones are the inequality contraints: <code class="reqn">Constr[nec+1:c_m, 1:tk] \theta \geq rhs[nec+1:c_m]</code>.
Two requirements should be met:
</p>

<ol>
<li><p> The first <code class="reqn">nec</code> constraints must be the equality contraints (i.e., <code class="reqn">Constr[1:nec, 1:tk] \theta = rhs[1:nec]</code>) and the remaining ones the inequality contraints (i.e., <code class="reqn">Constr[nec+1:c_m, 1:tk] \theta \geq rhs[nec+1:c_m]</code>).
</p>
</li>
<li><p> When <code class="reqn">rhs</code> is not zero, <code class="reqn">Constr</code> should be of full rank (after discarding redundant restrictions).
</p>
</li></ol>



<h3>Value</h3>

<p>an object of class orlm
</p>


<h3>References</h3>


<ul>
<li><p> Kuiper R.M., Hoijtink H., Silvapulle M.J. (2011). An Akaike-type Information Criterion for Model Selection Under Inequality Constraints. <em>Biometrika</em>, <b>98</b>, 495&ndash;501.
</p>
</li>
<li><p> Kuiper R.M., Hoijtink H., Silvapulle M.J. (2012). Generalization of the Order-Restricted Information Criterion for Multivariate Normal Linear Models. <em>Journal of Statistical Planning and Inference</em>, <b>142</b>, 2454-2463. doi:10.1016//j.jspi.2012.03.007.
</p>
</li>
<li><p> Kuiper R.M. and Hoijtink H. (submitted). A Fortran 90 Program for the Generalization of the Order-Restricted Information Criterion. Journal of Statictical Software.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="quadprog.html#topic+solve.QP">solve.QP</a></code>, <code><a href="#topic+goric">goric</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>########################
## Artificial example ##
########################
n &lt;- 10
m &lt;- c(1,2,1,5)
nm &lt;- length(m)
dat &lt;- data.frame(grp=as.factor(rep(1:nm, each=n)),
                  y=rnorm(n*nm, rep(m, each=n), 1))

# unrestricted linear model
cm1 &lt;- matrix(0, nrow=1, ncol=4)
fm1 &lt;- orlm(y ~ grp-1, data=dat, constr=cm1, rhs=0, nec=0)

# order restriction (increasing means)
cm2 &lt;- rbind(c(-1,1,0,0),
             c(0,-1,1,0),
             c(0,0,-1,1))
fm2 &lt;- orlm(y ~ grp-1, data=dat, constr=cm2,
            rhs=rep(0,nrow(cm2)), nec=0)

# order restriction (increasing at least by delta=1)
fm3 &lt;- orlm(y ~ grp-1, data=dat, constr=cm2,
            rhs=rep(1,nrow(cm2)), nec=0)

# larger than average of the neighboring first 2 parameters
cm4 &lt;- rbind(c(-0.5,-0.5,1,0),
             c(0,-0.5,-0.5,1))
fm4 &lt;- orlm(y ~ grp-1, data=dat, constr=cm4,
            rhs=rep(0,nrow(cm4)), nec=0)

# equality constraints (all parameters equal)
fm5 &lt;- orlm(y ~ grp-1, data=dat, constr=cm2,
            rhs=rep(0,nrow(cm2)), nec=nrow(cm2))
            
# alternatively
fm5 &lt;- orlm(y ~ grp-1, data=dat, constr=cm2,
            rhs=rep(0,nrow(cm2)), nec=c(TRUE,TRUE,TRUE))
            
# constraining the 1st and the 4th parameter
# to their true values, and the 2nd and 3rd between them
cm6 &lt;- rbind(c( 1,0,0,0),
             c(-1,1,0,0),
             c(0,-1,0,1),
             c(-1,0,1,0),
             c(0,0,-1,1),
             c(0,0, 0,1))
fm6 &lt;- orlm(y ~ grp-1, data=dat, constr=cm6,
            rhs=c(1,rep(0,4),5), nec=c(TRUE,rep(FALSE,4),TRUE))
            
            
###############################################################
## Example from Kuiper, R.M. and Hoijtink, H. (Unpublished). ##
## A Fortran 90 program for the generalization of the        ##
## order restricted information criterion.                   ##
###############################################################

# constraint definition
cmat &lt;- cbind(diag(3), 0) + cbind(0, -diag(3))
constr &lt;- kronecker(diag(3), cmat)

# no effect model
(fm0 &lt;- orlm(cbind(SDH, SGOT, SGPT) ~ dose-1, data=vinylidene,
             constr=constr, rhs=rep(0, nrow(constr)), nec=nrow(constr)))

# order constrained model (increasing serum levels with increasing doses)
fm1 &lt;- orlm(cbind(SDH, SGOT, SGPT) ~ dose-1, data=vinylidene,
            constr=constr, rhs=rep(0, nrow(constr)), nec=0)
summary(fm1)

# unconstrained model
(fmunc &lt;- orlm(cbind(SDH, SGOT, SGPT) ~ dose-1, data=vinylidene,
               constr=matrix(0, nrow=1, ncol=12), rhs=0, nec=0))
</code></pre>

<hr>
<h2 id='orlmcontrol'>Control arguments for the orlm function.</h2><span id='topic+orlmcontrol'></span>

<h3>Description</h3>

<p>A list with control arguments controlling the orlm function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orlmcontrol(maxiter = 10000, absval = 1e-04)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orlmcontrol_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="orlmcontrol_+3A_absval">absval</code></td>
<td>
<p>tolerance criterion for convergence</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with control arguments
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orlm">orlm</a></code>
</p>

<hr>
<h2 id='orlmSet'>Set of multivariate regression models</h2><span id='topic+orlmSet'></span>

<h3>Description</h3>

<p>Fitting a specific set of multivariate regression models with order restrictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orlmSet(formula, data, set, direction = "increase", n = NULL, base = 1,
  control = orlmcontrol())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orlmSet_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that can be coerced to that class): a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="orlmSet_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by as.data.frame to a data frame) containing the variables in the model. If not found in data, the variables are taken from environment(formula), typically the environment from which lm is called.</p>
</td></tr>
<tr><td><code id="orlmSet_+3A_set">set</code></td>
<td>
<p>either a character string (see <code><a href="#topic+constrSet">constrSet</a></code>), or a list with slots for constr, rhs, and nec similarly defined as in <code><a href="#topic+orlm">orlm</a></code></p>
</td></tr>
<tr><td><code id="orlmSet_+3A_direction">direction</code></td>
<td>
<p>direction of the order constraints</p>
</td></tr>
<tr><td><code id="orlmSet_+3A_n">n</code></td>
<td>
<p>a (possibly named) vector of sample sizes for each group</p>
</td></tr>
<tr><td><code id="orlmSet_+3A_base">base</code></td>
<td>
<p>column of the constraint matrix representing a control group</p>
</td></tr>
<tr><td><code id="orlmSet_+3A_control">control</code></td>
<td>
<p>a list of control arguments; see <code><a href="#topic+orlmcontrol">orlmcontrol</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is just a wrapper for repeated calls of <code><a href="#topic+orlm">orlm</a></code> with different constraint definitions. Predefined lists with constraint-sets can be constructed with function <code><a href="#topic+constrSet">constrSet</a></code>.
</p>


<h3>Value</h3>

<p>a list with orlm objects
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orlm">orlm</a></code>, <code><a href="#topic+constrSet">constrSet</a></code>, <code><a href="#topic+goric">goric</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>########################
## Artificial example ##
########################

n &lt;- 10
m &lt;- c(1,2,4,5,2,1)
nm &lt;- length(m)
dat &lt;- data.frame(grp=as.factor(rep(1:nm, each=n)),
                  y=rnorm(n*nm, rep(m, each=n), 1))

(cs &lt;- constrSet(table(dat$grp), set="sequence"))
(oss &lt;- orlmSet(y ~ grp-1, data=dat, set=cs))

# the same as:
oss &lt;- orlmSet(y ~ grp-1, data=dat, set="sequence")
</code></pre>

<hr>
<h2 id='sim'>Simulation from order restricted linear models</h2><span id='topic+sim'></span><span id='topic+sim.orlm'></span><span id='topic+sim.orgls'></span>

<h3>Description</h3>

<p>Simulation function for orlm and orgls objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim(object, n.sims)

## S3 method for class 'orlm'
sim(object, n.sims)

## S3 method for class 'orgls'
sim(object, n.sims)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_+3A_object">object</code></td>
<td>
<p>an object of class &quot;orlm&quot; or &quot;orgls&quot;.</p>
</td></tr>
<tr><td><code id="sim_+3A_n.sims">n.sims</code></td>
<td>
<p>number of simulation replications.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the estimated coefficients of a orlm or orgls model, a set new parameters are generated. n.sims new sets of observations are generated based on the unrestricted model; these new datasets are used to estimate a new set of model coefficients incorporating the given order restrictions.
</p>


<h3>Value</h3>

<p>a list with sets of simulated parameters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orlm">orlm</a></code>, <code><a href="#topic+orgls">orgls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>########################
## Artificial example ##
########################
n &lt;- 10
m &lt;- c(1,1,2)
dat &lt;- data.frame(grp=as.factor(rep(1:length(m), each=n)),
                  y=rnorm(n*length(m), rep(m, each=n), 1))
cm &lt;- rbind(c(-1,1,0),
            c(0,-1,1))
fm &lt;- orlm(y ~ grp-1, data=dat, constr=cm, rhs=rep(0,nrow(cm)), nec=0)
b &lt;- sim(fm, n.sims=1000)$coef
pairs(t(b), cex=0.3)
</code></pre>

<hr>
<h2 id='vinylidene'>Effect of vinylidene fluoride on liver cancer</h2><span id='topic+vinylidene'></span>

<h3>Description</h3>

<p>Real data which are available on page 10 of Silvapulle and Sen (2005) and in a report prepared by Litton Bionetics Inc in 1984.
These data were used in an experiment to find out whether vinylidene fluoride gives rise to liver damage. Since increased levels of serum enzyme are inherent in liver damage, the focus is on whether enzyme levels are affected by vinylidene fluoride. The variable of interest is the serum enzyme level. Three types of enzymes are inspected, namely SDH, SGOT, and SGPT. To study whether vinylidene fluoride has an influence on the three serum enzymes, four dosages of this substance are examined. In each of these four treatment groups, ten male Fischer-344 rats received the substance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vinylidene
</code></pre>


<h3>Format</h3>

<p>A data frame with 40 observations on the following 4 variables.
</p>

<dl>
<dt><code>SDH</code></dt><dd><p>serum enzyme level of enzyme type SDH.</p>
</dd>
<dt><code>SGOT</code></dt><dd><p>serum enzyme level of enzyme type SGOT.</p>
</dd>
<dt><code>SGPT</code></dt><dd><p>serum enzyme level of enzyme type SGPT.</p>
</dd>
<dt><code>dose</code></dt><dd><p>factor with 4 levels (d1-d4) representing the 4 vinylidene fluoride concentrations.</p>
</dd>
</dl>


<h3>References</h3>

<p>Silvapulle MJ, Sen PK (2005). <em>Constrained Statistical Inference</em>. New Jersey: Wiley.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
