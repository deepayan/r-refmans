<!DOCTYPE html><html><head><title>Help for package lubridate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lubridate}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%m+%'><p>Add and subtract months to a date without exceeding the last day of the new month</p></a></li>
<li><a href='#%within%'><p>Does a date (or interval) fall within an interval?</p></a></li>
<li><a href='#am'><p>Does date time occur in the am or pm?</p></a></li>
<li><a href='#as_date'><p>Convert an object to a date or date-time</p></a></li>
<li><a href='#as.duration'><p>Change an object to a duration</p></a></li>
<li><a href='#as.interval'><p>Change an object to an <code>interval</code></p></a></li>
<li><a href='#as.period'><p>Change an object to a period</p></a></li>
<li><a href='#cyclic_encoding'><p>Cyclic encoding of date-times</p></a></li>
<li><a href='#date'><p>Get/set date component of a date-time</p></a></li>
<li><a href='#date_decimal'><p>Converts a decimal to a date</p></a></li>
<li><a href='#DateCoercion'><p>Convert a variety of date-time classes to POSIXlt and POSIXct</p></a></li>
<li><a href='#DateTimeUpdate'><p>Changes the components of a date object</p></a></li>
<li><a href='#day'><p>Get/set days component of a date-time</p></a></li>
<li><a href='#days_in_month'><p>Get the number of days in the month of a date-time</p></a></li>
<li><a href='#decimal_date'><p>Converts a date to a decimal of its year</p></a></li>
<li><a href='#Deprecated-lubridate'><p>Deprecated functions in the lubridate package</p></a></li>
<li><a href='#dst'><p>Get <strong>d</strong>aylight <strong>s</strong>avings <strong>t</strong>ime indicator of a date-time</p></a></li>
<li><a href='#duration'><p>Create a duration object.</p></a></li>
<li><a href='#Duration-class'><p>Duration class</p></a></li>
<li><a href='#fit_to_timeline'><p>Fit a POSIXlt date-time to the timeline</p></a></li>
<li><a href='#force_tz'><p>Replace time zone to create new date-time</p></a></li>
<li><a href='#format_ISO8601'><p>Format in ISO8601 character format</p></a></li>
<li><a href='#format_ISO8601_precision_check'><p>Provide a format for ISO8601 dates and times with the requested precision.</p></a></li>
<li><a href='#guess_formats'><p>Guess possible date-times formats from a character vector</p></a></li>
<li><a href='#hidden_aliases'><p>Internal page for hidden aliases</p></a></li>
<li><a href='#hour'><p>Get/set hours component of a date-time</p></a></li>
<li><a href='#interval'><p>Utilities for creation and manipulation of <code>Interval</code> objects</p></a></li>
<li><a href='#Interval-class'><p>Interval class</p></a></li>
<li><a href='#is.Date'><p>Various date utilities</p></a></li>
<li><a href='#is.difftime'><p>Is x a difftime object?</p></a></li>
<li><a href='#is.instant'><p>Is x a date-time object?</p></a></li>
<li><a href='#is.POSIXt'><p>Various POSIX utilities</p></a></li>
<li><a href='#is.timespan'><p>Is x a length of time?</p></a></li>
<li><a href='#lakers'><p>Lakers 2008-2009 basketball data set</p></a></li>
<li><a href='#leap_year'><p>Is a year a leap year?</p></a></li>
<li><a href='#local_time'><p>Get local time from a date-time vector.</p></a></li>
<li><a href='#lubridate-package'><p>Dates and times made easy with lubridate</p></a></li>
<li><a href='#make_datetime'><p>Efficient creation of date-times from numeric representations</p></a></li>
<li><a href='#make_difftime'><p>Create a difftime object.</p></a></li>
<li><a href='#minute'><p>Get/set minutes component of a date-time</p></a></li>
<li><a href='#month'><p>Get/set months component of a date-time</p></a></li>
<li><a href='#ms'><p>Parse periods with <strong>h</strong>our, <strong>m</strong>inute, and <strong>s</strong>econd components</p></a></li>
<li><a href='#now'><p>The current day and time</p></a></li>
<li><a href='#origin'><p>1970-01-01 UTC</p></a></li>
<li><a href='#parse_date_time'><p>User friendly date-time parsing functions</p></a></li>
<li><a href='#period'><p>Create or parse period objects</p></a></li>
<li><a href='#period_to_seconds'><p>Contrive a period to/from a given number of seconds</p></a></li>
<li><a href='#Period-class'><p>Period class</p></a></li>
<li><a href='#pretty_dates'><p>Computes attractive axis breaks for date-time data</p></a></li>
<li><a href='#quarter'><p>Get the fiscal quarter and semester of a date-time</p></a></li>
<li><a href='#reclass_date'><p>Convenience method to reclass dates post-modification.</p></a></li>
<li><a href='#reclass_timespan'><p>Convenience method to reclass timespans post-modification.</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rollbackward'><p>Roll backward or forward a date the previous, current or next month</p></a></li>
<li><a href='#round_date'><p>Round, floor and ceiling methods for date-time objects</p></a></li>
<li><a href='#second'><p>Get/set seconds component of a date-time</p></a></li>
<li><a href='#stamp'><p>Format dates and times based on human-friendly templates</p></a></li>
<li><a href='#time_length'><p>Compute the exact length of a time span</p></a></li>
<li><a href='#timespan'><p>Description of time span classes in lubridate</p></a></li>
<li><a href='#Timespan-class'><p>Timespan class</p></a></li>
<li><a href='#tz'><p>Get/set time zone component of a date-time</p></a></li>
<li><a href='#week'><p>Get/set weeks component of a date-time</p></a></li>
<li><a href='#with_tz'><p>Get date-time in a different time zone</p></a></li>
<li><a href='#year'><p>Get/set years component of a date-time</p></a></li>
<li><a href='#ymd'><p>Parse dates with <strong>y</strong>ear, <strong>m</strong>onth, and <strong>d</strong>ay components</p></a></li>
<li><a href='#ymd_hms'><p>Parse date-times with <strong>y</strong>ear, <strong>m</strong>onth, and <strong>d</strong>ay, <strong>h</strong>our,</p>
<strong>m</strong>inute, and <strong>s</strong>econd components.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Make Dealing with Dates a Little Easier</td>
</tr>
<tr>
<td>Version:</td>
<td>1.9.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vitalie Spinu &lt;spinuvit@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to work with date-times and time-spans: fast and
    user friendly parsing of date-time data, extraction and updating of
    components of a date-time (years, months, days, hours, minutes, and
    seconds), algebraic manipulation on date-time and time-span objects.
    The 'lubridate' package has a consistent and memorable syntax that
    makes working with dates easy and fun.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://lubridate.tidyverse.org">https://lubridate.tidyverse.org</a>,
<a href="https://github.com/tidyverse/lubridate">https://github.com/tidyverse/lubridate</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidyverse/lubridate/issues">https://github.com/tidyverse/lubridate/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>methods, R (&ge; 3.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>generics, timechange (&ge; 0.1.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, rmarkdown, testthat (&ge; 2.1.0), vctrs (&ge; 0.5.0)</td>
</tr>
<tr>
<td>Enhances:</td>
<td>chron, data.table, timeDate, tis, zoo</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11, A system with zoneinfo data (e.g.
/usr/share/zoneinfo). On Windows the zoneinfo included with R
is used.</td>
</tr>
<tr>
<td>Collate:</td>
<td>'Dates.r' 'POSIXt.r' 'util.r' 'parse.r' 'timespans.r'
'intervals.r' 'difftimes.r' 'durations.r' 'periods.r'
'accessors-date.R' 'accessors-day.r' 'accessors-dst.r'
'accessors-hour.r' 'accessors-minute.r' 'accessors-month.r'
'accessors-quarter.r' 'accessors-second.r' 'accessors-tz.r'
'accessors-week.r' 'accessors-year.r' 'am-pm.r' 'time-zones.r'
'numeric.r' 'coercion.r' 'constants.r' 'cyclic_encoding.r'
'data.r' 'decimal-dates.r' 'deprecated.r' 'format_ISO8601.r'
'guess.r' 'hidden.r' 'instants.r' 'leap-years.r'
'ops-addition.r' 'ops-compare.r' 'ops-division.r'
'ops-integer-division.r' 'ops-m+.r' 'ops-modulo.r'
'ops-multiplication.r' 'ops-subtraction.r' 'package.r'
'pretty.r' 'round.r' 'stamp.r' 'tzdir.R' 'update.r' 'vctrs.R'
'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-24 18:46:12 UTC; vspinu</td>
</tr>
<tr>
<td>Author:</td>
<td>Vitalie Spinu [aut, cre],
  Garrett Grolemund [aut],
  Hadley Wickham [aut],
  Davis Vaughan [ctb],
  Ian Lyttle [ctb],
  Imanuel Costigan [ctb],
  Jason Law [ctb],
  Doug Mitarotonda [ctb],
  Joseph Larmarange [ctb],
  Jonathan Boiser [ctb],
  Chel Hee Lee [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-27 09:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25m+2B+25'>Add and subtract months to a date without exceeding the last day of the new month</h2><span id='topic++25m+2B+25'></span><span id='topic+m+2B'></span><span id='topic+m-'></span><span id='topic++25m-+25'></span><span id='topic++25m+2B+25+2CANY+2CANY-method'></span><span id='topic++25m-+25+2CANY+2CANY-method'></span><span id='topic++25m+2B+25+2CPeriod+2CANY-method'></span><span id='topic++25m+2B+25+2CANY+2CPeriod-method'></span><span id='topic++25m-+25+2CPeriod+2CANY-method'></span><span id='topic++25m-+25+2CANY+2CPeriod-method'></span><span id='topic++25m+2B+25+2CDuration+2CANY-method'></span><span id='topic++25m+2B+25+2CANY+2CDuration-method'></span><span id='topic++25m-+25+2CDuration+2CANY-method'></span><span id='topic++25m-+25+2CANY+2CDuration-method'></span><span id='topic++25m+2B+25+2CInterval+2CANY-method'></span><span id='topic++25m+2B+25+2CANY+2CInterval-method'></span><span id='topic++25m-+25+2CInterval+2CANY-method'></span><span id='topic++25m-+25+2CANY+2CInterval-method'></span><span id='topic+add_with_rollback'></span>

<h3>Description</h3>

<p>Adding months frustrates basic arithmetic because consecutive months have
different lengths. With other elements, it is helpful for arithmetic to
perform automatic roll over. For example, 12:00:00 + 61 seconds becomes
12:01:01. However, people often prefer that this behavior NOT occur with
months. For example, we sometimes want January 31 + 1 month = February 28 and
not March 3. <code>%m+%</code> performs this type of arithmetic. Date <code>%m+%</code> months(n)
always returns a date in the nth month after Date. If the new date would
usually spill over into the n + 1th month, <code>%m+%</code> will return the last day of
the nth month (<code><a href="#topic+rollback">rollback()</a></code>). Date <code>%m-%</code> months(n) always returns a
date in the nth month before Date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e1 %m+% e2

add_with_rollback(e1, e2, roll_to_first = FALSE, preserve_hms = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25m+2B2B+2B25_+3A_e1">e1</code></td>
<td>
<p>A period or a date-time object of class <a href="base.html#topic+POSIXlt">POSIXlt</a>, <a href="#topic+POSIXct">POSIXct</a>
or <a href="#topic+Date">Date</a>.</p>
</td></tr>
<tr><td><code id="+2B25m+2B2B+2B25_+3A_e2">e2</code></td>
<td>
<p>A period or a date-time object of class <a href="base.html#topic+POSIXlt">POSIXlt</a>, <a href="#topic+POSIXct">POSIXct</a>
or <a href="#topic+Date">Date</a>. Note that one of e1 and e2 must be a period and the other a
date-time object.</p>
</td></tr>
<tr><td><code id="+2B25m+2B2B+2B25_+3A_roll_to_first">roll_to_first</code></td>
<td>
<p>rollback to the first day of the month instead of the
last day of the previous month (passed to <code><a href="#topic+rollback">rollback()</a></code>)</p>
</td></tr>
<tr><td><code id="+2B25m+2B2B+2B25_+3A_preserve_hms">preserve_hms</code></td>
<td>
<p>retains the same hour, minute, and second information? If
FALSE, the new date will be at 00:00:00 (passed to <code><a href="#topic+rollback">rollback()</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>%m+%</code> and <code>%m-%</code> handle periods with components less than a month by first
adding/subtracting months and then performing usual arithmetics with smaller
units.
</p>
<p><code>%m+%</code> and <code>%m-%</code> should be used with caution as they are not one-to-one
operations and results for either will be sensitive to the order of
operations.
</p>


<h3>Value</h3>

<p>A date-time object of class POSIXlt, POSIXct or Date
</p>


<h3>Examples</h3>

<pre><code class='language-R'>jan &lt;- ymd_hms("2010-01-31 03:04:05")
jan + months(1:3) # Feb 31 and April 31 returned as NA
# NA "2010-03-31 03:04:05 UTC" NA
jan %m+% months(1:3) # No rollover

leap &lt;- ymd("2012-02-29")
"2012-02-29 UTC"
leap %m+% years(1)
leap %m+% years(-1)
leap %m-% years(1)

x &lt;- ymd_hms("2019-01-29 01:02:03")
add_with_rollback(x, months(1))
add_with_rollback(x, months(1), preserve_hms = FALSE)
add_with_rollback(x, months(1), roll_to_first = TRUE)
add_with_rollback(x, months(1), roll_to_first = TRUE, preserve_hms = FALSE)
</code></pre>

<hr>
<h2 id='+25within+25'>Does a date (or interval) fall within an interval?</h2><span id='topic++25within+25'></span><span id='topic++25within+25+2CInterval+2CInterval-method'></span><span id='topic++25within+25+2CANY+2CInterval-method'></span><span id='topic++25within+25+2CDate+2Clist-method'></span><span id='topic++25within+25+2CPOSIXt+2Clist-method'></span><span id='topic++25within+25+2CInterval+2Clist-method'></span>

<h3>Description</h3>

<p>Check whether <code>a</code> lies within the interval <code>b</code>, inclusive of the endpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a %within% b
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25within+2B25_+3A_a">a</code></td>
<td>
<p>An interval or date-time object.</p>
</td></tr>
<tr><td><code id="+2B25within+2B25_+3A_b">b</code></td>
<td>
<p>Either an interval vector, or a list of intervals.
</p>
<p>If <code>b</code> is an interval (or interval vector) it is recycled to the same length as <code>a</code>.
If <code>b</code> is a list of intervals, <code>a</code> is checked if it falls within <em>any</em>
of the intervals, i.e. <code>a %within% list(int1, int2)</code> is equivalent to
<code>a %within% int1 | a %within% int2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>int &lt;- interval(ymd("2001-01-01"), ymd("2002-01-01"))
int2 &lt;- interval(ymd("2001-06-01"), ymd("2002-01-01"))

ymd("2001-05-03") %within% int # TRUE
int2 %within% int # TRUE
ymd("1999-01-01") %within% int # FALSE

## recycling (carefully note the difference between using a vector of
## intervals and list of intervals for the second argument)
dates &lt;- ymd(c("2014-12-20", "2014-12-30", "2015-01-01", "2015-01-03"))
blackout_vector &lt;- c(
  interval(ymd("2014-12-30"), ymd("2014-12-31")),
  interval(ymd("2014-12-30"), ymd("2015-01-03"))
)
dates %within% blackout_vector

## within ANY of the intervals of a list
dates &lt;- ymd(c("2014-12-20", "2014-12-30", "2015-01-01", "2015-01-03"))
lst &lt;- list(
  interval(ymd("2014-12-30"), ymd("2014-12-31")),
  interval(ymd("2014-12-30"), ymd("2015-01-03"))
)
dates %within% lst

## interval within a list of intervals
int &lt;- interval(
  ymd("2014-12-20", "2014-12-30"),
  ymd("2015-01-01", "2015-01-03")
)
int %within% lst
</code></pre>

<hr>
<h2 id='am'>Does date time occur in the am or pm?</h2><span id='topic+am'></span><span id='topic+pm'></span>

<h3>Description</h3>

<p>Does date time occur in the am or pm?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>am(x)

pm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="am_+3A_x">x</code></td>
<td>
<p>a date-time object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE or FALSE depending on whether x occurs in the am or pm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ymd("2012-03-26")
am(x)
pm(x)
</code></pre>

<hr>
<h2 id='as_date'>Convert an object to a date or date-time</h2><span id='topic+as_date'></span><span id='topic+as_date+2CANY-method'></span><span id='topic+as_date+2CPOSIXt-method'></span><span id='topic+as_date+2Cnumeric-method'></span><span id='topic+as_date+2Ccharacter-method'></span><span id='topic+as_datetime'></span><span id='topic+as_datetime+2CANY-method'></span><span id='topic+as_datetime+2CPOSIXt-method'></span><span id='topic+as_datetime+2Cnumeric-method'></span><span id='topic+as_datetime+2Ccharacter-method'></span><span id='topic+as_datetime+2CDate-method'></span>

<h3>Description</h3>

<p>Convert an object to a date or date-time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_date(x, ...)

## S4 method for signature 'ANY'
as_date(x, ...)

## S4 method for signature 'POSIXt'
as_date(x, tz = NULL)

## S4 method for signature 'numeric'
as_date(x, origin = lubridate::origin)

## S4 method for signature 'character'
as_date(x, tz = NULL, format = NULL)

as_datetime(x, ...)

## S4 method for signature 'ANY'
as_datetime(x, tz = lubridate::tz(x))

## S4 method for signature 'POSIXt'
as_datetime(x, tz = lubridate::tz(x))

## S4 method for signature 'numeric'
as_datetime(x, origin = lubridate::origin, tz = "UTC")

## S4 method for signature 'character'
as_datetime(x, tz = "UTC", format = NULL)

## S4 method for signature 'Date'
as_datetime(x, tz = "UTC")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_date_+3A_x">x</code></td>
<td>
<p>a vector of <a href="base.html#topic+POSIXt">POSIXt</a>, numeric or character objects</p>
</td></tr>
<tr><td><code id="as_date_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to specific methods (see above).</p>
</td></tr>
<tr><td><code id="as_date_+3A_tz">tz</code></td>
<td>
<p>a time zone name (default: time zone of the POSIXt object <code>x</code>). See
<code><a href="base.html#topic+OlsonNames">OlsonNames()</a></code>.</p>
</td></tr>
<tr><td><code id="as_date_+3A_origin">origin</code></td>
<td>
<p>a Date object, or something which can be coerced by <code>as.Date(origin, ...)</code> to such an object (default: the Unix epoch of &quot;1970-01-01&quot;). Note that in
this instance, <code>x</code> is assumed to reflect the number of days since <code>origin</code> at
<code>"UTC"</code>.</p>
</td></tr>
<tr><td><code id="as_date_+3A_format">format</code></td>
<td>
<p>format argument for character methods. When supplied parsing is
performed by <code>parse_date_time(x, orders = formats, exact = TRUE)</code>. Thus, multiple
formats are supported and are tried in turn.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of <a href="#topic+Date">Date</a> objects corresponding to <code>x</code>.
</p>


<h3>Compare to base R</h3>

<p>These are drop in replacements for <code><a href="base.html#topic+as.Date">as.Date()</a></code> and <code><a href="base.html#topic+as.POSIXct">as.POSIXct()</a></code>, with a few
tweaks to make them work more intuitively.
</p>

<ul>
<li><p> Called on a <code>POSIXct</code> object, <code>as_date()</code> uses the tzone attribute of
the object to return the same date as indicated by the printed representation
of the object. This differs from as.Date, which ignores the attribute and
uses only the tz argument to <code>as.Date()</code> (&quot;UTC&quot; by default).
</p>
</li>
<li><p> Both functions provide a default origin argument for numeric vectors.
</p>
</li>
<li><p> Both functions will generate NAs for invalid date format. Valid formats are
those described by ISO8601 standard. A warning message will provide a count of the
elements that were not converted.
</p>
</li>
<li> <p><code>as_datetime()</code> defaults to using UTC.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>dt_utc &lt;- ymd_hms("2010-08-03 00:50:50")
dt_europe &lt;- ymd_hms("2010-08-03 00:50:50", tz = "Europe/London")
c(as_date(dt_utc), as.Date(dt_utc))
c(as_date(dt_europe), as.Date(dt_europe))
## need not supply origin
as_date(10)
## Will replace invalid date format with NA
dt_wrong &lt;- c("2009-09-29", "2012-11-29", "2015-29-12")
as_date(dt_wrong)
</code></pre>

<hr>
<h2 id='as.duration'>Change an object to a duration</h2><span id='topic+as.duration'></span><span id='topic+as.duration+2Cnumeric-method'></span><span id='topic+as.duration+2Clogical-method'></span><span id='topic+as.duration+2Cdifftime-method'></span><span id='topic+as.duration+2CInterval-method'></span><span id='topic+as.duration+2CDuration-method'></span><span id='topic+as.duration+2CPeriod-method'></span><span id='topic+as.duration+2Ccharacter-method'></span>

<h3>Description</h3>

<p>as.duration changes Interval, Period and numeric class objects to
Duration objects. Numeric objects are changed to Duration objects
with the seconds unit equal to the numeric value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.duration(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.duration_+3A_x">x</code></td>
<td>
<p>Object to be coerced to a duration</p>
</td></tr>
<tr><td><code id="as.duration_+3A_...">...</code></td>
<td>
<p>Parameters passed to other methods. Currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Durations are exact time measurements, whereas periods are relative time
measurements. See <a href="#topic+Period-class">Period</a>. The length of a period depends
on when it occurs. Hence, a one to one mapping does not exist between
durations and periods. When used with a period object, as.duration provides
an inexact estimate of the length of the period; each time unit is assigned
its most common number of seconds. A period of one month is converted to
2628000 seconds (approximately 30.42 days). This ensures that 12 months will
sum to 365 days, or one normal year. For an exact transformation, first
transform the period to an interval with <code><a href="#topic+as.interval">as.interval()</a></code>.
</p>


<h3>Value</h3>

<p>A duration object
</p>


<h3>See Also</h3>

<p><a href="#topic+Duration-class">Duration</a>, <code><a href="#topic+duration">duration()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>span &lt;- interval(ymd("2009-01-01"), ymd("2009-08-01")) # interval
as.duration(span)
as.duration(10) # numeric
dur &lt;- duration(hours = 10, minutes = 6)
as.numeric(dur, "hours")
as.numeric(dur, "minutes")
</code></pre>

<hr>
<h2 id='as.interval'>Change an object to an <code>interval</code></h2><span id='topic+as.interval'></span><span id='topic+as.interval+2Cnumeric-method'></span><span id='topic+as.interval+2Cdifftime-method'></span><span id='topic+as.interval+2CInterval-method'></span><span id='topic+as.interval+2CDuration-method'></span><span id='topic+as.interval+2CPeriod-method'></span><span id='topic+as.interval+2CPOSIXt-method'></span><span id='topic+as.interval+2Clogical-method'></span>

<h3>Description</h3>

<p>as.interval changes difftime, Duration, Period and numeric class objects to
intervals that begin at the specified date-time. Numeric objects are first
coerced to timespans equal to the numeric value in seconds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.interval(x, start, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.interval_+3A_x">x</code></td>
<td>
<p>a duration, difftime, period, or numeric object that describes the length of the interval</p>
</td></tr>
<tr><td><code id="as.interval_+3A_start">start</code></td>
<td>
<p>a POSIXt or Date object that describes when the interval begins</p>
</td></tr>
<tr><td><code id="as.interval_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to as.interval</p>
</td></tr>
</table>


<h3>Details</h3>

<p>as.interval can be used to create accurate transformations between Period
objects, which measure time spans in variable length units, and Duration objects,
which measure timespans as an exact number of seconds. A start date-
time must be supplied to make the conversion. Lubridate uses
this start date to look up how many seconds each variable
length unit (e.g. month, year) lasted for during the time span
described. See
<code><a href="#topic+as.duration">as.duration()</a></code>, <code><a href="#topic+as.period">as.period()</a></code>.
</p>


<h3>Value</h3>

<p>an interval object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interval">interval()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>diff &lt;- make_difftime(days = 31) # difftime
as.interval(diff, ymd("2009-01-01"))
as.interval(diff, ymd("2009-02-01"))

dur &lt;- duration(days = 31) # duration
as.interval(dur, ymd("2009-01-01"))
as.interval(dur, ymd("2009-02-01"))

per &lt;- period(months = 1) # period
as.interval(per, ymd("2009-01-01"))
as.interval(per, ymd("2009-02-01"))

as.interval(3600, ymd("2009-01-01")) # numeric
</code></pre>

<hr>
<h2 id='as.period'>Change an object to a period</h2><span id='topic+as.period'></span><span id='topic+as.period+2Cnumeric-method'></span><span id='topic+as.period+2Cdifftime-method'></span><span id='topic+as.period+2CInterval-method'></span><span id='topic+as.period+2CDuration-method'></span><span id='topic+as.period+2CPeriod-method'></span><span id='topic+as.period+2Clogical-method'></span><span id='topic+as.period+2Ccharacter-method'></span>

<h3>Description</h3>

<p>as.period changes Interval, Duration, difftime and numeric class objects
to Period class objects with the specified units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.period(x, unit, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.period_+3A_x">x</code></td>
<td>
<p>an interval, difftime, or numeric object</p>
</td></tr>
<tr><td><code id="as.period_+3A_unit">unit</code></td>
<td>
<p>A character string that specifies which time units to build period in.
unit is only implemented for the as.period.numeric method and the as.period.interval method.
For as.period.interval, as.period will convert intervals to units no larger than the specified
unit.</p>
</td></tr>
<tr><td><code id="as.period_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to as.period</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Users must specify which time units to measure the period in. The exact length of
each time unit in a period will depend on when it occurs. See
<a href="#topic+Period-class">Period</a> and <code><a href="#topic+period">period()</a></code>.
The choice of units is not trivial; units that are
normally equal may differ in length depending on when the time period
occurs. For example, when a leap second occurs one minute is longer than 60
seconds.
</p>
<p>Because periods do not have a fixed length, they can not be accurately
converted to and from Duration objects. Duration objects measure time spans
in exact numbers of seconds, see <a href="#topic+Duration-class">Duration</a>. Hence, a one to one
mapping does not exist between durations and periods. When used with a
Duration object, as.period provides an inexact estimate; the duration is
broken into time units based on the most common lengths of time units, in
seconds. Because the length of months are particularly variable, a period
with a months unit can not be coerced from a duration object. For an exact
transformation, first transform the duration to an interval with
<code><a href="#topic+as.interval">as.interval()</a></code>.
</p>
<p>Coercing an interval to a period may cause surprising behavior if you request
periods with small units. A leap year is 366 days long, but one year long. Such
an interval will convert to 366 days when unit is set to days and 1 year when
unit is set to years. Adding 366 days to a date will often give a different
result than adding one year. Daylight savings is the one exception where this
does not apply. Interval lengths are calculated on the UTC timeline, which does
not use daylight savings. Hence, periods converted with seconds or minutes will not
reflect the actual variation in seconds and minutes that occurs due to daylight
savings. These periods will show the &quot;naive&quot; change in seconds and minutes that is
suggested by the differences in clock time. See the examples below.
</p>


<h3>Value</h3>

<p>a period object
</p>


<h3>See Also</h3>

<p><a href="#topic+Period-class">Period</a>, <code><a href="#topic+period">period()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>span &lt;- interval(ymd_hms("2009-01-01 00:00:00"), ymd_hms("2010-02-02 01:01:01")) # interval
as.period(span)
as.period(span, unit = "day")
"397d 1H 1M 1S"
leap &lt;- interval(ymd("2016-01-01"), ymd("2017-01-01"))
as.period(leap, unit = "days")
as.period(leap, unit = "years")
dst &lt;- interval(
  ymd("2016-11-06", tz = "America/Chicago"),
  ymd("2016-11-07", tz = "America/Chicago")
)
# as.period(dst, unit = "seconds")
as.period(dst, unit = "hours")
per &lt;- period(hours = 10, minutes = 6)
as.numeric(per, "hours")
as.numeric(per, "minutes")
</code></pre>

<hr>
<h2 id='cyclic_encoding'>Cyclic encoding of date-times</h2><span id='topic+cyclic_encoding'></span>

<h3>Description</h3>

<p>Encode a date-time object into a cyclic coordinate system in which the
distances between two pairs of dates separated by the same time duration are
the same.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cyclic_encoding(
  x,
  periods,
  encoders = c("sin", "cos"),
  week_start = getOption("lubridate.week.start", 7)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cyclic_encoding_+3A_x">x</code></td>
<td>
<p>a date-time object</p>
</td></tr>
<tr><td><code id="cyclic_encoding_+3A_periods">periods</code></td>
<td>
<p>a character vector of periods. Follows same specification as
<a href="#topic+period">period</a> and <a href="#topic+floor_date">floor_date</a> functions.</p>
</td></tr>
<tr><td><code id="cyclic_encoding_+3A_encoders">encoders</code></td>
<td>
<p>names of functions to produce the encoding. Defaults to
&quot;sin&quot; and &quot;cos&quot;. Names of any predefined functions accepting a numeric
input are allowed.</p>
</td></tr>
<tr><td><code id="cyclic_encoding_+3A_week_start">week_start</code></td>
<td>
<p>week start day (Default is 7, Sunday. Set <code>lubridate.week.start</code> to
override). Full or abbreviated names of the days of the week can be in English or
as provided by the current locale.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Machine learning models don't know that December 31st and January 1st are
close in our human calendar sense. <code>cyclic_encoding</code> makes it obvious to the
machine learner that two calendar dates are close by mapping the dates onto
the circle.
</p>


<h3>Value</h3>

<p>a numeric matrix with number of columns equal <code>length(periods) * length(types)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
times &lt;- ymd_hms("2019-01-01 00:00:00") + hours(0:23)
cyclic_encoding(times, c("day", "week", "month"))
plot(cyclic_encoding(times, "1d"))
plot(cyclic_encoding(times, "2d"), xlim = c(-1, 1))
plot(cyclic_encoding(times, "4d"), xlim = c(-1, 1))
</code></pre>

<hr>
<h2 id='date'>Get/set date component of a date-time</h2><span id='topic+date'></span><span id='topic+date+3C-'></span>

<h3>Description</h3>

<p>Date-time must be a POSIXct, POSIXlt, Date, chron, yearmon, yearqtr, zoo,
zooreg, timeDate, xts, its, ti, jul, timeSeries, and fts objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date(x)

date(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_+3A_x">x</code></td>
<td>
<p>a date-time object</p>
</td></tr>
<tr><td><code id="date_+3A_value">value</code></td>
<td>
<p>an object for which the <code>date()</code> function is defined</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>date()</code> does not yet support years before 0 C.E.
Also <code>date()</code> is not defined for Period objects.
</p>


<h3>Value</h3>

<p>the date of x as a Date
</p>


<h3>Base compatibility</h3>

<p><code>date()</code> can be called without any arguments to return a string representing
the current date-time. This provides compatiblity with <code>base:date()</code> which
it overrides.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ymd_hms("2012-03-26 23:12:13", tz = "America/New_York")
date(x)
as.Date(x) # by default as.Date assumes you want to know the date in UTC
as.Date(x, tz = "America/New_York")
date(x) &lt;- as.Date("2000-01-02")
x
</code></pre>

<hr>
<h2 id='date_decimal'>Converts a decimal to a date</h2><span id='topic+date_decimal'></span>

<h3>Description</h3>

<p>Converts a decimal to a date
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_decimal(decimal, tz = "UTC")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_decimal_+3A_decimal">decimal</code></td>
<td>
<p>a numeric object</p>
</td></tr>
<tr><td><code id="date_decimal_+3A_tz">tz</code></td>
<td>
<p>the time zone required</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a POSIXct object, whose year corresponds to the integer part of
decimal. The months, days, hours, minutes and seconds elements are picked so
the date-time will accurately represent the fraction of the year expressed by
decimal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>date &lt;- ymd("2009-02-10")
decimal &lt;- decimal_date(date) # 2009.11
date_decimal(decimal) # "2009-02-10 UTC"
</code></pre>

<hr>
<h2 id='DateCoercion'>Convert a variety of date-time classes to POSIXlt and POSIXct</h2><span id='topic+DateCoercion'></span>

<h3>Description</h3>

<p>Convert a variety of date-time classes to POSIXlt and POSIXct
</p>

<hr>
<h2 id='DateTimeUpdate'>Changes the components of a date object</h2><span id='topic+DateTimeUpdate'></span><span id='topic+update.POSIXt'></span>

<h3>Description</h3>

<p><code>update.Date()</code> and <code>update.POSIXt()</code> return a date with the specified
elements updated.  Elements not specified will be left unaltered. update.Date
and update.POSIXt do not add the specified values to the existing date, they
substitute them for the appropriate parts of the existing date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'POSIXt'
update(
  object,
  ...,
  roll_dst = c("NA", "post"),
  week_start = getOption("lubridate.week.start", 7),
  roll = NULL,
  simple = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DateTimeUpdate_+3A_object">object</code></td>
<td>
<p>a date-time object</p>
</td></tr>
<tr><td><code id="DateTimeUpdate_+3A_...">...</code></td>
<td>
<p>named arguments: years, months, ydays, wdays, mdays, days, hours, minutes,
seconds, tzs (time zone component)</p>
</td></tr>
<tr><td><code id="DateTimeUpdate_+3A_roll_dst">roll_dst</code></td>
<td>
<p>is a string vector of length one or two. When two values are
supplied they specify how to roll date-times when they fall into &quot;skipped&quot; and
&quot;repeated&quot; DST transitions respectively. A single value is replicated to the
length of two. Possible values are:
</p>
<div class="sourceCode"><pre>* `pre` - Use the time before the transition boundary.
* `boundary` - Use the time exactly at the boundary transition.
* `post` - Use the time after the boundary transition.
* `xfirst` - crossed-first: First time which occurred when crossing the
   boundary. For addition with positive units pre interval is crossed first and
   post interval last. With negative units post interval is crossed first, pre -
   last. For subtraction the logic is reversed.
* `xlast` - crossed-last.
* `NA` - Produce NAs when the resulting time falls inside the problematic interval.
</pre></div>
<p>For example 'roll_dst = c(&quot;NA&quot;, &quot;pre&quot;) indicates that for skiped intervals
return NA and for repeated times return the earlier time.
</p>
<p>When multiple units are supplied the meaning of &quot;negative period&quot; is determined by
the largest unit. For example <code>time_add(t, days = -1, hours = 2, roll_dst = "xfirst")</code> would operate as if with negative period, thus crossing the boundary
from the &quot;post&quot; to &quot;pre&quot; side and &quot;xfirst&quot; and hence resolving to &quot;post&quot;
time. As this might result in confusing behavior. See examples.
</p>
<p>&quot;xfirst&quot; and &quot;xlast&quot; make sense for addition and subtraction only. An error is
raised if an attempt is made to use them with other functions.</p>
</td></tr>
<tr><td><code id="DateTimeUpdate_+3A_week_start">week_start</code></td>
<td>
<p>week start day (Default is 7, Sunday. Set <code>lubridate.week.start</code> to
override). Full or abbreviated names of the days of the week can be in English or
as provided by the current locale.</p>
</td></tr>
<tr><td><code id="DateTimeUpdate_+3A_simple">simple</code>, <code id="DateTimeUpdate_+3A_roll">roll</code></td>
<td>
<p>deprecated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a date object with the requested elements updated. The object will retain its
original class unless an element is updated which the original class does not
support. In this case, the date returned will be a POSIXlt date object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>date &lt;- ymd("2009-02-10")
update(date, year = 2010, month = 1, mday = 1)

update(date, year = 2010, month = 13, mday = 1)

update(date, minute = 10, second = 3)
</code></pre>

<hr>
<h2 id='day'>Get/set days component of a date-time</h2><span id='topic+day'></span><span id='topic+mday'></span><span id='topic+wday'></span><span id='topic+qday'></span><span id='topic+yday'></span><span id='topic+day+3C-'></span><span id='topic+mday+3C-'></span><span id='topic+qday+3C-'></span><span id='topic+wday+3C-'></span><span id='topic+yday+3C-'></span>

<h3>Description</h3>

<p>Get/set days component of a date-time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>day(x)

mday(x)

wday(
  x,
  label = FALSE,
  abbr = TRUE,
  week_start = getOption("lubridate.week.start", 7),
  locale = Sys.getlocale("LC_TIME")
)

qday(x)

yday(x)

day(x) &lt;- value

mday(x) &lt;- value

qday(x) &lt;- value

qday(x) &lt;- value

wday(x, week_start = getOption("lubridate.week.start", 7)) &lt;- value

yday(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="day_+3A_x">x</code></td>
<td>
<p>a POSIXct, POSIXlt, Date, chron, yearmon, yearqtr, zoo, zooreg, timeDate,
xts, its, ti, jul, timeSeries, or fts object.</p>
</td></tr>
<tr><td><code id="day_+3A_label">label</code></td>
<td>
<p>logical. Only available for wday. TRUE will display the day of the week
as an ordered factor of character strings, such as &quot;Sunday.&quot; FALSE will display the
day of the week as a number.</p>
</td></tr>
<tr><td><code id="day_+3A_abbr">abbr</code></td>
<td>
<p>logical. Only available for wday. FALSE will display the day of the week
as an ordered factor of character strings, such as &quot;Sunday.&quot; TRUE will display an
abbreviated version of the label, such as &quot;Sun&quot;. abbr is disregarded if label =
FALSE.</p>
</td></tr>
<tr><td><code id="day_+3A_week_start">week_start</code></td>
<td>
<p>day on which week starts following ISO conventions: 1 means Monday
and 7 means Sunday (default). When <code>label = FALSE</code> and <code>week_start = 7</code>, the number
returned for Sunday is 1, for Monday is 2, etc. When <code>label = TRUE</code>, the returned
value is a factor with the first level being the week start (e.g. Sunday if
<code>week_start = 7</code>). You can set <code>lubridate.week.start</code> option to control this
parameter globally.</p>
</td></tr>
<tr><td><code id="day_+3A_locale">locale</code></td>
<td>
<p>locale to use for day names. Default to current locale.</p>
</td></tr>
<tr><td><code id="day_+3A_value">value</code></td>
<td>
<p>(for <code style="white-space: pre;">&#8288;wday&lt;-&#8288;</code>) a numeric or a string giving the name of the day in the
current locale or in English. Can be abbreviated. When a string, the value of
<code>week_start</code> is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mday()</code> and <code>yday()</code> return the day of the month and day of the year
respectively. <code>day()</code> and <code style="white-space: pre;">&#8288;day&lt;-()&#8288;</code> are aliases for <code>mday()</code> and <code style="white-space: pre;">&#8288;mday&lt;-()&#8288;</code>.
</p>


<h3>Value</h3>

<p><code>wday()</code> returns the day of the week as a decimal number or an ordered factor
if label is <code>TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.Date("2009-09-02")
wday(x) # 4
wday(x, label = TRUE) # Wed

wday(x, week_start = 1) # 3
wday(x, week_start = 7) # 4

wday(x, label = TRUE, week_start = 7) # Wed (Sun is the first level)
wday(x, label = TRUE, week_start = 1) # Wed (Mon is the first level)

wday(ymd(080101))
wday(ymd(080101), label = TRUE, abbr = FALSE)
wday(ymd(080101), label = TRUE, abbr = TRUE)
wday(ymd(080101) + days(-2:4), label = TRUE, abbr = TRUE)

x &lt;- as.Date("2009-09-02")
yday(x) # 245
mday(x) # 2
yday(x) &lt;- 1 # "2009-01-01"
yday(x) &lt;- 366 # "2010-01-01"
mday(x) &gt; 3
</code></pre>

<hr>
<h2 id='days_in_month'>Get the number of days in the month of a date-time</h2><span id='topic+days_in_month'></span>

<h3>Description</h3>

<p>Date-time must be a POSIXct, POSIXlt, Date, chron, yearmon, yearqtr,
zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, and fts objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>days_in_month(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="days_in_month_+3A_x">x</code></td>
<td>
<p>a date-time object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer of the number of days in the month component of the date-time object.
</p>

<hr>
<h2 id='decimal_date'>Converts a date to a decimal of its year</h2><span id='topic+decimal_date'></span>

<h3>Description</h3>

<p>Converts a date to a decimal of its year
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decimal_date(date)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decimal_date_+3A_date">date</code></td>
<td>
<p>a POSIXt or Date object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric object where the date is expressed as a fraction of its year
</p>


<h3>Examples</h3>

<pre><code class='language-R'>date &lt;- ymd("2009-02-10")
decimal_date(date) # 2009.11
</code></pre>

<hr>
<h2 id='Deprecated-lubridate'>Deprecated functions in the lubridate package</h2><span id='topic+Deprecated-lubridate'></span>

<h3>Description</h3>

<p>Deprecated functions in the lubridate package
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="Deprecated-lubridate_+3A_x">x</code></td>
<td>
<p>numeric value to be converted into duration</p>
</td></tr>
<tr><td><code id="Deprecated-lubridate_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the functions
(obscured to enforce the usage of new functions)</p>
</td></tr>
</table>

<hr>
<h2 id='dst'>Get <strong>d</strong>aylight <strong>s</strong>avings <strong>t</strong>ime indicator of a date-time</h2><span id='topic+dst'></span>

<h3>Description</h3>

<p>Date-time must be a POSIXct, POSIXlt, Date, chron, yearmon, yearqtr, zoo,
zooreg, timeDate, xts, its, ti, jul, timeSeries, and fts objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dst(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dst_+3A_x">x</code></td>
<td>
<p>a date-time object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A date-time's daylight savings flag can not be set because it depends on the
date-time's year, month, day, and hour values.
</p>


<h3>Value</h3>

<p>A logical. TRUE if DST is in force, FALSE if not, NA if unknown.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ymd("2012-03-26")
dst(x)
</code></pre>

<hr>
<h2 id='duration'>Create a duration object.</h2><span id='topic+duration'></span><span id='topic+dseconds'></span><span id='topic+dminutes'></span><span id='topic+dhours'></span><span id='topic+ddays'></span><span id='topic+dweeks'></span><span id='topic+dmonths'></span><span id='topic+dyears'></span><span id='topic+dmilliseconds'></span><span id='topic+dmicroseconds'></span><span id='topic+dnanoseconds'></span><span id='topic+dpicoseconds'></span><span id='topic+is.duration'></span>

<h3>Description</h3>

<p><code>duration()</code> creates a duration object with the specified values. Entries
for different units are cumulative. durations display as the number of
seconds in a time span. When this number is large, durations also display an
estimate in larger units, however, the underlying object is always recorded
as a fixed number of seconds. For display and creation purposes, units are
converted to seconds using their most common lengths in seconds. Minutes = 60
seconds, hours = 3600 seconds, days = 86400 seconds, weeks = 604800. Units
larger than weeks are not used due to their variability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duration(num = NULL, units = "seconds", ...)

dseconds(x = 1)

dminutes(x = 1)

dhours(x = 1)

ddays(x = 1)

dweeks(x = 1)

dmonths(x = 1)

dyears(x = 1)

dmilliseconds(x = 1)

dmicroseconds(x = 1)

dnanoseconds(x = 1)

dpicoseconds(x = 1)

is.duration(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duration_+3A_num">num</code></td>
<td>
<p>the number or a character vector of time units. In string
representation all unambiguous name units and abbreviations and ISO 8601
formats are supported; 'm' stands for month and 'M' for minutes unless ISO
8601 &quot;P&quot; modifier is present (see examples). Fractional units are
supported.</p>
</td></tr>
<tr><td><code id="duration_+3A_units">units</code></td>
<td>
<p>a character string that specifies the type of units that <code>num</code>
refers to. When <code>num</code> is character, this argument is ignored.</p>
</td></tr>
<tr><td><code id="duration_+3A_...">...</code></td>
<td>
<p>a list of time units to be included in the duration and their
amounts. Seconds, minutes, hours, days, weeks, months and years are
supported. Durations of months and years assume that year consists of
365.25 days.</p>
</td></tr>
<tr><td><code id="duration_+3A_x">x</code></td>
<td>
<p>numeric value of the number of units to be contained in the
duration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Durations record the exact number of seconds in a time span. They measure the
exact passage of time but do not always align with measurements
made in larger units of time such as hours, months and years.
This is because the length of larger time units can be affected
by conventions such as leap years
and Daylight Savings Time. Base R provides a second class for measuring
durations, the difftime class.
</p>
<p>Duration objects can be easily created with the helper functions <code><a href="#topic+dweeks">dweeks()</a></code>,
<code><a href="#topic+ddays">ddays()</a></code>, <code><a href="#topic+dminutes">dminutes()</a></code>, <code><a href="#topic+dseconds">dseconds()</a></code>. These objects can be added to and
subtracted to date- times to create a user interface similar to object
oriented programming.
</p>


<h3>Value</h3>

<p>a duration object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.duration">as.duration()</a></code> <a href="#topic+Duration-class">Duration</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Separate period and units vectors

duration(90, "seconds")
duration(1.5, "minutes")
duration(-1, "days")

### Units as arguments

duration(day = -1)
duration(second = 90)
duration(minute = 1.5)
duration(mins = 1.5)
duration(second = 3, minute = 1.5, hour = 2, day = 6, week = 1)
duration(hour = 1, minute = -60)

### Parsing

duration("2M 1sec")
duration("2hours 2minutes 1second")
duration("2d 2H 2M 2S")
duration("2days 2hours 2mins 2secs")
# Missing numerals default to 1. Repeated units are added up.
duration("day day")

### ISO 8601 parsing

duration("P3Y6M4DT12H30M5S")
duration("P23DT23H") # M stands for months
duration("10DT10M") # M stands for minutes
duration("P23DT60H 20min 100 sec") # mixing ISO and lubridate style parsing

# Comparison with characters (from v1.6.0)

duration("day 2 sec") &gt; "day 1sec"


## ELEMENTARY CONSTRUCTORS:

dseconds(1)
dminutes(3.5)

x &lt;- ymd("2009-08-03", tz = "America/Chicago")
x + ddays(1) + dhours(6) + dminutes(30)
x + ddays(100) - dhours(8)

class(as.Date("2009-08-09") + ddays(1)) # retains Date class
as.Date("2009-08-09") + dhours(12)
class(as.Date("2009-08-09") + dhours(12))
# converts to POSIXt class to accomodate time units

dweeks(1) - ddays(7)
c(1:3) * dhours(1)

# compare DST handling to durations
boundary &lt;- ymd_hms("2009-03-08 01:59:59", tz = "America/Chicago")
boundary + days(1) # period
boundary + ddays(1) # duration
is.duration(as.Date("2009-08-03")) # FALSE
is.duration(duration(days = 12.4)) # TRUE
</code></pre>

<hr>
<h2 id='Duration-class'>Duration class</h2><span id='topic+Duration-class'></span><span id='topic+durations'></span>

<h3>Description</h3>

<p>Duration is an S4 class that extends the <a href="#topic+Timespan-class">Timespan</a> class.
Durations record the exact number of seconds in a time span. They measure the
exact passage of time but do not always align with measurements
made in larger units of time such as hours, months and years.
This is because the exact length of larger time units can be affected
by conventions such as leap years
and Daylight Savings Time.
</p>


<h3>Details</h3>

<p>Durations provide a method for measuring generalized timespans when we wish to
treat time as a mathematical quantity that increases in a uniform, monotone manner
along a continuous numberline. They allow exact comparisons with other durations.
See <a href="#topic+Period-class">Period</a> for an alternative way to measure timespans that better
preserves clock times.
</p>
<p>Durations class objects have one slot: .Data, a numeric object equal to the number
of seconds in the duration.
</p>

<hr>
<h2 id='fit_to_timeline'>Fit a POSIXlt date-time to the timeline</h2><span id='topic+fit_to_timeline'></span>

<h3>Description</h3>

<p>The POSIXlt format allows you to create instants that do not exist in real
life due to daylight savings time and other conventions. fit_to_timeline
matches POSIXlt date-times to a real times. If an instant does not exist, fit
to timeline will replace it with an NA. If an instant does exist, but has
been paired with an incorrect timezone/daylight savings time combination,
fit_to_timeline returns the instant with the correct combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_to_timeline(lt, class = "POSIXct", simple = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_to_timeline_+3A_lt">lt</code></td>
<td>
<p>a POSIXlt date-time object.</p>
</td></tr>
<tr><td><code id="fit_to_timeline_+3A_class">class</code></td>
<td>
<p>a character string that describes what type of object to return,
POSIXlt or POSIXct. Defaults to POSIXct. This is an optimization to avoid
needless conversions.</p>
</td></tr>
<tr><td><code id="fit_to_timeline_+3A_simple">simple</code></td>
<td>
<p>if TRUE, <span class="pkg">lubridate</span> makes no attempt to detect
meaningless time-dates or to correct time zones. No NAs are produced and
the most meaningful valid dates are returned instead. See examples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a POSIXct or POSIXlt object that contains no illusory date-times
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

tricky &lt;- structure(list(
  sec = c(5, 0, 0, -1),
  min = c(0L, 5L, 5L, 0L),
  hour = c(2L, 0L, 2L, 2L),
  mday = c(4L, 4L, 14L, 4L),
  mon = c(10L, 10L, 2L, 10L),
  year = c(112L, 112L, 110L, 112L),
  wday = c(0L, 0L, 0L, 0L),
  yday = c(308L, 308L, 72L, 308L),
  isdst = c(1L, 0L, 0L, 1L)
),
.Names = c(
  "sec", "min", "hour", "mday", "mon",
  "year", "wday", "yday", "isdst"
),
class = c("POSIXlt", "POSIXt"),
tzone = c("America/Chicago", "CST", "CDT")
)

tricky
## [1] "2012-11-04 02:00:00 CDT" Doesn't exist because clocks "fall back" to 1:00 CST
## [2] "2012-11-04 00:05:00 CST" Times are still CDT, not CST at this instant
## [3] "2010-03-14 02:00:00 CDT" DST gap
## [4] "2012-11-04 01:59:59 CDT" Does exist, but has deceptive internal structure

fit_to_timeline(tricky)
## Returns:
## [1] "2012-11-04 02:00:00 CST" instant paired with correct tz &amp; DST combination
## [2] "2012-11-04 00:05:00 CDT" instant paired with correct tz &amp; DST combination
## [3] NA - fake time changed to NA (compare to as.POSIXct(tricky))
## [4] "2012-11-04 01:59:59 CDT" -real instant, left as is

fit_to_timeline(tricky, simple = TRUE)
## Returns valid time-dates by extrapolating CDT and CST zones:
## [1] "2012-11-04 01:00:05 CST" "2012-11-04 01:05:00 CDT"
## [3] "2010-03-14 03:05:00 CDT" "2012-11-04 01:59:59 CDT"

## End(Not run)
</code></pre>

<hr>
<h2 id='force_tz'>Replace time zone to create new date-time</h2><span id='topic+force_tz'></span><span id='topic+force_tz.default'></span><span id='topic+force_tzs'></span>

<h3>Description</h3>

<p><code>force_tz</code> returns the date-time that has the same clock time as input time,
but in the new time zone. <code>force_tzs</code> is the parallel version of <code>force_tz</code>,
meaning that every element from <code>time</code> argument is matched with the
corresponding time zone in <code>tzones</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>force_tz(time, tzone = "", ...)

## Default S3 method:
force_tz(time, tzone = "", roll_dst = c("NA", "post"), roll = NULL, ...)

force_tzs(
  time,
  tzones,
  tzone_out = "UTC",
  roll_dst = c("NA", "post"),
  roll = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="force_tz_+3A_time">time</code></td>
<td>
<p>a POSIXct, POSIXlt, Date, chron date-time object, or a data.frame
object. When a data.frame all POSIXt elements of a data.frame are processed
with <code>force_tz()</code> and new data.frame is returned.</p>
</td></tr>
<tr><td><code id="force_tz_+3A_tzone">tzone</code></td>
<td>
<p>a character string containing the time zone to convert to. R
must recognize the name contained in the string as a time zone on your
system.</p>
</td></tr>
<tr><td><code id="force_tz_+3A_...">...</code></td>
<td>
<p>Parameters passed to other methods.</p>
</td></tr>
<tr><td><code id="force_tz_+3A_roll_dst">roll_dst</code></td>
<td>
<p>is a string vector of length one or two. When two values are
supplied they specify how to roll date-times when they fall into &quot;skipped&quot; and
&quot;repeated&quot; DST transitions respectively. A single value is replicated to the
length of two. Possible values are:
</p>
<div class="sourceCode"><pre>* `pre` - Use the time before the transition boundary.
* `boundary` - Use the time exactly at the boundary transition.
* `post` - Use the time after the boundary transition.
* `xfirst` - crossed-first: First time which occurred when crossing the
   boundary. For addition with positive units pre interval is crossed first and
   post interval last. With negative units post interval is crossed first, pre -
   last. For subtraction the logic is reversed.
* `xlast` - crossed-last.
* `NA` - Produce NAs when the resulting time falls inside the problematic interval.
</pre></div>
<p>For example 'roll_dst = c(&quot;NA&quot;, &quot;pre&quot;) indicates that for skiped intervals
return NA and for repeated times return the earlier time.
</p>
<p>When multiple units are supplied the meaning of &quot;negative period&quot; is determined by
the largest unit. For example <code>time_add(t, days = -1, hours = 2, roll_dst = "xfirst")</code> would operate as if with negative period, thus crossing the boundary
from the &quot;post&quot; to &quot;pre&quot; side and &quot;xfirst&quot; and hence resolving to &quot;post&quot;
time. As this might result in confusing behavior. See examples.
</p>
<p>&quot;xfirst&quot; and &quot;xlast&quot; make sense for addition and subtraction only. An error is
raised if an attempt is made to use them with other functions.</p>
</td></tr>
<tr><td><code id="force_tz_+3A_roll">roll</code></td>
<td>
<p>deprecated, same as <code>roll_dst</code> parameter.</p>
</td></tr>
<tr><td><code id="force_tz_+3A_tzones">tzones</code></td>
<td>
<p>character vector of timezones to be &quot;enforced&quot; on <code>time</code> time
stamps. If <code>time</code> and <code>tzones</code> lengths differ, the smaller one is recycled
in accordance with usual R conventions.</p>
</td></tr>
<tr><td><code id="force_tz_+3A_tzone_out">tzone_out</code></td>
<td>
<p>timezone of the returned date-time vector (for <code>force_tzs</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although the new date-time has the same clock time (e.g. the same values in
the year, month, days, etc. elements) it is a different moment of time than
the input date-time.
</p>
<p>As R date-time vectors cannot hold elements with non-uniform time zones,
<code>force_tzs</code> returns a vector with time zone <code>tzone_out</code>, UTC by default.
</p>


<h3>Value</h3>

<p>a POSIXct object in the updated time zone
</p>


<h3>See Also</h3>

<p><code><a href="#topic+with_tz">with_tz()</a></code>, <code><a href="#topic+local_time">local_time()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ymd_hms("2009-08-07 00:00:01", tz = "America/New_York")
force_tz(x, "UTC")
force_tz(x, "Europe/Amsterdam")

## DST skip:
y &lt;- ymd_hms("2010-03-14 02:05:05 UTC")
force_tz(y, "America/New_York", roll_dst = "NA")
force_tz(y, "America/New_York", roll_dst = "pre")
force_tz(y, "America/New_York", roll_dst = "boundary")
force_tz(y, "America/New_York", roll_dst = "post")

## DST repeat
y &lt;- ymd_hms("2014-11-02 01:35:00", tz = "UTC")
force_tz(y, "America/New_York", roll_dst = "NA")
force_tz(y, "America/New_York", roll_dst = "pre")
force_tz(y, "America/New_York", roll_dst = "boundary")
force_tz(y, "America/New_York", roll_dst = "post")

## DST skipped and repeated
y &lt;- ymd_hms("2010-03-14 02:05:05 UTC", "2014-11-02 01:35:00", tz = "UTC")
force_tz(y, "America/New_York", roll_dst = c("NA", "pre"))
force_tz(y, "America/New_York", roll_dst = c("boundary", "post"))

## Heterogeneous time-zones:

x &lt;- ymd_hms(c("2009-08-07 00:00:01", "2009-08-07 01:02:03"))
force_tzs(x, tzones = c("America/New_York", "Europe/Amsterdam"))
force_tzs(x, tzones = c("America/New_York", "Europe/Amsterdam"), tzone_out = "America/New_York")

x &lt;- ymd_hms("2009-08-07 00:00:01")
force_tzs(x, tzones = c("America/New_York", "Europe/Amsterdam"))
</code></pre>

<hr>
<h2 id='format_ISO8601'>Format in ISO8601 character format</h2><span id='topic+format_ISO8601'></span><span id='topic+format_ISO8601+2CDate-method'></span><span id='topic+format_ISO8601+2CPOSIXt-method'></span><span id='topic+format_ISO8601+2CInterval-method'></span><span id='topic+format_ISO8601+2CDuration-method'></span><span id='topic+format_ISO8601+2CPeriod-method'></span>

<h3>Description</h3>

<p>Format in ISO8601 character format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_ISO8601(x, usetz = FALSE, precision = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_ISO8601_+3A_x">x</code></td>
<td>
<p>An object to convert to ISO8601 character format.</p>
</td></tr>
<tr><td><code id="format_ISO8601_+3A_usetz">usetz</code></td>
<td>
<p>Include the time zone in the formatting.  If
<code>usetz</code> is <code>TRUE</code>, the time zone is included. If
<code>usetz</code> is <code>"Z"</code>, the time is converted to &quot;UTC&quot; and
the time zone is indicated with &quot;Z&quot; ISO8601 notation.</p>
</td></tr>
<tr><td><code id="format_ISO8601_+3A_precision">precision</code></td>
<td>
<p>The amount of precision to represent with
substrings of &quot;ymdhms&quot;, as &quot;y&quot;ear, &quot;m&quot;onth, &quot;d&quot;ay, &quot;h&quot;our,
&quot;m&quot;inute, and &quot;s&quot;econd. (e.g. &quot;ymdhm&quot; would show precision
through minutes.  When <code>NULL</code>, full precision for the object
is shown.</p>
</td></tr>
<tr><td><code id="format_ISO8601_+3A_...">...</code></td>
<td>
<p>Additional arguments to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of ISO8601-formatted text.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/ISO_8601">https://en.wikipedia.org/wiki/ISO_8601</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>format_ISO8601(as.Date("02-01-2018", format = "%m-%d-%Y"))
format_ISO8601(as.POSIXct("2018-02-01 03:04:05", tz = "EST"), usetz = TRUE)
format_ISO8601(as.POSIXct("2018-02-01 03:04:05", tz = "EST"), precision = "ymdhm")
</code></pre>

<hr>
<h2 id='format_ISO8601_precision_check'>Provide a format for ISO8601 dates and times with the requested precision.</h2><span id='topic+format_ISO8601_precision_check'></span>

<h3>Description</h3>

<p>Provide a format for ISO8601 dates and times with the requested precision.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_ISO8601_precision_check(precision, max_precision, usetz = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_ISO8601_precision_check_+3A_precision">precision</code></td>
<td>
<p>The amount of precision to represent with
substrings of &quot;ymdhms&quot;, as &quot;y&quot;ear, &quot;m&quot;onth, &quot;d&quot;ay, &quot;h&quot;our,
&quot;m&quot;inute, and &quot;s&quot;econd. (e.g. &quot;ymdhm&quot; would show precision
through minutes.  When <code>NULL</code>, full precision for the object
is shown.</p>
</td></tr>
<tr><td><code id="format_ISO8601_precision_check_+3A_max_precision">max_precision</code></td>
<td>
<p>The maximum precision allowed to be output.</p>
</td></tr>
<tr><td><code id="format_ISO8601_precision_check_+3A_usetz">usetz</code></td>
<td>
<p>Include the time zone in the formatting.  If
<code>usetz</code> is <code>TRUE</code>, the time zone is included. If
<code>usetz</code> is <code>"Z"</code>, the time is converted to &quot;UTC&quot; and
the time zone is indicated with &quot;Z&quot; ISO8601 notation.</p>
</td></tr>
</table>

<hr>
<h2 id='guess_formats'>Guess possible date-times formats from a character vector</h2><span id='topic+guess_formats'></span>

<h3>Description</h3>

<p>Guess possible date-times formats from a character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess_formats(
  x,
  orders,
  locale = Sys.getlocale("LC_TIME"),
  preproc_wday = TRUE,
  print_matches = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guess_formats_+3A_x">x</code></td>
<td>
<p>input vector of date-times.</p>
</td></tr>
<tr><td><code id="guess_formats_+3A_orders">orders</code></td>
<td>
<p>format orders to look for. See examples.</p>
</td></tr>
<tr><td><code id="guess_formats_+3A_locale">locale</code></td>
<td>
<p>locale to use. Defaults to the current locale.</p>
</td></tr>
<tr><td><code id="guess_formats_+3A_preproc_wday">preproc_wday</code></td>
<td>
<p>whether to preprocess weekday names. Internal
optimization used by <code>ymd_hms()</code> family of functions. If <code>TRUE</code>, weekdays are
substituted with %a or %A accordingly, so that there is no need to supply
this format explicitly.</p>
</td></tr>
<tr><td><code id="guess_formats_+3A_print_matches">print_matches</code></td>
<td>
<p>for development purposes mainly. If <code>TRUE</code>, prints a matrix
of matched templates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of matched formats
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- c('February 20th 1973',
       "february  14, 2004",
       "Sunday, May 1, 2000",
       "Sunday, May 1, 2000",
       "february  14, 04",
       'Feb 20th 73',
       "January 5 1999 at 7pm",
       "jan 3 2010",
       "Jan 1, 1999",
       "jan 3   10",
       "01 3 2010",
       "1 3 10",
       '1 13 89',
       "5/27/1979",
       "12/31/99",
       "DOB:12/11/00",
       "-----------",
       'Thu, 1 July 2004 22:30:00',
       'Thu, 1st of July 2004 at 22:30:00',
       'Thu, 1July 2004 at 22:30:00',
       'Thu, 1July2004 22:30:00',
       'Thu, 1July04 22:30:00',
       "21 Aug 2011, 11:15:34 pm",
       "-----------",
       "1979-05-27 05:00:59",
       "1979-05-27",
       "-----------",
       "3 jan 2000",
       "17 april 85",
       "27/5/1979",
       '20 01 89',
       '00/13/10',
       "-------",
       "14 12 00",
       "03:23:22 pm")

guess_formats(x, "BdY")
guess_formats(x, "Bdy")
## m also matches b and B; y also matches Y
guess_formats(x, "mdy", print_matches = TRUE)

## T also matches IMSp order
guess_formats(x, "T", print_matches = TRUE)

## b and B are equivalent and match, both, abreviated and full names
guess_formats(x, c("mdY", "BdY", "Bdy", "bdY", "bdy"), print_matches = TRUE)
guess_formats(x, c("dmy", "dbY", "dBy", "dBY"), print_matches = TRUE)


guess_formats(x, c("dBY HMS", "dbY HMS", "dmyHMS", "BdY H"), print_matches = TRUE)

guess_formats(x, c("ymd HMS"), print_matches = TRUE)

</code></pre>

<hr>
<h2 id='hidden_aliases'>Internal page for hidden aliases</h2><span id='topic+hidden_aliases'></span><span id='topic+day+3C-+2CDate-method'></span><span id='topic+hour+3C-+2CDate-method'></span><span id='topic+minute+3C-+2CDate-method'></span><span id='topic+month+3C-+2CDate-method'></span><span id='topic+second+3C-+2CDate-method'></span><span id='topic+year+3C-+2CDate-method'></span><span id='topic+day+3C-+2CPOSIXt-method'></span><span id='topic+hour+3C-+2CPOSIXt-method'></span><span id='topic+minute+3C-+2CPOSIXt-method'></span><span id='topic+month+3C-+2CPOSIXt-method'></span><span id='topic+second+3C-+2CPOSIXt-method'></span><span id='topic+year+3C-+2CPOSIXt-method'></span><span id='topic+Arith+2CInterval+2CANY-method'></span><span id='topic+Arith+2CANY+2CInterval-method'></span><span id='topic+intersect+2CInterval+2CInterval-method'></span><span id='topic+union+2CInterval+2CInterval-method'></span><span id='topic+setdiff+2CInterval+2CInterval-method'></span><span id='topic+as.numeric+2CInterval-method'></span><span id='topic+as.integer+2CInterval-method'></span><span id='topic+show+2CInterval-method'></span><span id='topic+c+2CInterval-method'></span><span id='topic+rep+2CInterval-method'></span><span id='topic++5B+2CInterval-method'></span><span id='topic++5B+3C-+2CInterval+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+5B+2CInterval-method'></span><span id='topic++5B+5B+3C-+2CInterval+2CANY+2CANY+2CANY-method'></span><span id='topic++24+2CInterval-method'></span><span id='topic++24+3C-+2CInterval-method'></span><span id='topic+as.difftime+2CInterval-method'></span><span id='topic+as.character+2CInterval-method'></span><span id='topic+day+3C-+2CInterval-method'></span><span id='topic+hour+3C-+2CInterval-method'></span><span id='topic+minute+3C-+2CInterval-method'></span><span id='topic+month+3C-+2CInterval-method'></span><span id='topic+second+3C-+2CInterval-method'></span><span id='topic+year+3C-+2CInterval-method'></span><span id='topic++2B+2CInterval+2CDuration-method'></span><span id='topic++2B+2CInterval+2CInterval-method'></span><span id='topic++2B+2CInterval+2CPeriod-method'></span><span id='topic++2B+2CInterval+2CDate-method'></span><span id='topic++2B+2CDate+2CInterval-method'></span><span id='topic++2B+2CInterval+2Cdifftime-method'></span><span id='topic++2B+2Cdifftime+2CInterval-method'></span><span id='topic++2B+2CInterval+2Cnumeric-method'></span><span id='topic++2B+2Cnumeric+2CInterval-method'></span><span id='topic++2B+2CInterval+2CPOSIXct-method'></span><span id='topic++2B+2CPOSIXct+2CInterval-method'></span><span id='topic++2B+2CInterval+2CPOSIXlt-method'></span><span id='topic++2B+2CPOSIXlt+2CInterval-method'></span><span id='topic++2F+2CInterval+2CDuration-method'></span><span id='topic++2F+2CInterval+2CInterval-method'></span><span id='topic++2F+2CInterval+2CPeriod-method'></span><span id='topic++2F+2CInterval+2Cdifftime-method'></span><span id='topic++2F+2Cdifftime+2CInterval-method'></span><span id='topic++2F+2CInterval+2Cnumeric-method'></span><span id='topic++2F+2Cnumeric+2CInterval-method'></span><span id='topic++2A+2CInterval+2CANY-method'></span><span id='topic++2A+2CANY+2CInterval-method'></span><span id='topic+-+2CInterval+2Cmissing-method'></span><span id='topic+-+2CInterval+2CInterval-method'></span><span id='topic+-+2CDate+2CInterval-method'></span><span id='topic+-+2CPOSIXct+2CInterval-method'></span><span id='topic+-+2CPOSIXlt+2CInterval-method'></span><span id='topic+-+2Cnumeric+2CInterval-method'></span><span id='topic+-+2CInterval+2CDate-method'></span><span id='topic+-+2CInterval+2CPOSIXct-method'></span><span id='topic+-+2CInterval+2CPOSIXlt-method'></span><span id='topic+-+2CInterval+2Cnumeric-method'></span><span id='topic+-+2CDuration+2CInterval-method'></span><span id='topic+-+2CPeriod+2CInterval-method'></span><span id='topic++25+25+2CInterval+2CDuration-method'></span><span id='topic++25+25+2CInterval+2CInterval-method'></span><span id='topic++25+25+2CInterval+2CPeriod-method'></span><span id='topic++25+25+2CInterval+2CDuration'></span><span id='topic++25+25+2CInterval+2CInterval'></span><span id='topic++25+25+2CInterval+2CPeriod'></span><span id='topic+-+2CDate+2CInterval'></span><span id='topic+-+2CDuration+2CInterval'></span><span id='topic+-+2CInterval+2CDate'></span><span id='topic+-+2CInterval+2CInterval'></span><span id='topic+-+2CInterval+2CPOSIXct'></span><span id='topic+-+2CInterval+2CPOSIXlt'></span><span id='topic+-+2CInterval+2Cnumeric'></span><span id='topic+-+2CPOSIXct+2CInterval'></span><span id='topic+-+2CPOSIXlt+2CInterval'></span><span id='topic+-+2Cnumeric+2CInterval'></span><span id='topic+-+2CInterval+2CDuration-method'></span><span id='topic+-+2CInterval+2CPeriod-method'></span><span id='topic+Compare+2CDuration+2CANY-method'></span><span id='topic+Compare+2CDuration+2CDuration-method'></span><span id='topic+Compare+2Cdifftime+2CDuration-method'></span><span id='topic+Compare+2CANY+2CDuration-method'></span><span id='topic+Compare+2CDuration+2CPeriod-method'></span><span id='topic+Compare+2CDuration+2Cdifftime-method'></span><span id='topic+Compare+2Ccharacter+2CDuration-method'></span><span id='topic+Compare+2CDuration+2Ccharacter-method'></span><span id='topic+Compare+2Cnumeric+2CDuration-method'></span><span id='topic+Compare+2CDuration+2Cnumeric-method'></span><span id='topic+as.numeric+2CDuration-method'></span><span id='topic+as.integer+2CDuration-method'></span><span id='topic+show+2CDuration-method'></span><span id='topic+c+2CDuration-method'></span><span id='topic+rep+2CDuration-method'></span><span id='topic++5B+2CDuration-method'></span><span id='topic++5B+3C-+2CDuration+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+5B+2CDuration-method'></span><span id='topic++5B+5B+3C-+2CDuration+2CANY+2CANY+2CANY-method'></span><span id='topic++24+2CDuration-method'></span><span id='topic++24+3C-+2CDuration-method'></span><span id='topic+as.difftime+2CDuration-method'></span><span id='topic+day+3C-+2CDuration-method'></span><span id='topic+hour+3C-+2CDuration-method'></span><span id='topic+minute+3C-+2CDuration-method'></span><span id='topic+month+3C-+2CDuration-method'></span><span id='topic+second+3C-+2CDuration-method'></span><span id='topic+year+3C-+2CDuration-method'></span><span id='topic+as.character+2CDuration-method'></span><span id='topic++2B+2CDuration+2CDuration-method'></span><span id='topic++2B+2CDuration+2CInterval-method'></span><span id='topic++2B+2CDuration+2CPeriod-method'></span><span id='topic++2B+2CDuration+2CDate-method'></span><span id='topic++2B+2CDate+2CDuration-method'></span><span id='topic++2B+2CDuration+2Cdifftime-method'></span><span id='topic++2B+2Cdifftime+2CDuration-method'></span><span id='topic++2B+2CDuration+2Cnumeric-method'></span><span id='topic++2B+2Cnumeric+2CDuration-method'></span><span id='topic++2B+2CDuration+2CPOSIXct-method'></span><span id='topic++2B+2CPOSIXct+2CDuration-method'></span><span id='topic++2B+2CDuration+2CPOSIXlt-method'></span><span id='topic++2B+2CPOSIXlt+2CDuration-method'></span><span id='topic+-+2CDuration+2CANY-method'></span><span id='topic++2F+2CDuration+2CDuration-method'></span><span id='topic++2F+2CDuration+2CInterval-method'></span><span id='topic++2F+2CDuration+2CPeriod-method'></span><span id='topic++2F+2CDuration+2Cdifftime-method'></span><span id='topic++2F+2Cdifftime+2CDuration-method'></span><span id='topic++2F+2CDuration+2Cnumeric-method'></span><span id='topic++2F+2Cnumeric+2CDuration-method'></span><span id='topic++2A+2CDuration+2CANY-method'></span><span id='topic++2A+2CANY+2CDuration-method'></span><span id='topic++25+25+2CDuration+2CDuration-method'></span><span id='topic++25+25+2CDuration+2CInterval-method'></span><span id='topic++25+25+2CDuration+2CPeriod-method'></span><span id='topic+-+2CDuration+2Cmissing-method'></span><span id='topic+-+2CANY+2CDuration-method'></span><span id='topic+-+2CDuration+2CDuration-method'></span><span id='topic+-+2CDuration+2CDate-method'></span><span id='topic+-+2CDuration+2CPOSIXct-method'></span><span id='topic+-+2CDuration+2CPOSIXlt-method'></span><span id='topic+-+2CDuration+2CPeriod-method'></span><span id='topic+-+2CDuration+2Cnumeric-method'></span><span id='topic+-+2CPOSIXct+2CDuration-method'></span><span id='topic+-+2Cnumeric+2CDuration-method'></span><span id='topic+-+2CPOSIXlt+2CDuration-method'></span><span id='topic+-+2CDate+2CDuration-method'></span><span id='topic+Arith+2CANY+2CPeriod-method'></span><span id='topic+Arith+2CDuration+2CPeriod-method'></span><span id='topic+Arith+2CPeriod+2CDuration-method'></span><span id='topic+Compare+2CPeriod+2CDuration-method'></span><span id='topic+Compare+2Cnumeric+2CPeriod-method'></span><span id='topic+Compare+2Cdifftime+2CPeriod-method'></span><span id='topic+Compare+2CPeriod+2Cdifftime-method'></span><span id='topic+Compare+2CPeriod+2CPeriod-method'></span><span id='topic+Compare+2CPeriod+2Ccharacter-method'></span><span id='topic+Compare+2CPeriod+2Cnumeric-method'></span><span id='topic+Compare+2Ccharacter+2CPeriod-method'></span><span id='topic+second+2CPeriod-method'></span><span id='topic+second+3C-+2CPeriod-method'></span><span id='topic+minute+2CPeriod-method'></span><span id='topic+minute+3C-+2CPeriod-method'></span><span id='topic+hour+2CPeriod-method'></span><span id='topic+hour+3C-+2CPeriod-method'></span><span id='topic+Arith+2CPeriod+2CANY-method'></span><span id='topic+day+2CPeriod-method'></span><span id='topic+day+3C-+2CPeriod-method'></span><span id='topic+month+2CPeriod-method'></span><span id='topic+month+3C-+2CPeriod-method'></span><span id='topic+year+2CPeriod-method'></span><span id='topic+year+3C-+2CPeriod-method'></span><span id='topic+date+2CPeriod-method'></span><span id='topic+date+3C-+2CPeriod-method'></span><span id='topic+as.numeric+2CPeriod-method'></span><span id='topic+as.integer+2CPeriod-method'></span><span id='topic+show+2CPeriod-method'></span><span id='topic+c+2CPeriod-method'></span><span id='topic+rep+2CPeriod-method'></span><span id='topic++5B+2CPeriod-method'></span><span id='topic++5B+3C-+2CPeriod+2CANY+2CANY+2CPeriod-method'></span><span id='topic++5B+5B+2CPeriod-method'></span><span id='topic++5B+5B+3C-+2CPeriod+2CANY+2CANY+2CPeriod-method'></span><span id='topic++24+2CPeriod-method'></span><span id='topic++24+3C-+2CPeriod-method'></span><span id='topic+as.difftime+2CPeriod-method'></span><span id='topic+as.character+2CPeriod-method'></span><span id='topic++2B+2CPeriod+2CDuration-method'></span><span id='topic++2B+2CPeriod+2CInterval-method'></span><span id='topic++2B+2CPeriod+2CPeriod-method'></span><span id='topic++2B+2CPeriod+2CDate-method'></span><span id='topic++2B+2CDate+2CPeriod-method'></span><span id='topic++2B+2CPeriod+2Cdifftime-method'></span><span id='topic++2B+2Cdifftime+2CPeriod-method'></span><span id='topic++2B+2CPeriod+2Cnumeric-method'></span><span id='topic++2B+2Cnumeric+2CPeriod-method'></span><span id='topic++2B+2CPeriod+2CPOSIXct-method'></span><span id='topic++2B+2CPOSIXct+2CPeriod-method'></span><span id='topic++2B+2CPeriod+2CPOSIXlt-method'></span><span id='topic++2B+2CPOSIXlt+2CPeriod-method'></span><span id='topic++2F+2CPeriod+2CDuration-method'></span><span id='topic++2F+2CPeriod+2CInterval-method'></span><span id='topic++2F+2CPeriod+2CPeriod-method'></span><span id='topic++2F+2CPeriod+2Cdifftime-method'></span><span id='topic++2F+2Cdifftime+2CPeriod-method'></span><span id='topic++2F+2CPeriod+2Cnumeric-method'></span><span id='topic++2F+2Cnumeric+2CPeriod-method'></span><span id='topic++2A+2CPeriod+2CANY-method'></span><span id='topic++2A+2CANY+2CPeriod-method'></span><span id='topic+-+2CPeriod+2CANY-method'></span><span id='topic+-+2CPeriod+2Cmissing-method'></span><span id='topic+-+2CANY+2CPeriod-method'></span><span id='topic+-+2CPeriod+2CPeriod-method'></span><span id='topic++25+25+2CPeriod+2CDuration-method'></span><span id='topic++25+25+2CPeriod+2CInterval-method'></span><span id='topic++25+25+2CPeriod+2CPeriod-method'></span><span id='topic++3E+2CPeriod+2CPeriod-method'></span><span id='topic++3E+3D+2CPeriod+2CPeriod-method'></span><span id='topic++3D+3D+2CPeriod+2CPeriod-method'></span><span id='topic++21+3D+2CPeriod+2CPeriod-method'></span><span id='topic++3C+3D+2CPeriod+2CPeriod-method'></span><span id='topic++3C+2CPeriod+2CPeriod-method'></span><span id='topic++3E+2CPeriod+2CDuration-method'></span><span id='topic++3E+3D+2CPeriod+2CDuration-method'></span><span id='topic++3D+3D+2CPeriod+2CDuration-method'></span><span id='topic++21+3D+2CPeriod+2CDuration-method'></span><span id='topic++3C+3D+2CPeriod+2CDuration-method'></span><span id='topic++3C+2CPeriod+2CDuration-method'></span><span id='topic++3E+2CDuration+2CPeriod-method'></span><span id='topic++3E+3D+2CDuration+2CPeriod-method'></span><span id='topic++3D+3D+2CDuration+2CPeriod-method'></span><span id='topic++21+3D+2CDuration+2CPeriod-method'></span><span id='topic++3C+3D+2CDuration+2CPeriod-method'></span><span id='topic++3C+2CDuration+2CPeriod-method'></span><span id='topic++3E+2CPeriod+2Cnumeric-method'></span><span id='topic++3E+3D+2CPeriod+2Cnumeric-method'></span><span id='topic++3D+3D+2CPeriod+2Cnumeric-method'></span><span id='topic++21+3D+2CPeriod+2Cnumeric-method'></span><span id='topic++3C+3D+2CPeriod+2Cnumeric-method'></span><span id='topic++3C+2CPeriod+2Cnumeric-method'></span><span id='topic++3E+2Cnumeric+2CPeriod-method'></span><span id='topic++3E+3D+2Cnumeric+2CPeriod-method'></span><span id='topic++3D+3D+2Cnumeric+2CPeriod-method'></span><span id='topic++21+3D+2Cnumeric+2CPeriod-method'></span><span id='topic++3C+3D+2Cnumeric+2CPeriod-method'></span><span id='topic++3C+2Cnumeric+2CPeriod-method'></span><span id='topic++21+3D+2CDuration+2CPeriod'></span><span id='topic++21+3D+2CPeriod+2CDuration'></span><span id='topic++21+3D+2CPeriod+2CPeriod'></span><span id='topic++21+3D+2CPeriod+2Cnumeric'></span><span id='topic++21+3D+2Cnumeric+2CPeriod'></span><span id='topic++25+25+2CPeriod+2CDuration'></span><span id='topic++25+25+2CPeriod+2CInterval'></span><span id='topic++25+25+2CPeriod+2CPeriod'></span><span id='topic++2A+2CANY+2CPeriod'></span><span id='topic++2A+2CPeriod+2CANY'></span><span id='topic+-+2CANY+2CPeriod'></span><span id='topic+-+2CPeriod+2CInterval'></span><span id='topic+-+2CPeriod+2Cmissing'></span><span id='topic++2F+2Cnumeric+2CPeriod'></span><span id='topic++3C+2CDuration+2CPeriod'></span><span id='topic++3C+2CPeriod+2CDuration'></span><span id='topic++3C+2CPeriod+2CPeriod'></span><span id='topic++3C+2CPeriod+2Cnumeric'></span><span id='topic++3C+2Cnumeric+2CPeriod'></span><span id='topic++3C+3D+2CDuration+2CPeriod'></span><span id='topic++3C+3D+2CPeriod+2CDuration'></span><span id='topic++3C+3D+2CPeriod+2CPeriod'></span><span id='topic++3C+3D+2CPeriod+2Cnumeric'></span><span id='topic++3C+3D+2Cnumeric+2CPeriod'></span><span id='topic++3D+3D+2CDuration+2CPeriod'></span><span id='topic++3D+3D+2CPeriod+2CDuration'></span><span id='topic++3D+3D+2CPeriod+2CPeriod'></span><span id='topic++3D+3D+2CPeriod+2Cnumeric'></span><span id='topic++3D+3D+2Cnumeric+2CPeriod'></span><span id='topic++3E+2CDuration+2CPeriod'></span><span id='topic++3E+2CPeriod+2CDuration'></span><span id='topic++3E+2CPeriod+2CPeriod'></span><span id='topic++3E+2CPeriod+2Cnumeric'></span><span id='topic++3E+2Cnumeric+2CPeriod'></span><span id='topic++3E+3D+2CDuration+2CPeriod'></span><span id='topic++3E+3D+2CPeriod+2CDuration'></span><span id='topic++3E+3D+2CPeriod+2CPeriod'></span><span id='topic++3E+3D+2CPeriod+2Cnumeric'></span><span id='topic++3E+3D+2Cnumeric+2CPeriod'></span><span id='topic+-+2CPeriod+2CDate-method'></span><span id='topic+-+2CPeriod+2CDuration-method'></span><span id='topic+-+2CPeriod+2CPOSIXct-method'></span><span id='topic+-+2CPeriod+2CPOSIXlt-method'></span><span id='topic+-+2CPeriod+2Cnumeric-method'></span><span id='topic+-+2CDate+2CPeriod-method'></span><span id='topic+-+2Cnumeric+2CPeriod-method'></span><span id='topic+-+2CPOSIXlt+2CPeriod-method'></span><span id='topic+-+2CPOSIXct+2CPeriod-method'></span>

<h3>Description</h3>

<p>For S4 methods that require a documentation entry but only clutter the index.
</p>

<hr>
<h2 id='hour'>Get/set hours component of a date-time</h2><span id='topic+hour'></span><span id='topic+hour+3C-'></span>

<h3>Description</h3>

<p>Date-time must be a POSIXct, POSIXlt, Date, Period, chron, yearmon, yearqtr, zoo,
zooreg, timeDate, xts, its, ti, jul, timeSeries, and fts objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hour(x)

hour(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hour_+3A_x">x</code></td>
<td>
<p>a date-time object</p>
</td></tr>
<tr><td><code id="hour_+3A_value">value</code></td>
<td>
<p>numeric value to be assigned to the <code>hour</code> component</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the hours element of x as a decimal number
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ymd("2012-03-26")
hour(x)
hour(x) &lt;- 1
hour(x) &lt;- 25
hour(x) &gt; 2
</code></pre>

<hr>
<h2 id='interval'>Utilities for creation and manipulation of <code>Interval</code> objects</h2><span id='topic+interval'></span><span id='topic++25--+25'></span><span id='topic+is.interval'></span><span id='topic+int_start'></span><span id='topic+int_start+3C-'></span><span id='topic+int_end'></span><span id='topic+int_end+3C-'></span><span id='topic+int_length'></span><span id='topic+int_flip'></span><span id='topic+int_shift'></span><span id='topic+int_overlaps'></span><span id='topic+int_standardize'></span><span id='topic+int_aligns'></span><span id='topic+int_diff'></span>

<h3>Description</h3>

<p><code>interval()</code> creates an <a href="#topic+Interval-class">Interval</a> object with the specified start and
end dates. If the start date occurs before the end date, the interval will be
positive. Otherwise, it will be negative. Character vectors in ISO 8601
format are supported from v1.7.2.
</p>
<p><code>int_start()</code>/<code>int_end()</code> and <code style="white-space: pre;">&#8288;int_start&lt;-()&#8288;</code>/<code style="white-space: pre;">&#8288;int_end&lt;-()&#8288;</code> are
&quot;accessors&quot; and &quot;setters&quot; respectively of the start/end date of an
interval.
</p>
<p><code>int_flip()</code> reverses the order of the start date and end date in an
interval. The new interval takes place during the same timespan as the
original interval, but has the opposite direction.
</p>
<p><code>int_shift()</code> shifts the start and end dates of an interval up or down the
timeline by a specified amount. Note that this may change the exact length of
the interval if the interval is shifted by a Period object. Intervals shifted
by a Duration or difftime object will retain their exact length in seconds.
</p>
<p><code>int_overlaps()</code> tests if two intervals overlap.
</p>
<p><code>int_standardize()</code> ensures all intervals in an interval object are
positive. If an interval is not positive, flip it so that it retains its
endpoints but becomes positive.
</p>
<p><code>int_aligns()</code> tests if two intervals share an endpoint. The direction of
each interval is ignored. int_align tests whether the earliest or latest
moments of each interval occur at the same time.
</p>
<p><code>int_diff()</code> returns the intervals that occur between the elements of a
vector of date-times. <code>int_diff()</code> is similar to the POSIXt and Date
methods of <code><a href="base.html#topic+diff">diff()</a></code>, but returns an <a href="#topic+Interval-class">Interval</a> object instead
of a difftime object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interval(start = NULL, end = NULL, tzone = tz(start))

start %--% end

is.interval(x)

int_start(int)

int_start(int) &lt;- value

int_end(int)

int_end(int) &lt;- value

int_length(int)

int_flip(int)

int_shift(int, by)

int_overlaps(int1, int2)

int_standardize(int)

int_aligns(int1, int2)

int_diff(times)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interval_+3A_start">start</code>, <code id="interval_+3A_end">end</code></td>
<td>
<p>POSIXt, Date or a character vectors. When <code>start</code> is a
character vector and end is <code>NULL</code>, ISO 8601 specification is assumed but
with much more permisive lubridate style parsing both for dates and periods
(see examples).</p>
</td></tr>
<tr><td><code id="interval_+3A_tzone">tzone</code></td>
<td>
<p>a recognized timezone to display the interval in</p>
</td></tr>
<tr><td><code id="interval_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="interval_+3A_int">int</code></td>
<td>
<p>an interval object</p>
</td></tr>
<tr><td><code id="interval_+3A_value">value</code></td>
<td>
<p>interval's start/end to be assigned to <code>int</code></p>
</td></tr>
<tr><td><code id="interval_+3A_by">by</code></td>
<td>
<p>A period or duration object to shift by (for <code>int_shift</code>)</p>
</td></tr>
<tr><td><code id="interval_+3A_int1">int1</code></td>
<td>
<p>an Interval object (for <code>int_overlaps()</code>, <code>int_aligns()</code>)</p>
</td></tr>
<tr><td><code id="interval_+3A_int2">int2</code></td>
<td>
<p>an Interval object (for <code>int_overlaps()</code>, <code>int_aligns()</code>)</p>
</td></tr>
<tr><td><code id="interval_+3A_times">times</code></td>
<td>
<p>A vector of POSIXct, POSIXlt or Date class date-times (for
<code>int_diff()</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Intervals are time spans bound by two real date-times.  Intervals can be
accurately converted to either period or duration objects using
<code><a href="#topic+as.period">as.period()</a></code>, <code><a href="#topic+as.duration">as.duration()</a></code>. Since an interval is anchored to a fixed
history of time, both the exact number of seconds that passed and the number
of variable length time units that occurred during the interval can be
calculated.
</p>


<h3>Value</h3>

<p><code>interval()</code> &ndash; <a href="#topic+Interval-class">Interval</a> object.
</p>
<p><code>int_start()</code> and <code>int_end()</code> return a POSIXct date object when
used as an accessor. Nothing when used as a setter.
</p>
<p><code>int_length()</code> &ndash; numeric length of the interval in
seconds. A negative number connotes a negative interval.
</p>
<p><code>int_flip()</code> &ndash; flipped interval object
</p>
<p><code>int_shift()</code> &ndash; an Interval object
</p>
<p><code>int_overlaps()</code> &ndash; logical, TRUE if int1 and int2 overlap by at
least one second. FALSE otherwise
</p>
<p><code>int_aligns()</code> &ndash; logical, TRUE if int1 and int2 begin or end on the
same moment. FALSE otherwise
</p>
<p><code>int_diff()</code> &ndash; interval object that contains the n-1 intervals
between the n date-time in times
</p>


<h3>See Also</h3>

<p><a href="#topic+Interval-class">Interval</a>, <code><a href="#topic+as.interval">as.interval()</a></code>, <code><a href="#topic++25within+25">%within%</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>interval(ymd(20090201), ymd(20090101))

date1 &lt;- ymd_hms("2009-03-08 01:59:59")
date2 &lt;- ymd_hms("2000-02-29 12:00:00")
interval(date2, date1)
interval(date1, date2)
span &lt;- interval(ymd(20090101), ymd(20090201))

### ISO Intervals

interval("2007-03-01T13:00:00Z/2008-05-11T15:30:00Z")
interval("2007-03-01T13:00:00Z/P1Y2M10DT2H30M")
interval("P1Y2M10DT2H30M/2008-05-11T15:30:00Z")
interval("2008-05-11/P2H30M")

### More permisive parsing (as long as there are no intermittent / characters)
interval("2008 05 11/P2hours 30minutes")
interval("08 05 11/P 2h 30m")

is.interval(period(months = 1, days = 15)) # FALSE
is.interval(interval(ymd(20090801), ymd(20090809))) # TRUE
int &lt;- interval(ymd("2001-01-01"), ymd("2002-01-01"))
int_start(int)
int_start(int) &lt;- ymd("2001-06-01")
int

int &lt;- interval(ymd("2001-01-01"), ymd("2002-01-01"))
int_end(int)
int_end(int) &lt;- ymd("2002-06-01")
int
int &lt;- interval(ymd("2001-01-01"), ymd("2002-01-01"))
int_length(int)
int &lt;- interval(ymd("2001-01-01"), ymd("2002-01-01"))
int_flip(int)
int &lt;- interval(ymd("2001-01-01"), ymd("2002-01-01"))
int_shift(int, duration(days = 11))
int_shift(int, duration(hours = -1))
int1 &lt;- interval(ymd("2001-01-01"), ymd("2002-01-01"))
int2 &lt;- interval(ymd("2001-06-01"), ymd("2002-06-01"))
int3 &lt;- interval(ymd("2003-01-01"), ymd("2004-01-01"))

int_overlaps(int1, int2) # TRUE
int_overlaps(int1, int3) # FALSE
int &lt;- interval(ymd("2002-01-01"), ymd("2001-01-01"))
int_standardize(int)
int1 &lt;- interval(ymd("2001-01-01"), ymd("2002-01-01"))
int2 &lt;- interval(ymd("2001-06-01"), ymd("2002-01-01"))
int3 &lt;- interval(ymd("2003-01-01"), ymd("2004-01-01"))

int_aligns(int1, int2) # TRUE
int_aligns(int1, int3) # FALSE
dates &lt;- now() + days(1:10)
int_diff(dates)
</code></pre>

<hr>
<h2 id='Interval-class'>Interval class</h2><span id='topic+Interval-class'></span><span id='topic+intervals'></span>

<h3>Description</h3>

<p>Interval is an S4 class that extends the <a href="#topic+Timespan-class">Timespan</a> class. An
Interval object records one or more spans of time. Intervals record these
timespans as a sequence of seconds that begin at a specified date. Since
intervals are anchored to a precise moment of time, they can accurately be
converted to <a href="#topic+Period-class">Period</a> or <a href="#topic+Duration-class">Duration</a> class objects. This
is because we can observe the length in seconds of each period that begins on a
specific date. Contrast this to a generalized period, which may not have a
consistent length in seconds (e.g. the number of seconds in a year will change
if it is a leap year).
</p>


<h3>Details</h3>

<p>Intervals can be both negative and positive. Negative intervals progress
backwards from the start date; positive intervals progress forwards.
</p>
<p>Interval class objects have two slots: .Data, a numeric object equal to the number
of seconds in the interval; and start, a POSIXct object that specifies the time
when the interval starts.
</p>

<hr>
<h2 id='is.Date'>Various date utilities</h2><span id='topic+is.Date'></span><span id='topic+Date'></span><span id='topic+NA_Date_'></span>

<h3>Description</h3>

<p><code><a href="#topic+Date">Date()</a></code> mirrors primitive contructors in base R (<code><a href="base.html#topic+double">double()</a></code>, <code><a href="base.html#topic+character">character()</a></code>
etc.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.Date(x)

Date(length = 0L)

NA_Date_
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.Date_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="is.Date_+3A_length">length</code></td>
<td>
<p>A non-negative number specifying the desired length. Supplying
an argument of length other than one is an error.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>Date</code> of length 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.instant">is.instant()</a></code>, <code><a href="#topic+is.timespan">is.timespan()</a></code>, <code><a href="#topic+is.POSIXt">is.POSIXt()</a></code>, <code><a href="#topic+POSIXct">POSIXct()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.Date(as.Date("2009-08-03")) # TRUE
is.Date(difftime(now() + 5, now())) # FALSE
</code></pre>

<hr>
<h2 id='is.difftime'>Is x a difftime object?</h2><span id='topic+is.difftime'></span>

<h3>Description</h3>

<p>Is x a difftime object?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.difftime(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.difftime_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if x is a difftime object, FALSE otherwise.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.instant">is.instant()</a></code>, <code><a href="#topic+is.timespan">is.timespan()</a></code>, <code><a href="#topic+is.interval">is.interval()</a></code>,
<code><a href="#topic+is.period">is.period()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.difftime(as.Date("2009-08-03")) # FALSE
is.difftime(make_difftime(days = 12.4)) # TRUE
</code></pre>

<hr>
<h2 id='is.instant'>Is x a date-time object?</h2><span id='topic+is.instant'></span><span id='topic+instant'></span><span id='topic+instants'></span><span id='topic+is.timepoint'></span>

<h3>Description</h3>

<p>An instant is a specific moment in time. Most common date-time
objects (e.g, POSIXct, POSIXlt, and Date objects) are instants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.instant(x)

is.timepoint(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.instant_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if x is a POSIXct, POSIXlt, or Date object, FALSE otherwise.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.timespan">is.timespan()</a></code>, <code><a href="#topic+is.POSIXt">is.POSIXt()</a></code>, <code><a href="#topic+is.Date">is.Date()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.instant(as.Date("2009-08-03")) # TRUE
is.timepoint(5) # FALSE
</code></pre>

<hr>
<h2 id='is.POSIXt'>Various POSIX utilities</h2><span id='topic+is.POSIXt'></span><span id='topic+is.POSIXlt'></span><span id='topic+is.POSIXct'></span><span id='topic+POSIXct'></span><span id='topic+NA_POSIXct_'></span>

<h3>Description</h3>

<p><code><a href="#topic+POSIXct">POSIXct()</a></code> mirrors primitive contructors in base R (<code><a href="base.html#topic+double">double()</a></code>,
<code><a href="base.html#topic+character">character()</a></code> etc.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.POSIXt(x)

is.POSIXlt(x)

is.POSIXct(x)

POSIXct(length = 0L, tz = "UTC")

NA_POSIXct_
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.POSIXt_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="is.POSIXt_+3A_length">length</code></td>
<td>
<p>A non-negative number specifying the desired length. Supplying
an argument of length other than one is an error.</p>
</td></tr>
<tr><td><code id="is.POSIXt_+3A_tz">tz</code></td>
<td>
<p>a timezone (defaults to &quot;utc&quot;)</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>POSIXct</code> (inherits from <code>POSIXt</code>) of length 1.
</p>


<h3>Value</h3>

<p>TRUE if x is a POSIXct or POSIXlt object, FALSE otherwise.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.instant">is.instant()</a></code>, <code><a href="#topic+is.timespan">is.timespan()</a></code>, <code><a href="#topic+is.Date">is.Date()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.POSIXt(as.Date("2009-08-03"))
is.POSIXt(as.POSIXct("2009-08-03"))
</code></pre>

<hr>
<h2 id='is.timespan'>Is x a length of time?</h2><span id='topic+is.timespan'></span>

<h3>Description</h3>

<p>Is x a length of time?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.timespan(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.timespan_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if x is a period, interval, duration, or difftime object, FALSE otherwise.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.instant">is.instant()</a></code>, <code><a href="#topic+is.duration">is.duration()</a></code>, <code><a href="#topic+is.difftime">is.difftime()</a></code>, <code><a href="#topic+is.period">is.period()</a></code>, <code><a href="#topic+is.interval">is.interval()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.timespan(as.Date("2009-08-03")) # FALSE
is.timespan(duration(second = 1)) # TRUE
</code></pre>

<hr>
<h2 id='lakers'>Lakers 2008-2009 basketball data set</h2><span id='topic+lakers'></span>

<h3>Description</h3>

<p>This data set contains play by play statistics of each Los
Angeles Lakers basketball game in the 2008-2009 season. Data
includes the date, opponent, and type of each game (home or
away). Each play is described by the time on the game clock
when the play was made, the period in which the play was
attempted, the type of play, the player and team who made the
play, the result of the play, and the location on the court
where each play was made.
</p>


<h3>References</h3>

<p>Originally taken from www.basketballgeek.com/data/.
</p>

<hr>
<h2 id='leap_year'>Is a year a leap year?</h2><span id='topic+leap_year'></span>

<h3>Description</h3>

<p>If x is a recognized date-time object, leap_year will return whether x
occurs during a leap year. If x is a number, leap_year returns whether it
would be a leap year under the Gregorian calendar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leap_year(date)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leap_year_+3A_date">date</code></td>
<td>
<p>a date-time object or a year</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if x is a leap year, FALSE otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.Date("2009-08-02")
leap_year(x) # FALSE
leap_year(2009) # FALSE
leap_year(2008) # TRUE
leap_year(1900) # FALSE
leap_year(2000) # TRUE
</code></pre>

<hr>
<h2 id='local_time'>Get local time from a date-time vector.</h2><span id='topic+local_time'></span>

<h3>Description</h3>

<p><code>local_time</code> retrieves day clock time in specified time zones. Computation is
vectorized over both <code>dt</code> and <code>tz</code> arguments, the shortest is recycled in
accordance with standard R rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_time(dt, tz = NULL, units = "secs")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_time_+3A_dt">dt</code></td>
<td>
<p>a date-time object.</p>
</td></tr>
<tr><td><code id="local_time_+3A_tz">tz</code></td>
<td>
<p>a character vector of timezones for which to compute the local time.</p>
</td></tr>
<tr><td><code id="local_time_+3A_units">units</code></td>
<td>
<p>passed directly to <code><a href="#topic+as.difftime">as.difftime()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- ymd_hms(c("2009-08-07 01:02:03", "2009-08-07 10:20:30"))
local_time(x, units = "secs")
local_time(x, units = "hours")
local_time(x, "Europe/Amsterdam")
local_time(x, "Europe/Amsterdam") == local_time(with_tz(x, "Europe/Amsterdam"))

x &lt;- ymd_hms("2009-08-07 01:02:03")
local_time(x, c("America/New_York", "Europe/Amsterdam", "Asia/Shanghai"), unit = "hours")
</code></pre>

<hr>
<h2 id='lubridate-package'>Dates and times made easy with lubridate</h2><span id='topic+lubridate'></span><span id='topic+lubridate-package'></span>

<h3>Description</h3>

<p>Lubridate provides tools that make it easier to parse and
manipulate dates. These tools are grouped below by common
purpose. More information about each function can be found in
its help documentation.
</p>


<h3>Parsing dates</h3>

<p>Lubridate's parsing functions read strings into R as POSIXct
date-time objects. Users should choose the function whose name
models the order in which the year ('y'), month ('m') and day
('d') elements appear the string to be parsed:
<code><a href="#topic+dmy">dmy()</a></code>, <code><a href="#topic+myd">myd()</a></code>, <code><a href="#topic+ymd">ymd()</a></code>,
<code><a href="#topic+ydm">ydm()</a></code>, <code><a href="#topic+dym">dym()</a></code>, <code><a href="#topic+mdy">mdy()</a></code>,
<code><a href="#topic+ymd_hms">ymd_hms()</a></code>). A very flexible and user friendly parser
is provided by <code><a href="#topic+parse_date_time">parse_date_time()</a></code>.
</p>
<p>Lubridate can also parse partial dates from strings into
<a href="#topic+Period-class">Period</a> objects with the functions
<code><a href="#topic+hm">hm()</a></code>, <code><a href="#topic+hms">hms()</a></code> and <code><a href="#topic+ms">ms()</a></code>.
</p>
<p>Lubridate has an inbuilt very fast POSIX parser. Most of the <code><a href="base.html#topic+strptime">strptime()</a></code>
formats and various extensions are supported for English locales. See
<code><a href="#topic+parse_date_time">parse_date_time()</a></code> for more details.
</p>


<h3>Manipulating dates</h3>

<p>Lubridate distinguishes between moments in time (known as
<code><a href="#topic+instants">instants()</a></code>) and spans of time (known as time spans, see
<a href="#topic+Timespan-class">Timespan</a>). Time spans are further separated into
<a href="#topic+Duration-class">Duration</a>, <a href="#topic+Period-class">Period</a> and
<a href="#topic+Interval-class">Interval</a> objects.
</p>


<h3>Instants</h3>

<p>Instants are specific moments of time. Date, POSIXct, and
POSIXlt are the three object classes Base R recognizes as
instants. <code><a href="#topic+is.Date">is.Date()</a></code> tests whether an object
inherits from the Date class. <code><a href="#topic+is.POSIXt">is.POSIXt()</a></code> tests
whether an object inherits from the POSIXlt or POSIXct classes.
<code><a href="#topic+is.instant">is.instant()</a></code> tests whether an object inherits from
any of the three classes.
</p>
<p><code><a href="#topic+now">now()</a></code> returns the current system time as a POSIXct
object. <code><a href="#topic+today">today()</a></code> returns the current system date.
For convenience, 1970-01-01 00:00:00 is saved to
<a href="#topic+origin">origin</a>. This is the instant from which POSIXct
times are calculated. Try <code>unclass(now())</code> to see the numeric structure that
underlies POSIXct objects. Each POSIXct object is saved as the number of seconds
it occurred after 1970-01-01 00:00:00.
</p>
<p>Conceptually, instants are a combination of measurements on different units
(i.e, years, months, days, etc.). The individual values for
these units can be extracted from an instant and set with the
accessor functions <code><a href="#topic+second">second()</a></code>, <code><a href="#topic+minute">minute()</a></code>,
<code><a href="#topic+hour">hour()</a></code>, <code><a href="#topic+day">day()</a></code>, <code><a href="#topic+yday">yday()</a></code>,
<code><a href="#topic+mday">mday()</a></code>, <code><a href="#topic+wday">wday()</a></code>, <code><a href="#topic+week">week()</a></code>,
<code><a href="#topic+month">month()</a></code>, <code><a href="#topic+year">year()</a></code>, <code><a href="#topic+tz">tz()</a></code>,
and <code><a href="#topic+dst">dst()</a></code>.
Note: the accessor functions are named after the singular form
of an element. They shouldn't be confused with the period
helper functions that have the plural form of the units as a
name (e.g, <code><a href="#topic+seconds">seconds()</a></code>).
</p>


<h3>Rounding dates</h3>

<p>Instants can be rounded to a convenient unit using the
functions <code><a href="#topic+ceiling_date">ceiling_date()</a></code>, <code><a href="#topic+floor_date">floor_date()</a></code>
and <code><a href="#topic+round_date">round_date()</a></code>.
</p>


<h3>Time zones</h3>

<p>Lubridate provides two helper functions for working with time
zones. <code><a href="#topic+with_tz">with_tz()</a></code> changes the time zone in which an
instant is displayed. The clock time displayed for the instant
changes, but the moment of time described remains the same.
<code><a href="#topic+force_tz">force_tz()</a></code> changes only the time zone element of an
instant. The clock time displayed remains the same, but the
resulting instant describes a new moment of time.
</p>


<h3>Timespans</h3>

<p>A timespan is a length of time that may or may not be connected to
a particular instant. For example, three months is a timespan. So is an hour and
a half. Base R uses difftime class objects to record timespans.
However, people are not always consistent in how they expect time to behave.
Sometimes the passage of time is a monotone progression of instants that should
be as mathematically reliable as the number line. On other occasions time must
follow complex conventions and rules so that the clock times we see reflect what
we expect to observe in terms of daylight, season, and congruence with the
atomic clock. To better navigate the nuances of time, <span class="pkg">lubridate</span> creates three
additional timespan classes, each with its own specific and consistent behavior:
<a href="#topic+Interval-class">Interval</a>, <a href="#topic+Period-class">Period</a> and
<a href="#topic+Duration-class">Duration</a>.
</p>
<p><code><a href="#topic+is.difftime">is.difftime()</a></code> tests whether an object
inherits from the difftime class. <code><a href="#topic+is.timespan">is.timespan()</a></code>
tests whether an object inherits from any of the four timespan
classes.
</p>


<h3>Durations</h3>

<p>Durations measure the exact amount of time that occurs between two
instants. This can create unexpected results in relation to clock times if a
leap second, leap year, or change in daylight savings time (DST) occurs in
the interval.
</p>
<p>Functions for working with durations include <code><a href="#topic+is.duration">is.duration()</a></code>,
<code><a href="#topic+as.duration">as.duration()</a></code> and <code><a href="#topic+duration">duration()</a></code>. <code><a href="#topic+dseconds">dseconds()</a></code>,
<code><a href="#topic+dminutes">dminutes()</a></code>, <code><a href="#topic+dhours">dhours()</a></code>,  <code><a href="#topic+ddays">ddays()</a></code>,
<code><a href="#topic+dweeks">dweeks()</a></code> and <code><a href="#topic+dyears">dyears()</a></code> convenient lengths.
</p>


<h3>Periods</h3>

<p>Periods measure the change in clock time that occurs between two
instants. Periods provide robust predictions of clock time in the presence of
leap seconds, leap years, and changes in DST.
</p>
<p>Functions for working with periods include
<code><a href="#topic+is.period">is.period()</a></code>, <code><a href="#topic+as.period">as.period()</a></code> and
<code><a href="#topic+period">period()</a></code>. <code><a href="#topic+seconds">seconds()</a></code>,
<code><a href="#topic+minutes">minutes()</a></code>, <code><a href="#topic+hours">hours()</a></code>, <code><a href="#topic+days">days()</a></code>,
<code><a href="#topic+weeks">weeks()</a></code>, <code><a href="base.html#topic+months">months()</a></code> and
<code><a href="#topic+years">years()</a></code> quickly create periods of convenient
lengths.
</p>


<h3>Intervals</h3>

<p>Intervals are timespans that begin at a specific instant and
end at a specific instant. Intervals retain complete information about a
timespan. They provide the only reliable way to convert between
periods and durations.
</p>
<p>Functions for working with intervals include
<code><a href="#topic+is.interval">is.interval()</a></code>, <code><a href="#topic+as.interval">as.interval()</a></code>,
<code><a href="#topic+interval">interval()</a></code>, <code><a href="#topic+int_shift">int_shift()</a></code>,
<code><a href="#topic+int_flip">int_flip()</a></code>, <code><a href="#topic+int_aligns">int_aligns()</a></code>,
<code><a href="#topic+int_overlaps">int_overlaps()</a></code>, and
<code><a href="#topic++25within+25">%within%</a></code>. Intervals can also be manipulated with
intersect, union, and setdiff().
</p>


<h3>Miscellaneous</h3>

<p><code><a href="#topic+decimal_date">decimal_date()</a></code> converts an instant to a decimal of
its year.
<code><a href="#topic+leap_year">leap_year()</a></code> tests whether an instant occurs during
a leap year.
<code><a href="#topic+pretty_dates">pretty_dates()</a></code> provides a method of making pretty
breaks for date-times.
<a href="#topic+lakers">lakers</a> is a data set that contains information
about the Los Angeles Lakers 2008-2009 basketball season.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Vitalie Spinu <a href="mailto:spinuvit@gmail.com">spinuvit@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Garrett Grolemund
</p>
</li>
<li><p> Hadley Wickham
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Davis Vaughan [contributor]
</p>
</li>
<li><p> Ian Lyttle [contributor]
</p>
</li>
<li><p> Imanuel Costigan [contributor]
</p>
</li>
<li><p> Jason Law [contributor]
</p>
</li>
<li><p> Doug Mitarotonda [contributor]
</p>
</li>
<li><p> Joseph Larmarange [contributor]
</p>
</li>
<li><p> Jonathan Boiser [contributor]
</p>
</li>
<li><p> Chel Hee Lee [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Garrett Grolemund, Hadley Wickham (2011). Dates and Times Made
Easy with lubridate. Journal of Statistical Software, 40(3), 1-25.
<a href="https://www.jstatsoft.org/v40/i03/">https://www.jstatsoft.org/v40/i03/</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://lubridate.tidyverse.org">https://lubridate.tidyverse.org</a>
</p>
</li>
<li> <p><a href="https://github.com/tidyverse/lubridate">https://github.com/tidyverse/lubridate</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tidyverse/lubridate/issues">https://github.com/tidyverse/lubridate/issues</a>
</p>
</li></ul>


<hr>
<h2 id='make_datetime'>Efficient creation of date-times from numeric representations</h2><span id='topic+make_datetime'></span><span id='topic+make_date'></span>

<h3>Description</h3>

<p><code>make_datetime()</code> is a very fast drop-in replacement for
<code><a href="base.html#topic+ISOdatetime">base::ISOdate()</a></code> and <code><a href="base.html#topic+ISOdatetime">base::ISOdatetime()</a></code>. <code>make_date()</code> produces
objects of class <code>Date</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_datetime(
  year = 1970L,
  month = 1L,
  day = 1L,
  hour = 0L,
  min = 0L,
  sec = 0,
  tz = "UTC"
)

make_date(year = 1970L, month = 1L, day = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_datetime_+3A_year">year</code></td>
<td>
<p>numeric year</p>
</td></tr>
<tr><td><code id="make_datetime_+3A_month">month</code></td>
<td>
<p>numeric month</p>
</td></tr>
<tr><td><code id="make_datetime_+3A_day">day</code></td>
<td>
<p>numeric day</p>
</td></tr>
<tr><td><code id="make_datetime_+3A_hour">hour</code></td>
<td>
<p>numeric hour</p>
</td></tr>
<tr><td><code id="make_datetime_+3A_min">min</code></td>
<td>
<p>numeric minute</p>
</td></tr>
<tr><td><code id="make_datetime_+3A_sec">sec</code></td>
<td>
<p>numeric second</p>
</td></tr>
<tr><td><code id="make_datetime_+3A_tz">tz</code></td>
<td>
<p>time zone. Defaults to UTC.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input vectors are silently recycled. All inputs except <code>sec</code> are
silently converted to integer vectors; <code>sec</code> can be either integer or
double.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_datetime(year = 1999, month = 12, day = 22, sec = 10)
make_datetime(year = 1999, month = 12, day = 22, sec = c(10, 11))
</code></pre>

<hr>
<h2 id='make_difftime'>Create a difftime object.</h2><span id='topic+make_difftime'></span>

<h3>Description</h3>

<p><code>make_difftime()</code> creates a difftime object with the specified number of
units. Entries for different units are cumulative. difftime displays
durations in various units,  but these units are estimates given for
convenience. The underlying object is always recorded as a fixed number of
seconds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_difftime(num = NULL, units = "auto", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_difftime_+3A_num">num</code></td>
<td>
<p>Optional number of seconds</p>
</td></tr>
<tr><td><code id="make_difftime_+3A_units">units</code></td>
<td>
<p>a character vector that lists the type of units to use for the
display of the return value (see examples). If <code>units</code> is &quot;auto&quot; (the
default) the display units are computed automatically. This might create
undesirable effects when converting <code>difftime</code> objects to numeric
values in data processing.</p>
</td></tr>
<tr><td><code id="make_difftime_+3A_...">...</code></td>
<td>
<p>a list of time units to be included in the difftime and their amounts. Seconds,
minutes, hours, days, and weeks are supported. Normally only one of <code>num</code> or <code>...</code> are present. If
both are present, the <code>difftime</code> objects are concatenated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Conceptually, difftime objects are a type of duration. They measure the
exact passage of time but do not always align with measurements
made in larger units of time such as hours, months and years.
This is because the length of larger time units can be affected
by conventions such as leap years
and Daylight Savings Time. <span class="pkg">lubridate</span> provides a second class for measuring durations, the Duration class.
</p>


<h3>Value</h3>

<p>a difftime object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+duration">duration()</a></code>, <code><a href="#topic+as.duration">as.duration()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_difftime(1)
make_difftime(60)
make_difftime(3600)
make_difftime(3600, units = "minute")
# Time difference of 60 mins
make_difftime(second = 90)
# Time difference of 1.5 mins
make_difftime(minute = 1.5)
# Time difference of 1.5 mins
make_difftime(second = 3, minute = 1.5, hour = 2, day = 6, week = 1)
# Time difference of 13.08441 days
make_difftime(hour = 1, minute = -60)
# Time difference of 0 secs
make_difftime(day = -1)
# Time difference of -1 days
make_difftime(120, day = -1, units = "minute")
# Time differences in mins
</code></pre>

<hr>
<h2 id='minute'>Get/set minutes component of a date-time</h2><span id='topic+minute'></span><span id='topic+minute+3C-'></span>

<h3>Description</h3>

<p>Date-time must be a  POSIXct, POSIXlt, Date, Period, chron, yearmon, yearqtr, zoo,
zooreg, timeDate, xts, its, ti, jul, timeSeries, and fts objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minute(x)

minute(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minute_+3A_x">x</code></td>
<td>
<p>a date-time object</p>
</td></tr>
<tr><td><code id="minute_+3A_value">value</code></td>
<td>
<p>numeric value to be assigned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the minutes element of x as a decimal number
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ymd("2012-03-26")
minute(x)
minute(x) &lt;- 1
minute(x) &lt;- 61
minute(x) &gt; 2
</code></pre>

<hr>
<h2 id='month'>Get/set months component of a date-time</h2><span id='topic+month'></span><span id='topic+month+3C-'></span>

<h3>Description</h3>

<p>Date-time must be a POSIXct, POSIXlt, Date, Period, chron, yearmon, yearqtr, zoo,
zooreg, timeDate, xts, its, ti, jul, timeSeries, and fts objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>month(x, label = FALSE, abbr = TRUE, locale = Sys.getlocale("LC_TIME"))

month(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="month_+3A_x">x</code></td>
<td>
<p>a date-time object</p>
</td></tr>
<tr><td><code id="month_+3A_label">label</code></td>
<td>
<p>logical. TRUE will display the month as a character string such
as &quot;January.&quot; FALSE will display the month as a number.</p>
</td></tr>
<tr><td><code id="month_+3A_abbr">abbr</code></td>
<td>
<p>logical. FALSE will display the month as a character string
label, such as &quot;January&quot;. TRUE will display an abbreviated version of the
label, such as &quot;Jan&quot;. abbr is disregarded if label = FALSE.</p>
</td></tr>
<tr><td><code id="month_+3A_locale">locale</code></td>
<td>
<p>for month, locale to use for month names. Default to current locale.</p>
</td></tr>
<tr><td><code id="month_+3A_value">value</code></td>
<td>
<p>a numeric object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>label = FALSE</code>: month as number (1-12, 1 = January, 12 = December),
otherwise as an ordered factor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ymd("2012-03-26")
month(x)
month(x) &lt;- 1
month(x) &lt;- 13
month(x) &gt; 3

month(ymd(080101))
month(ymd(080101), label = TRUE)
month(ymd(080101), label = TRUE, abbr = FALSE)
month(ymd(080101) + months(0:11), label = TRUE)
</code></pre>

<hr>
<h2 id='ms'>Parse periods with <strong>h</strong>our, <strong>m</strong>inute, and <strong>s</strong>econd components</h2><span id='topic+ms'></span><span id='topic+hm'></span><span id='topic+hms'></span>

<h3>Description</h3>

<p>Transforms a character or numeric vector into a period object with the
specified number of hours, minutes, and seconds. <code>hms()</code> recognizes all
non-numeric characters except '-' as separators ('-' is used for negative
<code>durations</code>). After hours, minutes and seconds have been parsed, the
remaining input is ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ms(..., quiet = FALSE, roll = FALSE)

hm(..., quiet = FALSE, roll = FALSE)

hms(..., quiet = FALSE, roll = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ms_+3A_...">...</code></td>
<td>
<p>a character vector of hour minute second triples</p>
</td></tr>
<tr><td><code id="ms_+3A_quiet">quiet</code></td>
<td>
<p>logical. If <code>TRUE</code>, function evaluates without displaying
customary messages.</p>
</td></tr>
<tr><td><code id="ms_+3A_roll">roll</code></td>
<td>
<p>logical. If <code>TRUE</code>, smaller units are rolled over to higher units
if they exceed the conventional limit. For example,
<code>hms("01:59:120", roll = TRUE)</code> produces period &quot;2H 1M 0S&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of period objects
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hm">hm()</a></code>, <code><a href="#topic+ms">ms()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ms(c("09:10", "09:02", "1:10"))
ms("7 6")
ms("6,5")
hm(c("09:10", "09:02", "1:10"))
hm("7 6")
hm("6,5")

x &lt;- c("09:10:01", "09:10:02", "09:10:03")
hms(x)

hms("7 6 5", "3:23:::2", "2 : 23 : 33", "Finished in 9 hours, 20 min and 4 seconds")
</code></pre>

<hr>
<h2 id='now'>The current day and time</h2><span id='topic+now'></span><span id='topic+today'></span>

<h3>Description</h3>

<p>The current day and time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>now(tzone = "")

today(tzone = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="now_+3A_tzone">tzone</code></td>
<td>
<p>a character vector specifying which time zone you would like the
current time in. tzone defaults to your computer's system timezone. You can
retrieve the current time in the Universal Coordinated Time (UTC) with
now(&quot;UTC&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>now</code> - the current datetime as a <code>POSIXct</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>now()
now("GMT")
now("")
now() == now() # would be TRUE if computer processed both at the same instant
now() &lt; now() # TRUE
now() &gt; now() # FALSE
today()
today("GMT")
today() == today("GMT") # not always true
today() &lt; as.Date("2999-01-01") # TRUE  (so far)
</code></pre>

<hr>
<h2 id='origin'>1970-01-01 UTC</h2><span id='topic+origin'></span>

<h3>Description</h3>

<p>Origin is the date-time for 1970-01-01 UTC in POSIXct format. This date-time
is the origin for the numbering system used by POSIXct, POSIXlt, chron, and
Date classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>origin
</code></pre>


<h3>Format</h3>

<p>An object of class <code>POSIXct</code> (inherits from <code>POSIXt</code>) of length 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>origin
</code></pre>

<hr>
<h2 id='parse_date_time'>User friendly date-time parsing functions</h2><span id='topic+parse_date_time'></span><span id='topic+parse_date_time2'></span><span id='topic+fast_strptime'></span>

<h3>Description</h3>

<p><code>parse_date_time()</code> parses an input vector into POSIXct date-time
object. It differs from <code><a href="base.html#topic+strptime">base::strptime()</a></code> in two respects. First,
it allows specification of the order in which the formats occur without the
need to include separators and the <code style="white-space: pre;">&#8288;%&#8288;</code> prefix. Such a formatting argument is
referred to as &quot;order&quot;. Second, it allows the user to specify several
format-orders to handle heterogeneous date-time character
representations.
</p>
<p><code>parse_date_time2()</code> is a fast C parser of numeric orders.
</p>
<p><code>fast_strptime()</code> is a fast C parser of numeric formats only
that accepts explicit format arguments, just like <code><a href="base.html#topic+strptime">base::strptime()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_date_time(
  x,
  orders,
  tz = "UTC",
  truncated = 0,
  quiet = FALSE,
  locale = Sys.getlocale("LC_TIME"),
  select_formats = .select_formats,
  exact = FALSE,
  train = TRUE,
  drop = FALSE
)

parse_date_time2(
  x,
  orders,
  tz = "UTC",
  exact = FALSE,
  lt = FALSE,
  cutoff_2000 = 68L
)

fast_strptime(x, format, tz = "UTC", lt = TRUE, cutoff_2000 = 68L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_date_time_+3A_x">x</code></td>
<td>
<p>a character or numeric vector of dates</p>
</td></tr>
<tr><td><code id="parse_date_time_+3A_orders">orders</code></td>
<td>
<p>a character vector of date-time formats. Each order string is
a series of formatting characters as listed in <code><a href="base.html#topic+strptime">base::strptime()</a></code> but
might not include the <code>"%"</code> prefix. For example, &quot;ymd&quot; will match all the
possible dates in year, month, day order. Formatting orders might include
arbitrary separators. These are discarded. See details for the implemented
formats. If multiple order strings are supplied, they are applied in turn
for <code>parse_date_time2()</code> and <code>fast_strptime()</code>. For <code>parse_date_time()</code>
the order of applied formats is determined by <code>select_formats</code> parameter.</p>
</td></tr>
<tr><td><code id="parse_date_time_+3A_tz">tz</code></td>
<td>
<p>a character string that specifies the time zone with which to
parse the dates</p>
</td></tr>
<tr><td><code id="parse_date_time_+3A_truncated">truncated</code></td>
<td>
<p>integer, number of formats that can be missing. The most
common type of irregularity in date-time data is the truncation due to
rounding or unavailability of the time stamp. If the <code>truncated</code> parameter
is non-zero <code>parse_date_time()</code> also checks for truncated formats. For
example,  if the format order is &quot;ymdHMS&quot; and <code>truncated = 3</code>,
<code>parse_date_time()</code> will correctly parse incomplete date-times like
<code style="white-space: pre;">&#8288;2012-06-01 12:23&#8288;</code>, <code style="white-space: pre;">&#8288;2012-06-01 12&#8288;</code> and <code>2012-06-01</code>. <b>NOTE:</b> The
<code>ymd()</code> family of functions is based on <code><a href="base.html#topic+strptime">base::strptime()</a></code> which currently
fails to parse <code style="white-space: pre;">&#8288;%Y-%m&#8288;</code> formats.</p>
</td></tr>
<tr><td><code id="parse_date_time_+3A_quiet">quiet</code></td>
<td>
<p>logical. If <code>TRUE</code>, progress messages are not printed, and <code style="white-space: pre;">&#8288;No formats found&#8288;</code> error is suppressed and the function simply returns a
vector of NAs.  This mirrors the behavior of base R functions
<code><a href="base.html#topic+strptime">base::strptime()</a></code> and <code><a href="base.html#topic+as.POSIXlt">base::as.POSIXct()</a></code>.</p>
</td></tr>
<tr><td><code id="parse_date_time_+3A_locale">locale</code></td>
<td>
<p>locale to be used, see <a href="base.html#topic+locales">locales</a>. On Linux systems you
can use <code>system("locale -a")</code> to list all the installed locales.</p>
</td></tr>
<tr><td><code id="parse_date_time_+3A_select_formats">select_formats</code></td>
<td>
<p>A function to select actual formats for parsing from a
set of formats which matched a training subset of <code>x</code>. It receives a named
integer vector and returns a character vector of selected formats. Names
of the input vector are formats (not orders) that matched the training
set. Numeric values are the number of dates (in the training set) that
matched the corresponding format. You should use this argument if the
default selection method fails to select the formats in the right
order. By default the formats with most formatting tokens (<code style="white-space: pre;">&#8288;%&#8288;</code>) are
selected and <code style="white-space: pre;">&#8288;%Y&#8288;</code> counts as 2.5 tokens (so that it has a priority over
<code style="white-space: pre;">&#8288;%y%m&#8288;</code>). See examples.</p>
</td></tr>
<tr><td><code id="parse_date_time_+3A_exact">exact</code></td>
<td>
<p>logical. If <code>TRUE</code>, the <code>orders</code> parameter is interpreted as an
exact <code><a href="base.html#topic+strptime">base::strptime()</a></code> format and no training or guessing are performed
(i.e. <code>train</code>, <code>drop</code> parameters are ignored).</p>
</td></tr>
<tr><td><code id="parse_date_time_+3A_train">train</code></td>
<td>
<p>logical, default <code>TRUE</code>. Whether to train formats on a subset of the
input vector. As a result the supplied orders are sorted according to performance
on this training set, which commonly results in increased performance. Please note
that even when <code>train = FALSE</code> (and <code>exact = FALSE</code>) guessing of the actual
formats is still performed on the training set (a pseudo-random subset of the
original input vector). This might result in <code style="white-space: pre;">&#8288;All formats failed to parse&#8288;</code>
error. See notes below.</p>
</td></tr>
<tr><td><code id="parse_date_time_+3A_drop">drop</code></td>
<td>
<p>logical, default <code>FALSE</code>. Whether to drop formats that didn't
match on the training set. If <code>FALSE</code>, unmatched on the training set
formats are tried as a last resort at the end of the parsing
queue. Applies only when <code>train = TRUE</code>. Setting this parameter to <code>TRUE</code>
might slightly speed up parsing in situations involving many
formats. Prior to v1.7.0 this parameter was implicitly <code>TRUE</code>, which
resulted in occasional surprising behavior when rare patterns where not
present in the training set.</p>
</td></tr>
<tr><td><code id="parse_date_time_+3A_lt">lt</code></td>
<td>
<p>logical. If <code>TRUE</code>, returned object is of class POSIXlt, and POSIXct
otherwise. For compatibility with <code><a href="base.html#topic+strptime">base::strptime()</a></code> the default is <code>TRUE</code>
for <code>fast_strptime()</code> and <code>FALSE</code> for <code>parse_date_time2()</code>.</p>
</td></tr>
<tr><td><code id="parse_date_time_+3A_cutoff_2000">cutoff_2000</code></td>
<td>
<p>integer. For <code>y</code> format,  two-digit numbers smaller or equal
to <code>cutoff_2000</code> are parsed as though starting with <code>20</code>, otherwise parsed
as though starting with <code>19</code>. Available only for functions relying on
<code>lubridate</code>s internal parser.</p>
</td></tr>
<tr><td><code id="parse_date_time_+3A_format">format</code></td>
<td>
<p>a vector of formats. If multiple formats supplied they are
applied in turn till success. The formats should include all the
separators and each format letter must be prefixed with %, just as in the
format argument of <code><a href="base.html#topic+strptime">base::strptime()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When several format-orders are specified, <code>parse_date_time()</code> selects
(guesses) format-orders based on a training subset of the input
strings. After guessing the formats are ordered according to the performance
on the training set and applied recursively on the entire input vector. You
can disable training with <code>train = FALSE</code>.
</p>
<p><code>parse_date_time()</code>, and all derived functions, such as <code>ymd_hms()</code>,
<code>ymd()</code>, etc., will drop into <code>fast_strptime()</code> instead of
<code><a href="base.html#topic+strptime">base::strptime()</a></code> whenever the guessed from the input data formats are all
numeric.
</p>
<p>The list below contains formats recognized by <span class="pkg">lubridate</span>. For numeric
formats leading 0s are optional. As compared to <code><a href="base.html#topic+strptime">base::strptime()</a></code>, some of
the formats are new or have been extended for efficiency reasons. These
formats are marked with &quot;(*)&quot; below. Fast parsers <code>parse_date_time2()</code> and
<code>fast_strptime()</code> accept only formats marked with &quot;(!)&quot;.
</p>
 <dl>
<dt><code>a</code></dt><dd><p>Abbreviated weekday name in the current
locale. (Also matches full name)</p>
</dd>
<dt><code>A</code></dt><dd><p>Full weekday name in the current locale.  (Also matches
abbreviated name).
</p>
<p>You don't need to specify <code>a</code> and <code>A</code> formats explicitly. Wday is
automatically handled if <code>preproc_wday = TRUE</code></p>
</dd>
<dt><code>b</code> (!)</dt><dd><p>Abbreviated or full month name in the current locale. The C
parser currently understands only English month names.</p>
</dd>
<dt><code>B</code> (!)</dt><dd><p>Same as b.</p>
</dd>
<dt><code>d</code> (!)</dt><dd><p>Day of the month as decimal number (01&ndash;31 or 0&ndash;31)</p>
</dd>
<dt><code>H</code> (!)</dt><dd><p>Hours as decimal number (00&ndash;24 or 0&ndash;24).</p>
</dd>
<dt><code>I</code> (!)</dt><dd><p>Hours as decimal number (01&ndash;12 or 1&ndash;12).</p>
</dd>
<dt><code>j</code></dt><dd><p>Day of year as decimal number (001&ndash;366 or 1&ndash;366).</p>
</dd>
<dt><code>q</code> (!*)</dt><dd><p>Quarter (1&ndash;4). The quarter month is added to the parsed
month if <code>m</code> element is present.</p>
</dd>
<dt><code>m</code> (!*)</dt><dd><p>Month as decimal number (01&ndash;12 or 1&ndash;12). For
<code>parse_date_time</code> also matches abbreviated and full months names as <code>b</code>
and <code>B</code> formats. C parser understands only English month names.</p>
</dd>
<dt><code>M</code> (!)</dt><dd><p>Minute as decimal number (00&ndash;59 or 0&ndash;59).</p>
</dd>
<dt><code>p</code> (!)</dt><dd><p>AM/PM indicator in the locale. Commonly used in conjunction
with <code>I</code> and <b>not</b> with <code>H</code>.  But <span class="pkg">lubridate</span>'s C parser accepts H
format as long as hour is not greater than 12. C parser understands only
English locale AM/PM indicator.</p>
</dd>
<dt><code>S</code> (!)</dt><dd><p>Second as decimal number (00&ndash;61 or 0&ndash;61), allowing for up
to two leap-seconds (but POSIX-compliant implementations will ignore leap
seconds).</p>
</dd>
<dt><code>OS</code></dt><dd><p>Fractional second.</p>
</dd>
<dt><code>U</code></dt><dd><p>Week of the year as decimal number (00&ndash;53 or 0&ndash;53) using
Sunday as the first day 1 of the week (and typically with the first Sunday
of the year as day 1 of week 1).  The US convention.</p>
</dd>
<dt><code>w</code></dt><dd><p>Weekday as decimal number (0&ndash;6, Sunday is 0).</p>
</dd>
<dt><code>W</code></dt><dd><p>Week of the year as decimal number (00&ndash;53 or 0&ndash;53) using
Monday as the first day of week (and typically with the first Monday of the
year as day 1 of week 1).  The UK convention.</p>
</dd>
<dt><code>y</code> (!*)</dt><dd><p>Year without century (00&ndash;99 or 0&ndash;99).  In
<code>parse_date_time()</code> also matches year with century (Y format).</p>
</dd>
<dt><code>Y</code> (!)</dt><dd><p>Year with century.</p>
</dd>
<dt><code>z</code> (!*)</dt><dd><p>ISO8601 signed offset in hours and minutes from UTC. For
example <code>-0800</code>, <code>-08:00</code> or <code>-08</code>, all represent 8 hours behind UTC. This
format also matches the Z (Zulu) UTC indicator. Because <code><a href="base.html#topic+strptime">base::strptime()</a></code>
doesn't fully support ISO8601 this format is implemented as an union of 4
formats: Ou (Z), Oz (-0800), OO (-08:00) and Oo (-08). You can use these
formats as any other but it is rarely necessary. <code>parse_date_time2()</code> and
<code>fast_strptime()</code> support all of these formats.</p>
</dd>
<dt><code>Om</code> (!*)</dt><dd><p>Matches numeric month and English alphabetic months
(Both, long and abbreviated forms).</p>
</dd>
<dt><code>Op</code> (!*)</dt><dd><p>Matches AM/PM English indicator.</p>
</dd>
<dt><code>r</code> (*)</dt><dd><p>Matches <code>Ip</code> and <code>H</code> orders.</p>
</dd>
<dt><code>R</code> (*)</dt><dd><p>Matches <code>HM</code> and<code>IMp</code> orders.</p>
</dd>
<dt><code>T</code> (*)</dt><dd><p>Matches <code>IMSp</code>, <code>HMS</code>, and <code>HMOS</code> orders.</p>
</dd>
</dl>



<h3>Value</h3>

<p>a vector of POSIXct date-time objects
</p>


<h3>Note</h3>

<p><code>parse_date_time()</code> (and the derivatives <code>ymd()</code>, <code>ymd_hms()</code>, etc.)
relies on a sparse guesser that takes at most 501 elements from the
supplied character vector in order to identify appropriate formats from
the supplied orders. If you get the error <code style="white-space: pre;">&#8288;All formats failed to parse&#8288;</code>
and you are confident that your vector contains valid dates, you should
either set <code>exact</code> argument to <code>TRUE</code> or use functions that don't perform
format guessing (<code>fast_strptime()</code>, <code>parse_date_time2()</code> or
<code><a href="base.html#topic+strptime">base::strptime()</a></code>).
</p>
<p>For performance reasons, when timezone is not UTC,
<code>parse_date_time2()</code> and <code>fast_strptime()</code> perform no validity checks for
daylight savings time. Thus, if your input string contains an invalid date
time which falls into DST gap and <code>lt = TRUE</code> you will get an <code>POSIXlt</code>
object with a non-existent time. If <code>lt = FALSE</code> your time instant will be
adjusted to a valid time by adding an hour. See examples. If you want to
get NA for invalid date-times use <code><a href="#topic+fit_to_timeline">fit_to_timeline()</a></code> explicitly.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+strptime">base::strptime()</a></code>, <code><a href="#topic+ymd">ymd()</a></code>, <code><a href="#topic+ymd_hms">ymd_hms()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ** orders are much easier to write **
x &lt;- c("09-01-01", "09-01-02", "09-01-03")
parse_date_time(x, "ymd")
parse_date_time(x, "y m d")
parse_date_time(x, "%y%m%d")
#  "2009-01-01 UTC" "2009-01-02 UTC" "2009-01-03 UTC"

## ** heterogeneous date-times **
x &lt;- c("09-01-01", "090102", "09-01 03", "09-01-03 12:02")
parse_date_time(x, c("ymd", "ymd HM"))

## ** different ymd orders **
x &lt;- c("2009-01-01", "02022010", "02-02-2010")
parse_date_time(x, c("dmY", "ymd"))
##  "2009-01-01 UTC" "2010-02-02 UTC" "2010-02-02 UTC"

## ** truncated time-dates **
x &lt;- c("2011-12-31 12:59:59", "2010-01-01 12:11", "2010-01-01 12", "2010-01-01")
parse_date_time(x, "Ymd HMS", truncated = 3)

## ** specifying exact formats and avoiding training and guessing **
parse_date_time(x, c("%m-%d-%y", "%m%d%y", "%m-%d-%y %H:%M"), exact = TRUE)
parse_date_time(c('12/17/1996 04:00:00','4/18/1950 0130'),
                c('%m/%d/%Y %I:%M:%S','%m/%d/%Y %H%M'), exact = TRUE)

## ** quarters and partial dates **
parse_date_time(c("2016.2", "2016-04"), orders = "Yq")
parse_date_time(c("2016", "2016-04"), orders = c("Y", "Ym"))

## ** fast parsing **
## Not run: 
  options(digits.secs = 3)
  ## random times between 1400 and 3000
  tt &lt;- as.character(.POSIXct(runif(1000, -17987443200, 32503680000)))
  tt &lt;- rep.int(tt, 1000)

  system.time(out &lt;- as.POSIXct(tt, tz = "UTC"))
  system.time(out1 &lt;- ymd_hms(tt)) # constant overhead on long vectors
  system.time(out2 &lt;- parse_date_time2(tt, "YmdHMOS"))
  system.time(out3 &lt;- fast_strptime(tt, "%Y-%m-%d %H:%M:%OS"))

  all.equal(out, out1)
  all.equal(out, out2)
  all.equal(out, out3)

## End(Not run)

## ** how to use `select_formats` argument **
## By default %Y has precedence:
parse_date_time(c("27-09-13", "27-09-2013"), "dmy")

## to give priority to %y format, define your own select_format function:

my_select &lt;-   function(trained, drop=FALSE, ...){
   n_fmts &lt;- nchar(gsub("[^%]", "", names(trained))) + grepl("%y", names(trained))*1.5
   names(trained[ which.max(n_fmts) ])
}

parse_date_time(c("27-09-13", "27-09-2013"), "dmy", select_formats = my_select)

## ** invalid times with "fast" parsing **
parse_date_time("2010-03-14 02:05:06",  "YmdHMS", tz = "America/New_York")
parse_date_time2("2010-03-14 02:05:06",  "YmdHMS", tz = "America/New_York")
parse_date_time2("2010-03-14 02:05:06",  "YmdHMS", tz = "America/New_York", lt = TRUE)
</code></pre>

<hr>
<h2 id='period'>Create or parse period objects</h2><span id='topic+period'></span><span id='topic+periods'></span><span id='topic+is.period'></span><span id='topic+seconds'></span><span id='topic+minutes'></span><span id='topic+hours'></span><span id='topic+days'></span><span id='topic+weeks'></span><span id='topic+years'></span><span id='topic+milliseconds'></span><span id='topic+microseconds'></span><span id='topic+nanoseconds'></span><span id='topic+picoseconds'></span><span id='topic+months.numeric'></span>

<h3>Description</h3>

<p><code>period()</code> creates or parses a period object with the specified values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>period(num = NULL, units = "second", ...)

is.period(x)

seconds(x = 1)

minutes(x = 1)

hours(x = 1)

days(x = 1)

weeks(x = 1)

years(x = 1)

milliseconds(x = 1)

microseconds(x = 1)

nanoseconds(x = 1)

picoseconds(x = 1)

## S3 method for class 'numeric'
months(x, abbreviate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="period_+3A_num">num</code></td>
<td>
<p>a numeric or character vector. A character vector can specify
periods in a convenient shorthand format or ISO 8601 specification. All
unambiguous name units and abbreviations are supported, &quot;m&quot; stands for
months, &quot;M&quot; for minutes unless ISO 8601 &quot;P&quot; modifier is present (see
examples). Fractional units are supported but the fractional part is always
converted to seconds.</p>
</td></tr>
<tr><td><code id="period_+3A_units">units</code></td>
<td>
<p>a character vector that lists the type of units to be used. The
units in units are matched to the values in num according to their
order. When <code>num</code> is character, this argument is ignored.</p>
</td></tr>
<tr><td><code id="period_+3A_...">...</code></td>
<td>
<p>a list of time units to be included in the period and their
amounts. Seconds, minutes,  hours, days, weeks, months, and years are
supported. Normally only one of <code>num</code> or <code>...</code> are present. If both are
present, the periods are concatenated.</p>
</td></tr>
<tr><td><code id="period_+3A_x">x</code></td>
<td>
<p>Any R object for <code>is.periods</code> and a numeric value of the number of
units for elementary constructors. With the exception of seconds(), x must
be an integer.</p>
</td></tr>
<tr><td><code id="period_+3A_abbreviate">abbreviate</code></td>
<td>
<p>Ignored. For consistency with S3 generic in base namespace.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Within a Period object, time units do not have a fixed length (except for
seconds) until they are added to a date-time. The length of each time unit
will depend on the date-time to which it is added. For example, a year that
begins on 2009-01-01 will be 365 days long.  A year that begins on 2012-01-01
will be 366 days long. When math is performed with a period object, each unit
is applied separately. How the length of a period is distributed among its
units is non-trivial. For example, when leap seconds occur 1 minute is longer
than 60 seconds.
</p>
<p>Periods track the change in the &quot;clock time&quot; between two date-times. They
are measured in common time related units: years, months, days, hours,
minutes, and seconds. Each unit except for seconds must be expressed in
integer values.
</p>
<p>Besides the main constructor and parser <code><a href="#topic+period">period()</a></code>, period objects can also
be created with the specialized functions <code><a href="#topic+years">years()</a></code>, <code><a href="base.html#topic+months">months()</a></code>, <code><a href="#topic+weeks">weeks()</a></code>,
<code><a href="#topic+days">days()</a></code>, <code><a href="#topic+hours">hours()</a></code>, <code><a href="#topic+minutes">minutes()</a></code>, and <code><a href="#topic+seconds">seconds()</a></code>. These objects can be added
to and subtracted to date-times to create a user interface similar to object
oriented programming.
</p>
<p>Note: Arithmetic with periods can result in undefined behavior when
non-existent dates are involved (such as February 29th in non-leap years).
Please see <a href="#topic+Period-class">Period</a> for more details and <code><a href="#topic++25m+2B+25">%m+%</a></code> and
<code><a href="#topic+add_with_rollback">add_with_rollback()</a></code> for alternative operations.
</p>


<h3>Value</h3>

<p>a period object
</p>


<h3>See Also</h3>

<p><a href="#topic+Period-class">Period</a>, <code><a href="#topic+period">period()</a></code>, <code><a href="#topic++25m+2B+25">%m+%</a></code>,
<code><a href="#topic+add_with_rollback">add_with_rollback()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Separate period and units vectors

period(c(90, 5), c("second", "minute"))
#  "5M 90S"
period(-1, "days")
period(c(3, 1, 2, 13, 1), c("second", "minute", "hour", "day", "week"))
period(c(1, -60), c("hour", "minute"))
period(0, "second")

### Units as arguments

period(second = 90, minute = 5)
period(day = -1)
period(second = 3, minute = 1, hour = 2, day = 13, week = 1)
period(hour = 1, minute = -60)
period(second = 0)
period(c(1, -60), c("hour", "minute"), hour = c(1, 2), minute = c(3, 4))

### Lubridate style parsing

period("2M 1sec")
period("2hours 2minutes 1second")
period("2d 2H 2M 2S")
period("2days 2hours 2mins 2secs")
period("2 days, 2 hours, 2 mins, 2 secs")
# Missing numerals default to 1. Repeated units are added up.
period("day day")

### ISO 8601 parsing

period("P10M23DT23H") # M stands for months
period("10DT10M") # M stands for minutes
period("P3Y6M4DT12H30M5S") # M for both minutes and months
period("P23DT60H 20min 100 sec") # mixing ISO and lubridate style parsing

### Comparison with characters (from v1.6.0)

period("day 2 sec") &gt; "day 1sec"

### Elementary Constructors

x &lt;- ymd("2009-08-03")
x + days(1) + hours(6) + minutes(30)
x + days(100) - hours(8)

class(as.Date("2009-08-09") + days(1)) # retains Date class
as.Date("2009-08-09") + hours(12)
class(as.Date("2009-08-09") + hours(12))
# converts to POSIXt class to accomodate time units

years(1) - months(7)
c(1:3) * hours(1)
hours(1:3)

# sequencing
y &lt;- ymd(090101) # "2009-01-01 CST"
y + months(0:11)

# compare DST handling to durations
boundary &lt;- ymd_hms("2009-03-08 01:59:59", tz = "America/Chicago")
boundary + days(1) # period
boundary + ddays(1) # duration
is.period(as.Date("2009-08-03")) # FALSE
is.period(period(months = 1, days = 15)) # TRUE
</code></pre>

<hr>
<h2 id='period_to_seconds'>Contrive a period to/from a given number of seconds</h2><span id='topic+period_to_seconds'></span><span id='topic+seconds_to_period'></span>

<h3>Description</h3>

<p><code>period_to_seconds()</code> approximately converts a period to seconds assuming
there are 365.25 days in a calendar year and 365.25/12 days in a month.
</p>
<p><code>seconds_to_period()</code> create a period that has the maximum number of
non-zero elements (days, hours, minutes, seconds). This computation is exact
because it doesn't involve years or months.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>period_to_seconds(x)

seconds_to_period(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="period_to_seconds_+3A_x">x</code></td>
<td>
<p>A numeric object. The number of seconds to coerce into a period.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number (period) that roughly equates to the period (seconds) given.
</p>

<hr>
<h2 id='Period-class'>Period class</h2><span id='topic+Period-class'></span>

<h3>Description</h3>

<p>Period is an S4 class that extends the <a href="#topic+Timespan-class">Timespan</a> class.
Periods track the change in the &quot;clock time&quot; between two date-times. They
are measured in common time related units: years, months, days, hours,
minutes, and seconds. Each unit except for seconds must be expressed in
integer values.
</p>


<h3>Details</h3>

<p>The exact length of a period is not defined until the period is placed at a
specific moment of time. This is because the precise length of one year,
month, day, etc. can change depending on when it occurs due to daylight savings,
leap years, and other conventions. A period can be
associated with a specific moment in time by coercing it to an
<a href="#topic+Interval-class">Interval</a> object with <code><a href="#topic+as.interval">as.interval()</a></code> or by adding
it to a date-time with &quot;+&quot;.
</p>
<p>Periods provide a method for measuring generalized timespans when we wish to
model clock times. Periods will attain intuitive results at this task even
when leap years, leap seconds, gregorian days, daylight savings changes, and
other events happen during the period.
</p>
<p>Because Period represents imprecise amount of time it cannot be compared to
precise timestamps as Durations and Intervals are. You need to explicitely
convert to durations. See <a href="#topic+Duration-class">Duration</a>.
</p>
<p>The logic that guides arithmetic with periods can be unintuitive. Starting
with version 1.3.0, <span class="pkg">lubridate</span> enforces the reversible property of arithmetic
(e.g. a date + period - period = date) by returning an NA if you create an
implausible date by adding periods with months or years units to a date. For
example,  adding one month to January 31st, 2013 results in February 31st,
2013, which is not a real date. <span class="pkg">lubridate</span> users have argued in the past that
February 31st, 2013 should be rolled over to March 3rd, 2013 or rolled back
to February 28, 2013. However, each of these corrections would destroy the
reversibility of addition (Mar 3 - one month == Feb 3 != Jan 31, Feb 28 - one
month == Jan 28 != Jan 31). If you would like to add and subtract months in a
way that rolls the results back to the last day of a month (when appropriate)
use the special operators, <code><a href="#topic++25m+2B+25">%m+%</a></code>,  <code><a href="#topic++25m-+25">%m-%</a></code> or a
bit more flexible <code><a href="#topic+add_with_rollback">add_with_rollback()</a></code>.
</p>
<p>Period class objects have six slots. 1) .Data, a numeric object. The
apparent amount of seconds to add to the period. 2) minute, a numeric object.
The apparent amount of minutes to add to the period. 3) hour, a numeric object.
The apparent amount of hours to add to the period.4) day, a numeric object.
The apparent amount of days to add to the period.5) month, a numeric object.
The apparent amount of months to add to the period. 6) year, a numeric object.
The apparent amount of years to add to the period.
</p>

<hr>
<h2 id='pretty_dates'>Computes attractive axis breaks for date-time data</h2><span id='topic+pretty_dates'></span>

<h3>Description</h3>

<p>pretty.dates indentifies which unit of time the sub-intervals should be
measured in to provide approximately n breaks. It then chooses a &quot;pretty&quot;
length for the sub-intervals and sets start and endpoints that 1) span the
entire range of the data, and 2) allow the breaks to occur on important
date-times (i.e. on the hour, on the first of the month, etc.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pretty_dates(x, n, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pretty_dates_+3A_x">x</code></td>
<td>
<p>a vector of POSIXct, POSIXlt, Date, or chron date-time objects</p>
</td></tr>
<tr><td><code id="pretty_dates_+3A_n">n</code></td>
<td>
<p>integer value of the desired number of breaks</p>
</td></tr>
<tr><td><code id="pretty_dates_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of date-times that can be used as axis tick marks or bin breaks
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq.Date(as.Date("2009-08-02"), by = "year", length.out = 2)
pretty_dates(x, 12)
</code></pre>

<hr>
<h2 id='quarter'>Get the fiscal quarter and semester of a date-time</h2><span id='topic+quarter'></span><span id='topic+semester'></span>

<h3>Description</h3>

<p>Quarters divide the year into fourths. Semesters divide the year into halfs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quarter(
  x,
  type = "quarter",
  fiscal_start = 1,
  with_year = identical(type, "year.quarter")
)

semester(x, with_year = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quarter_+3A_x">x</code></td>
<td>
<p>a date-time object of class POSIXct, POSIXlt, Date, chron, yearmon, yearqtr,
zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, fts or anything else that can
be converted with as.POSIXlt</p>
</td></tr>
<tr><td><code id="quarter_+3A_type">type</code></td>
<td>
<p>the format to be returned for the quarter. Can be one one of &quot;quarter&quot; -
return numeric quarter (default), &quot;year.quarter&quot; return the ending year and quarter
as a number of the form year.quarter, &quot;date_first&quot; or &quot;date_last&quot; - return the date
at the quarter's start or end, &quot;year_start/end&quot; - return a full description of the
quarter as a string which includes the start and end of the year
(ex. &quot;2020/21 Q1&quot;).</p>
</td></tr>
<tr><td><code id="quarter_+3A_fiscal_start">fiscal_start</code></td>
<td>
<p>numeric indicating the starting month of a fiscal year.</p>
</td></tr>
<tr><td><code id="quarter_+3A_with_year">with_year</code></td>
<td>
<p>logical indicating whether or not to include the quarter or
semester's year (deprecated; use the <code>type</code> parameter instead).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric or a vector of class POSIXct if <code>type</code> argument is <code>date_first</code> or
<code>date_last</code>. When <code>type</code> is <code>year.quarter</code> the year returned is the end year of the
financial year.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ymd(c("2012-03-26", "2012-05-04", "2012-09-23", "2012-12-31"))
quarter(x)
quarter(x, type = "year.quarter")
quarter(x, type = "year.quarter", fiscal_start = 11)
quarter(x, type = "date_first", fiscal_start = 11)
quarter(x, type = "date_last", fiscal_start = 11)
semester(x)
semester(x, with_year = TRUE)
</code></pre>

<hr>
<h2 id='reclass_date'>Convenience method to reclass dates post-modification.</h2><span id='topic+reclass_date'></span>

<h3>Description</h3>

<p>Convenience method to reclass dates post-modification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reclass_date(new, orig)
</code></pre>

<hr>
<h2 id='reclass_timespan'>Convenience method to reclass timespans post-modification.</h2><span id='topic+reclass_timespan'></span><span id='topic+reclass_timespan+2CANY+2CDuration-method'></span><span id='topic+reclass_timespan+2CANY+2CInterval-method'></span><span id='topic+reclass_timespan+2CANY+2CPeriod-method'></span><span id='topic+reclass_timespan+2CANY+2Cdifftime-method'></span>

<h3>Description</h3>

<p>Convenience method to reclass timespans post-modification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reclass_timespan(new, orig)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+intersect'></span><span id='topic+union'></span><span id='topic+setdiff'></span><span id='topic+as.difftime'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+coercion-time-difference">as.difftime</a></code>, <code><a href="generics.html#topic+setops">intersect</a></code>, <code><a href="generics.html#topic+setops">setdiff</a></code>, <code><a href="generics.html#topic+setops">union</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rollbackward'>Roll backward or forward a date the previous, current or next month</h2><span id='topic+rollbackward'></span><span id='topic+rollback'></span><span id='topic+rollforward'></span>

<h3>Description</h3>

<p><code>rollbackward()</code> changes a date to the last day of the previous month or to
the first day of the month. <code>rollforward()</code> rolls to the last day of the
current month or to the first day of the next month. Optionally, the new date
can retain the same hour, minute, and second information. <code>rollback()</code> is a
synonym for <code>rollbackward()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rollbackward(dates, roll_to_first = FALSE, preserve_hms = TRUE)

rollback(dates, roll_to_first = FALSE, preserve_hms = TRUE)

rollforward(dates, roll_to_first = FALSE, preserve_hms = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rollbackward_+3A_dates">dates</code></td>
<td>
<p>A POSIXct, POSIXlt or Date class object.</p>
</td></tr>
<tr><td><code id="rollbackward_+3A_roll_to_first">roll_to_first</code></td>
<td>
<p>Rollback to the first day of the month instead of the
last day of the month</p>
</td></tr>
<tr><td><code id="rollbackward_+3A_preserve_hms">preserve_hms</code></td>
<td>
<p>Retains the same hour, minute, and second information? If
FALSE, the new date will be at 00:00:00.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A date-time object of class POSIXlt, POSIXct or Date, whose day has
been adjusted to the last day of the previous month, or to the first day of
the month.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>date &lt;- ymd("2010-03-03")
rollbackward(date)

dates &lt;- date + months(0:2)
rollbackward(dates)

date &lt;- ymd_hms("2010-03-03 12:44:22")
rollbackward(date)
rollbackward(date, roll_to_first = TRUE)
rollbackward(date, preserve_hms = FALSE)
rollbackward(date, roll_to_first = TRUE, preserve_hms = FALSE)
</code></pre>

<hr>
<h2 id='round_date'>Round, floor and ceiling methods for date-time objects</h2><span id='topic+round_date'></span><span id='topic+floor_date'></span><span id='topic+ceiling_date'></span>

<h3>Description</h3>

<p><code>round_date()</code> takes a date-time object and time unit, and rounds it to the nearest value
of the specified time unit. For rounding date-times which are exactly halfway
between two consecutive units, the convention is to round up. Note that this
is in line with the behavior of R's <code><a href="base.html#topic+round.POSIXt">base::round.POSIXt()</a></code> function
but does not follow the convention of the base <code><a href="base.html#topic+Round">base::round()</a></code> function
which &quot;rounds to the even digit&quot;, as per IEC 60559.
</p>
<p>Rounding to the nearest unit or multiple of a unit is supported. All
meaningful specifications in the English language are supported - secs, min,
mins, 2 minutes, 3 years etc.
</p>
<p>Rounding to fractional seconds is also supported. Please note that rounding to
fractions smaller than 1 second can lead to large precision errors due to the
floating point representation of the POSIXct objects. See examples.
</p>
<p><code>floor_date()</code> takes a date-time object and rounds it down to the nearest
boundary of the specified time unit.
</p>
<p><code>ceiling_date()</code> takes a date-time object and rounds it up to the nearest
boundary of the specified time unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>round_date(
  x,
  unit = "second",
  week_start = getOption("lubridate.week.start", 7)
)

floor_date(
  x,
  unit = "seconds",
  week_start = getOption("lubridate.week.start", 7)
)

ceiling_date(
  x,
  unit = "seconds",
  change_on_boundary = NULL,
  week_start = getOption("lubridate.week.start", 7)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="round_date_+3A_x">x</code></td>
<td>
<p>a vector of date-time objects</p>
</td></tr>
<tr><td><code id="round_date_+3A_unit">unit</code></td>
<td>
<p>a string, <code>Period</code> object or a date-time object. When a singleton string,
it specifies a time unit or a multiple of a unit to be rounded to. Valid base units
are <code>second</code>, <code>minute</code>, <code>hour</code>, <code>day</code>, <code>week</code>, <code>month</code>, <code>bimonth</code>, <code>quarter</code>,
<code>season</code>, <code>halfyear</code> and <code>year</code>. Arbitrary unique English abbreviations as in the
<code><a href="#topic+period">period()</a></code> constructor are allowed. Rounding to multiples of units (except weeks)
is supported.
</p>
<p>When <code>unit</code> is a <code>Period</code> object, it is first converted to a string representation
which might not be in the same units as the constructor. For example <code>weeks(1)</code> is
converted to &quot;7d 0H 0M 0S&quot;. Thus, always check the string representation of the
period before passing to this function.
</p>
<p>When <code>unit</code> is a date-time object rounding is done to the nearest of the
elements in <code>unit</code>. If range of <code>unit</code> vector does not cover the range of
<code>x</code> <code>ceiling_date()</code> and <code>floor_date()</code> round to the <code>max(x)</code> and <code>min(x)</code>
for elements that fall outside of <code>range(unit)</code>.</p>
</td></tr>
<tr><td><code id="round_date_+3A_week_start">week_start</code></td>
<td>
<p>week start day (Default is 7, Sunday. Set <code>lubridate.week.start</code> to
override). Full or abbreviated names of the days of the week can be in English or
as provided by the current locale.</p>
</td></tr>
<tr><td><code id="round_date_+3A_change_on_boundary">change_on_boundary</code></td>
<td>
<p>if this is <code>NULL</code> (the default), instants on the
boundary remain unchanged, but <code>Date</code> objects are rounded up to the next
boundary. If this is <code>TRUE</code>, instants on the boundary are rounded up to the
next boundary. If this is <code>FALSE</code>, nothing on the boundary is rounded up at
all. This was the default for <span class="pkg">lubridate</span> prior to <code>v1.6.0</code>. See
section <code style="white-space: pre;">&#8288;Rounding Up Date Objects&#8288;</code> below for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <span class="pkg">lubridate</span>, functions that round date-time objects try to
preserve the class of the input object whenever possible. This is done by
first rounding to an instant, and then converting to the original class as per
usual R conventions.
</p>


<h3>Value</h3>

<p>When <code>unit</code> is a string, return a Date object if <code>x</code> is a Date and
<code>unit</code> is larger or equal than &quot;day&quot;, otherwise a POSIXct object. When
<code>unit</code> is a date-time object, return a date-time object of the same class
and same time zone as <code>unit</code>.
</p>


<h3>Rounding Up Date Objects</h3>

<p>By default, rounding up <code>Date</code> objects follows 3 steps:
</p>

<ol>
<li><p> Convert to an instant representing lower bound of the Date:
<code>2000-01-01</code> &ndash;&gt; <code style="white-space: pre;">&#8288;2000-01-01 00:00:00&#8288;</code>
</p>
</li>
<li><p> Round up to the <strong>next</strong> closest rounding unit boundary. For example,
if the rounding unit is <code>month</code> then next closest boundary of <code>2000-01-01</code>
is <code style="white-space: pre;">&#8288;2000-02-01 00:00:00&#8288;</code>.
</p>
<p>The motivation for this is that the &quot;partial&quot; <code>2000-01-01</code> is conceptually
an interval (<code style="white-space: pre;">&#8288;2000-01-01 00:00:00&#8288;</code> &ndash; <code style="white-space: pre;">&#8288;2000-01-02 00:00:00&#8288;</code>) and the day
hasn't started clocking yet at the exact boundary <code>00:00:00</code>. Thus, it
seems wrong to round a day to its lower boundary.
</p>
<p>Behavior on the boundary can be changed by setting
<code>change_on_boundary</code> to <code>TRUE</code> or <code>FALSE</code>.
</p>
</li>
<li><p> If the rounding unit is smaller than a day, return the instant from step 2
(<code>POSIXct</code>), otherwise convert to and return a <code>Date</code> object.
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="base.html#topic+Round">base::round()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## print fractional seconds
options(digits.secs = 6)

x &lt;- ymd_hms("2009-08-03 12:01:59.23")
round_date(x, ".5s")
round_date(x, "sec")
round_date(x, "second")
round_date(x, "minute")
round_date(x, "5 mins")
round_date(x, "hour")
round_date(x, "2 hours")
round_date(x, "day")
round_date(x, "week")
round_date(x, "month")
round_date(x, "bimonth")
round_date(x, "quarter") == round_date(x, "3 months")
round_date(x, "halfyear")
round_date(x, "year")

x &lt;- ymd_hms("2009-08-03 12:01:59.23")
floor_date(x, ".1s")
floor_date(x, "second")
floor_date(x, "minute")
floor_date(x, "hour")
floor_date(x, "day")
floor_date(x, "week")
floor_date(x, "month")
floor_date(x, "bimonth")
floor_date(x, "quarter")
floor_date(x, "season")
floor_date(x, "halfyear")
floor_date(x, "year")

x &lt;- ymd_hms("2009-08-03 12:01:59.23")
ceiling_date(x, ".1 sec") # imprecise representation at 0.1 sec !!!
ceiling_date(x, "second")
ceiling_date(x, "minute")
ceiling_date(x, "5 mins")
ceiling_date(x, "hour")
ceiling_date(x, "day")
ceiling_date(x, "week")
ceiling_date(x, "month")
ceiling_date(x, "bimonth") == ceiling_date(x, "2 months")
ceiling_date(x, "quarter")
ceiling_date(x, "season")
ceiling_date(x, "halfyear")
ceiling_date(x, "year")

## Period unit argument
floor_date(x, days(2))
floor_date(x, years(1))

## As of R 3.4.2 POSIXct printing of fractional numbers is wrong
as.POSIXct("2009-08-03 12:01:59.3") ## -&gt; "2009-08-03 12:01:59.2 CEST"
ceiling_date(x, ".1 sec") ## -&gt; "2009-08-03 12:01:59.2 CEST"

## behaviour of `change_on_boundary`
## As per default behaviour `NULL`, instants on the boundary remain the
## same but dates are rounded up
ceiling_date(ymd_hms("2000-01-01 00:00:00"), "month")
ceiling_date(ymd("2000-01-01"), "month")

## If `TRUE`, both instants and dates on the boundary are rounded up
ceiling_date(ymd_hms("2000-01-01 00:00:00"), "month", change_on_boundary = TRUE)
ceiling_date(ymd("2000-01-01"), "month")

## If `FALSE`, both instants and dates on the boundary remain the same
ceiling_date(ymd_hms("2000-01-01 00:00:00"), "month", change_on_boundary = FALSE)
ceiling_date(ymd("2000-01-01"), "month")

x &lt;- ymd_hms("2000-01-01 00:00:00")
ceiling_date(x, "month")
ceiling_date(x, "month", change_on_boundary = TRUE)

## For Date objects first day of the month is not on the
## "boundary". change_on_boundary applies to instants only.
x &lt;- ymd("2000-01-01")
ceiling_date(x, "month")
ceiling_date(x, "month", change_on_boundary = TRUE)
</code></pre>

<hr>
<h2 id='second'>Get/set seconds component of a date-time</h2><span id='topic+second'></span><span id='topic+second+3C-'></span>

<h3>Description</h3>

<p>Date-time must be a  POSIXct, POSIXlt, Date, Period, chron, yearmon, yearqtr, zoo,
zooreg, timeDate, xts, its, ti, jul, timeSeries, and fts objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>second(x)

second(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="second_+3A_x">x</code></td>
<td>
<p>a date-time object</p>
</td></tr>
<tr><td><code id="second_+3A_value">value</code></td>
<td>
<p>numeric value to be assigned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the seconds element of x as a decimal number
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ymd("2012-03-26")
second(x)
second(x) &lt;- 1
second(x) &lt;- 61
second(x) &gt; 2
</code></pre>

<hr>
<h2 id='stamp'>Format dates and times based on human-friendly templates</h2><span id='topic+stamp'></span><span id='topic+stamp_date'></span><span id='topic+stamp_time'></span>

<h3>Description</h3>

<p>Stamps are just like <code><a href="base.html#topic+format">format()</a></code>, but based on human-friendly
templates like &quot;Recorded at 10 am, September 2002&quot; or &quot;Meeting, Sunday May
1, 2000, at 10:20 pm&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stamp(
  x,
  orders = lubridate_formats,
  locale = Sys.getlocale("LC_TIME"),
  quiet = FALSE,
  exact = FALSE
)

stamp_date(x, locale = Sys.getlocale("LC_TIME"), quiet = FALSE)

stamp_time(x, locale = Sys.getlocale("LC_TIME"), quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stamp_+3A_x">x</code></td>
<td>
<p>a character vector of templates.</p>
</td></tr>
<tr><td><code id="stamp_+3A_orders">orders</code></td>
<td>
<p>orders are sequences of formatting characters which might be
used for disambiguation. For example &quot;ymd hms&quot;, &quot;aym&quot; etc. See
<code><a href="#topic+guess_formats">guess_formats()</a></code> for a list of available formats.</p>
</td></tr>
<tr><td><code id="stamp_+3A_locale">locale</code></td>
<td>
<p>locale in which <code>x</code> is encoded. On Linux-like systems use
<code>locale -a</code> in the terminal to list available locales.</p>
</td></tr>
<tr><td><code id="stamp_+3A_quiet">quiet</code></td>
<td>
<p>whether to output informative messages.</p>
</td></tr>
<tr><td><code id="stamp_+3A_exact">exact</code></td>
<td>
<p>logical. If <code>TRUE</code>, the <code>orders</code> parameter is interpreted as an
exact <code><a href="base.html#topic+strptime">base::strptime()</a></code> format and no format guessing is performed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stamp()</code> is a stamping function date-time templates mainly, though it
correctly handles all date and time formats as long as they are
unambiguous. <code>stamp_date()</code>, and <code>stamp_time()</code> are the specialized
stamps for dates and times (MHS). These function might be useful when the
input template is unambiguous and matches both a time and a date format.
</p>
<p>Lubridate tries hard to guess the formats, but often a given format can be
interpreted in multiple ways. One way to deal with such cases is to provide
unambiguous formats like 22/05/81 instead of 10/05/81 for d/m/y
format. Another way is to use a more specialized <code><a href="#topic+stamp_date">stamp_date</a></code> and
<code><a href="#topic+stamp_time">stamp_time</a></code>. The core function <code>stamp()</code> prioritizes longer date-time
formats.
</p>
<p>If <code>x</code> is a vector of values <span class="pkg">lubridate</span> will choose the format which
&quot;fits&quot; <code>x</code> the best. Note that longer formats are preferred. If you have
&quot;22:23:00 PM&quot; then &quot;HMSp&quot; format will be given priority to shorter &quot;HMS&quot;
order which also fits the supplied string.
</p>
<p>Finally, you can give desired format order directly as <code>orders</code>
argument.
</p>


<h3>Value</h3>

<p>a function to be applied on a vector of dates
</p>


<h3>See Also</h3>

<p><code><a href="#topic+guess_formats">guess_formats()</a></code>, <code><a href="#topic+parse_date_time">parse_date_time()</a></code>, <code><a href="base.html#topic+strptime">strptime()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>D &lt;- ymd("2010-04-05") - days(1:5)
stamp("March 1, 1999")(D)
sf &lt;- stamp("Created on Sunday, Jan 1, 1999 3:34 pm")
sf(D)
stamp("Jan 01")(D)
stamp("Sunday, May 1, 2000", locale = "C")(D)
stamp("Sun Aug 5")(D) #=&gt; "Sun Aug 04" "Sat Aug 04" "Fri Aug 04" "Thu Aug 04" "Wed Aug 03"
stamp("12/31/99")(D)              #=&gt; "06/09/11"
stamp("Sunday, May 1, 2000 22:10", locale = "C")(D)
stamp("2013-01-01T06:00:00Z")(D)
stamp("2013-01-01T00:00:00-06")(D)
stamp("2013-01-01T00:00:00-08:00")(force_tz(D, "America/Chicago"))
</code></pre>

<hr>
<h2 id='time_length'>Compute the exact length of a time span</h2><span id='topic+time_length'></span><span id='topic+time_length+2CInterval-method'></span>

<h3>Description</h3>

<p>Compute the exact length of a time span
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_length(x, unit = "second")

## S4 method for signature 'Interval'
time_length(x, unit = "second")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_length_+3A_x">x</code></td>
<td>
<p>a duration, period, difftime or interval</p>
</td></tr>
<tr><td><code id="time_length_+3A_unit">unit</code></td>
<td>
<p>a character string that specifies with time units to use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>x</code> is an <a href="#topic+Interval-class">Interval</a> object and
<code>unit</code> are years or months, <code>time_length()</code> takes into account
the fact that all months and years don't have the same number of days.
</p>
<p>When <code>x</code> is a <a href="#topic+Duration-class">Duration</a>, <a href="#topic+Period-class">Period</a>
or <code><a href="base.html#topic+difftime">difftime()</a></code> object, length in months or years is based on their
most common lengths in seconds (see <code><a href="#topic+timespan">timespan()</a></code>).
</p>


<h3>Value</h3>

<p>the length of the interval in the specified unit. A negative number
connotes a negative interval or duration
</p>


<h3>See Also</h3>

<p><code><a href="#topic+timespan">timespan()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>int &lt;- interval(ymd("1980-01-01"), ymd("2014-09-18"))
time_length(int, "week")

# Exact age
time_length(int, "year")

# Age at last anniversary
trunc(time_length(int, "year"))

# Example of difference between intervals and durations
int &lt;- interval(ymd("1900-01-01"), ymd("1999-12-31"))
time_length(int, "year")
time_length(as.duration(int), "year")
</code></pre>

<hr>
<h2 id='timespan'>Description of time span classes in lubridate</h2><span id='topic+timespan'></span><span id='topic+timespans'></span>

<h3>Description</h3>

<p>A time span can be measured in three ways: as a duration, an interval, or a
period.
</p>

<ul>
<li> <p><a href="#topic+duration">duration</a>s record the exact number of seconds in a time span.
They measure the exact passage of time but do not always align with
human measurements like hours, months and years.
</p>
</li>
<li> <p><a href="#topic+period">period</a>s record the change in the clock time between two date-times.
They are measured in human units: years, months, days, hours, minutes,
and seconds.
</p>
</li>
<li> <p><a href="#topic+intervals">intervals</a> are time spans bound by two real date-times. Intervals can be
accurately converted to periods and durations.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>duration(3690, "seconds")
period(3690, "seconds")
period(second = 30, minute = 1, hour = 1)
interval(ymd_hms("2009-08-09 13:01:30"), ymd_hms("2009-08-09 12:00:00"))

date &lt;- ymd_hms("2009-03-08 01:59:59") # DST boundary
date + days(1)
date + ddays(1)

date2 &lt;- ymd_hms("2000-02-29 12:00:00")
date2 + years(1)
# self corrects to next real day

date3 &lt;- ymd_hms("2009-01-31 01:00:00")
date3 + c(0:11) * months(1)

span &lt;- date2 %--% date # creates interval

date &lt;- ymd_hms("2009-01-01 00:00:00")
date + years(1)
date - days(3) + hours(6)
date + 3 * seconds(10)

months(6) + days(1)
</code></pre>

<hr>
<h2 id='Timespan-class'>Timespan class</h2><span id='topic+Timespan-class'></span><span id='topic++2A+2CTimespan+2CTimespan-method'></span><span id='topic++25+2F+25+2CTimespan+2CTimespan-method'></span><span id='topic++25+2F+25+2Cdifftime+2CTimespan-method'></span><span id='topic++25+2F+25+2CInterval+2CInterval-method'></span><span id='topic++25+2F+25+2CPeriod+2CPeriod-method'></span><span id='topic++25+2F+25+2CInterval+2CDuration-method'></span><span id='topic++25+2F+25+2CDuration+2CInterval-method'></span><span id='topic++25+2F+25+2CInterval+2CPeriod-method'></span><span id='topic++25+2F+25+2CPeriod+2CInterval-method'></span>

<h3>Description</h3>

<p>Timespan is an S4 class with no slots. It is extended by the
<a href="#topic+Interval-class">Interval</a>, <a href="#topic+Period-class">Period</a>, and <a href="#topic+Duration-class">Duration</a>
classes.
</p>

<hr>
<h2 id='tz'>Get/set time zone component of a date-time</h2><span id='topic+tz'></span><span id='topic+tz+3C-'></span>

<h3>Description</h3>

<p>Conveniently get and set the time zone of a date-time.
</p>
<p><code style="white-space: pre;">&#8288;tz&lt;-&#8288;</code> is an alias for <code><a href="#topic+force_tz">force_tz()</a></code>, which preserves the local time,
creating a different instant in time. Use <code><a href="#topic+with_tz">with_tz()</a></code> if you want keep
the instant the same, but change the printed representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tz(x)

tz(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tz_+3A_x">x</code></td>
<td>
<p>A date-time vector, usually of class <code>POSIXct</code> or <code>POSIXlt</code>.</p>
</td></tr>
<tr><td><code id="tz_+3A_value">value</code></td>
<td>
<p>New value of time zone.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of length 1. An empty string (<code>""</code>) represents
your current time zone.
</p>
<p>For backward compatibility, the time zone of a date, <code>NA</code>, or
character vector is <code>"UTC"</code>.
</p>


<h3>Valid time zones</h3>

<p>Time zones are stored in system specific database, so are not guaranteed
to be the same on every system (however, they are usually pretty similar
unless your system is very out of date). You can see a complete list with
<code><a href="base.html#topic+OlsonNames">OlsonNames()</a></code>.
</p>


<h3>See Also</h3>

<p>See <a href="base.html#topic+DateTimeClasses">DateTimeClasses</a> for a description of the underlying
<code>tzone</code> attribute..
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- y &lt;- ymd_hms("2012-03-26 10:10:00", tz = "UTC")
tz(x)

# Note that setting tz() preserved the clock time, which implies
# that the actual instant in time is changing
tz(y) &lt;- "Pacific/Auckland"
y
x - y

# This is the same as force_tz()
force_tz(x, "Pacific/Auckland")

# Use with_tz() if you want to change the time zone, leave
# the instant in time the same
with_tz(x, "Pacific/Auckland")
</code></pre>

<hr>
<h2 id='week'>Get/set weeks component of a date-time</h2><span id='topic+week'></span><span id='topic+week+3C-'></span><span id='topic+isoweek'></span><span id='topic+epiweek'></span>

<h3>Description</h3>

<p><code>week()</code> returns the number of complete seven day periods that have
occurred between the date and January 1st, plus one.
</p>
<p><code>isoweek()</code> returns the week as it would appear in the ISO 8601
system, which uses a reoccurring leap week.
</p>
<p><code>epiweek()</code> is the US CDC version of epidemiological week. It
follows same rules as <code>isoweek()</code> but starts on Sunday. In other parts of
the world the convention is to start epidemiological weeks on Monday,
which is the same as <code>isoweek</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>week(x)

week(x) &lt;- value

isoweek(x)

epiweek(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="week_+3A_x">x</code></td>
<td>
<p>a date-time object. Must be a POSIXct, POSIXlt, Date, chron,
yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, or
fts object.</p>
</td></tr>
<tr><td><code id="week_+3A_value">value</code></td>
<td>
<p>a numeric object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the weeks element of x as an integer number
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/ISO_week_date">https://en.wikipedia.org/wiki/ISO_week_date</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isoyear">isoyear()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ymd("2012-03-26")
week(x)
week(x) &lt;- 1
week(x) &lt;- 54
week(x) &gt; 3
</code></pre>

<hr>
<h2 id='with_tz'>Get date-time in a different time zone</h2><span id='topic+with_tz'></span><span id='topic+with_tz.default'></span>

<h3>Description</h3>

<p>with_tz returns a date-time as it would appear in a different time zone.
The actual moment of time measured does not change, just the time zone it is
measured in. with_tz defaults to the Universal Coordinated time zone (UTC)
when an unrecognized time zone is inputted. See <code><a href="base.html#topic+Sys.timezone">Sys.timezone()</a></code>
for more information on how R recognizes time zones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_tz(time, tzone = "", ...)

## Default S3 method:
with_tz(time, tzone = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_tz_+3A_time">time</code></td>
<td>
<p>a POSIXct, POSIXlt, Date, chron date-time object or a data.frame
object. When a data.frame all POSIXt elements of a data.frame are processed
with <code>with_tz()</code> and new data.frame is returned.</p>
</td></tr>
<tr><td><code id="with_tz_+3A_tzone">tzone</code></td>
<td>
<p>a character string containing the time zone to convert to. R
must recognize the name contained in the string as a time zone on your
system.</p>
</td></tr>
<tr><td><code id="with_tz_+3A_...">...</code></td>
<td>
<p>Parameters passed to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a POSIXct object in the updated time zone
</p>


<h3>See Also</h3>

<p><code><a href="#topic+force_tz">force_tz()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ymd_hms("2009-08-07 00:00:01", tz = "America/New_York")
with_tz(x, "GMT")
</code></pre>

<hr>
<h2 id='year'>Get/set years component of a date-time</h2><span id='topic+year'></span><span id='topic+year+3C-'></span><span id='topic+isoyear'></span><span id='topic+epiyear'></span>

<h3>Description</h3>

<p>Date-time must be a POSIXct, POSIXlt, Date, Period or any other object
convertible to POSIXlt.
</p>
<p><code>isoyear()</code> returns years according to the ISO 8601 week calendar.
</p>
<p><code>epiyear()</code> returns years according to the epidemiological week calendars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>year(x)

year(x) &lt;- value

isoyear(x)

epiyear(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="year_+3A_x">x</code></td>
<td>
<p>a date-time object</p>
</td></tr>
<tr><td><code id="year_+3A_value">value</code></td>
<td>
<p>a numeric object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>year does not yet support years before 0 C.E.
</p>


<h3>Value</h3>

<p>the years element of x as a decimal number
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/ISO_week_date">https://en.wikipedia.org/wiki/ISO_week_date</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ymd("2012-03-26")
year(x)
year(x) &lt;- 2001
year(x) &gt; 1995
</code></pre>

<hr>
<h2 id='ymd'>Parse dates with <strong>y</strong>ear, <strong>m</strong>onth, and <strong>d</strong>ay components</h2><span id='topic+ymd'></span><span id='topic+ydm'></span><span id='topic+mdy'></span><span id='topic+myd'></span><span id='topic+dmy'></span><span id='topic+dym'></span><span id='topic+yq'></span><span id='topic+ym'></span><span id='topic+my'></span>

<h3>Description</h3>

<p>Transforms dates stored in character and numeric vectors to Date or POSIXct
objects (see <code>tz</code> argument). These functions recognize arbitrary
non-digit separators as well as no separator. As long as the order of
formats is correct, these functions will parse dates correctly even when the
input vectors contain differently formatted dates. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ymd(
  ...,
  quiet = FALSE,
  tz = NULL,
  locale = Sys.getlocale("LC_TIME"),
  truncated = 0
)

ydm(
  ...,
  quiet = FALSE,
  tz = NULL,
  locale = Sys.getlocale("LC_TIME"),
  truncated = 0
)

mdy(
  ...,
  quiet = FALSE,
  tz = NULL,
  locale = Sys.getlocale("LC_TIME"),
  truncated = 0
)

myd(
  ...,
  quiet = FALSE,
  tz = NULL,
  locale = Sys.getlocale("LC_TIME"),
  truncated = 0
)

dmy(
  ...,
  quiet = FALSE,
  tz = NULL,
  locale = Sys.getlocale("LC_TIME"),
  truncated = 0
)

dym(
  ...,
  quiet = FALSE,
  tz = NULL,
  locale = Sys.getlocale("LC_TIME"),
  truncated = 0
)

yq(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale("LC_TIME"))

ym(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale("LC_TIME"))

my(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale("LC_TIME"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ymd_+3A_...">...</code></td>
<td>
<p>a character or numeric vector of suspected dates</p>
</td></tr>
<tr><td><code id="ymd_+3A_quiet">quiet</code></td>
<td>
<p>logical. If <code>TRUE</code>, function evaluates without displaying
customary messages.</p>
</td></tr>
<tr><td><code id="ymd_+3A_tz">tz</code></td>
<td>
<p>Time zone indicator. If <code>NULL</code> (default), a Date object is
returned. Otherwise a POSIXct with time zone attribute set to <code>tz</code>.</p>
</td></tr>
<tr><td><code id="ymd_+3A_locale">locale</code></td>
<td>
<p>locale to be used, see <a href="base.html#topic+locales">locales</a>. On Linux systems you
can use <code>system("locale -a")</code> to list all the installed locales.</p>
</td></tr>
<tr><td><code id="ymd_+3A_truncated">truncated</code></td>
<td>
<p>integer. Number of formats that can be truncated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case of heterogeneous date formats, the <code>ymd()</code> family guesses formats based
on a subset of the input vector. If the input vector contains many missing
values or non-date strings, the subset might not contain meaningful dates
and the date-time format won't be guessed resulting in
<code style="white-space: pre;">&#8288;All formats failed to parse&#8288;</code> error. In such cases please see
<code><a href="#topic+parse_date_time">parse_date_time()</a></code> for a more flexible parsing interface.
</p>
<p>If the <code>truncated</code> parameter is non-zero, the <code>ymd()</code> functions also check for
truncated formats. For example, <code>ymd()</code> with <code>truncated = 2</code> will also
parse incomplete dates like <code>2012-06</code> and <code>2012</code>.
</p>
<p>NOTE: The <code>ymd()</code> family of functions is based on <code>parse_date_time()</code> and thus
directly drop to the internal C parser for numeric months, but uses
<code><a href="base.html#topic+strptime">base::strptime()</a></code> for alphabetic months. This implies that some of <code><a href="base.html#topic+strptime">base::strptime()</a></code>'s
limitations are inherited by <span class="pkg">lubridate</span>'s parser. For example, truncated
formats (like <code style="white-space: pre;">&#8288;%Y-%b&#8288;</code>) will not be parsed. Numeric truncated formats (like
<code style="white-space: pre;">&#8288;%Y-%m&#8288;</code>) are handled correctly by <span class="pkg">lubridate</span>'s C parser.
</p>
<p>As of version 1.3.0, <span class="pkg">lubridate</span>'s parse functions no longer return a
message that displays which format they used to parse their input. You can
change this by setting the <code>lubridate.verbose</code> option to <code>TRUE</code> with
<code>options(lubridate.verbose = TRUE)</code>.
</p>


<h3>Value</h3>

<p>a vector of class POSIXct if <code>tz</code> argument is non-<code>NULL</code> or Date if tz
is <code>NULL</code> (default)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parse_date_time">parse_date_time()</a></code> for an even more flexible low level
mechanism.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("09-01-01", "09-01-02", "09-01-03")
ymd(x)
x &lt;- c("2009-01-01", "2009-01-02", "2009-01-03")
ymd(x)
ymd(090101, 90102)
now() &gt; ymd(20090101)
## TRUE
dmy(010210)
mdy(010210)

yq('2014.2')

## heterogeneous formats in a single vector:
x &lt;- c(20090101, "2009-01-02", "2009 01 03", "2009-1-4",
       "2009-1, 5", "Created on 2009 1 6", "200901 !!! 07")
ymd(x)

## What lubridate might not handle:

## Extremely weird cases when one of the separators is "" and some of the
## formats are not in double digits might not be parsed correctly:
## Not run: ymd("201002-01", "201002-1", "20102-1")
dmy("0312-2010", "312-2010")
## End(Not run)
</code></pre>

<hr>
<h2 id='ymd_hms'>Parse date-times with <strong>y</strong>ear, <strong>m</strong>onth, and <strong>d</strong>ay, <strong>h</strong>our,
<strong>m</strong>inute, and <strong>s</strong>econd components.</h2><span id='topic+ymd_hms'></span><span id='topic+ymd_hm'></span><span id='topic+ymd_h'></span><span id='topic+dmy_hms'></span><span id='topic+dmy_hm'></span><span id='topic+dmy_h'></span><span id='topic+mdy_hms'></span><span id='topic+mdy_hm'></span><span id='topic+mdy_h'></span><span id='topic+ydm_hms'></span><span id='topic+ydm_hm'></span><span id='topic+ydm_h'></span>

<h3>Description</h3>

<p>Transform dates stored as character or numeric vectors to POSIXct
objects. The <code>ymd_hms()</code> family of functions recognizes all non-alphanumeric
separators (with the exception of &quot;.&quot; if <code>frac = TRUE</code>) and correctly
handles heterogeneous date-time representations. For more flexibility in
treatment of heterogeneous formats, see low level parser
<code><a href="#topic+parse_date_time">parse_date_time()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ymd_hms(
  ...,
  quiet = FALSE,
  tz = "UTC",
  locale = Sys.getlocale("LC_TIME"),
  truncated = 0
)

ymd_hm(
  ...,
  quiet = FALSE,
  tz = "UTC",
  locale = Sys.getlocale("LC_TIME"),
  truncated = 0
)

ymd_h(
  ...,
  quiet = FALSE,
  tz = "UTC",
  locale = Sys.getlocale("LC_TIME"),
  truncated = 0
)

dmy_hms(
  ...,
  quiet = FALSE,
  tz = "UTC",
  locale = Sys.getlocale("LC_TIME"),
  truncated = 0
)

dmy_hm(
  ...,
  quiet = FALSE,
  tz = "UTC",
  locale = Sys.getlocale("LC_TIME"),
  truncated = 0
)

dmy_h(
  ...,
  quiet = FALSE,
  tz = "UTC",
  locale = Sys.getlocale("LC_TIME"),
  truncated = 0
)

mdy_hms(
  ...,
  quiet = FALSE,
  tz = "UTC",
  locale = Sys.getlocale("LC_TIME"),
  truncated = 0
)

mdy_hm(
  ...,
  quiet = FALSE,
  tz = "UTC",
  locale = Sys.getlocale("LC_TIME"),
  truncated = 0
)

mdy_h(
  ...,
  quiet = FALSE,
  tz = "UTC",
  locale = Sys.getlocale("LC_TIME"),
  truncated = 0
)

ydm_hms(
  ...,
  quiet = FALSE,
  tz = "UTC",
  locale = Sys.getlocale("LC_TIME"),
  truncated = 0
)

ydm_hm(
  ...,
  quiet = FALSE,
  tz = "UTC",
  locale = Sys.getlocale("LC_TIME"),
  truncated = 0
)

ydm_h(
  ...,
  quiet = FALSE,
  tz = "UTC",
  locale = Sys.getlocale("LC_TIME"),
  truncated = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ymd_hms_+3A_...">...</code></td>
<td>
<p>a character vector of dates in year, month, day, hour, minute,
second format</p>
</td></tr>
<tr><td><code id="ymd_hms_+3A_quiet">quiet</code></td>
<td>
<p>logical. If <code>TRUE</code>, function evaluates without displaying customary messages.</p>
</td></tr>
<tr><td><code id="ymd_hms_+3A_tz">tz</code></td>
<td>
<p>a character string that specifies which time zone to parse the date with. The string
must be a time zone that is recognized by the user's OS.</p>
</td></tr>
<tr><td><code id="ymd_hms_+3A_locale">locale</code></td>
<td>
<p>locale to be used, see <a href="base.html#topic+locales">locales</a>. On Linux systems you
can use <code>system("locale -a")</code> to list all the installed locales.</p>
</td></tr>
<tr><td><code id="ymd_hms_+3A_truncated">truncated</code></td>
<td>
<p>integer, indicating how many formats can be missing. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>ymd_hms()</code> functions automatically assign the Universal Coordinated Time
Zone (UTC) to the parsed date. This time zone can be changed with
<code><a href="#topic+force_tz">force_tz()</a></code>.
</p>
<p>The most common type of irregularity in date-time data is the truncation
due to rounding or unavailability of the time stamp. If the <code>truncated</code>
parameter is non-zero, the <code>ymd_hms()</code> functions also check for truncated
formats. For example, <code>ymd_hms()</code> with <code>truncated = 3</code> will also parse
incomplete dates like <code style="white-space: pre;">&#8288;2012-06-01 12:23&#8288;</code>, <code style="white-space: pre;">&#8288;2012-06-01 12&#8288;</code> and
<code>2012-06-01</code>. NOTE: The <code>ymd()</code> family of functions is based on
<code><a href="base.html#topic+strptime">base::strptime()</a></code> which currently fails to parse <code style="white-space: pre;">&#8288;%y-%m&#8288;</code> formats.
</p>
<p>In case of heterogeneous date formats the <code>ymd_hms()</code> family guesses formats
based on a subset of the input vector. If the input vector contains many
missing values or non-date strings, the subset might not contain meaningful
dates and the date-time format won't be guessed resulting in
<code style="white-space: pre;">&#8288;All formats failed to parse&#8288;</code> error. In such cases please see
<code><a href="#topic+parse_date_time">parse_date_time()</a></code> for a more flexible parsing interface.
</p>
<p>As of version 1.3.0, <span class="pkg">lubridate</span>'s parse functions no longer return a
message that displays which format they used to parse their input. You can
change this by setting the <code>lubridate.verbose</code> option to <code>TRUE</code> with
<code>options(lubridate.verbose = TRUE)</code>.
</p>


<h3>Value</h3>

<p>a vector of <a href="#topic+POSIXct">POSIXct</a> date-time objects
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+ymd">ymd()</a></code>, <code><a href="#topic+hms">hms()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+parse_date_time">parse_date_time()</a></code> for the underlying mechanism
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- c("2010-04-14-04-35-59", "2010-04-01-12-00-00")
ymd_hms(x)
x &lt;- c("2011-12-31 12:59:59", "2010-01-01 12:00:00")
ymd_hms(x)


## ** heterogeneous formats **
x &lt;- c(20100101120101, "2009-01-02 12-01-02", "2009.01.03 12:01:03",
       "2009-1-4 12-1-4",
       "2009-1, 5 12:1, 5",
       "200901-08 1201-08",
       "2009 arbitrary 1 non-decimal 6 chars 12 in between 1 !!! 6",
       "OR collapsed formats: 20090107 120107 (as long as prefixed with zeros)",
       "Automatic wday, Thu, detection, 10-01-10 10:01:10 and p format: AM",
       "Created on 10-01-11 at 10:01:11 PM")
ymd_hms(x)

## ** fractional seconds **
op &lt;- options(digits.secs=3)
dmy_hms("20/2/06 11:16:16.683")
options(op)

## ** different formats for ISO8601 timezone offset **
ymd_hms(c("2013-01-24 19:39:07.880-0600",
"2013-01-24 19:39:07.880", "2013-01-24 19:39:07.880-06:00",
"2013-01-24 19:39:07.880-06", "2013-01-24 19:39:07.880Z"))

## ** internationalization **
## Not run: 
x_RO &lt;- "Ma 2012 august 14 11:28:30 "
  ymd_hms(x_RO, locale = "ro_RO.utf8")

## End(Not run)

## ** truncated time-dates **
x &lt;- c("2011-12-31 12:59:59", "2010-01-01 12:11", "2010-01-01 12", "2010-01-01")
ymd_hms(x, truncated = 3)
x &lt;- c("2011-12-31 12:59", "2010-01-01 12", "2010-01-01")
ymd_hm(x, truncated = 2)
## ** What lubridate might not handle **
## Extremely weird cases when one of the separators is "" and some of the
## formats are not in double digits might not be parsed correctly:
## Not run: 
ymd_hm("20100201 07-01", "20100201 07-1", "20100201 7-01")
## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
