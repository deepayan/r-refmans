<!DOCTYPE html><html lang="en"><head><title>Help for package GoFKernel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GoFKernel}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#GoFKernel-package'>
<p>Testing Goodness-of-fit with the Kernel Density Estimator</p></a></li>
<li><a href='#area.between'><p>Area between a Density Function and a Kernel Estimate</p></a></li>
<li><a href='#density.reflected'>
<p>Kernel Density Estimation with Reflection</p></a></li>
<li><a href='#dgeometric.test'>
<p>Geometric Goodness-of-fit Test</p></a></li>
<li><a href='#fan.test'>
<p>Univariate implementation of the test of Fan (1994) in the form proposed by Li and Racine (2007).</p></a></li>
<li><a href='#inverse'><p>Inverse CDF Function</p></a></li>
<li><a href='#random.function'>
<p>Random Draw Generator</p></a></li>
<li><a href='#risk76.1929'>
<p>Inmigrants Exposed to Risk of Death</p></a></li>
<li><a href='#support.facto'>
<p>&quot;De Facto&quot; Support</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Testing Goodness-of-Fit with the Kernel Density Estimator</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1-3</td>
</tr>
<tr>
<td>Description:</td>
<td>Tests of goodness-of-fit based on a kernel smoothing of the data.
    References:
       Pavía (2015) &lt;<a href="https://doi.org/10.18637%2Fjss.v066.c01">doi:10.18637/jss.v066.c01</a>&gt;.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>stats, KernSmooth</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-05 17:37:09 UTC; mariaamparo</td>
</tr>
<tr>
<td>Author:</td>
<td>Jose M. Pavía <a href="https://orcid.org/0000-0002-0129-726X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jose M. Pavía &lt;jose.m.pavia@uv.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-06 10:20:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='GoFKernel-package'>
Testing Goodness-of-fit with the Kernel Density Estimator
</h2><span id='topic+GoFKernel-package'></span><span id='topic+GoFKernel'></span>

<h3>Description</h3>

<p>Tests of goodness-of-fit based on kernel smoothing of the data.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> GoFKernel</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;=2.17.3), <code>stats</code>, <code>KernSmooth</code> (&gt;=2.23-8)</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.1-1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-05-26</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The most important functions in <code>GoFKernel</code> are <code><a href="#topic+dgeometric.test">dgeometric.test</a></code> and <code><a href="#topic+fan.test">fan.test</a></code>.
</p>


<h3>Author(s)</h3>

<p>Jose M. Pavia
</p>
<p>Maintainer: Jose M. Pavia &lt;Jose.M.Pavia@uv.es&gt;
</p>


<h3>References</h3>

<p>Fan, Y (1994) &quot;Testing the goodness-of-fit of a parametric density function by kernel method&quot;, Econometric Theory, 10, 316-356.
</p>
<p>Li, O. and Racine, J.F. (2007) &quot;Nonparametric Econometrics&quot;, Princeton University Press, New Jersey.
</p>
<p>Pavia, JM (2015) &quot;Testing Goodness-of-fit with the Kernel Density Estimator: GoFKernel&quot;, Journal of Statistical Software, Code Snippets, 66(1), 1&ndash;27.
</p>

<hr>
<h2 id='area.between'>Area between a Density Function and a Kernel Estimate</h2><span id='topic+area.between'></span>

<h3>Description</h3>

<p>The function <code>area.between</code> is an (internal) function of the <code>GoFKernel</code> package that calculates the area,
in a given interval, between a theoretical density function and an empirical
kernel estimate. <code>area.between</code> is called by <code>dgeometric.test</code> of the <code>GoFKernel</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>area.between(f, kernel.density, lower = -Inf, upper = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="area.between_+3A_f">f</code></td>
<td>
<p>a density function.</p>
</td></tr>
<tr><td><code id="area.between_+3A_kernel.density">kernel.density</code></td>
<td>
<p>an empirical kernel estimate, an object of the class <code>density</code>.</p>
</td></tr>
<tr><td><code id="area.between_+3A_lower">lower</code></td>
<td>
<p>lower limit of the support of f, default -Inf.</p>
</td></tr>
<tr><td><code id="area.between_+3A_upper">upper</code></td>
<td>
<p>upper limit of the support of f, default Inf.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>area.between</code> is called by <code>dgeometric.test</code> and numerically calculates
the area between the density function of the null hypothesis and the kernel density estimate
of either the observed sample or a simulated sample from <code>f</code>.</p>


<h3>Value</h3>

<p>A number corresponding to the numerical value of the area between a density function and
a kernel estimate.</p>


<h3>Author(s)</h3>

<p>Jose M. Pavia
</p>


<h3>See Also</h3>

<p><code><a href="#topic+density.reflected">density.reflected</a></code>, <code><a href="#topic+dgeometric.test">dgeometric.test</a></code>, <code><a href="#topic+inverse">inverse</a></code>
<code><a href="#topic+random.function">random.function</a></code>, <code><a href="#topic+support.facto">support.facto</a></code> and
<code><a href="stats.html#topic+density">density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Unbounded example
x &lt;- rnorm(100)
dx &lt;- density(x)
area.between(dnorm, dx)

## Bounded example
x &lt;- rbeta(100, 1.3, 2)
dx &lt;- density.reflected(x, lower=0, upper=1)
area.between(dunif, dx)
</code></pre>

<hr>
<h2 id='density.reflected'>
Kernel Density Estimation with Reflection
</h2><span id='topic+density'></span><span id='topic+density.reflected'></span>

<h3>Description</h3>

<p>The function <code>density.reflected</code> computes kernel density estimates for univariate observations using reflection in the borders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'reflected'
density(x, lower = -Inf, upper = Inf, weights= NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="density.reflected_+3A_x">x</code></td>
<td>
<p>a numeric vector of data from which the estimate is to be computed.</p>
</td></tr>
<tr><td><code id="density.reflected_+3A_lower">lower</code></td>
<td>
<p>the lower limit of the interval to which x is theoretically constrained, default -Inf.</p>
</td></tr>
<tr><td><code id="density.reflected_+3A_upper">upper</code></td>
<td>
<p>the upper limit of the interval to which x is theoretically constrained, default, Inf.</p>
</td></tr>
<tr><td><code id="density.reflected_+3A_weights">weights</code></td>
<td>
<p>numeric vector of non-negative observation weights, hence of same length as x.
The default NULL is equivalent to weights = rep(1/length(x), length(x)).</p>
</td></tr>
<tr><td><code id="density.reflected_+3A_...">...</code></td>
<td>
<p>further <code>density</code> arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>density.reflected</code> is called by <code>dgeometric.test</code> and computes the density
kernel estimate of a univariate random sample <code>x</code> of a random variable defined in
the interval <code>(lower,upper)</code> using the default options of <code>density</code> and reflection in the borders.
This avoids the density kernel estimate being underestimated in the proximity of <code>lower</code> or <code>upper</code>.
For unbounded variables, <code>density.reflected</code> generates the same output as <code>density</code> with its default options.</p>


<h3>Value</h3>

<p>An object of the class <code>density</code> with borders correction, whose underlying structure
is a list containing the following components.
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>the <code>n</code> coordinates of the points where the density is estimated.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the estimated density values. These will be non-negative.</p>
</td></tr>
<tr><td><code>bw</code></td>
<td>
<p>the bandwidth used.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the sample size after elimination of missing values.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call which produced the result.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>the deparsed name of the <code>x</code> argument.</p>
</td></tr>
<tr><td><code>has.na</code></td>
<td>
<p>logical, for compatibility (always <code>FALSE</code>).</p>
</td></tr>
</table>
<p>The <code>print</code> method reports <code><a href="base.html#topic+summary">summary</a></code> values on the <code>x</code> and <code>y</code> components.
</p>


<h3>Note</h3>

<p>The function is based on <code><a href="stats.html#topic+density">density</a></code>.
</p>


<h3>Author(s)</h3>

<p>Jose M. Pavia
</p>


<h3>References</h3>

<p>Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) &quot;The New S Language.&quot; Wadsworth &amp; Brooks/Cole (for S version).
</p>
<p>Scott, D. W. (1992) &quot;Multivariate Density Estimation. Theory, Practice and Visualization.&quot; New York: Wiley.
</p>
<p>Sheather, S. J. and Jones M. C. (1991) &quot;A reliable data-based bandwidth selection method for kernel density estimation.&quot; J. Roy. Statist. Soc. B, 683&ndash;690.
</p>
<p>Silverman, B. W. (1986) &quot;Density Estimation.&quot; London: Chapman and Hall.
</p>
<p>Venables, W. N. and Ripley, B. D. (2002) &quot;Modern Applied Statistics with S.&quot; New York: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dgeometric.test">dgeometric.test</a></code> and <code><a href="stats.html#topic+density">density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(234)
x &lt;- runif(2000)
dx &lt;- density.reflected(x,0,1)

## Plot of the density estimate with and without reflection
par(mfcol=c(1,2))
plot(dx, xlim=c(-0.1,1.1), ylim=c(0,1.1))
abline(h=1, col="red")

plot(density(x), xlim=c(-0.1,1.1), ylim=c(0,1.1))
abline(h=1, col="blue")
</code></pre>

<hr>
<h2 id='dgeometric.test'>
Geometric Goodness-of-fit Test
</h2><span id='topic+dgeometric.test'></span>

<h3>Description</h3>

<p>Implementation of the goodness-of-fit test based on assessing the size of the area
between the null hypothesis density function and a  kernel density estimate of a sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgeometric.test(x, fun.den, par = NULL, lower = -Inf, upper = Inf, n.sim = 101,
                bw=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dgeometric.test_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values for which the null hypothesis is tested.</p>
</td></tr>
<tr><td><code id="dgeometric.test_+3A_fun.den">fun.den</code></td>
<td>
<p>an actual density distribution function, such as <code>dnorm</code>. Only continuous
densities are valid.</p>
</td></tr>
<tr><td><code id="dgeometric.test_+3A_par">par</code></td>
<td>
<p>list of (additional) parameters of the density function under the null hypothesis, default NULL.</p>
</td></tr>
<tr><td><code id="dgeometric.test_+3A_lower">lower</code></td>
<td>
<p>lower end point of the support of the random variable defined by <code>fun.den</code>,
default -Inf.</p>
</td></tr>
<tr><td><code id="dgeometric.test_+3A_upper">upper</code></td>
<td>
<p>upper end point of the support of the random variable defined by <code>fun.den</code>,
default -Inf.</p>
</td></tr>
<tr><td><code id="dgeometric.test_+3A_n.sim">n.sim</code></td>
<td>
<p>number of iterations performed to calculate the <code>p.value</code> of the test, default <code>101</code>.</p>
</td></tr>
<tr><td><code id="dgeometric.test_+3A_bw">bw</code></td>
<td>
<p>a number indicating the bandwidth to be used in the empirical kernel estimate of the data,
default NULL. In its default option, the bandwidth varies in each simulated dataset and is the one
estimated by default by <code><a href="stats.html#topic+density">density</a></code> with a Gaussian kernel.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dgeometric.test</code> uses numerical integration and Monte Carlo simulation to implement
the test based on assessing the extend of the area between a null hypothesis density function
and a density kernel estimation. It works as follows. After computing by numerical integration the area
between the density function under the null hypothesis and its sample empirical kernel estimate obtained using
<code>density.reflected</code>, the <code>p-value</code> of the test is obtained by simulation as follows:
(i) drawing <code>n.sim</code> samples from <code>fun.den</code> with the same size <code>length(x)</code> of our actual
sample <code>x</code>; (ii) estimating the kernel density function for each of these new samples;
(iii) computing the area between the theoretical density and each of the estimates obtained in (ii);
and, (iv) calculating the p-value as the proportion of times the sample <code>n.sim</code>
areas computed in (iii) exceed the value of the area computed from the observed sample.
</p>


<h3>Value</h3>

<p>The output is an object of the class <code>htest</code> exactly like for the Kolmogorov-Smirnov
test, <code><a href="stats.html#topic+ks.test">ks.test</a></code>.
A list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the character string &quot;Geometric test&quot;.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>dgeometric.test</code> calls <code><a href="#topic+density.reflected">density.reflected</a></code> and <code><a href="#topic+area.between">area.between</a></code>
(and, in some circunstances, also <code><a href="#topic+inverse">inverse</a></code>, <code><a href="#topic+random.function">random.function</a></code> and <code><a href="#topic+support.facto">support.facto</a></code>),
which are (internal) functions of the package <code>GoFKernel</code>.
</p>


<h3>Author(s)</h3>

<p>Jose M. Pavia
</p>


<h3>References</h3>

<p>Pavia, JM (2015) &quot;Testing Goodness-of-fit with the Kernel Density Estimator: GoFKernel&quot;, Journal of Statistical Software, Code Snippets, 66(1), 1&ndash;27.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+area.between">area.between</a></code>, <code><a href="#topic+density.reflected">density.reflected</a></code>, <code><a href="#topic+inverse">inverse</a></code>
<code><a href="#topic+random.function">random.function</a></code>, <code><a href="#topic+support.facto">support.facto</a></code> and <code><a href="#topic+fan.test">fan.test</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(12)
x &lt;- rlnorm(50, meanlog=1, sdlog=1)
## test if x follows a Gamma distribution with shape .6 and rate .1
dgeometric.test(x, dgamma, par=list(shape=0.6, rate=0.1), lower=0, upper=Inf, n.sim=100)

f0 &lt;- function(x) ifelse(x&gt;=0 &amp; x&lt;=1, 2-2*x, 0)
## test if risk76.1929 follows the distribution characterized by f0
dgeometric.test(risk76.1929, f0, lower=0, upper=1, n.sim=21)

</code></pre>

<hr>
<h2 id='fan.test'>
Univariate implementation of the test of Fan (1994) in the form proposed by Li and Racine (2007).
</h2><span id='topic+fan.test'></span>

<h3>Description</h3>

<p>Given a sample of a continuous univariate random variable and a density
function <code>fun.den</code> with support in the interval (<code>lower</code>, <code>upper</code>)),
<code>fan.test</code> considers the test whose null hypothesis is that the sample has <code>fun.den</code> as density function
and the test statistic and the corresponding p-value of the test based on the integral of the squared difference between
the null hypothesis density function and a kernel smoothing approximation.
To properly run, the <code>KernSmooth</code> package needs to be
installed, as in its default option it depends on the <code>dpik</code> function to estimate the bandwidth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fan.test(x, fun.den, par = NULL, lower = -Inf, upper = Inf, kernel = "normal",
         bw=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fan.test_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values for which the null hypothesis is tested.</p>
</td></tr>
<tr><td><code id="fan.test_+3A_fun.den">fun.den</code></td>
<td>
<p>an actual density distribution function, such as <code>dnorm</code>. Only continuous
densities are valid.</p>
</td></tr>
<tr><td><code id="fan.test_+3A_par">par</code></td>
<td>
<p>list of (additional) parameters of the density function under the null hypothesis, default NULL.</p>
</td></tr>
<tr><td><code id="fan.test_+3A_lower">lower</code></td>
<td>
<p>lower end point of the support of the random variable defined by <code>fun.den</code>,
default -Inf.</p>
</td></tr>
<tr><td><code id="fan.test_+3A_upper">upper</code></td>
<td>
<p>upper end point of the support of the random variable defined by <code>fun.den</code>,
default -Inf.</p>
</td></tr>
<tr><td><code id="fan.test_+3A_kernel">kernel</code></td>
<td>
<p>a character string with the kernel to be used, either &quot;normal&quot; (a N(0,1) density),
&quot;box&quot; (a uniform in -1 to 1) or &quot;epanech&quot; (a Epanechnikov quadratic kernel), default &quot;normal&quot;.</p>
</td></tr>
<tr><td><code id="fan.test_+3A_bw">bw</code></td>
<td>
<p>a number indicating the bandwidth to be used in the empirical kernel estimate of the data,
default NULL. In its default option, the bandwidth is estimated using the <code>dpik</code> function
included in the package <code>KernSmooth</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Fan's test is based on a normal approximation of the integral of the squared difference between
the null hypothesis density function and a kernel smoothing approximation. In Li and Racine's form it is
obtained as the aggregation of (i) a sampling component, (ii) the integrate of the square of the kernel
convolution of the density null function and (iii) the sum of the convolution of the density in the sampled values,
see Li and Racine (2007, pp.380-1) for details.
</p>


<h3>Value</h3>

<p>The output is an object of the class <code>htest</code> exactly like for the Kolmogorov-Smirnov
test, <code><a href="stats.html#topic+ks.test">ks.test</a></code>.
A list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the character string &quot;Geometric test&quot;.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p><code>fan.test</code> calls the <code><a href="KernSmooth.html#topic+dpik">dpik</a></code> function of <code>KernSmooth</code></p>


<h3>Note</h3>

<p>To properly run the function requires the package <code>KernSmooth</code>
to be installed to estimate the bandwidth.
</p>


<h3>Author(s)</h3>

<p>Jose M. Pavia
</p>


<h3>References</h3>

<p>Fan, Y (1994) &quot;Testing the goodness-of-fit of a parametric density function by kernel method&quot;, Econometric Theory, 10, 316&ndash;356.
</p>
<p>Li, O. and Racine, J.F. (2007) &quot;Nonparametric Econometrics&quot;, Princeton niversity Press, New Jersey.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dgeometric.test">dgeometric.test</a></code>, <code><a href="stats.html#topic+integrate">integrate</a></code> and <code><a href="KernSmooth.html#topic+dpik">dpik</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fan.test(runif(100), dunif, lower=0, upper=1)

f0 &lt;- function(x) ifelse(x&gt;=0 &amp; x&lt;=1, 2-2*x, 0)
## testing if risk76.1929 follows the distribution characterized by f0
fan.test(risk76.1929, f0, lower=0, upper=1, kernel="epanech")

</code></pre>

<hr>
<h2 id='inverse'>Inverse CDF Function</h2><span id='topic+inverse'></span>

<h3>Description</h3>

<p>Function to calculate the inverse function of a cumulative distribution function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>inverse(f, lower = -Inf, upper = Inf)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inverse_+3A_f">f</code></td>
<td>
<p>a cdf function for which we want to obtain its inverse.</p>
</td></tr>
<tr><td><code id="inverse_+3A_lower">lower</code></td>
<td>
<p>the lower limit of <code>f</code> domain (support of the random variable), default -Inf.</p>
</td></tr>
<tr><td><code id="inverse_+3A_upper">upper</code></td>
<td>
<p>the upper limit of <code>f</code> domain (support of the random variable), default Inf.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>inverse</code> is called by <code>random.function</code> and calculates the inverse of a given
function <code>f</code>. <code>inverse</code> has been specifically designed to compute the inverse
of the cumulative distribution function of an absolutely continuous random variable, therefore
it assumes there is only a root for each value in the interval (0,1) between <code>f(lower)</code>
and <code>f(upper)</code>. It is for internal use in <code><a href="#topic+dgeometric.test">dgeometric.test</a></code>.
</p>


<h3>Value</h3>

<p>A function, the inverse function of a cumulative distribution function <code>f</code>.
</p>


<h3>Note</h3>

<p>This function uses either <code><a href="stats.html#topic+optim">optim</a></code> with default options <code>method="L-BFGS-B"</code> or <code><a href="stats.html#topic+uniroot">uniroot</a></code>
to derive the inverse function.
</p>
<p>The upper endpoint must be strictly larger than the lower endpoint.
</p>


<h3>Author(s)</h3>

<p>Jose M. Pavia
</p>


<h3>References</h3>

<p>See the references in <code><a href="stats.html#topic+optim">optim</a></code> and <code><a href="stats.html#topic+uniroot">uniroot</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dgeometric.test">dgeometric.test</a></code>, <code><a href="stats.html#topic+integrate">integrate</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="#topic+random.function">random.function</a></code>,
<code><a href="#topic+support.facto">support.facto</a></code> and <code><a href="stats.html#topic+uniroot">uniroot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) pbeta(x, shape1=2, shape2=3)
f.inv &lt;- inverse(f,lower=0,upper=1)
f.inv(.2)
</code></pre>

<hr>
<h2 id='random.function'>
Random Draw Generator
</h2><span id='topic+random.function'></span>

<h3>Description</h3>

<p>This function generates random draws of a continuous random variable
given either its density or its cumulative distribution function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random.function(n = 1, f, lower = -Inf, upper = Inf, kind = "density")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random.function_+3A_n">n</code></td>
<td>
<p>number of draws, default 1.</p>
</td></tr>
<tr><td><code id="random.function_+3A_f">f</code></td>
<td>
<p>either a density (default) or cumulative distribution function of the random variable.</p>
</td></tr>
<tr><td><code id="random.function_+3A_lower">lower</code></td>
<td>
<p>lower limit of the support of the random variable, default -Inf.</p>
</td></tr>
<tr><td><code id="random.function_+3A_upper">upper</code></td>
<td>
<p>upper limit of the support of the random variable, default Inf.</p>
</td></tr>
<tr><td><code id="random.function_+3A_kind">kind</code></td>
<td>
<p>character string with the function used to identify the distribution,
either &quot;density&quot; (default) or &quot;cumulative&quot;, as alternative.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>random.function</code> uses the method of the inverse of the cdf to generate random draws from <code>f</code>.
</p>


<h3>Value</h3>

<p>A vector of length <code>n</code> with <code>n</code> draws from a random variable with density (or
cumulative distribution) function given by <code>f</code>.
</p>


<h3>Note</h3>

<p><code>random.function</code> is called by <code>dgeometric.test</code> when the corresponding r-
function (random generator of <code>f</code>) is not available in the environment. <code>random.function</code>
generates random samples from the null hypothesis density function specified in <code>dgeometric.test</code>.
</p>


<h3>Author(s)</h3>

<p>Jose M. Pavia
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dgeometric.test">dgeometric.test</a></code>, <code><a href="stats.html#topic+integrate">integrate</a></code>, <code><a href="#topic+inverse">inverse</a></code> and <code><a href="#topic+support.facto">support.facto</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f0 &lt;- function(x) ifelse(x&gt;=0 &amp; x&lt;=1, 2-2*x, 0)
random.function(10, f0, lower=0, upper=1, kind="density")
</code></pre>

<hr>
<h2 id='risk76.1929'>
Inmigrants Exposed to Risk of Death
</h2><span id='topic+risk76.1929'></span>

<h3>Description</h3>

<p>Vector containing the time exposed to risk of death with 76 years during 2006
for the 2006 registered Spanish immigrants born in 1929.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(risk76.1929)</code></pre>


<h3>Format</h3>

<p>The format is:
num [1:362] 0.94 0.885 0.863 0.852 0.797 ...
</p>


<h3>Note</h3>

<p>Under the null hypotheses of uniform distribution of date of birth and date of
migration, this time exposed to risk is distributed as a f(x)=2-2x 0&lt;x&lt;1.
</p>


<h3>Source</h3>

<p>Own elaboration from data available in <code>www.ine.es</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(density.reflected(risk76.1929, 0, 1))
</code></pre>

<hr>
<h2 id='support.facto'>
&quot;De Facto&quot; Support
</h2><span id='topic+support.facto'></span>

<h3>Description</h3>

<p><code>support.facto</code> computes the de facto numerical limits of a density function
with theoretical infinite support. This function is an (internal) function of
the <code>GoFKernel</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>support.facto(f, lower = -Inf, upper = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="support.facto_+3A_f">f</code></td>
<td>
<p> a density function.</p>
</td></tr>
<tr><td><code id="support.facto_+3A_lower">lower</code></td>
<td>
<p> theoretical lower limit of the support of the random variable, default -Inf.</p>
</td></tr>
<tr><td><code id="support.facto_+3A_upper">upper</code></td>
<td>
<p> theoretical upper limit of the support of the random variable, default, Inf.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>support.facto</code> requires that the  two first ordinary moments of <code>f</code> exist;
otherwise, <code>support.facto</code> returns the introduced limits.
</p>


<h3>Value</h3>

<p>A two components vector with the de facto lower and upper limits of <code>f</code>.
</p>


<h3>Author(s)</h3>

<p>Jose M. Pavia
</p>


<h3>See Also</h3>

<p><code><a href="#topic+area.between">area.between</a></code>, <code><a href="#topic+dgeometric.test">dgeometric.test</a></code>, <code><a href="#topic+inverse">inverse</a></code>, <code><a href="#topic+random.function">random.function</a></code>
and <code><a href="#topic+fan.test">fan.test</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>support.facto(dnorm)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
