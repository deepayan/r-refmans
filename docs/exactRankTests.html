<!DOCTYPE html><html><head><title>Help for package exactRankTests</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {exactRankTests}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ansari.exact'><p>Ansari-Bradley Test</p></a></li>
<li><a href='#ASAT'><p> Toxicological Study on Female Wistar Rats</p></a></li>
<li><a href='#bloodp'><p> Diastolic Blood Pressure</p></a></li>
<li><a href='#cscores'><p> Computation of Scores</p></a></li>
<li><a href='#dperm'><p> Distribution of One and Two Sample Permutation Tests</p></a></li>
<li><a href='#ears'><p> Survival of Ventilating Tubes</p></a></li>
<li><a href='#glioma'><p> Malignant Glioma Pilot Study</p></a></li>
<li><a href='#globulin'><p> Differences in Globulin Fraction in Two Groups</p></a></li>
<li><a href='#irank'><p> Integer Ranks</p></a></li>
<li><a href='#lungcancer'><p> Lung Cancer Clinical Trial</p></a></li>
<li><a href='#neuropathy'><p> Acute Painful Diabetic Neuropathy</p></a></li>
<li><a href='#ocarcinoma'><p> Ovarian Carcinoma</p></a></li>
<li><a href='#perm.test'><p>One and Two Sample Permutation Test</p></a></li>
<li><a href='#rotarod'><p> Rotating Rats Data</p></a></li>
<li><a href='#sal'><p> Serum Antigen Level</p></a></li>
<li><a href='#wilcox.exact'><p>Wilcoxon Rank Sum and Signed Rank Tests</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Exact Distributions for Rank and Permutation Tests</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-25</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8-35</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes exact conditional p-values and quantiles using an
 implementation of the Shift-Algorithm by Streitberg &amp; Roehmel.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.4.0), stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>survival</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-25 10:00:51 UTC; hothorn</td>
</tr>
<tr>
<td>Author:</td>
<td>Torsten Hothorn [aut, cre],
  Kurt Hornik [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Torsten Hothorn &lt;Torsten.Hothorn@R-project.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-26 04:52:18 UTC</td>
</tr>
</table>
<hr>
<h2 id='ansari.exact'>Ansari-Bradley Test</h2><span id='topic+ansari.exact'></span><span id='topic+ansari.exact.default'></span><span id='topic+ansari.exact.formula'></span>

<h3>Description</h3>

<p>Performs the Ansari-Bradley two-sample test for a difference in scale
parameters for possibly tied observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
ansari.exact(x, y, alternative = c("two.sided", "less", "greater"),
            exact = NULL, conf.int = FALSE, conf.level = 0.95, ...)
## S3 method for class 'formula'
ansari.exact(formula, data, subset, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ansari.exact_+3A_x">x</code></td>
<td>
<p>numeric vector of data values.</p>
</td></tr>
<tr><td><code id="ansari.exact_+3A_y">y</code></td>
<td>
<p>numeric vector of data values.</p>
</td></tr>
<tr><td><code id="ansari.exact_+3A_alternative">alternative</code></td>
<td>
<p>indicates the alternative hypothesis and must be
one of <code>"two.sided"</code>, <code>"greater"</code> or <code>"less"</code>.  You
can specify just the initial letter.</p>
</td></tr>
<tr><td><code id="ansari.exact_+3A_exact">exact</code></td>
<td>
<p>a logical indicating whether an exact p-value should be
computed.</p>
</td></tr>
<tr><td><code id="ansari.exact_+3A_conf.int">conf.int</code></td>
<td>
<p>a logical,indicating whether a confidence interval
should be computed.</p>
</td></tr>
<tr><td><code id="ansari.exact_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the interval.</p>
</td></tr>
<tr><td><code id="ansari.exact_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>lhs ~ rhs</code> where <code>lhs</code>
is a numeric variable giving the data values and <code>rhs</code> a factor
with two levels giving the corresponding groups.</p>
</td></tr>
<tr><td><code id="ansari.exact_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the
model formula.</p>
</td></tr>
<tr><td><code id="ansari.exact_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used.</p>
</td></tr>
<tr><td><code id="ansari.exact_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to
<code>getOption("na.action")</code>.</p>
</td></tr>
<tr><td><code id="ansari.exact_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose that <code>x</code> and <code>y</code> are independent samples from
distributions with densities <code class="reqn">f((t-m)/s)/s</code> and <code class="reqn">f(t-m)</code>,
respectively, where <code class="reqn">m</code> is an unknown nuisance parameter and
<code class="reqn">s</code>, the ratio of scales, is the parameter of interest.  The
Ansari-Bradley test is used for testing the null that <code class="reqn">s</code> equals
1, the two-sided alternative being that <code class="reqn">s \ne 1</code> (the
distributions differ only in variance), and the one-sided alternatives
being <code class="reqn">s &gt; 1</code> (the distribution underlying <code>x</code> has a larger
variance, <code>"greater"</code>) or <code class="reqn">s &lt; 1</code> (<code>"less"</code>).
</p>
<p>By default (if <code>exact</code> is not specified), an exact p-value is
computed if both samples contain less than 50 finite values. 
Otherwise, a normal approximation is used.
</p>
<p>Optionally, a nonparametric confidence interval and an estimator for
<code class="reqn">s</code> are computed.  If exact p-values are available, an exact
confidence interval is obtained by the algorithm described in Bauer
(1972), and the Hodges-Lehmann estimator is employed.  Otherwise, the
returned confidence interval and point estimate are based on normal
approximations.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the Ansari-Bradley test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the ratio of scales <code class="reqn">s</code> under the null, 1.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative
hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the string <code>"Ansari-Bradley test"</code>.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the names of the data.</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>a confidence interval for the scale parameter.
(Only present if argument <code>conf.int = TRUE</code>.)</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>an estimate of the ratio of scales.
(Only present if argument <code>conf.int = TRUE</code>.)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>To compare results of the Ansari-Bradley test to those of the F test
to compare two variances (under the assumption of normality), observe
that <code class="reqn">s</code> is the ratio of scales and hence <code class="reqn">s^2</code> is the ratio
of variances (provided they exist), whereas for the F test the ratio
of variances itself is the parameter of interest.  In particular,
confidence intervals are for <code class="reqn">s</code> in the Ansari-Bradley test but
for <code class="reqn">s^2</code> in the F test.
</p>


<h3>References</h3>

<p>Myles Hollander &amp; Douglas A. Wolfe (1973),
<em>Nonparametric statistical inference</em>.
New York: John Wiley &amp; Sons.
Pages 83&ndash;92.
</p>
<p>David F. Bauer (1972),
Constructing confidence sets using rank statistics.
<em>Journal of the American Statistical Association</em>
<b>67</b>, 687&ndash;690.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+fligner.test">fligner.test</a></code> for a rank-based (nonparametric)
<code class="reqn">k</code>-sample test for homogeneity of variances;
<code><a href="stats.html#topic+mood.test">mood.test</a></code> for another rank-based two-sample test for a
difference in scale parameters;
<code><a href="stats.html#topic+var.test">var.test</a></code> and <code><a href="stats.html#topic+bartlett.test">bartlett.test</a></code> for parametric
tests for the homogeneity in variance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Hollander &amp; Wolfe (1973, p. 86f):
## Serum iron determination using Hyland control sera
ramsay &lt;- c(111, 107, 100, 99, 102, 106, 109, 108, 104, 99,
            101, 96, 97, 102, 107, 113, 116, 113, 110, 98)
jung.parekh &lt;- c(107, 108, 106, 98, 105, 103, 110, 105, 104,
            100, 96, 108, 103, 104, 114, 114, 113, 108, 106, 99)
ansari.test(ramsay, jung.parekh)
ansari.exact(ramsay, jung.parekh)

ansari.exact(rnorm(20), rnorm(20, 0, 2), conf.int = TRUE)
</code></pre>

<hr>
<h2 id='ASAT'> Toxicological Study on Female Wistar Rats </h2><span id='topic+ASAT'></span>

<h3>Description</h3>

<p>ASAT-Values for a new compound and a control group of 34 female Wistar
rats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ASAT)</code></pre>


<h3>Format</h3>

<p>A data frame with 34 observations on the following 2 variables.
</p>

<dl>
<dt>asat</dt><dd><p>the ASAT-values (a liver enzyme)</p>
</dd>
<dt>group</dt><dd><p>a factor with levels <code>Compound</code> and <code>Control</code>.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The aim of this toxicological study is the proof of safety for the new
compound. The data are originally given in Hothorn (1992) and reproduced in
Hauschke et al. (1999).
</p>


<h3>Source</h3>

<p>Ludwig A. Hothorn (1992), Biometrische Analyse toxikologischer Untersuchungen.
In: J. Adams (ed.): <em>Statistisches Know how in der medizinischen 
Forschung.</em> Ullstein-Mosby, Berlin, 475&ndash;590.
</p>


<h3>References</h3>

<p>Dieter Hauschke, Meinhard Kieser &amp; Ludwig A. Hothorn (1999), 
Proof of safety in
toxicology based on the ratio of two means for normally distributed data.
<em>Biometrical Journal</em>, <b>41</b>(3), 295&ndash;304.
</p>
<p>Rafael Pfl\&quot;uger &amp; Torsten Hothorn (2002),
Assessing Equivalence Tests with Respect to their Expected
$p$-Value. <em>Biometrical Journal</em>, <b>44</b>(8), 1002&ndash;1027.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(29)

data(ASAT)
# does not really look symmetric

plot(asat ~ group, data=ASAT)

# proof-of-safety based on ration of medians
pos &lt;- wilcox.exact(I(log(asat)) ~ group, data = ASAT, alternative = "less", 
             conf.int=TRUE)

# one-sided confidence set. Safety cannot be concluded since the effect of
# the compound exceeds 20% of the control median
exp(pos$conf.int)
</code></pre>

<hr>
<h2 id='bloodp'> Diastolic Blood Pressure </h2><span id='topic+bloodp'></span>

<h3>Description</h3>

<p>Diastolic blood pressure for a two groups of patients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bloodp)</code></pre>


<h3>Format</h3>

<p>A data frame with 15 observations on the following 2 variables.
</p>

<dl>
<dt>bp</dt><dd><p>the diastolic blood pressure.</p>
</dd>
<dt>group</dt><dd><p>a factor with levels <code>group1</code> and <code>group2</code>.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data is given in Table 9.6, page 227, of Metha and Pathel (2001). Note
that there are some tied observations. The permutation test using the raw
blood pressure values does not lead to a rejection of the null hypothesis of
exchangeability: p-value = 0.1040 (two-sided) and p-value = 0.0564
(one-sided). The asymptotic two-sided p-value is 0.1070.
</p>
<p>For the Wilcoxon-Mann-Whitney test,
the one-sided p-value is 0.0542 and the two-sided one is 0.0989 (Metha &amp;
Patel, 2001, page 229).
</p>
<p>The one-sided p-value for the v.d.Waeren test is 0.0462 (Metha &amp;
Patel, 2001, page 241) and the two-sided p-value is 0.0799.
</p>


<h3>References</h3>

<p>Cyrus R. Mehta &amp; Nitin R. Patel (2001),
<em>StatXact-5 for Windows.</em>
Manual, Cytel Software Cooperation, Cambridge, USA
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bloodp)

# Permutation test

perm.test(bp ~ group, data=bloodp)
perm.test(bp ~ group, data=bloodp, alternative="greater")
perm.test(bp ~ group, data=bloodp, exact=FALSE)

# Wilcoxon-Mann-Whitney test

wilcox.exact(bp ~ group, data=bloodp, conf.int=TRUE, alternative="l")
wilcox.exact(bp ~ group, data=bloodp, conf.int=TRUE)

# compute the v.d. Waerden test

sc &lt;- cscores(bloodp$bp, type="NormalQuantile")
X &lt;- sum(sc[bloodp$group == "group2"])
round(pperm(X, sc, 11), 4) 
## IGNORE_RDIFF_BEGIN
round(pperm(X, sc, 11, simulate=TRUE), 4)
round(pperm(X, sc, 11, alternative="two.sided"), 4) 
round(pperm(X, sc, 11, alternative="two.sided", simulate=TRUE), 4)
## IGNORE_RDIFF_END

# use scores mapped into integers (cf. dperm)

sc &lt;- cscores(bloodp$bp, type="NormalQuantile", int=TRUE)
X &lt;- sum(sc[bloodp$group == "group2"])
round(pperm(X, sc, 11), 4)      
round(pperm(X, sc, 11, alternative="two.sided"), 4)

</code></pre>

<hr>
<h2 id='cscores'> Computation of Scores </h2><span id='topic+cscores'></span><span id='topic+cscores.default'></span><span id='topic+cscores.Surv'></span><span id='topic+cscores.factor'></span>

<h3>Description</h3>

<p>This function can be used to compute several scores for a data vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
cscores(y, type=c("Data", "Wilcoxon", "NormalQuantile", 
        "AnsariBradley", "Median", "Savage", "ConSal"), int=FALSE,
        maxs=length(y), ... )
## S3 method for class 'factor'
cscores(y, ...)
## S3 method for class 'Surv'
cscores(y, type="LogRank", int=FALSE, maxs=nrow(y), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cscores_+3A_y">y</code></td>
<td>
<p> a numeric, factor or logical vector or an object of class
<code>Surv</code>. </p>
</td></tr>
<tr><td><code id="cscores_+3A_type">type</code></td>
<td>
<p>a character string which specifies the type of the scores to be
computed. <code>Data</code> just returns <code>y</code> if 
<code>y</code> is numeric.</p>
</td></tr>
<tr><td><code id="cscores_+3A_int">int</code></td>
<td>
<p>a logical, forcing integer valued scores. </p>
</td></tr>
<tr><td><code id="cscores_+3A_maxs">maxs</code></td>
<td>
<p>an integer defining the maximal value of the scores
if <code>int=TRUE</code>.</p>
</td></tr>
<tr><td><code id="cscores_+3A_...">...</code></td>
<td>
<p> additional arguments, not passed to anything at the moment. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will serve as the basis for a 
more general framework of rank and permutation tests in future versions of
this package. Currently, it is only used in the examples.
</p>
<p>The logrank scores are computed as given in Hothorn &amp; Lausen (2002).
</p>
<p>If integer valued scores are requested (<code>int = TRUE</code>), the
<code>scores</code> are mapped into integers by
<code>round(scores*length(scores)/max(scores))</code>. See <code><a href="#topic+dperm">dperm</a></code> for
more details.
</p>
<p><code>type</code> is self descriptive, except for <code>ConSal</code> which implements
scores suggested by Conover &amp; Salsburg (1988).
</p>


<h3>Value</h3>

<p>A vector of scores for <code>y</code> with an attribute <code>scores</code> indicating
the kind of scores used is returned.
</p>


<h3>References</h3>

<p>Torsten Hothorn &amp; Berthold Lausen (2003),
On the exact distribution of maximally selected rank statistics.
<em>Computational Statistics &amp; Data Analysis</em>, <b>43</b>(2),
121-137.
</p>
<p>William J. Conover &amp; David S. Salsburg (1988), Locally most powerful tests
for detecting treatment effects when only a subset of patients can
be expected to &quot;respond&quot; to treatment. <em>Biometrics</em>, <b>44</b>,
189-196.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- rnorm(50)
# v.d. Waerden scores
nq &lt;- cscores(y, type="Normal", int=TRUE)
# quantile for m=20 observations in the first group
qperm(0.1, nq, 20)

</code></pre>

<hr>
<h2 id='dperm'> Distribution of One and Two Sample Permutation Tests </h2><span id='topic+dperm'></span><span id='topic+pperm'></span><span id='topic+qperm'></span><span id='topic+rperm'></span>

<h3>Description</h3>

<p>Density, distribution function and quantile function 
for the distribution of one and two sample 
permutation tests using the Shift-Algorithm by
Streitberg &amp; R\&quot;ohmel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dperm(x, scores, m, paired=NULL, tol = 0.01, fact=NULL, density=FALSE,
      simulate=FALSE, B=10000)
pperm(q, scores, m, paired=NULL, tol = 0.01, fact=NULL,
      alternative=c("less", "greater", "two.sided"), pprob=FALSE,
      simulate=FALSE, B=10000)
qperm(p, scores, m, paired=NULL, tol = 0.01, fact=NULL, 
      simulate=FALSE, B=10000)
rperm(n, scores, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dperm_+3A_x">x</code>, <code id="dperm_+3A_q">q</code></td>
<td>
<p> vector of quantiles.</p>
</td></tr>
<tr><td><code id="dperm_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="dperm_+3A_scores">scores</code></td>
<td>
<p>arbitrary scores of the observations 
of the <code>x</code> (first <code>m</code> elements) and 
<code>y</code> sample. </p>
</td></tr>
<tr><td><code id="dperm_+3A_m">m</code></td>
<td>
<p>sample size of the <code>x</code> sample. If <code>m = length(x)</code>
scores of paired observations are assumed.</p>
</td></tr>
<tr><td><code id="dperm_+3A_paired">paired</code></td>
<td>
<p>logical. Indicates if paired observations are used. Needed
to discriminate between a paired problem and the distribution 
of the total sum of the scores (which has mass 1 at the 
point <code>sum(scores)</code>).</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="dperm_+3A_tol">tol</code></td>
<td>
<p>real. Real valued scores are mapped into integers by rounding
after multiplication with an appropriate factor.
Make sure that the absolute difference between the 
each possible test statistic for the original scores and the
rounded scores is less than <code>tol</code>. This might not be 
possible due to memory/time limitations, a warning is given in
this case.</p>
</td></tr> 
<tr><td><code id="dperm_+3A_fact">fact</code></td>
<td>
<p>real. If <code>fact</code> is given, real valued scores are mapped 
into integers using <code>fact</code> as factor. <code>tol</code> is 
ignored in this case.</p>
</td></tr>
<tr><td><code id="dperm_+3A_n">n</code></td>
<td>
<p>number of random observations to generate.</p>
</td></tr>
<tr><td><code id="dperm_+3A_alternative">alternative</code></td>
<td>
<p>character indicating whether the probability 
<code class="reqn">P(T \le q)</code> (<code>less</code>), 
<code class="reqn">P(T \ge q)</code> (<code>greater</code>) or a two-sided 
p-value (<code>two.sided</code>) should be computed in
<code>pperm</code>.</p>
</td></tr> 
<tr><td><code id="dperm_+3A_pprob">pprob</code></td>
<td>
<p>logical. Indicates if the probability <code class="reqn">P(T = q)</code> should
be computed additionally.</p>
</td></tr>
<tr><td><code id="dperm_+3A_density">density</code></td>
<td>
<p>logical. When  <code>x</code> is a scalar and <code>density</code> is
<code>TRUE</code>, <code>dperm</code> returns the density for all
possible statistics less or equal <code>x</code> as a data frame.</p>
</td></tr>
<tr><td><code id="dperm_+3A_simulate">simulate</code></td>
<td>
<p>logical. Use conditional Monte-Carlo to 
compute the distribution.</p>
</td></tr>
<tr><td><code id="dperm_+3A_b">B</code></td>
<td>
<p>number of Monte-Carlo replications to be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The exact distribution of the sum of the first <code>m</code> scores is
evaluated using the Shift-Algorithm by Streitberg &amp; R\&quot;ohmel under the
hypothesis of exchangeability (or, equivalent, the hypothesis that all
permutations of the scores are equally likely). The algorithm is able
to deal with tied scores, so the conditional distribution can be
evaluated. 
</p>
<p>The algorithm is defined for positive integer valued scores only. 
There are two ways dealing with real valued scores. 
First, one can try to find integer valued scores that lead to statistics 
which differ not more than <code>tol</code>
from the statistics computed for the original scores. This can be done as
follows.  
</p>
<p>Without loss of generality let <code class="reqn">a_i &gt; 0</code> denote real valued scores in
reverse ordering and
<code class="reqn">f</code> a positive factor (this is the <code>fact</code> argument). 
Let <code class="reqn">R_i = f \cdot a_i - round(f \cdot a_i)</code>.  Then 
</p>
<p style="text-align: center;"><code class="reqn"> \sum_{i=1}^m f \cdot a_i = \sum_{i=1}^m round(f \cdot a_i) - R_i. </code>
</p>

<p>Clearly, the maximum difference between <code class="reqn">1/f \sum_{i=1}^m f \cdot a_i</code> and
<code class="reqn">1/f \sum_{i=1}^n round(f \cdot a_i)</code> is given by 
<code class="reqn">|\sum_{i=1}^m R_i|</code>. Therefore one searches for <code class="reqn">f</code> with 
</p>
<p style="text-align: center;"><code class="reqn"> |\sum_{i=1}^m R_i| \le \sum_{i=1}^m |R_i| \le tol.</code>
</p>

<p>If <code class="reqn">f</code> induces more that 100.000 columns in the Shift-Algorithm by 
Streitberg  &amp; R\&quot;ohmel, <code class="reqn">f</code> is restricted to the largest integer 
that does not. 
</p>
<p>The second idea is to map the scores into integers by taking the
integer part of <code class="reqn">a_i N / \max(a_i)</code> (Hothorn &amp; Lausen, 2002). 
This induces additional ties, but the shape of the
scores is very similar. That means we do not try to approximate something
but use a different test (with integer valued scores), serving for the 
same purpose
(due to a similar shape of the scores). However, this has to be done prior
to calling <code>pperm</code> (see the examples).
</p>
<p>Exact two-sided p-values are computed as suggested in the StatXact-5 
manual, page 225, equation (9.31) and equation (8.18), p. 179 (paired case).
In detail: For the paired case the two-sided p-value is just twice the
one-sided one. For the independent sample case the two sided p-value is
defined as
</p>
<p style="text-align: center;"><code class="reqn">p_2 = P( |T - E(T)| \ge | q - E(T) |)</code>
</p>

<p>where <code class="reqn">q</code> is the quantile passed to <code>pperm</code>.
</p>


<h3>Value</h3>

<p><code>dperm</code> gives the density, <code>pperm</code> gives the distribution
function and <code>qperm</code> gives the quantile function. If <code>pprob</code> is
true, <code>pperm</code> returns a list with elements
</p>
<table>
<tr><td><code>PVALUE</code></td>
<td>
<p>the probability specified by <code>alternative</code>.</p>
</td></tr>
<tr><td><code>PPROB</code></td>
<td>
<p>the probability <code class="reqn">P(T = q)</code>.</p>
</td></tr>
</table>
<p><code>rperm</code> is a wrapper to <code><a href="base.html#topic+sample">sample</a></code>.
</p>


<h3>References</h3>

 
<p>Bernd Streitberg &amp; Joachim R\&quot;ohmel (1986),
Exact distributions for permutations and rank tests: 
An introduction to some recently published algorithms. 
<em>Statistical Software Newsletter</em> <b>12</b>(1), 10&ndash;17.
</p>
<p>Bernd Streitberg &amp; Joachim R\&quot;ohmel (1987),
Exakte Verteilungen f\&quot;ur Rang- und Randomisierungstests 
im allgemeinen $c$-Stichprobenfall.
<em>EDV in Medizin und Biologie</em> <b>18</b>(1), 12&ndash;19.
</p>
<p>Torsten Hothorn (2001),
On exact rank tests in <span class="rlang"><b>R</b></span>.
<em>R News</em> <b>1</b>(1), 11&ndash;12.
</p>
<p>Cyrus R. Mehta &amp; Nitin R. Patel (2001),
<em>StatXact-5 for Windows.</em>
Manual, Cytel Software Cooperation, Cambridge, USA
</p>
<p>Torsten Hothorn &amp; Berthold Lausen (2003),
On the exact distribution of maximally selected rank statistics.
<em>Computational Statistics &amp; Data Analysis</em>, <b>43</b>(2),
121-137.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# exact one-sided p-value of the Wilcoxon test for a tied sample

x &lt;- c(0.5, 0.5, 0.6, 0.6, 0.7, 0.8, 0.9)
y &lt;- c(0.5, 1.0, 1.2, 1.2, 1.4, 1.5, 1.9, 2.0)
r &lt;- cscores(c(x,y), type="Wilcoxon")
pperm(sum(r[seq(along=x)]), r, 7)

# Compare the exact algorithm as implemented in ctest and the
# Shift-Algorithm by Streitberg &amp; Roehmel for untied samples
 
# Wilcoxon:

n &lt;- 10
x &lt;- rnorm(n, 2)
y &lt;- rnorm(n, 3)
r &lt;- cscores(c(x,y), type="Wilcoxon")

# exact distribution using the Shift-Algorithm

dwexac &lt;- dperm((n*(n+1)/2):(n^2 + n*(n+1)/2), r, n)
sum(dwexac)           # should be something near 1 :-)

# exact distribution using dwilcox

dw &lt;- dwilcox(0:(n^2), n, n)

# compare the two distributions:

plot(dw, dwexac, main="Wilcoxon", xlab="dwilcox", ylab="dperm")      
# should give a "perfect" line

# Wilcoxon signed rank test

n &lt;- 10
x &lt;- rnorm(n, 5)
y &lt;- rnorm(n, 5)
r &lt;- cscores(abs(x - y), type="Wilcoxon")
pperm(sum(r[x - y &gt; 0]), r, length(r))
wilcox.test(x,y, paired=TRUE, alternative="less")
psignrank(sum(r[x - y &gt; 0]), length(r))

# Ansari-Bradley

n &lt;- 10
x &lt;- rnorm(n, 2, 1)
y &lt;- rnorm(n, 2, 2)

# exact distribution using the Shift-Algorithm

sc &lt;- cscores(c(x,y), type="Ansari")
dabexac &lt;- dperm(0:(n*(2*n+1)/2), sc, n)
sum(dabexac)

# real scores are allowed (but only result in an approximation)
# e.g. v.d. Waerden test

n &lt;- 10
x &lt;- rnorm(n)
y &lt;- rnorm(n)
scores &lt;- cscores(c(x,y), type="NormalQuantile")
X &lt;- sum(scores[seq(along=x)])  # &lt;- v.d. Waerden normal quantile statistic

# critical value, two-sided test

abs(qperm(0.025, scores, length(x)))

# p-values

p1 &lt;- pperm(X, scores, length(x), alternative="two.sided")

# generate integer valued scores with the same shape as normal quantile
# scores, this no longer v.d.Waerden, but something very similar

scores &lt;- cscores(c(x,y), type="NormalQuantile", int=TRUE)

X &lt;- sum(scores[seq(along=x)])
p2 &lt;- pperm(X, scores, length(x), alternative="two.sided")

# compare p1 and p2

p1 - p2

</code></pre>

<hr>
<h2 id='ears'> Survival of Ventilating Tubes </h2><span id='topic+ears'></span>

<h3>Description</h3>

<p>Survival times of ventilating tubes of left and right ears in 78 children
with otitis media.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ears)</code></pre>


<h3>Format</h3>

<p>A data frame with 78 observations on the following 5 variables.
</p>

<dl>
<dt>left</dt><dd><p>Survival time in month of tube in left ear.</p>
</dd>
<dt>lcens</dt><dd><p>Censoring indicator for left ear: <code>0</code> censored and
<code>1</code> event.</p>
</dd>
<dt>right</dt><dd><p>Survival time in month of tube in right ear.</p>
</dd>
<dt>rcens</dt><dd><p>Censoring indicator for right ear: <code>0</code> censored and
<code>1</code> event.</p>
</dd>
<dt>group</dt><dd><p>a factor with levels <code>control</code> and <code>treat</code>. </p>
</dd></dl>



<h3>Source</h3>

<p>Sin-Ho Jung and Jong-Hyeon Jeong (2003). Rank tests for clustered survival
data. <em>Lifetime Data Analysis</em>, <b>9</b>, 21-33.
</p>


<h3>References</h3>

<p>V.M. Howie and R.H. Schwarz (1983). Acute otitis media: One year in
general pediatric practice. <em>American Journal of Diseases in Children</em>,
<b>137</b>, 155-158.
</p>
<p>D.W. Teele, J.O. Klein, B. Rosner et al. (1989). Epidemiology of otitis
media during the first seven years of life in children in greater Boston.
<em>Journal of Infectious Diseases</em>, <b>160</b>, 89-94.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ears)
if (require(survival, quietly=TRUE)) {
  ls &lt;- cscores(Surv(ears$left, ears$lcens), int=TRUE)
  perm.test(ls ~ group, data=ears)
}

</code></pre>

<hr>
<h2 id='glioma'> Malignant Glioma Pilot Study</h2><span id='topic+glioma'></span>

<h3>Description</h3>

<p>A non-randomized pilot study on malignant glioma patients with 
pretargeted adjuvant radioimmunotherapy using Yttrium-90-biotin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(glioma)</code></pre>


<h3>Format</h3>

<p>A data frame with 37 observations on the following 7 variables.
</p>

<dl>
<dt>No.</dt><dd><p>patient number.</p>
</dd>
<dt>Age</dt><dd><p>patients ages in years.</p>
</dd>
<dt>Sex</dt><dd><p>a factor with levels <code>F</code>(emale) and <code>M</code>(ale). </p>
</dd>
<dt>Histology</dt><dd><p>a factor with levels <code>GBM</code> (grade IV) and 
<code>Grade3</code> (grade III)</p>
</dd>
<dt>Survival</dt><dd><p>survival times in month.</p>
</dd>
<dt>Cens</dt><dd><p>censoring indicator: <code>0</code> censored and <code>1</code> dead.</p>
</dd>
<dt>Group</dt><dd><p>a factor with levels <code>Control</code> and <code>RIT</code>.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The primary endpoint of this small pilot study is survival. 
Survival times are tied, the usual asymptotic log-rank test may be
inadequate in this setup.
Therefore, a permutation test (via Monte-Carlo sampling) was conducted in
the original paper. The data are taken from Tables 1 and 2 of Grana et al.
(2002).
</p>


<h3>Source</h3>

<p>C. Grana, M. Chinol, C. Robertson, C. Mazzetta, M. Bartolomei, C. De
Cicco, M. Fiorenza, M. Gatti, P. Caliceti &amp; G. Paganelli (2002),
Pretargeted adjuvant radioimmunotherapy with Yttrium-90-biotin in malignant
glioma patients: A pilot study. <em>British Journal of Cancer</em>,
<b>86</b>(2), 207&ndash;212.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(glioma)

if(require(survival, quietly = TRUE)) {

  par(mfrow=c(1,2))

  # Grade III glioma
  g3 &lt;- glioma[glioma$Histology == "Grade3",]

  # Plot Kaplan-Meier curves
  plot(survfit(Surv(Survival, Cens) ~ Group, data=g3), 
       main="Grade III Glioma", lty=c(2,1), 
       legend.text=c("Control", "Treated"),
       legend.bty=1, ylab="Probability", 
       xlab="Survival Time in Month")

  # log-rank test
  survdiff(Surv(Survival, Cens) ~ Group, data=g3)

  # permutation test with integer valued log-rank scores
  lsc &lt;- cscores(Surv(g3$Survival, g3$Cens), int=TRUE) 
  perm.test(lsc ~ Group, data=g3) 

  # permutation test with real valued log-rank scores
  lsc &lt;- cscores(Surv(g3$Survival, g3$Cens), int=FALSE)
  tr &lt;- (g3$Group == "RIT")
  T &lt;- sum(lsc[tr])
  pperm(T, lsc, sum(tr), alternative="tw")
  pperm(T, lsc, sum(tr), alternative="tw", simulate=TRUE)

  # Grade IV glioma
  gbm &lt;- glioma[glioma$Histology == "GBM",] 

  # Plot Kaplan-Meier curves
  plot(survfit(Surv(Survival, Cens) ~ Group, data=gbm), 
       main="Grade IV Glioma", lty=c(2,1), 
       legend.text=c("Control", "Treated"),
       legend.bty=1, legend.pos=1, ylab="Probability", 
       xlab="Survival Time in Month")
   
  # log-rank test
  survdiff(Surv(Survival, Cens) ~ Group, data=gbm)

  # permutation test with integer valued log-rank scores
  lsc &lt;- cscores(Surv(gbm$Survival, gbm$Cens), int=TRUE)
  perm.test(lsc ~ Group, data=gbm)

  # permutation test with real valued log-rank scores 
  lsc &lt;- cscores(Surv(gbm$Survival, gbm$Cens), int=FALSE) 
  tr &lt;- (gbm$Group == "RIT")
  T &lt;- sum(lsc[tr])
  pperm(T, lsc, sum(tr), alternative="tw")
  pperm(T, lsc, sum(tr), alternative="tw", simulate=TRUE)
}
</code></pre>

<hr>
<h2 id='globulin'> Differences in Globulin Fraction in Two Groups </h2><span id='topic+globulin'></span>

<h3>Description</h3>

<p>Globulin fraction of plasma (g/l) in two groups of 10 patients. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(globulin)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following variables:
</p>

<dl>
<dt>gfrac</dt><dd><p>Globulin fraction of plasma</p>
</dd>
<dt>group</dt><dd><p>a factor with levels <code>group1</code> and <code>group2</code></p>
</dd>
</dl>



<h3>Details</h3>

<p>See page 75 of Gardner &amp; Altman (1989).
</p>


<h3>Source</h3>

<p>M. J. Gardner &amp; D. G. Altman (1989), 
<em>Statistics with Confidence</em>.
Published by the British Medical Journal.
</p>


<h3>References</h3>

<p>Joachim R\&quot;ohmel (1996),
Precision intervals for estimates of the difference in success 
rates for binary  random variables based on the permutation principle.
<em>Biometrical Journal</em>, <b>38</b>(8), 977&ndash;993.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(globulin)
perm.test(gfrac ~ group, data=globulin, conf.int=TRUE)
</code></pre>

<hr>
<h2 id='irank'> Integer Ranks </h2><span id='topic+irank'></span>

<h3>Description</h3>

<p>Compute the number of elements less or equal the elements in a given vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irank(x, ox = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irank_+3A_x">x</code></td>
<td>
<p>a numeric vector. </p>
</td></tr>
<tr><td><code id="irank_+3A_ox">ox</code></td>
<td>
<p><code>order(x)</code>, optionally (for efficiency in case
<code>order(x)</code> is already known). </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of integers. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(10)
irank(x)
rank(x)
x &lt;- c(1,2,3,3,0)
irank(x)
rank(x)
</code></pre>

<hr>
<h2 id='lungcancer'> Lung Cancer Clinical Trial </h2><span id='topic+lungcancer'></span>

<h3>Description</h3>

<p>Survival times for patients suffering lung cancer for a treatment and
control group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lungcancer)</code></pre>


<h3>Format</h3>

<p>A data frame with 14 observations on the following 3 variables.
</p>

<dl>
<dt>time</dt><dd><p>survival time in days.</p>
</dd>
<dt>cens</dt><dd><p>censoring indicator: 0 censored, 1 event.</p>
</dd>
<dt>group</dt><dd><p>a factor with levels <code>control</code> and <code>newdrug</code>.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data is given in Table 9.19, page 293, of Metha and Pathel (2001). The
two-sided p-value for the log-rank test is 0.001 (page 295).
</p>


<h3>References</h3>

<p>Cyrus R. Mehta &amp; Nitin R. Patel (2001),
<em>StatXact-5 for Windows.</em>
Manual, Cytel Software Cooperation, Cambridge, USA
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lungcancer)
attach(lungcancer)

# round logrank scores
scores &lt;- cscores.Surv(cbind(time, cens))
T &lt;- sum(scores[group=="newdrug"])
mobs &lt;- sum(group=="newdrug")
(prob &lt;- pperm(T, scores, m=mobs, al="le"))
pperm(T, scores, m=mobs, al="tw")
pperm(T, scores, m=mobs, al="tw", simulate=TRUE)

# map into integers, faster
scores &lt;- cscores.Surv(cbind(time, cens), int=TRUE)
T &lt;- sum(scores[group=="newdrug"])
mobs &lt;- sum(group=="newdrug")
(prob &lt;- pperm(T, scores, m=mobs, al="le"))
pperm(T, scores, m=mobs, al="tw")
pperm(T, scores, m=mobs, al="tw", simulate=TRUE)

detach(lungcancer)

</code></pre>

<hr>
<h2 id='neuropathy'> Acute Painful Diabetic Neuropathy </h2><span id='topic+neuropathy'></span>

<h3>Description</h3>

<p>The logarithm of the ratio of pain scores at baseline and after four weeks
for a control and treatment group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(neuropathy)</code></pre>


<h3>Format</h3>

<p>A data frame with 58 observations on the following 2 variables.
</p>

<dl>
<dt>pain</dt><dd><p>Pain scores: ln(baseline/final).</p>
</dd>
<dt>group</dt><dd><p>a factor with levels <code>control</code> and <code>treat</code>.</p>
</dd> </dl>



<h3>Details</h3>

<p>Data from Table 1 of Conover &amp; Salsburg (1988).
</p>


<h3>Source</h3>

<p>William J. Conover and David S. Salsburg (1988), Locally most powerful tests
for detecting treatment effects when only a subset of patients can  
be expected to &quot;respond&quot; to treatment. <em>Biometrics</em>, <b>44</b>,
189&ndash;196.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(neuropathy)
# compare with Table 2 of Conover &amp; Salsburg (1988)
wilcox.exact(pain ~ group, data=neuropathy, alternative="less")
css &lt;- cscores(neuropathy$pain, type="ConSal")
pperm(sum(css[neuropathy$group=="control"]),css,
      m=sum(neuropathy$group=="control"))

</code></pre>

<hr>
<h2 id='ocarcinoma'> Ovarian Carcinoma </h2><span id='topic+ocarcinoma'></span>

<h3>Description</h3>

<p>Survival times of 35 women suffering ovarian carcinoma at stadium II and
IIA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ocarcinoma)</code></pre>


<h3>Format</h3>

<p>A data frame with 35 observations on the following 3 variables.
</p>

<dl>
<dt>time</dt><dd><p>time in days.</p>
</dd>
<dt>cens</dt><dd><p>censoring indicator: 0 censored, 1 event.</p>
</dd>
<dt>stadium</dt><dd><p>a factor with levels <code>II</code> and <code>IIA</code>. </p>
</dd>
</dl>



<h3>Details</h3>

<p>Data from Fleming et al. (1980, 1984), reanalysed in Schumacher and
Schulgen (2002).
</p>


<h3>Source</h3>

<p>Thomas R. Fleming, Judith R. O'Fallon, Peter C. O'Brien &amp; David 
P. Harrington (1980),
Modified Kolmogorov-Smirnov test procedures with applications to 
arbitrarily censored data. <em>Biometrics</em>, <b>36</b>, 607&ndash;625.
</p>
<p>Thomas R. Fleming, Stephanie J. Green &amp; David P. Harrington (1984),
Considerations of monitoring and evaluating treatment effects in clinical
trials. <em>Controlled Clinical Trials</em>, <b>5</b>, 55&ndash;66.
</p>


<h3>References</h3>

<p>Martin Schumacher &amp; Gabi Schulgen (2002), <em>Methodik klinischer 
Studien: methodische Grundlagen der Planung, Durchf\&quot;uhrung und
Auswertung.</em> Springer, Heidelberg.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ocarcinoma)
attach(ocarcinoma)
# compute integer valued logrank scores
logrsc &lt;- cscores.Surv(cbind(time, cens), int=TRUE)
# the test statistic
lgT &lt;- sum(logrsc[stadium == "II"])
# p-value
round(pperm(lgT, logrsc, m=sum(stadium=="II"), al="tw"), 4)

# compute logrank scores and simulate p-value
logrsc &lt;- cscores.Surv(cbind(time, cens), int=FALSE)
# the test statistic
lgT &lt;- sum(logrsc[stadium == "II"])
# p-value
round(pperm(lgT, logrsc, m=sum(stadium=="II"), al="tw", simulate=TRUE), 4)

</code></pre>

<hr>
<h2 id='perm.test'>One and Two Sample Permutation Test </h2><span id='topic+perm.test'></span><span id='topic+perm.test.default'></span><span id='topic+perm.test.formula'></span>

<h3>Description</h3>

<p>Performs the permutation test for the one and two sample problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
perm.test(x, y, paired=FALSE, alternative=c("two.sided", "less", "greater"),
          mu=0, exact=NULL, conf.int=FALSE, conf.level=0.95, tol=NULL, ...)
## S3 method for class 'formula'
perm.test(formula, data, subset, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perm.test_+3A_x">x</code></td>
<td>
<p>numeric vector of integer data values.</p>
</td></tr>
<tr><td><code id="perm.test_+3A_y">y</code></td>
<td>
<p>numeric vector of integer data values.</p>
</td></tr>
<tr><td><code id="perm.test_+3A_paired">paired</code></td>
<td>
<p>a logical indicating whether you want a paired test.</p>
</td></tr>
<tr><td><code id="perm.test_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis must be
one of <code>"two.sided"</code> (default), <code>"greater"</code> or
<code>"less"</code>.  You can specify just the initial letter.</p>
</td></tr>
<tr><td><code id="perm.test_+3A_mu">mu</code></td>
<td>
<p>a number specifying an optional location parameter.</p>
</td></tr>
<tr><td><code id="perm.test_+3A_exact">exact</code></td>
<td>
<p>a logical indicating whether an exact p-value should be
computed.</p>
</td></tr>
<tr><td><code id="perm.test_+3A_conf.int">conf.int</code></td>
<td>
<p>a logical indicating whether a confidence interval
should be computed.</p>
</td></tr>
<tr><td><code id="perm.test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the interval.</p>
</td></tr>
<tr><td><code id="perm.test_+3A_tol">tol</code></td>
<td>
<p>real. real valued scores are mapped into integers by
multiplication. Make sure that the absolute difference between
the &quot;true&quot; quantile and the approximated quantile is less
than <code>tol</code>. This might not be possible due to memory/time limitations.
See <code><a href="#topic+pperm">pperm</a></code>.</p>
</td></tr>
<tr><td><code id="perm.test_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>lhs ~ rhs</code> where <code>lhs</code>
is a numeric variable giving the data values and <code>rhs</code> a factor
with two levels giving the corresponding groups.</p>
</td></tr>
<tr><td><code id="perm.test_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the
model formula.</p>
</td></tr>
<tr><td><code id="perm.test_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used.</p>
</td></tr>
<tr><td><code id="perm.test_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to
<code>getOption("na.action")</code>.</p>
</td></tr>
<tr><td><code id="perm.test_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The permutation test is performed for integer valued observations or
scores. If real values <code>x</code> or <code>y</code> are passed to this function
the following applies: if <code>exact</code> is true (i.e. the sample size is
less than 50 observations) and <code>tol</code> is not given, the scores are
mapped into <code class="reqn">\{1,\dots,N\}</code>, see <code><a href="#topic+pperm">pperm</a></code> for the details.
Otherwise the p-values are computed using <code>tol</code>. If the sample size
exceeds $50$ observations, the usual normal approximation is used.
</p>
<p>P-values are computed according to the StatXact-manual, see
<code><a href="#topic+pperm">pperm</a></code>. 
</p>
<p>For (in principle) continuous variables the confidence sets represent the
&quot;largest shift in location being consistent with the observations&quot;. For
discrete variables with only a few categories they are hard to interpret.
In the case of binary data (e.g. success / failure) the confidence sets
can be interpreted as the differences of two success-rates covered by the
data. For a detailed description see R\&quot;ohmel (1996). 
</p>
<p>Confidence intervals are only available for independent samples. When the
sample sizes are unbalanced, <code>length(x)</code> needs to be smaller than
<code>length(y)</code>.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic with a name
describing it.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>pointprob</code></td>
<td>
<p>this gives the probability of observing the test
statistic itself.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the location parameter <code>mu</code>.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative
hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the type of test applied.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the names of the data.</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>a confidence interval for the location parameter.
(Only present if argument <code>conf.int = TRUE</code>.)</p>
</td></tr>
</table>


<h3>Note</h3>

<p> Confidence intervals may need some cpu-time ... </p>


<h3>References</h3>

 
<p>Joachim R\&quot;ohmel (1996),
Precision intervals for estimates of the difference in success
rates for binary  random variables based on the permutation principle.
<em>Biometrical Journal</em>, <b>38</b>(8), 977&ndash;993.
</p>
<p>Cyrus R. Mehta &amp; Nitin R. Patel (2001),
<em>StatXact-5 for Windows.</em>
Manual, Cytel Software Cooperation, Cambridge, USA
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example from Gardner &amp; Altman (1989), p. 30
# two treatments A and B, 1 means improvement, 0 means no improvement
# confidence sets cf. R\"ohmel (1996)

A &lt;- c(rep(1, 61), rep(0, 19))
B &lt;- c(rep(1, 45), rep(0, 35))
perm.test(A, B, conf.int=TRUE, exact=TRUE)

# one-sample AIDS data (differences only), Methta and Patel (2001),
# Table 8.1 page 181

data(sal)
attach(sal)
ppdiff &lt;- pre - post
detach(sal)

# p-values in StatXact == 0.0011 one-sided, 0.0021 two.sided, page 183

perm.test(ppdiff)
perm.test(ppdiff, alternative="less")
perm.test(ppdiff, exact=FALSE)

</code></pre>

<hr>
<h2 id='rotarod'> Rotating Rats Data</h2><span id='topic+rotarod'></span>

<h3>Description</h3>

<p>The endurance time of 24 rats in two groups in a rotating cylinder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rotarod)</code></pre>


<h3>Format</h3>

<p>A data frame with 24 observations on the following 2 variables.
</p>

<dl>
<dt>time</dt><dd><p>the endurance time</p>
</dd>
<dt>group</dt><dd><p>a factor with levels <code>control</code> and <code>treatment</code>.</p>
</dd></dl>



<h3>Details</h3>

<p>The 24 rats received a fixed oral dose of a centrally acting muscle relaxant
(treatment) or a saline solvent (control). They were placed on a rotating
cylinder and the length of time each rat remains on the cylinder is
measured, up to a maximum of 300 seconds.
The rats were randomly assigned to the control and treatment group.
</p>
<p>Note that the empirical variance in the control group is 0 and that the
group medians are identical.
</p>
<p>This dataset serves as the basis of an comparision of the results of the 
Wilcoxon-Mann-Whitney test computed by 11 statistical packages in Bergmann
et al. (2000). The exact conditional p-value is $0.0373$ (two-sided) and
$0.0186$ (one-sided). The asymptotic two-sided 
p-value (corrected for ties) is reported as $0.0147$.
</p>


<h3>Source</h3>

<p>Reinhard Bergmann, John Ludbrook &amp; Will P.J.M. Spooren (2000),
Different outcomes of the Wilcoxon-Mann-Whitney test from different 
statistics packages. <em>The American Statistician</em>, 
<b>54</b>(1), 72&ndash;77.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rotarod)
wilcox.exact(time ~ group, data=rotarod, alternative="g")
wilcox.exact(time ~ group, data=rotarod, conf.int=TRUE)
wilcox.exact(time ~ group, data=rotarod, exact=FALSE)
# the permutation test
perm.test(time ~ group, data=rotarod)
perm.test(time ~ group, data=rotarod, exact=FALSE)
</code></pre>

<hr>
<h2 id='sal'> Serum Antigen Level </h2><span id='topic+sal'></span>

<h3>Description</h3>

<p>The response of serum antigen level to AZT in 20 patients suffering AIDS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sal)</code></pre>


<h3>Format</h3>

<p>A data frame with 20 observations on the following 2 variables.
</p>

<dl>
<dt>pre</dt><dd><p>level pre treatment.</p>
</dd>
<dt>post</dt><dd><p>level post treatment.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data is given in Metha and Patel (2001), Table 8.1, page 181.
Two-sided p-value for the Wilcoxon-Signed Rank Test: 0.0021 (page 183) or
0.0038 (asymptotically).
</p>


<h3>References</h3>

<p>Cyrus R. Mehta &amp; Nitin R. Patel (2001),
<em>StatXact-5 for Windows.</em>
Manual, Cytel Software Cooperation, Cambridge, USA
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sal)
attach(sal)

wilcox.exact(pre, post, paired=TRUE, conf.int=TRUE)
wilcox.exact(pre,post, paired=TRUE, conf.int=TRUE, exact=FALSE)

detach(sal)

</code></pre>

<hr>
<h2 id='wilcox.exact'>Wilcoxon Rank Sum and Signed Rank Tests</h2><span id='topic+wilcox.exact'></span><span id='topic+wilcox.exact.default'></span><span id='topic+wilcox.exact.formula'></span>

<h3>Description</h3>

<p>Performs one and two sample Wilcoxon tests on vectors of data for possibly
tied observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
wilcox.exact(x, y = NULL, alternative = c("two.sided", "less", "greater"),
             mu = 0, paired = FALSE, exact = NULL,  
             conf.int = FALSE, conf.level = 0.95, ...)
## S3 method for class 'formula'
wilcox.exact(formula, data, subset, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wilcox.exact_+3A_x">x</code></td>
<td>
<p>numeric vector of data values.</p>
</td></tr>
<tr><td><code id="wilcox.exact_+3A_y">y</code></td>
<td>
<p>an optional numeric vector of data values.</p>
</td></tr>
<tr><td><code id="wilcox.exact_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis must be
one of <code>"two.sided"</code> (default), <code>"greater"</code> or
<code>"less"</code>.  You can specify just the initial letter.</p>
</td></tr>
<tr><td><code id="wilcox.exact_+3A_mu">mu</code></td>
<td>
<p>a number specifying an optional location parameter.</p>
</td></tr>
<tr><td><code id="wilcox.exact_+3A_paired">paired</code></td>
<td>
<p>a logical indicating whether you want a paired test.</p>
</td></tr>
<tr><td><code id="wilcox.exact_+3A_exact">exact</code></td>
<td>
<p>a logical indicating whether an exact p-value should be
computed.</p>
</td></tr>
<tr><td><code id="wilcox.exact_+3A_conf.int">conf.int</code></td>
<td>
<p>a logical indicating whether a confidence interval
should be computed.</p>
</td></tr>
<tr><td><code id="wilcox.exact_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the interval.</p>
</td></tr>
<tr><td><code id="wilcox.exact_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>lhs ~ rhs</code> where <code>lhs</code>
is a numeric variable giving the data values and <code>rhs</code> a factor
with two levels giving the corresponding groups.</p>
</td></tr>
<tr><td><code id="wilcox.exact_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the
model formula.</p>
</td></tr>
<tr><td><code id="wilcox.exact_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used.</p>
</td></tr>
<tr><td><code id="wilcox.exact_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to
<code>getOption("na.action")</code>.</p>
</td></tr>
<tr><td><code id="wilcox.exact_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This version computes exact conditional (on the data) 
p-values and quantiles using the Shift-Algorithm by Streitberg &amp; 
R\&quot;ohmel for both tied and untied samples.  
</p>
<p>If only <code>x</code> is given, or if both <code>x</code> and <code>y</code> are given
and <code>paired</code> is <code>TRUE</code>, a Wilcoxon signed rank test of the
null that the median of <code>x</code> (in the one sample case) or of
<code>x-y</code> (in the paired two sample case) equals <code>mu</code> is
performed.
</p>
<p>Otherwise, if both <code>x</code> and <code>y</code> are given and <code>paired</code>
is <code>FALSE</code>, a Wilcoxon rank sum test (equivalent to the
Mann-Whitney test) is carried out.  In this case, the null hypothesis
is that the location of the distributions of <code>x</code> and <code>y</code>
differ by <code>mu</code>.
</p>
<p>By default (if <code>exact</code> is not specified), an exact p-value is
computed if the samples contain less than 50 finite values and there
are no ties.  Otherwise, a normal approximation is used.
</p>
<p>Optionally (if argument <code>conf.int</code> is true), a nonparametric
confidence interval for the median (one-sample case) or for the
difference of the location parameters <code>x-y</code> is computed.  If
exact p-values are available, an exact confidence interval is obtained
by the algorithm described in Bauer (1972).  Otherwise, an asymptotic
confidence interval is returned.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic with a name
describing it.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>pointprob</code></td>
<td>
<p>this gives the probability of observing the test
statistic itself (called <code>point-prob</code>).</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the location parameter <code>mu</code>.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative
hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the type of test applied.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the names of the data.</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>a confidence interval for the location parameter.
(Only present if argument <code>conf.int = TRUE</code>.)</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Hodges-Lehmann estimate of the location parameter.
(Only present if argument <code>conf.int = TRUE</code>.)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Myles Hollander &amp; Douglas A. Wolfe (1973),
<em>Nonparametric statistical inference</em>.
New York: John Wiley &amp; Sons.
Pages 27&ndash;33 (one-sample), 68&ndash;75 (two-sample).
</p>
<p>David F. Bauer (1972),
Constructing confidence sets using rank statistics.
<em>Journal of the American Statistical Association</em>
<b>67</b>, 687&ndash;690.
</p>
<p>Cyrus R. Mehta &amp; Nitin R. Patel (2001),
<em>StatXact-5 for Windows.</em>
Manual, Cytel Software Cooperation, Cambridge, USA
</p>


<h3>See Also</h3>

<p><code><a href="#topic+perm.test">perm.test</a></code> for the one and two sample permutation test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## One-sample test.
## Hollander &amp; Wolfe (1973), 29f.
## Hamilton depression scale factor measurements in 9 patients with
##  mixed anxiety and depression, taken at the first (x) and second
##  (y) visit after initiation of a therapy (administration of a
##  tranquilizer).
x &lt;- c(1.83,  0.50,  1.62,  2.48, 1.68, 1.88, 1.55, 3.06, 1.30)
y &lt;- c(0.878, 0.647, 0.598, 2.05, 1.06, 1.29, 1.06, 3.14, 1.29)
wilcox.exact(x, y, paired = TRUE, alternative = "greater")
wilcox.exact(y - x, alternative = "less")    # The same.

## Two-sample test.
## Hollander &amp; Wolfe (1973), 69f.
## Permeability constants of the human chorioamnion (a placental
##  membrane) at term (x) and between 12 to 26 weeks gestational
##  age (y).  The alternative of interest is greater permeability
##  of the human chorioamnion for the term pregnancy.
x &lt;- c(0.80, 0.83, 1.89, 1.04, 1.45, 1.38, 1.91, 1.64, 0.73, 1.46)
y &lt;- c(1.15, 0.88, 0.90, 0.74, 1.21)
wilcox.exact(x, y, alternative = "g")        # greater

## Formula interface.
data(airquality)
boxplot(Ozone ~ Month, data = airquality)
wilcox.exact(Ozone ~ Month, data = airquality,
            subset = Month %in% c(5, 8))


# Hollander &amp; Wolfe, p. 39, results p. 40 and p. 53

x &lt;- c(1.83, 0.50, 1.62, 2.48, 1.68, 1.88, 1.55, 3.06, 1.30)
y &lt;- c(0.878, 0.647, 0.598, 2.05, 1.06, 1.29, 1.06, 3.14, 1.29)

wilcox.exact(y,x, paired=TRUE, conf.int=TRUE)

# Hollander &amp; Wolfe, p. 110, results p. 111 and p. 126

x &lt;- c(0.8, 0.83, 1.89, 1.04, 1.45, 1.38, 1.91, 1.64, 0.73, 1.46)
y &lt;- c(1.15, 0.88, 0.90, 0.74, 1.21)

wilcox.exact(y,x, conf.int=TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
