<!DOCTYPE html><html><head><title>Help for package W4MRUtils</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {W4MRUtils}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check_err'><p>Check Errors</p></a></li>
<li><a href='#check_one_character'><p>check_one_character</p></a></li>
<li><a href='#check_one_complex'><p>check_one_complex</p></a></li>
<li><a href='#check_one_integer'><p>check_one_integer</p></a></li>
<li><a href='#check_one_logical'><p>check_one_logical</p></a></li>
<li><a href='#check_one_numeric'><p>check_one_numeric</p></a></li>
<li><a href='#check_param_type_n_length'><p>check_param_type_n_length - to check parameters</p></a></li>
<li><a href='#check_parameter_length'><p>check_parameter_length - validate parameter's length</p></a></li>
<li><a href='#check_parameter_type'><p>check_parameter_type - validate parameter's type</p></a></li>
<li><a href='#collapse'><p>collapse - to paste strings with collapse = &quot;&quot;</p></a></li>
<li><a href='#collapse_lines'><p>collapse_lines - to paste strings with collapse = &quot;\n&quot;</p></a></li>
<li><a href='#convert_parameters'><p>Convert Parameters</p></a></li>
<li><a href='#df_force_numeric'><p>Convert data frame to numeric.</p></a></li>
<li><a href='#df_is'><p>Test type of a data frame.</p></a></li>
<li><a href='#df_read_table'><p>Data frame loading from a file.</p></a></li>
<li><a href='#get_base_dir'><p>get_base_dir - to get... the base directory</p></a></li>
<li><a href='#get_logger'><p>Instantiate a Logger</p></a></li>
<li><a href='#get_r_env'><p>get_r_env - provides env vars begining with R_*</p></a></li>
<li><a href='#import2'><p>Import two W4M tables</p></a></li>
<li><a href='#import3'><p>Import the three W4M tables</p></a></li>
<li><a href='#in_galaxy_env'><p>in_galaxy_env - check if the script has been run by galaxy</p></a></li>
<li><a href='#match2'><p>Table match check functions</p></a></li>
<li><a href='#match3'><p>match3</p></a></li>
<li><a href='#mini_tools'><p>Mini tools for Galaxy scripting</p></a></li>
<li><a href='#optparse_character'><p>optparse_character - define a command parameter as string</p></a></li>
<li><a href='#optparse_flag'><p>optparse_flag - define a command parameter as a trigger</p></a></li>
<li><a href='#optparse_integer'><p>optparse_integer - define a command parameter as an integer</p></a></li>
<li><a href='#optparse_list'><p>optparse_list - define a command parameter as a list of objects</p></a></li>
<li><a href='#optparse_numeric'><p>optparse_numeric - define a command parameter as an numeric</p></a></li>
<li><a href='#optparse_parameters'><p>optparse_parameters - parse easily the command line parameters</p></a></li>
<li><a href='#parse_args'><p>Parse Command arguments</p></a></li>
<li><a href='#printf'><p>printf - to format a string and print it</p></a></li>
<li><a href='#printfp'><p>printfp - to paste, format and print a string</p></a></li>
<li><a href='#printp'><p>printp - to format a string and print it</p></a></li>
<li><a href='#reproduce_id'><p>Reproduce ID</p></a></li>
<li><a href='#run_galaxy_function'><p>run_galaxy_function - automate running functions in galaxy</p></a></li>
<li><a href='#run_galaxy_processing'><p>run_galaxy_processing - automate running code in galaxy</p></a></li>
<li><a href='#show_galaxy_footer'><p>show_galaxy_footer - shows the footer for glaxy tools</p></a></li>
<li><a href='#show_galaxy_header'><p>show_galaxy_header - shows the header for glaxy tools</p></a></li>
<li><a href='#show_sys'><p>show_sys - prints env variables related to R</p></a></li>
<li><a href='#shy_lib'><p>Shy Lib</p></a></li>
<li><a href='#source_local'><p>source_local - source file, from absolute or relative path</p></a></li>
<li><a href='#stock_id'><p>Stock ID</p></a></li>
<li><a href='#stopaste'><p>stopaste - to paste string to a message and stop</p></a></li>
<li><a href='#stopaste0'><p>stopaste0 - to paste string to a message and stop</p></a></li>
<li><a href='#stopf'><p>stopf - to stop and format message</p></a></li>
<li><a href='#unmangle_galaxy_param'><p>unmangle_galaxy_param - revert effects of galaxy manglings.</p></a></li>
<li><a href='#unmangle_galaxy_string'><p>unmangle_galaxy_string - revert effects of galaxy mangling</p></a></li>
<li><a href='#W4MLogger'><p>The W4MLogger Class</p></a></li>
<li><a href='#W4MLogger_.message__'><p>W4MLogger_.message__</p></a></li>
<li><a href='#W4MLogger_[info,warning,error,debug,verbose]'><p>Log info/warning/error/debug/verbose messages</p></a></li>
<li><a href='#W4MLogger_add_out_paths'><p>Adds a file where logs are duplicated</p></a></li>
<li><a href='#W4MLogger_finalize'><p>W4MLogger_finalize</p></a></li>
<li><a href='#W4MLogger_set_debug'><p>W4MLogger$set_debug</p></a></li>
<li><a href='#W4MLogger_set_error'><p>W4MLogger$set_error</p></a></li>
<li><a href='#W4MLogger_set_info'><p>W4MLogger$set_info</p></a></li>
<li><a href='#W4MLogger_set_out_paths'><p>Defines in which file logs are duplicated</p></a></li>
<li><a href='#W4MLogger_set_verbose'><p>W4MLogger$set_verbose</p></a></li>
<li><a href='#W4MLogger_set_warning'><p>W4MLogger$set_warning</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Utils List for W4M - Workflow for Metabolomics</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a set of utility function to prevent the spread of
    utilities script in W4M (Workflow4Metabolomics) scripts, and centralize
    them in a single package.
    Some are meant to be replaced by real packages in a near future, like
    the parse_args() function: it is here only to prepare the ground for
    more global changes in W4M scripts and tools.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, rlang</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, DT, knitr, optparse, pkgdown, rmarkdown, testthat (&ge;
3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>dataframe_helpers.R miniTools.R RcheckLibrary.R
optparse_helper.R galaxy.R logging.R utils.R</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-08 14:31:36 UTC; lpavot</td>
</tr>
<tr>
<td>Author:</td>
<td>Lain Pavot [aut, cre],
  Melanie Petera [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lain Pavot &lt;lain.pavot@inrae.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-08 14:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='check_err'>Check Errors</h2><span id='topic+check_err'></span>

<h3>Description</h3>

<p>check_err
Generic function stop in error if problems have been encountered
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_err(err_stock)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_err_+3A_err_stock">err_stock</code></td>
<td>
<p>vector of results returned by check functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>M.Petera
</p>

<hr>
<h2 id='check_one_character'>check_one_character</h2><span id='topic+check_one_character'></span>

<h3>Description</h3>

<p>Use this function to validate parameters.
You're never assured that provided parameters from users are the right
type, or length. This may be the case with your own code as well,
if you have undetected bugs in your code.
</p>
<p>This function helps prevent unpredictable behaviour coming from
bad parameters.
</p>
<p>It checks the size of vectors, and the type of values.
If the parameter is not the good type or length, the program stops
with an explanatory error.
</p>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>See Also</h3>

<p><a href="#topic+check_parameter_type">check_parameter_type</a>,<a href="#topic+check_parameter_length">check_parameter_length</a>
</p>
<p><a href="#topic+check_one_integer">check_one_integer</a>,<a href="#topic+check_one_logical">check_one_logical</a>,<a href="#topic+check_one_numeric">check_one_numeric</a>
</p>
<p><a href="#topic+check_one_complex">check_one_complex</a>,<a href="#topic+check_one_character">check_one_character</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## here is a simple utility function we will use in this example.
## It is not important
show_last_error &lt;- function(error) {
  dump.frames()
  message(base::attr(last.dump, "error.message"))
}

## The example really starts here
## we have a simple function like this:
custom_message &lt;- function(text) {
  message(sprintf("Message: %s", text))
}

## this function needs to have a character vector as first
## parameter.
## So, to validate the parameter, we could write:
custom_message &lt;- function(text) {
  check_parameter_type(text, "character")
  message(base::sprintf("Message: %s", text))
}
tryCatch(custom_message(42), error = show_last_error)


## this function needs to have a vector of length 1.
## So, to validate the parameter, we could write:
custom_message &lt;- function(text) {
  check_parameter_type(text, "character")
  check_parameter_length(text, 1)
  message(base::sprintf("Message: %s", text))
}
tryCatch(custom_message(c("uwu", "owo")), error = show_last_error)


## Or, to be more concise:
custom_message &lt;- function(text) {
  check_param_type_n_length(text, "character", 1)
  message(base::sprintf("Message: %s", text))
}
tryCatch(custom_message(c("uwu", "owo")), error = show_last_error)
tryCatch(custom_message(42), error = show_last_error)


## Let's say the text can be 1 or more elements, and can be null.
custom_message &lt;- function(text) {
  check_param_type_n_length(
    text,
    expected_type = "character",
    or_null = TRUE,
    expected_size = 1,
    or_more = TRUE
  )
  message(paste0(base::sprintf("Message: %s", text), collapse = "\n"))
}
tryCatch(custom_message(c(42, 43)), error = show_last_error)
tryCatch(custom_message(NULL), error = show_last_error)
## no error, because or_null is TRUE
tryCatch(custom_message(character(0)), error = show_last_error)
tryCatch(custom_message(c("uwu", ":3")), error = show_last_error)
## no error, because or_more is TRUE

## With a function that has a lot of parameters, it may be usefull to
## provide the parameter's number. And, because it becomes very long
## to test all those parameters, we will use shortcuts functions
write_msg &lt;- function(
  text,
  font = "owo",
  font_size = 16,
  italic = FALSE,
  bold = FALSE
) {
  check_one_character(text, nth = "1st")
  check_one_character(font, nth = "2nd")
  check_one_numeric(font_size, nth = "3rd")
  check_one_logical(italic, nth = "before last")
  check_one_logical(bold, nth = "last")
  message(paste0(base::sprintf("Message: %s", text), collapse = "\n"))
}
tryCatch(write_msg(text = 42, "font", 16), error = show_last_error)
tryCatch(write_msg("uwu", font = 1, 16), error = show_last_error)
tryCatch(write_msg("uwu", font_size = "16"), error = show_last_error)
tryCatch(write_msg("uwu", italic = "FALSE"), error = show_last_error)
tryCatch(write_msg("uwu", bold = "FALSE"), error = show_last_error)

</code></pre>

<hr>
<h2 id='check_one_complex'>check_one_complex</h2><span id='topic+check_one_complex'></span>

<h3>Description</h3>

<p>Use this function to validate parameters.
You're never assured that provided parameters from users are the right
type, or length. This may be the case with your own code as well,
if you have undetected bugs in your code.
</p>
<p>This function helps prevent unpredictable behaviour coming from
bad parameters.
</p>
<p>It checks the size of vectors, and the type of values.
If the parameter is not the good type or length, the program stops
with an explanatory error.
</p>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>See Also</h3>

<p><a href="#topic+check_parameter_type">check_parameter_type</a>,<a href="#topic+check_parameter_length">check_parameter_length</a>
</p>
<p><a href="#topic+check_one_integer">check_one_integer</a>,<a href="#topic+check_one_logical">check_one_logical</a>,<a href="#topic+check_one_numeric">check_one_numeric</a>
</p>
<p><a href="#topic+check_one_complex">check_one_complex</a>,<a href="#topic+check_one_character">check_one_character</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## here is a simple utility function we will use in this example.
## It is not important
show_last_error &lt;- function(error) {
  dump.frames()
  message(base::attr(last.dump, "error.message"))
}

## The example really starts here
## we have a simple function like this:
custom_message &lt;- function(text) {
  message(sprintf("Message: %s", text))
}

## this function needs to have a character vector as first
## parameter.
## So, to validate the parameter, we could write:
custom_message &lt;- function(text) {
  check_parameter_type(text, "character")
  message(base::sprintf("Message: %s", text))
}
tryCatch(custom_message(42), error = show_last_error)


## this function needs to have a vector of length 1.
## So, to validate the parameter, we could write:
custom_message &lt;- function(text) {
  check_parameter_type(text, "character")
  check_parameter_length(text, 1)
  message(base::sprintf("Message: %s", text))
}
tryCatch(custom_message(c("uwu", "owo")), error = show_last_error)


## Or, to be more concise:
custom_message &lt;- function(text) {
  check_param_type_n_length(text, "character", 1)
  message(base::sprintf("Message: %s", text))
}
tryCatch(custom_message(c("uwu", "owo")), error = show_last_error)
tryCatch(custom_message(42), error = show_last_error)


## Let's say the text can be 1 or more elements, and can be null.
custom_message &lt;- function(text) {
  check_param_type_n_length(
    text,
    expected_type = "character",
    or_null = TRUE,
    expected_size = 1,
    or_more = TRUE
  )
  message(paste0(base::sprintf("Message: %s", text), collapse = "\n"))
}
tryCatch(custom_message(c(42, 43)), error = show_last_error)
tryCatch(custom_message(NULL), error = show_last_error)
## no error, because or_null is TRUE
tryCatch(custom_message(character(0)), error = show_last_error)
tryCatch(custom_message(c("uwu", ":3")), error = show_last_error)
## no error, because or_more is TRUE

## With a function that has a lot of parameters, it may be usefull to
## provide the parameter's number. And, because it becomes very long
## to test all those parameters, we will use shortcuts functions
write_msg &lt;- function(
  text,
  font = "owo",
  font_size = 16,
  italic = FALSE,
  bold = FALSE
) {
  check_one_character(text, nth = "1st")
  check_one_character(font, nth = "2nd")
  check_one_numeric(font_size, nth = "3rd")
  check_one_logical(italic, nth = "before last")
  check_one_logical(bold, nth = "last")
  message(paste0(base::sprintf("Message: %s", text), collapse = "\n"))
}
tryCatch(write_msg(text = 42, "font", 16), error = show_last_error)
tryCatch(write_msg("uwu", font = 1, 16), error = show_last_error)
tryCatch(write_msg("uwu", font_size = "16"), error = show_last_error)
tryCatch(write_msg("uwu", italic = "FALSE"), error = show_last_error)
tryCatch(write_msg("uwu", bold = "FALSE"), error = show_last_error)

</code></pre>

<hr>
<h2 id='check_one_integer'>check_one_integer</h2><span id='topic+check_one_integer'></span>

<h3>Description</h3>

<p>Use this function to validate parameters.
You're never assured that provided parameters from users are the right
type, or length. This may be the case with your own code as well,
if you have undetected bugs in your code.
</p>
<p>This function helps prevent unpredictable behaviour coming from
bad parameters.
</p>
<p>It checks the size of vectors, and the type of values.
If the parameter is not the good type or length, the program stops
with an explanatory error.
</p>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>See Also</h3>

<p><a href="#topic+check_parameter_type">check_parameter_type</a>,<a href="#topic+check_parameter_length">check_parameter_length</a>
</p>
<p><a href="#topic+check_one_integer">check_one_integer</a>,<a href="#topic+check_one_logical">check_one_logical</a>,<a href="#topic+check_one_numeric">check_one_numeric</a>
</p>
<p><a href="#topic+check_one_complex">check_one_complex</a>,<a href="#topic+check_one_character">check_one_character</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## here is a simple utility function we will use in this example.
## It is not important
show_last_error &lt;- function(error) {
  dump.frames()
  message(base::attr(last.dump, "error.message"))
}

## The example really starts here
## we have a simple function like this:
custom_message &lt;- function(text) {
  message(sprintf("Message: %s", text))
}

## this function needs to have a character vector as first
## parameter.
## So, to validate the parameter, we could write:
custom_message &lt;- function(text) {
  check_parameter_type(text, "character")
  message(base::sprintf("Message: %s", text))
}
tryCatch(custom_message(42), error = show_last_error)


## this function needs to have a vector of length 1.
## So, to validate the parameter, we could write:
custom_message &lt;- function(text) {
  check_parameter_type(text, "character")
  check_parameter_length(text, 1)
  message(base::sprintf("Message: %s", text))
}
tryCatch(custom_message(c("uwu", "owo")), error = show_last_error)


## Or, to be more concise:
custom_message &lt;- function(text) {
  check_param_type_n_length(text, "character", 1)
  message(base::sprintf("Message: %s", text))
}
tryCatch(custom_message(c("uwu", "owo")), error = show_last_error)
tryCatch(custom_message(42), error = show_last_error)


## Let's say the text can be 1 or more elements, and can be null.
custom_message &lt;- function(text) {
  check_param_type_n_length(
    text,
    expected_type = "character",
    or_null = TRUE,
    expected_size = 1,
    or_more = TRUE
  )
  message(paste0(base::sprintf("Message: %s", text), collapse = "\n"))
}
tryCatch(custom_message(c(42, 43)), error = show_last_error)
tryCatch(custom_message(NULL), error = show_last_error)
## no error, because or_null is TRUE
tryCatch(custom_message(character(0)), error = show_last_error)
tryCatch(custom_message(c("uwu", ":3")), error = show_last_error)
## no error, because or_more is TRUE

## With a function that has a lot of parameters, it may be usefull to
## provide the parameter's number. And, because it becomes very long
## to test all those parameters, we will use shortcuts functions
write_msg &lt;- function(
  text,
  font = "owo",
  font_size = 16,
  italic = FALSE,
  bold = FALSE
) {
  check_one_character(text, nth = "1st")
  check_one_character(font, nth = "2nd")
  check_one_numeric(font_size, nth = "3rd")
  check_one_logical(italic, nth = "before last")
  check_one_logical(bold, nth = "last")
  message(paste0(base::sprintf("Message: %s", text), collapse = "\n"))
}
tryCatch(write_msg(text = 42, "font", 16), error = show_last_error)
tryCatch(write_msg("uwu", font = 1, 16), error = show_last_error)
tryCatch(write_msg("uwu", font_size = "16"), error = show_last_error)
tryCatch(write_msg("uwu", italic = "FALSE"), error = show_last_error)
tryCatch(write_msg("uwu", bold = "FALSE"), error = show_last_error)

</code></pre>

<hr>
<h2 id='check_one_logical'>check_one_logical</h2><span id='topic+check_one_logical'></span>

<h3>Description</h3>

<p>Use this function to validate parameters.
You're never assured that provided parameters from users are the right
type, or length. This may be the case with your own code as well,
if you have undetected bugs in your code.
</p>
<p>This function helps prevent unpredictable behaviour coming from
bad parameters.
</p>
<p>It checks the size of vectors, and the type of values.
If the parameter is not the good type or length, the program stops
with an explanatory error.
</p>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>See Also</h3>

<p><a href="#topic+check_parameter_type">check_parameter_type</a>,<a href="#topic+check_parameter_length">check_parameter_length</a>
</p>
<p><a href="#topic+check_one_integer">check_one_integer</a>,<a href="#topic+check_one_logical">check_one_logical</a>,<a href="#topic+check_one_numeric">check_one_numeric</a>
</p>
<p><a href="#topic+check_one_complex">check_one_complex</a>,<a href="#topic+check_one_character">check_one_character</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## here is a simple utility function we will use in this example.
## It is not important
show_last_error &lt;- function(error) {
  dump.frames()
  message(base::attr(last.dump, "error.message"))
}

## The example really starts here
## we have a simple function like this:
custom_message &lt;- function(text) {
  message(sprintf("Message: %s", text))
}

## this function needs to have a character vector as first
## parameter.
## So, to validate the parameter, we could write:
custom_message &lt;- function(text) {
  check_parameter_type(text, "character")
  message(base::sprintf("Message: %s", text))
}
tryCatch(custom_message(42), error = show_last_error)


## this function needs to have a vector of length 1.
## So, to validate the parameter, we could write:
custom_message &lt;- function(text) {
  check_parameter_type(text, "character")
  check_parameter_length(text, 1)
  message(base::sprintf("Message: %s", text))
}
tryCatch(custom_message(c("uwu", "owo")), error = show_last_error)


## Or, to be more concise:
custom_message &lt;- function(text) {
  check_param_type_n_length(text, "character", 1)
  message(base::sprintf("Message: %s", text))
}
tryCatch(custom_message(c("uwu", "owo")), error = show_last_error)
tryCatch(custom_message(42), error = show_last_error)


## Let's say the text can be 1 or more elements, and can be null.
custom_message &lt;- function(text) {
  check_param_type_n_length(
    text,
    expected_type = "character",
    or_null = TRUE,
    expected_size = 1,
    or_more = TRUE
  )
  message(paste0(base::sprintf("Message: %s", text), collapse = "\n"))
}
tryCatch(custom_message(c(42, 43)), error = show_last_error)
tryCatch(custom_message(NULL), error = show_last_error)
## no error, because or_null is TRUE
tryCatch(custom_message(character(0)), error = show_last_error)
tryCatch(custom_message(c("uwu", ":3")), error = show_last_error)
## no error, because or_more is TRUE

## With a function that has a lot of parameters, it may be usefull to
## provide the parameter's number. And, because it becomes very long
## to test all those parameters, we will use shortcuts functions
write_msg &lt;- function(
  text,
  font = "owo",
  font_size = 16,
  italic = FALSE,
  bold = FALSE
) {
  check_one_character(text, nth = "1st")
  check_one_character(font, nth = "2nd")
  check_one_numeric(font_size, nth = "3rd")
  check_one_logical(italic, nth = "before last")
  check_one_logical(bold, nth = "last")
  message(paste0(base::sprintf("Message: %s", text), collapse = "\n"))
}
tryCatch(write_msg(text = 42, "font", 16), error = show_last_error)
tryCatch(write_msg("uwu", font = 1, 16), error = show_last_error)
tryCatch(write_msg("uwu", font_size = "16"), error = show_last_error)
tryCatch(write_msg("uwu", italic = "FALSE"), error = show_last_error)
tryCatch(write_msg("uwu", bold = "FALSE"), error = show_last_error)

</code></pre>

<hr>
<h2 id='check_one_numeric'>check_one_numeric</h2><span id='topic+check_one_numeric'></span>

<h3>Description</h3>

<p>Use this function to validate parameters.
You're never assured that provided parameters from users are the right
type, or length. This may be the case with your own code as well,
if you have undetected bugs in your code.
</p>
<p>This function helps prevent unpredictable behaviour coming from
bad parameters.
</p>
<p>It checks the size of vectors, and the type of values.
If the parameter is not the good type or length, the program stops
with an explanatory error.
</p>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>See Also</h3>

<p><a href="#topic+check_parameter_type">check_parameter_type</a>,<a href="#topic+check_parameter_length">check_parameter_length</a>
</p>
<p><a href="#topic+check_one_integer">check_one_integer</a>,<a href="#topic+check_one_logical">check_one_logical</a>,<a href="#topic+check_one_numeric">check_one_numeric</a>
</p>
<p><a href="#topic+check_one_complex">check_one_complex</a>,<a href="#topic+check_one_character">check_one_character</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## here is a simple utility function we will use in this example.
## It is not important
show_last_error &lt;- function(error) {
  dump.frames()
  message(base::attr(last.dump, "error.message"))
}

## The example really starts here
## we have a simple function like this:
custom_message &lt;- function(text) {
  message(sprintf("Message: %s", text))
}

## this function needs to have a character vector as first
## parameter.
## So, to validate the parameter, we could write:
custom_message &lt;- function(text) {
  check_parameter_type(text, "character")
  message(base::sprintf("Message: %s", text))
}
tryCatch(custom_message(42), error = show_last_error)


## this function needs to have a vector of length 1.
## So, to validate the parameter, we could write:
custom_message &lt;- function(text) {
  check_parameter_type(text, "character")
  check_parameter_length(text, 1)
  message(base::sprintf("Message: %s", text))
}
tryCatch(custom_message(c("uwu", "owo")), error = show_last_error)


## Or, to be more concise:
custom_message &lt;- function(text) {
  check_param_type_n_length(text, "character", 1)
  message(base::sprintf("Message: %s", text))
}
tryCatch(custom_message(c("uwu", "owo")), error = show_last_error)
tryCatch(custom_message(42), error = show_last_error)


## Let's say the text can be 1 or more elements, and can be null.
custom_message &lt;- function(text) {
  check_param_type_n_length(
    text,
    expected_type = "character",
    or_null = TRUE,
    expected_size = 1,
    or_more = TRUE
  )
  message(paste0(base::sprintf("Message: %s", text), collapse = "\n"))
}
tryCatch(custom_message(c(42, 43)), error = show_last_error)
tryCatch(custom_message(NULL), error = show_last_error)
## no error, because or_null is TRUE
tryCatch(custom_message(character(0)), error = show_last_error)
tryCatch(custom_message(c("uwu", ":3")), error = show_last_error)
## no error, because or_more is TRUE

## With a function that has a lot of parameters, it may be usefull to
## provide the parameter's number. And, because it becomes very long
## to test all those parameters, we will use shortcuts functions
write_msg &lt;- function(
  text,
  font = "owo",
  font_size = 16,
  italic = FALSE,
  bold = FALSE
) {
  check_one_character(text, nth = "1st")
  check_one_character(font, nth = "2nd")
  check_one_numeric(font_size, nth = "3rd")
  check_one_logical(italic, nth = "before last")
  check_one_logical(bold, nth = "last")
  message(paste0(base::sprintf("Message: %s", text), collapse = "\n"))
}
tryCatch(write_msg(text = 42, "font", 16), error = show_last_error)
tryCatch(write_msg("uwu", font = 1, 16), error = show_last_error)
tryCatch(write_msg("uwu", font_size = "16"), error = show_last_error)
tryCatch(write_msg("uwu", italic = "FALSE"), error = show_last_error)
tryCatch(write_msg("uwu", bold = "FALSE"), error = show_last_error)

</code></pre>

<hr>
<h2 id='check_param_type_n_length'>check_param_type_n_length - to check parameters</h2><span id='topic+check_param_type_n_length'></span>

<h3>Description</h3>

<p>Use this function to validate parameters.
You're never assured that provided parameters from users are the right
type, or length. This may be the case with your own code as well,
if you have undetected bugs in your code.
</p>
<p>This function helps prevent unpredictable behaviour coming from
bad parameters.
</p>
<p>It checks the size of vectors, and the type of values.
If the parameter is not the good type or length, the program stops
with an explanatory error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_param_type_n_length(
  value,
  expected_type,
  expected_size = 1,
  nth = NULL,
  func_name = NULL,
  param_name = NULL,
  or_more = FALSE,
  or_null = FALSE,
  nframe = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_param_type_n_length_+3A_value">value</code></td>
<td>
<p>The parameter to test.</p>
</td></tr>
<tr><td><code id="check_param_type_n_length_+3A_expected_type">expected_type</code></td>
<td>
<p>The <code>chararcter</code> vector of the
kind: <code>"character"</code>, <code>"integer"</code>, <code>"logical"</code>, ...</p>
</td></tr>
<tr><td><code id="check_param_type_n_length_+3A_expected_size">expected_size</code></td>
<td>
<p>The expected <code>size</code> of the vector.
Usualy, <code>1</code>.</p>
</td></tr>
<tr><td><code id="check_param_type_n_length_+3A_nth">nth</code></td>
<td>
<p>This parameter is used in the error message generation.
Provide a character vector like <code>"first"</code>, <code>"second"</code>,
<code>"1st"</code>, <code>"2nd"</code>, ... this must be the number of the
parameter if the function.</p>
</td></tr>
<tr><td><code id="check_param_type_n_length_+3A_func_name">func_name</code></td>
<td>
<p>By default, the function name is guessed from the
stack. But if you want to change it, or if it is not the right
function name in error messages, set the right one here.</p>
</td></tr>
<tr><td><code id="check_param_type_n_length_+3A_param_name">param_name</code></td>
<td>
<p>Like <code>func_name</code>, by default the param name is
guessed. But if you want to change it, or if it is not the right
parameter name in error messages, set the right one here.</p>
</td></tr>
<tr><td><code id="check_param_type_n_length_+3A_or_more">or_more</code></td>
<td>
<p>When we check the parameter's length, if
<code>or_more</code> is <code>TRUE</code> and the value is bigger than
<code>expected_size</code>, then, the length check does not occur</p>
</td></tr>
<tr><td><code id="check_param_type_n_length_+3A_or_null">or_null</code></td>
<td>
<p>When we check the parameter's type, if <code>or_null</code>
is <code>TRUE</code> and the value is <code>NULL</code>, then, the type check
does not occur</p>
</td></tr>
<tr><td><code id="check_param_type_n_length_+3A_nframe">nframe</code></td>
<td>
<p>The number of function calls between this function
and the function where the value to test is a parameter.
for example, if a user calls function A, which calls
check_param_* directly, then nframe must be 1 because it
is a direct call.
But, if the user has called function A, and function A calls
function B, and check_param_<em>, is called in function B,
then, for check_param_</em> to understant it is a parameter
comming from function A (and not from function B), we have to tell
check_param_* that nframe is 2.
If the function name is not the right name, it may be because of that.
So don't fear testing different values for nframes.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>See Also</h3>

<p><a href="#topic+check_parameter_type">check_parameter_type</a>,<a href="#topic+check_parameter_length">check_parameter_length</a>
</p>
<p><a href="#topic+check_one_integer">check_one_integer</a>,<a href="#topic+check_one_logical">check_one_logical</a>,<a href="#topic+check_one_numeric">check_one_numeric</a>
</p>
<p><a href="#topic+check_one_complex">check_one_complex</a>,<a href="#topic+check_one_character">check_one_character</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## here is a simple utility function we will use in this example.
## It is not important
show_last_error &lt;- function(error) {
  dump.frames()
  message(base::attr(last.dump, "error.message"))
}

## The example really starts here
## we have a simple function like this:
custom_message &lt;- function(text) {
  message(sprintf("Message: %s", text))
}

## this function needs to have a character vector as first
## parameter.
## So, to validate the parameter, we could write:
custom_message &lt;- function(text) {
  check_parameter_type(text, "character")
  message(base::sprintf("Message: %s", text))
}
tryCatch(custom_message(42), error = show_last_error)


## this function needs to have a vector of length 1.
## So, to validate the parameter, we could write:
custom_message &lt;- function(text) {
  check_parameter_type(text, "character")
  check_parameter_length(text, 1)
  message(base::sprintf("Message: %s", text))
}
tryCatch(custom_message(c("uwu", "owo")), error = show_last_error)


## Or, to be more concise:
custom_message &lt;- function(text) {
  check_param_type_n_length(text, "character", 1)
  message(base::sprintf("Message: %s", text))
}
tryCatch(custom_message(c("uwu", "owo")), error = show_last_error)
tryCatch(custom_message(42), error = show_last_error)


## Let's say the text can be 1 or more elements, and can be null.
custom_message &lt;- function(text) {
  check_param_type_n_length(
    text,
    expected_type = "character",
    or_null = TRUE,
    expected_size = 1,
    or_more = TRUE
  )
  message(paste0(base::sprintf("Message: %s", text), collapse = "\n"))
}
tryCatch(custom_message(c(42, 43)), error = show_last_error)
tryCatch(custom_message(NULL), error = show_last_error)
## no error, because or_null is TRUE
tryCatch(custom_message(character(0)), error = show_last_error)
tryCatch(custom_message(c("uwu", ":3")), error = show_last_error)
## no error, because or_more is TRUE

## With a function that has a lot of parameters, it may be usefull to
## provide the parameter's number. And, because it becomes very long
## to test all those parameters, we will use shortcuts functions
write_msg &lt;- function(
  text,
  font = "owo",
  font_size = 16,
  italic = FALSE,
  bold = FALSE
) {
  check_one_character(text, nth = "1st")
  check_one_character(font, nth = "2nd")
  check_one_numeric(font_size, nth = "3rd")
  check_one_logical(italic, nth = "before last")
  check_one_logical(bold, nth = "last")
  message(paste0(base::sprintf("Message: %s", text), collapse = "\n"))
}
tryCatch(write_msg(text = 42, "font", 16), error = show_last_error)
tryCatch(write_msg("uwu", font = 1, 16), error = show_last_error)
tryCatch(write_msg("uwu", font_size = "16"), error = show_last_error)
tryCatch(write_msg("uwu", italic = "FALSE"), error = show_last_error)
tryCatch(write_msg("uwu", bold = "FALSE"), error = show_last_error)

</code></pre>

<hr>
<h2 id='check_parameter_length'>check_parameter_length - validate parameter's length</h2><span id='topic+check_parameter_length'></span>

<h3>Description</h3>

<p>Use this function to validate parameters.
You're never assured that provided parameters from users are the right
type, or length. This may be the case with your own code as well,
if you have undetected bugs in your code.
</p>
<p>This function helps prevent unpredictable behaviour coming from
bad parameters.
</p>
<p>It checks the size of vectors, and the type of values.
If the parameter is not the good type or length, the program stops
with an explanatory error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_parameter_length(
  value,
  expected_size,
  nth = NULL,
  func_name = NULL,
  param_name = NULL,
  or_more = FALSE,
  nframe = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_parameter_length_+3A_value">value</code></td>
<td>
<p>The parameter to test.</p>
</td></tr>
<tr><td><code id="check_parameter_length_+3A_expected_size">expected_size</code></td>
<td>
<p>The expected <code>size</code> of the vector.
Usualy, <code>1</code>.</p>
</td></tr>
<tr><td><code id="check_parameter_length_+3A_nth">nth</code></td>
<td>
<p>This parameter is used in the error message generation.
Provide a character vector like <code>"first"</code>, <code>"second"</code>,
<code>"1st"</code>, <code>"2nd"</code>, ... this must be the number of the
parameter if the function.</p>
</td></tr>
<tr><td><code id="check_parameter_length_+3A_func_name">func_name</code></td>
<td>
<p>By default, the function name is guessed from the
stack. But if you want to change it, or if it is not the right
function name in error messages, set the right one here.</p>
</td></tr>
<tr><td><code id="check_parameter_length_+3A_param_name">param_name</code></td>
<td>
<p>Like <code>func_name</code>, by default the param name is
guessed. But if you want to change it, or if it is not the right
parameter name in error messages, set the right one here.</p>
</td></tr>
<tr><td><code id="check_parameter_length_+3A_or_more">or_more</code></td>
<td>
<p>When we check the parameter's length, if
<code>or_more</code> is <code>TRUE</code> and the value is bigger than
<code>expected_size</code>, then, the length check does not occur</p>
</td></tr>
<tr><td><code id="check_parameter_length_+3A_nframe">nframe</code></td>
<td>
<p>The number of function calls between this function
and the function where the value to test is a parameter.
for example, if a user calls function A, which calls
check_param_* directly, then nframe must be 1 because it
is a direct call.
But, if the user has called function A, and function A calls
function B, and check_param_<em>, is called in function B,
then, for check_param_</em> to understant it is a parameter
comming from function A (and not from function B), we have to tell
check_param_* that nframe is 2.
If the function name is not the right name, it may be because of that.
So don't fear testing different values for nframes.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>See Also</h3>

<p><a href="#topic+check_parameter_type">check_parameter_type</a>,<a href="#topic+check_parameter_length">check_parameter_length</a>
</p>
<p><a href="#topic+check_one_integer">check_one_integer</a>,<a href="#topic+check_one_logical">check_one_logical</a>,<a href="#topic+check_one_numeric">check_one_numeric</a>
</p>
<p><a href="#topic+check_one_complex">check_one_complex</a>,<a href="#topic+check_one_character">check_one_character</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## here is a simple utility function we will use in this example.
## It is not important
show_last_error &lt;- function(error) {
  dump.frames()
  message(base::attr(last.dump, "error.message"))
}

## The example really starts here
## we have a simple function like this:
custom_message &lt;- function(text) {
  message(sprintf("Message: %s", text))
}

## this function needs to have a character vector as first
## parameter.
## So, to validate the parameter, we could write:
custom_message &lt;- function(text) {
  check_parameter_type(text, "character")
  message(base::sprintf("Message: %s", text))
}
tryCatch(custom_message(42), error = show_last_error)


## this function needs to have a vector of length 1.
## So, to validate the parameter, we could write:
custom_message &lt;- function(text) {
  check_parameter_type(text, "character")
  check_parameter_length(text, 1)
  message(base::sprintf("Message: %s", text))
}
tryCatch(custom_message(c("uwu", "owo")), error = show_last_error)


## Or, to be more concise:
custom_message &lt;- function(text) {
  check_param_type_n_length(text, "character", 1)
  message(base::sprintf("Message: %s", text))
}
tryCatch(custom_message(c("uwu", "owo")), error = show_last_error)
tryCatch(custom_message(42), error = show_last_error)


## Let's say the text can be 1 or more elements, and can be null.
custom_message &lt;- function(text) {
  check_param_type_n_length(
    text,
    expected_type = "character",
    or_null = TRUE,
    expected_size = 1,
    or_more = TRUE
  )
  message(paste0(base::sprintf("Message: %s", text), collapse = "\n"))
}
tryCatch(custom_message(c(42, 43)), error = show_last_error)
tryCatch(custom_message(NULL), error = show_last_error)
## no error, because or_null is TRUE
tryCatch(custom_message(character(0)), error = show_last_error)
tryCatch(custom_message(c("uwu", ":3")), error = show_last_error)
## no error, because or_more is TRUE

## With a function that has a lot of parameters, it may be usefull to
## provide the parameter's number. And, because it becomes very long
## to test all those parameters, we will use shortcuts functions
write_msg &lt;- function(
  text,
  font = "owo",
  font_size = 16,
  italic = FALSE,
  bold = FALSE
) {
  check_one_character(text, nth = "1st")
  check_one_character(font, nth = "2nd")
  check_one_numeric(font_size, nth = "3rd")
  check_one_logical(italic, nth = "before last")
  check_one_logical(bold, nth = "last")
  message(paste0(base::sprintf("Message: %s", text), collapse = "\n"))
}
tryCatch(write_msg(text = 42, "font", 16), error = show_last_error)
tryCatch(write_msg("uwu", font = 1, 16), error = show_last_error)
tryCatch(write_msg("uwu", font_size = "16"), error = show_last_error)
tryCatch(write_msg("uwu", italic = "FALSE"), error = show_last_error)
tryCatch(write_msg("uwu", bold = "FALSE"), error = show_last_error)

</code></pre>

<hr>
<h2 id='check_parameter_type'>check_parameter_type - validate parameter's type</h2><span id='topic+check_parameter_type'></span>

<h3>Description</h3>

<p>Use this function to validate parameters.
You're never assured that provided parameters from users are the right
type, or length. This may be the case with your own code as well,
if you have undetected bugs in your code.
</p>
<p>This function helps prevent unpredictable behaviour coming from
bad parameters.
</p>
<p>It checks the size of vectors, and the type of values.
If the parameter is not the good type or length, the program stops
with an explanatory error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_parameter_type(
  value,
  expected_type,
  nth = NULL,
  func_name = NULL,
  param_name = NULL,
  or_null = FALSE,
  nframe = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_parameter_type_+3A_value">value</code></td>
<td>
<p>The parameter to test.</p>
</td></tr>
<tr><td><code id="check_parameter_type_+3A_expected_type">expected_type</code></td>
<td>
<p>The <code>chararcter</code> vector of the
kind: <code>"character"</code>, <code>"integer"</code>, <code>"logical"</code>, ...</p>
</td></tr>
<tr><td><code id="check_parameter_type_+3A_nth">nth</code></td>
<td>
<p>This parameter is used in the error message generation.
Provide a character vector like <code>"first"</code>, <code>"second"</code>,
<code>"1st"</code>, <code>"2nd"</code>, ... this must be the number of the
parameter if the function.</p>
</td></tr>
<tr><td><code id="check_parameter_type_+3A_func_name">func_name</code></td>
<td>
<p>By default, the function name is guessed from the
stack. But if you want to change it, or if it is not the right
function name in error messages, set the right one here.</p>
</td></tr>
<tr><td><code id="check_parameter_type_+3A_param_name">param_name</code></td>
<td>
<p>Like <code>func_name</code>, by default the param name is
guessed. But if you want to change it, or if it is not the right
parameter name in error messages, set the right one here.</p>
</td></tr>
<tr><td><code id="check_parameter_type_+3A_or_null">or_null</code></td>
<td>
<p>When we check the parameter's type, if <code>or_null</code>
is <code>TRUE</code> and the value is <code>NULL</code>, then, the type check
does not occur</p>
</td></tr>
<tr><td><code id="check_parameter_type_+3A_nframe">nframe</code></td>
<td>
<p>The number of function calls between this function
and the function where the value to test is a parameter.
for example, if a user calls function A, which calls
check_param_* directly, then nframe must be 1 because it
is a direct call.
But, if the user has called function A, and function A calls
function B, and check_param_<em>, is called in function B,
then, for check_param_</em> to understant it is a parameter
comming from function A (and not from function B), we have to tell
check_param_* that nframe is 2.
If the function name is not the right name, it may be because of that.
So don't fear testing different values for nframes.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>See Also</h3>

<p><a href="#topic+check_parameter_type">check_parameter_type</a>,<a href="#topic+check_parameter_length">check_parameter_length</a>
</p>
<p><a href="#topic+check_one_integer">check_one_integer</a>,<a href="#topic+check_one_logical">check_one_logical</a>,<a href="#topic+check_one_numeric">check_one_numeric</a>
</p>
<p><a href="#topic+check_one_complex">check_one_complex</a>,<a href="#topic+check_one_character">check_one_character</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## here is a simple utility function we will use in this example.
## It is not important
show_last_error &lt;- function(error) {
  dump.frames()
  message(base::attr(last.dump, "error.message"))
}

## The example really starts here
## we have a simple function like this:
custom_message &lt;- function(text) {
  message(sprintf("Message: %s", text))
}

## this function needs to have a character vector as first
## parameter.
## So, to validate the parameter, we could write:
custom_message &lt;- function(text) {
  check_parameter_type(text, "character")
  message(base::sprintf("Message: %s", text))
}
tryCatch(custom_message(42), error = show_last_error)


## this function needs to have a vector of length 1.
## So, to validate the parameter, we could write:
custom_message &lt;- function(text) {
  check_parameter_type(text, "character")
  check_parameter_length(text, 1)
  message(base::sprintf("Message: %s", text))
}
tryCatch(custom_message(c("uwu", "owo")), error = show_last_error)


## Or, to be more concise:
custom_message &lt;- function(text) {
  check_param_type_n_length(text, "character", 1)
  message(base::sprintf("Message: %s", text))
}
tryCatch(custom_message(c("uwu", "owo")), error = show_last_error)
tryCatch(custom_message(42), error = show_last_error)


## Let's say the text can be 1 or more elements, and can be null.
custom_message &lt;- function(text) {
  check_param_type_n_length(
    text,
    expected_type = "character",
    or_null = TRUE,
    expected_size = 1,
    or_more = TRUE
  )
  message(paste0(base::sprintf("Message: %s", text), collapse = "\n"))
}
tryCatch(custom_message(c(42, 43)), error = show_last_error)
tryCatch(custom_message(NULL), error = show_last_error)
## no error, because or_null is TRUE
tryCatch(custom_message(character(0)), error = show_last_error)
tryCatch(custom_message(c("uwu", ":3")), error = show_last_error)
## no error, because or_more is TRUE

## With a function that has a lot of parameters, it may be usefull to
## provide the parameter's number. And, because it becomes very long
## to test all those parameters, we will use shortcuts functions
write_msg &lt;- function(
  text,
  font = "owo",
  font_size = 16,
  italic = FALSE,
  bold = FALSE
) {
  check_one_character(text, nth = "1st")
  check_one_character(font, nth = "2nd")
  check_one_numeric(font_size, nth = "3rd")
  check_one_logical(italic, nth = "before last")
  check_one_logical(bold, nth = "last")
  message(paste0(base::sprintf("Message: %s", text), collapse = "\n"))
}
tryCatch(write_msg(text = 42, "font", 16), error = show_last_error)
tryCatch(write_msg("uwu", font = 1, 16), error = show_last_error)
tryCatch(write_msg("uwu", font_size = "16"), error = show_last_error)
tryCatch(write_msg("uwu", italic = "FALSE"), error = show_last_error)
tryCatch(write_msg("uwu", bold = "FALSE"), error = show_last_error)

</code></pre>

<hr>
<h2 id='collapse'>collapse - to paste strings with collapse = &quot;&quot;</h2><span id='topic+collapse'></span>

<h3>Description</h3>

<p>collapse does exactly when paste does, but default collapse = &quot;&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse(..., sep = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="base.html#topic+paste">base::paste0()</a></code></p>
</td></tr>
<tr><td><code id="collapse_+3A_sep">sep</code></td>
<td>
<p>set the separator. Deafult is &quot;&quot;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
collapse(list("a message ", "in multiple", "parts"))

</code></pre>

<hr>
<h2 id='collapse_lines'>collapse_lines - to paste strings with collapse = &quot;\n&quot;</h2><span id='topic+collapse_lines'></span>

<h3>Description</h3>

<p>collapse_lines() does exactly when paste does, but default collapse = &quot;\n&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_lines(..., sep = "\n")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse_lines_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="base.html#topic+paste">base::paste0()</a></code></p>
</td></tr>
<tr><td><code id="collapse_lines_+3A_sep">sep</code></td>
<td>
<p>set the separator. Deafult is &quot;\n&quot;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
collapse_lines(list("a message ", "in multiple", "parts"))

</code></pre>

<hr>
<h2 id='convert_parameters'>Convert Parameters</h2><span id='topic+convert_parameters'></span>

<h3>Description</h3>

<p>convert_parameters
Applies a list of converters to each values on a list.
If a value is modified during the conversion (successfull conversion)
then, no further convert will be applied to this value, so values are
only converted once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_parameters(args, converters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_parameters_+3A_args">args</code></td>
<td>
<p>a named list, which values will be converted.</p>
</td></tr>
<tr><td><code id="convert_parameters_+3A_converters">converters</code></td>
<td>
<p>a vector of function. Each function will be applied to
each values with the exception of values already converted by a
previous converter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named <code>list</code> object with values converted by converters.
</p>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>boolean_converter &lt;- function(x) {
  return(if (x == "TRUE") TRUE else if (x == "FALSE") FALSE else x)
}
parameters &lt;- W4MRUtils::convert_parameters(
  list("x" = "TRUE"),
  c(boolean_converter)
)
print(parameters$`some-parameter`)
## "TRUE" has becomes TRUE.

</code></pre>

<hr>
<h2 id='df_force_numeric'>Convert data frame to numeric.</h2><span id='topic+df_force_numeric'></span>

<h3>Description</h3>

<p>df_force_numeric
Converts integer columns of a data frame into numeric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_force_numeric(df, cols = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df_force_numeric_+3A_df">df</code></td>
<td>
<p>The data frame.</p>
</td></tr>
<tr><td><code id="df_force_numeric_+3A_cols">cols</code></td>
<td>
<p>The set of columns to convert to numeric.
By default (when set to <code>NULL</code>) all integer columns are converted.
Set it to a character vector containing the names of the columns you
want to convert, or ton integer vector containing the indices of the
columns. Can be used to force conversion of non integer columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The converted <code>data.frame</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert an integer data frame
df &lt;- data.frame(a = as.integer(c(1, 4)), b = as.integer(c(6, 5)))
df &lt;- W4MRUtils::df_force_numeric(df)

</code></pre>

<hr>
<h2 id='df_is'>Test type of a data frame.</h2><span id='topic+df_is'></span>

<h3>Description</h3>

<p>df_is
This function tests if the columns of a data frame are all of the same type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_is(df, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df_is_+3A_df">df</code></td>
<td>
<p>The data frame.</p>
</td></tr>
<tr><td><code id="df_is_+3A_type">type</code></td>
<td>
<p>The type you expect the columns to have.
It must be one of the R base types:
- 'character' ;
- 'factor' ;
- 'integer' ;
- 'numeric' ;
- 'logical'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Test if a data frame contains only integers
df &lt;- data.frame(a = c(1, 4), b = c(6, 5))
# should return FALSE since in R all integers are converted to
# numeric by default.
W4MRUtils::df_is(df, "integer")
# should return TRUE.
W4MRUtils::df_is(df, "numeric")

</code></pre>

<hr>
<h2 id='df_read_table'>Data frame loading from a file.</h2><span id='topic+df_read_table'></span>

<h3>Description</h3>

<p>df_read_table
Reads a data frame from a file and possibly convert integer columns to
numeric. This function calls the built-in <code>read.table()</code> method and
then <code>W4MRUtils::df_force_numeric()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_read_table(file, force_numeric = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df_read_table_+3A_file">file</code></td>
<td>
<p>The path to the file you want to load. See
<code>read.table()</code> documentation for more information.</p>
</td></tr>
<tr><td><code id="df_read_table_+3A_force_numeric">force_numeric</code></td>
<td>
<p>If set to TRUE, all integer columns will be
converted to numeric.</p>
</td></tr>
<tr><td><code id="df_read_table_+3A_...">...</code></td>
<td>
<p>Parameter to transmit to the read.table function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The loaded data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load a data frame from a file and convert integer columns
file_path &lt;- system.file(
  "extdata",
  "example_df_read_table.csv",
  package="W4MRUtils"
)
str(W4MRUtils::df_read_table(
  file_path,
  sep = ",",
  force_numeric = TRUE,
  header=TRUE
))

</code></pre>

<hr>
<h2 id='get_base_dir'>get_base_dir - to get... the base directory</h2><span id='topic+get_base_dir'></span>

<h3>Description</h3>

<p>get_base_dir
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_base_dir()
</code></pre>


<h3>Value</h3>

<p>the directory path of the main script. PWD otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(get_base_dir())

</code></pre>

<hr>
<h2 id='get_logger'>Instantiate a Logger</h2><span id='topic+get_logger'></span>

<h3>Description</h3>

<p>Create a logger of the given name. You can call again <code>get_logger</code> and
provide the same name to get the same logger. It will not be recreated
unless recreate is TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_logger(name, recreate = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_logger_+3A_name">name</code></td>
<td>
<p>the name of the logger to get or create. This name will
be used in logs to differentiate from which part of you program
comes which lines of log. See the example of usage bellow.</p>
</td></tr>
<tr><td><code id="get_logger_+3A_recreate">recreate</code></td>
<td>
<p>logical=FALSE tells whether to recreate the logger
of the given name or not. Preferably, one should not recreate
a new logger each time.</p>
</td></tr>
<tr><td><code id="get_logger_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+W4MLogger">W4MLogger</a></code>
</p>

<dl>
<dt></dt><dd></dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>get_logger
</p>


<h3>Value</h3>

<p>A new W4MLogger instance if it did not exist or if recreate is
TRUE. Otherwise, a new W4MLogger instance.
</p>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## let's say our program is divided in three big tasks:
##   - the parsing
##   - the processing
##   - the output writing
parser_logger &lt;- W4MRUtils::get_logger("Parser")
process_logger &lt;- W4MRUtils::get_logger("Processing")
write_logger &lt;- W4MRUtils::get_logger("Writer")
input_path &lt;- "/home/anyone/input.csv"
parser_logger$info(paste("Parsing the input file at", input_path))
parser_logger$debug("Input extension detected: csv")
parser_logger$debug("The csv parser program will be used")
## do the parsing...
input &lt;- list(a=1:5, b=5:10, c=8:2)
parser_logger$info("Parsing succeed")
process_logger$info("Starting the processing of:", input)
process_logger$debug("The processing has started at...")
result &lt;- as.list(input)
process_logger$debug("The processing has finished at...")
process_logger$info("Processing finished in x seconds.")
outfile &lt;- "/home/anyone/output.tsv"
write_logger$info(paste("Creating the output in", outfile))

## we detected that the input was csv and the out was tsv:
## but it is not a blocking problem
write_logger$warning("The input and output file's extensions are different")
write_logger$debug("The output will be casted from csv to tsv")

## we try to write the file, but it fails
tryCatch({
  ## writing the output file failed with this error:
  stop(sprintf("I/O Error: %s is not writable.", outfile))
}, error = function(e) {
  write_logger$error(e$message)
  write_logger$error("Writing output file aborted.")
  ## quit(save = "no", status = 42)
})

## note that debug output were not written. To show debug logs
## we have to active it (disabled by default):

write_logger$set_debug()
write_logger$debug("The debug outputs are now visible!")

</code></pre>

<hr>
<h2 id='get_r_env'>get_r_env - provides env vars begining with R_*</h2><span id='topic+get_r_env'></span>

<h3>Description</h3>

<p>Returns a list of env vars if the start with R_*.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_r_env()
</code></pre>


<h3>Value</h3>

<p>a <code>list</code> of environment variables which
begin by <code>R_</code>.
</p>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>See Also</h3>

<p><a href="#topic+run_galaxy_processing">run_galaxy_processing</a>
</p>

<hr>
<h2 id='import2'>Import two W4M tables</h2><span id='topic+import2'></span>

<h3>Description</h3>

<p>import2
Function to import a metadata table file and its corresponding
dataMatrix file.
import2 performs checks to ensure the identifiers match between
the two tables and stops with an explicit error message in case
identifiers do not match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import2(pathDM, pathMeta, typeMeta, disable_comm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import2_+3A_pathdm">pathDM</code></td>
<td>
<p>a path to a file corresponding to the dataMatrix</p>
</td></tr>
<tr><td><code id="import2_+3A_pathmeta">pathMeta</code></td>
<td>
<p>a path to a file corresponding to the metadata table</p>
</td></tr>
<tr><td><code id="import2_+3A_typemeta">typeMeta</code></td>
<td>
<p>&quot;sample&quot; or &quot;variable&quot; depending on the metadata content</p>
</td></tr>
<tr><td><code id="import2_+3A_disable_comm">disable_comm</code></td>
<td>
<p>a <code>boolean</code> with default to <code>TRUE</code> to indicate
whether the comment character <code>#</code> should be disabled as a comment tag
for the import of the metadata file; when <code>TRUE</code>, <code>#</code> in the
metadata table's columns will be considered as any other character.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> containing two elements:
</p>

<ul>
<li><p> dataMatrix a <code>data.frame</code> corresponding to the imported dataMatrix table;
</p>
</li>
<li><p> metadata a <code>data.frame</code> corresponding to the imported metadata table
</p>
</li></ul>



<h3>Author(s)</h3>

<p>M.Petera
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

dm_path &lt;- system.file(
  "extdata",
  "mini_datamatrix.txt",
  package="W4MRUtils"
)
meta_path &lt;- system.file(
  "extdata",
  "mini_variablemetadata.txt",
  package="W4MRUtils"
)

## import considering # is not a comment character
A &lt;- W4MRUtils::import2(dm_path, meta_path, "variable")
print(A$dataMatrix[1:5, 1:5])
print(A$metadata[1:5, ])

## import considering # is a comment character
B &lt;- W4MRUtils::import2(dm_path, meta_path, "variable", disable_comm = FALSE)
print(B$dataMatrix[1:5, 1:5])
print(B$metadata[1:5, ])


</code></pre>

<hr>
<h2 id='import3'>Import the three W4M tables</h2><span id='topic+import3'></span>

<h3>Description</h3>

<p>import3
Function to import the three W4M tables from files
(dataMatrix, sampleMetadata, variableMetadata)
import3 performs checks to ensure the identifiers match between
the three tables and stops with an explicit error message in case
identifiers do not match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import3(pathDM, pathSM, pathVM, disable_comm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import3_+3A_pathdm">pathDM</code></td>
<td>
<p>a path to a file corresponding to the dataMatrix</p>
</td></tr>
<tr><td><code id="import3_+3A_pathsm">pathSM</code></td>
<td>
<p>a path to a file corresponding to the sampleMetadata</p>
</td></tr>
<tr><td><code id="import3_+3A_pathvm">pathVM</code></td>
<td>
<p>a path to a file corresponding to the variableMetadata</p>
</td></tr>
<tr><td><code id="import3_+3A_disable_comm">disable_comm</code></td>
<td>
<p>a <code>boolean</code> with default to <code>TRUE</code> to indicate
whether the comment character <code>#</code> should be disabled as a comment tag
for the import of the metadata files; when <code>TRUE</code>, <code>#</code> in the
metadata table's columns will be considered as any other character.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> containing three elements:
</p>

<ul>
<li><p> dataMatrix a <code>data.frame</code> corresponding to the imported dataMatrix table;
</p>
</li>
<li><p> sampleMetadata a <code>data.frame</code> corresponding to the imported sampleMetadata table;
</p>
</li>
<li><p> variableMetadata a <code>data.frame</code> corresponding to the imported variableMetadata table
</p>
</li></ul>



<h3>Author(s)</h3>

<p>M.Petera
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

dm_path &lt;- system.file(
  "extdata",
  "mini_datamatrix.txt",
  package="W4MRUtils"
)
vm_path &lt;- system.file(
  "extdata",
  "mini_variablemetadata.txt",
  package="W4MRUtils"
)
sm_path &lt;- system.file(
  "extdata",
  "mini_samplemetadata.txt",
  package="W4MRUtils"
)

## import considering # is not a comment character
A &lt;- W4MRUtils::import3(dm_path, sm_path, vm_path)
print(A$dataMatrix[1:5, 1:5])
print(A$sampleMetadata[1:5, ])
print(A$variableMetadata[1:5, ])

## import considering # is a comment character
B &lt;- W4MRUtils::import3(dm_path, sm_path, vm_path, disable_comm = FALSE)
print(B$dataMatrix[1:5, 1:5])
print(B$sampleMetadata[1:5, ])
print(B$variableMetadata[1:5, ])


</code></pre>

<hr>
<h2 id='in_galaxy_env'>in_galaxy_env - check if the script has been run by galaxy</h2><span id='topic+in_galaxy_env'></span>

<h3>Description</h3>

<p><code>in_galaxy_env</code> returns <code>TRUE</code> if it detects some
galaxy-specific environment variables. <code>FALSE</code> otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in_galaxy_env()
</code></pre>


<h3>Value</h3>

<p>A logical - whether the script has been run by galaxy or not.
</p>

<hr>
<h2 id='match2'>Table match check functions</h2><span id='topic+match2'></span>

<h3>Description</h3>

<p>match2
To check if data_matrix and (variable or sample)metadata match regarding
identifiers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match2(data_matrix, metadata, metadata_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match2_+3A_data_matrix">data_matrix</code></td>
<td>
<p>data.frame containing data_matrix</p>
</td></tr>
<tr><td><code id="match2_+3A_metadata">metadata</code></td>
<td>
<p>data.frame containing sample_metadata or variable_metadata</p>
</td></tr>
<tr><td><code id="match2_+3A_metadata_type">metadata_type</code></td>
<td>
<p>&quot;sample&quot; or &quot;variable&quot; depending on metadata content</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>character</code> vector a list of errors encountered
</p>


<h3>Author(s)</h3>

<p>M.Petera
</p>

<hr>
<h2 id='match3'>match3</h2><span id='topic+match3'></span>

<h3>Description</h3>

<p>match3
To check if the 3 standard tables match regarding identifiers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match3(data_matrix, sample_metadata, variable_metadata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match3_+3A_data_matrix">data_matrix</code></td>
<td>
<p>data.frame containing data_matrix</p>
</td></tr>
<tr><td><code id="match3_+3A_sample_metadata">sample_metadata</code></td>
<td>
<p>data.frame containing sample_metadata</p>
</td></tr>
<tr><td><code id="match3_+3A_variable_metadata">variable_metadata</code></td>
<td>
<p>data.frame containing variable_metadata</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>character</code> vector a list of errors encountered
</p>


<h3>Author(s)</h3>

<p>M.Petera
</p>

<hr>
<h2 id='mini_tools'>Mini tools for Galaxy scripting</h2><span id='topic+mini_tools'></span>

<h3>Description</h3>

<p>Mini tools for Galaxy scripting
Mini tools for Galaxy scripting
Coded by: M.Petera,
</p>
<p>R functions to use in R scripts and wrappers
to make things easier (lightening code, reducing verbose...)
</p>
<p>V0: script structure + first functions
V1: addition of functions to handle special characters in identifiers
</p>

<hr>
<h2 id='optparse_character'>optparse_character - define a command parameter as string</h2><span id='topic+optparse_character'></span>

<h3>Description</h3>

<p>To be used with <code>optparse_parameters</code>. This function tells
the provided parameter is to be parsed as a single string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optparse_character(help = "No documentation yet.", short = NULL, default = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optparse_character_+3A_help">help</code></td>
<td>

<ul>
<li><p> The help string to display when &ndash;help is triggered
</p>
</li></ul>
</td></tr>
<tr><td><code id="optparse_character_+3A_short">short</code></td>
<td>

<ul>
<li><p> The shortcut fir this parameter. For example
for a &ndash;output param, we could use
<code>optparse_flag(short = "-o", ...)</code> to set the &quot;-o&quot; shortcut.
</p>
</li></ul>
</td></tr>
<tr><td><code id="optparse_character_+3A_default">default</code></td>
<td>

<ul>
<li><p> The default value this parameter will hold.
</p>
</li></ul>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optparse_parameters">optparse_parameters()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
str(optparse_parameters(
  a_parameter = optparse_character(),
  args = list("--a-parameter", "42")
))

</code></pre>

<hr>
<h2 id='optparse_flag'>optparse_flag - define a command parameter as a trigger</h2><span id='topic+optparse_flag'></span>

<h3>Description</h3>

<p>To be used with <code>optparse_parameters</code>. This function tells
the provided parameter is a trigger (logical - TRUE/FALSE).
When the trigger parameter is not provided in the command line,
the value is FALSE. Otherwise, it is TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optparse_flag(help = "No documentation yet.", short = NULL, default = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optparse_flag_+3A_help">help</code></td>
<td>

<ul>
<li><p> The help string to display when &ndash;help is triggered
</p>
</li></ul>
</td></tr>
<tr><td><code id="optparse_flag_+3A_short">short</code></td>
<td>

<ul>
<li><p> The shortcut fir this parameter. For example
for a &ndash;output param, we could use
<code>optparse_flag(short = "-o", ...)</code> to set the &quot;-o&quot; shortcut.
</p>
</li></ul>
</td></tr>
<tr><td><code id="optparse_flag_+3A_default">default</code></td>
<td>

<ul>
<li><p> The default value this parameter will hold.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a list to give to <code>optparse_parameters</code> to build the
whole command line parsing tool.
</p>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optparse_parameters">optparse_parameters()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
str(optparse_parameters(
  a_parameter = optparse_flag(),
  args = list("--a-parameter")
))

</code></pre>

<hr>
<h2 id='optparse_integer'>optparse_integer - define a command parameter as an integer</h2><span id='topic+optparse_integer'></span>

<h3>Description</h3>

<p>To be used with <code>optparse_parameters</code>. This function tells
the provided parameter is to be parsed as an integer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optparse_integer(help = "No documentation yet.", short = NULL, default = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optparse_integer_+3A_help">help</code></td>
<td>

<ul>
<li><p> The help string to display when &ndash;help is triggered
</p>
</li></ul>
</td></tr>
<tr><td><code id="optparse_integer_+3A_short">short</code></td>
<td>

<ul>
<li><p> The shortcut fir this parameter. For example
for a &ndash;output param, we could use
<code>optparse_flag(short = "-o", ...)</code> to set the &quot;-o&quot; shortcut.
</p>
</li></ul>
</td></tr>
<tr><td><code id="optparse_integer_+3A_default">default</code></td>
<td>

<ul>
<li><p> The default value this parameter will hold.
</p>
</li></ul>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optparse_parameters">optparse_parameters()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
str(optparse_parameters(
  a_parameter = optparse_integer(),
  args = list("--a-parameter", "42")
))

</code></pre>

<hr>
<h2 id='optparse_list'>optparse_list - define a command parameter as a list of objects</h2><span id='topic+optparse_list'></span>

<h3>Description</h3>

<p>To be used with <code>optparse_parameters</code>. This function tells
the provided parameter is to be parsed as a list of objects.
The <code>of</code> parameter tells what type are elements of the list.
Each element must be separated by a separator. This separator must
be the value given in the <code>sep</code> parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optparse_list(
  help = "No documentation yet.",
  short = NULL,
  default = "",
  of = "character",
  sep = ",",
  truevalues = c("TRUE", "true", "1", "t", "T")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optparse_list_+3A_help">help</code></td>
<td>

<ul>
<li><p> The help string to display when &ndash;help is triggered
</p>
</li></ul>
</td></tr>
<tr><td><code id="optparse_list_+3A_short">short</code></td>
<td>

<ul>
<li><p> The shortcut fir this parameter. For example
for a &ndash;output param, we could use
<code>optparse_flag(short = "-o", ...)</code> to set the &quot;-o&quot; shortcut.
</p>
</li></ul>
</td></tr>
<tr><td><code id="optparse_list_+3A_default">default</code></td>
<td>

<ul>
<li><p> The default value this parameter will hold.
</p>
</li></ul>
</td></tr>
<tr><td><code id="optparse_list_+3A_of">of</code></td>
<td>

<ul>
<li><p> This type of elements of this list
</p>
</li></ul>
</td></tr>
<tr><td><code id="optparse_list_+3A_sep">sep</code></td>
<td>

<ul>
<li><p> This character to split on, to get the list
</p>
</li></ul>
</td></tr>
<tr><td><code id="optparse_list_+3A_truevalues">truevalues</code></td>
<td>

<ul>
<li><p> A <code>character</code> vector of different string
values to translate it as <code>TRUE</code> value.
</p>
</li></ul>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optparse_parameters">optparse_parameters()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
str(optparse_parameters(
  a_parameter = optparse_list(of="numeric"),
  b_parameter = optparse_list(of="integer"),
  c_parameter = optparse_list(of="logical"),
  args = list(
    "--a-parameter", "42.7,72.5",
    "--b-parameter", "42.7,72.5",
    "--c-parameter", "TRUE,FALSE,FALSE,TRUE"
  )
))

</code></pre>

<hr>
<h2 id='optparse_numeric'>optparse_numeric - define a command parameter as an numeric</h2><span id='topic+optparse_numeric'></span>

<h3>Description</h3>

<p>To be used with <code>optparse_parameters</code>. This function tells
the provided parameter is to be parsed as an numeric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optparse_numeric(help = "No documentation yet.", short = NULL, default = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optparse_numeric_+3A_help">help</code></td>
<td>

<ul>
<li><p> The help string to display when &ndash;help is triggered
</p>
</li></ul>
</td></tr>
<tr><td><code id="optparse_numeric_+3A_short">short</code></td>
<td>

<ul>
<li><p> The shortcut fir this parameter. For example
for a &ndash;output param, we could use
<code>optparse_flag(short = "-o", ...)</code> to set the &quot;-o&quot; shortcut.
</p>
</li></ul>
</td></tr>
<tr><td><code id="optparse_numeric_+3A_default">default</code></td>
<td>

<ul>
<li><p> The default value this parameter will hold.
</p>
</li></ul>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optparse_parameters">optparse_parameters()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
str(optparse_parameters(
  a_parameter = optparse_numeric(),
  args = list("--a-parameter", "42.72")
))

</code></pre>

<hr>
<h2 id='optparse_parameters'>optparse_parameters - parse easily the command line parameters</h2><span id='topic+optparse_parameters'></span>

<h3>Description</h3>

<p>This function is made to be used with the functions optparse_flag,
optparse_numeric, optparse_integer, optparse_character and/or
optparse_list
</p>
<p><code>optparse_parameters</code> parses arguments based on its parameters.
</p>
<p>You just have to call <code>optparse_parameters</code> with named arguments.
Each parameter is the result of either optparse_flag, optparse_numeric,
optparse_integer, optparse_character or optparse_list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optparse_parameters(
  fix_hyphens = TRUE,
  fix_dots = TRUE,
  add_trailing_hyphens = TRUE,
  args = NULL,
  no_optparse = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optparse_parameters_+3A_fix_hyphens">fix_hyphens</code></td>
<td>
<p>logical - whether to turn underscores into hyphens or not</p>
</td></tr>
<tr><td><code id="optparse_parameters_+3A_fix_dots">fix_dots</code></td>
<td>
<p>logical - whether to turn points into hyphens or not</p>
</td></tr>
<tr><td><code id="optparse_parameters_+3A_add_trailing_hyphens">add_trailing_hyphens</code></td>
<td>
<p>logical - whether to add trailing hyphens
if missing</p>
</td></tr>
<tr><td><code id="optparse_parameters_+3A_args">args</code></td>
<td>
<p><code>list</code> - The parameters from the <code>commandArgs</code> function</p>
</td></tr>
<tr><td><code id="optparse_parameters_+3A_no_optparse">no_optparse</code></td>
<td>
<p>logical - INTERNAL Tells whether to use optparse library or not</p>
</td></tr>
<tr><td><code id="optparse_parameters_+3A_...">...</code></td>
<td>
<p>parameters definition. Must be the result of either those functions:
</p>

<ul>
<li><p> optparse_flag
</p>
</li>
<li><p> optparse_numeric
</p>
</li>
<li><p> optparse_integer
</p>
</li>
<li><p> optparse_character
</p>
</li>
<li><p> optparse_list
</p>
</li></ul>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
args &lt;- optparse_parameters(
  a_integer = optparse_integer(),
  a_float = optparse_numeric(),
  a_boolean = optparse_flag(),
  a_character = optparse_character(),
  a_list = optparse_list(of = "numeric"),
  a_char_list = optparse_list(of = "character"),
  a_int_list = optparse_list(of = "integer"),
  args = list(
    "--a-integer",
    "42",
    "--a-float",
    "3.14",
    "--a-boolean",
    "FALSE",
    "--a-character",
    "FALSE",
    "--a-list",
    "1.5,2,3",
    "--a-char-list",
    "1.5,2,3",
    "--a-int-list",
    "1.5,2,3"
  )
)

str(args)

</code></pre>

<hr>
<h2 id='parse_args'>Parse Command arguments</h2><span id='topic+parse_args'></span>

<h3>Description</h3>

<p>parse_args
Replacement for the parseCommandArgs utility from batch.
Note that inputs like <code style="white-space: pre;">&#8288;script.R some-list c(1, 2, 3)&#8288;</code> will result in
args$<code>some-list</code> to be the string &quot;c(1, 2, 3)&quot;, and not a vector anymore
as this ability was permitted by dangerous behaviours from the
batch package (the usage of <code>eval</code> which MUST NEVER be used on user's
inputs).
</p>
<p>To get a list of numeric from users, instead of using the <code>c(1, 2)</code> trick,
please, use regular lists parsing:
</p>
<div class="sourceCode"><pre>&gt; args$`some-list`
[1] "1,2"
args$`some-list` &lt;- as.numeric(strsplit(args$`some-list`, ",")[[1]])
&gt; args$`some-list`
[1] 1 2
</pre></div>


<h3>Usage</h3>

<pre><code class='language-R'>parse_args(
  args = NULL,
  convert_booleans = TRUE,
  convert_numerics = TRUE,
  strip_trailing_dash = TRUE,
  replace_dashes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_args_+3A_args">args</code></td>
<td>
<p>optional, provide arguments to parse.
This function will use 'commandArgs()' if args is not provided</p>
</td></tr>
<tr><td><code id="parse_args_+3A_convert_booleans">convert_booleans</code></td>
<td>
<p>logical - tells the function to convert
values into logical if their value is &quot;TRUE&quot; or &quot;FALSE&quot;.</p>
</td></tr>
<tr><td><code id="parse_args_+3A_convert_numerics">convert_numerics</code></td>
<td>
<p>logical - tells the function to convert
values into numeric if possible.</p>
</td></tr>
<tr><td><code id="parse_args_+3A_strip_trailing_dash">strip_trailing_dash</code></td>
<td>

<ul>
<li><p> tells whether to remove trailing hyphens from
the start of the parameter name
</p>
</li></ul>
</td></tr>
<tr><td><code id="parse_args_+3A_replace_dashes">replace_dashes</code></td>
<td>

<ul>
<li><p> tells whether to turn trailing hyphens into
underscores
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a named <code>list</code> object containing the input parameters in values
and the parameters names in names
</p>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## faking command line parameters:

commandArgs &lt;- function() {
  list(
    "--args",
    "param1", "a value",
    "param2", "42"
  )
}

## extracting command line parameters:
parameters &lt;- W4MRUtils::parse_args(args = commandArgs())
str(parameters)

</code></pre>

<hr>
<h2 id='printf'>printf - to format a string and print it</h2><span id='topic+printf'></span>

<h3>Description</h3>

<p>printf calls sprintf of its parameters to build the error message
and prints with the given message
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printf(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printf_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="base.html#topic+sprintf">base::sprintf</a></code>
</p>

<dl>
<dt><code>fmt</code></dt><dd><p>a character vector of format strings, each of up to 8192 bytes.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
file &lt;- "/tmp/test"
printf("Error in file: ", file)

</code></pre>

<hr>
<h2 id='printfp'>printfp - to paste, format and print a string</h2><span id='topic+printfp'></span>

<h3>Description</h3>

<p>printfp calls paste and sprintf of its parameters to build the error message
and prints with the given message
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printfp(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printfp_+3A_x">x</code></td>
<td>
<p>a list of format string to concatenate before using sprintf on it.</p>
</td></tr>
<tr><td><code id="printfp_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="base.html#topic+paste">base::paste</a></code>
</p>

<dl>
<dt><code>sep</code></dt><dd><p>a character string to separate the terms.  Not
<code><a href="base.html#topic+NA_character_">NA_character_</a></code>.</p>
</dd>
<dt><code>collapse</code></dt><dd><p>an optional character string to separate the results.  Not
<code><a href="base.html#topic+NA_character_">NA_character_</a></code>.</p>
</dd>
<dt><code>recycle0</code></dt><dd><p><code><a href="base.html#topic+logical">logical</a></code> indicating if zero-length
character arguments should lead to the zero-length
<code><a href="base.html#topic+character">character</a>(0)</code> after the <code>sep</code>-phase (which turns into
<code>""</code> in the <code>collapse</code>-phase, i.e., when <code>collapse</code> is
not <code>NULL</code>).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
file &lt;- "/tmp/test"
printfp(
  list(
    "Very log error message that needs to be cut on multiple lines,",
    "and paste back together, but there are formatings like",
    "%%s for example, that provides a placeholder for parameters.",
    "Here %%s value is %s."
  ), file
)

</code></pre>

<hr>
<h2 id='printp'>printp - to format a string and print it</h2><span id='topic+printp'></span>

<h3>Description</h3>

<p>printp calls sprintf of its parameters to build the error message
and prints with the given message
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printp(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printp_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="base.html#topic+sprintf">base::sprintf</a></code>
</p>

<dl>
<dt><code>fmt</code></dt><dd><p>a character vector of format strings, each of up to 8192 bytes.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
file &lt;- "/tmp/test"
printp("Error in file: ", file)

</code></pre>

<hr>
<h2 id='reproduce_id'>Reproduce ID</h2><span id='topic+reproduce_id'></span>

<h3>Description</h3>

<p>reproduce_id
reproduce_id() reinjects original identifiers and original order into
final tables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reproduce_id(data_matrix, metadata, metadata_type, id_match)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reproduce_id_+3A_data_matrix">data_matrix</code></td>
<td>
<p>data.frame containing data_matrix</p>
</td></tr>
<tr><td><code id="reproduce_id_+3A_metadata">metadata</code></td>
<td>
<p>data.frame containing samplemetadata or variablemetadata</p>
</td></tr>
<tr><td><code id="reproduce_id_+3A_metadata_type">metadata_type</code></td>
<td>
<p>&quot;sample&quot; or &quot;variable&quot; depending on metadata content</p>
</td></tr>
<tr><td><code id="reproduce_id_+3A_id_match">id_match</code></td>
<td>
<p>'id_match' element produced by stock_id</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named <code>list</code> with two elements:
data_matrix: the processed data matrix with its original names and order
metadata: the processed metadata, with its original names and order.
</p>


<h3>Author(s)</h3>

<p>M.Petera
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

myDM &lt;- data.frame(data = 1:6, a = 2:7, b = 3:8, c = 2:7, d = 3:8, e = 2:7)
myvM &lt;- data.frame(variable = 1:6, x = 4:9, y = 2:7, z = 3:8)

A &lt;- W4MRUtils::stock_id(myDM, myvM, "variable")
myDM &lt;- A$dataMatrix
myvM &lt;- A$Metadata
A &lt;- A$id.match

## processing that may change order or requires specific identifiers format
## ...
datamatrix &lt;- as.data.frame(myDM)
sample_metadata &lt;- as.data.frame(myvM)

B &lt;- W4MRUtils::reproduce_id(datamatrix, sample_metadata, "variable", A)
datamatrix &lt;- B$dataMatrix
sample_metadata &lt;- B$Metadata


</code></pre>

<hr>
<h2 id='run_galaxy_function'>run_galaxy_function - automate running functions in galaxy</h2><span id='topic+run_galaxy_function'></span>

<h3>Description</h3>

<p>This function executes the provided function as a galaxy processing
This provided function is expected to take two parameters:
</p>

<ul>
<li><p> args, a list of command line parameters
</p>
</li>
<li><p> logger, the logger created for the tool
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>run_galaxy_function(tool_name, func, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_galaxy_function_+3A_tool_name">tool_name</code></td>
<td>

<ul>
<li><p> The name of the tool
</p>
</li></ul>
</td></tr>
<tr><td><code id="run_galaxy_function_+3A_func">func</code></td>
<td>

<ul>
<li><p> The function to be run, after galaxy header is displayed
</p>
</li></ul>
</td></tr>
<tr><td><code id="run_galaxy_function_+3A_...">...</code></td>
<td>

<ul>
<li><p> Parameters propagated to <a href="#topic+run_galaxy_processing">run_galaxy_processing</a>
</p>
</li></ul>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>See Also</h3>

<p><a href="#topic+run_galaxy_processing">run_galaxy_processing</a>
</p>

<hr>
<h2 id='run_galaxy_processing'>run_galaxy_processing - automate running code in galaxy</h2><span id='topic+run_galaxy_processing'></span>

<h3>Description</h3>

<p>run_galaxy_processing takes the tool's name, and the code to execute.
It detects galaxy-specific environement variable, and show headers
and footer if we are in a galaxy env.
</p>
<p>It will automatically convert command line parameters using
W4MRUtils::parse_args if args is not provided.
</p>
<p>Then, it unmangles galaxy parameters (galaxy params / values can be
mangled if they contains special characters)
</p>
<p>It creates a logger, and provide access to the <code>logger</code> and <code>args</code>
variables from withing the code to execute.
</p>
<p>Also, before executing the code, if <code>source_files</code> is set to some paths,
these paths will be source'd, so the code has access to functions
defined in these scripts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_galaxy_processing(
  tool_name,
  code,
  tool_version = "unknown",
  unmangle_parameters = TRUE,
  args = NULL,
  logger = NULL,
  source_files = c(),
  env = NULL,
  do_traceback = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_galaxy_processing_+3A_tool_name">tool_name</code></td>
<td>

<ul>
<li><p> Mandatory. The name of the tool to run.
</p>
</li></ul>
</td></tr>
<tr><td><code id="run_galaxy_processing_+3A_code">code</code></td>
<td>

<ul>
<li><p> Mandatory. The code to run the tool
</p>
</li></ul>
</td></tr>
<tr><td><code id="run_galaxy_processing_+3A_tool_version">tool_version</code></td>
<td>

<ul>
<li><p> The version number of the tool to run.
</p>
</li></ul>
</td></tr>
<tr><td><code id="run_galaxy_processing_+3A_unmangle_parameters">unmangle_parameters</code></td>
<td>

<ul>
<li><p> Whether or not to revert mangling from galaxy
useful if galaxy produces strange command parameters.
Not necessary, but produces more explicit outputs.
</p>
</li></ul>
</td></tr>
<tr><td><code id="run_galaxy_processing_+3A_args">args</code></td>
<td>

<ul>
<li><p> The result of <a href="base.html#topic+commandArgs">commandArgs</a> function, or from
the <a href="#topic+optparse_parameters">optparse_parameters</a> function.
Can be NULL. In this case, uses <a href="base.html#topic+commandArgs">commandArgs</a> to get the args.
</p>
</li></ul>
</td></tr>
<tr><td><code id="run_galaxy_processing_+3A_logger">logger</code></td>
<td>

<ul>
<li><p> You can provide a logger to use. If not provided,
a logger will be created with the tool's name.
</p>
</li></ul>
</td></tr>
<tr><td><code id="run_galaxy_processing_+3A_source_files">source_files</code></td>
<td>

<ul>
<li><p> You may provide some paths to source before executing
the provided code.
</p>
</li></ul>
</td></tr>
<tr><td><code id="run_galaxy_processing_+3A_env">env</code></td>
<td>

<ul>
<li><p> You may provide a environment object to execute the code
within.
</p>
</li></ul>
</td></tr>
<tr><td><code id="run_galaxy_processing_+3A_do_traceback">do_traceback</code></td>
<td>

<ul>
<li><p> logical - tells whether to produce a traceback in
case of error.
</p>
</li></ul>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
write_r_file_with_content &lt;- function(content) {
  "
  This function creates a temp R file. It writes the provided
  content in the R file. Then it returns the path of the script.
  "
  path &lt;- tempfile(fileext = ".R")
  file.create(path)
  writeLines(content, con = path)
  return(path)
}
## let's fake a galaxy env
Sys.setenv(GALAXY_SLOTS = 1)
## let's says the tool has been launched with this command line
log_file &lt;- tempfile()
file.create(log_file)
raw_args &lt;- list(
  "--args",
  "--input", "in.csv",
  "--output", "out.csv",
  "--logs", log_file,
  "--one-float", "3.14",
  "--one-integer", "456",
  "--one-logical", "FALSE",
  "--some-floats", "1.5,2.4,3.3",
  "--some-characters", "test,truc,bidule",
  "--debug", "TRUE",
  "--verbose", "FALSE"
)

##
# example 1
##

my_r_script &lt;- write_r_file_with_content('
  my_processing &lt;- function(args, logger) {
    logger$info("The tool is running")
    logger$infof("Input file: %s.", args$input)
    logger$info("The tool ended.")
  }
')

W4MRUtils::run_galaxy_processing(
  "Test tool 1",
  my_processing(args, logger),
  source_file = my_r_script,
  args = W4MRUtils::parse_args(args = raw_args)
)


##
# example 2

## let's say we have a R script with this content:
path &lt;- write_r_file_with_content('
  setup_logger &lt;- function(args, logger) {
    if (!is.null(args$verbose)) {
      logger$set_verbose(args$verbose)
    }
    if (!is.null(args$debug)) {
      logger$set_debug(args$debug)
    }
    if (!is.null(args$logs)) {
      logger$add_out_paths(args$logs)
    }
  }
  stop_logger &lt;- function(logger) {
    logger$close_files()
  }
  processing &lt;- function(args, logger) {
    setup_logger(args, logger)
    logger$info("The tool is working...")
    logger$infof("Input: %s.", args$input)
    logger$info("The tool stoping.")
    stop_logger(logger)
    return(NULL)
  }')


## wrapper script:

args &lt;- W4MRUtils::optparse_parameters(
  input = W4MRUtils::optparse_character(),
  output = W4MRUtils::optparse_character(),
  logs = W4MRUtils::optparse_character(),
  one_float = W4MRUtils::optparse_numeric(),
  one_integer = W4MRUtils::optparse_integer(),
  one_logical = W4MRUtils::optparse_flag(),
  some_floats = W4MRUtils::optparse_list(of = "numeric"),
  some_characters = W4MRUtils::optparse_list(of = "character"),
  debug = W4MRUtils::optparse_flag(),
  verbose = W4MRUtils::optparse_flag(),
  args = raw_args[raw_args != "--args"]
)

W4MRUtils::run_galaxy_processing("A Test tool", args = args, {
  ## processing is from the other R script
  processing(args, logger)
}, source_files = path)


</code></pre>

<hr>
<h2 id='show_galaxy_footer'>show_galaxy_footer - shows the footer for glaxy tools</h2><span id='topic+show_galaxy_footer'></span>

<h3>Description</h3>

<p>This function prints the footer to display in galaxy's tools logs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_galaxy_footer(
  tool_name,
  tool_version,
  logger = NULL,
  show_packages = TRUE,
  ellapsed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_galaxy_footer_+3A_tool_name">tool_name</code></td>
<td>
<p>a <code>character(1)</code> holding the
running tool's name.</p>
</td></tr>
<tr><td><code id="show_galaxy_footer_+3A_tool_version">tool_version</code></td>
<td>
<p>a <code>character(1)</code> holding the
running tool's version.</p>
</td></tr>
<tr><td><code id="show_galaxy_footer_+3A_logger">logger</code></td>
<td>
<p>a <code>get_logger("name")</code> instance - if provided, the
galaxy footer if output from the logger.</p>
</td></tr>
<tr><td><code id="show_galaxy_footer_+3A_show_packages">show_packages</code></td>
<td>
<p>logical - Tells whether to display loaded packages
and attached packages.</p>
</td></tr>
<tr><td><code id="show_galaxy_footer_+3A_ellapsed">ellapsed</code></td>
<td>
<p>NULL or a <code>character(1)</code> with execution duration.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>See Also</h3>

<p><a href="#topic+run_galaxy_processing">run_galaxy_processing</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
show_galaxy_footer("Tool Name", "1.2.0")

show_galaxy_footer(
  tool_name = "Tool Name",
  tool_version = "1.2.0",
  logger = get_logger("Some Tool"),
  show_packages = FALSE,
  ellapsed = "14.5 seconds"
)

</code></pre>

<hr>
<h2 id='show_galaxy_header'>show_galaxy_header - shows the header for glaxy tools</h2><span id='topic+show_galaxy_header'></span>

<h3>Description</h3>

<p>This function prints the header to display in galaxy's tools logs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_galaxy_header(
  tool_name,
  tool_version,
  args = NULL,
  logger = NULL,
  show_start_time = TRUE,
  show_sys = TRUE,
  show_parameters = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_galaxy_header_+3A_tool_name">tool_name</code></td>
<td>
<p>a <code>character(1)</code> holding the
running tool's name.</p>
</td></tr>
<tr><td><code id="show_galaxy_header_+3A_tool_version">tool_version</code></td>
<td>
<p>a <code>character(1)</code> holding the
running tool's version.</p>
</td></tr>
<tr><td><code id="show_galaxy_header_+3A_args">args</code></td>
<td>
<p>a <code>list(param="value")</code> - if provided, their are the
parameters shown in galaxy header and/or footer.</p>
</td></tr>
<tr><td><code id="show_galaxy_header_+3A_logger">logger</code></td>
<td>
<p>a <code>get_logger("name")</code> instance - if provided, the
galaxy footer if output from the logger.</p>
</td></tr>
<tr><td><code id="show_galaxy_header_+3A_show_start_time">show_start_time</code></td>
<td>

<ul>
<li><p> a logical telling whether to display
the start time or not.
</p>
</li></ul>
</td></tr>
<tr><td><code id="show_galaxy_header_+3A_show_sys">show_sys</code></td>
<td>

<ul>
<li><p> a logical telling whether to display
the system variables or not.
</p>
</li></ul>
</td></tr>
<tr><td><code id="show_galaxy_header_+3A_show_parameters">show_parameters</code></td>
<td>

<ul>
<li><p> a logical telling whether to display
the parameters or not.
</p>
</li></ul>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>See Also</h3>

<p><a href="#topic+run_galaxy_processing">run_galaxy_processing</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
show_galaxy_header("Tool Name", "1.2.0")
show_galaxy_header(
  tool_name = "Tool Name",
  tool_version = "1.2.0",
  logger = get_logger("Some Tool"),
  show_start_time = FALSE,
  show_sys = FALSE,
  show_parameters = FALSE
)

</code></pre>

<hr>
<h2 id='show_sys'>show_sys - prints env variables related to R</h2><span id='topic+show_sys'></span>

<h3>Description</h3>

<p>prints env variables related to R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_sys()
</code></pre>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
show_sys()

</code></pre>

<hr>
<h2 id='shy_lib'>Shy Lib</h2><span id='topic+shy_lib'></span>

<h3>Description</h3>

<p>shy_lib
Function to call packages without printing all the verbose
(only getting the essentials, like warning messages for example)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shy_lib(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shy_lib_+3A_...">...</code></td>
<td>
<p>Name of libraries to load</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> of attached packages
</p>


<h3>Author(s)</h3>

<p>M.Petera
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   W4MRUtils::shy_lib("base", "utils")


</code></pre>

<hr>
<h2 id='source_local'>source_local - source file, from absolute or relative path</h2><span id='topic+source_local'></span>

<h3>Description</h3>

<p>source_local
Transforms a relative path to an absolute one, and sources the path.
This helps source files located relatively to the main script without
the need to know from where it was run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>source_local(..., env = FALSE, do_print = FALSE, keep_source = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="source_local_+3A_...">...</code></td>
<td>
<p>paths, character vector of file paths to source</p>
</td></tr>
<tr><td><code id="source_local_+3A_env">env</code></td>
<td>
<p>an environement in which to source the paths</p>
</td></tr>
<tr><td><code id="source_local_+3A_do_print">do_print</code></td>
<td>
<p>a logical, telling whether to print sourced paths or
not</p>
</td></tr>
<tr><td><code id="source_local_+3A_keep_source">keep_source</code></td>
<td>
<p>See the parameter keep.source from source</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector resulting from the sourcing of the files provided.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+source">source()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## let's say we have some R file with the following content:
file_1_content &lt;- "
  setup_logger &lt;- function(args, logger) {
    if (!is.null(args$verbose) &amp;&amp; args$verbose) {
      logger$set_verbose(TRUE)
    }
    if (!is.null(args$debug) &amp;&amp; args$debug) {
      logger$set_debug(TRUE)
    }
    if (!is.null(args$logs)) {
      logger$add_out_paths(args$logs)
    }
  }"
file_2_content &lt;- "
  processing &lt;- function(args, logger) {
    logger$info(\"The tool is working...\")
    logger$infof(
      \"Parameters: %s\",
      paste(capture.output(str(args)), collapse = \"\n\")
    )
    logger$info(\"The tool ended fine.\")
    return(invisible(NULL))
  }"

if(!file.create(temp_path &lt;- tempfile(fileext = ".R"))) {
  stop("This documentation is not terminated doe to unknown error")
}
writeLines(file_1_content, con = temp_path)

local_path = "test-local-path.R"
local_full_path = file.path(get_base_dir(), local_path)
if(!file.create(local_full_path)) {
  stop("This documentation is not terminated doe to unknown error")
}
writeLines(file_2_content, con = local_full_path)

## now when we source them, the absolute path is sourced, and the
## relative file path is sourced too.
W4MRUtils::source_local(c(temp_path, local_path), do_print = TRUE)
file.remove(local_full_path)

## the function is accessible here
processing(list(), get_logger("Tool Name"))

</code></pre>

<hr>
<h2 id='stock_id'>Stock ID</h2><span id='topic+stock_id'></span>

<h3>Description</h3>

<p>stock_id
Functions to stock identifiers before applying make.names() and
to reinject it into final matrices.
stock_id stocks original identifiers and original order
needs checked data regarding table match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stock_id(data_matrix, metadata, metadata_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stock_id_+3A_data_matrix">data_matrix</code></td>
<td>
<p>a <code>data.frame</code> containing the data_matrix</p>
</td></tr>
<tr><td><code id="stock_id_+3A_metadata">metadata</code></td>
<td>
<p>a <code>data.frame</code> containing samplemetadata or
variablemetadata</p>
</td></tr>
<tr><td><code id="stock_id_+3A_metadata_type">metadata_type</code></td>
<td>
<p>&quot;sample&quot; or &quot;variable&quot; depending on metadata content</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a names <code>list</code> with three elements:
</p>

<ul>
<li><p> id.match a <code>data.frame</code> that contains original order of ids, names ;
</p>
</li>
<li><p> dataMatrix the modified data matrix with names sanitized
</p>
</li>
<li><p> Metadata the modified metadata matrix with names sanitized
This object can be used in reproduce_id() to replace sanitized names in data
matrix by original ones, in the right order.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>M.Petera
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

myDM &lt;- data.frame(data = 1:6, a = 2:7, b = 3:8, c = 2:7, d = 3:8, e = 2:7)
myvM &lt;- data.frame(variable = 1:6, x = 4:9, y = 2:7, z = 3:8)

A &lt;- W4MRUtils::stock_id(myDM, myvM, "variable")
myDM &lt;- A$dataMatrix
myvM &lt;- A$Metadata
A &lt;- A$id.match

## processing that may change order or requires specific identifiers format
## ...
datamatrix &lt;- as.data.frame(myDM)
sample_metadata &lt;- as.data.frame(myvM)

B &lt;- W4MRUtils::reproduce_id(datamatrix, sample_metadata, "variable", A)
datamatrix &lt;- B$dataMatrix
sample_metadata &lt;- B$Metadata


</code></pre>

<hr>
<h2 id='stopaste'>stopaste - to paste string to a message and stop</h2><span id='topic+stopaste'></span>

<h3>Description</h3>

<p>stopaste calls paste of its parameters to build the error message
and stops with the given message
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stopaste(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stopaste_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="base.html#topic+paste">base::paste</a></code>
</p>

<dl>
<dt><code>sep</code></dt><dd><p>a character string to separate the terms.  Not
<code><a href="base.html#topic+NA_character_">NA_character_</a></code>.</p>
</dd>
<dt><code>collapse</code></dt><dd><p>an optional character string to separate the results.  Not
<code><a href="base.html#topic+NA_character_">NA_character_</a></code>.</p>
</dd>
<dt><code>recycle0</code></dt><dd><p><code><a href="base.html#topic+logical">logical</a></code> indicating if zero-length
character arguments should lead to the zero-length
<code><a href="base.html#topic+character">character</a>(0)</code> after the <code>sep</code>-phase (which turns into
<code>""</code> in the <code>collapse</code>-phase, i.e., when <code>collapse</code> is
not <code>NULL</code>).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tryCatch({
  file &lt;- "/tmp/test"
  stopaste("Error in file: ", file)
}, error = function(error) {
  print(error)
})

</code></pre>

<hr>
<h2 id='stopaste0'>stopaste0 - to paste string to a message and stop</h2><span id='topic+stopaste0'></span>

<h3>Description</h3>

<p>stopaste calls paste0 of its parameters to build the error message
and stops with the given message
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stopaste0(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stopaste0_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="base.html#topic+paste">base::paste0</a></code>
</p>

<dl>
<dt><code>collapse</code></dt><dd><p>an optional character string to separate the results.  Not
<code><a href="base.html#topic+NA_character_">NA_character_</a></code>.</p>
</dd>
<dt><code>recycle0</code></dt><dd><p><code><a href="base.html#topic+logical">logical</a></code> indicating if zero-length
character arguments should lead to the zero-length
<code><a href="base.html#topic+character">character</a>(0)</code> after the <code>sep</code>-phase (which turns into
<code>""</code> in the <code>collapse</code>-phase, i.e., when <code>collapse</code> is
not <code>NULL</code>).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tryCatch({
  file &lt;- "/tmp/test"
  stopaste0("Error in file: ", file)
}, error = function(error) {
  print(error)
})

</code></pre>

<hr>
<h2 id='stopf'>stopf - to stop and format message</h2><span id='topic+stopf'></span>

<h3>Description</h3>

<p>stopf calls sprintf of its parameters to build the error message
and stops with the given message
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stopf(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stopf_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="base.html#topic+sprintf">base::sprintf</a></code>
</p>

<dl>
<dt><code>fmt</code></dt><dd><p>a character vector of format strings, each of up to 8192 bytes.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tryCatch({
  file &lt;- "/tmp/test"
  stopf("Error in %s file.", file)
}, error = function(error) {
  print(error)
})

</code></pre>

<hr>
<h2 id='unmangle_galaxy_param'>unmangle_galaxy_param - revert effects of galaxy manglings.</h2><span id='topic+unmangle_galaxy_param'></span>

<h3>Description</h3>

<p>When running a tool from galaxy, the command line may be
altered because some forbidden chars have been translated by galaxy.
</p>
<p>This function takes <code>args</code> are invert the galaxy's mangling process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unmangle_galaxy_param(args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmangle_galaxy_param_+3A_args">args</code></td>
<td>
<p>named <code>list</code> - contains params_name=value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named <code>list</code> - with unmangled parameter name and
values.
</p>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>See Also</h3>

<p><a href="#topic+run_galaxy_processing">run_galaxy_processing</a>, <a href="#topic+unmangle_galaxy_string">unmangle_galaxy_string</a>
</p>

<hr>
<h2 id='unmangle_galaxy_string'>unmangle_galaxy_string - revert effects of galaxy mangling</h2><span id='topic+unmangle_galaxy_string'></span>

<h3>Description</h3>

<p>Revert effect of string mangling from galaxy on the given string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unmangle_galaxy_string(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmangle_galaxy_string_+3A_string">string</code></td>
<td>

<ul>
<li><p> the character vector to fix mangling.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>string - the character vector, fixed.
</p>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>See Also</h3>

<p><a href="#topic+run_galaxy_processing">run_galaxy_processing</a>, <a href="#topic+unmangle_galaxy_param">unmangle_galaxy_param</a>
</p>

<hr>
<h2 id='W4MLogger'>The W4MLogger Class</h2><span id='topic+W4MLogger'></span>

<h3>Description</h3>

<p>This is a simple logger used to make uniform outputs across W4M tools.
</p>
<p>See <a href="#topic+get_logger">get_logger</a> for example usages.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="W4MLogger_+3A_name">name</code></td>
<td>
<p>character vector of length 1 - The name of the logger.
Use different loggers with a name specific to each part of you program.
The name will appear in the log prefix and helps to determine which
part of the program did what</p>
</td></tr>
<tr><td><code id="W4MLogger_+3A_format">format</code></td>
<td>
<p>character vector of length 1 - The format string for each
log line. The default is :
<code>"[{{ level }}-{{ name }}-{{ time }}] - {{ message }}"</code></p>
</td></tr>
<tr><td><code id="W4MLogger_+3A_do_coloring">do_coloring</code></td>
<td>
<p>logical vector of length 1 - By default, the logger
uses special control character to give some coloring to the text,
depending on the log level (info, warning, error, debug or verbose).
This coloring is deactivated in files and if
<code>W4MRUtils::in_galaxy_env()</code> returns TRUE. You can force or
deactivate the coloring with this  parameter.</p>
</td></tr>
<tr><td><code id="W4MLogger_+3A_show_debug">show_debug</code></td>
<td>
<p>logical vector of length 1 - Tells whether the
debug logs must be displayed/written or not. Default is FALSE</p>
</td></tr>
<tr><td><code id="W4MLogger_+3A_show_verbose">show_verbose</code></td>
<td>
<p>logical vector of length 1 - Tells whether the
verbose logs must be displayed/written or not. Default is FALSE</p>
</td></tr>
<tr><td><code id="W4MLogger_+3A_show_info">show_info</code></td>
<td>
<p>logical vector of length 1 - Tells whether the
info logs must be displayed/written or not Default is TRUE.</p>
</td></tr>
<tr><td><code id="W4MLogger_+3A_show_warning">show_warning</code></td>
<td>
<p>logical vector of length 1 - Tells whether the
warning logs must be displayed/written or not Default is TRUE.</p>
</td></tr>
<tr><td><code id="W4MLogger_+3A_show_error">show_error</code></td>
<td>
<p>logical vector of length 1 - Tells whether the
error logs must be displayed/written or not Default is TRUE.</p>
</td></tr>
<tr><td><code id="W4MLogger_+3A_coloring">coloring</code></td>
<td>
<p>named list - This lists maps a logging level to
its coloring. Like this: <code>list(debug = "purple", info = "green")</code>
Available colors can be found in <code>W4MRUtils::w4m_colors__</code>.</p>
</td></tr>
<tr><td><code id="W4MLogger_+3A_out_func">out_func</code></td>
<td>
<p>function - the default function to print messages
in the terminal. The default is <code>base::message</code> .</p>
</td></tr>
<tr><td><code id="W4MLogger_+3A_out_path">out_path</code></td>
<td>
<p>list of file paths - Provide a list of file path
where the logs will be written. It is not possible to separate
different levels of logs in different log files for the moment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A W4MLogger instance
</p>


<h3>Author(s)</h3>

<p>L.Pavot
</p>


<h3>See Also</h3>

<p><a href="#topic+W4MLogger+24info">W4MLogger$info</a>, <a href="#topic+W4MLogger+24warning">W4MLogger$warning</a>, <a href="#topic+W4MLogger+24error">W4MLogger$error</a>,
<a href="#topic+W4MLogger+24debug">W4MLogger$debug</a>, <a href="#topic+W4MLogger+24verbose">W4MLogger$verbose</a>
</p>

<hr>
<h2 id='W4MLogger_.message__'>W4MLogger_.message__</h2><span id='topic+W4MLogger_.message__'></span>

<h3>Description</h3>

<p>The function W4MLogger$.message__ is the function that gets
automatically called when  W4MLogger$info, W4MLogger$debug,
W4MLogger$warning, W4MLogger$error or W4MLogger$verbose are invoked.
This function is not truly internal, so it has to be considered
as external, but should not be exported:
</p>
<p>This means its has to do type checking of its inputs, and consider
parameters as unsafe.
</p>
<p>See <a href="#topic+get_logger">get_logger</a> for example usages.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="W4MLogger_.message___+3A_level">level</code></td>
<td>
<p>is a string. By default its value should be either &quot;info&quot;,
&quot;debug&quot;, &quot;warning&quot;, &quot;debug&quot;, &quot;verbose&quot; or &quot;INTERNAL&quot;.
But, if the logger was build with a different color naming, one of
the names provided in the &quot;coloring&quot; <code>named list</code> parameter must be
used, as it determines the color to use.</p>
</td></tr>
<tr><td><code id="W4MLogger_.message___+3A_...">...</code></td>
<td>
<p>anything, of any length. If this is not a character vector,
then, its displayable value will be obtained with
<code>capture.output(str(...))</code>
If the resulting character vector's length is greater than one,
then multiple messages will be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>this logger's instance ( <code>.self</code> )
</p>

<hr>
<h2 id='W4MLogger_+5Binfo+2Cwarning+2Cerror+2Cdebug+2Cverbose+5D'>Log info/warning/error/debug/verbose messages</h2><span id='topic+W4MLogger_+5Binfo+2Cwarning+2Cerror+2Cdebug+2Cverbose+5D'></span><span id='topic+W4MLogger+24info'></span><span id='topic+W4MLogger+24warning'></span><span id='topic+W4MLogger+24error'></span><span id='topic+W4MLogger+24debug'></span><span id='topic+W4MLogger+24verbose'></span>

<h3>Description</h3>

<p>Call one of the following function when you want a message to be printed
or written in a log file:
</p>

<ul>
<li> <p><code>your_logger$info("A info message")</code> ;
</p>
</li>
<li> <p><code>your_logger$warning("A warning message")</code> ;
</p>
</li>
<li> <p><code>your_logger$error("A error message")</code> ;
</p>
</li>
<li> <p><code>your_logger$debug("A debug message")</code> ;
</p>
</li>
<li> <p><code>your_logger$verbose.("A verbose. message")</code>
</p>
</li></ul>

<p>If the corresponding level is activated (with your_logger$set_info(TRUE),
your_logger$set_debug(TRUE), etc...), these functions will print the
message provided in the terminal and in logs files, if there were some
provided at the creation of the logger.
</p>
<p>If the corresponding log level is deactivated, these function will
not do anything. So, do not hesitate to use them a lot, and activate them
when needed.
</p>
<p>See <a href="#topic+get_logger">get_logger</a> for example usages.
</p>


<h3>Author(s)</h3>

<p>L.Pavot
</p>

<hr>
<h2 id='W4MLogger_add_out_paths'>Adds a file where logs are duplicated</h2><span id='topic+W4MLogger_add_out_paths'></span>

<h3>Description</h3>

<p>W4MLogger can output logs in file. This function adds a file in which
to put logs.
</p>

<hr>
<h2 id='W4MLogger_finalize'>W4MLogger_finalize</h2><span id='topic+W4MLogger_finalize'></span>

<h3>Description</h3>

<p>The function W4MLogger$finalize is the destructor function of this
class. It closes every files that was opened by the logger, or that
was provided during execution. It has to be considered internal.
</p>
<p>The function W4MLogger$finalize is the destructor function of this
class. It closes every files that was opened by the logger, or that
was provided during execution. It has to be considered internal.
</p>
<p>The function W4MLogger$finalize is the destructor function of this
class. It closes every files that was opened by the logger, or that
was provided during execution. It has to be considered internal.
</p>
<p>The function W4MLogger$finalize is the destructor function of this
class. It closes every files that was opened by the logger, or that
was provided during execution. It has to be considered internal.
</p>
<p>The function W4MLogger$finalize is the destructor function of this
class. It closes every files that was opened by the logger, or that
was provided during execution. It has to be considered internal.
</p>

<hr>
<h2 id='W4MLogger_set_debug'>W4MLogger$set_debug</h2><span id='topic+W4MLogger_set_debug'></span>

<h3>Description</h3>

<p>This method activate or deactivate the logging of debugs messages
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="W4MLogger_set_debug_+3A_value">value</code></td>
<td>
<p>logical TRUE/FALSE to activate/deactivate debug logging</p>
</td></tr>
<tr><td><code id="W4MLogger_set_debug_+3A_default">default</code></td>
<td>
<p>logical set to TRUE to use debug by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>.self the current W4MLogger instance
</p>

<hr>
<h2 id='W4MLogger_set_error'>W4MLogger$set_error</h2><span id='topic+W4MLogger_set_error'></span>

<h3>Description</h3>

<p>This method activate or deactivate the logging of errors messages
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="W4MLogger_set_error_+3A_value">value</code></td>
<td>
<p>logical TRUE/FALSE to activate/deactivate error logging</p>
</td></tr>
<tr><td><code id="W4MLogger_set_error_+3A_default">default</code></td>
<td>
<p>logical set to TRUE to use error by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>.self the current W4MLogger instance
</p>

<hr>
<h2 id='W4MLogger_set_info'>W4MLogger$set_info</h2><span id='topic+W4MLogger_set_info'></span>

<h3>Description</h3>

<p>This method activate or deactivate the logging of info messages
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="W4MLogger_set_info_+3A_value">value</code></td>
<td>
<p>logical TRUE/FALSE to activate/deactivate info logging</p>
</td></tr>
<tr><td><code id="W4MLogger_set_info_+3A_default">default</code></td>
<td>
<p>logical set to TRUE to use info by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>.self the current W4MLogger instance
</p>

<hr>
<h2 id='W4MLogger_set_out_paths'>Defines in which file logs are duplicated</h2><span id='topic+W4MLogger_set_out_paths'></span>

<h3>Description</h3>

<p>W4MLogger can output logs in file. This function tells in which file
to put logs.
</p>

<hr>
<h2 id='W4MLogger_set_verbose'>W4MLogger$set_verbose</h2><span id='topic+W4MLogger_set_verbose'></span>

<h3>Description</h3>

<p>This method activate or deactivate the logging of verbose messages
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="W4MLogger_set_verbose_+3A_value">value</code></td>
<td>
<p>logical TRUE/FALSE to activate/deactivate verbose logging</p>
</td></tr>
<tr><td><code id="W4MLogger_set_verbose_+3A_default">default</code></td>
<td>
<p>logical set to TRUE to use verbose by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>.self the current W4MLogger instance
</p>

<hr>
<h2 id='W4MLogger_set_warning'>W4MLogger$set_warning</h2><span id='topic+W4MLogger_set_warning'></span>

<h3>Description</h3>

<p>This method activate or deactivate the logging of warnings messages
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="W4MLogger_set_warning_+3A_value">value</code></td>
<td>
<p>logical TRUE/FALSE to activate/deactivate warning logging</p>
</td></tr>
<tr><td><code id="W4MLogger_set_warning_+3A_default">default</code></td>
<td>
<p>logical set to TRUE to use warning by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>.self the current W4MLogger instance
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
