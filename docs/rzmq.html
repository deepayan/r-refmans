<!DOCTYPE html><html><head><title>Help for package rzmq</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rzmq}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bind.socket'>
<p>Create an endpoint for accepting connections and bind it to the socket referenced by the socket argument.</p></a></li>
<li><a href='#connect.socket'>
<p>Connect the socket referenced by the socket argument to the endpoint specified by the endpoint argument.</p></a></li>
<li><a href='#init.context'>
<p>initailize zmq context and zmq socket</p></a></li>
<li><a href='#init.message'>
<p>create a message object.</p></a></li>
<li><a href='#poll.socket'><p>Polls a list of sockets, waiting for the presence of a nonblocking read, write, or error event.</p></a></li>
<li><a href='#receive.multipart'><p>Receive multipart ZMQ message</p></a></li>
<li><a href='#receive.socket'>
<p>Receive a message from the socket referenced by the socket argument.</p></a></li>
<li><a href='#send.multipart'><p>Send multipart ZMQ message.</p></a></li>
<li><a href='#send.socket'>
<p>send a message.</p></a></li>
<li><a href='#socket.options'>
<p>set a socket option.</p></a></li>
<li><a href='#zmq.error'>
<p>get libzmq error numbers and error strings</p></a></li>
<li><a href='#zmq.version'>
<p>get version of libzmq</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>R Bindings for 'ZeroMQ'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.12</td>
</tr>
<tr>
<td>Description:</td>
<td>Interface to the 'ZeroMQ' lightweight messaging kernel (see <a href="https://zeromq.org/">https://zeromq.org/</a> for more information).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>ZeroMQ &gt;= 3.0.0: libzmq3-dev (deb) or zeromq-devel
(rpm)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://docs.ropensci.org/rzmq/">https://docs.ropensci.org/rzmq/</a>
<a href="https://ropensci.r-universe.dev/rzmq">https://ropensci.r-universe.dev/rzmq</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/rzmq/issues">https://github.com/ropensci/rzmq/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-04 13:09:06 UTC; jeroen</td>
</tr>
<tr>
<td>Author:</td>
<td>Whit Armstrong [aut],
  Michael Schubert [ctb],
  Jeroen Ooms <a href="https://orcid.org/0000-0002-4035-0289"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jeroen Ooms &lt;jeroen@berkeley.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-04 18:40:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='bind.socket'>
Create an endpoint for accepting connections and bind it to the socket referenced by the socket argument.
</h2><span id='topic+bind.socket'></span>

<h3>Description</h3>

<p>The zmq_bind() function shall create an endpoint for accepting connections and bind it to the socket referenced by the socket argument.
</p>
<p>The endpoint argument is a string consisting of two parts as follows: transport ://address. The transport part specifies the underlying transport protocol to use. The meaning of the address part is specific to the underlying transport protocol selected.
</p>
<p>The following transports are defined:
</p>
<p>inproc
local in-process (inter-thread) communication transport, see zmq_inproc(7)
ipc
local inter-process communication transport, see zmq_ipc(7)
tcp
unicast transport using TCP, see zmq_tcp(7)
pgm, epgm
reliable multicast transport using PGM, see zmq_pgm(7)
With the exception of ZMQ_PAIR sockets, a single socket may be connected to multiple endpoints using zmq_connect(), while simultaneously accepting incoming connections from multiple endpoints bound to the socket using zmq_bind(). Refer to zmq_socket(3) for a description of the exact semantics involved when connecting or binding a socket to multiple endpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind.socket(socket, address)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind.socket_+3A_socket">socket</code></td>
<td>
<p>a zmq socket object.</p>
</td></tr>
<tr><td><code id="bind.socket_+3A_address">address</code></td>
<td>
<p>a transport as described above.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if operation succeeds or FALSE if the operation fails</p>


<h3>Author(s)</h3>

<p>ZMQ was written by Martin Sustrik &lt;sustrik@250bpm.com&gt; and Martin Lucina &lt;mato@kotelna.sk&gt;.
rzmq was written by Whit Armstrong.
</p>


<h3>References</h3>

<p>http://www.zeromq.org
http://api.zeromq.org
http://zguide.zeromq.org/page:all
</p>


<h3>See Also</h3>

<p><code><a href="#topic+connect.socket">connect.socket</a>,<a href="#topic+bind.socket">bind.socket</a>,<a href="#topic+receive.socket">receive.socket</a>,<a href="#topic+send.socket">send.socket</a>,<a href="#topic+poll.socket">poll.socket</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(rzmq)
context = init.context()
in.socket = init.socket(context,"ZMQ_PULL")
bind.socket(in.socket,"tcp://*:5557")

out.socket = init.socket(context,"ZMQ_PUSH")
bind.socket(out.socket,"tcp://*:5558")

## End(Not run)</code></pre>

<hr>
<h2 id='connect.socket'>
Connect the socket referenced by the socket argument to the endpoint specified by the endpoint argument.
</h2><span id='topic+connect.socket'></span><span id='topic+disconnect.socket'></span>

<h3>Description</h3>

<p>The zmq_connect() function shall connect the socket referenced by the socket argument to the endpoint specified by the endpoint argument.
</p>
<p>The endpoint argument is a string consisting of two parts as follows: transport ://address. The transport part specifies the underlying transport protocol to use. The meaning of the address part is specific to the underlying transport protocol selected.
</p>
<p>The following transports are defined:
</p>
<p>inproc
local in-process (inter-thread) communication transport, see zmq_inproc(7)
ipc
local inter-process communication transport, see zmq_ipc(7)
tcp
unicast transport using TCP, see zmq_tcp(7)
pgm, epgm
reliable multicast transport using PGM, see zmq_pgm(7)
With the exception of ZMQ_PAIR sockets, a single socket may be connected to multiple endpoints using zmq_connect(), while simultaneously accepting incoming connections from multiple endpoints bound to the socket using zmq_bind(). Refer to zmq_socket(3) for a description of the exact semantics involved when connecting or binding a socket to multiple endpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>connect.socket(socket, address)
disconnect.socket(socket, address)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connect.socket_+3A_socket">socket</code></td>
<td>
<p>a zmq socket object.</p>
</td></tr>
<tr><td><code id="connect.socket_+3A_address">address</code></td>
<td>
<p>a transport as described above.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if operation succeeds or FALSE if the operation fails</p>


<h3>Author(s)</h3>

<p>ZMQ was written by Martin Sustrik &lt;sustrik@250bpm.com&gt; and Martin Lucina &lt;mato@kotelna.sk&gt;.
rzmq was written by Whit Armstrong.
</p>


<h3>References</h3>

<p>http://www.zeromq.org
http://api.zeromq.org
http://zguide.zeromq.org/page:all
</p>


<h3>See Also</h3>

<p><code><a href="#topic+connect.socket">connect.socket</a>,<a href="#topic+bind.socket">bind.socket</a>,<a href="#topic+receive.socket">receive.socket</a>,<a href="#topic+send.socket">send.socket</a>,<a href="#topic+poll.socket">poll.socket</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(rzmq)
context = init.context()
in.socket = init.socket(context,"ZMQ_PULL")
bind.socket(in.socket,"tcp://*:5557")

out.socket = init.socket(context,"ZMQ_PUSH")
bind.socket(out.socket,"tcp://*:5558")

## End(Not run)</code></pre>

<hr>
<h2 id='init.context'>
initailize zmq context and zmq socket
</h2><span id='topic+init.context'></span><span id='topic+init.socket'></span>

<h3>Description</h3>

<p>initialize zmq context and zmq socket for to be used for further zmq operations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init.context(threads=1L)
init.socket(context, socket.type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init.context_+3A_threads">threads</code></td>
<td>
<p>number of threads for the context to use</p>
</td></tr>
<tr><td><code id="init.context_+3A_context">context</code></td>
<td>
<p>a zmq context object.</p>
</td></tr>
<tr><td><code id="init.context_+3A_socket.type">socket.type</code></td>
<td>
<p> The ZMQ socket type requested
e.g. ZMQ_REQ,ZMQ_REP,ZMQ_PULL,ZMQ_PUSH, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>init.context</code> returns a zmq context object. <code>init.socket</code> returns a zmq socket object.
</p>


<h3>Author(s)</h3>

<p>ZMQ was written by Martin Sustrik &lt;sustrik@250bpm.com&gt; and Martin Lucina &lt;mato@kotelna.sk&gt;.
rzmq was written by Whit Armstrong.
</p>


<h3>References</h3>

<p>http://www.zeromq.org
http://api.zeromq.org
http://zguide.zeromq.org/page:all
</p>


<h3>See Also</h3>

<p><code><a href="#topic+connect.socket">connect.socket</a>,<a href="#topic+bind.socket">bind.socket</a>,<a href="#topic+receive.socket">receive.socket</a>,<a href="#topic+send.socket">send.socket</a>,<a href="#topic+poll.socket">poll.socket</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(rzmq)
context = init.context()
in.socket = init.socket(context,"ZMQ_PULL")

## End(Not run)</code></pre>

<hr>
<h2 id='init.message'>
create a message object.
</h2><span id='topic+init.message'></span>

<h3>Description</h3>

<p>Create a ZeroMQ message object that can be sent multiple times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init.message(data, serialize=TRUE, xdr=.Platform$endian=="big")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init.message_+3A_data">data</code></td>
<td>
<p>the R object to be sent</p>
</td></tr>
<tr><td><code id="init.message_+3A_serialize">serialize</code></td>
<td>
<p>whether to call serialize before sending the data</p>
</td></tr>
<tr><td><code id="init.message_+3A_xdr">xdr</code></td>
<td>
<p>passed directly to serialize command if serialize is requested</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ZeroMQ message object as external pointer
</p>


<h3>Author(s)</h3>

<p>ZMQ was written by Martin Sustrik &lt;sustrik@250bpm.com&gt; and Martin Lucina &lt;mato@kotelna.sk&gt;.
rzmq was written by Whit Armstrong.
</p>


<h3>References</h3>

<p>http://www.zeromq.org
http://api.zeromq.org
http://zguide.zeromq.org/page:all
</p>


<h3>See Also</h3>

<p><code><a href="#topic+send.message.object">send.message.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## remote execution server in rzmq
library(rzmq)
data = list(x=5)
msg = init.message(data)

## End(Not run)</code></pre>

<hr>
<h2 id='poll.socket'>Polls a list of sockets, waiting for the presence of a nonblocking read, write, or error event.</h2><span id='topic+poll.socket'></span>

<h3>Description</h3>

<p>The zmq_poll() function shall poll a list of a sockets for either read, write, or error conditions subject to a millisecond resolution timeout.</p>


<h3>Usage</h3>

<pre><code class='language-R'>    poll.socket(sockets, events, timeout=0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poll.socket_+3A_sockets">sockets</code></td>
<td>
<p>a list of zmq socket objects.</p>
</td></tr>
<tr><td><code id="poll.socket_+3A_events">events</code></td>
<td>
<p>a list of character vectors containing one or more events in {read, write, error}. The first element in the list corresponds to the first zmq socket, and so on...</p>
</td></tr>
<tr><td><code id="poll.socket_+3A_timeout">timeout</code></td>
<td>
<p>the numbers of seconds to wait for events. Fractional seconds are supported. ZeroMQ guarantees at most millisecond resolution. A timeout of -1L blocks until an event occurs; a timeout of 0L is non-blocking.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of pairlists corresponding to the polled zmq sockets. Each list has one of more tags from {read, write, error} with logical values indicating the results of the poll operation.</p>


<h3>Author(s)</h3>

<p>ZMQ was written by Martin Sustrik &lt;sustrik@250bpm.com&gt; and Martin Lucina &lt;mato@kotelna.sk&gt;.
rzmq was written by Whit Armstrong.
</p>


<h3>References</h3>

<p>http://www.zeromq.org
http://api.zeromq.org
http://zguide.zeromq.org/page:all
</p>


<h3>See Also</h3>

<p><code><a href="#topic+connect.socket">connect.socket</a>,<a href="#topic+bind.socket">bind.socket</a>,<a href="#topic+receive.socket">receive.socket</a>,<a href="#topic+send.socket">send.socket</a>,<a href="#topic+poll.socket">poll.socket</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(rzmq)

# Create a set of REP-REQ sockets that
# have a Send, Receive, Send, Receive, ...
# pattern.
context = init.context()
in.socket = init.socket(context,"ZMQ_REP")
bind.socket(in.socket,"tcp://*:5557")

out.socket = init.socket(context,"ZMQ_REQ")
connect.socket(out.socket,"tcp://*:5557")

# Poll the REP and REQ sockets for all events.
events &lt;- poll.socket(list(in.socket, out.socket),
                      list(c("read", "write", "error"),
                           c("read", "write", "error")),
                      timeout=0L)

# The REQ socket is writable without blocking.
paste("Is upstream REP socket readable without blocking?", events[[1]]$read)
paste("Is upstream REP socket writable without blocking?", events[[1]]$write)
paste("Is downstream REQ socket readable without blocking?", events[[2]]$read)
paste("Is downstream REQ socket writable without blocking?", events[[2]]$write)

# Send a message to the REP socket from the REQ socket. The
# REQ socket must respond before the REP socket can send
# another message.
send.socket(out.socket, "Hello World")

events &lt;- poll.socket(list(in.socket, out.socket),
                      list(c("read", "write", "error"),
                           c("read", "write", "error")),
                      timeout=0L)

# The incoming message is readable on the REP socket.
paste("Is upstream REP socket readable without blocking?", events[[1]]$read)
paste("Is upstream REP socket writable without blocking?", events[[1]]$write)
paste("Is downstream REQ socket readable without blocking?", events[[2]]$read)
paste("Is downstream REQ socket writable without blocking?", events[[2]]$write)

receive.socket(in.socket)

events &lt;- poll.socket(list(in.socket, out.socket),
                      list(c("read", "write", "error"),
                           c("read", "write", "error")),
                      timeout=0L)

# The REQ socket is waiting for a response from the REP socket. 
paste("Is upstream REP socket readable without blocking?", events[[1]]$read)
paste("Is upstream REP socket writable without blocking?", events[[1]]$write)
paste("Is downstream REQ socket readable without blocking?", events[[2]]$read)
paste("Is downstream REQ socket writable without blocking?", events[[2]]$write)

send.socket(in.socket, "Greetings")

events &lt;- poll.socket(list(in.socket, out.socket),
                      list(c("read", "write", "error"),
                           c("read", "write", "error")),
                      timeout=0L)

# The REP response is waiting to be read on the REQ socket.
paste("Is upstream REP socket readable without blocking?", events[[1]]$read)
paste("Is upstream REP socket writable without blocking?", events[[1]]$write)
paste("Is downstream REQ socket readable without blocking?", events[[2]]$read)
paste("Is downstream REQ socket writable without blocking?", events[[2]]$write)

# Complete the REP-REQ transaction cycle by reading
# the REP response.
receive.socket(out.socket)

## End(Not run)</code></pre>

<hr>
<h2 id='receive.multipart'>Receive multipart ZMQ message</h2><span id='topic+receive.multipart'></span>

<h3>Description</h3>

<p>Returns a list of raw vectors for the parts of a multipart message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>receive.multipart(socket)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="receive.multipart_+3A_socket">socket</code></td>
<td>
<p>The ZMQ socket from which to receive data</p>
</td></tr>
</table>

<hr>
<h2 id='receive.socket'>
Receive a message from the socket referenced by the socket argument.
</h2><span id='topic+receive.socket'></span><span id='topic+receive.null.msg'></span><span id='topic+receive.string'></span><span id='topic+receive.int'></span><span id='topic+receive.double'></span>

<h3>Description</h3>

<p>The zmq_recv() function shall receive a message from the socket
referenced by the socket argument. If there are no messages available
on the specified socket, by default the function shall block until the request
can be satisfied.
A non-blocking receive can be obtained by setting dont.wait to TRUE
If there are no messages available on the specified socket, the
receive.socket() call will return NULL immediately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>receive.socket(socket, unserialize=TRUE, dont.wait=FALSE)
receive.null.msg(socket)
receive.string(socket)
receive.int(socket)
receive.double(socket)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="receive.socket_+3A_socket">socket</code></td>
<td>
<p>a zmq socket object</p>
</td></tr>
<tr><td><code id="receive.socket_+3A_unserialize">unserialize</code></td>
<td>
<p>whether to call unserialize on the received data</p>
</td></tr>
<tr><td><code id="receive.socket_+3A_dont.wait">dont.wait</code></td>
<td>
<p>defaults to false, for blocking receive. Set to TRUE for non-blocking receive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value sent from the remote server or NULL on failure.
If dont.wait was TRUE and a message was not immediately
available for receipt, NULL is returned and get.zmq.errno() is set to 11
or get.zmq.strerror() is set to EAGAIN.
</p>


<h3>Author(s)</h3>

<p>ZMQ was written by Martin Sustrik &lt;sustrik@250bpm.com&gt; and Martin Lucina &lt;mato@kotelna.sk&gt;.
rzmq was written by Whit Armstrong.
</p>


<h3>References</h3>

<p>http://www.zeromq.org
http://api.zeromq.org
http://zguide.zeromq.org/page:all
</p>


<h3>See Also</h3>

<p><code><a href="#topic+connect.socket">connect.socket</a>,<a href="#topic+bind.socket">bind.socket</a>,<a href="#topic+receive.socket">receive.socket</a>,<a href="#topic+send.socket">send.socket</a>,<a href="#topic+poll.socket">poll.socket</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(rzmq)

remote.exec &lt;- function(out.socket,in.socket,fun,...) {
    send.socket(out.socket,data=list(fun=fun,args=list(...)))
    receive.socket(in.socket)
}

context = init.context()
out.socket = init.socket(context,"ZMQ_PUSH")
bind.socket(out.socket,"tcp://*:5557")

in.socket = init.socket(context,"ZMQ_PULL")
bind.socket(in.socket,"tcp://*:5558")


myfun &lt;- function(x) {
    sum(abs(x))
}

remote.exec(out.socket,in.socket,myfun,rnorm(1e3))


## End(Not run)</code></pre>

<hr>
<h2 id='send.multipart'>Send multipart ZMQ message.</h2><span id='topic+send.multipart'></span>

<h3>Description</h3>

<p>Queue a list of raw vectors to be sent as a series of ZMQ message parts. Each
part before the last will be sent with the SNDMORE flag.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>send.multipart(socket, parts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="send.multipart_+3A_socket">socket</code></td>
<td>
<p>The ZMQ socket on which to send data</p>
</td></tr>
<tr><td><code id="send.multipart_+3A_parts">parts</code></td>
<td>
<p>A list of raw vectors; each component will be sent
as one part of the message, in the order of the list</p>
</td></tr>
</table>

<hr>
<h2 id='send.socket'>
send a message.
</h2><span id='topic+send.socket'></span><span id='topic+send.null.msg'></span><span id='topic+send.raw.string'></span><span id='topic+send.message.object'></span>

<h3>Description</h3>

<p>Queue the message referenced by the msg argument to be sent to the socket referenced by the socket argument. 
</p>
<p>A successful invocation of send.socket does not indicate that the message has been transmitted to the network, only that it has been queued on the socket and ZMQ has assumed responsibility for the message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>send.socket(socket, data, send.more=FALSE, serialize=TRUE, xdr=.Platform$endian=="big")
send.null.msg(socket, send.more=FALSE)
send.raw.string(socket,data,send.more=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="send.socket_+3A_socket">socket</code></td>
<td>
<p>a zmq socket object</p>
</td></tr>
<tr><td><code id="send.socket_+3A_data">data</code></td>
<td>
<p>the R object to be sent</p>
</td></tr>
<tr><td><code id="send.socket_+3A_send.more">send.more</code></td>
<td>
<p>whether this message has more frames to be sent</p>
</td></tr>
<tr><td><code id="send.socket_+3A_serialize">serialize</code></td>
<td>
<p>whether to call serialize before sending the data</p>
</td></tr>
<tr><td><code id="send.socket_+3A_xdr">xdr</code></td>
<td>
<p>passed directly to serialize command if serialize is requested</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean indicating success or failure of the operation.
</p>


<h3>Author(s)</h3>

<p>ZMQ was written by Martin Sustrik &lt;sustrik@250bpm.com&gt; and Martin Lucina &lt;mato@kotelna.sk&gt;.
rzmq was written by Whit Armstrong.
</p>


<h3>References</h3>

<p>http://www.zeromq.org
http://api.zeromq.org
http://zguide.zeromq.org/page:all
</p>


<h3>See Also</h3>

<p><code><a href="#topic+connect.socket">connect.socket</a>,<a href="#topic+bind.socket">bind.socket</a>,<a href="#topic+receive.socket">receive.socket</a>,<a href="#topic+send.socket">send.socket</a>,<a href="#topic+poll.socket">poll.socket</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## remote execution server in rzmq
library(rzmq)
context = init.context()
in.socket = init.socket(context,"ZMQ_PULL")
bind.socket(in.socket,"tcp://*:5557")

out.socket = init.socket(context,"ZMQ_PUSH")
bind.socket(out.socket,"tcp://*:5558")

while(1) {
   msg = receive.socket(in.socket)
   fun &lt;- msg$fun
   args &lt;- msg$args
   print(args)
   ans &lt;- do.call(fun,args)
   send.socket(out.socket,ans)
}

## End(Not run)</code></pre>

<hr>
<h2 id='socket.options'>
set a socket option.
</h2><span id='topic+set.hwm'></span><span id='topic+set.swap'></span><span id='topic+set.affinity'></span><span id='topic+set.identity'></span><span id='topic+subscribe'></span><span id='topic+unsubscribe'></span><span id='topic+set.rate'></span><span id='topic+set.recovery.ivl'></span><span id='topic+set.recovery.ivl.msec'></span><span id='topic+set.mcast.loop'></span><span id='topic+set.sndbuf'></span><span id='topic+set.rcvbuf'></span><span id='topic+set.linger'></span><span id='topic+set.reconnect.ivl'></span><span id='topic+set.zmq.backlog'></span><span id='topic+set.reconnect.ivl.max'></span><span id='topic+get.rcvmore'></span><span id='topic+get.last.endpoint'></span><span id='topic+get.send.timeout'></span><span id='topic+set.send.timeout'></span><span id='topic+get.rcv.timeout'></span><span id='topic+set.rcv.timeout'></span>

<h3>Description</h3>

<p>The zmq_setsockopt() function shall set the option specified by the
option_name argument to the value pointed to by the option_value
argument for the ZMQ socket pointed to by the socket argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.hwm(socket, option.value)
set.swap(socket, option.value)
set.affinity(socket, option.value)
set.identity(socket, option.value)
subscribe(socket, option.value)
unsubscribe(socket, option.value)
set.rate(socket, option.value)
set.recovery.ivl(socket, option.value)
set.recovery.ivl.msec(socket, option.value)
set.mcast.loop(socket, option.value)
set.sndbuf(socket, option.value)
set.rcvbuf(socket, option.value)
set.linger(socket, option.value)
set.reconnect.ivl(socket, option.value)
set.zmq.backlog(socket, option.value)
set.reconnect.ivl.max(socket, option.value)
get.rcvmore(socket)
get.last.endpoint(socket)
get.send.timeout(socket)
set.send.timeout(socket, option.value)
get.rcv.timeout(socket)
set.rcv.timeout(socket, option.value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="socket.options_+3A_socket">socket</code></td>
<td>
<p>a zmq socket object</p>
</td></tr>
<tr><td><code id="socket.options_+3A_option.value">option.value</code></td>
<td>
<p>the new option value to bet set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean indicating success or failure of the operation or in the
case of getsocketoptions, the value of the requsted option.
</p>


<h3>Author(s)</h3>

<p>ZMQ was written by Martin Sustrik &lt;sustrik@250bpm.com&gt; and Martin Lucina &lt;mato@kotelna.sk&gt;.
rzmq was written by Whit Armstrong.
</p>


<h3>References</h3>

<p>http://www.zeromq.org
http://api.zeromq.org
http://zguide.zeromq.org/page:all
</p>


<h3>See Also</h3>

<p><code><a href="#topic+connect.socket">connect.socket</a>,<a href="#topic+bind.socket">bind.socket</a>,<a href="#topic+receive.socket">receive.socket</a>,<a href="#topic+send.socket">send.socket</a>,<a href="#topic+poll.socket">poll.socket</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(rzmq)
context = init.context()
socket = init.socket(context,"ZMQ_REQ")

set.hwm(socket, 1L)
set.swap(socket, 100L)
set.identity(socket, "big.ass.socket")

## End(Not run)</code></pre>

<hr>
<h2 id='zmq.error'>
get libzmq error numbers and error strings
</h2><span id='topic+zmq.errno'></span><span id='topic+zmq.strerror'></span>

<h3>Description</h3>

<p>return the error number or error description after a zmq call
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zmq.errno()
zmq.strerror()
</code></pre>


<h3>Value</h3>

<p>an integer for zmq.errno or a string for zmq.strerror
</p>


<h3>Author(s)</h3>

<p>ZMQ was written by Martin Sustrik &lt;sustrik@250bpm.com&gt; and Martin Lucina &lt;mato@kotelna.sk&gt;.
rzmq was written by Whit Armstrong.
</p>


<h3>References</h3>

<p>http://www.zeromq.org
http://api.zeromq.org
http://zguide.zeromq.org/page:all
</p>


<h3>See Also</h3>

<p><code><a href="#topic+connect.socket">connect.socket</a>,<a href="#topic+bind.socket">bind.socket</a>,<a href="#topic+receive.socket">receive.socket</a>,<a href="#topic+send.socket">send.socket</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(rzmq)
zmq.errno()
zmq.strerror()

## End(Not run)</code></pre>

<hr>
<h2 id='zmq.version'>
get version of libzmq
</h2><span id='topic+zmq.version'></span>

<h3>Description</h3>

<p>return the version string of the system zmq library
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zmq.version()
</code></pre>


<h3>Value</h3>

<p>a string of the following format: major.minor.patch
</p>


<h3>Author(s)</h3>

<p>ZMQ was written by Martin Sustrik &lt;sustrik@250bpm.com&gt; and Martin Lucina &lt;mato@kotelna.sk&gt;.
rzmq was written by Whit Armstrong.
</p>


<h3>References</h3>

<p>http://www.zeromq.org
http://api.zeromq.org
http://zguide.zeromq.org/page:all
</p>


<h3>See Also</h3>

<p><code><a href="#topic+connect.socket">connect.socket</a>,<a href="#topic+bind.socket">bind.socket</a>,<a href="#topic+receive.socket">receive.socket</a>,<a href="#topic+send.socket">send.socket</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(rzmq)
zmq.version()

## End(Not run)</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
