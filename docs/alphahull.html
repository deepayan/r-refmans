<!DOCTYPE html><html><head><title>Help for package alphahull</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {alphahull}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ahull'><p>alpha-convex hull calculation</p></a></li>
<li><a href='#ahull_track'><p>alpha-convex hull calculation of tracking data</p></a></li>
<li><a href='#alphahull-package'>
<p>Generalization of the Convex Hull of a Sample of Points in the Plane</p></a></li>
<li><a href='#anglesArc'><p>Angles of the extremes of an arc</p></a></li>
<li><a href='#arc'><p>Add an arc to a plot</p></a></li>
<li><a href='#areaahull'><p> Area of the alpha-convex hull</p></a></li>
<li><a href='#areaahulleval'><p> Area of the alpha-convex hull</p></a></li>
<li><a href='#ashape'><p>alpha-shape calculation</p></a></li>
<li><a href='#complement'><p>Complement of the alpha-convex hull</p></a></li>
<li><a href='#delvor'><p> Delaunay triangulation and Voronoi diagram</p></a></li>
<li><a href='#dummycoor'><p>Semi-infinite edge of the Voronoi diagram</p></a></li>
<li><a href='#dw'><p>Devroye-Wise estimator</p></a></li>
<li><a href='#dw_track'><p>RBM-sausage calculation of tracking data</p></a></li>
<li><a href='#inahull'><p>Determines for one or more points whether they belong to the alpha-convex hull</p></a></li>
<li><a href='#inter'><p>Intersection of two circumferences</p></a></li>
<li><a href='#koch'>
<p>Construct a Kock snowflake curve</p></a></li>
<li><a href='#lengthahull'><p>Length of the boundary of the alpha-convex hull</p></a></li>
<li><a href='#plot.ahull'><p>Plot the alpha-convex hull</p></a></li>
<li><a href='#plot.ashape'><p>Plot the alpha-shape</p></a></li>
<li><a href='#plot.delvor'><p>Plot the Voronoi diagram and Delaunay traingulation</p></a></li>
<li><a href='#rkoch'><p>Random generation on a Koch snowflake curve</p></a></li>
<li><a href='#rotation'><p>Clockwise rotation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-16</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalization of the Convex Hull of a Sample of Points in the
Plane</td>
</tr>
<tr>
<td>Author:</td>
<td>Beatriz Pateiro-Lopez [aut, cre], Alberto Rodriguez-Casal, [aut].</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Beatriz Pateiro-Lopez &lt;beatriz.pateiro@usc.es&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, interp, R.utils, sgeostat, spatstat.geom,
spatstat.random, splancs</td>
</tr>
<tr>
<td>Description:</td>
<td>Computation of the alpha-shape and alpha-convex
        hull of a given sample of points in the plane. The concepts of
        alpha-shape and alpha-convex hull generalize the definition of
        the convex hull of a finite set of points. The programming is
        based on the duality between the Voronoi diagram and Delaunay
        triangulation. The package also includes a function that
        returns the Delaunay mesh of a given sample of points and its
        dual Voronoi diagram in one single object.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-16 16:31:03 UTC; beatriz</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-16 17:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ahull'>alpha-convex hull calculation</h2><span id='topic+ahull'></span>

<h3>Description</h3>

<p>This function calculates the <code class="reqn">\alpha</code>-convex hull of a given sample of points in the plane for <code class="reqn">\alpha&gt;0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ahull(x, y = NULL, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ahull_+3A_x">x</code>, <code id="ahull_+3A_y">y</code></td>
<td>
<p>The <code>x</code> and <code>y</code> arguments provide the <code>x</code> and <code>y</code> coordinates of a set of points. Alternatively, a single argument <code>x</code> can be provided, see Details.</p>
</td></tr>
<tr><td><code id="ahull_+3A_alpha">alpha</code></td>
<td>
<p>Value of <code class="reqn">\alpha</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An attempt is made to interpret the arguments x and y in a way suitable for computing the <code class="reqn">\alpha</code>-convex hull. Any reasonable way of defining the coordinates is acceptable, see <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code>. 
</p>
<p>The <code class="reqn">\alpha</code>-convex hull is defined for any finite number of points. However, since the algorithm is based on the Delaunay triangulation, at least three non-collinear points are required. 
</p>
<p>If <code>y</code> is NULL and <code>x</code> is an object of class <code>"delvor"</code>, then the <code class="reqn">\alpha</code>-convex hull is computed with no need to invoke again the function <code><a href="#topic+delvor">delvor</a></code> (it reduces the computational cost). 
</p>
<p>The complement of the <code class="reqn">\alpha</code>-convex hull can be written as the union of <code class="reqn">O(n)</code> open balls and halfplanes, see <code><a href="#topic+complement">complement</a></code>. 
The boundary of the <code class="reqn">\alpha</code>-convex hull is formed by arcs of open balls of radius <code class="reqn">\alpha</code> (besides possible isolated sample points). The arcs are determined by the intersections of some of the balls that define the complement of the <code class="reqn">\alpha</code>-convex hull. The extremes of an arc are given by <code class="reqn">c+rA_\theta v</code> and <code class="reqn">c+rA_{-\theta}v</code> where <code class="reqn">c</code> and <code class="reqn">r</code> represent the center and radius of the arc, repectively, and <code class="reqn">A_\theta v</code> represents the clockwise rotation of angle <code class="reqn">\theta</code> of the unitary vector <code class="reqn">v</code>. Joining the end points of adjacent arcs we can define polygons that help us to determine the area of the estimator , see <code><a href="#topic+areaahull">areaahull</a></code>.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>arcs</code></td>
<td>
<p>For each arc in the boundary of the <code class="reqn">\alpha</code>-convex hull, the columns of the matrix <code>arcs</code> store the center <code class="reqn">c</code> and radius <code class="reqn">r</code> of the arc, the unitary vector <code class="reqn">v</code>, the angle <code class="reqn">\theta</code> that define the arc and the indices of the end points, see Details. The coordinates of the end points of the arcs are stored in <code>xahull</code>. For isolated points in the boundary of the <code class="reqn">\alpha</code>-convex hull, columns 3 to 6 of the matrix <code>arcs</code> are equal to zero. </p>
</td></tr>
<tr><td><code>xahull</code></td>
<td>
<p>A 2-column matrix with the coordinates of the original set of points besides possible new end points of the arcs in the boundary of the <code class="reqn">\alpha</code>-convex hull.</p>
</td></tr>
<tr><td><code>length</code></td>
<td>
<p>Length of the boundary of the <code class="reqn">\alpha</code>-convex hull, see <code><a href="#topic+lengthahull">lengthahull</a></code>.</p>
</td></tr>  
<tr><td><code>complement</code></td>
<td>
<p>Output matrix from <code><a href="#topic+complement">complement</a></code>.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>Value of <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code>ashape.obj</code></td>
<td>
<p>Object of class <code>"ashape"</code> returned by the function <code><a href="#topic+ashape">ashape</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Edelsbrunner, H., Kirkpatrick, D.G. and Seidel, R. (1983). On the shape of a set of points in the plane. <em>IEEE Transactions on Information Theory</em>, 29(4), pp.551-559.
</p>
<p>Rodriguez-Casal, R. (2007). Set estimation under convexity type assumptions. <em>Annales de l'I.H.P.- Probabilites &amp; Statistiques</em>, 43, pp.763-774.
</p>
<p>Pateiro-Lopez, B. (2008). <em>Set estimation under convexity type restrictions</em>. Phd. Thesis. Universidad de Santiago de Compostela. ISBN 978-84-9887-084-8.</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.ahull">plot.ahull</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Random sample in the unit square
x &lt;- matrix(runif(100), nc = 2)
# Value of alpha
alpha &lt;- 0.2
# Alpha-convex hull
ahull.obj &lt;- ahull(x, alpha = alpha)
plot(ahull.obj)

# Uniform sample of size n=300 in the annulus B(c,0.5)\B(c,0.25), 
# with c=(0.5,0.5). 
n &lt;- 300
theta&lt;-runif(n,0,2*pi)
r&lt;-sqrt(runif(n,0.25^2,0.5^2))
x&lt;-cbind(0.5+r*cos(theta),0.5+r*sin(theta))
# Value of alpha
alpha &lt;- 0.1
# Alpha-convex hull
ahull.obj &lt;- ahull(x, alpha = alpha)
# The arcs defining the boundary of the alpha-convex hull are ordered
plot(x)
for (i in 1:dim(ahull.obj$arcs)[1]){
arc(ahull.obj$arcs[i,1:2],ahull.obj$arcs[i,3],ahull.obj$arcs[i,4:5],
ahull.obj$arcs[i,6],col=2)
Sys.sleep(0.5)
}

# Random sample  from a uniform distribution on a Koch snowflake 
# with initial side length 1 and 3 iterations
x &lt;- rkoch(2000, side = 1, niter = 3)
# Value of alpha
alpha &lt;- 0.05
# Alpha-convex hull
ahull.obj &lt;- ahull(x, alpha = alpha)
plot(ahull.obj)

## End(Not run)
</code></pre>

<hr>
<h2 id='ahull_track'>alpha-convex hull calculation of tracking data</h2><span id='topic+ahull_track'></span>

<h3>Description</h3>

<p>This function approximates the <code class="reqn">\alpha</code>-convex hull of tracking data and returns a list of geom_path objects of the boundary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ahull_track(x, y = NULL, alpha, nps = 10000, sc = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ahull_track_+3A_x">x</code>, <code id="ahull_track_+3A_y">y</code></td>
<td>
<p>The <code>x</code> and <code>y</code> arguments provide the <code>x</code> and <code>y</code> coordinates of a set of points. Alternatively, a single argument <code>x</code> can be provided, see Details.</p>
</td></tr>
<tr><td><code id="ahull_track_+3A_alpha">alpha</code></td>
<td>
<p>Value of <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code id="ahull_track_+3A_nps">nps</code></td>
<td>
<p>Number of points to generate in each segment connecting two locations, see Details</p>
</td></tr>
<tr><td><code id="ahull_track_+3A_sc">sc</code></td>
<td>
<p>Scale factor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An attempt is made to interpret the arguments x and y in a way suitable for computing the <code class="reqn">\alpha</code>-convex hull. Any reasonable way of defining the coordinates is acceptable, see <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code>. 
</p>
<p>Increase <code>nps</code> if the trajectory is not contained in the computed estimator.
</p>


<h3>Value</h3>

<p>A list of geom_path objects defining the boundary of the <code class="reqn">\alpha</code>-convex
</p>


<h3>References</h3>

<p>Cholaquidis, A., Fraiman, R., Lugosi, G. and Pateiro-Lopez, B. (2014) Set estimation from reflected Brownian motion. <em>arXiv:1411.0433</em>.
</p>
<p>Wikelski, M., and Kays, R. (2014). Movebank: archive, analysis and sharing of animal movement data. World Wide Web electronic publication.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(move)
library(ggmap)
# Data from Movebank
# Study Name: Dunn Ranch Bison Tracking Project
# Principal Investigator: Stephen Blake, Randy Arndt, Doug Ladd
# Max Planck Institute for Ornithology Radolfzell Germany
study &lt;- "Dunn Ranch Bison Tracking Project" 
cainfo &lt;- system.file("CurlSSL", "cacert.pem", package = "RCurl")
options(RCurlOptions = list(verbose = FALSE, capath = cainfo, ssl.verifypeer = FALSE))
# Login to movebank (first create the login object) 
curl &lt;- movebankLogin(username = "xxx", password = "zzz") 
# Downloads study stored in Movebank
track &lt;- getMovebankData(study = study, login = curl) 
dat &lt;- track@data[track@data[, "deployment_id"] == 13848432,]
# Map of animal locations 
bbox &lt;- ggmap::make_bbox(dat[,"location_long"], dat[,"location_lat"], f = 0.3) 
map_loc &lt;- get_map(location = bbox, source = "google", maptype = 'satellite')  
map &lt;- ggmap(map_loc, extent = 'panel', maprange=FALSE) 
p &lt;- map + geom_path(data = dat, aes(x = location_long, y = location_lat), col=2, size=0.3)
p
ah_gp &lt;- ahull_track(x = dat[, c("location_long", "location_lat")], alpha = 0.005)
p + ah_gp

## End(Not run)
</code></pre>

<hr>
<h2 id='alphahull-package'>
Generalization of the Convex Hull of a Sample of Points in the Plane
</h2><span id='topic+alphahull-package'></span>

<h3>Description</h3>

<p>Computation of the <code class="reqn">\alpha</code>-shape and <code class="reqn">\alpha</code>-convex hull of a given sample of points in the plane. The concepts of <code class="reqn">\alpha</code>-shape and <code class="reqn">\alpha</code>-convex hull generalize the definition of the convex hull of a finite set of points. The programming is based on the duality between the Voronoi diagram and Delaunay triangulation. The package also includes a function that returns the Delaunay mesh of a given sample of points and its dual Voronoi diagram in one single object.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> alphahull</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.5</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-06-16</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> R functions: 	GPL-2 | GPL-3
</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Beatriz Pateiro-Lopez, Alberto Rodriguez-Casal.
</p>
<p>Maintainer: Beatriz Pateiro-Lopez &lt;beatriz.pateiro@usc.es&gt;
</p>

<hr>
<h2 id='anglesArc'>Angles of the extremes of an arc</h2><span id='topic+anglesArc'></span>

<h3>Description</h3>

<p>Given a vector <code class="reqn">v</code> and an angle <code class="reqn">\theta</code>, <code>anglesArc</code> returns the angles that <code class="reqn">A_\theta v</code> and <code class="reqn">A_{-\theta} v</code> form with the axis <em>OX</em>, where <code class="reqn">A_\theta v</code> represents the clockwise rotation of angle <code class="reqn">\theta</code> of the vector <code class="reqn">v</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anglesArc(v, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anglesArc_+3A_v">v</code></td>
<td>
<p>Vector <code class="reqn">v</code> in the plane.</p>
</td></tr>
<tr><td><code id="anglesArc_+3A_theta">theta</code></td>
<td>
<p>Angle <code class="reqn">\theta</code> (in radians).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The angle that forms the vector <code class="reqn">v</code> with the axis <em>OX</em> takes its value in <code class="reqn">[0,2\pi)</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>angs</code></td>
<td>
<p>Numeric vector with two components.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Let v=c(0,1) and theta=pi/4
# Consider the arc such that v is the internal angle bisector that 
# divides the angle 2*theta into two equal angles
# The angles that the arc forms with the OX axis are pi/4 and 3*pi/4
v &lt;- c(0,1)
theta &lt;- pi/4
anglesArc(v,theta)

## End(Not run)
</code></pre>

<hr>
<h2 id='arc'>Add an arc to a plot</h2><span id='topic+arc'></span>

<h3>Description</h3>

<p>This function adds the arc of <code class="reqn">B(c,r)</code> between the angles that <code class="reqn">A_\theta v</code> and <code class="reqn">A_{-\theta} v</code> form with the axis <em>OX</em>, where <code class="reqn">A_\theta v</code> represents the clockwise rotation of angle <code class="reqn">\theta</code> of the vector <code class="reqn">v</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arc(c, r, v, theta, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arc_+3A_c">c</code></td>
<td>
<p> Center <code class="reqn">c</code> of the arc. </p>
</td></tr>
<tr><td><code id="arc_+3A_r">r</code></td>
<td>
<p> Radius <code class="reqn">r</code> of the arc. </p>
</td></tr>
<tr><td><code id="arc_+3A_v">v</code></td>
<td>
<p> Vector <code class="reqn">v</code> in the plane. </p>
</td></tr>
<tr><td><code id="arc_+3A_theta">theta</code></td>
<td>
<p> Angle <code class="reqn">\theta</code> (in radians).</p>
</td></tr>
<tr><td><code id="arc_+3A_...">...</code></td>
<td>
<p> Arguments to be passed to methods, such as graphical parameters (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plot.ahull">plot.ahull</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Plot of the circumference of radius 1
theta &lt;- seq(0, 2*pi, length = 100)
r &lt;- 1
plot(r*cos(theta), r*sin(theta), type = "l")
# Add in red the arc between pi/4 and 3*pi/4
arc(c(0,0), 1, c(0,1), pi/4, col = 2, lwd = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='areaahull'> Area of the alpha-convex hull
</h2><span id='topic+areaahull'></span>

<h3>Description</h3>

<p>This function calculates the area of the <code class="reqn">\alpha</code>-convex hull of a sample of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>areaahull(x, timeout = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="areaahull_+3A_x">x</code></td>
<td>
<p>Object of class <code>"ahull"</code>.</p>
</td></tr>
<tr><td><code id="areaahull_+3A_timeout">timeout</code></td>
<td>
<p>A numeric specifying the maximum number of seconds the expression is allowed to run before being interrupted by the timeout.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>area</code></td>
<td>
<p>Area of the <code class="reqn">\alpha</code>-convex hull. If the area cannot be computed, the output will be NA with a warning.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ahull">ahull</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Random sample in the unit square
x &lt;- matrix(runif(500), nc = 2)
# Value of alpha
alpha &lt;- 1
# alpha-convex hull
ahull.obj &lt;- ahull(x, alpha = alpha)
# Area of the alpha-convex hull
areaahull(ahull.obj)

## End(Not run)
</code></pre>

<hr>
<h2 id='areaahulleval'> Area of the alpha-convex hull
</h2><span id='topic+areaahulleval'></span>

<h3>Description</h3>

<p>This function calculates the area of the <code class="reqn">\alpha</code>-convex hull of a sample of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>areaahulleval(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="areaahulleval_+3A_x">x</code></td>
<td>
<p>Object of class <code>"ahull"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>area</code></td>
<td>
<p>Area of the <code class="reqn">\alpha</code>-convex hull. </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ahull">ahull</a></code>.</p>

<hr>
<h2 id='ashape'>alpha-shape calculation</h2><span id='topic+ashape'></span>

<h3>Description</h3>

<p>This function calculates the <code class="reqn">\alpha</code>-shape of a given sample for <code class="reqn">\alpha&gt;0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ashape(x, y = NULL, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ashape_+3A_x">x</code>, <code id="ashape_+3A_y">y</code></td>
<td>
<p>The <code>x</code> and <code>y</code> coordinates of a set of points. Alternatively, a single argument <code>x</code> can be provided, see Details.</p>
</td></tr>
<tr><td><code id="ashape_+3A_alpha">alpha</code></td>
<td>
<p>Value of <code class="reqn">\alpha</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An attempt is made to interpret the arguments x and y in a way suitable for computing the <code class="reqn">\alpha</code>-shape, see <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code>. 
</p>
<p>The <code class="reqn">\alpha</code>-shape is defined for any finite number of points. However, since the algorithm is based on the Delaunay triangulation, at least three non-collinear points are required. 
</p>
<p>If <code>y</code> is NULL and <code>x</code> is an object of class <code>"delvor"</code>, then the <code class="reqn">\alpha</code>-shape is computed without invoking again the function <code><a href="#topic+delvor">delvor</a></code> (it reduces the computational cost). 
</p>
<p>The function <code><a href="#topic+ashape">ashape</a></code> returns (among other values) the matrix <code>edges</code>. The structure of <code>edges</code> is that of matrix <code>mesh</code> returned by the function <code><a href="#topic+delvor">delvor</a></code>. Note that the <code class="reqn">\alpha</code>-shape is a subgraph of the Delaunay triangulation and, therefore, <code>edges</code> is a submatrix of <code>mesh</code>.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>edges</code></td>
<td>
<p>A <em>n.seg</em>-row matrix with the coordinates and indexes of the edges of the Delaunay triangulation that form the <code class="reqn">\alpha</code>-shape. The number of rows <em>n.seg</em> coincides with the number of segments of the <code class="reqn">\alpha</code>-shape. The matrix also includes information of the Voronoi extremes corresponding to each segment.</p>
</td></tr>
<tr><td><code>length</code></td>
<td>
<p>Length of the <code class="reqn">\alpha</code>-shape.</p>
</td></tr>  
<tr><td><code>alpha</code></td>
<td>
<p>Value of <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code>alpha.extremes</code></td>
<td>
<p>Vector with the indexes of the sample points that are <code class="reqn">\alpha</code>-extremes. See Edelsbrunnner <em>et al.</em> (1983).</p>
</td></tr>
<tr><td><code>delvor.obj</code></td>
<td>
<p>Object of class <code>"delvor"</code> returned by the <code><a href="#topic+delvor">delvor</a></code> function.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>A 2-column matrix with the coordinates of the set of points.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Edelsbrunner, H., Kirkpatrick, D.G. and Seidel, R. (1983). On the shape of a set of points in the plane. <em>IEEE Transactions on Information Theory</em>, 29(4), pp.551-559.</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.ashape">plot.ashape</a></code>, <code><a href="#topic+delvor">delvor</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Uniform sample of size n=300 in the annulus B(c,0.5)\B(c,0.25), 
# with c=(0.5,0.5). 
n &lt;- 300
theta&lt;-runif(n,0,2*pi)
r&lt;-sqrt(runif(n,0.25^2,0.5^2))
x&lt;-cbind(0.5+r*cos(theta),0.5+r*sin(theta))
# Value of alpha
alpha &lt;- 0.1
# alpha-shape 
ashape.obj &lt;- ashape(x, alpha = alpha)
# If we change the value of alpha there is no need to compute
# again the Delaunay triangulation and Voronoi Diagram
alpha &lt;- 0.4
ashape.obj.new &lt;- ashape(ashape.obj$delvor.obj, alpha = alpha)

# Random sample  from a uniform distribution on a Koch snowflake 
# with initial side length 1 and 3 iterations
x &lt;- rkoch(2000, side = 1, niter = 3)
# Value of alpha
alpha &lt;- 0.05
# alpha-shape 
ashape.obj &lt;- ashape(x, alpha = alpha)

## End(Not run)
</code></pre>

<hr>
<h2 id='complement'>Complement of the alpha-convex hull</h2><span id='topic+complement'></span>

<h3>Description</h3>

<p>This function calculates the complement of the <code class="reqn">\alpha</code>-convex hull of a given sample for <code class="reqn">\alpha&gt;0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complement(x, y = NULL, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complement_+3A_x">x</code>, <code id="complement_+3A_y">y</code></td>
<td>
<p>The <code>x</code> and <code>y</code> arguments provide the <code>x</code> and <code>y</code> coordinates of a set of points. Alternatively, a single argument <code>x</code> can be provided, see Details.</p>
</td></tr>
<tr><td><code id="complement_+3A_alpha">alpha</code></td>
<td>
<p>Value of <code class="reqn">\alpha</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An attempt is made to interpret the arguments x and y in a way suitable for computing the <code class="reqn">\alpha</code>-shape. Any reasonable way of defining the coordinates is acceptable, see <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code>. 
</p>
<p>If <code>y</code> is NULL and <code>x</code> is an object of class <code>"delvor"</code>, then the complement of the <code class="reqn">\alpha</code>-convex hull is computed with no need to invoke again the function <code><a href="#topic+delvor">delvor</a></code> (it reduces the computational cost). 
</p>
<p>The complement of the <code class="reqn">\alpha</code>-convex hull is calculated as a union of open balls and halfplanes that do not contain any point of the sample. See Edelsbrunnner <em>et al.</em> (1983) for a basic description of the algorithm. The construction of the complement is based on the Delaunay triangulation and Voronoi diagram of the sample, provided by the function <code><a href="#topic+delvor">delvor</a></code>. The function <code><a href="#topic+complement">complement</a></code> returns a matrix <code>compl</code>. For each row <code>i</code>,  <code>compl[i,]</code> contains the information relative to an open ball or halfplane of the complement. The first three columns are assigned to the characterization of the ball or halfplane <code>i</code>. The information relative to the edge of the Delaunay triangulation that generates the ball or halfplane <code>i</code> is contained in <code>compl[i,4:16]</code>. Thus, if the row <code>i</code> refers to an open ball, <code>compl[i,1:3]</code> contains the center and radius of the ball. Furthermore,  <code>compl[i,17:18]</code> and <code>compl[i,19]</code> refer to the unitary vector <code class="reqn">v</code> and the angle <code class="reqn">\theta</code> that characterize the arc that joins the two sample points that define the ball <code>i</code>. If the row <code>i</code> refers to a halfplane, <code>compl[i,1:3]</code> determines its equation. For the halfplane <code class="reqn">y&gt;a+bx</code>, <code>compl[i,1:3]=(a,b,-1)</code>. In the same way,   for the halfplane <code class="reqn">y&lt;a+bx</code>, <code>compl[i,1:3]=(a,b,-2)</code>, for the halfplane <code class="reqn">x&gt;a</code>, <code>compl[i,1:3]=(a,0,-3)</code> and for the halfplane <code class="reqn">x&lt;a</code>, <code>compl[i,1:3]=(a,0,-4)</code>.  
</p>


<h3>Value</h3>

<table>
<tr><td><code>compl</code></td>
<td>
<p>Output matrix. For each row <code>i</code>,  <code>compl[i,]</code> contains the information relative to an open ball or halfplane of the complement of the <code class="reqn">\alpha</code>-convex hull, see Details.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Edelsbrunner, H., Kirkpatrick, D.G. and Seidel, R. (1983) On the shape of a set of points in the plane. <em>IEEE Transactions on Information Theory</em>, 29(4), pp.551-559.</p>


<h3>See Also</h3>

<p><code><a href="#topic+delvor">delvor</a></code>, <code><a href="#topic+ahull">ahull</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Random sample in the unit square
x &lt;- matrix(runif(100), nc = 2)
# Value of alpha
alpha &lt;- 0.2
# Complement of the alpha-convex hull
compl &lt;- complement(x, alpha = alpha)

## End(Not run)
</code></pre>

<hr>
<h2 id='delvor'> Delaunay triangulation and Voronoi diagram</h2><span id='topic+delvor'></span>

<h3>Description</h3>

<p>This function returns a matrix with information about the Delaunay triangulation and Voronoi diagram of a given sample. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delvor(x, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delvor_+3A_x">x</code>, <code id="delvor_+3A_y">y</code></td>
<td>
<p>The <code>x</code> and <code>y</code> arguments provide the <code>x</code> and <code>y</code> coordinates of a set of points. Alternatively, a single argument <code>x</code> can be provided, see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An attempt is made to interpret the arguments x and y in a way suitable for computing the Delaunay triangulation and Voronoi diagram . Any reasonable way of defining the coordinates is acceptable, see <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code>. 
</p>
<p>The function <code><a href="interp.html#topic+tri.mesh">tri.mesh</a></code> from package <span class="pkg">interp</span> calculates the Delaunay triangulation of at least three non-collinear points. Using the Delaunay triangulation, the function <code>delvor</code> calculates the correspondig Voronoi diagram. For each edge of the Delaunay triangulation there is a segment in the Voronoi diagram, given by the union of the circumcenters of the two neighbour triangles that share the edge. For those triangles with edges on the convex hull, the corresponding line in the Voronoi diagram is a semi-infinite segment, whose boundless extreme is calculated by the function <code><a href="#topic+dummycoor">dummycoor</a></code>. The function <code>delvor</code> returns the sample, the output object of class <code>"triSht"</code> from the function <code><a href="interp.html#topic+tri.mesh">tri.mesh</a></code> and a matrix <code>mesh</code> with all the necessary information of the Delaunay triangulation and Voronoi diagram. Thus, for each edge of the Delaunay triangulation the output matrix contains the indexes and coordinates of the sample points that form the edge, the indexes and coordinates of the extremes of the corresponding segment in the Voronoi diagram, and an indicator that takes the value 1 for those extremes of the Voronoi diagram that represent a boundless extreme.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>mesh</code></td>
<td>
<p>A <code class="reqn">n.edges</code>-row matrix, where <code class="reqn">n.edges</code> is the total number of different edges of the Delaunay triangulation.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>A 2-column matrix with the coordinates of the sample points.</p>
</td></tr>
<tr><td><code>tri.obj</code></td>
<td>
<p>Object of class <code>"tri"</code>. See <code><a href="interp.html#topic+tri.mesh">tri.mesh</a></code> in package <span class="pkg">interp</span>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Renka, R. J. (1996). Algorithm 751: TRIPACK: a constrained two-dimensional Delaunay triangulation package, <em>ACM Trans. Math. Softw.</em>, 22(1), pp.1-8.</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.delvor">plot.delvor</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Random sample in the unit square
x &lt;- matrix(runif(20), nc = 2)
# Delaunay triangulation and Voronoi diagram calculation
delvor.obj &lt;- delvor(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='dummycoor'>Semi-infinite edge of the Voronoi diagram</h2><span id='topic+dummycoor'></span>

<h3>Description</h3>

<p>This function determines fictitious coordinates for the boundless extreme of a semi-infinite edge of the Voronoi diagram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dummycoor(tri.obj, l1, l2, m, away)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dummycoor_+3A_tri.obj">tri.obj</code></td>
<td>
<p>Object of class <code>"triSht"</code>. See <code><a href="interp.html#topic+tri.mesh">tri.mesh</a></code> in package <span class="pkg">interp</span>.</p>
</td></tr>
<tr><td><code id="dummycoor_+3A_l1">l1</code></td>
<td>
<p> Index of the sample point correponding to one vertex of a triangle of Delaunay that lies on the convex hull, see Details.</p>
</td></tr>
<tr><td><code id="dummycoor_+3A_l2">l2</code></td>
<td>
<p> Index of the sample point correponding to other vertex of a triangle of Delaunay that lies on the convex hull, see Details.</p>
</td></tr>
<tr><td><code id="dummycoor_+3A_m">m</code></td>
<td>
<p> Index of the circumcenter of the triangle of Delaunay with one edge on the convex hull.</p>
</td></tr>
<tr><td><code id="dummycoor_+3A_away">away</code></td>
<td>
<p> Constant that determines how far away the fictitious boundless extreme is located.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When a triangle of the Delaunay triangulation has one of its edges (given by the segment that joins the sample points with indexes <code>l1</code> and <code>l2</code>) on the convex hull, the corresponding segment of the Voronoi diagram is semi-infinite. The finite extreme coincides with the circumcenter of the triangle and the direction of the line is given by the perpendicular bisector of the edge that lies on the convex hull. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>dum</code></td>
<td>
<p>Fictitious coordinates of the boundless extreme.</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+delvor">delvor</a></code>.</p>

<hr>
<h2 id='dw'>Devroye-Wise estimator</h2><span id='topic+dw'></span>

<h3>Description</h3>

<p>This function calculates the Devroye-Wise estimator of a given sample of points in the plane for <code class="reqn">\epsilon&gt;0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dw(x, y = NULL, eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dw_+3A_x">x</code>, <code id="dw_+3A_y">y</code></td>
<td>
<p>The <code>x</code> and <code>y</code> arguments provide the <code>x</code> and <code>y</code> coordinates of a set of points. Alternatively, a single argument <code>x</code> can be provided, see Details.</p>
</td></tr>
<tr><td><code id="dw_+3A_eps">eps</code></td>
<td>
<p>Value of <code class="reqn">\epsilon</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An attempt is made to interpret the arguments x and y in a way suitable for computing the Devroye-Wise estimator. Any reasonable way of defining the coordinates is acceptable, see <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code>. 
</p>


<h3>Value</h3>

<p>Given a sample of points in the plane, the estimator is defined as union of balls of radius <code class="reqn">\epsilon</code> with centers in the sample points. For each arc in the boundary of the Devroye-Wise estimator, the columns of the output matrix store the center <code class="reqn">c</code> and radius <code class="reqn">r</code> of the arc, the unitary vector <code class="reqn">v</code>, the angle <code class="reqn">\theta</code> that define the arc and the indices of the end points.
</p>


<h3>References</h3>

<p>Devroye, L. and Wise, G. (1980) Detection of abnormal behaviour via nonparametric estimation of the support. <em>SIAM J. Appl. Math.</em> 3, pp. 480-488.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Uniform sample of size n = 200 in the annulus B(c, 0.5)\B(c, 0.25), 
# with c = (0.5, 0.5).
n &lt;- 200
theta &lt;- runif(n, 0, 2*pi)
r &lt;- sqrt(runif(n, 0.25^2, 0.5^2))
x &lt;- cbind(0.5 + r*cos(theta), 0.5 + r*sin(theta))
eps &lt;- 0.05
dw.obj &lt;- dw(x, eps = eps)
plot(x)
for(i in 1:dim(dw.obj)[1]){arc(dw.obj[i, 1:2], eps, dw.obj[i, 4:5], dw.obj[i, 6])}

## End(Not run)
</code></pre>

<hr>
<h2 id='dw_track'>RBM-sausage calculation of tracking data</h2><span id='topic+dw_track'></span>

<h3>Description</h3>

<p>This function approximates the RBM-sausage of tracking data and returns a list of geom_path objects of the boundary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dw_track(x, y = NULL, eps, nps = 20000, sc = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dw_track_+3A_x">x</code>, <code id="dw_track_+3A_y">y</code></td>
<td>
<p>The <code>x</code> and <code>y</code> arguments provide the <code>x</code> and <code>y</code> coordinates of a set of points. Alternatively, a single argument <code>x</code> can be provided, see Details.</p>
</td></tr>
<tr><td><code id="dw_track_+3A_eps">eps</code></td>
<td>
<p>Value of <code class="reqn">\epsilon</code>.</p>
</td></tr>
<tr><td><code id="dw_track_+3A_nps">nps</code></td>
<td>
<p>Number of points to generate in each segment connecting two locations, see Details.</p>
</td></tr>
<tr><td><code id="dw_track_+3A_sc">sc</code></td>
<td>
<p>Scale factor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An attempt is made to interpret the arguments x and y in a way suitable for computing the RBM-sausage. Any reasonable way of defining the coordinates is acceptable, see <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code>. 
Given a trajectory in the plane, the estimator is defined as the set of points whose distance to the trajectory is less than or equal to <code class="reqn">\epsilon</code> (this estimator is analogous to the one of Devroye and Wise (1980) for i.i.d. data). Increase <code>nps</code> if the trajectory is not contained in the computed estimator.
</p>


<h3>Value</h3>

<p>A list of geom_path objects defining the boundary of the estimator
</p>


<h3>References</h3>

<p>Cholaquidis, A., Fraiman, R., Lugosi, G. and Pateiro-Lopez, B. (2014) Set estimation from reflected Brownian motion. <em>arXiv:1411.0433</em>.
</p>
<p>Devroye, L. and Wise, G. (1980) Detection of abnormal behaviour via nonparametric estimation of the support. <em>SIAM J. Appl. Math.</em> 3, pp. 480-488.
</p>
<p>Wikelski, M., and Kays, R. (2014). Movebank: archive, analysis and sharing of animal movement data. World Wide Web electronic publication.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(move)
library(ggmap)
# Data from Movebank
# Study Name: Dunn Ranch Bison Tracking Project
# Principal Investigator: Stephen Blake, Randy Arndt, Doug Ladd
# Max Planck Institute for Ornithology Radolfzell Germany
study &lt;- "Dunn Ranch Bison Tracking Project" 
cainfo &lt;- system.file("CurlSSL", "cacert.pem", package = "RCurl")
options(RCurlOptions = list(verbose = FALSE, capath = cainfo, ssl.verifypeer = FALSE))
# Login to movebank (first create the login object) 
curl &lt;- movebankLogin(username = "xxx", password = "zzz") 
# Downloads study stored in Movebank
track &lt;- getMovebankData(study = study, login = curl) 
dat &lt;- track@data[track@data[, "deployment_id"] == 13848432,]
# Map of animal locations 
bbox &lt;- ggmap::make_bbox(dat[,"location_long"], dat[,"location_lat"], f = 0.3) 
map_loc &lt;- get_map(location = bbox, source = "google", maptype = 'satellite')  
map &lt;- ggmap(map_loc, extent = 'panel', maprange=FALSE) 
p &lt;- map + geom_path(data = dat, aes(x = location_long, y = location_lat), col=2, size=0.3)
p
ah_dw &lt;- dw_track(x = dat[, c("location_long", "location_lat")], eps = 0.001)
p + ah_dw

## End(Not run)
</code></pre>

<hr>
<h2 id='inahull'>Determines for one or more points whether they belong to the alpha-convex hull</h2><span id='topic+inahull'></span>

<h3>Description</h3>

<p>This function determines for one or more points <code class="reqn">p</code> whether they belong to the <code class="reqn">\alpha</code>-convex hull of a sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inahull(ahull.obj, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inahull_+3A_ahull.obj">ahull.obj</code></td>
<td>
<p>Object of class <code>"ahull"</code> returned by the funcion <code><a href="#topic+ahull">ahull</a></code>.</p>
</td></tr>
<tr><td><code id="inahull_+3A_p">p</code></td>
<td>
<p>Numeric vector with two components describing a point in the plane or two-column matrix of points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The complement of the <code class="reqn">\alpha</code>-convex hull of a sample is calculated by <code><a href="#topic+complement">complement</a></code>. The function <code><a href="#topic+inahull">inahull</a></code> checks whether each point in <code class="reqn">p</code> belongs to any of the open balls or halfplanes that define the complement. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>in.ahull</code></td>
<td>
<p>A logical vector specifying whether each point in <code class="reqn">p</code> belongs to the <code class="reqn">\alpha</code>-convex hull.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ahull">ahull</a></code>, <code><a href="#topic+complement">complement</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Random sample in the unit square
x &lt;- matrix(runif(100), nc = 2)
# Value of alpha
alpha &lt;- 0.2
# alpha-convex hull
ahull.obj &lt;- ahull(x, alpha = alpha)
# Check if the point (0.5, 0.5) belongs to the alpha-convex hull
inahull(ahull.obj, p = c(0.5, 0.5))
# Check if the points (0.5, 0.5) and (2, 2) belong to the alpha-convex hull
inahull(ahull.obj, p = rbind(c(0.5, 0.5), c(2, 2)))

## End(Not run)
</code></pre>

<hr>
<h2 id='inter'>Intersection of two circumferences</h2><span id='topic+inter'></span>

<h3>Description</h3>

<p>This function calculates the intersection of two circumferences, given their centers and radius <code class="reqn">c1,r1</code> and <code class="reqn">c2,r2</code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inter(c11, c12, r1, c21, c22, r2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inter_+3A_c11">c11</code></td>
<td>
<p><em>X</em>-coordinate of the center <code class="reqn">c1</code>.</p>
</td></tr>
<tr><td><code id="inter_+3A_c12">c12</code></td>
<td>
<p><em>Y</em>-coordinate of the center <code class="reqn">c1</code>.</p>
</td></tr>
<tr><td><code id="inter_+3A_r1">r1</code></td>
<td>
<p> Radius <code class="reqn">r1</code>.</p>
</td></tr>
<tr><td><code id="inter_+3A_c21">c21</code></td>
<td>
<p><em>X</em>-coordinate of the center <code class="reqn">c2</code>.</p>
</td></tr>
<tr><td><code id="inter_+3A_c22">c22</code></td>
<td>
<p><em>Y</em>-coordinate of the center <code class="reqn">c2</code>.</p>
</td></tr>
<tr><td><code id="inter_+3A_r2">r2</code></td>
<td>
<p> Radius <code class="reqn">r2</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>inter</code> is internally called by the function <code><a href="#topic+ahull">ahull</a></code>. 
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>n.cut</code></td>
<td>
<p>Number of intersection points (0,1,2, or Inf).</p>
</td></tr>
<tr><td><code>v1</code></td>
<td>
<p>If there are two intersection points, <code>v1</code> is the numeric vector whose components are the coordinates of the unitary vector that has its origin in <code class="reqn">c1</code> and it's perpendicular to the chord that joins the intersection points of the two circumferences. Otherwise, <code>v1=(0,0)</code></p>
</td></tr>
<tr><td><code>theta1</code></td>
<td>
<p>Angle that forms <code>v1</code> with the radius that joins the center <code class="reqn">c1</code> with an intersection point. </p>
</td></tr>
<tr><td><code>v2</code></td>
<td>
<p>If there are two intersection points, <code>v2</code> is the numeric vector whose components are the coordinates of the unitary vector that has its origin in <code class="reqn">c2</code> and it's perpendicular to the chord that joins the intersection points of the two circumferences. Otherwise, <code>v2=(0,0)</code></p>
</td></tr>
<tr><td><code>theta2</code></td>
<td>
<p>Angle that forms <code>v2</code> with the radius that joins the center <code class="reqn">c2</code> with an intersection point.</p>
</td></tr>
</table>

<hr>
<h2 id='koch'>
Construct a Kock snowflake curve
</h2><span id='topic+koch'></span>

<h3>Description</h3>

<p>This function uses recursion to construct a Kock snowflake curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>koch(side = 3, niter = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="koch_+3A_side">side</code></td>
<td>
<p>Side length of the initial equilateral triangle.
</p>
</td></tr>
<tr><td><code id="koch_+3A_niter">niter</code></td>
<td>
<p>Number of iterations in the development of the snowflake curve.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Koch snowflake is a fractal curve described by the Swedish mathematician Helge von Koch in 1904. It is built by starting with an equilateral triangle, removing the inner third of each side, building another equilateral triangle at the location where the side was removed, and then repeating the process.
</p>


<h3>Value</h3>

<table>
<tr><td><code>vertices</code></td>
<td>
<p>A 2-column matrix with the coordinates of the snowflake vertices.</p>
</td></tr>
</table>


<h3>References</h3>

<p>von Koch, H. (1904). Sur une courbe continue sans tangente, obtenue par une construction geometrique elementaire. <em>Arkiv for Matematik</em>, 1, pp.681-704.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rkoch">rkoch</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# The first four iterations of a Koch snowflake 
# with side length of the initial equilateral triangle equal to 3.
vertices &lt;- koch(side = 2, niter = 4)
plot(vertices[, 1], vertices[, 2], type = "l", asp = TRUE, 
main = "Koch snowflake", xlab = "", ylab = "", col = 4)
polygon(vertices[, 1], vertices[, 2] , col = 4)

## End(Not run)
</code></pre>

<hr>
<h2 id='lengthahull'>Length of the boundary of the alpha-convex hull</h2><span id='topic+lengthahull'></span>

<h3>Description</h3>

<p>This function calculates the length of the boundary of the <code class="reqn">\alpha</code>-convex hull of a given sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lengthahull(ahull.arcs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lengthahull_+3A_ahull.arcs">ahull.arcs</code></td>
<td>
<p>Output matrix of arcs returned by <code><a href="#topic+ahull">ahull</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>lengthahull</code> is internally called by the function <code><a href="#topic+ahull">ahull</a></code>. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>length</code></td>
<td>
<p>Length of the boundary of the <code class="reqn">\alpha</code>-convex hull.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ahull">ahull</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Random sample in the unit square
x &lt;- matrix(runif(100), nc = 2)
# Value of alpha
alpha &lt;- 0.2
# alpha-convex hull
ahull.obj &lt;- ahull(x, alpha = alpha)
# Length of the alpha-convex hull
ahull.obj$length

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.ahull'>Plot the alpha-convex hull</h2><span id='topic+plot.ahull'></span>

<h3>Description</h3>

<p>This function returns a plot of the <code class="reqn">\alpha</code>-convex hull. If desired, it also adds the Delaunay triangulation, Voronoi diagram and <code class="reqn">\alpha</code>-shape of the sample. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ahull'
plot(x, add = FALSE, do.shape = FALSE, 
	wlines = c("none", "both", "del", "vor"), wpoints = TRUE, 
	number = FALSE, col = NULL, xlim = NULL, 
	ylim = NULL, lwd = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ahull_+3A_x">x</code></td>
<td>
<p>Object of class <code>"ahull"</code>.</p>
</td></tr>
<tr><td><code id="plot.ahull_+3A_add">add</code></td>
<td>
<p>Logical, if TRUE add to a current plot.</p>
</td></tr> 
<tr><td><code id="plot.ahull_+3A_do.shape">do.shape</code></td>
<td>
<p>Logical, indicates if the <code class="reqn">\alpha</code>-shape should also be plotted.</p>
</td></tr>
<tr><td><code id="plot.ahull_+3A_wlines">wlines</code></td>
<td>
<p>&quot;Which lines?&quot;. I.e. should the Delaunay triangulation be plotted (wlines='del'), should the Voronoi diagram be plotted (wlines='vor'), should both be plotted (wlines='both'), or none (wlines='none', the default)?</p>
</td></tr>
<tr><td><code id="plot.ahull_+3A_wpoints">wpoints</code></td>
<td>
<p>Logical, indicates if sample points should be plotted.</p>
</td></tr>
<tr><td><code id="plot.ahull_+3A_number">number</code></td>
<td>
<p>Logical, defaulting to FALSE; if TRUE then the points plotted will be labelled with their index numbers.</p>
</td></tr>  
<tr><td><code id="plot.ahull_+3A_col">col</code></td>
<td>
<p>The colour numbers for plotting the <code class="reqn">\alpha</code>-convex hull, <code class="reqn">\alpha</code>-shape, data points, Delaunay triangulation, Voronoi diagram, and the point numbers, in that order; defaults to c(1,1,1,1,1,1). If fewer than six numbers are given, they are recycled. (If more than six numbers are given, the redundant ones are ignored.)</p>
</td></tr>
<tr><td><code id="plot.ahull_+3A_xlim">xlim</code></td>
<td>
<p>The limits on the x-axis.</p>
</td></tr>  
<tr><td><code id="plot.ahull_+3A_ylim">ylim</code></td>
<td>
<p>The limits on the y-axis.</p>
</td></tr>
<tr><td><code id="plot.ahull_+3A_lwd">lwd</code></td>
<td>
<p>The line widths for plotting the tesselations, the <code class="reqn">\alpha</code>-shape, and the <code class="reqn">\alpha</code>-convex hull, in that order; defaults to c(1,1,2).</p>
</td></tr>
<tr><td><code id="plot.ahull_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods, such as graphical parameters (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ahull">ahull</a></code>, <code><a href="#topic+ashape">ashape</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Random sample in the unit square
x &lt;- matrix(runif(100), nc = 2)
# Value of alpha
alpha &lt;- 0.2
# alpha-convex hull
ahull.obj &lt;- ahull(x, alpha = alpha)
# Plot including the alpha-convex hull in pink, alpha-shape in blue, 
# sample points in black, voronoi diagram in green 
# and Delaunay triangulation in red 
plot(ahull.obj, do.shape = TRUE, wlines = "both", col = c(6, 4, 1, 2, 3))

# Random sample  from a uniform distribution on a Koch snowflake 
# with initial side length 1 and 3 iterations
x &lt;- rkoch(2000, side = 1, niter = 3)
# Value of alpha
alpha &lt;- 0.05
# Alpha-convex hull
ahull.obj &lt;- ahull(x, alpha = alpha)
plot(ahull.obj)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.ashape'>Plot the alpha-shape</h2><span id='topic+plot.ashape'></span>

<h3>Description</h3>

<p>This function returns a plot of the <code class="reqn">\alpha</code>-shape. If desired, it also adds the Delaunay triangulation and Voronoi diagram of the sample. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ashape'
plot(x, add = FALSE, wlines = c("none", "both", "del", "vor"),
	wpoints = TRUE, number = FALSE, col = NULL, 
	xlim = NULL, ylim = NULL, lwd = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ashape_+3A_x">x</code></td>
<td>
<p>Object of class <code>"ashape"</code>.</p>
</td></tr>
<tr><td><code id="plot.ashape_+3A_add">add</code></td>
<td>
<p>Logical, if TRUE add to a current plot.</p>
</td></tr> 
<tr><td><code id="plot.ashape_+3A_wlines">wlines</code></td>
<td>
<p>&quot;Which lines?&quot;. I.e. should the Delaunay triangulation be plotted (wlines='del'), should the Voronoi diagram be plotted (wlines='vor'), should both be plotted (wlines='both'), or none (wlines='none', the default)?</p>
</td></tr>
<tr><td><code id="plot.ashape_+3A_wpoints">wpoints</code></td>
<td>
<p>Logical, indicates if sample points should be plotted.</p>
</td></tr>
<tr><td><code id="plot.ashape_+3A_number">number</code></td>
<td>
<p>Logical, defaulting to FALSE; if TRUE then the points plotted will be labelled with their index numbers.</p>
</td></tr>  
<tr><td><code id="plot.ashape_+3A_col">col</code></td>
<td>
<p>The colour numbers for plotting the <code class="reqn">\alpha</code>-shape, data points, Delaunay triangulation, Voronoi diagram, and the point numbers, in that order; defaults to c(1,1,1,1,1). If fewer than five numbers are given, they are recycled. (If more than five numbers are given, the redundant ones are ignored.)</p>
</td></tr>
<tr><td><code id="plot.ashape_+3A_xlim">xlim</code></td>
<td>
<p>The limits on the x-axis.</p>
</td></tr>  
<tr><td><code id="plot.ashape_+3A_ylim">ylim</code></td>
<td>
<p>The limits on the y-axis.</p>
</td></tr>
<tr><td><code id="plot.ashape_+3A_lwd">lwd</code></td>
<td>
<p>The line widths for plotting the tesselations and the <code class="reqn">\alpha</code>-shape; defaults to c(1,2).</p>
</td></tr>
<tr><td><code id="plot.ashape_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods, such as graphical parameters (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ashape">ashape</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Uniform sample of size n=300 in the annulus B(c, 0.5)\B(c, 0.25) 
# with c=(0.5, 0.5). 
n &lt;- 300
theta&lt;-runif(n,0,2*pi)
r&lt;-sqrt(runif(n,0.25^2,0.5^2))
x&lt;-cbind(0.5+r*cos(theta),0.5+r*sin(theta))
# Value of alpha
alpha &lt;- 0.1
# alpha-shape 
ashape.obj &lt;- ashape(x, alpha = alpha)
# Plot alpha-shape in blue, sample points in black, 
# and Delaunay triangulation in red
plot(ashape.obj, wlines= "del", col = c(4, 1, 2))

# Random sample  from a uniform distribution on a Koch snowflake 
# with initial side length 1 and 3 iterations
x &lt;- rkoch(2000, side = 1, niter = 3)
# Value of alpha
alpha &lt;- 0.05
# alpha-shape 
ashape.obj &lt;- ashape(x, alpha = alpha)
# Plot alpha-shape in blue
plot(ashape.obj, col = c(4, 1))

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.delvor'>Plot the Voronoi diagram and Delaunay traingulation</h2><span id='topic+plot.delvor'></span>

<h3>Description</h3>

<p>This function returns a plot of the Voronoi diagram and Delaunay traingulation. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'delvor'
plot(x, add = FALSE, wlines = c("both", "del", "vor"),
	wpoints = TRUE, number = FALSE, col = NULL, 
	xlim = NULL, ylim = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.delvor_+3A_x">x</code></td>
<td>
<p>An object of class <code>"delvor"</code> as constructed by the function delvor. </p>
</td></tr>
<tr><td><code id="plot.delvor_+3A_add">add</code></td>
<td>
<p>Logical, if TRUE add to a current plot.</p>
</td></tr> 
<tr><td><code id="plot.delvor_+3A_wlines">wlines</code></td>
<td>
<p>&quot;Which lines?&quot;. I.e. should the Delaunay triangulation be plotted (wlines='del'), should the Voronoi diagram be plotted (wlines='vor'), or should both be plotted (wlines='both', the default)?</p>
</td></tr>
<tr><td><code id="plot.delvor_+3A_wpoints">wpoints</code></td>
<td>
<p>Logical, indicates if sample points should be plotted.</p>
</td></tr>
<tr><td><code id="plot.delvor_+3A_number">number</code></td>
<td>
<p>Logical, defaulting to FALSE; if TRUE then the points plotted will be labelled with their index numbers.</p>
</td></tr>  
<tr><td><code id="plot.delvor_+3A_col">col</code></td>
<td>
<p>The colour numbers for plotting the data points, Delaunay triangulation, Voronoi diagram, and the point numbers, in that order; defaults to c(1,1,1,1). If fewer than four numbers are given, they are recycled. (If more than four numbers are given, the redundant ones are ignored.)</p>
</td></tr>
<tr><td><code id="plot.delvor_+3A_xlim">xlim</code></td>
<td>
<p>The limits on the x-axis.</p>
</td></tr>  
<tr><td><code id="plot.delvor_+3A_ylim">ylim</code></td>
<td>
<p>The limits on the y-axis.</p>
</td></tr>  
<tr><td><code id="plot.delvor_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods, such as graphical parameters (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+delvor">delvor</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Random sample in the unit square
x &lt;- matrix(runif(100), nc = 2)
# Delaunay triangulation and Voronoi diagram
delvor.obj &lt;- delvor(x)
# Plot Voronoi diagram and Delaunay triangulation 
plot(delvor.obj)

## End(Not run)
</code></pre>

<hr>
<h2 id='rkoch'>Random generation on a Koch snowflake curve</h2><span id='topic+rkoch'></span>

<h3>Description</h3>

<p>This function generates ramdom points from a uniform distribution on a Koch snowflake.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rkoch(n, side = 3, niter = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rkoch_+3A_n">n</code></td>
<td>

<p>Number of observations.
</p>
</td></tr>
<tr><td><code id="rkoch_+3A_side">side</code></td>
<td>

<p>Side length of the initial equilateral triangle of the Koch snowflake curve.
</p>
</td></tr>
<tr><td><code id="rkoch_+3A_niter">niter</code></td>
<td>
<p>Number of iterations in the development of the snowflake curve.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2-column matrix with the coordinates of generated points.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+koch">koch</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
unifkoch &lt;- rkoch(2000, side = 1, niter = 3)
plot(unifkoch, asp = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='rotation'>Clockwise rotation</h2><span id='topic+rotation'></span>

<h3>Description</h3>

<p>This function calculates the clockwise rotation of angle <code class="reqn">\theta</code> of a given vector <code class="reqn">v</code> in the plane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotation(v, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotation_+3A_v">v</code></td>
<td>
<p>Vector <code class="reqn">v</code> in the plane.</p>
</td></tr>
<tr><td><code id="rotation_+3A_theta">theta</code></td>
<td>
<p>Angle <code class="reqn">\theta</code> (in radians).</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>v.rot</code></td>
<td>
<p>Vector after rotation.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Rotation of angle pi/4 of the vector (0,1)
rotation(v = c(0, 1), theta = pi/4)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
