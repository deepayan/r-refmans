<!DOCTYPE html><html lang="en"><head><title>Help for package cocons</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cocons}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cocons-package'><p>Covariate-based Covariance Functions for Nonstationary Gaussian Processes</p></a></li>
<li><a href='#coco'><p>Creates a coco S4 object</p></a></li>
<li><a href='#coco-class'><p>An S4 class to store information</p></a></li>
<li><a href='#cocoOptim'><p>Optimizer for coco objects</p></a></li>
<li><a href='#cocoPredict'><p>Prediction for coco objects</p></a></li>
<li><a href='#cocoSim'><p>Marginal and conditional simulation of nonstationary Gaussian processes</p></a></li>
<li><a href='#cov_rns'><p>Dense covariance function (difference parameterization)</p></a></li>
<li><a href='#cov_rns_classic'><p>Dense covariance function (classic parameterization)</p></a></li>
<li><a href='#cov_rns_pred'><p>Dense covariance function</p></a></li>
<li><a href='#cov_rns_taper'><p>Sparse covariance function</p></a></li>
<li><a href='#cov_rns_taper_pred'><p>Sparse covariance function</p></a></li>
<li><a href='#getAIC'><p>Retrieve AIC</p></a></li>
<li><a href='#getBIC'><p>Retrieve BIC</p></a></li>
<li><a href='#getBoundaries'><p>Simple build of boundaries</p></a></li>
<li><a href='#getBoundariesV2'><p>Simple build of boundaries (v2)</p></a></li>
<li><a href='#getBoundariesV3'><p>Simple build of boundaries (v3)</p></a></li>
<li><a href='#getCIs'><p>Compute approximate confidence intervals for a coco object</p></a></li>
<li><a href='#getCovMatrix'><p>Covariance matrix for &quot;coco&quot; class</p></a></li>
<li><a href='#getCRPS'><p>Based on a set of predictions computes the Continuous Ranked Probability Score</p></a></li>
<li><a href='#getDensityFromDelta'><p>Based on a specific taper scale (delta), retrieves the density of the covariance matrix.</p></a></li>
<li><a href='#getDesignMatrix'><p>Create an efficient design matrix based on a list of aspect models</p></a></li>
<li><a href='#getEstims'><p>Retrieve estimates from a fitted coco object</p></a></li>
<li><a href='#getHessian'><p>getHessian</p></a></li>
<li><a href='#getLoglik'><p>Retrieve the loglikelihood value</p></a></li>
<li><a href='#getLogScore'><p>Based on a set of predictions computes the Log-Score</p></a></li>
<li><a href='#getModelLists'><p>Builds the necessary input for building covariance matrices</p></a></li>
<li><a href='#getModHess'><p>Retrieves the modified inverse of the hessian</p></a></li>
<li><a href='#GetNeg2loglikelihood'><p>GetNeg2loglikelihood</p></a></li>
<li><a href='#GetNeg2loglikelihoodProfile'><p>GetNeg2loglikelihoodProfile</p></a></li>
<li><a href='#GetNeg2loglikelihoodREML'><p>GetNeg2loglikelihoodREML</p></a></li>
<li><a href='#GetNeg2loglikelihoodTaper'><p>GetNeg2loglikelihoodTaper</p></a></li>
<li><a href='#GetNeg2loglikelihoodTaperProfile'><p>GetNeg2loglikelihoodTaperProfile</p></a></li>
<li><a href='#getScale'><p>Fast and simple standardization for the design matrix.</p></a></li>
<li><a href='#getSpatEffects'><p>Evaluates the spatially-varying functions from a coco object at locs</p></a></li>
<li><a href='#getSpatMean'><p>Computes the spatial mean of a (fitted) coco object</p></a></li>
<li><a href='#holes'><p>Holes Data Set</p></a></li>
<li><a href='#holes_bm'><p>Holes with trend + multiple realizations Data Set</p></a></li>
<li><a href='#is.formula'><p>check whether an R object is a formula</p></a></li>
<li><a href='#plot+2Ccoco+2Cmissing-method'><p>Plot Method for coco objects</p></a></li>
<li><a href='#plotOptimInfo'><p>Plot log info detailed</p></a></li>
<li><a href='#stripes'><p>Stripes Data Set</p></a></li>
<li><a href='#summary'><p>Summary Method for Coco Class</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Covariate-Based Covariance Functions for Nonstationary Spatial
Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Author:</td>
<td>Federico Blasi <a href="https://orcid.org/0000-0001-9337-7154"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Reinhard Furrer <a href="https://orcid.org/0000-0002-6319-2332"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Federico Blasi &lt;federico.blasi@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimation, prediction, and simulation of nonstationary Gaussian process with modular covariate-based covariance functions. 
  Sources of nonstationarity, such as spatial mean, variance, geometric anisotropy, smoothness, and nugget, can be considered based on spatial characteristics. 
  An induced compact-supported nonstationary covariance function is provided, enabling fast and memory-efficient computations when handling densely sampled domains.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.10), spam (&ge; 2.9.1), fields, optimParallel,
methods, knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, BH</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/blasif/cocons/issues">https://github.com/blasif/cocons/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-12 12:49:31 UTC; blasi</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-12 14:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cocons-package'>Covariate-based Covariance Functions for Nonstationary Gaussian Processes</h2><span id='topic+cocons-package'></span><span id='topic+cocons'></span>

<h3>Description</h3>

<p>Provides routines and methods for estimating and predicting nonstationary Gaussian process models with modular covariate-based covariance functions. Several sources of nonstationarity can be modeled based on spatial information, including a spatial mean, marginal standard deviation, local geometric anisotropy, local nugget, and spatially varying smoothness. Each of these components is modeled separately. An induced compact-supported nonstationary covariance function is provided to speed up computations when handling densly sampled domains. Model parameters are estimated via maximum likelihood (and flavours of it, such as penalized and profile maximum likelihood). A variety of functions are also included to compute prediction metrics and to visualize, simulate, and summarize these types of models. Details of the models can be found in the vignette and in <a href="#topic+coco">coco</a>.
</p>


<h3>Disclaimer</h3>

<p>This package is provided &quot;as is&quot; without warranty of any kind, either express or implied.
Backwards compatibility will not be offered until later versions.
</p>


<h3>Author(s)</h3>

<p>Federico Blasi [aut, cre], <a href="mailto:federico.blasi@gmail.com">federico.blasi@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    vignette("cocons", package = "cocons")
    methods(class = "coco")
  
## End(Not run)
</code></pre>

<hr>
<h2 id='coco'>Creates a coco S4 object</h2><span id='topic+coco'></span>

<h3>Description</h3>

<p>Creates an S4 object of class <code>coco</code>, which is the centerpiece of the <span class="pkg">cocons</span> package. The function provides a set of consistency checks for ensuring the suitability of the different objects involved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coco(type, data, locs, z, model.list, info, output = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coco_+3A_type">type</code></td>
<td>
<p>(<code>character</code>) One of two available types <code>"dense"</code> or <code>"sparse"</code>. See description.</p>
</td></tr>
<tr><td><code id="coco_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>) A <code>data.frame</code> with covariates information, where <code>colnames(data)</code> matches model.list specification.</p>
</td></tr>
<tr><td><code id="coco_+3A_locs">locs</code></td>
<td>
<p>(<code>matrix</code>) A <code>matrix</code> with spatial locations.</p>
</td></tr>
<tr><td><code id="coco_+3A_z">z</code></td>
<td>
<p>(<code>vector</code> or <code>matrix</code>) A matrix of <code class="reqn">n \times r</code> response realizations, one realization per column. When considering only one realization, a vector can also be provided.</p>
</td></tr>
<tr><td><code id="coco_+3A_model.list">model.list</code></td>
<td>
<p>(<code>list</code>) A <code>list</code> specifying a model for each source of nonstationarity.</p>
</td></tr>
<tr><td><code id="coco_+3A_info">info</code></td>
<td>
<p>(<code>list</code> or <code>NULL</code>) A <code>list</code> specifying characteristics of the coco object.</p>
</td></tr>
<tr><td><code id="coco_+3A_output">output</code></td>
<td>
<p>(<code>list</code> or <code>NULL</code>) Empty or the resulting object from running <a href="optimParallel.html#topic+optimParallel">optimParallel</a>, adding to this a list with boundary information (see <a href="#topic+getBoundaries">getBoundaries</a> to check the expected structure).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two types of <code>coco</code> objects are available, each assuming a different type of covariance matrix for the Gaussian process.
Type <code>"dense"</code> builds dense covariance matrices (non zero elements), while type <code>"sparse"</code> builds sparse covariance
matrices by tapering the dense covariance matrix with a compact isotropic compact-supported correlation matrix [1].
Type <code>"sparse"</code> allows a set of efficient algorithms, thus making it more suitable for large sample sizes.
</p>
<p>An important component of the <code>coco</code> S4 class is the <code>model.list</code> specification, involving individual formulas provided as a list, where each of them specifies a covariate-based parametric model for a specific source of nonstationarity.
It involves <code>"mean"</code> for the spatial mean, the <code>"std.dev"</code> for the marginal standard deviation,
<code>"scale"</code>, <code>"aniso"</code> and <code>"tilt"</code>, each of them shaping specific aspects of the local spatial geometrically anisotropy structure,
<code>"smooth"</code> handling local smoothness, and <code>"nugget"</code> handling the local nugget effect. The models are defined as:</p>

<table>
<tr>
 <td style="text-align: left;">
   Source </td><td style="text-align: left;"> Related to </td><td style="text-align: left;"> Description </td><td style="text-align: left;"> Model </td>
</tr>
<tr>
 <td style="text-align: left;">
   <em>mean</em> </td><td style="text-align: left;"> <code class="reqn">\mu</code> </td><td style="text-align: left;"> Spatial mean function </td><td style="text-align: left;"> <code class="reqn">\boldsymbol{X}_1\boldsymbol{\beta}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <em>std.dev</em> </td><td style="text-align: left;"> <code class="reqn">\sigma^{X}</code> </td><td style="text-align: left;"> Marginal standard deviation </td><td style="text-align: left;"> <code class="reqn">\text{exp}(0.5 \boldsymbol{X}_2 \boldsymbol{\alpha})</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <em>scale</em> </td><td style="text-align: left;"> <code class="reqn">\boldsymbol{\Sigma}^{X}</code> </td><td style="text-align: left;"> Local scale </td><td style="text-align: left;"> <code class="reqn">\text{exp}(\boldsymbol{X}_3 \boldsymbol{\theta}_1)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <em>aniso</em> </td><td style="text-align: left;"> <code class="reqn">\boldsymbol{\Sigma}^{X}</code> </td><td style="text-align: left;"> Local geometric anisotropy </td><td style="text-align: left;"> <code class="reqn">\text{exp}(\boldsymbol{X}_4 \boldsymbol{\theta}_2)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <em>tilt</em> </td><td style="text-align: left;"> <code class="reqn">\boldsymbol{\Sigma}^{X}</code> </td><td style="text-align: left;"> (Restricted) local tilt </td><td style="text-align: left;"> <code class="reqn">\cos(\text{logit}^{-1}(\boldsymbol{X}_5 \boldsymbol{\theta}_3))</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <em>smooth</em> </td><td style="text-align: left;"> <code class="reqn">\nu^{X}</code> </td><td style="text-align: left;"> Local smoothness </td><td style="text-align: left;"> <code class="reqn">(\nu_{u} - \nu_{l})/(1+\text{exp}(-\boldsymbol{X}_6 \boldsymbol{\phi})) + \nu_{l}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <em>nugget</em> </td><td style="text-align: left;"> <code class="reqn">\sigma^{X}_{\epsilon}</code> </td><td style="text-align: left;"> Local micro-scale variability </td><td style="text-align: left;"> <code class="reqn">\text{exp}(\boldsymbol{X}_7 \boldsymbol{\zeta})</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>where <code class="reqn">\boldsymbol{\beta}</code>, <code class="reqn">\boldsymbol{\alpha}</code>, <code class="reqn">\boldsymbol{\theta}_1</code>, <code class="reqn">\boldsymbol{\theta}_2</code>, <code class="reqn">\boldsymbol{\theta}_3</code>, <code class="reqn">\boldsymbol{\phi}</code>, and <code class="reqn">\boldsymbol{\zeta}</code> are the parameter vectors of each model,
<code class="reqn">\nu_{l}</code>, and <code class="reqn">\nu_{u}</code> are the lower and upper bounds limiting the range of variation of the spatially-varying smoothness, and where <code class="reqn">\boldsymbol{X}_{\ell}</code> relates to the design matrix defined by the specific models for each of the source of nonstationarity.
</p>
<p>Lastly, arguments for the <code>"info"</code> list argument involve: </p>

<ul>
<li> <p><code>"lambda"</code>: (<code>numeric</code>) a positive scalar specifying the regularization parameter. Larger values penalizes highly-smoothed long-tailed covariance functions.
</p>
</li>
<li> <p><code>"smooth.limits"</code>: (<code>numeric vector</code>) specifying the range of variation for the spatially varying smoothness (e.g. c(0.5, 2.5)).
</p>
</li>
<li> <p><code>"taper"</code>: (<code>numeric</code>) specifying the desired taper function from the spam package (only for &quot;sparse&quot; coco objects).
</p>
</li>
<li> <p><code>"delta"</code>: (<code>numeric</code>) specifying the taper range/scale (only for &quot;sparse&quot; coco objects).
</p>
</li>
<li> <p><code>"skip.scale"</code>: (<code>integer vector</code>) By default, all covariates are scaled. <code>skip.scale</code> allows to specify the index of those variables in <code>data</code> that should not be scaled during the optimization.
</p>
</li></ul>



<h3>Value</h3>

<p>(<code>S4</code>) An S4 object of class <code>coco</code>.
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>


<h3>References</h3>

<p>[1] Furrer, Reinhard, Marc G. Genton, and Douglas Nychka.
<em>&quot;Covariance tapering for interpolation of large spatial datasets.&quot;</em>
Journal of Computational and Graphical Statistics 15.3 (2006): 502-523.
</p>


<h3>See Also</h3>

<p><code><a href="spam.html#topic+covmat">spam::cov.wend1()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
locs &lt;- expand.grid(seq(0,1,length.out = 10),
seq(0,1,length.out = 10))

toydata &lt;- data.frame('x' = locs[,1])

set.seed(1)
z &lt;- rnorm(100)

model.list &lt;- list('mean' = 0,
                   'std.dev' = formula( ~ 1),
                   'scale' = formula( ~ 1 + x),
                   'aniso' = 0,
                   'tilt' = 0,
                   'smooth' = 3/2,
                   'nugget' = -Inf)
                   
coco_object &lt;- coco(type = 'dense',
                    data = toydata,
                    locs = as.matrix(locs),
                    z = z,
                    model.list = model.list)

coco_object

## End(Not run)

</code></pre>

<hr>
<h2 id='coco-class'>An S4 class to store information</h2><span id='topic+coco-class'></span>

<h3>Description</h3>

<p>An S4 class to store information
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>(<code>character</code>) One of two available types &quot;dense&quot; or &quot;sparse&quot;. See description.</p>
</dd>
<dt><code>data</code></dt><dd><p>(<code>data.frame</code>) A data.frame with covariates information, where colnames(data) matches model.list specification</p>
</dd>
<dt><code>locs</code></dt><dd><p>(<code>numeric matrix</code>) a matrix with locs matching data</p>
</dd>
<dt><code>z</code></dt><dd><p>(<code>numeric matrix</code>) A matrix of dimension n x p with response values</p>
</dd>
<dt><code>model.list</code></dt><dd><p>(<code>list</code>) A list specifying a model for each aspect of the spatial structure.</p>
</dd>
<dt><code>info</code></dt><dd><p>(<code>list</code>) a list with information about the coco object</p>
</dd>
<dt><code>output</code></dt><dd><p>(<code>list</code>) if building an already fitted <code>coco</code> object (not the standard approach), then requires an output from Optimparallel output, including as well boundaries, etc.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>

<hr>
<h2 id='cocoOptim'>Optimizer for coco objects</h2><span id='topic+cocoOptim'></span>

<h3>Description</h3>

<p>Estimation the spatial model parameters using the L-BFGS-B optimizer [1].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cocoOptim(coco.object, boundaries = list(), ncores = "auto", safe = TRUE,
optim.type, optim.control)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cocoOptim_+3A_coco.object">coco.object</code></td>
<td>
<p>(<code>S4</code>) A <a href="#topic+coco">coco</a> object.</p>
</td></tr>
<tr><td><code id="cocoOptim_+3A_boundaries">boundaries</code></td>
<td>
<p>(<code>list</code>) If provided, a list containing lower, initial, and upper values for the parameters, as defined by <a href="#topic+getBoundaries">getBoundaries</a>. If not provided, these values are automatically computed with global lower and upper bounds set to -2 and 2.</p>
</td></tr>
<tr><td><code id="cocoOptim_+3A_ncores">ncores</code></td>
<td>
<p>(<code>character</code> or <code>integer</code>) The number of threads to use for the optimization. If set to <code>"auto"</code>, the number of threads is chosen based on system capabilities or a fraction of the available cores.</p>
</td></tr>
<tr><td><code id="cocoOptim_+3A_safe">safe</code></td>
<td>
<p>(<code>logical</code>) If <code>TRUE</code>, the function avoids Cholesky decomposition errors due to ill-posed covariance matrices by returning a pre-defined large value. Defaults to <code>TRUE</code>.
</p>

<ul>
<li> <p><code>"ml"</code>: Classical Maximum Likelihood estimation.
</p>
</li>
<li> <p><code>"pml"</code>: Profile Maximum Likelihood, factoring out the spatial trend for dense objects or the global marginal variance parameter for sparse objects.
</p>
</li></ul>
</td></tr>
<tr><td><code id="cocoOptim_+3A_optim.type">optim.type</code></td>
<td>
<p>(<code>character</code>) The optimization approach. Options include:</p>
</td></tr>
<tr><td><code id="cocoOptim_+3A_optim.control">optim.control</code></td>
<td>
<p>(<code>list</code>) A list of settings to be passed to the <a href="optimParallel.html#topic+optimParallel">optimParallel</a> function [2].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>S4</code>) An optimized S4 object of class <code>coco</code>.
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>


<h3>References</h3>

<p>[1] Byrd, Richard H., et al. <em>&quot;A limited memory algorithm for bound constrained optimization.&quot;</em>
SIAM Journal on scientific computing 16.5 (1995): 1190-1208.
</p>
<p>[2] Gerber, Florian, and Reinhard Furrer. <em>&quot;optimParallel: An R package providing a parallel version of the L-BFGS-B optimization method.&quot;</em>
R Journal 11.1 (2019): 352-358.
</p>


<h3>See Also</h3>

<p>[<a href="optimParallel.html#topic+optimParallel">optimParallel</a>]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
model.list &lt;- list('mean' = 0,
                   'std.dev' = formula( ~ 1 + cov_x + cov_y),
                   'scale' = formula( ~ 1 + cov_x + cov_y),
                   'aniso' = 0,
                   'tilt' = 0,
                   'smooth' = 3/2,
                   'nugget' = -Inf)
                   
coco_object &lt;- coco(type = 'dense',
                    data = holes[[1]][1:100,],
                    locs = as.matrix(holes[[1]][1:100,1:2]),
                    z = holes[[1]][1:100,]$z,
                    model.list = model.list)
                    
optim_coco &lt;- cocoOptim(coco_object,
boundaries = getBoundaries(coco_object,
lower.value = -3, 3))

plotOptimInfo(optim_coco)

plot(optim_coco)

plot(optim_coco, type = 'ellipse')

plot(optim_coco, type = 'correlations', index = c(2,3,5))

summary(optim_coco)
 
getEstims(optim_coco)


## End(Not run)

</code></pre>

<hr>
<h2 id='cocoPredict'>Prediction for coco objects</h2><span id='topic+cocoPredict'></span>

<h3>Description</h3>

<p>Computes the conditional expectation and standard errors based on the conditional Gaussian distribution for nonstationary spatial models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cocoPredict(coco.object, newdataset, newlocs, type = 'mean', ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cocoPredict_+3A_coco.object">coco.object</code></td>
<td>
<p>(<code>S4</code>) A fitted <a href="#topic+coco">coco</a> object.</p>
</td></tr>
<tr><td><code id="cocoPredict_+3A_newdataset">newdataset</code></td>
<td>
<p>(<code>data.frame</code>) A data.frame containing the covariates present in <code>model.list</code> at the prediction locations.</p>
</td></tr>
<tr><td><code id="cocoPredict_+3A_newlocs">newlocs</code></td>
<td>
<p>(<code>matrix</code>) A matrix specifying the prediction locations, matching <code>newdataset</code> index.</p>
</td></tr>
<tr><td><code id="cocoPredict_+3A_type">type</code></td>
<td>
<p>(<code>character</code>) Specifies whether to return only the point prediction (<code>'mean'</code>) or both the point prediction and prediction standard errors (<code>'pred'</code>).</p>
</td></tr>
<tr><td><code id="cocoPredict_+3A_...">...</code></td>
<td>
<p>Additional arguments. If <code>coco.object</code> contains multiple realizations, the argument <code>index.pred</code> can be used to specify which realization of <code>coco.object@z</code> should be used for predictions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>systematic</code>: The systematic component of the conditional expectation.
</p>
</li>
<li> <p><code>stochastic</code>: The stochastic component of the conditional expectation.
</p>
</li>
<li> <p><code>sd.pred</code>: The standard errors, when <code>type = 'pred'</code> is specified.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Federico Blasi
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Stationary model

model.list_stat &lt;- list('mean' = 0,
'std.dev' = formula( ~ 1),
'scale' = formula( ~ 1),
'aniso' = 0,
'tilt' = 0,
'smooth' = 3/2,
'nugget' = -Inf)

 
model.list_ns &lt;- list('mean' = 0,
'std.dev' = formula( ~ 1 + cov_x + cov_y),
'scale' = formula( ~ 1 + cov_x + cov_y),
'aniso' = 0,
'tilt' = 0,
'smooth' = 3/2,
'nugget' = -Inf)

coco_object &lt;- coco(type = 'dense',
data = holes[[1]][1:100, ],
locs = as.matrix(holes[[1]][1:100, 1:2]),
z = holes[[1]][1:100, ]$z,
model.list = model.list_stat)

optim_coco_stat &lt;- cocoOptim(coco_object,
boundaries = getBoundaries(coco_object,
lower.value = -3, 3))

coco_preds_stat &lt;- cocoPredict(optim_coco_stat, newdataset = holes[[2]],
newlocs = as.matrix(holes[[2]][, 1:2]),
type = "pred")

# Update model
coco_object@model.list &lt;- model.list_ns

optim_coco_ns &lt;- cocoOptim(coco_object,
boundaries = getBoundaries(coco_object,
lower.value = -3, 3))

coco_preds_ns &lt;- cocoPredict(optim_coco_ns, newdataset = holes[[2]],
newlocs = as.matrix(holes[[2]][, 1:2]),
type = "pred")

par(mfrow = c(1, 3))

fields::quilt.plot(main = "full data", holes[[1]][, 1:2], 
holes[[1]]$z, xlim = c(-1, 1), ylim = c(-1, 1))

fields::quilt.plot(main = "stationary se", holes[[2]][, 1:2], 
coco_preds_stat$sd.pred, xlim = c(-1, 1), ylim = c(-1, 1))
fields::quilt.plot(main = "nonstationary se", holes[[2]][, 1:2], 
coco_preds_ns$sd.pred, xlim = c(-1, 1), ylim = c(-1, 1))



## End(Not run)

</code></pre>

<hr>
<h2 id='cocoSim'>Marginal and conditional simulation of nonstationary Gaussian processes</h2><span id='topic+cocoSim'></span>

<h3>Description</h3>

<p>draw realizations of stationary and nonstationary Gaussian processes with covariate-based covariance functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cocoSim(coco.object, pars, n, seed, standardize, 
type = 'classic', sim.type = NULL, cond.info = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cocoSim_+3A_coco.object">coco.object</code></td>
<td>
<p>(<code>S4</code>) A <a href="#topic+coco">coco</a> object.</p>
</td></tr>
<tr><td><code id="cocoSim_+3A_pars">pars</code></td>
<td>
<p>(<code>numeric vector</code> or NULL) A vector of parameter values associated with <code>model.list</code>.
If coco.object is a fitted object, and pars is <code>NULL</code>, it get pars from coco.object\@output$pars (and also sets 'type' to 'diff').</p>
</td></tr>
<tr><td><code id="cocoSim_+3A_n">n</code></td>
<td>
<p>(<code>integer</code>) Number of realizations to simulate.</p>
</td></tr>
<tr><td><code id="cocoSim_+3A_seed">seed</code></td>
<td>
<p>(<code>integer or NULL</code>) Seed for random number generation. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="cocoSim_+3A_standardize">standardize</code></td>
<td>
<p>(<code>logical</code>) Indicates whether the provided covariates should be standardized (<code>TRUE</code>) or not (<code>FALSE</code>). Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="cocoSim_+3A_type">type</code></td>
<td>
<p>(<code>character</code>) Specifies whether the parameters follow a classical parameterization (<code>'classic'</code>) or a difference parameterization (<code>'diff'</code>). Defaults to <code>'classic'</code>. For sparse <code>coco</code> objects, only <code>'diff'</code> is allowed.</p>
</td></tr>
<tr><td><code id="cocoSim_+3A_sim.type">sim.type</code></td>
<td>
<p>(<code>character</code>) If set to <code>'cond'</code>, a conditional simulation is performed.</p>
</td></tr>
<tr><td><code id="cocoSim_+3A_cond.info">cond.info</code></td>
<td>
<p>(<code>list</code>) A list containing additional information required for conditional simulation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>sim.type = 'cond'</code> specifies a conditional simulation, requiring <code>cond.info</code> to be provided.
<code>cond.info</code> is a list including <code>newdataset</code>, a data.frame containing covariates present in <code>model.list</code> at the simulation locations, and <code>newlocs</code>,
a matrix specifying the locations corresponding to the simulation, with indexing that matches <code>newdataset</code>.
</p>
<p>The argument <code>type = 'classic'</code> assumes a simplified parameterization for the covariance function, with log-parameterizations applied to the parameters <code>std.dev</code>,
<code>scale</code>, and <code>smooth</code>.
</p>


<h3>Value</h3>

<p>(<code>matrix</code>) a matrix dim(data)[1] x n.
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>


<h3>See Also</h3>

<p><a href="#topic+coco">coco</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

model.list &lt;- list('mean' = 0,
                   'std.dev' = formula( ~ 1 + cov_x + cov_y),
                   'scale' = formula( ~ 1 + cov_x + cov_y),
                   'aniso' = 0,
                   'tilt' = 0,
                   'smooth' = 0.5,
                   'nugget' = -Inf)
                   
coco_object &lt;- coco(type = 'dense',
                    data = holes[[1]][1:1000,],
                    locs = as.matrix(holes[[1]][1:1000,1:2]),
                    z = holes[[1]][1:1000,]$z,
                    model.list = model.list)
                    
coco_sim &lt;- cocoSim(coco.object = coco_object,
            pars = c(0,0.25,0.25,  # pars related to std.dev
            log(0.25),1,-1),       # pars related to scale
            n = 1, 
            standardize = TRUE) 

fields::quilt.plot(coco_object@locs,coco_sim)             

## End(Not run)

</code></pre>

<hr>
<h2 id='cov_rns'>Dense covariance function (difference parameterization)</h2><span id='topic+cov_rns'></span>

<h3>Description</h3>

<p>Dense covariance function (difference parameterization)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_rns(theta, locs, x_covariates, smooth_limits)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cov_rns_+3A_theta">theta</code></td>
<td>
<p>vector of parameters</p>
</td></tr>
<tr><td><code id="cov_rns_+3A_locs">locs</code></td>
<td>
<p>a matrix with locations</p>
</td></tr>
<tr><td><code id="cov_rns_+3A_x_covariates">x_covariates</code></td>
<td>
<p>design data.frame</p>
</td></tr>
<tr><td><code id="cov_rns_+3A_smooth_limits">smooth_limits</code></td>
<td>
<p>smooth limits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dense covariance matrix
</p>

<hr>
<h2 id='cov_rns_classic'>Dense covariance function (classic parameterization)</h2><span id='topic+cov_rns_classic'></span>

<h3>Description</h3>

<p>Dense covariance function (classic parameterization)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_rns_classic(theta, locs, x_covariates)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cov_rns_classic_+3A_theta">theta</code></td>
<td>
<p>vector of parameters</p>
</td></tr>
<tr><td><code id="cov_rns_classic_+3A_locs">locs</code></td>
<td>
<p>a matrix with locations</p>
</td></tr>
<tr><td><code id="cov_rns_classic_+3A_x_covariates">x_covariates</code></td>
<td>
<p>design data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dense covariance matrix with classic parameterization
</p>

<hr>
<h2 id='cov_rns_pred'>Dense covariance function</h2><span id='topic+cov_rns_pred'></span>

<h3>Description</h3>

<p>Dense covariance function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_rns_pred(
  theta,
  locs,
  locs_pred,
  x_covariates,
  x_covariates_pred,
  smooth_limits
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cov_rns_pred_+3A_theta">theta</code></td>
<td>
<p>vector of parameters</p>
</td></tr>
<tr><td><code id="cov_rns_pred_+3A_locs">locs</code></td>
<td>
<p>a matrix with locations</p>
</td></tr>
<tr><td><code id="cov_rns_pred_+3A_locs_pred">locs_pred</code></td>
<td>
<p>a matrix with prediction locations</p>
</td></tr>
<tr><td><code id="cov_rns_pred_+3A_x_covariates">x_covariates</code></td>
<td>
<p>design data.frame</p>
</td></tr>
<tr><td><code id="cov_rns_pred_+3A_x_covariates_pred">x_covariates_pred</code></td>
<td>
<p>design data.frame at prediction locations</p>
</td></tr>
<tr><td><code id="cov_rns_pred_+3A_smooth_limits">smooth_limits</code></td>
<td>
<p>smooth limits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dense covariance matrix
</p>

<hr>
<h2 id='cov_rns_taper'>Sparse covariance function</h2><span id='topic+cov_rns_taper'></span>

<h3>Description</h3>

<p>Sparse covariance function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_rns_taper(
  theta,
  locs,
  x_covariates,
  colindices,
  rowpointers,
  smooth_limits
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cov_rns_taper_+3A_theta">theta</code></td>
<td>
<p>vector of parameters</p>
</td></tr>
<tr><td><code id="cov_rns_taper_+3A_locs">locs</code></td>
<td>
<p>a matrix with locations</p>
</td></tr>
<tr><td><code id="cov_rns_taper_+3A_x_covariates">x_covariates</code></td>
<td>
<p>design data.frame</p>
</td></tr>
<tr><td><code id="cov_rns_taper_+3A_colindices">colindices</code></td>
<td>
<p>from spam object</p>
</td></tr>
<tr><td><code id="cov_rns_taper_+3A_rowpointers">rowpointers</code></td>
<td>
<p>from spam object</p>
</td></tr>
<tr><td><code id="cov_rns_taper_+3A_smooth_limits">smooth_limits</code></td>
<td>
<p>smooth limits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sparse covariance matrix between locs and pred_locs
</p>

<hr>
<h2 id='cov_rns_taper_pred'>Sparse covariance function</h2><span id='topic+cov_rns_taper_pred'></span>

<h3>Description</h3>

<p>Sparse covariance function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_rns_taper_pred(
  theta,
  locs,
  locs_pred,
  x_covariates,
  x_covariates_pred,
  colindices,
  rowpointers,
  smooth_limits
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cov_rns_taper_pred_+3A_theta">theta</code></td>
<td>
<p>vector of parameters</p>
</td></tr>
<tr><td><code id="cov_rns_taper_pred_+3A_locs">locs</code></td>
<td>
<p>a matrix with locations</p>
</td></tr>
<tr><td><code id="cov_rns_taper_pred_+3A_locs_pred">locs_pred</code></td>
<td>
<p>a matrix with prediction locations</p>
</td></tr>
<tr><td><code id="cov_rns_taper_pred_+3A_x_covariates">x_covariates</code></td>
<td>
<p>design data.frame</p>
</td></tr>
<tr><td><code id="cov_rns_taper_pred_+3A_x_covariates_pred">x_covariates_pred</code></td>
<td>
<p>design data.frame at prediction locations</p>
</td></tr>
<tr><td><code id="cov_rns_taper_pred_+3A_colindices">colindices</code></td>
<td>
<p>from spam object</p>
</td></tr>
<tr><td><code id="cov_rns_taper_pred_+3A_rowpointers">rowpointers</code></td>
<td>
<p>from spam object</p>
</td></tr>
<tr><td><code id="cov_rns_taper_pred_+3A_smooth_limits">smooth_limits</code></td>
<td>
<p>smooth limits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sparse covariance matrix at locs
</p>

<hr>
<h2 id='getAIC'>Retrieve AIC</h2><span id='topic+getAIC'></span>

<h3>Description</h3>

<p>Retrieve the Akaike information criterion from a fitted coco object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAIC(coco.object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getAIC_+3A_coco.object">coco.object</code></td>
<td>
<p><code>(S4)</code> a fitted coco S4 object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>numeric</code>) the associated AIC value
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>

<hr>
<h2 id='getBIC'>Retrieve BIC</h2><span id='topic+getBIC'></span>

<h3>Description</h3>

<p>Retrieve BIC from a fitted coco object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBIC(coco.object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getBIC_+3A_coco.object">coco.object</code></td>
<td>
<p><code>(S4)</code> a fitted coco S4 object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>numeric</code>) the associated BIC value
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>

<hr>
<h2 id='getBoundaries'>Simple build of boundaries</h2><span id='topic+getBoundaries'></span>

<h3>Description</h3>

<p>provides a generic set of upper and lower bounds for the L-BFGS-B routine
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBoundaries(x, lower.value, upper.value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getBoundaries_+3A_x">x</code></td>
<td>
<p><code>(S4) or (list)</code> a coco.object or a par.pos list (as output from <a href="#topic+getDesignMatrix">getDesignMatrix</a>)</p>
</td></tr>
<tr><td><code id="getBoundaries_+3A_lower.value">lower.value</code></td>
<td>
<p><code>(numeric vector)</code> if provided, provides a vector filled with values lower.value.</p>
</td></tr>
<tr><td><code id="getBoundaries_+3A_upper.value">upper.value</code></td>
<td>
<p><code>(numeric vector)</code> if provided, provides a vector filled with values upper.value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>list</code>) a list with boundaries and simple init values for the optim L-BFGS-B routine
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>

<hr>
<h2 id='getBoundariesV2'>Simple build of boundaries (v2)</h2><span id='topic+getBoundariesV2'></span>

<h3>Description</h3>

<p>provides a generic set of upper and lower bounds for the L-BFGS-B routine
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBoundariesV2(coco.object, mean.limits, std.dev.limits, 
scale.limits, aniso.limits, tilt.limits, smooth.limits, nugget.limits)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getBoundariesV2_+3A_coco.object">coco.object</code></td>
<td>
<p><code>(S4)</code> a coco object.</p>
</td></tr>
<tr><td><code id="getBoundariesV2_+3A_mean.limits">mean.limits</code></td>
<td>
<p><code>(numeric vector)</code> a vector of c(lower,init,upper) values for the associated param.</p>
</td></tr>
<tr><td><code id="getBoundariesV2_+3A_std.dev.limits">std.dev.limits</code></td>
<td>
<p><code>(numeric vector)</code> a vector of c(lower,init,upper) values for the associated param.</p>
</td></tr>
<tr><td><code id="getBoundariesV2_+3A_scale.limits">scale.limits</code></td>
<td>
<p><code>(numeric vector)</code> a vector of c(lower,init,upper) values for the associated param.</p>
</td></tr>
<tr><td><code id="getBoundariesV2_+3A_aniso.limits">aniso.limits</code></td>
<td>
<p><code>(numeric vector)</code> a vector of c(lower,init,upper) values for the associated param.</p>
</td></tr>
<tr><td><code id="getBoundariesV2_+3A_tilt.limits">tilt.limits</code></td>
<td>
<p><code>(numeric vector)</code> a vector of c(lower,init,upper) values for the associated param.</p>
</td></tr>
<tr><td><code id="getBoundariesV2_+3A_smooth.limits">smooth.limits</code></td>
<td>
<p><code>(numeric vector)</code> a vector of c(lower,init,upper) values for the associated param.</p>
</td></tr>
<tr><td><code id="getBoundariesV2_+3A_nugget.limits">nugget.limits</code></td>
<td>
<p><code>(numeric vector)</code> a vector of c(lower,init,upper) values for the associated param.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>list</code>) a list with boundaries for the optim L-BFGS-B routine
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>

<hr>
<h2 id='getBoundariesV3'>Simple build of boundaries (v3)</h2><span id='topic+getBoundariesV3'></span>

<h3>Description</h3>

<p>provides a generic set of upper and lower bounds for the L-BFGS-B routine
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBoundariesV3(coco.object, mean.limits, global.lower, 
std.dev.max.effects, 
scale.max.effects, aniso.max.effects, tilt.max.effects, 
smooth.max.effects, nugget.max.effects)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getBoundariesV3_+3A_coco.object">coco.object</code></td>
<td>
<p><code>(S4)</code> a coco object.</p>
</td></tr>
<tr><td><code id="getBoundariesV3_+3A_mean.limits">mean.limits</code></td>
<td>
<p><code>(numeric vector)</code> a vector of c(lower,init,upper) values for the associated param.</p>
</td></tr>
<tr><td><code id="getBoundariesV3_+3A_global.lower">global.lower</code></td>
<td>
<p><code>(numeric vector)</code> a vector of c(lower,init,upper) values for the associated param.</p>
</td></tr>
<tr><td><code id="getBoundariesV3_+3A_std.dev.max.effects">std.dev.max.effects</code></td>
<td>
<p><code>(numeric vector)</code> a vector of c(lower,init,upper) values for the associated param.</p>
</td></tr>
<tr><td><code id="getBoundariesV3_+3A_scale.max.effects">scale.max.effects</code></td>
<td>
<p><code>(numeric vector)</code> a vector of c(lower,init,upper) values for the associated param.</p>
</td></tr>
<tr><td><code id="getBoundariesV3_+3A_aniso.max.effects">aniso.max.effects</code></td>
<td>
<p><code>(numeric vector)</code> a vector of c(lower,init,upper) values for the associated param.</p>
</td></tr>
<tr><td><code id="getBoundariesV3_+3A_tilt.max.effects">tilt.max.effects</code></td>
<td>
<p><code>(numeric vector)</code> a vector of c(lower,init,upper) values for the associated param.</p>
</td></tr>
<tr><td><code id="getBoundariesV3_+3A_smooth.max.effects">smooth.max.effects</code></td>
<td>
<p><code>(numeric vector)</code> a vector of c(lower,init,upper) values for the associated param.</p>
</td></tr>
<tr><td><code id="getBoundariesV3_+3A_nugget.max.effects">nugget.max.effects</code></td>
<td>
<p><code>(numeric vector)</code> a vector of c(lower,init,upper) values for the associated param.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>list</code>) a list with boundaries for the optim L-BFGS-B routine
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>

<hr>
<h2 id='getCIs'>Compute approximate confidence intervals for a coco object</h2><span id='topic+getCIs'></span>

<h3>Description</h3>

<p>Compute approximate confidence intervals for a (fitted) coco object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCIs(coco.object, inv.hess, alpha = 0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCIs_+3A_coco.object">coco.object</code></td>
<td>
<p><code>(S4)</code> a fitted coco S4 object.</p>
</td></tr>
<tr><td><code id="getCIs_+3A_inv.hess">inv.hess</code></td>
<td>
<p><code>(matrix)</code> Inverse of the Hessian. <a href="#topic+getHessian">getHessian</a>.</p>
</td></tr>
<tr><td><code id="getCIs_+3A_alpha">alpha</code></td>
<td>
<p><code>(numeric)</code> confidence level.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>numeric matrix</code>) a matrix with approximate confidence intervals for each parameter in the model.
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>

<hr>
<h2 id='getCovMatrix'>Covariance matrix for &quot;coco&quot; class</h2><span id='topic+getCovMatrix'></span>

<h3>Description</h3>

<p>Compute the covariance matrix of <code>coco.object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCovMatrix(coco.object, type = 'global', index = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCovMatrix_+3A_coco.object">coco.object</code></td>
<td>
<p><code>(S4)</code> a fitted <code><a href="#topic+coco">coco()</a></code> object.</p>
</td></tr>
<tr><td><code id="getCovMatrix_+3A_type">type</code></td>
<td>
<p><code>(character)</code> whether <code>'global'</code> to retrieve the regular covariance matrix, or <code>'local'</code> to retrieve global covariance.
based on the local aspects of a specific location (not implemented yet).</p>
</td></tr>
<tr><td><code id="getCovMatrix_+3A_index">index</code></td>
<td>
<p><code>(integer)</code> index to perform local covariance matrix (not implemented yet).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>matrix</code> or <code>S4</code>) a n x n covariance matrix (for 'dense' coco objects) or a S4 spam object (for 'sparse' coco objects).
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
model.list &lt;- list('mean' = 0,
                   'std.dev' = formula( ~ 1 + cov_x + cov_y),
                   'scale' = formula( ~ 1 + cov_x + cov_y),
                   'aniso' = 0,
                   'tilt' = 0,
                   'smooth' = 3/2,
                   'nugget' = -Inf)
                   
coco_object &lt;- coco(type = 'dense',
                    data = holes[[1]][1:100,],
                    locs = as.matrix(holes[[1]][1:100,1:2]),
                    z = holes[[1]][1:100,]$z,
                    model.list = model.list)
                    
optim_coco &lt;- cocoOptim(coco_object,
boundaries = getBoundaries(coco_object,
lower.value = -3, 3))

getCovMatrix(optim_coco)


## End(Not run)

</code></pre>

<hr>
<h2 id='getCRPS'>Based on a set of predictions computes the Continuous Ranked Probability Score</h2><span id='topic+getCRPS'></span>

<h3>Description</h3>

<p>Retrieves the Continuous Ranked Probability Score (CRPS) [1].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCRPS(z.pred, mean.pred, sd.pred)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCRPS_+3A_z.pred">z.pred</code></td>
<td>
<p><code>(numeric vector)</code>.</p>
</td></tr>
<tr><td><code id="getCRPS_+3A_mean.pred">mean.pred</code></td>
<td>
<p><code>(numeric vector)</code>.</p>
</td></tr>
<tr><td><code id="getCRPS_+3A_sd.pred">sd.pred</code></td>
<td>
<p><code>(numeric vector)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>numeric vector</code>) retrieves CRPS.
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>


<h3>References</h3>

<p>[1] Gneiting, Tilmann, and Adrian E. Raftery. <em>&quot;Strictly proper scoring rules, prediction, and estimation.&quot;</em> Journal of the American statistical Association 102.477 (2007): 359-378.
</p>

<hr>
<h2 id='getDensityFromDelta'>Based on a specific taper scale (delta), retrieves the density of the covariance matrix.</h2><span id='topic+getDensityFromDelta'></span>

<h3>Description</h3>

<p>Based on a specific taper scale (delta), retrieves the density of the covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDensityFromDelta(coco.object, delta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDensityFromDelta_+3A_coco.object">coco.object</code></td>
<td>
<p><code>(S4)</code> a fitted <code><a href="#topic+coco">coco()</a></code> object.</p>
</td></tr>
<tr><td><code id="getDensityFromDelta_+3A_delta">delta</code></td>
<td>
<p><code>(numeric)</code> a delta taper scale (delta).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>numeric vector</code>) the associate density of the tapered covariance matrix.
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>

<hr>
<h2 id='getDesignMatrix'>Create an efficient design matrix based on a list of aspect models</h2><span id='topic+getDesignMatrix'></span>

<h3>Description</h3>

<p>Creates a unique design matrix based on model specification for
each of the different potentially spatially varying aspects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDesignMatrix(model.list, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDesignMatrix_+3A_model.list">model.list</code></td>
<td>
<p><code>(list)</code> a list of formulas, one for each source of nonstationarity, specifying the
models.</p>
</td></tr>
<tr><td><code id="getDesignMatrix_+3A_data">data</code></td>
<td>
<p><code>(data.frame)</code> a data.frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>list</code>) a list with two elements: a design matrix of dimension
(n x p), and a par.pos object, indexing columns of the design matrix to each of the spatially-varying functions.
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>

<hr>
<h2 id='getEstims'>Retrieve estimates from a fitted coco object</h2><span id='topic+getEstims'></span>

<h3>Description</h3>

<p>Retrieve estimates from a fitted coco object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEstims(coco.object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getEstims_+3A_coco.object">coco.object</code></td>
<td>
<p><code>(S4)</code> a fitted coco S4 object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>list</code>) a list with the estimates parameters for the different aspects
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>

<hr>
<h2 id='getHessian'>getHessian</h2><span id='topic+getHessian'></span>

<h3>Description</h3>

<p>numerically approximate the Hessian. Hessians of parameters based on &quot;pml&quot; are based on full likelihoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getHessian(coco.object, ncores = parallel::detectCores() - 1, 
eps = .Machine$double.eps^(1/4))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getHessian_+3A_coco.object">coco.object</code></td>
<td>
<p><code>(S4)</code> a fitted coco object.</p>
</td></tr>
<tr><td><code id="getHessian_+3A_ncores">ncores</code></td>
<td>
<p><code>(integer)</code> number of cores used for the computation.</p>
</td></tr>
<tr><td><code id="getHessian_+3A_eps">eps</code></td>
<td>
<p><code>(numeric)</code> ...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>numeric matrix</code>) a symmetric matrix pxp of the approximated (observed) Hessian
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>

<hr>
<h2 id='getLoglik'>Retrieve the loglikelihood value</h2><span id='topic+getLoglik'></span>

<h3>Description</h3>

<p>Retrieve the loglikelihood value from a fitted coco object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLoglik(coco.object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getLoglik_+3A_coco.object">coco.object</code></td>
<td>
<p><code>(S4)</code> a fitted coco S4 object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>numeric</code>) wrap for value from a OptimParallel object
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>

<hr>
<h2 id='getLogScore'>Based on a set of predictions computes the Log-Score</h2><span id='topic+getLogScore'></span>

<h3>Description</h3>

<p>Computes the Log-Score [1].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLogScore(z.pred, mean.pred, sd.pred)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getLogScore_+3A_z.pred">z.pred</code></td>
<td>
<p><code>(numeric vector)</code>.</p>
</td></tr>
<tr><td><code id="getLogScore_+3A_mean.pred">mean.pred</code></td>
<td>
<p><code>(numeric vector)</code>.</p>
</td></tr>
<tr><td><code id="getLogScore_+3A_sd.pred">sd.pred</code></td>
<td>
<p><code>(numeric vector)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>numeric vector</code>) retrieves Log-Score.
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>


<h3>References</h3>

<p>[1] Gneiting, Tilmann, and Adrian E. Raftery. <em>&quot;Strictly proper scoring rules, prediction, and estimation.&quot;</em> Journal of the American statistical Association 102.477 (2007): 359-378.
</p>

<hr>
<h2 id='getModelLists'>Builds the necessary input for building covariance matrices</h2><span id='topic+getModelLists'></span>

<h3>Description</h3>

<p>Returns a list of parameter vectors for each of the aspects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getModelLists(theta, par.pos, type = 'diff')
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getModelLists_+3A_theta">theta</code></td>
<td>
<p><code>(numeric vector)</code> a vector of length p, where p is the number of parameters for
each of the models.</p>
</td></tr>
<tr><td><code id="getModelLists_+3A_par.pos">par.pos</code></td>
<td>
<p><code>(list)</code> a list detailing in which position of each aspect the elements
of theta should be placed. Expected to be par.pos output of <a href="#topic+getDesignMatrix">getDesignMatrix</a>.</p>
</td></tr>
<tr><td><code id="getModelLists_+3A_type">type</code></td>
<td>
<p><code>(character)</code> whether parameters are related to a classical parameterization ('classic') or
a difference parameterization 'diff' . Default set to 'diff'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>list</code>) a list of different spatial aspects and mean required for the cov.rns functions
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>

<hr>
<h2 id='getModHess'>Retrieves the modified inverse of the hessian</h2><span id='topic+getModHess'></span>

<h3>Description</h3>

<p>Based on the inverse of the Hessian (based on the difference parameterization for the std.dev and scale parameters),
retrieves the modified inverse of the hessian (i.e. std.dev and scale).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getModHess(coco.object, inv.hess)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getModHess_+3A_coco.object">coco.object</code></td>
<td>
<p><code>(S4)</code> a fitted coco S4 object.</p>
</td></tr>
<tr><td><code id="getModHess_+3A_inv.hess">inv.hess</code></td>
<td>
<p><code>(matrix)</code> Inverse of the Hessian.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>numeric matrix</code>) the modified inverse of the hessian matrix
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>

<hr>
<h2 id='GetNeg2loglikelihood'>GetNeg2loglikelihood</h2><span id='topic+GetNeg2loglikelihood'></span>

<h3>Description</h3>

<p>compute the negative 2 log likelihood based on theta
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetNeg2loglikelihood(theta, par.pos, locs, x_covariates, 
smooth.limits, z, n, lambda, safe = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetNeg2loglikelihood_+3A_theta">theta</code></td>
<td>
<p><code>(numeric vector)</code> a vector with parameters values.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihood_+3A_par.pos">par.pos</code></td>
<td>
<p><code>(list)</code> par.pos list.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihood_+3A_locs">locs</code></td>
<td>
<p><code>(matrix)</code> spatial location matrix.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihood_+3A_x_covariates">x_covariates</code></td>
<td>
<p><code>(data.frame)</code> design matrix.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihood_+3A_smooth.limits">smooth.limits</code></td>
<td>
<p><code>(numeric vector)</code> smooth.limits.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihood_+3A_z">z</code></td>
<td>
<p><code>(numeric vector)</code> a vector of observed values.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihood_+3A_n">n</code></td>
<td>
<p><code>(integer)</code> dim(z)[1].</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihood_+3A_lambda">lambda</code></td>
<td>
<p><code>(numeric)</code> regularization parameter.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihood_+3A_safe">safe</code></td>
<td>
<p><code>(TRUE/FALSE)</code> if <code>TRUE</code> returns a large pre-defined value under Cholesky errors. Default <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>

<hr>
<h2 id='GetNeg2loglikelihoodProfile'>GetNeg2loglikelihoodProfile</h2><span id='topic+GetNeg2loglikelihoodProfile'></span>

<h3>Description</h3>

<p>compute the negative 2 log likelihood based on theta
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetNeg2loglikelihoodProfile(theta, par.pos, locs, x_covariates, 
smooth.limits, z, n, x_betas,lambda, safe = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetNeg2loglikelihoodProfile_+3A_theta">theta</code></td>
<td>
<p><code>(numeric vector)</code> a vector with parameters values.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodProfile_+3A_par.pos">par.pos</code></td>
<td>
<p><code>(list)</code> par.pos list.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodProfile_+3A_locs">locs</code></td>
<td>
<p><code>(matrix)</code> spatial location matrix.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodProfile_+3A_x_covariates">x_covariates</code></td>
<td>
<p><code>(data.frame)</code> design matrix.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodProfile_+3A_smooth.limits">smooth.limits</code></td>
<td>
<p><code>(numeric vector)</code> smooth.limits.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodProfile_+3A_z">z</code></td>
<td>
<p><code>(numeric vector)</code> a vector of observed values.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodProfile_+3A_n">n</code></td>
<td>
<p><code>(integer)</code> dim(z)[1].</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodProfile_+3A_x_betas">x_betas</code></td>
<td>
<p><code>(matrix) or (data.frame)</code> design matrix for the spatial mean.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodProfile_+3A_lambda">lambda</code></td>
<td>
<p><code>(numeric)</code> regularization parameter.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodProfile_+3A_safe">safe</code></td>
<td>
<p><code>(TRUE/FALSE)</code> if <code>TRUE</code> returns a large pre-defined value under Cholesky errors. Default <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>

<hr>
<h2 id='GetNeg2loglikelihoodREML'>GetNeg2loglikelihoodREML</h2><span id='topic+GetNeg2loglikelihoodREML'></span>

<h3>Description</h3>

<p>compute the negative 2 log REML likelihood based on theta
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetNeg2loglikelihoodREML(theta, par.pos, locs, x_covariates, x_betas,
smooth.limits, z, n, lambda, safe = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetNeg2loglikelihoodREML_+3A_theta">theta</code></td>
<td>
<p><code>(numeric vector)</code> a vector with parameters values.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodREML_+3A_par.pos">par.pos</code></td>
<td>
<p><code>(list)</code> par.pos list.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodREML_+3A_locs">locs</code></td>
<td>
<p><code>(matrix)</code> spatial location matrix.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodREML_+3A_x_covariates">x_covariates</code></td>
<td>
<p><code>(data.frame)</code> design matrix.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodREML_+3A_x_betas">x_betas</code></td>
<td>
<p><code>(matrix) or (data.frame)</code> design matrix for the spatial mean.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodREML_+3A_smooth.limits">smooth.limits</code></td>
<td>
<p><code>(numeric vector)</code> smooth.limits.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodREML_+3A_z">z</code></td>
<td>
<p><code>(numeric vector)</code> a vector of contrasts.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodREML_+3A_n">n</code></td>
<td>
<p><code>(integer)</code> dim(z)[1].</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodREML_+3A_lambda">lambda</code></td>
<td>
<p><code>(numeric)</code> regularization parameter.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodREML_+3A_safe">safe</code></td>
<td>
<p><code>(TRUE/FALSE)</code> if <code>TRUE</code> returns a large pre-defined value under Cholesky errors. Default <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>

<hr>
<h2 id='GetNeg2loglikelihoodTaper'>GetNeg2loglikelihoodTaper</h2><span id='topic+GetNeg2loglikelihoodTaper'></span>

<h3>Description</h3>

<p>compute the negative 2 log likelihood based on theta
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetNeg2loglikelihoodTaper(theta, par.pos, ref_taper, locs, 
x_covariates, smooth.limits, cholS, z, n, lambda, safe = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetNeg2loglikelihoodTaper_+3A_theta">theta</code></td>
<td>
<p><code>(numeric vector)</code> a vector with parameters values.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodTaper_+3A_par.pos">par.pos</code></td>
<td>
<p><code>(list)</code> par.pos list from <a href="#topic+getDesignMatrix">getDesignMatrix</a>.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodTaper_+3A_ref_taper">ref_taper</code></td>
<td>
<p><code>(S4)</code> spam object based on a compact-supported covariance function.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodTaper_+3A_locs">locs</code></td>
<td>
<p><code>(matrix)</code> spatial location matrix.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodTaper_+3A_x_covariates">x_covariates</code></td>
<td>
<p><code>(data.frame)</code> design matrix.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodTaper_+3A_smooth.limits">smooth.limits</code></td>
<td>
<p><code>(numeric vector)</code> smooth.limits.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodTaper_+3A_chols">cholS</code></td>
<td>
<p><code>(S4)</code> Cholesky object from spam.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodTaper_+3A_z">z</code></td>
<td>
<p><code>(numeric vector)</code> a vector of observed values.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodTaper_+3A_n">n</code></td>
<td>
<p><code>(numeric)</code> dim(z)[1].</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodTaper_+3A_lambda">lambda</code></td>
<td>
<p><code>(numeric)</code> regularization parameter.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodTaper_+3A_safe">safe</code></td>
<td>
<p><code>(TRUE/FALSE)</code> if <code>TRUE</code> returns a large pre-defined value under Cholesky errors. Default <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>

<hr>
<h2 id='GetNeg2loglikelihoodTaperProfile'>GetNeg2loglikelihoodTaperProfile</h2><span id='topic+GetNeg2loglikelihoodTaperProfile'></span>

<h3>Description</h3>

<p>compute the negative 2 log likelihood based on theta
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetNeg2loglikelihoodTaperProfile(theta, par.pos, ref_taper, 
locs, x_covariates, smooth.limits, cholS, z, n, lambda, safe = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetNeg2loglikelihoodTaperProfile_+3A_theta">theta</code></td>
<td>
<p><code>(numeric vector)</code> a vector with parameters values.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodTaperProfile_+3A_par.pos">par.pos</code></td>
<td>
<p><code>(list)</code> par.pos list.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodTaperProfile_+3A_ref_taper">ref_taper</code></td>
<td>
<p><code>(S4)</code> spam object based on a taper based covariance function.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodTaperProfile_+3A_locs">locs</code></td>
<td>
<p><code>(matrix)</code> spatial location matrix.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodTaperProfile_+3A_x_covariates">x_covariates</code></td>
<td>
<p><code>(data.frame)</code> design matrix.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodTaperProfile_+3A_smooth.limits">smooth.limits</code></td>
<td>
<p><code>(numeric vector)</code> smooth.limits.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodTaperProfile_+3A_chols">cholS</code></td>
<td>
<p><code>(S4)</code> Cholesky object from spam.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodTaperProfile_+3A_z">z</code></td>
<td>
<p><code>(numeric vector)</code> a vector of observed values.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodTaperProfile_+3A_n">n</code></td>
<td>
<p><code>(integer)</code> dim(z)[1].</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodTaperProfile_+3A_lambda">lambda</code></td>
<td>
<p><code>(numeric)</code> regularization parameter.</p>
</td></tr>
<tr><td><code id="GetNeg2loglikelihoodTaperProfile_+3A_safe">safe</code></td>
<td>
<p><code>(TRUE/FALSE)</code> if <code>TRUE</code> returns a large pre-defined value under Cholesky errors. Default <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>(numeric)</code>
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>

<hr>
<h2 id='getScale'>Fast and simple standardization for the design matrix.</h2><span id='topic+getScale'></span>

<h3>Description</h3>

<p>Centers and scale the design matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getScale(x, mean.vector = NULL, sd.vector = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getScale_+3A_x">x</code></td>
<td>
<p><code>(S4) or (matrix)</code> a coco object, or a n x p matrix with covariate information to introduce,
where the first column is a column of ones.</p>
</td></tr>
<tr><td><code id="getScale_+3A_mean.vector">mean.vector</code></td>
<td>
<p><code>(numeric vector)</code> if provided, it centers covariates based on this information.</p>
</td></tr>
<tr><td><code id="getScale_+3A_sd.vector">sd.vector</code></td>
<td>
<p><code>(numeric vector)</code> if provided, it scales covariates based on this information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>list</code>) a list with a scaled design matrix of dimension n x (p+1), and a set of mean and sd vectors
employed to scale the matrix
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>

<hr>
<h2 id='getSpatEffects'>Evaluates the spatially-varying functions from a coco object at locs</h2><span id='topic+getSpatEffects'></span>

<h3>Description</h3>

<p>Evaluates the spatially-varying functions of the nonstationary spatial structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSpatEffects(coco.object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSpatEffects_+3A_coco.object">coco.object</code></td>
<td>
<p><code>(S4)</code> a fitted coco S4 object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>list</code>) a list with the different estimated surfaces.
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>

<hr>
<h2 id='getSpatMean'>Computes the spatial mean of a (fitted) coco object</h2><span id='topic+getSpatMean'></span>

<h3>Description</h3>

<p>Computes the spatial mean of the (fitted) coco object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSpatMean(coco.object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSpatMean_+3A_coco.object">coco.object</code></td>
<td>
<p><code>(S4)</code> a fitted coco S4 object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>numeric vector</code>) a vector with the adjusted trend.
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>

<hr>
<h2 id='holes'>Holes Data Set</h2><span id='topic+holes'></span>

<h3>Description</h3>

<p>The synthetic &quot;holes&quot; provides a set of training and test data.frame of a Gaussian process realization with a (inherently dense) nonstationary covariance function.
Four holes are present in the training dataset, and the task is to predict them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>holes
</code></pre>


<h3>Format</h3>

<p>A list with training and test data.frame with rows and variables:
</p>

<dl>
<dt>x</dt><dd><p>first spatial coordinate</p>
</dd>
<dt>y</dt><dd><p>second spatial coordinate</p>
</dd>
<dt>cox_x</dt><dd><p>first spatial characteristic</p>
</dd>
<dt>cov_y</dt><dd><p>second spatial characteristic</p>
</dd>
<dt>z</dt><dd><p>response variable</p>
</dd>
</dl>



<h3>Source</h3>

<p>Source of the data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(holes)
</code></pre>

<hr>
<h2 id='holes_bm'>Holes with trend + multiple realizations Data Set</h2><span id='topic+holes_bm'></span>

<h3>Description</h3>

<p>The synthetic &quot;holes_bm&quot; provides a set of training and test data.frame of a Gaussian process realization with a (inherently dense) nonstationary covariance function.
Four holes are present in the training dataset, and the task is to predict them. This version provides ten independent realizations of the process, as well as considers
a spatial mean effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>holes_bm
</code></pre>


<h3>Format</h3>

<p>A list with training, training.z, test, and test.z data.frames with rows and variables:
</p>

<dl>
<dt>x</dt><dd><p>first spatial coordinate</p>
</dd>
<dt>y</dt><dd><p>second spatial coordinate</p>
</dd>
<dt>cox_x</dt><dd><p>first spatial characteristic</p>
</dd>
<dt>cov_y</dt><dd><p>second spatial characteristic</p>
</dd>
<dt>cov_z</dt><dd><p>third spatial characteristic</p>
</dd>
<dt>z.i</dt><dd><p>i-th response variable</p>
</dd>
</dl>



<h3>Source</h3>

<p>Source of the data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(holes_bm)
</code></pre>

<hr>
<h2 id='is.formula'>check whether an R object is a formula</h2><span id='topic+is.formula'></span>

<h3>Description</h3>

<p>check whether an R object is a formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.formula(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.formula_+3A_x">x</code></td>
<td>
<p>(ANY) an R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE/FALSE
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>

<hr>
<h2 id='plot+2Ccoco+2Cmissing-method'>Plot Method for coco objects</h2><span id='topic+plot+2Ccoco+2Cmissing-method'></span><span id='topic+plot+2Ccoco-method'></span>

<h3>Description</h3>

<p>This method plots objects of class <code>coco</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'coco,missing'
plot(x, y, type = NULL, index = NULL, factr = 0.1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot+2B2Ccoco+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>(<code>S4</code>) A fitted object of class <code>coco</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2Ccoco+2B2Cmissing-method_+3A_y">y</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="plot+2B2Ccoco+2B2Cmissing-method_+3A_type">type</code></td>
<td>
<p>(<code>character</code>  or <code>NULL</code>) The type of plot. NULL or &quot;ellipse&quot; for drawing ellipse of the convolution kernels.</p>
</td></tr>
<tr><td><code id="plot+2B2Ccoco+2B2Cmissing-method_+3A_index">index</code></td>
<td>
<p>(<code>integer vector</code>) For plotting local correlation plots.</p>
</td></tr>
<tr><td><code id="plot+2B2Ccoco+2B2Cmissing-method_+3A_factr">factr</code></td>
<td>
<p>(<code>numeric</code>) Factor rate for size of ellipses.</p>
</td></tr>
<tr><td><code id="plot+2B2Ccoco+2B2Cmissing-method_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <a href="fields.html#topic+quilt.plot">quilt.plot</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Several plots are created.
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>

<hr>
<h2 id='plotOptimInfo'>Plot log info detailed</h2><span id='topic+plotOptimInfo'></span>

<h3>Description</h3>

<p>plot output of optim
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotOptimInfo(coco.object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotOptimInfo_+3A_coco.object">coco.object</code></td>
<td>
<p>an optimized coco.object</p>
</td></tr>
<tr><td><code id="plotOptimInfo_+3A_...">...</code></td>
<td>
<p>arguments for par()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Outputs a sequence of plots detailing parameters during the
optimization routine
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cocoOptim">cocoOptim()</a></code>
</p>

<hr>
<h2 id='stripes'>Stripes Data Set</h2><span id='topic+stripes'></span>

<h3>Description</h3>

<p>The synthetic &quot;stripes&quot; provides a set of training and test data.frame of a Gaussian process realization with a (inherently sparse) nonstationary covariance function.
Several stripes are present in the training dataset, and the task is to predict them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stripes
</code></pre>


<h3>Format</h3>

<p>A list with training and test data.frame with rows and variables:
</p>

<dl>
<dt>x</dt><dd><p>first spatial coordinate</p>
</dd>
<dt>y</dt><dd><p>second spatial coordinate</p>
</dd>
<dt>cox_x</dt><dd><p>first spatial characteristic</p>
</dd>
<dt>cov_y</dt><dd><p>second spatial characteristic</p>
</dd>
<dt>cov_xy</dt><dd><p>third spatial characteristic</p>
</dd>
<dt>z</dt><dd><p>response variable</p>
</dd>
</dl>



<h3>Source</h3>

<p>Source of the data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(stripes)
</code></pre>

<hr>
<h2 id='summary'>Summary Method for Coco Class</h2><span id='topic+summary'></span><span id='topic+summary+2Ccoco-method'></span>

<h3>Description</h3>

<p>method summary for objects of class 'coco'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'coco'
summary(object, inv.hess = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p>(<code>S4</code>) An object of class 'coco'.</p>
</td></tr>
<tr><td><code id="summary_+3A_inv.hess">inv.hess</code></td>
<td>
<p>(<code>numeric matrix</code> or <code>NULL</code>) inverse of the approximated hessian matrix (getHessian)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>summary the coco object
</p>


<h3>Author(s)</h3>

<p>Federico Blasi
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
