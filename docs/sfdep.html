<!DOCTYPE html><html lang="en"><head><title>Help for package sfdep</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sfdep}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#active'><p>Activate spacetime context</p></a></li>
<li><a href='#as_sf'><p>Cast between <code>spacetime</code> and <code>sf</code> classes</p></a></li>
<li><a href='#center_mean'><p>Calculate Center Mean Point</p></a></li>
<li><a href='#check_pkg_suggests'><p>Check if a vector of packages are available</p></a></li>
<li><a href='#check_polygon'><p>Checks geometry for polygons.</p></a></li>
<li><a href='#class_modify'><p>Modify object classes</p></a></li>
<li><a href='#classify_hotspot'><p>Classify Hot Spot results</p></a></li>
<li><a href='#complete_spacetime_cube'><p>Convert spacetime object to spacetime cube</p></a></li>
<li><a href='#cond_permute_nb'><p>Conditional permutation of neighbors</p></a></li>
<li><a href='#critical_threshold'><p>Identify critical threshold</p></a></li>
<li><a href='#ellipse'><p>Create an Ellipse</p></a></li>
<li><a href='#emerging_hotspot_analysis'><p>Emerging Hot Spot Analysis</p></a></li>
<li><a href='#find_xj'><p>Identify xj values</p></a></li>
<li><a href='#global_c'><p>Compute Geary's C</p></a></li>
<li><a href='#global_c_perm'><p>Global C Permutation Test</p></a></li>
<li><a href='#global_c_test'><p>Global C Test</p></a></li>
<li><a href='#global_colocation'><p>Global Colocation Quotient</p></a></li>
<li><a href='#global_colocation_calc'><p>Calculate the Global Colocation Quotient</p></a></li>
<li><a href='#global_colocation_perm_impl'><p>Global Colocation Quotient Conditional Permutation Implementation</p></a></li>
<li><a href='#global_g_test'><p>Getis-Ord Global G</p></a></li>
<li><a href='#global_jc_perm'><p>Global Join Counts</p></a></li>
<li><a href='#global_moran'><p>Calculate Global Moran's I</p></a></li>
<li><a href='#global_moran_bv'><p>Compute the Global Bivariate Moran's I</p></a></li>
<li><a href='#global_moran_perm'><p>Global Moran Permutation Test</p></a></li>
<li><a href='#global_moran_test'><p>Global Moran Test</p></a></li>
<li><a href='#guerry'><p>&quot;Essay on the Moral Statistics of France&quot; data set.</p></a></li>
<li><a href='#include_self'><p>Includes self in neighbor list</p></a></li>
<li><a href='#inverse_dist_calc'><p>Calculate inverse distance weights</p></a></li>
<li><a href='#is_spacetime_cube'><p>Test if a spacetime object is a spacetime cube</p></a></li>
<li><a href='#jc_bjc_calc'><p>Calculate BJC Bivariate Case</p></a></li>
<li><a href='#jc_bjc_perm_impl'><p>Calculate BJC BV for conditional permutations</p></a></li>
<li><a href='#jc_clc_perm_impl'><p>Calculate CLC BV for conditional permutations</p></a></li>
<li><a href='#kernels'><p>Kernel functions</p></a></li>
<li><a href='#local_c'><p>Compute Local Geary statistic</p></a></li>
<li><a href='#local_colocation'><p>Local indicator of Colocation Quotient</p></a></li>
<li><a href='#local_colocation_calc'><p>Calculate the local colocation quotient</p></a></li>
<li><a href='#local_colocation_impl'><p>spdep implementation of local colocation quotient</p></a></li>
<li><a href='#local_g'><p>Local G</p></a></li>
<li><a href='#local_g_spt'><p>Calculate the Local Gi* for a spacetime cube</p></a></li>
<li><a href='#local_gstar'><p>Local G*</p></a></li>
<li><a href='#local_jc_bv'><p>Bivariate local join count</p></a></li>
<li><a href='#local_jc_uni'><p>Compute local univariate join count</p></a></li>
<li><a href='#local_moran'><p>Calculate the Local Moran's I Statistic</p></a></li>
<li><a href='#local_moran_bv'><p>Compute the Local Bivariate Moran's I Statistic</p></a></li>
<li><a href='#local_moran_bv_calc'><p>Calculate the Local Bivariate Moran Statistic</p></a></li>
<li><a href='#local_moran_bv_impl'><p>Local Bivariate Moran's I spdep implementation</p></a></li>
<li><a href='#local_moran_bv_perm_impl'><p>Local Bivariate Moran's I conditional permutation implementation</p></a></li>
<li><a href='#losh'><p>Local spatial heteroscedacity</p></a></li>
<li><a href='#nb_match_test'><p>Local Neighbor Match Test</p></a></li>
<li><a href='#nb_union'><p>Set Operations</p></a></li>
<li><a href='#nmt_calc'><p>Identify matches between two neighbor lists</p></a></li>
<li><a href='#nmt_impl'><p>Implementation of Neighbor Match Test</p></a></li>
<li><a href='#nmt_perm_impl'><p>Find conditionally permuted neighbor matches</p>
Given a kNN attribute neighbor list and a listw object, find the number of matches given a conditional permutation.</a></li>
<li><a href='#node_get_nbs'><p>Create node features from edges</p></a></li>
<li><a href='#pairwise_colocation'><p>Pairwise Colocation Quotient</p></a></li>
<li><a href='#pairwise_colocation_calc'><p>Pairwise CLQ calculation</p></a></li>
<li><a href='#pairwise_colocation_perm_impl'><p>Pairwise CLQ conditional permutation implementation</p></a></li>
<li><a href='#pct_nonzero'><p>Percent Non-zero Neighbors</p></a></li>
<li><a href='#permute_listw'><p>Conditionally permutes a listw object</p></a></li>
<li><a href='#recreate_listw'><p>Create a listw object from a neighbors and weight list</p></a></li>
<li><a href='#set_col'><p>Set columns from <code>geometry</code> to <code>data</code></p></a></li>
<li><a href='#shuffle_nbs'><p>Internal function to shuffle neighbors</p></a></li>
<li><a href='#sin_d'><p>Trigonometric functions</p></a></li>
<li><a href='#spacetime'><p>Construct a <code>spacetime</code> object</p></a></li>
<li><a href='#spatial_gini'><p>Spatial Gini Index</p></a></li>
<li><a href='#spt_nb'><p>Create time lagged spatial neighbors</p></a></li>
<li><a href='#spt_order'><p>Order a spacetime cube</p></a></li>
<li><a href='#spt_update'><p>Update spacetime attributes</p></a></li>
<li><a href='#spt_wt'><p>Create time lagged spatial weights</p></a></li>
<li><a href='#st_as_edges'><p>Convert to an edge lines object</p></a></li>
<li><a href='#st_as_graph'><p>Create an sfnetwork</p></a></li>
<li><a href='#st_as_nodes'><p>Convert to a node point object</p></a></li>
<li><a href='#st_block_nb'><p>Create Block Contiguity for Spatial Regimes</p></a></li>
<li><a href='#st_cardinalties'><p>Calculate neighbor cardinalities</p></a></li>
<li><a href='#st_complete_nb'><p>Create Neighbors as Complete Graph</p></a></li>
<li><a href='#st_contiguity'><p>Identify polygon neighbors</p></a></li>
<li><a href='#st_dist_band'><p>Neighbors from a distance band</p></a></li>
<li><a href='#st_inverse_distance'><p>Calculate inverse distance weights</p></a></li>
<li><a href='#st_kernel_weights'><p>Calculate Kernel Weights</p></a></li>
<li><a href='#st_knn'><p>Calculate K-Nearest Neighbors</p></a></li>
<li><a href='#st_lag'><p>Calculate spatial lag</p></a></li>
<li><a href='#st_nb_apply'><p>Apply a function to neighbors</p></a></li>
<li><a href='#st_nb_delaunay'><p>Graph based neighbors</p></a></li>
<li><a href='#st_nb_dists'><p>Calculate neighbor distances</p></a></li>
<li><a href='#st_nb_lag'><p>Pure Higher Order Neighbors</p></a></li>
<li><a href='#st_nb_lag_cumul'><p>Encompassing Higher Order Neighbors</p></a></li>
<li><a href='#st_weights'><p>Calculate spatial weights</p></a></li>
<li><a href='#std_dev_ellipse'><p>Calculation Standard Deviational Ellipse</p></a></li>
<li><a href='#std_distance'><p>Calculate standard distance</p></a></li>
<li><a href='#szero'><p>Global sum of weights</p></a></li>
<li><a href='#tidyverse'><p>tidyverse methods for spacetime objects</p></a></li>
<li><a href='#wt_as_matrix'><p>Convert neighbor or weights list to matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Spatial Dependence for Simple Features</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.5</td>
</tr>
<tr>
<td>Description:</td>
<td>An interface to 'spdep' to integrate with 'sf' objects and the 'tidyverse'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://sfdep.josiahparry.com">https://sfdep.josiahparry.com</a>,
<a href="https://github.com/josiahparry/sfdep">https://github.com/josiahparry/sfdep</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>broom, dbscan, dplyr, ggplot2, knitr, magrittr, patchwork,
purrr, pracma, rmarkdown, sfnetworks, stringr, testthat (&ge;
3.0.0), tibble, tidyr, vctrs, yaml, zoo, Kendall, igraph,
tidygraph</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>sf, cli, spdep, stats, rlang</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-12 21:29:43 UTC; dlocke</td>
</tr>
<tr>
<td>Author:</td>
<td>Josiah Parry <a href="https://orcid.org/0000-0001-9910-865X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Dexter Locke <a href="https://orcid.org/0000-0003-2704-9720"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dexter Locke &lt;dexter.locke@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-13 12:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='active'>Activate spacetime context</h2><span id='topic+active'></span><span id='topic+activate'></span>

<h3>Description</h3>

<p>From a <code><a href="#topic+spacetime">spacetime</a></code> object, activate either the data or geometry contexts. The active object will then become available for manipulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>active(.data)

activate(.data, what)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="active_+3A_.data">.data</code></td>
<td>
<p>a spacetime object</p>
</td></tr>
<tr><td><code id="active_+3A_what">what</code></td>
<td>
<p>default NULL. Determines which context to activate. Valid argument values
are <code>"geometry"</code> and <code>"data"</code>. If left null, returns <code>.data</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A  <code><a href="#topic+spacetime">spacetime</a></code> object contains both a data frame and an sf object. The
data frame represents geographies over one or more time periods and the sf
object contains the geographic information for those locations.
</p>


<h3>Value</h3>

<p>For <code>activate()</code> an object of class spacetime with the specified context activated. <code>active()</code> returns a scalar character with the active context can be either &quot;goemetry&quot; or &quot;data&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df_fp &lt;- system.file("extdata", "bos-ecometric.csv", package = "sfdep")
geo_fp &lt;- system.file("extdata", "bos-ecometric.geojson", package = "sfdep")

# read in data
df &lt;- read.csv(
  df_fp, colClasses = c("character", "character", "integer", "double", "Date")
)
geo &lt;- sf::st_read(geo_fp)

# Create spacetime object called `bos`
bos &lt;- spacetime(df, geo,
                 .loc_col = ".region_id",
                 .time_col = "time_period")

active(bos)
activate(bos, "geometry")
</code></pre>

<hr>
<h2 id='as_sf'>Cast between <code>spacetime</code> and <code>sf</code> classes</h2><span id='topic+as_sf'></span><span id='topic+as_spacetime'></span><span id='topic+as_spacetime.sf'></span>

<h3>Description</h3>

<p>Cast between <code>spacetime</code> and <code>sf</code> classes
</p>
<p>Convert sf object to spacetime
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_sf(x, ...)

as_spacetime(x, .loc_col, .time_col, ...)

## S3 method for class 'sf'
as_spacetime(x, .loc_col, .time_col, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_sf_+3A_x">x</code></td>
<td>
<p>for <code><a href="sf.html#topic+st_as_sf">sf::st_as_sf()</a></code> a spacetime object. For <code><a href="#topic+as_spacetime">as_spacetime()</a></code>
an sf object.</p>
</td></tr>
<tr><td><code id="as_sf_+3A_...">...</code></td>
<td>
<p>arguments passed to merge.</p>
</td></tr>
<tr><td><code id="as_sf_+3A_.loc_col">.loc_col</code></td>
<td>
<p>the quoted name of the column containing unique location identifiers.</p>
</td></tr>
<tr><td><code id="as_sf_+3A_.time_col">.time_col</code></td>
<td>
<p>the quoted name of the column containing time periods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>as_spacetime()</code> returns a spacetime object. For <code>as_sf()</code>, an sf object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require(dplyr, quietly = TRUE)) {
  df_fp &lt;- system.file("extdata", "bos-ecometric.csv", package = "sfdep")
  geo_fp &lt;- system.file("extdata", "bos-ecometric.geojson", package = "sfdep")

  # read in data
  df &lt;- read.csv(
    df_fp, colClasses = c("character", "character", "integer", "double", "Date")
  )
  geo &lt;- sf::st_read(geo_fp)

  # Create spacetime object called `bos`
  bos &lt;- spacetime(df, geo,
                   .loc_col = ".region_id",
                   .time_col = "time_period")

  as_sf(bos)
  if (require("dplyr", quietly=TRUE)) {
    as_spacetime(as_sf(bos) , ".region_id", "year")
  }
}
</code></pre>

<hr>
<h2 id='center_mean'>Calculate Center Mean Point</h2><span id='topic+center_mean'></span><span id='topic+center_median'></span><span id='topic+euclidean_median'></span>

<h3>Description</h3>

<p>Given an sfc object containing points, calculate a measure of central tendency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center_mean(geometry, weights = NULL)

center_median(geometry)

euclidean_median(geometry, tolerance = 1e-09)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="center_mean_+3A_geometry">geometry</code></td>
<td>
<p>an sfc object. If a polygon, uses <code><a href="sf.html#topic+geos_unary">sf::st_point_on_surface()</a></code>.</p>
</td></tr>
<tr><td><code id="center_mean_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights to apply to the coordinates before calculation.</p>
</td></tr>
<tr><td><code id="center_mean_+3A_tolerance">tolerance</code></td>
<td>
<p>a tolerance level to terminate the process. This is passed to <code><a href="pracma.html#topic+geo_median">pracma::geo_median()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>center_mean()</code> calculates the mean center of a point pattern
</p>
</li>
<li> <p><code>euclidean_median()</code> calculates the euclidean median center of a point pattern using the <code>pracma</code> package
</p>
</li>
<li> <p><code>center_median()</code> calculates the median center it is recommended to use the euclidean median over the this function.
</p>
</li></ul>



<h3>Value</h3>

<p>an sfc POINT object
</p>


<h3>See Also</h3>

<p>Other point-pattern: 
<code><a href="#topic+std_distance">std_distance</a>()</code>
</p>
<p>Other point-pattern: 
<code><a href="#topic+std_distance">std_distance</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("pracma")) {

# Make a grid to sample from
grd &lt;- sf::st_make_grid(n = c(1, 1), cellsize = c(100, 100), offset = c(0,0))

# sample 100 points
pnts &lt;- sf::st_sample(grd, 100)

cm &lt;- center_mean(pnts)
em &lt;- euclidean_median(pnts)
cmed &lt;- center_median(pnts)

plot(pnts)
plot(cm, col = "red", add = TRUE)
plot(em, col = "blue", add = TRUE)
plot(cmed, col = "green", add = TRUE)
}
</code></pre>

<hr>
<h2 id='check_pkg_suggests'>Check if a vector of packages are available</h2><span id='topic+check_pkg_suggests'></span>

<h3>Description</h3>

<p>Check if a vector of packages are available
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_pkg_suggests(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_pkg_suggests_+3A_x">x</code></td>
<td>
<p>a character vector of package names</p>
</td></tr>
</table>

<hr>
<h2 id='check_polygon'>Checks geometry for polygons.</h2><span id='topic+check_polygon'></span>

<h3>Description</h3>

<p>If the provided geometry is a polygon, a point will be generated using <code><a href="sf.html#topic+geos_unary">sf::st_point_on_surface()</a></code>. If a centroid is preferred, a new column can be created that contains the output of <code><a href="sf.html#topic+geos_unary">sf::st_centroid()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_polygon(geometry)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_polygon_+3A_geometry">geometry</code></td>
<td>
<p>an sfc object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Point geometry
</p>

<hr>
<h2 id='class_modify'>Modify object classes</h2><span id='topic+class_modify'></span>

<h3>Description</h3>

<p>Appends classes to exist object classes. This is utilized to aid in adding a list class to objects created by spdep. This enables to use of the returned objects within data frames and tibbles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>class_modify(x, class = "list")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="class_modify_+3A_x">x</code></td>
<td>
<p>an object to modify</p>
</td></tr>
<tr><td><code id="class_modify_+3A_class">class</code></td>
<td>
<p>a character vector of classes to append to an object</p>
</td></tr>
</table>

<hr>
<h2 id='classify_hotspot'>Classify Hot Spot results</h2><span id='topic+classify_hotspot'></span>

<h3>Description</h3>

<p>Given the Gi* time-series and Mann Kendall scores classify the hotspot values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify_hotspot(.x, threshold)
</code></pre>

<hr>
<h2 id='complete_spacetime_cube'>Convert spacetime object to spacetime cube</h2><span id='topic+complete_spacetime_cube'></span>

<h3>Description</h3>

<p>Given a spacetime object, convert it to a spacetime cube. A spacetime cube
ensures that there is a regular time-series for each geometry present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete_spacetime_cube(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="complete_spacetime_cube_+3A_x">x</code></td>
<td>
<p>a spacetime object.</p>
</td></tr>
<tr><td><code id="complete_spacetime_cube_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If observations are missing for a time period and location combination,
columns will be populated with NAs.
</p>
<p>See <code><a href="#topic+is_spacetime_cube">is_spacetime_cube()</a></code> for more details on spacetime cubes.
</p>


<h3>Value</h3>

<p>A spacetime object that meets the criteria of spacetime cube.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df_fp &lt;- system.file("extdata", "bos-ecometric.csv", package = "sfdep")
geo_fp &lt;- system.file("extdata", "bos-ecometric.geojson", package = "sfdep")

# read in data
df &lt;- read.csv(df_fp, colClasses = c("character", "character", "integer", "double", "Date"))
geo &lt;- sf::st_read(geo_fp)

# Create spacetime object called `bos`
bos &lt;- spacetime(df, geo,
                 .loc_col = ".region_id",
                 .time_col = "time_period")

# create a sample of data
set.seed(0)
sample_index &lt;- sample(1:nrow(bos), nrow(bos) * 0.95)
incomplete_spt &lt;- bos[sample_index,]

# check to see if is spacetime cube
is_spacetime_cube(incomplete_spt)

# complete it again
complete_spacetime_cube(incomplete_spt)
</code></pre>

<hr>
<h2 id='cond_permute_nb'>Conditional permutation of neighbors</h2><span id='topic+cond_permute_nb'></span>

<h3>Description</h3>

<p>Creates a conditional permutation of neighbors list holding i fixed and shuffling it's neighbors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cond_permute_nb(nb, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cond_permute_nb_+3A_nb">nb</code></td>
<td>
<p>a neighbor list.</p>
</td></tr>
<tr><td><code id="cond_permute_nb_+3A_seed">seed</code></td>
<td>
<p>default null. A value to pass to <code>set.seed()</code> for reproducibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>nb</code> where each element contains a random sample of neighbors excluding the observed region.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nb &lt;- st_contiguity(guerry)
nb[1:5]
# conditionally permute neighbors
perm_nb &lt;- cond_permute_nb(nb)
perm_nb[1:5]
</code></pre>

<hr>
<h2 id='critical_threshold'>Identify critical threshold</h2><span id='topic+critical_threshold'></span>

<h3>Description</h3>

<p>Identifies the minimum distance in which each observation will have at least one neighbor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>critical_threshold(geometry, k = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="critical_threshold_+3A_geometry">geometry</code></td>
<td>
<p>an sf geometry column</p>
</td></tr>
<tr><td><code id="critical_threshold_+3A_k">k</code></td>
<td>
<p>the minimum number of neighbors to check for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric scalar value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>critical_threshold(sf::st_geometry(guerry))
</code></pre>

<hr>
<h2 id='ellipse'>Create an Ellipse</h2><span id='topic+ellipse'></span><span id='topic+st_ellipse'></span>

<h3>Description</h3>

<p>Generate an ellipse from center coordinates, major and minor axis radii, and angle rotation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipse(x = 0, y = 0, sx = 2, sy = 1, rotation = 0, n = 100)

st_ellipse(geometry, sx, sy, rotation = 0, n = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ellipse_+3A_x">x</code></td>
<td>
<p>longitude of center point</p>
</td></tr>
<tr><td><code id="ellipse_+3A_y">y</code></td>
<td>
<p>latitude of center point</p>
</td></tr>
<tr><td><code id="ellipse_+3A_sx">sx</code></td>
<td>
<p>radius of major axis</p>
</td></tr>
<tr><td><code id="ellipse_+3A_sy">sy</code></td>
<td>
<p>radius of minor axis</p>
</td></tr>
<tr><td><code id="ellipse_+3A_rotation">rotation</code></td>
<td>
<p>the degree of rotation of the ellipse</p>
</td></tr>
<tr><td><code id="ellipse_+3A_n">n</code></td>
<td>
<p>the number of coordinates to generate for the ellipse</p>
</td></tr>
<tr><td><code id="ellipse_+3A_geometry">geometry</code></td>
<td>
<p>an sf <code>ST_POINT</code> geometry. Can be <code>sfg</code>, <code>sfc</code>, or <code>sf</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+ellipse">ellipse()</a></code> returns a matrix of point locations defining the ellipse. <code><a href="#topic+st_ellipse">st_ellipse()</a></code> returns an sf object with LINE geography of the ellipse. Increasing n increases the number of points generated to define the ellipse shape.
</p>
<p><code><a href="#topic+ellipse">ellipse()</a></code> function is adapted from <code>ggVennDiagram</code>.
</p>


<h3>Value</h3>

<p>an sf object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ellipse(n = 10)
st_ellipse(sf::st_point(c(0, 0)), sx = 10, sy = 10)
</code></pre>

<hr>
<h2 id='emerging_hotspot_analysis'>Emerging Hot Spot Analysis</h2><span id='topic+emerging_hotspot_analysis'></span>

<h3>Description</h3>

<p>Emerging Hot Spot Analysis identifies trends in spatial clustering over a
period of time. Emerging hot spot analysis combines the Getis-Ord Gi* statistic
with the Mann-Kendall trend test to determine if there is a temporal trend
associated with local clustering of hot and cold spots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emerging_hotspot_analysis(
  x,
  .var,
  k = 1,
  include_gi = FALSE,
  nb_col = NULL,
  wt_col = NULL,
  nsim = 199,
  threshold = 0.01,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="emerging_hotspot_analysis_+3A_x">x</code></td>
<td>
<p>a spacetime object and must be a spacetime cube see details for more.</p>
</td></tr>
<tr><td><code id="emerging_hotspot_analysis_+3A_.var">.var</code></td>
<td>
<p>a numeric vector in the spacetime cube with no missing values.</p>
</td></tr>
<tr><td><code id="emerging_hotspot_analysis_+3A_k">k</code></td>
<td>
<p>default <code>1</code>. The number of time lags to include in the neighborhood
for calculating the local Gi*. See details for more.</p>
</td></tr>
<tr><td><code id="emerging_hotspot_analysis_+3A_include_gi">include_gi</code></td>
<td>
<p>default <code>FALSE</code>. If <code>TRUE</code>, includes the local Gi* calculations
in the attribute <code>gi_star</code>.</p>
</td></tr>
<tr><td><code id="emerging_hotspot_analysis_+3A_nb_col">nb_col</code></td>
<td>
<p>Optional. Default <code>NULL</code>. The name of the column in the <code>geometry</code>
context of <code>x</code> containing spatial neighbors. If <code>NULL</code>, Queen's contiguity
neighbors are identified.</p>
</td></tr>
<tr><td><code id="emerging_hotspot_analysis_+3A_wt_col">wt_col</code></td>
<td>
<p>Optional. Default <code>NULL</code>. The name of the column in the <code>geometry</code>
context of <code>x</code> containing spatial weights. If <code>NULL</code>, row standardized weights
are used.</p>
</td></tr>
<tr><td><code id="emerging_hotspot_analysis_+3A_nsim">nsim</code></td>
<td>
<p>default <code>199</code>. The number of simulations to run in calculating the
simulated p-value for the local Gi*.</p>
</td></tr>
<tr><td><code id="emerging_hotspot_analysis_+3A_threshold">threshold</code></td>
<td>
<p>default <code>0.01</code>. The significance threshold to use.</p>
</td></tr>
<tr><td><code id="emerging_hotspot_analysis_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>How Emerging Hot Spot Analysis Works</h4>

<p>Emerging Hot Spot Analysis is a somewhat simple process. It works by first
calculating the Gi* statistic for each location in each time period (time-slice).
Next, for each location across all time-periods, the Mann-Kendall trend test
is done to identify any temporal trend in Gi* values over all time periods.
Additionally, each location is classified into one of seventeen categories based
on <a href="https://pro.arcgis.com/en/pro-app/2.8/tool-reference/space-time-pattern-mining/learnmoreemerging.htm">ESRI's emerging hot spot classification criteria</a>.
</p>
<p>The Mann-Kendall trend test is done using <code><a href="Kendall.html#topic+MannKendall">Kendall::MannKendall()</a></code>. <code>Kendall</code>
is not installed with sfdep and should be installed prior to use.
</p>



<h4>Using your own neighbors and weights</h4>

<p>If you would like to use your own neighbors and weights, they must be created
in the <code>geometry</code> context of a spacetime object. The arguments <code>nb_col</code>
and <code>wt_col</code> must both be populated in order to use your own neighbor and weights
definitions.
</p>



<h4>Time lagged neighbors</h4>

<p>In addition to identifying neighbors in space, emerging hotspot analysis also
incorporates the same observations from <code>k</code> periods ago-called a time lag. If
the time lag k is 1 and the unit of time is month, the neighbors for the
calculation of Gi* would include the spatial neighbors' values at time <code>t</code>
and the same spatial neighbors' values at time <code>t-1</code>. If <code>k = 2</code>, it would include
<code>t</code>, <code>t-1</code>, and <code>t-2</code>.
</p>



<h4>Missing values</h4>

<p>Presently, there is no method of missing value handling. If there are missing
values, the emerging hot spot analysis will fail. Be sure to fill or omit
time-slices with missing values <em>prior</em> to using emerging hot spot analysis.
</p>



<h3>Value</h3>

<p>Returns a data.frame.
</p>


<h3>See Also</h3>

<p><a href="https://pro.arcgis.com/en/pro-app/2.8/tool-reference/space-time-pattern-mining/learnmoreemerging.htm">How Emerging Hot Spot Analysis works</a>, <a href="https://pro.arcgis.com/en/pro-app/2.8/tool-reference/space-time-pattern-mining/emerginghotspots.htm">Emerging Hot Spot Analysis (Space Time Pattern Mining)</a>, and the video <a href="https://www.youtube.com/watch?v=0aV6HHwJuo4&amp;t=3848s&amp;ab_channel=EsriEvents">Spatial Data Mining II: A Deep Dive into Space-Time Analysis</a> by ESRI.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("Kendall")) {
df_fp &lt;- system.file("extdata", "bos-ecometric.csv", package = "sfdep")
geo_fp &lt;- system.file("extdata", "bos-ecometric.geojson", package = "sfdep")

# read in data
df &lt;- read.csv(df_fp, colClasses = c("character", "character", "integer", "double", "Date"))
geo &lt;- sf::st_read(geo_fp)

# Create spacetime object called `bos`
bos &lt;- spacetime(df, geo,
                 .loc_col = ".region_id",
                 .time_col = "time_period")


# conduct EHSA
ehsa &lt;- emerging_hotspot_analysis(
  x = bos,
  .var = "value",
  k = 1,
  nsim = 9
)

ehsa
}

</code></pre>

<hr>
<h2 id='find_xj'>Identify xj values</h2><span id='topic+find_xj'></span>

<h3>Description</h3>

<p>Find <code>xj</code> values given a numeric vector, <code>x</code>, and neighbors list, <code>nb</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_xj(x, nb)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_xj_+3A_x">x</code></td>
<td>
<p>a vector of any class</p>
</td></tr>
<tr><td><code id="find_xj_+3A_nb">nb</code></td>
<td>
<p>a <code>nb</code> object e.g. created by <code><a href="#topic+st_contiguity">st_contiguity()</a></code> or <code><a href="#topic+st_knn">st_knn()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length <code>x</code> where each element is a numeric vector with the same length as the corresponding element in <code>nb</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nb &lt;- st_contiguity(sf::st_geometry(guerry))
xj &lt;- find_xj(guerry$crime_prop, nb)
xj[1:3]
</code></pre>

<hr>
<h2 id='global_c'>Compute Geary's C</h2><span id='topic+global_c'></span>

<h3>Description</h3>

<p>Compute Geary's C
</p>


<h3>Usage</h3>

<pre><code class='language-R'>global_c(x, nb, wt, allow_zero = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="global_c_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="global_c_+3A_nb">nb</code></td>
<td>
<p>a neighbor list object for example as created by <code>st_contiguity()</code>.</p>
</td></tr>
<tr><td><code id="global_c_+3A_wt">wt</code></td>
<td>
<p>a weights list as created by <code>st_weights()</code>.</p>
</td></tr>
<tr><td><code id="global_c_+3A_allow_zero">allow_zero</code></td>
<td>
<p>If <code>TRUE</code>, assigns zero as lagged value to zone without neighbors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two names elements <code>C</code> and <code>K</code> returning the value of Geary's C and sample kurtosis respectively.
</p>


<h3>See Also</h3>

<p>Other global_c: 
<code><a href="#topic+global_c_perm">global_c_perm</a>()</code>,
<code><a href="#topic+global_c_test">global_c_test</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nb &lt;- guerry_nb$nb
wt &lt;- guerry_nb$wt
x &lt;- guerry_nb$crime_pers
global_c(x, nb, wt)
</code></pre>

<hr>
<h2 id='global_c_perm'>Global C Permutation Test</h2><span id='topic+global_c_perm'></span>

<h3>Description</h3>

<p>Global C Permutation Test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>global_c_perm(
  x,
  nb,
  wt,
  nsim = 499,
  alternative = "greater",
  allow_zero = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="global_c_perm_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="global_c_perm_+3A_nb">nb</code></td>
<td>
<p>a neighbor list object for example as created by <code>st_contiguity()</code>.</p>
</td></tr>
<tr><td><code id="global_c_perm_+3A_wt">wt</code></td>
<td>
<p>a weights list as created by <code>st_weights()</code>.</p>
</td></tr>
<tr><td><code id="global_c_perm_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations to run.</p>
</td></tr>
<tr><td><code id="global_c_perm_+3A_alternative">alternative</code></td>
<td>
<p>default <code>"two.sided"</code>. Should be one of <code>"greater"</code>, <code>"less"</code>, or <code>"two.sided"</code> to specify the alternative hypothesis.</p>
</td></tr>
<tr><td><code id="global_c_perm_+3A_allow_zero">allow_zero</code></td>
<td>
<p>If <code>TRUE</code>, assigns zero as lagged value to zone without neighbors.</p>
</td></tr>
<tr><td><code id="global_c_perm_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="spdep.html#topic+geary.mc">spdep::geary.mc()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of classes <code>htest</code> and <code>mc.sim</code>
</p>


<h3>See Also</h3>

<p>Other global_c: 
<code><a href="#topic+global_c">global_c</a>()</code>,
<code><a href="#topic+global_c_test">global_c_test</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geo &lt;- sf::st_geometry(guerry)
nb &lt;- st_contiguity(geo)
wt &lt;- st_weights(nb)
x &lt;- guerry$crime_pers
global_c_perm(x, nb, wt)
</code></pre>

<hr>
<h2 id='global_c_test'>Global C Test</h2><span id='topic+global_c_test'></span>

<h3>Description</h3>

<p>Global C Test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>global_c_test(x, nb, wt, randomization = TRUE, allow_zero = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="global_c_test_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="global_c_test_+3A_nb">nb</code></td>
<td>
<p>a neighbor list object for example as created by <code>st_contiguity()</code>.</p>
</td></tr>
<tr><td><code id="global_c_test_+3A_wt">wt</code></td>
<td>
<p>a weights list as created by <code>st_weights()</code>.</p>
</td></tr>
<tr><td><code id="global_c_test_+3A_randomization">randomization</code></td>
<td>
<p>default <code>TRUE</code>. Calculate variance based on randomization. If <code>FALSE</code>, under the assumption of normality.</p>
</td></tr>
<tr><td><code id="global_c_test_+3A_allow_zero">allow_zero</code></td>
<td>
<p>If <code>TRUE</code>, assigns zero as lagged value to zone without neighbors.</p>
</td></tr>
<tr><td><code id="global_c_test_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="spdep.html#topic+moran.mc">spdep::moran.mc()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>htest</code> object
</p>


<h3>See Also</h3>

<p>Other global_c: 
<code><a href="#topic+global_c">global_c</a>()</code>,
<code><a href="#topic+global_c_perm">global_c_perm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geo &lt;- sf::st_geometry(guerry)
nb &lt;- st_contiguity(geo)
wt &lt;- st_weights(nb)
x &lt;- guerry$crime_pers
global_c_test(x, nb, wt)
</code></pre>

<hr>
<h2 id='global_colocation'>Global Colocation Quotient</h2><span id='topic+global_colocation'></span>

<h3>Description</h3>

<p>Calculate the Global Colocation Quotient (CLQ) for a categorical variable using simulation based significance testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>global_colocation(A, nb, nsim = 99)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="global_colocation_+3A_a">A</code></td>
<td>
<p>a character or factor vector.</p>
</td></tr>
<tr><td><code id="global_colocation_+3A_nb">nb</code></td>
<td>
<p>a neighbors list e.g. created by <code><a href="#topic+st_knn">st_knn()</a></code> or <code><a href="#topic+st_contiguity">st_contiguity()</a></code></p>
</td></tr>
<tr><td><code id="global_colocation_+3A_nsim">nsim</code></td>
<td>
<p>default <code>99</code>. An integer representing how many simulations to run for calculating the simulated p-values.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Definition</h4>

<p>The CLQ is defined as <code class="reqn">CLQ_{Global} = \frac{\sum_{A \in X} C_{A \to A}}{\sum_{A \in X} N_A ({\frac{N_A - 1}{N-1})}}</code>. The numerator identifies the observed proportion of same-category neighbors while the denominator contains the <em>expected</em> proportion of same-category neighbors under the assumption of no spatial association. Thus the CLQ is just a ratio of observed to expected.
</p>



<h4>Inference</h4>

<p>Inference is done using conditional permutation as suggested by Anselin 1995 where a number of replicates are created. The observed values are compared to the replicates and a the simulated p-value is the proportion of cases where the observed is more extreme as compared to replicate. The simulated p-value returns the lower p-value of either tail.
</p>



<h4>Interpretation</h4>

<p>Given that the CLQ is a ratio of the observed to expected, we interpret values larger than one to mean that there is more colocation than to be expected under the null hypothesis of no spatial association. When the value is smaller than 0, we interpret it to mean that there is less colocation than expected under the null.
</p>



<h3>Value</h3>

<p>A list of two elements <code>CLQ</code> and <code>p_sim</code> containing the observed colocation quotient and the simulated p-value respectively.
</p>


<h3>References</h3>

<p>Leslie, T.F. and Kronenfeld, B.J. (2011), The Colocation Quotient: A New Measure of Spatial Association Between Categorical Subsets of Points. Geographical Analysis, 43: 306-326. <a href="https://doi.org/10.1111/j.1538-4632.2011.00821.x">doi:10.1111/j.1538-4632.2011.00821.x</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- guerry$main_city
nb &lt;- st_contiguity(sf::st_geometry(guerry))
global_colocation(A, nb, 49)
</code></pre>

<hr>
<h2 id='global_colocation_calc'>Calculate the Global Colocation Quotient</h2><span id='topic+global_colocation_calc'></span>

<h3>Description</h3>

<p>Given a categorical variable <code>A</code>, calculate the global colocation quotient (CLQ).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>global_colocation_calc(A, nb)
</code></pre>

<hr>
<h2 id='global_colocation_perm_impl'>Global Colocation Quotient Conditional Permutation Implementation</h2><span id='topic+global_colocation_perm_impl'></span>

<h3>Description</h3>

<p>This function will repeat calculation of the global colocation quotient (CLQ)
a specified number of times and return a simulated p-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>global_colocation_perm_impl(A, nb, nsim = 99)
</code></pre>

<hr>
<h2 id='global_g_test'>Getis-Ord Global G</h2><span id='topic+global_g_test'></span>

<h3>Description</h3>

<p>Getis-Ord Global G
</p>


<h3>Usage</h3>

<pre><code class='language-R'>global_g_test(x, nb, wt, alternative = "greater", allow_zero = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="global_g_test_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="global_g_test_+3A_nb">nb</code></td>
<td>
<p>a neighbor list object for example as created by <code>st_contiguity()</code>.</p>
</td></tr>
<tr><td><code id="global_g_test_+3A_wt">wt</code></td>
<td>
<p>a weights list as created by <code>st_weights()</code>.</p>
</td></tr>
<tr><td><code id="global_g_test_+3A_alternative">alternative</code></td>
<td>
<p>default <code>"two.sided"</code>. Should be one of <code>"greater"</code>, <code>"less"</code>, or <code>"two.sided"</code> to specify the alternative hypothesis.</p>
</td></tr>
<tr><td><code id="global_g_test_+3A_allow_zero">allow_zero</code></td>
<td>
<p>If <code>TRUE</code>, assigns zero as lagged value to zone without neighbors.</p>
</td></tr>
<tr><td><code id="global_g_test_+3A_...">...</code></td>
<td>
<p>additional methods passed to <code><a href="spdep.html#topic+globalG.test">spdep::globalG.test()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>htest</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geo &lt;- sf::st_geometry(guerry)
nb &lt;- st_contiguity(geo)
wt &lt;- st_weights(nb, style = "B")
x &lt;- guerry$crime_pers
global_g_test(x, nb, wt)
</code></pre>

<hr>
<h2 id='global_jc_perm'>Global Join Counts</h2><span id='topic+global_jc_perm'></span><span id='topic+global_jc_test'></span><span id='topic+tally_jc'></span>

<h3>Description</h3>

<p>Calculate global join count measure for a categorical variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>global_jc_perm(
  fx,
  nb,
  wt,
  alternative = "greater",
  nsim = 499,
  allow_zero = FALSE,
  ...
)

global_jc_test(fx, nb, wt, alternative = "greater", allow_zero = NULL, ...)

tally_jc(fx, nb, wt, allow_zero = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="global_jc_perm_+3A_fx">fx</code></td>
<td>
<p>a factor or character vector of the same length as nb.</p>
</td></tr>
<tr><td><code id="global_jc_perm_+3A_nb">nb</code></td>
<td>
<p>a neighbor list object for example as created by <code>st_contiguity()</code>.</p>
</td></tr>
<tr><td><code id="global_jc_perm_+3A_wt">wt</code></td>
<td>
<p>a weights list as created by <code>st_weights()</code>.</p>
</td></tr>
<tr><td><code id="global_jc_perm_+3A_alternative">alternative</code></td>
<td>
<p>default <code>"two.sided"</code>. Should be one of <code>"greater"</code>, <code>"less"</code>, or <code>"two.sided"</code> to specify the alternative hypothesis.</p>
</td></tr>
<tr><td><code id="global_jc_perm_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations to run.</p>
</td></tr>
<tr><td><code id="global_jc_perm_+3A_allow_zero">allow_zero</code></td>
<td>
<p>If <code>TRUE</code>, assigns zero as lagged value to zone without neighbors.</p>
</td></tr>
<tr><td><code id="global_jc_perm_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>global_jc_perm()</code> implements the monte-carlo based join count using <code>spdep::joincount.mc()</code>
</p>
</li>
<li> <p><code>global_jc_test()</code> implements the traditional BB join count statistic using <code>spdep::joincount.test()</code>
</p>
</li>
<li> <p><code>tally_jc()</code> calculated join counts for a variable <code>fx</code> and returns a data.frame using <code>spdep::joincount.multi()</code>
</p>
</li></ul>



<h3>Value</h3>

<p>an object of class <code>jclist</code> which is a list where each element is of class <code>htest</code> and <code>mc.sim</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geo &lt;- sf::st_geometry(guerry)
nb &lt;- st_contiguity(geo)
wt &lt;- st_weights(nb, style = "B")
fx &lt;- guerry$region
global_jc_perm(fx, nb, wt)

global_jc_test(fx, nb, wt)

tally_jc(fx, nb, wt)
</code></pre>

<hr>
<h2 id='global_moran'>Calculate Global Moran's I</h2><span id='topic+global_moran'></span>

<h3>Description</h3>

<p>Calculate Global Moran's I
</p>


<h3>Usage</h3>

<pre><code class='language-R'>global_moran(x, nb, wt, na_ok = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="global_moran_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="global_moran_+3A_nb">nb</code></td>
<td>
<p>a neighbor list object for example as created by <code>st_contiguity()</code>.</p>
</td></tr>
<tr><td><code id="global_moran_+3A_wt">wt</code></td>
<td>
<p>a weights list as created by <code>st_weights()</code>.</p>
</td></tr>
<tr><td><code id="global_moran_+3A_na_ok">na_ok</code></td>
<td>
<p>default <code>FALSE</code>. If <code>FALSE</code> presence or <code>NA</code> or <code>Inf</code> results in an error.</p>
</td></tr>
<tr><td><code id="global_moran_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="spdep.html#topic+moran">spdep::moran()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>htest</code> object
</p>


<h3>See Also</h3>

<p>Other global_moran: 
<code><a href="#topic+global_moran_bv">global_moran_bv</a>()</code>,
<code><a href="#topic+global_moran_perm">global_moran_perm</a>()</code>,
<code><a href="#topic+global_moran_test">global_moran_test</a>()</code>,
<code><a href="#topic+local_moran_bv">local_moran_bv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nb &lt;- guerry_nb$nb
wt &lt;- guerry_nb$wt
x &lt;- guerry_nb$crime_pers
moran &lt;- global_moran(x, nb, wt)
</code></pre>

<hr>
<h2 id='global_moran_bv'>Compute the Global Bivariate Moran's I</h2><span id='topic+global_moran_bv'></span>

<h3>Description</h3>

<p>Given two continuous numeric variables, calculate the bivariate Moran's I. See details for more.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>global_moran_bv(x, y, nb, wt, nsim = 99, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="global_moran_bv_+3A_x">x</code></td>
<td>
<p>a numeric vector of same length as <code>y</code>.</p>
</td></tr>
<tr><td><code id="global_moran_bv_+3A_y">y</code></td>
<td>
<p>a numeric vector of same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="global_moran_bv_+3A_nb">nb</code></td>
<td>
<p>a neighbor list object for example as created by <code>st_contiguity()</code>.</p>
</td></tr>
<tr><td><code id="global_moran_bv_+3A_wt">wt</code></td>
<td>
<p>a weights list as created by <code>st_weights()</code>.</p>
</td></tr>
<tr><td><code id="global_moran_bv_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulations to run.</p>
</td></tr>
<tr><td><code id="global_moran_bv_+3A_scale">scale</code></td>
<td>
<p>default <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Global Bivariate Moran is defined as
</p>
<p><code class="reqn">
I_B = \frac{\Sigma_i(\Sigma_j{w_{ij}y_j\times x_i})}{\Sigma_i{x_i^2}}
</code>
</p>
<p>It is important to note that this is a measure of autocorrelation of X
with the spatial lag of Y. As such, the resultant measure may overestimate the amount of
spatial autocorrelation which may be a product of the inherent correlation of X and Y.
</p>


<h3>Value</h3>

<p>an object of class boot
</p>


<h3>References</h3>

<p><a href="https://geodacenter.github.io/workbook/5b_global_adv/lab5b.html">Global Spatial Autocorrelation (2): Bivariate, Differential and EB Rate Moran Scatter Plot, Luc Anselin</a>
</p>


<h3>See Also</h3>

<p>Other global_moran: 
<code><a href="#topic+global_moran">global_moran</a>()</code>,
<code><a href="#topic+global_moran_perm">global_moran_perm</a>()</code>,
<code><a href="#topic+global_moran_test">global_moran_test</a>()</code>,
<code><a href="#topic+local_moran_bv">local_moran_bv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- guerry_nb$crime_pers
y &lt;- guerry_nb$wealth
nb &lt;- guerry_nb$nb
wt &lt;- guerry_nb$wt
global_moran_bv(x, y, nb, wt)
</code></pre>

<hr>
<h2 id='global_moran_perm'>Global Moran Permutation Test</h2><span id='topic+global_moran_perm'></span>

<h3>Description</h3>

<p>Global Moran Permutation Test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>global_moran_perm(x, nb, wt, alternative = "two.sided", nsim = 499, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="global_moran_perm_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="global_moran_perm_+3A_nb">nb</code></td>
<td>
<p>a neighbor list object for example as created by <code>st_contiguity()</code>.</p>
</td></tr>
<tr><td><code id="global_moran_perm_+3A_wt">wt</code></td>
<td>
<p>a weights list as created by <code>st_weights()</code>.</p>
</td></tr>
<tr><td><code id="global_moran_perm_+3A_alternative">alternative</code></td>
<td>
<p>default <code>"two.sided"</code>. Should be one of <code>"greater"</code>, <code>"less"</code>, or <code>"two.sided"</code> to specify the alternative hypothesis.</p>
</td></tr>
<tr><td><code id="global_moran_perm_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations to run.</p>
</td></tr>
<tr><td><code id="global_moran_perm_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="spdep.html#topic+moran.mc">spdep::moran.mc()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of classes <code>htest</code>, and <code>mc.sim</code>.
</p>


<h3>See Also</h3>

<p>Other global_moran: 
<code><a href="#topic+global_moran">global_moran</a>()</code>,
<code><a href="#topic+global_moran_bv">global_moran_bv</a>()</code>,
<code><a href="#topic+global_moran_test">global_moran_test</a>()</code>,
<code><a href="#topic+local_moran_bv">local_moran_bv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nb &lt;- guerry_nb$nb
wt &lt;- guerry_nb$wt
x &lt;- guerry_nb$crime_pers
moran &lt;- global_moran_perm(x, nb, wt)
moran
</code></pre>

<hr>
<h2 id='global_moran_test'>Global Moran Test</h2><span id='topic+global_moran_test'></span>

<h3>Description</h3>

<p>Global Moran Test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>global_moran_test(
  x,
  nb,
  wt,
  alternative = "greater",
  randomization = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="global_moran_test_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="global_moran_test_+3A_nb">nb</code></td>
<td>
<p>a neighbor list object for example as created by <code>st_contiguity()</code>.</p>
</td></tr>
<tr><td><code id="global_moran_test_+3A_wt">wt</code></td>
<td>
<p>a weights list as created by <code>st_weights()</code>.</p>
</td></tr>
<tr><td><code id="global_moran_test_+3A_alternative">alternative</code></td>
<td>
<p>default <code>"two.sided"</code>. Should be one of <code>"greater"</code>, <code>"less"</code>, or <code>"two.sided"</code> to specify the alternative hypothesis.</p>
</td></tr>
<tr><td><code id="global_moran_test_+3A_randomization">randomization</code></td>
<td>
<p>default <code>TRUE</code>. Calculate variance based on randomization. If <code>FALSE</code>, under the assumption of normality.</p>
</td></tr>
<tr><td><code id="global_moran_test_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="spdep.html#topic+moran.mc">spdep::moran.mc()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>htest</code>
</p>


<h3>See Also</h3>

<p>Other global_moran: 
<code><a href="#topic+global_moran">global_moran</a>()</code>,
<code><a href="#topic+global_moran_bv">global_moran_bv</a>()</code>,
<code><a href="#topic+global_moran_perm">global_moran_perm</a>()</code>,
<code><a href="#topic+local_moran_bv">local_moran_bv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nb &lt;- guerry_nb$nb
wt &lt;- guerry_nb$wt
x &lt;- guerry_nb$crime_pers
global_moran_test(x, nb, wt)
</code></pre>

<hr>
<h2 id='guerry'>&quot;Essay on the Moral Statistics of France&quot; data set.</h2><span id='topic+guerry'></span><span id='topic+guerry_nb'></span>

<h3>Description</h3>

<p>This dataset has been widely used to demonstrate geospatial methods and techniques. As such it is useful for inclusion to this R package for the purposes of example. The dataset in this package is modified from Guerry by <a href="https://www.datavis.ca/">Michael Friendly</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guerry

guerry_nb
</code></pre>


<h3>Format</h3>

<p>An object of class <code>sf</code> (inherits from <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 85 rows and 27 columns.
</p>
<p><code>guerry</code> an sf object with 85 observations and 27 variables. <code>guerry_nb</code> has 2 additional variables created by <code>sfdep</code>.
</p>


<h3>Details</h3>

<p><code>guerry</code> and <code>guerry_nb</code> objects are sf class objects. These are polygons of the boundaries of France (excluding Corsica) as they were in 1830.
</p>


<h3>Source</h3>

<p><code>Guerry::gfrance85</code>
</p>

<hr>
<h2 id='include_self'>Includes self in neighbor list</h2><span id='topic+include_self'></span><span id='topic+remove_self'></span>

<h3>Description</h3>

<p>Includes observed region in list of own neighbors. For some neighbor lists, it is important to include the ith observation (or self) in the neighbors list, particularly for kernel weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>include_self(nb)

remove_self(nb)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="include_self_+3A_nb">nb</code></td>
<td>
<p>an object of class <code>nb</code> e.g. made by <code><a href="#topic+st_contiguity">st_contiguity()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>nb</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nb &lt;- st_contiguity(guerry)
self_included &lt;- include_self(nb)
self_included
remove_self(self_included)
</code></pre>

<hr>
<h2 id='inverse_dist_calc'>Calculate inverse distance weights</h2><span id='topic+inverse_dist_calc'></span>

<h3>Description</h3>

<p>Calculate inverse distance weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inverse_dist_calc(.x, scale, alpha)
</code></pre>

<hr>
<h2 id='is_spacetime_cube'>Test if a spacetime object is a spacetime cube</h2><span id='topic+is_spacetime_cube'></span>

<h3>Description</h3>

<p>Given an object with class <code>spacetime</code>, determine if it is a <em>spacetime cube</em>.
If the time-series is is irregular a warning is emitted
(see <code><a href="#topic+validate_spacetime">validate_spacetime()</a></code> for more on the restrictions on the time column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_spacetime_cube(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_spacetime_cube_+3A_x">x</code></td>
<td>
<p>a spacetime object</p>
</td></tr>
<tr><td><code id="is_spacetime_cube_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A spacetime object is a spacetime cube when it contains a regular time-series
representation of each geometry. That is, only one observation for at each
time period per geography is present.
</p>
<p>The number of rows in a spacetime cube is the number of geographies multiplied
by the number of time periods. For example if there are 10 locations and 20
time periods, the number of rows must be 200.
</p>


<h3>Value</h3>

<p>A logical scalar.
</p>


<h3>Validation</h3>

<p><code>is_spacetime_cube()</code> runs a number of checks that to ensure that the provided
object is in fact a spacetime cube. It checks that:
</p>

<ul>
<li><p> the number of rows is equal to the number of locations multiplied by the number
of time periods
</p>
</li>
<li><p> each time period has an equal number of observations
</p>
</li>
<li><p> each location has an equal number of observations
</p>
</li>
<li><p> each combination of time period and location has only one observation
</p>
</li>
<li><p> that the time-series is regular
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("zoo", quietly = TRUE)) {
df_fp &lt;- system.file("extdata", "bos-ecometric.csv", package = "sfdep")
geo_fp &lt;- system.file("extdata", "bos-ecometric.geojson", package = "sfdep")

# read in data
df &lt;- read.csv(
  df_fp, colClasses = c("character", "character", "integer", "double", "Date")
)
geo &lt;- sf::st_read(geo_fp)

# Create spacetime object called `bos`
bos &lt;- spacetime(df, geo,
                .loc_col = ".region_id",
                .time_col = "time_period")

is_spacetime_cube(bos)
is_spacetime_cube(bos[round(runif(1000, 0, nrow(bos))),])
is_spacetime_cube(guerry)
}
</code></pre>

<hr>
<h2 id='jc_bjc_calc'>Calculate BJC Bivariate Case</h2><span id='topic+jc_bjc_calc'></span>

<h3>Description</h3>

<p>Assumes no colocation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jc_bjc_calc(x, xj, z, zj, wt)
</code></pre>

<hr>
<h2 id='jc_bjc_perm_impl'>Calculate BJC BV for conditional permutations</h2><span id='topic+jc_bjc_perm_impl'></span>

<h3>Description</h3>

<p>Calculate BJC BV for conditional permutations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jc_bjc_perm_impl(x, z, listw, index)
</code></pre>

<hr>
<h2 id='jc_clc_perm_impl'>Calculate CLC BV for conditional permutations</h2><span id='topic+jc_clc_perm_impl'></span>

<h3>Description</h3>

<p>Calculate CLC BV for conditional permutations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jc_clc_perm_impl(x, z, listw, index)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jc_clc_perm_impl_+3A_x">x</code></td>
<td>
<p>a binary variable consisting of 1 and 0, or <code>TRUE</code> and <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="jc_clc_perm_impl_+3A_z">z</code></td>
<td>
<p>a binary variable consisting of 1 and 0, or <code>TRUE</code> and <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="jc_clc_perm_impl_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object</p>
</td></tr>
<tr><td><code id="jc_clc_perm_impl_+3A_index">index</code></td>
<td>
<p>an integer vector identifying positions to subset.</p>
</td></tr>
</table>

<hr>
<h2 id='kernels'>Kernel functions</h2><span id='topic+kernels'></span>

<h3>Description</h3>

<p>Kernel functions for creating kernel based weights with <code><a href="#topic+st_kernel_weights">st_kernel_weights()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernels
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 5.
</p>


<h3>Details</h3>

<p>Supported kernels are below.
</p>
<p>Formulas come from Anselin &amp; Morrison's <a href="https://spatialanalysis.github.io/lab_tutorials/Spatial_Weights_as_Distance_Functions.html#kernal-weights">notes</a>.
</p>

<ul>
<li> <p><code>uniform</code>:  K(z) = 1/2 for |z|&lt;1
</p>
</li>
<li> <p><code>triangular</code>: K(z) = (1-|z|) for |z| &lt; 1
</p>
</li>
<li> <p><code>epanechnikov</code>: K(z) = (3/4)(1-z^2) for |z| &lt; 1
</p>
</li>
<li> <p><code>quartic</code>: K(z) = (15/16)*(1-(z/threshold)^2^)2 for |z| &lt; 1
</p>
</li>
<li> <p><code>gaussian</code>: K(z) = (2pi)^{1/2} * exp(-z^2/2)
</p>
</li></ul>



<h3>Value</h3>

<p>a list of length 5 where each element is a kernel function.
</p>

<hr>
<h2 id='local_c'>Compute Local Geary statistic</h2><span id='topic+local_c'></span><span id='topic+local_c_perm'></span>

<h3>Description</h3>

<p>The Local Geary is a local adaptation of Geary's C statistic of spatial autocorrelation. The Local Geary uses squared differences to measure dissimilarity unlike the Local Moran. Low values of the Local Geary indicate positive spatial autocorrelation and large refers to negative spatial autocorrelation.
Inference for the Local Geary is based on a permutation approach which compares the observed value to the reference distribution under spatial randomness. The Local Geary creates a pseudo p-value. This is not an analytical p-value and is based on the number of permutations and as such should be used with care.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_c(x, nb, wt, ...)

local_c_perm(x, nb, wt, nsim = 499, alternative = "two.sided", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="local_c_+3A_x">x</code></td>
<td>
<p>a numeric vector, or list of numeric vectors of equal length.</p>
</td></tr>
<tr><td><code id="local_c_+3A_nb">nb</code></td>
<td>
<p>a neighbor list</p>
</td></tr>
<tr><td><code id="local_c_+3A_wt">wt</code></td>
<td>
<p>a weights list</p>
</td></tr>
<tr><td><code id="local_c_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="spdep.html#topic+localC">spdep::localC_perm()</a></code>, e.g. <code>zero.policy = TRUE</code> to allow for zones without neighbors.</p>
</td></tr>
<tr><td><code id="local_c_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations used to generate reference distribution.</p>
</td></tr>
<tr><td><code id="local_c_+3A_alternative">alternative</code></td>
<td>
<p>A character defining the alternative hypothesis. Must be one of &quot;two.sided&quot;, &quot;less&quot; or &quot;greater&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Overview</h4>

<p>The Local Geary can be extended to a multivariate context. When <code>x</code> is a numeric vector, the univariate Local Geary will be calculated. To calculate the multivariate Local Moran provide either a list or a matrix. When <code>x</code> is a list, each element must be a numeric vector of the same length and of the same length as the neighbours in <code>listw</code>. In the case that <code>x</code> is a matrix the number of rows must be the same as the length of the neighbours in <code>listw</code>.
</p>
<p>While not required in the univariate context, the standardized Local Geary is calculated. The multivariate Local Geary is <em>always</em> standardized.
</p>
<p>The univariate Local Geary is calculated as <code class="reqn">c_i = \sum_j w_{ij}(x_i - x_j)^2</code> and the multivariate Local Geary is calculated as <code class="reqn">c_{k,i} = \sum_{v=1}^{k} c_{v,i}</code> as described in Anselin (2019).
</p>



<h4>Implementation</h4>

<p>These functions are based on the implementations of the local Geary statistic in the development version of spdep. They are based on <a href="spdep.html#topic+localC">spdep::localC</a> and <a href="spdep.html#topic+localC">spdep::localC_perm</a>.
</p>
<p><a href="spdep.html#topic+localC">spdep::localC_perm</a> and thus <a href="#topic+local_c_perm">local_c_perm</a> utilize a conditional permutation approach to approximate a reference distribution where each observation <code>i</code> is held fixed, randomly samples neighbors, and calculated the local C statistic for that tuple (<code>ci</code>). This is repeated <code>nsim</code> times. From the simulations 3 different types of p-values are calculated—all of which have their potential flaws. So be <em>extra judicious</em> with using p-values to make conclusions.
</p>

<ul>
<li> <p><code>p_ci</code>: utilizes the sample mean and standard deviation. The p-value is then calculated using <code>pnorm()</code>&ndash;assuming a normal distribution which isn't always true.
</p>
</li>
<li> <p><code>p_ci_sim</code>: uses the rank of the observed statistic.
</p>
</li>
<li> <p><code>p_folded_sim</code>: follows the pysal implementation where p-values are in the range of [0, 0.5]. This excludes 1/2 of all p-values and should be used with caution.
</p>
</li></ul>




<h3>Value</h3>

<p>a <code>data.frame</code> with columns
</p>

<ul>
<li> <p><code>ci</code>: Local Geary statistic
</p>
</li>
<li> <p><code>e_ci</code>: expected value of the Local Geary based on permutations
</p>
</li>
<li> <p><code>z_ci</code>: standard deviation based on permutations
</p>
</li>
<li> <p><code>var_ci</code>: variance based on permutations
</p>
</li>
<li> <p><code>p_ci</code>: p-value based on permutation sample standard deviation and means
</p>
</li>
<li> <p><code>p_ci_sim</code>: p-value based on rank of observed statistic
</p>
</li>
<li> <p><code>p_folded_sim</code>: p-value based on the implementation of Pysal which always assumes a two-sided test taking the minimum possible p-value
</p>
</li>
<li> <p><code>skewness</code>: sample skewness
</p>
</li>
<li> <p><code>kurtosis</code>: sample kurtosis
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Josiah Parry, <a href="mailto:josiah.parry@gmail.com">josiah.parry@gmail.com</a>
</p>


<h3>References</h3>

<p>Anselin, L. (1995), Local Indicators of Spatial Association—LISA. Geographical Analysis, 27: 93-115. <a href="https://doi.org/10.1111/j.1538-4632.1995.tb00338.x">doi:10.1111/j.1538-4632.1995.tb00338.x</a>
</p>
<p>Anselin, L. (2019), A Local Indicator of Multivariate Spatial Association: Extending Geary's c. Geogr Anal, 51: 133-150. <a href="https://doi.org/10.1111/gean.12164">doi:10.1111/gean.12164</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
local_c_perm(guerry_nb$crime_pers, guerry_nb$nb, guerry_nb$wt)

</code></pre>

<hr>
<h2 id='local_colocation'>Local indicator of Colocation Quotient</h2><span id='topic+local_colocation'></span>

<h3>Description</h3>

<p>The local indicator of the colocation quotient (LCLQ) is a Local Indicator of Spatial Association (LISA) that evaluates if a given observation's subcategory in A is colocated with subcategories in B. Like the CLQ, the LCLQ provides insight into the asymmetric relationships between subcategories of A and B (where B can also equal A) but at the local level.
</p>
<p>The LCLQ is defined using Gaussian kernel weights and an adaptive bandwidth (see <code><a href="#topic+st_kernel_weights">st_kernel_weights()</a></code>). However, any type of weights list can be used. Kernel weights are used to introduce a decay into the calculation of the CLQ. This ensures that points nearer to the focal point have more influence than those that are more distant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_colocation(A, B, nb, wt, nsim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="local_colocation_+3A_a">A</code></td>
<td>
<p>a character or factor vector.</p>
</td></tr>
<tr><td><code id="local_colocation_+3A_b">B</code></td>
<td>
<p>a character or factor vector.</p>
</td></tr>
<tr><td><code id="local_colocation_+3A_nb">nb</code></td>
<td>
<p>a neighbors list e.g. created by <code><a href="#topic+st_knn">st_knn()</a></code> or <code><a href="#topic+st_contiguity">st_contiguity()</a></code></p>
</td></tr>
<tr><td><code id="local_colocation_+3A_wt">wt</code></td>
<td>
<p>a weights list. Recommended that it is a Gaussian kernel weights list using an adaptive bandwidth e.g. created by <code>st_kernel_weights(nb, geometry, "gaussian", addaptive = TRUE)</code> that does not include the self.</p>
</td></tr>
<tr><td><code id="local_colocation_+3A_nsim">nsim</code></td>
<td>
<p>default <code>99</code>. An integer representing how many simulations to run for calculating the simulated p-values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The LCLQ is defined as <code class="reqn">LCLQ_{A_i \to B} = \frac{N_{A_i \to B}}{N_B / (N - 1)}</code> where <code class="reqn">N_{A_i \to B} = \sum_{j = 1(j \ne i)}^{N}(\frac{w_{ij}f_{ij}}{\sum_{j = 1(j \ne i)}^{N}w_{ij}})</code>. And the weights matrix, wij, uses adaptive bandwidth Gaussian kernel weights.
</p>
<p>LCLQ is only calculated for those subcategories which are present in the neighbor list. If a subcategory is not present, then the resultant LCLQ and simulated p-value will be <code>NA</code>.
</p>


<h3>Value</h3>

<p>a data frame with as many rows as observations in A and two times as many columns as unique values in B. Columns contain each unique value of B as well as the simulated p-value for each value of B.
</p>


<h3>References</h3>

<p>Fahui Wang, Yujie Hu, Shuai Wang &amp; Xiaojuan Li (2017) Local Indicator of Colocation Quotient with a Statistical Significance Test: Examining Spatial Association of Crime and Facilities, The Professional Geographer, 69:1, 22-31, <a href="https://doi.org/10.1080/00330124.2016.1157498">doi:10.1080/00330124.2016.1157498</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- guerry$main_city
B &lt;- guerry$region
geo &lt;- sf::st_centroid(sf::st_geometry(guerry))
nb &lt;- include_self(st_knn(geo, 5))
wt &lt;- st_kernel_weights(nb, geo, "gaussian", adaptive = TRUE)
res &lt;- local_colocation(A, B, nb, wt, 9)
tail(res)
</code></pre>

<hr>
<h2 id='local_colocation_calc'>Calculate the local colocation quotient</h2><span id='topic+local_colocation_calc'></span>

<h3>Description</h3>

<p>Calculate the local colocation quotient
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_colocation_calc(A, B, listw)
</code></pre>


<h3>Value</h3>

<p>a matrix
</p>

<hr>
<h2 id='local_colocation_impl'>spdep implementation of local colocation quotient</h2><span id='topic+local_colocation_impl'></span>

<h3>Description</h3>

<p>Internal implementation of the local CLQ that is compatible with spdep.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_colocation_impl(A, B, listw, nsim = 99)
</code></pre>


<h3>Value</h3>

<p>a data frame where the number of rows is the same length as <code>A</code> and the number of columns is the same as unique values in <code>B</code>.
</p>

<hr>
<h2 id='local_g'>Local G</h2><span id='topic+local_g'></span><span id='topic+local_g_perm'></span>

<h3>Description</h3>

<p>Calculate the local Geary statistic for a given variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_g(x, nb, wt, alternative = "two.sided", ...)

local_g_perm(x, nb, wt, nsim = 499, alternative = "two.sided", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="local_g_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="local_g_+3A_nb">nb</code></td>
<td>
<p>a neighbor list object for example as created by <code>st_contiguity()</code>.</p>
</td></tr>
<tr><td><code id="local_g_+3A_wt">wt</code></td>
<td>
<p>a weights list as created by <code>st_weights()</code>.</p>
</td></tr>
<tr><td><code id="local_g_+3A_alternative">alternative</code></td>
<td>
<p>default <code>"two.sided"</code>. Should be one of <code>"greater"</code>, <code>"less"</code>, or <code>"two.sided"</code> to specify the alternative hypothesis.</p>
</td></tr>
<tr><td><code id="local_g_+3A_...">...</code></td>
<td>
<p>methods passed to <code><a href="spdep.html#topic+localG">spdep::localG()</a></code> or <code><a href="spdep.html#topic+localG">spdep::localG_perm()</a></code></p>
</td></tr>
<tr><td><code id="local_g_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations to run.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with columns:
</p>

<ul>
<li> <p><code>gi</code>: the observed statistic
</p>
</li>
<li> <p><code>cluster</code>: factor variable with two levels classification high or low
</p>
</li>
<li> <p><code>e_gi</code>: the permutation sample mean
</p>
</li>
<li> <p><code>var_gi</code>: the permutation sample variance
</p>
</li>
<li> <p><code>std_dev</code>: standard deviation of the Gi statistic
</p>
</li>
<li> <p><code>p_value</code>: the p-value using sample mean and standard deviation
</p>
</li>
<li> <p><code>p_folded_sim</code>: p-value based on the implementation of Pysal which always assumes a two-sided test taking the minimum possible p-value
</p>
</li>
<li> <p><code>skewness</code>: sample skewness
</p>
</li>
<li> <p><code>kurtosis</code>: sample kurtosis
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- guerry$crime_pers
nb &lt;- st_contiguity(guerry)
wt &lt;- st_weights(nb)

res &lt;- local_g_perm(x, nb, wt)

head(res)
</code></pre>

<hr>
<h2 id='local_g_spt'>Calculate the Local Gi* for a spacetime cube</h2><span id='topic+local_g_spt'></span>

<h3>Description</h3>

<p>An alternative implementation to <a href="spdep.html#topic+localG">spdep::localG</a> intended for use with
a spacetime cube.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_g_spt(x, times, nb, wt, n_locs, nsim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="local_g_spt_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="local_g_spt_+3A_times">times</code></td>
<td>
<p>a vector determining time order</p>
</td></tr>
<tr><td><code id="local_g_spt_+3A_nb">nb</code></td>
<td>
<p>a spacetime neighbors list</p>
</td></tr>
<tr><td><code id="local_g_spt_+3A_wt">wt</code></td>
<td>
<p>a weights list associated with <code>nb</code></p>
</td></tr>
<tr><td><code id="local_g_spt_+3A_n_locs">n_locs</code></td>
<td>
<p>the number of unique locations</p>
</td></tr>
<tr><td><code id="local_g_spt_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulations to run for calculating <code>p_sim</code></p>
</td></tr>
</table>

<hr>
<h2 id='local_gstar'>Local G*</h2><span id='topic+local_gstar'></span><span id='topic+local_gstar_perm'></span>

<h3>Description</h3>

<p>Calculate the local Gi* statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_gstar(x, nb, wt, alternative = "two.sided", ...)

local_gstar_perm(x, nb, wt, nsim = 499, alternative = "two.sided", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="local_gstar_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="local_gstar_+3A_nb">nb</code></td>
<td>
<p>a neighbor list object for example as created by <code>st_contiguity()</code>.</p>
</td></tr>
<tr><td><code id="local_gstar_+3A_wt">wt</code></td>
<td>
<p>a weights list as created by <code>st_weights()</code>.</p>
</td></tr>
<tr><td><code id="local_gstar_+3A_alternative">alternative</code></td>
<td>
<p>default <code>"two.sided"</code>. Should be one of <code>"greater"</code>, <code>"less"</code>, or <code>"two.sided"</code> to specify the alternative hypothesis.</p>
</td></tr>
<tr><td><code id="local_gstar_+3A_...">...</code></td>
<td>
<p>methods passed to <code><a href="spdep.html#topic+localG">spdep::localG()</a></code> or <code><a href="spdep.html#topic+localG">spdep::localG_perm()</a></code></p>
</td></tr>
<tr><td><code id="local_gstar_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations to run.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with columns:
</p>

<ul>
<li> <p><code>gi</code>: the observed statistic
</p>
</li>
<li> <p><code>e_gi</code>: the permutation sample mean
</p>
</li>
<li> <p><code>var_gi</code>: the permutation sample variance
</p>
</li>
<li> <p><code>p_value</code>: the p-value using sample mean and standard deviation
</p>
</li>
<li> <p><code>p_folded_sim</code>: p-value based on the implementation of Pysal which always assumes a two-sided test taking the minimum possible p-value
</p>
</li>
<li> <p><code>skewness</code>: sample skewness
</p>
</li>
<li> <p><code>kurtosis</code>: sample kurtosis
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>nb &lt;- st_contiguity(guerry)
wt &lt;- st_weights(nb)
x &lt;- guerry$crime_pers

res &lt;- local_gstar_perm(x, nb, wt)
head(res)

res &lt;- local_gstar(x, nb, wt)
head(res)
</code></pre>

<hr>
<h2 id='local_jc_bv'>Bivariate local join count</h2><span id='topic+local_jc_bv'></span>

<h3>Description</h3>

<p>Bivariate local join count
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_jc_bv(x, z, nb, wt, nsim = 499)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="local_jc_bv_+3A_x">x</code></td>
<td>
<p>a binary variable either numeric or logical</p>
</td></tr>
<tr><td><code id="local_jc_bv_+3A_z">z</code></td>
<td>
<p>a binary variable either numeric or logical</p>
</td></tr>
<tr><td><code id="local_jc_bv_+3A_nb">nb</code></td>
<td>
<p>a neighbors list object.</p>
</td></tr>
<tr><td><code id="local_jc_bv_+3A_wt">wt</code></td>
<td>
<p>default <code>st_weights(nb, style = "B")</code>. A binary weights list as created by <code>st_weights(nb, style = "B")</code>.</p>
</td></tr>
<tr><td><code id="local_jc_bv_+3A_nsim">nsim</code></td>
<td>
<p>the number of conditional permutation simulations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with two columns <code>join_count</code> and <code>p_sim</code> and number of rows equal to the length of arguments <code>x</code>, <code>z</code>, <code>nb</code>, and <code>wt</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.integer(guerry$infants &gt; 23574)
z &lt;- as.integer(guerry$donations &gt; 10973)
nb &lt;- st_contiguity(guerry)
wt &lt;- st_weights(nb, style = "B")
local_jc_bv(x, z, nb, wt)
</code></pre>

<hr>
<h2 id='local_jc_uni'>Compute local univariate join count</h2><span id='topic+local_jc_uni'></span>

<h3>Description</h3>

<p>The univariate local join count statistic is used to identify clusters of rarely occurring binary variables. The binary variable of interest should occur less
than half of the time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_jc_uni(
  fx,
  chosen,
  nb,
  wt = st_weights(nb, style = "B"),
  nsim = 499,
  alternative = "two.sided",
  iseed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="local_jc_uni_+3A_fx">fx</code></td>
<td>
<p>a binary variable either numeric or logical</p>
</td></tr>
<tr><td><code id="local_jc_uni_+3A_chosen">chosen</code></td>
<td>
<p>a scalar character containing the level of <code>fx</code> that should be considered the observed value (1).</p>
</td></tr>
<tr><td><code id="local_jc_uni_+3A_nb">nb</code></td>
<td>
<p>a neighbors list object.</p>
</td></tr>
<tr><td><code id="local_jc_uni_+3A_wt">wt</code></td>
<td>
<p>default <code>st_weights(nb, style = "B")</code>. A binary weights list as created by <code>st_weights(nb, style = "B")</code>.</p>
</td></tr>
<tr><td><code id="local_jc_uni_+3A_nsim">nsim</code></td>
<td>
<p>the number of conditional permutation simulations</p>
</td></tr>
<tr><td><code id="local_jc_uni_+3A_alternative">alternative</code></td>
<td>
<p>default <code>"greater"</code>. One of <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="local_jc_uni_+3A_iseed">iseed</code></td>
<td>
<p>default NULL, used to set the seed for possible parallel RNGs</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The local join count statistic requires a binary weights list which can be generated with <code>st_weights(nb, style = "B")</code>. Additionally, ensure that the binary variable of interest is rarely occurring in no more than half of observations.
</p>
<p>P-values are estimated using a conditional permutation approach. This creates a reference distribution from which the observed statistic is compared. For more see <a href="https://geodacenter.github.io/glossary.html#ppvalue">Geoda Glossary</a>.
Calls <code>spdep::local_joincount_uni()</code>.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> with two columns <code>join_count</code> and <code>p_sim</code> and number of rows equal to the length of arguments <code>x</code>, <code>nb</code>, and <code>wt</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("dplyr", quietly = TRUE)) {

res &lt;- dplyr::transmute(
  guerry,
  top_crime = as.factor(crime_prop &gt; 9000),
  nb = st_contiguity(geometry),
  wt = st_weights(nb, style = "B"),
  jc = local_jc_uni(top_crime, "TRUE", nb, wt))
tidyr::unnest(res, jc)

}
</code></pre>

<hr>
<h2 id='local_moran'>Calculate the Local Moran's I Statistic</h2><span id='topic+local_moran'></span>

<h3>Description</h3>

<p>Moran's I is calculated for each polygon based on the neighbor and weight lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_moran(x, nb, wt, alternative = "two.sided", nsim = 499, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="local_moran_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="local_moran_+3A_nb">nb</code></td>
<td>
<p>a neighbor list object for example as created by <code>st_contiguity()</code>.</p>
</td></tr>
<tr><td><code id="local_moran_+3A_wt">wt</code></td>
<td>
<p>a weights list as created by <code>st_weights()</code>.</p>
</td></tr>
<tr><td><code id="local_moran_+3A_alternative">alternative</code></td>
<td>
<p>default <code>"two.sided"</code>. Should be one of <code>"greater"</code>, <code>"less"</code>, or <code>"two.sided"</code> to specify the alternative hypothesis.</p>
</td></tr>
<tr><td><code id="local_moran_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations to run.</p>
</td></tr>
<tr><td><code id="local_moran_+3A_...">...</code></td>
<td>
<p>See <code>?spdep::localmoran_perm()</code> for more options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+local_moran">local_moran()</a></code> calls <code><a href="spdep.html#topic+localmoran">spdep::localmoran_perm()</a></code> and calculates the Moran I for each polygon. As well as provide simulated p-values.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> containing the columns <code>ii</code>, <code>eii</code>, <code>var_ii</code>, <code>z_ii</code>, <code>p_ii</code>, <code>p_ii_sim</code>, and <code>p_folded_sim</code>. For more details please see <code><a href="spdep.html#topic+localmoran">spdep::localmoran_perm()</a></code>.
</p>


<h3>See Also</h3>

<p>Other stats: 
<code><a href="#topic+st_lag">st_lag</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local_moran(guerry_nb$crime_pers, guerry_nb$nb, guerry_nb$wt)
</code></pre>

<hr>
<h2 id='local_moran_bv'>Compute the Local Bivariate Moran's I Statistic</h2><span id='topic+local_moran_bv'></span>

<h3>Description</h3>

<p>Given two continuous numeric variables, calculate the bivariate Local Moran's I.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_moran_bv(x, y, nb, wt, nsim = 499)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="local_moran_bv_+3A_x">x</code></td>
<td>
<p>a numeric vector of same length as <code>y</code>.</p>
</td></tr>
<tr><td><code id="local_moran_bv_+3A_y">y</code></td>
<td>
<p>a numeric vector of same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="local_moran_bv_+3A_nb">nb</code></td>
<td>
<p>a neighbor list object for example as created by <code>st_contiguity()</code>.</p>
</td></tr>
<tr><td><code id="local_moran_bv_+3A_wt">wt</code></td>
<td>
<p>a weights list as created by <code>st_weights()</code>.</p>
</td></tr>
<tr><td><code id="local_moran_bv_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulations to run.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Bivariate Local Moran, like its global counterpart, evaluates the value
of x at observation i with its spatial neighbors' value of y. The value of </p>
<p style="text-align: center;"><code class="reqn">I_i^B</code>
</p>
<p> is just xi * Wyi. Or, in simpler words the local bivariate Moran is the result of multiplying x by the spatial lag of y. Formally it is defined as
</p>
<p><code class="reqn">
I_i^B= cx_i\Sigma_j{w_{ij}y_j}
</code>
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> containing two columns <code>Ib</code> and <code>p_sim</code> containing the local bivariate Moran's I and simulated p-values respectively.
</p>


<h3>References</h3>

<p><a href="https://geodacenter.github.io/workbook/6c_local_multi/lab6c.html#principle">Local Spatial Autocorrelation (3): Multivariate Local Spatial Autocorrelation, Luc Anselin</a>
</p>


<h3>See Also</h3>

<p>Other global_moran: 
<code><a href="#topic+global_moran">global_moran</a>()</code>,
<code><a href="#topic+global_moran_bv">global_moran_bv</a>()</code>,
<code><a href="#topic+global_moran_perm">global_moran_perm</a>()</code>,
<code><a href="#topic+global_moran_test">global_moran_test</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- guerry_nb$crime_pers
y &lt;- guerry_nb$wealth
nb &lt;- guerry_nb$nb
wt &lt;- guerry_nb$wt
local_moran_bv(x, y, nb, wt)
</code></pre>

<hr>
<h2 id='local_moran_bv_calc'>Calculate the Local Bivariate Moran Statistic</h2><span id='topic+local_moran_bv_calc'></span>

<h3>Description</h3>

<p>Calculate the Local Bivariate Moran Statistic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_moran_bv_calc(x, y, nb, wt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="local_moran_bv_calc_+3A_x">x</code></td>
<td>
<p>a numeric vector of same length as <code>y</code>.</p>
</td></tr>
<tr><td><code id="local_moran_bv_calc_+3A_y">y</code></td>
<td>
<p>a numeric vector of same length as <code>x</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='local_moran_bv_impl'>Local Bivariate Moran's I spdep implementation</h2><span id='topic+local_moran_bv_impl'></span>

<h3>Description</h3>

<p>Local Bivariate Moran's I spdep implementation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_moran_bv_impl(x, y, listw, nsim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="local_moran_bv_impl_+3A_x">x</code></td>
<td>
<p>a numeric vector of same length as <code>y</code>.</p>
</td></tr>
<tr><td><code id="local_moran_bv_impl_+3A_y">y</code></td>
<td>
<p>a numeric vector of same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="local_moran_bv_impl_+3A_listw">listw</code></td>
<td>
<p>a listw object for example as created by <code>nb2listw()</code>.</p>
</td></tr>
<tr><td><code id="local_moran_bv_impl_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulations to run.</p>
</td></tr>
</table>

<hr>
<h2 id='local_moran_bv_perm_impl'>Local Bivariate Moran's I conditional permutation implementation</h2><span id='topic+local_moran_bv_perm_impl'></span>

<h3>Description</h3>

<p>Local Bivariate Moran's I conditional permutation implementation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_moran_bv_perm_impl(x, y, listw)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="local_moran_bv_perm_impl_+3A_x">x</code></td>
<td>
<p>a numeric vector of same length as <code>y</code>.</p>
</td></tr>
<tr><td><code id="local_moran_bv_perm_impl_+3A_y">y</code></td>
<td>
<p>a numeric vector of same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="local_moran_bv_perm_impl_+3A_listw">listw</code></td>
<td>
<p>a listw object for example as created by <code>nb2listw()</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='losh'>Local spatial heteroscedacity</h2><span id='topic+losh'></span><span id='topic+losh_perm'></span>

<h3>Description</h3>

<p>Local spatial heteroscedacity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>losh(x, nb, wt, a = 2, ...)

losh_perm(x, nb, wt, a = 2, nsim = 499, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="losh_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="losh_+3A_nb">nb</code></td>
<td>
<p>a neighbor list for example created by <code><a href="#topic+st_contiguity">st_contiguity()</a></code></p>
</td></tr>
<tr><td><code id="losh_+3A_wt">wt</code></td>
<td>
<p>a weights list for example created by <code><a href="#topic+st_weights">st_weights()</a></code></p>
</td></tr>
<tr><td><code id="losh_+3A_a">a</code></td>
<td>
<p>the exponent applied to the local residuals</p>
</td></tr>
<tr><td><code id="losh_+3A_...">...</code></td>
<td>
<p>methods passed to <a href="spdep.html#topic+LOSH">spdep::LOSH</a></p>
</td></tr>
<tr><td><code id="losh_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations to run</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with columns
</p>

<ul>
<li> <p><code>hi</code>: the observed statistic
</p>
</li>
<li> <p><code>e_hi</code>: the sample average
</p>
</li>
<li> <p><code>var_hi</code>: the sample variance
</p>
</li>
<li> <p><code>z_hi</code> the approximately Chi-square distributed test statistic
</p>
</li>
<li> <p><code>x_bar_i</code>: the local spatially weight mean for observation <code>i</code>
</p>
</li>
<li> <p><code>ei</code>: residuals
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>nb &lt;- st_contiguity(guerry)
wt &lt;- st_weights(nb)
x &lt;- guerry$crime_pers
losh(x, nb, wt)
losh(x, nb, wt, var_hi = FALSE)
losh_perm(x, nb, wt, nsim = 49)
</code></pre>

<hr>
<h2 id='nb_match_test'>Local Neighbor Match Test</h2><span id='topic+nb_match_test'></span>

<h3>Description</h3>

<p>Implements the Local Neighbor Match Test as described in <em>Tobler's Law in a Multivariate World</em> (Anselin and Li, 2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nb_match_test(
  x,
  nb,
  wt = st_weights(nb),
  k = 10,
  nsim = 499,
  scale = TRUE,
  .method = "euclidian",
  .p = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nb_match_test_+3A_x">x</code></td>
<td>
<p>a numeric vector or a list of numeric vectors of equal length.</p>
</td></tr>
<tr><td><code id="nb_match_test_+3A_nb">nb</code></td>
<td>
<p>a neighbor list object for example as created by <code>st_contiguity()</code>.</p>
</td></tr>
<tr><td><code id="nb_match_test_+3A_wt">wt</code></td>
<td>
<p>a weights list as created by <code>st_weights()</code>.</p>
</td></tr>
<tr><td><code id="nb_match_test_+3A_k">k</code></td>
<td>
<p>the number of neighbors to identify in attribute space. Should be the same as number of neighbors provided in <a href="#topic+st_knn">st_knn</a>.</p>
</td></tr>
<tr><td><code id="nb_match_test_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulations to run for calculating the simulated p-value.</p>
</td></tr>
<tr><td><code id="nb_match_test_+3A_scale">scale</code></td>
<td>
<p>default <code>TRUE</code>. Whether <code>x</code> should be scaled or not. Note that measures should be standardized.</p>
</td></tr>
<tr><td><code id="nb_match_test_+3A_.method">.method</code></td>
<td>
<p>default <code>"euclidian"</code>. The distance measure passed to <code><a href="stats.html#topic+dist">stats::dist()</a></code>.</p>
</td></tr>
<tr><td><code id="nb_match_test_+3A_.p">.p</code></td>
<td>
<p>default 2. The power of Minkowski distance passed to the <code>p</code> argument in <code><a href="stats.html#topic+dist">stats::dist()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with columns
</p>

<ul>
<li> <p><code>n_shared</code> (integer): the number of shared neighbors between geographic and attribute space
</p>
</li>
<li> <p><code>nb_matches</code> (list): matched neighbor indexes. Each element is an integer vector of same length as the ith observation of <code>n_shared</code>
</p>
</li>
<li> <p><code>knn_nb</code> (list): the neighbors in attribute space
</p>
</li>
<li> <p><code>probability</code> (numeric): the geometric probability of observing the number of matches
</p>
</li>
<li> <p><code>p_sim</code> (numeric): a folded simulated p-value
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("dplyr", quietly = TRUE)) {
library(magrittr)
guerry %&gt;%
  dplyr::transmute(nb = st_knn(geometry, k = 10),
         nmt = nb_match_test(list(crime_pers, literacy, suicides),
                             nb, nsim = 999)) %&gt;%
  tidyr::unnest(nmt)
 }
</code></pre>

<hr>
<h2 id='nb_union'>Set Operations</h2><span id='topic+nb_union'></span><span id='topic+nb_intersect'></span><span id='topic+nb_setdiff'></span>

<h3>Description</h3>

<p>Perform set operations element-wise on two lists of equal length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nb_union(x, y)

nb_intersect(x, y)

nb_setdiff(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nb_union_+3A_x">x</code></td>
<td>
<p>list of class <code>nb</code></p>
</td></tr>
<tr><td><code id="nb_union_+3A_y">y</code></td>
<td>
<p>list of class <code>nb</code></p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>nb_union()</code> returns the union of elements in each element of x and y
</p>
</li>
<li> <p><code>nb_intersect()</code> returns the intersection of elements in each element of x and y
</p>
</li>
<li> <p><code>nb_setdiff()</code> returns the difference of elements in each element of x and y
</p>
</li></ul>



<h3>Value</h3>

<p>A list of class <code>nb</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nb &lt;- st_contiguity(guerry$geometry)
nb_knn &lt;- st_knn(guerry$geometry, k = 3)
nb_setdiff(nb, nb_knn)
nb_union(nb, nb_knn)
nb_intersect(nb, nb_knn)

</code></pre>

<hr>
<h2 id='nmt_calc'>Identify matches between two neighbor lists</h2><span id='topic+nmt_calc'></span>

<h3>Description</h3>

<p>Identify matches between two neighbor lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nmt_calc(knn_nb, nb)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nmt_calc_+3A_knn_nb">knn_nb</code></td>
<td>
<p>a list with the same length as number of observations in the used dataset</p>
</td></tr>
<tr><td><code id="nmt_calc_+3A_nb">nb</code></td>
<td>
<p>a list the same length as knn_nb.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector
</p>

<hr>
<h2 id='nmt_impl'>Implementation of Neighbor Match Test</h2><span id='topic+nmt_impl'></span>

<h3>Description</h3>

<p>Implementation of Neighbor Match Test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nmt_impl(x, k, listw, nsim = 199, scale = TRUE, .method = "euclidian", .p = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nmt_impl_+3A_x">x</code></td>
<td>
<p>a numeric vector or a list of numeric vectors of equal length.</p>
</td></tr>
<tr><td><code id="nmt_impl_+3A_k">k</code></td>
<td>
<p>the number of neighbors to identify in attribute space. Should be the same as number of neighbors provided in <a href="#topic+st_knn">st_knn</a>.</p>
</td></tr>
<tr><td><code id="nmt_impl_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulations to run for calculating the simulated p-value.</p>
</td></tr>
<tr><td><code id="nmt_impl_+3A_scale">scale</code></td>
<td>
<p>default <code>TRUE</code>. Whether <code>x</code> should be scaled or not. Note that measures should be standardized.</p>
</td></tr>
<tr><td><code id="nmt_impl_+3A_.method">.method</code></td>
<td>
<p>default <code>"euclidian"</code>. The distance measure passed to <code><a href="stats.html#topic+dist">stats::dist()</a></code>.</p>
</td></tr>
<tr><td><code id="nmt_impl_+3A_.p">.p</code></td>
<td>
<p>default 2. The power of Minkowski distance passed to the <code>p</code> argument in <code><a href="stats.html#topic+dist">stats::dist()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame containing columns:
</p>

<ul>
<li><p> n_shared
</p>
</li>
<li><p> nb_matches
</p>
</li>
<li><p> knn_nb
</p>
</li>
<li><p> probability
</p>
</li>
<li><p> p_sim
</p>
</li></ul>


<hr>
<h2 id='nmt_perm_impl'>Find conditionally permuted neighbor matches
Given a kNN attribute neighbor list and a listw object, find the number of matches given a conditional permutation.</h2><span id='topic+nmt_perm_impl'></span>

<h3>Description</h3>

<p>Find conditionally permuted neighbor matches
Given a kNN attribute neighbor list and a listw object, find the number of matches given a conditional permutation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nmt_perm_impl(knn_nb, listw)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nmt_perm_impl_+3A_knn_nb">knn_nb</code></td>
<td>
<p>a list with numeric elements. For example as made by <code><a href="dbscan.html#topic+NN">dbscan::adjacencylist()</a></code></p>
</td></tr>
<tr><td><code id="nmt_perm_impl_+3A_listw">listw</code></td>
<td>
<p>a listw object likely created by <a href="#topic+recreate_listw">recreate_listw</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector
</p>

<hr>
<h2 id='node_get_nbs'>Create node features from edges</h2><span id='topic+node_get_nbs'></span><span id='topic+node_get_edge_list'></span><span id='topic+node_get_edge_col'></span>

<h3>Description</h3>

<p>Given a tidygraph object, create a list column of edge data for each node in the node context.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_get_nbs()

node_get_edge_list()

node_get_edge_col(edges, .var)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="node_get_nbs_+3A_edges">edges</code></td>
<td>
<p>an edge list as created by <code>node_get_edge_list()</code></p>
</td></tr>
<tr><td><code id="node_get_nbs_+3A_.var">.var</code></td>
<td>
<p>the quoted name of a column in the edge context.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>node_get_nbs()</code>: creates a neighbor list in the nodes context based on the adjacency list. This returns a <code>nb</code> class object with the <em>neighboring nodes</em>.
</p>

<ul>
<li><p> Uses <code>igraph::get.adjlist()</code>
</p>
</li></ul>

</li>
<li> <p><code>node_get_edge_list()</code>: creates an edge list. The edge list contains the row index of the edge relationships in the edge context for each node.
</p>

<ul>
<li><p> Uses <code>igraph::get.adjedgelist()</code>.
</p>
</li></ul>

</li>
<li> <p><code>node_get_edge_col()</code>: creates a list column containing edge attributes as a list column in the node context (much like <code>find_xj()</code>).
</p>

<ul>
<li><p> Uses <code>igraph::get.edge.attribute()</code>
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>A list column
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) {
  net &lt;- sfnetworks::as_sfnetwork(
    sfnetworks::roxel
  )

  dplyr::mutate(
    net,
    nb = node_get_nbs(),
    edges = node_get_edge_list(),
    types = node_get_edge_col(edges, "type")
  )
}
</code></pre>

<hr>
<h2 id='pairwise_colocation'>Pairwise Colocation Quotient</h2><span id='topic+pairwise_colocation'></span>

<h3>Description</h3>

<p>Calculate the pairwise colocation quotient (CLQ) for two categorical variables using conditional permutation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise_colocation(A, B, nb, nsim = 99)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairwise_colocation_+3A_a">A</code></td>
<td>
<p>a character or factor vector.</p>
</td></tr>
<tr><td><code id="pairwise_colocation_+3A_b">B</code></td>
<td>
<p>a character or factor vector.</p>
</td></tr>
<tr><td><code id="pairwise_colocation_+3A_nb">nb</code></td>
<td>
<p>a neighbors list e.g. created by <code><a href="#topic+st_knn">st_knn()</a></code> or <code><a href="#topic+st_contiguity">st_contiguity()</a></code></p>
</td></tr>
<tr><td><code id="pairwise_colocation_+3A_nsim">nsim</code></td>
<td>
<p>default <code>99</code>. An integer representing how many simulations to run for calculating the simulated p-values.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Intuition</h4>

<p>The pairwise CLQ is used to test if there is a spatial directional association between subcategories of two vectors <code>A</code> and <code>B</code>. Compared to the cross-K metric and the join count statistic, the pairwise CLQ can elucidate the presence of an asymmetric relationship between subcategories of A and B. A and B can either be separate categorical vectors or the same categorical vector.
</p>
<p>&quot;The null hypothesis for a CLQ-based analysis is 'given the clustering of the joint population, there is no spatial association between pairs of categorical subsets.'&quot;
</p>



<h4>Definition</h4>

<p>The pairwise colocation quotient is defined as &quot;the ratio of observed to expected proportions of B among A's nearest neighbors. Formally this is given by
<code class="reqn">CLQ_{A \to B} = \frac{{C_{A \to B} / N_A}}{N^{'}_{B} / (N - 1)}</code>&quot; where <code class="reqn">C_{A \to B} = \sum_{i = 1}^{N_A}\sum_{j = 1}^{v}\frac{B_{ij}(1,0)}{v}</code>.
</p>



<h4>Inference</h4>

<p>Inference is done using conditional permutation as suggested by Anselin 1995 where a number of replicates are created. The observed values are compared to the replicates and a the simulated p-value is the proportion of cases where the observed is more extreme as compared to replicate. The simulated p-value returns the lower p-value of either tail.
</p>



<h4>Interpretation</h4>

<p>Given that the CLQ is a ratio of the observed to expected, we interpret values larger than one to mean that there is more colocation than to be expected under the null hypothesis of no spatial association. When the value is smaller than 0, we interpret it to mean that there is less colocation than expected under the null.
</p>



<h3>Value</h3>

<p>A matrix where the rownames are the unique values of A and the column names are the unique values of B and their simulated p-values in the form of <code style="white-space: pre;">&#8288;p_sim_{B}&#8288;</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- guerry$main_city
B &lt;- guerry$region
nb &lt;- st_knn(sf::st_geometry(guerry), 5)
pairwise_colocation(B, A, nb)
pairwise_colocation(B, B, nb, 199)
</code></pre>

<hr>
<h2 id='pairwise_colocation_calc'>Pairwise CLQ calculation</h2><span id='topic+pairwise_colocation_calc'></span>

<h3>Description</h3>

<p>Internal function to calculate the pairwise CQL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise_colocation_calc(A, B, nb)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairwise_colocation_calc_+3A_a">A</code></td>
<td>
<p>a character or factor vector.</p>
</td></tr>
<tr><td><code id="pairwise_colocation_calc_+3A_b">B</code></td>
<td>
<p>a character or factor vector.</p>
</td></tr>
<tr><td><code id="pairwise_colocation_calc_+3A_nb">nb</code></td>
<td>
<p>a neighbors list e.g. created by <code><a href="#topic+st_knn">st_knn()</a></code> or <code><a href="#topic+st_contiguity">st_contiguity()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix where rownames are A values colnames are B values
</p>

<hr>
<h2 id='pairwise_colocation_perm_impl'>Pairwise CLQ conditional permutation implementation</h2><span id='topic+pairwise_colocation_perm_impl'></span>

<h3>Description</h3>

<p>Internal implementation of the pairwise CQL using conditional permutation. Functionally the same as <code><a href="#topic+pairwise_colocation">pairwise_colocation()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise_colocation_perm_impl(A, B, nb, nsim = 199)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairwise_colocation_perm_impl_+3A_a">A</code></td>
<td>
<p>a character or factor vector.</p>
</td></tr>
<tr><td><code id="pairwise_colocation_perm_impl_+3A_b">B</code></td>
<td>
<p>a character or factor vector.</p>
</td></tr>
<tr><td><code id="pairwise_colocation_perm_impl_+3A_nb">nb</code></td>
<td>
<p>a neighbors list e.g. created by <code><a href="#topic+st_knn">st_knn()</a></code> or <code><a href="#topic+st_contiguity">st_contiguity()</a></code></p>
</td></tr>
<tr><td><code id="pairwise_colocation_perm_impl_+3A_nsim">nsim</code></td>
<td>
<p>default <code>99</code>. An integer representing how many simulations to run for calculating the simulated p-values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix used by pairwise_colocation
</p>

<hr>
<h2 id='pct_nonzero'>Percent Non-zero Neighbors</h2><span id='topic+pct_nonzero'></span>

<h3>Description</h3>

<p>Calculate the percentage of non-zero neighbors in a neighbor list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pct_nonzero(nb)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pct_nonzero_+3A_nb">nb</code></td>
<td>
<p>a neighbor list object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar double
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nb &lt;- st_contiguity(guerry)
pct_nonzero(nb)
</code></pre>

<hr>
<h2 id='permute_listw'>Conditionally permutes a listw object</h2><span id='topic+permute_listw'></span>

<h3>Description</h3>

<p>Conditionally permutes a listw object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permute_listw(listw)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permute_listw_+3A_listw">listw</code></td>
<td>
<p>a listw object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>listw</code> object
</p>

<hr>
<h2 id='recreate_listw'>Create a listw object from a neighbors and weight list</h2><span id='topic+recreate_listw'></span>

<h3>Description</h3>

<p>Given a neighbor and weight list, create a <code>listw</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recreate_listw(nb, wt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recreate_listw_+3A_nb">nb</code></td>
<td>
<p>a neighbor list object for example as created by <code>st_contiguity()</code>.</p>
</td></tr>
<tr><td><code id="recreate_listw_+3A_wt">wt</code></td>
<td>
<p>a weights list as created by <code>st_weights()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>listw</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>recreate_listw(guerry_nb$nb, guerry_nb$wt)
</code></pre>

<hr>
<h2 id='set_col'>Set columns from <code>geometry</code> to <code>data</code></h2><span id='topic+set_col'></span><span id='topic+set_wts'></span><span id='topic+set_nbs'></span>

<h3>Description</h3>

<p>Set a column from the <code>geometry</code> context of a spacetime object to the <code>data</code>
context.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_col(x, .from_geo, .to_data = .from_geo)

set_wts(x, .wt_col = "wt")

set_nbs(x, .nb_col = "nb")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_col_+3A_x">x</code></td>
<td>
<p>a spacetime object</p>
</td></tr>
<tr><td><code id="set_col_+3A_.from_geo">.from_geo</code></td>
<td>
<p>the name of the column in the <code>geometry</code> context</p>
</td></tr>
<tr><td><code id="set_col_+3A_.to_data">.to_data</code></td>
<td>
<p>the name of the new variable to create in the <code>data</code> context</p>
</td></tr>
<tr><td><code id="set_col_+3A_.wt_col">.wt_col</code></td>
<td>
<p>the name of the weights column in the <code>geometry</code> context</p>
</td></tr>
<tr><td><code id="set_col_+3A_.nb_col">.nb_col</code></td>
<td>
<p>the name of neighbor column in the <code>geometry</code> context</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions will reorder the spacetime object to ensure that it is ordered
correctly based on the location time columns in the <code>geometry</code> context defined
by the <code>loc_col</code> and <code>time_col</code> attributes respectively.
</p>
<p><code><a href="#topic+set_wts">set_wts()</a></code> and <code><a href="#topic+set_nbs">set_nbs()</a></code> create a new column in the data context with the
same name as the column in the geometry context. If a different name is desired
use <code><a href="#topic+set_col">set_col()</a></code>
</p>


<h3>Value</h3>

<p>A spacetime object with an active data context and a new column from the geometry
context.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) {
df_fp &lt;- system.file("extdata", "bos-ecometric.csv", package = "sfdep")
geo_fp &lt;- system.file("extdata", "bos-ecometric.geojson", package = "sfdep")

# read in data
df &lt;- read.csv(
  df_fp, colClasses = c("character", "character", "integer", "double", "Date")
)
geo &lt;- sf::st_read(geo_fp)

# Create spacetime object called `bos`
bos &lt;- spacetime(df, geo,
                .loc_col = ".region_id",
                .time_col = "time_period")
bos &lt;- activate(bos, "geometry")
bos$nb &lt;- st_contiguity(bos)
bos$wt &lt;- st_weights(bos$nb)
bos$card &lt;- st_cardinalties(bos$nb)

set_nbs(bos)
set_wts(bos)
set_col(bos, "card")
set_col(bos, "card", "cardinalities")
}
</code></pre>

<hr>
<h2 id='shuffle_nbs'>Internal function to shuffle neighbors</h2><span id='topic+shuffle_nbs'></span>

<h3>Description</h3>

<p>Used in conditional permutation and the function <code>permute_listw()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shuffle_nbs(i, n, card)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shuffle_nbs_+3A_i">i</code></td>
<td>
<p>the index position of observation <code>i</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>nb</code> class object
</p>

<hr>
<h2 id='sin_d'>Trigonometric functions</h2><span id='topic+sin_d'></span>

<h3>Description</h3>

<p>These functions are wrappers around the base trigonometric functions.
However these return degree values rather than radians.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sin_d(theta = 0)
</code></pre>


<h3>Details</h3>

<p>These functions were adopted from the now archived CRAN package <code>{aspace}</code>.
</p>


<h3>Value</h3>

<p>numeric
</p>

<hr>
<h2 id='spacetime'>Construct a <code>spacetime</code> object</h2><span id='topic+spacetime'></span><span id='topic+new_spacetime'></span><span id='topic+validate_spacetime'></span><span id='topic+is_spacetime'></span><span id='topic+is.spacetime'></span>

<h3>Description</h3>

<p>A spacetime object is a collection of a linked data frame and an sf objects.
It can be thought of as geography linked to a table that represents those
geographies over one or more time periods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spacetime(.data, .geometry, .loc_col, .time_col, active = "data")

new_spacetime(.data, .geometry, .loc_col, .time_col, active = "data")

validate_spacetime(.data, .geometry, .loc_col, .time_col)

is_spacetime(x, ...)

is.spacetime(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spacetime_+3A_.data">.data</code></td>
<td>
<p>an object with base class <code>data.frame</code> containing location and time
identifiers <code>.loc_col</code> and <code>.time_col</code> respectively.</p>
</td></tr>
<tr><td><code id="spacetime_+3A_.geometry">.geometry</code></td>
<td>
<p>an <code>sf</code> object with columns <code>.loc_col</code> and <code>.time_col</code></p>
</td></tr>
<tr><td><code id="spacetime_+3A_.loc_col">.loc_col</code></td>
<td>
<p>the quoted name of the column containing unique location identifiers. Must be present in both <code>.data</code> and <code>.geometry</code>.</p>
</td></tr>
<tr><td><code id="spacetime_+3A_.time_col">.time_col</code></td>
<td>
<p>the quoted name of the column containing time periods must be present <code>.data</code>. See details for more</p>
</td></tr>
<tr><td><code id="spacetime_+3A_active">active</code></td>
<td>
<p>default <code>"data"</code>. The object to make active. See <code><a href="#topic+activate">activate()</a></code> for more.</p>
</td></tr>
<tr><td><code id="spacetime_+3A_x">x</code></td>
<td>
<p>an object to test</p>
</td></tr>
<tr><td><code id="spacetime_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create a spacetime representation of vector data from a <code>data.frame</code> and an
<code>sf</code> object with <code>spacetime()</code>
</p>
<p><code>.time_col</code> must be able to be sorted. As such, <code>.time_col</code>
cannot be a character vector. It must have a base type of (<code>typeof()</code>) either
<code>double</code> or <code>integer</code>—the case in dates or factors respectively. An edge case
exists with <code>POSIXlt</code> class objects as these can be sorted appropriately but
have a base type of <code>list</code>.
</p>
<p><code><a href="#topic+spacetime">spacetime()</a></code> is a wrapper around <code><a href="#topic+new_spacetime">new_spacetime()</a></code>. Spacetimes are
validated before creation with <code><a href="#topic+validate_spacetime">validate_spacetime()</a></code>.
</p>
<p>Check if an object is a spacetime object with <code><a href="#topic+is_spacetime">is_spacetime()</a></code> or
<code><a href="#topic+is.spacetime">is.spacetime()</a></code>.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>spacetime()</code> and <code>new_spacetime()</code> construct spacetime clss objects
</p>
</li>
<li> <p><code>validate_spacetime()</code> returns nothing but will elicit a warning or error if the spacetime object is not validly constructed
</p>
</li>
<li> <p><code>is_spacetime()</code> and <code>is.spacetime()</code> return a logical scalar indicating if an object inherits the spacetime class
</p>
</li></ul>



<h3>Validation</h3>

<p><code>validate_spacetime()</code> checks both <code>.data</code> and <code>.geometry</code> to ensure that
the constructed spacetime object meets minimum requirements.:
</p>

<ul>
<li> <p><code>.data</code> inherits the <code>data.frame</code> class
</p>
</li>
<li> <p><code>.geometry</code> is an <code>sf</code> object
</p>
</li>
<li><p> ensures that <code>.time_col</code> is of the proper class
</p>
</li>
<li><p> ensures there are no missing geometries in <code>.geometry</code>
</p>
</li>
<li><p> checks for duplicate geometries
</p>
</li>
<li><p> ensures <code>.loc_col</code> are the same type in <code>.data</code> and <code>.geometry</code>
</p>
</li>
<li><p> lastly informs of missing values in additional columns in <code>.data</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
df_fp &lt;- system.file("extdata", "bos-ecometric.csv", package = "sfdep")
geo_fp &lt;- system.file("extdata", "bos-ecometric.geojson", package = "sfdep")

# read in data
df &lt;- read.csv(
  df_fp, colClasses = c("character", "character", "integer", "double", "Date")
)

geo &lt;- sf::st_read(geo_fp)

bos &lt;- spacetime(df, geo, ".region_id", "year")
is_spacetime(bos)
bos


</code></pre>

<hr>
<h2 id='spatial_gini'>Spatial Gini Index</h2><span id='topic+spatial_gini'></span>

<h3>Description</h3>

<p>Calculates the spatial Gini index for a given numeric vector and neighbor list.
Based on the formula provided Rey and Smith (2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial_gini(x, nb)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spatial_gini_+3A_x">x</code></td>
<td>
<p>a numeric vector without missing values</p>
</td></tr>
<tr><td><code id="spatial_gini_+3A_nb">nb</code></td>
<td>
<p>a neighbor list, for example created with <code><a href="#topic+st_contiguity">st_contiguity()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Gini index is a global measure of inequality based on the Lorenz curve. It ranges between 0 and 1 where 0 is perfect equality and 1 is perfect inequality.
</p>
<p>The spatial Gini index decomposes the Gini coefficient based on spatial neighbors.
</p>


<h3>Value</h3>

<p>A data frame with columns:
</p>

<ul>
<li> <p><code>G</code>: the Gini index
</p>
</li>
<li> <p><code>NBG</code>: the neighbor composition of the Gini coefficient
</p>
</li>
<li> <p><code>NG</code>: the non-neighbor composition of the Gini coefficient
</p>
</li>
<li> <p><code>SG</code>: the Spatial Gini which is equal to <code class="reqn">NG * \frac{1}{G}</code>
</p>
</li></ul>



<h3>References</h3>

<p><a href="https://doi.org/10.1007/s12076-012-0086-z">doi:10.1007/s12076-012-0086-z</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nb &lt;- st_contiguity(guerry)
x &lt;- guerry$wealth
spatial_gini(x, nb)

</code></pre>

<hr>
<h2 id='spt_nb'>Create time lagged spatial neighbors</h2><span id='topic+spt_nb'></span>

<h3>Description</h3>

<p>Given a an spdep neighbor list (or any other list indicating row position)
of neighbors in a <code>spacetime</code> object's geometry context, create a neighbor
list across space and time in the <code>data</code> context.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spt_nb(nb, n_times, n_locs, k = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spt_nb_+3A_nb">nb</code></td>
<td>
<p>a neighbors list created from a spacetime object's geometry context.</p>
</td></tr>
<tr><td><code id="spt_nb_+3A_n_times">n_times</code></td>
<td>
<p>the number of time slices</p>
</td></tr>
<tr><td><code id="spt_nb_+3A_n_locs">n_locs</code></td>
<td>
<p>the number of locations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this should only be used for spacetime cubes.
</p>
<p>This function is only available for internal development and should be used
with extreme caution.
</p>
<p>The number of bins is equal to <code>n_times * n_locs</code> where each location has
a bin time-series with <code>n_times</code> observations. This is what makes it a
spacetime cube function.
</p>


<h3>Value</h3>

<p>a <code>nb</code> list
</p>


<h3>References</h3>

<p>https://pro.arcgis.com/en/pro-app/2.8/tool-reference/space-time-pattern-mining/create-space-time-cube.htm
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spt_wt">spt_wt()</a></code> for converting spacetime neighbors to spacetime weights.
</p>

<hr>
<h2 id='spt_order'>Order a spacetime cube</h2><span id='topic+spt_order'></span>

<h3>Description</h3>

<p>When performing analysis on a spacetime cube, the order is of the utmost
importance. This function ensures that a spacetime cube is ordered
appropriately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spt_order(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spt_order_+3A_x">x</code></td>
<td>
<p>a spacetime cube object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a spacetime object that orders based on time and location
</p>

<hr>
<h2 id='spt_update'>Update spacetime attributes</h2><span id='topic+spt_update'></span>

<h3>Description</h3>

<p>Update's a spacetime object's number of locations and time periods.
A spacetime object's attributes are sticky and will not change if subsetted
for example by using <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code> or <code><a href="dplyr.html#topic+slice">dplyr::slice()</a></code>. Update the
locations and times of a spacetime object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spt_update(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spt_update_+3A_x">x</code></td>
<td>
<p>a spacetime object</p>
</td></tr>
<tr><td><code id="spt_update_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class spacetime with updated attributes
</p>

<hr>
<h2 id='spt_wt'>Create time lagged spatial weights</h2><span id='topic+spt_wt'></span>

<h3>Description</h3>

<p>Given a space-time-lagged neighbor list and a weights lists, e.g. made by
<code><a href="#topic+st_dist_band">st_dist_band()</a></code> or <code><a href="#topic+st_contiguity">st_contiguity()</a></code>, create a corresponding weights list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spt_wt(wt, nbt, n_times, n_locs, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spt_wt_+3A_wt">wt</code></td>
<td>
<p>a weights lists created from a spacetime object's geometry context.</p>
</td></tr>
<tr><td><code id="spt_wt_+3A_nbt">nbt</code></td>
<td>
<p>a time-lagged spatial neighbors list created by <code><a href="#topic+spt_nb">spt_nb()</a></code></p>
</td></tr>
<tr><td><code id="spt_wt_+3A_n_times">n_times</code></td>
<td>
<p>the number of time slices</p>
</td></tr>
<tr><td><code id="spt_wt_+3A_n_locs">n_locs</code></td>
<td>
<p>the number of locations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is intended that <code><a href="#topic+spt_wt">spt_wt()</a></code> is used following the use of <code><a href="#topic+spt_nb">spt_nb()</a></code>
using the same input arguments. This ensures that the time-lagged spatial
weights are correctly associated with the time-lagged spatial neighbors.
</p>


<h3>Value</h3>

<p>a weight list with same cardinality as <code>nbt</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spt_nb">spt_nb()</a></code> for creating spacetime neighbors which are inputs into spacetime weights
</p>

<hr>
<h2 id='st_as_edges'>Convert to an edge lines object</h2><span id='topic+st_as_edges'></span><span id='topic+st_as_edges.sf'></span><span id='topic+st_as_edges.sfc'></span>

<h3>Description</h3>

<p>Given geometry and neighbor and weights lists, create an edge list <code>sf</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_as_edges(x, nb, wt)

## S3 method for class 'sf'
st_as_edges(x, nb, wt)

## S3 method for class 'sfc'
st_as_edges(x, nb, wt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="st_as_edges_+3A_x">x</code></td>
<td>
<p>object of class <code>sf</code> or <code>sfc</code>.</p>
</td></tr>
<tr><td><code id="st_as_edges_+3A_nb">nb</code></td>
<td>
<p>a neighbor list. If <code>x</code> is class <code>sf</code>, the unquote named of the column. If <code>x</code> is class <code>sfc</code>, an object of class <code>nb</code> as created from <code>st_contiguity()</code>.</p>
</td></tr>
<tr><td><code id="st_as_edges_+3A_wt">wt</code></td>
<td>
<p>optional. A weights list as generated by <code>st_weights()</code>.  . If <code>x</code> is class <code>sf</code>, the unquote named of the column. If <code>x</code> is class <code>sfc</code>, the weights list itself.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creating an edge list creates a column for each <code>i</code> position and <code>j</code> between an observation and their neighbors. You can recreate these values by expanding the <code>nb</code> and <code>wt</code> list columns.
</p>
<div class="sourceCode r"><pre>library(magrittr)
guerry_nb %&gt;%
  tibble::as_tibble() %&gt;%
  dplyr::select(nb, wt) %&gt;%
  dplyr::mutate(i = dplyr::row_number(), .before = 1) %&gt;%
  tidyr::unnest(c(nb, wt))
#&gt; # A tibble: 420 x 3
#&gt;        i    nb    wt
#&gt;    &lt;int&gt; &lt;int&gt; &lt;dbl&gt;
#&gt;  1     1    36 0.25 
#&gt;  2     1    37 0.25 
#&gt;  3     1    67 0.25 
#&gt;  4     1    69 0.25 
#&gt;  5     2     7 0.167
#&gt;  6     2    49 0.167
#&gt;  7     2    57 0.167
#&gt;  8     2    58 0.167
#&gt;  9     2    73 0.167
#&gt; 10     2    76 0.167
#&gt; # i 410 more rows
</pre></div>


<h3>Value</h3>

<p>Returns an <code>sf</code> object with edges represented as a <code>LINESTRING</code>.
</p>

<ul>
<li> <p><code>from</code>: node index. This is the row position of <code>x</code>.
</p>
</li>
<li> <p><code>to</code>: node index. This is the neighbor value stored in <code>nb</code>.
</p>
</li>
<li> <p><code>i</code>: node index. This is the row position of <code>x</code>.
</p>
</li>
<li> <p><code>j</code>: node index. This is the neighbor value stored in <code>nb</code>.
</p>
</li>
<li> <p><code>wt</code>: the weight value of <code>j</code> stored in <code>wt</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("dplyr", quietly = TRUE)) {

library(magrittr)
guerry %&gt;%
  dplyr::mutate(nb = st_contiguity(geometry),
         wt = st_weights(nb)) %&gt;%
  st_as_edges(nb, wt)

}
</code></pre>

<hr>
<h2 id='st_as_graph'>Create an sfnetwork</h2><span id='topic+st_as_graph'></span><span id='topic+st_as_graph.sf'></span><span id='topic+st_as_graph.sfc'></span>

<h3>Description</h3>

<p>Given an <code>sf</code> or <code>sfc</code> object and neighbor and weights lists, create an <code>sfnetwork</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_as_graph(x, nb, wt)

## S3 method for class 'sf'
st_as_graph(x, nb, wt)

## S3 method for class 'sfc'
st_as_graph(x, nb, wt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="st_as_graph_+3A_x">x</code></td>
<td>
<p>object of class <code>sf</code> or <code>sfc</code>.</p>
</td></tr>
<tr><td><code id="st_as_graph_+3A_nb">nb</code></td>
<td>
<p>a neighbor list. If <code>x</code> is class <code>sf</code>, the unquote named of the column. If <code>x</code> is class <code>sfc</code>, an object of class <code>nb</code> as created from <code>st_contiguity()</code>.</p>
</td></tr>
<tr><td><code id="st_as_graph_+3A_wt">wt</code></td>
<td>
<p>optional. A weights list as generated by <code>st_weights()</code>.  . If <code>x</code> is class <code>sf</code>, the unquote named of the column. If <code>x</code> is class <code>sfc</code>, the weights list itself.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>sfnetwork</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+st_as_nodes">st_as_nodes()</a></code> and <code><a href="#topic+st_as_edges">st_as_edges()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("dplyr", quietly = TRUE)) {
library(magrittr)

guerry_nb %&gt;%
  st_as_graph(nb, wt)
}
</code></pre>

<hr>
<h2 id='st_as_nodes'>Convert to a node point object</h2><span id='topic+st_as_nodes'></span><span id='topic+st_as_nodes.sf'></span><span id='topic+st_as_nodes.sfc'></span>

<h3>Description</h3>

<p>Given geometry and a neighbor list, creates an <code>sf</code> object to be used as nodes in an <code><a href="sfnetworks.html#topic+sfnetwork">sfnetworks::sfnetwork()</a></code>. If the provided geometry is a polygon, <code><a href="sf.html#topic+geos_unary">sf::st_point_on_surface()</a></code> will be used to create the node point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_as_nodes(x, nb)

## S3 method for class 'sf'
st_as_nodes(x, nb)

## S3 method for class 'sfc'
st_as_nodes(x, nb)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="st_as_nodes_+3A_x">x</code></td>
<td>
<p>object of class <code>sf</code> or <code>sfc</code>.</p>
</td></tr>
<tr><td><code id="st_as_nodes_+3A_nb">nb</code></td>
<td>
<p>a neighbor list. If <code>x</code> is class <code>sf</code>, the unquote named of the column. If <code>x</code> is class <code>sfc</code>, an object of class <code>nb</code> as created from <code>st_contiguity()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>st_as_node()</code> adds a row <code>i</code> based on the attribute <code>"region.id"</code> in the <code>nb</code> object. If the <code>nb</code> object is created with <code>sfdep</code>, then the values will always be row indexes.
</p>


<h3>Value</h3>

<p>An object of class <code>sf</code> with <code>POINT</code> geometry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("dplyr", quitly = TRUE)) {
library(magrittr)
guerry %&gt;%
  dplyr::transmute(nb = st_contiguity(geometry)) %&gt;%
  st_as_nodes(nb)
 }
</code></pre>

<hr>
<h2 id='st_block_nb'>Create Block Contiguity for Spatial Regimes</h2><span id='topic+st_block_nb'></span>

<h3>Description</h3>

<p>libpysal write that &quot;block contiguity structures are relevant when defining neighbor relations based on membership in a regime. For example, all counties belonging to the same state could be defined as neighbors, in an analysis of all counties in the US.&quot;
</p>
<p>Source: <a href="https://pysal.org/libpysal/generated/libpysal.weights.block_weights.html">libpysal</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_block_nb(regime, id = 1:length(regime), diag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="st_block_nb_+3A_regime">regime</code></td>
<td>
<p>a column identifying which spatial regime each element of <code>id</code> belongs</p>
</td></tr>
<tr><td><code id="st_block_nb_+3A_id">id</code></td>
<td>
<p>a column identifying unique observations</p>
</td></tr>
<tr><td><code id="st_block_nb_+3A_diag">diag</code></td>
<td>
<p>default <code>FALSE</code>. If <code>TRUE</code>, includes diagonal element / the self.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>nb</code>. When <code>diag = TRUE</code> the attribute <code>self.included = TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>id &lt;- guerry$code_dept
regime &lt;- guerry$region
st_block_nb(regime, id)
</code></pre>

<hr>
<h2 id='st_cardinalties'>Calculate neighbor cardinalities</h2><span id='topic+st_cardinalties'></span>

<h3>Description</h3>

<p>Identify the cardinality of a neighbor object. Utilizes <code>spdep::card()</code> for objects with class <code>nb</code>, otherwise returns <code>lengths(nb)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_cardinalties(nb)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="st_cardinalties_+3A_nb">nb</code></td>
<td>
<p>A neighbor list object as created by <code>st_neighbors()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector with the same length as <code>nb</code>.
</p>


<h3>See Also</h3>

<p>Other other: 
<code><a href="#topic+st_nb_lag">st_nb_lag</a>()</code>,
<code><a href="#topic+st_nb_lag_cumul">st_nb_lag_cumul</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nb &lt;- st_contiguity(sf::st_geometry(guerry))
st_cardinalties(nb)
</code></pre>

<hr>
<h2 id='st_complete_nb'>Create Neighbors as Complete Graph</h2><span id='topic+st_complete_nb'></span>

<h3>Description</h3>

<p>Create a neighbors list where every element is related to every other element.
This creates a complete graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_complete_nb(n_elements, diag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="st_complete_nb_+3A_n_elements">n_elements</code></td>
<td>
<p>the number of observations to create a neighbors list for</p>
</td></tr>
<tr><td><code id="st_complete_nb_+3A_diag">diag</code></td>
<td>
<p>default <code>FALSE</code>. If <code>TRUE</code>, includes diagonal element / the self.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A neighbors list representing a complete graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>st_complete_nb(5)
</code></pre>

<hr>
<h2 id='st_contiguity'>Identify polygon neighbors</h2><span id='topic+st_contiguity'></span>

<h3>Description</h3>

<p>Given an sf geometry of type <code>POLYGON</code> or <code>MULTIPOLYGON</code> identify contiguity based neighbors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_contiguity(geometry, queen = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="st_contiguity_+3A_geometry">geometry</code></td>
<td>
<p>an sf or sfc object.</p>
</td></tr>
<tr><td><code id="st_contiguity_+3A_queen">queen</code></td>
<td>
<p>default <code>TRUE</code>. For more see <code>?spdep::poly2nb</code></p>
</td></tr>
<tr><td><code id="st_contiguity_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="spdep.html#topic+poly2nb">spdep::poly2nb()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Utilizes <code><a href="spdep.html#topic+poly2nb">spdep::poly2nb()</a></code>
</p>


<h3>Value</h3>

<p>a list of class <code>nb</code>
</p>


<h3>See Also</h3>

<p>Other neighbors: 
<code><a href="#topic+st_dist_band">st_dist_band</a>()</code>,
<code><a href="#topic+st_knn">st_knn</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># on basic polygons
geo &lt;- sf::st_geometry(guerry)
st_contiguity(geo)
if (requireNamespace("dplyr", quietyl = TRUE)) {
# in a pipe
library(magrittr)
guerry %&gt;%
  dplyr::mutate(nb = st_contiguity(geometry), .before = 1)
 }
</code></pre>

<hr>
<h2 id='st_dist_band'>Neighbors from a distance band</h2><span id='topic+st_dist_band'></span>

<h3>Description</h3>

<p>Creates neighbors based on a distance band. By default, creates a distance band with the maximum distance of k-nearest neighbors where k = 1 (the critical threshold) to ensure that there are no regions that are missing neighbors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_dist_band(geometry, lower = 0, upper = critical_threshold(geometry), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="st_dist_band_+3A_geometry">geometry</code></td>
<td>
<p>An sf or sfc object.</p>
</td></tr>
<tr><td><code id="st_dist_band_+3A_lower">lower</code></td>
<td>
<p>The lower threshold of the distance band. It is recommended to keep this as 0.</p>
</td></tr>
<tr><td><code id="st_dist_band_+3A_upper">upper</code></td>
<td>
<p>The upper threshold of the distance band. By default is set to a critical threshold using <code><a href="#topic+critical_threshold">critical_threshold()</a></code> ensuring that each region has a minimum of one neighbor.</p>
</td></tr>
<tr><td><code id="st_dist_band_+3A_...">...</code></td>
<td>
<p>Passed to <code>spdep::dnearneigh()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of class <code>nb</code>
</p>


<h3>See Also</h3>

<p>Other neighbors: 
<code><a href="#topic+st_contiguity">st_contiguity</a>()</code>,
<code><a href="#topic+st_knn">st_knn</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geo &lt;- sf::st_geometry(guerry)
st_dist_band(geo, upper = critical_threshold(geo))
</code></pre>

<hr>
<h2 id='st_inverse_distance'>Calculate inverse distance weights</h2><span id='topic+st_inverse_distance'></span>

<h3>Description</h3>

<p>From a neighbor list and sf geometry column, calculate inverse distance weight.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_inverse_distance(nb, geometry, scale = 100, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="st_inverse_distance_+3A_nb">nb</code></td>
<td>
<p>a neighbors list object e.g. created by <code><a href="#topic+st_knn">st_knn()</a></code> or <code><a href="#topic+st_contiguity">st_contiguity()</a></code></p>
</td></tr>
<tr><td><code id="st_inverse_distance_+3A_geometry">geometry</code></td>
<td>
<p>sf geometry</p>
</td></tr>
<tr><td><code id="st_inverse_distance_+3A_scale">scale</code></td>
<td>
<p>default <code>100</code>.a value to scale distances by before exponentiating by <code>alpha</code></p>
</td></tr>
<tr><td><code id="st_inverse_distance_+3A_alpha">alpha</code></td>
<td>
<p>default 1. Set to 2 for gravity weights.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inverse distance formula is
<code class="reqn">w_{ij} = 1 / d_{ij}^\alpha</code>
</p>


<h3>Value</h3>

<p>a list where each element is a numeric vector
</p>


<h3>See Also</h3>

<p>Other weights: 
<code><a href="#topic+st_kernel_weights">st_kernel_weights</a>()</code>,
<code><a href="#topic+st_nb_dists">st_nb_dists</a>()</code>,
<code><a href="#topic+st_weights">st_weights</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geo &lt;- sf::st_geometry(guerry)
nb &lt;- st_contiguity(geo)
wts &lt;- st_inverse_distance(nb, geo)
head(wts, 3)
wts &lt;- st_inverse_distance(nb, geo, scale = 10000)
head(wts, 3)
</code></pre>

<hr>
<h2 id='st_kernel_weights'>Calculate Kernel Weights</h2><span id='topic+st_kernel_weights'></span>

<h3>Description</h3>

<p>Create a weights list using a kernel function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_kernel_weights(
  nb,
  geometry,
  kernel = "uniform",
  threshold = critical_threshold(geometry),
  adaptive = FALSE,
  self_kernel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="st_kernel_weights_+3A_nb">nb</code></td>
<td>
<p>an object of class <code>nb</code> e.g. created by <code><a href="#topic+st_contiguity">st_contiguity()</a></code> or <code><a href="#topic+st_knn">st_knn()</a></code>.</p>
</td></tr>
<tr><td><code id="st_kernel_weights_+3A_geometry">geometry</code></td>
<td>
<p>the geometry an sf object.</p>
</td></tr>
<tr><td><code id="st_kernel_weights_+3A_kernel">kernel</code></td>
<td>
<p>One of &quot;uniform&quot;, &quot;gaussian&quot;,  &quot;triangular&quot;, &quot;epanechnikov&quot;, or &quot;quartic&quot;. See <a href="#topic+kernels">kernels</a> for more.</p>
</td></tr>
<tr><td><code id="st_kernel_weights_+3A_threshold">threshold</code></td>
<td>
<p>a scaling threshold to be used in calculating</p>
</td></tr>
<tr><td><code id="st_kernel_weights_+3A_adaptive">adaptive</code></td>
<td>
<p>default <code>FALSE</code>. If <code>TRUE</code> uses the maximum neighbor distance for each region as the threshold. Suppresses the <code>threshold</code> argument.</p>
</td></tr>
<tr><td><code id="st_kernel_weights_+3A_self_kernel">self_kernel</code></td>
<td>
<p>default <code>FALSE</code>. If <code>TRUE</code> applies the kernel function to the observed region.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default <code>st_kernel_weight()</code> utilizes a critical threshold of the maximum neighbor distance using <code>critical_threshold()</code>. If desired, the critical threshold can be specified manually. The <code>threshold</code> will be passed to the underlying kernel.
</p>


<h3>Value</h3>

<p>a list where each element is a numeric vector.
</p>


<h3>See Also</h3>

<p>Other weights: 
<code><a href="#topic+st_inverse_distance">st_inverse_distance</a>()</code>,
<code><a href="#topic+st_nb_dists">st_nb_dists</a>()</code>,
<code><a href="#topic+st_weights">st_weights</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geometry &lt;- sf::st_geometry(guerry)
nb &lt;- st_contiguity(geometry)
nb &lt;- include_self(nb)
res &lt;- st_kernel_weights(nb, geometry)
head(res, 3)
</code></pre>

<hr>
<h2 id='st_knn'>Calculate K-Nearest Neighbors</h2><span id='topic+st_knn'></span>

<h3>Description</h3>

<p>Identifies the <code>k</code> nearest neighbors for given point geometry. If polygon geometry is provided, the centroids of the polygon will be used and a warning will be emitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_knn(geometry, k = 1, symmetric = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="st_knn_+3A_geometry">geometry</code></td>
<td>
<p>an sf or sfc object.</p>
</td></tr>
<tr><td><code id="st_knn_+3A_k">k</code></td>
<td>
<p>number of nearest neighbours to be returned</p>
</td></tr>
<tr><td><code id="st_knn_+3A_symmetric">symmetric</code></td>
<td>
<p>default <code>FALSE</code>. Whether to force output of neighbours to be symmetric.</p>
</td></tr>
<tr><td><code id="st_knn_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code>knearneigh()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function utilizes <code><a href="spdep.html#topic+knearneigh">spdep::knearneigh()</a></code> and <code><a href="spdep.html#topic+knn2nb">spdep::knn2nb()</a></code>.
</p>


<h3>Value</h3>

<p>a list of class <code>nb</code>
</p>


<h3>See Also</h3>

<p>Other neighbors: 
<code><a href="#topic+st_contiguity">st_contiguity</a>()</code>,
<code><a href="#topic+st_dist_band">st_dist_band</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>st_knn(sf::st_geometry(guerry), k = 8)
</code></pre>

<hr>
<h2 id='st_lag'>Calculate spatial lag</h2><span id='topic+st_lag'></span>

<h3>Description</h3>

<p>Calculates the spatial lag of a numeric variable given a neighbor and weights list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_lag(x, nb, wt, na_ok = FALSE, allow_zero = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="st_lag_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="st_lag_+3A_nb">nb</code></td>
<td>
<p>A neighbor list object as created by <code>st_neighbors()</code>.</p>
</td></tr>
<tr><td><code id="st_lag_+3A_wt">wt</code></td>
<td>
<p>A weights list as created by <code>st_weights()</code>.</p>
</td></tr>
<tr><td><code id="st_lag_+3A_na_ok">na_ok</code></td>
<td>
<p>Default <code>FALSE</code>. If, <code>TRUE</code> missing values return a lagged <code>NA</code>.</p>
</td></tr>
<tr><td><code id="st_lag_+3A_allow_zero">allow_zero</code></td>
<td>
<p>If <code>TRUE</code>, assigns zero as lagged value to zone without neighbors.</p>
</td></tr>
<tr><td><code id="st_lag_+3A_...">...</code></td>
<td>
<p>See <code>?spdep::lag.listw</code> for more.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector with same length as <code>x</code>
</p>


<h3>See Also</h3>

<p>Other stats: 
<code><a href="#topic+local_moran">local_moran</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geo &lt;- sf::st_geometry(guerry)
nb &lt;- st_contiguity(geo)
wt &lt;- st_weights(nb)

st_lag(guerry$crime_pers, nb, wt)
</code></pre>

<hr>
<h2 id='st_nb_apply'>Apply a function to neighbors</h2><span id='topic+st_nb_apply'></span>

<h3>Description</h3>

<p>Sometimes one may want to create custom lag variables or create some other neighborhood level metric that may not be defined yet. This <code>st_nb_apply()</code> enables you to apply a function to each observation's (xi) neighbors (xij).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_nb_apply(x, nb, wt, .f, suffix = "dbl", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="st_nb_apply_+3A_x">x</code></td>
<td>
<p>A vector that will be used for neighbor xij values.</p>
</td></tr>
<tr><td><code id="st_nb_apply_+3A_nb">nb</code></td>
<td>
<p>A neighbor list object as created by <code>st_neighbors()</code>.</p>
</td></tr>
<tr><td><code id="st_nb_apply_+3A_wt">wt</code></td>
<td>
<p>A weights list as created by <code>st_weights()</code>.</p>
</td></tr>
<tr><td><code id="st_nb_apply_+3A_.f">.f</code></td>
<td>
<p>A function definition. There are three default objects that can be used inside of the function definition:
</p>

<ul>
<li> <p><code>.xij</code>: neighbor values of <code>x</code> for the ith observation. This is simply the subset of x based on the corresponding <code>nb</code> list values for each element.
</p>
</li>
<li> <p><code>.nb</code>: neighbor positions.
</p>
</li>
<li> <p><code>.wt</code>: neighbor weights value.
</p>
</li></ul>

<p>If any of these three function arguments are omitted from <code>.f</code>, dots (<code>...</code>) must be supplied.</p>
</td></tr>
<tr><td><code id="st_nb_apply_+3A_suffix">suffix</code></td>
<td>
<p>The <code>map</code> variant to use. Options are &quot;dbl&quot;, &quot;int&quot;, &quot;lgl&quot;, &quot;chr&quot;, &quot;list&quot;.</p>
</td></tr>
<tr><td><code id="st_nb_apply_+3A_...">...</code></td>
<td>
<p>arguments to pass to <code>.f</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The below example calculates the spatial lag using <code><a href="#topic+st_nb_apply">st_nb_apply()</a></code> and <code><a href="#topic+st_lag">st_lag()</a></code> to illustrate how we can apply functions to neighbors.
</p>
<p>Currently questioning the use case. <code><a href="#topic+find_xj">find_xj()</a></code> is now exported and may negate the need for this function.
</p>


<h3>Value</h3>

<p>a vector or list of with same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("dplyr", quietly = TRUE)) {
library(magrittr)
guerry %&gt;%
  dplyr::transmute(
    nb = st_contiguity(geometry),
    wt = st_weights(nb),
    lag_apply = st_nb_apply(
      crime_pers, nb, wt,
      .f = function(.xij, .wt, ...) sum(.xij *.wt)
    ),
    lag = st_lag(crime_pers, nb, wt)
  )
}
</code></pre>

<hr>
<h2 id='st_nb_delaunay'>Graph based neighbors</h2><span id='topic+st_nb_delaunay'></span><span id='topic+st_nb_gabriel'></span><span id='topic+st_nb_relative'></span>

<h3>Description</h3>

<p>Create graph based neighbors on a set of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_nb_delaunay(geometry, .id = NULL)

st_nb_gabriel(geometry, .nnmult = 3)

st_nb_relative(geometry, .nnmult = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="st_nb_delaunay_+3A_geometry">geometry</code></td>
<td>
<p>an object of class sfc. If polygons are used, points are generated using <code>sf::st_point_on_surface()</code>.</p>
</td></tr>
<tr><td><code id="st_nb_delaunay_+3A_.id">.id</code></td>
<td>
<p>default <code>NULL</code>. Passed as <code>spdep::tri2nb(x, row.names = .id)</code> to <code>spdep</code>.</p>
</td></tr>
<tr><td><code id="st_nb_delaunay_+3A_.nnmult">.nnmult</code></td>
<td>
<p>default 3. Used for memory scalling. See <code><a href="spdep.html#topic+graphneigh">spdep::gabrielneigh()</a></code> for more.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>st_nb_delaunay()</code> uses <code>spdep::tri2nb()</code>
</p>
</li>
<li> <p><code>st_nb_gabriel()</code> uses <code>spdep::gabrielneigh()</code> and <code>spdep::graph2nb()</code>
</p>
</li>
<li> <p><code>st_nb_relative()</code> uses <code>spdep::relativeneigh()</code> and <code>spdep::graph2nb()</code>
</p>
</li></ul>

<p><code>st_nb_delaunay()</code> implements Delaunay triangulation via <code>spdep</code> and thus via <code>deldir</code>. Delaunay triangulation creates a mesh of triangles that connects all points in a set. It ensures that no point is in in the circumcircle of an triangle in the triangulation. As a result, Delaunay triangulation maximizes the minimum angle in each triangle consequently avoiding skinny triangles.
</p>
<p>The Gabriel graph is a subgraph of the Delaunay triangulation. Edges are created when the closed disc between two points p, and q, contain no other points besides themselves.
</p>
<p>The relative neighborhood graph (RNG) is based on the Delaunay triangulation. It connects two points when there are no other closer points to each of them. The RNG is a subgraph of the Delaunay triangulation.
</p>
<p>Note that Delaunay triangulation assumes a plane and thus uses Euclidean distances.
</p>
<p>See <code><a href="spdep.html#topic+graphneigh">spdep::gabrielneigh()</a></code> for further descriptions of the graph neighbor implementations.
</p>


<h3>Value</h3>

<p>an object of class nb
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geometry &lt;- sf::st_centroid(sf::st_geometry(guerry))
st_nb_delaunay(geometry)
st_nb_gabriel(geometry)
st_nb_relative(geometry)
</code></pre>

<hr>
<h2 id='st_nb_dists'>Calculate neighbor distances</h2><span id='topic+st_nb_dists'></span>

<h3>Description</h3>

<p>From an nb list and point geometry, return a list of distances for each observation's neighbors list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_nb_dists(x, nb, longlat = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="st_nb_dists_+3A_x">x</code></td>
<td>
<p>an object of class <code>sfc</code>.</p>
</td></tr>
<tr><td><code id="st_nb_dists_+3A_nb">nb</code></td>
<td>
<p>a neighbor list for example created by <code><a href="#topic+st_contiguity">st_contiguity()</a></code></p>
</td></tr>
<tr><td><code id="st_nb_dists_+3A_longlat">longlat</code></td>
<td>
<p><code>TRUE</code> if point coordinates are longitude-latitude decimal degrees, in which case distances are measured in kilometers. See <code>?spdep::nbdists()</code> for more.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Utilizes <code>spdep::nbdists()</code> for distance calculation.
</p>


<h3>Value</h3>

<p>a list where each element is a numeric vector.
</p>


<h3>See Also</h3>

<p>Other weights: 
<code><a href="#topic+st_inverse_distance">st_inverse_distance</a>()</code>,
<code><a href="#topic+st_kernel_weights">st_kernel_weights</a>()</code>,
<code><a href="#topic+st_weights">st_weights</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geo &lt;- sf::st_geometry(guerry)
nb &lt;- st_contiguity(geo)
dists &lt;- st_nb_dists(geo, nb)

head(dists)
</code></pre>

<hr>
<h2 id='st_nb_lag'>Pure Higher Order Neighbors</h2><span id='topic+st_nb_lag'></span>

<h3>Description</h3>

<p>Identify higher order neighbors from a neighbor list. <code>order</code> must be greater than 1. When order equals 2 then the neighbors of the neighbors list is returned and so forth. See <a href="https://spatialanalysis.github.io/handsonspatialdata/index.html">Anselin's book</a> was: &quot;https://spatial.uchicago.edu&quot; &quot;/sites/spatial.uchicago.edu/files/1_introandreview_reducedsize.pdf&quot; for an example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_nb_lag(nb, order)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="st_nb_lag_+3A_nb">nb</code></td>
<td>
<p>A neighbor list object as created by <code>st_contiguity()</code>.</p>
</td></tr>
<tr><td><code id="st_nb_lag_+3A_order">order</code></td>
<td>
<p>The order of neighbors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Utilizes <code><a href="spdep.html#topic+nblag">spdep::nblag()</a></code>
</p>


<h3>Value</h3>

<p>a list of class <code>nb</code>
</p>


<h3>See Also</h3>

<p>Other other: 
<code><a href="#topic+st_cardinalties">st_cardinalties</a>()</code>,
<code><a href="#topic+st_nb_lag_cumul">st_nb_lag_cumul</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nb &lt;- st_contiguity(sf::st_geometry(guerry))
st_nb_lag(nb, 3)
</code></pre>

<hr>
<h2 id='st_nb_lag_cumul'>Encompassing Higher Order Neighbors</h2><span id='topic+st_nb_lag_cumul'></span>

<h3>Description</h3>

<p>Creates an encompassing neighbor list of the order specified.
For example, if the order is 2 the result contains both 1st
and 2nd order neighbors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_nb_lag_cumul(nb, order)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="st_nb_lag_cumul_+3A_nb">nb</code></td>
<td>
<p>A neighbor list object as created by <code>st_contiguity()</code>.</p>
</td></tr>
<tr><td><code id="st_nb_lag_cumul_+3A_order">order</code></td>
<td>
<p>The order of neighbors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Utilizes <code><a href="spdep.html#topic+nblag">spdep::nblag_cumul()</a></code>
</p>


<h3>Value</h3>

<p>a list of class <code>nb</code>
</p>


<h3>See Also</h3>

<p>Other other: 
<code><a href="#topic+st_cardinalties">st_cardinalties</a>()</code>,
<code><a href="#topic+st_nb_lag">st_nb_lag</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nb &lt;- st_contiguity(sf::st_geometry(guerry))
st_nb_lag_cumul(nb, 3)
</code></pre>

<hr>
<h2 id='st_weights'>Calculate spatial weights</h2><span id='topic+st_weights'></span>

<h3>Description</h3>

<p>Calculate polygon spatial weights from a <code>nb</code> list. See <code><a href="spdep.html#topic+nb2listw">spdep::nb2listw()</a></code> for further details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_weights(nb, style = "W", allow_zero = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="st_weights_+3A_nb">nb</code></td>
<td>
<p>A neighbor list object as created by <code>st_neighbors()</code>.</p>
</td></tr>
<tr><td><code id="st_weights_+3A_style">style</code></td>
<td>
<p>Default <code>"W"</code> for row standardized weights. This value can also be &quot;B&quot;, &quot;C&quot;, &quot;U&quot;, &quot;minmax&quot;, and &quot;S&quot;. See <code><a href="spdep.html#topic+nb2listw">spdep::nb2listw()</a></code> for details.</p>
</td></tr>
<tr><td><code id="st_weights_+3A_allow_zero">allow_zero</code></td>
<td>
<p>If <code>TRUE</code>, assigns zero as lagged value to zone without neighbors.</p>
</td></tr>
<tr><td><code id="st_weights_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="spdep.html#topic+nb2listw">spdep::nb2listw()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under the hood, <code><a href="#topic+st_weights">st_weights()</a></code> creates a <code>listw</code> object and then extracts the weights elements from it as the <code>neighbours</code> element is already&ndash;presumably&ndash;already existent in the neighbors list you've already created. <code>listw</code> objects are recreated using <code><a href="#topic+recreate_listw">recreate_listw()</a></code> when calculating other statistics.
</p>


<h3>Value</h3>

<p>a list where each element is a numeric vector
</p>


<h3>See Also</h3>

<p>Other weights: 
<code><a href="#topic+st_inverse_distance">st_inverse_distance</a>()</code>,
<code><a href="#topic+st_kernel_weights">st_kernel_weights</a>()</code>,
<code><a href="#topic+st_nb_dists">st_nb_dists</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("dplyr", quietly = TRUE)) {
library(magrittr)
guerry %&gt;%
 dplyr::mutate(nb = st_contiguity(geometry),
               wt = st_weights(nb),
               .before = 1)

}
# using geometry column directly
nb &lt;- st_contiguity(guerry$geometry)
wt &lt;- st_weights(nb)
wt[1:3]
</code></pre>

<hr>
<h2 id='std_dev_ellipse'>Calculation Standard Deviational Ellipse</h2><span id='topic+std_dev_ellipse'></span>

<h3>Description</h3>

<p>From an sf object containing points, calculate the standard deviational ellipse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>std_dev_ellipse(geometry)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="std_dev_ellipse_+3A_geometry">geometry</code></td>
<td>
<p>an sfc object. If a polygon, uses <code><a href="sf.html#topic+geos_unary">sf::st_point_on_surface()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bulk of this function is derived from the archived CRAN package aspace version 3.2.0.
</p>


<h3>Value</h3>

<p>An sf object with three columns
</p>

<ul>
<li> <p><code>sx</code>: major axis radius in CRS units,
</p>
</li>
<li> <p><code>sy</code>: minor axis radius in CRS units,
</p>
</li>
<li> <p><code>theta</code>: degree rotation of the ellipse.
</p>
</li></ul>

<p>sf object's geometry is the center mean point.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' # Make a grid to sample from
grd &lt;- sf::st_make_grid(n = c(1, 1), cellsize = c(100, 100), offset = c(0,0))

# sample 100 points
pnts &lt;- sf::st_sample(grd, 100)
std_dev_ellipse(pnts)
</code></pre>

<hr>
<h2 id='std_distance'>Calculate standard distance</h2><span id='topic+std_distance'></span>

<h3>Description</h3>

<p>The standard distance of a point pattern is a measure of central tendency.
Standard distance measures distance away from the mean center of the point pattern
similar to standard deviations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>std_distance(geometry)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="std_distance_+3A_geometry">geometry</code></td>
<td>
<p>an sfc object. If a polygon, uses <code><a href="sf.html#topic+geos_unary">sf::st_point_on_surface()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric scalar.
</p>


<h3>See Also</h3>

<p>Other point-pattern: 
<code><a href="#topic+center_mean">center_mean</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a grid to sample from
grd &lt;- sf::st_make_grid(n = c(1, 1), cellsize = c(100, 100), offset = c(0,0))

# sample 100 points
pnts &lt;- sf::st_sample(grd, 100)

# plot points
plot(pnts)

# calculate standard distance
std_distance(pnts)
</code></pre>

<hr>
<h2 id='szero'>Global sum of weights</h2><span id='topic+szero'></span>

<h3>Description</h3>

<p>Calculate the global sum of weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>szero(wt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="szero_+3A_wt">wt</code></td>
<td>
<p>a weights list—i.e. created by <code>st_weights()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar numeric
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nb &lt;- st_contiguity(guerry)
wt &lt;- st_weights(nb)
szero(wt)
</code></pre>

<hr>
<h2 id='tidyverse'>tidyverse methods for spacetime objects</h2><span id='topic+tidyverse'></span><span id='topic+group_by.spacetime'></span><span id='topic+mutate.spacetime'></span><span id='topic+ungroup.spacetime'></span>

<h3>Description</h3>

<p>dplyr methods for spacetime objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_by.spacetime(.data, ...)

mutate.spacetime(.data, ...)

ungroup.spacetime(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidyverse_+3A_.data">.data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a spacetime object
</p>

<hr>
<h2 id='wt_as_matrix'>Convert neighbor or weights list to matrix</h2><span id='topic+wt_as_matrix'></span><span id='topic+nb_as_matrix'></span>

<h3>Description</h3>

<p>Given a <code>nb</code> list or weights list, convert them to a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wt_as_matrix(nb, wt)

nb_as_matrix(nb)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wt_as_matrix_+3A_nb">nb</code></td>
<td>
<p>a neighbor list—i.e. as created by <code>st_contiguity()</code>.</p>
</td></tr>
<tr><td><code id="wt_as_matrix_+3A_wt">wt</code></td>
<td>
<p>a weights list—i.e. as created by <code>st_weights()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a n x n matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# make a grid
g &lt;- sf::st_make_grid(
  cellsize = c(10, 10),
  offset = c(0, 0),
  n = c(2, 2)
)

# create neighbors
nb &lt;- st_contiguity(g)

# cast to matrix
nb_as_matrix(nb)

# create weights
wt &lt;- st_weights(nb)

# cast as matrix
wt_as_matrix(nb, wt)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
