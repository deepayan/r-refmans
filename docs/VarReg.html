<!DOCTYPE html><html lang="en"><head><title>Help for package VarReg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {VarReg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#VarReg'><p>VarReg: Semi-parametric mean and variance regression</p></a></li>
<li><a href='#censlinVarReg'><p>Censored Linear mean and variance regression</p></a></li>
<li><a href='#censloop_em'><p>The Censored data EM loop</p></a></li>
<li><a href='#criterion'><p>Calculation of information criterion</p></a></li>
<li><a href='#linVarReg'><p>Linear mean and variance regression function</p></a></li>
<li><a href='#loop_em'><p>The EM loop for the main mean and variance function</p></a></li>
<li><a href='#loop_lss'><p>The EM loop for the LSS model</p></a></li>
<li><a href='#lss_calc'><p>Calculations for SN</p></a></li>
<li><a href='#lssVarReg'><p>Semi parametric location, shape and scale regression</p></a></li>
<li><a href='#lssVarReg.multi'><p>Semi parametric location, shape and scale regression</p></a></li>
<li><a href='#mcycle'><p>mcycle dataset.</p></a></li>
<li><a href='#plotlssVarReg'><p>Plots graphics for a location, scale and shape regression model</p></a></li>
<li><a href='#plotVarReg'><p>Plots graphics for a mean and variance regression model</p></a></li>
<li><a href='#searchVarReg'><p>Searches for best semi parametric mean and variance regression model</p></a></li>
<li><a href='#semiVarReg'><p>Semi parametric mean and variance regression</p></a></li>
<li><a href='#semiVarReg.multi'><p>Semi parametric mean and variance regression (multivariate)</p></a></li>
<li><a href='#seVarReg'><p>SE calculations for mean and variance regression models</p></a></li>
<li><a href='#VarReg.control'><p>Auxillary for controlling VarReg fitting</p></a></li>
<li><a href='#vcf'><p>vcf dataset.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Semi-Parametric Variance Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kristy Robledo &lt;robledo.kristy@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for fitting semi-parametric mean and variance models, with normal or censored data. Extended to allow a regression in the location, scale and shape parameters, and further for multiple regression in each.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Imports:</td>
<td>splines, stats, graphics, sn, survival, utils</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-15 23:16:16 UTC; kman2804</td>
</tr>
<tr>
<td>Author:</td>
<td>Kristy Robledo [aut, cre],
  Ian Marschner [ths]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-15 23:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='VarReg'>VarReg: Semi-parametric mean and variance regression</h2><span id='topic+VarReg'></span><span id='topic+VarReg-package'></span>

<h3>Description</h3>

<p>Methods for fitting semi-parametric mean and variance models, with normal or censored data.
Also extended to allow a regression in the location, scale and shape parameters.
</p>


<h3>Details</h3>

<p>This package provides functions to fit semi-parametric mean and variance regression models. These models
are based upon EM-type algorithms, which can have more stable convergence properties than other
algorithms for additive variance regression models.
</p>
<p>The primary function to use for linear and semi-parametric mean and variance models is <code><a href="#topic+semiVarReg">semiVarReg</a></code>.
This function also is able to fit models to censored outcome data. There is also a plot function for these
models called <code><a href="#topic+plotVarReg">plotVarReg</a></code>.
A search function has also been produced in order to assist users to find the optimal number of knots in
the model (<code><a href="#topic+searchVarReg">searchVarReg</a></code>).
</p>
<p>The other functions that are of particular use are <code><a href="#topic+lssVarReg">lssVarReg</a></code> and its plot function
<code><a href="#topic+plotlssVarReg">plotlssVarReg</a></code>. This uses the skew-normal distribution and combines the EM algorithm with
a coordinate-ascent type algorithm in order to fit a regression model in the location, scale and shape,
therefore extending the semi-parametric models to non-normal data.
</p>
<p>Multivariate models can be fit with <code><a href="#topic+semiVarReg.multi">semiVarReg.multi</a></code> and <code><a href="#topic+lssVarReg.multi">lssVarReg.multi</a></code>
</p>


<h3>Author(s)</h3>

<p>Kristy Robledo <a href="mailto:robledo.kristy@gmail.com">robledo.kristy@gmail.com</a>
</p>

<hr>
<h2 id='censlinVarReg'>Censored Linear mean and variance regression</h2><span id='topic+censlinVarReg'></span>

<h3>Description</h3>

<p><code>censlinVarReg</code> performs censored multivariate mean and multivariate variance regression.
This function is designed to be used by the  <code><a href="#topic+semiVarReg">semiVarReg</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>censlinVarReg(
  dat,
  mean.ind = c(2),
  var.ind = c(2),
  cens.ind = c(3),
  mean.intercept = TRUE,
  para.space = c("all", "positive", "negative"),
  mean.init = NULL,
  var.init = NULL,
  control = list(...),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="censlinVarReg_+3A_dat">dat</code></td>
<td>
<p>Dataframe containing outcome and covariate data. Outcome data must be in the first column, with censored values set to the limits. Covariates for mean and variance model in next columns.</p>
</td></tr>
<tr><td><code id="censlinVarReg_+3A_mean.ind">mean.ind</code></td>
<td>
<p>Vector containing the column numbers of the data in 'dat' to be fit as covariates in the mean model. 0 indicates constant mean option. NULL indicates zero mean option.</p>
</td></tr>
<tr><td><code id="censlinVarReg_+3A_var.ind">var.ind</code></td>
<td>
<p>Vector containing the column numbers of the data in 'dat' to be fit as covariates in the variance model. FALSE indicates constant variance option.</p>
</td></tr>
<tr><td><code id="censlinVarReg_+3A_cens.ind">cens.ind</code></td>
<td>
<p>Vector containing the column number of the data in 'dat' to indicate the censored data. 0 indicates no censoring, -1 indicates left (lower) censoring and 1 indicates right (upper) censoring.</p>
</td></tr>
<tr><td><code id="censlinVarReg_+3A_mean.intercept">mean.intercept</code></td>
<td>
<p>Logical to indicate if an intercept is to be included in the mean model. Default is TRUE.</p>
</td></tr>
<tr><td><code id="censlinVarReg_+3A_para.space">para.space</code></td>
<td>
<p>Parameter space to search for variance parameter estimates. &quot;positive&quot; means only search positive parameter space, &quot;negative&quot; means search only negative parameter space and &quot;all&quot; means search all. Default is all.</p>
</td></tr>
<tr><td><code id="censlinVarReg_+3A_mean.init">mean.init</code></td>
<td>
<p>Vector of initial estimates to be used for the mean model.</p>
</td></tr>
<tr><td><code id="censlinVarReg_+3A_var.init">var.init</code></td>
<td>
<p>Vector of initial estimates to be used for the variance model.</p>
</td></tr>
<tr><td><code id="censlinVarReg_+3A_control">control</code></td>
<td>
<p>List of control parameters. See <code><a href="#topic+VarReg.control">VarReg.control</a></code>.</p>
</td></tr>
<tr><td><code id="censlinVarReg_+3A_...">...</code></td>
<td>
<p>arguments to be used to form the default control argument if it is not supplied
directly</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>censlinVarReg</code> returns a list of output including:
</p>

<ul>
<li><p><code>converged</code>: Logical argument indicating if convergence occurred.
</p>
</li>
<li><p><code>iterations</code>: Total iterations performed of the EM algorithm.
</p>
</li>
<li><p><code>reldiff</code>: the positive convergence tolerance that occured at the final iteration.
</p>
</li>
<li><p><code>loglik</code>: Numeric variable of the maximised log-likelihood.
</p>
</li>
<li><p><code>boundary</code>: Logical argument indicating if estimates are on the boundary.
</p>
</li>
<li><p><code>aic.c</code>: Akaike information criterion corrected for small samples
</p>
</li>
<li><p><code>aic</code>: Akaike information criterion
</p>
</li>
<li><p><code>bic</code>: Bayesian information criterion
</p>
</li>
<li><p><code>hqc</code>: Hannan-Quinn information criterion
</p>
</li>
<li><p><code>mean.ind</code>: Vector of integer(s) indicating the column number(s) in the dataframe
<code>data</code> that were fit in the mean model.
</p>
</li>
<li><p><code>mean</code>: Vector of the maximum likelihood estimates of the mean parameters.
</p>
</li>
<li> <p><code>var.ind</code>: Vector of integer(s) indicating the column(s) in the dataframe
<code>data</code> that were fit in the variance model.
</p>
</li>
<li><p><code>variance</code>: Vector of the maximum likelihood estimates of the variance parameters.
</p>
</li>
<li><p><code>cens.ind</code>: Integer indicating the column in the dataframe <code>data</code> that
corresponds to the censoring indicator.
</p>
</li>
<li><p><code>data</code>: Dataframe containing the variables included in the model.
</p>
</li></ul>


<hr>
<h2 id='censloop_em'>The Censored data EM loop</h2><span id='topic+censloop_em'></span>

<h3>Description</h3>

<p><code>censloop_em</code> is an EM loop function for censored data to be utilised by various other higher level functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>censloop_em(
  meanmodel,
  theta.old,
  beta.old,
  p.old,
  x.0,
  X,
  censor.ind,
  mean.intercept,
  maxit,
  eps
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="censloop_em_+3A_meanmodel">meanmodel</code></td>
<td>
<p>Dataframe containing only the covariates to be fit in the mean model. NULL for zero mean model and FALSE for constant mean model.</p>
</td></tr>
<tr><td><code id="censloop_em_+3A_theta.old">theta.old</code></td>
<td>
<p>Vector containing the initial variance parameter estimates to be fit in the variance model.</p>
</td></tr>
<tr><td><code id="censloop_em_+3A_beta.old">beta.old</code></td>
<td>
<p>Vector containing the initial mean parameter estimates to be fit in the mean model.</p>
</td></tr>
<tr><td><code id="censloop_em_+3A_p.old">p.old</code></td>
<td>
<p>Vector of length n containing the initial variance estimate.</p>
</td></tr>
<tr><td><code id="censloop_em_+3A_x.0">x.0</code></td>
<td>
<p>Matrix of covariates (length n) to be fit in the variance model. All have been rescaled so zero is the minimum. If NULL, then its a constant variance model.</p>
</td></tr>
<tr><td><code id="censloop_em_+3A_x">X</code></td>
<td>
<p>Vector of length n of the outcome variable.</p>
</td></tr>
<tr><td><code id="censloop_em_+3A_censor.ind">censor.ind</code></td>
<td>
<p>Vector of length n of the censoring indicator. 0=uncensored, -1=left censored and 1 is right censored.</p>
</td></tr>
<tr><td><code id="censloop_em_+3A_mean.intercept">mean.intercept</code></td>
<td>
<p>Logical to indicate if mean intercept is to be included in the model.</p>
</td></tr>
<tr><td><code id="censloop_em_+3A_maxit">maxit</code></td>
<td>
<p>Number of maximum iterations for the EM algorithm.</p>
</td></tr>
<tr><td><code id="censloop_em_+3A_eps">eps</code></td>
<td>
<p>Very small number for the convergence criteria.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the results from the EM algorithm, including:
</p>

<ul>
<li><p><code>conv</code>: Logical argument indicating if convergence occurred
</p>
</li>
<li><p><code>it</code>: Total iterations performed of the EM algorithm
</p>
</li>
<li><p><code>reldiff</code>: the positive convergence tolerance that occured at the final iteration.
</p>
</li>
<li><p><code>theta.new</code>: Vector of variance parameter estimates. Note that these are not yet
transformed back to the appropriate scale
</p>
</li>
<li><p><code>mean</code>: Vector of mean parameter estimates
</p>
</li>
<li><p><code>fittedmean</code>: Vector of fitted mean estimates
</p>
</li>
<li><p><code>p.old</code>: Vector of fitted variance estimates
</p>
</li></ul>


<hr>
<h2 id='criterion'>Calculation of information criterion</h2><span id='topic+criterion'></span>

<h3>Description</h3>

<p><code>criterion</code> calculates various information criterion for the algorithms in this package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>criterion(n, loglik, param)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="criterion_+3A_n">n</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code id="criterion_+3A_loglik">loglik</code></td>
<td>
<p>Loglikelihood from model</p>
</td></tr>
<tr><td><code id="criterion_+3A_param">param</code></td>
<td>
<p>Number of parameters fit in model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the four IC
</p>

<ul>
<li><p><code>aic.c</code>: Akaike information criterion corrected for small samples
</p>
</li>
<li><p><code>aic</code>: Akaike information criterion
</p>
</li>
<li><p><code>bic</code>: Bayesian information criterion
</p>
</li>
<li><p><code>hqc</code>: Hannan-Quinn information criterion
</p>
</li></ul>


<hr>
<h2 id='linVarReg'>Linear mean and variance regression function</h2><span id='topic+linVarReg'></span>

<h3>Description</h3>

<p><code>linVarReg</code> performs multivariate mean and multivariate variance regression. This function is
designed to be used by the  <code><a href="#topic+semiVarReg">semiVarReg</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linVarReg(
  dat,
  var.ind = c(2),
  mean.ind = c(2),
  para.space = c("all", "positive", "negative"),
  control = list(...),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linVarReg_+3A_dat">dat</code></td>
<td>
<p>Dataframe containing outcome and covariate data. Outcome data must be in the first column. Covariates for mean and variance model in next columns.</p>
</td></tr>
<tr><td><code id="linVarReg_+3A_var.ind">var.ind</code></td>
<td>
<p>Vector containing the column numbers of the data in 'dat' to be fit as covariates in the variance model. FALSE indicates constant variance option.</p>
</td></tr>
<tr><td><code id="linVarReg_+3A_mean.ind">mean.ind</code></td>
<td>
<p>Vector containing the column numbers of the data in 'dat' to be fit as covariates in the mean model. 0 indicates constant mean option. NULL indicates zero mean option.</p>
</td></tr>
<tr><td><code id="linVarReg_+3A_para.space">para.space</code></td>
<td>
<p>Parameter space to search for variance parameter estimates. &quot;positive&quot; means only search positive parameter space, &quot;negative&quot; means search only negative parameter space and &quot;all&quot; means search all.</p>
</td></tr>
<tr><td><code id="linVarReg_+3A_control">control</code></td>
<td>
<p>List of control parameters. See <code><a href="#topic+VarReg.control">VarReg.control</a></code>.</p>
</td></tr>
<tr><td><code id="linVarReg_+3A_...">...</code></td>
<td>
<p>arguments to be used to form the default control argument if it is not supplied
directly</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>linVarReg</code> returns a list of output including:
</p>

<ul>
<li><p><code>converged</code>: Logical argument indicating if convergence occurred.
</p>
</li>
<li><p><code>iterations</code>: Total iterations performed of the EM algorithm.
</p>
</li>
<li><p><code>reldiff</code>: the positive convergence tolerance that occured at the final iteration.
</p>
</li>
<li><p><code>loglik</code>: Numeric variable of the maximised log-likelihood.
</p>
</li>
<li><p><code>boundary</code>: Logical argument indicating if estimates are on the boundary.
</p>
</li>
<li><p><code>aic.c</code>: Akaike information criterion corrected for small samples
</p>
</li>
<li><p><code>aic</code>: Akaike information criterion
</p>
</li>
<li><p><code>bic</code>: Bayesian information criterion
</p>
</li>
<li><p><code>hqc</code>: Hannan-Quinn information criterion
</p>
</li>
<li><p><code>mean.ind</code>: Vector of integer(s) indicating the column number(s) in the dataframe
<code>data</code> that were fit in the mean model.
</p>
</li>
<li><p><code>mean</code>: Vector of the maximum likelihood estimates of the mean parameters.
</p>
</li>
<li> <p><code>var.ind</code>: Vector of integer(s) indicating the column(s) in the dataframe
<code>data</code> that were fit in the variance model.
</p>
</li>
<li><p><code>variance</code>: Vector of the maximum likelihood estimates of the variance parameters.
</p>
</li>
<li><p><code>cens.ind</code>: Integer indicating the column in the dataframe <code>data</code> that
corresponds to the censoring indicator. Always NULL.
</p>
</li>
<li><p><code>data</code>: Dataframe containing the variables included in the model.
</p>
</li></ul>


<hr>
<h2 id='loop_em'>The EM loop for the main mean and variance function</h2><span id='topic+loop_em'></span>

<h3>Description</h3>

<p><code>loop_em</code> is a basic EM loop function to be utilised by various other higher level functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loop_em(meanmodel, theta.old, p.old, x.0, X, maxit, eps)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loop_em_+3A_meanmodel">meanmodel</code></td>
<td>
<p>Dataframe containing only the covariates to be fit in the mean model. NULL for zero mean model and FALSE for constant mean model.</p>
</td></tr>
<tr><td><code id="loop_em_+3A_theta.old">theta.old</code></td>
<td>
<p>Vector containing the initial variance parameter estimates to be fit in the variance model.</p>
</td></tr>
<tr><td><code id="loop_em_+3A_p.old">p.old</code></td>
<td>
<p>Vector of length n containing the containing the initial variance estimate.</p>
</td></tr>
<tr><td><code id="loop_em_+3A_x.0">x.0</code></td>
<td>
<p>Matrix of covariates (length n) to be fit in the variance model. All have been rescaled so zero is the minimum. If NULL, then its a constant variance model.</p>
</td></tr>
<tr><td><code id="loop_em_+3A_x">X</code></td>
<td>
<p>Vector of length n of the outcome variable.</p>
</td></tr>
<tr><td><code id="loop_em_+3A_maxit">maxit</code></td>
<td>
<p>Number of maximum iterations for the EM algorithm.</p>
</td></tr>
<tr><td><code id="loop_em_+3A_eps">eps</code></td>
<td>
<p>Very small number for the convergence criteria.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the results from the EM algorithm, including
</p>

<ul>
<li><p><code>conv</code>: Logical argument indicating if convergence occurred
</p>
</li>
<li><p><code>it</code>: Total iterations performed of the EM algorithm
</p>
</li>
<li><p><code>reldiff</code>: the positive convergence tolerance that occured at the final iteration.
</p>
</li>
<li><p><code>theta.new</code>: Vector of variance parameter estimates. Note that these are not yet
transformed back to the appropriate scale
</p>
</li>
<li><p><code>mean</code>: Vector of mean parameter estimates
</p>
</li>
<li><p><code>fittedmean</code>: Vector of fitted mean estimates
</p>
</li>
<li><p><code>p.old</code>: Vector of fitted variance estimates
</p>
</li></ul>


<hr>
<h2 id='loop_lss'>The EM loop for the LSS model</h2><span id='topic+loop_lss'></span>

<h3>Description</h3>

<p><code>loop_lss</code> is the EM loop function for the LSS model to be utilised by various other higher level functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loop_lss(
  alldat,
  xiold,
  omega2old,
  nuold,
  mean.ind,
  var.ind,
  nu.ind,
  para.space,
  maxit,
  eps,
  int.maxit,
  print.it
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loop_lss_+3A_alldat">alldat</code></td>
<td>
<p>Dataframe containing all the data for the models. Outcome in the first column.</p>
</td></tr>
<tr><td><code id="loop_lss_+3A_xiold">xiold</code></td>
<td>
<p>Vector of initial location parameter estimates to be fit in the location model.</p>
</td></tr>
<tr><td><code id="loop_lss_+3A_omega2old">omega2old</code></td>
<td>
<p>Vector of initial scale2 parameter estimates to be fit in the scale2 model.</p>
</td></tr>
<tr><td><code id="loop_lss_+3A_nuold">nuold</code></td>
<td>
<p>Vector of initial nu parameter estimates to be fit in the nu model.</p>
</td></tr>
<tr><td><code id="loop_lss_+3A_mean.ind">mean.ind</code></td>
<td>
<p>Vector containing the column numbers of the data in 'alldat' to be fit as covariates in the location model.</p>
</td></tr>
<tr><td><code id="loop_lss_+3A_var.ind">var.ind</code></td>
<td>
<p>Vector containing the column numbers of the data in 'alldat' to be fit as covariates in the scale2 model. FALSE indicates a constant variance model.</p>
</td></tr>
<tr><td><code id="loop_lss_+3A_nu.ind">nu.ind</code></td>
<td>
<p>Vector containing the column numbers of the data in 'alldat' to be fit as covariates in the nu model. NULL indicates constant model.</p>
</td></tr>
<tr><td><code id="loop_lss_+3A_para.space">para.space</code></td>
<td>
<p>Parameter space to search for variance parameter estimates. &quot;positive&quot; means only search positive parameter space, &quot;negative&quot; means search only negative parameter space and &quot;all&quot; means search all.</p>
</td></tr>
<tr><td><code id="loop_lss_+3A_maxit">maxit</code></td>
<td>
<p>Number of maximum iterations for the main EM algorithm.</p>
</td></tr>
<tr><td><code id="loop_lss_+3A_eps">eps</code></td>
<td>
<p>Very small number for the convergence criteria.</p>
</td></tr>
<tr><td><code id="loop_lss_+3A_int.maxit">int.maxit</code></td>
<td>
<p>Number of maximum iterations for the internal EM algorithm for the location and scale.</p>
</td></tr>
<tr><td><code id="loop_lss_+3A_print.it">print.it</code></td>
<td>
<p>Logical to indicate if the estimates for each iteration should be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the results from the algorithm, including conv, reldiff, it, mean, xi.new, omega2.new, nu.new, fitted.xi
</p>

<ul>
<li><p><code>conv</code>: Logical argument indicating if convergence occurred
</p>
</li>
<li><p><code>it</code>: Total iterations performed of the EM algorithm
</p>
</li>
<li><p><code>reldiff</code>: the positive convergence tolerance that occured at the final iteration
</p>
</li>
<li><p><code>xinew</code>: Vector of location parameter estimates
</p>
</li>
<li><p><code>omega2new</code>: Vector of scale squared parameter estimates
</p>
</li>
<li><p><code>nunew</code>: Vector of shape parameter estimates
</p>
</li>
<li><p><code>fitted.xi</code>: Vector of fitted location estimates
</p>
</li></ul>


<hr>
<h2 id='lss_calc'>Calculations for SN</h2><span id='topic+lss_calc'></span>

<h3>Description</h3>

<p><code>lss_calc</code> performs calculations for transforming SN data (location, scale and shape) to mean, variance and skew. This function is utilised by other, higher level functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lss_calc(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lss_calc_+3A_x">x</code></td>
<td>
<p>Object of class lssVarReg (output from <code>lssVarReg</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe containing:
</p>

<ul>
<li><p><code>y</code>: y variable
</p>
</li>
<li><p><code>x</code>: x variable
</p>
</li>
<li><p><code>eta</code>: <code class="reqn">\eta</code> or fitted location estimates
</p>
</li>
<li><p><code>omega</code>: <code class="reqn">\omega</code> or fitted scale estimates
</p>
</li>
<li><p><code>shape</code>: <code class="reqn">\alpha</code> or fitted shape estimates
</p>
</li>
<li><p><code>predicted mean</code>: fitted mean estimates
</p>
</li>
<li><p><code>predicted variance</code>: fitted variance estimates
</p>
</li>
<li><p><code>Predicted skewness</code>: fitted skewness estimates
</p>
</li>
<li><p><code>stand.res2</code>: Squared standardised residuals
</p>
</li></ul>


<hr>
<h2 id='lssVarReg'>Semi parametric location, shape and scale regression</h2><span id='topic+lssVarReg'></span>

<h3>Description</h3>

<p><code>lssVarReg</code> performs a semiparametric location (<code class="reqn">\xi</code> or xi), shape (<code class="reqn">\nu</code> or nu) and scale (<code class="reqn">\omega</code> or omega) regression model. Currently, this is only designed for a single covariate that is fit in the location, scale and shape models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lssVarReg(
  y,
  x,
  locationmodel = c("constant", "linear", "semi"),
  scale2model = c("constant", "linear", "semi"),
  shapemodel = c("constant", "linear"),
  knots.l = 2,
  knots.sc = 2,
  knots.sh = 2,
  degree = 2,
  mono.scale = c("none", "inc", "dec"),
  para.space = c("all", "positive", "negative"),
  location.init = NULL,
  scale2.init = NULL,
  shape.init = NULL,
  int.maxit = 1000,
  print.it = FALSE,
  control = list(...),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lssVarReg_+3A_y">y</code></td>
<td>
<p>Vector containing outcome data. Must be no missing data.</p>
</td></tr>
<tr><td><code id="lssVarReg_+3A_x">x</code></td>
<td>
<p>Vector containing the covariate data, same length as <code>y</code>. Must be no missing data.</p>
</td></tr>
<tr><td><code id="lssVarReg_+3A_locationmodel">locationmodel</code></td>
<td>
<p>Text to specify the location model to be fit. Options: <code>"constant"</code> = constant model (intercept only), <code>"linear"</code> = linear term with x covariate, <code>"semi"</code> = semiparametric spline (specify with <code>knots.l</code>).</p>
</td></tr>
<tr><td><code id="lssVarReg_+3A_scale2model">scale2model</code></td>
<td>
<p>Text to specify the scale^2 model to be fit. Options: <code>"constant"</code> = constant term only, <code>"linear"</code> = linear term with <code>x</code> covariate, <code>"semi"</code> = semiparametric spline (specify with <code>knots.sc</code>)</p>
</td></tr>
<tr><td><code id="lssVarReg_+3A_shapemodel">shapemodel</code></td>
<td>
<p>Text to specify the shape model to be fit. Options: <code>"constant"</code> = constant shape model, <code>"linear"</code> = linear term with x covariate, <code>"semi"</code> = semiparametric spline (specify with <code>knots.sh</code>).</p>
</td></tr>
<tr><td><code id="lssVarReg_+3A_knots.l">knots.l</code></td>
<td>
<p>Integer indicating the number of internal knots to be fit in the location model. Default is '2'. (Note that the knots are placed equidistantly over x.)</p>
</td></tr>
<tr><td><code id="lssVarReg_+3A_knots.sc">knots.sc</code></td>
<td>
<p>Integer indicating the number of internal knots to be fit in the scale^2 model. Default is '2'. (Note that the knots are placed equidistantly over x.)</p>
</td></tr>
<tr><td><code id="lssVarReg_+3A_knots.sh">knots.sh</code></td>
<td>
<p>Integer indicating the number of internal knots to be fit in the shape model. Default is '2'. (Note that the knots are placed equidistantly over x.)</p>
</td></tr>
<tr><td><code id="lssVarReg_+3A_degree">degree</code></td>
<td>
<p>Integer to indicate the degree of the splines fit in the location and scale.  Default is '2'.</p>
</td></tr>
<tr><td><code id="lssVarReg_+3A_mono.scale">mono.scale</code></td>
<td>
<p>Text to indicate whether the scale2 model is monotonic. Default is <code>"none"</code> (no monotonic constraints). Options are <code>"inc"</code> for increasing or <code>"dec"</code> for decreasing. If this is chosen, the appropriate <code>para.space</code> is set autopmatically (<code>"positive"</code> for <code>inc</code>, <code>"negative"</code> for <code>dec</code>).</p>
</td></tr>
<tr><td><code id="lssVarReg_+3A_para.space">para.space</code></td>
<td>
<p>Text to indicate the parameter space to search for scale2 parameter estimates. <code>"positive"</code> means only search positive parameter space, <code>"negative"</code> means search only negative parameter space and <code>"all"</code> means search all parameter spaces. Default is <code>all</code>.</p>
</td></tr>
<tr><td><code id="lssVarReg_+3A_location.init">location.init</code></td>
<td>
<p>Vector of initial parameter estimates for the location model. Defaults to vector of 1's of appropriate length.</p>
</td></tr>
<tr><td><code id="lssVarReg_+3A_scale2.init">scale2.init</code></td>
<td>
<p>Vector of initial parameter estimates for the scale^2 model. Defaults to vector of 1's of appropriate length.</p>
</td></tr>
<tr><td><code id="lssVarReg_+3A_shape.init">shape.init</code></td>
<td>
<p>Vector of initial parameter estimates for the shape model. Defaults to vector of 1's of appropriate length.</p>
</td></tr>
<tr><td><code id="lssVarReg_+3A_int.maxit">int.maxit</code></td>
<td>
<p>Integer of maximum iterations for the internal location and scale EM algorithm. Default is 1000 iterations.</p>
</td></tr>
<tr><td><code id="lssVarReg_+3A_print.it">print.it</code></td>
<td>
<p>Logical for printing progress of estimates through each iteration. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="lssVarReg_+3A_control">control</code></td>
<td>
<p>List of control parameters for the algorithm. See <code><a href="#topic+VarReg.control">VarReg.control</a></code>.</p>
</td></tr>
<tr><td><code id="lssVarReg_+3A_...">...</code></td>
<td>
<p>arguments to be used to form the default control argument if it is not supplied
directly</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>lssVarReg</code> returns an object of class <code>"lssVarReg"</code>, which inherits most from class
<code>"VarReg"</code>. This object of class <code>lssVarReg</code> is a list of the following components:
</p>

<ul>
<li> <p><code>modeltype</code>: Text indicating the model that was fit, always &quot;LSS model&quot;.
</p>
</li>
<li> <p><code>locationmodel</code>, <code>scale2model</code>, <code>shapemodel</code>, <code>knots.l</code>, <code>knots.sc</code>,
<code>knots.sh</code>, <code>degree</code>,<code>mono.scale</code> : Returning the input variables as described above
</p>
</li>
<li><p><code>converged</code>: Logical argument indicating if convergence occurred.
</p>
</li>
<li><p><code>iterations</code>: Total iterations performed of the main algorithm (not including the
internal EM algorithm).
</p>
</li>
<li><p><code>reldiff</code>: the positive convergence tolerance that occured at the final iteration.
</p>
</li>
<li><p><code>loglik</code>: Numeric variable of the maximised log-likelihood.
</p>
</li>
<li><p><code>aic.c</code>: Akaike information criterion corrected for small samples
</p>
</li>
<li><p><code>aic</code>: Akaike information criterion
</p>
</li>
<li><p><code>bic</code>: Bayesian information criterion
</p>
</li>
<li><p><code>hqc</code>: Hannan-Quinn information criterion
</p>
</li>
<li><p><code>location</code>: Vector of the maximum likelihood estimates of the location parameters.
</p>
</li>
<li><p><code>scale2</code>: Vector of the maximum likelihood estimates of the scale (squared) parameters.
</p>
</li>
<li><p><code>shape</code>: Vector of the maximum likelihood estimates of the shape parameters.
</p>
</li>
<li><p><code>data</code>: Dataframe containing the variables included in the model.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+VarReg.control">VarReg.control</a></code>  <code><a href="#topic+plotlssVarReg">plotlssVarReg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## run a model with linear mean, linear variance and constant shape (not run):
## lssmodel&lt;-lssVarReg(mcycle$accel, mcycle$times,  locationmodel="linear", scale2model="linear",
## shapemodel="constant",  maxit=10000)
</code></pre>

<hr>
<h2 id='lssVarReg.multi'>Semi parametric location, shape and scale regression</h2><span id='topic+lssVarReg.multi'></span>

<h3>Description</h3>

<p><code>lssVarReg.multi</code> performs a semiparametric location (<code class="reqn">\xi</code> or xi), shape (<code class="reqn">\nu</code> or nu) and scale (<code class="reqn">\omega</code> or omega) regression model. This is designed for multiple covariates that are fit in the location, scale and shape models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lssVarReg.multi(
  y,
  x,
  locationmodel = c("constant", "linear", "semi"),
  location.vars = c(1),
  scale2model = c("constant", "linear", "semi"),
  scale2.vars = c(1),
  shapemodel = c("constant", "linear", "semi"),
  shape.vars = c(1),
  knots.l = NULL,
  knots.sc = NULL,
  knots.sh = NULL,
  degree = 2,
  location.init = NULL,
  scale2.init = NULL,
  shape.init = NULL,
  int.maxit = 1000,
  print.it = FALSE,
  control = list(...),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lssVarReg.multi_+3A_y">y</code></td>
<td>
<p>Vector containing outcome data. Must be no missing data.</p>
</td></tr>
<tr><td><code id="lssVarReg.multi_+3A_x">x</code></td>
<td>
<p>Matrix containing the covariate data, same length as <code>y</code>. Must be no missing data.</p>
</td></tr>
<tr><td><code id="lssVarReg.multi_+3A_locationmodel">locationmodel</code></td>
<td>
<p>Vector to specify the location model to be fit for each covariate. Options: <code>"constant"</code> = constant model (intercept only), <code>"linear"</code> = linear term with x covariate, <code>"semi"</code> = semiparametric spline (specify with <code>knots.l</code>).</p>
</td></tr>
<tr><td><code id="lssVarReg.multi_+3A_location.vars">location.vars</code></td>
<td>
<p>Vector to specify the column(s) in <code>x</code> referring to covariates to be fit in the location model, eg c(1,2) indicates columns 1 and 2 in <code>x</code>. Must be the same length as <code>locationmodel</code> which specifies if they are fit as linear/semi. If semi, use <code>knots.l</code> to specify knots.</p>
</td></tr>
<tr><td><code id="lssVarReg.multi_+3A_scale2model">scale2model</code></td>
<td>
<p>Vector to specify the scale^2 model to be fit for each covariate. Options: <code>"constant"</code> = constant term only, <code>"linear"</code> = linear term with <code>x</code> covariate, <code>"semi"</code> = semiparametric spline (specify with <code>knots.sc</code>)</p>
</td></tr>
<tr><td><code id="lssVarReg.multi_+3A_scale2.vars">scale2.vars</code></td>
<td>
<p>Vector to specify the column(s) in <code>x</code> referring to covariates to be fit in the scale^2 model, eg c(1,2) indicates columns 1 and 2 in <code>x</code>. Must be the same length as <code>scale2model</code> which specifies if they are fit as linear/semi. If semi, use <code>knots.sc</code> to specify knots.</p>
</td></tr>
<tr><td><code id="lssVarReg.multi_+3A_shapemodel">shapemodel</code></td>
<td>
<p>Vector to specify the shape model to be fit for each covariate. Options: <code>"constant"</code> = constant shape model, <code>"linear"</code> = linear term with x covariate, <code>"semi"</code> = semiparametric spline (specify with <code>knots.sh</code>).</p>
</td></tr>
<tr><td><code id="lssVarReg.multi_+3A_shape.vars">shape.vars</code></td>
<td>
<p>Vector to specify the column(s) in <code>x</code> referring to covariates to be fit in the shape model, eg c(1,2) indicates columns 1 and 2 in <code>x</code>. Must be the same length as <code>shapemodel</code> which specifies if they are fit as linear/semi. If semi, use <code>knots.sh</code> to specify knots.</p>
</td></tr>
<tr><td><code id="lssVarReg.multi_+3A_knots.l">knots.l</code></td>
<td>
<p>Vector indicating the number of internal knots to be fit in the location model for each covariate. Default is '2'. (Note that the knots are placed equidistantly over x.)</p>
</td></tr>
<tr><td><code id="lssVarReg.multi_+3A_knots.sc">knots.sc</code></td>
<td>
<p>Vector indicating the number of internal knots to be fit in the scale^2 model for each covariate. Default is '2'. (Note that the knots are placed equidistantly over x.)</p>
</td></tr>
<tr><td><code id="lssVarReg.multi_+3A_knots.sh">knots.sh</code></td>
<td>
<p>Vector indicating the number of internal knots to be fit in the shape model for each covariate. Default is '2'. (Note that the knots are placed equidistantly over x.)</p>
</td></tr>
<tr><td><code id="lssVarReg.multi_+3A_degree">degree</code></td>
<td>
<p>Integer to indicate the degree of the splines fit in the location, scale and shape.  Default is '2'.</p>
</td></tr>
<tr><td><code id="lssVarReg.multi_+3A_location.init">location.init</code></td>
<td>
<p>Vector of initial parameter estimates for the location model. Defaults to vector of 1's of appropriate length.</p>
</td></tr>
<tr><td><code id="lssVarReg.multi_+3A_scale2.init">scale2.init</code></td>
<td>
<p>Vector of initial parameter estimates for the scale^2 model. Defaults to vector of 1's of appropriate length.</p>
</td></tr>
<tr><td><code id="lssVarReg.multi_+3A_shape.init">shape.init</code></td>
<td>
<p>Vector of initial parameter estimates for the shape model. Defaults to vector of 1's of appropriate length.</p>
</td></tr>
<tr><td><code id="lssVarReg.multi_+3A_int.maxit">int.maxit</code></td>
<td>
<p>Integer of maximum iterations for the internal location and scale EM algorithm. Default is 1000 iterations.</p>
</td></tr>
<tr><td><code id="lssVarReg.multi_+3A_print.it">print.it</code></td>
<td>
<p>Logical for printing progress of estimates through each iteration. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="lssVarReg.multi_+3A_control">control</code></td>
<td>
<p>List of control parameters for the algorithm. See <code><a href="#topic+VarReg.control">VarReg.control</a></code>.</p>
</td></tr>
<tr><td><code id="lssVarReg.multi_+3A_...">...</code></td>
<td>
<p>arguments to be used to form the default control argument if it is not supplied
directly</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>lssVarReg</code> returns an object of class <code>"lssVarReg"</code>, which inherits most from class
<code>"VarReg"</code>. This object of class <code>lssVarReg</code> is a list of the following components:
</p>

<ul>
<li> <p><code>modeltype</code>: Text indicating the model that was fit, always &quot;LSS model&quot; for this model.
</p>
</li>
<li> <p><code>locationmodel</code>, <code>scale2model</code>, <code>shapemodel</code>, <code>knots.l</code>, <code>knots.sc</code>,
<code>knots.sh</code>, <code>degree</code>,<code>mono.scale</code> : Returning the input variables as described above
</p>
</li>
<li><p><code>converged</code>: Logical argument indicating if convergence occurred.
</p>
</li>
<li><p><code>iterations</code>: Total iterations performed of the main algorithm (not including the
internal EM algorithm).
</p>
</li>
<li><p><code>reldiff</code>: the positive convergence tolerance that occured at the final iteration.
</p>
</li>
<li><p><code>loglik</code>: Numeric variable of the maximised log-likelihood.
</p>
</li>
<li><p><code>aic.c</code>: Akaike information criterion corrected for small samples
</p>
</li>
<li><p><code>aic</code>: Akaike information criterion
</p>
</li>
<li><p><code>bic</code>: Bayesian information criterion
</p>
</li>
<li><p><code>hqc</code>: Hannan-Quinn information criterion
</p>
</li>
<li><p><code>location</code>: Vector of the maximum likelihood estimates of the location parameters.
</p>
</li>
<li><p><code>scale2</code>: Vector of the maximum likelihood estimates of the scale (squared) parameters.
</p>
</li>
<li><p><code>shape</code>: Vector of the maximum likelihood estimates of the shape parameters.
</p>
</li>
<li><p><code>data</code>: Dataframe containing the variables included in the model.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+VarReg.control">VarReg.control</a></code>  <code><a href="#topic+plotlssVarReg">plotlssVarReg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## not run
## library(palmerpenguins)
## cc&lt;-na.omit(penguins)
## y&lt;-cc$body_mass_g
## x&lt;-as.data.frame(cbind(cc$bill_length_mm, cc$flipper_length_mm,cc$bill_depth_mm))
## colnames(x) &lt;-c("bill length mm", "flipper length mm","bill depth mm")
## model1&lt;-lssVarReg.multi(y, x,
##                         locationmodel="linear", location.vars = 2,
##                         scale2model="constant",
##                         shapemodel=c("linear", "semi"), shape.vars = c(2,3),
##                         knots.sh = 1, int.maxit=10 )
## model1[-21] ## print model
</code></pre>

<hr>
<h2 id='mcycle'>mcycle dataset.</h2><span id='topic+mcycle'></span>

<h3>Description</h3>

<p>A dataset containing 133 observations from a simulated motorcycle accident, used to test crash helmets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcycle
</code></pre>


<h3>Format</h3>

<p>A data frame with 133 rows and 2 variables:
</p>

<dl>
<dt>times</dt><dd><p>in milliseconds from time of impact</p>
</dd>
<dt>accel</dt><dd><p>in g, acceleration of the head</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p>Silverman, B. W. (1985) Some aspects of the spline smoothing approach to non-parametric curve
fitting. Journal of the Royal Statistical Society series B 47, 1-52.
</p>


<h3>References</h3>

<p>Venables, W. N. and Ripley, B. D. (1999) Modern Applied Statistics with S-PLUS. Third Edition.
Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(VarReg)
data(mcycle)
attach(mcycle)
plot(times,accel)
</code></pre>

<hr>
<h2 id='plotlssVarReg'>Plots graphics for a location, scale and shape regression model</h2><span id='topic+plotlssVarReg'></span>

<h3>Description</h3>

<p><code>plotlssVarReg</code> is used to produce graphics for models fit in the <code>VarReg</code> package with the
<code>lssVarReg</code> function. As the skew-normal distribution is used to fit this type of model, the data needs
to be transformed from the SN parameters (location, scale and shape) to the typical mean,
variance and skew parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotlssVarReg(x, knot.lines = FALSE, xlab = "x", ylab = "y")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotlssVarReg_+3A_x">x</code></td>
<td>
<p>Object of class lssVarReg (output from <code><a href="#topic+lssVarReg">lssVarReg</a></code>).</p>
</td></tr>
<tr><td><code id="plotlssVarReg_+3A_knot.lines">knot.lines</code></td>
<td>
<p>Logical to show the knot lines on the graphics (if model is type &quot;semi&quot;).
Default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plotlssVarReg_+3A_xlab">xlab</code></td>
<td>
<p>Label to be placed on the x axis of graphics (covariate)</p>
</td></tr>
<tr><td><code id="plotlssVarReg_+3A_ylab">ylab</code></td>
<td>
<p>Label to be placed on the y axis of graphics (outcome)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A graphic is returned, as well as a dataframe. The graphic returned is a 2 by 2 plot of:
</p>

<ul>
<li><p> the mean function over the x-variable, with or without the knot lines indicated
</p>
</li>
<li><p> the variance function over the x-variable, with or without the knot lines indicated
</p>
</li>
<li><p> the skew function over the x-variable, with or without the knot lines indicated
</p>
</li>
<li><p> a Q-Q plot of the squared residuals from the model, plotted against the Chi-squared (df=1)
distribution. For data from a skew-normal distribution, these residuals should follow a
Chi-squared (df=1) distribution, regardless of skew.
</p>
</li></ul>

<p>The dataframe returned contains the following columns:
</p>

<ul>
<li> <p><code>x</code>: x variable
</p>
</li>
<li> <p><code>y</code>: y variable
</p>
</li>
<li> <p><code>eta</code>:  (<code class="reqn">\eta</code>), the location parameter
</p>
</li>
<li> <p><code>omega</code>: (<code class="reqn">\omega</code>), the scale parameter
</p>
</li>
<li> <p><code>shape</code>: (<code class="reqn">\nu</code>),  the shape parameter
</p>
</li>
<li> <p><code>predicted~mean</code>: (<code class="reqn">\mu</code>), the mean
</p>
</li>
<li> <p><code>predicted~variance</code>: (<code class="reqn">\sigma^2</code>),  the variance
</p>
</li>
<li> <p><code>predicted~skewness</code>: (<code class="reqn">\gamma</code>),  the skew
</p>
</li>
<li> <p><code>stand.res2</code>: the standardised residuals squared.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+lssVarReg">lssVarReg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mcycle)
## not run. LSS model followed by the basic plot command
##lssmodel&lt;-lssVarReg(mcycle$accel, mcycle$times,  locationmodel="linear", scale2model="linear",
##shapemodel="constant", maxit=10000)
##lssplot_out&lt;-plotlssVarReg(lssmodel, xlab="Time in seconds", ylab="Acceleration")
</code></pre>

<hr>
<h2 id='plotVarReg'>Plots graphics for a mean and variance regression model</h2><span id='topic+plotVarReg'></span>

<h3>Description</h3>

<p><code>plotVarReg</code> to produce graphics for models fit in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotVarReg(
  x,
  knot.lines = FALSE,
  ci = FALSE,
  ci.type = c("im", "boot"),
  bootreps = 1000,
  xlab = "x",
  ylab = "y",
  control = list(...),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotVarReg_+3A_x">x</code></td>
<td>
<p>Object of class <code>VarReg</code> (see <code><a href="#topic+semiVarReg">semiVarReg</a></code>).</p>
</td></tr>
<tr><td><code id="plotVarReg_+3A_knot.lines">knot.lines</code></td>
<td>
<p>Logical to indicate if knot lines should be shown on graphics
(if model is type &quot;semi&quot;). Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plotVarReg_+3A_ci">ci</code></td>
<td>
<p>Logical indicate if 95% CI should be shown on the plots. Default is <code>FALSE</code>
and <code>ci.type="im"</code>.</p>
</td></tr>
<tr><td><code id="plotVarReg_+3A_ci.type">ci.type</code></td>
<td>
<p>Text to indicate the type of CI to plot. Either <code>"im"</code> (information matrix) or <code>"boot"</code> (bootstrapped). Default is <code>"im"</code>.</p>
</td></tr>
<tr><td><code id="plotVarReg_+3A_bootreps">bootreps</code></td>
<td>
<p>Integer to indicate the number of bootstrap replications to be performed if <code>ci.type="boot"</code>. Default is <code>1000</code>.</p>
</td></tr>
<tr><td><code id="plotVarReg_+3A_xlab">xlab</code></td>
<td>
<p>Text for the label to be placed on the <code>x</code> axis of graphics (covariate)</p>
</td></tr>
<tr><td><code id="plotVarReg_+3A_ylab">ylab</code></td>
<td>
<p>Text for the label to be placed on the <code>y</code> axis of graphics (outcome)</p>
</td></tr>
<tr><td><code id="plotVarReg_+3A_control">control</code></td>
<td>
<p>list of control parameters to be used in bootstrapping.
See <code><a href="#topic+VarReg.control">VarReg.control</a></code>.</p>
</td></tr>
<tr><td><code id="plotVarReg_+3A_...">...</code></td>
<td>
<p>arguments to be used to form the default control argument if it is not supplied
directly</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a 2x2 plot, with slightly different plots given, depending on the outcome data. For uncensored data, the plots are:
</p>

<ul>
<li><p> the mean function over the <code>x</code>-variable, with or without 95% CI,  and with or
without the knot lines indicated
</p>
</li>
<li><p> the variance function over the <code>x</code>-variable, with or without 95% CI and with or
without the knot lines indicated
</p>
</li>
<li><p> a Q-Q plot of the residuals from the model
</p>
</li>
<li><p> a histogram of the residuals from the model
</p>
</li></ul>

<p>If the outcome data is censored, the last two plots are no longer appropriate.
Given the censored residuals from the model, we can compare the squared standardised residuals
(given in black) with their censoring indicator to the chi-squared distribution with one
degree of freedom (given in red). This is one of the plots given for censored data, and the
other is a plot of the data, coloured by the censoring status. The triangles with the point at
the top are bottom censored and the triangles with the point at the bottom are top censored.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+semiVarReg">semiVarReg</a></code>, <code><a href="#topic+VarReg.control">VarReg.control</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mcycle)
linmodel&lt;-semiVarReg(mcycle$accel, mcycle$times, meanmodel="linear", varmodel="linear",
maxit=10000)
plotVarReg(linmodel)
plotVarReg(linmodel, ci=TRUE, ci.type="im", ylab="Range", xlab="Time in seconds")
##not run
##plotVarReg(linmodel, ci=TRUE, ci.type="boot", bootreps=10,ylab="Acceleration",
##xlab="Time in seconds")

##not run
##semimodel&lt;-semiVarReg(mcycle$accel, mcycle$times, meanmodel="semi", varmodel="semi",
##knots.m=4, knots.v=2, maxit=10000)
##plotVarReg(semimodel, ci=TRUE, ci.type="boot",bootreps=10,ylab="Acceleration",
##xlab="Time in seconds", maxit=10000)
</code></pre>

<hr>
<h2 id='searchVarReg'>Searches for best semi parametric mean and variance regression model</h2><span id='topic+searchVarReg'></span>

<h3>Description</h3>

<p><code>searchVarReg</code> performs multiple semi-parametric mean and variance regression models for a covariate of interest, in order to search for the optimal number of knots. The best model is chosen based on the information criterion of preference (<code>"selection"</code>). At the moment, this is only designed for a single covariate that is fit in both the mean and variance models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>searchVarReg(
  y,
  x,
  cens.ind = NULL,
  maxknots.m = 3,
  maxknots.v = 3,
  degree = 2,
  mono.var = c("none", "inc", "dec"),
  selection = c("AIC", "AICc", "HQC", "BIC"),
  print.it = FALSE,
  control = list(...),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="searchVarReg_+3A_y">y</code></td>
<td>
<p>Vector containing outcome data. Must be no missing data and any censored values must
be set to the limits of detection.</p>
</td></tr>
<tr><td><code id="searchVarReg_+3A_x">x</code></td>
<td>
<p>Vector containing the covariate data. Must be no missing data and same length as <code>y</code>.</p>
</td></tr>
<tr><td><code id="searchVarReg_+3A_cens.ind">cens.ind</code></td>
<td>
<p>Vector containing the censoring indicator, if applicable. There must be no missing
data contained in the vector and this vector should be the same length as <code>y</code>.
<code>"0"</code> values indicate uncensored data, <code>"1"</code> indicates right, or upper, censoring and
<code>"-1"</code> indicates left, or lower, censoring. The default is <code>NULL</code> which indicates there
is no censored data.</p>
</td></tr>
<tr><td><code id="searchVarReg_+3A_maxknots.m">maxknots.m</code></td>
<td>
<p>Integer indicating the maximum number of internal knots to be fit in the mean model. Default is <code>3</code>. (Note that the knots are placed equidistantly over x.)</p>
</td></tr>
<tr><td><code id="searchVarReg_+3A_maxknots.v">maxknots.v</code></td>
<td>
<p>Integer indicating the maximum number of internal knots to be fit in the variance model. Default is <code>3</code>. (Note that the knots are placed equidistantly over x.)</p>
</td></tr>
<tr><td><code id="searchVarReg_+3A_degree">degree</code></td>
<td>
<p>The degree of the splines fit in the mean and variance. Default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="searchVarReg_+3A_mono.var">mono.var</code></td>
<td>
<p>Text to indicate whether the variance model is monotonic (only applied to 'linear' or
semi-parametric variance models). Default is &quot;<code>none</code>&quot; (no monotonic constraints). Options are
&quot;<code>inc</code>&quot; for increasing or &quot;<code>dec</code>&quot; for decreasing. If the variance model is linear, the
parameter space is constrained (positive for increasing and negative for decreasing). For
semi-parametric variance models, the appropriate monotonic B splines are fit in the
semi-parametric variance model.</p>
</td></tr>
<tr><td><code id="searchVarReg_+3A_selection">selection</code></td>
<td>
<p>Text to indicate which information criteria is to be used for the selection of the
best model. Choices are &quot;<code>AIC</code>&quot;, &quot;<code>AICc</code>&quot;, &quot;<code>BIC</code>&quot; and &quot;<code>HQC</code>&quot;.
Default is &quot;<code>AIC</code>&quot;.</p>
</td></tr>
<tr><td><code id="searchVarReg_+3A_print.it">print.it</code></td>
<td>
<p>Logical to indicate whether to print progress from each model as the models are
performed. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="searchVarReg_+3A_control">control</code></td>
<td>
<p>list of control parameters. See <code><a href="#topic+VarReg.control">VarReg.control</a></code>.</p>
</td></tr>
<tr><td><code id="searchVarReg_+3A_...">...</code></td>
<td>
<p>arguments to be used to form the default control argument if it is not supplied
directly</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A matrix of models are performed, of increasing complexity. Mean models start at a zero mean
model, then constant mean, linear, 0 internal knots, etc, up to a maximum internal knots as specified
in <code>maxknots.m</code>. Variance models start at constant variance, linear variance, 0 internal knots,
etc, up to max internal knots as specified in <code>maxknots.v</code>.
</p>
<p>Note that this function can take some time to run, due to the number of models to be fit.
A window will appear on windows based systems to show a progress bar for the function.
</p>


<h3>Value</h3>

<p><code>searchVarReg</code> returns an list, with the following components:
</p>

<ul>
<li> <p><code>ll</code>: a dataframe of the log-likelihoods from each of the models that have been fit.
</p>
</li>
<li> <p><code>AIC</code>: a dataframe of the AIC from each of the models that have been fit. The parameters
fit in the mean model are given in the columns, and the parameters in the variance are given
in the rows.
</p>
</li>
<li> <p><code>AICc</code>: a dataframe of the AIC-c from each of the models that have been fit.
</p>
</li>
<li> <p><code>BIC</code>: a dataframe of the BIC from each of the models that have been fit.
</p>
</li>
<li> <p><code>HQC</code>: a dataframe of the HQC from each of the models that have been fit.
</p>
</li>
<li> <p><code>best.model</code>: an object of class <code>VarReg</code> (see <code><a href="#topic+semiVarReg">semiVarReg</a></code>)
containing the output from the optimal model (that model within the specified models in
the mean and variance with the lowest information criterion according to the criterion selected).
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+semiVarReg">semiVarReg</a></code>, <code><a href="#topic+VarReg.control">VarReg.control</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mcycle)
### not run
### find&lt;-searchVarReg(mcycle$accel, mcycle$times, maxknots.v=3, maxknots.m=3,
### selection="HQC", maxit=10000)
</code></pre>

<hr>
<h2 id='semiVarReg'>Semi parametric mean and variance regression</h2><span id='topic+semiVarReg'></span>

<h3>Description</h3>

<p><code>semiVarReg</code> performs semi-parametric mean and variance regression models. Currently, this is
only designed for a single covariate that is fit in the mean and variance models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semiVarReg(
  y,
  x,
  cens.ind = NULL,
  meanmodel = c("zero", "constant", "linear", "semi"),
  mean.intercept = TRUE,
  varmodel = c("constant", "linear", "semi"),
  knots.m = 2,
  knots.v = 2,
  degree = 2,
  mono.var = c("none", "inc", "dec"),
  para.space = c("all", "positive", "negative"),
  control = list(...),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semiVarReg_+3A_y">y</code></td>
<td>
<p>Vector containing outcome data. Must be no missing data and any censored values must
be set to the limits of detection.</p>
</td></tr>
<tr><td><code id="semiVarReg_+3A_x">x</code></td>
<td>
<p>Vector containing the covariate data. Must be no missing data and same length as <code>y</code>.</p>
</td></tr>
<tr><td><code id="semiVarReg_+3A_cens.ind">cens.ind</code></td>
<td>
<p>Vector containing the censoring indicator, if applicable. There must be no missing
data contained in the vector and this vector should be the same length as <code>y</code>.
<code>"0"</code> values indicate uncensored data, <code>"1"</code> indicates right, or upper, censoring and
<code>"-1"</code> indicates left, or lower, censoring. The default is <code>NULL</code> which indicates there
is no censored data.</p>
</td></tr>
<tr><td><code id="semiVarReg_+3A_meanmodel">meanmodel</code></td>
<td>
<p>Text to specify the mean model to be fit to the data. The possible inputs are
<code>"zero"</code>, <code>"constant"</code>, <code>"linear"</code> or <code>"semi"</code>. <code>"semi"</code>
indicates a semi-parametric spline model, with the number of internal knots specified in
<code>knots.m</code>.</p>
</td></tr>
<tr><td><code id="semiVarReg_+3A_mean.intercept">mean.intercept</code></td>
<td>
<p>Logical argument  to indicate if the mean model is to include an intercept
term. This option is only available in the censored mean model, and the default=<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="semiVarReg_+3A_varmodel">varmodel</code></td>
<td>
<p>Text to specify the variance model to be fit to the data. The possible inputs are
<code>"constant"</code>, <code>"linear"</code> or <code>"semi"</code>. <code>"semi"</code> indicates a semi-parametric
B-spline model, with the number of internal knots specified in <code>knots.v</code>.</p>
</td></tr>
<tr><td><code id="semiVarReg_+3A_knots.m">knots.m</code></td>
<td>
<p>Integer indicating the number of internal knots to be fit in the semi-parametric
mean model. Knots are placed equidistantly over the covariate. The default value is <code>2</code>.</p>
</td></tr>
<tr><td><code id="semiVarReg_+3A_knots.v">knots.v</code></td>
<td>
<p>Integer indicating the number of internal knots to be fit in the semi-parametric
variance model. Knots are placed equidistantly over the covariate. The default value is <code>2</code>.</p>
</td></tr>
<tr><td><code id="semiVarReg_+3A_degree">degree</code></td>
<td>
<p>Integer indicating the degree of the splines fit in the mean and the variance models.
The default value is <code>2</code>.</p>
</td></tr>
<tr><td><code id="semiVarReg_+3A_mono.var">mono.var</code></td>
<td>
<p>Text to indicate whether the variance model is monotonic. Note that this is not
available for the <code>"constant"</code> variance model. Options are <code>"none"</code>, <code>"inc"</code> or
<code>"dec"</code>, with the default=<code>"none"</code>. <code>"Inc"</code> indicates increasing monotonic and
<code>"dec"</code> indicates decreasing monotonic. If the variance model is linear, the parameter
space is constrained (positive for increasing and negative for decreasing). For semi-parametric
variance models, the appropriate monotonic B-splines are fit in the semi-parametric variance model.</p>
</td></tr>
<tr><td><code id="semiVarReg_+3A_para.space">para.space</code></td>
<td>
<p>Text to indicate the parameter space to search for scale2 parameter estimates.
<code>"positive"</code> means only search positive parameter space, <code>"negative"</code> means search only
negative parameter space and <code>"all"</code> means search all parameter spaces. Default is <code>all</code>.</p>
</td></tr>
<tr><td><code id="semiVarReg_+3A_control">control</code></td>
<td>
<p>list of control parameters. See <code><a href="#topic+VarReg.control">VarReg.control</a></code>.</p>
</td></tr>
<tr><td><code id="semiVarReg_+3A_...">...</code></td>
<td>
<p>arguments to be used to form the default control argument if it is not supplied
directly</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>semiVarReg</code> returns an object of class <code>"VarReg"</code> which inherits some components from the class <code>"glm"</code>. This object of class <code>"VarReg"</code> is a list containing the following components:
</p>

<ul>
<li><p><code>modeltype</code>: Text indicating the model that was fit, indicating if a censored approach or an uncensored approach was performed.
</p>
</li>
<li><p><code>knots.m</code>, <code>knots.v</code>, <code>degree</code>, <code>meanmodel</code>, <code>varmodel</code>: Returning the input variables as described above
</p>
</li>
<li><p><code>converged</code>: Logical argument indicating if convergence occurred.
</p>
</li>
<li><p><code>iterations</code>: Total iterations performed.
</p>
</li>
<li><p><code>reldiff</code>: the positive convergence tolerance that occurred at the final iteration.
</p>
</li>
<li><p><code>loglik</code>: Numeric variable of the maximised log-likelihood.
</p>
</li>
<li><p><code>boundary</code>: Logical argument indicating if the MLE is on the boundary of the parameter space.
</p>
</li>
<li><p><code>aic.c</code>: Akaike information criterion corrected for small samples
</p>
</li>
<li><p><code>aic</code>: Akaike information criterion
</p>
</li>
<li><p><code>bic</code>: Bayesian information criterion
</p>
</li>
<li><p><code>hqc</code>: Hannan-Quinn information criterion
</p>
</li>
<li><p><code>mean.ind</code>: Vector of integer(s) indicating the column number(s) in the dataframe
<code>data</code> that were fit in the mean model.
</p>
</li>
<li><p><code>mean</code>: Vector of the maximum likelihood estimates of the mean parameters.
</p>
</li>
<li> <p><code>var.ind</code>: Vector of integer(s) indicating the column(s) in the dataframe
<code>data</code> that were fit in the variance model.
</p>
</li>
<li><p><code>variance</code>: Vector of the maximum likelihood estimates of the variance parameters.
</p>
</li>
<li><p><code>cens.ind</code>: Integer indicating the column in the dataframe <code>data</code> that
corresponds to the censoring indicator.
</p>
</li>
<li><p><code>data</code>: Dataframe containing the variables included in the model.</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(mcycle)
## run a model with linear mean and linear variance:
linmodel&lt;-semiVarReg(mcycle$accel, mcycle$times, meanmodel="linear", varmodel="linear",
 maxit=10000)
## run a model with semi-parametric mean (4 internal knots) and semi-parametric variance (2 knots):
##not run
##semimodel&lt;-semiVarReg(mcycle$accel, mcycle$times, meanmodel="semi", varmodel="semi",
##knots.m=4, knots.v=2, maxit=10000)
## run a model with semi-parametric mean (4 internal knots) and semi-parametric monotonic
## variance (2 knots):
## not run
##semimodel_inc&lt;-semiVarReg(mcycle$accel, mcycle$times, meanmodel="semi", varmodel="semi",
##knots.m=4, knots.v=2, mono.var="inc")
</code></pre>

<hr>
<h2 id='semiVarReg.multi'>Semi parametric mean and variance regression (multivariate)</h2><span id='topic+semiVarReg.multi'></span>

<h3>Description</h3>

<p><code>semiVarReg.multi</code> performs semi-parametric mean and variance regression models. This is
designed for multiple covariates fit in the mean and variance models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semiVarReg.multi(
  y,
  x,
  mean.model = c("zero", "constant", "linear", "semi"),
  mean.vars = c(1),
  knots.m = NULL,
  var.model = c("constant", "linear", "semi"),
  var.vars = c(1),
  knots.v = NULL,
  degree = 2,
  control = list(...),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semiVarReg.multi_+3A_y">y</code></td>
<td>
<p>Vector containing outcome data. Must be no missing data and any censored values must
be set to the limits of detection.</p>
</td></tr>
<tr><td><code id="semiVarReg.multi_+3A_x">x</code></td>
<td>
<p>Matrix containing the covariate data. Must be no missing data and same length as <code>y</code>.</p>
</td></tr>
<tr><td><code id="semiVarReg.multi_+3A_mean.model">mean.model</code></td>
<td>
<p>Vector to specify the mean model to be fit to the data. The possible inputs are
<code>"zero"</code>, <code>"constant"</code>, or a vector to indicate if covariates are to be <code>"linear"</code> or <code>"semi"</code>. <code>"semi"</code>
indicates a semi-parametric spline model, with the number of internal knots specified in
<code>knots.m</code>. If covariates are fit, each covariate needs an indicator of <code>"linear"</code> or <code>"semi"</code>, where <code>mean.vars</code> specifies each covariate.</p>
</td></tr>
<tr><td><code id="semiVarReg.multi_+3A_mean.vars">mean.vars</code></td>
<td>
<p>Vector to specify column(s) in <code>x</code> referring to covariates to be fit in the mean model,
eg c(1,2) indicates columns 1 and 2 in <code>x</code>. Must be the same length as <code>mean.model</code> which specifies
if they are fit as linear/semi. If semi, use <code>knots.m</code> to specify knots.</p>
</td></tr>
<tr><td><code id="semiVarReg.multi_+3A_knots.m">knots.m</code></td>
<td>
<p>Vector indicating the number of internal knots to be fit in each of covariate(s) fit in the semi-parametric
mean model. Must be one entry per <code>"semi"</code> covariate in <code>mean.model</code>. Knots are placed equidistantly over each covariate.</p>
</td></tr>
<tr><td><code id="semiVarReg.multi_+3A_var.model">var.model</code></td>
<td>
<p>Vector to specify the variance model to be fit to the data. The possible inputs are
<code>"constant"</code>, or a vector to indicate if each covariate is to be <code>"linear"</code> or <code>"semi"</code>. <code>"semi"</code> indicates a semi-parametric
B-spline model, with the number of internal knots specified in <code>knots.v</code>.</p>
</td></tr>
<tr><td><code id="semiVarReg.multi_+3A_var.vars">var.vars</code></td>
<td>
<p>Vector to specify column(s) in <code>x</code> referring to covariates to be fit in the variance model,
eg c(1,2) indicates columns 1 and 2 in <code>x</code>. Must be the same length as <code>var.model</code> which specifies
if they are fit as linear/semi. If semi, use <code>knots.v</code> to specify knots.</p>
</td></tr>
<tr><td><code id="semiVarReg.multi_+3A_knots.v">knots.v</code></td>
<td>
<p>Vector indicating the number of internal knots to be fit in the semi-parametric
variance model. Knots are placed equidistantly over the covariate.</p>
</td></tr>
<tr><td><code id="semiVarReg.multi_+3A_degree">degree</code></td>
<td>
<p>Integer indicating the degree of the splines fit in the mean and the variance models.
The default value is <code>2</code>.</p>
</td></tr>
<tr><td><code id="semiVarReg.multi_+3A_control">control</code></td>
<td>
<p>list of control parameters. See <code><a href="#topic+VarReg.control">VarReg.control</a></code>.</p>
</td></tr>
<tr><td><code id="semiVarReg.multi_+3A_...">...</code></td>
<td>
<p>arguments to be used to form the default control argument if it is not supplied
directly</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>semiVarReg.multi</code> returns an object of class <code>"VarReg"</code> which inherits some components from the class <code>"glm"</code>. This object of class <code>"VarReg"</code> is a list containing the following components:
</p>

<ul>
<li><p><code>modeltype</code>: Text indicating the model that was fit, indicating an uncensored approach was performed.
</p>
</li>
<li><p><code>knots.m</code>, <code>knots.v</code>, <code>degree</code>, <code>meanmodel</code>, <code>varmodel</code>: Returning the input variables as described above
</p>
</li>
<li><p><code>converged</code>: Logical argument indicating if convergence occurred.
</p>
</li>
<li><p><code>iterations</code>: Total iterations performed.
</p>
</li>
<li><p><code>reldiff</code>: the positive convergence tolerance that occurred at the final iteration.
</p>
</li>
<li><p><code>loglik</code>: Numeric variable of the maximised log-likelihood.
</p>
</li>
<li><p><code>boundary</code>: Logical argument indicating if the MLE is on the boundary of the parameter space.
</p>
</li>
<li><p><code>aic.c</code>: Akaike information criterion corrected for small samples
</p>
</li>
<li><p><code>aic</code>: Akaike information criterion
</p>
</li>
<li><p><code>bic</code>: Bayesian information criterion
</p>
</li>
<li><p><code>hqc</code>: Hannan-Quinn information criterion
</p>
</li>
<li><p><code>mean.ind</code>: Vector of integer(s) indicating the column number(s) in the dataframe
<code>data</code> that were fit in the mean model.
</p>
</li>
<li><p><code>mean</code>: Vector of the maximum likelihood estimates of the mean parameters.
</p>
</li>
<li> <p><code>var.ind</code>: Vector of integer(s) indicating the column(s) in the dataframe
<code>data</code> that were fit in the variance model.
</p>
</li>
<li><p><code>variance</code>: Vector of the maximum likelihood estimates of the variance parameters.
</p>
</li>
<li><p><code>data</code>: Dataframe containing the variables included in the model.</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(mcycle)
## run a model with linear mean and linear variance:
linmodel&lt;-semiVarReg.multi(mcycle$accel, x=mcycle, mean.model="linear",mean.vars=2,
var.model="linear", var.vars=2,  maxit=10000)
## run a model with semi-parametric mean (4 internal knots) and semi-parametric variance (2 knots):
##not run
##semimodel&lt;-semiVarReg.multi(mcycle$accel, x=mcycle, meanmodel="semi",mean.vars=2, varmodel="semi",
##var.vars=2,knots.m=4, knots.v=2, maxit=10000)
</code></pre>

<hr>
<h2 id='seVarReg'>SE calculations for mean and variance regression models</h2><span id='topic+seVarReg'></span>

<h3>Description</h3>

<p><code>seVarReg</code> calculates SE for an object of class <code>VarReg</code>. If the result is not on a
boundary, the Fishers Information matrix SE are given. The bootstrapped 95% CI can also be
calculated. Designed to be called by the plot function <code>plotVarReg</code>, rather than run by a user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seVarReg(
  x,
  boot = FALSE,
  bootreps = 1000,
  vector.mean = x$data[, 2],
  vector.variance = x$data[, 2],
  control = list(...),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seVarReg_+3A_x">x</code></td>
<td>
<p>Object of class <code>VarReg</code> to determin the SE (eg. result from <code><a href="#topic+semiVarReg">semiVarReg</a></code>).</p>
</td></tr>
<tr><td><code id="seVarReg_+3A_boot">boot</code></td>
<td>
<p>Logical to indicate if bootstrapped CI should be calculated. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="seVarReg_+3A_bootreps">bootreps</code></td>
<td>
<p>Number of bootstraps to be performed if <code>boot=TRUE</code>. Default is <code>1000</code>.</p>
</td></tr>
<tr><td><code id="seVarReg_+3A_vector.mean">vector.mean</code></td>
<td>
<p>Vector of <code>x</code> values for which the SE of the mean is to be calculated.
Default is the <code>x</code> covariate from the model.</p>
</td></tr>
<tr><td><code id="seVarReg_+3A_vector.variance">vector.variance</code></td>
<td>
<p>Vector of <code>x</code> values for which the SE of the variance is to be calculated.
Default is the actual <code>x</code> covariate from the model.</p>
</td></tr>
<tr><td><code id="seVarReg_+3A_control">control</code></td>
<td>
<p>List of control parameters for the bootstrapped models.
See <code><a href="#topic+VarReg.control">VarReg.control</a></code>.</p>
</td></tr>
<tr><td><code id="seVarReg_+3A_...">...</code></td>
<td>
<p>arguments to be used to form the default control argument if it is not supplied
directly</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result is a list of results. This includes:
</p>

<ul>
<li> <p><code>mean.est</code>: dataframe of overall results from the mean model, including parameter estimates
from the model, SEs from information matrix (if <code>boundary=FALSE</code>) and if specified, the SE
from bootstrapping with the bootstrapped 95% CI.
</p>
</li>
<li> <p><code>variance.est</code>: dataframe of overall results from the variance model, including parameter
estimates from the model, SEs from information matrix (if <code>boundary=FALSE</code>) and if specified,
the SE from bootstrapping with the bootstrapped 95% CI.
</p>
</li>
<li> <p><code>mean.im</code>: dataframe of the expected information matrices for the mean (as appropriate)
</p>
</li>
<li> <p><code>variance.im</code>: dataframe of the expected information matrices for the variance
(as appropriate)
</p>
</li>
<li> <p><code>mean.outputs</code>: dataframe with complete output for mean graphics. Includes the
<code>vector.mean</code> as input, and the mean vector (<code>mean.mean</code>) and the SE vector
<code>mean.se.im</code>, and bootstrapping outputs as appropriate.
</p>
</li>
<li> <p><code>variance.outputs</code>: dataframe with complete output for variance graphics. Includes the
<code>vector.variance</code> as input, and the mean vector (<code>var.mean</code>) and the SE vector
<code>var.se.im</code>, and bootstrapping outputs as appropriate.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+semiVarReg">semiVarReg</a></code>, <code><a href="#topic+VarReg.control">VarReg.control</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mcycle)
##Fit model with range as a covariate in the mean and the variance model
semimodel&lt;-semiVarReg(mcycle$accel, mcycle$times, meanmodel="semi", varmodel="linear",
knots.m=4, maxit=10000)
##Calculate SE
se1&lt;-seVarReg(semimodel, boot=FALSE)
##not run: with bootstrapping
##se2&lt;-seVarReg(semimodel, boot=TRUE, bootreps=10)
##not run: calculate mean and SE for a given sequence
##test.seq&lt;-seq(min(mcycle$times), max(mcycle$times),
##by=((max(mcycle$times)-min(mcycle$times))/999))
##se2&lt;-seVarReg(semimodel, boot=TRUE, bootreps=10, vector.mean=test.seq)
</code></pre>

<hr>
<h2 id='VarReg.control'>Auxillary for controlling VarReg fitting</h2><span id='topic+VarReg.control'></span>

<h3>Description</h3>

<p>Use <code>VarReg.control</code> to determine parameters for the fitting of <code><a href="#topic+semiVarReg">semiVarReg</a></code>. Typically only used internally within functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VarReg.control(bound.tol = 1e-05, epsilon = 1e-06, maxit = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VarReg.control_+3A_bound.tol">bound.tol</code></td>
<td>
<p>Positive tolerance for specifying the interior of the parameter space. This allows the algorithm to terminate early if an interior maximum is found. If set to <code>bound.tol=Inf</code>, no early termination is attempted.</p>
</td></tr>
<tr><td><code id="VarReg.control_+3A_epsilon">epsilon</code></td>
<td>
<p>Positive convergence tolerance. If <code class="reqn">\theta</code> is a vector of estimates, convergence is declared when <code class="reqn">\sqrt{(\sum (\theta_{old} - \theta_{new})^2)}/ \sqrt{\sum (\theta_{old})^2} </code>. This should be smaller than <code>bound.tol</code>.</p>
</td></tr>
<tr><td><code id="VarReg.control_+3A_maxit">maxit</code></td>
<td>
<p>integer giving the maximum number of EM algorithm iterations for a given parameterisation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is used similarly to <code><a href="stats.html#topic+glm.control">glm.control</a></code>. If required, it may be internally passed to another function.
</p>


<h3>Value</h3>

<p>A list of the three components: <code>bound.tol</code>, <code>epsilon</code> and <code>maxit</code> .
</p>

<hr>
<h2 id='vcf'>vcf dataset.</h2><span id='topic+vcf'></span>

<h3>Description</h3>

<p>A dataset containing 100 observations of mean velocity of circumferential fibre shortening (vcf), made by long axis and short axis echocardiography.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcf
</code></pre>


<h3>Format</h3>

<p>A data frame with 133 rows and 3 variables:
</p>

<dl>
<dt>pid</dt><dd><p>patient identifier</p>
</dd>
<dt>vcflong</dt><dd><p>vcf measurement from long axis</p>
</dd>
<dt>vcfshort</dt><dd><p>vcf measurement from short axis</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p>Data from Bland JM, Altman DG. (1986) Statistical methods for assessing agreement between two methods of clinical measurement. Lancet i, 307-310. (Supplied by Paul D'Arbela)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(VarReg)
data(vcf)
attach(vcf)
plot(rowMeans(vcf[-1]),vcf$vcflong-vcf$vcfshort)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
