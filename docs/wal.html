<!DOCTYPE html><html lang="en"><head><title>Help for package wal</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {wal}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#apply.palette.to.rawdata'><p>Apply a palette to index data to create a 2D image.</p></a></li>
<li><a href='#check.palette'><p>Check palette, stop on invalid data.</p></a></li>
<li><a href='#closest.color.from.palette'><p>Find closest color from palette for each RGB color.</p></a></li>
<li><a href='#expand.rawdata.to.mipmaps'><p>Given the pixel data for the largest image, generate the full data for all mipmaps.</p></a></li>
<li><a href='#get.mipmap.data.lengths'><p>Compute length of mipmaps in bytes from width and height of largest image (mipmap0).</p></a></li>
<li><a href='#get.mipmap.data.offsets'><p>Get mipmap offsets for WAL header, based on mipmap sizes and start offset.</p></a></li>
<li><a href='#get.wadentry.type.strings'><p>Translate wad directory entry types from the integer to the string representation.</p></a></li>
<li><a href='#get.wal.mipmap.data'><p>Retrieve raw data for given mipmap level from WAL instance.</p></a></li>
<li><a href='#get.wal.mipmap.heights'><p>Compute widths of the 4 mipimap levels from base width.</p></a></li>
<li><a href='#get.wal.mipmap.widths'><p>Compute widths of the 4 mipimap levels from base width.</p></a></li>
<li><a href='#half.image'><p>Reduce image size by 2 along both axes by dropping pixels.</p></a></li>
<li><a href='#img.to.wal'><p>Convert image to WAL instance.</p></a></li>
<li><a href='#is.quakemodel'><p>Check whether object is a Quake 1 or 2 alias model.</p></a></li>
<li><a href='#is.quakemodel_md2'><p>Check whether object is Quake 2 MD2 model</p></a></li>
<li><a href='#is.quakemodel_mdl'><p>Check whether object is Quake 1 MDL model</p></a></li>
<li><a href='#lookup.q1.normals'><p>Lookup Quake I normals by index.</p></a></li>
<li><a href='#pak.extract'><p>Extract PAK contents into existing directory.</p></a></li>
<li><a href='#pal_q1'><p>Get Q1 palette.</p></a></li>
<li><a href='#pal_q2'><p>Get Q2 palette.</p></a></li>
<li><a href='#plot.wal'><p>S3 plot function for wal image.</p></a></li>
<li><a href='#plotwal.mipmap'><p>Plot a mipmap level from a WAL image.</p></a></li>
<li><a href='#plotwal.rawdata'><p>Plot raw pixel index data as image.</p></a></li>
<li><a href='#predefined.md2.normals'><p>Predefined MD2 normals from Quake 2.</p></a></li>
<li><a href='#predefined.mdl.normals'><p>Return list of pre-defined Quake I normals.</p></a></li>
<li><a href='#print.wad'><p>S3 print function for WAD</p></a></li>
<li><a href='#qarchive.extract'><p>Extract any of the supported Quake archives.</p></a></li>
<li><a href='#qarchive.type.from.filename'><p>Determine archive type from file name extension.</p></a></li>
<li><a href='#quakemodel.to.fs.surface'><p>Convert Quake Model to 'fs.surface' instance.</p></a></li>
<li><a href='#read.lmp'><p>Read binary lump, or 'lmp' files.</p></a></li>
<li><a href='#read.pak'><p>Read Quake PAK archive.</p></a></li>
<li><a href='#read.quake.md2'><p>Read Quake II model in MD2 format.</p></a></li>
<li><a href='#read.quake.mdl'><p>Read Quake model in MDL format.</p></a></li>
<li><a href='#read.quake1miptex'><p>Read a Quake mipmap texture from a WAD2 file.</p></a></li>
<li><a href='#read.wad'><p>Read Quake WAD file.</p></a></li>
<li><a href='#read.wal'><p>Read bitmap file in WAL format.</p></a></li>
<li><a href='#readWAL'><p>Read bitmap image in WAL format, returning image data only.</p></a></li>
<li><a href='#save.filepart'><p>Read part of binary file and save as new file.</p></a></li>
<li><a href='#unpack.vertex.coords'><p>Unpack vertex coords from Q1 0-255 representation.</p></a></li>
<li><a href='#wad_dir.fileext.mapping'><p>Get file extensions for WAD dir entry type strings.</p></a></li>
<li><a href='#wad_dir.types.int'><p>Get integers representing WAD dir entry types.</p></a></li>
<li><a href='#wad_dir.types.string'><p>Get strings describing WAD dir entry types.</p></a></li>
<li><a href='#wad.contents'><p>List WAD file contents.</p></a></li>
<li><a href='#wad.extract'><p>Extract WAD contents into existing directory.</p></a></li>
<li><a href='#wad.texname.clean'><p>Replace special chars in texture names to turn it into a valid filename.</p></a></li>
<li><a href='#wal.export.to.jpeg'><p>Export wal instance to JPEG format image file.</p></a></li>
<li><a href='#wal.export.to.png'><p>Export wal instance to PNG format image file.</p></a></li>
<li><a href='#wal.template'><p>Generate a WAL structure template.</p></a></li>
<li><a href='#writeWAL'><p>Write WAL instance to bitmap file in WAL format.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Read and Write 'wal' Bitmap Image Files and Other 'Quake' Assets</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tim Schäfer &lt;ts+code@rcmd.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Read 'Quake' assets including bitmap images and textures in 'wal' file format. This package also provides support for extracting these assets from 'WAD' and 'PAK' file archives. It can also read models in 'MDL' and 'MD2' formats.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dfsp-spirit/wal">https://github.com/dfsp-spirit/wal</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dfsp-spirit/wal/issues">https://github.com/dfsp-spirit/wal/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>freesurferformats (&ge; 0.1.12), imager, jpeg, png, spacesXYZ</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 2.1.0),</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-02 17:59:56 UTC; spirit</td>
</tr>
<tr>
<td>Author:</td>
<td>Tim Schäfer <a href="https://orcid.org/0000-0002-3683-8070"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-02 18:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='apply.palette.to.rawdata'>Apply a palette to index data to create a 2D image.</h2><span id='topic+apply.palette.to.rawdata'></span>

<h3>Description</h3>

<p>Apply a palette to index data to create a 2D image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply.palette.to.rawdata(raw_data, apply_palette, img_width, img_height)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply.palette.to.rawdata_+3A_raw_data">raw_data</code></td>
<td>
<p>integer vector of pixel data, each entry represents an index into the palette.</p>
</td></tr>
<tr><td><code id="apply.palette.to.rawdata_+3A_apply_palette">apply_palette</code></td>
<td>
<p>integer matrix, the palette.</p>
</td></tr>
<tr><td><code id="apply.palette.to.rawdata_+3A_img_width">img_width</code></td>
<td>
<p>integer, the width of the image to create.</p>
</td></tr>
<tr><td><code id="apply.palette.to.rawdata_+3A_img_height">img_height</code></td>
<td>
<p>integer, the height of the image to create.</p>
</td></tr>
</table>

<hr>
<h2 id='check.palette'>Check palette, stop on invalid data.</h2><span id='topic+check.palette'></span>

<h3>Description</h3>

<p>Check palette, stop on invalid data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.palette(pal)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check.palette_+3A_pal">pal</code></td>
<td>
<p>a palette, i.e., a 256 x 3 integer matrix, with values in range 0..255L.</p>
</td></tr>
</table>

<hr>
<h2 id='closest.color.from.palette'>Find closest color from palette for each RGB color.</h2><span id='topic+closest.color.from.palette'></span>

<h3>Description</h3>

<p>Find closest color from a palette for given colors. The similarity method used to define 'closest' is deltaE, and the input RGB colors are transformed to LAB space for the computation, assuming they are given in sRGB space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>closest.color.from.palette(colors_rgb, fixed_palette_rgb)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="closest.color.from.palette_+3A_colors_rgb">colors_rgb</code></td>
<td>
<p>n x 3 integer matrix, the truecolor (arbitrary) input RGB colors for which you want to find the most similar colors included in the fixed palette. Range 0..255.</p>
</td></tr>
<tr><td><code id="closest.color.from.palette_+3A_fixed_palette_rgb">fixed_palette_rgb</code></td>
<td>
<p>the fixed palette, an n x 3 matrix of integers, representing the fixed palette colors in RGB values in range 0..255.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of n integers, the index of the closest color into the palette for each of the <code>colors_rgb</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    colors_rgb = matrix(c(255, 0, 0, 100, 100, 100, 10, 10, 10, 5, 5, 5),
     ncol = 3, byrow = TRUE);
    fixed_palette_rgb = matrix(c(255, 0, 0, 255, 5, 0, 11, 11, 11, 0, 0, 0,
     255, 255, 255), ncol = 3, byrow = TRUE);
    pal_similar_colors = closest.color.from.palette(colors_rgb,
     fixed_palette_rgb);

</code></pre>

<hr>
<h2 id='expand.rawdata.to.mipmaps'>Given the pixel data for the largest image, generate the full data for all mipmaps.</h2><span id='topic+expand.rawdata.to.mipmaps'></span>

<h3>Description</h3>

<p>Given the pixel data for the largest image, generate the full data for all mipmaps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand.rawdata.to.mipmaps(raw_data_mip_level0, width, height, byrow = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expand.rawdata.to.mipmaps_+3A_raw_data_mip_level0">raw_data_mip_level0</code></td>
<td>
<p>integer vector or matrix, the image data for the largest mipmap.</p>
</td></tr>
<tr><td><code id="expand.rawdata.to.mipmaps_+3A_width">width</code></td>
<td>
<p>integer, width of image for mip level 0</p>
</td></tr>
<tr><td><code id="expand.rawdata.to.mipmaps_+3A_height">height</code></td>
<td>
<p>integer, width of image for mip level 0</p>
</td></tr>
</table>

<hr>
<h2 id='get.mipmap.data.lengths'>Compute length of mipmaps in bytes from width and height of largest image (mipmap0).</h2><span id='topic+get.mipmap.data.lengths'></span>

<h3>Description</h3>

<p>Compute length of mipmaps in bytes from width and height of largest image (mipmap0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.mipmap.data.lengths(mm0_width, mm0_height)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.mipmap.data.lengths_+3A_mm0_width">mm0_width</code></td>
<td>
<p>integer, width of mipmap 0</p>
</td></tr>
<tr><td><code id="get.mipmap.data.lengths_+3A_mm0_height">mm0_height</code></td>
<td>
<p>integer, height of mipmap 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector of length 4, the lengths.
</p>

<hr>
<h2 id='get.mipmap.data.offsets'>Get mipmap offsets for WAL header, based on mipmap sizes and start offset.</h2><span id='topic+get.mipmap.data.offsets'></span>

<h3>Description</h3>

<p>Get mipmap offsets for WAL header, based on mipmap sizes and start offset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.mipmap.data.offsets(mm0_width, mm0_height, start_at = 100L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.mipmap.data.offsets_+3A_mm0_width">mm0_width</code></td>
<td>
<p>integer, width of mipmap 0</p>
</td></tr>
<tr><td><code id="get.mipmap.data.offsets_+3A_mm0_height">mm0_height</code></td>
<td>
<p>integer, height of mipmap 0</p>
</td></tr>
<tr><td><code id="get.mipmap.data.offsets_+3A_start_at">start_at</code></td>
<td>
<p>integer, the offset at which the data starts in the file. Must be 100L for WAL format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector of length 4, the offsets.
</p>

<hr>
<h2 id='get.wadentry.type.strings'>Translate wad directory entry types from the integer to the string representation.</h2><span id='topic+get.wadentry.type.strings'></span>

<h3>Description</h3>

<p>Translate wad directory entry types from the integer to the string representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.wadentry.type.strings(wadentry_type_int)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.wadentry.type.strings_+3A_wadentry_type_int">wadentry_type_int</code></td>
<td>
<p>integer, WAD entry type code</p>
</td></tr>
</table>


<h3>Value</h3>

<p>type string
</p>

<hr>
<h2 id='get.wal.mipmap.data'>Retrieve raw data for given mipmap level from WAL instance.</h2><span id='topic+get.wal.mipmap.data'></span>

<h3>Description</h3>

<p>Retrieve raw data for given mipmap level from WAL instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.wal.mipmap.data(wal, mip_level)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.wal.mipmap.data_+3A_wal">wal</code></td>
<td>
<p>a WAL image instance, as returned by <code>read.wal</code>.</p>
</td></tr>
<tr><td><code id="get.wal.mipmap.data_+3A_mip_level">mip_level</code></td>
<td>
<p>integer in range 0..3, the mipmap to plot. Level 0 is the original full-size image, the other ones get smaller and smaller (by factor 2 on each dimension, so 1/4th the size of their predecessor).</p>
</td></tr>
</table>

<hr>
<h2 id='get.wal.mipmap.heights'>Compute widths of the 4 mipimap levels from base width.</h2><span id='topic+get.wal.mipmap.heights'></span>

<h3>Description</h3>

<p>Compute widths of the 4 mipimap levels from base width.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.wal.mipmap.heights(height_mm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.wal.mipmap.heights_+3A_height_mm">height_mm</code></td>
<td>
<p>integer, the base mipmap height.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector of length 4, the mipmap heights.
</p>

<hr>
<h2 id='get.wal.mipmap.widths'>Compute widths of the 4 mipimap levels from base width.</h2><span id='topic+get.wal.mipmap.widths'></span>

<h3>Description</h3>

<p>Compute widths of the 4 mipimap levels from base width.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.wal.mipmap.widths(width_mm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.wal.mipmap.widths_+3A_width_mm">width_mm</code></td>
<td>
<p>integer, the base mipmap width.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector of length 4, the mipmap widths.
</p>

<hr>
<h2 id='half.image'>Reduce image size by 2 along both axes by dropping pixels.</h2><span id='topic+half.image'></span>

<h3>Description</h3>

<p>Reduce image size by 2 along both axes by dropping pixels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>half.image(image_data, byrow = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="half.image_+3A_image_data">image_data</code></td>
<td>
<p>integer matrix, a 1-channel image.</p>
</td></tr>
</table>

<hr>
<h2 id='img.to.wal'>Convert image to WAL instance.</h2><span id='topic+img.to.wal'></span>

<h3>Description</h3>

<p>Convert an input RGB image to a WAL instance, re-mapping its colors to the WAL palette in the process and generating the mipmaps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>img.to.wal(in_image, apply_palette = wal::pal_q2(), wal = wal.template())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="img.to.wal_+3A_in_image">in_image</code></td>
<td>
<p>numeric matrix with 3 dimensions: widt, height, channels. Values must be in range 0..1. This is the image format returned by <code>jpeg::readJPEG</code> and <code>png::readPNG</code>. The image can have arbitrary colors, but the colors in the final WAL image will be limited to the palette. Both the width and height must be multiples of 8. Typical idtech1/2 textures use 32, 64, ..., 512. The reason is the mipmaps.</p>
</td></tr>
<tr><td><code id="img.to.wal_+3A_apply_palette">apply_palette</code></td>
<td>
<p>n x 3 integer matrix, the palette for the WAL image. This is not saved to the wal image, but still required because the colors from the <code>in_image</code> will be adapted to the palette colors (replaced with the most similar ones). If the palette does not cover the colors in the source image well, the resulting WAL image will look bad (dissimilar to the source image).</p>
</td></tr>
<tr><td><code id="img.to.wal_+3A_wal">wal</code></td>
<td>
<p>a wal instance. Note that 1 will be substracted from the data when it is written, as indices are stored 0-based in the file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>wal instance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   wal = img.to.wal(jpeg::readJPEG("~/mytex.jpg"));

## End(Not run)

</code></pre>

<hr>
<h2 id='is.quakemodel'>Check whether object is a Quake 1 or 2 alias model.</h2><span id='topic+is.quakemodel'></span>

<h3>Description</h3>

<p>Check whether object is a Quake 1 or 2 alias model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.quakemodel(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.quakemodel_+3A_x">x</code></td>
<td>
<p>any R object</p>
</td></tr>
</table>

<hr>
<h2 id='is.quakemodel_md2'>Check whether object is Quake 2 MD2 model</h2><span id='topic+is.quakemodel_md2'></span>

<h3>Description</h3>

<p>Check whether object is Quake 2 MD2 model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.quakemodel_md2(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.quakemodel_md2_+3A_x">x</code></td>
<td>
<p>any R object</p>
</td></tr>
</table>

<hr>
<h2 id='is.quakemodel_mdl'>Check whether object is Quake 1 MDL model</h2><span id='topic+is.quakemodel_mdl'></span>

<h3>Description</h3>

<p>Check whether object is Quake 1 MDL model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.quakemodel_mdl(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.quakemodel_mdl_+3A_x">x</code></td>
<td>
<p>any R object</p>
</td></tr>
</table>

<hr>
<h2 id='lookup.q1.normals'>Lookup Quake I normals by index.</h2><span id='topic+lookup.q1.normals'></span>

<h3>Description</h3>

<p>Lookup Quake I normals by index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lookup.q1.normals(normal_indices)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lookup.q1.normals_+3A_normal_indices">normal_indices</code></td>
<td>
<p>integer vector of length n, the normal indices (0-based).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n x 3 matrix of doubles, the normals
</p>

<hr>
<h2 id='pak.extract'>Extract PAK contents into existing directory.</h2><span id='topic+pak.extract'></span>

<h3>Description</h3>

<p>Extract PAK contents into existing directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pak.extract(pak_filepath, outdir = getwd())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pak.extract_+3A_pak_filepath">pak_filepath</code></td>
<td>
<p>character string, path to input PAK file.</p>
</td></tr>
<tr><td><code id="pak.extract_+3A_outdir">outdir</code></td>
<td>
<p>character string, the output directory in which the files should be created. Must be writeable. The sub directories and filenames are derived from the data in the WAD.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>PAK files can contain a directory structure, and new subdirectories will be created under <code>outdir</code> as needed to preserve it.
</p>

<hr>
<h2 id='pal_q1'>Get Q1 palette.</h2><span id='topic+pal_q1'></span>

<h3>Description</h3>

<p>Get Q1 palette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pal_q1()
</code></pre>


<h3>Value</h3>

<p>256 x 3 integer matrix, representing the RGB color values for an index into the palette.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   pal = pal_q1();
   dim(pal);

</code></pre>

<hr>
<h2 id='pal_q2'>Get Q2 palette.</h2><span id='topic+pal_q2'></span>

<h3>Description</h3>

<p>Get Q2 palette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pal_q2()
</code></pre>


<h3>Value</h3>

<p>256 x 3 integer matrix, representing the RGB color values for an index into the palette.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   pal = pal_q2();
   dim(pal);

</code></pre>

<hr>
<h2 id='plot.wal'>S3 plot function for wal image.</h2><span id='topic+plot.wal'></span>

<h3>Description</h3>

<p>S3 plot function for wal image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wal'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.wal_+3A_x">x</code></td>
<td>
<p>a wal instance.</p>
</td></tr>
<tr><td><code id="plot.wal_+3A_...">...</code></td>
<td>
<p>extra args, not used.</p>
</td></tr>
</table>

<hr>
<h2 id='plotwal.mipmap'>Plot a mipmap level from a WAL image.</h2><span id='topic+plotwal.mipmap'></span>

<h3>Description</h3>

<p>Plot a mipmap level from a WAL image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotwal.mipmap(wal, mip_level = 0L, apply_palette = wal::pal_q2())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotwal.mipmap_+3A_wal">wal</code></td>
<td>
<p>a WAL image instance, as returned by <code>read.wal</code>.</p>
</td></tr>
<tr><td><code id="plotwal.mipmap_+3A_mip_level">mip_level</code></td>
<td>
<p>integer in range 0..3, the mipmap to plot. Level 0 is the original full-size image, the other ones get smaller and smaller (by factor 2 on each dimension, so 1/4th the size of their predecessor).</p>
</td></tr>
<tr><td><code id="plotwal.mipmap_+3A_apply_palette">apply_palette</code></td>
<td>
<p>optional 256 x 3 integer matrix, the palette. Must contain values in range 0..255. Pass NULL if you do not want to apply any palette. The resulting <code>wal</code> object will not have an 'image' entry then.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   walf = '~/data/q2_pak0_extracted/textures/e1u2/basic1_7.wal';
   wal = read.wal(walf);
   plotwal.mipmap(wal, mip_level = 3);

## End(Not run)

</code></pre>

<hr>
<h2 id='plotwal.rawdata'>Plot raw pixel index data as image.</h2><span id='topic+plotwal.rawdata'></span>

<h3>Description</h3>

<p>Plot raw pixel index data as image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotwal.rawdata(raw_data, width, height, apply_palette = wal::pal_q2())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotwal.rawdata_+3A_raw_data">raw_data</code></td>
<td>
<p>integer vector in containing width * height values in range 0..255, and optionally additional mipmap data at the end (which will be ignored). The raw image data. Can be a Q2 WAL data,  Q1 miptex data, or anything else.</p>
</td></tr>
<tr><td><code id="plotwal.rawdata_+3A_width">width</code></td>
<td>
<p>positive integer, the image width.</p>
</td></tr>
<tr><td><code id="plotwal.rawdata_+3A_height">height</code></td>
<td>
<p>positive integer, the image height.</p>
</td></tr>
<tr><td><code id="plotwal.rawdata_+3A_apply_palette">apply_palette</code></td>
<td>
<p>optional 256 x 3 integer matrix, the palette. Must contain values in range 0..255. Pass NULL if you do not want to apply any palette. The resulting <code>wal</code> object will not have an 'image' entry then.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Plot the Q1 shambler skin:
mdl = read.quake.mdl("~/data/q1_pak/progs/shambler.mdl");
plotwal.rawdata(mdl$skins$skin_pic, mdl$header$skin_width,
 mdl$header$skin_height, apply_palette = pal_q1());

## End(Not run)

</code></pre>

<hr>
<h2 id='predefined.md2.normals'>Predefined MD2 normals from Quake 2.</h2><span id='topic+predefined.md2.normals'></span>

<h3>Description</h3>

<p>Predefined MD2 normals from Quake 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predefined.md2.normals()
</code></pre>


<h3>Value</h3>

<p>3xn matrix of normals.
</p>

<hr>
<h2 id='predefined.mdl.normals'>Return list of pre-defined Quake I normals.</h2><span id='topic+predefined.mdl.normals'></span>

<h3>Description</h3>

<p>Return list of pre-defined Quake I normals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predefined.mdl.normals()
</code></pre>


<h3>Value</h3>

<p>n x 3 matrix of doubles, the normals. Hardcoded.
</p>

<hr>
<h2 id='print.wad'>S3 print function for WAD</h2><span id='topic+print.wad'></span>

<h3>Description</h3>

<p>S3 print function for WAD
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wad'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.wad_+3A_x">x</code></td>
<td>
<p>wad instance</p>
</td></tr>
<tr><td><code id="print.wad_+3A_...">...</code></td>
<td>
<p>extra arguments, ignored</p>
</td></tr>
</table>

<hr>
<h2 id='qarchive.extract'>Extract any of the supported Quake archives.</h2><span id='topic+qarchive.extract'></span>

<h3>Description</h3>

<p>Extract any of the supported Quake archives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qarchive.extract(filepath, outdir, format = "auto", do_pre_checks = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qarchive.extract_+3A_filepath">filepath</code></td>
<td>
<p>character string, path to existing and readable file in PAK or WAD2 format.</p>
</td></tr>
<tr><td><code id="qarchive.extract_+3A_outdir">outdir</code></td>
<td>
<p>character string, path to an existing and writeable output directory into which to extract the archive.</p>
</td></tr>
<tr><td><code id="qarchive.extract_+3A_format">format</code></td>
<td>
<p>character string, of one 'auto' to detect from filename, 'QARCHIVE_TYPE_WAD' for WAD2, or 'QARCHIVE_TYPE_PAK' for PACK.</p>
</td></tr>
<tr><td><code id="qarchive.extract_+3A_do_pre_checks">do_pre_checks</code></td>
<td>
<p>logical, whether to perform extra sanity checks on the other parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='qarchive.type.from.filename'>Determine archive type from file name extension.</h2><span id='topic+qarchive.type.from.filename'></span>

<h3>Description</h3>

<p>Determine archive type from file name extension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qarchive.type.from.filename(filepath)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qarchive.type.from.filename_+3A_filepath">filepath</code></td>
<td>
<p>character string, path to existing and readable file in PAK or WAD2 format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string, one of 'QARCHIVE_TYPE_WAD' or 'QARCHIVE_TYPE_PAK'.
</p>

<hr>
<h2 id='quakemodel.to.fs.surface'>Convert Quake Model to 'fs.surface' instance.</h2><span id='topic+quakemodel.to.fs.surface'></span>

<h3>Description</h3>

<p>Convert Quake Model to 'fs.surface' instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quakemodel.to.fs.surface(quakemodel, frame_idx = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quakemodel.to.fs.surface_+3A_quakemodel">quakemodel</code></td>
<td>
<p>an instance of <code>quakemodel_mdl</code> or <code>quakemodel_md2</code>.</p>
</td></tr>
<tr><td><code id="quakemodel.to.fs.surface_+3A_frame_idx">frame_idx</code></td>
<td>
<p>integer, the frame to export. Quake models may contain animations made up of several frames. The mesh connectivity is unaltered between frames, but the vertex positions differ.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>fs.surface</code> mesh instance, as used by the <code>freesurferformats</code> package.
</p>

<hr>
<h2 id='read.lmp'>Read binary lump, or 'lmp' files.</h2><span id='topic+read.lmp'></span>

<h3>Description</h3>

<p>Read binary lump, or 'lmp' files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.lmp(filepath, dlength = 768L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.lmp_+3A_filepath">filepath</code></td>
<td>
<p>character string, path to the input file.</p>
</td></tr>
<tr><td><code id="read.lmp_+3A_dlength">dlength</code></td>
<td>
<p>the expected data length, in bytes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of dlength unsigned integers in range 0..255.
</p>

<hr>
<h2 id='read.pak'>Read Quake PAK archive.</h2><span id='topic+read.pak'></span>

<h3>Description</h3>

<p>Read Quake PAK archive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.pak(filepath)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.pak_+3A_filepath">filepath</code></td>
<td>
<p>character string, path to the file including extension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'pak' instance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   pakf = '~/.steam/steam/steamapps/common/Quake/Id1/PAK0.PAK';
   pak = read.pak(pakf);

## End(Not run)

</code></pre>

<hr>
<h2 id='read.quake.md2'>Read Quake II model in MD2 format.</h2><span id='topic+read.quake.md2'></span>

<h3>Description</h3>

<p>Read Quake II model in MD2 format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.quake.md2(filepath, anim = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.quake.md2_+3A_filepath">filepath</code></td>
<td>
<p>character string, the path to the MD2 file</p>
</td></tr>
<tr><td><code id="read.quake.md2_+3A_anim">anim</code></td>
<td>
<p>logical, whether to load the whole animation (if present). Returns a list of models, the animation frames. If FALSE, only the first frame is returned.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Ignore this function, it will be moved to a different package.
</p>

<hr>
<h2 id='read.quake.mdl'>Read Quake model in MDL format.</h2><span id='topic+read.quake.mdl'></span>

<h3>Description</h3>

<p>Read Quake model in MDL format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.quake.mdl(filepath, do_checks = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.quake.mdl_+3A_filepath">filepath</code></td>
<td>
<p>character string, the path to the MDL file</p>
</td></tr>
<tr><td><code id="read.quake.mdl_+3A_do_checks">do_checks</code></td>
<td>
<p>logical, whether to perform some sanity checks on the data and warn on suspicious results.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Ignore this function, it will be moved to a different package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   mdlf = "~/data/q1_pak/progs/quaddama.mdl"
   mdl = read.quake.mdl(mdlf);

## End(Not run)

</code></pre>

<hr>
<h2 id='read.quake1miptex'>Read a Quake mipmap texture from a WAD2 file.</h2><span id='topic+read.quake1miptex'></span>

<h3>Description</h3>

<p>Read a Quake mipmap texture from a WAD2 file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.quake1miptex(filepath, at_offset = 0L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.quake1miptex_+3A_filepath">filepath</code></td>
<td>
<p>character string, path to WAD file.</p>
</td></tr>
<tr><td><code id="read.quake1miptex_+3A_at_offset">at_offset</code></td>
<td>
<p>integer, the index in the WAD file where the texture starts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'qmiptex' instance, its like a wall with shorter name field (16 instead of 32) and some fields (anim_name, flags, contents, value) missing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    qm = read.quake1miptex("~/knave.wad", at_offset = 1317632);
    plotwal.mipmap(qm, apply_palette = pal_q1());

## End(Not run)

</code></pre>

<hr>
<h2 id='read.wad'>Read Quake WAD file.</h2><span id='topic+read.wad'></span>

<h3>Description</h3>

<p>Read Quake WAD file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.wad(filepath)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.wad_+3A_filepath">filepath</code></td>
<td>
<p>character string, path to the file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a wad instance, can be used to extract data or list contents.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   wadf = '~/knave.wad';
   wad = read.wad(wadf);
   wad.contents(wad);

## End(Not run)

</code></pre>

<hr>
<h2 id='read.wal'>Read bitmap file in WAL format.</h2><span id='topic+read.wal'></span>

<h3>Description</h3>

<p>Read bitmap file in WAL format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.wal(filepath, hdr = TRUE, hdr_only = FALSE, apply_palette = wal::pal_q2())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.wal_+3A_filepath">filepath</code></td>
<td>
<p>character string, path to the file including extension</p>
</td></tr>
<tr><td><code id="read.wal_+3A_hdr">hdr</code></td>
<td>
<p>logical, whether to return full list with header</p>
</td></tr>
<tr><td><code id="read.wal_+3A_hdr_only">hdr_only</code></td>
<td>
<p>logical, whether to read only the header</p>
</td></tr>
<tr><td><code id="read.wal_+3A_apply_palette">apply_palette</code></td>
<td>
<p>optional 256 x 3 integer matrix, the palette. Must contain values in range 0..255. Pass NULL if you do not want to apply any palette. The resulting <code>wal</code> object will not have an 'image' entry then.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer pixel matrix, each pixel value is in range 0-255 and refers to an index in a palette. The palette is NOT included in the file, so you will need to define one or get it from elsewhere to see the final image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   walf = '~/data/q2_pak0_extracted/textures/e1u2/basic1_7.wal';
   wal = read.wal(walf);
   plot(wal);

## End(Not run)

</code></pre>

<hr>
<h2 id='readWAL'>Read bitmap image in WAL format, returning image data only.</h2><span id='topic+readWAL'></span>

<h3>Description</h3>

<p>Read a bitmap image in WAL format, and return data in the same format as <code>png::readPNG</code> and <code>jpeg::readJPEG</code> do.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readWAL(filepath, apply_palette = wal::pal_q2())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readWAL_+3A_filepath">filepath</code></td>
<td>
<p>character string, path to the file including extension</p>
</td></tr>
<tr><td><code id="readWAL_+3A_apply_palette">apply_palette</code></td>
<td>
<p>optional 256 x 3 integer matrix, the palette. Must contain values in range 0..255. Pass NULL if you do not want to apply any palette. The resulting <code>wal</code> object will not have an 'image' entry then.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix with dimension width x height x channels, with all color values in range 0..1.
</p>


<h3>See Also</h3>

<p><code>read.wal</code> if you want to read the header and have more control.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   walf = '~/data/q2_pak0_extracted/textures/e1u2/basic1_7.wal';
   wal_image = readWAL(walf);
   dim(wal_image);

## End(Not run)

</code></pre>

<hr>
<h2 id='save.filepart'>Read part of binary file and save as new file.</h2><span id='topic+save.filepart'></span>

<h3>Description</h3>

<p>Read part of binary file and save as new file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save.filepart(infile, read_from, read_len, outfile)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="save.filepart_+3A_infile">infile</code></td>
<td>
<p>for input file, part of it gets read.</p>
</td></tr>
<tr><td><code id="save.filepart_+3A_read_from">read_from</code></td>
<td>
<p>integer, index at which to start reading, from start of file. Used to <code>seek</code> to the position.</p>
</td></tr>
<tr><td><code id="save.filepart_+3A_read_len">read_len</code></td>
<td>
<p>integer, the number of bytes to read.</p>
</td></tr>
<tr><td><code id="save.filepart_+3A_outfile">outfile</code></td>
<td>
<p>character string, the output filename.</p>
</td></tr>
</table>

<hr>
<h2 id='unpack.vertex.coords'>Unpack vertex coords from Q1 0-255 representation.</h2><span id='topic+unpack.vertex.coords'></span>

<h3>Description</h3>

<p>Unpack vertex coords from Q1 0-255 representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpack.vertex.coords(coords_packed, mdl_header)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unpack.vertex.coords_+3A_coords_packed">coords_packed</code></td>
<td>
<p>matrix of n x 3 integers in range 0..255, the packed coords from an MDL file.</p>
</td></tr>
<tr><td><code id="unpack.vertex.coords_+3A_mdl_header">mdl_header</code></td>
<td>
<p>MDL header or named list, only the fields 'header$scale' and 'header$origin' are used.</p>
</td></tr>
</table>

<hr>
<h2 id='wad_dir.fileext.mapping'>Get file extensions for WAD dir entry type strings.</h2><span id='topic+wad_dir.fileext.mapping'></span>

<h3>Description</h3>

<p>Get file extensions for WAD dir entry type strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wad_dir.fileext.mapping()
</code></pre>


<h3>Value</h3>

<p>named list, which maps <code>wad_dir.types.string</code>s to file extensions. Afaik, there are not standard file extensions for these file types, and I made the ones used here up.
</p>


<h3>See Also</h3>

<p>wad_dir.types.string
</p>

<hr>
<h2 id='wad_dir.types.int'>Get integers representing WAD dir entry types.</h2><span id='topic+wad_dir.types.int'></span>

<h3>Description</h3>

<p>Get integers representing WAD dir entry types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wad_dir.types.int()
</code></pre>


<h3>See Also</h3>

<p>wad_dir.types.string
</p>

<hr>
<h2 id='wad_dir.types.string'>Get strings describing WAD dir entry types.</h2><span id='topic+wad_dir.types.string'></span>

<h3>Description</h3>

<p>Get strings describing WAD dir entry types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wad_dir.types.string()
</code></pre>


<h3>See Also</h3>

<p>wad_dir.types.int
</p>

<hr>
<h2 id='wad.contents'>List WAD file contents.</h2><span id='topic+wad.contents'></span>

<h3>Description</h3>

<p>List WAD file contents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wad.contents(wad)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wad.contents_+3A_wad">wad</code></td>
<td>
<p>a wad instance, see <code>read.wad</code>. Alternatively  a character string, which will be interpreted as a filepath to a WAD file that should be loaded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame, info on the files inside the wad.
</p>

<hr>
<h2 id='wad.extract'>Extract WAD contents into existing directory.</h2><span id='topic+wad.extract'></span>

<h3>Description</h3>

<p>Extract WAD contents into existing directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wad.extract(
  wad_filepath,
  outdir = getwd(),
  file_ext_mapping = wad_dir.fileext.mapping()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wad.extract_+3A_wad_filepath">wad_filepath</code></td>
<td>
<p>character string, path to input WAD file.</p>
</td></tr>
<tr><td><code id="wad.extract_+3A_outdir">outdir</code></td>
<td>
<p>character string, the output directory in which the files should be created. The filenames are derived from the data in the WAD.</p>
</td></tr>
<tr><td><code id="wad.extract_+3A_file_ext_mapping">file_ext_mapping</code></td>
<td>
<p>named list, with keys corresponding to the type names and values are file extensions, including the dot, to use for them.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>One can read extracted textures with <code>read.quake1miptex()</code>.
</p>

<hr>
<h2 id='wad.texname.clean'>Replace special chars in texture names to turn it into a valid filename.</h2><span id='topic+wad.texname.clean'></span>

<h3>Description</h3>

<p>Replace special chars in texture names to turn it into a valid filename.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wad.texname.clean(texnames)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wad.texname.clean_+3A_texnames">texnames</code></td>
<td>
<p>character string, texture names from a WAD file. The textures may contain the special characters '*' and '+', which are used to indicate sequences (textures that change on an event, like a pressed button turning from red to green) and other things.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character strings usable as filenames.
</p>

<hr>
<h2 id='wal.export.to.jpeg'>Export wal instance to JPEG format image file.</h2><span id='topic+wal.export.to.jpeg'></span>

<h3>Description</h3>

<p>Export wal instance to JPEG format image file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wal.export.to.jpeg(wal, filepath, apply_palette = wal::pal_q2(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wal.export.to.jpeg_+3A_wal">wal</code></td>
<td>
<p>a wal instance, as returned by <code>read.wal</code></p>
</td></tr>
<tr><td><code id="wal.export.to.jpeg_+3A_filepath">filepath</code></td>
<td>
<p>character string, path to the JPEG file to write, including the file extension.</p>
</td></tr>
<tr><td><code id="wal.export.to.jpeg_+3A_apply_palette">apply_palette</code></td>
<td>
<p>optional 256 x 3 integer matrix, the palette. Must contain values in range 0..255. Pass NULL if you do not want to apply any palette. The resulting <code>wal</code> object will not have an 'image' entry then.</p>
</td></tr>
<tr><td><code id="wal.export.to.jpeg_+3A_...">...</code></td>
<td>
<p>extra parameters passed to <code>jpeg::writeJPEG</code>. Can be used to set JPEG quality.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   walf = '~/data/q2_pak0_extracted/textures/e1u2/basic1_7.wal';
   wal = read.wal(walf);
   wal.export.to.jpeg(wal, "~/basic1_7.jpg");

## End(Not run)

</code></pre>

<hr>
<h2 id='wal.export.to.png'>Export wal instance to PNG format image file.</h2><span id='topic+wal.export.to.png'></span>

<h3>Description</h3>

<p>Export wal instance to PNG format image file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wal.export.to.png(wal, filepath, apply_palette = wal::pal_q2(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wal.export.to.png_+3A_wal">wal</code></td>
<td>
<p>a wal instance, as returned by <code>read.wal</code></p>
</td></tr>
<tr><td><code id="wal.export.to.png_+3A_filepath">filepath</code></td>
<td>
<p>character string, path to the PNG file to write, including the file extension.</p>
</td></tr>
<tr><td><code id="wal.export.to.png_+3A_apply_palette">apply_palette</code></td>
<td>
<p>optional 256 x 3 integer matrix, the palette. Must contain values in range 0..255. Pass NULL if you do not want to apply any palette. The resulting <code>wal</code> object will not have an 'image' entry then.</p>
</td></tr>
<tr><td><code id="wal.export.to.png_+3A_...">...</code></td>
<td>
<p>extra parameters passed to <code>png::writePNG</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   walf = '~/data/q2_pak0_extracted/textures/e1u2/basic1_7.wal';
   wal = read.wal(walf);
   wal.export.to.png(wal, "~/basic1_7.png");

## End(Not run)

</code></pre>

<hr>
<h2 id='wal.template'>Generate a WAL structure template.</h2><span id='topic+wal.template'></span>

<h3>Description</h3>

<p>Generates a WAL instance that can be modified and filled with new data. The template represents a black 32x32 image (if the palette used to display it adhers to the convention that the first color is black). The indices used are 1-based (black is at index 1, not 0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wal.template()
</code></pre>

<hr>
<h2 id='writeWAL'>Write WAL instance to bitmap file in WAL format.</h2><span id='topic+writeWAL'></span>

<h3>Description</h3>

<p>Write WAL instance to bitmap file in WAL format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeWAL(filepath, wal)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="writeWAL_+3A_filepath">filepath</code></td>
<td>
<p>character string, path to the file including extension</p>
</td></tr>
<tr><td><code id="writeWAL_+3A_wal">wal</code></td>
<td>
<p>a wal instance. Note that 1 will be substracted from the data when it is written, as indices are stored 0-based in the file.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   walf = '~/data/q2_pak0_extracted/textures/e1u2/basic1_7.wal';
   wal = read.wal(walf);
   writeWAL(tempfile(fileext = ".wal"), wal);

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
