<!DOCTYPE html><html lang="en"><head><title>Help for package adwave</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {adwave}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#admix'><p>Simulated Admixed Population Data</p></a></li>
<li><a href='#plotsignal'><p>Plot Localized Admixture Signals</p></a></li>
<li><a href='#signal'><p>Compute Localized Admixture Signals</p></a></li>
<li><a href='#wavesum'><p>Wavelet Summaries of Localized Admixture Signals</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Wavelet Analysis of Genomic Data from Admixed Populations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-05-17</td>
</tr>
<tr>
<td>Depends:</td>
<td>waveslim</td>
</tr>
<tr>
<td>Author:</td>
<td>Jean Sanderson</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Murray Cox &lt;murray.p.cox@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements wavelet-based approaches for describing population admixture. Principal Components Analysis (PCA) is used to define the population structure and produce a localized admixture signal for each individual. Wavelet summaries of the PCA output describe variation present in the data and can be related to population-level demographic processes. For more details, see J Sanderson, H Sudoyo, TM Karafet, MF Hammer and MP Cox. 2015. Reconstructing past admixture processes from local genomic ancestry using wavelet transformation. Genetics 200:469-481 &lt;<a href="https://doi.org/10.1534%2Fgenetics.115.176842">doi:10.1534/genetics.115.176842</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://doi.org/10.1534/genetics.115.176842">https://doi.org/10.1534/genetics.115.176842</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-05-17 07:21:44 UTC; work</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-05-17 09:15:46 UTC</td>
</tr>
</table>
<hr>
<h2 id='admix'>Simulated Admixed Population Data</h2><span id='topic+admix'></span>

<h3>Description</h3>

<p>The example dataset provides simulated allele calls for 50 individuals from 3 populations. We consider a simple admixture scenario where two ancestral populations, popA (sample size <code class="reqn">n_A</code> = 15) and popB (sample size <code class="reqn">n_B</code> = 15), merged 160 generations ago to form the admixed population, popAB (sample size <code class="reqn">n_{AB}</code> = 20). The ancestral populations contributed to the admixed population with probability 0.5.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(admix)</code></pre>


<h3>Format</h3>

<p>A list with the following entries:
</p>

<ul>
<li> <p><b><code>data</code></b>:  3,000 x 50 data matrix with 3,000 genotype calls (rows) for 50 individuals (columns). Raw entries take the value 0 if heterozygous, and -1 or 1 if homozygous. Polymorphisms are ordered by their physical positions. Column names list individual IDs, row names list polymorphism IDs.
</p>
</li>
<li> <p><b><code>map</code></b>:  3,000 x 2 data matrix providing a mapping to genetic distance (&lsquo;recombination distance&rsquo;) for each polymorphism.
</p>
</li>
<li> <p><b><code>colplot</code></b>:  vector of length 50. Plotting color for each individual. 
</p>
</li>
<li> <p><b><code>populations</code></b>:  list of length 3. Character vectors giving the IDs of individuals in each population. IDs must map to the column names of the data matrix.
</p>
</li></ul>



<h3>Details</h3>

<p>Further description of the dataset can be found in Sanderson et al. (2015). The data were simulated using MaCS (Chen et al. 2009).
</p>


<h3>References</h3>

<p>Sanderson J, H Sudoyo, TM Karafet, MF Hammer and MP Cox. 2015. Reconstructing past admixture processes from local genomic ancestry using wavelet transformation. <em>Genetics</em> 200:469-481. <a href="https://doi.org/10.1534/genetics.115.176842">https://doi.org/10.1534/genetics.115.176842</a>
</p>
<p>Chen GK, P Marjoram and JD Wall. 2009. Fast and flexible simulation of DNA sequence data. <em>Genome Research</em> 19:136-142. <a href="https://doi.org/10.1101/gr.083634.108">https://doi.org/10.1101/gr.083634.108</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(admix)
str(admix) 
</code></pre>

<hr>
<h2 id='plotsignal'>Plot Localized Admixture Signals</h2><span id='topic+plotsignal'></span>

<h3>Description</h3>

<p>Plotting function for objects of class <code>adsig</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotsignal(x, ind = NULL, popA = NULL, popB = NULL, xlab = NULL, ylab = NULL, 
		ylim = NULL, main = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotsignal_+3A_x">x</code></td>
<td>

<p>object of class <code>adsig</code> for plotting. 
</p>
</td></tr>
<tr><td><code id="plotsignal_+3A_ind">ind</code></td>
<td>

<p>character giving ID of a single individual to plot. 
</p>
</td></tr>
<tr><td><code id="plotsignal_+3A_popa">popA</code></td>
<td>

<p><em>(optional)</em> name of ancestral population 1.
</p>
</td></tr>
<tr><td><code id="plotsignal_+3A_popb">popB</code></td>
<td>

<p><em>(optional)</em> name of ancestral population 2.
</p>
</td></tr>
<tr><td><code id="plotsignal_+3A_xlab">xlab</code></td>
<td>

<p><em>(optional)</em> character string for x axis label. 
</p>
</td></tr>
<tr><td><code id="plotsignal_+3A_ylab">ylab</code></td>
<td>

<p><em>(optional)</em> character string for y axis label. 
</p>
</td></tr>
<tr><td><code id="plotsignal_+3A_ylim">ylim</code></td>
<td>

<p><em>(optional)</em> vector giving plotting range for y axis.
</p>
</td></tr>
<tr><td><code id="plotsignal_+3A_main">main</code></td>
<td>

<p><em>(optional)</em> character string for title. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces figure.
</p>


<h3>Author(s)</h3>

<p>Jean Sanderson
</p>


<h3>References</h3>

<p>Sanderson J, H Sudoyo, TM Karafet, MF Hammer and MP Cox. 2015. Reconstructing past admixture processes from local genomic ancestry using wavelet transformation. <em>Genetics</em> 200:469-481. <a href="https://doi.org/10.1534/genetics.115.176842">https://doi.org/10.1534/genetics.115.176842</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+signal">signal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(admix)

# Generate the admixture signal with windowing
AdexPCA2 &lt;- signal(admix$data,popA="popA",popB="popB",populations=admix$populations,
		tol=0.001,n.signal=1000,window.size=0.01)

# Plot resulting admixture signal for one individual
plotsignal(AdexPCA2,ind="AD00001",popA=AdexPCA2$popA,popB=AdexPCA2$popB)
</code></pre>

<hr>
<h2 id='signal'>Compute Localized Admixture Signals</h2><span id='topic+signal'></span>

<h3>Description</h3>

<p>Produces estimates of localized ancestry for each individual. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal(table, who = colnames(table), populations, popA = NA, popB = NA, 
	normalize = FALSE, n.pca = 5, PCAonly = FALSE, verbose = TRUE, tol = 0.001,
	n.signal = NULL, window.size = NULL, genmap = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="signal_+3A_table">table</code></td>
<td>

<p>matrix of genotype calls (rows, length <em>T</em>) versus individuals (columns, length <em>n</em>).</p>
</td></tr>
<tr><td><code id="signal_+3A_who">who</code></td>
<td>
<p>individuals to include in the analysis. </p>
</td></tr>
<tr><td><code id="signal_+3A_populations">populations</code></td>
<td>
<p>list containing a vector of IDs for each population in the analysis.</p>
</td></tr>
<tr><td><code id="signal_+3A_popa">popA</code></td>
<td>

<p>name of ancestral population 1 (used for forming the axes of variation). Must match one of the names in <code>populations</code>. 
</p>
</td></tr>
<tr><td><code id="signal_+3A_popb">popB</code></td>
<td>

<p>name of ancestral population 2 (used for forming the axes of variation). Must match one of the names in <code>populations</code>. 
</p>
</td></tr>
<tr><td><code id="signal_+3A_normalize">normalize</code></td>
<td>

<p>if <code>TRUE</code>, normalize the data matrix. Default is <code>FALSE</code>. 
</p>
</td></tr>
<tr><td><code id="signal_+3A_n.pca">n.pca</code></td>
<td>

<p>number of PCA axes to compute (only the first principal component is used for forming the signals, but additional components may be desired for visualization). Default is 5.
</p>
</td></tr>
<tr><td><code id="signal_+3A_pcaonly">PCAonly</code></td>
<td>

<p>if <code>TRUE</code>, only compute the PCA, do not compute the signals. Default is<code> FALSE</code>.
</p>
</td></tr>
<tr><td><code id="signal_+3A_verbose">verbose</code></td>
<td>

<p>if <code>TRUE</code>, print summary to screen. Default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="signal_+3A_tol">tol</code></td>
<td>

<p>tolerance for normalization of admixture signals (<code class="reqn">\epsilon</code> in accompanying paper). Default is 0.001.
</p>
</td></tr>
<tr><td><code id="signal_+3A_n.signal">n.signal</code></td>
<td>

<p><em>(optional)</em> number of data points in the windowed signal. 
</p>
</td></tr>
<tr><td><code id="signal_+3A_window.size">window.size</code></td>
<td>

<p><em>(optional)</em> size of window specified as a proportion of total length; <br /> e.g., <code>window.size = 0.01</code> with signal of length <code class="reqn">T</code> = 3000 SNPs generates windows of <code class="reqn">0.01 x 3000 = 30</code> polymorphisms. Value need not be a round number. 
</p>
</td></tr>
<tr><td><code id="signal_+3A_genmap">genmap</code></td>
<td>

<p><em>(optional)</em> genetic distance of genotype calls, supplied as vector of length <em>T</em>. If specified, signals will be formulated in terms of genetic distance along the chromosome (rather than physical position).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Applies PCA to genome-wide data using ancestral reference populations. The first eigenvector reflects the population structure. All individuals are then projected on to this axis to form the SNP-level admixture signals. PCA scores are used to estimate the proportion of admixture at the level of individuals (<code>indP</code>) and populations (<code>popP</code>). There is no restriction on the length of the data (number of SNPs) and the default is to provide an estimate of localized ancestry at each SNP. <br /> <br />
Optionally, it is also possible to window the signals, producing processed signals of length <code>n.signal</code>. The windows may be overlapping or disjoint with width specified through the <code>window.size</code> option (see examples). If <code>genmap</code> is specified, the signals will be formulated in terms of genetic distance along the chromosome (note: this function is not described in the accompanying paper).
</p>


<h3>Value</h3>

<p>Returns an object of class <code>adsig</code>, a list with the following components: 
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>function call.</p>
</td></tr>
<tr><td><code>date</code></td>
<td>
<p>date of function call.</p>
</td></tr>
<tr><td><code>individuals</code></td>
<td>
<p>individuals for whom projections on the first principal component are calculated.</p>
</td></tr>
<tr><td><code>n.snps</code></td>
<td>
<p>number of polymorphisms in the table.</p>
</td></tr>
<tr><td><code>signals</code></td>
<td>
<p>The admixture signals, output as a <code class="reqn">T x n</code> data matrix, where <em>n</em> is the number of individuals and <em>T</em> is the number of data points (either the number of polymorphisms if <code>n.signal = NULL</code> or <code>n.signal</code> otherwise).</p>
</td></tr>
<tr><td><code>n.tol</code></td>
<td>
<p>the number of entries replaced by zero in the normalization procedure. This is dependent on the value set for the tolerance, tol.</p>
</td></tr>
<tr><td><code>popP</code></td>
<td>
<p>estimated proportion of admixture for each population.</p>
</td></tr>
<tr><td><code>indP</code></td>
<td>
<p>estimated proportion of admixture for each individual.</p>
</td></tr>
<tr><td><code>pa.ind</code></td>
<td>
<p>columns are principal axes in individual coordinates (<code class="reqn">n_A + n_B</code> rows, <code>n.pca</code> columns).</p>
</td></tr>
<tr><td><code>pa.snp</code></td>
<td>
<p>columns are principal axes in polymorphism coordinates (<em>T</em> rows, <code>n.pca</code> columns).</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>matrix of quadratic form in individual coordinates. </p>
</td></tr>
<tr><td><code>ev</code></td>
<td>
<p>vector of eigenvalues.</p>
</td></tr>
<tr><td><code>gendist</code></td>
<td>
<p>(<em>only if <code>genmap</code> is specified in input</em>) Vector of genetic distances along the chromosome, length <code>n.signal</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jean Sanderson
</p>


<h3>References</h3>

<p>Sanderson J, H Sudoyo, TM Karafet, MF Hammer and MP Cox. 2015. Reconstructing past admixture processes from local genomic ancestry using wavelet transformation. <em>Genetics</em> 200:469-481. <a href="https://doi.org/10.1534/genetics.115.176842">https://doi.org/10.1534/genetics.115.176842</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wavesum">wavesum</a></code>,  <code><a href="#topic+plotsignal">plotsignal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(admix)

# EXAMPLE 1
# Generate the admixture signal 
AdexPCA &lt;- signal(admix$data,popA="popA",popB="popB",populations=admix$populations,tol=0.001,
		n.signal=NULL)

# Plot the resulting PCA
plot(AdexPCA$pc.ind[,1],AdexPCA$pc.ind[,2],col=admix$colplot,xlab="PC1",ylab="PC2",pch=16)
legend("bottomright",c("popA","popB","popAB"),col=c(3,4,2),pch=16)


# EXAMPLE 2
# Generate the admixture signal with windowing
AdexPCA2 &lt;- signal(admix$data,popA="popA",popB="popB",populations=admix$populations,tol=0.001,
		n.signal=1000,window.size=0.01)

# Plot resulting admixture signal for one individual
plotsignal(AdexPCA2,ind="AD00001",popA=AdexPCA2$popA,popB=AdexPCA2$popB)


# EXAMPLE 3
# Generate the admixture signal with windowing
# As in EXAMPLE 2 but with n.signal reduced to 100 to provide disjoint windows
AdexPCA3 &lt;- signal(admix$data,popA="popA",popB="popB",populations=admix$populations,tol=0.001,
		n.signal=100,window.size=0.01)

# Plot resulting admixture signal for one individual
plotsignal(AdexPCA3,ind="AD00001",popA=AdexPCA2$popA,popB=AdexPCA2$popB)


# EXAMPLE 4
# Generate the admixture signal in terms of genetic distance
# As in EXAMPLE 2 but with genmap specified so that signals are formulated using genetic distances
AdexPCA4 &lt;- signal(admix$data,popA="popA",popB="popB",populations=admix$populations,tol=0.001,
	n.signal=1000,window.size=0.01,genmap=admix$map[,2])

# Plot resulting admixture signal for one individual
plotsignal(AdexPCA4,ind="AD00001",popA=AdexPCA4$popA,popB=AdexPCA4$popB)
</code></pre>

<hr>
<h2 id='wavesum'>Wavelet Summaries of Localized Admixture Signals</h2><span id='topic+wavesum'></span>

<h3>Description</h3>

<p>Produces wavelet summaries for each individual and group. Returns the wavelet variance and average block size metric (ABS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wavesum(x, populations, popA = NA, popB = NA, ml = NULL, type = "la8",
    t.factor = 1, fullWT = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wavesum_+3A_x">x</code></td>
<td>

<p>object of class <code>adsig</code>. 
</p>
</td></tr>
<tr><td><code id="wavesum_+3A_populations">populations</code></td>
<td>

<p>list containing a vector of individual IDs for each population in the analysis. 
</p>
</td></tr>
<tr><td><code id="wavesum_+3A_popa">popA</code></td>
<td>

<p>name of ancestral population 1 (used for forming the axes of variation). Must match one of the names in <code>populations</code>. 
</p>
</td></tr>
<tr><td><code id="wavesum_+3A_popb">popB</code></td>
<td>

<p>name of ancestral population 2 (used for forming the axes of variation). Must match one of the names in <code>populations</code>. 
</p>
</td></tr>
<tr><td><code id="wavesum_+3A_ml">ml</code></td>
<td>

<p>number of wavelet scales in the decomposition. Must not exceed <code class="reqn">log_2(T)</code>, where <em>T</em> is the length of the signal.
</p>
</td></tr>
<tr><td><code id="wavesum_+3A_type">type</code></td>
<td>

<p>name of the wavelet to use in the decomposition. The default, &ldquo;la8&rdquo;, is Daubechies Least Asymmetric wavelet of length 8. Other options include &ldquo;haar&rdquo;.
</p>
</td></tr>
<tr><td><code id="wavesum_+3A_t.factor">t.factor</code></td>
<td>

<p>multiplicative factor for thresholding. See paper for details. Default is 1.
</p>
</td></tr>
<tr><td><code id="wavesum_+3A_fullwt">fullWT</code></td>
<td>

<p>if <code>TRUE</code>, save the full wavelet periodogram, as well as the wavelet variance. Object size will be large. Default is <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces wavelet summaries for objects of class <code>adsig</code>. The function computes the wavelet variance for each individual and population, extracts the informative wavelet variance based on levels observed in the ancestral populations, and computes summary measures of average block size metric (ABS) and peak wavelet scale for each individual and population. <br /> <br />
See <code>waveslim</code> documentation for details of the <code>modwt</code> function and alternative wavelet options.
</p>


<h3>Value</h3>

<p>The code returns a list with the following components: 
</p>
<table role = "presentation">
<tr><td><code>n.ind</code></td>
<td>
<p>number of individuals in the analysis.</p>
</td></tr>
<tr><td><code>n.group</code></td>
<td>
<p>number of groups in the analysis.</p>
</td></tr>
<tr><td><code>rv.ind</code></td>
<td>
<p>matrix of dimension <code class="reqn">n x ml</code>, returning the raw wavelet variance for each individual.</p>
</td></tr>
<tr><td><code>rv.group</code></td>
<td>
<p>matrix of dimension <code class="reqn">n.group x ml</code>, returning the raw wavelet variance for each group.</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>
<p>vector of length <code class="reqn">ml</code>, returning threshold values for each wavelet scale.</p>
</td></tr>
<tr><td><code>iv.ind</code></td>
<td>
<p>matrix of dimension <code class="reqn">n x ml</code>, returning the informative (thresholded) wavelet variance for each individual.</p>
</td></tr>
<tr><td><code>iv.group</code></td>
<td>
<p>matrix of dimension <code class="reqn">n.group x ml</code>, returning the informative (thresholded) wavelet variance for each group.</p>
</td></tr>
<tr><td><code>abs.ind</code></td>
<td>
<p>vector of length <code class="reqn">n</code>, returning the average block size metric (ABS) for each individual.</p>
</td></tr>
<tr><td><code>abs.group</code></td>
<td>
<p>vector of length <code>n.group</code>, returning the average block size metric (ABS) for each group.</p>
</td></tr>
<tr><td><code>pws.ind</code></td>
<td>
<p>vector of length <code class="reqn">n</code>, returning the peak wavelet scale for each individual.</p>
</td></tr>
<tr><td><code>pws.group</code></td>
<td>
<p>vector of length <code>n.group</code>, returning the peak wavelet scale for each group.</p>
</td></tr>
<tr><td><code>wtmatrix</code></td>
<td>
 <p><em>(only if <code>fullWT = TRUE</code>)</em>. Array of dimension <code class="reqn">T x n x ml</code>, containing squared wavelet coefficients for each individual.</p>
</td></tr>
<tr><td><code>wtmatrix.group</code></td>
<td>
<p><em>(only if <code>fullWT = TRUE</code>)</em>. Array of dimension <code class="reqn">T x n.group x ml</code>, squared wavelet coefficients, averaged for each group.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jean Sanderson
</p>


<h3>References</h3>

<p>Sanderson J, H Sudoyo, TM Karafet, MF Hammer and MP Cox. 2015. Reconstructing past admixture processes from local genomic ancestry using wavelet transformation. <em>Genetics</em> 200:469-481. <a href="https://doi.org/10.1534/genetics.115.176842">https://doi.org/10.1534/genetics.115.176842</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+signal">signal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(admix)

# Generate the admixture signal 
AdexPCA &lt;- signal(admix$data,popA="popA",popB="popB",populations=admix$populations,
  tol=0.001, n.signal=NULL)

# Compute wavelet summaries
WSN &lt;- wavesum(AdexPCA,populations=admix$populations,popA="popA",popB="popB")

# Plot raw wavelet variance for each population
barplot(WSN$rv.group[3,],ylim=c(0,0.9),col="red", names.arg=1:11,border=NA)
barplot(WSN$rv.group[1,],ylim=c(0,0.9),col="green3",names.arg=1:11,border=NA,add=TRUE)
barplot(WSN$rv.group[2,],ylim=c(0,0.9),col="blue", names.arg=1:11,border=NA,add=TRUE)
legend("topright",c("popA","popB","popAB"),col=c(3,4,2),pch=15)
box()

# Plot informative wavelet variance for admixed population
barplot(WSN$iv.group[3,],ylim=c(0,0.15),col="red",names.arg=1:11,border=NA)
ABS &lt;- round(WSN$abs.group[3],2) 
text(11,0.13,paste("ABS=",ABS))
box()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
