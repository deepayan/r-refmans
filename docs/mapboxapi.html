<!DOCTYPE html><html><head><title>Help for package mapboxapi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mapboxapi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mapboxapi'><p>An R interface to Mapbox web services</p></a></li>
<li><a href='#addMapboxTiles'><p>Use a Mapbox style in a Leaflet map</p></a></li>
<li><a href='#check_upload_status'><p>Check the status of a Mapbox upload</p></a></li>
<li><a href='#feature_options'><p>Specify feature options for an MTS recipe layer</p></a></li>
<li><a href='#geocoder_as_sf'><p>Convert the result of a <code>mapboxGeocoderInput()</code> geocoded location to an sf object</p></a></li>
<li><a href='#geocoder_as_xy'><p>Convert the results of a <code>mapboxGeocoderInput()</code> geocoded location to XY coordinates</p></a></li>
<li><a href='#get_geocoder_dependencies'><p>Include Mapbox Geocoder dependencies</p></a></li>
<li><a href='#get_static_tiles'><p>Get static tiles from a Mapbox style for use as a basemap</p></a></li>
<li><a href='#get_style'><p>Get information about a style or list styles from a Mapbox account</p></a></li>
<li><a href='#get_vector_tiles'><p>Retrieve vector tiles from a given Mapbox tileset</p></a></li>
<li><a href='#layer_static_mapbox'><p>Make a static Mapbox ggplot2 layer or tmap basemap</p></a></li>
<li><a href='#mapboxGeocoderInput'><p>Use Mapbox's Geocoder widget in a Shiny application</p></a></li>
<li><a href='#mb_access_token'><p>Install or retrieve a Mapbox access token in your .Renviron for repeated use</p></a></li>
<li><a href='#mb_batch_geocode'><p>Geocode addresses or locations in bulk using the Mapbox Batch Geocoding API</p></a></li>
<li><a href='#mb_directions'><p>Make a request to the Mapbox Directions API</p></a></li>
<li><a href='#mb_geocode'><p>Geocode an address or place description using the Mapbox Geocoding API</p></a></li>
<li><a href='#mb_isochrone'><p>Generate isochrones using the Mapbox Navigation Service Isochrone API</p></a></li>
<li><a href='#mb_matrix'><p>Retrieve a matrix of travel times from the Mapbox Directions API</p></a></li>
<li><a href='#mb_optimized_route'><p>Return an optimized route for a series of input coordinates</p></a></li>
<li><a href='#mts_create_source'><p>Create a Mapbox tileset source from a sf object using the Mapbox Tiling Service API</p></a></li>
<li><a href='#mts_create_tileset'><p>Create a tileset with the Mapbox Tiling Service API</p></a></li>
<li><a href='#mts_get_recipe'><p>Retrieve the recipe for an MTS tileset in your Mapbox account</p></a></li>
<li><a href='#mts_list_sources'><p>List tileset sources in your Mapbox account</p></a></li>
<li><a href='#mts_list_tilesets'><p>List tilesets in a Mapbox account</p></a></li>
<li><a href='#mts_make_recipe'><p>Prepare a recipe for use with the Mapbox Tiling Service</p></a></li>
<li><a href='#mts_publish_tileset'><p>Publish a tileset with Mapbox Tiling Service</p></a></li>
<li><a href='#mts_update_recipe'><p>Update a tileset's MTS recipe</p></a></li>
<li><a href='#mts_validate_recipe'><p>Validate a Mapbox Tiling Service recipe</p></a></li>
<li><a href='#prep_overlay_markers'><p>Prepare overlay markers for use in a Mapbox static map</p></a></li>
<li><a href='#query_tiles'><p>Get information about features in a tileset using the Tilequery API</p></a></li>
<li><a href='#recipe_layer'><p>Prepare a formatted recipe layer for use in a Mapbox Tiling Service recipe</p></a></li>
<li><a href='#static_mapbox'><p>Return a static Mapbox map from a specified style</p></a></li>
<li><a href='#tile_options'><p>Specify tile options for an MTS recipe layer</p></a></li>
<li><a href='#tippecanoe'><p>Generate an .mbtiles file with tippecanoe</p></a></li>
<li><a href='#upload_tiles'><p>Upload dataset to your Mapbox account</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>R Interface to 'Mapbox' Web Services</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-10</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kyle Walker &lt;kyle@walker-data.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Includes support for 'Mapbox' Navigation APIs, including directions, 
  isochrones, and route optimization; the Search API for forward and reverse geocoding; 
  the Maps API for interacting with 'Mapbox' vector tilesets and visualizing 
  'Mapbox' maps in R; and 'Mapbox Tiling Service' and 'tippecanoe' for generating map tiles.
  See <a href="https://docs.mapbox.com/api/">https://docs.mapbox.com/api/</a> for more information about the 'Mapbox' APIs.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/walkerke/mapboxapi">https://github.com/walkerke/mapboxapi</a>,
<a href="https://walker-data.com/mapboxapi/">https://walker-data.com/mapboxapi/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/walkerke/mapboxapi/issues">https://github.com/walkerke/mapboxapi/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>httr, sf, jsonlite, purrr, curl, dplyr (&ge; 1.0.0), tidyr (&ge;
1.0.0), aws.s3, stringi, slippymath, protolite, rlang,
geojsonsf, magick, leaflet, units, raster, png, jpeg, htmltools</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggspatial, grDevices, mapdeck, tigris, tidycensus, tmap,
mapboxer, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-10 16:18:00 UTC; kylewalker</td>
</tr>
<tr>
<td>Author:</td>
<td>Kyle Walker [aut, cre],
  Eli Pousson [ctb],
  Anthony North [ctb, cph],
  Miles McBain [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-10 16:43:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='mapboxapi'>An R interface to Mapbox web services</h2><span id='topic+mapboxapi-package'></span><span id='topic+mapboxapi'></span>

<h3>Description</h3>

<p>Use Mapbox web services APIs for spatial data science and visualization projects in R. Usage of the package is governed by the Mapbox Terms of Service.
</p>


<h3>Author(s)</h3>

<p>Kyle Walker
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/walkerke/mapboxapi">https://github.com/walkerke/mapboxapi</a>
</p>
</li>
<li> <p><a href="https://walker-data.com/mapboxapi/">https://walker-data.com/mapboxapi/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/walkerke/mapboxapi/issues">https://github.com/walkerke/mapboxapi/issues</a>
</p>
</li></ul>


<hr>
<h2 id='addMapboxTiles'>Use a Mapbox style in a Leaflet map</h2><span id='topic+addMapboxTiles'></span>

<h3>Description</h3>

<p>See the <a href="https://docs.mapbox.com/api/maps/static-tiles/">Mapbox Static Tiles API documentation</a> for more
information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addMapboxTiles(
  map,
  style_id,
  username,
  style_url = NULL,
  scaling_factor = c("1x", "0.5x", "2x"),
  access_token = NULL,
  layerId = NULL,
  group = NULL,
  options = leaflet::tileOptions(),
  data = leaflet::getMapData(map),
  attribution = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addMapboxTiles_+3A_map">map</code></td>
<td>
<p>A map widget object created by <code><a href="leaflet.html#topic+leaflet">leaflet::leaflet()</a></code></p>
</td></tr>
<tr><td><code id="addMapboxTiles_+3A_style_id">style_id</code></td>
<td>
<p>The style ID of a Mapbox style</p>
</td></tr>
<tr><td><code id="addMapboxTiles_+3A_username">username</code></td>
<td>
<p>A Mapbox username</p>
</td></tr>
<tr><td><code id="addMapboxTiles_+3A_style_url">style_url</code></td>
<td>
<p>A Mapbox style URL</p>
</td></tr>
<tr><td><code id="addMapboxTiles_+3A_scaling_factor">scaling_factor</code></td>
<td>
<p>The scaling factor to use when rendering the tiles. A
scaling factor of <code>"1x"</code> (the default) returns 512px by 512px tiles. A
factor of <code>"1x"</code> returns 256x256 tiles, and a factor of <code>"2x"</code> returns
1024x1024 tiles.</p>
</td></tr>
<tr><td><code id="addMapboxTiles_+3A_access_token">access_token</code></td>
<td>
<p>Your Mapbox access token; which can be set with
<code><a href="#topic+mb_access_token">mb_access_token()</a></code>.</p>
</td></tr>
<tr><td><code id="addMapboxTiles_+3A_layerid">layerId</code></td>
<td>
<p>the layer ID</p>
</td></tr>
<tr><td><code id="addMapboxTiles_+3A_group">group</code></td>
<td>
<p>The name of the group the Mapbox tile layer should belong to
(for use in Shiny and to modify layers control in a Leaflet workflow)</p>
</td></tr>
<tr><td><code id="addMapboxTiles_+3A_options">options</code></td>
<td>
<p>A list of extra options (optional)</p>
</td></tr>
<tr><td><code id="addMapboxTiles_+3A_data">data</code></td>
<td>
<p>The data object used to derive argument values; can be provided
to the initial call to <code><a href="leaflet.html#topic+leaflet">leaflet::leaflet()</a></code></p>
</td></tr>
<tr><td><code id="addMapboxTiles_+3A_attribution">attribution</code></td>
<td>
<p>If <code>TRUE</code>, pass a standard attribution to
<code><a href="leaflet.html#topic+map-layers">leaflet::addTiles()</a></code>. If <code>FALSE</code>, attribution is <code>NULL</code>. attribution can
also be a character string including HTML.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A pointer to the Mapbox Static Tiles API which will be translated
appropriately by the leaflet R package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(leaflet)
library(mapboxapi)

leaflet() %&gt;%
  addMapboxTiles(
    style_id = "light-v9",
    username = "mapbox"
  ) %&gt;%
  setView(
    lng = -74.0051,
    lat = 40.7251,
    zoom = 13
  )

## End(Not run)

</code></pre>

<hr>
<h2 id='check_upload_status'>Check the status of a Mapbox upload</h2><span id='topic+check_upload_status'></span>

<h3>Description</h3>

<p>Check the status of a Mapbox upload
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_upload_status(upload_id, username, access_token = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_upload_status_+3A_upload_id">upload_id</code></td>
<td>
<p>The upload ID</p>
</td></tr>
<tr><td><code id="check_upload_status_+3A_username">username</code></td>
<td>
<p>Your account's username</p>
</td></tr>
<tr><td><code id="check_upload_status_+3A_access_token">access_token</code></td>
<td>
<p>Your Mapbox access token</p>
</td></tr>
</table>

<hr>
<h2 id='feature_options'>Specify feature options for an MTS recipe layer</h2><span id='topic+feature_options'></span>

<h3>Description</h3>

<p>Specify feature options for an MTS recipe layer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feature_options(
  id = NULL,
  bbox = NULL,
  attributes = list(zoom_element = NULL, set = NULL, allowed_output = NULL),
  filter = NULL,
  simplification = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feature_options_+3A_id">id</code></td>
<td>
<p>A column representing the feature ID. See <a href="https://docs.mapbox.com/mapbox-tiling-service/reference/#id-expression">https://docs.mapbox.com/mapbox-tiling-service/reference/#id-expression</a>.</p>
</td></tr>
<tr><td><code id="feature_options_+3A_bbox">bbox</code></td>
<td>
<p>A bounding box within which rendered features will be clipped. See <a href="https://docs.mapbox.com/mapbox-tiling-service/reference/#bounding-box">https://docs.mapbox.com/mapbox-tiling-service/reference/#bounding-box</a>.</p>
</td></tr>
<tr><td><code id="feature_options_+3A_attributes">attributes</code></td>
<td>
<p>A named list of attribute transformations. <code>zoom_element</code> specifies how an attribute should be made available at different zoom levels; <code>set</code> allows you to calculate new attributes from existing attributes when processing the tiles; and <code>allowed_output</code> specifies which columns should be carried through to the output tiles.  See <a href="https://docs.mapbox.com/mapbox-tiling-service/reference/#feature-attributes">https://docs.mapbox.com/mapbox-tiling-service/reference/#feature-attributes</a>.</p>
</td></tr>
<tr><td><code id="feature_options_+3A_filter">filter</code></td>
<td>
<p>An expression that determines how features in the tileset should be filtered. See <a href="https://docs.mapbox.com/mapbox-tiling-service/reference/#feature-filters">https://docs.mapbox.com/mapbox-tiling-service/reference/#feature-filters</a> for information on how to specify the filter.</p>
</td></tr>
<tr><td><code id="feature_options_+3A_simplification">simplification</code></td>
<td>
<p>Rules for feature simplification.  See <a href="https://docs.mapbox.com/mapbox-tiling-service/reference/#feature-simplification">https://docs.mapbox.com/mapbox-tiling-service/reference/#feature-simplification</a> for more information on how to specify this.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of feature options, likely to be used in <code>recipe_layer()</code>.
</p>


<h3>See Also</h3>

<p><a href="https://docs.mapbox.com/mapbox-tiling-service/reference/">https://docs.mapbox.com/mapbox-tiling-service/reference/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(tidycensus)
library(mapboxapi)
options(tigris_use_cache = TRUE)

# Get the national data on median age
us_median_age_tract &lt;- get_acs(
  geography = "tract",
  variables = "B01002_001",
  state = c(state.abb, "DC"),
  year = 2020,
  geometry = TRUE
)

# Get it for counties as well
us_median_age_county &lt;- get_acs(
  geography = "county",
  variables = "B01002_001",
  year = 2020,
  geometry = TRUE
)

# Create a source from the datasets
mts_create_source(data = us_median_age_tract,
                  tileset_id = "us_median_age_tract",
                  username = "your_mapbox_username")

mts_create_source(data = us_median_age_county,
                  tileset_id = "us_median_age_county",
                  username = "your_mapbox_username")

# Build out the recipe.  First, create a recipe layer with
# appropriate options.  We'll want a larger tile size and to restrict the minzoom
# to 4; a maxzoom of 12 will be fine as we can overzoom beyond that
#
# Your source ID will be returned by `mts_create_source()`, so use that value
tract_layer &lt;- recipe_layer(
  source = "mapbox://tileset-source/your_mapbox_username/us_median_age_tract",
  minzoom = 4,
  maxzoom = 12,
  tiles = tile_options(layer_size = 2500)
)

county_layer &lt;- recipe_layer(
  source = "mapbox://tileset-source/your_mapbox_username/us_median_age_county",
  minzoom = 2,
  maxzoom = 5
)

recipe &lt;- mts_make_recipe(tracts = tract_layer, counties = county_layer)

# Validate the recipe
mts_validate_recipe(recipe)

# Create a tileset from the recipe
mts_create_tileset(tileset_name = "median_age_acs",
                   username = "your_mapbox_username",
                   recipe = recipe)

# Publish the tileset
mts_publish_tileset(tileset_name = "median_age_acs",
                    username = "your_mapbox_username")

# If necessary, update the recipe
mts_update_recipe(tileset_name = "median_age_acs",
                  username = "your_mapbox_username",
                  recipe = new_recipe)

# Publish the tileset again after you've updated the recipe
mts_publish_tileset(tileset_name = "median_age_acs",
                    username = "your_mapbox_username")

## End(Not run)
</code></pre>

<hr>
<h2 id='geocoder_as_sf'>Convert the result of a <code>mapboxGeocoderInput()</code> geocoded location to an sf object</h2><span id='topic+geocoder_as_sf'></span>

<h3>Description</h3>

<p>Convert the result of a <code>mapboxGeocoderInput()</code> geocoded location to an sf object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geocoder_as_sf(input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geocoder_as_sf_+3A_input">input</code></td>
<td>
<p>The name of the Shiny input using <code>mapboxGeocoderInput()</code>, likely something like <code>input$geocode</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An sf object that can be used downstream in your Shiny applications.
</p>

<hr>
<h2 id='geocoder_as_xy'>Convert the results of a <code>mapboxGeocoderInput()</code> geocoded location to XY coordinates</h2><span id='topic+geocoder_as_xy'></span>

<h3>Description</h3>

<p>Convert the results of a <code>mapboxGeocoderInput()</code> geocoded location to XY coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geocoder_as_xy(input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geocoder_as_xy_+3A_input">input</code></td>
<td>
<p>The name of the Shiny input using <code>mapboxGeocoderInput()</code>, likely something like <code>input$geocode</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A length-2 vector representing the geocoded longitude/latitude coordinates of the location.
</p>

<hr>
<h2 id='get_geocoder_dependencies'>Include Mapbox Geocoder dependencies</h2><span id='topic+get_geocoder_dependencies'></span>

<h3>Description</h3>

<p>This function loads necessary JavaScript and CSS for the Mapbox Geocoder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_geocoder_dependencies()
</code></pre>

<hr>
<h2 id='get_static_tiles'>Get static tiles from a Mapbox style for use as a basemap</h2><span id='topic+get_static_tiles'></span>

<h3>Description</h3>

<p>This function queries the <a href="https://docs.mapbox.com/api/maps/static-tiles/">Mapbox Static Tiles API</a> and composites the tiles
as a raster suitable for use as a basemap in
<a href="https://r-tmap.github.io/tmap/">tmap</a> or
<a href="https://ggplot2.tidyverse.org/">ggplot2</a> (with the
<code><a href="ggspatial.html#topic+layer_spatial">ggspatial::layer_spatial()</a></code> function. It returns a raster
layer that corresponds either to an input bounding box or a buffered area
around an input shape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_static_tiles(
  location,
  zoom,
  style_id,
  username,
  style_url = NULL,
  scaling_factor = c("1x", "2x"),
  buffer_dist = 5000,
  units = "m",
  crop = TRUE,
  access_token = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_static_tiles_+3A_location">location</code></td>
<td>
<p>An input location for which you would like to request tiles.
Can be a length-4 vector representing a bounding box, or an <code>sf</code> object.
If an input <code>sf</code> object is supplied, use the <code>buffer_dist</code> argument to
control how much area you want to capture around the layer.
While the input <code>sf</code> object can be in an arbitrary coordinate reference system,
if a length-4 bounding box vector is supplied instead it must represent
WGS84 longitude/latitude coordinates and be in the order
<code>c(xmin, ymin, xmax, ymax)</code>.</p>
</td></tr>
<tr><td><code id="get_static_tiles_+3A_zoom">zoom</code></td>
<td>
<p>The zoom level for which you'd like to return tiles.</p>
</td></tr>
<tr><td><code id="get_static_tiles_+3A_style_id">style_id</code></td>
<td>
<p>A Mapbox style ID; retrieve yours from your Mapbox account.</p>
</td></tr>
<tr><td><code id="get_static_tiles_+3A_username">username</code></td>
<td>
<p>A Mapbox username.</p>
</td></tr>
<tr><td><code id="get_static_tiles_+3A_style_url">style_url</code></td>
<td>
<p>A Mapbox style URL.</p>
</td></tr>
<tr><td><code id="get_static_tiles_+3A_scaling_factor">scaling_factor</code></td>
<td>
<p>The scaling factor to use; one of <code>"1x"</code> or <code>"2x"</code>.</p>
</td></tr>
<tr><td><code id="get_static_tiles_+3A_buffer_dist">buffer_dist</code></td>
<td>
<p>The distance to buffer around an input <code>sf</code> object for determining tile extent, specified in units. Defaults to 5000.</p>
</td></tr>
<tr><td><code id="get_static_tiles_+3A_units">units</code></td>
<td>
<p>Units of <code>buffer_dist</code>; defaults to &quot;m&quot; (meters). If buffer_dist
is a units class object, the units argument is ignored.</p>
</td></tr>
<tr><td><code id="get_static_tiles_+3A_crop">crop</code></td>
<td>
<p>Whether or not to crop the result to the specified bounding box or buffer area.
Defaults to <code>TRUE</code>; <code>FALSE</code> will return the extent of the overlapping
tiles.</p>
</td></tr>
<tr><td><code id="get_static_tiles_+3A_access_token">access_token</code></td>
<td>
<p>A Mapbox access token. Supply yours here or set globally with the <code><a href="#topic+mb_access_token">mb_access_token()</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A raster layer of tiles from the requested Mapbox style representing the area around the input location. The raster layer is projected in the Web Mercator coordinate reference system.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(mapboxapi)
library(tigris)
library(tmap)
library(ggspatial)
library(ggplot2)

ny_tracts &lt;- tracts("NY", "New York", cb = TRUE)

ny_tiles &lt;- get_static_tiles(
  location = ny_tracts,
  zoom = 10,
  style_id = "light-v9",
  username = "mapbox"
)

# tmap usage:
tm_shape(ny_tiles) +
  tm_rgb() +
  tm_shape(ny_tracts) +
  tm_polygons(alpha = 0.5, col = "navy") +
  tm_credits("Basemap (c) Mapbox, (c) OpenStreetMap",
    position = c("RIGHT", "BOTTOM")
  )

# ggplot2 usage:
ggplot() +
  layer_spatial(ny_tiles) +
  geom_sf(data = ny_tracts, fill = "navy", alpha = 0.5) +
  theme_void() +
  labs(caption = "Basemap (c) Mapbox, (c) OpenStreetMap")

## End(Not run)

</code></pre>

<hr>
<h2 id='get_style'>Get information about a style or list styles from a Mapbox account</h2><span id='topic+get_style'></span><span id='topic+list_styles'></span>

<h3>Description</h3>

<p>See the <a href="https://docs.mapbox.com/api/maps/styles/">Mapbox Styles API</a>
documentation for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_style(style_id, username, style_url = NULL, access_token = NULL)

list_styles(username, access_token = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_style_+3A_style_id">style_id</code></td>
<td>
<p>A style ID</p>
</td></tr>
<tr><td><code id="get_style_+3A_username">username</code></td>
<td>
<p>A Mapbox username</p>
</td></tr>
<tr><td><code id="get_style_+3A_style_url">style_url</code></td>
<td>
<p>A Mapbox style URL</p>
</td></tr>
<tr><td><code id="get_style_+3A_access_token">access_token</code></td>
<td>
<p>A Mapbox public or secret access token; set with
<code><a href="#topic+mb_access_token">mb_access_token()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+get_style">get_style</a> returns a list of information about your selected style.
<a href="#topic+list_styles">list_styles</a> returns a data frame of information about styles from a
Mapbox account
</p>

<hr>
<h2 id='get_vector_tiles'>Retrieve vector tiles from a given Mapbox tileset</h2><span id='topic+get_vector_tiles'></span>

<h3>Description</h3>

<p>Retrieve vector tiles from a given Mapbox tileset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_vector_tiles(tileset_id, location, zoom, access_token = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_vector_tiles_+3A_tileset_id">tileset_id</code></td>
<td>
<p>The name of the tileset ID; names can be retrieved from
your Mapbox account</p>
</td></tr>
<tr><td><code id="get_vector_tiles_+3A_location">location</code></td>
<td>
<p>The location for which you'd like to retrieve tiles. If the
input is an <code>sf</code> object, the function will return data for all tiles that
intersect the object's bounding box. If the input is a coordinate pair or
an address, data will be returned for the specific tile that contains the
input.</p>
</td></tr>
<tr><td><code id="get_vector_tiles_+3A_zoom">zoom</code></td>
<td>
<p>The zoom level of the request; larger zoom levels will return
more detail but will take longer to process.</p>
</td></tr>
<tr><td><code id="get_vector_tiles_+3A_access_token">access_token</code></td>
<td>
<p>A Mapbox access token; which can be set with
<code><a href="#topic+mb_access_token">mb_access_token()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>sf</code> objects representing the different layer types found
in the requested vector tiles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(mapboxapi)
library(ggplot2)

vector_extract &lt;- get_vector_tiles(
  tileset_id = "mapbox.mapbox-streets-v8",
  location = c(-73.99405, 40.72033),
  zoom = 15
)

ggplot(vector_extract$building$polygons) +
  geom_sf() +
  theme_void()

## End(Not run)

</code></pre>

<hr>
<h2 id='layer_static_mapbox'>Make a static Mapbox ggplot2 layer or tmap basemap</h2><span id='topic+layer_static_mapbox'></span><span id='topic+tm_static_mapbox'></span>

<h3>Description</h3>

<p>These functions wrap <code><a href="#topic+static_mapbox">static_mapbox()</a></code> and <code><a href="ggspatial.html#topic+layer_spatial">ggspatial::layer_spatial()</a></code> or
<code><a href="tmap.html#topic+tm_raster">tmap::tm_rgb()</a></code> to support the use of images from the <a href="https://www.mapbox.com/static-maps">Mapbox Static Maps API</a> as
<a href="https://ggplot2.tidyverse.org/">ggplot2</a> or
<a href="https://r-tmap.github.io/tmap/">tmap</a> basemaps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layer_static_mapbox(
  location = NULL,
  buffer_dist = 1000,
  units = "m",
  style_id,
  username,
  style_url = NULL,
  overlay_sf = NULL,
  overlay_style = NULL,
  overlay_markers = NULL,
  width = NULL,
  height = NULL,
  scale = 0.5,
  scaling_factor = c("1x", "2x"),
  attribution = TRUE,
  logo = TRUE,
  before_layer = NULL,
  access_token = NULL,
  ...
)

tm_static_mapbox(
  location = NULL,
  buffer_dist = 1000,
  units = "m",
  style_id,
  username,
  style_url = NULL,
  overlay_sf = NULL,
  overlay_style = NULL,
  overlay_markers = NULL,
  width = NULL,
  height = NULL,
  scale = 0.5,
  scaling_factor = c("1x", "2x"),
  attribution = TRUE,
  logo = TRUE,
  before_layer = NULL,
  access_token = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layer_static_mapbox_+3A_location">location</code></td>
<td>
<p>An input location for which you would like to request tiles.
Can be a length-4 vector representing a bounding box, or an <code>sf</code> object.
If an input <code>sf</code> object is supplied, use the <code>buffer_dist</code> argument to
control how much area you want to capture around the layer.
While the input <code>sf</code> object can be in an arbitrary coordinate reference system,
if a length-4 bounding box vector is supplied instead it must represent
WGS84 longitude/latitude coordinates and be in the order
<code>c(xmin, ymin, xmax, ymax)</code>.</p>
</td></tr>
<tr><td><code id="layer_static_mapbox_+3A_buffer_dist">buffer_dist</code></td>
<td>
<p>The distance to buffer around an input <code>sf</code> object for
determining static map, specified in units. If location is a POINT object
of 2 rows or less and <code>buffer_dist</code> is 0 or <code>NULL</code>, a 1 unit buffer is
applied to try to ensure the creation of a valid bounding box for the map
area.</p>
</td></tr>
<tr><td><code id="layer_static_mapbox_+3A_units">units</code></td>
<td>
<p>Units of <code>buffer_dist</code>; defaults to &quot;m&quot; (meters). If buffer_dist
is a units class object, the units argument is ignored.</p>
</td></tr>
<tr><td><code id="layer_static_mapbox_+3A_style_id">style_id</code></td>
<td>
<p>A style ID (required if style_url is <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="layer_static_mapbox_+3A_username">username</code></td>
<td>
<p>A Mapbox username (required if <code>style_url = NULL</code>).</p>
</td></tr>
<tr><td><code id="layer_static_mapbox_+3A_style_url">style_url</code></td>
<td>
<p>A Mapbox style url; defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="layer_static_mapbox_+3A_overlay_sf">overlay_sf</code></td>
<td>
<p>The overlay <code>sf</code> object (optional). The function will
convert the <code>sf</code> object to GeoJSON then plot over the basemap style.
Spatial data that are too large will trigger an error, and should be added
to the style in Mapbox Studio instead.</p>
</td></tr>
<tr><td><code id="layer_static_mapbox_+3A_overlay_style">overlay_style</code></td>
<td>
<p>A named list of vectors specifying how to style the sf
overlay. Possible names are &quot;stroke&quot;, &quot;stroke-width&quot; (or &quot;stroke_width&quot;),
&quot;stroke-opacity&quot; (or &quot;stroke_opacity&quot;), &quot;fill&quot;, and &quot;fill-opacity&quot; (or
&quot;fill_opacity&quot;). The fill and stroke color values can be specified as
six-digit hex codes or color names, and the opacity and width values should
be supplied as floating-point numbers. If overlay_style is <code>NULL</code>, the
style values can be pulled from columns with the same names in
<code>overlay_sf</code>.</p>
</td></tr>
<tr><td><code id="layer_static_mapbox_+3A_overlay_markers">overlay_markers</code></td>
<td>
<p>The prepared overlay markers (optional). See the
function <a href="#topic+prep_overlay_markers">prep_overlay_markers</a> for more information on how to specify a
marker overlay.</p>
</td></tr>
<tr><td><code id="layer_static_mapbox_+3A_width">width</code>, <code id="layer_static_mapbox_+3A_height">height</code></td>
<td>
<p>The map width and height; defaults to <code>NULL</code></p>
</td></tr>
<tr><td><code id="layer_static_mapbox_+3A_scale">scale</code></td>
<td>
<p>ratio to scale the output image; <code>scale = 1</code> will return the
largest possible image. defaults to 0.5</p>
</td></tr>
<tr><td><code id="layer_static_mapbox_+3A_scaling_factor">scaling_factor</code></td>
<td>
<p>The scaling factor of the tiles; either <code>"1x"</code>
(the default) or <code>"2x"</code></p>
</td></tr>
<tr><td><code id="layer_static_mapbox_+3A_attribution">attribution</code></td>
<td>
<p>Controls whether there is attribution on the image.
Defaults to <code>TRUE</code>. If <code>FALSE</code>, the watermarked attribution is removed from
the image. You still have a legal responsibility to attribute maps that use
OpenStreetMap data, which includes most maps from Mapbox. If you specify
<code>attribution = FALSE</code>, you are legally required to include proper
attribution elsewhere on the webpage or document.</p>
</td></tr>
<tr><td><code id="layer_static_mapbox_+3A_logo">logo</code></td>
<td>
<p>Controls whether there is a Mapbox logo on the image. Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="layer_static_mapbox_+3A_before_layer">before_layer</code></td>
<td>
<p>A character string that specifies where in the hierarchy
of layer elements the overlay should be inserted. The overlay will be
placed just above the specified layer in the given Mapbox styles. List
layer ids for a map style with <code>get_style(style_id = style_id, username = username, style_url = style_url, access_token = access_token)[["layers"]][["id"]]</code></p>
</td></tr>
<tr><td><code id="layer_static_mapbox_+3A_access_token">access_token</code></td>
<td>
<p>A Mapbox access token; which can be set with
<a href="#topic+mb_access_token">mb_access_token</a>.</p>
</td></tr>
<tr><td><code id="layer_static_mapbox_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <a href="ggspatial.html#topic+layer_spatial">ggspatial::layer_spatial</a> or <a href="tmap.html#topic+tm_raster">tmap::tm_rgb</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses a different approach than <code><a href="#topic+get_static_tiles">get_static_tiles()</a></code>. Instead,
<code><a href="#topic+layer_static_mapbox">layer_static_mapbox()</a></code> is based largely on <code>layer_mapbox()</code> in the snapbox package
(available under a <a href="https://github.com/anthonynorth/snapbox/blob/master/LICENSE">MIT license</a>. There
are a few key differences between <code><a href="#topic+layer_static_mapbox">layer_static_mapbox()</a></code> and
<code>layer_mapbox()</code>. The &quot;scale&quot; parameter is equivalent to the
&quot;scale_ratio&quot; parameter for snapbox. Setting <code>scale_factor = "2x"</code> is
equivalent to setting <code>retina = TRUE.</code> Both functions return basemaps that
are no larger than a single tile (a maximum of 1280 by 1280 pixels).
</p>
<p>For <code><a href="#topic+tm_static_mapbox">tm_static_mapbox()</a></code>, <a href="tmap.html#topic+tm_shape">tmap::tm_shape</a> is called with <code>projection = 3857</code> and
<a href="tmap.html#topic+tm_raster">tmap::tm_rgb</a> is called with <code>max.value = 1</code>.
</p>


<h3>Author(s)</h3>

<p>Eli Pousson, <a href="mailto:eli.pousson@gmail.com">eli.pousson@gmail.com</a>
</p>
<p>Anthony North, <a href="mailto:anthony.jl.north@gmail.com">anthony.jl.north@gmail.com</a>
</p>
<p>Miles McBain, <a href="mailto:miles.mcbain@gmail.com">miles.mcbain@gmail.com</a>
</p>

<hr>
<h2 id='mapboxGeocoderInput'>Use Mapbox's Geocoder widget in a Shiny application</h2><span id='topic+mapboxGeocoderInput'></span>

<h3>Description</h3>

<p>Use Mapbox's Geocoder widget in a Shiny application
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapboxGeocoderInput(
  inputId,
  access_token = NULL,
  placeholder = "Search",
  search_within = NULL,
  proximity = NULL,
  limit = 5,
  min_length = 2,
  language = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapboxGeocoderInput_+3A_inputid">inputId</code></td>
<td>
<p>The Shiny input ID</p>
</td></tr>
<tr><td><code id="mapboxGeocoderInput_+3A_access_token">access_token</code></td>
<td>
<p>The Mapbox access token (required); can be set with
<code><a href="#topic+mb_access_token">mb_access_token()</a></code></p>
</td></tr>
<tr><td><code id="mapboxGeocoderInput_+3A_placeholder">placeholder</code></td>
<td>
<p>The placeholder to be used in the search box; defaults to 'Search'</p>
</td></tr>
<tr><td><code id="mapboxGeocoderInput_+3A_search_within">search_within</code></td>
<td>
<p>An <code>sf</code> object, or vector representing a bounding box of
format <code>c(min_longitude, min_latitude, max_longitude, max_latitude)</code> used
to limit search results. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="mapboxGeocoderInput_+3A_proximity">proximity</code></td>
<td>
<p>A length-2 vector of longitude and latitude coordinates used to prioritize results near to that location.  Defaults to NULL.</p>
</td></tr>
<tr><td><code id="mapboxGeocoderInput_+3A_limit">limit</code></td>
<td>
<p>The maximum number of results to show.  Defaults to 5.</p>
</td></tr>
<tr><td><code id="mapboxGeocoderInput_+3A_min_length">min_length</code></td>
<td>
<p>The minimum number of characters the user must enter before results are shown.  Defaults to 2.</p>
</td></tr>
<tr><td><code id="mapboxGeocoderInput_+3A_language">language</code></td>
<td>
<p>The language to use for the geocoder.  Per the Mapbox documentation, &quot;Options are IETF language tags comprised of a mandatory ISO 639-1 language code and optionally one or more IETF subtags for country or script.&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Mapbox geocoder widget as a Shiny input
</p>

<hr>
<h2 id='mb_access_token'>Install or retrieve a Mapbox access token in your .Renviron for repeated use</h2><span id='topic+mb_access_token'></span><span id='topic+get_mb_access_token'></span><span id='topic+list_tokens'></span>

<h3>Description</h3>

<p>See the Mapbox API documentation for <a href="https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes">more information on access tokens and token scopes</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mb_access_token(token, overwrite = FALSE, install = FALSE)

get_mb_access_token(
  token = NULL,
  default = c("MAPBOX_PUBLIC_TOKEN", "MAPBOX_SECRET_TOKEN"),
  secret_required = FALSE
)

list_tokens(
  username,
  default = NULL,
  limit = NULL,
  sortby = "created",
  usage = NULL,
  access_token = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mb_access_token_+3A_token">token</code></td>
<td>
<p>A Mapbox access token; can be public (starting with 'pk') or
secret (starting with 'sk') scope, which the function will interpret for
you.</p>
</td></tr>
<tr><td><code id="mb_access_token_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether or not to overwrite an existing Mapbox access token.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mb_access_token_+3A_install">install</code></td>
<td>
<p>if <code>TRUE</code>, will install the key in your <code>.Renviron</code> file for use
in future sessions. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mb_access_token_+3A_default">default</code></td>
<td>
<p>If <code>TRUE</code>, will only include the default token for an account.
If <code>FALSE</code>, will include all other tokens except for the default. Defaults
to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mb_access_token_+3A_secret_required">secret_required</code></td>
<td>
<p>If <code>TRUE</code>, a secret token is required. If <code>FALSE</code>, the
default token is provided first and the other token provided second if the
first is unavailable.</p>
</td></tr>
<tr><td><code id="mb_access_token_+3A_username">username</code></td>
<td>
<p>The Mapbox username for which you'd like to list access
tokens.</p>
</td></tr>
<tr><td><code id="mb_access_token_+3A_limit">limit</code></td>
<td>
<p>The maximum number of tokens to return. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mb_access_token_+3A_sortby">sortby</code></td>
<td>
<p>How to sort the returned tokens; one of <code>"created"</code> or
<code>"modified"</code>.</p>
</td></tr>
<tr><td><code id="mb_access_token_+3A_usage">usage</code></td>
<td>
<p>If <code>"pk"</code>, returns only public tokens; if <code>"sk"</code>, returns only
secret tokens. Defaults to <code>NULL</code>, which returns all tokens in the scope of
the supplied access token.</p>
</td></tr>
<tr><td><code id="mb_access_token_+3A_access_token">access_token</code></td>
<td>
<p>Your Mapbox access token. If left <code>NULL</code>, will first check
to see if you have a secret token stored in .Renviron, then a public token.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble of information about tokens in your Mapbox account.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
my_token &lt;- "..." # The token generated from your Mapbox account
mb_access_token(my_token, install = TRUE)
Sys.getenv("MAPBOX_PUBLIC_TOKEN")

get_mb_access_token()

## End(Not run)
## Not run: 

token_list &lt;- list_tokens(
  username = "kwalkertcu", # You would use your own username here
  limit = 10,
  sortby = "modified" #'
)

## End(Not run)

</code></pre>

<hr>
<h2 id='mb_batch_geocode'>Geocode addresses or locations in bulk using the Mapbox Batch Geocoding API</h2><span id='topic+mb_batch_geocode'></span>

<h3>Description</h3>

<p>Geocode addresses or locations in bulk using the Mapbox Batch Geocoding API
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mb_batch_geocode(
  data,
  search_column = NULL,
  address_line1 = NULL,
  address_number = NULL,
  street = NULL,
  block = NULL,
  place = NULL,
  region = NULL,
  postcode = NULL,
  locality = NULL,
  neighborhood = NULL,
  country = NULL,
  permanent = FALSE,
  limit = 1,
  search_within = NULL,
  language = NULL,
  types = NULL,
  proximity = NULL,
  worldview = NULL,
  allow_large_job = FALSE,
  access_token = NULL,
  sf = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mb_batch_geocode_+3A_data">data</code></td>
<td>
<p>An input data frame</p>
</td></tr>
<tr><td><code id="mb_batch_geocode_+3A_search_column">search_column</code></td>
<td>
<p>A column that contains a description of the place to geocode, or a full address.  <code>search_column</code> cannot be used with address component arguments.</p>
</td></tr>
<tr><td><code id="mb_batch_geocode_+3A_address_line1">address_line1</code></td>
<td>
<p>The name of a column in <code>data</code> that contains the first line of an address, e.g. &quot;1600 Pennsylvania Ave NW&quot;</p>
</td></tr>
<tr><td><code id="mb_batch_geocode_+3A_address_number">address_number</code></td>
<td>
<p>The name of a column in <code>data</code> that contains the address number, e.g. &quot;1600&quot;.  Not required when <code>address_line1</code> is used.</p>
</td></tr>
<tr><td><code id="mb_batch_geocode_+3A_street">street</code></td>
<td>
<p>The name of a column in <code>data</code> that contains the street name, e.g. &quot;Pennsylvania Ave NW&quot;.  Not required when <code>address_line1</code> is used.</p>
</td></tr>
<tr><td><code id="mb_batch_geocode_+3A_block">block</code></td>
<td>
<p>The name of a column in <code>data</code> that describes the block, used in some Japanese addresses.</p>
</td></tr>
<tr><td><code id="mb_batch_geocode_+3A_place">place</code></td>
<td>
<p>The name of a column in <code>data</code> that contains the place name; typically a city, village, or municipality, e.g. &quot;Washington&quot;</p>
</td></tr>
<tr><td><code id="mb_batch_geocode_+3A_region">region</code></td>
<td>
<p>The name of a column in <code>data</code> that represents sub-national administrative features, such as states in Mexico or the United States.  Example: &quot;DC&quot;</p>
</td></tr>
<tr><td><code id="mb_batch_geocode_+3A_postcode">postcode</code></td>
<td>
<p>The name of a column in <code>data</code> representing the postal code of the address; this will be a ZIP code in the United States, e.g. &quot;20500&quot;</p>
</td></tr>
<tr><td><code id="mb_batch_geocode_+3A_locality">locality</code></td>
<td>
<p>The name of a column in <code>data</code> that describes official sub-city locations, such as arrondissements in France.</p>
</td></tr>
<tr><td><code id="mb_batch_geocode_+3A_neighborhood">neighborhood</code></td>
<td>
<p>The name of a column in <code>data</code> that represents a colloquial neighborhood name for the location.</p>
</td></tr>
<tr><td><code id="mb_batch_geocode_+3A_country">country</code></td>
<td>
<p>A character string or vector of ISO 3166 alpha-2 country codes within which you would like to limit your search.</p>
</td></tr>
<tr><td><code id="mb_batch_geocode_+3A_permanent">permanent</code></td>
<td>
<p>Either FALSE (the default) when results are not intended to be stored, or TRUE if the results are planned to be stored.</p>
</td></tr>
<tr><td><code id="mb_batch_geocode_+3A_limit">limit</code></td>
<td>
<p>How many results to return per address.  This is not currently accessible for users and can only be 1.</p>
</td></tr>
<tr><td><code id="mb_batch_geocode_+3A_search_within">search_within</code></td>
<td>
<p>An <code>sf</code> object, or vector representing a bounding box of
format <code>c(min_longitude, min_latitude, max_longitude, max_latitude)</code> used
to limit search results. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="mb_batch_geocode_+3A_language">language</code></td>
<td>
<p>The user's language, which can help with interpretation of
queries. Available languages are found at
<a href="https://docs.mapbox.com/api/search/#language-coverage">https://docs.mapbox.com/api/search/#language-coverage</a>.</p>
</td></tr>
<tr><td><code id="mb_batch_geocode_+3A_types">types</code></td>
<td>
<p>A vector of feature types to limit to which the search should be
limited. Available options include <code>'country'</code>, <code>'region'</code>, <code>'postcode'</code>,
<code>'district'</code>, <code>'place'</code>, <code>'locality'</code>, <code>'neighborhood'</code>, <code>'address'</code>, <code>street</code>, <code>block</code>, <code>address</code>. and <code>'secondary_address'</code>. If left blank, all types will be searched.</p>
</td></tr>
<tr><td><code id="mb_batch_geocode_+3A_proximity">proximity</code></td>
<td>
<p>proximity Either a vector of coordinates or an IP address string to bias the results to favor locations near to the input location.</p>
</td></tr>
<tr><td><code id="mb_batch_geocode_+3A_worldview">worldview</code></td>
<td>
<p>Returns features intended for different regional or cultural groups.  The US (<code>'us'</code>) world view is returned by default.</p>
</td></tr>
<tr><td><code id="mb_batch_geocode_+3A_allow_large_job">allow_large_job</code></td>
<td>
<p>A boolean indicating that the user is OK with potential charges incurred to their account due to a large geocoding job (over 1000 addresses).  The Mapbox Free Tier includes 100,000 free geocodes per month.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mb_batch_geocode_+3A_access_token">access_token</code></td>
<td>
<p>The Mapbox access token (required); can be set with
<code><a href="#topic+mb_access_token">mb_access_token()</a></code></p>
</td></tr>
<tr><td><code id="mb_batch_geocode_+3A_sf">sf</code></td>
<td>
<p>A boolean that determines whether the output will be an sf POINT object (<code>TRUE</code>, the default) or a regular data frame (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataset as an sf POINT object representing the geocoded locations, or the input dataset with longitude, latitude, and matched address columns included.
</p>

<hr>
<h2 id='mb_directions'>Make a request to the Mapbox Directions API</h2><span id='topic+mb_directions'></span>

<h3>Description</h3>

<p>See the <a href="https://docs.mapbox.com/api/navigation/directions/">Mapbox Directions API documentation</a> for more
information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mb_directions(
  input_data = NULL,
  origin = NULL,
  destination = NULL,
  profile = "driving",
  output = "sf",
  depart_at = NULL,
  alternatives = NULL,
  annotations = NULL,
  bearings = NULL,
  continue_straight = NULL,
  exclude = NULL,
  geometries = "geojson",
  overview = "simplified",
  radiuses = NULL,
  approaches = NULL,
  steps = NULL,
  banner_instructions = NULL,
  language = NULL,
  roundabout_exits = NULL,
  voice_instructions = NULL,
  voice_units = NULL,
  waypoint_names = NULL,
  waypoint_targets = NULL,
  waypoints = NULL,
  walking_speed = NULL,
  walkway_bias = NULL,
  alley_bias = NULL,
  access_token = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mb_directions_+3A_input_data">input_data</code></td>
<td>
<p>An input dataset of class <code>"sf"</code>, or a list of coordinate
pairs for format <code>c(longitude, latitude)</code>. Cannot be used with an
origin/destination pair.</p>
</td></tr>
<tr><td><code id="mb_directions_+3A_origin">origin</code></td>
<td>
<p>An address or coordinate pair that represents the origin of
your requested route. Cannot be used with <code>input_data</code>.</p>
</td></tr>
<tr><td><code id="mb_directions_+3A_destination">destination</code></td>
<td>
<p>An address or coordinate pair that represents the
destination of your requested route.</p>
</td></tr>
<tr><td><code id="mb_directions_+3A_profile">profile</code></td>
<td>
<p>One of &quot;driving&quot; (the default), &quot;driving-traffic&quot;, &quot;walking&quot;,
or &quot;cycling&quot;.</p>
</td></tr>
<tr><td><code id="mb_directions_+3A_output">output</code></td>
<td>
<p>One of &quot;sf&quot; (the default), which returns an sf LINESTRING
representing the route geometry, or &quot;full&quot;, which returns the full request
from the Directions API as a list.</p>
</td></tr>
<tr><td><code id="mb_directions_+3A_depart_at">depart_at</code></td>
<td>
<p>(optional) For the &quot;driving&quot; or &quot;driving-traffic&quot; profiles,
the departure date and time to reflect historical traffic patterns. If
&quot;driving-traffic&quot; is used, live traffic will be mixed in with historical
traffic for dates/times near to the current time. Should be specified as an
ISO 8601 date/time, e.g. <code>"2022-03-31T09:00"</code>.</p>
</td></tr>
<tr><td><code id="mb_directions_+3A_alternatives">alternatives</code></td>
<td>
<p>Whether or not to return alternative routes with your
request. If TRUE, a list of up to 3 possible routes will be returned.</p>
</td></tr>
<tr><td><code id="mb_directions_+3A_annotations">annotations</code></td>
<td>
<p>A comma-separated string of additional route metadata,
which may include duration, distance, speed, and congestion. Must be used
with overview = &quot;full&quot;.</p>
</td></tr>
<tr><td><code id="mb_directions_+3A_bearings">bearings</code></td>
<td>
<p>A semicolon-delimited character string of bearings</p>
</td></tr>
<tr><td><code id="mb_directions_+3A_continue_straight">continue_straight</code></td>
<td>
<p>continue_straight</p>
</td></tr>
<tr><td><code id="mb_directions_+3A_exclude">exclude</code></td>
<td>
<p>Road types to exclude from your route; possible choices are
<code>'toll'</code>, <code>'motorway'</code>, or <code>'ferry'</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mb_directions_+3A_geometries">geometries</code></td>
<td>
<p>The route geometry format. If <code>output = 'sf'</code>, you will get
back an <code>sf</code> object and you should leave this blank. If <code>output = 'full'</code>,
the embedded route geometries will be one of <code>'geojson'</code> (the default),
<code>'polyline'</code> with five decimal place precision, or <code>'polyline6'</code>.</p>
</td></tr>
<tr><td><code id="mb_directions_+3A_overview">overview</code></td>
<td>
<p>If left blank, defaults to <code>'simplified'</code> for simplified
geometry; the other option is <code>'full'</code> which provides the most detailed
geometry available.</p>
</td></tr>
<tr><td><code id="mb_directions_+3A_radiuses">radiuses</code></td>
<td>
<p>A character string with semicolon-separated radii that
specify the distance (in meters) to snap each input coordinate to the road
network. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mb_directions_+3A_approaches">approaches</code></td>
<td>
<p>A character string with semicolon-separated specifications
for how to approach waypoints. Options include <code>unrestricted</code> and <code>curb</code>.
Defaults to <code>NULL</code> which uses <code>unrestricted</code> for all waypoints.</p>
</td></tr>
<tr><td><code id="mb_directions_+3A_steps">steps</code></td>
<td>
<p>If <code>TRUE</code>, returns the route object split up into route legs
with step-by-step instructions included. If <code>FALSE</code> or <code>NULL</code> (the
default), a single line geometry representing the full route will be
returned.</p>
</td></tr>
<tr><td><code id="mb_directions_+3A_banner_instructions">banner_instructions</code></td>
<td>
<p>Whether or not to return banner objects; only
available when<code>output = 'full'</code> and <code>steps = TRUE</code>.</p>
</td></tr>
<tr><td><code id="mb_directions_+3A_language">language</code></td>
<td>
<p>The language of the returned instructions (defaults to
English). Available language codes are found at
<a href="https://docs.mapbox.com/api/navigation/#instructions-languages">https://docs.mapbox.com/api/navigation/#instructions-languages</a>. Only
available when <code>steps = TRUE</code>.</p>
</td></tr>
<tr><td><code id="mb_directions_+3A_roundabout_exits">roundabout_exits</code></td>
<td>
<p>If TRUE, adds instructions for roundabout entrance
and exit. Only available when <code>steps = TRUE</code>.</p>
</td></tr>
<tr><td><code id="mb_directions_+3A_voice_instructions">voice_instructions</code>, <code id="mb_directions_+3A_voice_units">voice_units</code></td>
<td>
<p>Only available when <code>steps = TRUE</code> and
<code>output = 'full'</code>.</p>
</td></tr>
<tr><td><code id="mb_directions_+3A_waypoint_names">waypoint_names</code>, <code id="mb_directions_+3A_waypoint_targets">waypoint_targets</code>, <code id="mb_directions_+3A_waypoints">waypoints</code></td>
<td>
<p>Only available when <code>steps = TRUE</code> and <code>output = 'full'</code>.</p>
</td></tr>
<tr><td><code id="mb_directions_+3A_walking_speed">walking_speed</code></td>
<td>
<p>The walking speed in meters/second; available when
<code>profile = 'walking'</code>.</p>
</td></tr>
<tr><td><code id="mb_directions_+3A_walkway_bias">walkway_bias</code></td>
<td>
<p>Can take values between -1 and 1, where negative numbers
avoid walkways and positive numbers prefer walkways. Available when
<code>profile = 'walking'</code>.</p>
</td></tr>
<tr><td><code id="mb_directions_+3A_alley_bias">alley_bias</code></td>
<td>
<p>Can take values between -1 and 1, where negative numbers
avoid alleys and positive numbers prefer alleys. Available when <code>profile = 'walking'</code>.</p>
</td></tr>
<tr><td><code id="mb_directions_+3A_access_token">access_token</code></td>
<td>
<p>A Mapbox access token; which can be set with
<code><a href="#topic+mb_access_token">mb_access_token()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>sf</code> object (or list of <code>sf</code> objects), or full R list representing
the API response.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(mapboxapi)
library(leaflet)

my_route &lt;- mb_directions(
  origin = "10 Avenue de Wagram, 75008 Paris France",
  destination = "59 Rue de Tocqueville, 75017 Paris France",
  profile = "cycling",
  steps = TRUE,
  language = "fr"
)

leaflet(my_route) %&gt;%
  addMapboxTiles(
    style_id = "light-v9",
    username = "mapbox"
  ) %&gt;%
  addPolylines()

## End(Not run)
</code></pre>

<hr>
<h2 id='mb_geocode'>Geocode an address or place description using the Mapbox Geocoding API</h2><span id='topic+mb_geocode'></span><span id='topic+mb_reverse_geocode'></span>

<h3>Description</h3>

<p>See the <a href="https://docs.mapbox.com/api/search/geocoding/">Mapbox Geocoding API documentation</a> for more
information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mb_geocode(
  search_text = NULL,
  structured_input = NULL,
  permanent = FALSE,
  autocomplete = TRUE,
  limit = 1,
  types = NULL,
  search_within = NULL,
  language = NULL,
  country = NULL,
  proximity = NULL,
  worldview = NULL,
  output = "coordinates",
  access_token = NULL
)

mb_reverse_geocode(
  coordinates,
  permanent = FALSE,
  limit = 1,
  language = NULL,
  types = NULL,
  country = NULL,
  worldview = NULL,
  output = "text",
  access_token = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mb_geocode_+3A_search_text">search_text</code></td>
<td>
<p>The text to search, formatted as a character string. Can
be an address, a location, or a description of a point of interest.</p>
</td></tr>
<tr><td><code id="mb_geocode_+3A_structured_input">structured_input</code></td>
<td>
<p>A named list of structured address inputs, to be used in place of <code>search_text</code> when more formal address inputs are desired.  Available parameters, to be used as the names of list elements, include 'address_line1', 'address_number', 'street', 'block', 'place', 'region', 'locality', 'neighborhood', and 'country'.  See here for more documentation: <a href="https://docs.mapbox.com/api/search/geocoding/#forward-geocoding-with-structured-input">https://docs.mapbox.com/api/search/geocoding/#forward-geocoding-with-structured-input</a>.</p>
</td></tr>
<tr><td><code id="mb_geocode_+3A_permanent">permanent</code></td>
<td>
<p>Either FALSE (the default) when results are not intended to be stored, or TRUE if the results are planned to be stored.</p>
</td></tr>
<tr><td><code id="mb_geocode_+3A_autocomplete">autocomplete</code></td>
<td>
<p>Whether or not to return autocomplete results.  Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="mb_geocode_+3A_limit">limit</code></td>
<td>
<p>How many results to return; defaults to 1 (maximum 10).</p>
</td></tr>
<tr><td><code id="mb_geocode_+3A_types">types</code></td>
<td>
<p>A vector of feature types to limit to which the search should be
limited. Available options include <code>'country'</code>, <code>'region'</code>, <code>'postcode'</code>,
<code>'district'</code>, <code>'place'</code>, <code>'locality'</code>, <code>'neighborhood'</code>, <code>'address'</code>, <code>street</code>, <code>block</code>, <code>address</code>. and <code>'secondary_address'</code>. If left blank, all types will be searched.</p>
</td></tr>
<tr><td><code id="mb_geocode_+3A_search_within">search_within</code></td>
<td>
<p>An <code>sf</code> object, or vector representing a bounding box of
format <code>c(min_longitude, min_latitude, max_longitude, max_latitude)</code> used
to limit search results. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="mb_geocode_+3A_language">language</code></td>
<td>
<p>The user's language, which can help with interpretation of
queries. Available languages are found at
<a href="https://docs.mapbox.com/api/search/#language-coverage">https://docs.mapbox.com/api/search/#language-coverage</a>.</p>
</td></tr>
<tr><td><code id="mb_geocode_+3A_country">country</code></td>
<td>
<p>A character string or vector of ISO 3166 alpha-2 country codes within which you would like to limit your search.</p>
</td></tr>
<tr><td><code id="mb_geocode_+3A_proximity">proximity</code></td>
<td>
<p>Either a vector of coordinates or an IP address string to bias the results to favor locations near to the input location.</p>
</td></tr>
<tr><td><code id="mb_geocode_+3A_worldview">worldview</code></td>
<td>
<p>Returns features intended for different regional or cultural groups.  The US (<code>'us'</code>) world view is returned by default.</p>
</td></tr>
<tr><td><code id="mb_geocode_+3A_output">output</code></td>
<td>
<p>one of <code>"text"</code> (the default), which will return a character
string or list of character strings representing the returned results;
<code>output = "sf"</code>, returning an <code>sf</code> object; or <code>"full"</code>, which will return a
list with the full API response.</p>
</td></tr>
<tr><td><code id="mb_geocode_+3A_access_token">access_token</code></td>
<td>
<p>The Mapbox access token (required); can be set with
<code><a href="#topic+mb_access_token">mb_access_token()</a></code></p>
</td></tr>
<tr><td><code id="mb_geocode_+3A_coordinates">coordinates</code></td>
<td>
<p>The coordinates of a location in format <code>c(longitude, latitude)</code> for which you'd like to return information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector, list, or <code>sf</code> object representing the query
results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

whitehouse &lt;- mb_geocode("1600 Pennsylvania Ave, Washington DC")

## End(Not run)

## Not run: 

mb_reverse_geocode(c(77.5958768, 12.9667046), limit = 5, types = "address")

## End(Not run)

</code></pre>

<hr>
<h2 id='mb_isochrone'>Generate isochrones using the Mapbox Navigation Service Isochrone API</h2><span id='topic+mb_isochrone'></span>

<h3>Description</h3>

<p>This function returns isochrones from the Mapbox Navigation Service
<a href="https://docs.mapbox.com/api/navigation/isochrone/">Isochrone API</a>. Isochrones are
shapes that represent the reachable area around one or more locations within
a given travel time. Isochrones can be computed for driving, walking, or
cycling routing profiles, and can optionally be set to return distances
rather than times. <code><a href="#topic+mb_isochrone">mb_isochrone()</a></code> returns isochrones as simple
features objects in the WGS 1984 geographic coordinate system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mb_isochrone(
  location,
  profile = "driving",
  time = c(5, 10, 15),
  distance = NULL,
  depart_at = NULL,
  access_token = NULL,
  denoise = 1,
  generalize = NULL,
  geometry = "polygon",
  output = "sf",
  rate_limit = 300,
  keep_color_cols = FALSE,
  id_column = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mb_isochrone_+3A_location">location</code></td>
<td>
<p>A vector of form <code>c(longitude, latitude)</code>, an address that can be geocoded as a character string, or an <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="mb_isochrone_+3A_profile">profile</code></td>
<td>
<p>One of &quot;driving&quot;, &quot;walking&quot;, &quot;cycling&quot;, or &quot;driving-traffic&quot;.
&quot;driving&quot; is the default.</p>
</td></tr>
<tr><td><code id="mb_isochrone_+3A_time">time</code></td>
<td>
<p>A vector of isochrone contours, specified in minutes. Defaults to <code>c(5, 10, 15)</code>. The maximum time supported is 60 minutes. Reflects traffic conditions for the date and time at which the function is called. If reproducibility of isochrones is required, supply an argument to the <code>depart_at</code> parameter.</p>
</td></tr>
<tr><td><code id="mb_isochrone_+3A_distance">distance</code></td>
<td>
<p>A vector of distance contours specified in meters. If supplied, will supercede
any call to the <code>time</code> parameter as time and distance cannot be used
simultaneously. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mb_isochrone_+3A_depart_at">depart_at</code></td>
<td>
<p>(optional) For the &quot;driving&quot; or &quot;driving-traffic&quot; profiles, the departure date and time to reflect historical traffic patterns. If &quot;driving-traffic&quot; is used, live traffic will be mixed in with historical traffic for dates/times near to the current time. Should be specified as an ISO 8601 date/time, e.g. <code>"2022-03-31T09:00"</code>. If <code>NULL</code> (the default), isochrones will reflect traffic conditions at the date and time when the function is called.</p>
</td></tr>
<tr><td><code id="mb_isochrone_+3A_access_token">access_token</code></td>
<td>
<p>A valid Mapbox access token.</p>
</td></tr>
<tr><td><code id="mb_isochrone_+3A_denoise">denoise</code></td>
<td>
<p>A floating-point value between 0 and 1 used to remove smaller contours. 1 is the default and returns only the largest contour for an input time.</p>
</td></tr>
<tr><td><code id="mb_isochrone_+3A_generalize">generalize</code></td>
<td>
<p>A value expressed in meters of the tolerance for the Douglas-Peucker generalization algorithm used to simplify the isochrone shapes. If <code>NULL</code> (the default), the Mapbox API will choose an optimal value for you.</p>
</td></tr>
<tr><td><code id="mb_isochrone_+3A_geometry">geometry</code></td>
<td>
<p>one of <code>"polygon"</code> (the default), which returns isochrones as polygons, or alternatively <code>"linestring"</code>, which returns isochrones as linestrings.</p>
</td></tr>
<tr><td><code id="mb_isochrone_+3A_output">output</code></td>
<td>
<p>one of <code>"sf"</code> (the default), which returns an <code>sf</code> object representing the isochrone(s), or <code>"list"</code>, which returns the GeoJSON response from the API as an R list.</p>
</td></tr>
<tr><td><code id="mb_isochrone_+3A_rate_limit">rate_limit</code></td>
<td>
<p>The rate limit for the API, expressed in maximum number of calls per minute. For most users this will be 300 though this parameter can be modified based on your Mapbox plan. Used when <code>location</code> is <code>"sf"</code>.</p>
</td></tr>
<tr><td><code id="mb_isochrone_+3A_keep_color_cols">keep_color_cols</code></td>
<td>
<p>Whether or not to retain the color columns that the Mapbox API generates by default (applies when the output is an <code>sf</code> object). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mb_isochrone_+3A_id_column">id_column</code></td>
<td>
<p>If the input dataset is an <code>sf</code> object, the column in your dataset you want to use as the isochrone ID. Otherwise, isochrone IDs will be identified by row index or position.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>sf</code> object representing the isochrone(s) around the location(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(mapboxapi)
library(mapdeck)
isochrones &lt;- mb_isochrone("The Kremlin, Moscow Russia",
  time = c(4, 8, 12),
  profile = "walking"
)

mapdeck(style = mapdeck_style("light")) %&gt;%
  add_polygon(
    data = isochrones,
    fill_colour = "time",
    fill_opacity = 0.5,
    legend = TRUE
  )

## End(Not run)

</code></pre>

<hr>
<h2 id='mb_matrix'>Retrieve a matrix of travel times from the Mapbox Directions API</h2><span id='topic+mb_matrix'></span>

<h3>Description</h3>

<p>Retrieve a matrix of travel times from the Mapbox Directions API
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mb_matrix(
  origins,
  destinations = NULL,
  profile = "driving",
  fallback_speed = NULL,
  output = c("duration", "distance"),
  duration_output = c("minutes", "seconds"),
  access_token = NULL,
  depart_at = NULL,
  allow_large_matrix = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mb_matrix_+3A_origins">origins</code></td>
<td>
<p>The input coordinates of your request. Acceptable inputs include a list of
coordinate pair vectors in <code>c(x, y)</code> format or an <code>sf</code> object.
For sf linestrings or polygons, the distance between centroids will be taken.</p>
</td></tr>
<tr><td><code id="mb_matrix_+3A_destinations">destinations</code></td>
<td>
<p>The destination coordinates of your request. If <code>NULL</code> (the default), a many-to-many matrix using <code>origins</code> will be returned.</p>
</td></tr>
<tr><td><code id="mb_matrix_+3A_profile">profile</code></td>
<td>
<p>One of &quot;driving&quot; (the default), &quot;driving-traffic&quot;, &quot;walking&quot;, or &quot;cycling&quot;.</p>
</td></tr>
<tr><td><code id="mb_matrix_+3A_fallback_speed">fallback_speed</code></td>
<td>
<p>A value expressed in kilometers per hour used to estimate travel time when a route cannot be found between locations. The returned travel time will be based on the straight-line estimate of travel between the locations at the specified fallback speed.</p>
</td></tr>
<tr><td><code id="mb_matrix_+3A_output">output</code></td>
<td>
<p>one of <code>"duration"</code> (the default), which will be measured in either minutes or seconds (depending on the value of <code>duration_output</code>), or <code>"distance"</code>, which will be returned in meters.</p>
</td></tr>
<tr><td><code id="mb_matrix_+3A_duration_output">duration_output</code></td>
<td>
<p>one of <code>"minutes"</code> (the default) or <code>"seconds"</code></p>
</td></tr>
<tr><td><code id="mb_matrix_+3A_access_token">access_token</code></td>
<td>
<p>A Mapbox access token (required)</p>
</td></tr>
<tr><td><code id="mb_matrix_+3A_depart_at">depart_at</code></td>
<td>
<p>(optional) For the &quot;driving&quot; or &quot;driving-traffic&quot; profiles, the departure date and time to reflect historical traffic patterns. If &quot;driving-traffic&quot; is used, live traffic will be mixed in with historical traffic for dates/times near to the current time. Should be specified as an ISO 8601 date/time, e.g. <code>"2023-03-31T09:00"</code>. The time must be set to the current time or in the future.</p>
</td></tr>
<tr><td><code id="mb_matrix_+3A_allow_large_matrix">allow_large_matrix</code></td>
<td>
<p><code>mb_matrix()</code> will prevent the user from calculating large travel-time matrices (greater than 25x25) by default, as they may lead to unexpected charges.  If the user sets this argument to <code>TRUE</code>, <code>mb_matrix()</code> will bypass this error and calculate the large matrix for the user.  Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R matrix of source-destination travel times.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(mapboxapi)
library(tigris)
library(mapdeck)

philly_tracts &lt;- tracts("PA", "Philadelphia", cb = TRUE, class = "sf")
downtown_philly &lt;- mb_geocode("Philadelphia City Hall, Philadelphia PA")

time_to_downtown &lt;- mb_matrix(philly_tracts, downtown_philly)

philly_tracts$time &lt;- time_to_downtown

mapdeck(style = mapdeck_style("light")) %&gt;%
  add_polygon(
    data = philly_tracts,
    fill_colour = "time",
    fill_opacity = 0.6,
    legend = TRUE
  )

## End(Not run)

</code></pre>

<hr>
<h2 id='mb_optimized_route'>Return an optimized route for a series of input coordinates</h2><span id='topic+mb_optimized_route'></span>

<h3>Description</h3>

<p>Return an optimized route for a series of input coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mb_optimized_route(
  input_data,
  profile = c("driving", "walking", "cycling", "driving-traffic"),
  output = "sf",
  source = c("any", "first"),
  destination = c("any", "last"),
  roundtrip = TRUE,
  annotations = NULL,
  approaches = NULL,
  bearings = NULL,
  distributions = NULL,
  language = NULL,
  overview = "simplified",
  radiuses = NULL,
  steps = NULL,
  access_token = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mb_optimized_route_+3A_input_data">input_data</code></td>
<td>
<p>An input dataset of class <code>"sf"</code>, or a list of coordinate
pairs of format <code>c(longitude, latitude)</code>. Must be between 2 and 12
coordinate pairs.</p>
</td></tr>
<tr><td><code id="mb_optimized_route_+3A_profile">profile</code></td>
<td>
<p>One of &quot;driving&quot; (the default), &quot;driving-traffic&quot;, &quot;walking&quot;,
or &quot;cycling&quot;.</p>
</td></tr>
<tr><td><code id="mb_optimized_route_+3A_output">output</code></td>
<td>
<p>One of &quot;sf&quot; (the default), which returns an <code>sf</code> LINESTRING
representing the route geometry, or &quot;full&quot;, which returns the full request
from the Directions API as a list.</p>
</td></tr>
<tr><td><code id="mb_optimized_route_+3A_source">source</code></td>
<td>
<p>One of <code>"any"</code> (the default) or <code>"first"</code>. If &quot;any&quot; is
specified, any of the input coordinates may be used as the starting point.
If &quot;first&quot; is specified, the first coordinate will be used.</p>
</td></tr>
<tr><td><code id="mb_optimized_route_+3A_destination">destination</code></td>
<td>
<p>One of <code>"any"</code> (the default) or <code>"last"</code>. If &quot;any&quot; is
specified, any of the input coordinates may be used as the ending point. If
&quot;last&quot; is specified, the last coordinate will be used.</p>
</td></tr>
<tr><td><code id="mb_optimized_route_+3A_roundtrip">roundtrip</code></td>
<td>
<p>If <code>TRUE</code> (the default), the route will start and end at the
same point. <code>roundtrip = FALSE</code> only works when <code>source</code> is <code>"first"</code> and
<code>destination</code> is <code>"last"</code>. If <code>FALSE</code> is supplied here, the route will
start at the first point in <code>input_data</code> and end at the last point.</p>
</td></tr>
<tr><td><code id="mb_optimized_route_+3A_annotations">annotations</code></td>
<td>
<p>A comma-separated string of additional route metadata,
which may include duration, distance, speed, and congestion. Must be used
with <code>overview = "full"</code>.</p>
</td></tr>
<tr><td><code id="mb_optimized_route_+3A_approaches">approaches</code></td>
<td>
<p>A character string with semicolon-separated specifications
for how to approach waypoints. Options include <code>unrestricted</code> and <code>curb</code>.
Defaults to NULL which uses <code>unrestricted</code> for all waypoints.</p>
</td></tr>
<tr><td><code id="mb_optimized_route_+3A_bearings">bearings</code></td>
<td>
<p>A semicolon-delimited character string of bearings.</p>
</td></tr>
<tr><td><code id="mb_optimized_route_+3A_distributions">distributions</code></td>
<td>
<p>A semicolon-delimited character string of number pairs
that specifies pick-up and drop-off locations. The first number indicates
the index of the pick-up location, and the second number represents the
index of the drop-off location.</p>
</td></tr>
<tr><td><code id="mb_optimized_route_+3A_language">language</code></td>
<td>
<p>The language of the returned instructions (defaults to
English). Available language codes are found at
<a href="https://docs.mapbox.com/api/navigation/#instructions-languages">https://docs.mapbox.com/api/navigation/#instructions-languages</a>. Only
available when <code>steps = TRUE</code>.</p>
</td></tr>
<tr><td><code id="mb_optimized_route_+3A_overview">overview</code></td>
<td>
<p>If left blank, defaults to <code>'simplified'</code> for simplified
geometry; the other option is <code>'full'</code> which provides the most detailed
geometry available.</p>
</td></tr>
<tr><td><code id="mb_optimized_route_+3A_radiuses">radiuses</code></td>
<td>
<p>A character string with semicolon-separated radii that
specify the distance (in meters) to snap each input coordinate to the road
network. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mb_optimized_route_+3A_steps">steps</code></td>
<td>
<p>If <code>TRUE</code>, returns the route object split up into route legs
with step-by-step instructions included. If <code>FALSE</code> or <code>NULL</code> (the default), a
single line geometry representing the full route will be returned.</p>
</td></tr>
<tr><td><code id="mb_optimized_route_+3A_access_token">access_token</code></td>
<td>
<p>Your Mapbox access token; which can be set with
<code><a href="#topic+mb_access_token">mb_access_token()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a list of two <code>sf</code> objects - one representing the waypoints, and one representing the route - or an R list representing the full optimization API response.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(mapboxapi)
library(sf)

to_visit &lt;- data.frame(
  X = c(-0.209307, -0.185875, -0.216877, -0.233511, -0.234541),
  Y = c(5.556019, 5.58031, 5.582528, 5.566771, 5.550209)
) %&gt;%
  st_as_sf(coords = c("X", "Y"), crs = 4326)

optimized_route &lt;- mb_optimized_route(to_visit,
  profile = "driving-traffic"
)

## End(Not run)

</code></pre>

<hr>
<h2 id='mts_create_source'>Create a Mapbox tileset source from a sf object using the Mapbox Tiling Service API</h2><span id='topic+mts_create_source'></span>

<h3>Description</h3>

<p>The <code>mts_create_source()</code> function can be used to create a tileset source or append to an existing tileset source.  This function publishes a simple features object you've created in R to your Mapbox account, where it is stored as line-delimited GeoJSON. A tileset source is required to create a vector tileset, and the same source can be used across multiple tilesets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mts_create_source(data, tileset_id, username, access_token = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_create_source_+3A_data">data</code></td>
<td>
<p>An input simple features object</p>
</td></tr>
<tr><td><code id="mts_create_source_+3A_tileset_id">tileset_id</code></td>
<td>
<p>The tileset ID. If the tileset ID already exists in your Mapbox account, this function will overwrite the existing source with a new source.</p>
</td></tr>
<tr><td><code id="mts_create_source_+3A_username">username</code></td>
<td>
<p>Your Mapbox username</p>
</td></tr>
<tr><td><code id="mts_create_source_+3A_access_token">access_token</code></td>
<td>
<p>Your Mapbox access token with secret scope. Install with <code>mb_access_token()</code> after you retrieve it from your Mapbox account.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the MTS API's responses, including the name of the tileset source in your Mapbox account.  You'll use this name to build a MTS recipe.
</p>


<h3>See Also</h3>

<p><a href="https://docs.mapbox.com/api/maps/mapbox-tiling-service/#create-a-tileset-source">https://docs.mapbox.com/api/maps/mapbox-tiling-service/#create-a-tileset-source</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(tidycensus)
library(mapboxapi)
options(tigris_use_cache = TRUE)

# Get the national data on median age
us_median_age_tract &lt;- get_acs(
  geography = "tract",
  variables = "B01002_001",
  state = c(state.abb, "DC"),
  year = 2020,
  geometry = TRUE
)

# Get it for counties as well
us_median_age_county &lt;- get_acs(
  geography = "county",
  variables = "B01002_001",
  year = 2020,
  geometry = TRUE
)

# Create a source from the datasets
mts_create_source(data = us_median_age_tract,
                  tileset_id = "us_median_age_tract",
                  username = "your_mapbox_username")

mts_create_source(data = us_median_age_county,
                  tileset_id = "us_median_age_county",
                  username = "your_mapbox_username")

# Build out the recipe.  First, create a recipe layer with
# appropriate options.  We'll want a larger tile size and to restrict the minzoom
# to 4; a maxzoom of 12 will be fine as we can overzoom beyond that
#
# Your source ID will be returned by `mts_create_source()`, so use that value
tract_layer &lt;- recipe_layer(
  source = "mapbox://tileset-source/your_mapbox_username/us_median_age_tract",
  minzoom = 4,
  maxzoom = 12,
  tiles = tile_options(layer_size = 2500)
)

county_layer &lt;- recipe_layer(
  source = "mapbox://tileset-source/your_mapbox_username/us_median_age_county",
  minzoom = 2,
  maxzoom = 5
)

recipe &lt;- mts_make_recipe(tracts = tract_layer, counties = county_layer)

# Validate the recipe
mts_validate_recipe(recipe)

# Create a tileset from the recipe
mts_create_tileset(tileset_name = "median_age_acs",
                   username = "your_mapbox_username",
                   recipe = recipe)

# Publish the tileset
mts_publish_tileset(tileset_name = "median_age_acs",
                    username = "your_mapbox_username")

# If necessary, update the recipe
mts_update_recipe(tileset_name = "median_age_acs",
                  username = "your_mapbox_username",
                  recipe = new_recipe)

# Publish the tileset again after you've updated the recipe
mts_publish_tileset(tileset_name = "median_age_acs",
                    username = "your_mapbox_username")

## End(Not run)
</code></pre>

<hr>
<h2 id='mts_create_tileset'>Create a tileset with the Mapbox Tiling Service API</h2><span id='topic+mts_create_tileset'></span>

<h3>Description</h3>

<p>After you've uploaded your spatial data to your Mapbox account with <code>mts_create_source</code> and prepared a valid recipe with <code>mts_make_recipe()</code>, you can use your source and recipe to create a vector tileset.  This tileset will be hosted at your Mapbox account.  Once created successfully, you will need to publish the tileset using <code>mts_publish_tileset</code> to use it in Mapbox Studio, Mapbox GL JS, or an R package that can read Mapbox tilesets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mts_create_tileset(
  tileset_name,
  username,
  recipe,
  request_name = tileset_name,
  access_token = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_create_tileset_+3A_tileset_name">tileset_name</code></td>
<td>
<p>The name of the MTS tileset you intend to create</p>
</td></tr>
<tr><td><code id="mts_create_tileset_+3A_username">username</code></td>
<td>
<p>Your Mapbox username</p>
</td></tr>
<tr><td><code id="mts_create_tileset_+3A_recipe">recipe</code></td>
<td>
<p>An MTS recipe, created with <code>mts_make_recipe()</code></p>
</td></tr>
<tr><td><code id="mts_create_tileset_+3A_request_name">request_name</code></td>
<td>
<p>The name of the request; defaults to the tileset name</p>
</td></tr>
<tr><td><code id="mts_create_tileset_+3A_access_token">access_token</code></td>
<td>
<p>Your Mapbox access token</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The response from the API, formatted as an R list.
</p>


<h3>See Also</h3>

<p><a href="https://docs.mapbox.com/api/maps/mapbox-tiling-service/#create-a-tileset">https://docs.mapbox.com/api/maps/mapbox-tiling-service/#create-a-tileset</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(tidycensus)
library(mapboxapi)
options(tigris_use_cache = TRUE)

# Get the national data on median age
us_median_age_tract &lt;- get_acs(
  geography = "tract",
  variables = "B01002_001",
  state = c(state.abb, "DC"),
  year = 2020,
  geometry = TRUE
)

# Get it for counties as well
us_median_age_county &lt;- get_acs(
  geography = "county",
  variables = "B01002_001",
  year = 2020,
  geometry = TRUE
)

# Create a source from the datasets
mts_create_source(data = us_median_age_tract,
                  tileset_id = "us_median_age_tract",
                  username = "your_mapbox_username")

mts_create_source(data = us_median_age_county,
                  tileset_id = "us_median_age_county",
                  username = "your_mapbox_username")

# Build out the recipe.  First, create a recipe layer with
# appropriate options.  We'll want a larger tile size and to restrict the minzoom
# to 4; a maxzoom of 12 will be fine as we can overzoom beyond that
#
# Your source ID will be returned by `mts_create_source()`, so use that value
tract_layer &lt;- recipe_layer(
  source = "mapbox://tileset-source/your_mapbox_username/us_median_age_tract",
  minzoom = 4,
  maxzoom = 12,
  tiles = tile_options(layer_size = 2500)
)

county_layer &lt;- recipe_layer(
  source = "mapbox://tileset-source/your_mapbox_username/us_median_age_county",
  minzoom = 2,
  maxzoom = 5
)

recipe &lt;- mts_make_recipe(tracts = tract_layer, counties = county_layer)

# Validate the recipe
mts_validate_recipe(recipe)

# Create a tileset from the recipe
mts_create_tileset(tileset_name = "median_age_acs",
                   username = "your_mapbox_username",
                   recipe = recipe)

# Publish the tileset
mts_publish_tileset(tileset_name = "median_age_acs",
                    username = "your_mapbox_username")

# If necessary, update the recipe
mts_update_recipe(tileset_name = "median_age_acs",
                  username = "your_mapbox_username",
                  recipe = new_recipe)

# Publish the tileset again after you've updated the recipe
mts_publish_tileset(tileset_name = "median_age_acs",
                    username = "your_mapbox_username")

## End(Not run)
</code></pre>

<hr>
<h2 id='mts_get_recipe'>Retrieve the recipe for an MTS tileset in your Mapbox account</h2><span id='topic+mts_get_recipe'></span>

<h3>Description</h3>

<p>Retrieve the recipe for an MTS tileset in your Mapbox account
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mts_get_recipe(tileset_name, username, access_token = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_get_recipe_+3A_tileset_name">tileset_name</code></td>
<td>
<p>The tileset name for which you'd like to retrieve a recipe</p>
</td></tr>
<tr><td><code id="mts_get_recipe_+3A_username">username</code></td>
<td>
<p>Your Mapbox username</p>
</td></tr>
<tr><td><code id="mts_get_recipe_+3A_access_token">access_token</code></td>
<td>
<p>Your Mapbox access token with secret scope</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The recipe for your tileset as an R list
</p>


<h3>See Also</h3>

<p><a href="https://docs.mapbox.com/api/maps/mapbox-tiling-service/#retrieve-a-tilesets-recipe">https://docs.mapbox.com/api/maps/mapbox-tiling-service/#retrieve-a-tilesets-recipe</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(tidycensus)
library(mapboxapi)
options(tigris_use_cache = TRUE)

# Get the national data on median age
us_median_age_tract &lt;- get_acs(
  geography = "tract",
  variables = "B01002_001",
  state = c(state.abb, "DC"),
  year = 2020,
  geometry = TRUE
)

# Get it for counties as well
us_median_age_county &lt;- get_acs(
  geography = "county",
  variables = "B01002_001",
  year = 2020,
  geometry = TRUE
)

# Create a source from the datasets
mts_create_source(data = us_median_age_tract,
                  tileset_id = "us_median_age_tract",
                  username = "your_mapbox_username")

mts_create_source(data = us_median_age_county,
                  tileset_id = "us_median_age_county",
                  username = "your_mapbox_username")

# Build out the recipe.  First, create a recipe layer with
# appropriate options.  We'll want a larger tile size and to restrict the minzoom
# to 4; a maxzoom of 12 will be fine as we can overzoom beyond that
#
# Your source ID will be returned by `mts_create_source()`, so use that value
tract_layer &lt;- recipe_layer(
  source = "mapbox://tileset-source/your_mapbox_username/us_median_age_tract",
  minzoom = 4,
  maxzoom = 12,
  tiles = tile_options(layer_size = 2500)
)

county_layer &lt;- recipe_layer(
  source = "mapbox://tileset-source/your_mapbox_username/us_median_age_county",
  minzoom = 2,
  maxzoom = 5
)

recipe &lt;- mts_make_recipe(tracts = tract_layer, counties = county_layer)

# Validate the recipe
mts_validate_recipe(recipe)

# Create a tileset from the recipe
mts_create_tileset(tileset_name = "median_age_acs",
                   username = "your_mapbox_username",
                   recipe = recipe)

# Publish the tileset
mts_publish_tileset(tileset_name = "median_age_acs",
                    username = "your_mapbox_username")

# If necessary, update the recipe
mts_update_recipe(tileset_name = "median_age_acs",
                  username = "your_mapbox_username",
                  recipe = new_recipe)

# Publish the tileset again after you've updated the recipe
mts_publish_tileset(tileset_name = "median_age_acs",
                    username = "your_mapbox_username")

## End(Not run)
</code></pre>

<hr>
<h2 id='mts_list_sources'>List tileset sources in your Mapbox account</h2><span id='topic+mts_list_sources'></span>

<h3>Description</h3>

<p>List tileset sources in your Mapbox account
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mts_list_sources(
  username,
  sortby = c("created", "modified"),
  limit = 100,
  start = NULL,
  access_token = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_list_sources_+3A_username">username</code></td>
<td>
<p>Your Mapbox username</p>
</td></tr>
<tr><td><code id="mts_list_sources_+3A_sortby">sortby</code></td>
<td>
<p>One of <code>"created"</code> or <code>"modified"</code>; the returned data frame will be sorted by one of these two options.</p>
</td></tr>
<tr><td><code id="mts_list_sources_+3A_limit">limit</code></td>
<td>
<p>The number of tileset sources to return; defaults to 100.  The maximum number of tileset sources returned by this endpoint is 2000.</p>
</td></tr>
<tr><td><code id="mts_list_sources_+3A_start">start</code></td>
<td>
<p>The source ID at which to start the list of sources; defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mts_list_sources_+3A_access_token">access_token</code></td>
<td>
<p>Your Mapbox access token with secret scope.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing information on your tileset sources.
</p>


<h3>See Also</h3>

<p><a href="https://docs.mapbox.com/api/maps/mapbox-tiling-service/#create-a-tileset-source">https://docs.mapbox.com/api/maps/mapbox-tiling-service/#create-a-tileset-source</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
source_list &lt;- mts_list_sources(username = "your_mapbox_username")

## End(Not run)
</code></pre>

<hr>
<h2 id='mts_list_tilesets'>List tilesets in a Mapbox account</h2><span id='topic+mts_list_tilesets'></span>

<h3>Description</h3>

<p>List tilesets in a Mapbox account
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mts_list_tilesets(
  username,
  type = NULL,
  visibility = NULL,
  sortby = c("created", "modified"),
  limit = 100,
  start = NULL,
  access_token = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_list_tilesets_+3A_username">username</code></td>
<td>
<p>A Mapbox username</p>
</td></tr>
<tr><td><code id="mts_list_tilesets_+3A_type">type</code></td>
<td>
<p>(optional) Return only <code>"vector"</code> or <code>"raster"</code> tilesets. If left blank, all tilesets will be returned.</p>
</td></tr>
<tr><td><code id="mts_list_tilesets_+3A_visibility">visibility</code></td>
<td>
<p>Return only <code>"public"</code> or <code>"private"</code> tilesets. Public tilesets can be returned with any public access token; private tilesets require the user's access token with secret scope.</p>
</td></tr>
<tr><td><code id="mts_list_tilesets_+3A_sortby">sortby</code></td>
<td>
<p>One of <code>"created"</code> or <code>"modified"</code>; the returned data frame will be sorted by one of these two options.</p>
</td></tr>
<tr><td><code id="mts_list_tilesets_+3A_limit">limit</code></td>
<td>
<p>The number of tilesets to return; defaults to 100.  The maximum number of tilesets returned by this endpoint is 500.</p>
</td></tr>
<tr><td><code id="mts_list_tilesets_+3A_start">start</code></td>
<td>
<p>The tileset ID at which to start the list of sources; defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mts_list_tilesets_+3A_access_token">access_token</code></td>
<td>
<p>Your Mapbox access token with secret scope.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing information on available tilesets in a given Mapbox account.
</p>


<h3>See Also</h3>

<p><a href="https://docs.mapbox.com/api/maps/mapbox-tiling-service/#list-tilesets">https://docs.mapbox.com/api/maps/mapbox-tiling-service/#list-tilesets</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
tileset_list &lt;- mts_list_tilesets(username = "your_mapbox_username")

## End(Not run)
</code></pre>

<hr>
<h2 id='mts_make_recipe'>Prepare a recipe for use with the Mapbox Tiling Service</h2><span id='topic+mts_make_recipe'></span>

<h3>Description</h3>

<p>Prepare a recipe for use with the Mapbox Tiling Service
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mts_make_recipe(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_make_recipe_+3A_...">...</code></td>
<td>
<p>One or more named lists that represent layers in the Mapbox Tiling Service recipe specification (<a href="https://docs.mapbox.com/mapbox-tiling-service/reference/#layer-example">https://docs.mapbox.com/mapbox-tiling-service/reference/#layer-example</a>).  These lists can be prepared with the helper function <code>recipe_layer()</code>, or prepared by hand if the user prefers. If multiple layers are included, a multi-layer recipe will be prepared that can produce tilesets with multiple sources.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R list representing an MTS recipe to be used to create a tileset.
</p>


<h3>See Also</h3>

<p><a href="https://docs.mapbox.com/mapbox-tiling-service/reference/">https://docs.mapbox.com/mapbox-tiling-service/reference/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(tidycensus)
library(mapboxapi)
options(tigris_use_cache = TRUE)

# Get the national data on median age
us_median_age_tract &lt;- get_acs(
  geography = "tract",
  variables = "B01002_001",
  state = c(state.abb, "DC"),
  year = 2020,
  geometry = TRUE
)

# Get it for counties as well
us_median_age_county &lt;- get_acs(
  geography = "county",
  variables = "B01002_001",
  year = 2020,
  geometry = TRUE
)

# Create a source from the datasets
mts_create_source(data = us_median_age_tract,
                  tileset_id = "us_median_age_tract",
                  username = "your_mapbox_username")

mts_create_source(data = us_median_age_county,
                  tileset_id = "us_median_age_county",
                  username = "your_mapbox_username")

# Build out the recipe.  First, create a recipe layer with
# appropriate options.  We'll want a larger tile size and to restrict the minzoom
# to 4; a maxzoom of 12 will be fine as we can overzoom beyond that
#
# Your source ID will be returned by `mts_create_source()`, so use that value
tract_layer &lt;- recipe_layer(
  source = "mapbox://tileset-source/your_mapbox_username/us_median_age_tract",
  minzoom = 4,
  maxzoom = 12,
  tiles = tile_options(layer_size = 2500)
)

county_layer &lt;- recipe_layer(
  source = "mapbox://tileset-source/your_mapbox_username/us_median_age_county",
  minzoom = 2,
  maxzoom = 5
)

recipe &lt;- mts_make_recipe(tracts = tract_layer, counties = county_layer)

# Validate the recipe
mts_validate_recipe(recipe)

# Create a tileset from the recipe
mts_create_tileset(tileset_name = "median_age_acs",
                   username = "your_mapbox_username",
                   recipe = recipe)

# Publish the tileset
mts_publish_tileset(tileset_name = "median_age_acs",
                    username = "your_mapbox_username")

# If necessary, update the recipe
mts_update_recipe(tileset_name = "median_age_acs",
                  username = "your_mapbox_username",
                  recipe = new_recipe)

# Publish the tileset again after you've updated the recipe
mts_publish_tileset(tileset_name = "median_age_acs",
                    username = "your_mapbox_username")

## End(Not run)
</code></pre>

<hr>
<h2 id='mts_publish_tileset'>Publish a tileset with Mapbox Tiling Service</h2><span id='topic+mts_publish_tileset'></span>

<h3>Description</h3>

<p><code>mts_publish_tileset()</code> publishes an existing vector tileset at your Mapbox account, allowing you to use the vector tiles in your projects.  The tileset name will be the same name you specified in <code>mts_create_tileset()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mts_publish_tileset(tileset_name, username, access_token = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_publish_tileset_+3A_tileset_name">tileset_name</code></td>
<td>
<p>The name of the tileset (as supplied to <code>mts_create_tileset()</code>)</p>
</td></tr>
<tr><td><code id="mts_publish_tileset_+3A_username">username</code></td>
<td>
<p>Your Mapbox username</p>
</td></tr>
<tr><td><code id="mts_publish_tileset_+3A_access_token">access_token</code></td>
<td>
<p>Your Mapbox access token</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The published tileset will conform to rules specified in its recipe.  If you want to change the recipe for a tileset, use <code>mts_update_recipe()</code> then re-publish the tileset with a call to <code>mts_publish_tileset()</code> once more.
</p>


<h3>Value</h3>

<p>The response from the Mapbox Tiling Service API, formatted as an R list.
</p>


<h3>See Also</h3>

<p><a href="https://docs.mapbox.com/api/maps/mapbox-tiling-service/#publish-a-tileset">https://docs.mapbox.com/api/maps/mapbox-tiling-service/#publish-a-tileset</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(tidycensus)
library(mapboxapi)
options(tigris_use_cache = TRUE)

# Get the national data on median age
us_median_age_tract &lt;- get_acs(
  geography = "tract",
  variables = "B01002_001",
  state = c(state.abb, "DC"),
  year = 2020,
  geometry = TRUE
)

# Get it for counties as well
us_median_age_county &lt;- get_acs(
  geography = "county",
  variables = "B01002_001",
  year = 2020,
  geometry = TRUE
)

# Create a source from the datasets
mts_create_source(data = us_median_age_tract,
                  tileset_id = "us_median_age_tract",
                  username = "your_mapbox_username")

mts_create_source(data = us_median_age_county,
                  tileset_id = "us_median_age_county",
                  username = "your_mapbox_username")

# Build out the recipe.  First, create a recipe layer with
# appropriate options.  We'll want a larger tile size and to restrict the minzoom
# to 4; a maxzoom of 12 will be fine as we can overzoom beyond that
#
# Your source ID will be returned by `mts_create_source()`, so use that value
tract_layer &lt;- recipe_layer(
  source = "mapbox://tileset-source/your_mapbox_username/us_median_age_tract",
  minzoom = 4,
  maxzoom = 12,
  tiles = tile_options(layer_size = 2500)
)

county_layer &lt;- recipe_layer(
  source = "mapbox://tileset-source/your_mapbox_username/us_median_age_county",
  minzoom = 2,
  maxzoom = 5
)

recipe &lt;- mts_make_recipe(tracts = tract_layer, counties = county_layer)

# Validate the recipe
mts_validate_recipe(recipe)

# Create a tileset from the recipe
mts_create_tileset(tileset_name = "median_age_acs",
                   username = "your_mapbox_username",
                   recipe = recipe)

# Publish the tileset
mts_publish_tileset(tileset_name = "median_age_acs",
                    username = "your_mapbox_username")

# If necessary, update the recipe
mts_update_recipe(tileset_name = "median_age_acs",
                  username = "your_mapbox_username",
                  recipe = new_recipe)

# Publish the tileset again after you've updated the recipe
mts_publish_tileset(tileset_name = "median_age_acs",
                    username = "your_mapbox_username")

## End(Not run)
</code></pre>

<hr>
<h2 id='mts_update_recipe'>Update a tileset's MTS recipe</h2><span id='topic+mts_update_recipe'></span>

<h3>Description</h3>

<p>Update a tileset's MTS recipe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mts_update_recipe(tileset_name, username, recipe, access_token = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_update_recipe_+3A_tileset_name">tileset_name</code></td>
<td>
<p>The name of your Mapbox tileset</p>
</td></tr>
<tr><td><code id="mts_update_recipe_+3A_username">username</code></td>
<td>
<p>Your Mapbox username</p>
</td></tr>
<tr><td><code id="mts_update_recipe_+3A_recipe">recipe</code></td>
<td>
<p>The new recipe for your tileset, likely created with <code>mts_make_recipe()</code>.</p>
</td></tr>
<tr><td><code id="mts_update_recipe_+3A_access_token">access_token</code></td>
<td>
<p>Your Mapbox access token</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the update is successful, the function will print a message informing you of its success.  Otherwise, a list of responses from the API will be returned letting you know why the request was invalid.
</p>


<h3>See Also</h3>

<p><a href="https://docs.mapbox.com/api/maps/mapbox-tiling-service/#update-a-tilesets-recipe">https://docs.mapbox.com/api/maps/mapbox-tiling-service/#update-a-tilesets-recipe</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(tidycensus)
library(mapboxapi)
options(tigris_use_cache = TRUE)

# Get the national data on median age
us_median_age_tract &lt;- get_acs(
  geography = "tract",
  variables = "B01002_001",
  state = c(state.abb, "DC"),
  year = 2020,
  geometry = TRUE
)

# Get it for counties as well
us_median_age_county &lt;- get_acs(
  geography = "county",
  variables = "B01002_001",
  year = 2020,
  geometry = TRUE
)

# Create a source from the datasets
mts_create_source(data = us_median_age_tract,
                  tileset_id = "us_median_age_tract",
                  username = "your_mapbox_username")

mts_create_source(data = us_median_age_county,
                  tileset_id = "us_median_age_county",
                  username = "your_mapbox_username")

# Build out the recipe.  First, create a recipe layer with
# appropriate options.  We'll want a larger tile size and to restrict the minzoom
# to 4; a maxzoom of 12 will be fine as we can overzoom beyond that
#
# Your source ID will be returned by `mts_create_source()`, so use that value
tract_layer &lt;- recipe_layer(
  source = "mapbox://tileset-source/your_mapbox_username/us_median_age_tract",
  minzoom = 4,
  maxzoom = 12,
  tiles = tile_options(layer_size = 2500)
)

county_layer &lt;- recipe_layer(
  source = "mapbox://tileset-source/your_mapbox_username/us_median_age_county",
  minzoom = 2,
  maxzoom = 5
)

recipe &lt;- mts_make_recipe(tracts = tract_layer, counties = county_layer)

# Validate the recipe
mts_validate_recipe(recipe)

# Create a tileset from the recipe
mts_create_tileset(tileset_name = "median_age_acs",
                   username = "your_mapbox_username",
                   recipe = recipe)

# Publish the tileset
mts_publish_tileset(tileset_name = "median_age_acs",
                    username = "your_mapbox_username")

# If necessary, update the recipe
mts_update_recipe(tileset_name = "median_age_acs",
                  username = "your_mapbox_username",
                  recipe = new_recipe)

# Publish the tileset again after you've updated the recipe
mts_publish_tileset(tileset_name = "median_age_acs",
                    username = "your_mapbox_username")

## End(Not run)
</code></pre>

<hr>
<h2 id='mts_validate_recipe'>Validate a Mapbox Tiling Service recipe</h2><span id='topic+mts_validate_recipe'></span>

<h3>Description</h3>

<p>Validate a Mapbox Tiling Service recipe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mts_validate_recipe(recipe, access_token = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mts_validate_recipe_+3A_recipe">recipe</code></td>
<td>
<p>A recipe list, created with <code>mts_make_recipe()</code></p>
</td></tr>
<tr><td><code id="mts_validate_recipe_+3A_access_token">access_token</code></td>
<td>
<p>Your Mapbox access token.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A response from the API indicating whether the MTS recipe is valid or not. If the recipe is valid, returns <code>TRUE</code>, allowing you to use the output of this function for error handling pipelines.  If the recipe is invalid, the function returns <code>FALSE</code> and prints the API response telling you why the recipe is invalid.
</p>


<h3>See Also</h3>

<p><a href="https://docs.mapbox.com/api/maps/mapbox-tiling-service/#validate-a-recipe">https://docs.mapbox.com/api/maps/mapbox-tiling-service/#validate-a-recipe</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(tidycensus)
library(mapboxapi)
options(tigris_use_cache = TRUE)

# Get the national data on median age
us_median_age_tract &lt;- get_acs(
  geography = "tract",
  variables = "B01002_001",
  state = c(state.abb, "DC"),
  year = 2020,
  geometry = TRUE
)

# Get it for counties as well
us_median_age_county &lt;- get_acs(
  geography = "county",
  variables = "B01002_001",
  year = 2020,
  geometry = TRUE
)

# Create a source from the datasets
mts_create_source(data = us_median_age_tract,
                  tileset_id = "us_median_age_tract",
                  username = "your_mapbox_username")

mts_create_source(data = us_median_age_county,
                  tileset_id = "us_median_age_county",
                  username = "your_mapbox_username")

# Build out the recipe.  First, create a recipe layer with
# appropriate options.  We'll want a larger tile size and to restrict the minzoom
# to 4; a maxzoom of 12 will be fine as we can overzoom beyond that
#
# Your source ID will be returned by `mts_create_source()`, so use that value
tract_layer &lt;- recipe_layer(
  source = "mapbox://tileset-source/your_mapbox_username/us_median_age_tract",
  minzoom = 4,
  maxzoom = 12,
  tiles = tile_options(layer_size = 2500)
)

county_layer &lt;- recipe_layer(
  source = "mapbox://tileset-source/your_mapbox_username/us_median_age_county",
  minzoom = 2,
  maxzoom = 5
)

recipe &lt;- mts_make_recipe(tracts = tract_layer, counties = county_layer)

# Validate the recipe
mts_validate_recipe(recipe)

# Create a tileset from the recipe
mts_create_tileset(tileset_name = "median_age_acs",
                   username = "your_mapbox_username",
                   recipe = recipe)

# Publish the tileset
mts_publish_tileset(tileset_name = "median_age_acs",
                    username = "your_mapbox_username")

# If necessary, update the recipe
mts_update_recipe(tileset_name = "median_age_acs",
                  username = "your_mapbox_username",
                  recipe = new_recipe)

# Publish the tileset again after you've updated the recipe
mts_publish_tileset(tileset_name = "median_age_acs",
                    username = "your_mapbox_username")

## End(Not run)
</code></pre>

<hr>
<h2 id='prep_overlay_markers'>Prepare overlay markers for use in a Mapbox static map</h2><span id='topic+prep_overlay_markers'></span>

<h3>Description</h3>

<p>Markers are prepared to match GeoJSON
<a href="https://github.com/mapbox/mapbox-gl-markers#geojson-marker-spec">marker-spec</a>
which is a partial implementation of the GeoJSON
<a href="https://github.com/mapbox/simplestyle-spec/tree/master/1.1.0">simplestyle-spec</a>
(described as a work-in-progress by Mapbox).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_overlay_markers(
  data = NULL,
  marker_type = c("pin-s", "pin-l", "url"),
  label = NA,
  color = NA,
  longitude = NULL,
  latitude = NULL,
  url = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_overlay_markers_+3A_data">data</code></td>
<td>
<p>An input data frame with longitude and latitude columns (X and Y
or lon and lat as names are also acceptable) or an <code>sf</code> object with
geometry type POINT.</p>
</td></tr>
<tr><td><code id="prep_overlay_markers_+3A_marker_type">marker_type</code></td>
<td>
<p>The marker type; one of <code>"pin-s"</code>, for a small pin;
<code>"pin-l"</code>, for a large pin; and <code>"url"</code>, for an image path. If
marker_type is the same length as the rows in data, a mix of different
marker types are allowed.</p>
</td></tr>
<tr><td><code id="prep_overlay_markers_+3A_label">label</code></td>
<td>
<p>The marker label (optional). Can be a letter, number (0 through
99), or a valid Maki icon (see <a href="https://labs.mapbox.com/maki-icons/">https://labs.mapbox.com/maki-icons/</a>)
for options).</p>
</td></tr>
<tr><td><code id="prep_overlay_markers_+3A_color">color</code></td>
<td>
<p>The marker color (optional). <code>color</code> can be specified as a color
name or as a three or six-digit hexadecimal code (with or without the
number sign).</p>
</td></tr>
<tr><td><code id="prep_overlay_markers_+3A_longitude">longitude</code></td>
<td>
<p>A vector of longitudes; inferred from the input dataset if
<code>data</code> is provided.</p>
</td></tr>
<tr><td><code id="prep_overlay_markers_+3A_latitude">latitude</code></td>
<td>
<p>A vector of latitudes; inferred from the input dataset if
<code>data</code> is provided.</p>
</td></tr>
<tr><td><code id="prep_overlay_markers_+3A_url">url</code></td>
<td>
<p>The URL of the image to be used for the icon if <code>marker_type = "url"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formatted list of marker specifications that can be passed to the
<a href="#topic+static_mapbox">static_mapbox</a> function.
</p>

<hr>
<h2 id='query_tiles'>Get information about features in a tileset using the Tilequery API</h2><span id='topic+query_tiles'></span>

<h3>Description</h3>

<p>Get information about features in a tileset using the Tilequery API
</p>


<h3>Usage</h3>

<pre><code class='language-R'>query_tiles(
  location,
  tileset_id,
  radius = 0,
  limit = 5,
  dedupe = TRUE,
  geometry = NULL,
  layers = NULL,
  access_token = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="query_tiles_+3A_location">location</code></td>
<td>
<p>The location for which you'd like to query tiles, expressed
as either a length-2 vector of longitude and latitude or an address you'd
like to geocode.</p>
</td></tr>
<tr><td><code id="query_tiles_+3A_tileset_id">tileset_id</code></td>
<td>
<p>The tileset ID to query.</p>
</td></tr>
<tr><td><code id="query_tiles_+3A_radius">radius</code></td>
<td>
<p>The radius around the point (in meters) for which you'd like to
query features. For point-in-polygon queries (e.g. &quot;what county is my point
located in?&quot;) the default of 0 should be used.</p>
</td></tr>
<tr><td><code id="query_tiles_+3A_limit">limit</code></td>
<td>
<p>How many features to return (defaults to 5). Can be an integer
between 1 and 50.</p>
</td></tr>
<tr><td><code id="query_tiles_+3A_dedupe">dedupe</code></td>
<td>
<p>Whether or not to return duplicate features as identified by
their IDs. The default, TRUE, will de-duplicate your dataset.</p>
</td></tr>
<tr><td><code id="query_tiles_+3A_geometry">geometry</code></td>
<td>
<p>The feature geometry type to query - can be <code>"point"</code>,
<code>"linestring"</code>, or <code>"polygon"</code>. If left blank, all geometry types
will be queried.</p>
</td></tr>
<tr><td><code id="query_tiles_+3A_layers">layers</code></td>
<td>
<p>A vector of layer IDs you'd like to query (recommended); if
left blank will query all layers, with the limitation that at most 50
features can be returned.</p>
</td></tr>
<tr><td><code id="query_tiles_+3A_access_token">access_token</code></td>
<td>
<p>A Mapbox access token, which can be set with
<code><a href="#topic+mb_access_token">mb_access_token()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R list containing the API response, which includes information
about the requested features. Parse the list to extract desired elements.
</p>


<h3>See Also</h3>

<p><a href="https://docs.mapbox.com/help/tutorials/find-elevations-with-tilequery-api/">https://docs.mapbox.com/help/tutorials/find-elevations-with-tilequery-api/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(mapboxapi)

elevation &lt;- query_tiles(
  location = "Breckenridge, Colorado",
  tileset_id = "mapbox.mapbox-terrain-v2",
  layer = "contour",
  limit = 50
)

max(elevation$features$properties$ele)

## End(Not run)

</code></pre>

<hr>
<h2 id='recipe_layer'>Prepare a formatted recipe layer for use in a Mapbox Tiling Service recipe</h2><span id='topic+recipe_layer'></span>

<h3>Description</h3>

<p>Prepare a formatted recipe layer for use in a Mapbox Tiling Service recipe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recipe_layer(
  source,
  minzoom,
  maxzoom,
  features = feature_options(),
  tiles = tile_options()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recipe_layer_+3A_source">source</code></td>
<td>
<p>The tileset source ID. This is returned by <code>mts_create_source()</code> or can be retrieved from your Mapbox account with <code>mts_list_sources()</code>.</p>
</td></tr>
<tr><td><code id="recipe_layer_+3A_minzoom">minzoom</code></td>
<td>
<p>The minimum zoom level at which a layer can be viewed.</p>
</td></tr>
<tr><td><code id="recipe_layer_+3A_maxzoom">maxzoom</code></td>
<td>
<p>The maximum zoom level at which a layer is rendered; the layer will still be visible past the maximum zoom level due to overzooming.</p>
</td></tr>
<tr><td><code id="recipe_layer_+3A_features">features</code></td>
<td>
<p>A list of feature options, possibly generated with <code>feature_options()</code>.</p>
</td></tr>
<tr><td><code id="recipe_layer_+3A_tiles">tiles</code></td>
<td>
<p>A list of tile options, possibly generated with <code>tile_options()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A recipe layer list to be used in <code>mts_make_recipe()</code>.
</p>


<h3>See Also</h3>

<p><a href="https://docs.mapbox.com/mapbox-tiling-service/reference/">https://docs.mapbox.com/mapbox-tiling-service/reference/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(tidycensus)
library(mapboxapi)
options(tigris_use_cache = TRUE)

# Get the national data on median age
us_median_age_tract &lt;- get_acs(
  geography = "tract",
  variables = "B01002_001",
  state = c(state.abb, "DC"),
  year = 2020,
  geometry = TRUE
)

# Get it for counties as well
us_median_age_county &lt;- get_acs(
  geography = "county",
  variables = "B01002_001",
  year = 2020,
  geometry = TRUE
)

# Create a source from the datasets
mts_create_source(data = us_median_age_tract,
                  tileset_id = "us_median_age_tract",
                  username = "your_mapbox_username")

mts_create_source(data = us_median_age_county,
                  tileset_id = "us_median_age_county",
                  username = "your_mapbox_username")

# Build out the recipe.  First, create a recipe layer with
# appropriate options.  We'll want a larger tile size and to restrict the minzoom
# to 4; a maxzoom of 12 will be fine as we can overzoom beyond that
#
# Your source ID will be returned by `mts_create_source()`, so use that value
tract_layer &lt;- recipe_layer(
  source = "mapbox://tileset-source/your_mapbox_username/us_median_age_tract",
  minzoom = 4,
  maxzoom = 12,
  tiles = tile_options(layer_size = 2500)
)

county_layer &lt;- recipe_layer(
  source = "mapbox://tileset-source/your_mapbox_username/us_median_age_county",
  minzoom = 2,
  maxzoom = 5
)

recipe &lt;- mts_make_recipe(tracts = tract_layer, counties = county_layer)

# Validate the recipe
mts_validate_recipe(recipe)

# Create a tileset from the recipe
mts_create_tileset(tileset_name = "median_age_acs",
                   username = "your_mapbox_username",
                   recipe = recipe)

# Publish the tileset
mts_publish_tileset(tileset_name = "median_age_acs",
                    username = "your_mapbox_username")

# If necessary, update the recipe
mts_update_recipe(tileset_name = "median_age_acs",
                  username = "your_mapbox_username",
                  recipe = new_recipe)

# Publish the tileset again after you've updated the recipe
mts_publish_tileset(tileset_name = "median_age_acs",
                    username = "your_mapbox_username")

## End(Not run)
</code></pre>

<hr>
<h2 id='static_mapbox'>Return a static Mapbox map from a specified style</h2><span id='topic+static_mapbox'></span>

<h3>Description</h3>

<p>This function uses the <a href="https://www.mapbox.com/static-maps">Mapbox Static Maps API</a> to return a pointer to an
<code>"magick-image"</code> class image or a <a href="httr.html#topic+response">httr::response</a> object from the static map
image URL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>static_mapbox(
  location = NULL,
  buffer_dist = 1000,
  units = "m",
  style_id,
  username,
  style_url = NULL,
  overlay_sf = NULL,
  overlay_style = NULL,
  overlay_markers = NULL,
  longitude = NULL,
  latitude = NULL,
  zoom = NULL,
  width = NULL,
  height = NULL,
  bearing = NULL,
  pitch = NULL,
  scale = 0.5,
  scaling_factor = c("1x", "2x"),
  attribution = TRUE,
  logo = TRUE,
  before_layer = NULL,
  access_token = NULL,
  image = TRUE,
  strip = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="static_mapbox_+3A_location">location</code></td>
<td>
<p>An input location for which you would like to request tiles.
Can be a length-4 vector representing a bounding box, or an <code>sf</code> object.
If an input <code>sf</code> object is supplied, use the <code>buffer_dist</code> argument to
control how much area you want to capture around the layer.
While the input <code>sf</code> object can be in an arbitrary coordinate reference system,
if a length-4 bounding box vector is supplied instead it must represent
WGS84 longitude/latitude coordinates and be in the order
<code>c(xmin, ymin, xmax, ymax)</code>.</p>
</td></tr>
<tr><td><code id="static_mapbox_+3A_buffer_dist">buffer_dist</code></td>
<td>
<p>The distance to buffer around an input <code>sf</code> object for
determining static map, specified in units. If location is a POINT object
of 2 rows or less and <code>buffer_dist</code> is 0 or <code>NULL</code>, a 1 unit buffer is
applied to try to ensure the creation of a valid bounding box for the map
area.</p>
</td></tr>
<tr><td><code id="static_mapbox_+3A_units">units</code></td>
<td>
<p>Units of <code>buffer_dist</code>; defaults to &quot;m&quot; (meters). If buffer_dist
is a units class object, the units argument is ignored.</p>
</td></tr>
<tr><td><code id="static_mapbox_+3A_style_id">style_id</code></td>
<td>
<p>A style ID (required if style_url is <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="static_mapbox_+3A_username">username</code></td>
<td>
<p>A Mapbox username (required if <code>style_url = NULL</code>).</p>
</td></tr>
<tr><td><code id="static_mapbox_+3A_style_url">style_url</code></td>
<td>
<p>A Mapbox style url; defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="static_mapbox_+3A_overlay_sf">overlay_sf</code></td>
<td>
<p>The overlay <code>sf</code> object (optional). The function will
convert the <code>sf</code> object to GeoJSON then plot over the basemap style.
Spatial data that are too large will trigger an error, and should be added
to the style in Mapbox Studio instead.</p>
</td></tr>
<tr><td><code id="static_mapbox_+3A_overlay_style">overlay_style</code></td>
<td>
<p>A named list of vectors specifying how to style the sf
overlay. Possible names are &quot;stroke&quot;, &quot;stroke-width&quot; (or &quot;stroke_width&quot;),
&quot;stroke-opacity&quot; (or &quot;stroke_opacity&quot;), &quot;fill&quot;, and &quot;fill-opacity&quot; (or
&quot;fill_opacity&quot;). The fill and stroke color values can be specified as
six-digit hex codes or color names, and the opacity and width values should
be supplied as floating-point numbers. If overlay_style is <code>NULL</code>, the
style values can be pulled from columns with the same names in
<code>overlay_sf</code>.</p>
</td></tr>
<tr><td><code id="static_mapbox_+3A_overlay_markers">overlay_markers</code></td>
<td>
<p>The prepared overlay markers (optional). See the
function <a href="#topic+prep_overlay_markers">prep_overlay_markers</a> for more information on how to specify a
marker overlay.</p>
</td></tr>
<tr><td><code id="static_mapbox_+3A_longitude">longitude</code>, <code id="static_mapbox_+3A_latitude">latitude</code></td>
<td>
<p>The longitude and latitude of the map center. If an
overlay is supplied, the map will default to the extent of the overlay
unless longitude, latitude, and zoom are all specified.</p>
</td></tr>
<tr><td><code id="static_mapbox_+3A_zoom">zoom</code></td>
<td>
<p>The map zoom. The map will infer this from the overlay unless
longitude, latitude, and zoom are all specified.</p>
</td></tr>
<tr><td><code id="static_mapbox_+3A_width">width</code>, <code id="static_mapbox_+3A_height">height</code></td>
<td>
<p>The map width and height; defaults to <code>NULL</code></p>
</td></tr>
<tr><td><code id="static_mapbox_+3A_pitch">pitch</code>, <code id="static_mapbox_+3A_bearing">bearing</code></td>
<td>
<p>The map pitch and bearing; defaults to <code>NULL</code>. pitch can
range from 0 to 60, and bearing from -360 to 360.</p>
</td></tr>
<tr><td><code id="static_mapbox_+3A_scale">scale</code></td>
<td>
<p>ratio to scale the output image; <code>scale = 1</code> will return the
largest possible image. defaults to 0.5</p>
</td></tr>
<tr><td><code id="static_mapbox_+3A_scaling_factor">scaling_factor</code></td>
<td>
<p>The scaling factor of the tiles; either <code>"1x"</code>
(the default) or <code>"2x"</code></p>
</td></tr>
<tr><td><code id="static_mapbox_+3A_attribution">attribution</code></td>
<td>
<p>Controls whether there is attribution on the image.
Defaults to <code>TRUE</code>. If <code>FALSE</code>, the watermarked attribution is removed from
the image. You still have a legal responsibility to attribute maps that use
OpenStreetMap data, which includes most maps from Mapbox. If you specify
<code>attribution = FALSE</code>, you are legally required to include proper
attribution elsewhere on the webpage or document.</p>
</td></tr>
<tr><td><code id="static_mapbox_+3A_logo">logo</code></td>
<td>
<p>Controls whether there is a Mapbox logo on the image. Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="static_mapbox_+3A_before_layer">before_layer</code></td>
<td>
<p>A character string that specifies where in the hierarchy
of layer elements the overlay should be inserted. The overlay will be
placed just above the specified layer in the given Mapbox styles. List
layer ids for a map style with <code>get_style(style_id = style_id, username = username, style_url = style_url, access_token = access_token)[["layers"]][["id"]]</code></p>
</td></tr>
<tr><td><code id="static_mapbox_+3A_access_token">access_token</code></td>
<td>
<p>A Mapbox access token; which can be set with
<a href="#topic+mb_access_token">mb_access_token</a>.</p>
</td></tr>
<tr><td><code id="static_mapbox_+3A_image">image</code></td>
<td>
<p>If <code>FALSE</code>, return the a <a href="httr.html#topic+response">httr::response</a> object from
<a href="httr.html#topic+GET">httr::GET</a> using the static image URL; defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="static_mapbox_+3A_strip">strip</code></td>
<td>
<p>If <code>TRUE</code>, drop image comments and metadata when <code>image = TRUE</code>;
defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A pointer to an image of class <code>"magick-image"</code> if <code>image = TRUE</code>.
The resulting image can be manipulated further with functions from the
magick package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(mapboxapi)

points_of_interest &lt;- tibble::tibble(
  longitude = c(-73.99405, -74.00616, -73.99577, -74.00761),
  latitude = c(40.72033, 40.72182, 40.71590, 40.71428)
)

prepped_pois &lt;- prep_overlay_markers(
  data = points_of_interest,
  marker_type = "pin-l",
  label = 1:4,
  color = "fff"
)

map &lt;- static_mapbox(
  style_id = "streets-v11",
  username = "mapbox",
  overlay_markers = prepped_pois,
  width = 1200,
  height = 800
)

map

## End(Not run)

</code></pre>

<hr>
<h2 id='tile_options'>Specify tile options for an MTS recipe layer</h2><span id='topic+tile_options'></span>

<h3>Description</h3>

<p>Specify tile options for an MTS recipe layer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tile_options(
  bbox = NULL,
  extent = NULL,
  buffer_size = NULL,
  limit = NULL,
  union = list(where = NULL, group_by = NULL, aggregate = NULL, maintain_direction =
    NULL, simplification = NULL),
  filter = NULL,
  attributes = NULL,
  order = NULL,
  remove_filled = NULL,
  id = NULL,
  layer_size = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tile_options_+3A_bbox">bbox</code>, <code id="tile_options_+3A_extent">extent</code>, <code id="tile_options_+3A_buffer_size">buffer_size</code>, <code id="tile_options_+3A_limit">limit</code>, <code id="tile_options_+3A_union">union</code>, <code id="tile_options_+3A_filter">filter</code>, <code id="tile_options_+3A_attributes">attributes</code>, <code id="tile_options_+3A_order">order</code>, <code id="tile_options_+3A_remove_filled">remove_filled</code>, <code id="tile_options_+3A_id">id</code>, <code id="tile_options_+3A_layer_size">layer_size</code></td>
<td>
<p>Tile options in the MTS recipe. See <a href="https://docs.mapbox.com/mapbox-tiling-service/reference/#tile-configuration">https://docs.mapbox.com/mapbox-tiling-service/reference/#tile-configuration</a> for more information on the available options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of tile options, likely to be used in <code>recipe_layer</code>.
</p>


<h3>See Also</h3>

<p><a href="https://docs.mapbox.com/mapbox-tiling-service/reference/">https://docs.mapbox.com/mapbox-tiling-service/reference/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(tidycensus)
library(mapboxapi)
options(tigris_use_cache = TRUE)

# Get the national data on median age
us_median_age_tract &lt;- get_acs(
  geography = "tract",
  variables = "B01002_001",
  state = c(state.abb, "DC"),
  year = 2020,
  geometry = TRUE
)

# Get it for counties as well
us_median_age_county &lt;- get_acs(
  geography = "county",
  variables = "B01002_001",
  year = 2020,
  geometry = TRUE
)

# Create a source from the datasets
mts_create_source(data = us_median_age_tract,
                  tileset_id = "us_median_age_tract",
                  username = "your_mapbox_username")

mts_create_source(data = us_median_age_county,
                  tileset_id = "us_median_age_county",
                  username = "your_mapbox_username")

# Build out the recipe.  First, create a recipe layer with
# appropriate options.  We'll want a larger tile size and to restrict the minzoom
# to 4; a maxzoom of 12 will be fine as we can overzoom beyond that
#
# Your source ID will be returned by `mts_create_source()`, so use that value
tract_layer &lt;- recipe_layer(
  source = "mapbox://tileset-source/your_mapbox_username/us_median_age_tract",
  minzoom = 4,
  maxzoom = 12,
  tiles = tile_options(layer_size = 2500)
)

county_layer &lt;- recipe_layer(
  source = "mapbox://tileset-source/your_mapbox_username/us_median_age_county",
  minzoom = 2,
  maxzoom = 5
)

recipe &lt;- mts_make_recipe(tracts = tract_layer, counties = county_layer)

# Validate the recipe
mts_validate_recipe(recipe)

# Create a tileset from the recipe
mts_create_tileset(tileset_name = "median_age_acs",
                   username = "your_mapbox_username",
                   recipe = recipe)

# Publish the tileset
mts_publish_tileset(tileset_name = "median_age_acs",
                    username = "your_mapbox_username")

# If necessary, update the recipe
mts_update_recipe(tileset_name = "median_age_acs",
                  username = "your_mapbox_username",
                  recipe = new_recipe)

# Publish the tileset again after you've updated the recipe
mts_publish_tileset(tileset_name = "median_age_acs",
                    username = "your_mapbox_username")

## End(Not run)
</code></pre>

<hr>
<h2 id='tippecanoe'>Generate an .mbtiles file with tippecanoe</h2><span id='topic+tippecanoe'></span>

<h3>Description</h3>

<p>Tippecanoe is a tile-generation utility
for building vector tilesets from large (or small) collections of GeoJSON,
Geobuf, or CSV features. The <a href="#topic+tippecanoe">tippecanoe</a> function requires that the
tippecanoe utility is installed on your system; see the tippecanoe
documentation for <a href="https://github.com/mapbox/tippecanoe#installation">installation instructions</a>. Once
installed, tippecanoe can be used in large visualization workflows in concert
with Mapbox Studio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tippecanoe(
  input,
  output,
  layer_name = NULL,
  min_zoom = NULL,
  max_zoom = NULL,
  drop_rate = NULL,
  overwrite = TRUE,
  other_options = NULL,
  keep_geojson = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tippecanoe_+3A_input">input</code></td>
<td>
<p>The dataset from which to generate vector tiles. Can be an sf
object or GeoJSON file on disk.</p>
</td></tr>
<tr><td><code id="tippecanoe_+3A_output">output</code></td>
<td>
<p>The name of the output .mbtiles file (with .mbtiles extension).
Will be saved in the current working directory.</p>
</td></tr>
<tr><td><code id="tippecanoe_+3A_layer_name">layer_name</code></td>
<td>
<p>The name of the layer in the output .mbtiles file. If NULL,
will either be a random string (if input is an <code>sf</code> object) or the name of
the input GeoJSON file (if input is a file path).</p>
</td></tr>
<tr><td><code id="tippecanoe_+3A_min_zoom">min_zoom</code>, <code id="tippecanoe_+3A_max_zoom">max_zoom</code></td>
<td>
<p>The minimum and maximum zoom levels for which to
compute tiles. If both min_zoom and max_zoom are blank, tippecanoe will
guess the best zoom levels for your data.</p>
</td></tr>
<tr><td><code id="tippecanoe_+3A_drop_rate">drop_rate</code></td>
<td>
<p>The rate at which tippecanoe will drop features as you zoom
out. If NULL, tippecanoe will drop features as needed in the densest tiles
to stay within Mapbox's limits.</p>
</td></tr>
<tr><td><code id="tippecanoe_+3A_overwrite">overwrite</code></td>
<td>
<p>If <code>TRUE</code>, an existing .mbtiles file with the same name will
be overwritten.</p>
</td></tr>
<tr><td><code id="tippecanoe_+3A_other_options">other_options</code></td>
<td>
<p>A character string of other options to be passed to the
tippecanoe program.</p>
</td></tr>
<tr><td><code id="tippecanoe_+3A_keep_geojson">keep_geojson</code></td>
<td>
<p>Whether nor not to keep the temporary CSV or GeoJSON file
used to generate the tiles. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mapbox also offers the <a href="https://docs.mapbox.com/mapbox-tiling-service/guides/">Mapbox Tiling Service</a> as an
alternate way to transform datasets into vector tiles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Workflow: create a dynamic tileset for dot-density mapping
library(tidycensus)
library(sf)
library(mapboxapi)

# Get population data for Census tracts in Vermont
vt_population &lt;- get_decennial(
  geography = "tract",
  variables = "P001001",
  state = "Vermont",
  year = 2010,
  geometry = TRUE
)

# Convert to representative dots - 1 per person
vt_dots &lt;- st_sample(
  vt_population,
  size = vt_population$value
)

# Use tippecanoe to create dynamic tiles
tippecanoe(
  input = vt_dots,
  output = "vt_population.mbtiles",
  layer_name = "vermont_population",
  max_zoom = 18,
  drop_rate = 1.5
)

# Upload to your Mapbox account for visualization
# A Mapbox secret access token must be set with mb_access_token()
# to upload data to your account
upload_tiles(
  input = "vt_population.mbtiles",
  username = "kwalkertcu",
  tileset_id = "vt_population_dots",
  multipart = TRUE
)

## End(Not run)

</code></pre>

<hr>
<h2 id='upload_tiles'>Upload dataset to your Mapbox account</h2><span id='topic+upload_tiles'></span>

<h3>Description</h3>

<p>Upload dataset to your Mapbox account
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upload_tiles(
  input,
  username,
  access_token = NULL,
  tileset_id = NULL,
  tileset_name = NULL,
  keep_geojson = FALSE,
  multipart = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upload_tiles_+3A_input">input</code></td>
<td>
<p>An <code>sf</code> object, or the path to the dataset to upload as a
character string.</p>
</td></tr>
<tr><td><code id="upload_tiles_+3A_username">username</code></td>
<td>
<p>Your Mapbox username</p>
</td></tr>
<tr><td><code id="upload_tiles_+3A_access_token">access_token</code></td>
<td>
<p>Your Mapbox access token; must have secret scope</p>
</td></tr>
<tr><td><code id="upload_tiles_+3A_tileset_id">tileset_id</code></td>
<td>
<p>The ID of the tileset in your Mapbox account</p>
</td></tr>
<tr><td><code id="upload_tiles_+3A_tileset_name">tileset_name</code></td>
<td>
<p>The name of the tileset in your Mapbox account</p>
</td></tr>
<tr><td><code id="upload_tiles_+3A_keep_geojson">keep_geojson</code></td>
<td>
<p>Whether or not to keep the temporary GeoJSON used to
generate the tiles (if the input is an <code>sf</code> object)</p>
</td></tr>
<tr><td><code id="upload_tiles_+3A_multipart">multipart</code></td>
<td>
<p>Whether or not to upload to the temporary AWS staging bucket
as a multipart object; defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Example: create a tileset of median age for all United States Census tracts
# Requires setting a Mapbox secret access token as an environment variable

library(mapboxapi)
library(tidycensus)
options(tigris_use_cache = TRUE)

median_age &lt;- get_acs(
  geography = "tract",
  variables = "B01002_001",
  state = c(state.abb, "DC"),
  geometry = TRUE
)

upload_tiles(
  input = median_age,
  username = "kwalkertcu", # Your username goes here
  tileset_id = "median_age",
  tileset_name = "us_median_age_2014_to_2018"
)

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
