<!DOCTYPE html><html lang="en"><head><title>Help for package SeqNet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SeqNet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_modules_to_network'><p>Internal function for adding a set of modules to the network</p></a></li>
<li><a href='#add_random_module_to_network'><p>Adds a random module of a given size to the network</p></a></li>
<li><a href='#all_networks_contain_same_modules'><p>Internal function to check if a list of networks all contain the same modules.</p></a></li>
<li><a href='#all_networks_contain_same_nodes'><p>Internal function to check if a list of networks all contain the same nodes.</p></a></li>
<li><a href='#as_single_module'><p>Collapses all modules in network into a single module</p></a></li>
<li><a href='#check_adjacency_cpp'><p>C++ implementation to check if a matrix is an adjacency matrix</p></a></li>
<li><a href='#components_in_adjacency'><p>C++ implementation to obtain connected components in a graph.</p></a></li>
<li><a href='#connect_module_structure'><p>Connect disconnected components in an adjacency matrix</p></a></li>
<li><a href='#create_cytoscape_file'><p>Create an edge table file for Cytoscape</p></a></li>
<li><a href='#create_empty_module'><p>Create a module</p></a></li>
<li><a href='#create_empty_network'><p>Create a network object.</p></a></li>
<li><a href='#create_module_from_adjacency_matrix'><p>Create a module from an adjacency matrix</p></a></li>
<li><a href='#create_module_from_association_matrix'><p>Create a module from an association matrix</p></a></li>
<li><a href='#create_modules_for_network'><p>Randomly sample subsets of genes for each module</p></a></li>
<li><a href='#create_network_from_adjacency_matrix'><p>Create a network object from an adjacency matrix</p></a></li>
<li><a href='#create_network_from_association_matrix'><p>Create a network object from an association matrix</p></a></li>
<li><a href='#create_network_from_modules'><p>Create a network object.</p></a></li>
<li><a href='#dzinb'><p>The Zero-Inflated Negative Binomial Distribution</p></a></li>
<li><a href='#ecdf_cpp'><p>C++ implementation of empirical CDF</p></a></li>
<li><a href='#edges_from_adjacency_cpp'><p>C++ implementation for obtaining an edge list from adjacency matrix</p></a></li>
<li><a href='#est_params_from_reference'><p>Estimate ZINB parameters from reference data</p></a></li>
<li><a href='#gen_gaussian'><p>Generate observations from a Gaussian graphical model.</p></a></li>
<li><a href='#gen_partial_correlations'><p>Generate partial correlations for a list of networks.</p></a></li>
<li><a href='#gen_rnaseq'><p>Generate RNA-seq data from an underlying network</p></a></li>
<li><a href='#gen_zinb'><p>Generate ZINB counts from an underlying network</p></a></li>
<li><a href='#get_adjacency_matrix'><p>Get adjacency matrix</p></a></li>
<li><a href='#get_adjacency_matrix.default'><p>Get adjacency matrix</p></a></li>
<li><a href='#get_adjacency_matrix.matrix'><p>Get adjacency matrix</p></a></li>
<li><a href='#get_adjacency_matrix.network'><p>Get adjacency matrix</p></a></li>
<li><a href='#get_adjacency_matrix.network_module'><p>Get adjacency matrix</p></a></li>
<li><a href='#get_association_matrix'><p>Get association matrix</p></a></li>
<li><a href='#get_association_matrix.default'><p>Get association matrix</p></a></li>
<li><a href='#get_association_matrix.matrix'><p>Get association matrix</p></a></li>
<li><a href='#get_association_matrix.network'><p>Get association matrix</p></a></li>
<li><a href='#get_association_matrix.network_module'><p>Get association matrix</p></a></li>
<li><a href='#get_degree_distribution'><p>Get the degree distribution for a network.</p></a></li>
<li><a href='#get_edge_weights_from_module'><p>Get edge weights.</p></a></li>
<li><a href='#get_layout_for_modules'><p>Internal function used to create coordinates based on a set of modules</p></a></li>
<li><a href='#get_network_arguments'><p>Internal function used to extract 'network' objects from argument list.</p></a></li>
<li><a href='#get_network_characteristics'><p>Characteristics of the network topology</p></a></li>
<li><a href='#get_network_modules'><p>Get a list of modules from the network</p></a></li>
<li><a href='#get_node_names'><p>Get node names</p></a></li>
<li><a href='#get_node_names.default'><p>Get node names</p></a></li>
<li><a href='#get_node_names.matrix'><p>Get node names</p></a></li>
<li><a href='#get_node_names.network'><p>Get node names</p></a></li>
<li><a href='#get_node_names.network_module'><p>Get node names</p></a></li>
<li><a href='#get_sigma'><p>Get the covariance matrix</p></a></li>
<li><a href='#get_sigma.default'><p>Get the covariance matrix</p></a></li>
<li><a href='#get_sigma.matrix'><p>Get the covariance matrix</p></a></li>
<li><a href='#get_sigma.network'><p>Get the covariance matrix</p></a></li>
<li><a href='#get_sigma.network_module'><p>Get the covariance matrix</p></a></li>
<li><a href='#get_summary_for_node'><p>Get summary for a node in the network.</p></a></li>
<li><a href='#heatmap_network'><p>Plot heatmap representation of a network</p></a></li>
<li><a href='#is_PD'><p>Internal function to check if a matrix is positive definite</p></a></li>
<li><a href='#is_symmetric_cpp'><p>C++ implementation to check if a matrix is symmetric</p></a></li>
<li><a href='#is_weighted'><p>Check if an object is weighted</p></a></li>
<li><a href='#is_weighted.default'><p>Check if an object is weighted</p></a></li>
<li><a href='#is_weighted.matrix'><p>Check if an object is weighted</p></a></li>
<li><a href='#is_weighted.network'><p>Check if an object is weighted</p></a></li>
<li><a href='#is_weighted.network_module'><p>Check if an object is weighted</p></a></li>
<li><a href='#perturb_network'><p>Perturbs the connections in a network</p></a></li>
<li><a href='#plot_gene_pair'><p>Scatter plot of two gene expressions</p></a></li>
<li><a href='#plot_modules'><p>Visualize a network and its modules</p></a></li>
<li><a href='#plot_network'><p>Visualize a network</p></a></li>
<li><a href='#plot_network_diff'><p>Plot the difference between two networks</p></a></li>
<li><a href='#plot_network_sim'><p>Plot the similarity between two networks</p></a></li>
<li><a href='#plot.network'><p>Plot function for 'network' object</p></a></li>
<li><a href='#plot.network_module'><p>Plot function for 'network_module' object.</p></a></li>
<li><a href='#plot.network_plot'><p>Plot function for 'network_plot' class</p></a></li>
<li><a href='#print.network'><p>Print function for 'network' object.</p></a></li>
<li><a href='#print.network_module'><p>Print function for 'network_module' object.</p></a></li>
<li><a href='#print.network_plot'><p>Print function for 'network_plot' class</p></a></li>
<li><a href='#pzinb'><p>The Zero-Inflated Negative Binomial Distribution</p></a></li>
<li><a href='#qzinb'><p>The Zero-Inflated Negative Binomial Distribution</p></a></li>
<li><a href='#random_module'><p>Create a random module</p></a></li>
<li><a href='#random_module_structure'><p>Create a random network structure for a module</p></a></li>
<li><a href='#random_network'><p>Create a network object.</p></a></li>
<li><a href='#reference'><p>RNA-seq reference dataset</p></a></li>
<li><a href='#remove_connections'><p>Remove connections in a network</p></a></li>
<li><a href='#remove_connections_to_node'><p>Remove connections to a node</p></a></li>
<li><a href='#remove_connections_to_node.default'><p>Remove connections to a node</p></a></li>
<li><a href='#remove_connections_to_node.matrix'><p>Remove connections to a node</p></a></li>
<li><a href='#remove_connections_to_node.network'><p>Remove connections to a node</p></a></li>
<li><a href='#remove_connections_to_node.network_module'><p>Remove connections to a node</p></a></li>
<li><a href='#remove_connections.default'><p>Remove connections in a network</p></a></li>
<li><a href='#remove_connections.matrix'><p>Remove connections in a network</p></a></li>
<li><a href='#remove_connections.network'><p>Remove connections in a network</p></a></li>
<li><a href='#remove_connections.network_module'><p>Remove connections in a network</p></a></li>
<li><a href='#remove_weights'><p>Removes the weights of all connections</p></a></li>
<li><a href='#remove_weights.default'><p>Removes the weights of all connections</p></a></li>
<li><a href='#remove_weights.matrix'><p>Removes the weights of all connections</p></a></li>
<li><a href='#remove_weights.network'><p>Removes the weights of all connections</p></a></li>
<li><a href='#remove_weights.network_module'><p>Removes the weights of all connections</p></a></li>
<li><a href='#replace_module_in_network'><p>Internal function for replacing a module in the network</p></a></li>
<li><a href='#rewire_connections'><p>Rewire connections</p></a></li>
<li><a href='#rewire_connections_to_node'><p>Rewire connections to a node</p></a></li>
<li><a href='#rewire_connections_to_node.default'><p>Rewire connections to a node</p></a></li>
<li><a href='#rewire_connections_to_node.matrix'><p>Rewire connections to a node</p></a></li>
<li><a href='#rewire_connections_to_node.network'><p>Rewire connections to a node</p></a></li>
<li><a href='#rewire_connections_to_node.network_module'><p>Rewire connections to a node</p></a></li>
<li><a href='#rewire_connections.default'><p>Rewire connections</p></a></li>
<li><a href='#rewire_connections.matrix'><p>Rewire connections</p></a></li>
<li><a href='#rewire_connections.network'><p>Rewire connections</p></a></li>
<li><a href='#rewire_connections.network_module'><p>Rewire connections</p></a></li>
<li><a href='#ring_lattice_cpp'><p>C++ implementation for creating a ring lattice</p></a></li>
<li><a href='#rzinb'><p>The Zero-Inflated Negative Binomial Distribution</p></a></li>
<li><a href='#sample_link_nodes'><p>Sample link nodes for new module</p></a></li>
<li><a href='#sample_module_nodes'><p>Sample nodes for new module</p></a></li>
<li><a href='#sample_reference_data'><p>Sample genes from reference dataset</p></a></li>
<li><a href='#set_module_edges'><p>Internal function used to set the edges in a module</p></a></li>
<li><a href='#set_module_name'><p>Set the name for a module</p></a></li>
<li><a href='#set_module_weights'><p>Internal function to set the connection weights for a module</p></a></li>
<li><a href='#set_node_names'><p>Set the node names in a network</p></a></li>
<li><a href='#update_module_with_random_weights'><p>Generate small-world network structure for module</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Generate RNA-Seq Data from Gene-Gene Association Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Tyler Grimes [aut, cre],
  Somnath Datta [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tyler Grimes &lt;tyler.grimes@unf.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods to generate random gene-gene association networks and simulate RNA-seq data from them, as described in Grimes and Datta (2021) &lt;<a href="https://doi.org/10.18637%2Fjss.v098.i12">doi:10.18637/jss.v098.i12</a>&gt;. Includes functions to generate random networks of any size and perturb them to obtain differential networks. Network objects are built from individual, overlapping modules that represent pathways. The resulting network has various topological properties that are characteristic of gene regulatory networks. RNA-seq data can be generated such that the association among gene expression profiles reflect the underlying network. A reference RNA-seq dataset can be provided to model realistic marginal distributions. Plotting functions are available to visualize a network, compare two networks, and compare the expression of two genes across multiple networks.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>fitdistrplus, ggplot2, grDevices, graphics, igraph, mvtnorm,
purrr, tibble, Rcpp, rlang, Rdpack, stats, utils, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-07-08 13:06:56 UTC; Grimes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-07-09 08:20:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_modules_to_network'>Internal function for adding a set of modules to the network</h2><span id='topic+add_modules_to_network'></span>

<h3>Description</h3>

<p>Internal function for adding a set of modules to the network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_modules_to_network(network, module_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_modules_to_network_+3A_network">network</code></td>
<td>
<p>The network to modify.</p>
</td></tr>
<tr><td><code id="add_modules_to_network_+3A_module_list">module_list</code></td>
<td>
<p>A list of 'network_module' objects to add to the network.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified network.
</p>

<hr>
<h2 id='add_random_module_to_network'>Adds a random module of a given size to the network</h2><span id='topic+add_random_module_to_network'></span>

<h3>Description</h3>

<p>Adds a random module of a given size to the network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_random_module_to_network(network, module_size, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_random_module_to_network_+3A_network">network</code></td>
<td>
<p>The 'network' object to modify.</p>
</td></tr>
<tr><td><code id="add_random_module_to_network_+3A_module_size">module_size</code></td>
<td>
<p>The size of the module to generate.</p>
</td></tr>
<tr><td><code id="add_random_module_to_network_+3A_...">...</code></td>
<td>
<p>Additional arguments passed into random_module().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified 'network' object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This function provides an alternative way to iteratively add random
# modules to the network. It uses a weighted sampling of nodes, where
# nodes that haven't been selected for a module have a higher probability 
# of being sampled for the new module.
nw &lt;- create_empty_network(100)
plot(nw) # An empty network of 100 nodes.
# Add random modules of size 10 to the network, 1 at a time.
# By plotting the network each time, we can watch it grow.
set.seed(12345)
plot(nw &lt;&lt;- add_random_module_to_network(nw, 10))
plot(nw &lt;&lt;- add_random_module_to_network(nw, 10))
plot(nw &lt;&lt;- add_random_module_to_network(nw, 10))
plot(nw &lt;&lt;- add_random_module_to_network(nw, 10))
plot(nw &lt;&lt;- add_random_module_to_network(nw, 10))
plot(nw &lt;&lt;- add_random_module_to_network(nw, 10))
# Etc.
</code></pre>

<hr>
<h2 id='all_networks_contain_same_modules'>Internal function to check if a list of networks all contain the same modules.</h2><span id='topic+all_networks_contain_same_modules'></span>

<h3>Description</h3>

<p>Internal function to check if a list of networks all contain the same modules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_networks_contain_same_modules(network_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="all_networks_contain_same_modules_+3A_network_list">network_list</code></td>
<td>
<p>A list of 'network' objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value; <code>TRUE</code> indicates the networks contain the same
modules, and <code>FALSE</code> indicates otherwise. Note, this only checks that
the modules contain the same nodes - the structure of the modules are allowed
to differ.
</p>

<hr>
<h2 id='all_networks_contain_same_nodes'>Internal function to check if a list of networks all contain the same nodes.</h2><span id='topic+all_networks_contain_same_nodes'></span>

<h3>Description</h3>

<p>Internal function to check if a list of networks all contain the same nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_networks_contain_same_nodes(network_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="all_networks_contain_same_nodes_+3A_network_list">network_list</code></td>
<td>
<p>A list of 'network' objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value; <code>TRUE</code> indicates the networks contain the same
nodes, and <code>FALSE</code> indicates otherwise.
</p>

<hr>
<h2 id='as_single_module'>Collapses all modules in network into a single module</h2><span id='topic+as_single_module'></span>

<h3>Description</h3>

<p>This modification can be used if it is desired to simulate from a single
GGM rather than averaging over the GGMs for each module.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_single_module(network)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_single_module_+3A_network">network</code></td>
<td>
<p>The 'network' object to modify</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified 'network' object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This function can be used prior to generating weights for the network 
# connections. With multiple modules in the network, the weighted network may
# gain conditional dependencies between nodes across modules. If the network
# is reduced to a single module prior to generating weights, then the
# weighted and unweighted networks will maintain the same structure.
nw &lt;- random_network(20, n_modules = 3)
g &lt;- plot(nw)
nw &lt;- gen_partial_correlations(nw)
plot(nw, g) # Additional edges appear from conditional dependencies across modules.
nw &lt;- remove_weights(nw) # Remove weights to avoid warning message in next call.
nw &lt;- as_single_module(nw)
nw &lt;- gen_partial_correlations(nw)
plot(nw, g) # With only one module, the weighted network has the same structure.
</code></pre>

<hr>
<h2 id='check_adjacency_cpp'>C++ implementation to check if a matrix is an adjacency matrix</h2><span id='topic+check_adjacency_cpp'></span>

<h3>Description</h3>

<p>C++ implementation to check if a matrix is an adjacency matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_adjacency_cpp(m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_adjacency_cpp_+3A_m">m</code></td>
<td>
<p>A matrix to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns 0 if the matrix is an adjacency matrix. If the matrix is
not square, returns 1; if the diagonal entries are not all zero, returns 2;
if the matrix is not symmetric, returns 3; if the matrix contains values
other than 0 or 1, returns 4.
</p>

<hr>
<h2 id='components_in_adjacency'>C++ implementation to obtain connected components in a graph.</h2><span id='topic+components_in_adjacency'></span>

<h3>Description</h3>

<p>C++ implementation to obtain connected components in a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>components_in_adjacency(adj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="components_in_adjacency_+3A_adj">adj</code></td>
<td>
<p>An adjacency matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with 2 columns containing the indicies in the
lower-triangle of the matrix that are nonzero.
</p>

<hr>
<h2 id='connect_module_structure'>Connect disconnected components in an adjacency matrix</h2><span id='topic+connect_module_structure'></span>

<h3>Description</h3>

<p>Connect disconnected components in an adjacency matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>connect_module_structure(
  adj,
  weights = NULL,
  alpha = 100,
  beta = 1,
  epsilon = 10^-5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="connect_module_structure_+3A_adj">adj</code></td>
<td>
<p>An adjacency matrix to modify.</p>
</td></tr>
<tr><td><code id="connect_module_structure_+3A_weights">weights</code></td>
<td>
<p>(Optional) weights used for sampling nodes.</p>
</td></tr>
<tr><td><code id="connect_module_structure_+3A_alpha">alpha</code></td>
<td>
<p>A positive value used to parameterize the Beta distribution.</p>
</td></tr>
<tr><td><code id="connect_module_structure_+3A_beta">beta</code></td>
<td>
<p>A positive value used to parameterize the Beta distribution.</p>
</td></tr>
<tr><td><code id="connect_module_structure_+3A_epsilon">epsilon</code></td>
<td>
<p>A small constant added to the sampling probability of each node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified adjacency matrix
</p>


<h3>Note</h3>

<p>This function is used in <code><a href="#topic+random_module_structure">random_module_structure</a></code> to
reconnect any disconnected components after edge removal and rewiring.
When connecting two components, a node is sampled from each component
with probability that is dependent on node degree; those two nodes are then
connected, which connects the components.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This function is used in `random_module_structure()` to reconnect any
# disconnected components. To demonstrate, we'll create a random structure,
# remove connections to one of the nodes (that node will then be a disconnected
# component), and use `connect_module_structure()` to reconnect it back to
# the main component.
adj &lt;- random_module_structure(10)
adj &lt;- remove_connections_to_node(adj, 1, prob_remove = 1)
# Note that there are now two components in the network:
components_in_adjacency(adj) 
g &lt;- plot_network(adj)
# After connecting, the network contains one component.
adj &lt;- connect_module_structure(adj)
components_in_adjacency(adj) 
plot_network(adj, g)
</code></pre>

<hr>
<h2 id='create_cytoscape_file'>Create an edge table file for Cytoscape</h2><span id='topic+create_cytoscape_file'></span>

<h3>Description</h3>

<p>The returned data frame can be saved as a .csv file. Then, in Cytoscape use
File -&gt; Import -&gt; Network -&gt; File. Select the .csv file containing the data
frame generated by this function. There will be a pop-up window. The source,
interaction, and target columns should automatically be identified. Click OK.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_cytoscape_file(g)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_cytoscape_file_+3A_g">g</code></td>
<td>
<p>A 'network_plot' object. See <code><a href="#topic+plot_network">plot_network</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing an edge table that can be saved as a .csv file
to be used in Cytoscape.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nw &lt;- random_network(10)
g &lt;- plot(nw)
nw_plot_cytoscape &lt;- create_cytoscape_file(g)

# Save the edge table in a .csv file to be used in cytoscape.
write.table(nw_plot_cytoscape, file.path(tempdir(), "file_name.csv"), 
            sep = ",", row.names = FALSE, col.names = TRUE, quote = FALSE)

</code></pre>

<hr>
<h2 id='create_empty_module'>Create a module</h2><span id='topic+create_empty_module'></span>

<h3>Description</h3>

<p>Create a module
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_empty_module(nodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_empty_module_+3A_nodes">nodes</code></td>
<td>
<p>A numeric vector indicating which nodes in the network are
contained in this module.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'network_module' object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>module &lt;- create_empty_module(1:10)
plot(module) # A module with no edges.
</code></pre>

<hr>
<h2 id='create_empty_network'>Create a network object.</h2><span id='topic+create_empty_network'></span>

<h3>Description</h3>

<p>Creates a 'network' object containing no modules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_empty_network(p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_empty_network_+3A_p">p</code></td>
<td>
<p>The number of nodes in the network</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A network object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nw &lt;- create_empty_network(10)
plot(nw) # A network with no edges.
</code></pre>

<hr>
<h2 id='create_module_from_adjacency_matrix'>Create a module from an adjacency matrix</h2><span id='topic+create_module_from_adjacency_matrix'></span>

<h3>Description</h3>

<p>The edges in the module will be set to the edges in the adjacency matrix.
The edges are undirected, and only the lower triangle of the
matrix is considered. See <code><a href="#topic+set_module_edges">set_module_edges</a></code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_module_from_adjacency_matrix(
  adjacency_matrix,
  nodes = NULL,
  module_name = NULL,
  run_checks = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_module_from_adjacency_matrix_+3A_adjacency_matrix">adjacency_matrix</code></td>
<td>
<p>The adjacency matrix used to create the module.</p>
</td></tr>
<tr><td><code id="create_module_from_adjacency_matrix_+3A_nodes">nodes</code></td>
<td>
<p>A numeric vector indicating which nodes in the network are
contained in this module.</p>
</td></tr>
<tr><td><code id="create_module_from_adjacency_matrix_+3A_module_name">module_name</code></td>
<td>
<p>(optional) Character string specifying the name of the
module. If <code>NULL</code>, the module will be unnamed.</p>
</td></tr>
<tr><td><code id="create_module_from_adjacency_matrix_+3A_run_checks">run_checks</code></td>
<td>
<p>If <code>TRUE</code>, then the <code>adjacency_matrix</code> argument
is checked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'network_module' object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nw &lt;- random_network(10)
nw &lt;- gen_partial_correlations(nw)
adj_mat &lt;- get_adjacency_matrix(nw)
create_module_from_adjacency_matrix(adj_mat)
</code></pre>

<hr>
<h2 id='create_module_from_association_matrix'>Create a module from an association matrix</h2><span id='topic+create_module_from_association_matrix'></span>

<h3>Description</h3>

<p>The edge weights in the module will be set to the corresponding values
in the association matrix. The edges are undirected, and only the lower
triangle of the matrix is considered. See <code><a href="#topic+set_module_weights">set_module_weights</a></code>
for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_module_from_association_matrix(
  association_matrix,
  nodes = NULL,
  module_name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_module_from_association_matrix_+3A_association_matrix">association_matrix</code></td>
<td>
<p>The association matrix used to create the module.</p>
</td></tr>
<tr><td><code id="create_module_from_association_matrix_+3A_nodes">nodes</code></td>
<td>
<p>A numeric vector indicating which nodes in the network are
contained in this module.</p>
</td></tr>
<tr><td><code id="create_module_from_association_matrix_+3A_module_name">module_name</code></td>
<td>
<p>(optional) Character string specifying the name of the
module. If <code>NULL</code>, the module will be unnamed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'network_module' object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nw &lt;- random_network(10)
nw &lt;- gen_partial_correlations(nw)
assoc_mat &lt;- get_association_matrix(nw)
create_module_from_association_matrix(assoc_mat)
</code></pre>

<hr>
<h2 id='create_modules_for_network'>Randomly sample subsets of genes for each module</h2><span id='topic+create_modules_for_network'></span>

<h3>Description</h3>

<p>Creates a collection of modules containing randomly samples genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_modules_for_network(
  n_modules,
  p,
  avg_module_size = 50,
  sd_module_size = 50,
  min_module_size = 10,
  max_module_size = 200,
  sample_link_nodes_fn = sample_link_nodes,
  sample_module_nodes_fn = sample_module_nodes,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_modules_for_network_+3A_n_modules">n_modules</code></td>
<td>
<p>The number of modules to include in the network.</p>
</td></tr>
<tr><td><code id="create_modules_for_network_+3A_p">p</code></td>
<td>
<p>The number of nodes in the network.</p>
</td></tr>
<tr><td><code id="create_modules_for_network_+3A_avg_module_size">avg_module_size</code></td>
<td>
<p>The average number of nodes in a module.</p>
</td></tr>
<tr><td><code id="create_modules_for_network_+3A_sd_module_size">sd_module_size</code></td>
<td>
<p>The standard deviation of module size.</p>
</td></tr>
<tr><td><code id="create_modules_for_network_+3A_min_module_size">min_module_size</code></td>
<td>
<p>The minimum number of nodes in a module.</p>
</td></tr>
<tr><td><code id="create_modules_for_network_+3A_max_module_size">max_module_size</code></td>
<td>
<p>A positive value. Any generated module sizes above this
value will be reduced to 'max_module_size'. Set to 'Inf' to avoid this
truncation.</p>
</td></tr>
<tr><td><code id="create_modules_for_network_+3A_sample_link_nodes_fn">sample_link_nodes_fn</code></td>
<td>
<p>A function used for sampling link nodes for a new
module.</p>
</td></tr>
<tr><td><code id="create_modules_for_network_+3A_sample_module_nodes_fn">sample_module_nodes_fn</code></td>
<td>
<p>A function used for sampling nodes for a new
module.</p>
</td></tr>
<tr><td><code id="create_modules_for_network_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+random_module">random_module</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the indices for genes contained in each module.
</p>


<h3>References</h3>

<p>Grimes T, Datta S (2021).
&ldquo;SeqNet: An R Package for Generating Gene-Gene Networks and Simulating RNA-Seq Data.&rdquo;
<em>Journal of Statistical Software</em>, <b>98</b>(12), 1&ndash;49.
doi: <a href="https://doi.org/10.18637/jss.v098.i12">10.18637/jss.v098.i12</a>, <a href="https://doi.org/10.18637/jss.v098.i12">https://doi.org/10.18637/jss.v098.i12</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a two modules (having random structures and sizes) from a pool 
# of 100 nodes.
create_modules_for_network(n_modules = 2, p = 100)
# Set n_modules = NULL to continue making modules until all nodes have
# been selected at least once.
create_modules_for_network(n_modules = NULL, p = 100)
</code></pre>

<hr>
<h2 id='create_network_from_adjacency_matrix'>Create a network object from an adjacency matrix</h2><span id='topic+create_network_from_adjacency_matrix'></span>

<h3>Description</h3>

<p>Create a network object from an adjacency matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_network_from_adjacency_matrix(adjacency_matrix, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_network_from_adjacency_matrix_+3A_adjacency_matrix">adjacency_matrix</code></td>
<td>
<p>The adjacency matrix for the network. Since the
adjacency matrix only provides information on the global connections, the
resulting 'network' object will consist of a single module containing these
connections.</p>
</td></tr>
<tr><td><code id="create_network_from_adjacency_matrix_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
<code><a href="#topic+create_module_from_adjacency_matrix">create_module_from_adjacency_matrix</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A network object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adj_mat &lt;- random_module_structure(10)
nw &lt;- create_network_from_adjacency_matrix(adj_mat)
all(adj_mat == get_adjacency_matrix(nw))
</code></pre>

<hr>
<h2 id='create_network_from_association_matrix'>Create a network object from an association matrix</h2><span id='topic+create_network_from_association_matrix'></span>

<h3>Description</h3>

<p>Create a network object from an association matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_network_from_association_matrix(association_matrix, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_network_from_association_matrix_+3A_association_matrix">association_matrix</code></td>
<td>
<p>The association matrix for the network. Since the
association matrix only provides information on the global connections, the
resulting 'network' object will consist of a single weighted module
containing these connections. The edge weights, i.e. the partial correlations,
will correspond to the nonzero values in the matrix.</p>
</td></tr>
<tr><td><code id="create_network_from_association_matrix_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
<code><a href="#topic+create_module_from_association_matrix">create_module_from_association_matrix</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A network object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random weighted network and extract the association matrix from it.
nw &lt;- random_network(10)
nw &lt;- gen_partial_correlations(nw)
assoc_mat &lt;- get_association_matrix(nw)
# Any association matrix can be used to directly create a network object.
# However, the created network will only contain one module.
nw_from_assoc &lt;- create_network_from_association_matrix(assoc_mat)
all(get_adjacency_matrix(nw) == get_adjacency_matrix(nw_from_assoc))
</code></pre>

<hr>
<h2 id='create_network_from_modules'>Create a network object.</h2><span id='topic+create_network_from_modules'></span>

<h3>Description</h3>

<p>Generates a 'network' object from a list of 'network_modules', The modules
are assumed to have their local network structure already generated.
Individual modules can be generated using the <code><a href="#topic+random_module">random_module</a></code>
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_network_from_modules(
  p,
  module_list,
  node_names = as.character(1:p),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_network_from_modules_+3A_p">p</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
<tr><td><code id="create_network_from_modules_+3A_module_list">module_list</code></td>
<td>
<p>A named list of 'network_module' objects.</p>
</td></tr>
<tr><td><code id="create_network_from_modules_+3A_node_names">node_names</code></td>
<td>
<p>(optional) Vector of strings providing names for each node
in the graph. Default names are &quot;1&quot;, &quot;2&quot;, ..., &quot;p&quot;.</p>
</td></tr>
<tr><td><code id="create_network_from_modules_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to other methods. Possible arguments
include:
</p>

<table>
<tr>
 <td style="text-align: left;">
prob_rewire </td><td style="text-align: left;">
The probability of removing a connection from the local network
structure; this is applied to each edge created. Used in
<code><a href="#topic+random_module_structure">random_module_structure</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">

prob_remove </td><td style="text-align: left;">
The probability of rewiring a connection from the local network
structure; this is applied every connection of each node. See
<code><a href="#topic+random_module_structure">random_module_structure</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">

neig_size </td><td style="text-align: left;">
The initial degree of each node when constructing the ring lattice.
See <code><a href="#topic+random_module_structure">random_module_structure</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">

alpha </td><td style="text-align: left;">
A positive value used to parameterize the Beta distribution used
to sample nodes based on their degree. Larger values will place more weight
on highly connected nodes. See <code><a href="#topic+random_module_structure">random_module_structure</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">

beta </td><td style="text-align: left;"> A positive value used to parameterize the Beta distribution used
to sample nodes based on their degree. Set to 1 by default. Increasing this
parameter will cause the sampling to favor moderately connected nodes over
the extreme tail of highly connected nodes.
See <code><a href="#topic+random_module_structure">random_module_structure</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">

epsilon </td><td style="text-align: left;"> A small constant added to the sampling probability of each node.
See <code><a href="#topic+random_module_structure">random_module_structure</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>
</td></tr>
</table>


<h3>Value</h3>

<p>A network object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Networks can be crafted manually by first constructing the individual
# modules, then putting them together to create a network.
module_1 &lt;- random_module(1:10) # A module containing nodes 1-10
module_2 &lt;- random_module(5:15) # A module containing nodes 5-15
# Create a network containing 20 nodes and the two modules. 
nw &lt;- create_network_from_modules(20, list(module_1, module_2))
nw 
# Note: nodes 16-20 are not in a module, so they have no connections.
plot(nw)
</code></pre>

<hr>
<h2 id='dzinb'>The Zero-Inflated Negative Binomial Distribution</h2><span id='topic+dzinb'></span>

<h3>Description</h3>

<p>The Zero-Inflated Negative Binomial Distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dzinb(x, size, mu, rho = 0, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dzinb_+3A_x">x</code></td>
<td>
<p>A vector of quantities.</p>
</td></tr>
<tr><td><code id="dzinb_+3A_size">size</code></td>
<td>
<p>The dispersion paramater used in <code><a href="stats.html#topic+NegBinomial">dnbinom</a></code>.</p>
</td></tr>
<tr><td><code id="dzinb_+3A_mu">mu</code></td>
<td>
<p>The mean parameter used in <code><a href="stats.html#topic+NegBinomial">dnbinom</a></code>.</p>
</td></tr>
<tr><td><code id="dzinb_+3A_rho">rho</code></td>
<td>
<p>The zero-inflation parameter.</p>
</td></tr>
<tr><td><code id="dzinb_+3A_log">log</code></td>
<td>
<p>Logical; if <code>TRUE</code>, then log(d) is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value(s) of the density function evaluated at <code>x</code>.
</p>


<h3>References</h3>

<p>Grimes T, Datta S (2021).
&ldquo;SeqNet: An R Package for Generating Gene-Gene Networks and Simulating RNA-Seq Data.&rdquo;
<em>Journal of Statistical Software</em>, <b>98</b>(12), 1&ndash;49.
doi: <a href="https://doi.org/10.18637/jss.v098.i12">10.18637/jss.v098.i12</a>, <a href="https://doi.org/10.18637/jss.v098.i12">https://doi.org/10.18637/jss.v098.i12</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rzinb(10, 1, 10, 0.1)
p &lt;- pzinb(x, 1, 10, 0.1)
y &lt;- qzinb(p, 1, 10, 0.1)
all(x == y)
# Compute P(0 &lt; X &lt; 5) for X ~ ZINB(1, 10, 0.1)
sum(dzinb(0:5, 1, 10, 0.1))
</code></pre>

<hr>
<h2 id='ecdf_cpp'>C++ implementation of empirical CDF</h2><span id='topic+ecdf_cpp'></span>

<h3>Description</h3>

<p>Constructs the empirical CDF, F, for a set of observations, x, and
returns F(x).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ecdf_cpp(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ecdf_cpp_+3A_x">x</code></td>
<td>
<p>The observation to construct the empirical CDF from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the values for F(x).
</p>

<hr>
<h2 id='edges_from_adjacency_cpp'>C++ implementation for obtaining an edge list from adjacency matrix</h2><span id='topic+edges_from_adjacency_cpp'></span>

<h3>Description</h3>

<p>C++ implementation for obtaining an edge list from adjacency matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edges_from_adjacency_cpp(adj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edges_from_adjacency_cpp_+3A_adj">adj</code></td>
<td>
<p>An adjacency matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with 2 columns containing the indicies in the
lower-triangle of the matrix that are nonzero.
</p>

<hr>
<h2 id='est_params_from_reference'>Estimate ZINB parameters from reference data</h2><span id='topic+est_params_from_reference'></span>

<h3>Description</h3>

<p>The observations in the reference dataset should be as homogeneous as possible.
For example, we should not expect differential expression or differential
connectivity of genes within the sample. If the data are heterogeneous, the
estimation of the parameters may be unreliable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_params_from_reference(reference, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est_params_from_reference_+3A_reference">reference</code></td>
<td>
<p>Either a vector or data.frame of counts from a reference
gene expression profile. If a data.frame is provided, each column should
correspond to a gene.</p>
</td></tr>
<tr><td><code id="est_params_from_reference_+3A_verbose">verbose</code></td>
<td>
<p>Boolean indicator for message output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing a matrix of parameter estimates 'size',
'mu', and 'rho' for each gene in the reference, and the reference dataset
used. The parameter matrix can be used in <code><a href="#topic+gen_zinb">gen_zinb</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The internal reference dataset already contains ZINB parameter estimates,
# so running est_params_from_reference() is not necessary. To simulate 
# ZINB data from a different RNA-seq reference dataset, the data can
# be passed into gen_zinb() directly using the 'reference' argument, and 
# est_params_from_reference() will be used automatically (i.e. the user
# does not need to call this function directly).

# An example using the reference dataset
data(reference) 
# The RNA-seq dataset should have samples as rows and genes as columns:
rnaseq &lt;- reference$rnaseq
# Estimate ZINB params for first ten genes.
params &lt;- est_params_from_reference(rnaseq[, 1:10])$params 
# However, the previous call is not needed for simulated ZINB data.
# The RNA-seq dataset can be passed directly to `gen_zinb()`.
nw &lt;- random_network(10)
x &lt;- gen_zinb(20, nw, reference = rnaseq[, 1:10])$x # Pass in 'rnaseq' directly.

</code></pre>

<hr>
<h2 id='gen_gaussian'>Generate observations from a Gaussian graphical model.</h2><span id='topic+gen_gaussian'></span>

<h3>Description</h3>

<p>Generates data based on the multivariate normal distribution parameterized by
a zero mean vector and a covariance matrix. Observations are generated for
each module in the network individually, and the covariance matrix is set to
the inverse of the standardized association matrix for the module.
Observations are combined for gene i by taking the sum across the m_i modules
containing it and dividing by sqrt(m_i).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_gaussian(n, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_gaussian_+3A_n">n</code></td>
<td>
<p>The number of samples to generate. If multiple networks are provided,
n samples are generated per network.</p>
</td></tr>
<tr><td><code id="gen_gaussian_+3A_...">...</code></td>
<td>
<p>The 'network' object(s) to generate data from. Can be a single
network, many networks, or a single list of networks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the n by p matrix of samples and the 'network'
object used to generate them.
</p>


<h3>References</h3>

<p>Grimes T, Datta S (2021).
&ldquo;SeqNet: An R Package for Generating Gene-Gene Networks and Simulating RNA-Seq Data.&rdquo;
<em>Journal of Statistical Software</em>, <b>98</b>(12), 1&ndash;49.
doi: <a href="https://doi.org/10.18637/jss.v098.i12">10.18637/jss.v098.i12</a>, <a href="https://doi.org/10.18637/jss.v098.i12">https://doi.org/10.18637/jss.v098.i12</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nw &lt;- random_network(10) # Create a random network with 10 nodes.
nw &lt;- gen_partial_correlations(nw) # Add weights to connections in the network.
x &lt;- gen_gaussian(20, nw)$x # Simulate 20 Gaussian observations from network. 
</code></pre>

<hr>
<h2 id='gen_partial_correlations'>Generate partial correlations for a list of networks.</h2><span id='topic+gen_partial_correlations'></span>

<h3>Description</h3>

<p>Random partial correlations are generated to weigh the network connections.
If multiple networks are provided, the networks must contain the same nodes
and the same modules (the connections within modules may differ). Any
connection that is common across different networks will also have the same
partial correlation weight across networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_partial_correlations(
  ...,
  k = 2.5,
  rweights = function(n) (-1)^rbinom(n, 1, 0.5) * runif(n, 0.5, 1)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_partial_correlations_+3A_...">...</code></td>
<td>
<p>The 'network' objects to modify.</p>
</td></tr>
<tr><td><code id="gen_partial_correlations_+3A_k">k</code></td>
<td>
<p>An positive number used to ensure that the matrix inverse is
numerically stable.  <code>k = 2.5</code> is the default value; higher values
will allow for larger values of partial correlations (and will result in a
wider distribution of Pearson correlations).</p>
</td></tr>
<tr><td><code id="gen_partial_correlations_+3A_rweights">rweights</code></td>
<td>
<p>A generator for initial weights in the network. By default,
values are generated uniformly from (-1, -0.5) U (0.5, 1). The weights will
be adjusted so that the sign of a generated weight and the sign of the
corresponding partial correlation agree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated network object containing random weights. If multiple
networks were provided, then a list of network objects is returned.
</p>


<h3>References</h3>

<p>Grimes T, Datta S (2021).
&ldquo;SeqNet: An R Package for Generating Gene-Gene Networks and Simulating RNA-Seq Data.&rdquo;
<em>Journal of Statistical Software</em>, <b>98</b>(12), 1&ndash;49.
doi: <a href="https://doi.org/10.18637/jss.v098.i12">10.18637/jss.v098.i12</a>, <a href="https://doi.org/10.18637/jss.v098.i12">https://doi.org/10.18637/jss.v098.i12</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nw &lt;- random_network(10) # Create a random network with 10 nodes.
nw &lt;- gen_partial_correlations(nw) # Add weights to connections in the network.
</code></pre>

<hr>
<h2 id='gen_rnaseq'>Generate RNA-seq data from an underlying network</h2><span id='topic+gen_rnaseq'></span>

<h3>Description</h3>

<p>The expression data are generated based on the gene-gene associations of an
underlying network. An association structure is imposed by first generating
data from a multivariate Gaussian distribution. Those data are then used to
sample from the empirical distribution of gene expression profiles in the
reference dataset using the inverse transform method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_rnaseq(n, network, reference = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_rnaseq_+3A_n">n</code></td>
<td>
<p>The number of samples to generate.</p>
</td></tr>
<tr><td><code id="gen_rnaseq_+3A_network">network</code></td>
<td>
<p>A 'network' object or list of 'network' objects.</p>
</td></tr>
<tr><td><code id="gen_rnaseq_+3A_reference">reference</code></td>
<td>
<p>A data.frame containing reference gene expression data. Rows
should correspond to samples and columns to genes. If <code>NULL</code>, then the
<code><a href="#topic+reference">reference</a></code> dataset is used.</p>
</td></tr>
<tr><td><code id="gen_rnaseq_+3A_verbose">verbose</code></td>
<td>
<p>Boolean indicator for message output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the simulated expression data and the reference
dataset. If a list of networks were provided, then the results for
each network are returned as a list.
</p>


<h3>References</h3>

<p>Grimes T, Datta S (2021).
&ldquo;SeqNet: An R Package for Generating Gene-Gene Networks and Simulating RNA-Seq Data.&rdquo;
<em>Journal of Statistical Software</em>, <b>98</b>(12), 1&ndash;49.
doi: <a href="https://doi.org/10.18637/jss.v098.i12">10.18637/jss.v098.i12</a>, <a href="https://doi.org/10.18637/jss.v098.i12">https://doi.org/10.18637/jss.v098.i12</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nw &lt;- random_network(10) # Create a random network with 10 nodes.
nw &lt;- gen_partial_correlations(nw) # Add weights to connections in the network.
# If no reference is provided, the internal RNA-seq reference dataset is used.
x &lt;- gen_rnaseq(20, nw)$x # Simulate 20 observations from the network.
</code></pre>

<hr>
<h2 id='gen_zinb'>Generate ZINB counts from an underlying network</h2><span id='topic+gen_zinb'></span>

<h3>Description</h3>

<p>The count data are generated based on the gene-gene associations of an
udnerlying network. An association structure is imposed by first generating
data from a multivariate Gaussian distribution, and counts are then obtained
through the inverse tranformation method. To generate realistic counts, either
a reference dataset or parameters for the ZINB model (size, mu, rho) can be
provided. Parameters can be estimated from a reference using the
<code><a href="#topic+est_params_from_reference">est_params_from_reference</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_zinb(
  n,
  network,
  reference = NULL,
  params = NULL,
  library_sizes = NULL,
  adjust_library_size = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_zinb_+3A_n">n</code></td>
<td>
<p>The number of samples to generate.</p>
</td></tr>
<tr><td><code id="gen_zinb_+3A_network">network</code></td>
<td>
<p>A 'network' object or list of 'network' objects.</p>
</td></tr>
<tr><td><code id="gen_zinb_+3A_reference">reference</code></td>
<td>
<p>Either a vector or data.frame of counts from a reference
gene expression profile. If a data.frame is provided, each column should
correspond to a gene. If both <code>reference</code> and <code>params</code> are
<code>NULL</code>, then parameters are estimated from the
<code><a href="#topic+reference">reference</a></code> dataset.</p>
</td></tr>
<tr><td><code id="gen_zinb_+3A_params">params</code></td>
<td>
<p>A matrix of ZINB parameter values; each column should contain
the size, mu, and rho parameters for a gene.</p>
</td></tr>
<tr><td><code id="gen_zinb_+3A_library_sizes">library_sizes</code></td>
<td>
<p>A vector of library sizes. Used only if <code>reference</code> is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="gen_zinb_+3A_adjust_library_size">adjust_library_size</code></td>
<td>
<p>A boolean value. If <code>TRUE</code>, the library size of
generated counts are adjusted based on the reference library sizes. If both
<code>reference</code> and <code>library_sizes</code> is <code>NULL</code>, then no adjustment is made.
By default, this adjustment is made if the necessary information is provided.</p>
</td></tr>
<tr><td><code id="gen_zinb_+3A_verbose">verbose</code></td>
<td>
<p>Boolean indicator for message output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the generated counts and the ZINB parameters used
to create them. If a list of networks were provided, then the results for
each network are returned as a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nw &lt;- random_network(10) # Create a random network with 10 nodes.
nw &lt;- gen_partial_correlations(nw) # Add weights to connections in the network.
# If no reference is provided, ZINB data are generated using an internal reference.
x &lt;- gen_zinb(20, nw)$x # Simulate 20 ZINB observations from the network.
</code></pre>

<hr>
<h2 id='get_adjacency_matrix'>Get adjacency matrix</h2><span id='topic+get_adjacency_matrix'></span>

<h3>Description</h3>

<p>The adjacency matrix is constructed from all modules in a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_adjacency_matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_adjacency_matrix_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="get_adjacency_matrix_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An adjacency matrix with entry ij = 1 if node i and j are
connected, and 0 otherwise. The diagonal entries are all zero.
</p>


<h3>Note</h3>

<p>The connections in an adjacency matrix and association matrix may differ
if the network contains multiple modules. The adjacency matrix only considers
direct connections in the network, whereas the association matrix takes into
account the fact that overlapping modules can create conditional dependencies
between two genes in seperate modules (i.e. genes that don't have a direct
connection in the graph).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes and add random edge weights.
nw &lt;- random_network(10)
nw &lt;- gen_partial_correlations(nw)
# Get adjacency matrix for the network or individual modules in the network.
get_adjacency_matrix(nw)
module &lt;- nw$modules[[1]]
get_adjacency_matrix(module)
</code></pre>

<hr>
<h2 id='get_adjacency_matrix.default'>Get adjacency matrix</h2><span id='topic+get_adjacency_matrix.default'></span>

<h3>Description</h3>

<p>The adjacency matrix is constructed from all modules in a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
get_adjacency_matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_adjacency_matrix.default_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="get_adjacency_matrix.default_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An adjacency matrix with entry ij = 1 if node i and j are
connected, and 0 otherwise. The diagonal entries are all zero.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes and add random edge weights.
nw &lt;- random_network(10)
nw &lt;- gen_partial_correlations(nw)
# Get adjacency matrix for the network or individual modules in the network.
get_adjacency_matrix(nw)
module &lt;- nw$modules[[1]]
get_adjacency_matrix(module)
</code></pre>

<hr>
<h2 id='get_adjacency_matrix.matrix'>Get adjacency matrix</h2><span id='topic+get_adjacency_matrix.matrix'></span>

<h3>Description</h3>

<p>The adjacency matrix is constructed from all modules in a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
get_adjacency_matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_adjacency_matrix.matrix_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="get_adjacency_matrix.matrix_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An adjacency matrix with entry ij = 1 if node i and j are
connected, and 0 otherwise. The diagonal entries are all zero.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes and add random edge weights.
nw &lt;- random_network(10)
nw &lt;- gen_partial_correlations(nw)
# Get adjacency matrix for the network or individual modules in the network.
get_adjacency_matrix(nw)
module &lt;- nw$modules[[1]]
get_adjacency_matrix(module)
</code></pre>

<hr>
<h2 id='get_adjacency_matrix.network'>Get adjacency matrix</h2><span id='topic+get_adjacency_matrix.network'></span>

<h3>Description</h3>

<p>The adjacency matrix is constructed from all modules in a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network'
get_adjacency_matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_adjacency_matrix.network_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="get_adjacency_matrix.network_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An adjacency matrix with entry ij = 1 if node i and j are
connected, and 0 otherwise. The diagonal entries are all zero.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes and add random edge weights.
nw &lt;- random_network(10)
nw &lt;- gen_partial_correlations(nw)
# Get adjacency matrix for the network or individual modules in the network.
get_adjacency_matrix(nw)
module &lt;- nw$modules[[1]]
get_adjacency_matrix(module)
</code></pre>

<hr>
<h2 id='get_adjacency_matrix.network_module'>Get adjacency matrix</h2><span id='topic+get_adjacency_matrix.network_module'></span>

<h3>Description</h3>

<p>The adjacency matrix is constructed from all modules in a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network_module'
get_adjacency_matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_adjacency_matrix.network_module_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="get_adjacency_matrix.network_module_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An adjacency matrix with entry ij = 1 if node i and j are
connected, and 0 otherwise. The diagonal entries are all zero.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes and add random edge weights.
nw &lt;- random_network(10)
nw &lt;- gen_partial_correlations(nw)
# Get adjacency matrix for the network or individual modules in the network.
get_adjacency_matrix(nw)
module &lt;- nw$modules[[1]]
get_adjacency_matrix(module)
</code></pre>

<hr>
<h2 id='get_association_matrix'>Get association matrix</h2><span id='topic+get_association_matrix'></span>

<h3>Description</h3>

<p>Get association matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_association_matrix(x, tol = 10^-13, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_association_matrix_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="get_association_matrix_+3A_tol">tol</code></td>
<td>
<p>A small tolerance threshold; any entry that is within <code>tol</code> from zero
is set to zero.</p>
</td></tr>
<tr><td><code id="get_association_matrix_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An association matrix with entry ij != 0 if node i and j are
connected, and 0 otherwise. The diagonal entries are all zero.
</p>


<h3>Note</h3>

<p>The connections in an adjacency matrix and association matrix may differ
if the network contains multiple modules. The adjacency matrix only considers
direct connections in the network, whereas the association matrix takes into
account the fact that overlapping modules can create conditional dependencies
between two genes in seperate modules (i.e. genes that don't have a direct
connection in the graph).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes and add random edge weights.
nw &lt;- random_network(10)
nw &lt;- gen_partial_correlations(nw)
# Get adjacency matrix for the network or individual modules in the network.
get_association_matrix(nw)
module &lt;- nw$modules[[1]]
get_association_matrix(module)
</code></pre>

<hr>
<h2 id='get_association_matrix.default'>Get association matrix</h2><span id='topic+get_association_matrix.default'></span>

<h3>Description</h3>

<p>Get association matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
get_association_matrix(x, tol = 10^-13, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_association_matrix.default_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="get_association_matrix.default_+3A_tol">tol</code></td>
<td>
<p>A small tolerance threshold; any entry that is within <code>tol</code> from zero
is set to zero.</p>
</td></tr>
<tr><td><code id="get_association_matrix.default_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An association matrix with entry ij != 0 if node i and j are
connected, and 0 otherwise. The diagonal entries are all zero.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes and add random edge weights.
nw &lt;- random_network(10)
nw &lt;- gen_partial_correlations(nw)
# Get adjacency matrix for the network or individual modules in the network.
get_association_matrix(nw)
module &lt;- nw$modules[[1]]
get_association_matrix(module)
</code></pre>

<hr>
<h2 id='get_association_matrix.matrix'>Get association matrix</h2><span id='topic+get_association_matrix.matrix'></span>

<h3>Description</h3>

<p>Get association matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
get_association_matrix(x, tol = 10^-13, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_association_matrix.matrix_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="get_association_matrix.matrix_+3A_tol">tol</code></td>
<td>
<p>A small tolerance threshold; any entry that is within <code>tol</code> from zero
is set to zero.</p>
</td></tr>
<tr><td><code id="get_association_matrix.matrix_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An association matrix with entry ij != 0 if node i and j are
connected, and 0 otherwise. The diagonal entries are all zero.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes and add random edge weights.
nw &lt;- random_network(10)
nw &lt;- gen_partial_correlations(nw)
# Get adjacency matrix for the network or individual modules in the network.
get_association_matrix(nw)
module &lt;- nw$modules[[1]]
get_association_matrix(module)
</code></pre>

<hr>
<h2 id='get_association_matrix.network'>Get association matrix</h2><span id='topic+get_association_matrix.network'></span>

<h3>Description</h3>

<p>Get association matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network'
get_association_matrix(x, tol = 10^-13, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_association_matrix.network_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="get_association_matrix.network_+3A_tol">tol</code></td>
<td>
<p>A small tolerance threshold; any entry that is within <code>tol</code> from zero
is set to zero.</p>
</td></tr>
<tr><td><code id="get_association_matrix.network_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An association matrix with entry ij != 0 if node i and j are
connected, and 0 otherwise. The diagonal entries are all zero.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes and add random edge weights.
nw &lt;- random_network(10)
nw &lt;- gen_partial_correlations(nw)
# Get adjacency matrix for the network or individual modules in the network.
get_association_matrix(nw)
module &lt;- nw$modules[[1]]
get_association_matrix(module)
</code></pre>

<hr>
<h2 id='get_association_matrix.network_module'>Get association matrix</h2><span id='topic+get_association_matrix.network_module'></span>

<h3>Description</h3>

<p>Get association matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network_module'
get_association_matrix(x, tol = 10^-13, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_association_matrix.network_module_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="get_association_matrix.network_module_+3A_tol">tol</code></td>
<td>
<p>A small tolerance threshold; any entry that is within <code>tol</code> from zero
is set to zero.</p>
</td></tr>
<tr><td><code id="get_association_matrix.network_module_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An association matrix with entry ij != 0 if node i and j are
connected, and 0 otherwise. The diagonal entries are all zero.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes and add random edge weights.
nw &lt;- random_network(10)
nw &lt;- gen_partial_correlations(nw)
# Get adjacency matrix for the network or individual modules in the network.
get_association_matrix(nw)
module &lt;- nw$modules[[1]]
get_association_matrix(module)
</code></pre>

<hr>
<h2 id='get_degree_distribution'>Get the degree distribution for a network.</h2><span id='topic+get_degree_distribution'></span>

<h3>Description</h3>

<p>Counts the connections to each node within each structure. Note, this
is not the same as the degree distribution from the adjacency matrix
obtained from the network, which collapses the individual structures into
one graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_degree_distribution(network)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_degree_distribution_+3A_network">network</code></td>
<td>
<p>A network object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length p, containing the degree for each node in the
network.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(13245)
nw &lt;- random_network(10)
deg &lt;- get_degree_distribution(nw) # Degree of each node.
table(deg) # Frequency table of degrees.
# Five nodes have degree 2, three nodes have degree 3, etc.
</code></pre>

<hr>
<h2 id='get_edge_weights_from_module'>Get edge weights.</h2><span id='topic+get_edge_weights_from_module'></span>

<h3>Description</h3>

<p>Get edge weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_edge_weights_from_module(module)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_edge_weights_from_module_+3A_module">module</code></td>
<td>
<p>The 'network_module' object to get edge weights for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the weights of each edge. If the edges are
unweighted, then a vector of 1's is returned. If there are no edges, in the
module, then <code>NULL</code> is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nw &lt;- random_network(10)
nw &lt;- gen_partial_correlations(nw)
module &lt;- nw$modules[[1]]
get_edge_weights_from_module(module)
</code></pre>

<hr>
<h2 id='get_layout_for_modules'>Internal function used to create coordinates based on a set of modules</h2><span id='topic+get_layout_for_modules'></span>

<h3>Description</h3>

<p>Internal function used to create coordinates based on a set of modules
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_layout_for_modules(g, modules)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_layout_for_modules_+3A_g">g</code></td>
<td>
<p>An 'igraph' object</p>
</td></tr>
<tr><td><code id="get_layout_for_modules_+3A_modules">modules</code></td>
<td>
<p>A list containing sets of indicies indicating the nodes in
<code>g</code> that belong to each module</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of coordinates for plotting
</p>

<hr>
<h2 id='get_network_arguments'>Internal function used to extract 'network' objects from argument list.</h2><span id='topic+get_network_arguments'></span>

<h3>Description</h3>

<p>Internal function used to extract 'network' objects from argument list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_network_arguments(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_network_arguments_+3A_...">...</code></td>
<td>
<p>The 'network' object(s) or list of networks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 'network' objects.
</p>

<hr>
<h2 id='get_network_characteristics'>Characteristics of the network topology</h2><span id='topic+get_network_characteristics'></span>

<h3>Description</h3>

<p>The average degree, clustering coefficient, and average path length are calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_network_characteristics(network, global_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_network_characteristics_+3A_network">network</code></td>
<td>
<p>A 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="get_network_characteristics_+3A_global_only">global_only</code></td>
<td>
<p>If <code>TRUE</code>, only the global characteristics are calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing characteristics of the network.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nw &lt;- random_network(10)
get_network_characteristics(nw)
</code></pre>

<hr>
<h2 id='get_network_modules'>Get a list of modules from the network</h2><span id='topic+get_network_modules'></span>

<h3>Description</h3>

<p>Get a list of modules from the network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_network_modules(network)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_network_modules_+3A_network">network</code></td>
<td>
<p>A 'network' object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list whose length is the number of modules in the network;
each element is a vector containing the indicies of the nodes
that belong to that module.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12345)
# Create a random network of 50 nodes and modules of sizes between 5-20.
nw &lt;- random_network(50, n_modules = 5, min_module_size = 5, 
                     max_module_size = 20, avg_module_size = 10,
                     sd_module_size = 5)
get_network_modules(nw) # Indicies of nodes contained in each module.
</code></pre>

<hr>
<h2 id='get_node_names'>Get node names</h2><span id='topic+get_node_names'></span>

<h3>Description</h3>

<p>Get node names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_node_names(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_node_names_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="get_node_names_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the node names or node indices.
</p>


<h3>Note</h3>

<p>Modules do not retain the names of each node, so the node indicies are
returned instead. These can be used to index into the vector of node
names obtained from the network.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(10)
get_node_names(nw) # Default names are 1, 2, ..., 10.
nw &lt;- set_node_names(nw, paste("node", 1:10, sep = "_"))
get_node_names(nw) # Print out updated node names.
# Modules only contain the indicies to nodes, not the node names
module &lt;- nw$modules[[1]]
get_node_names(module)
# When converting the network to a matrix, node names appear as column names.
adj_matrix &lt;- get_adjacency_matrix(nw)
colnames(adj_matrix) 
</code></pre>

<hr>
<h2 id='get_node_names.default'>Get node names</h2><span id='topic+get_node_names.default'></span>

<h3>Description</h3>

<p>Get node names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
get_node_names(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_node_names.default_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="get_node_names.default_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the node names or node indices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(10)
get_node_names(nw) # Default names are 1, 2, ..., 10.
nw &lt;- set_node_names(nw, paste("node", 1:10, sep = "_"))
get_node_names(nw) # Print out updated node names.
# Modules only contain the indicies to nodes, not the node names
module &lt;- nw$modules[[1]]
get_node_names(module)
# When converting the network to a matrix, node names appear as column names.
adj_matrix &lt;- get_adjacency_matrix(nw)
colnames(adj_matrix) 
</code></pre>

<hr>
<h2 id='get_node_names.matrix'>Get node names</h2><span id='topic+get_node_names.matrix'></span>

<h3>Description</h3>

<p>Get node names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
get_node_names(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_node_names.matrix_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="get_node_names.matrix_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the node names or node indices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(10)
get_node_names(nw) # Default names are 1, 2, ..., 10.
nw &lt;- set_node_names(nw, paste("node", 1:10, sep = "_"))
get_node_names(nw) # Print out updated node names.
# Modules only contain the indicies to nodes, not the node names
module &lt;- nw$modules[[1]]
get_node_names(module)
# When converting the network to a matrix, node names appear as column names.
adj_matrix &lt;- get_adjacency_matrix(nw)
colnames(adj_matrix) 
</code></pre>

<hr>
<h2 id='get_node_names.network'>Get node names</h2><span id='topic+get_node_names.network'></span>

<h3>Description</h3>

<p>Get node names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network'
get_node_names(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_node_names.network_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="get_node_names.network_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the node names or node indices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(10)
get_node_names(nw) # Default names are 1, 2, ..., 10.
nw &lt;- set_node_names(nw, paste("node", 1:10, sep = "_"))
get_node_names(nw) # Print out updated node names.
# Modules only contain the indicies to nodes, not the node names
module &lt;- nw$modules[[1]]
get_node_names(module)
# When converting the network to a matrix, node names appear as column names.
adj_matrix &lt;- get_adjacency_matrix(nw)
colnames(adj_matrix) 
</code></pre>

<hr>
<h2 id='get_node_names.network_module'>Get node names</h2><span id='topic+get_node_names.network_module'></span>

<h3>Description</h3>

<p>Get node names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network_module'
get_node_names(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_node_names.network_module_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="get_node_names.network_module_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the node names or node indices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(10)
get_node_names(nw) # Default names are 1, 2, ..., 10.
nw &lt;- set_node_names(nw, paste("node", 1:10, sep = "_"))
get_node_names(nw) # Print out updated node names.
# Modules only contain the indicies to nodes, not the node names
module &lt;- nw$modules[[1]]
get_node_names(module)
# When converting the network to a matrix, node names appear as column names.
adj_matrix &lt;- get_adjacency_matrix(nw)
colnames(adj_matrix) 
</code></pre>

<hr>
<h2 id='get_sigma'>Get the covariance matrix</h2><span id='topic+get_sigma'></span>

<h3>Description</h3>

<p>The associations in each module are taken as partial correlations, and
the covariance matrix is calculated from these assuming that expression
for gene i is the weighted average over each module using 1/sqrt(m_i)
as the weight, where m_i is the number of modules containing gene i.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sigma(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_sigma_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="get_sigma_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A covariance matrix.
</p>


<h3>Note</h3>

<p>If a matrix is provided, it is assumed to be a partial correlation matrix;
a warning is given in this case. To avoid the warning message, convert the
matrix into a network object using
<code><a href="#topic+create_network_from_association_matrix">create_network_from_association_matrix</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes and add random edge weights.
nw &lt;- random_network(10)
nw &lt;- gen_partial_correlations(nw)
# Get covariance matrix for the network or individual modules in the network.
get_sigma(nw)
module &lt;- nw$modules[[1]]
get_sigma(module)
</code></pre>

<hr>
<h2 id='get_sigma.default'>Get the covariance matrix</h2><span id='topic+get_sigma.default'></span>

<h3>Description</h3>

<p>The associations in each module are taken as partial correlations, and
the covariance matrix is calculated from these assuming that expression
for gene i is the weighted average over each module using 1/sqrt(m_i)
as the weight, where m_i is the number of modules containing gene i.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
get_sigma(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_sigma.default_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="get_sigma.default_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A covariance matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes and add random edge weights.
nw &lt;- random_network(10)
nw &lt;- gen_partial_correlations(nw)
# Get covariance matrix for the network or individual modules in the network.
get_sigma(nw)
module &lt;- nw$modules[[1]]
get_sigma(module)
</code></pre>

<hr>
<h2 id='get_sigma.matrix'>Get the covariance matrix</h2><span id='topic+get_sigma.matrix'></span>

<h3>Description</h3>

<p>The associations in each module are taken as partial correlations, and
the covariance matrix is calculated from these assuming that expression
for gene i is the weighted average over each module using 1/sqrt(m_i)
as the weight, where m_i is the number of modules containing gene i.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
get_sigma(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_sigma.matrix_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="get_sigma.matrix_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A covariance matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes and add random edge weights.
nw &lt;- random_network(10)
nw &lt;- gen_partial_correlations(nw)
# Get covariance matrix for the network or individual modules in the network.
get_sigma(nw)
module &lt;- nw$modules[[1]]
get_sigma(module)
</code></pre>

<hr>
<h2 id='get_sigma.network'>Get the covariance matrix</h2><span id='topic+get_sigma.network'></span>

<h3>Description</h3>

<p>The associations in each module are taken as partial correlations, and
the covariance matrix is calculated from these assuming that expression
for gene i is the weighted average over each module using 1/sqrt(m_i)
as the weight, where m_i is the number of modules containing gene i.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network'
get_sigma(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_sigma.network_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="get_sigma.network_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A covariance matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes and add random edge weights.
nw &lt;- random_network(10)
nw &lt;- gen_partial_correlations(nw)
# Get covariance matrix for the network or individual modules in the network.
get_sigma(nw)
module &lt;- nw$modules[[1]]
get_sigma(module)
</code></pre>

<hr>
<h2 id='get_sigma.network_module'>Get the covariance matrix</h2><span id='topic+get_sigma.network_module'></span>

<h3>Description</h3>

<p>The associations in each module are taken as partial correlations, and
the covariance matrix is calculated from these assuming that expression
for gene i is the weighted average over each module using 1/sqrt(m_i)
as the weight, where m_i is the number of modules containing gene i.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network_module'
get_sigma(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_sigma.network_module_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="get_sigma.network_module_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A covariance matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes and add random edge weights.
nw &lt;- random_network(10)
nw &lt;- gen_partial_correlations(nw)
# Get covariance matrix for the network or individual modules in the network.
get_sigma(nw)
module &lt;- nw$modules[[1]]
get_sigma(module)
</code></pre>

<hr>
<h2 id='get_summary_for_node'>Get summary for a node in the network.</h2><span id='topic+get_summary_for_node'></span>

<h3>Description</h3>

<p>Get summary for a node in the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_summary_for_node(node, network)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_summary_for_node_+3A_node">node</code></td>
<td>
<p>The node to summarize. Can be a character string
corresponding to a name of a node in the network, or an integer value from
1 to p corresponding to the index of a node.</p>
</td></tr>
<tr><td><code id="get_summary_for_node_+3A_network">network</code></td>
<td>
<p>A network object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing summary information for the node; this includes
a vector of indicies to other nodes in the network it is connected to, and
a vector of incidices to modules that contain the node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12345)
nw &lt;- random_network(100)
get_summary_for_node(1, nw)
# Node 1 is contained in modules 1 and 2, and it is connected to nodes 
# 2, 4, 11, 13, 23, and 29.
</code></pre>

<hr>
<h2 id='heatmap_network'>Plot heatmap representation of a network</h2><span id='topic+heatmap_network'></span>

<h3>Description</h3>

<p>This function plots the given network as a heatmap to visualize its
connections. If the network is weighted, then the heatmap will use greyscale
colors to represent connection strengths; black squares correspond to the
strongest connections, while lighter color squares are weaker connections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heatmap_network(
  network,
  main = NULL,
  col = colorRampPalette(gray.colors(8, 0.1, 1))(50),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heatmap_network_+3A_network">network</code></td>
<td>
<p>Either a network object or association matrix of the network.</p>
</td></tr>
<tr><td><code id="heatmap_network_+3A_main">main</code></td>
<td>
<p>A string containing the title for the graph.</p>
</td></tr>
<tr><td><code id="heatmap_network_+3A_col">col</code></td>
<td>
<p>Color palatte used for heatmap. See <code>link[stats]{heatmap}</code>
for details.</p>
</td></tr>
<tr><td><code id="heatmap_network_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>link[stats]{heatmap}</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix used to create the heatmap.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12345)
nw &lt;- random_network(10)
nw &lt;- set_node_names(nw, paste("node", 1:10, sep = "_"))
heatmap_network(nw, "Unweighted Network")
nw &lt;- gen_partial_correlations(nw)
heatmap_network(nw, "Weighted Network")
</code></pre>

<hr>
<h2 id='is_PD'>Internal function to check if a matrix is positive definite</h2><span id='topic+is_PD'></span>

<h3>Description</h3>

<p>Internal function to check if a matrix is positive definite
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_PD(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_PD_+3A_x">x</code></td>
<td>
<p>A matrix to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns TRUE if the matrix is positive definite and FALSE otherwise.
</p>

<hr>
<h2 id='is_symmetric_cpp'>C++ implementation to check if a matrix is symmetric</h2><span id='topic+is_symmetric_cpp'></span>

<h3>Description</h3>

<p>C++ implementation to check if a matrix is symmetric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_symmetric_cpp(m, tol = 1e-12)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_symmetric_cpp_+3A_m">m</code></td>
<td>
<p>A matrix to check.</p>
</td></tr>
<tr><td><code id="is_symmetric_cpp_+3A_tol">tol</code></td>
<td>
<p>A Numeric scalar &gt;= 0. Differences smaller than tol are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns TRUE if the matrix is symmetric and FALSE otherwise.
</p>

<hr>
<h2 id='is_weighted'>Check if an object is weighted</h2><span id='topic+is_weighted'></span>

<h3>Description</h3>

<p>Check if an object is weighted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_weighted(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_weighted_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="is_weighted_+3A_...">...</code></td>
<td>
<p>Additional arguments.
object are weighted by 0s and 1s, and returns <code>TRUE</code> otherwise. If there
are no connections in the module, then this function returns <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Boolean value indicating whether the input is weighted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(10)
# The network, and hence all of its modules, are unweighted.
is_weighted(nw)
sapply(nw$modules, is_weighted)
# Add random weights to the connections.
nw &lt;- gen_partial_correlations(nw)
# The network, and hence all of its modules, are now weighted.
is_weighted(nw)
sapply(nw$modules, is_weighted)
</code></pre>

<hr>
<h2 id='is_weighted.default'>Check if an object is weighted</h2><span id='topic+is_weighted.default'></span>

<h3>Description</h3>

<p>Check if an object is weighted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
is_weighted(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_weighted.default_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="is_weighted.default_+3A_...">...</code></td>
<td>
<p>Additional arguments.
object are weighted by 0s and 1s, and returns <code>TRUE</code> otherwise. If there
are no connections in the module, then this function returns <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Boolean value indicating whether the input is weighted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(10)
# The network, and hence all of its modules, are unweighted.
is_weighted(nw)
sapply(nw$modules, is_weighted)
# Add random weights to the connections.
nw &lt;- gen_partial_correlations(nw)
# The network, and hence all of its modules, are now weighted.
is_weighted(nw)
sapply(nw$modules, is_weighted)
</code></pre>

<hr>
<h2 id='is_weighted.matrix'>Check if an object is weighted</h2><span id='topic+is_weighted.matrix'></span>

<h3>Description</h3>

<p>Check if an object is weighted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
is_weighted(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_weighted.matrix_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="is_weighted.matrix_+3A_...">...</code></td>
<td>
<p>Additional arguments.
object are weighted by 0s and 1s, and returns <code>TRUE</code> otherwise. If there
are no connections in the module, then this function returns <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Boolean value indicating whether the input is weighted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(10)
# The network, and hence all of its modules, are unweighted.
is_weighted(nw)
sapply(nw$modules, is_weighted)
# Add random weights to the connections.
nw &lt;- gen_partial_correlations(nw)
# The network, and hence all of its modules, are now weighted.
is_weighted(nw)
sapply(nw$modules, is_weighted)
</code></pre>

<hr>
<h2 id='is_weighted.network'>Check if an object is weighted</h2><span id='topic+is_weighted.network'></span>

<h3>Description</h3>

<p>Check if an object is weighted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network'
is_weighted(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_weighted.network_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="is_weighted.network_+3A_...">...</code></td>
<td>
<p>Additional arguments.
object are weighted by 0s and 1s, and returns <code>TRUE</code> otherwise. If there
are no connections in the module, then this function returns <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Boolean value indicating whether the input is weighted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(10)
# The network, and hence all of its modules, are unweighted.
is_weighted(nw)
sapply(nw$modules, is_weighted)
# Add random weights to the connections.
nw &lt;- gen_partial_correlations(nw)
# The network, and hence all of its modules, are now weighted.
is_weighted(nw)
sapply(nw$modules, is_weighted)
</code></pre>

<hr>
<h2 id='is_weighted.network_module'>Check if an object is weighted</h2><span id='topic+is_weighted.network_module'></span>

<h3>Description</h3>

<p>Check if an object is weighted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network_module'
is_weighted(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_weighted.network_module_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="is_weighted.network_module_+3A_...">...</code></td>
<td>
<p>Additional arguments.
object are weighted by 0s and 1s, and returns <code>TRUE</code> otherwise. If there
are no connections in the module, then this function returns <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Boolean value indicating whether the input is weighted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(10)
# The network, and hence all of its modules, are unweighted.
is_weighted(nw)
sapply(nw$modules, is_weighted)
# Add random weights to the connections.
nw &lt;- gen_partial_correlations(nw)
# The network, and hence all of its modules, are now weighted.
is_weighted(nw)
sapply(nw$modules, is_weighted)
</code></pre>

<hr>
<h2 id='perturb_network'>Perturbs the connections in a network</h2><span id='topic+perturb_network'></span>

<h3>Description</h3>

<p>The network is perturbed by removing connections from hubs and/or rewiring
other nodes in the network. By default, one hub is turned off (i.e. its
connections are removed each with probability <code>rewire_hub_prob = 0.5</code>), and
no other nodes are changed. Hub nodes are defined as those having degree
above three standard deviations from the average degree, and nodes are
sampled from these to be turned off; if there are no hub nodes, then
those with the largest degree are turned off.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perturb_network(
  network,
  n_hubs = 1,
  n_nodes = 0,
  rewire_hub_prob = 0.5,
  rewire_other_prob = 0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="perturb_network_+3A_network">network</code></td>
<td>
<p>The network to modify.</p>
</td></tr>
<tr><td><code id="perturb_network_+3A_n_hubs">n_hubs</code></td>
<td>
<p>The number of hub nodes to turn off.</p>
</td></tr>
<tr><td><code id="perturb_network_+3A_n_nodes">n_nodes</code></td>
<td>
<p>The number of non-hub nodes to rewire. When rewiring, the
degree of the node is unchanged.</p>
</td></tr>
<tr><td><code id="perturb_network_+3A_rewire_hub_prob">rewire_hub_prob</code></td>
<td>
<p>The probability that a connection is removed from
a hub that is selected to be turned off. If <code>rewire_hub_prob = 1</code>, then
all of the connections to the hub are removed.</p>
</td></tr>
<tr><td><code id="perturb_network_+3A_rewire_other_prob">rewire_other_prob</code></td>
<td>
<p>The probability that a connection is rewired from
a non-hub that is selected for rewiring. If <code>rewire_other_prob = 1</code>, then
all of the connections to the hub are rewired; however, this does not mean
that all connections will be changed, as some connections may be removed
but later rewired back.</p>
</td></tr>
<tr><td><code id="perturb_network_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
<code><a href="#topic+rewire_connections_to_node">rewire_connections_to_node</a></code> and
<code><a href="#topic+remove_connections_to_node">remove_connections_to_node</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified network.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network, perturb the network, then plot the differential network.
set.seed(12345)
nw &lt;- random_network(100)
# Rewire 2 random hub genes and 10 other random genes:
nw_diff &lt;- perturb_network(nw, n_hubs = 2, n_nodes = 10)
plot_network_diff(nw, nw_diff) 
</code></pre>

<hr>
<h2 id='plot_gene_pair'>Scatter plot of two gene expressions</h2><span id='topic+plot_gene_pair'></span>

<h3>Description</h3>

<p>Plots the expression of two genes for visual assessment of association.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_gene_pair(
  x_list,
  geneA,
  geneB,
  method = "loess",
  se_alpha = 0.1,
  do_facet_wrap = FALSE,
  scales = "fixed"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_gene_pair_+3A_x_list">x_list</code></td>
<td>
<p>A named list containing one or more n by p gene expression
profiles, one for each group or subpopulation under consideration.</p>
</td></tr>
<tr><td><code id="plot_gene_pair_+3A_genea">geneA</code></td>
<td>
<p>The name of the first gene to plot. Must be either a character
string matching a column name in each matrix of <code>x_list</code> or an integer
to index the columns.</p>
</td></tr>
<tr><td><code id="plot_gene_pair_+3A_geneb">geneB</code></td>
<td>
<p>The name of the second gene to plot. Must be either a character
string matching a column name in each matrix of <code>x_list</code> or an integer
to index the columns.</p>
</td></tr>
<tr><td><code id="plot_gene_pair_+3A_method">method</code></td>
<td>
<p>Charater string either &quot;lm&quot; or &quot;loess&quot; used for plotting.
For no line, set <code>method = NULL</code>.</p>
</td></tr>
<tr><td><code id="plot_gene_pair_+3A_se_alpha">se_alpha</code></td>
<td>
<p>Sets transparancy of confidence interval around association
trend line. Set to 0 to remove the confidence interval.</p>
</td></tr>
<tr><td><code id="plot_gene_pair_+3A_do_facet_wrap">do_facet_wrap</code></td>
<td>
<p>If <code>TRUE</code>, the groups are plotted in seperate graphs.</p>
</td></tr>
<tr><td><code id="plot_gene_pair_+3A_scales">scales</code></td>
<td>
<p>Only used if <code>do_facet_wrap</code> is <code>TRUE</code>. See
<code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the generated plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(reference)
rnaseq &lt;- reference$rnaseq
genes &lt;- colnames(rnaseq)
plot_gene_pair(rnaseq, genes[1], genes[2])
# Suppose we had multiple data frames.
control &lt;- rnaseq[1:100, 1:10]
treatment1 &lt;- rnaseq[101:200, 1:10]
treatment2 &lt;- rnaseq[201:250, 1:10]
plot_gene_pair(list(ctrl = control, trt1 = treatment1, trt2 = treatment2),
               genes[1], genes[2], method = NA)
plot_gene_pair(list(ctrl = control, trt = treatment1),
               genes[1], genes[2], do_facet_wrap = TRUE, method = "lm")

</code></pre>

<hr>
<h2 id='plot_modules'>Visualize a network and its modules</h2><span id='topic+plot_modules'></span>

<h3>Description</h3>

<p>This function plots a network and highlights the individual modules.
An attempt is made to layout the nodes so that any visual overlaps among modules
correspond to true overlaps in the network, however it is possible that
a node may appear to be in multiple modules in the visualization when it does
not actually belong to multiple modules. If the result of another plot is
provided using the <code>compare_graph</code> argument, then the layout of this network
will be based on that plot and convex hulls are drawn to trace out the modules;
in this case it is likely that the displayed modules will contain extraneous
nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_modules(
  network,
  compare_graph = NULL,
  as_subgraph = TRUE,
  modules = NULL,
  node_scale = 4,
  edge_scale = 1,
  node_color = adjustcolor("orange", 0.5),
  group_color = palette.colors(9, "Set 1"),
  generate_layout = igraph::nicely,
  include_vertex_labels = TRUE,
  show_legend = FALSE,
  legend_position = "topright",
  legend_horizontal = FALSE,
  display_plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_modules_+3A_network">network</code></td>
<td>
<p>A 'network' object to plot. Alternatively, an adjacency or
association matrix can be provided, in which case the 'modules' argument
should be specified.</p>
</td></tr>
<tr><td><code id="plot_modules_+3A_compare_graph">compare_graph</code></td>
<td>
<p>The plot of another network to use for comparison.</p>
</td></tr>
<tr><td><code id="plot_modules_+3A_as_subgraph">as_subgraph</code></td>
<td>
<p>If <code>TRUE</code>, only nodes of positive degree will be shown.</p>
</td></tr>
<tr><td><code id="plot_modules_+3A_modules">modules</code></td>
<td>
<p>A list of modules for the network; this is used to provide
a member list of each module when the <code>network</code> argument is not a
'network' object. To get this list from a network, use
<code><a href="#topic+get_network_modules">get_network_modules</a></code>.</p>
</td></tr>
<tr><td><code id="plot_modules_+3A_node_scale">node_scale</code></td>
<td>
<p>Used for scaling of nodes.</p>
</td></tr>
<tr><td><code id="plot_modules_+3A_edge_scale">edge_scale</code></td>
<td>
<p>Used for scaling of edges.</p>
</td></tr>
<tr><td><code id="plot_modules_+3A_node_color">node_color</code></td>
<td>
<p>The color used for the nodes.</p>
</td></tr>
<tr><td><code id="plot_modules_+3A_group_color">group_color</code></td>
<td>
<p>A vector of colors used for the modules.</p>
</td></tr>
<tr><td><code id="plot_modules_+3A_generate_layout">generate_layout</code></td>
<td>
<p>A function to generate the layout of a graph; used
if coords is <code>NULL</code>. See <code><a href="igraph.html#topic+layout_">layout_</a></code> from
<span class="pkg"><a href="igraph.html#topic+igraph">igraph</a></span> for details. Other options include
<code><a href="igraph.html#topic+layout_as_star">as_star</a></code>, <code><a href="igraph.html#topic+layout_in_circle">in_circle</a></code>, and
<code><a href="igraph.html#topic+layout_with_fr">with_fr</a></code>, among many others.</p>
</td></tr>
<tr><td><code id="plot_modules_+3A_include_vertex_labels">include_vertex_labels</code></td>
<td>
<p>If <code>TRUE</code>, the verticies will be labeled.</p>
</td></tr>
<tr><td><code id="plot_modules_+3A_show_legend">show_legend</code></td>
<td>
<p>If <code>TRUE</code>, a legend for the modules is shown.
Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plot_modules_+3A_legend_position">legend_position</code></td>
<td>
<p>The location of the legend. Can be any one of
&quot;bottomright&quot;, &quot;bottom&quot;, &quot;bottomleft&quot;, &quot;left&quot;, &quot;topleft&quot;, &quot;top&quot;, &quot;topright&quot;,
&quot;right&quot; or &quot;center&quot;.</p>
</td></tr>
<tr><td><code id="plot_modules_+3A_legend_horizontal">legend_horizontal</code></td>
<td>
<p>If <code>TRUE</code>, the legend will be displayed
horizontally.</p>
</td></tr>
<tr><td><code id="plot_modules_+3A_display_plot">display_plot</code></td>
<td>
<p>If <code>TRUE</code> (default), the plot will be generated and
displayed.</p>
</td></tr>
<tr><td><code id="plot_modules_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'network_plot' object for the network. This object can be passed
back into a future call of <code><a href="#topic+plot.network">plot.network</a></code> through the
<code>compare_graph</code>  argument, which will setup the plot for easier
comparison between the old graph and the new graph of <code>network</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
# Networks can be plotted with modules highlighted.
nw &lt;- random_network(100)
g &lt;- plot_network(nw)
plot_modules(nw, g) # Overlay convex hulls around modules in previous layout.
</code></pre>

<hr>
<h2 id='plot_network'>Visualize a network</h2><span id='topic+plot_network'></span>

<h3>Description</h3>

<p>This function is used to plot a network. The <code>network</code> argument can be a
network object, network module, an adjacency matrix, or an association matrix.
If the result of another plot is provided using the <code>compare_graph</code> argument,
then the layout of this network will be based on that plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_network(
  network,
  compare_graph = NULL,
  as_subgraph = FALSE,
  node_scale = 4,
  edge_scale = 1,
  node_color = adjustcolor("orange", 0.5),
  generate_layout = igraph::nicely,
  include_vertex_labels = TRUE,
  display_plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_network_+3A_network">network</code></td>
<td>
<p>A 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="plot_network_+3A_compare_graph">compare_graph</code></td>
<td>
<p>The plot of another network to use for comparison.</p>
</td></tr>
<tr><td><code id="plot_network_+3A_as_subgraph">as_subgraph</code></td>
<td>
<p>If <code>TRUE</code>, only nodes of positive degree will be shown.</p>
</td></tr>
<tr><td><code id="plot_network_+3A_node_scale">node_scale</code></td>
<td>
<p>Used for scaling of nodes.</p>
</td></tr>
<tr><td><code id="plot_network_+3A_edge_scale">edge_scale</code></td>
<td>
<p>Used for scaling of edges.</p>
</td></tr>
<tr><td><code id="plot_network_+3A_node_color">node_color</code></td>
<td>
<p>The color used for the nodes.</p>
</td></tr>
<tr><td><code id="plot_network_+3A_generate_layout">generate_layout</code></td>
<td>
<p>A function to generate the layout of a graph; used
if coords is <code>NULL</code>. See <code><a href="igraph.html#topic+layout_">layout_</a></code> from <span class="pkg"><a href="igraph.html#topic+igraph">igraph</a></span>
for details. Other options include <code><a href="igraph.html#topic+layout_as_star">as_star</a></code>,
<code><a href="igraph.html#topic+layout_in_circle">in_circle</a></code>, and <code><a href="igraph.html#topic+layout_with_fr">with_fr</a></code>, among
many others.</p>
</td></tr>
<tr><td><code id="plot_network_+3A_include_vertex_labels">include_vertex_labels</code></td>
<td>
<p>If <code>TRUE</code>, the verticies will be labeled.</p>
</td></tr>
<tr><td><code id="plot_network_+3A_display_plot">display_plot</code></td>
<td>
<p>If <code>TRUE</code> (default), the plot will be generated and
displayed.</p>
</td></tr>
<tr><td><code id="plot_network_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Creates a plot of the network and returns a graph object.
The graph object can be passed back into a future call of
<code><a href="#topic+plot.network">plot.network</a></code> through the <code>compare_edge</code> argument, which
will setup the plot for easier comparison between the old graph and the graph
of <code>network</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
# Basic plotting for networks, modules, and matricies
nw &lt;- random_network(10)
plot(nw)
module &lt;- random_module(1:10)
plot(module)
adj_mat &lt;- get_adjacency_matrix(nw)
plot_network(adj_mat)
# To compare multiple networks, the layout from the first plot can be used
# in subsequent plots using the second argument, `compare_graph`.
nw1 &lt;- random_network(10)
nw2 &lt;- remove_connections_to_node(nw1, 6, prob_remove = 1)
g &lt;- plot(nw1)
plot(nw2, g)
# If the network contains many nodes of degree 0, plotting as subgraph
# may be preferred.
nw &lt;- random_network(100, n_modules = 1)
plot(nw)
plot(nw, as_subgraph = TRUE)
# Networks can be plotted with modules highlighted.
nw &lt;- random_network(100)
g &lt;- plot_network(nw)
plot_modules(nw, g)
# For large networks, the vertex labels can clutter the graph; these can
# be removed using the `include_vertex_labels` argument.
nw &lt;- random_network(250)
g &lt;- plot(nw)
plot(nw, g, include = FALSE)
</code></pre>

<hr>
<h2 id='plot_network_diff'>Plot the difference between two networks</h2><span id='topic+plot_network_diff'></span>

<h3>Description</h3>

<p>This function plots the difference in connectivity between two networks.
For two identical networks, the graph will be empty. For non-identical
networks, black edges are shared by both networks but differ in magnitude or
direction (if the networks are weighted), tan edges are in <code>network_1</code>
but not <code>network_2</code>, and red edges are in <code>network_2</code> but not
<code>network_1</code>. All edges are scaled according to the strongest association
in either network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_network_diff(
  network_1,
  network_2,
  compare_graph = NULL,
  as_subgraph = FALSE,
  node_scale = 4,
  edge_scale = 1,
  node_color = adjustcolor("orange", 0.5),
  edge_colors = c("black", "wheat", "red"),
  generate_layout = igraph::nicely,
  include_vertex_labels = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_network_diff_+3A_network_1">network_1</code></td>
<td>
<p>A 'network' or 'matrix' object.</p>
</td></tr>
<tr><td><code id="plot_network_diff_+3A_network_2">network_2</code></td>
<td>
<p>A 'network' or 'matrix' object.</p>
</td></tr>
<tr><td><code id="plot_network_diff_+3A_compare_graph">compare_graph</code></td>
<td>
<p>The plot of another network to use for comparison.</p>
</td></tr>
<tr><td><code id="plot_network_diff_+3A_as_subgraph">as_subgraph</code></td>
<td>
<p>If TRUE, only nodes of positive degree will be shown.</p>
</td></tr>
<tr><td><code id="plot_network_diff_+3A_node_scale">node_scale</code></td>
<td>
<p>Used for scaling of nodes.</p>
</td></tr>
<tr><td><code id="plot_network_diff_+3A_edge_scale">edge_scale</code></td>
<td>
<p>Used for scaling of edges.</p>
</td></tr>
<tr><td><code id="plot_network_diff_+3A_node_color">node_color</code></td>
<td>
<p>The color used for the nodes.</p>
</td></tr>
<tr><td><code id="plot_network_diff_+3A_edge_colors">edge_colors</code></td>
<td>
<p>A vector of three colors used for edges; the first colors
edges common to both network, the second colors edges in <code>network_1</code> but
not <code>network_2</code>, and the third colors edges that are in <code>network_2</code>
but not <code>network_2</code>. Default is <code>c("black", "wheat", "red")</code>.</p>
</td></tr>
<tr><td><code id="plot_network_diff_+3A_generate_layout">generate_layout</code></td>
<td>
<p>A function to generate the layout of a graph; used
if coords is <code>NULL</code>. See <code><a href="igraph.html#topic+layout_">layout_</a></code> from <span class="pkg"><a href="igraph.html#topic+igraph">igraph</a></span>
for details. Other options include <code><a href="igraph.html#topic+layout_as_star">as_star</a></code>,
<code><a href="igraph.html#topic+layout_in_circle">in_circle</a></code>, and <code><a href="igraph.html#topic+layout_with_fr">with_fr</a></code>, among
many others.</p>
</td></tr>
<tr><td><code id="plot_network_diff_+3A_include_vertex_labels">include_vertex_labels</code></td>
<td>
<p>If <code>TRUE</code>, the verticies will be labeled.</p>
</td></tr>
<tr><td><code id="plot_network_diff_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Creates a plot of the network and returns a graph object.
The graph object can be passed back into a future call of
<code><a href="#topic+plot_network">plot_network</a></code>, <code><a href="#topic+plot_network_diff">plot_network_diff</a></code>, or
<code><a href="#topic+plot_network_sim">plot_network_sim</a></code> through the <code>compare_edge</code> argument,
which will setup the plot for easier  comparison between the old graph and
the graph of <code>network</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create two networks, the second being a perturbation of the first.
nw1 &lt;- random_network(20)
nw2 &lt;- perturb_network(nw1, n_nodes = 5)
# Can compare networks by plotting each using the same layout.
g &lt;- plot(nw1)
plot(nw2, g)
# Or, the differential network can be plotted.
plot_network_diff(nw1, nw2, g)
</code></pre>

<hr>
<h2 id='plot_network_sim'>Plot the similarity between two networks</h2><span id='topic+plot_network_sim'></span>

<h3>Description</h3>

<p>This function plots the similarity of connections between two networks.
Both networks must be weighted. The width of each edge corresponds to
the strength of similarity and is calculated by sqrt(abs((s1 + s2)s1s2)),
where s1 and s2 are the weights for a particular
connection in <code>network_1</code> and <code>network_2</code>, respectively
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_network_sim(network_1, network_2, compare_graph = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_network_sim_+3A_network_1">network_1</code></td>
<td>
<p>A weighted 'network' or 'matrix' object.</p>
</td></tr>
<tr><td><code id="plot_network_sim_+3A_network_2">network_2</code></td>
<td>
<p>A weighted 'network' or 'matrix' object.</p>
</td></tr>
<tr><td><code id="plot_network_sim_+3A_compare_graph">compare_graph</code></td>
<td>
<p>The plot of another network to use for comparison.</p>
</td></tr>
<tr><td><code id="plot_network_sim_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+plot_network">plot_network</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Creates a plot of the network and returns a graph object.
The graph object can be passed back into a future call of
<code><a href="#topic+plot_network">plot_network</a></code>, <code><a href="#topic+plot_network_diff">plot_network_diff</a></code> or
<code><a href="#topic+plot_network_sim">plot_network_sim</a></code> through the <code>compare_edge</code> argument,
which will setup the plot for easier  comparison between the old graph and
the graph of <code>network</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create two networks, the second being a perturbation of the first.
nw1 &lt;- random_network(20)
nw2 &lt;- perturb_network(nw1, n_nodes = 5)
nw1 &lt;- gen_partial_correlations(nw1)
nw2 &lt;- gen_partial_correlations(nw2)
# Can compare networks by plotting each using the same layout.
g &lt;- plot(nw1)
plot(nw2, g)
# Or, plot the differential network or similarity network
plot_network_diff(nw1, nw2, g)
plot_network_sim(nw1, nw2, g)
# Note the behavior when both networks are the same.
plot_network_diff(nw1, nw1, g) # No differences produces an empty network
plot_network_sim(nw1, nw1, g) # Edge widths are still scaled by connection strength.
</code></pre>

<hr>
<h2 id='plot.network'>Plot function for 'network' object</h2><span id='topic+plot.network'></span>

<h3>Description</h3>

<p>This function plots the given network. If the result of another plot is
provided, this plot will be modified for easier comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network'
plot(x, compare_graph = NULL, show_modules = FALSE, as_subgraph = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.network_+3A_x">x</code></td>
<td>
<p>A 'network' object.</p>
</td></tr>
<tr><td><code id="plot.network_+3A_compare_graph">compare_graph</code></td>
<td>
<p>The plot of another network to use for comparison.</p>
</td></tr>
<tr><td><code id="plot.network_+3A_show_modules">show_modules</code></td>
<td>
<p>If <code>TRUE</code>, the modules will highlighted in the graph.
Defaults to <code>FALSE</code> if there is exactly one module in the network and to
<code>TRUE</code> otherwise.</p>
</td></tr>
<tr><td><code id="plot.network_+3A_as_subgraph">as_subgraph</code></td>
<td>
<p>If <code>TRUE</code>, only nodes of positive degree will be shown.
Defaults to <code>FALSE</code> if there are 100 or fewer nodes in the network and to
<code>TRUE</code> otherwise.</p>
</td></tr>
<tr><td><code id="plot.network_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+plot_modules">plot_modules</a></code> or
<code><a href="#topic+plot_network">plot_network</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Creates a plot of the module and returns a graph object.
See <code><a href="#topic+plot_modules">plot_modules</a></code> and <code><a href="#topic+plot_network">plot_network</a></code> for details.
</p>
<p>A 'network_plot' object for the network. This object can be passed
back into a future call of <code><a href="#topic+plot.network">plot.network</a></code> through the
<code>compare_graph</code> argument, which will setup the plot for easier
comparison between the old graph and the new graph of <code>network</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nw &lt;- random_network(10)
plot(nw)
</code></pre>

<hr>
<h2 id='plot.network_module'>Plot function for 'network_module' object.</h2><span id='topic+plot.network_module'></span>

<h3>Description</h3>

<p>Plot function for 'network_module' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network_module'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.network_module_+3A_x">x</code></td>
<td>
<p>A 'network_module' object.</p>
</td></tr>
<tr><td><code id="plot.network_module_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+plot_network">plot_network</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Creates a plot of the module and returns a graph object.
See <code><a href="#topic+plot_network">plot_network</a></code> for details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>module &lt;- random_module(1:10)
plot(module)
</code></pre>

<hr>
<h2 id='plot.network_plot'>Plot function for 'network_plot' class</h2><span id='topic+plot.network_plot'></span>

<h3>Description</h3>

<p>Plot function for 'network_plot' class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network_plot'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.network_plot_+3A_x">x</code></td>
<td>
<p>A 'network_plot' object obtained from <code><a href="#topic+plot.network">plot.network</a></code> or
<code><a href="#topic+plot_network">plot_network</a></code>.</p>
</td></tr>
<tr><td><code id="plot.network_plot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Creates a plot of the network and returns a graph object.
See <code><a href="#topic+plot_network">plot_network</a></code> for details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nw &lt;- random_network(10)
g &lt;- plot(nw)
# Can change the plot by modifying the instance `g`.
# For example, make vertex size and edge width twice as big.
g$edge.width &lt;- 2 * g$edge.width
g$vertex.size &lt;- 2 * g$vertex.size
# Change color of verticies, edges, and vertex labels.
g$edge.color &lt;- "orange"
g$vertex.color &lt;- "navy"
g$vertex.label.color &lt;- "white"
plot(g)
</code></pre>

<hr>
<h2 id='print.network'>Print function for 'network' object.</h2><span id='topic+print.network'></span>

<h3>Description</h3>

<p>Print function for 'network' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.network_+3A_x">x</code></td>
<td>
<p>A 'network' object.</p>
</td></tr>
<tr><td><code id="print.network_+3A_...">...</code></td>
<td>
<p>Additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints a summary of the module.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nw &lt;- random_network(10)
nw
print(nw)
</code></pre>

<hr>
<h2 id='print.network_module'>Print function for 'network_module' object.</h2><span id='topic+print.network_module'></span>

<h3>Description</h3>

<p>Print function for 'network_module' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network_module'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.network_module_+3A_x">x</code></td>
<td>
<p>A 'network_module' object.</p>
</td></tr>
<tr><td><code id="print.network_module_+3A_...">...</code></td>
<td>
<p>Additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints a summary of the module.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>module &lt;- random_module(1:10)
module
print(module)
</code></pre>

<hr>
<h2 id='print.network_plot'>Print function for 'network_plot' class</h2><span id='topic+print.network_plot'></span>

<h3>Description</h3>

<p>Displays the network plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network_plot'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.network_plot_+3A_x">x</code></td>
<td>
<p>A 'network_plot' object obtained from <code><a href="#topic+plot.network">plot.network</a></code> or
<code><a href="#topic+plot_network">plot_network</a></code>.</p>
</td></tr>
<tr><td><code id="print.network_plot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="graphics.html#topic+plot.default">plot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Creates a plot of the network and returns a graph object.
See <code><a href="#topic+plot_network">plot_network</a></code> for details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nw &lt;- random_network(10)
g &lt;- plot(nw, display_plot = FALSE) # Doesn't display the plot.
g # Displays the plot.
</code></pre>

<hr>
<h2 id='pzinb'>The Zero-Inflated Negative Binomial Distribution</h2><span id='topic+pzinb'></span>

<h3>Description</h3>

<p>The Zero-Inflated Negative Binomial Distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pzinb(q, size, mu, rho, lower.tail = TRUE, log.p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pzinb_+3A_q">q</code></td>
<td>
<p>A vector of quantities.</p>
</td></tr>
<tr><td><code id="pzinb_+3A_size">size</code></td>
<td>
<p>The dispersion paramater used in <code><a href="stats.html#topic+NegBinomial">dnbinom</a></code></p>
</td></tr>
<tr><td><code id="pzinb_+3A_mu">mu</code></td>
<td>
<p>The mean parameter used in <code><a href="stats.html#topic+NegBinomial">dnbinom</a></code>.</p>
</td></tr>
<tr><td><code id="pzinb_+3A_rho">rho</code></td>
<td>
<p>The zero-inflation parameter.</p>
</td></tr>
<tr><td><code id="pzinb_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if <code>TRUE</code>, then probabilities are P(X &lt;= x).
Otherwise, P(X &gt; x).</p>
</td></tr>
<tr><td><code id="pzinb_+3A_log.p">log.p</code></td>
<td>
<p>Logical; if <code>TRUE</code>, then log(p) is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The probabilities for the given <code>q</code> values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rzinb(10, 1, 10, 0.1)
p &lt;- pzinb(x, 1, 10, 0.1)
y &lt;- qzinb(p, 1, 10, 0.1)
all(x == y)
# Compute P(0 &lt; X &lt; 5) for X ~ ZINB(1, 10, 0.1)
sum(dzinb(0:5, 1, 10, 0.1))
</code></pre>

<hr>
<h2 id='qzinb'>The Zero-Inflated Negative Binomial Distribution</h2><span id='topic+qzinb'></span>

<h3>Description</h3>

<p>The Zero-Inflated Negative Binomial Distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qzinb(p, size, mu, rho, lower.tail = TRUE, log.p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qzinb_+3A_p">p</code></td>
<td>
<p>A vector of probabilities</p>
</td></tr>
<tr><td><code id="qzinb_+3A_size">size</code></td>
<td>
<p>The dispersion paramater used in <code><a href="stats.html#topic+NegBinomial">dnbinom</a></code></p>
</td></tr>
<tr><td><code id="qzinb_+3A_mu">mu</code></td>
<td>
<p>The mean parameter used in <code><a href="stats.html#topic+NegBinomial">dnbinom</a></code>.</p>
</td></tr>
<tr><td><code id="qzinb_+3A_rho">rho</code></td>
<td>
<p>The zero-inflation parameter.</p>
</td></tr>
<tr><td><code id="qzinb_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if <code>TRUE</code>, then probabilities are P(X &lt;= x).
Otherwise, P(X &gt; x).</p>
</td></tr>
<tr><td><code id="qzinb_+3A_log.p">log.p</code></td>
<td>
<p>Logical; if <code>TRUE</code>, then exp(p) is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The quantiles for the given probabilities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rzinb(10, 1, 10, 0.1)
p &lt;- pzinb(x, 1, 10, 0.1)
y &lt;- qzinb(p, 1, 10, 0.1)
all(x == y)
# Compute P(0 &lt; X &lt; 5) for X ~ ZINB(1, 10, 0.1)
sum(dzinb(0:5, 1, 10, 0.1))
</code></pre>

<hr>
<h2 id='random_module'>Create a random module</h2><span id='topic+random_module'></span>

<h3>Description</h3>

<p>Create a random module
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_module(nodes, module_name = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_module_+3A_nodes">nodes</code></td>
<td>
<p>A numeric vector indicating which nodes in the network
are contained in this module.</p>
</td></tr>
<tr><td><code id="random_module_+3A_module_name">module_name</code></td>
<td>
<p>(optional) Character string specifying the name of the
module. If <code>NULL</code>, the module will be unnamed.</p>
</td></tr>
<tr><td><code id="random_module_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
<code><a href="#topic+random_module_structure">random_module_structure</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'network_module' object.
</p>


<h3>References</h3>

<p>Grimes T, Datta S (2021).
&ldquo;SeqNet: An R Package for Generating Gene-Gene Networks and Simulating RNA-Seq Data.&rdquo;
<em>Journal of Statistical Software</em>, <b>98</b>(12), 1&ndash;49.
doi: <a href="https://doi.org/10.18637/jss.v098.i12">10.18637/jss.v098.i12</a>, <a href="https://doi.org/10.18637/jss.v098.i12">https://doi.org/10.18637/jss.v098.i12</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>module &lt;- random_module(1:10)
</code></pre>

<hr>
<h2 id='random_module_structure'>Create a random network structure for a module</h2><span id='topic+random_module_structure'></span>

<h3>Description</h3>

<p>A single, connected graph is created. The graph is initialized as a ring
lattice, and edges are randomly rewired and/or removed. The procedure
is similar to the Watts-Strogatz method, but the sampling of edges to
modify can be based on the degree of each node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_module_structure(
  size,
  prob_rewire = 1,
  prob_remove = 0.5,
  weights = NULL,
  neig_size = 3,
  alpha = 100,
  beta = 1,
  epsilon = 10^-5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_module_structure_+3A_size">size</code></td>
<td>
<p>The number of nodes to include in the graph.</p>
</td></tr>
<tr><td><code id="random_module_structure_+3A_prob_rewire">prob_rewire</code></td>
<td>
<p>The probability of rewiring an edge.</p>
</td></tr>
<tr><td><code id="random_module_structure_+3A_prob_remove">prob_remove</code></td>
<td>
<p>The probability of removing an edge.</p>
</td></tr>
<tr><td><code id="random_module_structure_+3A_weights">weights</code></td>
<td>
<p>(Optional) Weights used for sampling nodes. See
<code><a href="#topic+rewire_connections_to_node">rewire_connections_to_node</a></code> and
<code><a href="#topic+remove_connections_to_node">remove_connections_to_node</a></code> for details.</p>
</td></tr>
<tr><td><code id="random_module_structure_+3A_neig_size">neig_size</code></td>
<td>
<p>The neighborhood size within which the nodes of the
ring lattice are connected. The initial degree of each node is
<code>2 * neig_size</code>, so long as <code>size &gt;= (1 + 2 * neig_size)</code>.</p>
</td></tr>
<tr><td><code id="random_module_structure_+3A_alpha">alpha</code></td>
<td>
<p>A positive value used to parameterize the Beta distribution.</p>
</td></tr>
<tr><td><code id="random_module_structure_+3A_beta">beta</code></td>
<td>
<p>A positive value used to parameterize the Beta distribution.</p>
</td></tr>
<tr><td><code id="random_module_structure_+3A_epsilon">epsilon</code></td>
<td>
<p>A small constant added to the sampling probability of each node.</p>
</td></tr>
<tr><td><code id="random_module_structure_+3A_...">...</code></td>
<td>
<p>Additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An adjacency matrix representing the network structure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random module structure (an adjacency matrix) for 10 nodes.
adj_mat &lt;- random_module_structure(10)
# A network object can be created using this structure.
module &lt;- create_module_from_adjacency_matrix(adj_mat)
nw &lt;- create_network_from_modules(10, module)
</code></pre>

<hr>
<h2 id='random_network'>Create a network object.</h2><span id='topic+random_network'></span>

<h3>Description</h3>

<p>Creates an unweighted 'network' object containing randomly generated
modules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_network(p, n_modules = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_network_+3A_p">p</code></td>
<td>
<p>The number of nodes in the network. If <code>p</code> is much larger than
10^4, computation may begin to slow depending on the average module size and
the amount of overlap among modules.</p>
</td></tr>
<tr><td><code id="random_network_+3A_n_modules">n_modules</code></td>
<td>
<p>The number of modules to include in the network. If
<code>NULL</code>, then modules are created until all nodes in the network have
positive degree.</p>
</td></tr>
<tr><td><code id="random_network_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to other methods. Possible arguments
include:
</p>

<table>
<tr>
 <td style="text-align: left;">
nu </td><td style="text-align: left;">
A value between 0 and 1 used to control the amount of overlap among
modules. Smaller values result in less overlap. Used in
<code><a href="#topic+sample_module_nodes">sample_module_nodes</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">

prob_rewire </td><td style="text-align: left;">
The probability of removing a connection from the local network
structure; this is applied to each edge created. Used in
<code><a href="#topic+random_module_structure">random_module_structure</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">

prob_remove </td><td style="text-align: left;">
The probability of rewiring a connection from the local network
structure; this is applied every connection of each node. See
<code><a href="#topic+random_module_structure">random_module_structure</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">

neig_size </td><td style="text-align: left;">
The initial degree of each node when constructing the ring lattice.
See <code><a href="#topic+random_module_structure">random_module_structure</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">

alpha </td><td style="text-align: left;">
A positive value used to parameterize the Beta distribution used
to sample nodes based on their degree. Larger values will place more weight
on highly connected nodes. See <code><a href="#topic+random_module_structure">random_module_structure</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">

beta </td><td style="text-align: left;"> A positive value used to parameterize the Beta distribution used
to sample nodes based on their degree. Set to 1 by default. Increasing this
parameter will cause the sampling to favor moderately connected nodes over
the extreme tail of highly connected nodes.
See <code><a href="#topic+random_module_structure">random_module_structure</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">

epsilon </td><td style="text-align: left;"> A small constant added to the sampling probability of each node.
See <code><a href="#topic+random_module_structure">random_module_structure</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">

avg_module_size </td><td style="text-align: left;">
See <code><a href="#topic+create_modules_for_network">create_modules_for_network</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">

sd_module_size </td><td style="text-align: left;">
See <code><a href="#topic+create_modules_for_network">create_modules_for_network</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">

min_module_size </td><td style="text-align: left;">
See <code><a href="#topic+create_modules_for_network">create_modules_for_network</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">

max_module_size </td><td style="text-align: left;">
See <code><a href="#topic+create_modules_for_network">create_modules_for_network</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>
</td></tr>
</table>


<h3>Value</h3>

<p>An unweighted network object.
</p>


<h3>References</h3>

<p>Grimes T, Datta S (2021).
&ldquo;SeqNet: An R Package for Generating Gene-Gene Networks and Simulating RNA-Seq Data.&rdquo;
<em>Journal of Statistical Software</em>, <b>98</b>(12), 1&ndash;49.
doi: <a href="https://doi.org/10.18637/jss.v098.i12">10.18637/jss.v098.i12</a>, <a href="https://doi.org/10.18637/jss.v098.i12">https://doi.org/10.18637/jss.v098.i12</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network of 10 nodes
nw &lt;- random_network(10)
nw
# Add a random weight to each connection.
nw &lt;- gen_partial_correlations(nw)
# Plot the network
plot(nw)
</code></pre>

<hr>
<h2 id='reference'>RNA-seq reference dataset</h2><span id='topic+reference'></span>

<h3>Description</h3>

<p>The reference is a breast invasive carcinoma dataset containing gene
expression profiles generated by The Cancer Genome Atlas (TCGA) and
downloaded using the LinkedOmics portal. The dataset contains 1093 samples
and 15944 genes. The reference is a list containing a data frame of the
expression data and a data frame of estimated ZINB parameters for each
expression profile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reference
</code></pre>


<h3>Format</h3>

<p>A list containing two data frames:
</p>

<dl>
<dt>$rnaseq</dt><dd><p>A 1093 by 15944 data frame containing the raw RNA-seq
expression counts</p>
</dd>
<dt>$params</dt><dd><p>A 3 by 15944 data frame containing the estimated
ZINB parameters for each expression profile</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="http://www.linkedomics.org/data_download/TCGA-BRCA/">http://www.linkedomics.org/data_download/TCGA-BRCA/</a>
</p>

<hr>
<h2 id='remove_connections'>Remove connections in a network</h2><span id='topic+remove_connections'></span>

<h3>Description</h3>

<p>Remove connections in a network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_connections(x, prob_remove, run_checks = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_connections_+3A_x">x</code></td>
<td>
<p>The 'network', 'network_module', or 'matrix' object to modify.</p>
</td></tr>
<tr><td><code id="remove_connections_+3A_prob_remove">prob_remove</code></td>
<td>
<p>A value between 0 and 1. Each edge will be removed with
probability equal to <code>prob_remove</code>.</p>
</td></tr>
<tr><td><code id="remove_connections_+3A_run_checks">run_checks</code></td>
<td>
<p>If <code>TRUE</code> and 'x' is a matrix, then it is checked that
'x' is an adjacency matrix. This catches the case where 'x' is a weighted
matrix, in which case the weights are removed and a warning is given.</p>
</td></tr>
<tr><td><code id="remove_connections_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified adjacency matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(20)
# Remove connections in the network each with probability 1/2.
nw_rewired &lt;- remove_connections(nw, 0.5)
# Plot the two networks for comparison
g &lt;- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired)
</code></pre>

<hr>
<h2 id='remove_connections_to_node'>Remove connections to a node</h2><span id='topic+remove_connections_to_node'></span>

<h3>Description</h3>

<p>Remove connections to a node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_connections_to_node(x, node, prob_remove, run_checks = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_connections_to_node_+3A_x">x</code></td>
<td>
<p>The 'network', 'network_module', or 'matrix' object to modify.</p>
</td></tr>
<tr><td><code id="remove_connections_to_node_+3A_node">node</code></td>
<td>
<p>The node to unwire.</p>
</td></tr>
<tr><td><code id="remove_connections_to_node_+3A_prob_remove">prob_remove</code></td>
<td>
<p>A value between 0 and 1. Each connection to <code>node</code>
will be removed with probability equal to <code>prob_remove</code>.</p>
</td></tr>
<tr><td><code id="remove_connections_to_node_+3A_run_checks">run_checks</code></td>
<td>
<p>If <code>TRUE</code> and 'x' is a matrix, then it is checked that
'x' is an adjacency matrix. This catches the case where 'x' is a weighted
matrix, in which case the weights are removed and a warning is given.</p>
</td></tr>
<tr><td><code id="remove_connections_to_node_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified adjacency matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(10)
# Remove all connections to node 1.
nw_rewired &lt;- remove_connections_to_node(nw, 1, 1)
# Plot the two networks for comparison
g &lt;- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired)
</code></pre>

<hr>
<h2 id='remove_connections_to_node.default'>Remove connections to a node</h2><span id='topic+remove_connections_to_node.default'></span>

<h3>Description</h3>

<p>Remove connections to a node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
remove_connections_to_node(x, node, prob_remove, run_checks = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_connections_to_node.default_+3A_x">x</code></td>
<td>
<p>The 'network', 'network_module', or 'matrix' object to modify.</p>
</td></tr>
<tr><td><code id="remove_connections_to_node.default_+3A_node">node</code></td>
<td>
<p>The node to unwire.</p>
</td></tr>
<tr><td><code id="remove_connections_to_node.default_+3A_prob_remove">prob_remove</code></td>
<td>
<p>A value between 0 and 1. Each connection to <code>node</code>
will be removed with probability equal to <code>prob_remove</code>.</p>
</td></tr>
<tr><td><code id="remove_connections_to_node.default_+3A_run_checks">run_checks</code></td>
<td>
<p>If <code>TRUE</code> and 'x' is a matrix, then it is checked that
'x' is an adjacency matrix. This catches the case where 'x' is a weighted
matrix, in which case the weights are removed and a warning is given.</p>
</td></tr>
<tr><td><code id="remove_connections_to_node.default_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified adjacency matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(10)
# Remove all connections to node 1.
nw_rewired &lt;- remove_connections_to_node(nw, 1, 1)
# Plot the two networks for comparison
g &lt;- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired)
</code></pre>

<hr>
<h2 id='remove_connections_to_node.matrix'>Remove connections to a node</h2><span id='topic+remove_connections_to_node.matrix'></span>

<h3>Description</h3>

<p>Remove connections to a node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
remove_connections_to_node(x, node, prob_remove, run_checks = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_connections_to_node.matrix_+3A_x">x</code></td>
<td>
<p>The 'network', 'network_module', or 'matrix' object to modify.</p>
</td></tr>
<tr><td><code id="remove_connections_to_node.matrix_+3A_node">node</code></td>
<td>
<p>The node to unwire.</p>
</td></tr>
<tr><td><code id="remove_connections_to_node.matrix_+3A_prob_remove">prob_remove</code></td>
<td>
<p>A value between 0 and 1. Each connection to <code>node</code>
will be removed with probability equal to <code>prob_remove</code>.</p>
</td></tr>
<tr><td><code id="remove_connections_to_node.matrix_+3A_run_checks">run_checks</code></td>
<td>
<p>If <code>TRUE</code> and 'x' is a matrix, then it is checked that
'x' is an adjacency matrix. This catches the case where 'x' is a weighted
matrix, in which case the weights are removed and a warning is given.</p>
</td></tr>
<tr><td><code id="remove_connections_to_node.matrix_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified adjacency matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(10)
# Remove all connections to node 1.
nw_rewired &lt;- remove_connections_to_node(nw, 1, 1)
# Plot the two networks for comparison
g &lt;- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired)
</code></pre>

<hr>
<h2 id='remove_connections_to_node.network'>Remove connections to a node</h2><span id='topic+remove_connections_to_node.network'></span>

<h3>Description</h3>

<p>Remove connections to a node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network'
remove_connections_to_node(x, node, prob_remove, run_checks = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_connections_to_node.network_+3A_x">x</code></td>
<td>
<p>The 'network', 'network_module', or 'matrix' object to modify.</p>
</td></tr>
<tr><td><code id="remove_connections_to_node.network_+3A_node">node</code></td>
<td>
<p>The node to unwire.</p>
</td></tr>
<tr><td><code id="remove_connections_to_node.network_+3A_prob_remove">prob_remove</code></td>
<td>
<p>A value between 0 and 1. Each connection to <code>node</code>
will be removed with probability equal to <code>prob_remove</code>.</p>
</td></tr>
<tr><td><code id="remove_connections_to_node.network_+3A_run_checks">run_checks</code></td>
<td>
<p>If <code>TRUE</code> and 'x' is a matrix, then it is checked that
'x' is an adjacency matrix. This catches the case where 'x' is a weighted
matrix, in which case the weights are removed and a warning is given.</p>
</td></tr>
<tr><td><code id="remove_connections_to_node.network_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified adjacency matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(10)
# Remove all connections to node 1.
nw_rewired &lt;- remove_connections_to_node(nw, 1, 1)
# Plot the two networks for comparison
g &lt;- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired)
</code></pre>

<hr>
<h2 id='remove_connections_to_node.network_module'>Remove connections to a node</h2><span id='topic+remove_connections_to_node.network_module'></span>

<h3>Description</h3>

<p>Remove connections to a node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network_module'
remove_connections_to_node(x, node, prob_remove, run_checks = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_connections_to_node.network_module_+3A_x">x</code></td>
<td>
<p>The 'network', 'network_module', or 'matrix' object to modify.</p>
</td></tr>
<tr><td><code id="remove_connections_to_node.network_module_+3A_node">node</code></td>
<td>
<p>The node to unwire.</p>
</td></tr>
<tr><td><code id="remove_connections_to_node.network_module_+3A_prob_remove">prob_remove</code></td>
<td>
<p>A value between 0 and 1. Each connection to <code>node</code>
will be removed with probability equal to <code>prob_remove</code>.</p>
</td></tr>
<tr><td><code id="remove_connections_to_node.network_module_+3A_run_checks">run_checks</code></td>
<td>
<p>If <code>TRUE</code> and 'x' is a matrix, then it is checked that
'x' is an adjacency matrix. This catches the case where 'x' is a weighted
matrix, in which case the weights are removed and a warning is given.</p>
</td></tr>
<tr><td><code id="remove_connections_to_node.network_module_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified adjacency matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(10)
# Remove all connections to node 1.
nw_rewired &lt;- remove_connections_to_node(nw, 1, 1)
# Plot the two networks for comparison
g &lt;- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired)
</code></pre>

<hr>
<h2 id='remove_connections.default'>Remove connections in a network</h2><span id='topic+remove_connections.default'></span>

<h3>Description</h3>

<p>Remove connections in a network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
remove_connections(x, prob_remove, run_checks = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_connections.default_+3A_x">x</code></td>
<td>
<p>The 'network', 'network_module', or 'matrix' object to modify.</p>
</td></tr>
<tr><td><code id="remove_connections.default_+3A_prob_remove">prob_remove</code></td>
<td>
<p>A value between 0 and 1. Each edge will be removed with
probability equal to <code>prob_remove</code>.</p>
</td></tr>
<tr><td><code id="remove_connections.default_+3A_run_checks">run_checks</code></td>
<td>
<p>If <code>TRUE</code> and 'x' is a matrix, then it is checked that
'x' is an adjacency matrix. This catches the case where 'x' is a weighted
matrix, in which case the weights are removed and a warning is given.</p>
</td></tr>
<tr><td><code id="remove_connections.default_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified adjacency matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(20)
# Remove connections in the network each with probability 1/2.
nw_rewired &lt;- remove_connections(nw, 0.5)
# Plot the two networks for comparison
g &lt;- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired)
</code></pre>

<hr>
<h2 id='remove_connections.matrix'>Remove connections in a network</h2><span id='topic+remove_connections.matrix'></span>

<h3>Description</h3>

<p>Remove connections in a network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
remove_connections(x, prob_remove, run_checks = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_connections.matrix_+3A_x">x</code></td>
<td>
<p>The 'network', 'network_module', or 'matrix' object to modify.</p>
</td></tr>
<tr><td><code id="remove_connections.matrix_+3A_prob_remove">prob_remove</code></td>
<td>
<p>A value between 0 and 1. Each edge will be removed with
probability equal to <code>prob_remove</code>.</p>
</td></tr>
<tr><td><code id="remove_connections.matrix_+3A_run_checks">run_checks</code></td>
<td>
<p>If <code>TRUE</code> and 'x' is a matrix, then it is checked that
'x' is an adjacency matrix. This catches the case where 'x' is a weighted
matrix, in which case the weights are removed and a warning is given.</p>
</td></tr>
<tr><td><code id="remove_connections.matrix_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified adjacency matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(20)
# Remove connections in the network each with probability 1/2.
nw_rewired &lt;- remove_connections(nw, 0.5)
# Plot the two networks for comparison
g &lt;- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired)
</code></pre>

<hr>
<h2 id='remove_connections.network'>Remove connections in a network</h2><span id='topic+remove_connections.network'></span>

<h3>Description</h3>

<p>Remove connections in a network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network'
remove_connections(x, prob_remove, run_checks = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_connections.network_+3A_x">x</code></td>
<td>
<p>The 'network', 'network_module', or 'matrix' object to modify.</p>
</td></tr>
<tr><td><code id="remove_connections.network_+3A_prob_remove">prob_remove</code></td>
<td>
<p>A value between 0 and 1. Each edge will be removed with
probability equal to <code>prob_remove</code>.</p>
</td></tr>
<tr><td><code id="remove_connections.network_+3A_run_checks">run_checks</code></td>
<td>
<p>If <code>TRUE</code> and 'x' is a matrix, then it is checked that
'x' is an adjacency matrix. This catches the case where 'x' is a weighted
matrix, in which case the weights are removed and a warning is given.</p>
</td></tr>
<tr><td><code id="remove_connections.network_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified adjacency matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(20)
# Remove connections in the network each with probability 1/2.
nw_rewired &lt;- remove_connections(nw, 0.5)
# Plot the two networks for comparison
g &lt;- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired)
</code></pre>

<hr>
<h2 id='remove_connections.network_module'>Remove connections in a network</h2><span id='topic+remove_connections.network_module'></span>

<h3>Description</h3>

<p>Remove connections in a network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network_module'
remove_connections(x, prob_remove, run_checks = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_connections.network_module_+3A_x">x</code></td>
<td>
<p>The 'network', 'network_module', or 'matrix' object to modify.</p>
</td></tr>
<tr><td><code id="remove_connections.network_module_+3A_prob_remove">prob_remove</code></td>
<td>
<p>A value between 0 and 1. Each edge will be removed with
probability equal to <code>prob_remove</code>.</p>
</td></tr>
<tr><td><code id="remove_connections.network_module_+3A_run_checks">run_checks</code></td>
<td>
<p>If <code>TRUE</code> and 'x' is a matrix, then it is checked that
'x' is an adjacency matrix. This catches the case where 'x' is a weighted
matrix, in which case the weights are removed and a warning is given.</p>
</td></tr>
<tr><td><code id="remove_connections.network_module_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified adjacency matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(20)
# Remove connections in the network each with probability 1/2.
nw_rewired &lt;- remove_connections(nw, 0.5)
# Plot the two networks for comparison
g &lt;- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired)
</code></pre>

<hr>
<h2 id='remove_weights'>Removes the weights of all connections</h2><span id='topic+remove_weights'></span>

<h3>Description</h3>

<p>Removes the weights of all connections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_weights(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_weights_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="remove_weights_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes and add random edge weights.
nw &lt;- random_network(10)
nw &lt;- gen_partial_correlations(nw)
is_weighted(nw)
# Remove the edge weights from the network.
nw &lt;- remove_weights(nw)
is_weighted(nw)
</code></pre>

<hr>
<h2 id='remove_weights.default'>Removes the weights of all connections</h2><span id='topic+remove_weights.default'></span>

<h3>Description</h3>

<p>Removes the weights of all connections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
remove_weights(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_weights.default_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="remove_weights.default_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes and add random edge weights.
nw &lt;- random_network(10)
nw &lt;- gen_partial_correlations(nw)
is_weighted(nw)
# Remove the edge weights from the network.
nw &lt;- remove_weights(nw)
is_weighted(nw)
</code></pre>

<hr>
<h2 id='remove_weights.matrix'>Removes the weights of all connections</h2><span id='topic+remove_weights.matrix'></span>

<h3>Description</h3>

<p>Removes the weights of all connections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
remove_weights(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_weights.matrix_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="remove_weights.matrix_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes and add random edge weights.
nw &lt;- random_network(10)
nw &lt;- gen_partial_correlations(nw)
is_weighted(nw)
# Remove the edge weights from the network.
nw &lt;- remove_weights(nw)
is_weighted(nw)
</code></pre>

<hr>
<h2 id='remove_weights.network'>Removes the weights of all connections</h2><span id='topic+remove_weights.network'></span>

<h3>Description</h3>

<p>Removes the weights of all connections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network'
remove_weights(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_weights.network_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="remove_weights.network_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes and add random edge weights.
nw &lt;- random_network(10)
nw &lt;- gen_partial_correlations(nw)
is_weighted(nw)
# Remove the edge weights from the network.
nw &lt;- remove_weights(nw)
is_weighted(nw)
</code></pre>

<hr>
<h2 id='remove_weights.network_module'>Removes the weights of all connections</h2><span id='topic+remove_weights.network_module'></span>

<h3>Description</h3>

<p>Removes the weights of all connections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network_module'
remove_weights(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_weights.network_module_+3A_x">x</code></td>
<td>
<p>Either a 'network', 'network_module', or 'matrix' object.</p>
</td></tr>
<tr><td><code id="remove_weights.network_module_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes and add random edge weights.
nw &lt;- random_network(10)
nw &lt;- gen_partial_correlations(nw)
is_weighted(nw)
# Remove the edge weights from the network.
nw &lt;- remove_weights(nw)
is_weighted(nw)
</code></pre>

<hr>
<h2 id='replace_module_in_network'>Internal function for replacing a module in the network</h2><span id='topic+replace_module_in_network'></span>

<h3>Description</h3>

<p>Internal function for replacing a module in the network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_module_in_network(module_index, module, network)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="replace_module_in_network_+3A_module_index">module_index</code></td>
<td>
<p>The index of the module to replace.</p>
</td></tr>
<tr><td><code id="replace_module_in_network_+3A_module">module</code></td>
<td>
<p>The new module to replace with.</p>
</td></tr>
<tr><td><code id="replace_module_in_network_+3A_network">network</code></td>
<td>
<p>The network to modify.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified network.
</p>

<hr>
<h2 id='rewire_connections'>Rewire connections</h2><span id='topic+rewire_connections'></span>

<h3>Description</h3>

<p>Rewire connections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rewire_connections(
  x,
  prob_rewire = 1,
  weights = NULL,
  alpha = 100,
  beta = 1,
  epsilon = 10^-5,
  run_checks = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rewire_connections_+3A_x">x</code></td>
<td>
<p>The 'network', 'network_module', or 'matrix' object to modify.</p>
</td></tr>
<tr><td><code id="rewire_connections_+3A_prob_rewire">prob_rewire</code></td>
<td>
<p>A value between 0 and 1. The connections to each node
will be rewired with probability equal to <code>prob_rewire</code>.</p>
</td></tr>
<tr><td><code id="rewire_connections_+3A_weights">weights</code></td>
<td>
<p>(Optional) A vector of weights for each node. These are used
in addition to the degree of each node when sampling a node to rewire to.</p>
</td></tr>
<tr><td><code id="rewire_connections_+3A_alpha">alpha</code></td>
<td>
<p>A positive value used to parameterize the Beta distribution.</p>
</td></tr>
<tr><td><code id="rewire_connections_+3A_beta">beta</code></td>
<td>
<p>A positive value used to parameterize the Beta distribution.</p>
</td></tr>
<tr><td><code id="rewire_connections_+3A_epsilon">epsilon</code></td>
<td>
<p>A small constant added to the sampling probability of each
node.</p>
</td></tr>
<tr><td><code id="rewire_connections_+3A_run_checks">run_checks</code></td>
<td>
<p>If <code>TRUE</code> and 'x' is a matrix, then it is checked that
'x' is an adjacency matrix. This catches the case where 'x' is a weighted
matrix, in which case the weights are removed and a warning is given.</p>
</td></tr>
<tr><td><code id="rewire_connections_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified module.
</p>


<h3>Note</h3>

<p>When applied to a network object, all modules in the network are
rewired. If
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(10)
# Rewire nodes in the network each with probability 1/2
nw_rewired &lt;- rewire_connections(nw, 0.5)
# Plot the two networks for comparison
g &lt;- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired, g)
</code></pre>

<hr>
<h2 id='rewire_connections_to_node'>Rewire connections to a node</h2><span id='topic+rewire_connections_to_node'></span>

<h3>Description</h3>

<p>Rewire connections to a node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rewire_connections_to_node(
  x,
  node,
  prob_rewire = 1,
  weights = NULL,
  alpha = 100,
  beta = 1,
  epsilon = 10^-5,
  run_checks = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rewire_connections_to_node_+3A_x">x</code></td>
<td>
<p>The 'network', 'network_module', or 'matrix' object to modify.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node_+3A_node">node</code></td>
<td>
<p>The node to rewire.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node_+3A_prob_rewire">prob_rewire</code></td>
<td>
<p>A value between 0 and 1, inclusive. Each connection to
<code>node</code> will be rewired with probability equal to <code>prob_rewire</code>.
Note, the degree of <code>node</code> is unchanged after this operation.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node_+3A_weights">weights</code></td>
<td>
<p>(Optional) A vector of weights for each node. These are used
in addition to the degree of each node when sampling nodes to rewire.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node_+3A_alpha">alpha</code></td>
<td>
<p>A positive value used to parameterize the Beta distribution.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node_+3A_beta">beta</code></td>
<td>
<p>A positive value used to parameterize the Beta distribution.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node_+3A_epsilon">epsilon</code></td>
<td>
<p>A small constant added to the sampling probability of each
node.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node_+3A_run_checks">run_checks</code></td>
<td>
<p>If <code>TRUE</code> and 'x' is a matrix, then it is checked that
'x' is an adjacency matrix. This catches the case where 'x' is a weighted
matrix, in which case the weights are removed and a warning is given.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(10)
# Rewire connections to the first node.
nw_rewired &lt;- rewire_connections_to_node(nw, 1)
# Plot the two networks for comparison
g &lt;- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired, g)
</code></pre>

<hr>
<h2 id='rewire_connections_to_node.default'>Rewire connections to a node</h2><span id='topic+rewire_connections_to_node.default'></span>

<h3>Description</h3>

<p>Rewire connections to a node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
rewire_connections_to_node(
  x,
  node,
  prob_rewire = 1,
  weights = NULL,
  alpha = 100,
  beta = 1,
  epsilon = 10^-5,
  run_checks = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rewire_connections_to_node.default_+3A_x">x</code></td>
<td>
<p>The 'network', 'network_module', or 'matrix' object to modify.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.default_+3A_node">node</code></td>
<td>
<p>The node to rewire.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.default_+3A_prob_rewire">prob_rewire</code></td>
<td>
<p>A value between 0 and 1, inclusive. Each connection to
<code>node</code> will be rewired with probability equal to <code>prob_rewire</code>.
Note, the degree of <code>node</code> is unchanged after this operation.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.default_+3A_weights">weights</code></td>
<td>
<p>(Optional) A vector of weights for each node. These are used
in addition to the degree of each node when sampling nodes to rewire.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.default_+3A_alpha">alpha</code></td>
<td>
<p>A positive value used to parameterize the Beta distribution.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.default_+3A_beta">beta</code></td>
<td>
<p>A positive value used to parameterize the Beta distribution.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.default_+3A_epsilon">epsilon</code></td>
<td>
<p>A small constant added to the sampling probability of each
node.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.default_+3A_run_checks">run_checks</code></td>
<td>
<p>If <code>TRUE</code> and 'x' is a matrix, then it is checked that
'x' is an adjacency matrix. This catches the case where 'x' is a weighted
matrix, in which case the weights are removed and a warning is given.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.default_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(10)
# Rewire connections to the first node.
nw_rewired &lt;- rewire_connections_to_node(nw, 1)
# Plot the two networks for comparison
g &lt;- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired, g)
</code></pre>

<hr>
<h2 id='rewire_connections_to_node.matrix'>Rewire connections to a node</h2><span id='topic+rewire_connections_to_node.matrix'></span>

<h3>Description</h3>

<p>Rewire connections to a node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
rewire_connections_to_node(
  x,
  node,
  prob_rewire = 1,
  weights = NULL,
  alpha = 100,
  beta = 1,
  epsilon = 10^-5,
  run_checks = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rewire_connections_to_node.matrix_+3A_x">x</code></td>
<td>
<p>The 'network', 'network_module', or 'matrix' object to modify.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.matrix_+3A_node">node</code></td>
<td>
<p>The node to rewire.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.matrix_+3A_prob_rewire">prob_rewire</code></td>
<td>
<p>A value between 0 and 1, inclusive. Each connection to
<code>node</code> will be rewired with probability equal to <code>prob_rewire</code>.
Note, the degree of <code>node</code> is unchanged after this operation.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.matrix_+3A_weights">weights</code></td>
<td>
<p>(Optional) A vector of weights for each node. These are used
in addition to the degree of each node when sampling nodes to rewire.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.matrix_+3A_alpha">alpha</code></td>
<td>
<p>A positive value used to parameterize the Beta distribution.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.matrix_+3A_beta">beta</code></td>
<td>
<p>A positive value used to parameterize the Beta distribution.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.matrix_+3A_epsilon">epsilon</code></td>
<td>
<p>A small constant added to the sampling probability of each
node.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.matrix_+3A_run_checks">run_checks</code></td>
<td>
<p>If <code>TRUE</code> and 'x' is a matrix, then it is checked that
'x' is an adjacency matrix. This catches the case where 'x' is a weighted
matrix, in which case the weights are removed and a warning is given.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.matrix_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(10)
# Rewire connections to the first node.
nw_rewired &lt;- rewire_connections_to_node(nw, 1)
# Plot the two networks for comparison
g &lt;- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired, g)
</code></pre>

<hr>
<h2 id='rewire_connections_to_node.network'>Rewire connections to a node</h2><span id='topic+rewire_connections_to_node.network'></span>

<h3>Description</h3>

<p>Rewire connections to a node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network'
rewire_connections_to_node(
  x,
  node,
  prob_rewire = 1,
  weights = NULL,
  alpha = 100,
  beta = 1,
  epsilon = 10^-5,
  run_checks = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rewire_connections_to_node.network_+3A_x">x</code></td>
<td>
<p>The 'network', 'network_module', or 'matrix' object to modify.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.network_+3A_node">node</code></td>
<td>
<p>The node to rewire.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.network_+3A_prob_rewire">prob_rewire</code></td>
<td>
<p>A value between 0 and 1, inclusive. Each connection to
<code>node</code> will be rewired with probability equal to <code>prob_rewire</code>.
Note, the degree of <code>node</code> is unchanged after this operation.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.network_+3A_weights">weights</code></td>
<td>
<p>(Optional) A vector of weights for each node. These are used
in addition to the degree of each node when sampling nodes to rewire.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.network_+3A_alpha">alpha</code></td>
<td>
<p>A positive value used to parameterize the Beta distribution.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.network_+3A_beta">beta</code></td>
<td>
<p>A positive value used to parameterize the Beta distribution.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.network_+3A_epsilon">epsilon</code></td>
<td>
<p>A small constant added to the sampling probability of each
node.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.network_+3A_run_checks">run_checks</code></td>
<td>
<p>If <code>TRUE</code> and 'x' is a matrix, then it is checked that
'x' is an adjacency matrix. This catches the case where 'x' is a weighted
matrix, in which case the weights are removed and a warning is given.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.network_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(10)
# Rewire connections to the first node.
nw_rewired &lt;- rewire_connections_to_node(nw, 1)
# Plot the two networks for comparison
g &lt;- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired, g)
</code></pre>

<hr>
<h2 id='rewire_connections_to_node.network_module'>Rewire connections to a node</h2><span id='topic+rewire_connections_to_node.network_module'></span>

<h3>Description</h3>

<p>Rewire connections to a node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network_module'
rewire_connections_to_node(
  x,
  node,
  prob_rewire = 1,
  weights = NULL,
  alpha = 100,
  beta = 1,
  epsilon = 10^-5,
  run_checks = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rewire_connections_to_node.network_module_+3A_x">x</code></td>
<td>
<p>The 'network', 'network_module', or 'matrix' object to modify.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.network_module_+3A_node">node</code></td>
<td>
<p>The node to rewire.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.network_module_+3A_prob_rewire">prob_rewire</code></td>
<td>
<p>A value between 0 and 1, inclusive. Each connection to
<code>node</code> will be rewired with probability equal to <code>prob_rewire</code>.
Note, the degree of <code>node</code> is unchanged after this operation.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.network_module_+3A_weights">weights</code></td>
<td>
<p>(Optional) A vector of weights for each node. These are used
in addition to the degree of each node when sampling nodes to rewire.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.network_module_+3A_alpha">alpha</code></td>
<td>
<p>A positive value used to parameterize the Beta distribution.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.network_module_+3A_beta">beta</code></td>
<td>
<p>A positive value used to parameterize the Beta distribution.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.network_module_+3A_epsilon">epsilon</code></td>
<td>
<p>A small constant added to the sampling probability of each
node.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.network_module_+3A_run_checks">run_checks</code></td>
<td>
<p>If <code>TRUE</code> and 'x' is a matrix, then it is checked that
'x' is an adjacency matrix. This catches the case where 'x' is a weighted
matrix, in which case the weights are removed and a warning is given.</p>
</td></tr>
<tr><td><code id="rewire_connections_to_node.network_module_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(10)
# Rewire connections to the first node.
nw_rewired &lt;- rewire_connections_to_node(nw, 1)
# Plot the two networks for comparison
g &lt;- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired, g)
</code></pre>

<hr>
<h2 id='rewire_connections.default'>Rewire connections</h2><span id='topic+rewire_connections.default'></span>

<h3>Description</h3>

<p>Rewire connections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
rewire_connections(
  x,
  prob_rewire = 1,
  weights = NULL,
  alpha = 100,
  beta = 1,
  epsilon = 10^-5,
  run_checks = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rewire_connections.default_+3A_x">x</code></td>
<td>
<p>The 'network', 'network_module', or 'matrix' object to modify.</p>
</td></tr>
<tr><td><code id="rewire_connections.default_+3A_prob_rewire">prob_rewire</code></td>
<td>
<p>A value between 0 and 1. The connections to each node
will be rewired with probability equal to <code>prob_rewire</code>.</p>
</td></tr>
<tr><td><code id="rewire_connections.default_+3A_weights">weights</code></td>
<td>
<p>(Optional) A vector of weights for each node. These are used
in addition to the degree of each node when sampling a node to rewire to.</p>
</td></tr>
<tr><td><code id="rewire_connections.default_+3A_alpha">alpha</code></td>
<td>
<p>A positive value used to parameterize the Beta distribution.</p>
</td></tr>
<tr><td><code id="rewire_connections.default_+3A_beta">beta</code></td>
<td>
<p>A positive value used to parameterize the Beta distribution.</p>
</td></tr>
<tr><td><code id="rewire_connections.default_+3A_epsilon">epsilon</code></td>
<td>
<p>A small constant added to the sampling probability of each
node.</p>
</td></tr>
<tr><td><code id="rewire_connections.default_+3A_run_checks">run_checks</code></td>
<td>
<p>If <code>TRUE</code> and 'x' is a matrix, then it is checked that
'x' is an adjacency matrix. This catches the case where 'x' is a weighted
matrix, in which case the weights are removed and a warning is given.</p>
</td></tr>
<tr><td><code id="rewire_connections.default_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified module.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(10)
# Rewire nodes in the network each with probability 1/2
nw_rewired &lt;- rewire_connections(nw, 0.5)
# Plot the two networks for comparison
g &lt;- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired, g)
</code></pre>

<hr>
<h2 id='rewire_connections.matrix'>Rewire connections</h2><span id='topic+rewire_connections.matrix'></span>

<h3>Description</h3>

<p>Rewire connections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
rewire_connections(
  x,
  prob_rewire = 1,
  weights = NULL,
  alpha = 100,
  beta = 1,
  epsilon = 10^-5,
  run_checks = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rewire_connections.matrix_+3A_x">x</code></td>
<td>
<p>The 'network', 'network_module', or 'matrix' object to modify.</p>
</td></tr>
<tr><td><code id="rewire_connections.matrix_+3A_prob_rewire">prob_rewire</code></td>
<td>
<p>A value between 0 and 1. The connections to each node
will be rewired with probability equal to <code>prob_rewire</code>.</p>
</td></tr>
<tr><td><code id="rewire_connections.matrix_+3A_weights">weights</code></td>
<td>
<p>(Optional) A vector of weights for each node. These are used
in addition to the degree of each node when sampling a node to rewire to.</p>
</td></tr>
<tr><td><code id="rewire_connections.matrix_+3A_alpha">alpha</code></td>
<td>
<p>A positive value used to parameterize the Beta distribution.</p>
</td></tr>
<tr><td><code id="rewire_connections.matrix_+3A_beta">beta</code></td>
<td>
<p>A positive value used to parameterize the Beta distribution.</p>
</td></tr>
<tr><td><code id="rewire_connections.matrix_+3A_epsilon">epsilon</code></td>
<td>
<p>A small constant added to the sampling probability of each
node.</p>
</td></tr>
<tr><td><code id="rewire_connections.matrix_+3A_run_checks">run_checks</code></td>
<td>
<p>If <code>TRUE</code> and 'x' is a matrix, then it is checked that
'x' is an adjacency matrix. This catches the case where 'x' is a weighted
matrix, in which case the weights are removed and a warning is given.</p>
</td></tr>
<tr><td><code id="rewire_connections.matrix_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified module.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(10)
# Rewire nodes in the network each with probability 1/2
nw_rewired &lt;- rewire_connections(nw, 0.5)
# Plot the two networks for comparison
g &lt;- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired, g)
</code></pre>

<hr>
<h2 id='rewire_connections.network'>Rewire connections</h2><span id='topic+rewire_connections.network'></span>

<h3>Description</h3>

<p>Rewire connections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network'
rewire_connections(
  x,
  prob_rewire = 1,
  weights = NULL,
  alpha = 100,
  beta = 1,
  epsilon = 10^-5,
  run_checks = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rewire_connections.network_+3A_x">x</code></td>
<td>
<p>The 'network', 'network_module', or 'matrix' object to modify.</p>
</td></tr>
<tr><td><code id="rewire_connections.network_+3A_prob_rewire">prob_rewire</code></td>
<td>
<p>A value between 0 and 1. The connections to each node
will be rewired with probability equal to <code>prob_rewire</code>.</p>
</td></tr>
<tr><td><code id="rewire_connections.network_+3A_weights">weights</code></td>
<td>
<p>(Optional) A vector of weights for each node. These are used
in addition to the degree of each node when sampling a node to rewire to.</p>
</td></tr>
<tr><td><code id="rewire_connections.network_+3A_alpha">alpha</code></td>
<td>
<p>A positive value used to parameterize the Beta distribution.</p>
</td></tr>
<tr><td><code id="rewire_connections.network_+3A_beta">beta</code></td>
<td>
<p>A positive value used to parameterize the Beta distribution.</p>
</td></tr>
<tr><td><code id="rewire_connections.network_+3A_epsilon">epsilon</code></td>
<td>
<p>A small constant added to the sampling probability of each
node.</p>
</td></tr>
<tr><td><code id="rewire_connections.network_+3A_run_checks">run_checks</code></td>
<td>
<p>If <code>TRUE</code> and 'x' is a matrix, then it is checked that
'x' is an adjacency matrix. This catches the case where 'x' is a weighted
matrix, in which case the weights are removed and a warning is given.</p>
</td></tr>
<tr><td><code id="rewire_connections.network_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified module.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(10)
# Rewire nodes in the network each with probability 1/2
nw_rewired &lt;- rewire_connections(nw, 0.5)
# Plot the two networks for comparison
g &lt;- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired, g)
</code></pre>

<hr>
<h2 id='rewire_connections.network_module'>Rewire connections</h2><span id='topic+rewire_connections.network_module'></span>

<h3>Description</h3>

<p>Rewire connections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network_module'
rewire_connections(
  x,
  prob_rewire = 1,
  weights = NULL,
  alpha = 100,
  beta = 1,
  epsilon = 10^-5,
  run_checks = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rewire_connections.network_module_+3A_x">x</code></td>
<td>
<p>The 'network', 'network_module', or 'matrix' object to modify.</p>
</td></tr>
<tr><td><code id="rewire_connections.network_module_+3A_prob_rewire">prob_rewire</code></td>
<td>
<p>A value between 0 and 1. The connections to each node
will be rewired with probability equal to <code>prob_rewire</code>.</p>
</td></tr>
<tr><td><code id="rewire_connections.network_module_+3A_weights">weights</code></td>
<td>
<p>(Optional) A vector of weights for each node. These are used
in addition to the degree of each node when sampling a node to rewire to.</p>
</td></tr>
<tr><td><code id="rewire_connections.network_module_+3A_alpha">alpha</code></td>
<td>
<p>A positive value used to parameterize the Beta distribution.</p>
</td></tr>
<tr><td><code id="rewire_connections.network_module_+3A_beta">beta</code></td>
<td>
<p>A positive value used to parameterize the Beta distribution.</p>
</td></tr>
<tr><td><code id="rewire_connections.network_module_+3A_epsilon">epsilon</code></td>
<td>
<p>A small constant added to the sampling probability of each
node.</p>
</td></tr>
<tr><td><code id="rewire_connections.network_module_+3A_run_checks">run_checks</code></td>
<td>
<p>If <code>TRUE</code> and 'x' is a matrix, then it is checked that
'x' is an adjacency matrix. This catches the case where 'x' is a weighted
matrix, in which case the weights are removed and a warning is given.</p>
</td></tr>
<tr><td><code id="rewire_connections.network_module_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified module.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(10)
# Rewire nodes in the network each with probability 1/2
nw_rewired &lt;- rewire_connections(nw, 0.5)
# Plot the two networks for comparison
g &lt;- plot(nw)
plot(nw_rewired, g) # Pass in g to mirror the layout.
# Or plot the differential network.
plot_network_diff(nw, nw_rewired, g)
</code></pre>

<hr>
<h2 id='ring_lattice_cpp'>C++ implementation for creating a ring lattice</h2><span id='topic+ring_lattice_cpp'></span>

<h3>Description</h3>

<p>C++ implementation for creating a ring lattice
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ring_lattice_cpp(p, neig_size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ring_lattice_cpp_+3A_p">p</code></td>
<td>
<p>The number of nodes in the lattice.</p>
</td></tr>
<tr><td><code id="ring_lattice_cpp_+3A_neig_size">neig_size</code></td>
<td>
<p>The neighborhood side within which nodes are connected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the adjacency matrix for the ring lattice.
</p>

<hr>
<h2 id='rzinb'>The Zero-Inflated Negative Binomial Distribution</h2><span id='topic+rzinb'></span>

<h3>Description</h3>

<p>The Zero-Inflated Negative Binomial Distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rzinb(n, size, mu, rho)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rzinb_+3A_n">n</code></td>
<td>
<p>The number of random values to return.</p>
</td></tr>
<tr><td><code id="rzinb_+3A_size">size</code></td>
<td>
<p>The dispersion paramater used in <code><a href="stats.html#topic+NegBinomial">dnbinom</a></code>.</p>
</td></tr>
<tr><td><code id="rzinb_+3A_mu">mu</code></td>
<td>
<p>The mean parameter used in <code><a href="stats.html#topic+NegBinomial">dnbinom</a></code>.</p>
</td></tr>
<tr><td><code id="rzinb_+3A_rho">rho</code></td>
<td>
<p>The zero-inflation parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The randomly generated values from the distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rzinb(10, 1, 10, 0.1)
p &lt;- pzinb(x, 1, 10, 0.1)
y &lt;- qzinb(p, 1, 10, 0.1)
all(x == y)
# Compute P(0 &lt; X &lt; 5) for X ~ ZINB(1, 10, 0.1)
sum(dzinb(0:5, 1, 10, 0.1))
</code></pre>

<hr>
<h2 id='sample_link_nodes'>Sample link nodes for new module</h2><span id='topic+sample_link_nodes'></span>

<h3>Description</h3>

<p>Sample link nodes for new module
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_link_nodes(
  n,
  nodes,
  degree,
  alpha = 100,
  beta = 1,
  epsilon = 10^-5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_link_nodes_+3A_n">n</code></td>
<td>
<p>The number of link nodes to sample.</p>
</td></tr>
<tr><td><code id="sample_link_nodes_+3A_nodes">nodes</code></td>
<td>
<p>The nodes to sample from.</p>
</td></tr>
<tr><td><code id="sample_link_nodes_+3A_degree">degree</code></td>
<td>
<p>The degree of each node.</p>
</td></tr>
<tr><td><code id="sample_link_nodes_+3A_alpha">alpha</code></td>
<td>
<p>A positive value used to parameterize the Beta distribution.</p>
</td></tr>
<tr><td><code id="sample_link_nodes_+3A_beta">beta</code></td>
<td>
<p>A positive value used to parameterize the Beta distribution.</p>
</td></tr>
<tr><td><code id="sample_link_nodes_+3A_epsilon">epsilon</code></td>
<td>
<p>Used when sampling link nodes.</p>
</td></tr>
<tr><td><code id="sample_link_nodes_+3A_...">...</code></td>
<td>
<p>Additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of selected nodes (possibly of length 1).
</p>


<h3>Note</h3>

<p>This function is used by <code><a href="#topic+create_modules_for_network">create_modules_for_network</a></code>
and is not meant to be used externally.
</p>

<hr>
<h2 id='sample_module_nodes'>Sample nodes for new module</h2><span id='topic+sample_module_nodes'></span>

<h3>Description</h3>

<p>Sample nodes for new module
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_module_nodes(n, nodes, degree, nu = 0.01, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_module_nodes_+3A_n">n</code></td>
<td>
<p>The number of nodes to sample.</p>
</td></tr>
<tr><td><code id="sample_module_nodes_+3A_nodes">nodes</code></td>
<td>
<p>The nodes available to sample from.</p>
</td></tr>
<tr><td><code id="sample_module_nodes_+3A_degree">degree</code></td>
<td>
<p>The degree of each node.</p>
</td></tr>
<tr><td><code id="sample_module_nodes_+3A_nu">nu</code></td>
<td>
<p>Multiplier for nodes that are already in one or more modules.</p>
</td></tr>
<tr><td><code id="sample_module_nodes_+3A_...">...</code></td>
<td>
<p>Additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of selected nodes of length m.
</p>


<h3>Note</h3>

<p>This function is used by <code><a href="#topic+create_modules_for_network">create_modules_for_network</a></code>
and is not meant to be used externally.
</p>

<hr>
<h2 id='sample_reference_data'>Sample genes from reference dataset</h2><span id='topic+sample_reference_data'></span>

<h3>Description</h3>

<p>Sample genes from reference dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_reference_data(reference_data, p, percent_ZI = NULL, threshold_ZI = 0.2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_reference_data_+3A_reference_data">reference_data</code></td>
<td>
<p>The reference data.frame to use.</p>
</td></tr>
<tr><td><code id="sample_reference_data_+3A_p">p</code></td>
<td>
<p>The number of genes (columns) to sample.</p>
</td></tr>
<tr><td><code id="sample_reference_data_+3A_percent_zi">percent_ZI</code></td>
<td>
<p>The desired percentage of zero-inflated genes. This
percentage of zero-inflated genes will be sampled from the reference
dataset, and the remaining will be non-zero-inflated. If
NULL, then genes are sampled at random from the reference dataset.</p>
</td></tr>
<tr><td><code id="sample_reference_data_+3A_threshold_zi">threshold_ZI</code></td>
<td>
<p>The minimum proportion of zero counts for a gene to be
considered as zero inflated. This is used to identify which genes in the
reference dataset are zero-inflated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified reference dataset.
</p>


<h3>Note</h3>

<p>If p is greater than the number of columns in the reference dataset,
then sampling with replacement will be used (with a warning message).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(reference)
rnaseq &lt;- reference$rnaseq
rnaseq_subset &lt;- sample_reference_data(rnaseq, 10)

</code></pre>

<hr>
<h2 id='set_module_edges'>Internal function used to set the edges in a module</h2><span id='topic+set_module_edges'></span>

<h3>Description</h3>

<p>Internal function used to set the edges in a module
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_module_edges(module, edges)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_module_edges_+3A_module">module</code></td>
<td>
<p>The 'network_module' object to modify.</p>
</td></tr>
<tr><td><code id="set_module_edges_+3A_edges">edges</code></td>
<td>
<p>A matrix used to indicate the edges in the module. If the matrix
is square and contains the same number of rows and columns as nodes in
the module, then it is assumed to be an adjacency matrix and the nonzero
lower-triangle values of the matrix are used to indicate edges in the module.
If the matrix is not square, the first two columns are assumed to be an
edge list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified 'network_module' object.
</p>

<hr>
<h2 id='set_module_name'>Set the name for a module</h2><span id='topic+set_module_name'></span>

<h3>Description</h3>

<p>Set the name for a module
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_module_name(module, module_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_module_name_+3A_module">module</code></td>
<td>
<p>The 'network_module' object to modify.</p>
</td></tr>
<tr><td><code id="set_module_name_+3A_module_name">module_name</code></td>
<td>
<p>A character string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified 'network_module' object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nw &lt;- random_network(10)
nw &lt;- gen_partial_correlations(nw)
module &lt;- nw$modules[[1]]
named_module &lt;- set_module_name(module, "new name")
</code></pre>

<hr>
<h2 id='set_module_weights'>Internal function to set the connection weights for a module</h2><span id='topic+set_module_weights'></span>

<h3>Description</h3>

<p>Internal function to set the connection weights for a module
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_module_weights(module, weights)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_module_weights_+3A_module">module</code></td>
<td>
<p>The 'network_module' object to modify.</p>
</td></tr>
<tr><td><code id="set_module_weights_+3A_weights">weights</code></td>
<td>
<p>A vector or matrix of weights for each connetions. If a vector,
its length must equal the number of connections in the module. If a matrix,
it should be square with the number of columns equal to the number of nodes
in the module; only the entries in the lower triangle that correspond to
connections in the module will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified 'network_module' object.
</p>

<hr>
<h2 id='set_node_names'>Set the node names in a network</h2><span id='topic+set_node_names'></span>

<h3>Description</h3>

<p>Set the node names in a network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_node_names(network, node_names)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_node_names_+3A_network">network</code></td>
<td>
<p>The network to modify.</p>
</td></tr>
<tr><td><code id="set_node_names_+3A_node_names">node_names</code></td>
<td>
<p>A vector of strings containing the names for each node
in the network. If a numeric vector is provided, the values will be coerced
into strings. If 'node_names' is <code>NULL</code>, then the names will default to
&quot;1&quot;, &quot;2&quot;, ..., &quot;p&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified network.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random network with 10 nodes. 
nw &lt;- random_network(10)
get_node_names(nw) # Default names are 1, 2, ..., 10.
nw &lt;- set_node_names(nw, paste("node", 1:10, sep = "_"))
get_node_names(nw) # Print out updated node names.
# Modules only contain the indicies to nodes, not the node names
module &lt;- nw$modules[[1]]
get_node_names(module)
# When converting the network to a matrix, node names appear as column names.
adj_matrix &lt;- get_adjacency_matrix(nw)
colnames(adj_matrix) 
</code></pre>

<hr>
<h2 id='update_module_with_random_weights'>Generate small-world network structure for module</h2><span id='topic+update_module_with_random_weights'></span>

<h3>Description</h3>

<p>The small-world network is generated using the Watts-Strogatz method.
See <code><a href="igraph.html#topic+sample_smallworld">watts.strogatz.game</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_module_with_random_weights(
  module,
  rdist = function(n) {     runif(n, 0.5, 1) * (-1)^rbinom(n, 1, 0.5) },
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_module_with_random_weights_+3A_module">module</code></td>
<td>
<p>The network_module object to modify.</p>
</td></tr>
<tr><td><code id="update_module_with_random_weights_+3A_rdist">rdist</code></td>
<td>
<p>A distribution function that generates random numbers. The first
argument should specify the number of weights to generate. By default,
weights are generated uniformly from the set (-1, -0.5)U(0.5, 1).</p>
</td></tr>
<tr><td><code id="update_module_with_random_weights_+3A_...">...</code></td>
<td>
<p>Additional parameters are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated 'network_module' object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random module. 
module &lt;- random_module(1:10)
is_weighted(module)
# Add a random weight to each connection.
module &lt;- update_module_with_random_weights(module)
is_weighted(module)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
