<!DOCTYPE html><html><head><title>Help for package treestats</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {treestats}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#area_per_pair'><p>Fast function using C++ to calculate the area per pair index</p></a></li>
<li><a href='#average_leaf_depth'><p>Calculate the average leaf depth statistic. The average leaf depth statistic</p>
is a normalized version of the Sackin index, normalized by the number of
tips.</a></li>
<li><a href='#avg_ladder'><p>Average ladder index</p></a></li>
<li><a href='#b1'><p>Fast function using C++ to calculate the B1 metric</p></a></li>
<li><a href='#b2'><p>Fast function using C++ to calculate the B2 metric</p></a></li>
<li><a href='#beta_statistic'><p>Fast function using C++ to calculate the Aldous beta statistic.</p></a></li>
<li><a href='#blum'><p>Fast function using C++ to calculate the Blum index of (im)balance.</p></a></li>
<li><a href='#branching_times'><p>Calculates branching times of a tree, using C++</p></a></li>
<li><a href='#calc_all_stats'><p>function to apply all available tree statistics to a single tree</p></a></li>
<li><a href='#calc_balance_stats'><p>function to apply all balance statistics to a single tree</p></a></li>
<li><a href='#calc_brts_stats'><p>function to apply all tree statistics related to branching times</p>
to a single tree.</a></li>
<li><a href='#cherries'><p>Cherry index</p></a></li>
<li><a href='#colless'><p>Fast function using C++ to calculate the Colless index of (im)balance.</p></a></li>
<li><a href='#crown_age'><p>Calculates the crown age of a tree using C++.</p></a></li>
<li><a href='#diameter'><p>Fast function using C++ to calculate the diameter</p></a></li>
<li><a href='#eigen_vector'><p>Fast function using C++ to calculate eigen vector centrality</p></a></li>
<li><a href='#entropy_j'><p>Fast function using C++ to calculate the intensive quadratic entropy</p>
statistic J.</a></li>
<li><a href='#ew_colless'><p>Fast function using C++ to calculate the equal weights Colless index of</p>
(im)balance.</a></li>
<li><a href='#gamma_statistic'><p>Calculate the gamma statistic, using a fast implementation in C++.</p></a></li>
<li><a href='#ILnumber'><p>Calculate ILnumber</p></a></li>
<li><a href='#imbalance_steps'><p>imbalance steps index</p></a></li>
<li><a href='#j_one'><p>function to calculate the J^1 index.</p></a></li>
<li><a href='#l_to_phylo'><p>Convert an L table to phylo object</p></a></li>
<li><a href='#laplacian_spectrum'><p>function to calculate the laplacian spectrum, from RPANDA</p></a></li>
<li><a href='#list_statistics'><p>Provides a list of all available statistics in the package</p></a></li>
<li><a href='#ltable_to_newick'><p>Convert an L table to newick string</p></a></li>
<li><a href='#make_unbalanced_tree'><p>this function increasingly increases the imbalance of a tree</p></a></li>
<li><a href='#max_betweenness'><p>Fast function using C++ to calculate maximum betweenness centrality.</p></a></li>
<li><a href='#max_closeness'><p>Fast function using C++ to calculate maximum closeness</p></a></li>
<li><a href='#max_del_width'><p>Fast function using C++ to calculate the maximum difference of widths of a</p>
phylogenetic tree</a></li>
<li><a href='#max_depth'><p>Fast function using C++ to calculate maximum depth metric</p></a></li>
<li><a href='#max_ladder'><p>maximum ladder index</p></a></li>
<li><a href='#max_width'><p>Fast function using C++ to calculate the maximum width of branch depth.</p></a></li>
<li><a href='#mean_branch_length'><p>Calculates the mean branch length of a tree, including extinct branches.</p></a></li>
<li><a href='#mean_branch_length_ext'><p>Calculates the mean of external branch lengths of a tree, e.g. of</p>
branches leading to a tip.</a></li>
<li><a href='#mean_branch_length_int'><p>Calculates the variation of internal branch lengths of a tree, e.g. of</p>
branches not leading to a tip.</a></li>
<li><a href='#mean_i'><p>Fast function using C++ to calculate the mean I value.</p></a></li>
<li><a href='#mean_pair_dist'><p>Mean Pairwise distance</p></a></li>
<li><a href='#mntd'><p>Mean Nearest Taxon distance</p></a></li>
<li><a href='#nLTT'><p>Calculate the nLTT, using C++.</p></a></li>
<li><a href='#nLTT_base'><p>Calculates the nLTT statistic using a reference 'empty' tree with only</p>
two lineages.</a></li>
<li><a href='#number_of_lineages'><p>Calculate the number of tips of a tree, including extinct tips.</p></a></li>
<li><a href='#phylo_to_l'><p>Function to generate an ltable from a phy object.</p></a></li>
<li><a href='#phylogenetic_diversity'><p>Calculates phylogenetic diversity at time point t</p></a></li>
<li><a href='#pigot_rho'><p>calculate Pigot's rho</p></a></li>
<li><a href='#pitchforks'><p>Calculate pitchforks, from the phyloTop package, a pitchfork is a clade</p>
with three tips.</a></li>
<li><a href='#prep_lapl_spec'><p>function to create laplacian matrix</p></a></li>
<li><a href='#psv'><p>Fast function using C++ to calculate Phylogenetic Species Variability.</p></a></li>
<li><a href='#rebase_ltable'><p>a function to modify an ltable, such that the longest path in the phylogeny</p>
is a crown lineage.</a></li>
<li><a href='#rogers'><p>Fast function using C++ to calculate the Rogers J index of (im)balance.</p></a></li>
<li><a href='#rquartet'><p>Fast function using C++ to calculate the rquartet index.</p></a></li>
<li><a href='#sackin'><p>Fast function using C++ to calculate the sackin index of (im)balance.</p></a></li>
<li><a href='#stairs'><p>Calculates the staircase-ness measure, from the phyloTop package. The</p>
staircase-ness reflects the number of subtrees that are imbalanced, e.g.
subtrees where the left child has more extant tips than the right child, or
vice versa.</a></li>
<li><a href='#stairs2'><p>Calculates the stairs2 measure, from the phyloTop package. The</p>
stairs2 reflects the imbalance at each node, where it represents the average
across measure at each node, the measure being min(l, r) / max(l, r), where
l and r reflect the number of tips connected at the left (l) and right (r)
daughter.</a></li>
<li><a href='#sym_nodes'><p>Fast function using C++ to calculate the symmetry nodes metric</p></a></li>
<li><a href='#tot_coph'><p>Fast function using C++ to calculate the total cophenetic index.</p></a></li>
<li><a href='#tree_height'><p>Calculates the height of a tree using C++.</p></a></li>
<li><a href='#treestats-package'>
<p>Collection of phylogenetic tree statistics</p></a></li>
<li><a href='#var_branch_length'><p>Calculates the variance of branch lengths of a tree,</p>
including extinct branches.</a></li>
<li><a href='#var_branch_length_ext'><p>Calculates the variance of external branch lengths of a tree, e.g. of</p>
branches leading to a tip.</a></li>
<li><a href='#var_branch_length_int'><p>Calculates the variance of internal branch lengths of a tree, e.g. of</p>
branches not leading to a tip.</a></li>
<li><a href='#var_leaf_depth'><p>Fast function using C++ to calculate the variance of leaf depth statistic</p></a></li>
<li><a href='#var_pair_dist'><p>Fast function using C++ to calculate the variance of all pairwise distances.</p></a></li>
<li><a href='#wiener'><p>Fast function using C++ to calculate the Wiener index</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Phylogenetic Tree Statistics</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thijs Janzen &lt;thijsjanzen@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Collection of phylogenetic tree statistics,
             collected throughout the literature. All functions have been 
             written to maximize computation speed. The package includes 
             umbrella functions to calculate all statistics, all balance 
             associated statistics, or all branching time related statistics. 
             Furthermore, the 'treestats' package supports summary statistic 
             calculations on Ltables, provides speed-improved coding of 
             branching times, Ltable conversion and includes algorithms to
             create intermediately balanced trees. Full description can be
             found in Janzen (2023) &lt;<a href="https://doi.org/10.1101%2F2024.01.24.576848">doi:10.1101/2024.01.24.576848</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, nloptr</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, nloptr, RSpectra, Matrix</td>
</tr>
<tr>
<td>Suggests:</td>
<td>phyloTop, testthat, DDD, geiger, nodeSub, nLTT, castor,
adephylo, ggplot2, tibble, picante, treebalance, RPANDA, lintr,
rmarkdown, knitr</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/thijsjanzen/treestats/issues">https://github.com/thijsjanzen/treestats/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/thijsjanzen/treestats">https://github.com/thijsjanzen/treestats</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-30 13:59:36 UTC; thijsjanzen</td>
</tr>
<tr>
<td>Author:</td>
<td>Thijs Janzen <a href="https://orcid.org/0000-0002-4162-1140"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-30 15:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='area_per_pair'>Fast function using C++ to calculate the area per pair index</h2><span id='topic+area_per_pair'></span>

<h3>Description</h3>

<p>The area per pair index calculates the sum of the number of
edges on the path between all two leaves. Instead, the area per pair index
(APP) can also be derived from the Sackin (S) and total cophenetic index
(TC):
<code class="reqn"> APP = \frac{2}{n}\cdot S - \frac{4}{n(n-1)}\cdot TC</code>
<code class="reqn">APP = 2/n * S - 4/(n(n-1)) * TC</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>area_per_pair(phy, normalization = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="area_per_pair_+3A_phy">phy</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
<tr><td><code id="area_per_pair_+3A_normalization">normalization</code></td>
<td>
<p>&quot;none&quot; or &quot;yule&quot;, in which case the acquired result
is divided by the expectation for the Yule model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Total cophenetic index
</p>


<h3>References</h3>

<p>T. Araújo Lima, F. M. D. Marquitti, and M. A. M. de Aguiar.
Measuring Tree Balance with Normalized Tree Area. arXiv e-prints, art.
arXiv:2008.12867, 2020.
</p>

<hr>
<h2 id='average_leaf_depth'>Calculate the average leaf depth statistic. The average leaf depth statistic
is a normalized version of the Sackin index, normalized by the number of
tips.</h2><span id='topic+average_leaf_depth'></span>

<h3>Description</h3>

<p>Calculate the average leaf depth statistic. The average leaf depth statistic
is a normalized version of the Sackin index, normalized by the number of
tips.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>average_leaf_depth(phy, normalization = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="average_leaf_depth_+3A_phy">phy</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
<tr><td><code id="average_leaf_depth_+3A_normalization">normalization</code></td>
<td>
<p>&quot;none&quot; or &quot;yule&quot;, in which case the statistic is
divided by the expectation under the yule model, following Remark 1 in
Coronado et al. 2020.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>average leaf depth statistic
</p>


<h3>References</h3>

<p>M. Coronado, T., Mir, A., Rosselló, F. et al. On Sackin’s
original proposal: the variance of the leaves’ depths as a phylogenetic
balance index. BMC Bioinformatics 21, 154 (2020).
https://doi.org/10.1186/s12859-020-3405-1
K.-T. Shao and R. R. Sokal. Tree balance. Systematic Zoology,
39(3):266, 1990. doi: 10.2307/2992186.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simulated_tree &lt;- ape::rphylo(n = 10, birth = 1, death = 0)
average_leaf_depth(simulated_tree)
</code></pre>

<hr>
<h2 id='avg_ladder'>Average ladder index</h2><span id='topic+avg_ladder'></span>

<h3>Description</h3>

<p>Calculate the avgLadder index, from the phyloTop package.
Higher values indicate more unbalanced trees. To calculate the average ladder
index, first all potential ladders in the tree are calculated. A ladder is
defined as a sequence of nodes where one of the daughter branches is a
terminal branch, resulting in a 'ladder' like pattern. The average ladder
index then represents the average lenght across all observed ladders in the
tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avg_ladder(input_obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="avg_ladder_+3A_input_obj">input_obj</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>average number of ladders
</p>

<hr>
<h2 id='b1'>Fast function using C++ to calculate the B1 metric</h2><span id='topic+b1'></span>

<h3>Description</h3>

<p>Balance metric (in the case of a binary tree), which measures
the sum across all internal nodes of one over the maximum depth of all
attached tips to that node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>b1(phy, normalization = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b1_+3A_phy">phy</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
<tr><td><code id="b1_+3A_normalization">normalization</code></td>
<td>
<p>&quot;none&quot; or &quot;tips&quot;, in which case the resulting
statistic is divided by the number of tips in the tree, as a crude way of
normalization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>B1 statistic
</p>


<h3>References</h3>

<p>K.-T. Shao and R. R. Sokal. Tree Balance.
Systematic Zoology, 39(3):266, 1990. doi: 10.2307/2992186.
</p>

<hr>
<h2 id='b2'>Fast function using C++ to calculate the B2 metric</h2><span id='topic+b2'></span>

<h3>Description</h3>

<p>Balance metric that uses the Shannon-Wiener statistic of
information content. The b2 measure is given by the sum over the depths of
all tips, divided by 2^depth: sum Ni / 2^Ni
</p>


<h3>Usage</h3>

<pre><code class='language-R'>b2(phy, normalization = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b2_+3A_phy">phy</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
<tr><td><code id="b2_+3A_normalization">normalization</code></td>
<td>
<p>&quot;none&quot; or &quot;yule&quot;, when &quot;yule&quot; is chosen, the statistic
is divided by the Yule expectation, following from theorem 3.7 in Bienvenu
2020.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Maximum depth (in number of edges)
</p>


<h3>References</h3>

<p>K.-T. Shao and R. R. Sokal. Tree Balance.
Systematic Zoology, 39(3):266, 1990. doi: 10.2307/2992186.
</p>
<p>Bienvenu, François, Gabriel Cardona, and Celine Scornavacca.
&quot;Revisiting Shao and Sokal’s $$ B_2 $$ B 2 index of phylogenetic balance.&quot;
Journal of Mathematical Biology 83.5 (2021): 1-43.
</p>

<hr>
<h2 id='beta_statistic'>Fast function using C++ to calculate the Aldous beta statistic.</h2><span id='topic+beta_statistic'></span>

<h3>Description</h3>

<p>The Beta statistic fits a beta splitting model to each node,
assuming that the number of extant descendents of each daughter branch is
split following a beta distribution, such that the number of extant
descendentants x and y at a node follows <code class="reqn">q(x, y) = s_n(beta)^-1
\frac{(gamma(x + 1 + beta)gamma(y + 1 + beta))}{gamma(x+1)gamma(y+1)}</code>, where
<code class="reqn">s_n(beta)^-1</code> is a normalizing constant. When this model is fit to a
tree, different values of beta correspond to the expectation following from
different diversification models, such that a beta of 0 corresponds to a
Yule tree, a beta of -3/2 to a tree following from a PDA model. In general,
negative beta values correspond to trees more unbalanced than Yule trees, and
beta values larger than zero indicate trees more balanced than Yule trees.
The lower bound of the beta splitting parameter is -2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta_statistic(
  phy,
  upper_lim = 10,
  algorithm = "COBYLA",
  abs_tol = 1e-04,
  rel_tol = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta_statistic_+3A_phy">phy</code></td>
<td>
<p>phylogeny or ltable</p>
</td></tr>
<tr><td><code id="beta_statistic_+3A_upper_lim">upper_lim</code></td>
<td>
<p>Upper limit for beta parameter, default = 10.</p>
</td></tr>
<tr><td><code id="beta_statistic_+3A_algorithm">algorithm</code></td>
<td>
<p>optimization algorithm used, default is &quot;COBYLA&quot;
(Constrained Optimization BY Linear Approximations), also available are
&quot;subplex&quot; and &quot;simplex&quot;. Subplex and Simplex seem to have difficulties with
unbalanced trees, e.g. if beta &lt; 0.</p>
</td></tr>
<tr><td><code id="beta_statistic_+3A_abs_tol">abs_tol</code></td>
<td>
<p>absolute stopping criterion of optimization. Default is 1e-4.</p>
</td></tr>
<tr><td><code id="beta_statistic_+3A_rel_tol">rel_tol</code></td>
<td>
<p>relative stopping criterion of optimization. Default is 1e-6.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Beta value
</p>


<h3>References</h3>

<p>Aldous, David. &quot;Probability distributions on cladograms.&quot; Random
discrete structures. Springer, New York, NY, 1996. 1-18.
Jones, Graham R. &quot;Tree models for macroevolution and phylogenetic analysis.&quot;
Systematic biology 60.6 (2011): 735-746.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simulated_tree &lt;- ape::rphylo(n = 100, birth = 1, death = 0)
if (requireNamespace("nodeSub")) {
  brts &lt;- branching_times(simulated_tree)
  balanced_tree &lt;- nodeSub::create_balanced_tree(brts)
  unbalanced_tree &lt;- nodeSub::create_unbalanced_tree(brts)
  beta_statistic(balanced_tree) # should be approximately 10
  beta_statistic(simulated_tree) # should be near 0
  beta_statistic(unbalanced_tree) # should be approximately -2
}
</code></pre>

<hr>
<h2 id='blum'>Fast function using C++ to calculate the Blum index of (im)balance.</h2><span id='topic+blum'></span>

<h3>Description</h3>

<p>The Blum index of imbalance (also known as the s-shape
statistic) calculates the sum of <code class="reqn">log(N-1)</code> over all internal nodes,
where N represents the total number of extant tips connected to that node.
An alternative implementation can be found in the Castor R package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blum(phy, normalization = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blum_+3A_phy">phy</code></td>
<td>
<p>phylogeny or ltable</p>
</td></tr>
<tr><td><code id="blum_+3A_normalization">normalization</code></td>
<td>
<p>because the Blum index sums over all nodes,
the resulting statistic tends to be correlated with the number of extant
tips. Normalization can be performed by dividing by the number of extant
tips.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Blum index of imbalance
</p>


<h3>References</h3>

<p>M. G. B. Blum and O. Francois (2006). Which random processes
describe the Tree of Life? A large-scale study of phylogenetic tree
imbalance. Systematic Biology. 55:685-691.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simulated_tree &lt;- ape::rphylo(n = 10, birth = 1, death = 0)
brts &lt;- branching_times(simulated_tree)
if (requireNamespace("nodeSub")) {
  balanced_tree &lt;- nodeSub::create_balanced_tree(brts)
  unbalanced_tree &lt;- nodeSub::create_unbalanced_tree(brts)
  blum(balanced_tree)
  blum(unbalanced_tree) # should be higher
}
</code></pre>

<hr>
<h2 id='branching_times'>Calculates branching times of a tree, using C++</h2><span id='topic+branching_times'></span>

<h3>Description</h3>

<p>C++ based alternative to 'ape::branching.times', please note
that to maximise speed, 'treestats::branching_times' does not return
node names associated to the branching times, in contrast to the ape version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>branching_times(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="branching_times_+3A_phy">phy</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of branching times
</p>

<hr>
<h2 id='calc_all_stats'>function to apply all available tree statistics to a single tree</h2><span id='topic+calc_all_stats'></span>

<h3>Description</h3>

<p>this function applies all tree statistics available in
this package to a
single tree, being:
</p>

<ul>
<li><p> gamma
</p>
</li>
<li><p> Sackin
</p>
</li>
<li><p> Colless
</p>
</li>
<li><p> Aldous' beta statistic
</p>
</li>
<li><p> Blum
</p>
</li>
<li><p> crown age
</p>
</li>
<li><p> tree height
</p>
</li>
<li><p> Pigot's rho
</p>
</li>
<li><p> number of lineages
</p>
</li>
<li><p> nLTT with empty tree
</p>
</li>
<li><p> phylogenetic diversity
</p>
</li>
<li><p> avgLadder index
</p>
</li>
<li><p> cherries
</p>
</li>
<li><p> ILnumber
</p>
</li>
<li><p> pitchforks
</p>
</li>
<li><p> stairs
</p>
</li>
<li><p> stairs2
</p>
</li>
<li><p> laplacian spectrum
</p>
</li>
<li><p> B1
</p>
</li>
<li><p> B2
</p>
</li>
<li><p> area per pair (aPP)
</p>
</li>
<li><p> average leaf depth (aLD)
</p>
</li>
<li><p> I statistic
</p>
</li>
<li><p> ewColless
</p>
</li>
<li><p> max Delta Width (maxDelW)
</p>
</li>
<li><p> maximum of Depth
</p>
</li>
<li><p> variance of Depth
</p>
</li>
<li><p> maximum Width
</p>
</li>
<li><p> Rogers
</p>
</li>
<li><p> total Cophenetic distance
</p>
</li>
<li><p> symmetry Nodes
</p>
</li>
<li><p> mean of pairwise distance (mpd)
</p>
</li>
<li><p> variance of pairwise distance (vpd)
</p>
</li>
<li><p> Phylogenetic Species Variability (psv)
</p>
</li>
<li><p> mean nearest taxon distance (mntd)
</p>
</li>
<li><p> J statistic of entropy
</p>
</li>
<li><p> rquartet index
</p>
</li>
<li><p> Wiener index
</p>
</li>
<li><p> max betweenness
</p>
</li>
<li><p> max closeness
</p>
</li>
<li><p> diameter, without branch lenghts
</p>
</li>
<li><p> maximum eigen vector value
</p>
</li>
<li><p> mean branch length
</p>
</li>
<li><p> variance of branch length
</p>
</li>
<li><p> mean external branch length
</p>
</li>
<li><p> variance of external branch length
</p>
</li>
<li><p> mean internal branch length
</p>
</li>
<li><p> variance of internal branch length
</p>
</li>
<li><p> number of imbalancing steps
</p>
</li>
<li><p> j_one statistic
</p>
</li></ul>

<p>For the Laplacian spectrum properties, four properties of the eigenvalue
distribution are returned: 1) asymmetry, 2) peakedness, 3) log(principal
eigenvalue) and 4) eigengap.
Please notice that for some very small or very large trees, some of the
statistics can not be calculated. The function will report an NA for this
statistic, but will not break, to facilitate batch analysis of large numbers
of trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_all_stats(phylo, normalize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_all_stats_+3A_phylo">phylo</code></td>
<td>
<p>phylo object</p>
</td></tr>
<tr><td><code id="calc_all_stats_+3A_normalize">normalize</code></td>
<td>
<p>if set to TRUE, results are normalized (if possible) under
either the  Yule expectation (if available), or the number of tips</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with statistics
</p>

<hr>
<h2 id='calc_balance_stats'>function to apply all balance statistics to a single tree</h2><span id='topic+calc_balance_stats'></span>

<h3>Description</h3>

<p>this function applies all tree statistics available in
this package to a single tree, being:
</p>

<ul>
<li><p>Sackin
</p>
</li>
<li><p>Colless
</p>
</li>
<li><p>Aldous' beta statistic
</p>
</li>
<li><p>Blum
</p>
</li>
<li><p>Average Ladder Size
</p>
</li>
<li><p>cherries
</p>
</li>
<li><p>ILnumber
</p>
</li>
<li><p>pitchforks
</p>
</li>
<li><p>stairs
</p>
</li>
<li><p>stairs2
</p>
</li>
<li><p>B1
</p>
</li>
<li><p>B2
</p>
</li>
<li><p>area per pair (aPP) 
</p>
</li>
<li><p>average leaf depth (aLD)
</p>
</li>
<li><p>I statistic
</p>
</li>
<li><p>ewColless
</p>
</li>
<li><p>max Delta Width (maxDelW)
</p>
</li>
<li><p>maximum of Depth
</p>
</li>
<li><p>variance of Depth
</p>
</li>
<li><p>maximum Width
</p>
</li>
<li><p>Rogers
</p>
</li>
<li><p>total Cophenetic distance
</p>
</li>
<li><p>symmetry Nodes
</p>
</li>
<li><p>rquartet index
</p>
</li>
<li><p>j_one statistic
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>calc_balance_stats(phylo, normalize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_balance_stats_+3A_phylo">phylo</code></td>
<td>
<p>phylo object</p>
</td></tr>
<tr><td><code id="calc_balance_stats_+3A_normalize">normalize</code></td>
<td>
<p>if set to TRUE, results are normalized (if possible) under
either the  Yule expectation (if available), or the number of tips</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with statistics
</p>

<hr>
<h2 id='calc_brts_stats'>function to apply all tree statistics related to branching times
to a single tree.</h2><span id='topic+calc_brts_stats'></span>

<h3>Description</h3>

<p>this function applies all tree statistics based on
branching times to a single tree, being:
</p>

<ul>
<li><p>gamma
</p>
</li>
<li><p>pigot's rho
</p>
</li>
<li><p>mean branch length
</p>
</li>
<li><p>nLTT with empty tree
</p>
</li>
<li><p>var branch length
</p>
</li>
<li><p>mean internal branch length
</p>
</li>
<li><p>mean external branch length
</p>
</li>
<li><p>var internal branch length
</p>
</li>
<li><p>var external branch length
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>calc_brts_stats(phylo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_brts_stats_+3A_phylo">phylo</code></td>
<td>
<p>phylo object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with statistics
</p>

<hr>
<h2 id='cherries'>Cherry index</h2><span id='topic+cherries'></span>

<h3>Description</h3>

<p>Calculate the number of cherries, from the phyloTop package.
A cherry is a pair of sister tips.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cherries(input_obj, normalization = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cherries_+3A_input_obj">input_obj</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
<tr><td><code id="cherries_+3A_normalization">normalization</code></td>
<td>
<p>&quot;none&quot;, &quot;yule&quot;, or &quot;pda&quot;, the found number of
cherries is divided by the expected number, following
McKenzie &amp; Steel 2000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number of cherries
</p>


<h3>References</h3>

<p>McKenzie, Andy, and Mike Steel. &quot;Distributions of cherries for
two models of trees.&quot; Mathematical biosciences 164.1 (2000): 81-92.
</p>

<hr>
<h2 id='colless'>Fast function using C++ to calculate the Colless index of (im)balance.</h2><span id='topic+colless'></span>

<h3>Description</h3>

<p>The Colless index is calculated as the sum of
<code class="reqn">abs(L - R)</code> over all nodes, where L (or R) is the number of extant tips
associated with the L (or R) daughter branch at that node.  Higher values
indicate higher imbalance. Two normalizations are available,
where a correction is made for tree size, under either a yule expectation,
or a pda expectation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colless(phy, normalization = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colless_+3A_phy">phy</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
<tr><td><code id="colless_+3A_normalization">normalization</code></td>
<td>
<p>A character string equals to &quot;none&quot; (default) for no
normalization or one of &quot;pda&quot; or &quot;yule&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>colless index
</p>


<h3>References</h3>

<p>Colless D H. 1982. Review of: Phylogenetics: The Theory and
Practice of Phylogenetic Systematics. Systematic Zoology 31:100-104.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simulated_tree &lt;- ape::rphylo(n = 10, birth = 1, death = 0)
brts &lt;- branching_times(simulated_tree)
if (requireNamespace("nodeSub")) {
  balanced_tree &lt;- nodeSub::create_balanced_tree(brts)
  unbalanced_tree &lt;- nodeSub::create_unbalanced_tree(brts)
  colless(balanced_tree)
  colless(unbalanced_tree) # should be higher
}
</code></pre>

<hr>
<h2 id='crown_age'>Calculates the crown age of a tree using C++.</h2><span id='topic+crown_age'></span>

<h3>Description</h3>

<p>In a reconstructed tree, obtaining the crown age is
fairly straightforward, and the function beautier::get_crown_age does
a great job at it. However, in a non-ultrametric tree, that function no
longer works. This function provides a functioning alternative
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crown_age(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crown_age_+3A_phy">phy</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>crown age
</p>

<hr>
<h2 id='diameter'>Fast function using C++ to calculate the diameter</h2><span id='topic+diameter'></span>

<h3>Description</h3>

<p>The Diameter of a tree is defined as the maximum length of a
shortest path. When taking branch lengths into account, this is equal to
twice the crown age.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diameter(phy, weight = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diameter_+3A_phy">phy</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
<tr><td><code id="diameter_+3A_weight">weight</code></td>
<td>
<p>if TRUE, uses branch lengths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Diameter
</p>


<h3>References</h3>

<p>Chindelevitch, Leonid, et al. &quot;Network science inspires novel
tree shape statistics.&quot; PloS one 16.12 (2021): e0259877.
</p>

<hr>
<h2 id='eigen_vector'>Fast function using C++ to calculate eigen vector centrality</h2><span id='topic+eigen_vector'></span>

<h3>Description</h3>

<p>Eigen vector centrality associates with each node v the positive
value e(v), such that: <code class="reqn">sum_{e~v} w(uv) * e(u) = \lambda * e(v)</code>. Thus,
e(v) is the Perron-Frobenius eigenvector of the adjacency matrix of the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigen_vector(phy, weight = TRUE, scale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigen_vector_+3A_phy">phy</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
<tr><td><code id="eigen_vector_+3A_weight">weight</code></td>
<td>
<p>if TRUE, uses branch lengths.</p>
</td></tr>
<tr><td><code id="eigen_vector_+3A_scale">scale</code></td>
<td>
<p>if TRUE, the eigenvector is rescaled</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the eigen vector and the leading eigen value
</p>


<h3>References</h3>

<p>Chindelevitch, Leonid, et al. &quot;Network science inspires novel
tree shape statistics.&quot; Plos one 16.12 (2021): e0259877.
</p>

<hr>
<h2 id='entropy_j'>Fast function using C++ to calculate the intensive quadratic entropy
statistic J.</h2><span id='topic+entropy_j'></span>

<h3>Description</h3>

<p>The intensive quadratic entropy statistic J is given by the
average distance between two randomly chosen species, thus given by the
sum of all pairwise distances, divided by S^2, where S is the number of tips
of the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entropy_j(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entropy_j_+3A_phy">phy</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>intensive quadratic entropy statistic J
</p>


<h3>References</h3>

<p>Izsák, János, and Laszlo Papp. &quot;A link between ecological
diversity indices and measures of biodiversity.&quot;
Ecological Modelling 130.1-3 (2000): 151-156.
</p>

<hr>
<h2 id='ew_colless'>Fast function using C++ to calculate the equal weights Colless index of
(im)balance.</h2><span id='topic+ew_colless'></span>

<h3>Description</h3>

<p>The equal weights Colless index is calculated as the sum of
<code class="reqn">abs(L - R) / (L + R - 2)</code> over all nodes where L + R &gt; 2,
where L (or R) is the number of extant tips associated with the L (or R)
daughter branch at that node.  Maximal imbalance is associated with a value
of 1.0. The ew_colless index is not sensitive to tree size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ew_colless(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ew_colless_+3A_phy">phy</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>colless index
</p>


<h3>References</h3>

<p>A. O. Mooers and S. B. Heard. Inferring Evolutionary Process
from Phylogenetic Tree Shape. The Quarterly Review of Biology, 72(1), 1997.
doi: 10.1086/419657.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simulated_tree &lt;- ape::rphylo(n = 10, birth = 1, death = 0)
brts &lt;- branching_times(simulated_tree)
if (requireNamespace("nodeSub")) {
  balanced_tree &lt;- nodeSub::create_balanced_tree(brts)
  unbalanced_tree &lt;- nodeSub::create_unbalanced_tree(brts)
  ew_colless(balanced_tree)
  ew_colless(unbalanced_tree) # should be higher
}
</code></pre>

<hr>
<h2 id='gamma_statistic'>Calculate the gamma statistic, using a fast implementation in C++.</h2><span id='topic+gamma_statistic'></span>

<h3>Description</h3>

<p>The gamma statistic measures the relative position of
internal nodes within a reconstructed phylogeny. Under the Yule process,
the gamma values of a reconstructed tree follow a standard normal
distribution. If gamma &gt; 0, the nodes are located more towards the tips of
the tree, and if gamma &lt; 0, the nodes are located more towards the root of
the tree. Only available for ultrametric trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamma_statistic(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamma_statistic_+3A_phy">phy</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>gamma statistic
</p>


<h3>References</h3>

<p>Pybus, O. G. and Harvey, P. H. (2000) Testing macro-evolutionary
models using incomplete molecular phylogenies. Proceedings of the Royal
Society of London. Series B. Biological Sciences, 267, 2267–2272.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simulated_tree &lt;- ape::rphylo(n = 10, birth = 1, death = 0)
gamma_statistic(simulated_tree) # should be around 0.
if (requireNamespace("DDD")) {
  ddd_tree &lt;- DDD::dd_sim(pars = c(1, 0, 10), age = 7)$tes
  gamma_statistic(ddd_tree) # because of diversity dependence, should be &lt; 0
}
</code></pre>

<hr>
<h2 id='ILnumber'>Calculate ILnumber</h2><span id='topic+ILnumber'></span>

<h3>Description</h3>

<p>The ILnumber is the number of internal nodes with a
single tip child. Higher values typically indicate a tree that
is more unbalanced.
</p>
<p>The ILnumber is the number of internal nodes with a single tip child, as
adapted from the phyloTop package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ILnumber(input_obj, normalization = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ILnumber_+3A_input_obj">input_obj</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
<tr><td><code id="ILnumber_+3A_normalization">normalization</code></td>
<td>
<p>&quot;none&quot; or &quot;tips&quot;, in which case the result is normalized
by dividing by N - 2, where N is the number of tips.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ILnumber
</p>

<hr>
<h2 id='imbalance_steps'>imbalance steps index</h2><span id='topic+imbalance_steps'></span>

<h3>Description</h3>

<p>Calculates the number of moves required to transform the focal
tree into a fully imbalanced (caterpillar) tree. Higher value indicates a
more balanced tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imbalance_steps(input_obj, normalization = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imbalance_steps_+3A_input_obj">input_obj</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
<tr><td><code id="imbalance_steps_+3A_normalization">normalization</code></td>
<td>
<p>if true, the number of steps taken is normalized by tree
size, by dividing by the maximum number of moves required to move from a
fully balanced to a fully imbalanced tree, which is N - log2(N) - 1, where
N is the number of extant tips.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>required number of moves
</p>

<hr>
<h2 id='j_one'>function to calculate the J^1 index.</h2><span id='topic+j_one'></span>

<h3>Description</h3>

<p>The J^1 index calculates the Shannon Entropy of a tree, where
at each node with two children, the Shannon Entropy is the sum of
p_i log_2(p_i) over the two children i, and p_i is L / (L + R), where L and
R represent the number of tips connected to the two daughter branches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>j_one(input_obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="j_one_+3A_input_obj">input_obj</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>j^1 index
</p>


<h3>References</h3>

<p>Jeanne Lemant, Cécile Le Sueur, Veselin Manojlović, Robert Noble,
Robust, Universal Tree Balance Indices, Systematic Biology, Volume 71,
Issue 5, September 2022, Pages 1210–1224,
https://doi.org/10.1093/sysbio/syac027
</p>

<hr>
<h2 id='l_to_phylo'>Convert an L table to phylo object</h2><span id='topic+l_to_phylo'></span>

<h3>Description</h3>

<p>Convert an L table to phylo object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_to_phylo(ltab, drop_extinct = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_to_phylo_+3A_ltab">ltab</code></td>
<td>
<p>ltable</p>
</td></tr>
<tr><td><code id="l_to_phylo_+3A_drop_extinct">drop_extinct</code></td>
<td>
<p>should extinct species be dropped from the phylogeny?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>phylo object
</p>

<hr>
<h2 id='laplacian_spectrum'>function to calculate the laplacian spectrum, from RPANDA</h2><span id='topic+laplacian_spectrum'></span>

<h3>Description</h3>

<p>Computes the distribution of eigenvalues for the modified graph
Laplacian of a phylogenetic tree, and several summary statistics of this
distribution. The modified graph Laplacian of a phylogeny is given by the
difference between its' distance matrix (e.g. all pairwise distances between
all nodes), and the degree matrix (e.g. the diagonal matrix where each
diagonal element represents the sum of branch lengths to all other nodes).
Each row of the modified graph Laplacian sums to zero. For a tree with n
tips, there are N = 2n-1 nodes, and hence the modified graph Laplacian is
represented by a N x N matrix. Where RPANDA relies on the package igraph to
calculate the modified graph Laplacian, the treestats package uses C++ to
directly calculate the different entries in the matrix. This makes the
treestats implementation slightly faster, although the bulk of computation
occurs in estimating the eigen values, using the function eigen from base.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>laplacian_spectrum(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="laplacian_spectrum_+3A_phy">phy</code></td>
<td>
<p>phy</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with five components: 1) eigenvalues the vector of eigen
values, 2) principal_eigenvalue the largest eigenvalueof the spectral
density distribution 3) asymmetry the skewness of the spectral density
distribution 4) peak_height the largest y-axis valueof the spectral
density distribution and 5) eigengap theposition ofthe largest
difference between eigenvalues, giving the number of modalities in the tree.
</p>


<h3>References</h3>

<p>Eric Lewitus, Helene Morlon, Characterizing and Comparing
Phylogenies from their Laplacian Spectrum, Systematic Biology, Volume 65,
Issue 3, May 2016, Pages 495–507, https://doi.org/10.1093/sysbio/syv116
</p>

<hr>
<h2 id='list_statistics'>Provides a list of all available statistics in the package</h2><span id='topic+list_statistics'></span>

<h3>Description</h3>

<p>Provides a list of all available statistics in the package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_statistics(only_balance_stats = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_statistics_+3A_only_balance_stats">only_balance_stats</code></td>
<td>
<p>only return those statistics associated with
measuring balance of a tree</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with names of summary statistics
</p>

<hr>
<h2 id='ltable_to_newick'>Convert an L table to newick string</h2><span id='topic+ltable_to_newick'></span>

<h3>Description</h3>

<p>Convert an L table to newick string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ltable_to_newick(ltab, drop_extinct = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ltable_to_newick_+3A_ltab">ltab</code></td>
<td>
<p>ltable</p>
</td></tr>
<tr><td><code id="ltable_to_newick_+3A_drop_extinct">drop_extinct</code></td>
<td>
<p>should extinct species be dropped from the phylogeny?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>phylo object
</p>

<hr>
<h2 id='make_unbalanced_tree'>this function increasingly increases the imbalance of a tree</h2><span id='topic+make_unbalanced_tree'></span>

<h3>Description</h3>

<p>the goal of this function is to increasingly imbalance a tree,
by changing the topology, one move at a time. It does so by re-attaching
terminal branches to the root lineage, through the ltable. In effect, this
causes the tree to become increasingly caterpillarlike. When started with
a balanced tree, this allows for exploring the gradient between a fully
balanced tree, and a fully unbalanced tree.
Please note that the algorithm will try to increase imbalance, until a fully
caterpillar like tree is reached, which may occur before unbal_steps is
reached.
Three methods are available: &quot;youngest&quot;, reattaches branches in order of age,
starting with the branch originating from the most recent branching event
and working itself through the tree. &quot;Random&quot; picks a random branch to
reattach. &quot;Terminal&quot; also picks a random branch, but only from terminal
branches (e.g. branches that don't have any daughter lineages, which is
maximized in a fully imbalanced tree).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_unbalanced_tree(
  init_tree,
  unbal_steps,
  group_method = "any",
  selection_method = "random"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_unbalanced_tree_+3A_init_tree">init_tree</code></td>
<td>
<p>starting tree to work with</p>
</td></tr>
<tr><td><code id="make_unbalanced_tree_+3A_unbal_steps">unbal_steps</code></td>
<td>
<p>number of imbalance generating steps</p>
</td></tr>
<tr><td><code id="make_unbalanced_tree_+3A_group_method">group_method</code></td>
<td>
<p>choice of &quot;any&quot; and &quot;terminal&quot;</p>
</td></tr>
<tr><td><code id="make_unbalanced_tree_+3A_selection_method">selection_method</code></td>
<td>
<p>choice of &quot;random&quot;, &quot;youngest&quot; and &quot;oldest&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>phylo object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simulated_tree &lt;- ape::rphylo(n = 16, birth = 1, death = 0)
brts &lt;- branching_times(simulated_tree)
if (requireNamespace("nodeSub")) {
  balanced_tree &lt;- nodeSub::create_balanced_tree(brts)
  unbalanced_tree &lt;- nodeSub::create_unbalanced_tree(brts)
  intermediate_tree &lt;- make_unbalanced_tree(balanced_tree, 8)
  colless(balanced_tree)
  colless(intermediate_tree) # should be intermediate value
  colless(unbalanced_tree) # should be highest colless value
}
</code></pre>

<hr>
<h2 id='max_betweenness'>Fast function using C++ to calculate maximum betweenness centrality.</h2><span id='topic+max_betweenness'></span>

<h3>Description</h3>

<p>Betweenness centrality associates with each node v, the two
nodes u, w, for which the shortest path between u and w runs through v, if
the tree were re-rooted at node v. Then, we report the node with maximum
betweenness centrality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_betweenness(phy, normalization = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_betweenness_+3A_phy">phy</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
<tr><td><code id="max_betweenness_+3A_normalization">normalization</code></td>
<td>
<p>&quot;none&quot; or &quot;tips&quot;, if tips is chosen, the obtained
maximum betweenness is normalized by the total amount of node pair
combinations considered, e.g. (n-2)*(n-1), where n is the number of tips.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Maximum Betweenness
</p>


<h3>References</h3>

<p>Chindelevitch, Leonid, et al. &quot;Network science inspires novel
tree shape statistics.&quot; Plos one 16.12 (2021): e0259877.
</p>

<hr>
<h2 id='max_closeness'>Fast function using C++ to calculate maximum closeness</h2><span id='topic+max_closeness'></span>

<h3>Description</h3>

<p>Closeness is defined as 1 / Farness, where Farness is the sum
of distances from a node to all the other nodes in the tree. Here, we return
the node with maximum closeness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_closeness(phy, weight = TRUE, normalization = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_closeness_+3A_phy">phy</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
<tr><td><code id="max_closeness_+3A_weight">weight</code></td>
<td>
<p>if TRUE, uses branch lengths.</p>
</td></tr>
<tr><td><code id="max_closeness_+3A_normalization">normalization</code></td>
<td>
<p>&quot;none&quot; or &quot;tips&quot;, in which case an arbitrary post-hoc
correction is performed by dividing by the expectation of n log(n), where n
is the number of tips.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Maximum Closeness
</p>


<h3>References</h3>

<p>Chindelevitch, Leonid, et al. &quot;Network science inspires novel
tree shape statistics.&quot; Plos one 16.12 (2021): e0259877.
Wang W, Tang CY. Distributed computation of classic and exponential closeness
on tree graphs. Proceedings of the American Control Conference. IEEE; 2014.
p. 2090–2095.
</p>

<hr>
<h2 id='max_del_width'>Fast function using C++ to calculate the maximum difference of widths of a
phylogenetic tree</h2><span id='topic+max_del_width'></span>

<h3>Description</h3>

<p>Calculates the maximum difference of widths of a phylogenetic
tree. First, the widths are calculated by collecting the depth of each node
and tip across the entire tree, where the depth represents the distance
(in nodes) to the root. Then, the width represents the number of occurrences
of each possible depth. Then, we take the difference between each consecutive
width, starting with the first width. The maximum difference is then
returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_del_width(phy, normalization = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_del_width_+3A_phy">phy</code></td>
<td>
<p>phylogeny or ltable</p>
</td></tr>
<tr><td><code id="max_del_width_+3A_normalization">normalization</code></td>
<td>
<p>&quot;none&quot; or &quot;tips&quot;, in which case the resulting statistic
is divided by the number of tips in the tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>maximum difference of widths
</p>


<h3>References</h3>

<p>C. Colijn and J. Gardy. Phylogenetic tree shapes resolve disease
transmission patterns. Evolution, Medicine, and Public Health,
2014(1):96-108, 2014. ISSN 2050-6201. doi: 10.1093/emph/eou018..
</p>

<hr>
<h2 id='max_depth'>Fast function using C++ to calculate maximum depth metric</h2><span id='topic+max_depth'></span>

<h3>Description</h3>

<p>The maximum depth metric, measures the maximal path (in edges),
between the tips and the root.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_depth(phy, normalization = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_depth_+3A_phy">phy</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
<tr><td><code id="max_depth_+3A_normalization">normalization</code></td>
<td>
<p>&quot;none&quot; or &quot;tips&quot;, in which case the resulting statistic
is divided by the number of tips in the tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Maximum depth (in number of edges)
</p>


<h3>References</h3>

<p>C. Colijn and J. Gardy. Phylogenetic tree shapes resolve disease
transmission patterns. Evolution, Medicine, and Public Health,
2014(1):96-108, 2014. ISSN 2050-6201. doi: 10.1093/emph/eou018.
</p>

<hr>
<h2 id='max_ladder'>maximum ladder index</h2><span id='topic+max_ladder'></span>

<h3>Description</h3>

<p>Calculate the maximum ladder index, from the phyloTop package.
Higher values indicate more unbalanced trees. To calculate the maximum ladder
index, first all potential ladders in the tree are calculated. A ladder is
defined as a sequence of nodes where one of the daughter branches is a
terminal branch, resulting in a 'ladder' like pattern. The maximum ladder
index then represents the longest ladder found amongst all observed ladders
in the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_ladder(input_obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_ladder_+3A_input_obj">input_obj</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>longest ladder in the tree
</p>

<hr>
<h2 id='max_width'>Fast function using C++ to calculate the maximum width of branch depth.</h2><span id='topic+max_width'></span>

<h3>Description</h3>

<p>Calculates the maximum width, this is calculated by first
collecting the depth of each node and tip across the entire tree, where the
depth represents the distance (in nodes) to the root. Then, the width
represents the number of occurrences of each possible depth. The maximal
width then returns the maximum number of such occurences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_width(phy, normalization = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_width_+3A_phy">phy</code></td>
<td>
<p>phylogeny or ltable</p>
</td></tr>
<tr><td><code id="max_width_+3A_normalization">normalization</code></td>
<td>
<p>&quot;none&quot; or &quot;tips&quot;, in which case the resulting statistic
is divided by the number of tips in the tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>maximum width
</p>


<h3>References</h3>

<p>C. Colijn and J. Gardy. Phylogenetic tree shapes resolve disease
transmission patterns. Evolution, Medicine, and Public Health,
2014(1):96-108, 2014. ISSN 2050-6201. doi: 10.1093/emph/eou018.
</p>

<hr>
<h2 id='mean_branch_length'>Calculates the mean branch length of a tree, including extinct branches.</h2><span id='topic+mean_branch_length'></span>

<h3>Description</h3>

<p>Calculates the mean branch length of a tree, including extinct branches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_branch_length(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_branch_length_+3A_phy">phy</code></td>
<td>
<p>phylo object or Ltable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mean branch length
</p>

<hr>
<h2 id='mean_branch_length_ext'>Calculates the mean of external branch lengths of a tree, e.g. of
branches leading to a tip.</h2><span id='topic+mean_branch_length_ext'></span>

<h3>Description</h3>

<p>Calculates the mean of external branch lengths of a tree, e.g. of
branches leading to a tip.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_branch_length_ext(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_branch_length_ext_+3A_phy">phy</code></td>
<td>
<p>phylo object or Ltable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mean of external branch lengths
</p>

<hr>
<h2 id='mean_branch_length_int'>Calculates the variation of internal branch lengths of a tree, e.g. of
branches not leading to a tip.</h2><span id='topic+mean_branch_length_int'></span>

<h3>Description</h3>

<p>Calculates the variation of internal branch lengths of a tree, e.g. of
branches not leading to a tip.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_branch_length_int(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_branch_length_int_+3A_phy">phy</code></td>
<td>
<p>phylo object or Ltable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>variation of internal branch lengths
</p>

<hr>
<h2 id='mean_i'>Fast function using C++ to calculate the mean I value.</h2><span id='topic+mean_i'></span>

<h3>Description</h3>

<p>The mean I value is defined for all nodes with at least 4 tips
connected, such that different topologies can be formed. Then, for each node,
I = (nm - nt/2) / (nt - 1 - nt/2), where nt is the total number of tips
descending from that node, nm is the daughter branch leading to most tips,
and nt/2 is the minimum size of the maximum branch, rounded up. Following
Purvis et al 2002, we perform a correction on I, where we correct I for
odd nt, such that I' = I * (nt - 1) / nt. This correction ensures that I
is independent of nt. We report the mean value across all I' (again,
following Purvis et al. 2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_i(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_i_+3A_phy">phy</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>average I value across all nodes
</p>


<h3>References</h3>

<p>G. Fusco and Q. C. Cronk. A new method for evaluating the shape
of large phylogenies. Journal of Theoretical Biology, 1995.
doi: 10.1006/jtbi.1995.0136.
A. Purvis, A. Katzourakis, and P.-M. Agapow. Evaluating Phylogenetic Tree
Shape: Two Modifications to Fusco &amp; Cronks Method. Journal of Theoretical
Biology, 2002. doi: 10.1006/jtbi.2001.2443.
</p>

<hr>
<h2 id='mean_pair_dist'>Mean Pairwise distance</h2><span id='topic+mean_pair_dist'></span>

<h3>Description</h3>

<p>Fast function using C++ to calculate the mean pairwise distance,
using the fast algorithm by Constantinos, Sandel &amp; Cheliotis (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_pair_dist(phy, normalization = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_pair_dist_+3A_phy">phy</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
<tr><td><code id="mean_pair_dist_+3A_normalization">normalization</code></td>
<td>
<p>&quot;none&quot; or &quot;tips&quot;, in which case the obtained mean
pairwise distance is normalized by the factor 2log(n),
where n is the number of tips.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mean pairwise distance
</p>


<h3>References</h3>

<p>Webb, C., D. Ackerly, M. McPeek, and M. Donoghue. 2002.
Phylogenies and community ecology. Annual Review of Ecology and
Systematics 33:475-505.
Tsirogiannis, Constantinos, Brody Sandel, and Dimitris Cheliotis.
&quot;Efficient computation of popular phylogenetic tree measures.&quot; Algorithms in
Bioinformatics: 12th International Workshop, WABI 2012, Ljubljana, Slovenia,
September 10-12, 2012. Proceedings 12. Springer Berlin Heidelberg, 2012.
</p>

<hr>
<h2 id='mntd'>Mean Nearest Taxon distance</h2><span id='topic+mntd'></span>

<h3>Description</h3>

<p>Per tip, evaluates the shortest distance to another tip,
then takes the average across all tips.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mntd(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mntd_+3A_phy">phy</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mean Nearest Taxon Distance.
</p>


<h3>References</h3>

<p>Webb, C., D. Ackerly, M. McPeek, and M. Donoghue. 2002.
Phylogenies and community ecology. Annual Review of Ecology and
Systematics 33:475-505.
</p>

<hr>
<h2 id='nLTT'>Calculate the nLTT, using C++.</h2><span id='topic+nLTT'></span>

<h3>Description</h3>

<p>The nLTT statistic calculates the sum of
absolute differences in the number of lineages over time, where both the
number of lineages and the time are normalized. The number of lineages is
normalized by the number of extant tips, whereas the time is normalized by
the crown age. The nLTT can only be calculated for reconstructed trees.
Only use the treestats version if you are very certain
about the input data, and are certain that performing nLTT is valid (e.g.
your tree is ultrametric etc). If you are less certain, use the nLTT function
from the nLTT package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nLTT(phy, ref_tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nLTT_+3A_phy">phy</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
<tr><td><code id="nLTT_+3A_ref_tree">ref_tree</code></td>
<td>
<p>reference tree to compare with (should be same type as phy)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number of lineages
</p>


<h3>References</h3>

<p>Janzen, T., Höhna, S. and Etienne, R.S. (2015), Approximate
Bayesian Computation of diversification rates from molecular phylogenies:
introducing a new efficient summary statistic, the nLTT. Methods Ecol Evol,
6: 566-575. https://doi.org/10.1111/2041-210X.12350
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simulated_tree &lt;- ape::rphylo(n = 10, birth = 1, death = 0)
reference_tree &lt;- ape::rphylo(n = 10, birth = 0.2, death = 0)
nLTT(simulated_tree, reference_tree)
nLTT(simulated_tree, simulated_tree) # should be zero.
</code></pre>

<hr>
<h2 id='nLTT_base'>Calculates the nLTT statistic using a reference 'empty' tree with only
two lineages.</h2><span id='topic+nLTT_base'></span>

<h3>Description</h3>

<p>The base nLTT statistic can be used as a semi stand-alone
statistic for phylogenetic trees. However, please note that although this
provides a nice way of checking the power of the nLTT statistic without
directly comparing two trees, the nLTT_base statistic is not a substitute
for directly comparing two phylogenetic trees. E.g. one would perhaps
naively assume that <code class="reqn">nLTT(A, B) = |nLTT(A, base) - nLTT(B, base)</code>.
Indeed, in some cases this may hold true (when, for instance, all normalized
lineages of A are less than all normalized lineages of B), but once the
nLTT curve of A intersects the nLTT curve of B, this no longer applies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nLTT_base(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nLTT_base_+3A_phy">phy</code></td>
<td>
<p>phylo object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number of lineages
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simulated_tree &lt;- ape::rphylo(n = 10, birth = 1, death = 0)
nLTT_base(simulated_tree)
</code></pre>

<hr>
<h2 id='number_of_lineages'>Calculate the number of tips of a tree, including extinct tips.</h2><span id='topic+number_of_lineages'></span>

<h3>Description</h3>

<p>Calculate the number of tips of a tree, including extinct tips.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>number_of_lineages(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="number_of_lineages_+3A_phy">phy</code></td>
<td>
<p>phylo object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number of lineages
</p>

<hr>
<h2 id='phylo_to_l'>Function to generate an ltable from a phy object.</h2><span id='topic+phylo_to_l'></span>

<h3>Description</h3>

<p>This function is a C++
implementation of the function DDD::phylo2L. An L table summarises a
phylogeny in a table with four columns, being: 1) time at which a species
is born, 2) label of the parent of the species, where positive and negative
numbers indicate whether the species belongs to the left or right crown
lineage, 3) label of the daughter species itself (again positive or
negative depending on left or right crown lineage), and the last column 4)
indicates the time of extinction of a species, or -1 if the species is
extant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylo_to_l(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylo_to_l_+3A_phy">phy</code></td>
<td>
<p>phylo object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ltable (see description)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simulated_tree &lt;- ape::rphylo(n = 4, birth = 1, death = 0)
ltable &lt;- phylo_to_l(simulated_tree)
reconstructed_tree &lt;- DDD::L2phylo(ltable)
old_par &lt;- par()
par(mfrow = c(1, 2))
# trees should be more or less similar, although labels may not match, and
# rotations might cause (initial) visual mismatches
plot(simulated_tree)
plot(reconstructed_tree)
par(old_par)
</code></pre>

<hr>
<h2 id='phylogenetic_diversity'>Calculates phylogenetic diversity at time point t</h2><span id='topic+phylogenetic_diversity'></span>

<h3>Description</h3>

<p>The phylogenetic diversity at time t is given by the total
branch length of the tree reconstructed up until time point t. Time is
measured increasingly, with the crown age equal to 0. Thus, the time at
the present is equal to the crown age.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylogenetic_diversity(input_obj, t = 0, extinct_tol = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylogenetic_diversity_+3A_input_obj">input_obj</code></td>
<td>
<p>phylo object or Ltable</p>
</td></tr>
<tr><td><code id="phylogenetic_diversity_+3A_t">t</code></td>
<td>
<p>time point at which to measure phylogenetic diversity, alternatively
a vector of time points can also be provided. Time is measured with 0 being
the present.</p>
</td></tr>
<tr><td><code id="phylogenetic_diversity_+3A_extinct_tol">extinct_tol</code></td>
<td>
<p>tolerance to determine if a lineage is extinct at time t.
Default is 1/100 * smallest branch length of the tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>phylogenetic diversity, or vector of phylogenetic diversity measures
if a vector of time points is used as input.
</p>


<h3>References</h3>

<p>Faith, Daniel P. &quot;Conservation evaluation and phylogenetic
diversity.&quot; Biological conservation 61.1 (1992): 1-10.
</p>

<hr>
<h2 id='pigot_rho'>calculate Pigot's rho</h2><span id='topic+pigot_rho'></span>

<h3>Description</h3>

<p>Calculates the change in rate between the first half and the
second half of the extant phylogeny. Rho = (r2 - r1) / (r1 + r2), where r
reflects the rate in either the first or second half. The rate within a half
is given by (log(n2) - log(n1) / t, where n2 is the number of lineages at the
end of the half, and n1 the number of lineages at the start of the half. Rho
varies between -1 and 1, with a 0 indicating a constant rate across the
phylogeny, a rho &lt; 0 indicating a slow down and a rho &gt; 0 indicating a speed
up of speciation. In contrast to the Gamma statistic, Pigot's rho is not
sensitive to tree size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pigot_rho(phy, extant_tree = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pigot_rho_+3A_phy">phy</code></td>
<td>
<p>phylo object</p>
</td></tr>
<tr><td><code id="pigot_rho_+3A_extant_tree">extant_tree</code></td>
<td>
<p>Pigot's rho is originally only defined for an extant tree,
however we include functionality to calculate Pigot's rho for a complete
tree as well.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rho
</p>


<h3>References</h3>

<p>Alex L. Pigot, Albert B. Phillimore, Ian P. F. Owens,
C. David L. Orme, The Shape and Temporal Dynamics of Phylogenetic Trees
Arising from Geographic Speciation, Systematic Biology, Volume 59, Issue 6,
December 2010, Pages 660–673, https://doi.org/10.1093/sysbio/syq058
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simulated_tree &lt;- ape::rphylo(n = 10, birth = 1, death = 0)
pigot_rho(simulated_tree) # should be around 0.
ddd_tree &lt;- DDD::dd_sim(pars = c(1, 0, 10), age = 7)$tes
pigot_rho(ddd_tree) # because of diversity dependence, should be &lt; 0
</code></pre>

<hr>
<h2 id='pitchforks'>Calculate pitchforks, from the phyloTop package, a pitchfork is a clade
with three tips.</h2><span id='topic+pitchforks'></span>

<h3>Description</h3>

<p>Calculate pitchforks, from the phyloTop package, a pitchfork is a clade
with three tips.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pitchforks(input_obj, normalization = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pitchforks_+3A_input_obj">input_obj</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
<tr><td><code id="pitchforks_+3A_normalization">normalization</code></td>
<td>
<p>&quot;none&quot; or &quot;tips&quot;, in which case the found number of
pitchforks is divided by the expected number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number of pitchforks
</p>

<hr>
<h2 id='prep_lapl_spec'>function to create laplacian matrix</h2><span id='topic+prep_lapl_spec'></span>

<h3>Description</h3>

<p>function to create laplacian matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_lapl_spec(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_lapl_spec_+3A_phy">phy</code></td>
<td>
<p>phy</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numericmatrix
</p>

<hr>
<h2 id='psv'>Fast function using C++ to calculate Phylogenetic Species Variability.</h2><span id='topic+psv'></span>

<h3>Description</h3>

<p>The phylogenetic species variability is bounded in [0, 1]. The
psv quantifies how phylogenetic relatedness decrease the variance of a
(neutral) trait shared by all species in the tree. As species become more
related, the psv tends to 0.
Please note that the psv is a special case of the Mean Pair Distance (see
appendix of Tucker et al. 2017 for a full derivation), and thus correlates
directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psv(phy, normalization = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psv_+3A_phy">phy</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
<tr><td><code id="psv_+3A_normalization">normalization</code></td>
<td>
<p>&quot;none&quot; or &quot;tips&quot;, in which case the obtained mean
pairwise distance is normalized by the factor 2log(n), where n is the number
of tips.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Phylogenetic Species Variability
</p>


<h3>References</h3>

<p>Helmus M.R., Bland T.J., Williams C.K. &amp; Ives A.R. (2007)
Phylogenetic measures of biodiversity. American Naturalist, 169, E68-E83
</p>
<p>Tucker, Caroline M., et al. &quot;A guide to phylogenetic metrics for
conservation, community ecology and macroecology.&quot;
Biological Reviews 92.2 (2017): 698-715.
</p>

<hr>
<h2 id='rebase_ltable'>a function to modify an ltable, such that the longest path in the phylogeny
is a crown lineage.</h2><span id='topic+rebase_ltable'></span>

<h3>Description</h3>

<p>a function to modify an ltable, such that the longest path in the phylogeny
is a crown lineage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rebase_ltable(ltable)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rebase_ltable_+3A_ltable">ltable</code></td>
<td>
<p>ltable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>modified ltable
</p>

<hr>
<h2 id='rogers'>Fast function using C++ to calculate the Rogers J index of (im)balance.</h2><span id='topic+rogers'></span>

<h3>Description</h3>

<p>The Rogers index is calculated as the total number of internal
nodes that are unbalanced, e.g. for which both daughter nodes lead to a
different number of extant tips. in other words, the number of nodes where
L != R (where L(R) is the number of extant tips of the Left (Right) daughter
node).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rogers(phy, normalization = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rogers_+3A_phy">phy</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
<tr><td><code id="rogers_+3A_normalization">normalization</code></td>
<td>
<p>&quot;none&quot; or &quot;tips&quot;, in which case the resulting statistic
is divided by the number of tips - 2 (e.g. the maximum value of the rogers
index for a tree).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Rogers index
</p>


<h3>References</h3>

<p>J. S. Rogers. Central Moments and Probability Distributions of
Three Measures of Phylogenetic Tree Imbalance. Systematic Biology,
45(1):99-110, 1996. doi: 10.1093/sysbio/45.1.99.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simulated_tree &lt;- ape::rphylo(n = 10, birth = 1, death = 0)
brts &lt;- branching_times(simulated_tree)
if (requireNamespace("nodeSub")) {
  balanced_tree &lt;- nodeSub::create_balanced_tree(brts)
  unbalanced_tree &lt;- nodeSub::create_unbalanced_tree(brts)
  rogers(balanced_tree)
  rogers(unbalanced_tree) # should be higher
}
</code></pre>

<hr>
<h2 id='rquartet'>Fast function using C++ to calculate the rquartet index.</h2><span id='topic+rquartet'></span>

<h3>Description</h3>

<p>The rquartet index counts the number of potential fully
balanced rooted subtrees of 4 tips in the tree. The function in treestats
assumes a bifurcating tree. For trees with polytomies, we refer the user to
treebalance::rquartedI, which can also take polytomies into account.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rquartet(phy, normalization = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rquartet_+3A_phy">phy</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
<tr><td><code id="rquartet_+3A_normalization">normalization</code></td>
<td>
<p>The index can be normalized by the expectation under
the Yule (&quot;yule&quot;) or PDA model (&quot;pda&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rquartet index
</p>


<h3>References</h3>

<p>T. M. Coronado, A. Mir, F. Rosselló, and G. Valiente. A balance
index for phylogenetic trees based on rooted quartets. Journal of
Mathematical Biology, 79(3):1105-1148, 2019. doi: 10.1007/s00285-019-01377-w.
</p>

<hr>
<h2 id='sackin'>Fast function using C++ to calculate the sackin index of (im)balance.</h2><span id='topic+sackin'></span>

<h3>Description</h3>

<p>The Sackin index is calculated as the sum of ancestors for each
of the tips. Higher values indicate higher imbalance. Two normalizations
are available, where a correction is made for tree size, under either a
Yule expectation, or a pda expectation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sackin(phy, normalization = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sackin_+3A_phy">phy</code></td>
<td>
<p>phylogeny or ltable</p>
</td></tr>
<tr><td><code id="sackin_+3A_normalization">normalization</code></td>
<td>
<p>normalization, either 'none' (default), &quot;yule&quot; or &quot;pda&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sackin index
</p>


<h3>References</h3>

<p>M. J. Sackin (1972). &quot;Good&quot; and &quot;Bad&quot; Phenograms.
Systematic Biology. 21:225-226.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simulated_tree &lt;- ape::rphylo(n = 10, birth = 1, death = 0)
brts &lt;- branching_times(simulated_tree)
if (requireNamespace("nodeSub")) {
  balanced_tree &lt;- nodeSub::create_balanced_tree(brts)
  unbalanced_tree &lt;- nodeSub::create_unbalanced_tree(brts)
  sackin(balanced_tree)
  sackin(unbalanced_tree) # should be much higher
}
</code></pre>

<hr>
<h2 id='stairs'>Calculates the staircase-ness measure, from the phyloTop package. The
staircase-ness reflects the number of subtrees that are imbalanced, e.g.
subtrees where the left child has more extant tips than the right child, or
vice versa.</h2><span id='topic+stairs'></span>

<h3>Description</h3>

<p>Calculates the staircase-ness measure, from the phyloTop package. The
staircase-ness reflects the number of subtrees that are imbalanced, e.g.
subtrees where the left child has more extant tips than the right child, or
vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stairs(input_obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stairs_+3A_input_obj">input_obj</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number of stairs
</p>


<h3>References</h3>

<p>Norström, Melissa M., et al. &quot;Phylotempo: a set of r scripts for
assessing and visualizing temporal clustering in genealogies inferred from
serially sampled viral sequences.&quot; Evolutionary Bioinformatics 8 (2012):
EBO-S9738.
</p>

<hr>
<h2 id='stairs2'>Calculates the stairs2 measure, from the phyloTop package. The
stairs2 reflects the imbalance at each node, where it represents the average
across measure at each node, the measure being min(l, r) / max(l, r), where
l and r reflect the number of tips connected at the left (l) and right (r)
daughter.</h2><span id='topic+stairs2'></span>

<h3>Description</h3>

<p>Calculates the stairs2 measure, from the phyloTop package. The
stairs2 reflects the imbalance at each node, where it represents the average
across measure at each node, the measure being min(l, r) / max(l, r), where
l and r reflect the number of tips connected at the left (l) and right (r)
daughter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stairs2(input_obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stairs2_+3A_input_obj">input_obj</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number of stairs
</p>


<h3>References</h3>

<p>Norström, Melissa M., et al. &quot;Phylotempo: a set of r scripts for
assessing and visualizing temporal clustering in genealogies inferred from
serially sampled viral sequences.&quot; Evolutionary Bioinformatics 8 (2012):
EBO-S9738.
</p>

<hr>
<h2 id='sym_nodes'>Fast function using C++ to calculate the symmetry nodes metric</h2><span id='topic+sym_nodes'></span>

<h3>Description</h3>

<p>Balance metric that returns the total number of internal nodes
that are not-symmetric (confusingly enough). A node is considered symmetric
when both daughter trees have the same topology, measured as having the
same sum of depths, where depth is measured as the distance from the root
to the node/tip.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sym_nodes(phy, normalization = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sym_nodes_+3A_phy">phy</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
<tr><td><code id="sym_nodes_+3A_normalization">normalization</code></td>
<td>
<p>&quot;none&quot; or &quot;tips&quot;, in which case the resulting statistic
is divided by the number of tips - 2 (e.g. the maximum value of the symmetry
nodes index for a tree).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Maximum depth (in number of edges)
</p>


<h3>References</h3>

<p>S. J. Kersting and M. Fischer. Measuring tree balance using
symmetry nodes — A new balance index and its extremal properties.
Mathematical Biosciences, page 108690, 2021. ISSN 0025-5564.
doi:https://doi.org/10.1016/j.mbs.2021.108690
</p>

<hr>
<h2 id='tot_coph'>Fast function using C++ to calculate the total cophenetic index.</h2><span id='topic+tot_coph'></span>

<h3>Description</h3>

<p>The total cophenetic index is the sum of the depth of the last
common ancestor of all pairs of leaves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tot_coph(phy, normalization = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tot_coph_+3A_phy">phy</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
<tr><td><code id="tot_coph_+3A_normalization">normalization</code></td>
<td>
<p>&quot;none&quot; or &quot;yule&quot;, when &quot;yule&quot; is chosen, the statistic
is divided by the Yule expectation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Total cophenetic index
</p>


<h3>References</h3>

<p>A. Mir, F. Rosselló, and L. Rotger. A new balance index for
phylogenetic trees. Mathematical Bio-sciences, 241(1):125-136, 2013.
doi: 10.1016/j.mbs.2012.10.005.
</p>

<hr>
<h2 id='tree_height'>Calculates the height of a tree using C++.</h2><span id='topic+tree_height'></span>

<h3>Description</h3>

<p>In a reconstructed tree, obtaining the tree height is fairly
straightforward, and the function beautier::get_crown_age does a great job
at it. However, in a non-ultrametric tree, that function no longer works.
Alternatively, taking the maximum value of adephylo::distRoot will also yield
the tree height (including the root branch), but will typically perform
many superfluous calculations and thus be slow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_height(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_height_+3A_phy">phy</code></td>
<td>
<p>phylo object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>crown age
</p>

<hr>
<h2 id='treestats-package'>
Collection of phylogenetic tree statistics
</h2><span id='topic+treestats-package'></span><span id='topic+treestats'></span>

<h3>Description</h3>

<p>The 'treestats' package contains a collection of phylogenetic tree statistics,
implemented in C++ to ensure high speed.
</p>


<h3>Details</h3>

<p>Given a phylogenetic tree as a phylo object, the 'treestats' package provides
a wide range of individual functions returning the relevant statistic. In
addition, there are three functions available that calculate a collection
of statistics at once: calc_all_statistics (which calculates all currently
implemented statistics of treestats), calc_balance_stats, which calculates
all (im)balance related statistics and calc_brts_stats, which calculates all
branching times and branch length related statistics.
Furthermore, there are a number of additional tools available that allow for
phylogenetic tree manipulation: make_unbalanced_tree, which creates an
imbalanced tree in a stepwise fashion. Then there are two functions related to
conversion from and to an ltable, an alternative notation method used in some
simulations. These are l_to_phylo which is a C++ based
version of DDD::L2phylo, which converts an ltable to a phylo object, and
phylo_to_l, which is a C+ based version of DDD::phylo2L, which converts a
phylo object to an ltable. Lastly, the treestats package also includes a
faster, C++ based, implementation of ape::branching.times (the
function branching_times), which yields the same sequence of branching times,
but omits the branching names in favour of speed.
</p>


<h3>Author(s)</h3>

<p>Maintainer: Thijs Janzen &lt;thijsjanzen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Phylogenetic tree statistics: a systematic overview using the new R package
'treestats' Thijs Janzen, Rampal S. Etienne bioRxiv 2024.01.24.576848;
doi: https://doi.org/10.1101/2024.01.24.576848
</p>

<hr>
<h2 id='var_branch_length'>Calculates the variance of branch lengths of a tree,
including extinct branches.</h2><span id='topic+var_branch_length'></span>

<h3>Description</h3>

<p>Calculates the variance of branch lengths of a tree,
including extinct branches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_branch_length(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_branch_length_+3A_phy">phy</code></td>
<td>
<p>phylo object or Ltable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>variance of branch lengths
</p>

<hr>
<h2 id='var_branch_length_ext'>Calculates the variance of external branch lengths of a tree, e.g. of
branches leading to a tip.</h2><span id='topic+var_branch_length_ext'></span>

<h3>Description</h3>

<p>Calculates the variance of external branch lengths of a tree, e.g. of
branches leading to a tip.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_branch_length_ext(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_branch_length_ext_+3A_phy">phy</code></td>
<td>
<p>phylo object or Ltable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>variance of external branch lengths
</p>

<hr>
<h2 id='var_branch_length_int'>Calculates the variance of internal branch lengths of a tree, e.g. of
branches not leading to a tip.</h2><span id='topic+var_branch_length_int'></span>

<h3>Description</h3>

<p>Calculates the variance of internal branch lengths of a tree, e.g. of
branches not leading to a tip.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_branch_length_int(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_branch_length_int_+3A_phy">phy</code></td>
<td>
<p>phylo object or Ltable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>variance of internal branch lengths
</p>

<hr>
<h2 id='var_leaf_depth'>Fast function using C++ to calculate the variance of leaf depth statistic</h2><span id='topic+var_leaf_depth'></span>

<h3>Description</h3>

<p>The variance of leaf depth statistic returns the variance
of depths across all tips.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_leaf_depth(phy, normalization = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_leaf_depth_+3A_phy">phy</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
<tr><td><code id="var_leaf_depth_+3A_normalization">normalization</code></td>
<td>
<p>&quot;none&quot; or &quot;yule&quot;, when &quot;yule&quot; is chosen, the statistic
is divided by the Yule expectation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Variance of leaf depths
</p>


<h3>References</h3>

<p>T. M. Coronado, A. Mir, F. Rosselló, and L. Rotger.
On Sackin's original proposal: the variance of the leaves' depths as a
phylogenetic balance index. BMC Bioinformatics, 21(1), 2020.
doi: 10.1186/s12859-020-3405-1.
</p>

<hr>
<h2 id='var_pair_dist'>Fast function using C++ to calculate the variance of all pairwise distances.</h2><span id='topic+var_pair_dist'></span>

<h3>Description</h3>

<p>After calculating all pairwise distances between all tips,
this function takes the variance across these values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_pair_dist(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_pair_dist_+3A_phy">phy</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Variance in pairwise distance
</p>


<h3>References</h3>

<p>Webb, C., D. Ackerly, M. McPeek, and M. Donoghue. 2002.
Phylogenies and community ecology. Annual Review of Ecology and
Systematics 33:475-505.
</p>

<hr>
<h2 id='wiener'>Fast function using C++ to calculate the Wiener index</h2><span id='topic+wiener'></span>

<h3>Description</h3>

<p>The Wiener index is defined as the sum of all shortest path
lengths between pairs of nodes in a tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wiener(phy, normalization = FALSE, weight = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wiener_+3A_phy">phy</code></td>
<td>
<p>phylo object or ltable</p>
</td></tr>
<tr><td><code id="wiener_+3A_normalization">normalization</code></td>
<td>
<p>if TRUE, the Wiener index is normalized by the number of
nodes, e.g. by choose(n, 2), where n is the number of nodes.</p>
</td></tr>
<tr><td><code id="wiener_+3A_weight">weight</code></td>
<td>
<p>if TRUE, branch lenghts are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Wiener index
</p>


<h3>References</h3>

<p>Chindelevitch, Leonid, et al. &quot;Network science inspires novel
tree shape statistics.&quot; Plos one 16.12 (2021): e0259877.
Mohar, B., Pisanski, T. How to compute the Wiener index of a graph.
J Math Chem 2, 267–277 (1988)
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
