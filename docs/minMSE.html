<!DOCTYPE html><html><head><title>Help for package minMSE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {minMSE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#assign_minMSE_treatment'><p>minMSE Treatment Assignment for One or Multiple Treatment Groups &ndash; Wrapper</p></a></li>
<li><a href='#assign_treatment'>
<p>Min MSE Treatment Assignment</p></a></li>
<li><a href='#count_occurrences'>
<p>Count of Equal Treatment Vectors</p></a></li>
<li><a href='#evaluate_solution'>
<p>Evaluate MSE Equation</p></a></li>
<li><a href='#evaluate_solution_matrix'>
<p>Evaluate MSE Equation</p></a></li>
<li><a href='#evaluate_solution_vector'>
<p>Evaluate MSE Equation</p></a></li>
<li><a href='#evaluate_solution.optim'>
<p>Evaluate MSE Equation (using optim)</p></a></li>
<li><a href='#output_file'><p>TXT File That Contains Additional Output Information</p></a></li>
<li><a href='#plotting_file'><p>CSV File for Saving the Data to Plot</p></a></li>
<li><a href='#sample_with_prev_treatment'>
<p>Sample Under Consideration of an Already Treated Subset of Units</p></a></li>
<li><a href='#scale_vars'>
<p>Covariate Vectors Scaling</p></a></li>
<li><a href='#swap_treatment'>
<p>Swap Treatment</p></a></li>
<li><a href='#swap_treatment_prev'>
<p>Swap Treatment</p></a></li>
<li><a href='#swap_treatment.optim'>
<p>Swap Treatment (using optim)</p></a></li>
<li><a href='#vector_gcd'>
<p>Vector Greatest Common Divisor</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Implementation of the minMSE Treatment Assignment Method for One
or Multiple Treatment Groups</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastian O. Schneider, Giulia Baldini</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sebastian O. Schneider &lt;sschneider@coll.mpg.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs treatment assignment for (field) experiments considering available, possibly multivariate and continuous, information (covariates, observable characteristics), that is: forms balanced treatment groups, according to the minMSE-method as proposed by Schneider and Schlather (2017) &lt;<a href="https://doi.org/10419%2F161931">doi:10419/161931</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.sebastianoschneider.com">https://www.sebastianoschneider.com</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GNU General Public License]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-11-26 21:36:56 UTC; schneider</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-11-26 22:50:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='assign_minMSE_treatment'>minMSE Treatment Assignment for One or Multiple Treatment Groups &ndash; Wrapper</h2><span id='topic+assign_minMSE_treatment'></span>

<h3>Description</h3>

<p>Calling <a href="#topic+assign_treatment">assign_treatment</a>, this user-friendly wrapper function computes a given number of treatment assignment vectors that will contain at most a certain percentage of duplicates, specified in percentage_equal_treatments. This is useful if non-parametric inference (randomization inference, sometimes called Fisher's exact test or permutation test) is desired (which is often advised), for analysis of significance of the treatment effect. The main function, assign_treatment, computes the treatment assignment vector according to available data (observable characteristics, covariate vectors) given about the units (individuals or clusters, such as schools, hospitals, ...)</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_minMSE_treatment(data,
                        prev_treatment = NULL,
                        n_treatments = 1,
                        n_per_group = NULL,
                        mse_weights = NULL,
                        iterations = 50,
                        change = 3,
                        cooling = 1,
                        t0 = 10,
                        tmax = 10,
                        built_in = 0,
                        desired_test_vectors = 100,
                        percentage_equal_treatments = 1,
                        plot = 0,
                        trace_output = 1,
                        filename = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assign_minMSE_treatment_+3A_data">data</code></td>
<td>
<p>a dataframe or a matrix containing the covariate vectors for each attribute. The values might be missing or on different scales as the software deals with missing values and scaling automatically.</p>
</td></tr>
<tr><td><code id="assign_minMSE_treatment_+3A_prev_treatment">prev_treatment</code></td>
<td>
<p>takes a numerical vector of partial treatment assignment as argument, and assigns the missing units (where the value is NA) to a treatment group while minimizing the objective function. Non-missing values are copied to the new vector, i.e., treatment group assignment of these observations is unaffected, but taken into consideration for achieving balanced treatment groups.</p>
</td></tr>
<tr><td><code id="assign_minMSE_treatment_+3A_n_treatments">n_treatments</code></td>
<td>
<p>specifies the number of treatment groups desired (in addition to the control group); minimum and default value is n_treatments = 1.</p>
</td></tr>
<tr><td><code id="assign_minMSE_treatment_+3A_n_per_group">n_per_group</code></td>
<td>
<p>specifies a vector containing uneven sizes for the treatment groups. Default value is NULL, which yields even sized groups. The sum of the elements in the vector should be equal to the total number of observations.</p>
</td></tr>
<tr><td><code id="assign_minMSE_treatment_+3A_mse_weights">mse_weights</code></td>
<td>
<p>a vector containing the mse_weights for each treatment, or a matrix containing the mse_weights for treatments and outcomes and scaling factors.</p>
</td></tr>
<tr><td><code id="assign_minMSE_treatment_+3A_iterations">iterations</code></td>
<td>
<p>specifies the number of iterations the algorithm performs; the default value is iterations = 50. Depending on the number of units and the number of covariates to consider for group assignment, a high value could result in a long run-time.</p>
</td></tr>
<tr><td><code id="assign_minMSE_treatment_+3A_change">change</code></td>
<td>
<p>sets the number of units to exchange treatment in each iteration; the default value is change = 3. In case of big datasets (e.g. with more than 100 units), one might consider increasing the default value.</p>
</td></tr>
<tr><td><code id="assign_minMSE_treatment_+3A_cooling">cooling</code></td>
<td>
<p>specifies the cooling scheme for the simulated annealing algorithm to use. cooling = 1, which is the default scheme, sets the temperature to
</p>
<p style="text-align: center;"><code class="reqn">t0/log(floor((k - 1)/tmax ) * tmax + exp(1)),</code>
</p>
<p> whereas cooling = 2 sets the temperature to the faster decreasing sequence </p>
<p style="text-align: center;"><code class="reqn">t0 /(floor((k - 1)/tmax) * tmax + 1).</code>
</p>
<p> In praxis, cooling schemes are mostly of one of these forms. One might want to change the cooling scheme if the plot indicates a too slow decrease of objective values. For a theoretical discussion of cooling schemes Belisle (see 1992, p. 890).</p>
</td></tr>
<tr><td><code id="assign_minMSE_treatment_+3A_t0">t0</code></td>
<td>
<p>sets the starting temperature for the simulated annealing algorithm, see Belisle (1992) for theoretical convergence considerations. In praxis, a lower starting temperature t0 decreases the acceptance rate of a worse solution more rapidly. Specifying a negative number allows values proportional to the objective function, i.e. t0 = -5 sets the starting temperature to 1/5 of the objective function for the starting point, and thus - for the first tmax iterations of the algorithm - the difference of the old and the proposed solution is scaled by 1/5. When changing the default value, it should be considered that also worse solutions have to be accepted in order for the algorithm to escape a local minimum, so it should be chosen high enough. The default value is t0 = 10.</p>
</td></tr>
<tr><td><code id="assign_minMSE_treatment_+3A_tmax">tmax</code></td>
<td>
<p>specifies the number of function evaluations at each temperature: For instance, tmax = 10 makes the algorithm evaluate 10 treatment assignments that are found based on the current solution, before the temperature is decreased and thus the probability of accepting a worse solution is decreased. The default value is tmax = 10.</p>
</td></tr>
<tr><td><code id="assign_minMSE_treatment_+3A_built_in">built_in</code></td>
<td>
<p>if built_in = 1 the R built-in function <a href="stats.html#topic+optim">optim</a> with method 'SANN' (Simulated ANNealing) will be used to optimize the function. Otherwise, if built_in = 0, our implementation of the simulated annealing will be used. The function built_in = 0 uses our first cooling function and this cannot be changed. To used the second cooling function, set built_in = 0. All the other parameters, such as iterations, change, t0, tmax are taken into account.</p>
</td></tr>
<tr><td><code id="assign_minMSE_treatment_+3A_desired_test_vectors">desired_test_vectors</code></td>
<td>
<p>specifies the number of treatment assignment vectors that will be produced to perform Fischer's exact test (sometimes also called permutation test) for assessment of significance of the treatment effect (this, of course, will be done after treatment has been conducted and measurement of the outcome of interest has occurred). The number of possible treatment vectors will not exceed this number. The default value is desired_test_vectors = 100. For small datasets, one might consider increasing it without affecting performance. Note that this will affect your significance level: If desired_test_vectors = 100 and all of them are unique (see &lsquo;percentage_equal_treatments' below), you can achieve a significance level of at most p &lt; 0.01%.If desired_test_vectors = 1, then the program returns a single vector that can be used for treatment assignment. Note that Fischer&rsquo;s exact test might still be possible and that alternative treatment vectors might also be produced after treatment has been conducted; yet, it is not sure how many *different* vectors can be produced with a given number of iterations. It is, therefore, good practice to produce the desired number of vectors with treatment assignment. For testing purposes, however, one might want to produce just one vector.</p>
</td></tr>
<tr><td><code id="assign_minMSE_treatment_+3A_percentage_equal_treatments">percentage_equal_treatments</code></td>
<td>
<p>the percentage of non-unique treatment vectors that we allow. The default value is percentage_equal_treatments = 1. Note that this will affect your significance level: If desired_test_vectors = 100 and percentage_equal_treatments = 1, you can achieve a significance level of at most p &lt; 0.01%.</p>
</td></tr>
<tr><td><code id="assign_minMSE_treatment_+3A_plot">plot</code></td>
<td>
<p>can be used to draw a plot showing the value of the objective function for the a percentage of the iterations by setting plot = 1. The default setting is plot = 0, which suppresses the plot.</p>
</td></tr>
<tr><td><code id="assign_minMSE_treatment_+3A_trace_output">trace_output</code></td>
<td>
<p>trace_output = 1 prints helpful output such as the current iteration. To avoid the program output to be too cumbersome, a more detailed output is saved in a txt file called program_output.txt.</p>
</td></tr>
<tr><td><code id="assign_minMSE_treatment_+3A_filename">filename</code></td>
<td>
<p>takes a string that represents the name of the csv file where the possible treatment assignments will be stored. If filename = NULL, then the file will not be saved.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The program returns a dataframe containing all the unique treatments generated by the program. It also outputs the maximum number of iterations that were reached before finding a non-unique vector.
</p>


<h3>Note</h3>

<p>With the default setting of plotting and using the trace output, the program writes to different files. To avoid this, set plot = 0 and trace_output = 0. For the built-in function <a href="stats.html#topic+optim">optim</a>, the trace output is necessary for printing, because we pipe the output of the program to file to obtain the intermediate values of the optimization function.
</p>


<h3>Author(s)</h3>

<p>Sebastian Schneider <a href="mailto:sschneider@coll.mpg.de">sschneider@coll.mpg.de</a>; <a href="mailto:sebastian@sebastianschneider.eu">sebastian@sebastianschneider.eu</a>,
Giulia Baldini <a href="mailto:giulia.baldini@uni-bonn.de">giulia.baldini@uni-bonn.de</a>
</p>


<h3>References</h3>

<p><a href="https://www.econstor.eu/handle/10419/161931">Schneider and Schlather (2017)</a>,
<a href="https://www.jstor.org/stable/3214721">Belisle (1992)</a>
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+ginv">ginv</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="#topic+assign_treatment">assign_treatment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input &lt;- data.frame(c(10, 20, 30, 40, 130, 40, 120, 5, 10, 80),
                    c(2, 6, 2, 8, 1, 10, 9, 8, 7, 5),
                    c(1, 0, 2, 1, 0, 1, 0, 2, 1, 0))
colnames(input) &lt;- c("IQ", "grade_maths", "both_parents")

assign_minMSE_treatment(input,
                        prev_treatment = c(0, NA, NA, NA, 1, NA, NA, NA, NA, NA),
                        n_treatments = 2,
                        mse_weights = c(1, 2),
                        iterations = 100,
                        trace_output = 1,
                        built_in = 0,
                        desired_test_vectors = 100,
                        plot = 0,
                        filename = NULL)
</code></pre>

<hr>
<h2 id='assign_treatment'>
Min MSE Treatment Assignment
</h2><span id='topic+assign_treatment'></span>

<h3>Description</h3>

<p>Computes the treatment assignment vector according to available data (observable characteristics, covariate vectors) given about the units (individuals or clusters, such as schools, hospitals, ...).
Consider using the user-friendly wrapper function <a href="#topic+assign_minMSE_treatment">assign_minMSE_treatment</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_treatment(current_data,
                 prev_treatment = NULL,
                 evaluation_function = evaluate_solution,
                 swap_treatment_function = swap_treatment,
                 n_treatments = 1,
                 n_per_group = NULL,
                 mse_weights = NULL,
                 iterations = 50,
                 change = 3,
                 cooling = 1,
                 t0 = 10,
                 tmax = 10,
                 built_in = 0,
                 plot = 0,
                 create_plot_file = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assign_treatment_+3A_current_data">current_data</code></td>
<td>
<p>a matrix containing the covariate vectors for each attribute. If the values are missing or on different scales, please use <a href="#topic+assign_minMSE_treatment">assign_minMSE_treatment</a>, which automatically scales the data.</p>
</td></tr>
<tr><td><code id="assign_treatment_+3A_prev_treatment">prev_treatment</code></td>
<td>
<p>takes a numerical vector of partial treatment assignment as argument, and assigns the missing units (where the value is NA) to a treatment group while minimizing the objective function. Non-missing values are copied to the new vector, i.e., treatment group assignment of these observations is unaffected, but taken into consideration for achieving balanced treatment groups.</p>
</td></tr>
<tr><td><code id="assign_treatment_+3A_evaluation_function">evaluation_function</code></td>
<td>
<p>the function used to evaluate the MSE treatment. Default is <a href="#topic+evaluate_solution">evaluate_solution</a>, which does not take into account outcome or treatment weights. Other options are <a href="#topic+evaluate_solution_vector">evaluate_solution_vector</a> and <a href="#topic+evaluate_solution_matrix">evaluate_solution_matrix</a>.</p>
</td></tr>
<tr><td><code id="assign_treatment_+3A_swap_treatment_function">swap_treatment_function</code></td>
<td>
<p>the function used to create new treatments. Default is <a href="#topic+swap_treatment">swap_treatment</a>. Other options are <a href="#topic+swap_treatment_prev">swap_treatment_prev</a> which, given a previous treatment, creates a new treatment assignment that takes the previous one into account.</p>
</td></tr>
<tr><td><code id="assign_treatment_+3A_n_treatments">n_treatments</code></td>
<td>
<p>specifies the number of treatment groups desired (in addition to the control group); minimum and default value is n_treatments = 1.</p>
</td></tr>
<tr><td><code id="assign_treatment_+3A_n_per_group">n_per_group</code></td>
<td>
<p>specifies a vector containing uneven sizes for the treatment groups. Default value is NULL, which yields even sized groups. The sum of the elements in the vector should be equal to the total number of observations.</p>
</td></tr>
<tr><td><code id="assign_treatment_+3A_mse_weights">mse_weights</code></td>
<td>
<p>a vector containing the mse_weights for each treatment, or a matrix containing the mse_weights for treatments and outcomes and scaling factors.</p>
</td></tr>
<tr><td><code id="assign_treatment_+3A_iterations">iterations</code></td>
<td>
<p>specifies the number of iterations the algorithm performs; the default value is iterations = 50. Depending on the number of units and the number of covariates to consider for group assignment, a high value could result in a long run-time.</p>
</td></tr>
<tr><td><code id="assign_treatment_+3A_change">change</code></td>
<td>
<p>sets the number of units to exchange treatment in each iteration; the default value is change = 3. In case of big datasets (e.g., with more than 100 units), one might consider increasing the default value.</p>
</td></tr>
<tr><td><code id="assign_treatment_+3A_cooling">cooling</code></td>
<td>
<p>specifies the cooling scheme for the simulated annealing algorithm to use. cooling = 1, which is the default scheme, sets the temperature to
</p>
<p style="text-align: center;"><code class="reqn">t0/log(floor((k - 1)/tmax ) * tmax + exp(1)),</code>
</p>
<p> whereas cooling = 2 sets the temperature to the faster decreasing sequence </p>
<p style="text-align: center;"><code class="reqn">t0 /(floor((k - 1)/tmax) * tmax + 1).</code>
</p>
<p> In praxis, cooling schemes are mostly of one of these forms. One might want to change the cooling scheme if the plot indicates a too slow decrease of objective values. For a theoretical discussion of cooling schemes, see Belisle (see 1992, p. 890).</p>
</td></tr>
<tr><td><code id="assign_treatment_+3A_t0">t0</code></td>
<td>
<p>sets the starting temperature for the simulated annealing algorithm, see Belisle (1992) for theoretical convergence considerations. In praxis, a lower starting temperature t0 decreases the acceptance rate of a worse solution more rapidly. Specifying a negative number allows values proportional to the objective function, i.e. t0 = -5 sets the starting temperature to 1/5 of the objective function for the starting point, and thus - for the first tmax iterations of the algorithm - the difference of the old and the proposed solution is scaled by 1/5. When changing the default value, it should be considered that also worse solutions have to be accepted in order for the algorithm to escape a local minimum, so it should be chosen high enough. The default value is t0 = 10.</p>
</td></tr>
<tr><td><code id="assign_treatment_+3A_tmax">tmax</code></td>
<td>
<p>specifies the number of function evaluations at each temperature: For instance, tmax = 10 makes the algorithm evaluate 10 treatment assignments that are found based on the current solution, before the temperature is decreased and thus the probability of accepting a worse solution is decreased. The default value is tmax = 10.</p>
</td></tr>
<tr><td><code id="assign_treatment_+3A_built_in">built_in</code></td>
<td>
<p>if built_in = 1 the R built-in function <a href="stats.html#topic+optim">optim</a> with method 'SANN' (Simulated ANNealing) will be used to optimize the function. Otherwise, if built_in = 0, our implementation of the simulated annealing will be used. The function built_in = 0 uses our first cooling function and this cannot be changed. To use the second cooling function, set built_in = 0. All the other parameters, such as iterations, change, t0, tmax are taken into account.</p>
</td></tr>
<tr><td><code id="assign_treatment_+3A_plot">plot</code></td>
<td>
<p>can be used to draw a plot showing the value of the objective function for the a percentage of the iterations by setting plot = 1. The default setting is plot = 0, which suppresses the plot.</p>
</td></tr>
<tr><td><code id="assign_treatment_+3A_create_plot_file">create_plot_file</code></td>
<td>
<p>Used to overwrite the plot file, in case there already exists one. It should only be 1 (true) when this method is called without the wrapper <a href="#topic+assign_minMSE_treatment">assign_minMSE_treatment</a>. This method alone is not capable of plotting, but it will create an auxiliary file that contains the information for plotting. To include plotting, use <a href="#topic+assign_minMSE_treatment">assign_minMSE_treatment</a> with desired_test_vectors = 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the current assignment and the mean squared error value for that assignment.
</p>


<h3>Note</h3>

<p>With the default setting of plotting and using the trace output, the program writes to different files. To avoid this, set plot = 0 and trace_output = 0. For the built-in function <a href="stats.html#topic+optim">optim</a>, the trace output is necessary for printing, because we pipe the output of the program to a file to obtain the intermediate values of the optimization function.
</p>


<h3>Author(s)</h3>

<p>Sebastian Schneider <a href="mailto:sschneider@coll.mpg.de">sschneider@coll.mpg.de</a>; <a href="mailto:sebastian@sebastianschneider.eu">sebastian@sebastianschneider.eu</a>,
Giulia Baldini <a href="mailto:giulia.baldini@uni-bonn.de">giulia.baldini@uni-bonn.de</a>
</p>


<h3>References</h3>

<p><a href="https://www.econstor.eu/handle/10419/161931">Schneider and Schlather (2017)</a>,
<a href="https://www.jstor.org/stable/3214721">Belisle (1992)</a>
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+ginv">ginv</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input &lt;- matrix(1:30, nrow = 10, ncol = 3)

assign_treatment(input,
                 evaluation_function = evaluate_solution_vector,
                 swap_treatment_function = swap_treatment_prev,
                 prev_treatment = c(0, NA, NA, NA, 1, NA, NA, NA, NA, NA),
                 n_treatments = 2,
                 mse_weights = c(1, 2),
                 iterations = 100,
                 built_in = 0,
                 plot = 0)
</code></pre>

<hr>
<h2 id='count_occurrences'>
Count of Equal Treatment Vectors
</h2><span id='topic+count_occurrences'></span>

<h3>Description</h3>

<p>Checks if the treatment vector given as argument already exists in the dataframe, i.e., has been produced by one or more earlier iteration(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_occurrences(df_treatments, curr_treatment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_occurrences_+3A_df_treatments">df_treatments</code></td>
<td>
<p>dataframe containing all the discovered treatment vectors.</p>
</td></tr>
<tr><td><code id="count_occurrences_+3A_curr_treatment">curr_treatment</code></td>
<td>
<p>treatment vector to be investigated. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the number of treatment assignment vectors which are equal to the one being investigated.
</p>


<h3>Author(s)</h3>

<p>Sebastian Schneider <a href="mailto:sschneider@coll.mpg.de">sschneider@coll.mpg.de</a>; <a href="mailto:sebastian@sebastianschneider.eu">sebastian@sebastianschneider.eu</a>,
Giulia Baldini <a href="mailto:giulia.baldini@uni-bonn.de">giulia.baldini@uni-bonn.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df_treatments &lt;- data.frame(c(0, 2, 0, 1, 1, 0, 2, 1, 1, 0),
                            c(0, 2, 0, 1, 2, 0, 1, 2, 1, 0),
                            c(0, 2, 1, 1, 2, 0, 0, 2, 0, 0))
colnames(df_treatments) &lt;- c("treatment_iter_1", "treatment_iter_2", "treatment_iter_3")

count_occurrences(df_treatments,
                  c(0, 2, 1, 1, 2, 0, 0, 2, 0, 0))
</code></pre>

<hr>
<h2 id='evaluate_solution'>
Evaluate MSE Equation
</h2><span id='topic+evaluate_solution'></span>

<h3>Description</h3>

<p>The function computes the mean squared error for a given treatment assignment.
More precisely: it computes the mean squared error of the treatment effect estimator resulting from the treatment groups as specified by the argument, the treatment assignment vector.
The function uses matrix multiplication and the Moore-Penrose generalized inverse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_solution(treatment, data, mse_weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_solution_+3A_treatment">treatment</code></td>
<td>
<p>a treatment assignment. The treatment and the data must have the same number of observations (rows).</p>
</td></tr>
<tr><td><code id="evaluate_solution_+3A_data">data</code></td>
<td>
<p>a matrix containing the covariate vectors for each attribute.</p>
</td></tr>
<tr><td><code id="evaluate_solution_+3A_mse_weights">mse_weights</code></td>
<td>
<p>not used, needed for compatibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the mean squared error value for the current treatment assignment.
</p>


<h3>Author(s)</h3>

<p>Sebastian Schneider <a href="mailto:sschneider@coll.mpg.de">sschneider@coll.mpg.de</a>; <a href="mailto:sebastian@sebastianschneider.eu">sebastian@sebastianschneider.eu</a>,
Giulia Baldini <a href="mailto:giulia.baldini@uni-bonn.de">giulia.baldini@uni-bonn.de</a>
</p>


<h3>References</h3>

<p><a href="https://www.econstor.eu/handle/10419/161931">Schneider and Schlather (2017)</a>,
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+ginv">ginv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input &lt;- matrix(1:30, nrow = 10, ncol = 3)

evaluate_solution(treatment = c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0),
                  input)
</code></pre>

<hr>
<h2 id='evaluate_solution_matrix'>
Evaluate MSE Equation
</h2><span id='topic+evaluate_solution_matrix'></span>

<h3>Description</h3>

<p>The function computes the mean squared error for a given treatment assignment.
More precisely: it computes the mean squared error of the treatment effect estimator resulting from the treatment groups as specified by the argument, the treatment assignment vector.
The function uses matrix multiplication and the Moore-Penrose generalized inverse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_solution_matrix(treatment, data, mse_weights)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_solution_matrix_+3A_treatment">treatment</code></td>
<td>
<p>a treatment assignment. The treatment and the data must have the same number of observations (rows).</p>
</td></tr>
<tr><td><code id="evaluate_solution_matrix_+3A_data">data</code></td>
<td>
<p>a matrix containing the covariate vectors for each attribute.</p>
</td></tr>
<tr><td><code id="evaluate_solution_matrix_+3A_mse_weights">mse_weights</code></td>
<td>
<p>a matrix containing the mse_weights for treatments and outcomes and scaling factors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the mean squared error value for the current treatment assignment.
</p>


<h3>Author(s)</h3>

<p>Sebastian Schneider <a href="mailto:sschneider@coll.mpg.de">sschneider@coll.mpg.de</a>; <a href="mailto:sebastian@sebastianschneider.eu">sebastian@sebastianschneider.eu</a>,
Giulia Baldini <a href="mailto:giulia.baldini@uni-bonn.de">giulia.baldini@uni-bonn.de</a>
</p>


<h3>References</h3>

<p><a href="https://www.econstor.eu/handle/10419/161931">Schneider and Schlather (2017)</a>,
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+ginv">ginv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input &lt;- matrix(1:30, nrow = 10, ncol = 3)

evaluate_solution_matrix(treatment = c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0),
                         input,
                         mse_weights = matrix(1:20, nrow = 10, ncol = 2))
</code></pre>

<hr>
<h2 id='evaluate_solution_vector'>
Evaluate MSE Equation
</h2><span id='topic+evaluate_solution_vector'></span>

<h3>Description</h3>

<p>The function computes the mean squared error for a given treatment assignment.
More precisely: it computes the mean squared error of the treatment effect estimator resulting from the treatment groups as specified by the argument, the treatment assignment vector.
The function uses matrix multiplication and the Moore-Penrose generalized inverse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_solution_vector(treatment, data, mse_weights)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_solution_vector_+3A_treatment">treatment</code></td>
<td>
<p>a treatment assignment. The treatment and the data must have the same number of observations (rows).</p>
</td></tr>
<tr><td><code id="evaluate_solution_vector_+3A_data">data</code></td>
<td>
<p>a matrix containing the covariate vectors for each attribute.</p>
</td></tr>
<tr><td><code id="evaluate_solution_vector_+3A_mse_weights">mse_weights</code></td>
<td>
<p>a vector containing the mse_weights for each treatment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the mean squared error value for the current treatment assignment.
</p>


<h3>Author(s)</h3>

<p>Sebastian Schneider <a href="mailto:sschneider@coll.mpg.de">sschneider@coll.mpg.de</a>; <a href="mailto:sebastian@sebastianschneider.eu">sebastian@sebastianschneider.eu</a>,
Giulia Baldini <a href="mailto:giulia.baldini@uni-bonn.de">giulia.baldini@uni-bonn.de</a>
</p>


<h3>References</h3>

<p><a href="https://www.econstor.eu/handle/10419/161931">Schneider and Schlather (2017)</a>,
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+ginv">ginv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input &lt;- matrix(1:30, nrow = 10, ncol = 3)

evaluate_solution_vector(treatment = c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0),
                         input,
                         mse_weights = c(1, 2))
</code></pre>

<hr>
<h2 id='evaluate_solution.optim'>
Evaluate MSE Equation (using <a href="stats.html#topic+optim">optim</a>)
</h2><span id='topic+evaluate_solution.optim'></span>

<h3>Description</h3>

<p>This function calls <a href="#topic+evaluate_solution">evaluate_solution</a>, but since <a href="stats.html#topic+optim">optim</a> requires fn and gr to have the same parameters, it has two additional ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_solution.optim(par,
                        data,
                        evaluation_function = evaluate_solution,
                        swap_treatment_function = NULL,
                        mse_weights = NULL,
                        change = NULL,
                        prev_index_list = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_solution.optim_+3A_par">par</code></td>
<td>
<p>a treatment assignment. The treatment and the data must have the same number of observations (rows).</p>
</td></tr>
<tr><td><code id="evaluate_solution.optim_+3A_data">data</code></td>
<td>
<p>a matrix containing the covariate vectors for each attribute.</p>
</td></tr>
<tr><td><code id="evaluate_solution.optim_+3A_evaluation_function">evaluation_function</code></td>
<td>
<p>the function used to evaluate the MSE treatment. Default is <a href="#topic+evaluate_solution">evaluate_solution</a>, which does not take into account outcome or treatment weights. Other options are <a href="#topic+evaluate_solution_vector">evaluate_solution_vector</a> and <a href="#topic+evaluate_solution_matrix">evaluate_solution_matrix</a>.</p>
</td></tr>
<tr><td><code id="evaluate_solution.optim_+3A_swap_treatment_function">swap_treatment_function</code></td>
<td>
<p>the parameter is only needed for optim, it does not play any role.</p>
</td></tr>
<tr><td><code id="evaluate_solution.optim_+3A_mse_weights">mse_weights</code></td>
<td>
<p>a vector containing the mse_weights for each treatment, or a matrix containing the mse_weights for treatments and outcomes and scaling factors.</p>
</td></tr>
<tr><td><code id="evaluate_solution.optim_+3A_change">change</code></td>
<td>
<p>the parameter is only needed for optim, it does not play any role.</p>
</td></tr>
<tr><td><code id="evaluate_solution.optim_+3A_prev_index_list">prev_index_list</code></td>
<td>
<p>the parameter is only needed for optim, it does not play any role.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the mean square error value for the current treatment assignment.
</p>


<h3>Author(s)</h3>

<p>Sebastian Schneider <a href="mailto:sschneider@coll.mpg.de">sschneider@coll.mpg.de</a>; <a href="mailto:sebastian@sebastianschneider.eu">sebastian@sebastianschneider.eu</a>,
Giulia Baldini <a href="mailto:giulia.baldini@uni-bonn.de">giulia.baldini@uni-bonn.de</a>
</p>


<h3>References</h3>

<p><a href="https://www.econstor.eu/handle/10419/161931">Schneider and Schlather (2017)</a>,
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+ginv">ginv</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input &lt;- matrix(1:30, nrow = 10, ncol = 3)

evaluate_solution.optim(par = c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0),
                        input)
</code></pre>

<hr>
<h2 id='output_file'>TXT File That Contains Additional Output Information</h2><span id='topic+output_file'></span>

<h3>Description</h3>

<p>File .txt that contains additional output information.</p>

<hr>
<h2 id='plotting_file'>CSV File for Saving the Data to Plot</h2><span id='topic+plotting_file'></span>

<h3>Description</h3>

<p>CSV file for saving the data to plot.</p>

<hr>
<h2 id='sample_with_prev_treatment'>
Sample Under Consideration of an Already Treated Subset of Units
</h2><span id='topic+sample_with_prev_treatment'></span>

<h3>Description</h3>

<p>Given a previous treatment assignment vector for a subset of all observations that treatment assigment is desired for, the function computes a treatment assignment vector for which the previously assigned units are not changed.
At a later step, the previously assigned units are also taken into consideration for computation of the score value, the min MSE function, to achieve balanced treatment groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_with_prev_treatment(prev_treatment, n_treatments, n_per_group)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_with_prev_treatment_+3A_prev_treatment">prev_treatment</code></td>
<td>
<p>takes a numerical vector of partial treatment assignment as argument, and &ndash; for a start &ndash; assigns the missing units (where the value is NA) to a random treatment group, while maintaining the same proportions in the groups.</p>
</td></tr>
<tr><td><code id="sample_with_prev_treatment_+3A_n_treatments">n_treatments</code></td>
<td>
<p>specifies the number of treatment groups desired (in addition to the control group). They might be more than the ones already defined in prev_treatment.</p>
</td></tr>
<tr><td><code id="sample_with_prev_treatment_+3A_n_per_group">n_per_group</code></td>
<td>
<p>specifies the distribution of participants per experimental group. It is either an integer, which produces even-sized groups, or a vector which has the same length as the number of experimental groups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a treatment assignment vector where the observations given by prev_treatment are unmodified, and the others are assigned to a group.
</p>


<h3>Author(s)</h3>

<p>Sebastian Schneider <a href="mailto:sschneider@coll.mpg.de">sschneider@coll.mpg.de</a>; <a href="mailto:sebastian@sebastianschneider.eu">sebastian@sebastianschneider.eu</a>,
Giulia Baldini <a href="mailto:giulia.baldini@uni-bonn.de">giulia.baldini@uni-bonn.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sample_with_prev_treatment(prev_treatment = c(0, NA, NA, NA, 1, NA, NA, NA, NA, NA),
                           n_treatments = 2,
                           n_per_group = c(2, 4, 4))
</code></pre>

<hr>
<h2 id='scale_vars'>
Covariate Vectors Scaling
</h2><span id='topic+scale_vars'></span>

<h3>Description</h3>

<p>Scales the data such that the empty fiels (NA) are the mean of the column and all variables are scaled to have variance 1.
In case a variable has cero variance, the variable internally is treated as if it was 0, that way it is not taken into account for treatment assignment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_vars(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_vars_+3A_data">data</code></td>
<td>
<p>a dataframe containing the covariate vectors for each attribute.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe where the empty fields are filled with the mean of the column, and for all variables the variance is 1.
</p>


<h3>Author(s)</h3>

<p>Sebastian Schneider <a href="mailto:sschneider@coll.mpg.de">sschneider@coll.mpg.de</a>; <a href="mailto:sebastian@sebastianschneider.eu">sebastian@sebastianschneider.eu</a>,
Giulia Baldini <a href="mailto:giulia.baldini@uni-bonn.de">giulia.baldini@uni-bonn.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input &lt;- data.frame(c(10, 20, 30, 40, 130, 40, 120, 5, 10, 80),
                    c(2, 6, 2, 8, 1, 10, 9, 8, 7, 5),
                    c(1, 0, 2, 1, 0, 1, 0, 2, 1, 0))
colnames(input) &lt;- c("IQ", "grade_maths", "both_parents")

scale_vars(input)
</code></pre>

<hr>
<h2 id='swap_treatment'>
Swap Treatment
</h2><span id='topic+swap_treatment'></span>

<h3>Description</h3>

<p>Scrambles the elements of the vector and swaps a predefined number of elements. Afterwards, the vector is ordered according to the original ordering and returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swap_treatment(current_treatment,
               change,
               prev_index_list = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swap_treatment_+3A_current_treatment">current_treatment</code></td>
<td>
<p>a treatment vector to be changed.</p>
</td></tr>
<tr><td><code id="swap_treatment_+3A_change">change</code></td>
<td>
<p>number of elements that will be changed in the treatment vector.</p>
</td></tr>
<tr><td><code id="swap_treatment_+3A_prev_index_list">prev_index_list</code></td>
<td>
<p>not used, needed for compatibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a new treatment vector.
</p>


<h3>Author(s)</h3>

<p>Sebastian Schneider <a href="mailto:sschneider@coll.mpg.de">sschneider@coll.mpg.de</a>; <a href="mailto:sebastian@sebastianschneider.eu">sebastian@sebastianschneider.eu</a>,
Giulia Baldini <a href="mailto:giulia.baldini@uni-bonn.de">giulia.baldini@uni-bonn.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>swap_treatment(current_treatment = c(0, 2, 0, 1, 1, 0, 2, 1, 1, 0),
               change = 2)
</code></pre>

<hr>
<h2 id='swap_treatment_prev'>
Swap Treatment
</h2><span id='topic+swap_treatment_prev'></span>

<h3>Description</h3>

<p>Scrambles the elements of the vector and swaps a predefined number of elements. Afterwards, the vector is ordered according to the original ordering and returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swap_treatment_prev(current_treatment,
                    change,
                    prev_index_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swap_treatment_prev_+3A_current_treatment">current_treatment</code></td>
<td>
<p>a treatment vector to be changed.</p>
</td></tr>
<tr><td><code id="swap_treatment_prev_+3A_change">change</code></td>
<td>
<p>number of elements that will be changed in the treatment vector.</p>
</td></tr>
<tr><td><code id="swap_treatment_prev_+3A_prev_index_list">prev_index_list</code></td>
<td>
<p>index list of the elements that can be changed. The current treatment vector may belong to a previous, unchangeable assignment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a new treatment vector.
</p>


<h3>Author(s)</h3>

<p>Sebastian Schneider <a href="mailto:sschneider@coll.mpg.de">sschneider@coll.mpg.de</a>; <a href="mailto:sebastian@sebastianschneider.eu">sebastian@sebastianschneider.eu</a>,
Giulia Baldini <a href="mailto:giulia.baldini@uni-bonn.de">giulia.baldini@uni-bonn.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>swap_treatment_prev(current_treatment = c(0, 2, 0, 1, 1, 0, 2, 1, 1, 0),
                    change = 2,
                    prev_index_list = c(1, 2, 3, 4))
</code></pre>

<hr>
<h2 id='swap_treatment.optim'>
Swap Treatment (using <a href="stats.html#topic+optim">optim</a>)
</h2><span id='topic+swap_treatment.optim'></span>

<h3>Description</h3>

<p>This function calls <a href="#topic+swap_treatment">swap_treatment</a>, but since <a href="stats.html#topic+optim">optim</a> requires fn and gr to have the same parameters, it has an additional one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swap_treatment.optim(current_treatment,
                     data = NULL,
                     evaluation_function = NULL,
                     swap_treatment_function = swap_treatment,
                     mse_weights = NULL,
                     change,
                     prev_index_list = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swap_treatment.optim_+3A_current_treatment">current_treatment</code></td>
<td>
<p>a treatment vector to be changed.</p>
</td></tr>
<tr><td><code id="swap_treatment.optim_+3A_data">data</code></td>
<td>
<p>the parameter is only needed for optim, it does not play any role.</p>
</td></tr>
<tr><td><code id="swap_treatment.optim_+3A_evaluation_function">evaluation_function</code></td>
<td>
<p>the parameter is only needed for optim, it does not play any role.</p>
</td></tr>
<tr><td><code id="swap_treatment.optim_+3A_swap_treatment_function">swap_treatment_function</code></td>
<td>
<p>the function used to create new treatments. Default is <a href="#topic+swap_treatment">swap_treatment</a>. Other options are <a href="#topic+swap_treatment_prev">swap_treatment_prev</a> which, given a previous treatment, creates a new treatment assignment that takes the previous one into account.</p>
</td></tr>
<tr><td><code id="swap_treatment.optim_+3A_change">change</code></td>
<td>
<p>number of elements that will be changed in the treatment vector.</p>
</td></tr>
<tr><td><code id="swap_treatment.optim_+3A_prev_index_list">prev_index_list</code></td>
<td>
<p>index list of the elements that can be changed. The current treatment vector may belong to a previous, unchangeable assignment.</p>
</td></tr>
<tr><td><code id="swap_treatment.optim_+3A_mse_weights">mse_weights</code></td>
<td>
<p>the parameter is only needed for optim, it does not play any role.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a new treatment vector.
</p>


<h3>Author(s)</h3>

<p>Sebastian Schneider <a href="mailto:sschneider@coll.mpg.de">sschneider@coll.mpg.de</a>; <a href="mailto:sebastian@sebastianschneider.eu">sebastian@sebastianschneider.eu</a>,
Giulia Baldini <a href="mailto:giulia.baldini@uni-bonn.de">giulia.baldini@uni-bonn.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+optim">optim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>swap_treatment.optim(current_treatment = c(0, 2, 0, 1, 1, 0, 2, 1, 1, 0),
                     change = 2)

swap_treatment.optim(current_treatment = c(0, 2, 0, 1, 1, 0, 2, 1, 1, 0),
                     change = 2,
                     prev_index_list = c(1, 2, 3, 4))
</code></pre>

<hr>
<h2 id='vector_gcd'>
Vector Greatest Common Divisor
</h2><span id='topic+vector_gcd'></span>

<h3>Description</h3>

<p>Computes the GCD of a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vector_gcd(vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vector_gcd_+3A_vec">vec</code></td>
<td>
<p>a vector, for which we want to compute the GCD.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The GCD of the elements in the given vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input = c(3,6,9)
vector_gcd(input)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
