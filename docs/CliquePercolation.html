<!DOCTYPE html><html lang="en"><head><title>Help for package CliquePercolation</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CliquePercolation}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CliquePercolation-package'><p>CliquePercolation: Clique Percolation for Networks</p></a></li>
<li><a href='#cpAlgorithm'><p>Clique Percolation Community Detection</p></a></li>
<li><a href='#cpColoredGraph'><p>Colored Network According To Clique Percolation Communities</p></a></li>
<li><a href='#cpCommunityGraph'><p>Plotting Clique Percolation Community Network</p></a></li>
<li><a href='#cpCommunitySizeDistribution'><p>Plotting Clique Percolation Community Size Distribution</p></a></li>
<li><a href='#cpPermuteEntropy'><p>Confidence Intervals Of Entropy Based On Random Permutations Of Network</p></a></li>
<li><a href='#cpThreshold'><p>Optimizing <code>k</code> And <code>I</code> For Clique Percolation Community Detection</p></a></li>
<li><a href='#FuzzyMod'><p>Fuzzy Modularity of a community structure of a graph</p></a></li>
<li><a href='#immuno'><p>Data: Immunoglobulin interaction network</p></a></li>
<li><a href='#Obama'><p>Data: Evaluative Reactions Toward Barack Obama (2012)</p></a></li>
<li><a href='#print.cpAlgorithm'><p>print.cpAlgorithm</p></a></li>
<li><a href='#print.cpPermuteEntropy'><p>print.cpPermuteEntropy</p></a></li>
<li><a href='#SignedFuzzyMod'><p>Signed Fuzzy Modularity of a community structure of a graph</p></a></li>
<li><a href='#summary.cpAlgorithm'><p>summary.cpAlgorithm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-08</td>
</tr>
<tr>
<td>Title:</td>
<td>Clique Percolation for Networks</td>
</tr>
<tr>
<td>Description:</td>
<td>Clique percolation community detection for weighted and
    unweighted networks as well as threshold and plotting functions.
    For more information see Farkas et al. (2007) &lt;<a href="https://doi.org/10.1088%2F1367-2630%2F9%2F6%2F180">doi:10.1088/1367-2630/9/6/180</a>&gt;
    and Palla et al. (2005) &lt;<a href="https://doi.org/10.1038%2Fnature03607">doi:10.1038/nature03607</a>&gt;.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jens Lange &lt;lange.jens@outlook.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>colorspace, graphics, igraph, magrittr, Matrix, methods,
Polychrome, qgraph, stats, utils, parallel, lessR, ohenery,
pbapply</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-09 07:25:05 UTC; lange</td>
</tr>
<tr>
<td>Author:</td>
<td>Jens Lange [aut, cre],
  Janis Zickfeld [ctb],
  Alexander P. Christensen [ctb],
  Pedro Henrique Ribeiro Santiago [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-09 08:40:37 UTC</td>
</tr>
</table>
<hr>
<h2 id='CliquePercolation-package'>CliquePercolation: Clique Percolation for Networks</h2><span id='topic+CliquePercolation'></span><span id='topic+CliquePercolation-package'></span>

<h3>Description</h3>

<p>Clique percolation community detection for weighted and unweighted networks as well as threshold and plotting functions. For more information see Farkas et al. (2007) <a href="https://doi.org/10.1088/1367-2630/9/6/180">doi:10.1088/1367-2630/9/6/180</a> and Palla et al. (2005) <a href="https://doi.org/10.1038/nature03607">doi:10.1038/nature03607</a>.
</p>


<h3>Details</h3>

<p>CliquePercolation includes a number of functions for detecting and interpreting
overlapping network communities. It is based on research by Palla et al. (2005)
and Farkas et al. (2007).
</p>

<dl>
<dt>cpAlgorithm()</dt><dd><p>conducts clique percolation for unweighted and weighted 
networks; see <a href="#topic+cpAlgorithm">cpAlgorithm</a></p>
</dd>
<dt>cpColoredGraph()</dt><dd><p>plots the original network with nodes colored according
to community partition, taking sets of nodes into account; see
<a href="#topic+cpColoredGraph">cpColoredGraph</a></p>
</dd>
<dt>cpCommunityGraph()</dt><dd><p>plots the network of communities; see <a href="#topic+cpCommunityGraph">cpCommunityGraph</a></p>
</dd> 
<dt>cpCommunitySizeDistribution()</dt><dd><p>plots the frequency distribution of the
sizes of the communities; see <a href="#topic+cpCommunitySizeDistribution">cpCommunitySizeDistribution</a></p>
</dd>
<dt>cpThreshold()</dt><dd><p>optimizing <code>k</code> and <code>I</code> via threshold-based selection;
see <a href="#topic+cpThreshold">cpThreshold</a></p>
</dd>
<dt>cpPermuteEntropy()</dt><dd><p>determines confidence intervals for the entropy threshold
based on random permutations of the network; see <a href="#topic+cpPermuteEntropy">cpPermuteEntropy</a></p>
</dd>
<dt>FuzzyMod()</dt><dd><p>calculates the fuzzy modularity of a (disjoint or non-disjoint
division) of a graph into subgraphs; see <a href="#topic+FuzzyMod">FuzzyMod</a></p>
</dd>
<dt>SignedFuzzyMod()</dt><dd><p>calculates the fuzzy modularity of a (disjoint or non-disjoint
division) of a graph into subgraphs for signed weighted networks;
see <a href="#topic+SignedFuzzyMod">SignedFuzzyMod</a></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Jens Lange, <a href="mailto:lange.jens@outlook.com">lange.jens@outlook.com</a>
</p>


<h3>References</h3>

<p>Farkas, I., Abel, D., Palla, G., &amp; Vicsek, T. (2007). Weighted network modules.
<em>New Journal of Physics, 9</em>, 180-180. http://doi.org/10.1088/1367-2630/9/6/180
</p>
<p>Palla, G., Derenyi, I., Farkas, I., &amp; Vicsek, T. (2005). Uncovering the overlapping community 
structure of complex networks in nature and society. <em>Nature, 435</em>, 
814-818. http://doi.org/10.1038/nature03607
</p>

<hr>
<h2 id='cpAlgorithm'>Clique Percolation Community Detection</h2><span id='topic+cpAlgorithm'></span>

<h3>Description</h3>

<p>Function for clique percolation community detection algorithms for weighted
and unweighted networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpAlgorithm(W, k, method = c("unweighted", "weighted", "weighted.CFinder"), I)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpAlgorithm_+3A_w">W</code></td>
<td>
<p>A qgraph object or a symmetric matrix; see also <a href="qgraph.html#topic+qgraph">qgraph</a></p>
</td></tr>
<tr><td><code id="cpAlgorithm_+3A_k">k</code></td>
<td>
<p>Clique size (number of nodes that should form a clique)</p>
</td></tr>
<tr><td><code id="cpAlgorithm_+3A_method">method</code></td>
<td>
<p>A string indicating the method to use 
(<code>"unweighted"</code>, <code>"weighted"</code>, or <code>"weighted.CFinder"</code>); see Details</p>
</td></tr>
<tr><td><code id="cpAlgorithm_+3A_i">I</code></td>
<td>
<p>Intensity threshold for weighted networks</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>method = "unweighted"</code> conducts clique percolation for unweighted networks as
described in Palla et al. (2005). <code>method = "weighted"</code> conducts clique percolation
for weighted graphs with inclusion of cliques if their Intensity is higher than the
specified Intensity (<code>I</code>), which is the method described in Farkas et al. (2007).
<code>method = "weighted.CFinder"</code> conducts clique percolation as in the CFinder program.
The Intensity (<code>I</code>) threshold is applied twice, namely first to the Intensity of the
cliques (as before) and then also to their <code>k-1</code> overlap with other cliques
(e.g., in the case of <code>k = 3</code>, it is applied to the edge that two cliques share).
</p>
<p>For weighted networks, the absolute value of the edge weights is taken.
Therefore, negative edges are treated like positive edges just like in the CFinder program.
Thus, the Intensity threshold <code>I</code> can only be positive.
</p>
<p>cpAlgorithm produces a solution for all networks, even if there are no communities 
or communities have no overlap. The respective output is empty in such cases.
</p>


<h3>Value</h3>

<p>A list object with the following elements:
</p>

<dl>
<dt>list.of.communities.numbers</dt><dd><p>list of communities with numbers as identifiers 
of nodes</p>
</dd>
<dt>list.of.communities.labels</dt><dd><p>list of communities with labels from qgraph object 
or row or column names of matrix as identifiers of nodes</p>
</dd>
<dt>shared.nodes.numbers</dt><dd><p>vector with all nodes that belong to multiple communities 
with numbers as identifiers of nodes</p>
</dd>
<dt>shared.nodes.labels</dt><dd><p>vector with all nodes that belong to multiple communities 
with labels from qgraph object or row or column names of matrix  as identifiers
of nodes</p>
</dd>
<dt>isolated.nodes.numbers</dt><dd><p>vector with all nodes that belong to no community 
with numbers as identifiers of nodes</p>
</dd>
<dt>isolated.nodes.labels</dt><dd><p>vector with all nodes that belong to no community 
with labels from qgraph object or row or column names of matrix as identifiers
of nodes</p>
</dd>
<dt>k</dt><dd><p>user-specified <code>k</code></p>
</dd>
<dt>method</dt><dd><p>user-specified method</p>
</dd>
<dt>I</dt><dd><p>user-specified <code>I</code> (if method was <code>"weighted"</code> 
or <code>"weighted.CFinder"</code>)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Jens Lange, <a href="mailto:lange.jens@outlook.com">lange.jens@outlook.com</a>
</p>


<h3>References</h3>

<p>Farkas, I., Abel, D., Palla, G., &amp; Vicsek, T. (2007). Weighted network modules.
<em>New Journal of Physics, 9</em>, 180-180. http://doi.org/10.1088/1367-2630/9/6/180
</p>
<p>Palla, G., Derenyi, I., Farkas, I., &amp; Vicsek, T. (2005). Uncovering the overlapping community 
structure of complex networks in nature and society. <em>Nature, 435</em>, 
814-818. http://doi.org/10.1038/nature03607
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example for unweighted networks

# create qgraph object
W &lt;- matrix(c(0,1,1,1,0,0,0,0,
              0,0,1,1,0,0,0,0,
              0,0,0,0,0,0,0,0,
              0,0,0,0,1,1,1,0,
              0,0,0,0,0,1,1,0,
              0,0,0,0,0,0,1,0,
              0,0,0,0,0,0,0,1,
              0,0,0,0,0,0,0,0), nrow = 8, ncol = 8, byrow = TRUE)
W &lt;- Matrix::forceSymmetric(W)
W &lt;- qgraph::qgraph(W)

# run clique percolation for unweighted networks
results &lt;- cpAlgorithm(W = W, k = 3, method = "unweighted")

# print results overview
results

# extract more information about communities
summary(results)

## Example for weighted networks

# create qgraph object
W &lt;- matrix(c(0,1,1,1,0,0,0,0,
              0,0,1,1,0,0,0,0,
              0,0,0,0,0,0,0,0,
              0,0,0,0,1,1,1,0,
              0,0,0,0,0,1,1,0,
              0,0,0,0,0,0,1,0,
              0,0,0,0,0,0,0,1,
              0,0,0,0,0,0,0,0), nrow = 8, ncol = 8, byrow = TRUE)
set.seed(4186)
rand_w &lt;- stats::rnorm(length(which(W == 1)), mean = 0.3, sd = 0.1)
W[which(W == 1)] &lt;- rand_w
W &lt;- Matrix::forceSymmetric(W)
W &lt;- qgraph::qgraph(W)

# run clique percolation for weighted networks
results &lt;- cpAlgorithm(W = W, k = 3, method = "weighted", I = 0.1)

# print results overview
results

# extract more information about communities
summary(results)

## Example with Obama data set (see ?Obama)

# get data
data(Obama)

# estimate network
net &lt;- qgraph::EBICglasso(qgraph::cor_auto(Obama), n = nrow(Obama))

# run clique percolation algorithm with specific k and I
cpk3I.16 &lt;- cpAlgorithm(net, k = 3, I = 0.16, method = "weighted")

# print results overview
cpk3I.16

# extract more information about communities
summary(cpk3I.16)

</code></pre>

<hr>
<h2 id='cpColoredGraph'>Colored Network According To Clique Percolation Communities</h2><span id='topic+cpColoredGraph'></span>

<h3>Description</h3>

<p>Function for plotting the original network with nodes colored according
to the community partition identified via the clique percolation community
detection algorithm, taking predefined sets of nodes into account.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpColoredGraph(
  W,
  list.of.communities,
  list.of.sets = NULL,
  larger.six = FALSE,
  h.cp = c(0, 360 * (length(cplist) - 1)/length(cplist)),
  c.cp = 80,
  l.cp = 60,
  set.palettes.size = NULL,
  own.colors = NULL,
  avoid.repeated.mixed.colors = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpColoredGraph_+3A_w">W</code></td>
<td>
<p>A qgraph object or a symmetric matrix; see also <a href="qgraph.html#topic+qgraph">qgraph</a></p>
</td></tr>
<tr><td><code id="cpColoredGraph_+3A_list.of.communities">list.of.communities</code></td>
<td>
<p>List object taken from results of cpAlgorithm
function; see also <a href="#topic+cpAlgorithm">cpAlgorithm</a></p>
</td></tr>
<tr><td><code id="cpColoredGraph_+3A_list.of.sets">list.of.sets</code></td>
<td>
<p>List object specifying predefined groups of nodes
in original network; default is NULL; see Details</p>
</td></tr>
<tr><td><code id="cpColoredGraph_+3A_larger.six">larger.six</code></td>
<td>
<p>Integer indicating whether <code>length(list.of.communities)</code> is
larger six (if <code>list.of.sets = NULL</code>) or <code>length(list.of.sets)</code>
is larger six (if <code>list.of.sets</code> is not NULL); default is FALSE; see Details</p>
</td></tr>
<tr><td><code id="cpColoredGraph_+3A_h.cp">h.cp</code></td>
<td>
<p>Vector of integers indicating the range of hue from which
colors should be drawn for elements in <code>list.of.communities</code> (if
<code>list.of.sets = NULL</code>) or for elements in <code>list.of.sets</code> (if
<code>list.of.sets</code> is not NULL); default is the value specified in
<a href="colorspace.html#topic+hcl_palettes">colorspace::qualitative_hcl()</a>; see Details</p>
</td></tr>
<tr><td><code id="cpColoredGraph_+3A_c.cp">c.cp</code></td>
<td>
<p>Integer indicating the chroma from which
colors should be drawn for elements in <code>list.of.communities</code> (if
<code>list.of.sets = NULL</code>) or for elements in <code>list.of.sets</code> (if
<code>list.of.sets</code> is not NULL); default is 80 as specified in
<a href="colorspace.html#topic+hcl_palettes">colorspace::qualitative_hcl()</a>; see Details</p>
</td></tr>
<tr><td><code id="cpColoredGraph_+3A_l.cp">l.cp</code></td>
<td>
<p>Integer indicating the luminance from which
colors should be drawn for elements in <code>list.of.communities</code> (if
<code>list.of.sets = NULL</code>) or for elements in <code>list.of.sets</code> (if
<code>list.of.sets</code> is not NULL); default is 60 as specified in
<a href="colorspace.html#topic+hcl_palettes">colorspace::qualitative_hcl()</a>; see Details</p>
</td></tr>
<tr><td><code id="cpColoredGraph_+3A_set.palettes.size">set.palettes.size</code></td>
<td>
<p>Integer indicating the number of sets for which
smooth gradients of a set color should be generated using
<a href="colorspace.html#topic+hcl_palettes">colorspace::sequential_hcl()</a>; default is
the number of pure communities of a set plus one; see Details</p>
</td></tr>
<tr><td><code id="cpColoredGraph_+3A_own.colors">own.colors</code></td>
<td>
<p>Vector of hex code colors of length of <code>list.of.communities</code>
(if <code>list.of.sets = NULL</code>) or <code>list.of.sets</code> (if <code>list.of.sets</code>
is not NULL); if specified, colors are used for coloring the communities and no
other colors are generated; if NULL (default), reasonable colors are generated; see
Details</p>
</td></tr>
<tr><td><code id="cpColoredGraph_+3A_avoid.repeated.mixed.colors">avoid.repeated.mixed.colors</code></td>
<td>
<p>Logical indicating whether it should be avoided
that multiple mixed communities are assigned the same color; default is FALSE;
see Details</p>
</td></tr>
<tr><td><code id="cpColoredGraph_+3A_...">...</code></td>
<td>
<p>any additional argument from qgraph; see also <a href="qgraph.html#topic+qgraph">qgraph</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes the results of cpAlgorithm (see also <a href="#topic+cpAlgorithm">cpAlgorithm</a>),
that is, either the <code>list.of.communities.numbers</code> or the
<code>list.of.communities.labels</code> and plots the original network, coloring
the nodes according to the community partition. If there are no predefined
sets of nodes (<code>list.of.sets = NULL</code>; the default), each community is
assigned a color by using a palette generation algorithm from the package
colorspace, which relies on HCL color space. Specifically, the function
qualitative_hcl (see also
<a href="colorspace.html#topic+hcl_palettes">colorspace::qualitative_hcl()</a> is used,
which generates a balanced set of colors over a range of hue values, holding
chroma and luminance constant. This method is preferred over other palette
generating algorithms in other color spaces (Zeileis et al., subm.). The
default values recommended in qualitative_hcl are used, adapted to the
current context in the case of hue. Yet, h.cp, c.cp, and l.cp can be used
to overwrite the default values. Each node gets the color of the community
it belongs to. Shared nodes are split equally in multiple colors, one for
each community they belong to. Isolated nodes are colored white.
</p>
<p>If there are predefined sets of nodes, the qualitatively different colors
are assigned to the sets specified in <code>list.of.sets</code>. Then, it is
checked whether communities are pure (they contain nodes from only one set)
or they are mixed (they contain nodes from multiple sets). For pure
communities of each set, the assigned color is taken and faded towards white
with another function from colorspace, namely sequential_hcl
(see also <a href="colorspace.html#topic+hcl_palettes">colorspace::sequential_hcl()</a>. For
instance, if there are three pure communities with nodes that are only from
Set 1, then the basic color assigned to Set 1 is taken, and faded toward white
in 3 + 1 steps. There is one color generated more than needed (here four colors
for three communities), because the last color in the fading is always white, which
is reserved for isolated nodes. The three non-white colors are then assigned
to each community, with stronger colors being assigned to larger communities.
In that sense, all communities that entail nodes from only one specific set, will
have rather similar colors (only faded towards white). All communities that
entail nodes from only one specific other set, will also have similar colors,
yet they will differ qualitatively from the colors of the communities that
entail items from other sets. For communities that entail items from multiple
sets, the basic colors assigned to these sets are mixed in proportion to the
number of nodes from each set. For instance, if a community entails two nodes
from Set 1 and one node from Set 2, then the colors of Sets 1 and 2 are mixed
2:1.
</p>
<p>The mixing of colors is subtractive (how paint mixes). Subtractive color
mixing is difficult to implement. An algorithm proposed by Scott Burns is used
(see http://scottburns.us/subtractive-color-mixture/ and 
http://scottburns.us/fast-rgb-to-spectrum-conversion-for-reflectances/). Each
color is transformed into a corresponding reflectance curve via the RGBC
algorithm. That is, optimized reflectance curves of red, green, and blue
are adapted according to the RGB values of the respective color. The reflectance
curves of the colors that need to be mixed are averaged via the weighted
geometric mean. The resulting mixed reflectance curve is transformed back to
RGB values by multiplying the curve with a derived matrix. The algorithm
produces rather good color mixing and is computationally efficient. Yet,
results may not always be absolutely precise.
</p>
<p>The mixing of colors for mixed communities can lead to multiple communities
being assigned the same color. For instance, two communities with two nodes
each from Sets 1 and 2 would have the same color, namely the colors assigned to
the sets mixed in the same proportion. This is reasonable, because these
communities are structurally similar. However, it can be confusing to have
two actually different communities with the same color. To avoid this,
set <code>avoid.repeated.mixed.colors = TRUE</code>. Doing so slightly alters the
ratio with which the color of a mixed community is determined, if the
community would have been assigned a color that was already assigned.
This slight variation of the ratio is random. To reproduce results from a
previous run, set a seed.
</p>
<p>The fading of pure communities via sequential_hcl is a function of
the number of sets. If there are more pure communities from a specific
set, more faded colors will be generated. This makes coloring results hard
to compare across different networks, if such a comparison is desired.
For instance, if one network has 12 nodes that belong to three communities
sized 6, 3, and 3, all of them pure (having nodes from only one set), then
their colors will be strong, average, and almost white respectively. If the
same 12 nodes belong to two communities size 6 and 6, both of them pure, then
their colors will be strong and average to almost white. Different numbers
of pure communities therefore change the color range. To circumvent that,
one can specify <code>set.palettes.size</code> to any number larger than the number
of pure communities of a set plus one. For all sets, sequential_hcl
then generates as many shades towards white of a respective color as specified
in <code>set.palettes.size</code>. Colors for each community are then picked
from the strongest towards whiter colors, with larger communities being
assigned stronger colors. Note that in this situation, the range of colors
is always the same for all sets in a network, making them comparable across
different sets. When there are more pure communities of one set than from another
their luminance will be lower. Moreover, also across networks, the luminance
of different sets of nodes or of the same set can be compared.
</p>
<p>In all cases, qualitatively different colors are assigned to either the elements
in <code>list.of.communities</code> (when <code>list.of.sets = NULL</code>) or the elements
in <code>list.of.sets</code> (when <code>list.of.sets</code> is not NULL) with qualitative_hcl.
Zeileis et al. (subm.) argue that this function can generate up to six
different colors that people can still distinguish. For a larger number of
qualitative colors, other packages can be used. Specifically, if the argument
<code>larger.six = TRUE</code> (default is <code>FALSE</code>), the qualitatively
different colors are generated via the package Polychrome (Coombes et al., 2019)
with the function createPalette (see also <a href="Polychrome.html#topic+createPalette">createPalette</a>).
This function generates maximally different colors in HCL space and can generate a
higher number of distinct colors. With these colors, the rest of the procedure is
identical. The seedcolors specified in Polychrome are general red, green, and
blue. As the procedure relies on randomness, you have to set a seed to reproduce
the results of a previous run.
Note that the Polychrome palettes are maximally distinct, thus they are
most likely not as balanced as the palettes generated with colorspace. In general,
the function cpColoredGraph is recommended only for very small networks
anyways, for which <code>larger.six = FALSE</code> makes sense. For larger networks,
consider plotting the community network instead (see <a href="#topic+cpCommunityGraph">cpCommunityGraph</a>).
</p>
<p>When own.colors are specified, these colors are assigned to the elements in
<code>list.of.communities</code> (if <code>list.of.sets = NULL</code>) or to the elements
in <code>list.of.sets</code> (if <code>list.of.sets</code> is not NULL). The rest of the 
procedure is identical.
</p>


<h3>Value</h3>

<p>The function primarily plots the original network and colors the nodes
according to the communities, taking predefined sets into account. 
Additionally, it returns a list with the following elements:
</p>

<dl>
<dt>basic.colors.sets</dt><dd><p>Vector with colors assigned to the elements in
<code>list.of.sets</code>, if <code>list.of.sets</code> is not NULL. Otherwise NULL is returned.</p>
</dd>
<dt>colors.communities</dt><dd><p>Vector with colors of the communities, namely assigned
colors if <code>list.of.sets = NULL</code> or shaded and mixed colors if
<code>list.of.sets</code> is not NULL.</p>
</dd>
<dt>colors.nodes</dt><dd><p>List with all colors assigned to each node. Isolated nodes
are white. Shared nodes have a vector of colors from each community they
belong to.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Jens Lange, <a href="mailto:lange.jens@outlook.com">lange.jens@outlook.com</a>
</p>


<h3>References</h3>

<p>Coombes, K. R., Brock, G., Abrams, Z. B., &amp; Abruzzo, L. V. (2019). Polychrome:
Creating and assessing qualitative palettes with many colors.
<em>Journal of Statistical Software, 90</em>, 1-26. https://doi.org/10.18637/jss.v090.c01
</p>
<p>Zeileis, A., Fisher, J. C., Hornik, K., Ihaka, R., McWhite, C. D., Murrell, P.,
Stauffer, R., &amp; Wilke, C. O. (subm.). <em>colorspace: A toolbox for manipulating
and assessing colors and palettes</em>. https://arxiv.org/abs/1903.06490
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example with fictitious data

# generate qgraph object with letters as labels
W &lt;- matrix(c(0,0.10,0,0,0,0.10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
              0,0,0.10,0,0,0.10,0.20,0,0,0,0,0.20,0.20,0,0,0,0,0,0,0,0,
              0,0,0,0.10,0,0.10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
              0,0,0,0,0.10,0.10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
              0,0,0,0,0,0.10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
              0,0,0,0,0,0,0,0.20,0,0,0,0,0.20,0,0,0,0,0,0,0,0,
              0,0,0,0,0,0,0,0,0.20,0,0,0,0.20,0,0,0,0,0,0,0,0,
              0,0,0,0,0,0,0,0,0,0.20,0,0,0.20,0,0,0,0,0,0,0,0,
              0,0,0,0,0,0,0,0,0,0,0.20,0,0.20,0,0,0,0,0,0,0,0,
              0,0,0,0,0,0,0,0,0,0,0,0.20,0.20,0.30,0,0,0,0,0.30,0.30,0,
              0,0,0,0,0,0,0,0,0,0,0,0,0.20,0,0,0,0,0,0,0,0,
              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.30,0,0,0,0,0.30,0,
              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.30,0,0,0,0.30,0,
              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.30,0,0,0.30,0,
              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.30,0,0.30,0.30,
              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.30,0.30,0,
              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.30,0,
              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0), nrow = 21, ncol = 21, byrow = TRUE) 

W &lt;- Matrix::forceSymmetric(W)
rownames(W) &lt;- letters[seq(from = 1, to = nrow(W))]
colnames(W) &lt;- letters[seq(from = 1, to = ncol(W))]

W &lt;- qgraph::qgraph(W, layout = "spring", edge.labels = TRUE)

# run clique percolation algorithm; three communities; two shared nodes, one isolated node
cp &lt;- cpAlgorithm(W, k = 3, method = "weighted", I = 0.09)

# color original graph according to community partition
# all other arguments are defaults; qgraph arguments used to return same layout

results &lt;- cpColoredGraph(W, list.of.communities = cp$list.of.communities.labels,
                          layout = "spring", edge.labels = TRUE)


# own colors (red, green, and blue) assigned to the communities

results &lt;- cpColoredGraph(W, list.of.communities = cp$list.of.communities.labels,
                          own.colors = c("#FF0000","#00FF00","#0000FF"),
                          layout = "spring", edge.labels = TRUE)


# define sets of nodes; nodes a to o are in Set 1 and letters p to u in Set 2
list.of.sets &lt;- list(letters[seq(from = 1, to = 15)],
                     letters[seq(from = 16, to = 21)])

# color original graph according to community partition, taking sets of nodes into account
# two communities are pure and therefore get shades of set color; smaller community is more white
# one community is mixed, so both set colors get mixed

results &lt;- cpColoredGraph(W, list.of.communities = cp$list.of.communities.labels,
                          list.of.sets = list.of.sets,
                          layout = "spring", edge.labels = TRUE)


# graph as before, but specifying the set palette size to 6
# from a range of 6 colors, the pure communities get the darker ones
# in a different network with also two pure communities, luminance would therefore be equal

results &lt;- cpColoredGraph(W, list.of.communities = cp$list.of.communities.labels,
                          list.of.sets = list.of.sets, set.palettes.size = 6,
                          layout = "spring", edge.labels = TRUE)


# graph as before, but colors sampled only form yellow to blue range, less chroma, more luminance

results &lt;- cpColoredGraph(W, list.of.communities = cp$list.of.communities.labels,
                          list.of.sets = list.of.sets, set.palettes.size = 6,
                          h.cp = c(50, 210), c.cp = 70, l.cp = 70,
                          layout = "spring", edge.labels = TRUE)


# own colors (red and green) assigned to the sets
# two communities in shades of red and one community is mix of green and red (brown)

results &lt;- cpColoredGraph(W, list.of.communities = cp$list.of.communities.labels,
                          list.of.sets = list.of.sets,
                          own.colors = c("#FF0000","#00FF00"),
                          layout = "spring", edge.labels = TRUE)


## Example with Obama data set (see ?Obama)

# get data
data(Obama)

# estimate network
net &lt;- qgraph::EBICglasso(qgraph::cor_auto(Obama), n = nrow(Obama))

# run clique percolation algorithm with specific k and I
cpk3I.16 &lt;- cpAlgorithm(net, k = 3, I = 0.16, method = "weighted")

# color original graph according to community partition
# all other arguments are defaults

results &lt;- cpColoredGraph(net, list.of.communities = cpk3I.16$list.of.communities.labels,
                          layout = "spring", theme = "colorblind")


</code></pre>

<hr>
<h2 id='cpCommunityGraph'>Plotting Clique Percolation Community Network</h2><span id='topic+cpCommunityGraph'></span>

<h3>Description</h3>

<p>Function for plotting a network with nodes representing communities from clique percolation
community detection and edges representing the number of shared nodes of the communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpCommunityGraph(
  list.of.communities,
  node.size.method = c("proportional", "normal"),
  max.node.size = 10,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpCommunityGraph_+3A_list.of.communities">list.of.communities</code></td>
<td>
<p>List object taken from results of cpAlgorithm
function; see also <a href="#topic+cpAlgorithm">cpAlgorithm</a></p>
</td></tr>
<tr><td><code id="cpCommunityGraph_+3A_node.size.method">node.size.method</code></td>
<td>
<p>String indicating how node size is plotted (<code>"proportional"</code>
or <code>"normal"</code>); see Details</p>
</td></tr>
<tr><td><code id="cpCommunityGraph_+3A_max.node.size">max.node.size</code></td>
<td>
<p>Integer indicating size of the node representing the
largest community, if <code>node.size.method = "proportional"</code></p>
</td></tr>
<tr><td><code id="cpCommunityGraph_+3A_...">...</code></td>
<td>
<p>any additional argument from qgraph; see also <a href="qgraph.html#topic+qgraph">qgraph</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes the results of cpAlgorithm (see also <a href="#topic+cpAlgorithm">cpAlgorithm</a>),
that is, either the <code>list.of.communities.numbers</code> or the
<code>list.of.communities.labels</code> and plots the community network. Each node represents
a community. Edges connecting two nodes represent the number of shared nodes between
the two communities.
</p>
<p>The nodes can be plotted proportional to the sizes of the communities
(<code>node.size.method = "proportional"</code>). The node representing the largest community
is then plotted with the size specified in <code>max.node.size</code>. All other nodes
are plotted relative to this largest node. Alternatively, all nodes can have the
same size (<code>node.size.method = "normal"</code>).
</p>
<p>For the plotting, all isolated nodes will be ignored. If there are less than two
communities in the list, plotting the network is useless. Therefore, an error
is printed in this case.
</p>


<h3>Value</h3>

<p>The function primarily plots the community network. Additionally, it returns a list with
the weights matrix (<code>community.weights.matrix</code>) of the community network.
</p>


<h3>Author(s)</h3>

<p>Jens Lange, <a href="mailto:lange.jens@outlook.com">lange.jens@outlook.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example with fictitious data

# create qgraph object
W &lt;- matrix(c(0,1,1,0,0,0,0,
              0,0,1,0,0,0,0,
              0,0,0,1,1,1,0,
              0,0,0,0,1,1,0,
              0,0,0,0,0,1,0,
              0,0,0,0,0,0,1,
              0,0,0,0,0,0,0), nrow = 7, ncol = 7, byrow = TRUE)
W &lt;- Matrix::forceSymmetric(W)
W &lt;- qgraph::qgraph(W)

# run clique percolation for unweighted networks
cp.results &lt;- cpAlgorithm(W = W, k = 3, method = "unweighted")

# plot community network; proportional; maximum size is 7
cp.network1 &lt;- cpCommunityGraph(cp.results$list.of.communities.numbers,
                                node.size.method = "proportional",
                                max.node.size = 7)
                                       
# plot community network; proportional; maximum size is 7
# change shape of nodes to triangle via qgraph argument
cp.network2 &lt;- cpCommunityGraph(cp.results$list.of.communities.numbers,
                                node.size.method = "proportional",
                                max.node.size = 7,
                                shape = "triangle")
                                
## Example with Obama data set (see ?Obama)

# get data
data(Obama)

# estimate network
net &lt;- qgraph::EBICglasso(qgraph::cor_auto(Obama), n = nrow(Obama))

# run clique percolation algorithm with specific k and I
cpk3I.16 &lt;- cpAlgorithm(net, k = 3, I = 0.16, method = "weighted")

# plot community network; normal
Obama.network &lt;- cpCommunityGraph(cpk3I.16$list.of.communities.numbers,
                                  node.size.method = "proportional",
                                  theme = "colorblind")

</code></pre>

<hr>
<h2 id='cpCommunitySizeDistribution'>Plotting Clique Percolation Community Size Distribution</h2><span id='topic+cpCommunitySizeDistribution'></span>

<h3>Description</h3>

<p>Function for plotting the frequency distribution of community sizes from clique
percolation community detection and testing for power-law.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpCommunitySizeDistribution(
  list.of.communities,
  color.line = "#bc0031",
  test.power.law = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpCommunitySizeDistribution_+3A_list.of.communities">list.of.communities</code></td>
<td>
<p>List object taken from results of cpAlgorithm
function; see also <a href="#topic+cpAlgorithm">cpAlgorithm</a></p>
</td></tr>
<tr><td><code id="cpCommunitySizeDistribution_+3A_color.line">color.line</code></td>
<td>
<p>string indicating the color of the line in the plot as described
in <a href="graphics.html#topic+par">par</a>; default is <code>"#bc0031"</code></p>
</td></tr>
<tr><td><code id="cpCommunitySizeDistribution_+3A_test.power.law">test.power.law</code></td>
<td>
<p>Logical indicating whether fit of power-law should be tested; default
is FALSE; see Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes the results of cpAlgorithm (see also <a href="#topic+cpAlgorithm">cpAlgorithm</a>),
that is, either the <code>list.of.communities.numbers</code> or the
<code>list.of.communities.labels</code> and plots the community size distribution. If there
are no communities, no plot can be generated. An error is printed indicating this.
</p>
<p>If <code>test.power.law = TRUE</code>, test of a fit of a power-law is performed with the
function fit_power_law (see also <a href="igraph.html#topic+fit_power_law">fit_power_law</a>). Fit is tested for
the entire distribution from the smallest community size onward (i.e., typically k
as specified in cpAlgorithm). Moreover, test uses the <code>plfit</code> implementation of
fit_power_law. For other arguments, default values are used.
</p>


<h3>Value</h3>

<p>The function primarily plots the community size distribution. Additionally, it returns
a list with a data frame containing all community sizes and their frequencies
(<code>size.distribution</code>). If <code>test.power.law = TRUE</code>, a test of fit of a power-law
distribution is also returned as a list object with results from fit_power_law (see
also <a href="igraph.html#topic+fit_power_law">fit_power_law</a>).
</p>


<h3>Author(s)</h3>

<p>Jens Lange, <a href="mailto:lange.jens@outlook.com">lange.jens@outlook.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example with fictitious data

# create qgraph object; 150 nodes; 1/7 of all edges are different from zero
W &lt;- matrix(c(0), nrow = 150, ncol = 150, byrow = TRUE)
set.seed(4186)
W[upper.tri(W)] &lt;- sample(c(rep(0,6),1), length(W[upper.tri(W)]), replace = TRUE)
rand_w &lt;- stats::rnorm(length(which(W == 1)), mean = 0.3, sd = 0.1)
W[which(W == 1)] &lt;- rand_w
W &lt;- Matrix::forceSymmetric(W)
W &lt;- qgraph::qgraph(W, DoNotPlot = TRUE)

# run clique percolation for weighted networks
cp.results &lt;- cpAlgorithm(W, k = 3, method = "weighted", I = 0.38)

# plot community size distribution with blue line
cp.size.dist &lt;- cpCommunitySizeDistribution(cp.results$list.of.communities.numbers,
                                            color.line = "#0000ff")
# test for power-law distribution
cp.size.dist &lt;- cpCommunitySizeDistribution(cp.results$list.of.communities.numbers,
                                            color.line = "#0000ff",
                                            test.power.law = TRUE)
cp.size.dist$fit.power.law

## Example with Obama data set (see ?Obama)

# get data
data(Obama)

# estimate network
net &lt;- qgraph::EBICglasso(qgraph::cor_auto(Obama), n = nrow(Obama))

# run clique percolation algorithm with specific k and I
cpk3I.16 &lt;- cpAlgorithm(net, k = 3, I = 0.16, method = "weighted")

# plot community size distribution
#the distribution is not very informative with four equally-sized communities
Obama.size.dist &lt;- cpCommunitySizeDistribution(cpk3I.16$list.of.communities.numbers)

</code></pre>

<hr>
<h2 id='cpPermuteEntropy'>Confidence Intervals Of Entropy Based On Random Permutations Of Network</h2><span id='topic+cpPermuteEntropy'></span>

<h3>Description</h3>

<p>Function for determining confidence intervals of entropy values calculated for
community partition from clique percolation based on randomly permuted networks
of original network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpPermuteEntropy(
  W,
  cpThreshold.object,
  n = 100,
  interval = 0.95,
  CFinder = FALSE,
  ncores,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpPermuteEntropy_+3A_w">W</code></td>
<td>
<p>A qgraph object or a symmetric matrix; see also <a href="qgraph.html#topic+qgraph">qgraph</a></p>
</td></tr>
<tr><td><code id="cpPermuteEntropy_+3A_cpthreshold.object">cpThreshold.object</code></td>
<td>
<p>A cpThreshold object; see also <a href="#topic+cpThreshold">cpThreshold</a></p>
</td></tr>
<tr><td><code id="cpPermuteEntropy_+3A_n">n</code></td>
<td>
<p>number of permutations (default is 100)</p>
</td></tr>
<tr><td><code id="cpPermuteEntropy_+3A_interval">interval</code></td>
<td>
<p>requested confidence interval (larger than zero and smaller 1;
default is 0.95)</p>
</td></tr>
<tr><td><code id="cpPermuteEntropy_+3A_cfinder">CFinder</code></td>
<td>
<p>logical indicating whether clique percolation for weighted networks
should be performed as in CFinder ; see also <a href="#topic+cpAlgorithm">cpAlgorithm</a></p>
</td></tr>
<tr><td><code id="cpPermuteEntropy_+3A_ncores">ncores</code></td>
<td>
<p>Numeric.
Number of cores to use in computing results.
Defaults to <code>parallel::detectCores() / 2</code> or half of your
computer's processing power.
Set to <code>1</code> to not use parallel computing</p>
</td></tr>
<tr><td><code id="cpPermuteEntropy_+3A_seed">seed</code></td>
<td>
<p>Numeric.
Set seed for reproducible results.
Defaults to <code>NULL</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates <code>n</code> random permutations of the network
specified in <code>W</code>. For each randomly permuted network, it runs <code>cpThreshold</code>
(see <a href="#topic+cpThreshold">cpThreshold</a> for more information) with <code>k</code> and <code>I</code> values
extracted from the cpThreshold object specified in <code>cpThreshold.object</code>.
Across permutations, the confidence intervals of the entropy values are determined
for each <code>k</code> separately.
</p>
<p>The confidence interval of the entropy values is determined separately for each <code>k</code>.
This is because larger <code>k</code> have to produce less communities on average,
which will decrease entropy. Comparing confidence intervals of smaller <code>k</code> to
those of larger <code>k</code> would therefore be disadvantageous for larger <code>k</code>.
</p>
<p>In the output, one can check the confidence intervals of each <code>k</code>. Moreover,
a data frame is produced that takes the cpThreshold object that was specified in
<code>cpThreshold.object</code> and removes all rows that do not exceed the upper bound of the
confidence interval of the respective <code>k</code>.
</p>


<h3>Value</h3>

<p>A list object with the following elements:
</p>

<dl>
<dt>Confidence.Interval</dt><dd><p>a data frame with lower and upper bound of
confidence interval for each <code>k</code></p>
</dd>
<dt>Extracted.Rows</dt><dd><p>rows extracted from <code>cpThreshold.object</code> that are
larger than the upper bound of the specified confidence interval for
each <code>k</code></p>
</dd>
<dt>Settings</dt><dd><p>user-specified settings</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Jens Lange, <a href="mailto:lange.jens@outlook.com">lange.jens@outlook.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example with fictitious data

# create qgraph object
W &lt;- matrix(c(0,1,1,1,0,0,0,0,
              0,0,1,1,0,0,0,0,
              0,0,0,0,0,0,0,0,
              0,0,0,0,1,1,1,0,
              0,0,0,0,0,1,1,0,
              0,0,0,0,0,0,1,0,
              0,0,0,0,0,0,0,1,
              0,0,0,0,0,0,0,0), nrow = 8, ncol = 8, byrow = TRUE)
W &lt;- Matrix::forceSymmetric(W)
W &lt;- qgraph::qgraph(W)

# create cpThreshold object
cpThreshold.object &lt;- cpThreshold(W = W, method = "unweighted", k.range = c(3,4),
                                  threshold = "entropy")

# run cpPermuteEntropy with 100 permutations and 95% confidence interval

results &lt;- cpPermuteEntropy(W = W, cpThreshold.object = cpThreshold.object,
                            n = 100, interval = 0.95, ncores = 1, seed = 4186)

# check results
results


## Example with Obama data set (see ?Obama)

# get data
data(Obama)

# estimate network
net &lt;- qgraph::EBICglasso(qgraph::cor_auto(Obama), n = nrow(Obama))

# create cpThreshold object

threshold &lt;- cpThreshold(net, method = "weighted",
                         k.range = 3:4,
                         I.range = seq(0.1, 0.5, 0.01),
                         threshold = "entropy")

                          
# run cpPermuteEntropy with 50 permutations and 99% confidence interval

permute &lt;- cpPermuteEntropy(net, cpThreshold.object = threshold,
                            interval = 0.99, n = 50, ncores = 1, seed = 4186)

# check results
permute


</code></pre>

<hr>
<h2 id='cpThreshold'>Optimizing <code>k</code> And <code>I</code> For Clique Percolation Community Detection</h2><span id='topic+cpThreshold'></span>

<h3>Description</h3>

<p>Function for determining threshold value(s) (ratio of largest to second largest
community sizes, chi, entropy, fuzzy modularity, signed fuzzy modularity) of ranges 
of <code>k</code> and <code>I</code> values to help deciding for optimal <code>k</code> and <code>I</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpThreshold(
  W,
  method = c("unweighted", "weighted", "weighted.CFinder"),
  k.range,
  I.range,
  threshold = c("largest.components.ratio", "chi", "entropy", "fuzzymod",
    "signedfuzzymod")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpThreshold_+3A_w">W</code></td>
<td>
<p>A qgraph object or a symmetric matrix; see also <a href="qgraph.html#topic+qgraph">qgraph</a></p>
</td></tr>
<tr><td><code id="cpThreshold_+3A_method">method</code></td>
<td>
<p>A string indicating the method to use 
(<code>"unweighted"</code>, <code>"weighted"</code>, or <code>"weighted.CFinder"</code>).
See <a href="#topic+cpAlgorithm">cpAlgorithm</a> for more information</p>
</td></tr>
<tr><td><code id="cpThreshold_+3A_k.range">k.range</code></td>
<td>
<p>integer or vector of <code>k</code> value(s) for which threshold(s) are determined
See <a href="#topic+cpAlgorithm">cpAlgorithm</a> for more information</p>
</td></tr>
<tr><td><code id="cpThreshold_+3A_i.range">I.range</code></td>
<td>
<p>integer or vector of <code>I</code> value(s) for which threshold(s) are determined
See <a href="#topic+cpAlgorithm">cpAlgorithm</a> for more information</p>
</td></tr>
<tr><td><code id="cpThreshold_+3A_threshold">threshold</code></td>
<td>
<p>A string or vector indicating which threshold(s) to determine
(<code>"largest.components.ratio", "chi", "entropy", "fuzzymod", "signedfuzzymod"</code>); see Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Optimizing <code>k</code> (clique size) and <code>I</code> (Intensity threshold) in clique percolation
community detection is a difficult task. Farkas et al. (2007) recommend to look at the
ratio of the largest to second largest community sizes
(<code>threshold = "largest.components.ratio"</code>) for very large networks or
the variance of the community sizes when removing the community size of the largest
community (<code>threshold = "chi"</code>) for somewhat smaller networks. These thresholds were
derived from percolation theory. If <code>I</code> for a certain <code>k</code> is too high, no
community will be identified. If <code>I</code> is too low, a giant community with all nodes
emerges. Just above this <code>I</code>, the distribution of community sizes often follows a
power law, which constitutes a broad community sizes distribution. Farkas et al. (2007)
point out, that for such <code>I</code>, the ratio of the largest to second largest community
sizes is approximately 2, constituting one way to optimize <code>I</code> for each possible
<code>k</code>. For somewhat smaller networks, the ratio can be rather unstable. Instead,
Farkas et al. (2007, p.8) propose to look at the variance of the community sizes after
removing the largest community. The idea is that when <code>I</code> is rather low, one giant
community and multiple equally small ones occur. Then, the variance of the community
sizes of the small communities (removing the giant community) is low. When <code>I</code>
is high, only a few equally small communities will occur. Then, the variance of the
community sizes (after removing the largest community) will also be low. In between,
the variance will at some point be maximal, namely when the community size
distribution is maximally broad (power law-distributed). Thus, the maximal variance
could be used to optimize <code>I</code> for various <code>k</code>.
</p>
<p>For very small networks, optimizing <code>k</code> and <code>I</code> based on the distribution of the
community sizes will be impossible, as too few communities will occur. Another possible
threshold for such networks is based on the entropy of the community sizes
(<code>threshold = "entropy"</code>). Entropy can be interpreted as an indicator of how
surprising the respective solution is. The formula used here is based on Shannon
Information, namely
</p>
<p style="text-align: center;"><code class="reqn">-\sum_{i=1}^N p_i * \log_2 p_i</code>
</p>

<p>with <code class="reqn">p_i</code> being the probability that a node is part of community <code class="reqn">i</code>. For instance,
if there are two communities, one of size 5 and one of size 3, the result would be
</p>
<p style="text-align: center;"><code class="reqn">-((5/8 * \log_2 5/8) + (3/8 * \log_2 3/8)) = 1.46</code>
</p>

<p>When calculating entropy, the isolated nodes identified by clique percolation are treated as
a separate community. If there is only one community or only isolated nodes, entropy is
zero, indicating that the surprisingness is low. As compared to the ratio and chi 
thresholds, entropy favors communities that are equal in size. Thus, it should not be 
used for larger networks for which a broader community size distribution is preferred.
Note that the entropy threshold has not been validated for clique percolation as of now.
Initial simulation studies indicate that it consistently detects surprising community
partitions in smaller networks especially if there are cliques of larger <code>k</code>.
</p>
<p>Santiago et al. (2022) recently proposed in a simulation study that two 
alternative metrics, fuzzy modularity and signed fuzzy modularity, showed good performance 
in recovering the true community assignment in psychological networks with overlapping nodes 
and can also be used to optimize <code>k</code> (clique size) and <code>I</code> (Intensity threshold).
See <a href="#topic+FuzzyMod">FuzzyMod</a> and <a href="#topic+SignedFuzzyMod">SignedFuzzyMod</a> for more information.
</p>
<p>Ratio thresholds can be determined only if there are at least two communities. Chi threshold
can be determined only if there are at least three communities. If there are not enough
communities for the respective threshold, their values are NA in the data frame.
Entropy, fuzzy modularity, and signed fuzzy modularity can always be determined.
</p>


<h3>Value</h3>

<p>A data frame with columns for <code>k</code>, <code>I</code> (if <code>method = "weighted"</code>
or <code>method = "weighted.CFinder"</code>), number of communities, number of isolated
nodes, and results of the specified threshold(s).
</p>


<h3>Author(s)</h3>

<p>Jens Lange, <a href="mailto:lange.jens@outlook.com">lange.jens@outlook.com</a>
</p>


<h3>References</h3>

<p>Farkas, I., Abel, D., Palla, G., &amp; Vicsek, T. (2007). Weighted network modules.
<em>New Journal of Physics, 9</em>, 180-180. http://doi.org/10.1088/1367-2630/9/6/180
</p>
<p>Santiago, P. H. R., Soares, G. H., Quintero, A., &amp; Jamieson, L. (2022). <em>The performance of 
the Clique Percolation to identify overlapping symptoms in psychological networks</em>. PsyArXiv.
https://psyarxiv.com/fk963/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Example for unweighted networks

# create qgraph object
W &lt;- matrix(c(0,1,1,1,0,0,0,0,
              0,0,1,1,0,0,0,0,
              0,0,0,0,0,0,0,0,
              0,0,0,0,1,1,1,0,
              0,0,0,0,0,1,1,0,
              0,0,0,0,0,0,1,0,
              0,0,0,0,0,0,0,1,
              0,0,0,0,0,0,0,0), nrow = 8, ncol = 8, byrow = TRUE)
W &lt;- Matrix::forceSymmetric(W)
W &lt;- qgraph::qgraph(W)

# determine entropy and fuzzy modularity thresholds for k = 3 and k = 4
results &lt;- cpThreshold(W = W, method = "unweighted", k.range = c(3,4), threshold = c("entropy",
"fuzzymod"))

## Example for weighted networks; three large communities with I = 0.3, 0.2, and 0.1, respectively

# create qgraph object
W &lt;- matrix(c(0,0.10,0,0,0,0,0.10,0.10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
              0,0,0.10,0,0,0,0,0.10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
              0,0,0,0.10,0,0,0,0.10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
              0,0,0,0,0.10,0,0,0.10,0.20,0,0,0,0,0.20,0.20,0,0,0,0,0,0,0,
              0,0,0,0,0,0.10,0,0.10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
              0,0,0,0,0,0,0.10,0.10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
              0,0,0,0,0,0,0,0.10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
              0,0,0,0,0,0,0,0,0,0.20,0,0,0,0,0.20,0,0,0,0,0,0,0,
              0,0,0,0,0,0,0,0,0,0,0.20,0,0,0,0.20,0,0,0,0,0,0,0,
              0,0,0,0,0,0,0,0,0,0,0,0.20,0,0,0.20,0,0,0,0,0,0,0,
              0,0,0,0,0,0,0,0,0,0,0,0,0.20,0,0.20,0,0,0,0,0,0,0,
              0,0,0,0,0,0,0,0,0,0,0,0,0,0.20,0.20,0.30,0,0,0,0,0.30,0.30,
              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.20,0,0,0,0,0,0,0,
              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.30,0,0,0,0,0.30,
              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.30,0,0,0,0.30,
              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.30,0,0,0.30,
              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.30,0,0.30,
              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.30,0.30,
              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.30,
              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0), nrow = 22, ncol = 22, byrow = TRUE) 
W &lt;- Matrix::forceSymmetric(W)
W &lt;- qgraph::qgraph(W, layout = "spring", edge.labels = TRUE)

# determine ratio, chi, entropy, fuzzy modularity, and signed fuzzy modularity 
# thresholds for k = 3 and I from 0.3 to 0.09
results &lt;- cpThreshold(W = W, method = "weighted", k.range = 3,
                       I.range = c(seq(0.3, 0.09, by = -0.01)),
                       threshold = c("largest.components.ratio","chi","entropy",
                       "fuzzymod","signedfuzzymod"))

## Example with Obama data set (see ?Obama)

# get data
data(Obama)

# estimate network
net &lt;- qgraph::EBICglasso(qgraph::cor_auto(Obama), n = nrow(Obama))

# determine entropy, fuzzy modularity, and signed fuzzy modularity thresholds 
# for k from 3 to 4 and I from 0.1 to 0.5
threshold &lt;- cpThreshold(net, method = "weighted",
                         k.range = 3:4,
                         I.range = seq(0.1, 0.5, 0.01),
                         threshold = c("entropy", "fuzzymod", "signedfuzzymod"))
## End(Not run)

</code></pre>

<hr>
<h2 id='FuzzyMod'>Fuzzy Modularity of a community structure of a graph</h2><span id='topic+FuzzyMod'></span>

<h3>Description</h3>

<p>Function calculates the fuzzy modularity of a (disjoint or non-disjoint division)
of a graph into subgraphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FuzzyMod(graph, membership, abs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FuzzyMod_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="FuzzyMod_+3A_membership">membership</code></td>
<td>
<p>Numeric vector or list indicating the membership structure.</p>
</td></tr>
<tr><td><code id="FuzzyMod_+3A_abs">abs</code></td>
<td>
<p>Should fuzzy modularity be calculated based on absolute values of 
network edges? Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The modularity of a graph with respect to some division is a measure of how good 
the division is. The traditional <em>modularity</em> Q was proposed by Newman and Girvan (2004):
</p>
<p style="text-align: center;"><code class="reqn">Q=\frac{1}{2m} \sum_{c\epsilon_C} \sum_{u,v\epsilon_V} (A_{uv}-\frac{k_{u}k_{v}}{2m}) \delta_{cu} \delta_{cv}</code>
</p>

<p>where m is the total number of edges, C is the set of communities corresponding to a partition,
V is the set of vertices (i.e. nodes) in the network, <code class="reqn">A_{uv}</code> is the element of the 
A adjacency matrix in row <code class="reqn">i</code> and column <code class="reqn">j</code>, and <code class="reqn">k_{u}</code> and <code class="reqn">k_{v}</code> are the node 
degrees of nodes <code class="reqn">u</code> and <code class="reqn">v</code>, respectively. <code class="reqn">\delta_{cu}</code> indicates whether 
node <code class="reqn">u</code> belongs to community <code class="reqn">c</code>, which equals 1 if u and v belongs to 
community c and 0 otherwise. The product <code class="reqn">\delta_{cu}*\delta_{cv}</code> is a Kronecker delta function
which equals 1 if <code class="reqn">u</code> and <code class="reqn">v</code> belongs to community <code class="reqn">c</code> and 0 otherwise.
</p>
<p>In the case of <em>weighted</em> networks, Fan, Li, Zhang, Wu, and Di (2007) proposed that to calculate 
<em>modularity</em> Q, m should be the total edge weights, and <code class="reqn">k_{u}</code> and <code class="reqn">k_{v}</code> should be 
the node strengths of nodes <code class="reqn">u</code> and <code class="reqn">v</code>, respectively. 
</p>
<p>One limitation of <em>modularity</em> Q proposed by Newman and Girvan (2004) was that modularity could 
not be calculated for non-disjoint community partitions (i.e. networks in which a node is assigned
to more than one community). As such, Chen, Shang, Lv, and Fu (2010) proposed a generalisation 
in terms of fuzzy modularity:
</p>
<p style="text-align: center;"><code class="reqn">Q=\frac{1}{2m} \sum_{c\epsilon_C} \sum_{u,v\epsilon_V} \alpha_{cu} \alpha_{cv} (A_{uv}-\frac{k_{u}k_{v}}{2m})</code>
</p>

<p>where <code class="reqn">\alpha_{cu}</code> is the <em>belonging coefficient</em>. The <em>belonging coefficient</em> reflects 
how much the node <code class="reqn">u</code> belongs to community <code class="reqn">c</code>. The belonging coefficient is calculated as:
</p>
<p style="text-align: center;"><code class="reqn">\alpha_{cu} = \frac{k_{cu}}{\sum_{c\epsilon_C}k_{cu}}</code>
</p>

<p>In case of a disjoint solution, the fuzzy modularity Q proposed by Chen, Shang, Lv, and Fu (2010) reduces to the 
modularity Q proposed by Newman and Girvan (2004).
</p>


<h3>Value</h3>

<p>A numeric scalar, the fuzzy modularity score of the given configuration.
</p>


<h3>Author(s)</h3>

<p>Pedro Henrique Ribeiro Santiago, <a href="mailto:phrs16@gmail.edu.au">phrs16@gmail.edu.au</a> [ctb]
</p>
<p>Gustavo Hermes Soares, [rev]
</p>
<p>Adrian Quintero, [rev]
</p>
<p>Lisa Jamieson, [rev]
</p>


<h3>References</h3>

<p>Newman, M. E., &amp; Girvan, M. (2004). Finding and evaluating community structure in networks. 
<em>Physical review E</em>, 69(2), 026113. 
</p>
<p>Fan, Y., Li, M., Zhang, P., Wu, J., &amp; Di, Z. (2007). Accuracy and precision of methods for community 
identification in weighted networks. <em>Physica A: Statistical Mechanics and its Applications</em>, 377(1), 363-372. 
</p>
<p>Chen, D., Shang, M., Lv, Z., &amp; Fu, Y. (2010). Detecting overlapping communities of weighted networks 
via a local algorithm. <em>Physica A: Statistical Mechanics and its Applications</em>, 389(19), 4177-4187.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- igraph::disjoint_union(igraph::make_full_graph(5),igraph::make_full_graph(4))
g &lt;- igraph::add_edges(g, c(2,6, 2,7, 2,8, 2,9))
wc &lt;- list(c(1,2,3,4,5),c(2,6,7,8,9))
FuzzyMod(graph=g, membership=wc, abs=TRUE)

</code></pre>

<hr>
<h2 id='immuno'>Data: Immunoglobulin interaction network</h2><span id='topic+immuno'></span>

<h3>Description</h3>

<p>Unweighted, undirected network of interactions in the immunoglobulin
network. The 1,316 nodes represent amino-acids and two nodes are
connected by an edge if the shortest distance of their C_alpha atoms
is smaller than <code class="reqn">\Theta = 8</code> Angstrom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(immuno)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"qgraph"</code> with 1,316 nodes and
6,300 edges.
</p>


<h3>Source</h3>

<p><a href="https://CRAN.R-project.org/package=igraphdata">https://CRAN.R-project.org/package=igraphdata</a>
</p>


<h3>References</h3>

<p>Gfeller, D. (2007). <em>Simplifying complex networks: From a clustering
to a coarse graining strategy</em>. EPFL. http://library.epfl.ch/theses/?nr=3888
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immuno)
</code></pre>

<hr>
<h2 id='Obama'>Data: Evaluative Reactions Toward Barack Obama (2012)</h2><span id='topic+Obama'></span>

<h3>Description</h3>

<p>A data set containing evaluative reactions toward
Barack Obama from the American National Election Studies
in 2012. The study included 5,914 participants, representative
of the adult U.S. American population (note missing values).
The participants rated Obama on 10 evaluative reactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Obama)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code> with 5,914 observations
and 10 variables.
</p>

<dl>
<dt>Mor</dt><dd><p>&quot;Is moral&quot;</p>
</dd>
<dt>Led</dt><dd><p>&quot;Would provide strong leadership&quot;</p>
</dd>
<dt>Car</dt><dd><p>&quot;Really cares about people like you&quot;</p>
</dd>
<dt>Kno</dt><dd><p>&quot;Is knowledgeable&quot;</p>
</dd>
<dt>Int</dt><dd><p>&quot;Is intelligent&quot;</p>
</dd>
<dt>Hns</dt><dd><p>&quot;Is honest&quot;</p>
</dd>
<dt>Ang</dt><dd><p>&quot;Angry&quot;</p>
</dd>
<dt>Hop</dt><dd><p>&quot;Hopeful&quot;</p>
</dd>
<dt>Afr</dt><dd><p>&quot;Afraid of him&quot;</p>
</dd>
<dt>Prd</dt><dd><p>&quot;Proud&quot;</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://electionstudies.org/">https://electionstudies.org/</a>
</p>


<h3>References</h3>

<p>Dalege, J., Borsboom, D., Van Harreveld, F., Van der Maas, H. L. J. (2017).
Network analysis on attitudes: A brief tutorial. <em>Social Psychological
and Personality Science, 8</em>, 528-537. https://doi.org/10.1177/1948550617709827
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Obama)
</code></pre>

<hr>
<h2 id='print.cpAlgorithm'>print.cpAlgorithm</h2><span id='topic+print.cpAlgorithm'></span>

<h3>Description</h3>

<p>Print method for objects of class <code>cpAlgorithm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpAlgorithm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.cpAlgorithm_+3A_x">x</code></td>
<td>
<p>An object of class <code>cpAlgorithm</code>; see also
<a href="#topic+cpAlgorithm">cpAlgorithm</a></p>
</td></tr>
<tr><td><code id="print.cpAlgorithm_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jens Lange, <a href="mailto:lange.jens@outlook.com">lange.jens@outlook.com</a>
</p>

<hr>
<h2 id='print.cpPermuteEntropy'>print.cpPermuteEntropy</h2><span id='topic+print.cpPermuteEntropy'></span>

<h3>Description</h3>

<p>Print method for objects of class <code>cpPermuteEntropy</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpPermuteEntropy'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.cpPermuteEntropy_+3A_x">x</code></td>
<td>
<p>An object of class <code>cpPermuteEntropy</code>; see also
<a href="#topic+cpPermuteEntropy">cpPermuteEntropy</a></p>
</td></tr>
<tr><td><code id="print.cpPermuteEntropy_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jens Lange, <a href="mailto:lange.jens@outlook.com">lange.jens@outlook.com</a>
</p>

<hr>
<h2 id='SignedFuzzyMod'>Signed Fuzzy Modularity of a community structure of a graph</h2><span id='topic+SignedFuzzyMod'></span>

<h3>Description</h3>

<p>Function calculates the fuzzy modularity of a (disjoint or non-disjoint division) of a graph into subgraphs
for signed weighted networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SignedFuzzyMod(netinput, membassigned)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SignedFuzzyMod_+3A_netinput">netinput</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="SignedFuzzyMod_+3A_membassigned">membassigned</code></td>
<td>
<p>Numeric vector or list indicating the membership structure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <em>signed</em> weighted networks (i.e. networks with positive and negative edges), the 
calculation of the modularity Q is problematic. Gomez, Jensen, and Arenas (2009) explain that, 
when calculating modularity Q for unweighted (Newman &amp; Girvan, 2004) or weighted networks 
(Fan, Li, Zhang, Wu, &amp; Di, 2007), the term <code class="reqn">\frac{k_{u}}{2m}</code> indicates the probability of 
node <code class="reqn">u</code> making connections with other nodes in the network, if connections between nodes 
were random. Gomez, Jensen, and Arenas (2009) discuss how, when networks are signed, the 
positive and negative edges cancel each other out and the term <code class="reqn">\frac{k_{u}}{2m}</code> loses its 
probabilistic meaning. To deal with this limitation, Gomez, Jensen, and Arenas (2009) proposed modularity Q for signed 
weighted networks, generalised to fuzzy modularity Q for signed weighted networks:
</p>
<p style="text-align: center;"><code class="reqn">Q=(\frac{2w^{+}}{2w^{+}+2w^{-}})(\frac{1}{2m^{+}}) \sum_{c\epsilon_C} \sum_{u,v\epsilon_V} \alpha_{cu}^{+} \alpha_{cv}^{+} 
(A_{uv}^{+}-\frac{k_{u}^{+}k_{v}^{+}}{2m})-
(\frac{2w^{-}}{2w^{+}+2w^{-}})(\frac{1}{2m^{-}}) \sum_{c\epsilon_C} \sum_{u,v\epsilon_V} \alpha_{cu}^{-} \alpha_{cv}^{-} 
(A_{uv}^{-}-\frac{k_{u}^{-}k_{v}^{-}}{2m})</code>
</p>

<p>where the sign + indicates positive edge weights and the sign - indicates negative edge weights, respectively.
</p>


<h3>Value</h3>

<p>A numeric scalar, the fuzzy modularity score for signed weighted networks of the given configuration.
</p>


<h3>Author(s)</h3>

<p>Pedro Henrique Ribeiro Santiago, <a href="mailto:phrs16@gmail.com">phrs16@gmail.com</a> [ctb]
</p>
<p>Gustavo Hermes Soares, [rev]
</p>
<p>Adrian Quintero, [rev]
</p>
<p>Lisa Jamieson, [rev]
</p>


<h3>References</h3>

<p>Gomez, S., Jensen, P., &amp; Arenas, A. (2009). Analysis of community structure in networks of correlated data. 
<em>Physical review E</em>, 80(1), 016114.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FuzzyMod">FuzzyMod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>`%du%` &lt;- igraph::`%du%` 
g &lt;- igraph::make_full_graph(6) %du% igraph::make_full_graph(6)
g &lt;- igraph::add_edges(g, c(1,7, 2,8))
edges &lt;- rep(1,32)
edges[31] &lt;- -1
igraph::E(g)$weight &lt;- edges
plot(g, edge.label=round(igraph::E(g)$weight, 3))
wc &lt;- list(c(1,2,3,4,5,6),c(7,8,9,10,11,12))
SignedFuzzyMod(netinput=g, membassigned=wc)

</code></pre>

<hr>
<h2 id='summary.cpAlgorithm'>summary.cpAlgorithm</h2><span id='topic+summary.cpAlgorithm'></span>

<h3>Description</h3>

<p>Summary method for objects of class <code>cpAlgorithm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpAlgorithm'
summary(
  object,
  details = c("communities.labels", "shared.nodes.labels", "isolated.nodes.labels"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.cpAlgorithm_+3A_object">object</code></td>
<td>
<p>An object of class <code>cpAlgorithm</code>; see also
<a href="#topic+cpAlgorithm">cpAlgorithm</a></p>
</td></tr>
<tr><td><code id="summary.cpAlgorithm_+3A_details">details</code></td>
<td>
<p>A string or vector indicating about which part of
the results more information is requested; default is
<code>c("communities.labels","shared.nodes.labels","isolated.nodes.labels")</code>;
see Details</p>
</td></tr>
<tr><td><code id="summary.cpAlgorithm_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function extracts information from an object produced by <code>cpAlgorithm</code>.
To do so, the user has to specify in <code>details</code> which information is requested.
It is possible to extract information about the communities with either
numbers (<code>communities.numbers</code>) or labels (<code>communities.labels</code>)
as identifiers of the nodes. Moreover, it is possible to extract information about
shared nodes with either numbers (<code>shared.nodes.numbers</code>) or labels
(<code>shared.nodes.labels</code>) as identifiers of the nodes. Finally, it is possible
to extract information about isolated nodes with either numbers
(<code>isolated.nodes.numbers</code>) or labels (<code>isolated.nodes.labels</code>)
as identifiers of the nodes. Any combination of these options can be specified
in <code>details</code>.
</p>


<h3>Value</h3>

<p>Prints information depending on <code>details</code>.
</p>


<h3>Author(s)</h3>

<p>Jens Lange, <a href="mailto:lange.jens@outlook.com">lange.jens@outlook.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example for unweighted networks

# create qgraph object
W &lt;- matrix(c(0,1,1,1,0,0,0,0,
              0,0,1,1,0,0,0,0,
              0,0,0,0,0,0,0,0,
              0,0,0,0,1,1,1,0,
              0,0,0,0,0,1,1,0,
              0,0,0,0,0,0,1,0,
              0,0,0,0,0,0,0,1,
              0,0,0,0,0,0,0,0), nrow = 8, ncol = 8, byrow = TRUE)
colnames(W) &lt;- letters[1:8]
rownames(W) &lt;- letters[1:8]
W &lt;- Matrix::forceSymmetric(W)
W &lt;- qgraph::qgraph(W)

# run clique percolation for unweighted networks
results &lt;- cpAlgorithm(W = W, k = 3, method = "unweighted")

# print results overview
results

# extract details about the communities
summary(results, details = "communities.labels")

# extract information about shared and isolated nodes
summary(results, details = c("shared.nodes.numbers", "isolated.nodes.labels"))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
