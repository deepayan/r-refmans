<!DOCTYPE html><html><head><title>Help for package SEI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SEI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aggregate_xts'><p>Aggregate values in xts objects</p></a></li>
<li><a href='#data_supply'><p>Time series of wind and solar energy production</p></a></li>
<li><a href='#data_wind_de'><p>Time series of average wind speed in Germany</p></a></li>
<li><a href='#fit_dist'><p>Fit a distribution to data</p></a></li>
<li><a href='#get_drought'><p>Get drought characteristics</p></a></li>
<li><a href='#get_pit'><p>Calculate probability integral transform values</p></a></li>
<li><a href='#plot_sei'><p>Plot standardised indices</p></a></li>
<li><a href='#std_index'><p>Calculate standardised indices</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Calculating Standardised Indices</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Convert a time series of observations to a time series of standardised indices that can be used to monitor variables on a common and probabilistically interpretable scale. The indices can be aggregated and rescaled to different time scales, visualised using plot capabilities, and calculated using a range of distributions. This includes flexible non- and semi-parametric methods, as suggested by Allen and Otero (2023) &lt;<a href="https://doi.org/10.1016%2Fj.renene.2023.119206">doi:10.1016/j.renene.2023.119206</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/noeliaof/SEI">https://github.com/noeliaof/SEI</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, xts, zoo, fitdistrplus</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, lubridate, dplyr, gridExtra, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-26 15:59:17 UTC; sa20i493</td>
</tr>
<tr>
<td>Author:</td>
<td>Sam Allen [aut, cre],
  Noelia Otero [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sam Allen &lt;sam.allen@unibe.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-26 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aggregate_xts'>Aggregate values in xts objects</h2><span id='topic+aggregate_xts'></span>

<h3>Description</h3>

<p>Inputs an xts time series and outputs an xts time series whose
values have been aggregated over a moving window of a user-specified length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregate_xts(
  x,
  len,
  scale = c("days", "hours", "weeks", "quarters", "years"),
  fun = "sum",
  timescale = c("days", "hours", "weeks", "quarters", "years"),
  na_thres = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate_xts_+3A_x">x</code></td>
<td>
<p>xts object to be aggregated.</p>
</td></tr>
<tr><td><code id="aggregate_xts_+3A_len">len</code></td>
<td>
<p>length of the aggregation period.</p>
</td></tr>
<tr><td><code id="aggregate_xts_+3A_scale">scale</code></td>
<td>
<p>timescale of the aggregation period, default is 'days'.</p>
</td></tr>
<tr><td><code id="aggregate_xts_+3A_fun">fun</code></td>
<td>
<p>function to apply to the aggregated data, default is 'sum'.</p>
</td></tr>
<tr><td><code id="aggregate_xts_+3A_timescale">timescale</code></td>
<td>
<p>timescale of <code>x</code>, default is 'days'.</p>
</td></tr>
<tr><td><code id="aggregate_xts_+3A_na_thres">na_thres</code></td>
<td>
<p>threshold for the percentage of NA values allowed in the
aggregation period, default = 10.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This has been adapted from code available at
<a href="https://github.com/WillemMaetens/standaRdized">https://github.com/WillemMaetens/standaRdized</a>.
</p>
<p><code>len</code> is a single numeric value specifying over how many time units the
data <code>x</code> is to be aggregated. By default, <code>len</code> is assumed to correspond
to a number of days, but this can also be specified manually using the argument
<code>scale</code>. <code>scale</code> must be one of: &quot;days&quot;, &quot;weeks&quot;, &quot;months&quot;, &quot;quarters&quot;, and &quot;years&quot;.
</p>
<p><code>fun</code> determines the function used to aggregate the time series. By default,
<code>fun = "sum"</code>, meaning the aggregation results in accumulations over the
aggregation period. Alternative functions can also be used. For example, specifying
<code>fun = "mean"</code> would return the mean over the aggregation period.
</p>
<p><code>timescale</code> is the timescale of the input data <code>x</code>. By default, this
is assumed to be &quot;days&quot;.
</p>
<p>Since the time series <code>x</code> aggregates data over the aggregation period, problems
may arise when <code>x</code> contains missing values. For example, if interest is
on daily accumulations, but 50% of the values in the aggregation period are missing,
the accumulation over this aggregation period will not be accurate.
This can be controlled using the argument <code>na_thres</code>.
<code>na_thres</code> specifies the percentage of NA values in the aggregation period
before a NA value is returned. i.e. the proportion of values that are allowed to be missing.
The default is <code>na_thres = 10</code>.
</p>


<h3>Value</h3>

<p>An xts time series with aggregated values.
</p>


<h3>Author(s)</h3>

<p>Sam Allen, Noelia Otero
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(data_supply, package = "SEI")
# consider hourly German energy production data in 2019
supply_de &lt;- subset(data_supply, country == "Germany", select = c("date", "PWS"))
supply_de &lt;- xts::xts(supply_de$PWS, order.by = supply_de$date)

# daily accumulations
supply_de_daily &lt;- aggregate_xts(supply_de, len = 1, timescale = "hours")

# weekly means
supply_de_weekly &lt;- aggregate_xts(supply_de, len = 1, scale = "weeks", fun = "mean", "hours")

plot(supply_de, main = "Hourly energy production in Germany")
plot(supply_de_daily, main = "Daily energy production in Germany")
plot(supply_de_weekly, main = "Weekly energy production in Germany")



</code></pre>

<hr>
<h2 id='data_supply'>Time series of wind and solar energy production</h2><span id='topic+data_supply'></span>

<h3>Description</h3>

<p>This dataset contains hourly time series of wind and solar energy production
in 27 European countries in 2019.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("data_supply")
</code></pre>


<h3>Format</h3>

<p>An object of type <code>data.frame</code> containing 3 variables:
</p>

<dl>
<dt>date</dt><dd><p>A <code>POSIXct</code> series of times at which energy production
is available.</p>
</dd>
<dt>country</dt><dd><p>The country to which the energy production measurement corresponds.</p>
</dd>
<dt>PWS</dt><dd><p>The hourly wind and solar energy production for the corresponding time and country.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The dataframe <code>data_supply</code> contains 236520 (24 x 365 x 27) rows, containing the wind
and solar energy production for each hour in 2019 for each of the 27 countries.
</p>
<p>This corresponds to a subset of the data used in Bloomfield and Brayshaw. (2021),
which can be accessed at https://researchdata.reading.ac.uk/321/.
Users are referred to this paper for further details.
</p>


<h3>References</h3>

<p>Bloomfield, Hannah and Brayshaw, David (2021):
ERA5 derived time series of European aggregated surface weather variables, wind power, and solar power capacity factors: hourly data from 1950-2020.
<a href="https://doi.org/10.17864/1947.000321">doi:10.17864/1947.000321</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("data_supply")
</code></pre>

<hr>
<h2 id='data_wind_de'>Time series of average wind speed in Germany</h2><span id='topic+data_wind_de'></span>

<h3>Description</h3>

<p>This dataset contains a daily time series of average wind speeds across Germany between 1979 and 2019.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("data_wind_de")
</code></pre>


<h3>Format</h3>

<p>An object of type <code>data.frame</code> containing 2 variables:
</p>

<dl>
<dt>date</dt><dd><p>A <code>POSIXct</code> series of times at which average wind speeds are available.</p>
</dd>
<dt>wsmean</dt><dd><p>The average wind speed in Germany for the corresponding time.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The dataframe <code>data_wind_de</code> contains 14975 (365 x 41 + 10) rows, containing the
daily average wind speed in Germany for 41 years between 1979 and 2019. Ten leap
years occur within this period.
</p>
<p>This corresponds to a subset of the data that is publicly available at
https://cds.climate.copernicus.eu/cdsapp#!/dataset/reanalysis-era5-pressure-levels?tab=overview.
Users are referred to the reference below for further details.
</p>


<h3>References</h3>

<p>Hersbach, H et al. (2023):
ERA5 hourly data on single levels from 1940 to present. Copernicus Climate Change Service (C3S) Climate Data Store (CDS)
<a href="https://doi.org/10.24381/cds.adbb2d47">doi:10.24381/cds.adbb2d47</a>
Accessed 01-09-2022.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("wind_de")
</code></pre>

<hr>
<h2 id='fit_dist'>Fit a distribution to data</h2><span id='topic+fit_dist'></span>

<h3>Description</h3>

<p>Function to fit a specified distribution a vector of data. Returns
the estimated distribution and relevant goodness-of-fit statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_dist(data, dist, n_thres = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_dist_+3A_data">data</code></td>
<td>
<p>vector of data</p>
</td></tr>
<tr><td><code id="fit_dist_+3A_dist">dist</code></td>
<td>
<p>character string specifying the distribution, see details</p>
</td></tr>
<tr><td><code id="fit_dist_+3A_n_thres">n_thres</code></td>
<td>
<p>number of data points required to estimate the distribution</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This has been adapted from code available at
<a href="https://github.com/WillemMaetens/standaRdized">https://github.com/WillemMaetens/standaRdized</a>.
</p>
<p><code>data</code> is a numeric vector of data from which the distribution is to be estimated.
</p>
<p><code>dist</code> is the specified distribution to be fit to <code>data</code>. This must be one of
'empirical' (the empirical distribution given <code>data</code>), 'kde' (kernel density estimation),
'norm', 'lnorm', 'logis', 'llogis', 'exp', 'gamma', and 'weibull'.
</p>
<p>By default, <code>dist = "empirical"</code>, in which case
the distribution is estimated empirically from <code>data</code>. This is only
recommended if there are at least 100 values in <code>data</code>, and a warning
message is returned otherwise.
</p>
<p><code>n_thres</code> is the minimum number of observations required to fit the distribution.
The default is <code>n_thres = 20</code>. If the number of values in <code>data</code> is
smaller than <code>na_thres</code>, an error is returned. This guards against over-fitting,
which can result in distributions that do not generalise well out-of-sample.
</p>
<p>Where relevant, parameter estimation is performed using maximum likelihood
estimation.
</p>


<h3>Value</h3>

<p>A list containing the estimated distribution function, its parameters,
and Kolmogorov-Smirnov goodness-of-fit statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 1000
shape &lt;- 3
rate &lt;- 2


# gamma distribution
data &lt;- rgamma(N, shape, rate)
out &lt;- fit_dist(data, dist = "gamma")
hist(data, breaks = 30, probability = TRUE)
lines(seq(0, 10, 0.01), dgamma(seq(0, 10, 0.01), out$params[1], out$params[2]), col = "blue")


# weibull distribution
data &lt;- rweibull(N, shape, 1/rate)
out &lt;- fit_dist(data, dist = "weibull")
hist(data, breaks = 30, probability = TRUE)
lines(seq(0, 10, 0.01), dweibull(seq(0, 10, 0.01), out$params[1], out$params[2]), col = "blue")

</code></pre>

<hr>
<h2 id='get_drought'>Get drought characteristics</h2><span id='topic+get_drought'></span>

<h3>Description</h3>

<p>Extract characteristics of droughts from a time series of values. Drought characteristics
include the occurrence, intensity, magnitude, and duration of the drought.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_drought(x, thresholds = c(1.28, 1.64, 1.96), exceed = TRUE, lag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_drought_+3A_x">x</code></td>
<td>
<p>vector or xts object.</p>
</td></tr>
<tr><td><code id="get_drought_+3A_thresholds">thresholds</code></td>
<td>
<p>numeric vector containing thresholds to use when defining droughts.</p>
</td></tr>
<tr><td><code id="get_drought_+3A_exceed">exceed</code></td>
<td>
<p>logical; TRUE if a drought is defined when <code>x</code> is above the thresholds, FALSE otherwise.</p>
</td></tr>
<tr><td><code id="get_drought_+3A_lag">lag</code></td>
<td>
<p>logical; TRUE if the drought should end when the value changes sign.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A drought is assumed to be defined as an instance when the vector <code>x</code> exceeds
(if <code>exceed = TRUE</code>) or falls below (if <code>exceed = FALSE</code>) the specified
thresholds in <code>thresholds</code>.
</p>
<p><code>thresholds</code> can be a single value, or a vector of values. In the latter case,
each threshold is assumed to be a different level or intensity of the drought.
For example, if <code>thresholds = c(1, 1.5, 2)</code>, then a level 1 drought occurs
whenever <code>x</code> exceeds 1 but is lower than 1.5, a level 2 drought occurs
whenever <code>x</code> exceeds 1.5 but is lower than 2, and a level 3 drought occurs
whenever <code>x</code> exceeds 2.
</p>
<p>By default, <code>thresholds = c(1.28, 1.64, 1.96)</code>, which correspond to the
90th, 95th, and 97.5th percentiles of the standard normal distribution.
</p>
<p>In meteorology, droughts are typically defined in terms of
standardised indices, such as the standardised precipitation index (SPI).
It is sometimes the case that a drought event ends not when the variable of
interest no longer exceeds (or falls below) the relevant thresholds, but rather
when the index changes sign. This can help to account for fluctuations around
the threshold values, classing it as one long drought rather than several shorter
droughts. This definition can be used by specifying <code>lag = TRUE</code>.
</p>
<p><code>get_drought()</code> currently does not use the time series information in
the xts input, thereby assuming that the time series is complete, without missing
time periods. If <code>x</code> is a vector, rather than an xts object, then this
is also implicitly assumed.
</p>
<p>The output is a dataframe containing the vector <code>x</code>, a logical vector
specifying whether each value of <code>x</code> corresponds to a drought event,
and the magnitude of the drought. The magnitude of the drought is only shown
on the last day of the drought. This makes it easier to compute statistics about
the drought magnitude, such as the average drought magnitude.
If <code>thresholds</code> is a vector, the intensity or level of the drought is also returned.
</p>


<h3>Value</h3>

<p>A data frame containing the original values <code>x</code> and the corresponding drought characteristics.
</p>


<h3>Author(s)</h3>

<p>Sam Allen, Noelia Otero
</p>


<h3>References</h3>

<p>Allen, S. and N. Otero (2023):
&lsquo;Standardised indices to monitor energy droughts&rsquo;,
<em>Renewable Energy</em>
<a href="https://doi.org/10.1016/j.renene.2023.119206">doi:10.1016/j.renene.2023.119206</a>
</p>
<p>McKee, T. B., Doesken, N. J., &amp; Kleist, J. (1993):
&lsquo;The relationship of drought frequency and duration to time scales&rsquo;,
<em>In Proceedings of the 8th Conference on Applied Climatology</em> 17, 179-183.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data_supply)
# consider hourly German energy supply data in 2019
supply_de &lt;- subset(data_supply, country == "Germany", select = c("date", "PWS"))
supply_de &lt;- xts::xts(supply_de$PWS, order.by = supply_de$date)
supply_de_std &lt;- std_index(supply_de, timescale = "hours")

get_drought(supply_de_std, thresholds = c(-1, -1.5, -2), exceed = FALSE)

</code></pre>

<hr>
<h2 id='get_pit'>Calculate probability integral transform values</h2><span id='topic+get_pit'></span>

<h3>Description</h3>

<p>Function to estimate the cumulative distribution function (CDF)
from a set of observations, and return the corresponding probability integral
transform (PIT) values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pit(ref_data, new_data, dist = "empirical", return_fit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pit_+3A_ref_data">ref_data</code></td>
<td>
<p>numeric vector from which to estimate the CDF.</p>
</td></tr>
<tr><td><code id="get_pit_+3A_new_data">new_data</code></td>
<td>
<p>numeric vector from which to calculate the PIT values.</p>
</td></tr>
<tr><td><code id="get_pit_+3A_dist">dist</code></td>
<td>
<p>string; distribution used to estimate the CDF.</p>
</td></tr>
<tr><td><code id="get_pit_+3A_return_fit">return_fit</code></td>
<td>
<p>logical; return parameters and goodness-of-fit statistics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dist</code> specifies the distribution used to estimate the cumulative distribution
function of the observations. By default, <code>dist = "empirical"</code>, in which case
the CDF is estimated empirically from the values <code>ref_data</code>. This is only
recommended if there are at least 100 values in <code>ref_data</code>, and a warning
message is returned otherwise.
</p>
<p>Parametric distributions are more appropriate when there is relatively little data,
and good reason to expect that the data follows a particular distribution. To
check that the chosen parametric distribution is appropriate, the argument
<code>return_fit</code> can be used to return the estimated parameters of the
distribution, as well as Kolmogorov-Smirnov goodness-of-fit test statistics.
</p>
<p>A flexible compromise between using empirical methods and parametric distributions is to
use kernel density estimation, <code>dist = "kde"</code>.
</p>
<p><code>dist</code> must be one of: 'empirical' (the empirical distribution given <code>data</code>),
'kde' (kernel density estimation), norm', 'lnorm', 'logis', 'llogis', 'exp', 'gamma', and 'weibull'.
For the parametric distributions, parameters are estimated using maximum likelihood estimation.
</p>


<h3>Value</h3>

<p>A vector of PIT values if return_fit = F, or, if return_fit = T, a list containing
the estimated CDF (<code>F_x</code>), the corresponding parameters (<code>params</code>), and
properties of the fit (<code>fit_props</code>).
</p>


<h3>Author(s)</h3>

<p>Sam Allen, Noelia Otero
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 1000
shape &lt;- 3
rate &lt;- 2

x_ref &lt;- rgamma(N, shape, rate)
x_new &lt;- rgamma(N, shape, rate)

# empirical distribution
pit &lt;- get_pit(x_ref, x_new)
hist(pit)

# gamma distribution
pit &lt;- get_pit(x_ref, x_new, dist = "gamma", return_fit = TRUE)
hist(pit$pit)

hist(x_ref, breaks = 30, probability = TRUE)
lines(seq(0, 10, 0.01), dgamma(seq(0, 10, 0.01), pit$params[1], pit$params[2]), col = "blue")


# weibull distribution
pit &lt;- get_pit(x_ref, x_new, dist = "weibull", return_fit = TRUE)
hist(pit$pit)

hist(x_ref, breaks = 30, probability = TRUE)
lines(seq(0, 10, 0.01), dweibull(seq(0, 10, 0.01), pit$params[1], pit$params[2]), col = "blue")


# exponential distribution
pit &lt;- get_pit(x_ref, x_new, dist = "exp", return_fit = TRUE)
hist(pit$pit)

hist(x_ref, breaks = 30, probability = TRUE)
lines(seq(0, 10, 0.01), dexp(seq(0, 10, 0.01), pit$params[1]), col = "blue")


</code></pre>

<hr>
<h2 id='plot_sei'>Plot standardised indices</h2><span id='topic+plot_sei'></span>

<h3>Description</h3>

<p>Plot a time series containing standardised indices, or a histogram
of the indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_sei(
  x,
  type = c("ts", "hist", "bar"),
  title = NULL,
  lab = "Std. Index",
  xlims = NULL,
  ylims = NULL,
  n_bins = 30
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_sei_+3A_x">x</code></td>
<td>
<p>vector or xts object containing the indices to be plotted.</p>
</td></tr>
<tr><td><code id="plot_sei_+3A_type">type</code></td>
<td>
<p>type of plot (either time series &quot;ts&quot;, histogram &quot;hist&quot;, or barplot &quot;bar&quot;).</p>
</td></tr>
<tr><td><code id="plot_sei_+3A_title">title</code></td>
<td>
<p>optional title of the plot.</p>
</td></tr>
<tr><td><code id="plot_sei_+3A_lab">lab</code></td>
<td>
<p>axis label.</p>
</td></tr>
<tr><td><code id="plot_sei_+3A_xlims">xlims</code>, <code id="plot_sei_+3A_ylims">ylims</code></td>
<td>
<p>lower and upper limits of the axes.</p>
</td></tr>
<tr><td><code id="plot_sei_+3A_n_bins">n_bins</code></td>
<td>
<p>the number of bins to show in the histogram.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot_sei()</code> function can be used to plot either a time series (if <code>type = "ts"</code>)
or a histogram (if <code>type = "hist"</code> or <code>type = "bar"</code>) of the values in <code>x</code>.
</p>
<p>A time series can only be displayed if <code>x</code> is an <span class="pkg">xts</span> time series.
</p>
<p>The argument <code>lab</code> is a string containing the label of the x-axis if
<code>type = "hist"</code> or <code>type = "bar"</code> and the y-axis if <code>type = "ts"</code>.
</p>
<p>The options <code>type = "hist"</code> and <code>type = "bar"</code> both display histograms
of the data <code>x</code>. With <code>type = "hist"</code>, <code>plot_sei()</code> is essentially a
wrapper of <code>geom_histogram()</code>, while <code>type = "bar"</code> is a wrapper of
<code>geom_bar()</code>. The latter can provide more flexibility when plotting bounded data,
whereas the former is easier to use when superimposing densities on top.
</p>


<h3>Value</h3>

<p>A ggplot object displaying the standardised index values.
</p>


<h3>Author(s)</h3>

<p>Sam Allen, Noelia Otero
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data_supply)
# consider hourly German energy supply data in 2019
supply_de &lt;- subset(data_supply, country == "Germany", select = c("date", "PWS"))
supply_de &lt;- xts::xts(supply_de$PWS, order.by = supply_de$date)
supply_de_std &lt;- std_index(supply_de, timescale = "hours")

plot_sei(supply_de, title = "German renewable energy production in 2019")
plot_sei(supply_de_std, title = "German SREPI in 2019")

plot_sei(supply_de, type = "hist", title = "German renewable energy production in 2019")
plot_sei(supply_de_std, type = "hist", title = "German SREPI in 2019")

</code></pre>

<hr>
<h2 id='std_index'>Calculate standardised indices</h2><span id='topic+std_index'></span>

<h3>Description</h3>

<p>Inputs a time series of a chosen variable (e.g. precipitation,
energy demand, residual load etc.) and returns a time series of standardised indices.
Indices can be calculated on any timescale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>std_index(
  x_new,
  x_ref = x_new,
  timescale = NULL,
  dist = "empirical",
  return_fit = FALSE,
  moving_window = NULL,
  window_scale = NULL,
  agg_period = NULL,
  agg_scale = NULL,
  agg_fun = "sum",
  rescale = NULL,
  rescale_fun = "sum",
  index_type = "normal",
  ignore_na = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="std_index_+3A_x_new">x_new</code></td>
<td>
<p>numeric; vector or time series to be converted to standardised indices.</p>
</td></tr>
<tr><td><code id="std_index_+3A_x_ref">x_ref</code></td>
<td>
<p>numeric; vector or time series containing reference data to use when calculating the standardised indices.</p>
</td></tr>
<tr><td><code id="std_index_+3A_timescale">timescale</code></td>
<td>
<p>string; timescale of the data. Required if the time series is to be aggregated or rescaled.</p>
</td></tr>
<tr><td><code id="std_index_+3A_dist">dist</code></td>
<td>
<p>string; distribution used to calculate the indices.</p>
</td></tr>
<tr><td><code id="std_index_+3A_return_fit">return_fit</code></td>
<td>
<p>logical; return parameters and goodness-of-fit statistics for the distribution fit.</p>
</td></tr>
<tr><td><code id="std_index_+3A_moving_window">moving_window</code></td>
<td>
<p>numeric; length of moving window on which to calculate the indices.</p>
</td></tr>
<tr><td><code id="std_index_+3A_window_scale">window_scale</code></td>
<td>
<p>string; timescale of <code>moving_window</code>, default is the timescale of the data.</p>
</td></tr>
<tr><td><code id="std_index_+3A_agg_period">agg_period</code></td>
<td>
<p>numeric; the number of values to aggregate over.</p>
</td></tr>
<tr><td><code id="std_index_+3A_agg_scale">agg_scale</code></td>
<td>
<p>string; timescale of <code>agg_period</code>, default is the timescale of the data.</p>
</td></tr>
<tr><td><code id="std_index_+3A_agg_fun">agg_fun</code></td>
<td>
<p>string; function used to aggregate the data over the aggregation period, default is &quot;sum&quot;.</p>
</td></tr>
<tr><td><code id="std_index_+3A_rescale">rescale</code></td>
<td>
<p>string; the timescale that the time series should be rescaled to.</p>
</td></tr>
<tr><td><code id="std_index_+3A_rescale_fun">rescale_fun</code></td>
<td>
<p>string; function used to rescale the data, default is &quot;sum&quot;.</p>
</td></tr>
<tr><td><code id="std_index_+3A_index_type">index_type</code></td>
<td>
<p>string; the type of index: &quot;normal&quot; (default), &quot;probability&quot;, or &quot;bounded&quot;.</p>
</td></tr>
<tr><td><code id="std_index_+3A_ignore_na">ignore_na</code></td>
<td>
<p>logical; ignore NAs when rescaling the time series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Standardised indices are calculated by estimating the cumulative distribution function (CDF)
of the variable of interest, and using this to transform the measurements to
a standardised scale.
</p>
<p><code>std_index()</code> estimates the CDF using a time series of reference data <code>x_ref</code>,
and applies the resulting transformation to the time series <code>x_new</code>. The result is
a time series of standardised <code>x_new</code> values. These standardised indices quantify
how extreme the <code>x_new</code> values are in reference to <code>x_ref</code>.
<code>x_new</code> and <code>x_ref</code> should therefore contain values of the same variable.
If <code>x_ref</code> is not specified, then <code>x_new</code> is also used to estimate the CDF.
</p>
<p><code>x_new</code> and <code>x_ref</code> can either be provided as vectors or xts time series.
In the latter case, the time series can be aggregated across timescales or rescaled.
This is useful, for example, if <code>x_new</code> contains hourly data, but interest is
on daily accumulations or averages of the hourly data.
</p>
<p>The argument <code>rescale</code> converts the data to a different timescale. The original
timescale of the data can be manually specified using the argument <code>timescale</code>.
Otherwise, the function will try to automatically determine the timescale of the data.
Manually specifying the timescale of the data is generally more robust. The rescaling
is performed using the function <code>rescale_fun</code>. By default, this is assumed to be
<code>rescale_fun = "sum"</code>, so that values are added across the timescale of interest.
This can be changed to any user-specified function.
</p>
<p>The argument <code>agg_period</code> aggregates the data across the timescale of interest.
This differs from <code>rescale</code> in that the resolution of the data remains the same.
<code>agg_period</code> is a number specifying how long the data should be aggregated across.
By default, it is assumed that <code>agg_period</code> is on the same timescale as <code>x_new</code>
and <code>x_ref</code>. For example, if the data is hourly and <code>agg_period = 24</code>, then
this assumes the data is to be aggregated over the past 24 hours. The scale of the
aggregation period can also be specified manually using <code>agg_scale</code>. For example,
one could also specify <code>agg_period = 1</code> and <code>agg_scale = "days"</code>, and this
would also aggregate the data over the past day. <code>agg_fun</code> specifies how the
data is to be aggregated, the default is <code>agg_fun = "sum"</code>.
</p>
<p><code>timescale</code>, <code>agg_scale</code>, and <code>rescale</code> must all be one of: &quot;days&quot;,
&quot;weeks&quot;, &quot;months&quot;, &quot;quarters&quot;, and &quot;years&quot;.
</p>
<p><code>dist</code> is the distribution used to estimate the CDF from <code>x_ref</code>.
Currently, functionality is available to fit one of the following distributions to the data:
Normal ('norm'), Log-normal ('lnorm'), Logistic ('logis'), Log-logistic ('llogis'),
Exponential ('exp'), Gamma ('gamma'), and Weibull ('weibull').
Alternatively, the CDF can be estimated empirically (<code>dist = "empirical"</code>)
based on the values in <code>x_ref</code>, or using kernel density estimation (<code>dist = "kde"</code>).
</p>
<p>If <code>dist</code> is a parametric family of distributions, then parameters of the
distribution are estimated using maximum likelihood estimation from <code>x_ref</code>.
The resulting parameters and corresponding goodness-of-fit statistics can be
returned by specifying <code>return_fit = TRUE</code>.
</p>
<p>By default, the distribution is estimated over all values in <code>x_ref</code>. Alternatively,
if <code>x_new</code> is an xts object, parameters can be estimated sequentially using a
moving window of values. <code>moving_window</code> determines the length of the moving window.
This is a single value, assumed to be on the same timescale as <code>x_new</code>.
This can also be specified manually using <code>window_scale</code>. <code>window_scale</code>
must also be one of &quot;days&quot;, &quot;weeks&quot;, &quot;months&quot;, &quot;quarters&quot;, and &quot;years&quot;.
</p>
<p>The function returns a vector of time series (depending on the format of <code>x_new</code>)
containing the standardised indices corresponding to <code>x_new</code>. Three different
types of indices are available, which are explained in detail in the vignette.
The index type can be chosen using <code>index_type</code>, which must be one of
&quot;normal&quot; (default), &quot;probability&quot;, and &quot;bounded&quot;.
</p>


<h3>Value</h3>

<p>Time series of standardised indices.
</p>


<h3>Author(s)</h3>

<p>Sam Allen, Noelia Otero
</p>


<h3>References</h3>

<p>Allen, S. and N. Otero (2023):
&lsquo;Standardised indices to monitor energy droughts&rsquo;,
<em>Renewable Energy</em> 217, 119206
<a href="https://doi.org/10.1016/j.renene.2023.119206">doi:10.1016/j.renene.2023.119206</a>
</p>
<p>McKee, T. B., Doesken, N. J., &amp; Kleist, J. (1993):
&lsquo;The relationship of drought frequency and duration to time scales&rsquo;,
<em>In Proceedings of the 8th Conference on Applied Climatology</em> 17, 179-183.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data_supply)
# consider hourly German energy supply data in 2019
supply_de &lt;- subset(data_supply, country == "Germany", select = c("date", "PWS"))
supply_de &lt;- xts::xts(supply_de$PWS, order.by = supply_de$date)
#options(xts_check_TZ = FALSE)

# convert to hourly standardised indices
supply_de_std &lt;- std_index(supply_de, timescale = "hours")
hist(supply_de, main = "Raw values")
hist(supply_de_std, main = "Standardised values")

# convert to daily or weekly standardised indices
supply_de_std &lt;- std_index(supply_de, timescale = "hours", rescale = "days")

# convert to weekly standardised indices calculated on each day
supply_de_std &lt;- std_index(supply_de, timescale = "hours", rescale = "days",
                           agg_period = 1, agg_scale = "weeks")

# calculate standardised indices corresponding to December, based on the previous year
dec &lt;- zoo::index(supply_de) &gt; "2019-12-01 UTC"
supply_de_std_dec &lt;- std_index(x_new = supply_de[dec], x_ref = supply_de[!dec],
                               timescale = "hours")

# calculate standardised indices using a 100 day moving window
supply_de_std_dec &lt;- std_index(supply_de[dec], supply_de, timescale = "hours",
                               rescale = "days", moving_window = 100)

# suppose we are interested in the daily maximum rather than the daily total
supply_de_std &lt;- std_index(supply_de, timescale = "hours", rescale = "days",
                           rescale_fun = "max")
supply_de_std &lt;- std_index(supply_de, timescale = "hours", rescale = "days",
                           rescale_fun = "mean") # or average

# the default uses the empirical distribution, but this requires more data than
# parametric distributions, meaning it is not ideal when data is short, e.g. in weekly case
supply_de_std &lt;- std_index(supply_de, timescale = "hours", rescale = "weeks") # warning
# instead, we can use a parametric distribution, e.g. a gamma distribution
supply_de_std &lt;- std_index(supply_de, timescale = "hours", rescale = "weeks", dist = "gamma")
# we can check the fit by checking whether the indices resemble a standard normal distribution
hist(supply_de)
hist(supply_de_std)
# we can also look at the properties of the fit
supply_de_std &lt;- std_index(supply_de, timescale = "hours", rescale = "weeks",
                           dist = "gamma", return_fit = TRUE)

# we could also use kernel density estimation, which is a flexible compromise between the two
supply_de_std &lt;- std_index(supply_de, timescale = "hours", rescale = "weeks", dist = "kde")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
