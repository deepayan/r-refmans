<!DOCTYPE html><html><head><title>Help for package dclone</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dclone}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.dcFit'>
<p>Internal function for iterative model fitting with data cloning</p></a></li>
<li><a href='#bugs.fit'>
<p>Fit BUGS models with cloned data</p></a></li>
<li><a href='#bugs.parfit'>
<p>Parallel computing with WinBUGS/OpenBUGS</p></a></li>
<li><a href='#clusterSize'>
<p>Optimizing the number of workers</p></a></li>
<li><a href='#clusterSplitSB'>
<p>Size balancing</p></a></li>
<li><a href='#codaSamples'><p>Generate posterior samples in mcmc.list format</p></a></li>
<li><a href='#dc.fit'>
<p>Iterative model fitting with data cloning</p></a></li>
<li><a href='#dc.parfit'>
<p>Parallel model fitting with data cloning</p></a></li>
<li><a href='#dclone'>
<p>Cloning R objects</p></a></li>
<li><a href='#dclone-package'>
<p>Data Cloning</p></a></li>
<li><a href='#DcloneEnv'>
<p>Manipulating dclone environments</p></a></li>
<li><a href='#dcoptions'>
<p>Setting Options</p></a></li>
<li><a href='#dctable'>
<p>Retrieve descriptive statistics from fitted objects to</p>
evaluate convergence</a></li>
<li><a href='#errlines'>
<p>Plot error bars</p></a></li>
<li><a href='#evalParallelArgument'>
<p>Evaluates parallel argument</p></a></li>
<li><a href='#jags.fit'>
<p>Fit JAGS models with cloned data</p></a></li>
<li><a href='#jags.parfit'>
<p>Parallel computing with JAGS</p></a></li>
<li><a href='#jagsModel'><p>Create a JAGS model object</p></a></li>
<li><a href='#lambdamax.diag'>
<p>Data Cloning Diagnostics</p></a></li>
<li><a href='#make.symmetric'>
<p>Make a square matrix symmetric by averaging.</p></a></li>
<li><a href='#mclapplySB'>
<p>Size balancing version of mclapply</p></a></li>
<li><a href='#mcmc.list-methods'>
<p>Methods for the 'mcmc.list' class</p></a></li>
<li><a href='#mcmcapply'>
<p>Calculations on 'mcmc.list' objects</p></a></li>
<li><a href='#nclones'>
<p>Number of Clones</p></a></li>
<li><a href='#ovenbird'>
<p>Abundances of ovenbird in Alberta</p></a></li>
<li><a href='#pairs.mcmc.list'>
<p>Scatterplot Matrices for 'mcmc.list' Objects</p></a></li>
<li><a href='#parallel.inits'>
<p>Parallel RNGs for initial values</p></a></li>
<li><a href='#parCodaSamples'><p>Generate posterior samples in 'mcmc.list'</p>
format on parallel workers</a></li>
<li><a href='#parDosa'>
<p>Parallel wrapper function to call from within a function</p></a></li>
<li><a href='#parJagsModel'><p>Create a JAGS model object on parallel workers</p></a></li>
<li><a href='#parLoadModule'><p>Dynamically load JAGS modules on parallel workers</p></a></li>
<li><a href='#parSetFactory'><p>Advanced control over JAGS on parallel workers</p></a></li>
<li><a href='#parUpdate'><p>Update jags models on parallel workers</p></a></li>
<li><a href='#regmod'>
<p>Exemplary MCMC list object</p></a></li>
<li><a href='#stan.fit'>
<p>Fit Stan models with cloned data</p></a></li>
<li><a href='#update.mcmc.list'>
<p>Automatic updating of an MCMC object from JAGS</p></a></li>
<li><a href='#write.jags.model'>
<p>Write and remove model file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Data Cloning and MCMC Tools for Maximum Likelihood Methods</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-07-02</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Solymos [aut, cre] (&lt;https://orcid.org/0000-0001-7337-1740&gt;)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Solymos &lt;psolymos@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Low level functions for implementing
    maximum likelihood estimating procedures for
    complex models using data cloning and Bayesian
    Markov chain Monte Carlo methods
    as described in Solymos 2010 &lt;<a href="https://doi.org/10.32614%2FRJ-2010-011">doi:10.32614/RJ-2010-011</a>&gt;.
    Sequential and parallel MCMC support
    for 'JAGS', 'WinBUGS', 'OpenBUGS', and 'Stan'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.1), coda (&ge; 0.13), parallel, Matrix</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, rjags (&ge; 4-4), rstan, R2OpenBUGS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, lattice, R2WinBUGS, BRugs, rlecuyer</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>none, one or more of JAGS (&gt;= 3.0.0), WinBUGS (&gt;=
1.4), OpenBUGS (&gt;= 3.2.2), Stan</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://groups.google.com/forum/#!forum/dclone-users">https://groups.google.com/forum/#!forum/dclone-users</a>,
<a href="https://datacloning.org">https://datacloning.org</a>, <a href="https://github.com/datacloning/dclone">https://github.com/datacloning/dclone</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/datacloning/dclone/issues">https://github.com/datacloning/dclone/issues</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-03 02:03:48 UTC; Peter</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-03 07:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='.dcFit'>
Internal function for iterative model fitting with data cloning
</h2><span id='topic+.dcFit'></span>

<h3>Description</h3>

<p>This is the workhorse for <code><a href="#topic+dc.fit">dc.fit</a></code> and
<code><a href="#topic+dc.parfit">dc.parfit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.dcFit(data, params, model, inits, n.clones,
    multiply = NULL, unchanged = NULL,
    update = NULL, updatefun = NULL, initsfun = NULL,
    flavour = c("jags", "bugs", "stan"),
    n.chains=3, cl = NULL, parchains = FALSE,
    return.all=FALSE, check.nclones=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".dcFit_+3A_data">data</code></td>
<td>

<p>A named list (or environment) containing the data.
</p>
</td></tr>
<tr><td><code id=".dcFit_+3A_params">params</code></td>
<td>

<p>Character vector of parameters to be sampled.
It can be a list of 2 vectors, 1st element
is used as parameters to monitor, the 2nd is used
as parameters to use in calculating the data cloning
diagnostics.
</p>
</td></tr>
<tr><td><code id=".dcFit_+3A_model">model</code></td>
<td>

<p>Character string (name of the model file), a function containing
the model, or a <code><a href="#topic+custommodel">custommodel</a></code> object (see Examples).
</p>
</td></tr>
<tr><td><code id=".dcFit_+3A_inits">inits</code></td>
<td>

<p>Optional specification of initial values in the form of a list or a
function (see Initialization at <code><a href="rjags.html#topic+jags.model">jags.model</a></code>).
If missing, will be treated as <code>NULL</code> and initial values will
be generated automatically.
</p>
</td></tr>
<tr><td><code id=".dcFit_+3A_n.clones">n.clones</code></td>
<td>

<p>An integer vector containing the numbers of clones to use iteratively.
</p>
</td></tr>
<tr><td><code id=".dcFit_+3A_multiply">multiply</code></td>
<td>

<p>Numeric or character index for list element(s) in the <code>data</code>
argument to be multiplied by the number of clones instead of repetitions.
</p>
</td></tr>
<tr><td><code id=".dcFit_+3A_unchanged">unchanged</code></td>
<td>

<p>Numeric or character index for list element(s) in the <code>data</code>
argument to be left unchanged.
</p>
</td></tr>
<tr><td><code id=".dcFit_+3A_update">update</code></td>
<td>

<p>Numeric or character index for list element(s) in the <code>data</code>
argument that has to be updated by <code>updatefun</code> in each iterations.
This usually is for making priors more informative, and enhancing
convergence. See Details and Examples.
</p>
</td></tr>
<tr><td><code id=".dcFit_+3A_updatefun">updatefun</code></td>
<td>

<p>A function to use for updating <code>data[[update]]</code>.
It should take an 'mcmc.list' object as 1st argument,
2nd argument can be the number of clones.
See Details and Examples.
</p>
</td></tr>
<tr><td><code id=".dcFit_+3A_initsfun">initsfun</code></td>
<td>

<p>A function to use for generating initial values, <code>inits</code> are
updated by the object
returned by this function from the second iteration. If initial values
are not dependent on the previous iteration, this should be <code>NULL</code>,
otherwise, it should take an 'mcmc.list' object as 1st argument,
2nd argument can be the number of clones.
This feature is useful if latent nodes are provided in <code>inits</code>
so it also requires to be cloned for subsequent iterations.
See Details and Examples.
</p>
</td></tr>
<tr><td><code id=".dcFit_+3A_flavour">flavour</code></td>
<td>

<p>If <code>"jags"</code>, the function <code><a href="#topic+jags.fit">jags.fit</a></code> is called.
If <code>"bugs"</code>, the function <code><a href="#topic+bugs.fit">bugs.fit</a></code> is called.
If <code>"stan"</code>, the function <code><a href="#topic+stan.fit">stan.fit</a></code> is called.
</p>
</td></tr>
<tr><td><code id=".dcFit_+3A_n.chains">n.chains</code></td>
<td>

<p>Number of chains to generate.
</p>
</td></tr>
<tr><td><code id=".dcFit_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>, or
an integer, see <code><a href="#topic+parDosa">parDosa</a></code> and
<code><a href="#topic+evalParallelArgument">evalParallelArgument</a></code>.
</p>
</td></tr>
<tr><td><code id=".dcFit_+3A_parchains">parchains</code></td>
<td>

<p>Logical, whether parallel chains should be run.
</p>
</td></tr>
<tr><td><code id=".dcFit_+3A_return.all">return.all</code></td>
<td>

<p>Logical. If <code>TRUE</code>, all the MCMC list objects corresponding to the sequence
<code>n.clones</code> are returned for further inspection
(this only works with <code>partype = "parchains"</code>). Otherwise only
the MCMC list corresponding to highest number of clones is returned
with summary statistics for the rest.
</p>
</td></tr>
<tr><td><code id=".dcFit_+3A_check.nclones">check.nclones</code></td>
<td>

<p>Logical, whether to check and ensure that values of <code>n.clones</code>
are unique and increasing. <code>check.nclones = FALSE</code> means that
<code>n.clones</code> is used as is, thus it is possible to supply
repeated values but still use the update functionality.
</p>
</td></tr>
<tr><td><code id=".dcFit_+3A_...">...</code></td>
<td>

<p>Other values supplied to <code><a href="#topic+jags.fit">jags.fit</a></code>, or
<code><a href="#topic+bugs.fit">bugs.fit</a></code>, depending on the <code>flavour</code> argument.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object inheriting from the class 'mcmc.list'.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a>,
implementation is based on many discussions
with Khurram Nadeem and Subhash Lele.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dc.fit">dc.fit</a></code>, <code><a href="#topic+dc.parfit">dc.parfit</a></code>
</p>

<hr>
<h2 id='bugs.fit'>
Fit BUGS models with cloned data
</h2><span id='topic+bugs.fit'></span><span id='topic+as.mcmc.list.bugs'></span>

<h3>Description</h3>

<p>Convenient functions designed to work well with 
cloned data arguments
and WinBUGS and OpenBUGS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bugs.fit(data, params, model, inits = NULL, n.chains = 3,
    format = c("mcmc.list", "bugs"), 
    program = c("winbugs", "openbugs", "brugs"), 
    seed, ...)
## S3 method for class 'bugs'
as.mcmc.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bugs.fit_+3A_data">data</code></td>
<td>

<p>A list (or environment) containing the data.
</p>
</td></tr>
<tr><td><code id="bugs.fit_+3A_params">params</code></td>
<td>

<p>Character vector of parameters to be sampled.
</p>
</td></tr>
<tr><td><code id="bugs.fit_+3A_model">model</code></td>
<td>

<p>Character string (name of the model file), a function containing 
the model, or a <code><a href="#topic+custommodel">custommodel</a></code> object (see Examples).
</p>
</td></tr>
<tr><td><code id="bugs.fit_+3A_inits">inits</code></td>
<td>

<p>Optional specification of initial values in the 
form of a list or a function. 
If <code>NULL</code>, initial values will be 
generated automatically.
</p>
</td></tr>
<tr><td><code id="bugs.fit_+3A_n.chains">n.chains</code></td>
<td>

<p>number of Markov chains.
</p>
</td></tr>
<tr><td><code id="bugs.fit_+3A_format">format</code></td>
<td>

<p>Required output format.
</p>
</td></tr>
<tr><td><code id="bugs.fit_+3A_program">program</code></td>
<td>

<p>The program to use, not case sensitive.
<code>winbugs</code> calls the function <code><a href="R2WinBUGS.html#topic+bugs">bugs</a></code> from
package <span class="pkg">R2WinBUGS</span>,
<code>openbugs</code> calls the function <code><a href="R2OpenBUGS.html#topic+bugs">bugs</a></code> 
from package <span class="pkg">R2OpenBUGS</span> (this has changed since <span class="pkg">dclone</span>
version 1.8-1, this is now the preferred OpenBUGS interface).
<code>brugs</code> calls the function <code><a href="R2WinBUGS.html#topic+openbugs">openbugs</a></code> 
from package <span class="pkg">R2WinBUGS</span> and requires the CRAN package <span class="pkg">BRugs</span>
(this is provided for back compatibility purposes, but gives a warning
because it is not the preferred interface to R2OpenBUGS).
</p>
</td></tr>
<tr><td><code id="bugs.fit_+3A_seed">seed</code></td>
<td>

<p>Random seed (<code>bugs.seed</code> argument for 
<code><a href="R2WinBUGS.html#topic+bugs">bugs</a></code> in package <span class="pkg">R2WinBUGS</span> or 
<code><a href="R2OpenBUGS.html#topic+bugs">bugs</a></code> in package <span class="pkg">R2OpenBUGS</span>, 
<code>seed</code> argument for <code><a href="R2WinBUGS.html#topic+openbugs">openbugs</a></code>).
It takes the corresponding default values (<code>NULL</code> or <code>1</code>)
when missing.
</p>
</td></tr>
<tr><td><code id="bugs.fit_+3A_x">x</code></td>
<td>

<p>A fitted 'bugs' object.
</p>
</td></tr>
<tr><td><code id="bugs.fit_+3A_...">...</code></td>
<td>

<p>Further arguments of the <code><a href="R2WinBUGS.html#topic+bugs">bugs</a></code> function,
except for <code>codaPkg</code> are passed also, most notably 
the ones to set up burn-in, thin, etc. (see Details).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, an <code>mcmc.list</code> object. If data cloning is used via the 
<code>data</code> argument, <code>summary</code> returns a modified summary
containing scaled data cloning standard errors 
(scaled by <code>sqrt(n.clones)</code>), and
<code class="reqn">R_{hat}</code> values (as returned by <code><a href="coda.html#topic+gelman.diag">gelman.diag</a></code>).
</p>
<p><code>bugs.fit</code> can return a <code>bugs</code> object if 
<code>format = "bugs"</code>.
In this case, summary is not changed, but the number of clones 
used is attached as attribute
and can be retrieved by the function <code><a href="#topic+nclones">nclones</a></code>.
</p>
<p>The function <code>as.mcmc.list.bugs</code> converts a 'bugs' object
into 'mcmc.list' and retrieves
data cloning information as well.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a>
</p>


<h3>See Also</h3>

<p>Underlying functions: 
<code><a href="R2WinBUGS.html#topic+bugs">bugs</a></code> in package <span class="pkg">R2WinBUGS</span>,
<code><a href="R2WinBUGS.html#topic+openbugs">openbugs</a></code> in package <span class="pkg">R2WinBUGS</span>,
<code><a href="R2OpenBUGS.html#topic+bugs">bugs</a></code> in package <span class="pkg">R2OpenBUGS</span>
</p>
<p>Methods: <code><a href="#topic+dcsd">dcsd</a></code>, <code><a href="#topic+confint.mcmc.list.dc">confint.mcmc.list.dc</a></code>, 
<code><a href="#topic+coef.mcmc.list">coef.mcmc.list</a></code>, <code><a href="#topic+quantile.mcmc.list">quantile.mcmc.list</a></code>, 
<code><a href="#topic+vcov.mcmc.list.dc">vcov.mcmc.list.dc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## fitting with WinBUGS, bugs example
if (require(R2WinBUGS)) {
data(schools)
dat &lt;- list(J = nrow(schools), 
    y = schools$estimate, 
    sigma.y = schools$sd)
bugs.model &lt;- function(){
       for (j in 1:J){
         y[j] ~ dnorm (theta[j], tau.y[j])
         theta[j] ~ dnorm (mu.theta, tau.theta)
         tau.y[j] &lt;- pow(sigma.y[j], -2)
       }
       mu.theta ~ dnorm (0.0, 1.0E-6)
       tau.theta &lt;- pow(sigma.theta, -2)
       sigma.theta ~ dunif (0, 1000)
     }  
inits &lt;- function(){
    list(theta=rnorm(nrow(schools), 0, 100), mu.theta=rnorm(1, 0, 100),
         sigma.theta=runif(1, 0, 100))
}
param &lt;- c("mu.theta", "sigma.theta")
if (.Platform$OS.type == "windows") {
sim &lt;- bugs.fit(dat, param, bugs.model, inits)
summary(sim)
}
dat2 &lt;- dclone(dat, 2, multiply="J")
if (.Platform$OS.type == "windows") {
sim2 &lt;- bugs.fit(dat2, param, bugs.model, 
    program="winbugs", n.iter=2000, n.thin=1)
summary(sim2)
}
}
if (require(BRugs)) {
## fitting the model with OpenBUGS
## using the less preferred BRugs interface
sim3 &lt;- bugs.fit(dat2, param, bugs.model, 
    program="brugs", n.iter=2000, n.thin=1)
summary(sim3)
}
if (require(R2OpenBUGS)) {
## fitting the model with OpenBUGS
## using the preferred R2OpenBUGS interface
sim4 &lt;- bugs.fit(dat2, param, bugs.model, 
    program="openbugs", n.iter=2000, n.thin=1)
summary(sim4)
}
if (require(rjags)) {
## fitting the model with JAGS
sim5 &lt;- jags.fit(dat2, param, bugs.model)
summary(sim5)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='bugs.parfit'>
Parallel computing with WinBUGS/OpenBUGS
</h2><span id='topic+bugs.parfit'></span>

<h3>Description</h3>

<p>Does the same job as <code><a href="#topic+bugs.fit">bugs.fit</a></code>,
but parallel chains are run on parallel workers, thus
computations can be faster (up to 1/<code>n.chains</code>) for long MCMC runs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bugs.parfit(cl, data, params, model, inits=NULL, n.chains = 3,
    seed, program=c("winbugs", "openbugs", "brugs"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bugs.parfit_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>, or
an integer, see <code><a href="#topic+parDosa">parDosa</a></code> and
<code><a href="#topic+evalParallelArgument">evalParallelArgument</a></code>.
</p>
</td></tr>
<tr><td><code id="bugs.parfit_+3A_data">data</code></td>
<td>

<p>A named list or environment containing the data. If an environment,
<code>data</code> is coerced into a list.
</p>
</td></tr>
<tr><td><code id="bugs.parfit_+3A_params">params</code></td>
<td>

<p>Character vector of parameters to be sampled.
</p>
</td></tr>
<tr><td><code id="bugs.parfit_+3A_model">model</code></td>
<td>

<p>Character string (name of the model file), a function
containing the model, or a or <code><a href="#topic+custommodel">custommodel</a></code>
object (see Examples).
</p>
</td></tr>
<tr><td><code id="bugs.parfit_+3A_inits">inits</code></td>
<td>

<p>Specification of initial values in the form of a
list or a function, can be missing.
If this is a function and using 'snow' type
cluster as <code>cl</code>, the function must be self containing, i.e.
not having references to R objects outside of the
function, or the objects should be exported with
<code><a href="parallel.html#topic+clusterExport">clusterExport</a></code> before calling <code>bugs.parfit</code>.
Forking type parallelism does not require such attention.
</p>
</td></tr>
<tr><td><code id="bugs.parfit_+3A_n.chains">n.chains</code></td>
<td>

<p>Number of chains to generate, must be higher than 1. Ideally,
this is equal to the number of parallel workers in the cluster.
</p>
</td></tr>
<tr><td><code id="bugs.parfit_+3A_seed">seed</code></td>
<td>

<p>Vector of random seeds, must have <code>n.chains</code> unique values.
See Details.
</p>
</td></tr>
<tr><td><code id="bugs.parfit_+3A_program">program</code></td>
<td>

<p>The program to use, not case sensitive. See <code><a href="#topic+bugs.fit">bugs.fit</a></code>.
</p>
</td></tr>
<tr><td><code id="bugs.parfit_+3A_...">...</code></td>
<td>

<p>Other arguments passed to <code><a href="#topic+bugs.fit">bugs.fit</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Chains are run on parallel workers,
and the results are combined in the end.
</p>
<p>The seed must be supplied, as it is the user's responsibility
to make sure that pseudo random sequences do not seriously
overlap.
</p>
<p>The WinBUGS implementation is quite unsafe from this regard,
because the pseudo-random number generator used by WinBUGS
generates a finite (albeit very long) sequence of distinct numbers,
which would eventually be repeated if the sampler
were run for a sufficiently long time.
Thus it's usage must be discouraged. That is the reason for the
warning that is issued when <code>program = "winbugs"</code>.
</p>
<p>OpenBUGS (starting from version 3.2.2) implemented a system
where internal state of the pseudo random number generator can be
set to one of 14 predefined states (seed values in <code>1:14</code>).
Each predefined state is 10^12 draws apart to avoid overlap in
pseudo random number sequences.
</p>
<p>Note: the default setting <code>working.directory = NULL</code> cannot be changed
when running parallel chains with <code>bugs.parfit</code> because
the multiple instances would try to read/write the same directory.
</p>


<h3>Value</h3>

<p>An <code>mcmc.list</code> object.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a>
</p>


<h3>See Also</h3>

<p>Sequential version: <code><a href="#topic+bugs.fit">bugs.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## fitting with WinBUGS, bugs example
if (require(R2WinBUGS)) {
data(schools)
dat &lt;- list(J = nrow(schools),
    y = schools$estimate,
    sigma.y = schools$sd)
bugs.model &lt;- function(){
       for (j in 1:J){
         y[j] ~ dnorm (theta[j], tau.y[j])
         theta[j] ~ dnorm (mu.theta, tau.theta)
         tau.y[j] &lt;- pow(sigma.y[j], -2)
       }
       mu.theta ~ dnorm (0.0, 1.0E-6)
       tau.theta &lt;- pow(sigma.theta, -2)
       sigma.theta ~ dunif (0, 1000)
     }
param &lt;- c("mu.theta", "sigma.theta")
SEED &lt;- floor(runif(3, 100000, 999999))
cl &lt;- makePSOCKcluster(3)
if (.Platform$OS.type == "windows") {
sim &lt;- bugs.parfit(cl, dat, param, bugs.model, seed=SEED)
summary(sim)
}
dat2 &lt;- dclone(dat, 2, multiply="J")
if (.Platform$OS.type == "windows") {
sim2 &lt;- bugs.parfit(cl, dat2, param, bugs.model,
    program="winbugs", n.iter=2000, n.thin=1, seed=SEED)
summary(sim2)
}
}
if (require(BRugs)) {
## fitting the model with OpenBUGS
## using the less preferred BRugs interface
sim3 &lt;- bugs.parfit(cl, dat2, param, bugs.model,
    program="brugs", n.iter=2000, n.thin=1, seed=1:3)
summary(sim3)
}
if (require(R2OpenBUGS)) {
## fitting the model with OpenBUGS
## using the preferred R2OpenBUGS interface
sim4 &lt;- bugs.parfit(cl, dat2, param, bugs.model,
    program="openbugs", n.iter=2000, n.thin=1, seed=1:3)
summary(sim4)
}
stopCluster(cl)
## multicore type forking
if (require(R2OpenBUGS) &amp;&amp; .Platform$OS.type != "windows") {
sim7 &lt;- bugs.parfit(3, dat2, param, bugs.model,
    program="openbugs", n.iter=2000, n.thin=1, seed=1:3)
summary(sim7)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='clusterSize'>
Optimizing the number of workers
</h2><span id='topic+clusterSize'></span><span id='topic+plotClusterSize'></span>

<h3>Description</h3>

<p>These functions help in optimizing workload for the workers 
if problems are of different size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterSize(size)
plotClusterSize(n, size, 
    balancing = c("none", "load", "size", "both"),
    plot = TRUE, col = NA, xlim = NULL, ylim = NULL, 
    main, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterSize_+3A_n">n</code></td>
<td>

<p>Number of workers.
</p>
</td></tr>
<tr><td><code id="clusterSize_+3A_size">size</code></td>
<td>

<p>Vector of problem sizes (recycled if needed).
The default <code>1</code> indicates equality of problem sizes.
</p>
</td></tr>
<tr><td><code id="clusterSize_+3A_balancing">balancing</code></td>
<td>

<p>Character, type of balancing to perform, one of 
<code>c("none", "load", "size", "both")</code>.
</p>
</td></tr>
<tr><td><code id="clusterSize_+3A_plot">plot</code></td>
<td>

<p>Logical, if a plot should be drawn.
</p>
</td></tr>
<tr><td><code id="clusterSize_+3A_col">col</code></td>
<td>

<p>Color of the polygons for work load pieces.
</p>
</td></tr>
<tr><td><code id="clusterSize_+3A_xlim">xlim</code>, <code id="clusterSize_+3A_ylim">ylim</code></td>
<td>

<p>Limits for the x and the y axis, respectively (optional).
</p>
</td></tr>
<tr><td><code id="clusterSize_+3A_main">main</code></td>
<td>

<p>Title of the plot, can be missing.
</p>
</td></tr>
<tr><td><code id="clusterSize_+3A_...">...</code></td>
<td>

<p>Other arguments passed to <code><a href="graphics.html#topic+polygon">polygon</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions help determine the optimal number of 
workers needed for different sized problems
('size' indicates approximate processing time here). 
The number of workers needed depends on the
type of balancing.
</p>
<p>For the description of the balancing types, see 
<code><a href="#topic+parDosa">parDosa</a></code>.
</p>


<h3>Value</h3>

<p><code>clusterSize</code> returns a data frame with approximate 
processing time as the function of
the number of workers (rows, in <code>1:length(size)</code>) and 
the type of balancing (<code>c("none", "load", "size", "both")</code>). 
Approximate processing time is calculated from values in <code>size</code>
without taking into account any communication overhead.
</p>
<p><code>plotClusterSize</code> invisibly returns the total 
processing time needed for a setting given
its arguments. As a side effect, a plot is produced 
(if <code>plot = TRUE</code>).
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## determine the number of workers needed
clusterSize(1:5)
## visually compare balancing options
opar &lt;- par(mfrow=c(2, 2))
plotClusterSize(2,1:5, "none")
plotClusterSize(2,1:5, "load")
plotClusterSize(2,1:5, "size")
plotClusterSize(2,1:5, "both")
par(opar)
</code></pre>

<hr>
<h2 id='clusterSplitSB'>
Size balancing
</h2><span id='topic+clusterSplitSB'></span><span id='topic+parLapplySB'></span><span id='topic+parLapplySLB'></span>

<h3>Description</h3>

<p>Functions for size balancing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterSplitSB(cl = NULL, seq, size = 1)
parLapplySB(cl = NULL, x, size = 1, fun, ...)
parLapplySLB(cl = NULL, x, size = 1, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterSplitSB_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>
the the package <span class="pkg">parallel</span>.
</p>
</td></tr>
<tr><td><code id="clusterSplitSB_+3A_x">x</code>, <code id="clusterSplitSB_+3A_seq">seq</code></td>
<td>

<p>A vector to split.
</p>
</td></tr>
<tr><td><code id="clusterSplitSB_+3A_fun">fun</code></td>
<td>

<p>A function or character string naming a function.
</p>
</td></tr>
<tr><td><code id="clusterSplitSB_+3A_size">size</code></td>
<td>

<p>Vector of problem sizes (approximate processing times)
corresponding to elements of <code>seq</code>
(recycled if needed). The default <code>1</code> indicates
equality of problem sizes.
</p>
</td></tr>
<tr><td><code id="clusterSplitSB_+3A_...">...</code></td>
<td>

<p>Other arguments of <code>fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>clusterSplitSB</code> splits <code>seq</code> into subsets,
with respect to <code>size</code>.
In size balancing, the problem is re-ordered from
largest to smallest, and then subsets are
determined by minimizing the total approximate processing time.
This splitting is deterministic (reproducible).
</p>
<p><code>parLapplySB</code> and <code>parLapplySLB</code> evaluates <code>fun</code>
on elements of <code>x</code> in parallel, similarly to
<code><a href="parallel.html#topic+parLapply">parLapply</a></code>. <code>parLapplySB</code>
uses size balancing (via <code>clusterSplitSB</code>).
<code>parLapplySLB</code> uses size and load balancing.
This means that the problem is re-ordered from largest to smallest,
and then undeterministic load balancing
is used (see <code><a href="parallel.html#topic+clusterApplyLB">clusterApplyLB</a></code>). If <code>size</code> is
correct, this is identical to size balancing.
This splitting is non-deterministic (might not be reproducible).
</p>


<h3>Value</h3>

<p><code>clusterSplitSB</code> returns a list of subsets
split with respect to <code>size</code>.
</p>
<p><code>parLapplySB</code> and <code>parLapplySLB</code> evaluates
<code>fun</code> on elements of <code>x</code>, and return a result
corresponding to <code>x</code>. Usually a list with results
returned by the cluster.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a>
</p>


<h3>See Also</h3>

<p>Related functions without size balancing:
<code><a href="parallel.html#topic+clusterSplit">clusterSplit</a></code>, <code><a href="parallel.html#topic+parLapply">parLapply</a></code>.
</p>
<p>Underlying functions: <code><a href="parallel.html#topic+clusterApply">clusterApply</a></code>,
<code><a href="parallel.html#topic+clusterApplyLB">clusterApplyLB</a></code>.
</p>
<p>Optimizing the number of workers: <code><a href="#topic+clusterSize">clusterSize</a></code>,
<code><a href="#topic+plotClusterSize">plotClusterSize</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
cl &lt;- makePSOCKcluster(2)
## equal sizes, same as clusterSplit(cl, 1:5)
clusterSplitSB(cl, 1:5)
## different sizes
clusterSplitSB(cl, 1:5, 5:1)
x &lt;- list(1, 2, 3, 4)
parLapplySB(cl, x, function(z) z^2, size=1:4)
stopCluster(cl)

## End(Not run)
</code></pre>

<hr>
<h2 id='codaSamples'>Generate posterior samples in mcmc.list format</h2><span id='topic+codaSamples'></span>

<h3>Description</h3>

<p>This function sets a trace
monitor for all requested nodes, updates the model and coerces the
output to a single <code>mcmc.list</code> object.
This function uses <code><a href="rjags.html#topic+coda.samples">coda.samples</a></code> but keeps track
of data cloning information supplied via the <code>model</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>codaSamples(model, variable.names, n.iter, thin = 1, na.rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="codaSamples_+3A_model">model</code></td>
<td>
<p>a jags model object</p>
</td></tr>
<tr><td><code id="codaSamples_+3A_variable.names">variable.names</code></td>
<td>
<p>a character vector giving the names of variables
to be monitored</p>
</td></tr>
<tr><td><code id="codaSamples_+3A_n.iter">n.iter</code></td>
<td>
<p>number of iterations to monitor</p>
</td></tr>
<tr><td><code id="codaSamples_+3A_thin">thin</code></td>
<td>
<p>thinning interval for monitors</p>
</td></tr>
<tr><td><code id="codaSamples_+3A_na.rm">na.rm</code></td>
<td>
<p>logical flag that indicates whether variables containing
missing values should be omitted. See details in help page
of <code><a href="rjags.html#topic+coda.samples">coda.samples</a></code>.</p>
</td></tr>
<tr><td><code id="codaSamples_+3A_...">...</code></td>
<td>
<p>optional arguments that are passed to the update method
for jags model objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>mcmc.list</code> object. An <code>n.clones</code> attribute is attached
to the object, but unlike in <code><a href="#topic+jags.fit">jags.fit</a></code> there is no
<code><a href="#topic+updated.model">updated.model</a></code> attribute as it is equivalent to the
input jags model object.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a></p>


<h3>See Also</h3>

<p><code><a href="rjags.html#topic+coda.samples">coda.samples</a></code>,
<code><a href="rjags.html#topic+update.jags">update.jags</a></code>,
<code><a href="rjags.html#topic+jags.model">jags.model</a></code>
</p>
<p>Parallel version: <code><a href="#topic+parCodaSamples">parCodaSamples</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
model &lt;- function() {
    for (i in 1:N) {
        Y[i] ~ dnorm(mu[i], tau)
        mu[i] &lt;- alpha + beta * (x[i] - x.bar)
    }
    x.bar &lt;- mean(x[])
    alpha ~ dnorm(0.0, 1.0E-4)
    beta ~ dnorm(0.0, 1.0E-4)
    sigma &lt;- 1.0/sqrt(tau)
    tau ~ dgamma(1.0E-3, 1.0E-3)
}
## data generation
set.seed(1234)
N &lt;- 100
alpha &lt;- 1
beta &lt;- -1
sigma &lt;- 0.5
x &lt;- runif(N)
linpred &lt;- crossprod(t(model.matrix(~x)), c(alpha, beta))
Y &lt;- rnorm(N, mean = linpred, sd = sigma)
jdata &lt;- dclone(list(N = N, Y = Y, x = x), 2, multiply="N")
jpara &lt;- c("alpha", "beta", "sigma")
## jags model
res &lt;- jagsModel(file=model, data=jdata, n.chains = 3, n.adapt=1000)
nclones(res)
update(res, n.iter=1000)
nclones(res)
m &lt;- codaSamples(res, jpara, n.iter=2000)
summary(m)
nclones(m)

## End(Not run)
</code></pre>

<hr>
<h2 id='dc.fit'>
Iterative model fitting with data cloning
</h2><span id='topic+dc.fit'></span>

<h3>Description</h3>

<p><code><a href="#topic+jags.fit">jags.fit</a></code> or <code><a href="#topic+bugs.fit">bugs.fit</a></code> is
iteratively used to fit a model with
increasing the number of clones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.fit(data, params, model, inits, n.clones,
    multiply = NULL, unchanged = NULL,
    update = NULL, updatefun = NULL, initsfun = NULL,
    flavour = c("jags", "bugs", "stan"), n.chains = 3,
    return.all=FALSE, check.nclones=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.fit_+3A_data">data</code></td>
<td>

<p>A named list (or environment) containing the data.
</p>
</td></tr>
<tr><td><code id="dc.fit_+3A_params">params</code></td>
<td>

<p>Character vector of parameters to be sampled.
It can be a list of 2 vectors, 1st element
is used as parameters to monitor, the 2nd is used
as parameters to use in calculating the data cloning
diagnostics.
</p>
</td></tr>
<tr><td><code id="dc.fit_+3A_model">model</code></td>
<td>

<p>Character string (name of the model file), a function containing
the model, or a <code><a href="#topic+custommodel">custommodel</a></code> object (see Examples).
</p>
</td></tr>
<tr><td><code id="dc.fit_+3A_inits">inits</code></td>
<td>

<p>Optional specification of initial values in the form of a list or a
function (see Initialization at <code><a href="rjags.html#topic+jags.model">jags.model</a></code>).
If missing, will be treated as <code>NULL</code> and initial values will
be generated automatically.
</p>
</td></tr>
<tr><td><code id="dc.fit_+3A_n.clones">n.clones</code></td>
<td>

<p>An integer vector containing the numbers of clones to use iteratively.
</p>
</td></tr>
<tr><td><code id="dc.fit_+3A_multiply">multiply</code></td>
<td>

<p>Numeric or character index for list element(s) in the <code>data</code>
argument to be multiplied by the number of clones instead of repetitions.
</p>
</td></tr>
<tr><td><code id="dc.fit_+3A_unchanged">unchanged</code></td>
<td>

<p>Numeric or character index for list element(s) in the <code>data</code>
argument to be left unchanged.
</p>
</td></tr>
<tr><td><code id="dc.fit_+3A_update">update</code></td>
<td>

<p>Character, the name of the list element(s) in the <code>data</code>
argument that has to be updated by <code>updatefun</code> in each iteration.
This usually is for making priors more informative, and enhancing
convergence. See Details and Examples.
</p>
</td></tr>
<tr><td><code id="dc.fit_+3A_updatefun">updatefun</code></td>
<td>

<p>A function to use for updating named elements in <code>data</code>.
It should take an 'mcmc.list' object as 1st argument,
2nd argument can be the number of clones.
If <code>legth(update) &gt; 1</code> the function must return a named list
so that <code>data[update]</code> can be updated.
See Details and Examples.
</p>
</td></tr>
<tr><td><code id="dc.fit_+3A_initsfun">initsfun</code></td>
<td>

<p>A function to use for generating initial values, <code>inits</code> are
updated by the object
returned by this function from the second iteration. If initial values
are not dependent on the previous iteration, this should be <code>NULL</code>,
otherwise, it should take an 'mcmc.list' object as 1st argument,
2nd argument can be the number of clones.
This feature is useful if latent nodes are provided in <code>inits</code>
so it also requires to be cloned for subsequent iterations.
See Details and Examples.
</p>
</td></tr>
<tr><td><code id="dc.fit_+3A_flavour">flavour</code></td>
<td>

<p>If <code>"jags"</code>, the function <code><a href="#topic+jags.fit">jags.fit</a></code> is called.
If <code>"bugs"</code>, the function <code><a href="#topic+bugs.fit">bugs.fit</a></code> is called.
If <code>"stan"</code>, the function <code><a href="#topic+stan.fit">stan.fit</a></code> is called.
</p>
</td></tr>
<tr><td><code id="dc.fit_+3A_n.chains">n.chains</code></td>
<td>

<p>Number of chains to generate.
</p>
</td></tr>
<tr><td><code id="dc.fit_+3A_return.all">return.all</code></td>
<td>

<p>Logical. If <code>TRUE</code>, all the MCMC list objects corresponding to the sequence
<code>n.clones</code> are returned for further inspection. Otherwise only
the MCMC list corresponding to highest number of clones is returned
with summary statistics for the rest.
</p>
</td></tr>
<tr><td><code id="dc.fit_+3A_check.nclones">check.nclones</code></td>
<td>

<p>Logical, whether to check and ensure that values of <code>n.clones</code>
are unique and increasing. <code>check.nclones = FALSE</code> means that
<code>n.clones</code> is used as is, thus it is possible to supply
repeated values but still use the update functionality.
</p>
</td></tr>
<tr><td><code id="dc.fit_+3A_...">...</code></td>
<td>

<p>Other values supplied to <code><a href="#topic+jags.fit">jags.fit</a></code>, or
<code><a href="#topic+bugs.fit">bugs.fit</a></code>, depending on the <code>flavour</code> argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function fits a JAGS/BUGS model with increasing numbers of clones,
as supplied by the argument <code>n.clones</code>. Data cloning is done by the
function <code>dclone</code> using
the arguments <code>multiply</code> and <code>unchanged</code>.
An updating function can be provided, see Examples.
</p>


<h3>Value</h3>

<p>An object inheriting from the class 'mcmc.list'.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a>,
implementation is based on many discussions
with Khurram Nadeem and Subhash Lele.
</p>


<h3>References</h3>

<p>Lele, S.R., B. Dennis and F. Lutscher, 2007.
Data cloning: easy maximum likelihood estimation for complex
ecological models using Bayesian Markov chain Monte Carlo  methods.
<em>Ecology Letters</em> <strong>10</strong>, 551&ndash;563.
</p>
<p>Lele, S. R., K. Nadeem and B. Schmuland, 2010.
Estimability and likelihood inference for generalized linear
mixed models using data cloning.
<em>Journal of the American Statistical Association</em>
<strong>105</strong>, 1617&ndash;1625.
</p>
<p>Solymos, P., 2010. dclone: Data Cloning in R.
<em>The R Journal</em> <strong>2(2)</strong>, 29&ndash;37.
URL: <a href="https://journal.r-project.org/archive/2010-2/RJournal_2010-2_Solymos.pdf">https://journal.r-project.org/archive/2010-2/RJournal_2010-2_Solymos.pdf</a>
</p>


<h3>See Also</h3>

<p>Data cloning: <code><a href="#topic+dclone">dclone</a></code>.
</p>
<p>Parallel computations: <code><a href="#topic+dc.parfit">dc.parfit</a></code>
</p>
<p>Model fitting: <code><a href="#topic+jags.fit">jags.fit</a></code>, <code><a href="#topic+bugs.fit">bugs.fit</a></code>
</p>
<p>Convergence diagnostics: <code><a href="#topic+dctable">dctable</a></code>, <code><a href="#topic+dcdiag">dcdiag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## simulation for Poisson GLMM
set.seed(1234)
n &lt;- 20
beta &lt;- c(2, -1)
sigma &lt;- 0.1
alpha &lt;- rnorm(n, 0, sigma)
x &lt;- runif(n)
X &lt;- model.matrix(~x)
linpred &lt;- crossprod(t(X), beta) + alpha
Y &lt;- rpois(n, exp(linpred))
## JAGS model as a function
jfun1 &lt;- function() {
    for (i in 1:n) {
        Y[i] ~ dpois(lambda[i])
        log(lambda[i]) &lt;- alpha[i] + inprod(X[i,], beta)
        alpha[i] ~ dnorm(0, 1/sigma^2)
    }
    for (j in 1:np) {
        beta[j] ~ dnorm(0, 0.001)
    }
    sigma ~ dlnorm(0, 0.001)
}
## data
jdata &lt;- list(n = n, Y = Y, X = X, np = NCOL(X))
## inits with latent variable and parameters
ini &lt;- list(alpha=rep(0,n), beta=rep(0, NCOL(X)))
## function to update inits
ifun &lt;- function(model, n.clones) {
    list(alpha=dclone(rep(0,n), n.clones),
        beta=coef(model)[-length(coef(model))])
}
## iteartive fitting
jmod &lt;- dc.fit(jdata, c("beta", "sigma"), jfun1, ini,
    n.clones = 1:5, multiply = "n", unchanged = "np",
    initsfun=ifun)
## summary with DC SE and R hat
summary(jmod)
dct &lt;- dctable(jmod)
plot(dct)
## How to use estimates to make priors more informative?
glmm.model.up &lt;- function() {
    for (i in 1:n) {
        Y[i] ~ dpois(lambda[i])
        log(lambda[i]) &lt;- alpha[i] + inprod(X[i,], beta[1,])
        alpha[i] ~ dnorm(0, 1/sigma^2)
    }
    for (j in 1:p) {
        beta[1,j] ~ dnorm(priors[j,1], priors[j,2])
    }
    sigma ~ dgamma(priors[(p+1),2], priors[(p+1),1])
}
## function for updating, x is an MCMC object
upfun &lt;- function(x) {
    if (missing(x)) {
        p &lt;- ncol(X)
        return(cbind(c(rep(0, p), 0.001), rep(0.001, p+1)))
    } else {
        par &lt;- coef(x)
        return(cbind(par, rep(0.01, length(par))))
    }
}
updat &lt;- list(n = n, Y = Y, X = X, p = ncol(X), priors = upfun())
dcmod &lt;- dc.fit(updat, c("beta", "sigma"), glmm.model.up,
    n.clones = 1:5, multiply = "n", unchanged = "p",
    update = "priors", updatefun = upfun)
summary(dcmod)
## time series example
## data and model taken from Ponciano et al. 2009
## Ecology 90, 356-362.
paurelia &lt;- c(17,29,39,63,185,258,267,392,510,
    570,650,560,575,650,550,480,520,500)
dat &lt;- list(ncl=1, n=length(paurelia), Y=dcdim(data.matrix(paurelia)))
beverton.holt &lt;- function() {
    for (k in 1:ncl) {
        for(i in 2:(n+1)){
            ## observations
            Y[(i-1), k] ~ dpois(exp(X[i, k]))
            ## state
            X[i, k] ~ dnorm(mu[i, k], 1 / sigma^2)
            mu[i, k] &lt;- X[(i-1), k] + log(lambda) - log(1 + beta * exp(X[(i-1), k]))
        }
        ## state at t0
        X[1, k] ~ dnorm(mu0, 1 / sigma^2)
    }
    # Priors on model parameters
    beta ~ dlnorm(-1, 1)
    sigma ~ dlnorm(0, 1)
    tmp ~ dlnorm(0, 1)
    lambda &lt;- tmp + 1
    mu0 &lt;- log(2)  + log(lambda) - log(1 + beta * 2)
}
mod &lt;- dc.fit(dat, c("lambda","beta","sigma"), beverton.holt,
    n.clones=c(1, 2, 5, 10), multiply="ncl", unchanged="n")
## compare with results from the paper:
##   beta   = 0.00235
##   lambda = 2.274
##   sigma  = 0.1274
summary(mod)

## Using WinBUGS/OpenBUGS
library(R2WinBUGS)
data(schools)
dat &lt;- list(J = nrow(schools), y = schools$estimate,
    sigma.y = schools$sd)
bugs.model &lt;- function(){
       for (j in 1:J){
         y[j] ~ dnorm (theta[j], tau.y[j])
         theta[j] ~ dnorm (mu.theta, tau.theta)
         tau.y[j] &lt;- pow(sigma.y[j], -2)
       }
       mu.theta ~ dnorm (0.0, 1.0E-6)
       tau.theta &lt;- pow(sigma.theta, -2)
       sigma.theta ~ dunif (0, 1000)
     }
inits &lt;- function(){
    list(theta=rnorm(nrow(schools), 0, 100), mu.theta=rnorm(1, 0, 100),
         sigma.theta=runif(1, 0, 100))
}
param &lt;- c("mu.theta", "sigma.theta")
if (.Platform$OS.type == "windows") {
sim2 &lt;- dc.fit(dat, param, bugs.model, n.clones=1:2,
    flavour="bugs", program="WinBUGS", multiply="J",
    n.iter=2000, n.thin=1)
summary(sim2)
}
sim3 &lt;- dc.fit(dat, param, bugs.model, n.clones=1:2,
    flavour="bugs", program="brugs", multiply="J",
    n.iter=2000, n.thin=1)
summary(sim3)
library(R2OpenBUGS)
sim4 &lt;- dc.fit(dat, param, bugs.model, n.clones=1:2,
    flavour="bugs", program="openbugs", multiply="J",
    n.iter=2000, n.thin=1)
summary(sim4)

## Using Stan
if (require(rstan)) {
    model &lt;- custommodel("data {
          int&lt;lower=0&gt; N;
          vector[N] y;
          vector[N] x;
        }
        parameters {
          real alpha;
          real beta;
          real&lt;lower=0&gt; sigma;
        }
        model {
          alpha ~ normal(0,10);
          beta ~ normal(0,10);
          sigma ~ cauchy(0,5);
          for (n in 1:N)
            y[n] ~ normal(alpha + beta * x[n], sigma);
        }")
    N &lt;- 100
    alpha &lt;- 1
    beta &lt;- -1
    sigma &lt;- 0.5
    x &lt;- runif(N)
    y &lt;- rnorm(N, alpha + beta * x, sigma)
    dat &lt;- list(N=N, y=y, x=x)
    params &lt;- c("alpha", "beta", "sigma")
    ## compile on 1st time only
    fit0 &lt;- stan.fit(dat, params, model)
    ## reuse compiled fit0
    dcfit &lt;- dc.fit(dat, params, model, n.clones=1:2,
        flavour="stan", multiply="N", fit=fit0)
    summary(dcfit)
    stan.model(dcfit)
    dcdiag(dcfit)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='dc.parfit'>
Parallel model fitting with data cloning
</h2><span id='topic+dc.parfit'></span>

<h3>Description</h3>

<p>Iterative model fitting on parallel workers with different
numbers of clones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.parfit(cl, data, params, model, inits, n.clones,
    multiply=NULL, unchanged=NULL,
    update = NULL, updatefun = NULL, initsfun = NULL,
    flavour = c("jags", "bugs", "stan"), n.chains = 3,
    partype=c("balancing", "parchains", "both"),
    return.all=FALSE, check.nclones=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.parfit_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>, or
an integer, see <code><a href="#topic+parDosa">parDosa</a></code> and
<code><a href="#topic+evalParallelArgument">evalParallelArgument</a></code>.
</p>
</td></tr>
<tr><td><code id="dc.parfit_+3A_data">data</code></td>
<td>

<p>A named list (or environment) containing the data.
</p>
</td></tr>
<tr><td><code id="dc.parfit_+3A_params">params</code></td>
<td>

<p>Character vector of parameters to be sampled.
It can be a list of 2 vectors, 1st element
is used as parameters to monitor, the 2nd is used
as parameters to use in calculating the data cloning
diagnostics. (<code>partype = "both"</code>
currently cannot handle <code>params</code> as list.)
</p>
</td></tr>
<tr><td><code id="dc.parfit_+3A_model">model</code></td>
<td>

<p>Character string (name of the model file), a function containing the
model, or a or <code><a href="#topic+custommodel">custommodel</a></code> object (see Examples).
</p>
</td></tr>
<tr><td><code id="dc.parfit_+3A_inits">inits</code></td>
<td>

<p>Optional specification of initial values in the form of a list
or a function (see Initialization at <code><a href="rjags.html#topic+jags.model">jags.model</a></code>).
If missing, will be treated as <code>NULL</code> and initial values
will be generated automatically.
If this is a function, it must be self containing, i.e. not
having references to R objects outside of the
function, or the objects should be exported with
<code><a href="parallel.html#topic+clusterExport">clusterExport</a></code> before calling <code>dc.parfit</code>.
</p>
</td></tr>
<tr><td><code id="dc.parfit_+3A_n.clones">n.clones</code></td>
<td>

<p>An integer vector containing the numbers of clones to use iteratively.
</p>
</td></tr>
<tr><td><code id="dc.parfit_+3A_multiply">multiply</code></td>
<td>

<p>Numeric or character index for list element(s) in the <code>data</code>
argument to be multiplied by the number of clones instead of repetitions.
</p>
</td></tr>
<tr><td><code id="dc.parfit_+3A_unchanged">unchanged</code></td>
<td>

<p>Numeric or character index for list element(s) in the <code>data</code>
argument to be left unchanged.
</p>
</td></tr>
<tr><td><code id="dc.parfit_+3A_update">update</code></td>
<td>

<p>Numeric or character index for list element(s) in the <code>data</code>
argument that has to be updated by <code>updatefun</code> in each iterations.
This usually is for making priors more informative, and enhancing
convergence.
This argument is ignored if size balancing is used (default), and not
ignored when multiple parallel chains are used.
</p>
</td></tr>
<tr><td><code id="dc.parfit_+3A_updatefun">updatefun</code></td>
<td>

<p>A function to use for updating <code>data[[update]]</code>.
It should take an 'mcmc.list' object as 1st argument,
2nd argument can be the number of clones.
This argument is ignored if size balancing is used (default), and not
ignored when multiple parallel chains are used.
</p>
</td></tr>
<tr><td><code id="dc.parfit_+3A_initsfun">initsfun</code></td>
<td>

<p>A function to use for generating initial values, <code>inits</code>
are updated by the object returned by this function from the
second iteration. If initial values
are not dependent on the previous iteration, this should be <code>NULL</code>,
otherwise, it should take an 'mcmc.list' object as 1st argument,
2nd argument can be the number of clones. This feature is useful if
latent nodes are provided in <code>inits</code>
so it also requires to be cloned for subsequent iterations.
The 1st argument of the <code>initsfun</code> function is ignored if
<code>partype != "parchains"</code> but the function must have a first
argument regardless,
see Examples.
</p>
</td></tr>
<tr><td><code id="dc.parfit_+3A_flavour">flavour</code></td>
<td>

<p>If <code>"jags"</code>, the function <code><a href="#topic+jags.fit">jags.fit</a></code> is called.
If <code>"bugs"</code>, the function <code><a href="#topic+bugs.fit">bugs.fit</a></code> is called
(available with <code>partype = "balancing"</code> only).
If <code>"stan"</code>, the function <code><a href="#topic+stan.fit">stan.fit</a></code> is called.
See Details.
</p>
</td></tr>
<tr><td><code id="dc.parfit_+3A_partype">partype</code></td>
<td>

<p>Type of parallel workload distribution, see Details.
</p>
</td></tr>
<tr><td><code id="dc.parfit_+3A_n.chains">n.chains</code></td>
<td>

<p>Number of chains to generate.
</p>
</td></tr>
<tr><td><code id="dc.parfit_+3A_return.all">return.all</code></td>
<td>

<p>Logical. If <code>TRUE</code>, all the MCMC list objects corresponding to the sequence
<code>n.clones</code> are returned for further inspection
(this only works with <code>partype = "parchains"</code>). Otherwise only
the MCMC list corresponding to highest number of clones is returned
with summary statistics for the rest.
</p>
</td></tr>
<tr><td><code id="dc.parfit_+3A_check.nclones">check.nclones</code></td>
<td>

<p>Logical, whether to check and ensure that values of <code>n.clones</code>
are unique and increasing. <code>check.nclones = FALSE</code> means that
<code>n.clones</code> is used as is, thus it is possible to supply
repeated values but still use the update functionality.
</p>
</td></tr>
<tr><td><code id="dc.parfit_+3A_...">...</code></td>
<td>

<p>Other values supplied to <code><a href="#topic+jags.fit">jags.fit</a></code>, or
<code><a href="#topic+bugs.fit">bugs.fit</a></code>, depending on the <code>flavour</code>
argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>dc.parfit</code> is a parallel computing version of
<code><a href="#topic+dc.fit">dc.fit</a></code>.
After parallel computations, temporary objects passed to workers and
the <span class="pkg">dclone</span> package is cleaned up. It is not guaranteed
that objects already on the workers and independently loaded packages
are not affected. Best to start new instances beforehand.
</p>
<p><code>partype="balancing"</code> distributes each model corresponding
to values in <code>n.clones</code> as jobs to workers according to size
balancing (see <code><a href="#topic+parDosa">parDosa</a></code>). <code>partype="parchains"</code>
makes repeated calls
to <code><a href="#topic+jags.parfit">jags.parfit</a></code> for each value in <code>n.clones</code>.
<code>partype="both"</code> also calls <code><a href="#topic+jags.parfit">jags.parfit</a></code> but
each chain of each cloned model is distributed as separate job to the
workers.
</p>
<p>The vector <code>n.clones</code> is used to determine size balancing.
If load balancing is also desired
besides of size balancing (e.g. due to unequal performance of
the workers, the option <code>"dclone.LB"</code> should be set to <code>TRUE</code>
(by using <code>options("dclone.LB" = TRUE)</code>).
By default, the <code>"dclone.LB"</code>
option is <code>FALSE</code> for reproducibility reasons.
</p>
<p>Some arguments from <code><a href="#topic+dc.fit">dc.fit</a></code> are not available in parallel
version (<code>update</code>, <code>updatefun</code>, <code>initsfun</code>)
when size balancing is used
(<code>partype</code> is <code>"balancing"</code> or <code>"both"</code>).
These arguments are evaluated only when <code>partype="parchains"</code>.
</p>
<p>Size balancing is recommended if <code>n.clones</code> is a relatively long
vector, while parallel chains might be more efficient when
<code>n.clones</code> has few elements.
For efficiency reasons, a combination of the two
(<code>partype="both"</code>) is preferred if cluster size allows it.
</p>
<p>Additionally loaded JAGS modules (e.g. <code>"glm"</code>) need to be loaded
to the workers.
</p>


<h3>Value</h3>

<p>An object inheriting from the class 'mcmc.list'.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a>
</p>


<h3>References</h3>

<p>Lele, S.R., B. Dennis and F. Lutscher, 2007.
Data cloning: easy maximum likelihood estimation for complex
ecological models using Bayesian Markov chain Monte Carlo  methods.
<em>Ecology Letters</em> <strong>10</strong>, 551&ndash;563.
</p>
<p>Lele, S. R., K. Nadeem and B. Schmuland, 2010.
Estimability and likelihood inference for generalized
linear mixed models using data cloning.
<em>Journal of the American Statistical Association</em>
<strong>105</strong>, 1617&ndash;1625.
</p>
<p>Solymos, P., 2010. dclone: Data Cloning in R.
<em>The R Journal</em> <strong>2(2)</strong>, 29&ndash;37.
URL: <a href="https://journal.r-project.org/archive/2010-2/RJournal_2010-2_Solymos.pdf">https://journal.r-project.org/archive/2010-2/RJournal_2010-2_Solymos.pdf</a>
</p>


<h3>See Also</h3>

<p>Sequential version: <code><a href="#topic+dc.fit">dc.fit</a></code>.
</p>
<p>Optimizing the number of workers: <code><a href="#topic+clusterSize">clusterSize</a></code>,
<code><a href="#topic+plotClusterSize">plotClusterSize</a></code>.
</p>
<p>Underlying functions: <code><a href="#topic+jags.fit">jags.fit</a></code>,
<code><a href="#topic+bugs.fit">bugs.fit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(1234)
n &lt;- 20
x &lt;- runif(n, -1, 1)
X &lt;- model.matrix(~x)
beta &lt;- c(2, -1)
mu &lt;- crossprod(t(X), beta)
Y &lt;- rpois(n, exp(mu))
glm.model &lt;- function() {
    for (i in 1:n) {
        Y[i] ~ dpois(lambda[i])
        log(lambda[i]) &lt;- inprod(X[i,], beta[1,])
    }
    for (j in 1:np) {
        beta[1,j] ~ dnorm(0, 0.001)
    }
}
dat &lt;- list(Y=Y, X=X, n=n, np=ncol(X))
k &lt;- 1:3
## sequential version
dcm &lt;- dc.fit(dat, "beta", glm.model, n.clones=k, multiply="n",
    unchanged="np")
## parallel version
cl &lt;- makePSOCKcluster(3)
pdcm1 &lt;- dc.parfit(cl, dat, "beta", glm.model, n.clones=k,
    multiply="n", unchanged="np",
    partype="balancing")
pdcm2 &lt;- dc.parfit(cl, dat, "beta", glm.model, n.clones=k,
    multiply="n", unchanged="np",
    partype="parchains")
pdcm3 &lt;- dc.parfit(cl, dat, "beta", glm.model, n.clones=k,
    multiply="n", unchanged="np",
    partype="both")
summary(dcm)
summary(pdcm1)
summary(pdcm2)
summary(pdcm3)
stopCluster(cl)
## multicore type forking
if (.Platform$OS.type != "windows") {
mcdcm1 &lt;- dc.parfit(3, dat, "beta", glm.model, n.clones=k,
    multiply="n", unchanged="np",
    partype="balancing")
mcdcm2 &lt;- dc.parfit(3, dat, "beta", glm.model, n.clones=k,
    multiply="n", unchanged="np",
    partype="parchains")
mcdcm3 &lt;- dc.parfit(3, dat, "beta", glm.model, n.clones=k,
    multiply="n", unchanged="np",
    partype="both")
}

## Using WinBUGS/OpenBUGS
library(R2WinBUGS)
data(schools)
dat &lt;- list(J = nrow(schools), y = schools$estimate,
    sigma.y = schools$sd)
bugs.model &lt;- function(){
       for (j in 1:J){
         y[j] ~ dnorm (theta[j], tau.y[j])
         theta[j] ~ dnorm (mu.theta, tau.theta)
         tau.y[j] &lt;- pow(sigma.y[j], -2)
       }
       mu.theta ~ dnorm (0.0, 1.0E-6)
       tau.theta &lt;- pow(sigma.theta, -2)
       sigma.theta ~ dunif (0, 1000)
     }
inits &lt;- function(){
    list(theta=rnorm(nrow(schools), 0, 100), mu.theta=rnorm(1, 0, 100),
         sigma.theta=runif(1, 0, 100))
}
param &lt;- c("mu.theta", "sigma.theta")
cl &lt;- makePSOCKcluster(2)
if (.Platform$OS.type == "windows") {
sim2 &lt;- dc.parfit(cl, dat, param, bugs.model, n.clones=1:2,
    flavour="bugs", program="WinBUGS", multiply="J",
    n.iter=2000, n.thin=1)
summary(sim2)
}
sim3 &lt;- dc.parfit(cl, dat, param, bugs.model, n.clones=1:2,
    flavour="bugs", program="brugs", multiply="J",
    n.iter=2000, n.thin=1)
summary(sim3)
library(R2OpenBUGS)
sim4 &lt;- dc.parfit(cl, dat, param, bugs.model, n.clones=1:2,
    flavour="bugs", program="openbugs", multiply="J",
    n.iter=2000, n.thin=1)
summary(sim4)
stopCluster(cl)

## simulation for Poisson GLMM with inits
set.seed(1234)
n &lt;- 5
beta &lt;- c(2, -1)
sigma &lt;- 0.1
alpha &lt;- rnorm(n, 0, sigma)
x &lt;- runif(n)
X &lt;- model.matrix(~x)
linpred &lt;- crossprod(t(X), beta) + alpha
Y &lt;- rpois(n, exp(linpred))
## JAGS model as a function
jfun1 &lt;- function() {
    for (i in 1:n) {
        Y[i] ~ dpois(lambda[i])
        log(lambda[i]) &lt;- alpha[i] + inprod(X[i,], beta)
        alpha[i] ~ dnorm(0, 1/sigma^2)
    }
    for (j in 1:np) {
        beta[j] ~ dnorm(0, 0.001)
    }
    sigma ~ dlnorm(0, 0.001)
}
## data
jdata &lt;- list(n = n, Y = Y, X = X, np = NCOL(X))
## inits with latent variable and parameters
ini &lt;- list(alpha=rep(0,n), beta=rep(0, NCOL(X)))
## model arg is necessary as 1st arg,
## but not used when partype!=parchains
ifun &lt;-
function(model, n.clones) {
    list(alpha=dclone(rep(0,n), n.clones),
        beta=c(0,0))
}
## make cluster
cl &lt;- makePSOCKcluster(2)
## pass global n variable used in ifun to workers
tmp &lt;- clusterExport(cl, "n")
## fit the model
jmod2 &lt;- dc.parfit(cl, jdata, c("beta", "sigma"), jfun1, ini,
    n.clones = 1:2, multiply = "n", unchanged = "np",
    initsfun=ifun, partype="balancing")
stopCluster(cl)

## Using Stan
if (require(rstan)) {
    model &lt;- custommodel("data {
          int&lt;lower=0&gt; N;
          vector[N] y;
          vector[N] x;
        }
        parameters {
          real alpha;
          real beta;
          real&lt;lower=0&gt; sigma;
        }
        model {
          alpha ~ normal(0,10);
          beta ~ normal(0,10);
          sigma ~ cauchy(0,5);
          for (n in 1:N)
            y[n] ~ normal(alpha + beta * x[n], sigma);
        }")
    N &lt;- 100
    alpha &lt;- 1
    beta &lt;- -1
    sigma &lt;- 0.5
    x &lt;- runif(N)
    y &lt;- rnorm(N, alpha + beta * x, sigma)
    dat &lt;- list(N=N, y=y, x=x)
    params &lt;- c("alpha", "beta", "sigma")
    ## compile on 1st time only
    fit0 &lt;- stan.fit(dat, params, model)
    if (.Platform$OS.type != "windows") {
        ## utilize compiled fit0
        dcfit &lt;- dc.parfit(cl=2, dat, params, model, n.clones=1:2,
            flavour="stan", multiply="N", fit=fit0)
        summary(dcfit)
        stan.model(dcfit)
        dcdiag(dcfit)
    }
}

## End(Not run)
</code></pre>

<hr>
<h2 id='dclone'>
Cloning R objects
</h2><span id='topic+dclone'></span><span id='topic+dclone.default'></span><span id='topic+dclone.list'></span><span id='topic+dclone.environment'></span><span id='topic+dclone.dcdim'></span><span id='topic+dclone.dciid'></span><span id='topic+dclone.dctr'></span><span id='topic+dcdim'></span><span id='topic+dciid'></span><span id='topic+dctr'></span>

<h3>Description</h3>

<p>Makes clones of R objects, that is values in the object are repeated <code class="reqn">n</code> times,
leaving the original structure of the object intact (in most of the cases).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dclone(x, n.clones=1, ...)
## Default S3 method:
dclone(x, n.clones = 1, attrib=TRUE, ...)
## S3 method for class 'dcdim'
dclone(x, n.clones = 1, attrib=TRUE, ...)
## S3 method for class 'dciid'
dclone(x, n.clones = 1, attrib=TRUE, ...)
## S3 method for class 'dctr'
dclone(x, n.clones = 1, attrib=TRUE, ...)
## S3 method for class 'list'
dclone(x, n.clones = 1,
    multiply = NULL, unchanged = NULL, attrib=TRUE, ...)
## S3 method for class 'environment'
dclone(x, n.clones = 1,
    multiply = NULL, unchanged = NULL, attrib=TRUE, ...)
dcdim(x, drop = TRUE, perm = NULL)
dciid(x, iid=character(0))
dctr(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dclone_+3A_x">x</code></td>
<td>

<p>An R object to be cloned, or a cloned object to print.
</p>
</td></tr>
<tr><td><code id="dclone_+3A_n.clones">n.clones</code></td>
<td>

<p>Number of clones.
</p>
</td></tr>
<tr><td><code id="dclone_+3A_multiply">multiply</code></td>
<td>

<p>Numeric or character index for list element(s) to be multiplied by
<code>n.clones</code> instead of repetitions
(as done by <code>dclone.default</code>).
</p>
</td></tr>
<tr><td><code id="dclone_+3A_unchanged">unchanged</code></td>
<td>

<p>Numeric or character index for list element(s) to be left unchanged.
</p>
</td></tr>
<tr><td><code id="dclone_+3A_attrib">attrib</code></td>
<td>

<p>Logical, <code>TRUE</code> if attributes are to be attached.
</p>
</td></tr>
<tr><td><code id="dclone_+3A_drop">drop</code></td>
<td>

<p>Logical, if <code>TRUE</code>, deletes the last dimension of
an array if that have only one level.
</p>
</td></tr>
<tr><td><code id="dclone_+3A_perm">perm</code></td>
<td>

<p>The subscript permutation value, if the cloning dimension is not the last.
</p>
</td></tr>
<tr><td><code id="dclone_+3A_iid">iid</code></td>
<td>

<p>Character (or optionally numeric or logical).
Column(s) to be treated as i.i.d. observations.
Ignored when <code>x</code> is a vector.
</p>
</td></tr>
<tr><td><code id="dclone_+3A_...">...</code></td>
<td>

<p>Other arguments passed to function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dclone</code> is a generic function for cloning objects.
It is separate from <code><a href="base.html#topic+rep">rep</a></code>,
because there are different ways of cloning, depending on the
<code>BUGS</code> code implementation:
</p>
<p>(1) Unchanged: no cloning at all (for e.g. constants).
</p>
<p>(2) Repeat: this is the most often used cloning method,
repeating the observations row-wise as if there
were more samples. The <code>dctr</code> option allows repeating
the data column-wise.
</p>
<p>(3) Multiply: sometimes it is enough to multiply the numbers
(e.g. for Binomial distribution).
</p>
<p>(4) Add dimension: under specific circumstances, it is easier to
add another dimension for clones,
but otherwise repeat the observations (e.g. in case of time series,
or for addressing special
indexing conventions in the <code>BUGS</code> code, see examples
<code>dcdim</code> and <code>dclone.dcdim</code>).
</p>
<p>(5) Repeat pattern (i.i.d.): this is useful for example when
a grouping variable is considered, and more i.i.d. groups are to be
added to the data set. E.g. <code>c(1, 1, 2, 2)</code> is to be cloned as
<code>c(1, 1, 2, 2, 3, 3, 4, 4)</code> instead of
<code>c(1, 1, 2, 2, 1, 1, 2, 2)</code>.
</p>


<h3>Value</h3>

<p>An object with class attributes <code>"dclone"</code> plus the original
one(s). Dimensions of the original object might change according to
<code>n.clones</code>. The function tries to take care of names, sometimes
replacing those with the combination of the original names and an
integer for number of clones.
</p>
<p><code>dcdim</code> sets the class attribute of an object to <code>"dcdim"</code>,
thus <code>dclone</code> will clone the object by adding an extra dimension
for the clones.
</p>
<p><code>dciid</code> sets the class attribute of an object to <code>"dciid"</code>,
thus <code>dclone</code> will clone the object by treating columns
defined by the <code>iid</code> argument as i.i.d. observations.
These columns must be numeric.
This aims to facilitates working with the <span class="pkg">INLA</span>
package to generate approximate marginals based on DC.
Columns specified by <code>iid</code> will be replaced by an increasing
sequence of values respecting possible grouping structure (see
Examples).
</p>
<p>Lists (i.e. BUGS data objects) are handled differently to enable element
specific determination of the mode of cloning. This can be done via the
<code>unchanged</code> and <code>multiply</code> arguments, or by setting the
behaviour by the <code>dcdim</code> function.
</p>
<p>Environments are coerced into a list, and return value is identical to
<code>dclone(as.list(x), ...)</code>.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a>,
implementation is based on many discussions
with Khurram Nadeem and Subhash Lele.
</p>


<h3>References</h3>

<p>Lele, S.R., B. Dennis and F. Lutscher, 2007.
Data cloning: easy maximum likelihood estimation for complex
ecological models using Bayesian Markov chain Monte Carlo  methods.
<em>Ecology Letters</em> <strong>10</strong>, 551&ndash;563.
</p>
<p>Lele, S. R., K. Nadeem and B. Schmuland, 2010.
Estimability and likelihood inference for generalized
linear mixed models using data cloning.
<em>Journal of the American Statistical Association</em>
<strong>105</strong>, 1617&ndash;1625.
</p>
<p>Solymos, P., 2010. dclone: Data Cloning in R.
<em>The R Journal</em> <strong>2(2)</strong>, 29&ndash;37.
URL: <a href="https://journal.r-project.org/archive/2010-2/RJournal_2010-2_Solymos.pdf">https://journal.r-project.org/archive/2010-2/RJournal_2010-2_Solymos.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## scalar
dclone(4, 2)
## vector
(x &lt;- 1:6)
dclone(x, 2)
## matrix
(m &lt;- matrix(x, 2, 3))
dclone(m, 2)
## data frame
(dfr &lt;- as.data.frame(t(m)))
dclone(dfr, 2)
## list
(l &lt;- list(n = 10, y = 1:10, x = 1:10, p = 1))
dclone(l, 2)
dclone(as.environment(l), 2)
dclone(l, 2, attrib = FALSE)
dclone(l, 2, multiply = "n", unchanged = "p")
## effect of dcdim
l$y &lt;- dcdim(l$y)
dclone(l, 2, multiply = "n", unchanged = "p")
## time series like usage of dcdim
z &lt;- data.matrix(rnorm(10))
dclone(dcdim(z), 2)
## usage if dciid
ll &lt;- dciid(data.frame(x=1:10, y=1:10), iid="y")
dclone(ll, 2)
## respecting grouping structure in iid
ll$y &lt;- rep(1:5, each=2)
(dci &lt;- dclone(ll, 2))
nclones(dci)
## repeating the data column-wise
dclone(dctr(m), 2)
</code></pre>

<hr>
<h2 id='dclone-package'>
Data Cloning
</h2><span id='topic+dclone-package'></span>

<h3>Description</h3>

<p>Low level functions for implementing
maximum likelihood estimating procedures for
complex models using data cloning and Bayesian
Markov chain Monte Carlo methods.
Sequential and parallel MCMC support
for JAGS, WinBUGS, OpenBUGS, and Stan.
</p>
<p>Main functions include:
</p>

<ul>
<li>
<p><code><a href="#topic+dclone">dclone</a></code>, <code><a href="#topic+dcdim">dcdim</a></code>, <code><a href="#topic+dciid">dciid</a></code>,
<code><a href="#topic+dctr">dctr</a></code>:
cloning R objects in various ways.

</p>
</li>
<li>
<p><code><a href="#topic+jags.fit">jags.fit</a></code>, <code><a href="#topic+bugs.fit">bugs.fit</a></code>, <code><a href="#topic+stan.fit">stan.fit</a></code>:
conveniently fit JAGS/BUGS/Stan models.
<code><a href="#topic+jags.parfit">jags.parfit</a></code>, <code><a href="#topic+bugs.parfit">bugs.parfit</a></code>, <code><a href="#topic+stan.parfit">stan.parfit</a></code>
fits chains on parallel workers.

</p>
</li>
<li>
<p><code><a href="#topic+dc.fit">dc.fit</a></code>: iterative model fitting by
the data cloning algorithm.
<code><a href="#topic+dc.parfit">dc.parfit</a></code> is the parallelized version.

</p>
</li>
<li>
<p><code><a href="#topic+dctable">dctable</a></code>, <code><a href="#topic+dcdiag">dcdiag</a></code>:
helps evaluating data cloning
convergence by descriptive statistics and diagnostic tools.
(These are based on e.g. <code><a href="#topic+chisq.diag">chisq.diag</a></code>
and <code><a href="#topic+lambdamax.diag">lambdamax.diag</a></code>.)

</p>
</li>
<li>
<p><code><a href="#topic+coef.mcmc.list">coef.mcmc.list</a></code>, <code><a href="#topic+confint.mcmc.list.dc">confint.mcmc.list.dc</a></code>,
<code><a href="#topic+dcsd.mcmc.list">dcsd.mcmc.list</a></code>, <code><a href="#topic+quantile.mcmc.list">quantile.mcmc.list</a></code>,
<code><a href="#topic+vcov.mcmc.list.dc">vcov.mcmc.list.dc</a></code>, <code><a href="#topic+mcmcapply">mcmcapply</a></code>,
<code><a href="#topic+stack.mcmc.list">stack.mcmc.list</a></code>:
methods for <code>mcmc.list</code> objects.

</p>
</li>
<li>
<p><code><a href="#topic+write.jags.model">write.jags.model</a></code>, <code><a href="#topic+clean.jags.model">clean.jags.model</a></code>,
<code><a href="#topic+custommodel">custommodel</a></code>:
convenient functions for handling <code>JAGS/BUGS/Stan</code> models.

</p>
</li>
<li>
<p><code><a href="#topic+jagsModel">jagsModel</a></code>, <code><a href="#topic+codaSamples">codaSamples</a></code>: basic functions
from <span class="pkg">rjags</span> package rewrote to recognize data cloning
attributes from data (<code><a href="#topic+parJagsModel">parJagsModel</a></code>,
<code><a href="#topic+parUpdate">parUpdate</a></code>, <code><a href="#topic+parCodaSamples">parCodaSamples</a></code>
are the parallel versions).

</p>
</li></ul>



<h3>Author(s)</h3>

<p>Author: Peter Solymos
</p>
<p>Maintainer: Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a>
</p>


<h3>References</h3>

<p>Forum: <a href="https://groups.google.com/forum/#!forum/dclone-users">https://groups.google.com/forum/#!forum/dclone-users</a>
</p>
<p>Issues: <a href="https://github.com/datacloning/dcmle/issues">https://github.com/datacloning/dcmle/issues</a>
</p>
<p>Data cloning website: <a href="https://datacloning.org">https://datacloning.org</a>
</p>
<p>Solymos, P., 2010. dclone: Data Cloning in R.
<em>The R Journal</em> <strong>2(2)</strong>, 29&ndash;37.
URL: <a href="https://journal.r-project.org/archive/2010-2/RJournal_2010-2_Solymos.pdf">https://journal.r-project.org/archive/2010-2/RJournal_2010-2_Solymos.pdf</a>
</p>
<p>Lele, S.R., B. Dennis and F. Lutscher, 2007.
Data cloning: easy maximum likelihood estimation for complex
ecological models using Bayesian Markov chain Monte Carlo  methods.
<em>Ecology Letters</em> <strong>10</strong>, 551&ndash;563.
</p>
<p>Lele, S. R., K. Nadeem and B. Schmuland, 2010.
Estimability and likelihood inference for generalized
linear mixed models using data cloning.
<em>Journal of the American Statistical Association</em>
<strong>105</strong>, 1617&ndash;1625.
</p>

<hr>
<h2 id='DcloneEnv'>
Manipulating dclone environments
</h2><span id='topic+DcloneEnv'></span><span id='topic+.DcloneEnvModel'></span><span id='topic+.DcloneEnvResults'></span><span id='topic+pullDcloneEnv'></span><span id='topic+pushDcloneEnv'></span><span id='topic+clearDcloneEnv'></span><span id='topic+listDcloneEnv'></span><span id='topic+existsDcloneEnv'></span>

<h3>Description</h3>

<p>Manipulating dclone environments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pullDcloneEnv(x, type = c("model", "results"))
pushDcloneEnv(x, value, type = c("model", "results"))
clearDcloneEnv(..., list = character(), 
    type = c("model", "results"))
listDcloneEnv(type = c("model", "results"))
existsDcloneEnv(x, type = c("model", "results"),
    mode = "any", inherits = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DcloneEnv_+3A_x">x</code></td>
<td>

<p>a variable name, given as a character string. 
No coercion is done, and the first element of a 
character vector of length greater than one will be used,
with a warning.
</p>
</td></tr>
<tr><td><code id="DcloneEnv_+3A_value">value</code></td>
<td>

<p>a value to be assigned to <code>x</code>.
</p>
</td></tr>
<tr><td><code id="DcloneEnv_+3A_type">type</code></td>
<td>

<p>character, the type of environment to be accessed, see Details.
</p>
</td></tr>
<tr><td><code id="DcloneEnv_+3A_...">...</code></td>
<td>

<p>the objects to be removed, as names (unquoted) 
or character strings (quoted).
</p>
</td></tr>
<tr><td><code id="DcloneEnv_+3A_list">list</code></td>
<td>

<p>a character vector naming objects to be removed.
</p>
</td></tr>
<tr><td><code id="DcloneEnv_+3A_mode">mode</code></td>
<td>

<p>the mode or type of object sought: see the <code><a href="base.html#topic+exists">exists</a></code>.
</p>
</td></tr>
<tr><td><code id="DcloneEnv_+3A_inherits">inherits</code></td>
<td>

<p>logical, should the enclosing frames of the environment be searched?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>type = "model"</code> manipulates the <code>.DcloneEnvModel</code> 
environment, which is meant to store temporary objects
for model fitting with &lsquo;snow&rsquo; type parallelism
(see <code><a href="#topic+parDosa">parDosa</a></code> for the implementation).
This is swiped clean after use.
</p>
<p>The<code>type = "results"</code> manipulates the <code>.DcloneEnvResults</code>
environment, which is meant to store result objects on the workers.
This is <em>not</em> swiped clean after use.
</p>
<p><code>pullDcloneEnv</code> pulls an object from these environments,
similar to <code><a href="base.html#topic+get">get</a></code> in effect.
</p>
<p><code>pushDcloneEnv</code> pushes an object to these environments,
similar to <code><a href="base.html#topic+assign">assign</a></code> in effect.
</p>
<p><code>clearDcloneEnv</code> removes object(s) from these environments,
similar to <code><a href="base.html#topic+rm">rm</a></code> in effect.
</p>
<p><code>listDcloneEnv</code> lists name(s) of object(s) in these environments,
similar to <code><a href="base.html#topic+ls">ls</a></code> in effect.
</p>
<p><code>existsDcloneEnv</code> tests if an object exists in these environments,
similar to <code><a href="base.html#topic+exists">exists</a></code> in effect.
</p>


<h3>Value</h3>

<p>For <code>pullDcloneEnv</code>, the object found. 
If no object is found an error results.
</p>
<p><code>pushDcloneEnv</code> is invoked for its side effect, 
which is assigning <code>value</code> to the variable <code>x</code>.
</p>
<p>For <code>clearDcloneEnv</code> its is the side effect of an object removed.
No value returned.
</p>
<p><code>listDcloneEnv</code> returns a character vector.
</p>
<p><code>existsDcloneEnv</code> returns logical, <code>TRUE</code> if and only if an
object of the correct name and mode is found.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parDosa">parDosa</a></code>
</p>

<hr>
<h2 id='dcoptions'>
Setting Options
</h2><span id='topic+dcoptions'></span>

<h3>Description</h3>

<p>Setting options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcoptions(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcoptions_+3A_...">...</code></td>
<td>

<p>Arguments in <code>tag = value</code> form, or a list of tagged values.
The tags must come from the parameters described below.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dcoptions</code> is a convenient way of handling options related to the
package.
</p>


<h3>Value</h3>

<p>When parameters are set by <code>dcoptions</code>, their former values are
returned in an invisible named list. Such a list can be passed as an
argument to <code>dcoptions</code> to restore the parameter values.
Tags are the following:
</p>
<table>
<tr><td><code>autoburnin</code></td>
<td>
<p>logical, to use in <code>gelman.diag</code>
(default is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code>diag</code></td>
<td>
<p>critical value to use for data cloning convergence
diagnostics, default is 0.05.</p>
</td></tr>
<tr><td><code>LB</code></td>
<td>
<p>logical, should load balancing be used,
default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code>overwrite</code></td>
<td>
<p>logical, should existing model file be overwritten,
default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>rhat</code></td>
<td>
<p>critical value for testing chain convergence,
default is 1.1.</p>
</td></tr>
<tr><td><code>RNG</code></td>
<td>
<p>parallel RNG type, either
<code>"none"</code> (default), or <code>"RNGstream"</code>,
see <code><a href="parallel.html#topic+clusterSetRNGStream">clusterSetRNGStream</a></code>.</p>
</td></tr>
<tr><td><code>verbose</code></td>
<td>
<p>integer, should output be verbose (&gt;0) or not (0),
default is 1.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set LB option, but store old value
ov &lt;- dcoptions("LB"=TRUE)
## this is old value
ov
## this is new value
getOption("dcoptions")
## reset to old value
dcoptions(ov)
## check reset
getOption("dcoptions")

</code></pre>

<hr>
<h2 id='dctable'>
Retrieve descriptive statistics from fitted objects to
evaluate convergence
</h2><span id='topic+dctable'></span><span id='topic+dctable.default'></span><span id='topic+extractdctable'></span><span id='topic+extractdctable.default'></span><span id='topic+plot.dctable'></span><span id='topic+dcdiag'></span><span id='topic+dcdiag.default'></span><span id='topic+extractdcdiag'></span><span id='topic+extractdcdiag.default'></span><span id='topic+plot.dcdiag'></span>

<h3>Description</h3>

<p>The function is used to retrieve descriptive statistics
from fitted objects on order to evaluate
convergence of the data cloning algorithm. This is best done
via visual display of the results,
separately for each parameters of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dctable(x, ...)
## Default S3 method:
dctable(x, ...)
## S3 method for class 'dctable'
plot(x, which = 1:length(x),
    type = c("all", "var", "log.var"),
    position = "topright", box.cex = 0.75, box.bg, ...)
extractdctable(x, ...)
## Default S3 method:
extractdctable(x, ...)

dcdiag(x, ...)
## Default S3 method:
dcdiag(x, ...)
## S3 method for class 'dcdiag'
plot(x, which = c("all", "lambda.max",
    "ms.error", "r.squared", "log.lambda.max"),
    position = "topright", ...)
extractdcdiag(x, ...)
## Default S3 method:
extractdcdiag(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dctable_+3A_x">x</code></td>
<td>

<p>An MCMC or a 'dctable' object.
</p>
</td></tr>
<tr><td><code id="dctable_+3A_...">...</code></td>
<td>

<p>Optionally more fitted model objects for function <code>dctable</code>.
</p>
</td></tr>
<tr><td><code id="dctable_+3A_which">which</code></td>
<td>

<p>What to plot. For <code>dctable</code>, character names or integer indices
of the estimated parameters are accepted.
for <code>dcdiag</code> it should be one of
<code>c("all", "lambda.max", "ms.error", "r.squared")</code>.
</p>
</td></tr>
<tr><td><code id="dctable_+3A_type">type</code></td>
<td>

<p>Type of plot to be drawn. See Details.
</p>
</td></tr>
<tr><td><code id="dctable_+3A_position">position</code></td>
<td>

<p>Position for the legend, as for <code><a href="graphics.html#topic+legend">legend</a></code>.
</p>
</td></tr>
<tr><td><code id="dctable_+3A_box.cex">box.cex</code></td>
<td>

<p>Scaling factor for the interquartile boxes.
</p>
</td></tr>
<tr><td><code id="dctable_+3A_box.bg">box.bg</code></td>
<td>

<p>Background color for the interquartile boxes.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dctable</code> returns the <code>"dctable"</code> attribute of the MCMC
object, or if it is <code>NULL</code>, calculates the <code>dctable</code>
summaries. If more than one fitted objects are provided, summaries are
calculated for all objects, and results are ordered by the number of
clones.
</p>
<p>The <code>plot</code> method for <code>dctable</code> helps in graphical
representation of the descriptive statistics.
<code>type = "all"</code> results in plotting means,
standard deviations and quantiles
against the number of clones as boxplot. <code>type = "var"</code>
results in plotting the scaled variances
against the number of clones. In this case variances are
divided by the variance of the
model with smallest number of clones, <code>min(n.clones)</code>.
<code>type = "log.var"</code> is the same as <code>"var"</code>,
but on the log scale. Along with the values, the
<code>min(n.clones) / n.clones</code> line is plotted for reference.
</p>
<p>Lele et al. (2010) introduced diagnostic measures
for checking the convergence of the data cloning algorithm
which are based on the joint posterior distribution
and not only on single parameters. These
include to calculate the largest eigenvalue of the posterior
variance covariance matrix (<code>lambda.max</code> as returned by
<code><a href="#topic+lambdamax.diag">lambdamax.diag</a></code>),
or to calculate mean squared error (<code>ms.error</code>) and another
correlation-like fit statistic (<code>r.squared</code>) based on a
Chi-squared approximation
(as returned by <code><a href="#topic+chisq.diag">chisq.diag</a></code>). The maximum
eigenvalue reflects the degenerateness of the
posterior distribution, while the two fit measures reflect
if the Normal approximation is adequate. All
three statistics should converge to zero as the number of clones
increases. If this happens, different prior specifications are no
longer influencing the results (Lele et al., 2007, 2010).
These are conveniently collected by the <code>dcdiag</code> function.
</p>
<p><b>IMPORTANT!</b>
Have you checked if different prior specifications
lead to the same results?
</p>


<h3>Value</h3>

<p>An object of class 'dctable'.
It is a list, and contains as many data frames as the number of
parameters in the fitted object. Each data frame contains
descriptives as the function of the number of clones.
</p>
<p><code>dcdiag</code> returns a data frame with convergence diagnostics.
</p>
<p>The <code>plot</code> methods produce graphs as side effect.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a>,
implementation is based on many discussions
with Khurram Nadeem and Subhash Lele.
</p>


<h3>References</h3>

<p>Lele, S.R., B. Dennis and F. Lutscher, 2007.
Data cloning: easy maximum likelihood estimation for complex
ecological models using Bayesian Markov chain Monte Carlo  methods.
<em>Ecology Letters</em> <strong>10</strong>, 551&ndash;563.
</p>
<p>Lele, S. R., K. Nadeem and B. Schmuland, 2010.
Estimability and likelihood inference for generalized
linear mixed models using data cloning.
<em>Journal of the American Statistical Association</em>
<strong>105</strong>, 1617&ndash;1625.
</p>
<p>Solymos, P., 2010. dclone: Data Cloning in R.
<em>The R Journal</em> <strong>2(2)</strong>, 29&ndash;37.
URL: <a href="https://journal.r-project.org/archive/2010-2/RJournal_2010-2_Solymos.pdf">https://journal.r-project.org/archive/2010-2/RJournal_2010-2_Solymos.pdf</a>
</p>


<h3>See Also</h3>

<p>Data cloning: <code><a href="#topic+dclone">dclone</a></code>
</p>
<p>Model fitting: <code><a href="#topic+jags.fit">jags.fit</a></code>, <code><a href="#topic+bugs.fit">bugs.fit</a></code>,
<code><a href="#topic+dc.fit">dc.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## simulation for Poisson GLMM
set.seed(1234)
n &lt;- 20
beta &lt;- c(2, -1)
sigma &lt;- 0.1
alpha &lt;- rnorm(n, 0, sigma)
x &lt;- runif(n)
X &lt;- model.matrix(~x)
linpred &lt;- crossprod(t(X), beta) + alpha
Y &lt;- rpois(n, exp(linpred))
## JAGS model as a function
jfun1 &lt;- function() {
    for (i in 1:n) {
        Y[i] ~ dpois(lambda[i])
        log(lambda[i]) &lt;- alpha[i] + inprod(X[i,], beta[1,])
        alpha[i] ~ dnorm(0, 1/sigma^2)
    }
    for (j in 1:np) {
        beta[1,j] ~ dnorm(0, 0.001)
    }
    sigma ~ dlnorm(0, 0.001)
}
## data
jdata &lt;- list(n = n, Y = Y, X = X, np = NCOL(X))
## number of clones to be used, etc.
## iteartive fitting
jmod &lt;- dc.fit(jdata, c("beta", "sigma"), jfun1,
    n.clones = 1:5, multiply = "n", unchanged = "np")
## summary with DC SE and R hat
summary(jmod)
dct &lt;- dctable(jmod)
plot(dct)
## How to use estimates to make priors more informative?
glmm.model.up &lt;- function() {
    for (i in 1:n) {
        Y[i] ~ dpois(lambda[i])
        log(lambda[i]) &lt;- alpha[i] + inprod(X[i,], beta[1,])
        alpha[i] ~ dnorm(0, 1/sigma^2)
    }
    for (j in 1:p) {
        beta[1,j] ~ dnorm(priors[j,1], priors[j,2])
    }
    sigma ~ dgamma(priors[(p+1),2], priors[(p+1),1])
}
## function for updating, x is an MCMC object
upfun &lt;- function(x) {
    if (missing(x)) {
        p &lt;- ncol(X)
        return(cbind(c(rep(0, p), 0.001), rep(0.001, p+1)))
    } else {
        par &lt;- coef(x)
        return(cbind(par, rep(0.01, length(par))))
    }
}
updat &lt;- list(n = n, Y = Y, X = X, p = ncol(X), priors = upfun())
dcmod &lt;- dc.fit(updat, c("beta", "sigma"), glmm.model.up,
    n.clones = 1:5, multiply = "n", unchanged = "p",
    update = "priors", updatefun = upfun)
summary(dcmod)
dct &lt;- dctable(dcmod)
plot(dct)
plot(dct, type = "var")

## End(Not run)
</code></pre>

<hr>
<h2 id='errlines'>
Plot error bars
</h2><span id='topic+errlines'></span><span id='topic+errlines.default'></span>

<h3>Description</h3>

<p>The function plots error bars to existing plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>errlines(x, ...)
## Default S3 method:
errlines(x, y, type = "l", code = 0, 
    width = 0, vertical = TRUE, col = 1, bg = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="errlines_+3A_x">x</code></td>
<td>

<p>Numeric vector with coordinates along the horizontal axis 
(if <code>vertical = FALSE</code>, this sets the vertical axis).
</p>
</td></tr>
<tr><td><code id="errlines_+3A_y">y</code></td>
<td>

<p>A matrix-like object with 2 columns for lower and upper values on the
vertical axis (if <code>vertical = FALSE</code>, 
this sets the horizontal axis).
</p>
</td></tr>
<tr><td><code id="errlines_+3A_type">type</code></td>
<td>

<p>Character, <code>"l"</code> for lines, <code>"b"</code> for boxes to be drawn.
</p>
</td></tr>
<tr><td><code id="errlines_+3A_code">code</code></td>
<td>

<p>Integer code, determining the kind of ticks to be drawn. See Details.
</p>
</td></tr>
<tr><td><code id="errlines_+3A_width">width</code></td>
<td>

<p>Numeric, width of the ticks (if <code>type = "l"</code>) or 
width of the boxes (if <code>type = "b"</code>).
</p>
</td></tr>
<tr><td><code id="errlines_+3A_vertical">vertical</code></td>
<td>

<p>Logical, if errorbars should be plotted vertically or horizontally.
</p>
</td></tr>
<tr><td><code id="errlines_+3A_col">col</code></td>
<td>

<p>Color of the error lines to be drawn, recycled if needed.
</p>
</td></tr>
<tr><td><code id="errlines_+3A_bg">bg</code></td>
<td>

<p>If <code>type = "b"</code> the background color of the boxes. 
By default, no background color used.
</p>
</td></tr>
<tr><td><code id="errlines_+3A_...">...</code></td>
<td>

<p>Other arguments passed to the function <code><a href="graphics.html#topic+lines">lines</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>errlines</code> function uses <code><a href="graphics.html#topic+lines">lines</a></code> to draw error bars
to existing plot when <code>type = "l"</code>.
<code><a href="graphics.html#topic+polygon">polygon</a></code> is used for boxes when <code>type = "b"</code>.
</p>
<p>If <code>code = 0</code> no ticks are drawn, if <code>code = 1</code>, only
lower ticks are drawn, if <code>code = 2</code> only
lower ticks are drawn, if <code>code = 3</code> both
lower and upper ticks are drawn.
</p>


<h3>Value</h3>

<p>Adds error bars to an existing plot as a side effect.
Returns <code>NULL</code> invisibly.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+lines">lines</a></code>, <code><a href="graphics.html#topic+polygon">polygon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
a &lt;- rnorm(10,10)
a &lt;- a[order(a)]
b &lt;- runif(10)
y &lt;- cbind(a-b, a+b+rev(b))
opar &lt;- par(mfrow=c(2, 3))
plot(x, a, ylim = range(y))
errlines(x, y)
plot(x, a, ylim = range(y))
errlines(x, y, width = 0.5, code = 1)
plot(x, a, ylim = range(y), col = 1:10)
errlines(x, y, width = 0.5, code = 3, col = 1:10)
plot(x, a, ylim = range(y))
errlines(x, y, width = 0.5, code = 2, type = "b")
plot(x, a, ylim = range(y))
errlines(x, y, width = 0.5, code = 3, type = "b")
plot(x, a, ylim = range(y), type = "n")
errlines(x, y, width = 0.5, code = 3, type = "b", bg = 1:10)
errlines(x, cbind(a-b/2, a+b/2+rev(b)/2))
points(x, a)
par(opar)
</code></pre>

<hr>
<h2 id='evalParallelArgument'>
Evaluates parallel argument
</h2><span id='topic+evalParallelArgument'></span>

<h3>Description</h3>

<p>Evaluates parallel argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalParallelArgument(cl, quit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalParallelArgument_+3A_cl">cl</code></td>
<td>

<p><code>NULL</code>, a cluster object or an integer. Can be missing.
</p>
</td></tr>
<tr><td><code id="evalParallelArgument_+3A_quit">quit</code></td>
<td>

<p>Logical, whether it should stop with error when ambiguous
parallel definition is found (conflicting default 
environmental variable settings).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> for sequential evaluation or
the original value of <code>cl</code> if parallel
evaluation is meaningful.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>evalParallelArgument()
evalParallelArgument(NULL)
evalParallelArgument(1)
evalParallelArgument(2)
cl &lt;- makePSOCKcluster(2)
evalParallelArgument(cl)
stopCluster(cl)
oop &lt;- options("mc.cores"=2)
evalParallelArgument()
options(oop)
</code></pre>

<hr>
<h2 id='jags.fit'>
Fit JAGS models with cloned data
</h2><span id='topic+jags.fit'></span>

<h3>Description</h3>

<p>Convenient functions designed to work well with 
cloned data arguments and JAGS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jags.fit(data, params, model, inits = NULL, n.chains = 3, 
    n.adapt = 1000, n.update = 1000, thin = 1, n.iter = 5000, 
    updated.model = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jags.fit_+3A_data">data</code></td>
<td>

<p>A named list or environment containing the data. 
If an environment, <code>data</code>
is coerced into a list.
</p>
</td></tr>
<tr><td><code id="jags.fit_+3A_params">params</code></td>
<td>

<p>Character vector of parameters to be sampled.
</p>
</td></tr>
<tr><td><code id="jags.fit_+3A_model">model</code></td>
<td>

<p>Character string (name of the model file), a function containing 
the model, or a or <code><a href="#topic+custommodel">custommodel</a></code> object (see Examples).
</p>
</td></tr>
<tr><td><code id="jags.fit_+3A_inits">inits</code></td>
<td>

<p>Optional specification of initial values in the form of a 
list or a function (see Initialization at 
<code><a href="rjags.html#topic+jags.model">jags.model</a></code>). 
If <code>NULL</code>, initial values will be generated automatically. 
It is an error to supply an initial value for an observed node.
</p>
</td></tr>
<tr><td><code id="jags.fit_+3A_n.chains">n.chains</code></td>
<td>

<p>Number of chains to generate.
</p>
</td></tr>
<tr><td><code id="jags.fit_+3A_n.adapt">n.adapt</code></td>
<td>

<p>Number of steps for adaptation.
</p>
</td></tr>
<tr><td><code id="jags.fit_+3A_n.update">n.update</code></td>
<td>

<p>Number of updates before iterations. 
It is usually a bad idea to use <code>n.update=0</code> if 
<code>n.adapt&gt;0</code>, so a warning is issued in such cases.
</p>
</td></tr>
<tr><td><code id="jags.fit_+3A_thin">thin</code></td>
<td>

<p>Thinning value.
</p>
</td></tr>
<tr><td><code id="jags.fit_+3A_n.iter">n.iter</code></td>
<td>

<p>Number of iterations.
</p>
</td></tr>
<tr><td><code id="jags.fit_+3A_updated.model">updated.model</code></td>
<td>

<p>Logical, if the updated model should be attached as attribute 
(this can be used to further update if convergence
was not satisfactory, see <code><a href="#topic+updated.model">updated.model</a></code> and 
<code><a href="#topic+update.mcmc.list">update.mcmc.list</a></code>).
</p>
</td></tr>
<tr><td><code id="jags.fit_+3A_...">...</code></td>
<td>

<p>Further arguments passed to <code><a href="rjags.html#topic+coda.samples">coda.samples</a></code>, 
and <code><a href="rjags.html#topic+update.jags">update.jags</a></code>
(e.g. the <code>progress.bar</code> argument).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>mcmc.list</code> object. If data cloning is used via the 
<code>data</code> argument, <code>summary</code> returns a modified summary
containing scaled data cloning standard errors 
(scaled by <code>sqrt(n.clones)</code>, see <code><a href="#topic+dcsd">dcsd</a></code>), 
and <code class="reqn">R_{hat}</code> values 
(as returned by <code><a href="coda.html#topic+gelman.diag">gelman.diag</a></code>).
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a>
</p>


<h3>See Also</h3>

<p>Underlying functions: <code><a href="rjags.html#topic+jags.model">jags.model</a></code>, 
<code><a href="rjags.html#topic+update.jags">update.jags</a></code>, 
<code><a href="rjags.html#topic+coda.samples">coda.samples</a></code>
</p>
<p>Parallel chain computations: <code><a href="#topic+jags.parfit">jags.parfit</a></code>
</p>
<p>Methods: <code><a href="#topic+dcsd">dcsd</a></code>, <code><a href="#topic+confint.mcmc.list.dc">confint.mcmc.list.dc</a></code>, 
<code><a href="#topic+coef.mcmc.list">coef.mcmc.list</a></code>, <code><a href="#topic+quantile.mcmc.list">quantile.mcmc.list</a></code>, 
<code><a href="#topic+vcov.mcmc.list.dc">vcov.mcmc.list.dc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (require(rjags)) {
## simple regression example from the JAGS manual
jfun &lt;- function() {
    for (i in 1:N) {
        Y[i] ~ dnorm(mu[i], tau)
        mu[i] &lt;- alpha + beta * (x[i] - x.bar)
    }
    x.bar &lt;- mean(x[])
    alpha ~ dnorm(0.0, 1.0E-4)
    beta ~ dnorm(0.0, 1.0E-4)
    sigma &lt;- 1.0/sqrt(tau)
    tau ~ dgamma(1.0E-3, 1.0E-3)
}
## data generation
set.seed(1234)
N &lt;- 100
alpha &lt;- 1
beta &lt;- -1
sigma &lt;- 0.5
x &lt;- runif(N)
linpred &lt;- crossprod(t(model.matrix(~x)), c(alpha, beta))
Y &lt;- rnorm(N, mean = linpred, sd = sigma)
## list of data for the model
jdata &lt;- list(N = N, Y = Y, x = x)
## what to monitor
jpara &lt;- c("alpha", "beta", "sigma")
## fit the model with JAGS
regmod &lt;- jags.fit(jdata, jpara, jfun, n.chains = 3)
## model summary
summary(regmod)
## data cloning
dcdata &lt;- dclone(jdata, 5, multiply = "N")
dcmod &lt;- jags.fit(dcdata, jpara, jfun, n.chains = 3)
summary(dcmod)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='jags.parfit'>
Parallel computing with JAGS
</h2><span id='topic+jags.parfit'></span>

<h3>Description</h3>

<p>Does the same job as <code><a href="#topic+jags.fit">jags.fit</a></code>,
but parallel chains are run on parallel workers, thus
computations can be faster (up to 1/<code>n.chains</code>) for long MCMC runs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jags.parfit(cl, data, params, model, inits = NULL, n.chains = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jags.parfit_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>, or
an integer, see <code><a href="#topic+parDosa">parDosa</a></code> and
<code><a href="#topic+evalParallelArgument">evalParallelArgument</a></code>.
</p>
</td></tr>
<tr><td><code id="jags.parfit_+3A_data">data</code></td>
<td>

<p>A named list or environment containing the data. If an environment,
<code>data</code> is coerced into a list.
</p>
</td></tr>
<tr><td><code id="jags.parfit_+3A_params">params</code></td>
<td>

<p>Character vector of parameters to be sampled.
</p>
</td></tr>
<tr><td><code id="jags.parfit_+3A_model">model</code></td>
<td>

<p>Character string (name of the model file), a function
containing the model, or a or <code><a href="#topic+custommodel">custommodel</a></code>
object (see Examples).
</p>
</td></tr>
<tr><td><code id="jags.parfit_+3A_inits">inits</code></td>
<td>

<p>Specification of initial values in the form of a
list or a function, can be missing.
Missing value setting can include RNG seed information,
see Initialization at <code><a href="rjags.html#topic+jags.model">jags.model</a></code>.
If this is a function and using 'snow' type
cluster as <code>cl</code>, the function must be self containing, i.e.
not having references to R objects outside of the
function, or the objects should be exported with
<code><a href="parallel.html#topic+clusterExport">clusterExport</a></code> before calling <code>jags.parfit</code>.
Forking type parallelism does not require such attention.
</p>
</td></tr>
<tr><td><code id="jags.parfit_+3A_n.chains">n.chains</code></td>
<td>

<p>Number of chains to generate, must be higher than 1. Ideally,
this is equal to the number of parallel workers in the cluster.
</p>
</td></tr>
<tr><td><code id="jags.parfit_+3A_...">...</code></td>
<td>

<p>Other arguments passed to <code><a href="#topic+jags.fit">jags.fit</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Chains are run on parallel workers,
and the results are combined in the end.
</p>
<p>No update method is available for parallel <code>mcmc.list</code> objects.
See <code><a href="#topic+parUpdate">parUpdate</a></code> and related parallel functions
(<code><a href="#topic+parJagsModel">parJagsModel</a></code>, <code><a href="#topic+parCodaSamples">parCodaSamples</a></code>)
for such purpose.
</p>
<p>Additionally loaded JAGS modules (e.g. <code>"glm"</code>,
<code>"lecuyer"</code>) need to be loaded to the workers
when using 'snow' type cluster as <code>cl</code> argument. See Examples.
</p>
<p>The use of the <code>"lecuyer"</code> module is recommended when
running more than 4 chains. See Examples and
<code><a href="#topic+parallel.inits">parallel.inits</a></code>.
</p>


<h3>Value</h3>

<p>An <code>mcmc.list</code> object.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a>
</p>


<h3>See Also</h3>

<p>Sequential version: <code><a href="#topic+jags.fit">jags.fit</a></code>
</p>
<p>Function for stepwise modeling with JAGS: <code><a href="#topic+parJagsModel">parJagsModel</a></code>,
<code><a href="#topic+parUpdate">parUpdate</a></code>, <code><a href="#topic+parCodaSamples">parCodaSamples</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (require(rjags)) {
set.seed(1234)
n &lt;- 20
x &lt;- runif(n, -1, 1)
X &lt;- model.matrix(~x)
beta &lt;- c(2, -1)
mu &lt;- crossprod(t(X), beta)
Y &lt;- rpois(n, exp(mu))
glm.model &lt;- function() {
    for (i in 1:n) {
        Y[i] ~ dpois(lambda[i])
        log(lambda[i]) &lt;- inprod(X[i,], beta[1,])
    }
    for (j in 1:np) {
        beta[1,j] ~ dnorm(0, 0.001)
    }
}
dat &lt;- list(Y=Y, X=X, n=n, np=ncol(X))
load.module("glm")
m &lt;- jags.fit(dat, "beta", glm.model)
cl &lt;- makePSOCKcluster(3)
## load glm module
tmp &lt;- clusterEvalQ(cl, library(dclone))
parLoadModule(cl, "glm")
pm &lt;- jags.parfit(cl, dat, "beta", glm.model)
## chains are not identical -- this is good
pm[1:2,]
summary(pm)
## examples on how to use initial values
## fixed initial values
inits &lt;- list(list(beta=matrix(c(0,1),1,2)),
    list(beta=matrix(c(1,0),1,2)),
    list(beta=matrix(c(0,0),1,2)))
pm2 &lt;- jags.parfit(cl, dat, "beta", glm.model, inits)
## random numbers generated prior to jags.parfit
inits &lt;- list(list(beta=matrix(rnorm(2),1,2)),
    list(beta=matrix(rnorm(2),1,2)),
    list(beta=matrix(rnorm(2),1,2)))
pm3 &lt;- jags.parfit(cl, dat, "beta", glm.model, inits)
## self contained function
inits &lt;- function() list(beta=matrix(rnorm(2),1,2))
pm4 &lt;- jags.parfit(cl, dat, "beta", glm.model, inits)
## function pointing to the global environment
fun &lt;- function() list(beta=matrix(rnorm(2),1,2))
inits &lt;- function() fun()
clusterExport(cl, "fun")
## using the L'Ecuyer module with 6 chains
load.module("lecuyer")
parLoadModule(cl,"lecuyer")
pm5 &lt;- jags.parfit(cl, dat, "beta", glm.model, inits,
    n.chains=6)
nchain(pm5)
unload.module("lecuyer")
parUnloadModule(cl,"lecuyer")
stopCluster(cl)
## multicore type forking
if (.Platform$OS.type != "windows") {
pm6 &lt;- jags.parfit(3, dat, "beta", glm.model)
}
}

## End(Not run)
</code></pre>

<hr>
<h2 id='jagsModel'>Create a JAGS model object</h2><span id='topic+jagsModel'></span>

<h3>Description</h3>

<p><code>jagsModel</code> is used to create an object representing a
Bayesian graphical model, specified with a BUGS-language description
of the prior distribution, and a set of data.
This function uses <code><a href="rjags.html#topic+jags.model">jags.model</a></code> but keeps track
of data cloning information supplied via the <code>data</code> argument.
The model argument can also accept functions or 'custommodel' objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jagsModel(file, data=sys.frame(sys.parent()), inits, n.chains = 1,
    n.adapt=1000, quiet=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jagsModel_+3A_file">file</code></td>
<td>
<p>the name of the file containing a 
description of the model in the
JAGS dialect of the BUGS language.
Alternatively, <code>file</code> can be a readable text-mode connection,
or a complete URL. It can be also a function or a 
<code><a href="#topic+custommodel">custommodel</a></code> object.</p>
</td></tr>
<tr><td><code id="jagsModel_+3A_data">data</code></td>
<td>
<p>a list or environment containing the data. Any numeric
objects in <code>data</code> corresponding to node arrays used in
<code>file</code> are taken to represent the values of observed nodes
in the model</p>
</td></tr>
<tr><td><code id="jagsModel_+3A_inits">inits</code></td>
<td>
<p>optional specification of initial values in the form of a
list or a function. If omitted,
initial values will be generated automatically. It is an error to
supply an initial value for an observed node.</p>
</td></tr>
<tr><td><code id="jagsModel_+3A_n.chains">n.chains</code></td>
<td>
<p>the number of chains for the model</p>
</td></tr>
<tr><td><code id="jagsModel_+3A_n.adapt">n.adapt</code></td>
<td>
<p>the number of iterations for adaptation. See
<code><a href="rjags.html#topic+adapt">adapt</a></code> for details. If <code>n.adapt = 0</code> then no
adaptation takes place.</p>
</td></tr>
<tr><td><code id="jagsModel_+3A_quiet">quiet</code></td>
<td>
<p>if <code>TRUE</code> then messages generated during compilation
will be suppressed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>parJagsModel</code> returns an object inheriting from class <code>jags</code>
which can be used to generate dependent samples from the posterior
distribution of the parameters.
</p>
<p>An object of class <code>jags</code> is a list of functions that share a
common environment, see <code><a href="rjags.html#topic+jags.model">jags.model</a></code> for details.
</p>
<p>An <code>n.clones</code> attribute is attached to the object when applicable.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a></p>


<h3>See Also</h3>

<p>Underlying functions: <code><a href="rjags.html#topic+jags.model">jags.model</a></code>, 
<code><a href="rjags.html#topic+update.jags">update.jags</a></code>
</p>
<p>See example on help page of <code><a href="#topic+codaSamples">codaSamples</a></code>.
</p>
<p>Parallel version: <code><a href="#topic+parJagsModel">parJagsModel</a></code>
</p>

<hr>
<h2 id='lambdamax.diag'>
Data Cloning Diagnostics
</h2><span id='topic+lambdamax.diag'></span><span id='topic+chisq.diag'></span><span id='topic+lambdamax.diag.mcmc.list'></span><span id='topic+chisq.diag.mcmc.list'></span>

<h3>Description</h3>

<p>These functions calculates diagnostics for evaluating data cloning
convergence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambdamax.diag(x, ...)
## S3 method for class 'mcmc.list'
lambdamax.diag(x, ...)

chisq.diag(x, ...)
## S3 method for class 'mcmc.list'
chisq.diag(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambdamax.diag_+3A_x">x</code></td>
<td>

<p>An object of class <code>mcmc</code> or <code>mcmc.list</code>.
</p>
</td></tr>
<tr><td><code id="lambdamax.diag_+3A_...">...</code></td>
<td>

<p>Other arguments to be passed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These diagnostics can be used to test for the data cloning convergence
(Lele et al. 2007, 2010).
Asymptotically the posterior distribution of the parameters approaches
a degenerate multivariate normal distribution. As the distribution
is getting more degenerate, the maximal eigenvalue (<code class="reqn">\lambda_{max}</code>)
of the unscaled covariance matrix is decreasing.
There is no critical value under which <code class="reqn">\lambda_{max}</code> is good
enough. By default, 0.05 is used (see <code>getOption("dclone")$diag</code>).
</p>
<p>Another diagnostic tool is to check if the joint posterior distribution
is multivariate normal. It is done by <code>chisq.diag</code> as described by
Lele et al. (2010).
</p>


<h3>Value</h3>

<p><code>lambdamax.diag</code> returns a single value, the maximum of the
eigenvalues of the
unscaled variance covariance matrix of the estimated parameters.
</p>
<p><code>chisq.diag</code> returns two test statistic values
(mean squared error and r-squared) with empirical and theoretical
quantiles.
</p>


<h3>Author(s)</h3>

<p>Khurram Nadeem, <a href="mailto:knadeem@math.ualberta.ca">knadeem@math.ualberta.ca</a>
</p>
<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a>
</p>


<h3>References</h3>

<p>Lele, S.R., B. Dennis and F. Lutscher, 2007.
Data cloning: easy maximum likelihood estimation for complex
ecological models using Bayesian Markov chain Monte Carlo  methods.
<em>Ecology Letters</em> <strong>10</strong>, 551&ndash;563.
</p>
<p>Lele, S. R., K. Nadeem and B. Schmuland, 2010.
Estimability and likelihood inference for generalized
linear mixed models using data cloning.
<em>Journal of the American Statistical Association</em>
<strong>105</strong>, 1617&ndash;1625.
</p>
<p>Solymos, P., 2010. dclone: Data Cloning in R.
<em>The R Journal</em> <strong>2(2)</strong>, 29&ndash;37.
URL: <a href="https://journal.r-project.org/archive/2010-2/RJournal_2010-2_Solymos.pdf">https://journal.r-project.org/archive/2010-2/RJournal_2010-2_Solymos.pdf</a>
</p>


<h3>See Also</h3>

<p>Eigen decomposition: <code><a href="base.html#topic+eigen">eigen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(regmod)
lambdamax.diag(regmod)
chisq.diag(regmod)
</code></pre>

<hr>
<h2 id='make.symmetric'>
Make a square matrix symmetric by averaging.
</h2><span id='topic+make.symmetric'></span>

<h3>Description</h3>

<p>Matrix symmetry might depend on numerical precision issues.
The older version of JAGS had a bug related to this issue for 
multivariate normal nodes. This simple function can fix the issue,
but new JAGS versions do not require such intervention.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.symmetric(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.symmetric_+3A_x">x</code></td>
<td>

<p>A square matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes the average as <code>(x[i, j] + x[j, i]) / 2</code> 
for each off diagonal cells.
</p>


<h3>Value</h3>

<p>A symmetric square matrix.
</p>


<h3>Note</h3>

<p>The function works for any matrix, 
even for those not intended to be symmetric.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.matrix(as.dist(matrix(1:25, 5, 5)))
diag(x) &lt;- 100
x[lower.tri(x)] &lt;- x[lower.tri(x)] - 0.1
x[upper.tri(x)] &lt;- x[upper.tri(x)] + 0.1
x
make.symmetric(x)
</code></pre>

<hr>
<h2 id='mclapplySB'>
Size balancing version of mclapply
</h2><span id='topic+mclapplySB'></span>

<h3>Description</h3>

<p><code>mclapplySB</code> is a size balancing version of 
<code><a href="parallel.html#topic+mclapply">mclapply</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mclapplySB(X, FUN, ..., 
    mc.preschedule = TRUE, mc.set.seed = TRUE,
    mc.silent = FALSE, mc.cores = 1L,
    mc.cleanup = TRUE, mc.allow.recursive = TRUE, 
    size = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mclapplySB_+3A_x">X</code></td>
<td>
<p>a vector (atomic or list) or an expressions vector.  Other
objects (including classed objects) will be coerced by
<code><a href="base.html#topic+as.list">as.list</a></code>.</p>
</td></tr>
<tr><td><code id="mclapplySB_+3A_fun">FUN</code></td>
<td>
<p>the function to be applied to each element of <code>X</code></p>
</td></tr>
<tr><td><code id="mclapplySB_+3A_...">...</code></td>
<td>
<p>optional arguments to <code>FUN</code></p>
</td></tr>
<tr><td><code id="mclapplySB_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>see <code><a href="parallel.html#topic+mclapply">mclapply</a></code></p>
</td></tr>
<tr><td><code id="mclapplySB_+3A_mc.set.seed">mc.set.seed</code></td>
<td>
<p>see <code><a href="parallel.html#topic+mclapply">mclapply</a></code></p>
</td></tr>
<tr><td><code id="mclapplySB_+3A_mc.silent">mc.silent</code></td>
<td>
<p>see <code><a href="parallel.html#topic+mclapply">mclapply</a></code></p>
</td></tr>
<tr><td><code id="mclapplySB_+3A_mc.cores">mc.cores</code></td>
<td>
<p>The number of cores to use, i.e. how many processes
will be spawned (at most)</p>
</td></tr>
<tr><td><code id="mclapplySB_+3A_mc.cleanup">mc.cleanup</code></td>
<td>
<p>see <code><a href="parallel.html#topic+mclapply">mclapply</a></code></p>
</td></tr>
<tr><td><code id="mclapplySB_+3A_mc.allow.recursive">mc.allow.recursive</code></td>
<td>
<p>see <code><a href="parallel.html#topic+mclapply">mclapply</a></code></p>
</td></tr>
<tr><td><code id="mclapplySB_+3A_size">size</code></td>
<td>
<p>Vector of problem sizes 
(or relative performance information) 
corresponding to elements of <code>X</code> (recycled if needed). 
The default <code>1</code> indicates equality of problem sizes.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="parallel.html#topic+mclapply">mclapply</a></code> gives details of the forking
mechanism. 
</p>
<p><code><a href="parallel.html#topic+mclapply">mclapply</a></code> is used unmodified 
if sizes of the jobs are equal (<code>length(unique(size)) == 1</code>).
Size balancing (as described in <code><a href="#topic+parDosa">parDosa</a></code>)
is used to balance workload on the child processes
otherwise.
</p>


<h3>Value</h3>

<p>A list.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos</p>


<h3>See Also</h3>

<p><code><a href="parallel.html#topic+mclapply">mclapply</a></code>, <code><a href="#topic+parDosa">parDosa</a></code>
</p>

<hr>
<h2 id='mcmc.list-methods'>
Methods for the 'mcmc.list' class
</h2><span id='topic+dcsd'></span><span id='topic+dcsd.mcmc.list'></span><span id='topic+coef.mcmc.list'></span><span id='topic+confint.mcmc.list.dc'></span><span id='topic+vcov.mcmc.list.dc'></span><span id='topic+vcov.mcmc.list'></span><span id='topic+quantile.mcmc.list'></span>

<h3>Description</h3>

<p>Methods for 'mcmc.list' objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcsd(object, ...)
## S3 method for class 'mcmc.list'
dcsd(object, ...)
## S3 method for class 'mcmc.list'
coef(object, ...)
## S3 method for class 'mcmc.list.dc'
confint(object, parm, level = 0.95, ...)
## S3 method for class 'mcmc.list'
vcov(object, ...)
## S3 method for class 'mcmc.list.dc'
vcov(object, invfisher = TRUE, ...)
## S3 method for class 'mcmc.list'
quantile(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc.list-methods_+3A_x">x</code>, <code id="mcmc.list-methods_+3A_object">object</code></td>
<td>

<p>MCMC object to be processed.
</p>
</td></tr>
<tr><td><code id="mcmc.list-methods_+3A_parm">parm</code></td>
<td>

<p>A specification of which parameters are to be given confidence intervals, 
either a vector of numbers or a vector of names. 
If missing, all parameters are considered.
</p>
</td></tr>
<tr><td><code id="mcmc.list-methods_+3A_level">level</code></td>
<td>

<p>The confidence level required.
</p>
</td></tr>
<tr><td><code id="mcmc.list-methods_+3A_...">...</code></td>
<td>

<p>Further arguments passed to functions.
</p>
</td></tr>
<tr><td><code id="mcmc.list-methods_+3A_invfisher">invfisher</code></td>
<td>

<p>Logical, if the inverse of the Fisher information matrix 
(<code>TRUE</code>) should be returned
instead of the variance-covariance matrix of the joint 
posterior distribution (<code>FALSE</code>).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dcsd</code> returns the data cloning standard errors of a posterior 
MCMC chain calculated as standard deviation times the square root 
of the number of clones.
</p>
<p>The <code>coef</code> method returns mean of the posterior MCMC chains
for the monitored parameters.
</p>
<p>The <code>confint</code> method returns Wald-type confidence intervals 
for the parameters assuming asymptotic normality.
</p>
<p>The <code>vcov</code> method returns the inverse of the Fisher 
information matrix (<code>invfisher = TRUE</code>) or the covariance matrix 
of the joint posterior distribution (<code>invfisher = FALSE</code>). 
The <code>invfisher</code> is valid only for <code>mcmc.list.dc</code>
(data cloned) objects.
</p>
<p>The <code>quantile</code> method returns quantiles for each variable.
</p>


<h3>Note</h3>

<p>Some functions only available for the 'mcmc.list.dc' class which 
inherits from class 'mcmc.list'.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jags.fit">jags.fit</a></code>, <code><a href="#topic+bugs.fit">bugs.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## simple regression example from the JAGS manual
jfun &lt;- function() {
    for (i in 1:N) {
        Y[i] ~ dnorm(mu[i], tau)
        mu[i] &lt;- alpha + beta * (x[i] - x.bar)
    }
    x.bar &lt;- mean(x)
    alpha ~ dnorm(0.0, 1.0E-4)
    beta ~ dnorm(0.0, 1.0E-4)
    sigma &lt;- 1.0/sqrt(tau)
    tau ~ dgamma(1.0E-3, 1.0E-3)
}
## data generation
set.seed(1234)
N &lt;- 100
alpha &lt;- 1
beta &lt;- -1
sigma &lt;- 0.5
x &lt;- runif(N)
linpred &lt;- crossprod(t(model.matrix(~x)), c(alpha, beta))
Y &lt;- rnorm(N, mean = linpred, sd = sigma)
## data for the model
dcdata &lt;- dclone(list(N = N, Y = Y, x = x), 5, multiply = "N")
## data cloning
dcmod &lt;- jags.fit(dcdata, c("alpha", "beta", "sigma"), jfun, 
    n.chains = 3)
summary(dcmod)
coef(dcmod)
dcsd(dcmod)
confint(dcmod)
vcov(dcmod)
vcov(dcmod, invfisher = FALSE)
quantile(dcmod)

## End(Not run)
</code></pre>

<hr>
<h2 id='mcmcapply'>
Calculations on 'mcmc.list' objects
</h2><span id='topic+mcmcapply'></span><span id='topic+stack.mcmc.list'></span>

<h3>Description</h3>

<p>Conveniently calculates statistics for mcmc.list objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcapply(x, FUN, ...)
## S3 method for class 'mcmc.list'
stack(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmcapply_+3A_x">x</code></td>
<td>

<p>Objects of class <code>mcmc.list</code>.
</p>
</td></tr>
<tr><td><code id="mcmcapply_+3A_fun">FUN</code></td>
<td>

<p>A function to be used in the calculations, returning a single value.
</p>
</td></tr>
<tr><td><code id="mcmcapply_+3A_...">...</code></td>
<td>

<p>Other arguments passed to <code>FUN</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mcmcapply</code> returns a certain statistics based on <code>FUN</code>
after coercing into a matrix. <code>FUN</code> can be missing, 
in this case <code>mcmcapply</code> is equivalent
to calling <code>as.matrix</code> on an 'mcmc.list' object.
</p>
<p><code>stack</code> can be used to concatenates 'mcmc.list' 
objects into a single vector
along with index variables indicating where each observation originated
from (e.g. iteration, variable, chain).
</p>


<h3>Value</h3>

<p><code>mcmcapply</code> returns statistic value for each variable
based on <code>FUN</code>, using all values in all chains of the MCMC object.
</p>
<p><code>stack</code> returns a data frame with columns:
iter, variable, chain, value.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(regmod)
mcmcapply(regmod, mean)
mcmcapply(regmod, sd)

x &lt;- stack(regmod)
head(x)
summary(x)
library(lattice)
xyplot(value ~ iter | variable, data=x,
    type="l", scales = "free", groups=chain)
</code></pre>

<hr>
<h2 id='nclones'>
Number of Clones
</h2><span id='topic+nclones'></span><span id='topic+nclones.list'></span><span id='topic+nclones.default'></span>

<h3>Description</h3>

<p>Retrieves the number of clones from an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nclones(x, ...)
## Default S3 method:
nclones(x, ...)
## S3 method for class 'list'
nclones(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nclones_+3A_x">x</code></td>
<td>

<p>An object.
</p>
</td></tr>
<tr><td><code id="nclones_+3A_...">...</code></td>
<td>

<p>Other arguments to be passed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the number of of clones, or <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dclone">dclone</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- dclone(1:10, 10)
nclones(x)
nclones(1:10) # this is NULL
</code></pre>

<hr>
<h2 id='ovenbird'>
Abundances of ovenbird in Alberta
</h2><span id='topic+ovenbird'></span>

<h3>Description</h3>

<p>The data set contains observations (point counts) of 198 sites of the 
Alberta Biodiversity Monitoring Institute.
</p>
<p><code>count</code>: integer, ovenbird counts per site.
</p>
<p><code>site, year</code>: numeric, site number and year of data collection.
</p>
<p><code>ecosite</code>: factor with 5 levels, 
ecological categorization of the sites.
</p>
<p><code>uplow</code>: factor with 2 levels, ecological 
categorization of the sites
(same es ecosite but levels are grouped into 
<code>upland</code> and <code>lowland</code>).
</p>
<p><code>dsucc, dalien, thd</code>: numeric, percentage of successional, 
alienating and total human disturbance
based on interpreted 3 x 7 km photoplots centered on each site.
</p>
<p><code>long, lat</code>: numeric, public 
longitude/latitude coordinates of the sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ovenbird)</code></pre>


<h3>Source</h3>

<p>Alberta Biodiversity Monitoring Institute, https://www.abmi.ca
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ovenbird)
summary(ovenbird)
str(ovenbird)
</code></pre>

<hr>
<h2 id='pairs.mcmc.list'>
Scatterplot Matrices for 'mcmc.list' Objects
</h2><span id='topic+pairs.mcmc.list'></span>

<h3>Description</h3>

<p>A matrix of scatterplots is produced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmc.list'
pairs(x, n = 25, col = 1:length(x), 
    col.hist = "gold", col.image = terrain.colors(50), 
    density = TRUE, contour = TRUE, mean = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairs.mcmc.list_+3A_x">x</code></td>
<td>

<p>an 'mcmc.list' object.
</p>
</td></tr>
<tr><td><code id="pairs.mcmc.list_+3A_n">n</code></td>
<td>

<p>number of of grid points in each direction for
two-dimensional kernel density estimation. 
Can be scalar or a length-2 integer vector.
</p>
</td></tr>
<tr><td><code id="pairs.mcmc.list_+3A_col">col</code></td>
<td>

<p>color for chains in upper panel scatterplots.
</p>
</td></tr>
<tr><td><code id="pairs.mcmc.list_+3A_col.hist">col.hist</code></td>
<td>

<p>color for histogram fill in diagonal panels.
</p>
</td></tr>
<tr><td><code id="pairs.mcmc.list_+3A_col.image">col.image</code></td>
<td>

<p>color palette for image plot in lower panel scatterplots.
</p>
</td></tr>
<tr><td><code id="pairs.mcmc.list_+3A_density">density</code></td>
<td>

<p>logical, if image plot based on the two-dimensional kernel 
density estimation should be plotted in lower panel.
</p>
</td></tr>
<tr><td><code id="pairs.mcmc.list_+3A_contour">contour</code></td>
<td>

<p>logical, if contour plot based on the two-dimensional kernel 
density estimation should be plotted in lower panel.
</p>
</td></tr>
<tr><td><code id="pairs.mcmc.list_+3A_mean">mean</code></td>
<td>

<p>logical, if lines should indicate means of the
posterior densities in the panels.
</p>
</td></tr>
<tr><td><code id="pairs.mcmc.list_+3A_...">...</code></td>
<td>

<p>additional graphical parameters/arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function produces a scatterplot matrix for 'mcmc.list' objects.
Diagonal panels are posterior densities with labels and
rug on the top. Upper panels are pairwise bivariate scatterplots
with coloring corresponding to chains, thus highlighting mixing properties
although not as clearly as trace plots. Lower panels
are two-dimensional kernel density estimates based on 
<code><a href="MASS.html#topic+kde2d">kde2d</a></code> function 
of <span class="pkg">MASS</span> package using <code><a href="Matrix.html#topic+image">image</a></code> 
and <code><a href="graphics.html#topic+contour">contour</a></code>.
</p>


<h3>Value</h3>

<p>The function returns <code>NULL</code> invisibly and 
produces a plot as a side effect.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+pairs">pairs</a></code>, <code><a href="coda.html#topic+plot.mcmc.list">plot.mcmc.list</a></code>
</p>
<p>Two-dimensional kernel density estimation: 
<code><a href="MASS.html#topic+kde2d">kde2d</a></code> in <span class="pkg">MASS</span> package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(regmod)
pairs(regmod)
</code></pre>

<hr>
<h2 id='parallel.inits'>
Parallel RNGs for initial values
</h2><span id='topic+parallel.inits'></span>

<h3>Description</h3>

<p>This function takes care of initial values with safe RNGs based on
<code><a href="rjags.html#topic+parallel.seeds">parallel.seeds</a></code> of the <span class="pkg">rjags</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parallel.inits(inits, n.chains)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parallel.inits_+3A_inits">inits</code></td>
<td>

<p>Initial values (see Initialization at <code><a href="rjags.html#topic+jags.model">jags.model</a></code>). 
If <code>NULL</code>, an empty list of length <code>n.chains</code>
will be generated and seeded (RNG type and seed).
</p>
</td></tr>
<tr><td><code id="parallel.inits_+3A_n.chains">n.chains</code></td>
<td>

<p>Number of chains to generate.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Initial values are handled similar to as it is done in
<code><a href="rjags.html#topic+jags.model">jags.model</a></code>.
</p>
<p>RNGs are based on values returned by 
<code><a href="rjags.html#topic+parallel.seeds">parallel.seeds</a></code>.
</p>
<p>If the <code>"lecuyer"</code> JAGS module is active, RNGs are based on
the <code>"lecuyer::RngStream"</code> factory, otherwise those are based on
the <code>"base::BaseRNG"</code> factory.
</p>


<h3>Value</h3>

<p>Returns a list of initial values with RNGs.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a>. Based on Martyn Plummer's 
<code><a href="rjags.html#topic+parallel.seeds">parallel.seeds</a></code> function and code in 
<code><a href="rjags.html#topic+jags.model">jags.model</a></code> for initial value handling in the 
<span class="pkg">rjags</span> package.
</p>


<h3>See Also</h3>

<p><code><a href="rjags.html#topic+parallel.seeds">parallel.seeds</a></code>, <code><a href="rjags.html#topic+jags.model">jags.model</a></code>
</p>
<p>This seeding function is used in all of <span class="pkg">dclone</span>'s 
parallel functions that do initialization: 
<code><a href="#topic+parJagsModel">parJagsModel</a></code>, <code><a href="#topic+jags.parfit">jags.parfit</a></code>, 
<code><a href="#topic+dc.parfit">dc.parfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(rjags)) {
## "base::BaseRNG" factory.
parallel.inits(NULL, 2)
## "lecuyer::RngStream" factory
load.module("lecuyer")
parallel.inits(NULL, 2)
unload.module("lecuyer")
## some non NULL inits specifications
parallel.inits(list(a=0), 2)
parallel.inits(list(list(a=0), list(a=0)), 2)
parallel.inits(function() list(a=0), 2)
parallel.inits(function(chain) list(a=chain), 2)
}
</code></pre>

<hr>
<h2 id='parCodaSamples'>Generate posterior samples in 'mcmc.list'
format on parallel workers</h2><span id='topic+parCodaSamples'></span>

<h3>Description</h3>

<p>This function sets a trace
monitor for all requested nodes, updates the model on each
workers. Finally, it return the chains to the master and coerces the
output to a single <code>mcmc.list</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parCodaSamples(cl, model, variable.names, n.iter, thin = 1, na.rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parCodaSamples_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>, or
an integer. It can also be <code>NULL</code>, see
<code><a href="#topic+parDosa">parDosa</a></code>.
</p>
</td></tr>
<tr><td><code id="parCodaSamples_+3A_model">model</code></td>
<td>
<p>character, name of a jags model object</p>
</td></tr>
<tr><td><code id="parCodaSamples_+3A_variable.names">variable.names</code></td>
<td>
<p>a character vector giving the names of variables
to be monitored</p>
</td></tr>
<tr><td><code id="parCodaSamples_+3A_n.iter">n.iter</code></td>
<td>
<p>number of iterations to monitor</p>
</td></tr>
<tr><td><code id="parCodaSamples_+3A_thin">thin</code></td>
<td>
<p>thinning interval for monitors</p>
</td></tr>
<tr><td><code id="parCodaSamples_+3A_na.rm">na.rm</code></td>
<td>
<p>logical flag that indicates whether variables containing
missing values should be omitted. See details in help page
of <code><a href="rjags.html#topic+coda.samples">coda.samples</a></code>.</p>
</td></tr>
<tr><td><code id="parCodaSamples_+3A_...">...</code></td>
<td>
<p>optional arguments that are passed to the update method
for jags model objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>mcmc.list</code> object with possibly an <code>n.clones</code> attribute.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a></p>


<h3>See Also</h3>

<p>Original sequential function in <span class="pkg">rjags</span>:
<code><a href="rjags.html#topic+coda.samples">coda.samples</a></code>
</p>
<p>Sequential <span class="pkg">dclone</span>-ified version: <code><a href="#topic+codaSamples">codaSamples</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (require(rjags)) {
model &lt;- function() {
    for (i in 1:N) {
        Y[i] ~ dnorm(mu[i], tau)
        mu[i] &lt;- alpha + beta * (x[i] - x.bar)
    }
    x.bar &lt;- mean(x[])
    alpha ~ dnorm(0.0, 1.0E-4)
    beta ~ dnorm(0.0, 1.0E-4)
    sigma &lt;- 1.0/sqrt(tau)
    tau ~ dgamma(1.0E-3, 1.0E-3)
}
## data generation
set.seed(1234)
N &lt;- 100
alpha &lt;- 1
beta &lt;- -1
sigma &lt;- 0.5
x &lt;- runif(N)
linpred &lt;- crossprod(t(model.matrix(~x)), c(alpha, beta))
Y &lt;- rnorm(N, mean = linpred, sd = sigma)
jdata &lt;- list(N = N, Y = Y, x = x)
jpara &lt;- c("alpha", "beta", "sigma")
## jags model on parallel workers
## n.chains must be &lt;= no. of workers
cl &lt;- makePSOCKcluster(4)
parJagsModel(cl, name="res", file=model, data=jdata,
    n.chains = 2, n.adapt=1000)
parUpdate(cl, "res", n.iter=1000)
m &lt;- parCodaSamples(cl, "res", jpara, n.iter=2000)
stopifnot(2==nchain(m))
## with data cloning
dcdata &lt;- dclone(list(N = N, Y = Y, x = x), 2, multiply="N")
parJagsModel(cl, name="res2", file=model, data=dcdata,
    n.chains = 2, n.adapt=1000)
parUpdate(cl, "res2", n.iter=1000)
m2 &lt;- parCodaSamples(cl, "res2", jpara, n.iter=2000)
stopifnot(2==nchain(m2))
nclones(m2)
stopCluster(cl)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='parDosa'>
Parallel wrapper function to call from within a function
</h2><span id='topic+parDosa'></span>

<h3>Description</h3>

<p><code>parDosa</code> is a wrapper function around many
functionalities of the <span class="pkg">parallel</span> package.
It is designed to work closely with MCMC fitting functions,
e.g. can easily be called from inside of a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parDosa(cl, seq, fun, cldata,
    lib = NULL, dir = NULL, evalq=NULL,
    size = 1, balancing = c("none", "load", "size", "both"),
    rng.type = c("none", "RNGstream"),
    cleanup = TRUE, unload = FALSE, iseed=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parDosa_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>, or
an integer. It can also be <code>NULL</code>, see Details.
</p>
</td></tr>
<tr><td><code id="parDosa_+3A_seq">seq</code></td>
<td>

<p>A vector to split.
</p>
</td></tr>
<tr><td><code id="parDosa_+3A_fun">fun</code></td>
<td>

<p>A function or character string naming a function.
</p>
</td></tr>
<tr><td><code id="parDosa_+3A_cldata">cldata</code></td>
<td>

<p>A list containing data.
This list is then exported to the cluster by
<code><a href="parallel.html#topic+clusterExport">clusterExport</a></code>.
It is stored in a hidden environment.
Data in <code>cldata</code> can be used by <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="parDosa_+3A_lib">lib</code></td>
<td>

<p>Character, name of package(s). Optionally packages can be
loaded onto the cluster. More than one package can be
specified as character vector. Packages already loaded are skipped.
</p>
</td></tr>
<tr><td><code id="parDosa_+3A_dir">dir</code></td>
<td>

<p>Working directory to use, if <code>NULL</code> working
directory is not set on workers (default).
Can be a vector to set different directories on workers.
</p>
</td></tr>
<tr><td><code id="parDosa_+3A_evalq">evalq</code></td>
<td>

<p>Character, expressions to evaluate,
e.g. for changing global options (passed to <code><a href="parallel.html#topic+clusterEvalQ">clusterEvalQ</a></code>).
More than one expressions can be specified as character vector.
</p>
</td></tr>
<tr><td><code id="parDosa_+3A_balancing">balancing</code></td>
<td>

<p>Character, type of balancing to perform (see Details).
</p>
</td></tr>
<tr><td><code id="parDosa_+3A_size">size</code></td>
<td>

<p>Vector of problem sizes (or relative performance information)
corresponding to elements of <code>seq</code> (recycled if needed).
The default <code>1</code> indicates equality of problem sizes.
</p>
</td></tr>
<tr><td><code id="parDosa_+3A_rng.type">rng.type</code></td>
<td>

<p>Character, <code>"none"</code> will not set any seeds on the workers,
<code>"RNGstream"</code> selects the <code>"L'Ecuyer-CMRG"</code> RNG and then
distributes streams to the members of a cluster,
optionally setting the seed of the streams by <code>set.seed(iseed)</code>
(otherwise they are set from the current seed of the master process:
after selecting the L'Ecuyer generator).
See <code><a href="parallel.html#topic+clusterSetRNGStream">clusterSetRNGStream</a></code>.
The logical value <code>!(rng.type == "none")</code> is used for
forking (e.g. when <code>cl</code> is integer).
</p>
</td></tr>
<tr><td><code id="parDosa_+3A_cleanup">cleanup</code></td>
<td>

<p>logical, if <code>cldata</code> should be removed from
the workers after applying <code>fun</code>.
If <code>TRUE</code>, effects of <code>dir</code> argument is also cleaned up.
</p>
</td></tr>
<tr><td><code id="parDosa_+3A_unload">unload</code></td>
<td>

<p>logical, if <code>pkg</code> should be unloaded after applying <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="parDosa_+3A_iseed">iseed</code></td>
<td>

<p>integer or <code>NULL</code>, passed to <code><a href="parallel.html#topic+clusterSetRNGStream">clusterSetRNGStream</a></code>
to be supplied to <code><a href="base.html#topic+set.seed">set.seed</a></code> on the workers,
or NULL not to set reproducible seeds.
</p>
</td></tr>
<tr><td><code id="parDosa_+3A_...">...</code></td>
<td>

<p>Other arguments of <code>fun</code>, that are simple values and not objects.
(Arguments passed as objects should be specified in <code>cldata</code>,
otherwise those are not exported to the cluster by this function.)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses 'snow' type clusters when <code>cl</code> is a cluster
object. The function uses 'multicore' type forking (shared memory)
when <code>cl</code> is an integer.
The value from <code>getOption("mc.cores")</code> is used if the
argument is <code>NULL</code>.
</p>
<p>The function sets the random seeds, loads packages <code>lib</code>
onto the cluster, sets the working directory as <code>dir</code>,
exports <code>cldata</code> and evaluates <code>fun</code> on <code>seq</code>.
</p>
<p>No balancing (<code>balancing = "none"</code>) means, that the problem
is split into roughly equal
subsets, without respect to <code>size</code>
(see <code><a href="parallel.html#topic+clusterSplit">clusterSplit</a></code>). This splitting
is deterministic (reproducible).
</p>
<p>Load balancing (<code>balancing = "load"</code>) means,
that the problem is not splitted into subsets
<em>a priori</em>, but subsequent items are placed on the
worker which is empty
(see <code><a href="parallel.html#topic+clusterApplyLB">clusterApplyLB</a></code> for load balancing).
This splitting is non-deterministic (might not be reproducible).
</p>
<p>Size balancing (<code>balancing = "size"</code>) means,
that the problem is splitted into
subsets, with respect to <code>size</code>
(see <code><a href="#topic+clusterSplitSB">clusterSplitSB</a></code> and <code><a href="#topic+parLapplySB">parLapplySB</a></code>).
In size balancing, the problem is re-ordered from
largest to smallest, and then subsets are
determined by minimizing the total approximate processing time.
This splitting is deterministic (reproducible).
</p>
<p>Size and load balancing (<code>balancing = "both"</code>) means,
that the problem is re-ordered from largest to smallest,
and then undeterministic load balancing
is used (see <code><a href="#topic+parLapplySLB">parLapplySLB</a></code>).
If <code>size</code> is correct, this is identical to size balancing.
This splitting is non-deterministic (might not be reproducible).
</p>


<h3>Value</h3>

<p>Usually a list with results returned by the cluster.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a>
</p>


<h3>See Also</h3>

<p>Size balancing: <code><a href="#topic+parLapplySB">parLapplySB</a></code>, <code><a href="#topic+parLapplySLB">parLapplySLB</a></code>,
<code><a href="#topic+mclapplySB">mclapplySB</a></code>
</p>
<p>Optimizing the number of workers:
<code><a href="#topic+clusterSize">clusterSize</a></code>, <code><a href="#topic+plotClusterSize">plotClusterSize</a></code>.
</p>
<p><code>parDosa</code> is used internally by parallel <span class="pkg">dclone</span>
functions: <code><a href="#topic+jags.parfit">jags.parfit</a></code>, <code><a href="#topic+dc.parfit">dc.parfit</a></code>,
<code><a href="#topic+parJagsModel">parJagsModel</a></code>, <code><a href="#topic+parUpdate">parUpdate</a></code>,
<code><a href="#topic+parCodaSamples">parCodaSamples</a></code>.
</p>
<p><code>parDosa</code> manipulates specific environments
described on the help page <code><a href="#topic+DcloneEnv">DcloneEnv</a></code>.
</p>

<hr>
<h2 id='parJagsModel'>Create a JAGS model object on parallel workers</h2><span id='topic+parJagsModel'></span>

<h3>Description</h3>

<p><code>parJagsModel</code> is used to create an object representing a
Bayesian graphical model, specified with a BUGS-language description
of the prior distribution, and a set of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parJagsModel(cl, name, file, data=sys.frame(sys.parent()),
    inits, n.chains = 1, n.adapt=1000, quiet=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parJagsModel_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>, or
an integer. It can also be <code>NULL</code>,
see <code><a href="#topic+parDosa">parDosa</a></code>.
Size of the cluster must be equal to or larger than <code>n.chains</code>.
</p>
</td></tr>
<tr><td><code id="parJagsModel_+3A_name">name</code></td>
<td>

<p>character, name for the model to be assigned on the workers.</p>
</td></tr>
<tr><td><code id="parJagsModel_+3A_file">file</code></td>
<td>

<p>the name of the file containing a
description of the model in the
JAGS dialect of the BUGS language.
Alternatively, <code>file</code> can be a readable text-mode connection,
or a complete URL. It can be also a function or a
<code><a href="#topic+custommodel">custommodel</a></code> object.</p>
</td></tr>
<tr><td><code id="parJagsModel_+3A_data">data</code></td>
<td>

<p>a list or environment containing the data. Any numeric
objects in <code>data</code> corresponding to node arrays used in
<code>file</code> are taken to represent the values of observed nodes
in the model</p>
</td></tr>
<tr><td><code id="parJagsModel_+3A_inits">inits</code></td>
<td>

<p>optional specification of initial values in the form of a
list or a function (see <code>Initialization</code> on
help page of <code><a href="rjags.html#topic+jags.model">jags.model</a></code>). If omitted,
initial values will be generated automatically. It is an error to
supply an initial value for an observed node.</p>
</td></tr>
<tr><td><code id="parJagsModel_+3A_n.chains">n.chains</code></td>
<td>

<p>the number of parallel chains for the model</p>
</td></tr>
<tr><td><code id="parJagsModel_+3A_n.adapt">n.adapt</code></td>
<td>

<p>the number of iterations for adaptation. See
<code><a href="rjags.html#topic+adapt">adapt</a></code> for details. If <code>n.adapt = 0</code> then no
adaptation takes place.</p>
</td></tr>
<tr><td><code id="parJagsModel_+3A_quiet">quiet</code></td>
<td>

<p>if <code>TRUE</code> then messages generated during compilation
will be suppressed. Effect of this argument is not visible on the
master process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>parJagsModel</code> returns an object inheriting from class <code>jags</code>
which can be used to generate dependent samples from the posterior
distribution of the parameters. These <code>jags</code> models are
residing on the workers, thus updating/sampling is possible.
</p>
<p>Length of <code>cl</code> must be equal to or greater than <code>n.chains</code>.
RNG seed generation takes place first on the master,
and chains then initialized on
each worker by distributing <code>inits</code> and single chained models.
</p>
<p>An object of class <code>jags</code> is a list of functions that share a
common environment, see <code><a href="rjags.html#topic+jags.model">jags.model</a></code> for details.
Data cloning information is attached to the returned
object if data argument has <code>n.clones</code> attribute.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a></p>


<h3>See Also</h3>

<p>Original sequential function in <span class="pkg">rjags</span>:
<code><a href="rjags.html#topic+jags.model">jags.model</a></code>
</p>
<p>Sequential <span class="pkg">dclone</span>-ified version: <code><a href="#topic+jagsModel">jagsModel</a></code>
</p>
<p>See example on help page of <code><a href="#topic+parCodaSamples">parCodaSamples</a></code>.
</p>

<hr>
<h2 id='parLoadModule'>Dynamically load JAGS modules on parallel workers</h2><span id='topic+parLoadModule'></span><span id='topic+parUnloadModule'></span><span id='topic+parListModules'></span>

<h3>Description</h3>

<p>A JAGS module is a dynamically loaded library that extends the
functionality of JAGS. These functions load and unload JAGS modules
and show the names of the currently loaded modules on parallel workers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parLoadModule(cl, name, path, quiet=FALSE)
parUnloadModule(cl, name, quiet=FALSE)
parListModules(cl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parLoadModule_+3A_cl">cl</code></td>
<td>
<p>a cluster object created by the
<span class="pkg">parallel</span> package.</p>
</td></tr>
<tr><td><code id="parLoadModule_+3A_name">name</code></td>
<td>
<p>character, name of the module to be loaded</p>
</td></tr>
<tr><td><code id="parLoadModule_+3A_path">path</code></td>
<td>
<p>file path to the location of the DLL. If omitted,
the option <code>jags.moddir</code> is used to locate the modules.
it can be a vector of length <code>length(cl)</code> to set different
DLL locations on each worker</p>
</td></tr>
<tr><td><code id="parLoadModule_+3A_quiet">quiet</code></td>
<td>
<p>a logical. If <code>TRUE</code>, no message will be printed
about loading the module</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a></p>


<h3>See Also</h3>

<p><code><a href="rjags.html#topic+list.modules">list.modules</a></code>,
<code><a href="rjags.html#topic+load.module">load.module</a></code>, <code><a href="rjags.html#topic+unload.module">unload.module</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (require(rjags)) {
cl &lt;- makePSOCKcluster(3)
parListModules(cl)
parLoadModule(cl, "glm")
parListModules(cl)
parUnloadModule(cl, "glm")
parListModules(cl)
stopCluster(cl)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='parSetFactory'>Advanced control over JAGS on parallel workers</h2><span id='topic+parListFactories'></span><span id='topic+parSetFactory'></span>

<h3>Description</h3>

<p>JAGS modules contain factory objects for samplers, monitors, and
random number generators for a JAGS model.  These functions allow
fine-grained control over which factories are active
on parallel workers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parListFactories(cl, type)
parSetFactory(cl, name, type, state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parSetFactory_+3A_cl">cl</code></td>
<td>
<p>a cluster object created by the
<span class="pkg">parallel</span> package.</p>
</td></tr>
<tr><td><code id="parSetFactory_+3A_name">name</code></td>
<td>
<p>name of the factory to set</p>
</td></tr>
<tr><td><code id="parSetFactory_+3A_type">type</code></td>
<td>
<p>type of factory to query or set. Possible values are
<code>"sampler"</code>, <code>"monitor"</code>, or <code>"rng"</code></p>
</td></tr>
<tr><td><code id="parSetFactory_+3A_state">state</code></td>
<td>
<p>a logical. If <code>TRUE</code> then the factory will be
active, otherwise the factory will become inactive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>parListFactories</code> returns a a list of data frame
with two columns per each worker, the first
column shows the names of the factory objects in the currently loaded
modules, and the second column is a logical vector indicating whether
the corresponding factory is active or not.
</p>
<p><code>sparStFactory</code> is called to change
the future behaviour of factory
objects. If a factory is set to inactive then it will be skipped.
</p>


<h3>Note</h3>

<p>When a module is loaded, all of its factory objects are active. This
is also true if a module is unloaded and then reloaded.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a></p>


<h3>See Also</h3>

<p><code><a href="rjags.html#topic+list.modules">list.modules</a></code>,
<code><a href="rjags.html#topic+set.factory">set.factory</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (require(rjags)) {
cl &lt;- makePSOCKcluster(3)
parListFactories(cl, "sampler")
parListFactories(cl, "monitor")
parListFactories(cl, "rng")
parSetFactory(cl, "base::Slice", "sampler", FALSE)
parListFactories(cl, "sampler")
parSetFactory(cl, "base::Slice", "sampler", TRUE)
stopCluster(cl)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='parUpdate'>Update jags models on parallel workers</h2><span id='topic+parUpdate'></span>

<h3>Description</h3>

<p>Update the Markov chain associated with the model on parallel workers.
(This represents the 'burn-in' phase when nodes are not monitored.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parUpdate(cl, object, n.iter=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parUpdate_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>, or
an integer. It can also be <code>NULL</code>,
see <code><a href="#topic+parDosa">parDosa</a></code>.
</p>
</td></tr>
<tr><td><code id="parUpdate_+3A_object">object</code></td>
<td>
<p>character, name of a jags model object</p>
</td></tr>
<tr><td><code id="parUpdate_+3A_n.iter">n.iter</code></td>
<td>
<p>number of iterations of the Markov chain to run</p>
</td></tr>
<tr><td><code id="parUpdate_+3A_...">...</code></td>
<td>
<p>additional arguments to the update method, see
<code><a href="rjags.html#topic+update.jags">update.jags</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>parUpdate</code> function modifies the
original object on parallel workers and returns <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a></p>


<h3>See Also</h3>

<p><code><a href="rjags.html#topic+update.jags">update.jags</a></code>
</p>
<p>See example on help page of <code><a href="#topic+parCodaSamples">parCodaSamples</a></code>.</p>

<hr>
<h2 id='regmod'>
Exemplary MCMC list object
</h2><span id='topic+regmod'></span>

<h3>Description</h3>

<p>This data set was made via the <code><a href="#topic+jags.fit">jags.fit</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(regmod)</code></pre>


<h3>Source</h3>

<p>See Example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(regmod)
summary(regmod)
plot(regmod)
## Not run: 
## DATA GENERATION
## simple regression example from the JAGS manual
jfun &lt;- function() {
    for (i in 1:N) {
        Y[i] ~ dnorm(mu[i], tau)
        mu[i] &lt;- alpha + beta * (x[i] - x.bar)
    }
    x.bar &lt;- mean(x[])
    alpha ~ dnorm(0.0, 1.0E-4)
    beta ~ dnorm(0.0, 1.0E-4)
    sigma &lt;- 1.0/sqrt(tau)
    tau ~ dgamma(1.0E-3, 1.0E-3)
}
## data generation
set.seed(1234)
N &lt;- 100
alpha &lt;- 1
beta &lt;- -1
sigma &lt;- 0.5
x &lt;- runif(N)
linpred &lt;- crossprod(t(model.matrix(~x)), c(alpha, beta))
Y &lt;- rnorm(N, mean = linpred, sd = sigma)
## list of data for the model
jdata &lt;- list(N = N, Y = Y, x = x)
## what to monitor
jpara &lt;- c("alpha", "beta", "sigma")
## fit the model with JAGS
regmod &lt;- jags.fit(jdata, jpara, jfun, n.chains = 3,
    updated.model = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='stan.fit'>
Fit Stan models with cloned data
</h2><span id='topic+stan.fit'></span><span id='topic+stan.parfit'></span><span id='topic+stan.model'></span>

<h3>Description</h3>

<p>Convenient functions designed to work well with
cloned data arguments and Stan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan.fit(data, params, model, inits = NULL,
    seed = sample.int(.Machine$integer.max, 1),
    n.chains = 3,
    format = c("mcmc.list", "stanfit"),
    stan.model = TRUE, fit = NA, ...)
stan.model(object, ...)
stan.parfit(cl, data, params, model, inits = NULL,
    seed = sample.int(.Machine$integer.max, n.chains),
    n.chains = 3,
    format = c("mcmc.list", "stanfit"),
    stan.model = TRUE, fit = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan.fit_+3A_data">data</code></td>
<td>

<p>A list (or environment) containing the data.
</p>
</td></tr>
<tr><td><code id="stan.fit_+3A_params">params</code></td>
<td>

<p>Character vector of parameters to be sampled.
</p>
</td></tr>
<tr><td><code id="stan.fit_+3A_model">model</code></td>
<td>

<p>Character string (name of the model file), a function containing
the model, or a <code><a href="#topic+custommodel">custommodel</a></code> object.
</p>
</td></tr>
<tr><td><code id="stan.fit_+3A_inits">inits</code></td>
<td>

<p>Optional specification of initial values in the
form of a list or a function.
If <code>NULL</code>, initial values will be
generated automatically.
</p>
</td></tr>
<tr><td><code id="stan.fit_+3A_seed">seed</code></td>
<td>

<p>Random seed.
</p>
</td></tr>
<tr><td><code id="stan.fit_+3A_n.chains">n.chains</code></td>
<td>

<p>number of Markov chains.
</p>
</td></tr>
<tr><td><code id="stan.fit_+3A_format">format</code></td>
<td>

<p>Desired output format.
</p>
</td></tr>
<tr><td><code id="stan.fit_+3A_stan.model">stan.model</code></td>
<td>

<p>Logical, if <code>stanmodel</code> object should be returned.
</p>
</td></tr>
<tr><td><code id="stan.fit_+3A_fit">fit</code></td>
<td>

<p>Fitted Stan object.
</p>
</td></tr>
<tr><td><code id="stan.fit_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>, or
an integer, see <code><a href="#topic+parDosa">parDosa</a></code> and
<code><a href="#topic+evalParallelArgument">evalParallelArgument</a></code>.
</p>
</td></tr>
<tr><td><code id="stan.fit_+3A_object">object</code></td>
<td>

<p>A fitted MCMC object ('mcmc.list' class for example),
with <code>"stan.model"</code> attribute.
</p>
</td></tr>
<tr><td><code id="stan.fit_+3A_...">...</code></td>
<td>

<p>Further arguments.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, an <code>stan.fit</code> returns an
<code>mcmc.list</code> object. If data cloning is used via the
<code>data</code> argument, <code>summary</code> returns a modified summary
containing scaled data cloning standard errors
(scaled by <code>sqrt(n.clones)</code>), and
<code class="reqn">R_{hat}</code> values (as returned by <code><a href="coda.html#topic+gelman.diag">gelman.diag</a></code>).
</p>
<p><code>stan.model</code> returns the <code>stanmodel</code> object.
</p>
<p><code>stan.parfit</code> runs chains using multiple cores when <code>cl</code>
is an integer. Using a cluster object leads to recompiling the
model (therefore <code>fit</code> is ignored), and might not be
very quick to run.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a>
</p>


<h3>See Also</h3>

<p>Underlying functions:
<code><a href="rstan.html#topic+stan">stan</a></code> and
<code><a href="rstan.html#topic+stanfit">stanfit</a></code> in package <span class="pkg">rstan</span>
</p>
<p>Methods: <code><a href="#topic+dcsd">dcsd</a></code>, <code><a href="#topic+confint.mcmc.list.dc">confint.mcmc.list.dc</a></code>,
<code><a href="#topic+coef.mcmc.list">coef.mcmc.list</a></code>, <code><a href="#topic+quantile.mcmc.list">quantile.mcmc.list</a></code>,
<code><a href="#topic+vcov.mcmc.list.dc">vcov.mcmc.list.dc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (require(rstan)) {
    model &lt;- custommodel("data {
          int&lt;lower=0&gt; N;
          vector[N] y;
          vector[N] x;
        }
        parameters {
          real alpha;
          real beta;
          real&lt;lower=0&gt; sigma;
        }
        model {
          alpha ~ normal(0,10);
          beta ~ normal(0,10);
          sigma ~ cauchy(0,5);
          for (n in 1:N)
            y[n] ~ normal(alpha + beta * x[n], sigma);
        }")
    N &lt;- 100
    alpha &lt;- 1
    beta &lt;- -1
    sigma &lt;- 0.5
    x &lt;- runif(N)
    y &lt;- rnorm(N, alpha + beta * x, sigma)
    dat &lt;- list(N=N, y=y, x=x)
    params &lt;- c("alpha", "beta", "sigma")
    ## compile on 1st time only
    fit0 &lt;- stan.fit(dat, params, model)
    ## reuse compiled fit0
    fit &lt;- stan.fit(dat, params, model, fit=fit0)
    sm &lt;- stan.model(fit)
    summary(fit)
    sm

    ## data cloning
    dcdat &lt;- dclone(dat, n.clones=2, multiply="N")
    dcfit &lt;- stan.fit(dcdat, params, model, fit=fit0)
    summary(dcfit)
    nclones(dcfit)

    ## using parallel options
    cl &lt;- makeCluster(2)
    ## cannot utilize compiled fit0
    fit2 &lt;- stan.parfit(cl=cl, dat, params, model)
    stopCluster(cl)
    if (.Platform$OS.type != "windows") {
        ## utilize compiled fit0
        fit3 &lt;- stan.parfit(cl=2, dat, params, model, fit=fit0)
    }
}

## End(Not run)
</code></pre>

<hr>
<h2 id='update.mcmc.list'>
Automatic updating of an MCMC object from JAGS
</h2><span id='topic+update.mcmc.list'></span><span id='topic+updated.model'></span>

<h3>Description</h3>

<p>Automatic updating of an MCMC object until a
desired statistic value reached.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updated.model(object, ...)
## S3 method for class 'mcmc.list'
update(object, fun,
    times = 1, n.update = 0, n.iter, thin, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.mcmc.list_+3A_object">object</code></td>
<td>

<p>A fitted MCMC object ('mcmc.list' class for example), with
<code>"updated.model"</code> attribute.
</p>
</td></tr>
<tr><td><code id="update.mcmc.list_+3A_fun">fun</code></td>
<td>

<p>A function that evaluates convergence of the MCMC chains,
must return logical result. See Examples.
The iterative updating quits when return value is <code>TRUE</code>.
Can be missing, in which case there is no stopping rule.
</p>
</td></tr>
<tr><td><code id="update.mcmc.list_+3A_times">times</code></td>
<td>

<p>Number of times the updating should be repeated.
If <code>fun</code> returns <code>TRUE</code>, updating
is finished and MCMC object is returned.
</p>
</td></tr>
<tr><td><code id="update.mcmc.list_+3A_n.update">n.update</code></td>
<td>

<p>Number of updating iterations. The default 0 indicates,
that only <code>n.iter</code> iterations are used.
</p>
</td></tr>
<tr><td><code id="update.mcmc.list_+3A_n.iter">n.iter</code></td>
<td>

<p>Number of iterations for sampling and evaluating <code>fun</code>.
If missing, value is taken from <code>object</code>.
</p>
</td></tr>
<tr><td><code id="update.mcmc.list_+3A_thin">thin</code></td>
<td>

<p>Thinning value. If missing, value is taken from <code>object</code>.
</p>
</td></tr>
<tr><td><code id="update.mcmc.list_+3A_...">...</code></td>
<td>

<p>Other arguments passed to <code><a href="rjags.html#topic+coda.samples">coda.samples</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>updated.model</code> can be used to retrieve the updated model
from an MCMC object fitted via the function <code><a href="#topic+jags.fit">jags.fit</a></code>
and <code><a href="#topic+dc.fit">dc.fit</a></code> (with <code>flavour = "jags"</code>).
The <code>update</code> method is a wrapper for this purpose,
specifically designed
for the case when MCMC convergence is problematic. A function
is evaluated on the updated model in each iteration of
the updating process,
and an MCMC object is returned when iteration ends,
or when the evaluated
function returns <code>TRUE</code> value.
</p>
<p><code>n.update</code> and <code>n.iter</code> can be vectors, if lengths are
shorter then <code>times</code>, values are recycled.
</p>
<p>Data cloning information is preserved.
</p>


<h3>Value</h3>

<p><code>updated.model</code> returns the state of the JAGS model after updating
and sampling. This can be further updated by the function
<code><a href="rjags.html#topic+update.jags">update.jags</a></code>
and sampled by <code><a href="rjags.html#topic+coda.samples">coda.samples</a></code> if
convergence diagnostics were not satisfactory.
</p>
<p><code>update</code> returns an MCMC object with
<code>"updated.model"</code> attribute.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jags.fit">jags.fit</a></code>, <code><a href="rjags.html#topic+coda.samples">coda.samples</a></code>,
<code><a href="rjags.html#topic+update.jags">update.jags</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## simple regression example from the JAGS manual
jfun &lt;- function() {
    for (i in 1:N) {
        Y[i] ~ dnorm(mu[i], tau)
        mu[i] &lt;- alpha + beta * (x[i] - x.bar)
    }
    x.bar &lt;- mean(x[])
    alpha ~ dnorm(0.0, 1.0E-4)
    beta ~ dnorm(0.0, 1.0E-4)
    sigma &lt;- 1.0/sqrt(tau)
    tau ~ dgamma(1.0E-3, 1.0E-3)
}
## data generation
set.seed(1234)
N &lt;- 100
alpha &lt;- 1
beta &lt;- -1
sigma &lt;- 0.5
x &lt;- runif(N)
linpred &lt;- crossprod(t(model.matrix(~x)), c(alpha, beta))
Y &lt;- rnorm(N, mean = linpred, sd = sigma)
## list of data for the model
jdata &lt;- list(N = N, Y = Y, x = x)
## what to monitor
jpara &lt;- c("alpha", "beta", "sigma")
## fit the model with JAGS
regmod &lt;- jags.fit(jdata, jpara, jfun, n.chains = 3)
## get the updated model
upmod &lt;- updated.model(regmod)
upmod
## automatic updating
## using R_hat &lt; 1.1 as criteria
critfun &lt;- function(x)
    all(gelman.diag(x)$psrf[,1] &lt; 1.1)
mod &lt;- update(regmod, critfun, 5)
## update just once
mod2 &lt;- update(regmod)
summary(mod)

## End(Not run)
</code></pre>

<hr>
<h2 id='write.jags.model'>
Write and remove model file
</h2><span id='topic+write.jags.model'></span><span id='topic+clean.jags.model'></span><span id='topic+custommodel'></span>

<h3>Description</h3>

<p>Writes or removes a BUGS model file to or from the hard drive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.jags.model(model, filename = "model.txt", digits = 5,
    dir = tempdir(), overwrite = getOption("dcoptions")$overwrite)
clean.jags.model(filename = "model.txt")
custommodel(model, exclude = NULL, digits = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.jags.model_+3A_model">model</code></td>
<td>

<p>JAGS model to write onto the hard drive (see Example).
For <code>write.jags.model</code>, it can be name of a file or a function,
or it can be an 'custommodel' object returned by <code>custommodel</code>.
<code>custommodel</code> can take its <code>model</code> argument as function.
If <code>model</code> is not function, its is coerced as character.
</p>
</td></tr>
<tr><td><code id="write.jags.model_+3A_digits">digits</code></td>
<td>

<p>Number of significant digits used in the output.
</p>
</td></tr>
<tr><td><code id="write.jags.model_+3A_filename">filename</code></td>
<td>

<p>Character, the name of the file to write/remove.
It can be a <code>link{connection}</code>.
</p>
</td></tr>
<tr><td><code id="write.jags.model_+3A_dir">dir</code></td>
<td>

<p>Optional argument for directory where to write the file.
The default is to use a temporary directory and use
<code><a href="base.html#topic+file.path">file.path</a>(dir, filename)</code>.
When <code>NULL</code>, it uses the current working directory
(<code><a href="base.html#topic+getwd">getwd</a>()</code>).
</p>
</td></tr>
<tr><td><code id="write.jags.model_+3A_overwrite">overwrite</code></td>
<td>

<p>Logical, if <code>TRUE</code> the <code>filename</code> will be forced and existing
file with same name will be overwritten.
</p>
</td></tr>
<tr><td><code id="write.jags.model_+3A_exclude">exclude</code></td>
<td>

<p>Numeric, lines of the model to exclude (see Details).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>write.jags.model</code> is built upon the function
<code><a href="R2WinBUGS.html#topic+write.model">write.model</a></code> of the <span class="pkg">R2WinBUGS</span> package.
</p>
<p><code>clean.jags.model</code> is built upon the function
<code><a href="base.html#topic+file.remove">file.remove</a></code>, and
intended to be used internally to clean up the JAGS
model file after estimating sessions,
ideally via the <code><a href="base.html#topic+on.exit">on.exit</a></code> function.
It requires the full path as returned by <code>write.jags.model</code>.
</p>
<p>The function <code>custommodel</code> can be used to exclude some lines
of the model. This is handy when there are variations of the same model.
<code>write.jags.model</code> accepts results returned by <code>custommodel</code>.
This is also the preferred way of including BUGS models into
R packages, because the function form often includes
undefined functions.
</p>
<p>Use the <code>%_%</code> operator if the model is a function and the model
contains truncation (<code>I()</code> in WinBUGS, <code>T()</code> in JAGS).
See explanation on help page of <code><a href="R2WinBUGS.html#topic+write.model">write.model</a></code>.
</p>


<h3>Value</h3>

<p><code>write.jags.model</code> invisibly returns the name of the file
that was written eventually (possibly including random string).
The return value includes the full path.
</p>
<p><code>clean.jags.model</code> invisibly returns the result of
<code><a href="base.html#topic+file.remove">file.remove</a></code> (logical).
</p>
<p><code>custommodel</code> returns an object of class 'custommodel',
which is a character vector.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, <a href="mailto:solymos@ualberta.ca">solymos@ualberta.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="R2WinBUGS.html#topic+write.model">write.model</a></code>, <code><a href="base.html#topic+file.remove">file.remove</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## simple regression example from the JAGS manual
jfun &lt;- function() {
    for (i in 1:N) {
        Y[i] ~ dnorm(mu[i], tau)
        mu[i] &lt;- alpha + beta * (x[i] - x.bar)
    }
    x.bar &lt;- mean(x)
    alpha ~ dnorm(0.0, 1.0E-4)
    beta ~ dnorm(0.0, 1.0E-4)
    sigma &lt;- 1.0/sqrt(tau)
    tau ~ dgamma(1.0E-3, 1.0E-3)
}
## data generation
set.seed(1234)
N &lt;- 100
alpha &lt;- 1
beta &lt;- -1
sigma &lt;- 0.5
x &lt;- runif(N)
linpred &lt;- crossprod(t(model.matrix(~x)), c(alpha, beta))
Y &lt;- rnorm(N, mean = linpred, sd = sigma)
## list of data for the model
jdata &lt;- list(N = N, Y = Y, x = x)
## what to monitor
jpara &lt;- c("alpha", "beta", "sigma")
## write model onto hard drive
jmodnam &lt;- write.jags.model(jfun)
## fit the model
regmod &lt;- jags.fit(jdata, jpara, jmodnam, n.chains = 3)
## cleanup
clean.jags.model(jmodnam)
## model summary
summary(regmod)

## End(Not run)
## let's customize this model
jfun2 &lt;- structure(
    c(" model { ",
    "     for (i in 1:n) { ",
    "         Y[i] ~ dpois(lambda[i]) ",
    "         Y[i] &lt;- alpha[i] + inprod(X[i,], beta[1,]) ",
    "         log(lambda[i]) &lt;- alpha[i] + inprod(X[i,], beta[1,]) ",
    "         alpha[i] ~ dnorm(0, 1/sigma^2) ",
    "     } ",
    "     for (j in 1:np) { ",
    "         beta[1,j] ~ dnorm(0, 0.001) ",
    "     } ",
    "     sigma ~ dlnorm(0, 0.001) ",
    " } "),
    class = "custommodel")
custommodel(jfun2)
## GLMM
custommodel(jfun2, 4)
## LM
custommodel(jfun2, c(3,5))
## deparse when print
print(custommodel(jfun2), deparse=TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
