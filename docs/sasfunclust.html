<!DOCTYPE html><html><head><title>Help for package sasfunclust</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sasfunclust}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sasfunclust-package'><p>Sparse and smooth functional data clustering</p></a></li>
<li><a href='#plot.sasfclust'><p>Plot the results of  the Sas-funclust method</p></a></li>
<li><a href='#sasfclust'><p>Sparse and Smooth Functional Data Clustering</p></a></li>
<li><a href='#sasfclust_cv'><p>Cross-validation for sasfclust</p></a></li>
<li><a href='#simulate_data'><p>Simulate data for functional clustering</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Sparse and Smooth Functional Clustering</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the sparse and smooth functional clustering (SaS-Funclust) method (Centofanti et al. (2021) &lt;<a href="https://doi.org/10.48550/arXiv.2103.15224">doi:10.48550/arXiv.2103.15224</a>&gt;) that aims to classify a sample of curves into homogeneous groups while jointly detecting the most informative portions of domain.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp,RcppArmadillo</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, fda, mclust, matrixcalc, MASS, Matrix</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/unina-sfere/sasfunclust">https://github.com/unina-sfere/sasfunclust</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/unina-sfere/sasfunclust/issues">https://github.com/unina-sfere/sasfunclust/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-04-01 17:26:24 UTC; fabio</td>
</tr>
<tr>
<td>Author:</td>
<td>Fabio Centofanti [cre, aut],
  Antonio Lepore [aut],
  Biagio Palumbo [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Fabio Centofanti &lt;fabio.centofanti@unina.it&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-04-02 11:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='sasfunclust-package'>Sparse and smooth functional data clustering</h2><span id='topic+sasfunclust'></span><span id='topic+sasfunclust-package'></span>

<h3>Description</h3>

<p>Implements the sparse and smooth functional clustering (SaS-Funclust) method (Centofanti et al. (2021) &lt;arXiv:2103.15224&gt;) that aims to classify a sample of curves into homogeneous groups while jointly detecting the most informative portions of domain.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> sasfunclust</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0.0 </td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;">  2021-04-01 </td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Fabio Centofanti, Antonio Lepore, Biagio Palumbo
</p>


<h3>References</h3>

<p>Centofanti, F., Lepore, A., &amp; Palumbo, B. (2021).
Sparse and Smooth Functional Data Clustering.
<em>arXiv preprint arXiv:2103.15224</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sasfclust">sasfclust</a></code>,  <code><a href="#topic+sasfclust_cv">sasfclust_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

n_i=20
train&lt;-simulate_data("Scenario I",n_i=n_i,sd = 1,sd2_basis = 0.5^2)
lambda_s_seq=10^seq(-4,-3)
lambda_l_seq=10^seq(-1,0)
G_seq=2
mod_cv&lt;-sasfclust_cv(X=train$X,grid=train$grid,G_seq=G_seq,
lambda_l_seq = lambda_l_seq,lambda_s_seq =lambda_s_seq,maxit = 5,K_fold = 2,q=10)
plot(mod_cv)

mod&lt;-sasfclust(X=train$X,grid=train$grid,G_seq=mod_cv$G_opt,
lambda_l = mod_cv$lambda_l_opt,lambda_s_seq =mod_cv$lambda_s_opt,maxit = 5,q=10)

print(aa$clus$classes)
plot(mod)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.sasfclust'>Plot the results of  the Sas-funclust method</h2><span id='topic+plot.sasfclust'></span><span id='topic+plot.sasfclust_cv'></span>

<h3>Description</h3>

<p>This function provides plots of the estimated cluster mean functions and of the classified curves when applied to the output of <code>sasfclust</code>, whereas
provides the cross-validation plots when applied to the output of <code>sasfclust_cv</code>. In the latter case the first plot displays the CV values as a function of  <code>G</code>, <code>lambda_s</code> and <code>lambda_l</code>;
the second plot displays the CV values as a function of <code>lambda_s</code> and <code>lambda_l</code> for <code>G</code> fixed at its optimal value;
the third plot displays the CV values as a function of <code>lambda_l</code> for <code>G</code> and <code>lambda_s</code>   fixed at their optimal value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sasfclust_cv'
plot(x, ...)

## S3 method for class 'sasfclust'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sasfclust_+3A_x">x</code></td>
<td>
<p>The output of  either <code>sasfclust</code> or <code>sasfclust_cv</code>.</p>
</td></tr>
<tr><td><code id="plot.sasfclust_+3A_...">...</code></td>
<td>
<p>No additional parameters, called for side effects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(sasfunclust)
train&lt;-simulate_data("Scenario I",n_i=20,var_e = 1,var_b = 0.5^2)
lambda_s_seq=10^seq(-4,-3)
lambda_l_seq=10^seq(-1,0)
G_seq=2
mod_cv&lt;-sasfclust_cv(X=train$X,grid=train$grid,G_seq=G_seq,
lambda_l_seq = lambda_l_seq,lambda_s_seq =lambda_s_seq,maxit = 20,K_fold = 2,q=10)
plot(mod_cv)
mod&lt;-sasfclust(X=train$X,grid=train$grid,lambda_s = 10^-6,lambda_l =10,G = 2,maxit = 20,q=10)
plot(mod)

</code></pre>

<hr>
<h2 id='sasfclust'>Sparse and Smooth Functional Data Clustering</h2><span id='topic+sasfclust'></span>

<h3>Description</h3>

<p>Sparse and smooth functional clustering (SaS-Funclust) allows to cluster a sample of curves
into homogeneous groups while jointly detecting the most informative portion of domain. (Centofanti et al., 2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sasfclust(
  X = NULL,
  timeindex = NULL,
  curve = NULL,
  grid = NULL,
  q = 30,
  lambda_l = 10,
  lambda_s = 10,
  G = 2,
  tol = 10^-7,
  maxit = 50,
  par_LQA = list(eps_diff = 1e-06, MAX_iter_LQA = 200, eps_LQA = 1e-05),
  plot = F,
  trace = F,
  init = "kmeans",
  varcon = "diagonal",
  lambda_s_ini = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sasfclust_+3A_x">X</code></td>
<td>
<p>For functional data observed over a regular grid: a matrix of where  the rows must correspond to argument values and columns to replications.
For functional data observed over an irregular grid:  a vector of length <code class="reqn">\sum_{i=1}^{N}n_i</code>, with <code class="reqn">N</code>  the number of curves,
where the entries from  <code class="reqn">\sum_{i=1}^{k-1}(n_i+1)</code> to <code class="reqn">\sum_{i=1}^{k}n_i</code> are elements representing the observations for curve <code class="reqn">k</code>.</p>
</td></tr>
<tr><td><code id="sasfclust_+3A_timeindex">timeindex</code></td>
<td>
<p>A vector of length <code class="reqn">\sum_{i=1}^{N}n_i</code>. The entries from  <code class="reqn">\sum_{i=1}^{k-1}(n_i+1)</code> to <code class="reqn">\sum_{i=1}^{k}n_i</code> provide the locations on <code>grid</code> of curve  <code class="reqn">k</code>.
So for example, if the <code class="reqn">k</code>th curve is observed at time points <code class="reqn">t_l,t_m</code> of the <code>grid</code> then the the entries from  <code class="reqn">\sum_{i=1}^{k-1}(n_i+1)</code> to <code class="reqn">\sum_{i=1}^{k}n_i</code> would be <code class="reqn">l,m</code>, being <code class="reqn">n_k=2</code>.
If X is a matrix, timeindex is ignored.</p>
</td></tr>
<tr><td><code id="sasfclust_+3A_curve">curve</code></td>
<td>
<p>A vector of length <code class="reqn">\sum_{i=1}^{N}n_i</code>. The entries from  <code class="reqn">\sum_{i=1}^{k-1}(n_i+1)</code> to <code class="reqn">\sum_{i=1}^{k}n_i</code> are equal to  <code class="reqn">k</code>.
If X is a matrix, curve is ignored.</p>
</td></tr>
<tr><td><code id="sasfclust_+3A_grid">grid</code></td>
<td>
<p>The vector of time points where the curves are sampled.
For Functional data observed over an irregular grid, <code>timeindex</code> and <code>grid</code> provide the time points for each curve.</p>
</td></tr>
<tr><td><code id="sasfclust_+3A_q">q</code></td>
<td>
<p>The dimension of the set of B-spline functions.</p>
</td></tr>
<tr><td><code id="sasfclust_+3A_lambda_l">lambda_l</code></td>
<td>
<p>Tuning parameter of the functional adaptive pairwise fusion penalty (FAPFP).</p>
</td></tr>
<tr><td><code id="sasfclust_+3A_lambda_s">lambda_s</code></td>
<td>
<p>Tuning parameter of the smoothness penalty.</p>
</td></tr>
<tr><td><code id="sasfclust_+3A_g">G</code></td>
<td>
<p>The number of clusters.</p>
</td></tr>
<tr><td><code id="sasfclust_+3A_tol">tol</code></td>
<td>
<p>The tolerance for the stopping condition of the expectation conditional maximization (ECM) algorithms.
The algorithm stops when the log-likelihood difference between two consecutive iterations is less or equal than <code>tol</code>.</p>
</td></tr>
<tr><td><code id="sasfclust_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations allowed in the ECM algorithm.</p>
</td></tr>
<tr><td><code id="sasfclust_+3A_par_lqa">par_LQA</code></td>
<td>
<p>A list of parameters for the local quadratic approximation (LQA) in the ECM algorithm.
<code>eps_diff</code> is the lower bound for the coefficient mean differences, values below <code>eps_diff</code> are set to zero.
<code>MAX_iter_LQA</code> is the maximum number of iterations allowed in the LQA.
<code>eps_LQA</code> is the tolerance for the stopping condition of LQA.</p>
</td></tr>
<tr><td><code id="sasfclust_+3A_plot">plot</code></td>
<td>
<p>If TRUE, the estimated cluster means are plotted at each iteration of the ECM algorithm. Default is FALSE.</p>
</td></tr>
<tr><td><code id="sasfclust_+3A_trace">trace</code></td>
<td>
<p>If TRUE, information are shown at each iteration of the ECM algorithm. Default is FALSE.</p>
</td></tr>
<tr><td><code id="sasfclust_+3A_init">init</code></td>
<td>
<p>It is the way to initialize the ECM algorithm. There are three ways of initialization: &quot;kmeans&quot;, &quot;model-based&quot;, and &quot;hierarchical&quot;, that
provide initialization through the k-means algorithm,  model-based clustering based on parameterized finite Gaussian mixture model, and  hierarchical clustering, respectively.
Default is &quot;kmeans&quot;.</p>
</td></tr>
<tr><td><code id="sasfclust_+3A_varcon">varcon</code></td>
<td>
<p>A vector of character strings indicating the type of coefficient covariance matrix. Three values are allowed: &quot;full&quot;, &quot;diagonal&quot;, and &quot;equal&quot;.
&quot;full&quot; means unrestricted cluster coefficient covariance matrices allowed to be different among clusters.
&quot;diagonal&quot; means diagonal cluster coefficient covariance matrices that are equal among clusters.
&quot;equal&quot; means diagonal cluster coefficient covariance matrices, with equal diagonal entries, that are equal among clusters.
Default is &quot;diagonal&quot;.</p>
</td></tr>
<tr><td><code id="sasfclust_+3A_lambda_s_ini">lambda_s_ini</code></td>
<td>
<p>The tuning parameter used to obtain the functional data through smoothing B-splines before applying the initialization algorithm.
If NULL a Generalized cross validation procedure is used as described in Ramsay (2005). Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following arguments:
<code>mod</code> that is a list composed by
</p>

<ul>
<li> <p><code>data</code>: A list containing the vectorized form of <code>X</code>, <code>timeindex</code>, and <code>curve</code>. For functional data observed over a regular grid <code>timeindex</code> and <code>curve</code> are trivially obtained.
</p>
</li>
<li> <p><code>parameters</code>: A list containing all the estimated parameters.
</p>
</li>
<li> <p><code>vars</code>: A list containing results from the Expectation step of the ECM algorithm.
</p>
</li>
<li> <p><code>FullS</code>: The matrix of B-spline computed over <code>grid</code>.
</p>
</li>
<li> <p><code>grid</code>: The vector of time points where the curves are sampled.
</p>
</li>
<li> <p><code>W</code>: The basis roughness penalty matrix containing the inner products of pairs of basis function second derivatives.
</p>
</li>
<li> <p><code>AW_vec</code>: Vectorized version of the diagonal matrix used in the approximation of FAPFP.
</p>
</li>
<li> <p><code>P_tot</code>: Sparse Matrix used to compute all the pairwise comparisons in the FAPFP.
</p>
</li>
<li> <p><code>lambda_s</code>: Tuning parameter of the smoothness penalty.
</p>
</li>
<li> <p><code>lambda_l</code>: Tuning parameter of the FAPFP.
</p>
</li></ul>

<p>A list, named <code>clus</code>, containing the following arguments:
</p>

<ul>
<li> <p><code>classes</code>: The vector of cluster membership.
</p>
</li>
<li> <p><code>po_pr</code>: Posterior probabilities of cluster membership.
</p>
</li></ul>

<p><code>mean_fd</code> The estimated cluster mean functions.
</p>
<p><code>class</code> A label for the output type.
</p>


<h3>References</h3>

<p>Centofanti, F., Lepore, A., &amp; Palumbo, B. (2021).
Sparse and Smooth Functional Data Clustering.
<em>arXiv preprint arXiv:2103.15224</em>.
</p>
<p>Ramsay, J., Ramsay, J., &amp; Silverman, B. W. (2005). Functional Data Analysis. Springer Science &amp; Business Media.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sasfclust_cv">sasfclust_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sasfunclust)
train&lt;-simulate_data("Scenario I",n_i=20,var_e = 1,var_b = 0.5^2)
mod&lt;-sasfclust(X=train$X,grid=train$grid,lambda_s = 10^-6,lambda_l =10,G = 2,maxit = 5,q=10)
plot(mod)
</code></pre>

<hr>
<h2 id='sasfclust_cv'>Cross-validation for sasfclust</h2><span id='topic+sasfclust_cv'></span>

<h3>Description</h3>

<p>K-fold cross-validation procedure to choose the number of clusters and the tuning parameters for the sparse and smooth functional clustering (SaS-Funclust) method (Centofanti et al., 2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sasfclust_cv(
  X = NULL,
  timeindex = NULL,
  curve = NULL,
  grid = NULL,
  q = 30,
  lambda_l_seq = 10^seq(-1, 2),
  lambda_s_seq = 10^seq(-5, -3),
  G_seq = 2,
  tol = 10^-7,
  maxit = 50,
  par_LQA = list(eps_diff = 1e-06, MAX_iter_LQA = 200, eps_LQA = 1e-05),
  plot = FALSE,
  trace = FALSE,
  init = "kmeans",
  varcon = "diagonal",
  lambda_s_ini = NULL,
  K_fold = 5,
  X_test = NULL,
  grid_test = NULL,
  m1 = 1,
  m2 = 0,
  m3 = 1,
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sasfclust_cv_+3A_x">X</code></td>
<td>
<p>For functional data observed over a regular grid: a matrix of where  the rows must correspond to argument values and columns to replications.
For functional data observed over an irregular grid:  a vector of length <code class="reqn">\sum_{i=1}^{N}n_i</code>, with <code class="reqn">N</code>  the number of curves,
where the entries from  <code class="reqn">\sum_{i=1}^{k-1}(n_i+1)</code> to <code class="reqn">\sum_{i=1}^{k}n_i</code> are elements representing the observations for curve <code class="reqn">k</code>.</p>
</td></tr>
<tr><td><code id="sasfclust_cv_+3A_timeindex">timeindex</code></td>
<td>
<p>A vector of length <code class="reqn">\sum_{i=1}^{N}n_i</code>. The entries from  <code class="reqn">\sum_{i=1}^{k-1}(n_i+1)</code> to <code class="reqn">\sum_{i=1}^{k}n_i</code> provide the locations on <code>grid</code> of curve  <code class="reqn">k</code>.
So for example, if the <code class="reqn">k</code>th curve is observed at time points <code class="reqn">t_l,t_m</code> of the <code>grid</code> then the the entries from  <code class="reqn">\sum_{i=1}^{k-1}(n_i+1)</code> to <code class="reqn">\sum_{i=1}^{k}n_i</code> would be <code class="reqn">l,m</code>, being <code class="reqn">n_k=2</code>.
If X is a matrix, timeindex is ignored.</p>
</td></tr>
<tr><td><code id="sasfclust_cv_+3A_curve">curve</code></td>
<td>
<p>A vector of length <code class="reqn">\sum_{i=1}^{N}n_i</code>. The entries from  <code class="reqn">\sum_{i=1}^{k-1}(n_i+1)</code> to <code class="reqn">\sum_{i=1}^{k}n_i</code> are equal to  <code class="reqn">k</code>.
If X is a matrix, curve is ignored.</p>
</td></tr>
<tr><td><code id="sasfclust_cv_+3A_grid">grid</code></td>
<td>
<p>The vector of time points where the curves are sampled.
For Functional data observed over an irregular grid, <code>timeindex</code> and <code>grid</code> provide the time points for each curve.</p>
</td></tr>
<tr><td><code id="sasfclust_cv_+3A_q">q</code></td>
<td>
<p>The dimension of the set of B-spline functions.</p>
</td></tr>
<tr><td><code id="sasfclust_cv_+3A_lambda_l_seq">lambda_l_seq</code></td>
<td>
<p>Sequence of tuning parameter of the functional adaptive pairwise fusion penalty (FAPFP).</p>
</td></tr>
<tr><td><code id="sasfclust_cv_+3A_lambda_s_seq">lambda_s_seq</code></td>
<td>
<p>Sequence of tuning parameter of the smoothness penalty.</p>
</td></tr>
<tr><td><code id="sasfclust_cv_+3A_g_seq">G_seq</code></td>
<td>
<p>Sequence of number of clusters.</p>
</td></tr>
<tr><td><code id="sasfclust_cv_+3A_tol">tol</code></td>
<td>
<p>The tolerance for the stopping condition of the expectation conditional maximization (ECM) algorithms.
The algorithm stops when the log-likelihood difference between two consecutive iterations is less or equal than <code>tol</code>.</p>
</td></tr>
<tr><td><code id="sasfclust_cv_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations allowed in the ECM algorithm.</p>
</td></tr>
<tr><td><code id="sasfclust_cv_+3A_par_lqa">par_LQA</code></td>
<td>
<p>A list of parameters for the local quadratic approximation (LQA) in the ECM algorithm.
<code>eps_diff</code> is the lower bound for the coefficient mean differences, values below <code>eps_diff</code> are set to zero.
<code>MAX_iter_LQA</code> is the maximum number of iterations allowed in the LQA.
<code>eps_LQA</code> is the tolerance for the stopping condition of LQA.</p>
</td></tr>
<tr><td><code id="sasfclust_cv_+3A_plot">plot</code></td>
<td>
<p>If TRUE, the estimated cluster means are plotted at each iteration of the ECM algorithm. Default is FALSE.</p>
</td></tr>
<tr><td><code id="sasfclust_cv_+3A_trace">trace</code></td>
<td>
<p>If TRUE, information are shown at each iteration of the ECM algorithm. Default is FALSE.</p>
</td></tr>
<tr><td><code id="sasfclust_cv_+3A_init">init</code></td>
<td>
<p>It is the way to initialize the ECM algorithm. There are three ways of initialization: &quot;kmeans&quot;, &quot;model-based&quot;, and &quot;hierarchical&quot;, that
provide initialization through the k-means algorithm,  model-based clustering based on parameterized finite Gaussian mixture model, and  hierarchical clustering, respectively.
Default is &quot;kmeans&quot;.</p>
</td></tr>
<tr><td><code id="sasfclust_cv_+3A_varcon">varcon</code></td>
<td>
<p>A vector of character strings indicating the type of coefficient covariance matrix. Three values are allowed: &quot;full&quot;, &quot;diagonal&quot;, and &quot;equal&quot;.
&quot;full&quot; means unrestricted cluster coefficient covariance matrices allowed to be different among clusters.
&quot;diagonal&quot; means diagonal cluster coefficient covariance matrices that are equal among clusters.
&quot;equal&quot; means diagonal cluster coefficient covariance matrices, with equal diagonal entries, that are equal among clusters.
Default is &quot;diagonal&quot;.</p>
</td></tr>
<tr><td><code id="sasfclust_cv_+3A_lambda_s_ini">lambda_s_ini</code></td>
<td>
<p>The tuning parameter used to obtain the functional data through smoothing B-splines before applying the initialization algorithm.
If NULL a Generalized cross validation procedure is used as described in Ramsay (2005). Default is NULL.</p>
</td></tr>
<tr><td><code id="sasfclust_cv_+3A_k_fold">K_fold</code></td>
<td>
<p>Number of folds. Default is 5.</p>
</td></tr>
<tr><td><code id="sasfclust_cv_+3A_x_test">X_test</code></td>
<td>
<p>Only for functional data observed over a regular grid, a matrix  where  the rows must correspond to argument values and columns to replications of the test set. Default in NULL.</p>
</td></tr>
<tr><td><code id="sasfclust_cv_+3A_grid_test">grid_test</code></td>
<td>
<p>The vector of time points where the test set curves are sampled. Default is NULL.</p>
</td></tr>
<tr><td><code id="sasfclust_cv_+3A_m1">m1</code></td>
<td>
<p>The m-standard deviation rule parameter to choose <code>G</code> for each <code>lambda_s</code> and <code>lambda_l</code>.</p>
</td></tr>
<tr><td><code id="sasfclust_cv_+3A_m2">m2</code></td>
<td>
<p>The m-standard deviation rule parameter to choose <code>lambda_s</code> fixed <code>G</code> for each <code>lambda_l</code>.</p>
</td></tr>
<tr><td><code id="sasfclust_cv_+3A_m3">m3</code></td>
<td>
<p>The m-standard deviation rule parameter to choose <code>lambda_l</code> fixed <code>G</code> and <code>lambda_s</code>.</p>
</td></tr>
<tr><td><code id="sasfclust_cv_+3A_ncores">ncores</code></td>
<td>
<p>If <code>ncores</code>&gt;1, then parallel computing is used, with <code>ncores</code> cores. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following arguments:
</p>
<p><code>G_opt</code>: The optimal  number of clusters.
</p>
<p><code>lambda_l_opt</code>: The optimal tuning parameter of the FAPFP.
</p>
<p><code>lambda_s_opt</code>: The optimal tuning parameter of the smoothness penalty.
</p>
<p><code>comb_list</code>: The combinations of <code>G</code>,<code>lambda_s</code> and <code>lambda_l</code> explored.
</p>
<p><code>CV</code>: The cross-validation values obtained for each combination of <code>G</code>,<code>lambda_s</code> and <code>lambda_l</code>.
</p>
<p><code>CV_sd</code>: The standard deviations of the cross-validation values.
</p>
<p><code>zeros</code>: Fraction of domain over which the estimated cluster means are fused.
</p>
<p><code>ms</code>: The m-standard deviation rule parameters.
</p>
<p><code>class</code>: A label for the output type.
</p>


<h3>References</h3>

<p>Centofanti, F., Lepore, A., &amp; Palumbo, B. (2021).
Sparse and Smooth Functional Data Clustering.
<em>arXiv preprint arXiv:2103.15224</em>.
</p>
<p>Ramsay, J., Ramsay, J., &amp; Silverman, B. W. (2005). Functional Data Analysis. Springer Science &amp; Business Media.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sasfclust">sasfclust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(sasfunclust)
train&lt;-simulate_data("Scenario I",n_i=20,var_e = 1,var_b = 0.5^2)
lambda_s_seq=10^seq(-4,-3)
lambda_l_seq=10^seq(-1,0)
G_seq=2
mod_cv&lt;-sasfclust_cv(X=train$X,grid=train$grid,G_seq=G_seq,
lambda_l_seq = lambda_l_seq,lambda_s_seq =lambda_s_seq,maxit = 20,K_fold = 2,q=10)
plot(mod_cv)

</code></pre>

<hr>
<h2 id='simulate_data'>Simulate data for functional clustering</h2><span id='topic+simulate_data'></span>

<h3>Description</h3>

<p>Generate synthetic data as in the simulation study of Centofanti et al., 2021.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_data(
  scenario,
  n_i = 50,
  nbasis = 30,
  length_tot = 50,
  var_e = 1,
  var_b = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_data_+3A_scenario">scenario</code></td>
<td>
<p>A  character strings indicating the scenario considered. It could be &quot;Scenario I&quot;, &quot;Scenario II&quot;, and &quot;Scenario III&quot;.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_n_i">n_i</code></td>
<td>
<p>Number of curves in each cluster.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_nbasis">nbasis</code></td>
<td>
<p>The dimension of the set of B-spline functions.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_length_tot">length_tot</code></td>
<td>
<p>Number of evaluation points.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_var_e">var_e</code></td>
<td>
<p>Variance of the measurement error.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_var_b">var_b</code></td>
<td>
<p>Diagonal entries of the coefficient variance matrix, which is assumed to be diagonal, with equal diagonal entries, and the same among clusters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following arguments:
</p>
<p><code>X</code>: Observation matrix, where  the rows  correspond to argument values and columns to replications.
</p>
<p><code>X_fd</code>: Functional observations without measurement error.
</p>
<p><code>mu_fd</code>: True cluster mean function.
</p>
<p><code>grid</code>: The vector of time points where the curves are sampled.
</p>
<p><code>clus</code>: True cluster membership vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sasfunclust)
train&lt;-simulate_data("Scenario I",n_i=20,var_e = 1,var_b = 0.5^2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
