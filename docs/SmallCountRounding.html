<!DOCTYPE html><html><head><title>Help for package SmallCountRounding</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SmallCountRounding}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aggrtab'><p>function aggrtab</p></a></li>
<li><a href='#FindMaxDiff'><p>Calculate maxdiff  nMaxdiff</p></a></li>
<li><a href='#HD'><p>Hellinger Distance (Utility)</p></a></li>
<li><a href='#Lists2formula'><p>Make formula from input parameters to makeroundtabs()</p></a></li>
<li><a href='#MakeControl'><p>Make suggested control - input to makeroundtabs()</p></a></li>
<li><a href='#makeroundtabs'><p>function makeroundtabs</p></a></li>
<li><a href='#PLS2way'><p>Two-way table from PLSrounding output</p></a></li>
<li><a href='#PLSrounding'><p>PLS inspired rounding</p></a></li>
<li><a href='#PLSroundingFits'><p>Small count rounding with post-processing to expected frequencies</p></a></li>
<li><a href='#PLSroundingLoop'><p>PLSrounding on portions of data at a time</p></a></li>
<li><a href='#print.PLSrounded'><p>Print method for PLSrounded</p></a></li>
<li><a href='#redcube'><p>function redcube</p></a></li>
<li><a href='#Round2'><p>Small count rounding by various methods</p></a></li>
<li><a href='#roundcube'><p>function roundcube</p></a></li>
<li><a href='#RoundViaDummy'><p>Small Count Rounding of Tabular Data</p></a></li>
<li><a href='#RoundViaDummy2'><p>RoundViaDummy2</p></a></li>
<li><a href='#SmallCountData'><p>Function that returns a dataset</p></a></li>
<li><a href='#SmallCountRounding-package'><p>Small Count Rounding of Tabular Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Small Count Rounding of Tabular Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-16</td>
</tr>
<tr>
<td>Author:</td>
<td>Øyvind Langsrud [aut, cre],
  Johan Heldal [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Øyvind Langsrud &lt;oyl@ssb.no&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>Matrix, SSBtools (&ge; 1.3.4)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, kableExtra, sdcHierarchies, testthat</td>
</tr>
<tr>
<td>Description:</td>
<td>A statistical disclosure control tool to protect frequency tables in cases where small values are sensitive. The function PLSrounding() performs small count rounding of necessary inner cells so that all small frequencies of cross-classifications to be published (publishable cells) are rounded. This is equivalent to changing micro data since frequencies of unique combinations are changed. Thus, additivity and consistency are guaranteed. The methodology is described in Langsrud and Heldal (2018) <a href="https://www.researchgate.net/publication/327768398_An_Algorithm_for_Small_Count_Rounding_of_Tabular_Data">https://www.researchgate.net/publication/327768398_An_Algorithm_for_Small_Count_Rounding_of_Tabular_Data</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/statisticsnorway/SmallCountRounding">https://github.com/statisticsnorway/SmallCountRounding</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/statisticsnorway/SmallCountRounding/issues">https://github.com/statisticsnorway/SmallCountRounding/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-16 11:37:33 UTC; oyl</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-16 15:00:17 UTC</td>
</tr>
</table>
<hr>
<h2 id='aggrtab'>function aggrtab</h2><span id='topic+aggrtab'></span>

<h3>Description</h3>

<p>function aggrtab
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggrtab(A, d, micro = TRUE, nin = "n", nout = "n")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggrtab_+3A_a">A</code></td>
<td>
<p>A data frame representing a micro dataset or a frequency count hypercube. The (first) columns
define the variables. If A is a hypercube the last column contains the number of units in each cell.</p>
</td></tr>
<tr><td><code id="aggrtab_+3A_d">d</code></td>
<td>
<p>A list d[[j]] whose elements are vectors of variable names from A defining marginal tables/cubes 
of A that we are interested in.</p>
</td></tr>
<tr><td><code id="aggrtab_+3A_micro">micro</code></td>
<td>
<p>Logical. TRUE if A is a micro dataset (default). FALSE if A i a frequency count hypercube.</p>
</td></tr>
<tr><td><code id="aggrtab_+3A_nin">nin</code></td>
<td>
<p>Name of count variable if A is a hypercube. Default name: &quot;n&quot;.</p>
</td></tr>
<tr><td><code id="aggrtab_+3A_nout">nout</code></td>
<td>
<p>Name of the frequency count variable in the output tables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>D = D[[j]] of marginal tables/cubes of A spesified by the list d = d[[j]] generated 
by aggregating over cells in A.
</p>


<h3>Author(s)</h3>

<p>Johan Heldal, November 2017
</p>

<hr>
<h2 id='FindMaxDiff'>Calculate maxdiff  nMaxdiff</h2><span id='topic+FindMaxDiff'></span>

<h3>Description</h3>

<p>Calculate maxdiff  nMaxdiff
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindMaxDiff(data, control, original, rounded, datareturn = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindMaxDiff_+3A_data">data</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="FindMaxDiff_+3A_control">control</code></td>
<td>
<p>control</p>
</td></tr>
<tr><td><code id="FindMaxDiff_+3A_original">original</code></td>
<td>
<p>original</p>
</td></tr>
<tr><td><code id="FindMaxDiff_+3A_rounded">rounded</code></td>
<td>
<p>rounded</p>
</td></tr>
<tr><td><code id="FindMaxDiff_+3A_datareturn">datareturn</code></td>
<td>
<p>datareturn</p>
</td></tr>
</table>


<h3>Value</h3>

<p>maxdiff and nMaxdiff
</p>

<hr>
<h2 id='HD'>Hellinger Distance (Utility)</h2><span id='topic+HD'></span><span id='topic+HDutility'></span>

<h3>Description</h3>

<p>Hellinger distance (<code>HD</code>) and a related utility measure (<code>HDutility</code>)
described in the reference below.
The utility measure is made to be bounded between 0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HD(f, g)

HDutility(f, g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HD_+3A_f">f</code></td>
<td>
<p>Vector of original counts</p>
</td></tr>
<tr><td><code id="HD_+3A_g">g</code></td>
<td>
<p>Vector of perturbed counts</p>
</td></tr>
</table>


<h3>Details</h3>

<p>HD is defined as &quot;<code>sqrt(sum((sqrt(f) - sqrt(g))^2)/2)</code>&quot; and
HDutility  is defined as &quot;<code>1 - HD(f, g)/sqrt(sum(f))</code>&quot;.
</p>


<h3>Value</h3>

<p>Hellinger distance or related utility measure
</p>


<h3>References</h3>

<p>Shlomo, N., Antal, L., &amp; Elliot, M. (2015).
Measuring Disclosure Risk and Data Utility for Flexible Table Generators,
Journal of Official Statistics, 31(2), 305-324. <a href="https://doi.org/10.1515/jos-2015-0019">doi:10.1515/jos-2015-0019</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- 1:6
g &lt;- c(0, 3, 3, 3, 6, 6)
print(c(
  HD = HD(f, g), 
  HDutility = HDutility(f, g), 
  maxdiff = max(abs(g - f)), 
  meanAbsDiff = mean(abs(g - f)), 
  rootMeanSquare = sqrt(mean((g - f)^2))
))
</code></pre>

<hr>
<h2 id='Lists2formula'>Make formula from input parameters to makeroundtabs()</h2><span id='topic+Lists2formula'></span>

<h3>Description</h3>

<p>Make formula from input parameters to makeroundtabs()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lists2formula(d, control = NULL, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lists2formula_+3A_d">d</code></td>
<td>
<p>d</p>
</td></tr>
<tr><td><code id="Lists2formula_+3A_control">control</code></td>
<td>
<p>control</p>
</td></tr>
<tr><td><code id="Lists2formula_+3A_data">data</code></td>
<td>
<p>data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>formula as string
</p>

<hr>
<h2 id='MakeControl'>Make suggested control - input to makeroundtabs()</h2><span id='topic+MakeControl'></span>

<h3>Description</h3>

<p>Make suggested control - input to makeroundtabs()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeControl(d, data, level = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MakeControl_+3A_d">d</code></td>
<td>
<p>as input to <code>makeroundtabs()</code></p>
</td></tr>
<tr><td><code id="MakeControl_+3A_data">data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="MakeControl_+3A_level">level</code></td>
<td>
<p>Interaction level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>

<hr>
<h2 id='makeroundtabs'>function makeroundtabs</h2><span id='topic+makeroundtabs'></span>

<h3>Description</h3>

<p>This function creates a set of consistently rounded frequency count tables or
hypercubes by means of a version of small count rounding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeroundtabs(
  A,
  b = 3,
  d,
  micro = "TRUE",
  sort,
  control,
  nin = "n",
  nout = "n",
  minit = 3,
  maxit = 3,
  maxdiff = 5,
  seed
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeroundtabs_+3A_a">A</code></td>
<td>
<p>A data frame representing a micro dataset or a frequency count hypercube. The (first) columns
define the variables. If A is a hypercube the last column contains the number of units in each cell.
If A is a micro dataset it is reduced to hypercube by the function aggrtab.</p>
</td></tr>
<tr><td><code id="makeroundtabs_+3A_b">b</code></td>
<td>
<p>Rounding base. Counts in A less than b tat are contributing to counts less than b in the marginal 
cubes D are selected from A. The selected dataframe is called B</p>
</td></tr>
<tr><td><code id="makeroundtabs_+3A_d">d</code></td>
<td>
<p>A list d[[j]] whose elements are vectors of variable names from A defining marginal tables/cubes D
of A that we are interested in.</p>
</td></tr>
<tr><td><code id="makeroundtabs_+3A_micro">micro</code></td>
<td>
<p>Logical. TRUE if A is a micro dataset (default). FALSE if A i a frequency count hypercube.</p>
</td></tr>
<tr><td><code id="makeroundtabs_+3A_sort">sort</code></td>
<td>
<p>An ordered list of variables in hypercubes in D meant for priority sorting of the reduced 
hypercube B before rounding. Not all variables in D should be included.</p>
</td></tr>
<tr><td><code id="makeroundtabs_+3A_control">control</code></td>
<td>
<p>A list of marginals of the hypercubes in D where deviations of aggregated rounded counts
are checked against original counts.</p>
</td></tr>
<tr><td><code id="makeroundtabs_+3A_nin">nin</code></td>
<td>
<p>Name of count variable if A is a hypercube. Default name: &quot;n&quot;.</p>
</td></tr>
<tr><td><code id="makeroundtabs_+3A_nout">nout</code></td>
<td>
<p>Name of the frequency count variable in the output tables.</p>
</td></tr>
<tr><td><code id="makeroundtabs_+3A_minit">minit</code></td>
<td>
<p>Minimum number of searches to be carried out.</p>
</td></tr>
<tr><td><code id="makeroundtabs_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of searches to be carried out.</p>
</td></tr>
<tr><td><code id="makeroundtabs_+3A_maxdiff">maxdiff</code></td>
<td>
<p>If maximum difference in &quot;control&quot; is no larger than maxit, the stop search.</p>
</td></tr>
<tr><td><code id="makeroundtabs_+3A_seed">seed</code></td>
<td>
<p>Input seed for first systematic random search.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Ar: The rounded version of A
</p>
<p>Br: The rounded version of B
</p>
<p>D: The original hypercube of interest.
</p>
<p>Dr: The rounded version of D. The final table of interest.
</p>
<p>maxdiff: The largest absolute difference between cells D and Dr among cells in the control list.
</p>
<p>nmaxdiff: The number of occurences if Maxdiff
</p>


<h3>Author(s)</h3>

<p>Johan Heldal, January 2018
</p>


<h3>See Also</h3>

<p>Dependencies:  <code><a href="#topic+aggrtab">aggrtab</a></code>, <code><a href="#topic+redcube">redcube</a></code>, <code><a href="#topic+roundcube">roundcube</a></code>
</p>

<hr>
<h2 id='PLS2way'>Two-way table from PLSrounding output</h2><span id='topic+PLS2way'></span>

<h3>Description</h3>

<p>Output from <code><a href="#topic+PLSrounding">PLSrounding</a></code> is presented as two-way table(s) in cases where this is possible.
A requirement is that the number of main dimensional variables is two.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLS2way(obj, variable = c("rounded", "original", "difference", "code"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLS2way_+3A_obj">obj</code></td>
<td>
<p>Output object from <code><a href="#topic+PLSrounding">PLSrounding</a></code></p>
</td></tr>
<tr><td><code id="PLS2way_+3A_variable">variable</code></td>
<td>
<p>One of <code>"rounded"</code> (default), <code>"original"</code>, <code>"difference"</code> or <code>"code"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When parameter <code>"variable"</code> is <code>"code"</code>, output is coded as  <code>"#"</code> (publish), <code>"."</code> (inner) and <code>"&amp;"</code> (both).
</p>


<h3>Value</h3>

<p>A data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Making tables from PLSrounding examples 
z &lt;- SmallCountData("e6")
a &lt;- PLSrounding(z, "freq", formula = ~eu * year + geo)
PLS2way(a, "original")
PLS2way(a, "difference")
PLS2way(a, "code")
PLS2way(PLSrounding(z, "freq", formula = ~eu * year + geo * year), "code")
eHrc2 &lt;- list(geo = c("EU", "@Portugal", "@Spain", "Iceland"), year = c("2018", "2019"))
PLS2way(PLSrounding(z, "freq", hierarchies = eHrc2))
</code></pre>

<hr>
<h2 id='PLSrounding'>PLS inspired rounding</h2><span id='topic+PLSrounding'></span><span id='topic+PLSroundingInner'></span><span id='topic+PLSroundingPublish'></span>

<h3>Description</h3>

<p>Small count rounding of necessary inner cells are performed so that all small frequencies of cross-classifications to be published
(publishable cells) are rounded. The publishable cells can be defined from a model formula, hierarchies or automatically from data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLSrounding(
  data,
  freqVar = NULL,
  roundBase = 3,
  hierarchies = NULL,
  formula = NULL,
  dimVar = NULL,
  maxRound = roundBase - 1,
  printInc = nrow(data) &gt; 1000,
  output = NULL,
  preAggregate = is.null(freqVar),
  ...
)

PLSroundingInner(..., output = "inner")

PLSroundingPublish(..., output = "publish")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLSrounding_+3A_data">data</code></td>
<td>
<p>Input data as a data frame (inner cells)</p>
</td></tr>
<tr><td><code id="PLSrounding_+3A_freqvar">freqVar</code></td>
<td>
<p>Variable holding counts (inner cells frequencies).  When <code>NULL</code> (default), microdata is assumed.</p>
</td></tr>
<tr><td><code id="PLSrounding_+3A_roundbase">roundBase</code></td>
<td>
<p>Rounding base</p>
</td></tr>
<tr><td><code id="PLSrounding_+3A_hierarchies">hierarchies</code></td>
<td>
<p>List of hierarchies</p>
</td></tr>
<tr><td><code id="PLSrounding_+3A_formula">formula</code></td>
<td>
<p>Model formula defining publishable cells</p>
</td></tr>
<tr><td><code id="PLSrounding_+3A_dimvar">dimVar</code></td>
<td>
<p>The main dimensional variables and additional aggregating variables. This parameter can be  useful when hierarchies and formula are unspecified.</p>
</td></tr>
<tr><td><code id="PLSrounding_+3A_maxround">maxRound</code></td>
<td>
<p>Inner cells contributing to original publishable cells equal to or less than maxRound will be rounded</p>
</td></tr>
<tr><td><code id="PLSrounding_+3A_printinc">printInc</code></td>
<td>
<p>Printing iteration information to console when TRUE</p>
</td></tr>
<tr><td><code id="PLSrounding_+3A_output">output</code></td>
<td>
<p>Possible non-NULL values are <code>"input"</code>, <code>"inner"</code> and <code>"publish"</code>. Then a single data frame is returned.</p>
</td></tr>
<tr><td><code id="PLSrounding_+3A_preaggregate">preAggregate</code></td>
<td>
<p>When <code>TRUE</code>, the data will be aggregated beforehand within the function by the dimensional variables.</p>
</td></tr>
<tr><td><code id="PLSrounding_+3A_...">...</code></td>
<td>
<p>Further parameters sent to <code>RoundViaDummy</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a user-friendly wrapper for <code>RoundViaDummy</code> with data frame output and with computed summary of the results.
See <code><a href="#topic+RoundViaDummy">RoundViaDummy</a></code> for more details.
</p>


<h3>Value</h3>

<p>Output is a four-element list with class attribute &quot;PLSrounded&quot; (to ensure informative printing).
</p>
<table>
<tr><td><code>inner</code></td>
<td>
<p>Data frame corresponding to input data with the main dimensional variables and with cell
frequencies (original, rounded, difference).</p>
</td></tr>
<tr><td><code>publish</code></td>
<td>
<p>Data frame of publishable data with the main dimensional variables and with cell frequencies
(original, rounded, difference).</p>
</td></tr>
<tr><td><code>metrics</code></td>
<td>
<p>A named character vector of various statistics calculated from the two output data frames
(&quot;<code>inner_</code>&quot; used to distinguish). See examples below and the function <code><a href="#topic+HDutility">HDutility</a></code>.</p>
</td></tr>
<tr><td><code>freqTable</code></td>
<td>
<p>Matrix of frequencies of cell frequencies and absolute differences.
For example, row &quot;<code>rounded</code>&quot; and column &quot;<code>inn.4+</code>&quot; is the number of rounded
inner cell frequencies greater than or equal to <code>4</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Langsrud, Ø. and Heldal, J. (2018): &ldquo;An Algorithm for Small Count Rounding of Tabular Data&rdquo;.
Presented at: <em>Privacy in statistical databases</em>, Valencia, Spain. September 26-28, 2018.
<a href="https://www.researchgate.net/publication/327768398_An_Algorithm_for_Small_Count_Rounding_of_Tabular_Data">https://www.researchgate.net/publication/327768398_An_Algorithm_for_Small_Count_Rounding_of_Tabular_Data</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RoundViaDummy">RoundViaDummy</a></code>, <code><a href="#topic+PLS2way">PLS2way</a></code>, <code><a href="SSBtools.html#topic+ModelMatrix">ModelMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Small example data set
z &lt;- SmallCountData("e6")
print(z)

# Publishable cells by formula interface
a &lt;- PLSrounding(z, "freq", roundBase = 5,  formula = ~geo + eu + year)
print(a)
print(a$inner)
print(a$publish)
print(a$metrics)
print(a$freqTable)

# Recalculation of maxdiff, HDutility, meanAbsDiff and rootMeanSquare
max(abs(a$publish[, "difference"]))
HDutility(a$publish[, "original"], a$publish[, "rounded"])
mean(abs(a$publish[, "difference"]))
sqrt(mean((a$publish[, "difference"])^2))

# Six lines below produce equivalent results 
# Ordering of rows can be different
PLSrounding(z, "freq") # All variables except "freq" as dimVar  
PLSrounding(z, "freq", dimVar = c("geo", "eu", "year"))
PLSrounding(z, "freq", formula = ~eu * year + geo * year)
PLSrounding(z[, -2], "freq", hierarchies = SmallCountData("eHrc"))
PLSrounding(z[, -2], "freq", hierarchies = SmallCountData("eDimList"))
PLSrounding(z[, -2], "freq", hierarchies = SmallCountData("eDimList"), formula = ~geo * year)

# Define publishable cells differently by making use of formula interface
PLSrounding(z, "freq", formula = ~eu * year + geo)

# Define publishable cells differently by making use of hierarchy interface
eHrc2 &lt;- list(geo = c("EU", "@Portugal", "@Spain", "Iceland"), year = c("2018", "2019"))
PLSrounding(z, "freq", hierarchies = eHrc2)

# Also possible to combine hierarchies and formula
PLSrounding(z, "freq", hierarchies = SmallCountData("eDimList"), formula = ~geo + year)

# Single data frame output
PLSroundingInner(z, "freq", roundBase = 5, formula = ~geo + eu + year)
PLSroundingPublish(z, roundBase = 5, formula = ~geo + eu + year)

# Microdata input
PLSroundingInner(rbind(z, z), roundBase = 5, formula = ~geo + eu + year)

# Parameter avoidHierarchical (see RoundViaDummy and ModelMatrix) 
PLSroundingPublish(z, roundBase = 5, formula = ~geo + eu + year, avoidHierarchical = TRUE)

# Package sdcHierarchies can be used to create hierarchies. 
# The small example code below works if this package is available. 
if (require(sdcHierarchies)) {
  z2 &lt;- cbind(geo = c("11", "21", "22"), z[, 3:4], stringsAsFactors = FALSE)
  h2 &lt;- list(
    geo = hier_compute(inp = unique(z2$geo), dim_spec = c(1, 1), root = "Tot", as = "df"),
    year = hier_convert(hier_create(root = "Total", nodes = c("2018", "2019")), as = "df"))
  PLSrounding(z2, "freq", hierarchies = h2)
}

# Use PLS2way to produce tables as in Langsrud and Heldal (2018) and to demonstrate 
# parameters maxRound, zeroCandidates and identifyNew (see RoundViaDummy).   
# Parameter rndSeed used to ensure same output as in reference.
exPSD &lt;- SmallCountData("exPSD")
a &lt;- PLSrounding(exPSD, "freq", 5, formula = ~rows + cols, rndSeed=124)
PLS2way(a, "original")  # Table 1
PLS2way(a)  # Table 2
a &lt;- PLSrounding(exPSD, "freq", 5, formula = ~rows + cols, identifyNew = FALSE, rndSeed=124)
PLS2way(a)  # Table 3
a &lt;- PLSrounding(exPSD, "freq", 5, formula = ~rows + cols, maxRound = 7)
PLS2way(a)  # Values in col1 rounded
a &lt;- PLSrounding(exPSD, "freq", 5, formula = ~rows + cols, zeroCandidates = TRUE)
PLS2way(a)  # (row3, col4): original is 0 and rounded is 5
</code></pre>

<hr>
<h2 id='PLSroundingFits'>Small count rounding with post-processing to expected frequencies</h2><span id='topic+PLSroundingFits'></span>

<h3>Description</h3>

<p>The counts rounded by <code><a href="#topic+PLSrounding">PLSrounding</a></code>
Thereafter, based on the publishable rounded data, expected inner cell frequencies are generated by iterative proportional fitting using <code><a href="SSBtools.html#topic+Mipf">Mipf</a></code>.
To ensure that empty cells missing in input data are included in the fitting process, the data is first extended using <code><a href="SSBtools.html#topic+Extend0">Extend0</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLSroundingFits(
  data,
  freqVar = NULL,
  roundBase = 3,
  hierarchies = NULL,
  formula = NULL,
  dimVar = NULL,
  preAggregate = is.null(freqVar),
  xReturn = FALSE,
  extend0 = TRUE,
  limit = 1e-10,
  viaQR = FALSE,
  iter = 1000,
  eps = 0.01,
  tol = 1e-13,
  reduceBy0 = TRUE,
  reduceByColSums = TRUE,
  reduceByLeverage = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLSroundingFits_+3A_data">data</code></td>
<td>
<p>data frame (inner cells)</p>
</td></tr>
<tr><td><code id="PLSroundingFits_+3A_freqvar">freqVar</code></td>
<td>
<p>Variable holding counts</p>
</td></tr>
<tr><td><code id="PLSroundingFits_+3A_roundbase">roundBase</code></td>
<td>
<p>Rounding base</p>
</td></tr>
<tr><td><code id="PLSroundingFits_+3A_hierarchies">hierarchies</code></td>
<td>
<p>List of hierarchies</p>
</td></tr>
<tr><td><code id="PLSroundingFits_+3A_formula">formula</code></td>
<td>
<p>Model formula</p>
</td></tr>
<tr><td><code id="PLSroundingFits_+3A_dimvar">dimVar</code></td>
<td>
<p>Dimensional variables</p>
</td></tr>
<tr><td><code id="PLSroundingFits_+3A_preaggregate">preAggregate</code></td>
<td>
<p>Aggregation</p>
</td></tr>
<tr><td><code id="PLSroundingFits_+3A_xreturn">xReturn</code></td>
<td>
<p>Dummy matrix in output when <code>TRUE</code>. To return crossTable as well, use <code>xReturn = 2</code>.</p>
</td></tr>
<tr><td><code id="PLSroundingFits_+3A_extend0">extend0</code></td>
<td>
<p>Data is automatically extended by <code>Extend0</code> when <code>TRUE</code>. Can also be specified as a list meaning parameter <code>varGroups</code> to <code>Extend0</code>.</p>
</td></tr>
<tr><td><code id="PLSroundingFits_+3A_limit">limit</code></td>
<td>
<p><code>LSfitNonNeg</code> parameter</p>
</td></tr>
<tr><td><code id="PLSroundingFits_+3A_viaqr">viaQR</code></td>
<td>
<p><code>LSfitNonNeg</code> parameter</p>
</td></tr>
<tr><td><code id="PLSroundingFits_+3A_iter">iter</code></td>
<td>
<p><code>Mipf</code> parameter</p>
</td></tr>
<tr><td><code id="PLSroundingFits_+3A_eps">eps</code></td>
<td>
<p><code>Mipf</code> parameter</p>
</td></tr>
<tr><td><code id="PLSroundingFits_+3A_tol">tol</code></td>
<td>
<p><code>Mipf</code> parameter</p>
</td></tr>
<tr><td><code id="PLSroundingFits_+3A_reduceby0">reduceBy0</code></td>
<td>
<p><code>Mipf</code> parameter</p>
</td></tr>
<tr><td><code id="PLSroundingFits_+3A_reducebycolsums">reduceByColSums</code></td>
<td>
<p><code>Mipf</code> parameter</p>
</td></tr>
<tr><td><code id="PLSroundingFits_+3A_reducebyleverage">reduceByLeverage</code></td>
<td>
<p><code>Mipf</code> parameter</p>
</td></tr>
<tr><td><code id="PLSroundingFits_+3A_...">...</code></td>
<td>
<p>Further parameters to <code><a href="#topic+PLSrounding">PLSrounding</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The seven first parameters is documented in more detail in <code><a href="#topic+PLSrounding">PLSrounding</a></code>.
If iterative proportional fitting succeeds, the maximum difference between rounded counts and <code>ipFit</code> is less than input parameter <code>eps</code>.
</p>


<h3>Value</h3>

<p>Output from <code><a href="#topic+PLSrounding">PLSrounding</a></code> (class attribute &quot;PLSrounded&quot;) with modified versions of <code>inner</code> and <code>publish</code>:
</p>
<table>
<tr><td><code>inner</code></td>
<td>
<p>Extended with more input data variables and with expected frequencies (<code>ipFit</code>).</p>
</td></tr>
<tr><td><code>publish</code></td>
<td>
<p>Extended with aggregated expected frequencies (<code>ipFit</code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- data.frame(geo  = c("Iceland", "Portugal", "Spain"), 
                eu = c("nonEU", "EU", "EU"),
                year = rep(c("2018","2019"), each = 3),
                freq = c(2,3,7,1,5,6), stringsAsFactors = FALSE)
z4 &lt;- z[-c(1:2), ]

PLSroundingFits(z4, "freq", formula = ~eu * year + geo, extend0 = FALSE)[c("inner", "publish")]
PLSroundingFits(z4, "freq", formula = ~eu * year + geo)[c("inner", "publish")]

my_km2 &lt;- SSBtools::SSBtoolsData("my_km2")

# Default automatic extension (extend0 = TRUE)
PLSroundingFits(my_km2, "freq", 
       formula = ~(Sex + Age) * Municipality * Square1000m + Square250m)[c("inner", "publish")]

# Manual specification to avoid Nittedal combined with another_km
PLSroundingFits(my_km2, "freq", formula = ~(Sex + Age) * Municipality * Square1000m + Square250m, 
       extend0 = list(c("Sex", "Age"), 
       c("Municipality", "Square1000m", "Square250m")))[c("inner", "publish")]
</code></pre>

<hr>
<h2 id='PLSroundingLoop'>PLSrounding on portions of data at a time</h2><span id='topic+PLSroundingLoop'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+PLSrounding">PLSrounding</a></code> runs are coordinated by using preliminary differences as input for the next run (parameter <code>preDifference</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLSroundingLoop(
  data,
  loopId,
  ...,
  zeroCandidates = FALSE,
  forceInner = FALSE,
  preRounded = NULL,
  plsWeights = NULL,
  printInc = TRUE,
  preDifference = TRUE,
  preOutput = NULL,
  rndSeed = 123
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLSroundingLoop_+3A_data">data</code></td>
<td>
<p>Input data as a data frame (inner cells)</p>
</td></tr>
<tr><td><code id="PLSroundingLoop_+3A_loopid">loopId</code></td>
<td>
<p>Variable holding id for loops</p>
</td></tr>
<tr><td><code id="PLSroundingLoop_+3A_...">...</code></td>
<td>
<p><code>PLSrounding</code> parameters</p>
</td></tr>
<tr><td><code id="PLSroundingLoop_+3A_zerocandidates">zeroCandidates</code></td>
<td>
<p><code>PLSrounding</code> parameter (see details)</p>
</td></tr>
<tr><td><code id="PLSroundingLoop_+3A_forceinner">forceInner</code></td>
<td>
<p><code>PLSrounding</code> parameter (see details)</p>
</td></tr>
<tr><td><code id="PLSroundingLoop_+3A_prerounded">preRounded</code></td>
<td>
<p><code>PLSrounding</code> parameter (see details)</p>
</td></tr>
<tr><td><code id="PLSroundingLoop_+3A_plsweights">plsWeights</code></td>
<td>
<p><code>PLSrounding</code> parameter (see details)</p>
</td></tr>
<tr><td><code id="PLSroundingLoop_+3A_printinc">printInc</code></td>
<td>
<p>Printing iteration information to console when TRUE</p>
</td></tr>
<tr><td><code id="PLSroundingLoop_+3A_predifference">preDifference</code></td>
<td>
<p>When TRUE, the <code>preDifference</code> parameter to <code>PLSrounding</code> is used. Each time with the differences obtained so far.</p>
</td></tr>
<tr><td><code id="PLSroundingLoop_+3A_preoutput">preOutput</code></td>
<td>
<p>preOutput The function can continue from output from a previous run</p>
</td></tr>
<tr><td><code id="PLSroundingLoop_+3A_rndseed">rndSeed</code></td>
<td>
<p>If non-NULL, a random generator seed to be set locally at the beginning of <code>PLSroundingLoop</code> without affecting the random value stream in R.
Within <code>PLSroundingLoop</code>, <code>PLSrounding</code> is called with <code>rndSeed = NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that in this function <code>zeroCandidates</code>, <code>forceInner</code>, <code>preRounded</code> and <code>plsWeights</code> cannot be supplied as vectors.
They may be specified as functions or as variables in the input data.
</p>


<h3>Value</h3>

<p>As output from <code><a href="#topic+PLSrounding">PLSrounding</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mf2 &lt;- ~region + fylke * hovedint
z2 &lt;- SmallCountData("z2")
a &lt;- PLSroundingLoop(z2, loopId = "kostragr", freqVar = "ant", formula = mf2)
a
</code></pre>

<hr>
<h2 id='print.PLSrounded'>Print method for PLSrounded</h2><span id='topic+print.PLSrounded'></span>

<h3>Description</h3>

<p>Print method for PLSrounded
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PLSrounded'
print(x, digits = max(getOption("digits") - 3, 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.PLSrounded_+3A_x">x</code></td>
<td>
<p>PLSrounded object</p>
</td></tr>
<tr><td><code id="print.PLSrounded_+3A_digits">digits</code></td>
<td>
<p>positive integer.  Minimum number of significant digits to be used for printing most numbers.</p>
</td></tr>
<tr><td><code id="print.PLSrounded_+3A_...">...</code></td>
<td>
<p>further arguments sent to the underlying</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the original object.
</p>

<hr>
<h2 id='redcube'>function redcube</h2><span id='topic+redcube'></span>

<h3>Description</h3>

<p>This function produces a reduced small count frequency hypercube for rounding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redcube(A, d, b = 3, micro = TRUE, nin = "n")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redcube_+3A_a">A</code></td>
<td>
<p>A data frame representing a micro dataset or a frequency count hypercube. The (first) columns
define the variables. If A is a hypercube the last column contains the number of units in each cell.
If A is a micro dataset it is reduced to hypercube by the function aggrtab.</p>
</td></tr>
<tr><td><code id="redcube_+3A_d">d</code></td>
<td>
<p>A list d[[j]] whose elements are vectors of variable names from A defining marginal tables/cubes D
of A that we are interested in.</p>
</td></tr>
<tr><td><code id="redcube_+3A_b">b</code></td>
<td>
<p>Rounding base. Counts in A less than b tat are contributing to counts less than b in the marginal 
cubes D are selected from A. The selected dataframe is called B</p>
</td></tr>
<tr><td><code id="redcube_+3A_micro">micro</code></td>
<td>
<p>Logical. TRUE if A is a micro dataset (default). FALSE if A i a frequency count hypercube.</p>
</td></tr>
<tr><td><code id="redcube_+3A_nin">nin</code></td>
<td>
<p>Name of count variable if A is a hypercube. Default name: &quot;n&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A: The input dataframe reduced to a hypercube.
</p>
<p>B: The dataframe of small count rows selected from A.
</p>
<p>C: The dataframe of rows in A that are nor selected from A.
</p>
<p>D: The cubes defined by d.
</p>
<p>Dr: The small counts (&lt;b) in D.
</p>
<p>The input elements d, b and nin
</p>


<h3>Author(s)</h3>

<p>Johan Heldal, November 2017
</p>

<hr>
<h2 id='Round2'>Small count rounding by various methods</h2><span id='topic+Round2'></span>

<h3>Description</h3>

<p>Run <code>makeroundtabs()</code> or <code>RoundViaDummy2()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Round2(data, control, ..., method = c("roundtabs", "viadummy", "viadummyAll"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Round2_+3A_data">data</code></td>
<td>
<p>Input data.frame. Same as input parameter <code>A</code> to <code>makeroundtabs()</code></p>
</td></tr>
<tr><td><code id="Round2_+3A_control">control</code></td>
<td>
<p>As input to <code>makeroundtabs()</code></p>
</td></tr>
<tr><td><code id="Round2_+3A_...">...</code></td>
<td>
<p>Other paramameters as input to <code>makeroundtabs()</code></p>
</td></tr>
<tr><td><code id="Round2_+3A_method">method</code></td>
<td>
<p>One of &quot;roundtabs&quot; (default), &quot;viadummy&quot;, &quot;viadummyAll&quot; (<code>allTerms=TRUE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output from  <code><a href="#topic+makeroundtabs">makeroundtabs</a></code> or <code><a href="#topic+RoundViaDummy2">RoundViaDummy2</a></code>
</p>


<h3>See Also</h3>

<p><code>RoundKostra</code> (SSB internal), <code><a href="#topic+RoundViaDummy">RoundViaDummy</a></code>, <code><a href="#topic+Lists2formula">Lists2formula</a></code>, <code><a href="#topic+MakeControl">MakeControl</a></code>, <code><a href="#topic+FindMaxDiff">FindMaxDiff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
z &lt;- SmallCountData("sosialFiktiv")
d &lt;- list(c("region","mnd") , c("hovedint","mnd2") , c("fylke","hovedint","mnd2") , 
          c("kostragr","hovedint","mnd"))
con &lt;- MakeControl(d,z)
sor &lt;- names(z)[c(4,5,3,2,1)]

roundedA &lt;-  Round2(data=z,b=3,d=d,micro=FALSE,sort=sor,control=con, nin="ant",nout="Rndtall",
                    minit=2,maxit=10,maxdiff=5,seed=123,method="roundtabs")
roundedB &lt;-  Round2(data=z,b=3,d=d,micro=FALSE,sort=sor,control=con, nin="ant",nout="Rndtall",
                    minit=2,maxit=10,maxdiff=5,seed=123,method="viadummy")
#10 rows of rounded data
roundedA$Ar[1:10,]  #"roundtabs"
cbind(z,roundedB$yInner)[1:10,] #"viadummy"

# recalculate maxdiff  nMaxdiff
dA &lt;- FindMaxDiff(roundedA$Ar,con,"ant","m")
dB &lt;- FindMaxDiff(z,con,roundedB$yInner[,1],roundedB$yInner[,2])

# Formula from d and control
Lists2formula(d,con,z)

# Formula from another d
d2 &lt;-list(sor)
Lists2formula(d2,con,z)
Lists2formula(d2,con) # Without knowing data
Lists2formula(d2,data=z) # Without control
Lists2formula(d2,data=z) # Without control and data

## End(Not run)
</code></pre>

<hr>
<h2 id='roundcube'>function roundcube</h2><span id='topic+roundcube'></span>

<h3>Description</h3>

<p>This function rounds small counts in a set of hypercubes D produced by the function redcube 
and searches for a solution with smallest possible deviations from the original hypercube at
some aggregated levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roundcube(rc, sort, control, minit, maxit, maxdiff, seed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roundcube_+3A_rc">rc</code></td>
<td>
<p>The list of outpts from redcube</p>
</td></tr>
<tr><td><code id="roundcube_+3A_sort">sort</code></td>
<td>
<p>An ordered list of variables in hypercubes in D meant for priority sorting of the reduced 
hypercube B before rounding. Not all variables in D should be included.</p>
</td></tr>
<tr><td><code id="roundcube_+3A_control">control</code></td>
<td>
<p>A list of marginals of the hypercubes in D where deviations of aggregated rounded counts
are checked against original counts.</p>
</td></tr>
<tr><td><code id="roundcube_+3A_minit">minit</code></td>
<td>
<p>Minimum number of searches to be carried out.</p>
</td></tr>
<tr><td><code id="roundcube_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of searches to be carried out.</p>
</td></tr>
<tr><td><code id="roundcube_+3A_maxdiff">maxdiff</code></td>
<td>
<p>If maximum difference in &quot;control&quot; is no larger than maxit, the stop search.</p>
</td></tr>
<tr><td><code id="roundcube_+3A_seed">seed</code></td>
<td>
<p>Input seed for first systematic random search.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Ar: The rounded version of A
Br: The rounded version of B
D: The original hypercube of interest.
Dr: The rounded version of D. The final table of interest.
maxdiff: The largest absolute difference between cells D and Dr among cells in the control list.
nmaxdiff: The number of occurences if Maxdiff
</p>


<h3>Author(s)</h3>

<p>Johan Heldal, January 2018
</p>

<hr>
<h2 id='RoundViaDummy'>Small Count Rounding of Tabular Data</h2><span id='topic+RoundViaDummy'></span>

<h3>Description</h3>

<p>Small count rounding via a dummy matrix and by an algorithm inspired by PLS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RoundViaDummy(
  data,
  freqVar,
  formula = NULL,
  roundBase = 3,
  singleRandom = FALSE,
  crossTable = TRUE,
  total = "Total",
  maxIterRows = 1000,
  maxIter = 1e+07,
  x = NULL,
  hierarchies = NULL,
  xReturn = FALSE,
  maxRound = roundBase - 1,
  zeroCandidates = FALSE,
  forceInner = FALSE,
  identifyNew = TRUE,
  step = 0,
  preRounded = NULL,
  leverageCheck = FALSE,
  easyCheck = TRUE,
  printInc = TRUE,
  rndSeed = 123,
  dimVar = NULL,
  plsWeights = NULL,
  preDifference = NULL,
  allSmall = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RoundViaDummy_+3A_data">data</code></td>
<td>
<p>Input data as a data frame (inner cells)</p>
</td></tr>
<tr><td><code id="RoundViaDummy_+3A_freqvar">freqVar</code></td>
<td>
<p>Variable holding counts (name or number)</p>
</td></tr>
<tr><td><code id="RoundViaDummy_+3A_formula">formula</code></td>
<td>
<p>Model formula defining publishable cells. Will be used to calculate <code>x</code> (via <code><a href="SSBtools.html#topic+ModelMatrix">ModelMatrix</a></code>).
When NULL, x must be supplied.</p>
</td></tr>
<tr><td><code id="RoundViaDummy_+3A_roundbase">roundBase</code></td>
<td>
<p>Rounding base</p>
</td></tr>
<tr><td><code id="RoundViaDummy_+3A_singlerandom">singleRandom</code></td>
<td>
<p>Single random draw when TRUE (instead of algorithm)</p>
</td></tr>
<tr><td><code id="RoundViaDummy_+3A_crosstable">crossTable</code></td>
<td>
<p>When TRUE, cross table in output and caculations via FormulaSums()</p>
</td></tr>
<tr><td><code id="RoundViaDummy_+3A_total">total</code></td>
<td>
<p>String used to name totals</p>
</td></tr>
<tr><td><code id="RoundViaDummy_+3A_maxiterrows">maxIterRows</code></td>
<td>
<p>See details</p>
</td></tr>
<tr><td><code id="RoundViaDummy_+3A_maxiter">maxIter</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="RoundViaDummy_+3A_x">x</code></td>
<td>
<p>Dummy matrix defining publishable cells</p>
</td></tr>
<tr><td><code id="RoundViaDummy_+3A_hierarchies">hierarchies</code></td>
<td>
<p>List of hierarchies, which can be converted by <code><a href="SSBtools.html#topic+AutoHierarchies">AutoHierarchies</a></code>.
Thus, a single string as hierarchy input is assumed to be a total code.
Exceptions are <code>"rowFactor"</code> or <code>""</code>, which correspond to only using the categories in the data.</p>
</td></tr>
<tr><td><code id="RoundViaDummy_+3A_xreturn">xReturn</code></td>
<td>
<p>Dummy matrix in output when TRUE (as input parameter <code>x</code>)</p>
</td></tr>
<tr><td><code id="RoundViaDummy_+3A_maxround">maxRound</code></td>
<td>
<p>Inner cells contributing to original publishable cells equal to or less than maxRound will be rounded.</p>
</td></tr>
<tr><td><code id="RoundViaDummy_+3A_zerocandidates">zeroCandidates</code></td>
<td>
<p>When TRUE, inner cells in input with zero count (and multiple of roundBase when maxRound is in use)
contributing to publishable cells will be included as candidates to obtain roundBase value.
With vector input, the rule is specified individually for each cell.
This can be specified as a vector, a variable in data or a function generating it (see details).</p>
</td></tr>
<tr><td><code id="RoundViaDummy_+3A_forceinner">forceInner</code></td>
<td>
<p>When TRUE, all inner cells will be rounded. Use vector input to force individual cells to be rounded.
This can be specified as a vector, a variable in data or a function generating it (see details).
Can be combined with parameter zeroCandidates to allow zeros and roundBase multiples to be rounded up.</p>
</td></tr>
<tr><td><code id="RoundViaDummy_+3A_identifynew">identifyNew</code></td>
<td>
<p>When <code>TRUE</code>, new cells may be identified after initial rounding to ensure all rounded publishable
cells equal to or less than <code>maxRound</code> to be <code>roundBase</code> multiples. Use <code>NA</code> for the a less conservative
behavior (old behavior). Then it is ensured that no nonzero rounded publishable cells are smaller
than <code>roundBase</code>. When <code>maxRound</code> is default, there is no difference between <code>TRUE</code> and <code>NA</code>.</p>
</td></tr>
<tr><td><code id="RoundViaDummy_+3A_step">step</code></td>
<td>
<p>When <code>step&gt;1</code>, the original forward part of the algorithm is replaced by a kind of stepwise.
After <code>step</code> steps forward, backward steps may be performed. The <code>step</code> parameter is also used
for backward-forward iteration at the end of the algorithm; <code>step</code> backward steps may be performed.</p>
</td></tr>
<tr><td><code id="RoundViaDummy_+3A_prerounded">preRounded</code></td>
<td>
<p>A vector or a variable in data that contains a mixture of missing values and predetermined values of rounded inner cells.
Can also be specified as a function generating it (see details).</p>
</td></tr>
<tr><td><code id="RoundViaDummy_+3A_leveragecheck">leverageCheck</code></td>
<td>
<p>When TRUE, all inner cells that depends linearly on the published cells and with small frequencies
(<code>&lt;=maxRound</code>) will be rounded.
The computation of leverages can be very time and memory consuming.
The function <code><a href="SSBtools.html#topic+Reduce0exact">Reduce0exact</a></code> is called.
The default leverage limit is <code>0.999999</code>. Another limit can be sent as input instead of <code>TRUE</code>.
Checking is performed before and after (since new zeros) rounding. Extra iterations are performed when needed.</p>
</td></tr>
<tr><td><code id="RoundViaDummy_+3A_easycheck">easyCheck</code></td>
<td>
<p>A light version of the above leverage checking.
Checking is performed after rounding. Extra iterations are performed when needed.
<code>Reduce0exact</code> is called with <code>reduceByLeverage=FALSE</code> and <code>reduceByColSums=TRUE</code>.</p>
</td></tr>
<tr><td><code id="RoundViaDummy_+3A_printinc">printInc</code></td>
<td>
<p>Printing iteration information to console when TRUE</p>
</td></tr>
<tr><td><code id="RoundViaDummy_+3A_rndseed">rndSeed</code></td>
<td>
<p>If non-NULL, a random generator seed to be used locally within the function without affecting the random value stream in R.</p>
</td></tr>
<tr><td><code id="RoundViaDummy_+3A_dimvar">dimVar</code></td>
<td>
<p>The main dimensional variables and additional aggregating variables. This parameter can be  useful when hierarchies and formula are unspecified.</p>
</td></tr>
<tr><td><code id="RoundViaDummy_+3A_plsweights">plsWeights</code></td>
<td>
<p>A vector of weights for each cell to be published or a function generating it (see details). For use in the algorithm criterion.</p>
</td></tr>
<tr><td><code id="RoundViaDummy_+3A_predifference">preDifference</code></td>
<td>
<p>A data.frame with differences already obtained from rounding another subset of data.
There must be columns that match <code>crossTable</code>. Differences must be in the last column.</p>
</td></tr>
<tr><td><code id="RoundViaDummy_+3A_allsmall">allSmall</code></td>
<td>
<p>When TRUE, all small inner cells (<code style="white-space: pre;">&#8288;&lt;= maxRound&#8288;</code>) are rounded. This parameter is a simplified alternative to specifying <code>forceInner</code>  (see details).</p>
</td></tr>
<tr><td><code id="RoundViaDummy_+3A_...">...</code></td>
<td>
<p>Further parameters sent to <code><a href="SSBtools.html#topic+ModelMatrix">ModelMatrix</a></code>.
In particular, one can specify <code>removeEmpty=TRUE</code> to omit empty combinations.
The parameter <code>inputInOutput</code> can be used to specify whether to include codes from input.
The parameter <code>avoidHierarchical</code> (<code><a href="SSBtools.html#topic+Formula2ModelMatrix">Formula2ModelMatrix</a></code>) can be combined with formula input.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Small count rounding of necessary inner cells are performed so that all small frequencies of cross-classifications to be published
(publishable cells) are rounded. This is equivalent to changing micro data since frequencies of unique combinations are changed.
Thus, additivity and consistency are guaranteed. The matrix multiplication formula is:
<code>yPublish</code> <code>=</code> <code>t(x)</code> <code>%*%</code>  <code>yInner</code>, where <code>x</code> is the dummy matrix.
</p>
<p>Parameters <code>zeroCandidates</code>, <code>forceInner</code>,  <code>preRounded</code> and <code>plsWeights</code> can be specified as functions.
The supplied functions take the following arguments: <code>data</code>, <code>yPublish</code>,  <code>yInner</code>, <code>crossTable</code>, <code>x</code>, <code>roundBase</code>, <code>maxRound</code>, and <code>...</code>,
where the first two are numeric vectors of original counts.
When <code>allSmall</code> is <code>TRUE</code>,  <code>forceInner</code> is set to  <code style="white-space: pre;">&#8288;function(yInner, maxRound, ...)&#8288;</code> <code>yInner &lt;= maxRound</code>.
</p>


<h3>Value</h3>

<p>A list where the two first elements are two column matrices.
The first matrix consists of inner cells and the second of cells to be published.
In each matrix the first and the second column contains, respectively, original and rounded values.
By default the cross table is the third element of the output list.
</p>


<h3>Note</h3>

<p>Iterations are needed since after initial rounding of identified cells, new cells are identified.
If cases of a high number of identified cells the algorithm can be too memory consuming (unless singleRandom=TRUE).
To avoid problems, not more than maxIterRows cells are rounded in each iteration.
The iteration limit (maxIter) is by default set to be high since a low number of maxIterRows may need a high number of iterations.
</p>


<h3>See Also</h3>

<p>See the  user-friendly wrapper <code><a href="#topic+PLSrounding">PLSrounding</a></code>
and see <code>Round2</code> for rounding by other algorithm
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See similar and related examples in PLSrounding documentation
RoundViaDummy(SmallCountData("e6"), "freq")
RoundViaDummy(SmallCountData("e6"), "freq", formula = ~eu * year + geo)
RoundViaDummy(SmallCountData("e6"), "freq", hierarchies = 
   list(geo = c("EU", "@Portugal", "@Spain", "Iceland"), year = c("2018", "2019")))

RoundViaDummy(SmallCountData('z2'), 
              'ant', ~region + hovedint + fylke*hovedint + kostragr*hovedint, 10)
mf &lt;- ~region*mnd + hovedint*mnd + fylke*hovedint*mnd + kostragr*hovedint*mnd
a &lt;- RoundViaDummy(SmallCountData('z3'), 'ant', mf, 5)
b &lt;- RoundViaDummy(SmallCountData('sosialFiktiv'), 'ant', mf, 4)
print(cor(b[[2]]),digits=12) # Correlation between original and rounded

# Demonstrate parameter leverageCheck 
# The 42nd inner cell must be rounded since it can be revealed from the published cells.
mf2 &lt;- ~region + hovedint + fylke * hovedint + kostragr * hovedint
RoundViaDummy(SmallCountData("z2"), "ant", mf2, leverageCheck = FALSE)$yInner[42, ]
RoundViaDummy(SmallCountData("z2"), "ant", mf2, leverageCheck = TRUE)$yInner[42, ]

## Not run: 
# Demonstrate parameters maxRound, zeroCandidates and forceInner 
# by tabulating the inner cells that have been changed.
z4 &lt;- SmallCountData("sosialFiktiv")
for (forceInner in c("FALSE", "z4$ant &lt; 10")) 
  for (zeroCandidates in c(FALSE, TRUE)) 
    for (maxRound in c(2, 5)) {
      set.seed(123)
      a &lt;- RoundViaDummy(z4, "ant", formula = mf, maxRound = maxRound, 
                         zeroCandidates = zeroCandidates, 
                         forceInner = eval(parse(text = forceInner)))
      change &lt;- a$yInner[, "original"] != a$yInner[, "rounded"]
      cat("\n\n---------------------------------------------------\n")
      cat("      maxRound:", maxRound, "\n")
      cat("zeroCandidates:", zeroCandidates, "\n")
      cat("    forceInner:", forceInner, "\n\n")
      print(table(original = a$yInner[change, "original"], rounded = a$yInner[change, "rounded"]))
      cat("---------------------------------------------------\n")
    }

## End(Not run)
</code></pre>

<hr>
<h2 id='RoundViaDummy2'>RoundViaDummy2</h2><span id='topic+RoundViaDummy2'></span>

<h3>Description</h3>

<p>RoundViaDummy with input as makeroundtabs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RoundViaDummy2(
  data,
  b,
  d,
  nin,
  micro = FALSE,
  control = NULL,
  allTerms = FALSE,
  singleRandom = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RoundViaDummy2_+3A_data">data</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="RoundViaDummy2_+3A_b">b</code></td>
<td>
<p>b</p>
</td></tr>
<tr><td><code id="RoundViaDummy2_+3A_d">d</code></td>
<td>
<p>d</p>
</td></tr>
<tr><td><code id="RoundViaDummy2_+3A_nin">nin</code></td>
<td>
<p>nin</p>
</td></tr>
<tr><td><code id="RoundViaDummy2_+3A_micro">micro</code></td>
<td>
<p>micro</p>
</td></tr>
<tr><td><code id="RoundViaDummy2_+3A_control">control</code></td>
<td>
<p>control</p>
</td></tr>
<tr><td><code id="RoundViaDummy2_+3A_allterms">allTerms</code></td>
<td>
<p>Use all interaction terms in formula instead of using control</p>
</td></tr>
<tr><td><code id="RoundViaDummy2_+3A_singlerandom">singleRandom</code></td>
<td>
<p>Single random draw when TRUE (instead of algorithm)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output from RoundViaDummy extended with  &quot;yControl&quot; &quot;maxdiff&quot;  &quot;nMaxdiff&quot; &quot;formula&quot;
</p>

<hr>
<h2 id='SmallCountData'>Function that returns a dataset</h2><span id='topic+SmallCountData'></span>

<h3>Description</h3>

<p>Function that returns a dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SmallCountData(dataset, path = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SmallCountData_+3A_dataset">dataset</code></td>
<td>
<p>Name of data set within the SmallCountRounding  package</p>
</td></tr>
<tr><td><code id="SmallCountData_+3A_path">path</code></td>
<td>
<p>When non-NULL the data set is read from &quot;path/dataset.RData&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The dataset
</p>


<h3>Note</h3>

<p>Except for <code>"europe6"</code>, <code>"eHrc"</code>, <code>"eDimList"</code> and <code>"exPSD"</code>, the function returns the same datasets as <code><a href="SSBtools.html#topic+SSBtoolsData">SSBtoolsData</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="SSBtools.html#topic+SSBtoolsData">SSBtoolsData</a></code>, <code><a href="SSBtools.html#topic+Hrc2DimList">Hrc2DimList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> SmallCountData("z1")
 SmallCountData("e6")
 SmallCountData("eHrc")      #  TauArgus coded hierarchies
 SmallCountData("eDimList")  #  sdcTable coded hierarchies
 SmallCountData("exPSD")     #  Example data in presentation at Privacy in statistical databases

</code></pre>

<hr>
<h2 id='SmallCountRounding-package'>Small Count Rounding of Tabular Data</h2><span id='topic+SmallCountRounding-package'></span><span id='topic+SmallCountRounding'></span>

<h3>Description</h3>

<p>A statistical disclosure control tool to protect frequency tables in cases where small values are sensitive.
The main function, <code><a href="#topic+PLSrounding">PLSrounding</a></code>, performs small count rounding of necessary inner cells (Heldal, 2017)
so that all small frequencies of cross-classifications to be published (publishable cells) are rounded.
This is equivalent to changing micro data since frequencies of unique combinations are changed.
Thus, additivity and consistency are guaranteed.
This is performed by an algorithm inspired by partial least squares regression (Langsrud and Heldal, 2018). <br />
</p>


<h3>References</h3>

<p>Heldal, J. (2017): &ldquo;The European Census Hub 2011 Hypercubes - Norwegian SDC Experiences&rdquo;.
In: <em>Work Session on Statistical Data Confidentiality</em>,
Skopje, The former Yugoslav Republic of Macedonia, September 20-22 , 2017.
</p>
<p>Langsrud, Ø. and Heldal, J. (2018): &ldquo;An Algorithm for Small Count Rounding of Tabular Data&rdquo;.
Presented at: <em>Privacy in statistical databases</em>, Valencia, Spain. September 26-28, 2018.
<a href="https://www.researchgate.net/publication/327768398_An_Algorithm_for_Small_Count_Rounding_of_Tabular_Data">https://www.researchgate.net/publication/327768398_An_Algorithm_for_Small_Count_Rounding_of_Tabular_Data</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
