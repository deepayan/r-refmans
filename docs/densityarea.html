<!DOCTYPE html><html><head><title>Help for package densityarea</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {densityarea}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#density_area'><p>Density Area</p></a></li>
<li><a href='#density_polygons'><p>Density polygons</p></a></li>
<li><a href='#s01'><p>Vowel Space Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Polygons of Bivariate Density Distributions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>With bivariate data, it is possible to calculate
    2-dimensional kernel density estimates that return polygons at given
    levels of probability. 'densityarea' returns these polygons for
    analysis, including for calculating their area.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/JoFrhwld/densityarea">https://github.com/JoFrhwld/densityarea</a>,
<a href="https://jofrhwld.github.io/densityarea/">https://jofrhwld.github.io/densityarea/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/JoFrhwld/densityarea/issues">https://github.com/JoFrhwld/densityarea/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, dplyr, ggdensity, isoband, purrr, rlang, sf, sfheaders,
tibble, vctrs</td>
</tr>
<tr>
<td>Suggests:</td>
<td>forcats, ggplot2, knitr, ragg, readr, rmarkdown, stringr,
testthat (&ge; 3.0.0), tidyr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-01 18:30:29 UTC; joseffruehwald</td>
</tr>
<tr>
<td>Author:</td>
<td>Josef Fruehwald [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Josef Fruehwald &lt;jofrhwld@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-02 10:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='density_area'>Density Area</h2><span id='topic+density_area'></span>

<h3>Description</h3>

<p>A convenience function to get just the areas of density polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>density_area(
  x,
  y,
  probs = 0.5,
  as_sf = FALSE,
  as_list = FALSE,
  range_mult = 0.25,
  rangex = NULL,
  rangey = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density_area_+3A_x">x</code>, <code id="density_area_+3A_y">y</code></td>
<td>
<p>Numeric data dimensions</p>
</td></tr>
<tr><td><code id="density_area_+3A_probs">probs</code></td>
<td>
<p>Probabilities to compute density polygons for</p>
</td></tr>
<tr><td><code id="density_area_+3A_as_sf">as_sf</code></td>
<td>
<p>Should the returned values be <a href="sf.html#topic+sf">sf::sf</a>? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="density_area_+3A_as_list">as_list</code></td>
<td>
<p>Should the returned value be a list? Defaults to <code>TRUE</code> to
work well with tidyverse list columns</p>
</td></tr>
<tr><td><code id="density_area_+3A_range_mult">range_mult</code></td>
<td>
<p>A multiplier to the range of <code>x</code> and <code>y</code> across which the
probability density will be estimated.</p>
</td></tr>
<tr><td><code id="density_area_+3A_rangex">rangex</code>, <code id="density_area_+3A_rangey">rangey</code></td>
<td>
<p>Custom ranges across <code>x</code> and <code>y</code> ranges across which the
probability density will be estimated.</p>
</td></tr>
<tr><td><code id="density_area_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="ggdensity.html#topic+get_hdr">ggdensity::get_hdr()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If both <code>rangex</code> and <code>rangey</code> are defined, <code>range_mult</code> will be disregarded.
If only one or the other of <code>rangex</code> and <code>rangey</code> are defined, <code>range_mult</code>
will be used to produce the range of the undefined one.
</p>


<h3>Value</h3>

<p>A list of data frames, if <code>as_list=TRUE</code>, or just a data frame,
if <code>as_list=FALSE</code>.
</p>


<h4>Data frame output</h4>

<p>If <code>as_sf=FALSE</code>, the data frame has the following columns:
</p>

<dl>
<dt>level_id</dt><dd><p>An integer id for each probability level</p>
</dd>
<dt>prob</dt><dd><p>The probability level (originally passed to <code>probs</code>)</p>
</dd>
<dt>area</dt><dd><p>The area of the HDR polygon</p>
</dd>
</dl>




<h4>sf output</h4>

<p>If <code>as_sf=TRUE</code>, the data frame has the following columns:
</p>

<dl>
<dt>level_id</dt><dd><p>An integer id for each probability level</p>
</dd>
<dt>prob</dt><dd><p>The probability level (originally passed to <code>probs</code>)</p>
</dd>
<dt>geometry</dt><dd><p>The <code>sf::st_polygon()</code> of the HDR</p>
</dd>
<dt>area</dt><dd><p>The area of the HDR polygon</p>
</dd>
</dl>




<h3>Examples</h3>

<pre><code class='language-R'>library(densityarea)
library(dplyr)
library(sf)

ggplot2_inst &lt;- require(ggplot2)

# basic usage

set.seed(10)
x &lt;- rnorm(100)
y &lt;- rnorm(100)

density_area(x,
             y,
             probs = ppoints(50)) -&gt;
  poly_areas_df

head(poly_areas_df)

# Plotting the relationship between probability level and area
if(ggplot2_inst){
  ggplot(poly_areas_df,
         aes(prob, area)) +
    geom_line()
}

# Tidyverse usage

data(s01)

## Data preprocessing

s01 |&gt;
  mutate(log_F2 = -log(F2),
         log_F1 = -log(F1)) -&gt;
  s01

### Data frame output

s01 |&gt;
  group_by(name) |&gt;
  reframe(density_area(log_F2,
                       log_F1,
                       probs = ppoints(10))) -&gt;
  s01_areas_df

if(ggplot2_inst){
  s01_areas_df |&gt;
    ggplot(aes(prob, area)) +
    geom_line()
}

### Including sf output

s01 |&gt;
  group_by(name) |&gt;
  reframe(density_area(log_F2,
                       log_F1,
                       probs = ppoints(10),
                       as_sf = TRUE)) |&gt;
  st_sf() -&gt;
  s01_areas_sf

if(ggplot2_inst){
  s01_areas_sf |&gt;
    arrange(desc(prob)) |&gt;
    ggplot() +
    geom_sf(aes(fill = area))
}
</code></pre>

<hr>
<h2 id='density_polygons'>Density polygons</h2><span id='topic+density_polygons'></span>

<h3>Description</h3>

<p>Given numeric vectors <code>x</code> and <code>y</code>, <code>density_polygons()</code> will return
a data frame, or list of a data frames, of the polygon defining 2d kernel
densities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>density_polygons(
  x,
  y,
  probs = 0.5,
  as_sf = FALSE,
  as_list = FALSE,
  range_mult = 0.25,
  rangex = NULL,
  rangey = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density_polygons_+3A_x">x</code>, <code id="density_polygons_+3A_y">y</code></td>
<td>
<p>Numeric data dimensions</p>
</td></tr>
<tr><td><code id="density_polygons_+3A_probs">probs</code></td>
<td>
<p>Probabilities to compute density polygons for</p>
</td></tr>
<tr><td><code id="density_polygons_+3A_as_sf">as_sf</code></td>
<td>
<p>Should the returned values be <a href="sf.html#topic+sf">sf::sf</a>? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="density_polygons_+3A_as_list">as_list</code></td>
<td>
<p>Should the returned value be a list? Defaults to <code>FALSE</code> to
work with <code><a href="dplyr.html#topic+reframe">dplyr::reframe()</a></code></p>
</td></tr>
<tr><td><code id="density_polygons_+3A_range_mult">range_mult</code></td>
<td>
<p>A multiplier to the range of <code>x</code> and <code>y</code> across which the
probability density will be estimated.</p>
</td></tr>
<tr><td><code id="density_polygons_+3A_rangex">rangex</code>, <code id="density_polygons_+3A_rangey">rangey</code></td>
<td>
<p>Custom ranges across <code>x</code> and <code>y</code> ranges across which the
probability density will be estimated.</p>
</td></tr>
<tr><td><code id="density_polygons_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="ggdensity.html#topic+get_hdr">ggdensity::get_hdr()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using <code>density_polygons()</code> together with <code><a href="dplyr.html#topic+summarise">dplyr::summarise()</a></code>, <code>as_list</code>
should be <code>TRUE</code>.
</p>
<p>If both <code>rangex</code> and <code>rangey</code> are defined, <code>range_mult</code> will be disregarded.
If only one or the other of <code>rangex</code> and <code>rangey</code> are defined, <code>range_mult</code>
will be used to produce the range of the undefined one.
</p>


<h3>Value</h3>

<p>A list of data frames, if <code>as_list=TRUE</code>, or just a data frame,
if <code>as_list=FALSE</code>.
</p>


<h4>Data frame output</h4>

<p>If <code>as_sf=FALSE</code>, the data frame has the following columns:
</p>

<dl>
<dt>level_id</dt><dd><p>An integer id for each probability level</p>
</dd>
<dt>id</dt><dd><p>An integer id for each sub-polygon within a probabilty level</p>
</dd>
<dt>prob</dt><dd><p>The probability level (originally passed to <code>probs</code>)</p>
</dd>
<dt>x, y</dt><dd><p>The values along the original <code>x</code> and <code>y</code> dimensions defining
the density polygon. These will be renamed to the original input variable
names.</p>
</dd>
<dt>order</dt><dd><p>The original plotting order of the polygon points, for
convenience.</p>
</dd>
</dl>




<h4>sf output</h4>

<p>If <code>as_sf=TRUE</code>, the data frame has the following columns:
</p>

<dl>
<dt>level_id</dt><dd><p>An integer id for each probability level</p>
</dd>
<dt>prob</dt><dd><p>The probability level (originally passed to <code>probs</code>)</p>
</dd>
<dt>geometry</dt><dd><p>A column of <code><a href="sf.html#topic+st">sf::st_polygon()</a></code>s.</p>
</dd>
</dl>

<p>This output will need to be passed to <code><a href="sf.html#topic+sf">sf::st_sf()</a></code> to utilize many of the
features of <a href="sf.html#topic+sf">sf</a>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>library(densityarea)
library(dplyr)
library(purrr)
library(sf)

ggplot2_inst &lt;- require(ggplot2)
tidyr_inst &lt;- require(tidyr)

set.seed(10)
x &lt;- c(rnorm(100))
y &lt;- c(rnorm(100))

# ordinary data frame output
poly_df &lt;- density_polygons(x,
                            y,
                            probs = ppoints(5))

head(poly_df)

# It's necessary to specify a grouping factor that combines `level_id` and `id`
# for cases of multimodal density distributions
if(ggplot2_inst){
  ggplot(poly_df, aes(x, y)) +
    geom_path(aes(group = paste0(level_id, id),
                  color = prob))
}

# sf output
poly_sf &lt;- density_polygons(x,
                            y,
                            probs = ppoints(5),
                            as_sf = TRUE)

head(poly_sf)

# `geom_sf()` is from the `{sf}` package.
if(ggplot2_inst){
  poly_sf |&gt;
    arrange(desc(prob)) |&gt;
    ggplot() +
    geom_sf(aes(fill = prob))
}

# Tidyverse usage

data(s01)

# Data transformation
s01 &lt;- s01 |&gt;
  mutate(log_F1 = -log(F1),
         log_F2 = -log(F2))

## Basic usage with `dplyr::reframe()`
### Data frame output
s01 |&gt;
  group_by(name) |&gt;
  reframe(density_polygons(log_F2,
                           log_F1,
                           probs = ppoints(5))) -&gt;
  speaker_poly_df

if(ggplot2_inst){
  speaker_poly_df |&gt;
    ggplot(aes(log_F2, log_F1)) +
    geom_path(aes(group = paste0(level_id, id),
                  color = prob)) +
    coord_fixed()
}

### sf output
s01 |&gt;
  group_by(name) |&gt;
  reframe(density_polygons(log_F2,
                           log_F1,
                           probs = ppoints(5),
                           as_sf = TRUE)) |&gt;
  st_sf() -&gt;
  speaker_poly_sf

if(ggplot2_inst){
  speaker_poly_sf |&gt;
    ggplot() +
    geom_sf(aes(color = prob),
            fill = NA)
}

## basic usage with dplyr::summarise()
### data frame output

if(tidyr_inst){
  s01 |&gt;
    group_by(name) |&gt;
    summarise(poly = density_polygons(log_F2,
                                      log_F1,
                                      probs = ppoints(5),
                                      as_list = TRUE)) |&gt;
    unnest(poly) -&gt;
    speaker_poly_df
}
### sf output

if(tidyr_inst){
  s01 |&gt;
    group_by(name) |&gt;
    summarise(poly = density_polygons(
      log_F2,
      log_F1,
      probs = ppoints(5),
      as_list = TRUE,
      as_sf = TRUE
    )) |&gt;
    unnest(poly) |&gt;
    st_sf() -&gt;
    speaker_poly_sf
}
</code></pre>

<hr>
<h2 id='s01'>Vowel Space Data</h2><span id='topic+s01'></span>

<h3>Description</h3>

<p>This is the vowel space data from a single speaker, s01, whose
audio interview and transcription are part of the Buckeye Corpus
(Pitt et al. 2007). The transcript was realigned to the audio using the
Montreal Forced Aligner (McAullife et al. 2022) and vowel formant data
extracted with FAVE (Rosenfelder et al. 2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s01
</code></pre>


<h3>Format</h3>



<h4><code>s01</code></h4>

<p>A dataframe with 4,245 rows and 10 columns
</p>

<dl>
<dt>name</dt><dd><p>Speaker id</p>
</dd>
<dt>age</dt><dd><p>Speaker age (y=young, o=old)</p>
</dd>
<dt>sex</dt><dd><p>Speaker sex</p>
</dd>
<dt>word</dt><dd><p>Word in the transcription</p>
</dd>
<dt>vowel</dt><dd><p>Arpabet transcription of the measured vowel</p>
</dd>
<dt>plt_vclass</dt><dd><p>A modified Labov/Trager notation of the measured vowel</p>
</dd>
<dt>ip_vclass</dt><dd><p>An IPA-like transcription of the measured vowel</p>
</dd>
<dt>F1</dt><dd><p>The measured F1 frequency (Hz)</p>
</dd>
<dt>F2</dt><dd><p>The measured F2 frequency (Hz)</p>
</dd>
<dt>dur</dt><dd><p>The measured vowel duration</p>
</dd>
</dl>




<h3>Source</h3>

<p>McAuliffe, M., Fatchurrahman, M. R., GalaxieT, NTT123,
Amogh Gulati, Coles, A., Veaux, C., Eren, E., Mishra, H., Paweł Potrykus,
Jung, S., Sereda, T., Mestrou, T., Michaelasocolof, &amp; Vannawillerton. (2022).
MontrealCorpusTools/Montreal-Forced-Aligner: Version 2.0.1 (v2.0.1)
<a href="https://doi.org/10.5281/ZENODO.6658586">doi:10.5281/ZENODO.6658586</a>
</p>
<p>Pitt, M. A., Dilley, L., Johnson, K., Kiesling, S., Raymond, W.,
Hume, E., &amp; Fosler-Lussier, E. (2007). Buckeye Corpus of Conversational
Speech (2nd release). Department of Psychology, Ohio State University.
<a href="https://buckeyecorpus.osu.edu/">https://buckeyecorpus.osu.edu/</a>
</p>
<p>Rosenfelder, I., Fruehwald, J., Brickhouse, C., Evanini, K.,
Seyfarth, S., Gorman, K., Prichard, H., &amp; Yuan, J. (2022).
FAVE (Forced Alignment and Vowel Extraction) Program Suite v2.0.0
<a href="https://github.com/JoFrhwld/FAVE">https://github.com/JoFrhwld/FAVE</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
