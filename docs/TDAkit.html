<!DOCTYPE html><html><head><title>Help for package TDAkit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TDAkit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#diag2landscape'><p>Convert Persistence Diagram into Persistence Landscape</p></a></li>
<li><a href='#diag2silhouette'><p>Convert Persistence Diagram into Persistent Silhouette</p></a></li>
<li><a href='#diagRips'><p>Compute Vietoris-Rips Complex for Persistent Homology</p></a></li>
<li><a href='#fsdist'><p>Pairwise <code class="reqn">L_p</code> Distance of Multiple Functional Summaries</p></a></li>
<li><a href='#fsdist2'><p>Pairwise <code class="reqn">L_p</code> Distance for Two Sets of Functional Summaries</p></a></li>
<li><a href='#fseqdist'><p>Multi-sample Energy Test of Equal Distributions</p></a></li>
<li><a href='#fshclust'><p>Hierarchical Agglomerative Clustering</p></a></li>
<li><a href='#fskgroups'><p><code class="reqn">k</code>-Groups Clustering of Multiple Functional Summaries by Energy Distance</p></a></li>
<li><a href='#fskmedoids'><p>K-Medoids Clustering</p></a></li>
<li><a href='#fsmds'><p>Multidimensional Scaling</p></a></li>
<li><a href='#fsmean'><p>Mean of Multiple Functional Summaries</p></a></li>
<li><a href='#fsnorm'><p><code class="reqn">L_p</code> Norm of a Single Functional Summary</p></a></li>
<li><a href='#fssc05Z'><p>Spectral Clustering by Zelnik-Manor and Perona (2005)</p></a></li>
<li><a href='#fssum'><p>Weighted Sum of Multiple Functional Summaries</p></a></li>
<li><a href='#fstsne'><p>t-distributed Stochastic Neighbor Embedding</p></a></li>
<li><a href='#gen2circles'><p>Generate Two Intersecting Circles</p></a></li>
<li><a href='#gen2holes'><p>Generate Two Intertwined Holes</p></a></li>
<li><a href='#plkernel'><p>Persistence Landscape Kernel</p></a></li>
<li><a href='#plot.homology'><p>Plot Persistent Homology via Barcode or Diagram</p></a></li>
<li><a href='#plot.landscape'><p>Plot Persistence Landscape</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Toolkit for Topological Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Topological data analysis studies structure and shape of the data using topological features. We provide a variety of algorithms to learn with persistent homology of the data based on functional summaries for clustering, hypothesis testing, visualization, and others. We refer to Wasserman (2018) &lt;<a href="https://doi.org/10.1146%2Fannurev-statistics-031017-100045">doi:10.1146/annurev-statistics-031017-100045</a>&gt; for a statistical perspective on the topic. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, Rdpack, TDAstats, T4cluster, energy, ggplot2, maotai,
stats, utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-08-22 18:57:08 UTC; kisung</td>
</tr>
<tr>
<td>Author:</td>
<td>Kisung You <a href="https://orcid.org/0000-0002-8584-459X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Byeongsu Yu [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kisung You &lt;kisungyou@outlook.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-08-23 14:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='diag2landscape'>Convert Persistence Diagram into Persistence Landscape</h2><span id='topic+diag2landscape'></span>

<h3>Description</h3>

<p>Persistence Landscape (PL) is a functional summary of persistent homology 
that is constructed given a <code>homology</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diag2landscape(homology, dimension = 1, k = 0, nseq = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diag2landscape_+3A_homology">homology</code></td>
<td>
<p>an object of S3 class <code>"homology"</code> generated from <code>diagRips</code> or other homology-generating functions.</p>
</td></tr>
<tr><td><code id="diag2landscape_+3A_dimension">dimension</code></td>
<td>
<p>dimension of features to be considered (default: 1).</p>
</td></tr>
<tr><td><code id="diag2landscape_+3A_k">k</code></td>
<td>
<p>the number of top landscape functions to be used (default: 0). When <code>k=0</code> is set, it gives all relevant landscape functions that are non-zero.</p>
</td></tr>
<tr><td><code id="diag2landscape_+3A_nseq">nseq</code></td>
<td>
<p>grid size for which the landscape function is evaluated (default: 1000).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list object of <code>"landscape"</code> class containing</p>

<dl>
<dt>lambda</dt><dd><p>an <code class="reqn">(\code{nseq} \times k)</code> landscape functions.</p>
</dd>
<dt>tseq</dt><dd><p>a length-<code>nseq</code> vector of domain grid.</p>
</dd>
<dt>dimension</dt><dd><p>dimension of features considered.</p>
</dd>
</dl>



<h3>References</h3>

<p>Peter Bubenik (2018). &ldquo;The Persistence Landscape and Some of Its Properties.&rdquo; <em>arXiv:1810.04963</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ---------------------------------------------------------------------------
#              Persistence Landscape of 'iris' Dataset
#
# We will extract landscapes of dimensions 0, 1, and 2.
# For each feature, only the top 5 landscape functions are plotted.
# ---------------------------------------------------------------------------
## Prepare 'iris' data
XX = as.matrix(iris[,1:4])

## Compute Persistence Diagram 
pdrips = diagRips(XX, maxdim=2)

## Convert to Landscapes of Each Dimension
land0 &lt;- diag2landscape(pdrips, dimension=0, k=5)
land1 &lt;- diag2landscape(pdrips, dimension=1, k=5)
land2 &lt;- diag2landscape(pdrips, dimension=2, k=5)

## Visualize
opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(2,2))
plot(pdrips$Birth, pdrips$Death, col=as.factor(pdrips$Dimension),
     pch=19, main="persistence diagram", xlab="Birth", ylab="Death")
matplot(land0$tseq, land0$lambda, type="l", lwd=3, main="dimension 0", xlab="t")
matplot(land1$tseq, land1$lambda, type="l", lwd=3, main="dimension 1", xlab="t")
matplot(land2$tseq, land2$lambda, type="l", lwd=3, main="dimension 2", xlab="t")
par(opar)

</code></pre>

<hr>
<h2 id='diag2silhouette'>Convert Persistence Diagram into Persistent Silhouette</h2><span id='topic+diag2silhouette'></span>

<h3>Description</h3>

<p>Persistence Silhouette (PS) is a functional summary of persistent homology 
that is constructed given a <code>homology</code> object. PS is a weighted average of 
landscape functions so that it becomes a uni-dimensional function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diag2silhouette(homology, dimension = 1, p = 2, nseq = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diag2silhouette_+3A_homology">homology</code></td>
<td>
<p>an object of S3 class <code>"homology"</code> generated from <code>diagRips</code> or other diagram-generating functions.</p>
</td></tr>
<tr><td><code id="diag2silhouette_+3A_dimension">dimension</code></td>
<td>
<p>dimension of features to be considered (default: 1).</p>
</td></tr>
<tr><td><code id="diag2silhouette_+3A_p">p</code></td>
<td>
<p>an exponent for the weight function of form <code class="reqn">|a-b|^p</code> (default: 2).</p>
</td></tr>
<tr><td><code id="diag2silhouette_+3A_nseq">nseq</code></td>
<td>
<p>grid size for which the landscape function is evaluated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list object of <code>"silhouette"</code> class containing</p>

<dl>
<dt>lambda</dt><dd><p>an <code class="reqn">(\code{nseq} \times k)</code> landscape functions.</p>
</dd>
<dt>tseq</dt><dd><p>a length-<code>nseq</code> vector of domain grid.</p>
</dd>
<dt>dimension</dt><dd><p>dimension of features considered.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># ---------------------------------------------------------------------------
#              Persistence Silhouette of 'iris' Dataset
#
# We will extract silhouettes of dimensions 0, 1, and 2.
# ---------------------------------------------------------------------------
## Prepare 'iris' data
XX = as.matrix(iris[,1:4])

## Compute Persistence Diagram 
pdrips = diagRips(XX, maxdim=2)

## Convert to Silhouettes of Each Dimension
sil0 &lt;- diag2silhouette(pdrips, dimension=0)
sil1 &lt;- diag2silhouette(pdrips, dimension=1)
sil2 &lt;- diag2silhouette(pdrips, dimension=2)

## Visualize
opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(2,2))
plot(pdrips$Birth, pdrips$Death, col=as.factor(pdrips$Dimension),
     pch=19, main="persistence diagram", xlab="Birth", ylab="Death")
plot(sil0$tseq, sil0$lambda, type="l", lwd=3, main="dimension 0", xlab="t")
plot(sil1$tseq, sil1$lambda, type="l", lwd=3, main="dimension 1", xlab="t")
plot(sil2$tseq, sil2$lambda, type="l", lwd=3, main="dimension 2", xlab="t")
par(opar)

</code></pre>

<hr>
<h2 id='diagRips'>Compute Vietoris-Rips Complex for Persistent Homology</h2><span id='topic+diagRips'></span>

<h3>Description</h3>

<p><code>diagRips</code> computes the persistent diagram of the Vietoris-Rips filtration 
constructed on a point cloud represented as <code>matrix</code> or <code>dist</code> object. 
This function is a second-hand wrapper to <span class="pkg">TDAstats</span>'s wrapping for <code>Ripser</code> library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagRips(data, maxdim = 1, threshold = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagRips_+3A_data">data</code></td>
<td>
<p>a <code>'matrix'</code> or a S3 <code>'dist'</code> object.</p>
</td></tr>
<tr><td><code id="diagRips_+3A_maxdim">maxdim</code></td>
<td>
<p>maximum dimension of the computed homological features (default: 1).</p>
</td></tr>
<tr><td><code id="diagRips_+3A_threshold">threshold</code></td>
<td>
<p>maximum value of the filtration (default: <code>Inf</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe object of S3 class <code>"homology"</code> with following columns</p>

<dl>
<dt>Dimension</dt><dd><p>dimension corresponding to a feature.</p>
</dd>
<dt>Birth</dt><dd><p>birth of a feature.</p>
</dd>
<dt>Death</dt><dd><p>death of a feature.</p>
</dd>
</dl>



<h3>References</h3>

<p>Raoul
R. Wadhwa, Drew
F.K. Williamson, Andrew Dhawan, Jacob
G. Scott (2018).
&ldquo;TDAstats: R Pipeline for Computing Persistent Homology in Topological Data Analysis.&rdquo;
<em>Journal of Open Source Software</em>, <b>3</b>(28), 860.
ISSN 2475-9066.
</p>
<p>Ulrich Bauer (2019). &ldquo;Ripser: Efficient Computation of Vietoris-Rips Persistence Barcodes.&rdquo; <em>arXiv:1908.02518</em>.
</p>


<h3>See Also</h3>

<p><code><a href="TDAstats.html#topic+calculate_homology">calculate_homology</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ---------------------------------------------------------------------------
# Check consistency of two types of inputs : 'matrix' and 'dist' objects
# ---------------------------------------------------------------------------
# Use 'iris' data and compute its distance matrix
XX = as.matrix(iris[,1:4])
DX = stats::dist(XX)

# Compute VR Diagram with two inputs
vr.mat = diagRips(XX)
vr.dis = diagRips(DX)

col1 = as.factor(vr.mat$Dimension)
col2 = as.factor(vr.dis$Dimension)

# Visualize
opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
plot(vr.mat$Birth, vr.mat$Death, pch=19, col=col1, main="from 'matrix'")
plot(vr.dis$Birth, vr.dis$Death, pch=19, col=col2, main="from 'dist'")
par(opar)

</code></pre>

<hr>
<h2 id='fsdist'>Pairwise <code class="reqn">L_p</code> Distance of Multiple Functional Summaries</h2><span id='topic+fsdist'></span>

<h3>Description</h3>

<p>Given multiple functional summaries <code class="reqn">\Lambda_1 (t), \Lambda_2 (t), \ldots, \Lambda_N (t)</code>, 
compute <code class="reqn">L_p</code> distance in a pairwise sense.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsdist(fslist, p = 2, as.dist = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsdist_+3A_fslist">fslist</code></td>
<td>
<p>a length-<code class="reqn">N</code> list of functional summaries of persistent diagrams.</p>
</td></tr>
<tr><td><code id="fsdist_+3A_p">p</code></td>
<td>
<p>an exponent in <code class="reqn">[1,\infty)</code> (default: 2).</p>
</td></tr>
<tr><td><code id="fsdist_+3A_as.dist">as.dist</code></td>
<td>
<p>logical; if TRUE, it returns <code>dist</code> object, else it returns an <code class="reqn">(N\times N)</code> symmetric matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a S3 <code>dist</code> object or <code class="reqn">(N\times N)</code> symmetric matrix of pairwise distances according to <code>as.dist</code> parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ---------------------------------------------------------------------------
#      Compute L_2 Distance for 3 Types of Landscapes and Silhouettes
#
# We will compare dim=0,1 with top-5 landscape functions with 
# - Class 1 : 'iris' dataset with noise
# - Class 2 : samples from 'gen2holes()'
# - Class 3 : samples from 'gen2circles()'
# ---------------------------------------------------------------------------
## Generate Data and Diagram from VR Filtration
ndata     = 10
list_rips = list()
for (i in 1:ndata){
  dat1 = as.matrix(iris[,1:4]) + matrix(rnorm(150*4), ncol=4)
  dat2 = gen2holes(n=100, sd=1)$data
  dat3 = gen2circles(n=100, sd=1)$data
  
  list_rips[[i]] = diagRips(dat1, maxdim=1)
  list_rips[[i+ndata]] = diagRips(dat2, maxdim=1)
  list_rips[[i+(2*ndata)]] = diagRips(dat3, maxdim=1)
}

## Compute Persistence Landscapes from Each Diagram with k=5 Functions
#  We try to get distance in dimensions 0 and 1.
list_land0 = list()
list_land1 = list()
for (i in 1:(3*ndata)){
  list_land0[[i]] = diag2landscape(list_rips[[i]], dimension=0, k=5)
  list_land1[[i]] = diag2landscape(list_rips[[i]], dimension=1, k=5)
}

## Compute Silhouettes
list_sil0 = list()
list_sil1 = list()
for (i in 1:(3*ndata)){
  list_sil0[[i]] = diag2silhouette(list_rips[[i]], dimension=0)
  list_sil1[[i]] = diag2silhouette(list_rips[[i]], dimension=1)
}

## Compute L2 Distance Matrices
ldmat0 = fsdist(list_land0, p=2, as.dist=FALSE)
ldmat1 = fsdist(list_land1, p=2, as.dist=FALSE)
sdmat0 = fsdist(list_sil0, p=2, as.dist=FALSE)
sdmat1 = fsdist(list_sil1, p=2, as.dist=FALSE)

## Visualize
opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(2,2), pty="s")
image(ldmat0[,(3*(ndata)):1], axes=FALSE, main="Landscape : dim=0")
image(ldmat1[,(3*(ndata)):1], axes=FALSE, main="Landscape : dim=1")
image(sdmat0[,(3*(ndata)):1], axes=FALSE, main="Silhouette : dim=0")
image(sdmat1[,(3*(ndata)):1], axes=FALSE, main="Silhouette : dim=1")
par(opar)


</code></pre>

<hr>
<h2 id='fsdist2'>Pairwise <code class="reqn">L_p</code> Distance for Two Sets of Functional Summaries</h2><span id='topic+fsdist2'></span>

<h3>Description</h3>

<p>Given two sets of functional summaries <code class="reqn">\Lambda_1 (t), \ldots, \Lambda_M (t)</code> and 
<code class="reqn">\Omega_1 (t), \ldots, \Omega_N (t)</code>, compute <code class="reqn">L_p</code> distance across pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsdist2(fslist1, fslist2, p = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsdist2_+3A_fslist1">fslist1</code></td>
<td>
<p>a length-<code class="reqn">M</code> list of functional summaries of persistent diagrams.</p>
</td></tr>
<tr><td><code id="fsdist2_+3A_fslist2">fslist2</code></td>
<td>
<p>a length-<code class="reqn">N</code> list of functional summaries of persistent diagrams.</p>
</td></tr>
<tr><td><code id="fsdist2_+3A_p">p</code></td>
<td>
<p>an exponent in <code class="reqn">[1,\infty)</code> (default: 2).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code class="reqn">(M\times N)</code> distance matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ---------------------------------------------------------------------------
#         Compute L1 and L2 Distance for Two Sets of Landscapes
#
# First  set consists of {Class 1, Class 2}, while
# Second set consists of {Class 1, Class 3} where
#
# - Class 1 : 'iris' dataset with noise
# - Class 2 : samples from 'gen2holes()'
# - Class 3 : samples from 'gen2circles()'
# ---------------------------------------------------------------------------
## Generate Data and Diagram from VR Filtration
ndata      = 10
list_rips1 = list()
list_rips2 = list()
for (i in 1:ndata){
  dat1 = as.matrix(iris[,1:4]) + matrix(rnorm(150*4, sd=4), ncol=4)
  dat2 = gen2holes(n=100, sd=1)$data
  dat3 = as.matrix(iris[,1:4]) + matrix(rnorm(150*4, sd=4), ncol=4)
  dat4 = gen2circles(n=100, sd=1)$data
  
  list_rips1[[i]]       = diagRips(dat1, maxdim=1)
  list_rips1[[i+ndata]] = diagRips(dat2, maxdim=1)
  
  list_rips2[[i]]       = diagRips(dat3, maxdim=1)
  list_rips2[[i+ndata]] = diagRips(dat4, maxdim=1)
}

## Compute Persistence Landscapes from Each Diagram with k=10 Functions
#  We try to get distance in dimension 1 only for faster comparison.
list_pset1 = list()
list_pset2 = list()
for (i in 1:(2*ndata)){
  list_pset1[[i]] = diag2landscape(list_rips1[[i]], dimension=1, k=10)
  list_pset2[[i]] = diag2landscape(list_rips2[[i]], dimension=1, k=10)
}

## Compute L1 and L2 Distance Matrix
dmat1 = fsdist2(list_pset1, list_pset2, p=1)
dmat2 = fsdist2(list_pset1, list_pset2, p=2)

## Visualize
opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
image(dmat1[,(2*ndata):1], axes=FALSE, main="distance for p=1")
image(dmat2[,(2*ndata):1], axes=FALSE, main="distance for p=2")
par(opar)


</code></pre>

<hr>
<h2 id='fseqdist'>Multi-sample Energy Test of Equal Distributions</h2><span id='topic+fseqdist'></span>

<h3>Description</h3>

<p>Also known as <code class="reqn">k</code>-sample problem, it tests whether multiple functional summaries 
are equally distributed or not via Energy statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fseqdist(fslist, label, method = c("original", "disco"), mc.iter = 999)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fseqdist_+3A_fslist">fslist</code></td>
<td>
<p>a length-<code class="reqn">N</code> list of functional summaries of persistent diagrams.</p>
</td></tr>
<tr><td><code id="fseqdist_+3A_label">label</code></td>
<td>
<p>a length-<code class="reqn">N</code> vector of class labels.</p>
</td></tr>
<tr><td><code id="fseqdist_+3A_method">method</code></td>
<td>
<p>(case-sensitive) name of methods; one of <code>"original"</code> or <code>"disco"</code>.</p>
</td></tr>
<tr><td><code id="fseqdist_+3A_mc.iter">mc.iter</code></td>
<td>
<p>number of bootstrap replicates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a (list) object of S3 class <code>htest</code> containing:</p>

<dl>
<dt>method</dt><dd><p>name of the test.</p>
</dd>
<dt>statistic</dt><dd><p>a test statistic.</p>
</dd>
<dt>p.value</dt><dd><p><code class="reqn">p</code>-value under <code class="reqn">H_0</code> of equal distributions.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
# ---------------------------------------------------------------------------
#         Test for Equality of Distributions via Energy Statistics
#
# We will compare dim=0's top-5 landscape functions with 
# - Class 1 : 'iris' dataset with noise
# - Class 2 : samples from 'gen2holes()'
# - Class 3 : samples from 'gen2circles()'
# ---------------------------------------------------------------------------
## Generate Data and Diagram from VR Filtration
ndata     = 10
list_rips = list()
for (i in 1:ndata){
  dat1 = as.matrix(iris[,1:4]) + matrix(rnorm(150*4), ncol=4)
  dat2 = gen2holes(n=100, sd=1)$data
  dat3 = gen2circles(n=100, sd=1)$data
  
  list_rips[[i]] = diagRips(dat1, maxdim=1)
  list_rips[[i+ndata]] = diagRips(dat2, maxdim=1)
  list_rips[[i+(2*ndata)]] = diagRips(dat3, maxdim=1)
}

## Compute Persistence Landscapes from Each Diagram with k=5 Functions
list_land0 = list()
for (i in 1:(3*ndata)){
  list_land0[[i]] = diag2landscape(list_rips[[i]], dimension=0, k=5)
}

## Create Label and Run the Test with Different Options
list_lab = c(rep(1,ndata), rep(2,ndata), rep(3,ndata))
fseqdist(list_land0, list_lab, method="original")
fseqdist(list_land0, list_lab, method="disco")


</code></pre>

<hr>
<h2 id='fshclust'>Hierarchical Agglomerative Clustering</h2><span id='topic+fshclust'></span>

<h3>Description</h3>

<p>Given multiple functional summaries <code class="reqn">\Lambda_1 (t), \Lambda_2 (t), \ldots, \Lambda_N (t)</code>, 
perform hierarchical agglomerative clustering with <code class="reqn">L_2</code> distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fshclust(
  fslist,
  method = c("single", "complete", "average", "mcquitty", "ward.D", "ward.D2",
    "centroid", "median"),
  members = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fshclust_+3A_fslist">fslist</code></td>
<td>
<p>a length-<code class="reqn">N</code> list of functional summaries of persistent diagrams.</p>
</td></tr>
<tr><td><code id="fshclust_+3A_method">method</code></td>
<td>
<p>agglomeration method to be used. This must be one of <code>"single"</code>, <code>"complete"</code>, <code>"average"</code>, <code>"mcquitty"</code>, <code>"ward.D"</code>, <code>"ward.D2"</code>, <code>"centroid"</code> or <code>"median"</code>.</p>
</td></tr>
<tr><td><code id="fshclust_+3A_members">members</code></td>
<td>
<p><code>NULL</code> or a vector whose length equals the number of observations. See <code><a href="stats.html#topic+hclust">hclust</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>hclust</code>. See <code><a href="stats.html#topic+hclust">hclust</a></code> for details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ---------------------------------------------------------------------------
#           K-Groups Clustering via Energy Distance
#
# We will cluster dim=0 under top-5 landscape functions with 
# - Class 1 : 'iris' dataset with noise
# - Class 2 : samples from 'gen2holes()'
# - Class 3 : samples from 'gen2circles()'
# ---------------------------------------------------------------------------
## Generate Data and Diagram from VR Filtration
ndata     = 10
list_rips = list()
for (i in 1:ndata){
  dat1 = as.matrix(iris[,1:4]) + matrix(rnorm(150*4), ncol=4)
  dat2 = gen2holes(n=100, sd=1)$data
  dat3 = gen2circles(n=100, sd=1)$data
  
  list_rips[[i]] = diagRips(dat1, maxdim=1)
  list_rips[[i+ndata]] = diagRips(dat2, maxdim=1)
  list_rips[[i+(2*ndata)]] = diagRips(dat3, maxdim=1)
}
list_lab = c(rep(1,ndata), rep(2,ndata), rep(3,ndata))

## Compute Persistence Landscapes from Each Diagram with k=5 Functions
list_land0 = list()
for (i in 1:(3*ndata)){
  list_land0[[i]] = diag2landscape(list_rips[[i]], dimension=0, k=5)
}

## Run MDS for Visualization
embed = fsmds(list_land0, ndim=2)

## Clustering with 'single' and 'complete' linkage
hc.sing &lt;- fshclust(list_land0, method="single")
hc.comp &lt;- fshclust(list_land0, method="complete")

## Visualize
opar  = par(no.readonly=TRUE)
par(mfrow=c(1,3))
plot(embed, pch=19, col=list_lab, main="2-dim embedding")
plot(hc.sing, main="single linkage")
plot(hc.comp, main="complete linkage")
par(opar)


</code></pre>

<hr>
<h2 id='fskgroups'><code class="reqn">k</code>-Groups Clustering of Multiple Functional Summaries by Energy Distance</h2><span id='topic+fskgroups'></span>

<h3>Description</h3>

<p>Given <code class="reqn">N</code> functional summaries <code class="reqn">\Lambda_1 (t), \Lambda_2 (t), \ldots, \Lambda_N (t)</code>, 
perform <code class="reqn">k</code>-groups clustering by energy distance using <code class="reqn">L_2</code> metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fskgroups(fslist, k = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fskgroups_+3A_fslist">fslist</code></td>
<td>
<p>a length-<code class="reqn">N</code> list of functional summaries of persistent diagrams.</p>
</td></tr>
<tr><td><code id="fskgroups_+3A_k">k</code></td>
<td>
<p>the number of clusters.</p>
</td></tr>
<tr><td><code id="fskgroups_+3A_...">...</code></td>
<td>
<p>extra parameters including </p>

<dl>
<dt>maxiter</dt><dd><p>the number of iterations (default: 50).</p>
</dd>
<dt>nstart</dt><dd><p>the number of restarts (default: 2).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>a length-<code class="reqn">N</code> vector of class labels (from <code class="reqn">1:k</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ---------------------------------------------------------------------------
#           K-Groups Clustering via Energy Distance
#
# We will cluster dim=0 under top-5 landscape functions with 
# - Class 1 : 'iris' dataset with noise
# - Class 2 : samples from 'gen2holes()'
# - Class 3 : samples from 'gen2circles()'
# ---------------------------------------------------------------------------
## Generate Data and Diagram from VR Filtration
ndata     = 10
list_rips = list()
for (i in 1:ndata){
  dat1 = as.matrix(iris[,1:4]) + matrix(rnorm(150*4), ncol=4)
  dat2 = gen2holes(n=100, sd=1)$data
  dat3 = gen2circles(n=100, sd=1)$data
  
  list_rips[[i]] = diagRips(dat1, maxdim=1)
  list_rips[[i+ndata]] = diagRips(dat2, maxdim=1)
  list_rips[[i+(2*ndata)]] = diagRips(dat3, maxdim=1)
}

## Compute Persistence Landscapes from Each Diagram with k=5 Functions
list_land0 = list()
for (i in 1:(3*ndata)){
  list_land0[[i]] = diag2landscape(list_rips[[i]], dimension=0, k=5)
}

## Run K-Groups Clustering with different K's
label2  = fskgroups(list_land0, k=2)
label3  = fskgroups(list_land0, k=3)
label4  = fskgroups(list_land0, k=4)
truelab = rep(c(1,2,3), each=ndata)

## Run MDS &amp; Visualization
embed = fsmds(list_land0, ndim=2)
opar  = par(no.readonly=TRUE)
par(mfrow=c(2,2), pty="s")
plot(embed, col=truelab, pch=19, main="true label")
plot(embed, col=label2,  pch=19, main="k=2 label")
plot(embed, col=label3,  pch=19, main="k=3 label")
plot(embed, col=label4,  pch=19, main="k=4 label")
par(opar)


</code></pre>

<hr>
<h2 id='fskmedoids'>K-Medoids Clustering</h2><span id='topic+fskmedoids'></span>

<h3>Description</h3>

<p>Given <code class="reqn">N</code> functional summaries <code class="reqn">\Lambda_1 (t), \Lambda_2 (t), \ldots, \Lambda_N (t)</code>, 
perform k-medoids clustering using pairwise distances using <code class="reqn">L_2</code> metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fskmedoids(fslist, k = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fskmedoids_+3A_fslist">fslist</code></td>
<td>
<p>a length-<code class="reqn">N</code> list of functional summaries of persistent diagrams.</p>
</td></tr>
<tr><td><code id="fskmedoids_+3A_k">k</code></td>
<td>
<p>the number of clusters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a length-<code class="reqn">N</code> vector of class labels (from <code class="reqn">1:k</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ---------------------------------------------------------------------------
#           K-Groups Clustering via Energy Distance
#
# We will cluster dim=0 under top-5 landscape functions with 
# - Class 1 : 'iris' dataset with noise
# - Class 2 : samples from 'gen2holes()'
# - Class 3 : samples from 'gen2circles()'
# ---------------------------------------------------------------------------
## Generate Data and Diagram from VR Filtration
ndata     = 10
list_rips = list()
for (i in 1:ndata){
  dat1 = as.matrix(iris[,1:4]) + matrix(rnorm(150*4), ncol=4)
  dat2 = gen2holes(n=100, sd=1)$data
  dat3 = gen2circles(n=100, sd=1)$data
  
  list_rips[[i]] = diagRips(dat1, maxdim=1)
  list_rips[[i+ndata]] = diagRips(dat2, maxdim=1)
  list_rips[[i+(2*ndata)]] = diagRips(dat3, maxdim=1)
}

## Compute Persistence Landscapes from Each Diagram with k=5 Functions
list_land0 = list()
for (i in 1:(3*ndata)){
  list_land0[[i]] = diag2landscape(list_rips[[i]], dimension=0, k=5)
}

## Run K-Medoids Clustering with different K's
label2  = fskmedoids(list_land0, k=2)
label3  = fskmedoids(list_land0, k=3)
label4  = fskmedoids(list_land0, k=4)
truelab = rep(c(1,2,3), each=ndata)

## Run MDS &amp; Visualization
embed = fsmds(list_land0, ndim=2)
opar  = par(no.readonly=TRUE)
par(mfrow=c(2,2), pty="s")
plot(embed, col=truelab, pch=19, main="true label")
plot(embed, col=label2,  pch=19, main="k=2 label")
plot(embed, col=label3,  pch=19, main="k=3 label")
plot(embed, col=label4,  pch=19, main="k=4 label")
par(opar)


</code></pre>

<hr>
<h2 id='fsmds'>Multidimensional Scaling</h2><span id='topic+fsmds'></span>

<h3>Description</h3>

<p>Given multiple functional summaries <code class="reqn">\Lambda_1 (t), \Lambda_2 (t), \ldots, \Lambda_N (t)</code>, 
apply multidimensional scaling to get low-dimensional representation in Euclidean space. Usually, 
<code>ndim=2,3</code> is chosen for visualization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsmds(fslist, ndim = 2, method = c("classical", "metric"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsmds_+3A_fslist">fslist</code></td>
<td>
<p>a length-<code class="reqn">N</code> list of functional summaries of persistent diagrams.</p>
</td></tr>
<tr><td><code id="fsmds_+3A_ndim">ndim</code></td>
<td>
<p>an integer-valued target dimension (default: 2).</p>
</td></tr>
<tr><td><code id="fsmds_+3A_method">method</code></td>
<td>
<p>name of an algorithm type (default: classical).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code class="reqn">(N\times ndim)</code> matrix of embedding.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ---------------------------------------------------------------------------
#     Multidimensional Scaling for Multiple Landscapes and Silhouettes
#
# We will compare dim=0 with top-5 landscape and silhouette functions with 
# - Class 1 : 'iris' dataset with noise
# - Class 2 : samples from 'gen2holes()'
# - Class 3 : samples from 'gen2circles()'
# ---------------------------------------------------------------------------
## Generate Data and Diagram from VR Filtration
ndata     = 10
list_rips = list()
for (i in 1:ndata){
  dat1 = as.matrix(iris[,1:4]) + matrix(rnorm(150*4), ncol=4)
  dat2 = gen2holes(n=100, sd=1)$data
  dat3 = gen2circles(n=100, sd=1)$data
  
  list_rips[[i]] = diagRips(dat1, maxdim=1)
  list_rips[[i+ndata]] = diagRips(dat2, maxdim=1)
  list_rips[[i+(2*ndata)]] = diagRips(dat3, maxdim=1)
}

## Compute Landscape and Silhouettes of Dimension 0
list_land = list()
list_sils = list()
for (i in 1:(3*ndata)){
  list_land[[i]] = diag2landscape(list_rips[[i]], dimension=0)
  list_sils[[i]] = diag2silhouette(list_rips[[i]], dimension=0)
}
list_lab = rep(c(1,2,3), each=ndata)

## Run Classical/Metric Multidimensional Scaling
land_cmds = fsmds(list_land, method="classical")
land_mmds = fsmds(list_land, method="metric")
sils_cmds = fsmds(list_sils, method="classical")
sils_mmds = fsmds(list_sils, method="metric")

## Visualize
opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(2,2))
plot(land_cmds, pch=19, col=list_lab, main="Landscape+CMDS")
plot(land_mmds, pch=19, col=list_lab, main="Landscape+MMDS")
plot(sils_cmds, pch=19, col=list_lab, main="Silhouette+CMDS")
plot(sils_mmds, pch=19, col=list_lab, main="Silhouette+MMDS")
par(opar)


</code></pre>

<hr>
<h2 id='fsmean'>Mean of Multiple Functional Summaries</h2><span id='topic+fsmean'></span>

<h3>Description</h3>

<p>Given multiple functional summaries <code class="reqn">\Lambda_1 (t), \Lambda_2 (t), \ldots, \Lambda_N (t)</code>,
compute the mean 
</p>
<p style="text-align: center;"><code class="reqn">\bar{\Lambda} (t) = \frac{1}{N} \sum_{n=1}^N \Lambda_n (t)</code>
</p>
<p>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsmean(fslist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsmean_+3A_fslist">fslist</code></td>
<td>
<p>a length-<code class="reqn">N</code> list of functional summaries of persistent diagrams.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a functional summary object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ---------------------------------------------------------------------------
#         Mean of 10 Persistence Landscapes from '2holes' data
# ---------------------------------------------------------------------------
## Generate 10 Diagrams with 'gen2holes()' function
list_rips = list()
for (i in 1:10){
  list_rips[[i]] = diagRips(gen2holes(n=100, sd=2)$data, maxdim=1)
}

## Compute Persistence Landscapes from Each Diagram with k=5 Functions
list_land = list()
for (i in 1:10){
  list_land[[i]] = diag2landscape(list_rips[[i]], dimension=0, k=5)
}

## Compute Weighted Sum of Landscapes
ldsum = fsmean(list_land)

## Visualize
sam5  &lt;- sort(sample(1:10, 5, replace=FALSE))
opar  &lt;- par(no.readonly=TRUE)
par(mfrow=c(2,3), pty="s")
for (i in 1:5){
  tgt = list_land[[sam5[i]]]
  matplot(tgt$tseq, tgt$lambda[,1:5], type="l", lwd=3, main=paste("landscape no.",sam5[i]))
}
matplot(ldsum$tseq, ldsum$lambda[,1:5], type="l", lwd=3, main="weighted sum")
par(opar)

</code></pre>

<hr>
<h2 id='fsnorm'><code class="reqn">L_p</code> Norm of a Single Functional Summary</h2><span id='topic+fsnorm'></span>

<h3>Description</h3>

<p>Given a functional summary <code class="reqn">\Lambda (t)</code>, compute the <code class="reqn">p</code>-norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsnorm(fsobj, p = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsnorm_+3A_fsobj">fsobj</code></td>
<td>
<p>a functional summary object.</p>
</td></tr>
<tr><td><code id="fsnorm_+3A_p">p</code></td>
<td>
<p>an exponent in <code class="reqn">[1,\infty)</code> (default: 2).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code class="reqn">L_p</code>-norm value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Generate Toy Data from 'gen2circles()'
dat = gen2circles(n=100)$data

## Compute PD, Landscapes, and Silhouettes
myPD  = diagRips(dat, maxdim=1)
myPL0 = diag2landscape(myPD, dimension=0)
myPL1 = diag2landscape(myPD, dimension=1)
myPS0 = diag2silhouette(myPD, dimension=0)
myPS1 = diag2silhouette(myPD, dimension=1)

## Compute 2-norm
fsnorm(myPL0, p=2)
fsnorm(myPL1, p=2)
fsnorm(myPS0, p=2)
fsnorm(myPS1, p=2)


</code></pre>

<hr>
<h2 id='fssc05Z'>Spectral Clustering by Zelnik-Manor and Perona (2005)</h2><span id='topic+fssc05Z'></span>

<h3>Description</h3>

<p>Given <code class="reqn">N</code> functional summaries <code class="reqn">\Lambda_1 (t), \Lambda_2 (t), \ldots, \Lambda_N (t)</code>, 
perform spectral clustering proposed by Zelnik-Manor and Perona using a set of 
data-driven bandwidth parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fssc05Z(fslist, k = 2, nnbd = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fssc05Z_+3A_fslist">fslist</code></td>
<td>
<p>a length-<code class="reqn">N</code> list of functional summaries of persistent diagrams.</p>
</td></tr>
<tr><td><code id="fssc05Z_+3A_k">k</code></td>
<td>
<p>the number of cluster (default: 2).</p>
</td></tr>
<tr><td><code id="fssc05Z_+3A_nnbd">nnbd</code></td>
<td>
<p>neighborhood size to define data-driven bandwidth parameter (default: 5).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a length-<code class="reqn">N</code> vector of class labels (from <code class="reqn">1:k</code>).
</p>


<h3>References</h3>

<p>Zelnik-manor L, Perona P (2005). &ldquo;Self-Tuning Spectral Clustering.&rdquo; In Saul LK, Weiss Y, Bottou L (eds.), <em>Advances in Neural Information Processing Systems 17</em>, 1601–1608. MIT Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ---------------------------------------------------------------------------
#           Spectral Clustering Clustering via Energy Distance
#
# We will cluster dim=0 under top-5 landscape functions with 
# - Class 1 : 'iris' dataset with noise
# - Class 2 : samples from 'gen2holes()'
# - Class 3 : samples from 'gen2circles()'
# ---------------------------------------------------------------------------
## Generate Data and Diagram from VR Filtration
ndata     = 10
list_rips = list()
for (i in 1:ndata){
  dat1 = as.matrix(iris[,1:4]) + matrix(rnorm(150*4), ncol=4)
  dat2 = gen2holes(n=100, sd=1)$data
  dat3 = gen2circles(n=100, sd=1)$data
  
  list_rips[[i]] = diagRips(dat1, maxdim=1)
  list_rips[[i+ndata]] = diagRips(dat2, maxdim=1)
  list_rips[[i+(2*ndata)]] = diagRips(dat3, maxdim=1)
}

## Compute Persistence Landscapes from Each Diagram with k=5 Functions
list_land0 = list()
for (i in 1:(3*ndata)){
  list_land0[[i]] = diag2landscape(list_rips[[i]], dimension=0, k=5)
}

## Run Spectral Clustering using Different K's.
label2  = fssc05Z(list_land0, k=2)
label3  = fssc05Z(list_land0, k=3)
label4  = fssc05Z(list_land0, k=4)
truelab = rep(c(1,2,3), each=ndata)

## Run MDS &amp; Visualization
embed = fsmds(list_land0, ndim=2)
opar  = par(no.readonly=TRUE)
par(mfrow=c(2,2), pty="s")
plot(embed, col=truelab, pch=19, main="true label")
plot(embed, col=label2,  pch=19, main="k=2 label")
plot(embed, col=label3,  pch=19, main="k=3 label")
plot(embed, col=label4,  pch=19, main="k=4 label")
par(opar)


</code></pre>

<hr>
<h2 id='fssum'>Weighted Sum of Multiple Functional Summaries</h2><span id='topic+fssum'></span>

<h3>Description</h3>

<p>Given multiple functional summaries <code class="reqn">\Lambda_1 (t), \Lambda_2 (t), \ldots, \Lambda_N (t)</code>,
compute the weighted sum 
</p>
<p style="text-align: center;"><code class="reqn">\bar{\Lambda} (t) = \sum_{n=1}^N w_n \Lambda_n (t)</code>
</p>

<p>with a specified vector of given weights <code class="reqn">w_1,w_2,\ldots,w_N</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fssum(fslist, weight = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fssum_+3A_fslist">fslist</code></td>
<td>
<p>a length-<code class="reqn">N</code> list of functional summaries of persistent diagrams.</p>
</td></tr>
<tr><td><code id="fssum_+3A_weight">weight</code></td>
<td>
<p>a weight vector of length <code class="reqn">N</code>. If <code>NULL</code> (default), weights are automatically set as <code class="reqn">w_1=\cdots=w_N = 1/N</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a functional summary object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ---------------------------------------------------------------------------
#     Weighted Average of 10 Persistence Landscapes from '2holes' data
# ---------------------------------------------------------------------------
## Generate 10 Diagrams with 'gen2holes()' function
list_rips = list()
for (i in 1:10){
  list_rips[[i]] = diagRips(gen2holes(n=100, sd=2)$data, maxdim=1)
}

## Compute Persistence Landscapes from Each Diagram with k=5 Functions
list_land = list()
for (i in 1:10){
  list_land[[i]] = diag2landscape(list_rips[[i]], dimension=0, k=5)
}

## Some Random Weights
wrand = abs(stats::rnorm(10))
wrand = wrand/sum(wrand)

## Compute Weighted Sum of Landscapes
ldsum = fssum(list_land, weight=wrand)

## Visualize
sam5  &lt;- sort(sample(1:10, 5, replace=FALSE))
opar  &lt;- par(no.readonly=TRUE)
par(mfrow=c(2,3), pty="s")
for (i in 1:5){
  tgt = list_land[[sam5[i]]]
  matplot(tgt$tseq, tgt$lambda[,1:5], type="l", lwd=3, main=paste("landscape no.",sam5[i]))
}
matplot(ldsum$tseq, ldsum$lambda[,1:5], type="l", lwd=3, main="weighted sum")
par(opar)

</code></pre>

<hr>
<h2 id='fstsne'>t-distributed Stochastic Neighbor Embedding</h2><span id='topic+fstsne'></span>

<h3>Description</h3>

<p>Given <code class="reqn">N</code>  functional summaries <code class="reqn">\Lambda_1 (t), \Lambda_2 (t), \ldots, \Lambda_N (t)</code>, 
t-SNE mimicks the pattern of probability distributions over pairs of Banach-valued 
objects on low-dimensional target embedding space by minimizing Kullback-Leibler divergence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fstsne(fslist, ndim = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fstsne_+3A_fslist">fslist</code></td>
<td>
<p>a length-<code class="reqn">N</code> list of functional summaries of persistent diagrams.</p>
</td></tr>
<tr><td><code id="fstsne_+3A_ndim">ndim</code></td>
<td>
<p>an integer-valued target dimension.</p>
</td></tr>
<tr><td><code id="fstsne_+3A_...">...</code></td>
<td>
<p>extra parameters for <code><a href="Rtsne.html#topic+Rtsne">Rtsne</a></code> algorithm, such as perplexity, momentum, and others.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing </p>

<dl>
<dt>embed</dt><dd><p>an <code class="reqn">(N\times ndim)</code> matrix whose rows are embedded observations.</p>
</dd>
<dt>stress</dt><dd><p>discrepancy between embedded and original distances as a measure of error.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="Rtsne.html#topic+Rtsne">Rtsne</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ---------------------------------------------------------------------------
#     Multidimensional Scaling for Multiple Landscapes and Silhouettes
#
# We will compare dim=0 with top-5 landscape and silhouette functions with 
# - Class 1 : 'iris' dataset with noise
# - Class 2 : samples from 'gen2holes()'
# - Class 3 : samples from 'gen2circles()'
# ---------------------------------------------------------------------------
## Generate Data and Diagram from VR Filtration
ndata     = 10
list_rips = list()
for (i in 1:ndata){
  dat1 = as.matrix(iris[,1:4]) + matrix(rnorm(150*4), ncol=4)
  dat2 = gen2holes(n=100, sd=1)$data
  dat3 = gen2circles(n=100, sd=1)$data
  
  list_rips[[i]] = diagRips(dat1, maxdim=1)
  list_rips[[i+ndata]] = diagRips(dat2, maxdim=1)
  list_rips[[i+(2*ndata)]] = diagRips(dat3, maxdim=1)
}

## Compute Landscape and Silhouettes of Dimension 0
list_land = list()
list_sils = list()
for (i in 1:(3*ndata)){
  list_land[[i]] = diag2landscape(list_rips[[i]], dimension=0)
  list_sils[[i]] = diag2silhouette(list_rips[[i]], dimension=0)
}
list_lab = rep(c(1,2,3), each=ndata)

## Run t-SNE and Classical/Metric MDS
land_cmds = fsmds(list_land, method="classical")
land_mmds = fsmds(list_land, method="metric")
land_tsne = fstsne(list_land, perplexity=5)$embed
sils_cmds = fsmds(list_sils, method="classical")
sils_mmds = fsmds(list_sils, method="metric")
sils_tsne = fstsne(list_land, perplexity=5)$embed

## Visualize
opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(2,3))
plot(land_cmds, pch=19, col=list_lab, main="Landscape+CMDS")
plot(land_mmds, pch=19, col=list_lab, main="Landscape+MMDS")
plot(land_tsne, pch=19, col=list_lab, main="Landscape+tSNE")
plot(sils_cmds, pch=19, col=list_lab, main="Silhouette+CMDS")
plot(sils_mmds, pch=19, col=list_lab, main="Silhouette+MMDS")
plot(sils_tsne, pch=19, col=list_lab, main="Silhouette+tSNE")
par(opar)


</code></pre>

<hr>
<h2 id='gen2circles'>Generate Two Intersecting Circles</h2><span id='topic+gen2circles'></span>

<h3>Description</h3>

<p>It generates data from two intersecting circles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen2circles(n = 496, sd = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen2circles_+3A_n">n</code></td>
<td>
<p>the total number of observations to be generated.</p>
</td></tr>
<tr><td><code id="gen2circles_+3A_sd">sd</code></td>
<td>
<p>level of additive white noise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing</p>

<dl>
<dt>data</dt><dd><p>an <code class="reqn">(n\times 2)</code> data matrix for row-stacked observations.</p>
</dd>
<dt>label</dt><dd><p>a length-<code class="reqn">n</code> vector for class label.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Generate Data with Different Noise Levels
nn = 200
x1 = gen2circles(n=nn, sd=0)
x2 = gen2circles(n=nn, sd=0.1)
x3 = gen2circles(n=nn, sd=0.25)

## Visualize
opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(1,3), pty="s")
plot(x1$data, pch=19, main="sd=0.00", col=x1$label)
plot(x2$data, pch=19, main="sd=0.10", col=x2$label)
plot(x3$data, pch=19, main="sd=0.25", col=x3$label)
par(opar)

</code></pre>

<hr>
<h2 id='gen2holes'>Generate Two Intertwined Holes</h2><span id='topic+gen2holes'></span>

<h3>Description</h3>

<p>It generates data from two intertwine circles with empty interiors(holes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen2holes(n = 496, sd = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen2holes_+3A_n">n</code></td>
<td>
<p>the total number of observations to be generated.</p>
</td></tr>
<tr><td><code id="gen2holes_+3A_sd">sd</code></td>
<td>
<p>level of additive white noise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing</p>

<dl>
<dt>data</dt><dd><p>an <code class="reqn">(n\times 2)</code> data matrix for row-stacked observations.</p>
</dd>
<dt>label</dt><dd><p>a length-<code class="reqn">n</code> vector for class label.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Generate Data with Different Noise Levels
nn = 200
x1 = gen2holes(n=nn, sd=0)
x2 = gen2holes(n=nn, sd=0.1)
x3 = gen2holes(n=nn, sd=0.25)

## Visualize
opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(1,3), pty="s")
plot(x1$data, pch=19, main="sd=0.00", col=x1$label)
plot(x2$data, pch=19, main="sd=0.10", col=x2$label)
plot(x3$data, pch=19, main="sd=0.25", col=x3$label)
par(opar)

</code></pre>

<hr>
<h2 id='plkernel'>Persistence Landscape Kernel</h2><span id='topic+plkernel'></span>

<h3>Description</h3>

<p>Given multiple persistence landscapes <code class="reqn">\Lambda_1 (t), \Lambda_2 (t), \ldots, \Lambda_N (t)</code>, compute 
the persistence landscape kernel under the <code class="reqn">L_2</code> sense.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plkernel(landlist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plkernel_+3A_landlist">landlist</code></td>
<td>
<p>a length-<code class="reqn">N</code> list of <code>"landscape"</code> objects, which can be obtained from <code><a href="#topic+diag2landscape">diag2landscape</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code class="reqn">(N\times N)</code> kernel matrix.
</p>


<h3>References</h3>

<p>Jan Reininghaus, Stefan Huber, Ulrich Bauer, and Roland Kwitt (2015). &ldquo;A stable multi-scale kernel for topological machine learning.&rdquo; 
<em>Proc. 2015 IEEE Conf. Comp. Vision &amp; Pat. Rec. (CVPR ’15)</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ---------------------------------------------------------------------------
#      Persistence Landscape Kernel in Dimension 0 and 1
#
# We will compare dim=0,1 with top-20 landscape functions with 
# - Class 1 : 'iris' dataset with noise
# - Class 2 : samples from 'gen2holes()'
# - Class 3 : samples from 'gen2circles()'
# ---------------------------------------------------------------------------
## Generate Data and Diagram from VR Filtration
ndata     = 10
list_rips = list()
for (i in 1:ndata){
  dat1 = as.matrix(iris[,1:4]) + matrix(rnorm(150*4), ncol=4)
  dat2 = gen2holes(n=100, sd=1)$data
  dat3 = gen2circles(n=100, sd=1)$data
  
  list_rips[[i]] = diagRips(dat1, maxdim=1)
  list_rips[[i+ndata]] = diagRips(dat2, maxdim=1)
  list_rips[[i+(2*ndata)]] = diagRips(dat3, maxdim=1)
}

## Compute Persistence Landscapes from Each Diagram with k=5 Functions
#  We try to get distance in dimensions 0 and 1.
list_land0 = list()
list_land1 = list()
for (i in 1:(3*ndata)){
  list_land0[[i]] = diag2landscape(list_rips[[i]], dimension=0, k=5)
  list_land1[[i]] = diag2landscape(list_rips[[i]], dimension=1, k=5)
}

## Compute Persistence Landscape Kernel Matrix
plk0 &lt;- plkernel(list_land0)
plk1 &lt;- plkernel(list_land1)

## Visualize
opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
image(plk0[,(3*(ndata)):1], axes=FALSE, main="Kernel : dim=0")
image(plk1[,(3*(ndata)):1], axes=FALSE, main="Kernel : dim=1")
par(opar)


</code></pre>

<hr>
<h2 id='plot.homology'>Plot Persistent Homology via Barcode or Diagram</h2><span id='topic+plot.homology'></span>

<h3>Description</h3>

<p>Given a persistent homology of the data represented by a reconstructed 
complex in S3 class <code>homology</code> object, visualize it as either a barcode 
or a persistence diagram using <span class="pkg">ggplot2</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'homology'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.homology_+3A_x">x</code></td>
<td>
<p>a <code>homology</code> object.</p>
</td></tr>
<tr><td><code id="plot.homology_+3A_...">...</code></td>
<td>
<p>extra parameters including</p>

<dl>
<dt>method</dt><dd><p>type of visualization; either <code>"barcode"</code> or <code>"diagram"</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>a <span class="pkg">ggplot2</span> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Use 'iris' data
XX = as.matrix(iris[,1:4])

# Compute VR Diagram 
homology = diagRips(XX)

# Plot with 'barcode'
opar &lt;- par(no.readonly=TRUE)
plot(homology, method="barcode")
par(opar)


</code></pre>

<hr>
<h2 id='plot.landscape'>Plot Persistence Landscape</h2><span id='topic+plot.landscape'></span>

<h3>Description</h3>

<p>Given a persistence landscape object in S3 class <code>landscape</code>, visualize the 
landscapes using <span class="pkg">ggplot2</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'landscape'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.landscape_+3A_x">x</code></td>
<td>
<p>a <code>landscape</code> object.</p>
</td></tr>
<tr><td><code id="plot.landscape_+3A_...">...</code></td>
<td>
<p>extra parameters including </p>

<dl>
<dt>top.k</dt><dd><p>the number of landscapes to be plotted (default: 5).</p>
</dd>
<dt>colored</dt><dd><p>a logical; <code>TRUE</code> to assign different colors for landscapes, or <code>FALSE</code> to use grey color for all landscapes.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>a <span class="pkg">ggplot2</span> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Use 'iris' data
XX = as.matrix(iris[,1:4])

# Compute Persistence diagram and landscape of order 0 
homology  = diagRips(XX)
landscape = diag2landscape(homology, dimension=0)

# Plot with 'barcode'
opar &lt;- par(no.readonly=TRUE)
plot(landscape)
par(opar)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
