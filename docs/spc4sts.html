<!DOCTYPE html><html><head><title>Help for package spc4sts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spc4sts}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#spc4sts-package'>
<p>Statistical Process Control for Stochastic Textured Surfaces</p></a></li>
<li><a href='#ad'>
<p>One-Sample Anderson-Darling Statistic</p></a></li>
<li><a href='#bp'>
<p>Box-Pierce-Type Statistic</p></a></li>
<li><a href='#climit'>
<p>Control Limit and Diagnostic Threshold Construction</p></a></li>
<li><a href='#climit.object'>
<p>Control Limit and Diagnostic Threshold Construction Object</p></a></li>
<li><a href='#dataPrep'>
<p>Neighborhood Data Preparation</p></a></li>
<li><a href='#diagnoseLD'>
<p>Diagnose Local Defects on Stochastic Textured Surfaces</p></a></li>
<li><a href='#disMat'>
<p>Pairwise Dissimilarity Matrix of Stochastic Textured Surfaces</p></a></li>
<li><a href='#exptailecdf'>
<p>Empirical Cumulative Distribution Function with Exponential Tail Approximation</p></a></li>
<li><a href='#exptailecdf.object'>
<p>Empirical Cumulative Distribution Function with Exponential Tail Approximation Object</p></a></li>
<li><a href='#imposeDefect'>
<p>Superimpose A Local Defect</p></a></li>
<li><a href='#kerMat'>
<p>Epanechnikov quadratic kernel matrix</p></a></li>
<li><a href='#mbChange'>
<p>Matchbox Change</p></a></li>
<li><a href='#monitoringStat'>
<p>Monitoring Statistic for Stochastic Textured Surfaces</p></a></li>
<li><a href='#pexptailecdf'>
<p>Predictions from an Exptailecdf Object</p></a></li>
<li><a href='#plotcc'>
<p>Control Chart Plotting</p></a></li>
<li><a href='#sarGen'>
<p>Stochastic Autoregressive Image Generator</p></a></li>
<li><a href='#showNb'>
<p>Show Neighborhood</p></a></li>
<li><a href='#sms'>
<p>Spatial Moving Statistic</p></a></li>
<li><a href='#spaCov'>
<p>Spatial Weighted Covariance</p></a></li>
<li><a href='#surfacemodel'>
<p>Statistical reprentations of stochastic textured surfaces using supervised learning</p></a></li>
<li><a href='#twms'>
<p>Time-Weighted Moving Statistic</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Process Control for Stochastic Textured Surfaces</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Anh Tuan Bui [aut, cre] and Daniel W. Apley [ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anh Tuan Bui &lt;atbui@u.northwestern.edu&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>rpart, gridExtra, parallel</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides statistical process control tools for stochastic 
    textured surfaces. The current version supports the following tools:
    (1) generic modeling of stochastic textured surfaces.
    (2) local defect monitoring and diagnostics in stochastic 
        textured surfaces, which was proposed by Bui and Apley (2018a) 
        &lt;<a href="https://doi.org/10.1080%2F00401706.2017.1302362">doi:10.1080/00401706.2017.1302362</a>&gt;.
    (3) global change monitoring in the nature of stochastic 
        textured surfaces, which was proposed by Bui and Apley (2018b) 
        &lt;<a href="https://doi.org/10.1080%2F00224065.2018.1507559">doi:10.1080/00224065.2018.1507559</a>&gt;.
    (4) computation of dissimilarity matrix of stochastic textured 
        surface images, which was proposed by Bui and Apley (2019b)
        &lt;<a href="https://doi.org/10.1016%2Fj.csda.2019.01.019">doi:10.1016/j.csda.2019.01.019</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-21 15:53:09 UTC; buiat2</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-24 09:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='spc4sts-package'>
Statistical Process Control for Stochastic Textured Surfaces
</h2><span id='topic+spc4sts-package'></span><span id='topic+spc4sts'></span>

<h3>Description</h3>

<p>Provides statistical process control tools for stochastic textured surfaces. Some tools in the package can also be used in non-SPC contexts that deal with stochastic textured surface images (see Section Details below). The current version supports the following tools:
</p>
<p>(1) generic modeling of stochastic textured surfaces (Bui and Apley 2018a, 2018b)
</p>
<p>(2) local defect monitoring and diagnostics in stochastic textured surfaces (Bui and Apley 2018a)
</p>
<p>(3) global change monitoring in the nature of stochastic textured surfaces (Bui and Apley 2018b)
</p>
<p>(4) computation of dissimilarity matrix of stochastic textured surface images (Bui and Apley 2019b).
</p>
<p>See Bui and Apley (2021) for a vignette of this package.
</p>
<p>Please cite this package as follows:
Bui, A.T. and Apley, D.W. (2021) &quot;spc4sts: Statistical Process Control for Stochastic Textured Surfaces in R&quot;, Journal of Quality Technology, 53, 219–242.
</p>


<h3>Details</h3>

<p>Stochastic textured surface (STS) is the term used in Bui and Apley (2018a) to refer to a class of measurement data of material surfaces that have no distinct features other than stochastic characteristics that vary randomly. A few examples of STS data include microscopy images of material microstructure samples and images of lumber surfaces, engineered stone countertops, ceramic capacitor surfaces, and textile materials that show weave patterns (Bui and Apley 2017a, 2017b, 2019a).
</p>
<p>For STS data, even of the same nature, each image is completely different from others on a pixel-by-pixel basis. In addition, it is not straightforward to align, transform, or warp them into a common &quot;gold standard&quot; image, as a basis for comparison. The existence of a gold standard is a fundamental requirement for most of the statistical process control (SPC) literature for profile and multivariate data that are not STSs. An example of a gold standard in non-STS data is an image of a circuit assembly with perfectly positioned chips, to which images of actual assemblies with chips positioned inaccurately are compared for SPC quality control purposes. Existing SPC methods that may be applicable to STS data rely on some form of feature extraction from the STS images (e.g., a specific frequency component from a spectral analysis of the image), but they are problem specific because prior knowledge of abnormal behavior is needed to define suitable features.
</p>
<p>The <span class="pkg">spc4sts</span> (Statistical Process Control for Stochastic Textured Surfaces) package is the first implementation of the methods in Bui and Apley (2018a), Bui and Apley (2018b), and Bui and Apley (2019b), and serves as the first off-the-shelf toolkit for performing SPC for general STS data without prior knowledge of abnormal behavior. The package is applicable to a wide range of materials as mentioned above, including random heterogeneous materials.
</p>
<p>Some tools in the package can also be used in non-SPC contexts that deal with STS images. First, the STS modeling tool can be used in STS image characterization and reconstruction (e.g., powder materials micrograph characterization and materials microstructure image reconstruction). Second, the surface dissimilarity calculation tool can be used for STS image classification, clustering, and outlier detection. Some examples are medical microscopy image classification, cancer tissue image clustering, and outlying mammalian cell image detection.
</p>
<p>Brief descriptions of the main functions of the package are provided below:
</p>
<p><code>surfacemodel()</code> builds a supervised learning model (a regression tree in this version) to characterize the statistical behavior of the given stochastic textured surface data sample.
</p>
<p><code>monitoringStat()</code> computes the monitoring statistic(s) (for local defects and/or global changes) for the given image, based on the model built from <code>surfacemodel()</code>.
</p>
<p><code>climit()</code> establishes the control limits (for local defects and/or global changes) at the given false alarm rates based on the monitoring statistics (for local defects and/or global changes) computed for a set of in-control images (i.e., without local defects or global changes) using <code>monitoringStat()</code>. It also constructs the diagnostic thresholds (for diagnosing local defects) to be used for <code>diagnoseLD()</code>.
</p>
<p><code>diagnoseLD()</code> produces a binary diagnostic image that highlights local defects (if any) in the given stochastic textured surface image.
</p>
<p><code>disMat()</code>: computes KL and/or AKL dissimilarity matrices for the given stochastic textured surface images.
</p>
<p>See Bui and Apley (2020) for an introduction of the package.
</p>


<h3>Author(s)</h3>

<p>Anh Tuan Bui and Daniel W. Apley
</p>
<p>Maintainer: Anh Tuan Bui &lt;atbui@u.northwestern.edu&gt;
</p>


<h3>References</h3>

<p>Bui, A.T., and Apley, D.W. (2017a), textile: Textile Images, R package version 0.1.2. https://cran.r-project.org/package=textile.
</p>
<p>Bui, A.T., and Apley, D.W. (2017b), Textile Images 2, Mendeley Data, v1. http://dx.doi.org/10.17632/wy3pndgpcx.1.
</p>
<p>Bui, A.T. and Apley., D.W. (2018a) &quot;A Monitoring and Diagnostic Approach for Stochastic Textured Surfaces&quot;, Technometrics, 60, 1-13.
</p>
<p>Bui, A.T. and Apley, D.W. (2018b) &quot;Monitoring for changes in the nature of stochastic textured surfaces&quot;, Journal of Quality Technology, 50, 363-378.
</p>
<p>Bui, A.T. and Apley D.W. (2019a) &quot;Textile Image 3&quot;, figshare, http://dx.doi.org/10.6084/m9.figshare.7619351.v1.
</p>
<p>Bui, A.T. and Apley, D.W. (2019b) &quot;An exploratory analysis approach for understanding variation in stochastic textured surfaces&quot;, Computational Statistics &amp; Data Analysis, 137, 33-50.
</p>
<p>Bui, A.T. and Apley, D.W. (2021) &quot;spc4sts: Statistical Process Control for Stochastic Textured Surfaces in R&quot;, Journal of Quality Technology, 53, 219–242.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See the examples in the help pages for the main functions mentioned above.
#
</code></pre>

<hr>
<h2 id='ad'>
One-Sample Anderson-Darling Statistic
</h2><span id='topic+ad'></span>

<h3>Description</h3>

<p>Computes the one-sample Anderson-Darling (AD) statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ad(r, P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ad_+3A_r">r</code></td>
<td>

<p>the given vector/matrix of observations
</p>
</td></tr>
<tr><td><code id="ad_+3A_p">P</code></td>
<td>

<p>the vector/matrix containing the values of a (reference) cumulative distribution function evaluated at the values in <code>r</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The AD statistic.
</p>


<h3>Author(s)</h3>

<p>Anh Bui
</p>


<h3>References</h3>

<p>Bui, A.T. and Apley., D.W. (2018a) &quot;A Monitoring and Diagnostic Approach for Stochastic Textured Surfaces&quot;, Technometrics, 60, 1-13.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+exptailecdf">exptailecdf</a>, <a href="#topic+sms">sms</a>, <a href="#topic+bp">bp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>img &lt;- matrix(rnorm(100), 10, 10)
ad(img, pnorm(img))
</code></pre>

<hr>
<h2 id='bp'>
Box-Pierce-Type Statistic
</h2><span id='topic+bp'></span><span id='topic+bp2'></span>

<h3>Description</h3>

<p>Compute a Box-Pierce-type (BP) statistic for pixels in a given image. <code>bp2()</code> cannot be used for pixels with the boundary problem, but is more efficient than <code>bp()</code> for other pixels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bp(img, i1, i2, w, K)
bp2(img, i1, i2, w , K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bp_+3A_img">img</code></td>
<td>

<p>the given image
</p>
</td></tr>
<tr><td><code id="bp_+3A_i1">i1</code></td>
<td>

<p>the row index of the pixel to compute the BP statistic for.
</p>
</td></tr>
<tr><td><code id="bp_+3A_i2">i2</code></td>
<td>

<p>the column index of the pixel to compute the BP statistic for.
</p>
</td></tr>
<tr><td><code id="bp_+3A_w">w</code></td>
<td>

<p>the dimension of the spatial (square) moving window of the BP statistic. Must be an odd number &gt;= 3.
</p>
</td></tr>
<tr><td><code id="bp_+3A_k">K</code></td>
<td>

<p>the weighted (kernel) matrix.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The BP statistic.
</p>


<h3>Warning </h3>

<p>For pixels with the boundary problem, <code>bp()</code> must be used.</p>


<h3>Note</h3>

<p><code>bp()</code> is only used in <code>sms()</code> for pixels with the boundary problem. It is less efficient than <code>bp2()</code> for other pixels.
</p>


<h3>Author(s)</h3>

<p>Anh Bui
</p>


<h3>References</h3>

<p>Bui, A.T. and Apley., D.W. (2018a) &quot;A Monitoring and Diagnostic Approach for Stochastic Textured Surfaces&quot;, Technometrics, 60, 1-13.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kerMat">kerMat</a>, <a href="#topic+spaCov">spaCov</a>, <a href="#topic+sms">sms</a>, <a href="#topic+ad">ad</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>img &lt;- matrix(rnorm(100),10,10)
w &lt;- 3
K &lt;- kerMat((w + 1)/2)
## for pixels with the boundary problem, e.g., Pixel (5,1),
# running bp2(img,5,1,w,K) will produce an error; instead, use bp() in this case:
bp(img,5,1,w,K)

## for pixels without the boundary problem, e.g., Pixel (5,5),
# both can be used, but bp2() is more efficient than bp()
bp2(img,5,5,w,K)
bp(img,5,5,w,K)
</code></pre>

<hr>
<h2 id='climit'>
Control Limit and Diagnostic Threshold Construction
</h2><span id='topic+climit'></span><span id='topic+climit2'></span><span id='topic+print.climit'></span><span id='topic+plot.climit'></span>

<h3>Description</h3>

<p>Establish control limits (for local defects and/or global changes) and diagnostic thresholds (for local defects) from the given Phase I images. <code>climit</code> is used for the first time. <code>climit2</code> can update the control limits and diagnostic thresholds given the output of <code>climit</code>. See Warning. To plot histograms of the Phase I monitoring statistics, use <code>plot.climit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>climit(imgs, fa.rate, model, type, stat = c("ad", "bp"), w = 5,
       nD = 10, no_cores = 1, verbose = FALSE)
climit2(cl, fa.rate, nD)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="climit_+3A_imgs">imgs</code></td>
<td>

<p>a 3-dimensional array containing all Phase I in-control images.
</p>
</td></tr>
<tr><td><code id="climit_+3A_fa.rate">fa.rate</code></td>
<td>

<p>the false alarm rate, which asserts the rate of in-control images that are falsely alarmed as out-of-control. This can be a vector, in which case several levels of the control limit are returned.
</p>
</td></tr>
<tr><td><code id="climit_+3A_model">model</code></td>
<td>

<p>the object returned by <code>surfacemodel</code>.
</p>
</td></tr>
<tr><td><code id="climit_+3A_type">type</code></td>
<td>

<p>for local defects, <code>type = 1</code>; for global changes, <code>type = 2</code>; for both, <code>type = 1:2</code>.
</p>
</td></tr>
<tr><td><code id="climit_+3A_stat">stat</code></td>
<td>

<p>for local defects only. The statistic used in the spatial moving statistics. Must be either <code>"ad"</code> (default) or <code>"bp"</code>.
</p>
</td></tr>
<tr><td><code id="climit_+3A_w">w</code></td>
<td>

<p>for local defects only. The dimension of the spatial (square) moving window. Must be an odd number &gt;= 3.
</p>
</td></tr>
<tr><td><code id="climit_+3A_nd">nD</code></td>
<td>

<p>for local defects only. The parameter to construct the diagnostic threshold. It is the average number of highlighted pixels in the diagnostic image for an in-control image.
</p>
</td></tr>
<tr><td><code id="climit_+3A_no_cores">no_cores</code></td>
<td>

<p>if &gt; 1, parallely compute Phase I monitoring statistics using <code>no_cores</code> processors.
</p>
</td></tr>
<tr><td><code id="climit_+3A_verbose">verbose</code></td>
<td>

<p>if <code>TRUE</code>, show the computing progress.
</p>
</td></tr>
<tr><td><code id="climit_+3A_cl">cl</code></td>
<td>

<p>the object returned by <code>climit</code> or <code>climit2</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>climit</code>. See <code><a href="#topic+climit.object">climit.object</a></code>.
</p>


<h3>Author(s)</h3>

<p>Anh Bui
</p>


<h3>References</h3>

<p>Bui, A.T. and Apley., D.W. (2018a) &quot;A Monitoring and Diagnostic Approach for Stochastic Textured Surfaces&quot;, Technometrics, 60, 1-13.
</p>
<p>Bui, A.T. and Apley, D.W. (2018b) &quot;Monitoring for changes in the nature of stochastic textured surfaces&quot;, Journal of Quality Technology, 50, 363-378.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+monitoringStat">monitoringStat</a>, <a href="#topic+diagnoseLD">diagnoseLD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## build the in-control model
img &lt;- sarGen(m = 50, n = 50, border = 50) # training image
model &lt;- surfacemodel(img, nb = 1, keep.residuals = TRUE)

## after that, generate Phase I images
imgs &lt;- array(0, c(50,50,3))
for (j in 1:dim(imgs)[3])
  imgs[,,j] &lt;- sarGen(phi1 = .6, phi2 = .35, m = 50, n = 50, border = 50)

## establish control limits and diagnostic thresholds
# construct control limits (for both local defects and global changes)
# and diagnostic thresholds (for local defects) for the first time
cl &lt;- climit(imgs, fa.rate = .05, model, type = 1:2, stat = "ad", w = 5, nD = 50)
cl
# update new control limit and diagnostic threshold
cl2 &lt;- climit2(cl, fa.rate = .01, nD = 5)
# plots histograms of Phase I monitoring statistics
plot(cl2)

## after that, monitor a Phase II image as follows:
# create a new image with a local defect
img2 &lt;- sarGen(phi1 = .6, phi2 = .35, m = 50, n = 50, border = 50) # simulate a new image
img3 &lt;- imposeDefect(img2)$img # add a local defect to this image
ms3 &lt;- monitoringStat(img = img3, model = model, cl = cl2) # computing monitoring statistics
# now create a new image with parameters reduced by 5% (representing a global change)
img4 &lt;- sarGen(phi1 = .6*.95, phi2 = .35*.95, m = 50, n = 50, border = 50)
ms4 &lt;- monitoringStat(img = img4, model = model, cl = cl2) # computing monitoring statistics

## diagnose for local defect regions in img3
bimg &lt;- diagnoseLD(ms3, dth = 9, plot.it = FALSE) # use climit() to find dth

#par(mfcol = c(1, 2))
#par(mar = c(2, 0.5, 1, 0.5))
image(xaxt = 'n', yaxt = 'n', as.matrix(t(apply(img3 , 2, rev))),
      col = gray((0:32)/32), xlab = '', ylab = '', asp = 1, bty = 'n')
image(xaxt = 'n', yaxt = 'n', as.matrix(t(apply(bimg , 2, rev))),
      col = gray(c(1, .5)), xlab = '', ylab = '', asp = 1, bty = 'n')

#
# NOTE: The above example is just for quick illustration. To obtain a good
# control limit, the training image should be representative (e.g., set
# m = 250, n = 250, and border = 200). The number of Phase I images also
# needs to be large (e.g., 100 images or more).
#
# For real images in a textile application, use the R data package "textile".
#

</code></pre>

<hr>
<h2 id='climit.object'>
Control Limit and Diagnostic Threshold Construction Object
</h2><span id='topic+climit.object'></span>

<h3>Description</h3>

<p>Tthe object returned by <code>climit</code> or <code>climit2</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>type</code></td>
<td>
<p>the <code>type</code> argument of <code>climit</code>.</p>
</td></tr>
<tr><td><code>fa.rate</code></td>
<td>
<p>the <code>fa.rate</code> argument of <code>climit</code>.</p>
</td></tr>
<tr><td><code>localStat</code></td>
<td>
<p>contains values for local defect monitoring:
<code>nDmaxSms</code> is a vector that stores the <code>(nD*N + 1)</code> largest SMS values computed for all <code>N</code> Phase I images.
<code>PIstats</code> is a vector that stores the monitoring statistics computed for all the Phase I images.
<code>diagnostic.threshold </code> is a scalar/vector that stores the established diagnostic threshold(s).
<code>stat</code> and <code>w</code> are the <code>stat</code> and <code>w</code> arguments of the <code>climit</code> function.
<code>control.limit</code> is a scalar/vector that stores the established control limit(s).
</p>
</td></tr>
<tr><td><code>globalStat</code></td>
<td>
<p>contains values for global change monitoring:
<code>PIstats</code> is a vector that stores the monitoring statistics computed for all the Phase I images.
<code>xval</code> is the <code>xval</code> argument of the <code>climit</code> function.
<code>control.limit.trans_chi2</code> and <code>control.limit.ecdf</code> are a scalar/vector that stores the established control limit(s) using the parametric approximation of the empirical distributions and the empirical distributions directly, respectively. The former is recommended when the number of Phase I images is not enough for using directly the empirical distribution.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Anh Bui
</p>


<h3>References</h3>

<p>Bui, A.T. and Apley., D.W. (2018a) &quot;A Monitoring and Diagnostic Approach for Stochastic Textured Surfaces&quot;, Technometrics, 60, 1-13.
</p>
<p>Bui, A.T. and Apley, D.W. (2018b) &quot;Monitoring for changes in the nature of stochastic textured surfaces&quot;, Journal of Quality Technology, 50, 363-378.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+climit">climit</a></code>
</p>

<hr>
<h2 id='dataPrep'>
Neighborhood Data Preparation
</h2><span id='topic+dataPrep'></span>

<h3>Description</h3>

<p>Prepares a neighborhood data from a given image, using the left-to-right then top-to-bottom raster scan order (see Bui and Apley 2018a).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataPrep(img, nb, vars = NULL, subsample = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataPrep_+3A_img">img</code></td>
<td>

<p>the given image in the matrix format.
</p>
</td></tr>
<tr><td><code id="dataPrep_+3A_nb">nb</code></td>
<td>

<p>the size of the neighborhood. It must be a 1-length or 3-length vector of positive integer(s). If the former, it is the same with a 3-length vector with the same elements.
</p>
</td></tr>
<tr><td><code id="dataPrep_+3A_vars">vars</code></td>
<td>

<p>names of variables to be selected in the neighborhood data.
</p>
</td></tr>
<tr><td><code id="dataPrep_+3A_subsample">subsample</code></td>
<td>

<p>the portion of data rows be returned. It takes values in (0, 1]. If <code>subsample = 1</code>, all data rows will be returned, and if <code>subsample = .5</code>, only roughly a half will be returned.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with column names &quot;V1&quot;, &quot;V2&quot;, &quot;V3&quot;, ...
The first column &quot;V1&quot; contains the response pixel, whereas the other columns contain pixels in the neighborhood (with size <code>nb</code>) of the response pixel.
</p>


<h3>Note</h3>

<p>Only rows without missing values (corresponding to pixels with full neighborhood) are returned.
</p>


<h3>Author(s)</h3>

<p>Anh Bui
</p>


<h3>References</h3>

<p>Bui, A.T. and Apley., D.W. (2018a) &quot;A Monitoring and Diagnostic Approach for Stochastic Textured Surfaces&quot;, Technometrics, 60, 1-13.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+surfacemodel">surfacemodel</a>, <a href="#topic+monitoringStat">monitoringStat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## construct a neighborhood data for an unrealistically small mock image (7x9 pixels).
mock.img &lt;- matrix(sample(0:255, 63, replace = TRUE), 7, 9)
mock.img
dataPrep(img = mock.img, nb = 2) # the same with nb = c(2, 2, 2)

## select only columns "V2", "V5", and "V13" in the output
dataPrep(img = mock.img, nb = 2, vars = c("V2", "V5", "V13"))

## return only a half number of rows
dataPrep(img = mock.img, nb = 2, subsample = .5)
</code></pre>

<hr>
<h2 id='diagnoseLD'>
Diagnose Local Defects on Stochastic Textured Surfaces
</h2><span id='topic+diagnoseLD'></span>

<h3>Description</h3>

<p>Produces a binary diagnostic image of a given stochastic textured surface image based on its spatial moving statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnoseLD(ms, dth, plot.it = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnoseLD_+3A_ms">ms</code></td>
<td>

<p>the object return by <code>monitoringStat()</code>
</p>
</td></tr>
<tr><td><code id="diagnoseLD_+3A_dth">dth</code></td>
<td>

<p>the diagnostic threshold
</p>
</td></tr>
<tr><td><code id="diagnoseLD_+3A_plot.it">plot.it</code></td>
<td>

<p>plots the binary diagnositc image if set to <code>TRUE</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The binary diagnostic image in the matrix format.
</p>


<h3>Author(s)</h3>

<p>Anh Bui
</p>


<h3>References</h3>

<p>Bui, A.T. and Apley., D.W. (2018a) &quot;A Monitoring and Diagnostic Approach for Stochastic Textured Surfaces&quot;, Technometrics, 60, 1-13.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+monitoringStat">monitoringStat</a>, <a href="#topic+climit">climit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ## see the examples in the help file of climit()
?climit
</code></pre>

<hr>
<h2 id='disMat'>
Pairwise Dissimilarity Matrix of Stochastic Textured Surfaces
</h2><span id='topic+disMat'></span>

<h3>Description</h3>

<p>Compute KL and ALK dissimiarlity matrices for the given stochastic textured surface images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disMat(imgs, nb, cp=1e-3, subsample = c(1, .5),
                   standardize = TRUE, keep.fits = FALSE, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disMat_+3A_imgs">imgs</code></td>
<td>

<p>a 3-dimensional array containing all images.
</p>
</td></tr>
<tr><td><code id="disMat_+3A_nb">nb</code></td>
<td>

<p>the size of the neighborhood. It must be a 1-length or 3-length vector of positive integer(s). If the former, it is the same with a 3-length vector with the same elements.
</p>
</td></tr>
<tr><td><code id="disMat_+3A_cp">cp</code></td>
<td>

<p>the minimal value for the <code>rpart</code> complexity models. The smaller <code>cp</code> is, the more complex the <code>rpart</code> models are fit.
</p>
</td></tr>
<tr><td><code id="disMat_+3A_subsample">subsample</code></td>
<td>

<p>the portion of pixels in the given image <code>img</code> to be used when fitting models (the first component) and computing dissimilarities (the second component). It takes values in (0, 1] (e.g., <code>subsample = c(1, .5)</code> means that the whole image is used when fitting models, and roughly a half of that is used when compute dissimilarities).
</p>
</td></tr>
<tr><td><code id="disMat_+3A_standardize">standardize</code></td>
<td>

<p>if <code>TRUE</code>, standardize the given image <code>img &lt;- (img - mean(img))/sd(img)</code>. This reduces the effect of different lighting conditions when images are taken.
</p>
</td></tr>
<tr><td><code id="disMat_+3A_keep.fits">keep.fits</code></td>
<td>

<p>if <code>TRUE</code>, save all the fitted models in the &quot;fits.Rdata&quot; under the wokring directory.
</p>
</td></tr>
<tr><td><code id="disMat_+3A_verbose">verbose</code></td>
<td>

<p>if set to <code>TRUE</code>, output some computational time information.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the KL and AKL dissimilarity matrices.
</p>


<h3>Author(s)</h3>

<p>Anh Bui
</p>


<h3>References</h3>

<p>Bui, A.T. and Apley, D.W. (2019b) &quot;An exploratory analysis approach for understanding variation in stochastic textured surfaces&quot;, Computational Statistics &amp; Data Analysis, 137, 33-50.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate images: the first two are similar, the third is different with the other two
phi1 &lt;- c(.6, .6, .5)
phi2 &lt;- c(.35, .35, .3)
imgs &lt;- array(0, c(100,100,3))
for (j in 1:dim(imgs)[3])
  imgs[,,j] &lt;- sarGen(phi1 = phi1[j], phi2 = phi2[j], m = 100, n = 100, border = 50)
## compute KL and AKL dissimilarity matrices
disMat(imgs = imgs, nb = 1)
</code></pre>

<hr>
<h2 id='exptailecdf'>
Empirical Cumulative Distribution Function with Exponential Tail Approximation
</h2><span id='topic+exptailecdf'></span><span id='topic+print.exptailecdf'></span>

<h3>Description</h3>

<p>Computes the empirical cumulative distribution funciton (ecdf) of a given vector of observations, and approximates the tails of the ecdf with exponential curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exptailecdf(x, N = max(2, 0.002 * length(x)), m = min(N, 5))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exptailecdf_+3A_x">x</code></td>
<td>

<p>the given vector of observations
</p>
</td></tr>
<tr><td><code id="exptailecdf_+3A_n">N</code></td>
<td>

<p>the number of observations at each tail of the ecdf used for estimating the exponential curves.
</p>
</td></tr>
<tr><td><code id="exptailecdf_+3A_m">m</code></td>
<td>

<p>the <code>m</code>th observation from each extreme of the ecdf is the starting point to use the estimated exponential curves.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An ecdf has a probability of 0 or 1 for any new observation that lies beyond the range of the data of the cedf. This is a problem when using the ecdf as the reference cdf for the one-sample Anderson-Darling (AD) statistic because the computational formula of the AD statistic is infinite with such probabilities. The ecdf with exponential tail approximation replaces the tails of the ecdf with exponential curves, which extend to infinity, to solve this problem. The exponential curves are estimated using the observations at the tails of the ecdf. See Bui and Apley (2018a) for more details.
</p>


<h3>Value</h3>

<p>An object of class <code>exptailecdf</code>. See <code><a href="#topic+exptailecdf.object">exptailecdf.object</a></code>
</p>


<h3>Author(s)</h3>

<p>Anh Bui
</p>


<h3>References</h3>

<p>Bui, A.T. and Apley., D.W. (2018a) &quot;A Monitoring and Diagnostic Approach for Stochastic Textured Surfaces&quot;, Technometrics, 60, 1-13.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+exptailecdf.object">exptailecdf.object</a>, <a href="#topic+pexptailecdf">pexptailecdf</a>, <a href="stats.html#topic+ecdf">ecdf</a>, <a href="#topic+ad">ad</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rnorm(1000)
Fr &lt;- exptailecdf(r)
</code></pre>

<hr>
<h2 id='exptailecdf.object'>
Empirical Cumulative Distribution Function with Exponential Tail Approximation Object
</h2><span id='topic+exptailecdf.object'></span>

<h3>Description</h3>

<p>The object returned by <code>exptailecdf</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>ecdf</code></td>
<td>
<p>the ecdf returned by the <code>stats::ecdf()</code></p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the parameters estimated for the exponential curves. <code>lambda[1]</code> corresponds to the left tail.</p>
</td></tr>
<tr><td><code>joint</code></td>
<td>
<p>where the ecdf started to be replaced by the exponential curves. <code>joint[1]</code> corresponds to the left tail.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Anh Bui
</p>


<h3>See Also</h3>

<p><code><a href="#topic+exptailecdf">exptailecdf</a></code>
</p>

<hr>
<h2 id='imposeDefect'>
Superimpose A Local Defect
</h2><span id='topic+imposeDefect'></span>

<h3>Description</h3>

<p>Superimposes a local defect (a 2D stochastic AR(1) image from <code>sarGen</code>) on a given image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imposeDefect(img, loc = NULL, a = 4, b = 10, eps = 0.05, phi1 = 0, phi2 = 0, sigma = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imposeDefect_+3A_img">img</code></td>
<td>

<p>the image to be superimposed a defect.
</p>
</td></tr>
<tr><td><code id="imposeDefect_+3A_loc">loc</code></td>
<td>

<p>the location of the defect in the generated image.
</p>
</td></tr>
<tr><td><code id="imposeDefect_+3A_a">a</code></td>
<td>

<p><code>2*a + 1</code> is the vertical axis length of the ellipsoidal defect.
</p>
</td></tr>
<tr><td><code id="imposeDefect_+3A_b">b</code></td>
<td>

<p><code>2*b + 1</code> is the vertical axis length of the ellipsoidal defect.
</p>
</td></tr>
<tr><td><code id="imposeDefect_+3A_eps">eps</code></td>
<td>

<p>controls the curvature of the ellipsoidal defect.
</p>
</td></tr>
<tr><td><code id="imposeDefect_+3A_phi1">phi1</code></td>
<td>

<p>the parameter <code>phi1</code> of the defect.
</p>
</td></tr>
<tr><td><code id="imposeDefect_+3A_phi2">phi2</code></td>
<td>

<p>the parameter <code>phi2</code> of the defect.
</p>
</td></tr>
<tr><td><code id="imposeDefect_+3A_sigma">sigma</code></td>
<td>

<p>the parameter <code>sigma</code> of the defect.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The defect is generated using <code><a href="#topic+sarGen">sarGen</a></code>.
</p>


<h3>Value</h3>

<p>A list of the following:
</p>
<table>
<tr><td><code>img</code></td>
<td>
<p>the generated image in the matrix format.</p>
</td></tr>
<tr><td><code>defect.info</code></td>
<td>
<p>the information of the defects.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Anh Bui
</p>


<h3>References</h3>

<p>Bui, A.T. and Apley., D.W. (2018a) &quot;A Monitoring and Diagnostic Approach for Stochastic Textured Surfaces&quot;, Technometrics, 60, 1-13.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate an image without defects
img &lt;- sarGen(m = 100, n = 100, border = 50)
image(img,col=gray(c(0:32)/32))

## superimpose a defect
img2 &lt;- imposeDefect(img)
image(img2$img,col=gray(c(0:32)/32))
</code></pre>

<hr>
<h2 id='kerMat'>
Epanechnikov quadratic kernel matrix
</h2><span id='topic+kerMat'></span>

<h3>Description</h3>

<p>Computes the Epanechnikov quadratic kernel in 2-D, and returns the positive kernel values.</p>


<h3>Usage</h3>

<pre><code class='language-R'>kerMat(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kerMat_+3A_p">p</code></td>
<td>

<p>the bandwidth parameter
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing all the positive kernel values
</p>


<h3>Author(s)</h3>

<p>Anh Bui
</p>


<h3>References</h3>

<p>Bui, A.T. and Apley., D.W. (2018a) &quot;A Monitoring and Diagnostic Approach for Stochastic Textured Surfaces&quot;, Technometrics, 60, 1-13.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bp">bp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kerMat(5)
</code></pre>

<hr>
<h2 id='mbChange'>
Matchbox Change
</h2><span id='topic+mbChange'></span>

<h3>Description</h3>

<p>Modifies a given image to have a matchbox change.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mbChange(img, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mbChange_+3A_img">img</code></td>
<td>

<p>the image to be matchboxed
</p>
</td></tr>
<tr><td><code id="mbChange_+3A_alpha">alpha</code></td>
<td>

<p>the amount of matchboxing
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each column <code>i</code> of <code>img</code> is modified as follows: <code>img[2:nrow(img),i] &lt;- (1 - alpha*(i-1)/ncol(img))*img[2:nrow(img),i] + alpha*(i-1)/ncol(img)*img[1:(nrow(img)-1),i]</code>
</p>


<h3>Value</h3>

<p>The matchboxed image in the matrix format.
</p>


<h3>Author(s)</h3>

<p>Anh Bui
</p>


<h3>References</h3>

<p>Bui, A.T. and Apley, D.W. (2018b) &quot;Monitoring for changes in the nature of stochastic textured surfaces&quot;, Journal of Quality Technology, 50, 363-378.
</p>

<hr>
<h2 id='monitoringStat'>
Monitoring Statistic for Stochastic Textured Surfaces
</h2><span id='topic+monitoringStat'></span><span id='topic+print.monitoringStat'></span>

<h3>Description</h3>

<p>Computes monitoring statistic(s) for local defects (see Bui and Apley 2018a) and/or global changes (see Bui and Apley 2018b) for a given stochastic textured surface image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monitoringStat(img, model, type, stat = c("ad", "bp"), w, cl = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="monitoringStat_+3A_img">img</code></td>
<td>

<p>the given image in the matrix format.
</p>
</td></tr>
<tr><td><code id="monitoringStat_+3A_model">model</code></td>
<td>

<p>the object returned by <code>surfacemodel</code>
</p>
</td></tr>
<tr><td><code id="monitoringStat_+3A_type">type</code></td>
<td>

<p>for local defects, <code>type = 1</code>; for global changes, <code>type = 2</code>; for both, <code>type = 1:2</code>
</p>
</td></tr>
<tr><td><code id="monitoringStat_+3A_stat">stat</code></td>
<td>

<p>for local defects only. The statistic used in the spatial moving statistics. Must be either <code>"ad"</code> (default) or <code>"bp"</code>.
</p>
</td></tr>
<tr><td><code id="monitoringStat_+3A_w">w</code></td>
<td>

<p>for local defects only. The dimension of the spatial (square) moving window. Must be an odd number &gt;= 3.
</p>
</td></tr>
<tr><td><code id="monitoringStat_+3A_cl">cl</code></td>
<td>

<p>the object returned by <code>climit</code> or <code>climit2</code>.
</p>
</td></tr>
<tr><td><code id="monitoringStat_+3A_verbose">verbose</code></td>
<td>

<p>if set to <code>TRUE</code>, output monitoring outcome.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>monitoringStat</code> object containing the following components:
</p>
<table>
<tr><td><code>sms</code></td>
<td>
<p>a matrix of the SMS values computed for pixels in <code>img</code></p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>the <code>stat</code> argument</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>the <code>w</code> argument</p>
</td></tr>
<tr><td><code>localStat</code></td>
<td>
<p>the monitoring statistic for local defects of <code>img</code></p>
</td></tr>
<tr><td><code>globalStat</code></td>
<td>
<p>the monitoring statistic for global changes of <code>img</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Anh Bui
</p>


<h3>References</h3>

<p>Bui, A.T. and Apley., D.W. (2018a) &quot;A Monitoring and Diagnostic Approach for Stochastic Textured Surfaces&quot;, Technometrics, 60, 1-13.
</p>
<p>Bui, A.T. and Apley, D.W. (2018b) &quot;Monitoring for changes in the nature of stochastic textured surfaces&quot;, Journal of Quality Technology, 50, 363-378.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+surfacemodel">surfacemodel</a>, <a href="#topic+sms">sms</a>, <a href="#topic+dataPrep">dataPrep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># run the example in the help file of climit()
?climit


</code></pre>

<hr>
<h2 id='pexptailecdf'>
Predictions from an Exptailecdf Object
</h2><span id='topic+pexptailecdf'></span>

<h3>Description</h3>

<p>Returns the values of the <code>exptailecdf</code> object at given observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pexptailecdf(Fx, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pexptailecdf_+3A_fx">Fx</code></td>
<td>

<p>the object of class <code>exptailecdf</code>, containing an ecdf with exponential tail approximation.
</p>
</td></tr>
<tr><td><code id="pexptailecdf_+3A_y">y</code></td>
<td>

<p>the given observations in the scalar/vector/matrix format.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type with <code>y</code> that stores the evaluations of the <code>exptailecdf</code> object at the given <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>Anh Bui
</p>


<h3>References</h3>

<p>Bui, A.T. and Apley., D.W. (2018a) &quot;A Monitoring and Diagnostic Approach for Stochastic Textured Surfaces&quot;, Technometrics, 60, 1-13.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+exptailecdf.object">exptailecdf.object</a>, <a href="#topic+exptailecdf">exptailecdf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rnorm(1000)
Fr &lt;- exptailecdf(r)

pexptailecdf(Fr, max(r) + .1)
pexptailecdf(Fr, c(min(r) - .1, max(r) + .1))
pexptailecdf(Fr, matrix(c(.8, .9, 1, 1.1), 2, 2))
</code></pre>

<hr>
<h2 id='plotcc'>
Control Chart Plotting
</h2><span id='topic+plotcc'></span>

<h3>Description</h3>

<p>Plotting a control chart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotcc(statsII, CL, statsI = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotcc_+3A_statsii">statsII</code></td>
<td>

<p>the Phase II monitoring statistics.
</p>
</td></tr>
<tr><td><code id="plotcc_+3A_cl">CL</code></td>
<td>

<p>the control limit of the control chart.
</p>
</td></tr>
<tr><td><code id="plotcc_+3A_statsi">statsI</code></td>
<td>

<p>(some of) the Phase I monitoring statistics.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for plotting control charts.</p>


<h3>Author(s)</h3>

<p>Anh Bui
</p>

<hr>
<h2 id='sarGen'>
Stochastic Autoregressive Image Generator
</h2><span id='topic+sarGen'></span>

<h3>Description</h3>

<p>Generates a 2D stochastic AR(1) image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sarGen(phi1 = .6, phi2 = .35, sigma = .01, m = 250, n = 250, border = 200)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sarGen_+3A_phi1">phi1</code></td>
<td>

<p>the parameter <code>phi1</code>  of the process.
</p>
</td></tr>
<tr><td><code id="sarGen_+3A_phi2">phi2</code></td>
<td>

<p>the parameter <code>phi2</code> of the process.
</p>
</td></tr>
<tr><td><code id="sarGen_+3A_sigma">sigma</code></td>
<td>

<p>the parameter <code>sigma</code> of the process.
</p>
</td></tr>
<tr><td><code id="sarGen_+3A_m">m</code></td>
<td>

<p>the number of rows of the generated image.
</p>
</td></tr>
<tr><td><code id="sarGen_+3A_n">n</code></td>
<td>

<p>the number of columns of the generated image.
</p>
</td></tr>
<tr><td><code id="sarGen_+3A_border">border</code></td>
<td>

<p>the number of top rows/left columns to be cut off from the generated image. This helps reduce the effect of the starting condition.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pixel <code>y(i,j)</code> of the 2D AR(1) process satisfies: <code>y(i,j) = phi1*y(i-1,j) + phi2*y(i,j-1) + e(i,j)</code>, where <code>e(i,j)</code> follows a zero-mean Gaussian distribution with standard deviation of <code>sigma</code>. The process is then rescaled to [0, 255] to produce a greyscale image.
</p>


<h3>Value</h3>

<p>The generated image in the matrix format.
</p>


<h3>Author(s)</h3>

<p>Anh Bui
</p>


<h3>References</h3>

<p>Bui, A.T. and Apley., D.W. (2018a) &quot;A Monitoring and Diagnostic Approach for Stochastic Textured Surfaces&quot;, Technometrics, 60, 1-13.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+imposeDefect">imposeDefect</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate an image without defects
img &lt;- sarGen(m = 100, n = 100, border = 50)
image(img,col=gray(c(0:32)/32))
</code></pre>

<hr>
<h2 id='showNb'>
Show Neighborhood
</h2><span id='topic+showNb'></span>

<h3>Description</h3>

<p>Shows the neighborhood corresponding to the left-to-right then top-to-bottom raster scan order with additional information: variable names of the data frame returned by <code>dataPrep</code>, predictors used in the model returned by <code>surfacemodel</code>, or their percentage importance in the model (currently extracted from the <code>rpart</code> object). This function is useful for choosing a good neighborhood size and understanding relationship between pixels (e.g., periodicity).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showNb(model, what = c("neighborhood", "predictors", "importance"), plot.it = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showNb_+3A_model">model</code></td>
<td>

<p>either the object returned by <code>surfacemodel</code> or a positive vector of length 1 or 3 specifying the neighboorhood. If it is a vector, <code>what &lt;- "neighborhood"</code>.
</p>
</td></tr>
<tr><td><code id="showNb_+3A_what">what</code></td>
<td>

<p>what to show in the neighorhood. <code>"neighborhood"</code> shows variable names of the data frame returned by <code>dataPrep</code>, <code>"predictors"</code> shows predictors used in the model returned by <code>surfacemodel</code>, and <code>"importance"</code> shows their percentage importance in the model.
</p>
</td></tr>
<tr><td><code id="showNb_+3A_plot.it">plot.it</code></td>
<td>

<p>if <code>TRUE</code>, plot the neighborhood.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix that contains the information for the plot (using the <code>grid.table</code> function).
</p>


<h3>Author(s)</h3>

<p>Anh Bui
</p>


<h3>References</h3>

<p>Bui, A.T. and Apley., D.W. (2018a) &quot;A Monitoring and Diagnostic Approach for Stochastic Textured Surfaces&quot;, Technometrics, 60, 1-13.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dataPrep">dataPrep</a>, <a href="#topic+surfacemodel">surfacemodel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## show the neighorhood with variables names of the data frame constructed by dataPrep()
img &lt;- matrix(1:25, 5, 5) # an image of size 5x5 pixels
img
dataPrep(img, 2)
showNb(c(2, 2, 2)) # showNb(2) has the same effect

## show the neighorhood with predictors and their importance used in the model returned
## by surfacemodel()
img &lt;- sarGen(m = 100, n = 100, border = 50) # training image
model &lt;- surfacemodel(img, nb = 3)
showNb(model, "predictors") # show predictors
showNb(model, "importance") # show predictor percentage importance
</code></pre>

<hr>
<h2 id='sms'>
Spatial Moving Statistic
</h2><span id='topic+sms'></span>

<h3>Description</h3>

<p>Computes the spatial moving statistics (SMS) for pixels in a given image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sms(img, stat = c("ad", "bp"), w, Fr, gamma = (w + 1)/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sms_+3A_img">img</code></td>
<td>

<p>the image to compute the SMS for.
</p>
</td></tr>
<tr><td><code id="sms_+3A_stat">stat</code></td>
<td>

<p>the statistic used in the SMS. Must be either <code>"ad"</code> (default) or <code>"bp"</code>.
</p>
</td></tr>
<tr><td><code id="sms_+3A_w">w</code></td>
<td>

<p>the dimension of the square moving window of the SMS. It must be an odd number &gt;= 3.
</p>
</td></tr>
<tr><td><code id="sms_+3A_fr">Fr</code></td>
<td>

<p>the reference ecdf with exponential tail approximation (see <code><a href="#topic+exptailecdf">exptailecdf</a></code>). Only used when <code>stat = "ad"</code>.
</p>
</td></tr>
<tr><td><code id="sms_+3A_gamma">gamma</code></td>
<td>

<p>the bandwidth parameter for <code><a href="#topic+kerMat">kerMat</a></code>. It must be a positive integer and is only used when <code>stat = "bp"</code>. The default value is recommended.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the SMS values computed for the pixels in <code>img</code>.
</p>


<h3>Author(s)</h3>

<p>Anh Bui
</p>


<h3>References</h3>

<p>Bui, A.T. and Apley., D.W. (2018a) &quot;A Monitoring and Diagnostic Approach for Stochastic Textured Surfaces&quot;, Technometrics, 60, 1-13.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ad">ad</a>, <a href="#topic+bp">bp</a>, <a href="#topic+monitoringStat">monitoringStat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>img &lt;- matrix(rnorm(100),10,10)
ms.ad &lt;- sms(img, "ad", 3, exptailecdf(rnorm(1000)))
ms.bp &lt;- sms(img, "bp", 3)
</code></pre>

<hr>
<h2 id='spaCov'>
Spatial Weighted Covariance
</h2><span id='topic+spaCov'></span>

<h3>Description</h3>

<p>Computes the spatial weighted covariance of a pair of pixels in a given image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spaCov(img, i1, i2, j1, j2, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spaCov_+3A_img">img</code></td>
<td>

<p>the given image
</p>
</td></tr>
<tr><td><code id="spaCov_+3A_i1">i1</code></td>
<td>

<p>the row index of the first pixel in the pair.
</p>
</td></tr>
<tr><td><code id="spaCov_+3A_i2">i2</code></td>
<td>

<p>the column index of the first pixel in the pair.
</p>
</td></tr>
<tr><td><code id="spaCov_+3A_j1">j1</code></td>
<td>

<p>the row index of the second pixel in the pair.
</p>
</td></tr>
<tr><td><code id="spaCov_+3A_j2">j2</code></td>
<td>

<p>the column index of the second pixel in the pair.
</p>
</td></tr>
<tr><td><code id="spaCov_+3A_k">K</code></td>
<td>

<p>the weighted matrix.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The spatial weighted covariance.
</p>


<h3>Author(s)</h3>

<p>Anh Bui
</p>


<h3>References</h3>

<p>Bui, A.T. and Apley., D.W. (2018a) &quot;A Monitoring and Diagnostic Approach for Stochastic Textured Surfaces&quot;, Technometrics, 60, 1-13.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kerMat">kerMat</a>, <a href="#topic+bp">bp</a></code>
</p>

<hr>
<h2 id='surfacemodel'>
Statistical reprentations of stochastic textured surfaces using supervised learning
</h2><span id='topic+surfacemodel'></span><span id='topic+print.surfacemodel'></span><span id='topic+plot.surfacemodel'></span>

<h3>Description</h3>

<p>Provides a statistical represenation for a given stochastic textured surface image via a supervised learning model (a regression tree in this version).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surfacemodel(img, nb, trim.vars = TRUE, cp = 1e-5,
             xval = 5, standardize = TRUE, subsample = 1,
             verbose = FALSE, keep.residuals = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surfacemodel_+3A_img">img</code></td>
<td>

<p>the given stochastic textured surface image in the matrix format.
</p>
</td></tr>
<tr><td><code id="surfacemodel_+3A_nb">nb</code></td>
<td>

<p>the size of the neighborhood. It must be a 1-length or 3-length vector of positive integer(s). If the former, it is the same with a 3-length vector with the same elements.
</p>
</td></tr>
<tr><td><code id="surfacemodel_+3A_trim.vars">trim.vars</code></td>
<td>

<p>if <code>TRUE</code>, refit the model using only the variables that were used in the first fit.
</p>
</td></tr>
<tr><td><code id="surfacemodel_+3A_cp">cp</code></td>
<td>

<p>the complexity parameter for rpart fits (see <code><a href="rpart.html#topic+rpart.control">rpart.control</a></code>).
</p>
</td></tr>
<tr><td><code id="surfacemodel_+3A_xval">xval</code></td>
<td>

<p>the number of folds in cross-validation (see <code><a href="rpart.html#topic+rpart.control">rpart.control</a></code>). If <code>xval &lt;= 1</code>, cross-validation will not be used.
</p>
</td></tr>
<tr><td><code id="surfacemodel_+3A_standardize">standardize</code></td>
<td>

<p>if <code>TRUE</code>, standardize the given image <code>img &lt;- (img - mean(img))/sd(img)</code>. This reduces the effect of different lighting conditions when images are taken.
</p>
</td></tr>
<tr><td><code id="surfacemodel_+3A_subsample">subsample</code></td>
<td>

<p>the portion of pixels in the given image <code>img</code> to be used. It takes values in (0,1].  <code>subsample = .5</code> means that roughly a half number of pixels is used.
</p>
</td></tr>
<tr><td><code id="surfacemodel_+3A_verbose">verbose</code></td>
<td>

<p>if <code>TRUE</code>, output some model fitting information.
</p>
</td></tr>
<tr><td><code id="surfacemodel_+3A_keep.residuals">keep.residuals</code></td>
<td>

<p>if <code>TRUE</code>, keep residuals of the fitted model in the output.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>surfacemodel</code> object containing the following components:
</p>
<table>
<tr><td><code>fit</code></td>
<td>
<p>the pruned <code>rpart</code> tree using cross-validation.</p>
</td></tr>
<tr><td><code>trim.vars</code></td>
<td>
<p>the <code>trim.vars</code> argument.</p>
</td></tr>
<tr><td><code>nb</code></td>
<td>
<p>the <code>nb</code> argument.</p>
</td></tr>
<tr><td><code>Fr</code></td>
<td>
<p>the empirical cdf with exponential tail approximation of the model residuals.</p>
</td></tr>
<tr><td><code>MSE</code></td>
<td>
<p>the mean squared residuals.</p>
</td></tr>
<tr><td><code>standardize</code></td>
<td>
<p>the <code>standardize</code> argument.</p>
</td></tr>
<tr><td><code>R2cv</code></td>
<td>
<p>the cross-validated R-squared of <code>fit</code>.</p>
</td></tr>
<tr><td><code>complexity</code></td>
<td>
<p>the complexity value of the returned <code>fit</code>.</p>
</td></tr>
<tr><td><code>vars</code></td>
<td>
<p>the variables used in the formula when fitting the model.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals of the fitted model.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The best value for the neighborhood size <code>nb</code> argument can be chosen by comparing the cross-validated R-squared values <code>R2cv</code> of models built with different values of <code>nb</code>. Users may use 'surfacemodel' with some initial large <code>nb</code>, and then use the <code>showNb()</code> function to visualize the importance of the predictors used in the fitted model to have some idea about the range of important predictors to reduce (or increase if necessary) <code>nb</code>.
</p>
<p>After finalizing the choice of <code>nb</code>, it is better to set <code>trim.vars = TRUE</code> to further remove some unused variables within that neighborhood.
</p>
<p>The raster scan order for constructing the neiborhood data in <code>dataPrep()</code> is left-to-right then top-to-bottom (see Bui and Apley 208a). Rotating the image by every 90 degrees could be used to quicly change to some other raster scan orders. Again, the cross-validated R-squared <code>R2cv</code> output can be used to select the best raster scan order. See the below examples.
</p>
<p><code>plot.surfacemodel()</code> is a generic function for <code>surfacemodel()</code> that produces two plots: a plot of the cross-validation R-squared against the complexity parameter and a histogram of the residuals (along with a normal density curve) of the fitted model.
</p>


<h3>Author(s)</h3>

<p>Anh Bui
</p>


<h3>References</h3>

<p>Bui, A.T. and Apley., D.W. (2018a) &quot;A Monitoring and Diagnostic Approach for Stochastic Textured Surfaces&quot;, Technometrics, 60, 1-13.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dataPrep">dataPrep</a>, <a href="#topic+showNb">showNb</a>, <a href="#topic+monitoringStat">monitoringStat</a>, <a href="rpart.html#topic+rpart">rpart</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## fit a model to characterize the surface of a simulated image:
img &lt;- sarGen(m = 50, n = 50, border = 50) # training image
model &lt;- surfacemodel(img, nb = 1, keep.residuals = TRUE) # see Note above for how to select nb
model
# plot cross-validation R-squared against complexity parameter and residual histogram
plot(model, type=1:2)

## change the raster scan order from left-to-right then top-to-bottom to
## left-to-right then bottom-to-top, and re-fit the model
## (see the Note section above)
img2  &lt;- as.matrix(t(apply(img , 2, rev)))
model2 &lt;- surfacemodel(img2, nb = 1)
model2$R2cv # cross-validation R-squared
</code></pre>

<hr>
<h2 id='twms'>
Time-Weighted Moving Statistic
</h2><span id='topic+twms'></span>

<h3>Description</h3>

<p>Computes time-weighted moving statistics EWMA or tabular CUSUM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twms(x, type = c("ewma", "cusum"), lambda, mu0, K, x0 = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twms_+3A_x">x</code></td>
<td>

<p>the vector of observations to compute the time-weighted moving statistic for.
</p>
</td></tr>
<tr><td><code id="twms_+3A_type">type</code></td>
<td>

<p>the type of statistic used in the computation.
</p>
</td></tr>
<tr><td><code id="twms_+3A_lambda">lambda</code></td>
<td>

<p>the parameter of EWMA
</p>
</td></tr>
<tr><td><code id="twms_+3A_mu0">mu0</code></td>
<td>

<p>the mean of the observations
</p>
</td></tr>
<tr><td><code id="twms_+3A_k">K</code></td>
<td>

<p>the parameter of tabular CUSUM
</p>
</td></tr>
<tr><td><code id="twms_+3A_x0">x0</code></td>
<td>

<p>the starting value for the time-weighted moving statistics.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the EWMA or tabular CUSUM statistics
</p>


<h3>Author(s)</h3>

<p>Anh Bui
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- twms(1:10, "ewma", lambda=0.2)
C &lt;- twms(1:10, "cusum", mu0=5, K=1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
