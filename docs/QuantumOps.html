<!DOCTYPE html><html lang="en"><head><title>Help for package QuantumOps</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {QuantumOps}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addmod2'><p>addmod2</p></a></li>
<li><a href='#adjoint'><p>adjoint</p></a></li>
<li><a href='#AmplitudeDamping'><p>AmplitudeDamping</p></a></li>
<li><a href='#BELL'><p>BELL</p></a></li>
<li><a href='#bra'><p>bra</p></a></li>
<li><a href='#CFA'><p>CFA</p></a></li>
<li><a href='#checkCases'><p>checkCases</p></a></li>
<li><a href='#cntrld'><p>cntrld</p></a></li>
<li><a href='#CoherentNoise'><p>CoherentNoise</p></a></li>
<li><a href='#colv'><p>colv</p></a></li>
<li><a href='#compareQuantumState'><p>compareQuantumState</p></a></li>
<li><a href='#controlled'><p>controlled</p></a></li>
<li><a href='#convert_bin2dec'><p>convert_bin2dec</p></a></li>
<li><a href='#convert_dec2bin'><p>convert_dec2bin</p></a></li>
<li><a href='#convert_ket2DM'><p>convert_ket2DM</p></a></li>
<li><a href='#CX'><p>CX</p></a></li>
<li><a href='#CY'><p>CY</p></a></li>
<li><a href='#CZ'><p>CZ</p></a></li>
<li><a href='#DecomposeGate'><p>DecomposeGate</p></a></li>
<li><a href='#dirac'><p>dirac</p></a></li>
<li><a href='#dist'><p>dist</p></a></li>
<li><a href='#dotmod2'><p>dotmod2</p></a></li>
<li><a href='#exponentialMod'><p>exponentialMod</p></a></li>
<li><a href='#extractMNIST'><p>extractMNIST</p></a></li>
<li><a href='#FullAdder'><p>FullAdder</p></a></li>
<li><a href='#G'><p>G</p></a></li>
<li><a href='#gcd'><p>gcd</p></a></li>
<li><a href='#GroverDiffusion'><p>GroverDiffusion</p></a></li>
<li><a href='#GroverOracle'><p>GroverOracle</p></a></li>
<li><a href='#GroversAlgorithm'><p>GroversAlgorithm</p></a></li>
<li><a href='#H'><p>H</p></a></li>
<li><a href='#hermitian'><p>hermitian</p></a></li>
<li><a href='#I'><p>I</p></a></li>
<li><a href='#inner'><p>inner</p></a></li>
<li><a href='#intket'><p>intket</p></a></li>
<li><a href='#ket'><p>ket</p></a></li>
<li><a href='#many'><p>many</p></a></li>
<li><a href='#measure'><p>measure</p></a></li>
<li><a href='#mm'><p>mm</p></a></li>
<li><a href='#nBitAddition'><p>nBitAddition</p></a></li>
<li><a href='#norm'><p>norm</p></a></li>
<li><a href='#opDM'><p>opDM</p></a></li>
<li><a href='#PauliNoise'><p>PauliNoise</p></a></li>
<li><a href='#PauliOperators'><p>PauliOperators</p></a></li>
<li><a href='#PhaseDamping'><p>PhaseDamping</p></a></li>
<li><a href='#plotprobs'><p>plotprobs</p></a></li>
<li><a href='#pp'><p>pp</p></a></li>
<li><a href='#probs'><p>probs</p></a></li>
<li><a href='#QAOA'><p>QAOA</p></a></li>
<li><a href='#QAOA_example'><p>QAOA_example</p></a></li>
<li><a href='#QAOA_maxcut'><p>QAOA_maxcut</p></a></li>
<li><a href='#QFT'><p>QFT</p></a></li>
<li><a href='#QuantumClassifier'><p>QuantumClassifier</p></a></li>
<li><a href='#QuantumMNIST256Classifier'><p>QuantumMNIST256Classifier</p></a></li>
<li><a href='#R'><p>R</p></a></li>
<li><a href='#randomConnectionMatrix'><p>randomConnectionMatrix</p></a></li>
<li><a href='#RandomizeCompile'><p>RandomizeCompile</p></a></li>
<li><a href='#ranket'><p>ranket</p></a></li>
<li><a href='#reduceMeasure'><p>reduceMeasure</p></a></li>
<li><a href='#repeatTensor'><p>repeatTensor</p></a></li>
<li><a href='#Rx'><p>Rx</p></a></li>
<li><a href='#Ry'><p>Ry</p></a></li>
<li><a href='#Rz'><p>Rz</p></a></li>
<li><a href='#S'><p>S</p></a></li>
<li><a href='#Shor'><p>Shor</p></a></li>
<li><a href='#single'><p>single</p></a></li>
<li><a href='#singleSWAP'><p>singleSWAP</p></a></li>
<li><a href='#Steane'><p>Steane</p></a></li>
<li><a href='#SteaneCorrect'><p>SteaneCorrect</p></a></li>
<li><a href='#SWAP'><p>SWAP</p></a></li>
<li><a href='#swapTest'><p>swapTest</p></a></li>
<li><a href='#SynthesizeCircuit'><p>SynthesizeCircuit</p></a></li>
<li><a href='#T'><p>T</p></a></li>
<li><a href='#teleport'><p>teleport</p></a></li>
<li><a href='#tensor'><p>tensor</p></a></li>
<li><a href='#testGate'><p>testGate</p></a></li>
<li><a href='#TOFFOLI'><p>TOFFOLI</p></a></li>
<li><a href='#U'><p>U</p></a></li>
<li><a href='#Uf'><p>Uf</p></a></li>
<li><a href='#unitary'><p>unitary</p></a></li>
<li><a href='#X'><p>X</p></a></li>
<li><a href='#Y'><p>Y</p></a></li>
<li><a href='#Z'><p>Z</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Performs Common Linear Algebra Operations Used in Quantum
Computing and Implements Quantum Algorithms</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-02-01</td>
</tr>
<tr>
<td>Author:</td>
<td>Salonik Resch</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Salonik Resch &lt;resc0059@umn.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains basic structures and operations used frequently in quantum computing. Intended to be a convenient tool to help learn quantum mechanics and algorithms. Can create arbitrarily sized kets and bras and implements quantum gates, inner products, and tensor products. Creates arbitrarily controlled versions of all gates and can simulate complete or partial measurements of kets. Has functionality to convert functions into equivalent quantum gates and model quantum noise. Includes larger applications, such as Steane error correction &lt;<a href="https://doi.org/10.1103%2Fphysrevlett.77.793">doi:10.1103/physrevlett.77.793</a>&gt;, Quantum Fourier Transform and Shor's algorithm (Shor 1999), Grover's algorithm (1996), Quantum Approximation Optimization Algorithm (QAOA) (Farhi, Goldstone, and Gutmann 2014) &lt;<a href="https://doi.org/10.48550/arXiv.1411.4028">doi:10.48550/arXiv.1411.4028</a>&gt;, and a variational quantum classifier (Schuld 2018) &lt;<a href="https://doi.org/10.48550/arXiv.1804.00633">doi:10.48550/arXiv.1804.00633</a>&gt;. Can be used with the gridsynth algorithm &lt;<a href="https://doi.org/10.48550/arXiv.1212.6253">doi:10.48550/arXiv.1212.6253</a>&gt; to perform decomposition into the Clifford+T set.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-02 18:48:07 UTC; mike</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-02-03 09:20:18 UTC</td>
</tr>
</table>
<hr>
<h2 id='addmod2'>addmod2</h2><span id='topic+addmod2'></span>

<h3>Description</h3>

<p>Takes two integers and adds their bits modulus two. The resulting string of bits represents an integer, that value of which is the output. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addmod2(x,a)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addmod2_+3A_x">x</code></td>
<td>
<p> integer </p>
</td></tr>
<tr><td><code id="addmod2_+3A_a">a</code></td>
<td>
<p> integer  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer resulting from the bit-wise addition of two number modulus 2
</p>


<h3>Examples</h3>

<pre><code class='language-R'> addmod2(5,5)
 addmod2(1,2)
</code></pre>

<hr>
<h2 id='adjoint'>adjoint</h2><span id='topic+adjoint'></span>

<h3>Description</h3>

<p>Finds the adjoint of the input. An input ket will become a bra and input bra will become a ket
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjoint(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjoint_+3A_x">x</code></td>
<td>
<p> A ket (column vector), bra (row vecor), or gate (matrix)  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The adjoint of <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> adjoint(ket(1,5))
</code></pre>

<hr>
<h2 id='AmplitudeDamping'>AmplitudeDamping</h2><span id='topic+AmplitudeDamping'></span>

<h3>Description</h3>

<p>Implements Amplitude Damping noise model on the input quantum state. Formulas taken from &lt;DOI:10.1103/PhysRevA.90.062320&gt;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AmplitudeDamping(p,Pad)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AmplitudeDamping_+3A_p">p</code></td>
<td>
<p> Input quantum state, in density matrix format  </p>
</td></tr>
<tr><td><code id="AmplitudeDamping_+3A_pad">Pad</code></td>
<td>
<p>The probability of Amplitude Damping. Commonly referred to as gamma in the literature. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The quantum state, after Amplitude Damping has been applied.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> AmplitudeDamping(p=convert_ket2DM(ket(1,0)),Pad=0.01)
</code></pre>

<hr>
<h2 id='BELL'>BELL</h2><span id='topic+BELL'></span>

<h3>Description</h3>

<p>If no argument is supplied, returns the matrix of BELL gate. If ket given as input, applies a BELL gate to the input ket and returns the resulting ket
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BELL(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BELL_+3A_...">...</code></td>
<td>
<p> No argument, or 4 dimensional (2 qubit) ket (column vector) that is input to the gate   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matix of the BELL gate or ket after a BELL gate is applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'> BELL(ket(1,1,1,1))
 BELL()
</code></pre>

<hr>
<h2 id='bra'>bra</h2><span id='topic+bra'></span>

<h3>Description</h3>

<p>Returns a normalized bra (row vector) 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bra(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bra_+3A_...">...</code></td>
<td>
<p> Variable number of numbers representing the amplitudes of the bra   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Row vector containing normalized amplitudes of a bra
</p>


<h3>Examples</h3>

<pre><code class='language-R'> bra(1,0,1,2)
</code></pre>

<hr>
<h2 id='CFA'>CFA</h2><span id='topic+CFA'></span>

<h3>Description</h3>

<p>Performs the continued fractions algorithm to find a fraction close to input value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CFA(y,epsilon=1e-2)
</code></pre>


<h3>Arguments</h3>

	
<table role = "presentation">
<tr><td><code id="CFA_+3A_y">y</code></td>
<td>
<p>Value that function attempts to find. Typically comes from measurement of Shor's algorithm </p>
</td></tr>
<tr><td><code id="CFA_+3A_epsilon">epsilon</code></td>
<td>
<p>Acceptable error between value and fraction</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector containing numerator and denominator of fraction
</p>


<h3>Examples</h3>

<pre><code class='language-R'> CFA(285/14)
</code></pre>

<hr>
<h2 id='checkCases'>checkCases</h2><span id='topic+checkCases'></span>

<h3>Description</h3>

<p>Takes in a matrix of clauses and determines what percentage of the clauses each possible value satisfies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkCases(clauses,colorCode=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkCases_+3A_clauses">clauses</code></td>
<td>
<p> Matrix that specifies the clauses. Each row is a clause. Each row must contain the same number of columns as qubits, the bit length of the clauses. 0 and 1 are values which are added to clause, ignored bits should be set to any other value. </p>
</td></tr>
<tr><td><code id="checkCases_+3A_colorcode">colorCode</code></td>
<td>
<p>Boolean which specifies if data should be returned as list of colors rather than numerical data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array of numbers or string color names
</p>


<h3>Examples</h3>

<pre><code class='language-R'> checkCases( rbind(c(1,-1),c(1,1) ) )
</code></pre>

<hr>
<h2 id='cntrld'>cntrld</h2><span id='topic+cntrld'></span>

<h3>Description</h3>

<p>Creates a matrix representing a controlled gate on a system of qubits. The target and control qubits can be located at arbitrarying positions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cntrld(gate,n,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cntrld_+3A_gate">gate</code></td>
<td>
<p> single qubit gate to create controlled version of   </p>
</td></tr>
<tr><td><code id="cntrld_+3A_n">n</code></td>
<td>
<p> Number of qubits in the ket, including target, control, and all other qubits</p>
</td></tr>
<tr><td><code id="cntrld_+3A_...">...</code></td>
<td>
<p>List of qubits. The last qubit in the list is the target. Any others listed before it are control qubits. Can be any number between 1 and n-1 control qubits, where n is the number of qubits in the ket. Qubits are indexed from 0, starting at the most significant qubit</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix representing the operation of a controlled qubit gate on any subset of the input ket
</p>


<h3>Examples</h3>

<pre><code class='language-R'> cntrld(X(),2,0,1)
 cntrld(X(),2,1,0)
 cntrld(Y(),4,2,3)
 cntrld(X(),8,0,5)
</code></pre>

<hr>
<h2 id='CoherentNoise'>CoherentNoise</h2><span id='topic+CoherentNoise'></span>

<h3>Description</h3>

<p>Implements a model of coherent noise as used in &lt;DOI:10.1038/s41534-018-0106-y&gt;. It rotates each qubit around the z-axis by the specified amount. If randomRoation is set, it will rotate around the X, Y, or Z axis, which is chosen at random. Randomizing provides interesting side effects but is less representative of quantum noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CoherentNoise(p,theta,randomRotation=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CoherentNoise_+3A_p">p</code></td>
<td>
<p> Input quantum state in density matrix format  </p>
</td></tr>
<tr><td><code id="CoherentNoise_+3A_theta">theta</code></td>
<td>
<p> Angle of rotation to apply  </p>
</td></tr>
<tr><td><code id="CoherentNoise_+3A_randomrotation">randomRotation</code></td>
<td>
<p> Boolean specifying whether the rotation should be in a semi-random direction </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The quantum state in density matrix format after noise has been applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'> CoherentNoise( p= convert_ket2DM(ket(1,1,1,1)),theta=0.06*pi) 
</code></pre>

<hr>
<h2 id='colv'>colv</h2><span id='topic+colv'></span>

<h3>Description</h3>

<p>Returns a column vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colv(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="colv_+3A_...">...</code></td>
<td>
<p> Variable number of numbers representing the values in the column vector   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Column vector containing input arguments
</p>


<h3>Examples</h3>

<pre><code class='language-R'> colv(1,0,1,2)
</code></pre>

<hr>
<h2 id='compareQuantumState'>compareQuantumState</h2><span id='topic+compareQuantumState'></span>

<h3>Description</h3>

<p>Generates a matrix (quantum oracle) which will flip the last qubit in a quantum state if the qubits at indices in vectors a and b are the same
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareQuantumState(nQubits,a,b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compareQuantumState_+3A_nqubits">nQubits</code></td>
<td>
<p> Number of qubits in a target ket. Should contain at least enough for states a and b and an additional last qubit. </p>
</td></tr>
<tr><td><code id="compareQuantumState_+3A_a">a</code></td>
<td>
<p> Vector of indices of first state to compare in a target ket </p>
</td></tr>
<tr><td><code id="compareQuantumState_+3A_b">b</code></td>
<td>
<p> Vector of indices of second state to compare in a target ket </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of the compareQuantumState oracle
</p>


<h3>Examples</h3>

<pre><code class='language-R'> compareQuantumState(5,0:1,2:3)
</code></pre>

<hr>
<h2 id='controlled'>controlled</h2><span id='topic+controlled'></span>

<h3>Description</h3>

<p>Creates a matrix representing a controlled gate on a system of qubits. The target and control qubits can be located at arbitrary positions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>controlled(gate,n,cQubits,tQubit)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="controlled_+3A_gate">gate</code></td>
<td>
<p> single qubit gate to create controlled version of   </p>
</td></tr>
<tr><td><code id="controlled_+3A_n">n</code></td>
<td>
<p> Number of qubits in the ket, including target, control, and all other qubits</p>
</td></tr>
<tr><td><code id="controlled_+3A_cqubits">cQubits</code></td>
<td>
<p>Vector of qubit indices. There can be between 1 and n-1 control qubits, where n is the number of qubits in the ket. Qubits are indexed from 0, starting at the most significant qubit</p>
</td></tr>
<tr><td><code id="controlled_+3A_tqubit">tQubit</code></td>
<td>
<p>Index of the target qubit. Qubits are indexed from 0, starting at the most significant qubit</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix representing the operation of a controlled qubit gate on any subset of the input ket
</p>


<h3>Examples</h3>

<pre><code class='language-R'> controlled(X(),n=2,cQubits=0,tQubit=1)
 controlled(X(),n=4,cQubits=c(0,1,2),tQubit=3)
</code></pre>

<hr>
<h2 id='convert_bin2dec'>convert_bin2dec</h2><span id='topic+convert_bin2dec'></span>

<h3>Description</h3>

<p>Takes a vector of unsigned bits with MSB first and produces integer value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_bin2dec(b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_bin2dec_+3A_b">b</code></td>
<td>
<p> Vector of bits with most significant bits first </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer value of bits
</p>


<h3>Examples</h3>

<pre><code class='language-R'> convert_bin2dec( c(1,0,0) )

</code></pre>

<hr>
<h2 id='convert_dec2bin'>convert_dec2bin</h2><span id='topic+convert_dec2bin'></span>

<h3>Description</h3>

<p>Takes an integer and returns an unsigned vector bits representing the same value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_dec2bin(x,len=32)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_dec2bin_+3A_x">x</code></td>
<td>
<p> Integer </p>
</td></tr>
<tr><td><code id="convert_dec2bin_+3A_len">len</code></td>
<td>
<p> Number of bits to represent integer with. Will crop most significant bits if insufficient length. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of bits with MSB first
</p>


<h3>Examples</h3>

<pre><code class='language-R'> convert_dec2bin(10)
 convert_dec2bin(10,8)
</code></pre>

<hr>
<h2 id='convert_ket2DM'>convert_ket2DM</h2><span id='topic+convert_ket2DM'></span>

<h3>Description</h3>

<p>Converts a ket (pure) description of quantum state and creates a density matrix representation of the same state. Density matrices can represent both pure and mixed states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_ket2DM(v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_ket2DM_+3A_v">v</code></td>
<td>
<p> An input ket  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Density matrix representing same state as input ket
</p>


<h3>Examples</h3>

<pre><code class='language-R'> convert_ket2DM( ket(1,0) )
</code></pre>

<hr>
<h2 id='CX'>CX</h2><span id='topic+CX'></span>

<h3>Description</h3>

<p>If no argument is supplied, returns the matrix of Controlled-X gate. If ket given as input, applies a Controlled-X gate to the input ket and returns the resulting ket
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CX(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CX_+3A_...">...</code></td>
<td>
<p> No argument, or 4 dimensional (2 qubit) ket (column vector) that is input to the gate   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matix of the Controlled-X gate or ket after a Controlled-X gate is applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'> CX(ket(1,1,1,1))
 CX()
</code></pre>

<hr>
<h2 id='CY'>CY</h2><span id='topic+CY'></span>

<h3>Description</h3>

<p>If no argument is supplied, returns the matrix of Controlled-Y gate. If ket given as input, applies a Controlled-Y gate to the input ket and returns the resulting ket
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CY(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CY_+3A_...">...</code></td>
<td>
<p> No argument, or 4 dimensional (2 qubit) ket (column vector) that is input to the gate   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matix of the Controlled-Y gate or ket after a Controlled-Y gate is applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'> CY(ket(1,1,1,1))
 CY()
</code></pre>

<hr>
<h2 id='CZ'>CZ</h2><span id='topic+CZ'></span>

<h3>Description</h3>

<p>If no argument is supplied, returns the matrix of Controlled-Z gate. If ket given as input, applies a Controlled-Z gate to the input ket and returns the resulting ket
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CZ(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CZ_+3A_...">...</code></td>
<td>
<p> No argument, or 4 dimensional (2 qubit) ket (column vector) that is input to the gate   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matix of the Controlled-Z gate or ket after a Controlled-Z gate is applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'> CZ(ket(1,1,1,1))
 CZ()
</code></pre>

<hr>
<h2 id='DecomposeGate'>DecomposeGate</h2><span id='topic+DecomposeGate'></span>

<h3>Description</h3>

<p>Uses the gridsynth algorithm Sellinger 2012 &lt;arXiv:1212.6253&gt;, which is available at https://www.mathstat.dal.ca/~selinger/newsynth/, to decompose arbitrary gates to the Clifford+T set. For decomposition of controlled 2-qubit gates, circuits from Amy 2013 &lt;DOI:10.1109/TCAD.2013.2244643&gt; are also used. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DecomposeGate(path,g,TwoQubit=FALSE,n=1,tQubit=0,cQubit=1,prec=10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DecomposeGate_+3A_path">path</code></td>
<td>
<p>String of path to folder containing gridsynth binary (not including gridsynths file name). R must have permission to read and write from this folder, and to execute the binary. </p>
</td></tr>
<tr><td><code id="DecomposeGate_+3A_g">g</code></td>
<td>
<p>If a single number, this is the Z-rotation angle to approximate. If a vector of length 3, it is the alpha, beta, and gamma parameters as defined in Schuld 2018 &lt;arXiv:1804.00633&gt;.</p>
</td></tr>
<tr><td><code id="DecomposeGate_+3A_twoqubit">TwoQubit</code></td>
<td>
<p>Boolean specifying whether this is a single or controlled 2-qubit gate  </p>
</td></tr>
<tr><td><code id="DecomposeGate_+3A_n">n</code></td>
<td>
<p>The total number of qubits in the system. If TwoQubit is TRUE, the returned circuit will have n+1 qubits due to the requirement of an ancilla qubit.  </p>
</td></tr>
<tr><td><code id="DecomposeGate_+3A_tqubit">tQubit</code></td>
<td>
<p> The target qubit. If a single qubit gate, the gate is applied to this qubit. If a 2-qubit gate, this is the target qubit.  </p>
</td></tr>
<tr><td><code id="DecomposeGate_+3A_cqubit">cQubit</code></td>
<td>
<p> Control qubit if a 2-qubit gate. Value does not matter for single qubit gate. </p>
</td></tr>
<tr><td><code id="DecomposeGate_+3A_prec">prec</code></td>
<td>
<p> The binary precision of the approximation, which is passed to the gridsynth binary. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of cycles which approximates the input gate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 DecomposeGate(path="./",g=pi/5,TwoQubit=TRUE,n=3,tQubit=0,cQubit=1,prec=3)

## End(Not run)
</code></pre>

<hr>
<h2 id='dirac'>dirac</h2><span id='topic+dirac'></span>

<h3>Description</h3>

<p>Prints the dirac notation of the input ket
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dirac(ket)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dirac_+3A_ket">ket</code></td>
<td>
<p> Ket (column vector) to print dirac notation of   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>String of dirac notation
</p>


<h3>Examples</h3>

<pre><code class='language-R'> dirac(ket(1,0,1,0))
</code></pre>

<hr>
<h2 id='dist'>dist</h2><span id='topic+dist'></span>

<h3>Description</h3>

<p>Reports the distance between two vectors/kets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist(a,b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_+3A_a">a</code></td>
<td>
<p> column vector </p>
</td></tr>
<tr><td><code id="dist_+3A_b">b</code></td>
<td>
<p> column vector  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Distance between two vectors
</p>


<h3>Examples</h3>

<pre><code class='language-R'> dist(ket(1,1,1,1),ket(1,0,0,1))
</code></pre>

<hr>
<h2 id='dotmod2'>dotmod2</h2><span id='topic+dotmod2'></span>

<h3>Description</h3>

<p>Takes two integers and takes the dot product of their binary representations. Output is the value of the dot product, modulus 2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dotmod2(x,a)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dotmod2_+3A_x">x</code></td>
<td>
<p> integer </p>
</td></tr>
<tr><td><code id="dotmod2_+3A_a">a</code></td>
<td>
<p> integer  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Binary value resulting from the bit-wise dot product modulus 2
</p>


<h3>Examples</h3>

<pre><code class='language-R'> dotmod2(5,5)
 dotmod2(1,2)
 dotmod2(0,1)
</code></pre>

<hr>
<h2 id='exponentialMod'>exponentialMod</h2><span id='topic+exponentialMod'></span>

<h3>Description</h3>

<p>Creates a function that raises a number to a power modulus another number. Is a fix for information loss due to extremely large numbers. It takes the modulus for every multiplication
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exponentialMod(a,N)
</code></pre>


<h3>Arguments</h3>

	
<table role = "presentation">
<tr><td><code id="exponentialMod_+3A_a">a</code></td>
<td>
<p>random number that is used as input to Shor's algorithm</p>
</td></tr>
<tr><td><code id="exponentialMod_+3A_n">N</code></td>
<td>
<p>Number that Shor's algorithm is to factor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that takes argument x and returns a^x modulus N
</p>


<h3>Examples</h3>

<pre><code class='language-R'> exponentialMod(8,21)
 exponentialMod(2,15)
</code></pre>

<hr>
<h2 id='extractMNIST'>extractMNIST</h2><span id='topic+extractMNIST'></span>

<h3>Description</h3>

<p>Opens the MNIST training data and label files (not provided with package) and extracts the images and labels and returns them in a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractMNIST(data,labels,s,centercrop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractMNIST_+3A_data">data</code></td>
<td>
<p> String of path to file containing MNIST training images   </p>
</td></tr>
<tr><td><code id="extractMNIST_+3A_labels">labels</code></td>
<td>
<p> String of path to file containing MNIST training labels </p>
</td></tr>
<tr><td><code id="extractMNIST_+3A_s">s</code></td>
<td>
<p> Number of samples and labels to extract from file</p>
</td></tr>
<tr><td><code id="extractMNIST_+3A_centercrop">centercrop</code></td>
<td>
<p> Boolean indicating whether the images should be centercropped to contain only 256 points </p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing matrix of image data and array of training labels
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
 extractMNIST("train-images.idx3-ubyte","train-labels.idx1-ubyte",2)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='FullAdder'>FullAdder</h2><span id='topic+FullAdder'></span>

<h3>Description</h3>

<p>Provides the quantum operatios for a full-adder with the specified input and output indices. Uses the circuit developed by Cheng and Tseng &lt;DOI:10.1049/el:20020949&gt;. Uses CNOT and TOFFOLI gates, with the TOFFOLI gates being broken down into H, T, and CNOT gates. The SUM (qu)bit gets places where the b operand (qu)bit is.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FullAdder(n=4,cin=0,a=1,b=2,cout=3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FullAdder_+3A_n">n</code></td>
<td>
<p> Number of qubits in input quantum state  </p>
</td></tr>
<tr><td><code id="FullAdder_+3A_cin">cin</code></td>
<td>
<p> index of the carry in (qu)bit  </p>
</td></tr>
<tr><td><code id="FullAdder_+3A_a">a</code></td>
<td>
<p> Index of the first operand (qu)bit  </p>
</td></tr>
<tr><td><code id="FullAdder_+3A_b">b</code></td>
<td>
<p> Index of the second operand (qu)bit  </p>
</td></tr>
<tr><td><code id="FullAdder_+3A_cout">cout</code></td>
<td>
<p> Index where the output carry (qu)bit will be placed  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements containing the quantum operations (matrices) for the full adder in each cycle.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> FullAdder(n=4,cin=0,a=1,b=2,cout=3)
</code></pre>

<hr>
<h2 id='G'>G</h2><span id='topic+G'></span>

<h3>Description</h3>

<p>Creates quantum gate defined by 4 angles as demonstrated by Barenco (1995). If no argument is supplied, returns the matrix of G gate. If ket given as input, applies an G gate to the input ket and returns the resulting ket
</p>


<h3>Usage</h3>

<pre><code class='language-R'>G(a,b,g,p=0,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="G_+3A_a">a</code></td>
<td>
<p>First angle</p>
</td></tr>
<tr><td><code id="G_+3A_b">b</code></td>
<td>
<p>second angle</p>
</td></tr>
<tr><td><code id="G_+3A_g">g</code></td>
<td>
<p>third angle</p>
</td></tr>
<tr><td><code id="G_+3A_p">p</code></td>
<td>
<p>global phase</p>
</td></tr>
<tr><td><code id="G_+3A_...">...</code></td>
<td>
<p> No argument, or ket (column vector) that is input to the gate   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of the G gate or ket after an G gate is applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'> G(0,0,0,0,ket(1,0))
 G(1,1,1)
</code></pre>

<hr>
<h2 id='gcd'>gcd</h2><span id='topic+gcd'></span>

<h3>Description</h3>

<p>Finds the gcd
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcd(x,y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gcd_+3A_x">x</code></td>
<td>
<p> First argument   </p>
</td></tr>
<tr><td><code id="gcd_+3A_y">y</code></td>
<td>
<p> Second argument </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The greated common divisor of x and y
</p>


<h3>Examples</h3>

<pre><code class='language-R'> gcd(7,3)
 gcd(10,4)
</code></pre>

<hr>
<h2 id='GroverDiffusion'>GroverDiffusion</h2><span id='topic+GroverDiffusion'></span>

<h3>Description</h3>

<p>If integer is input, returns the matrix of Grover Diffusion operation on the integer number of qubits. If ket given as input, applies a Grover Diffusion operation to the input ket and returns the resulting ket
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GroverDiffusion(input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GroverDiffusion_+3A_input">input</code></td>
<td>
<p> Either integer specifying size of operation (in number of qubits it is applied to) or input ket to apply Grover Diffusion to   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either the matrix of the Grover Diffusion gate of the specified size or ket after a Grover Diffusion operation is applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'> GroverDiffusion(ket(1,1,1,1,1,1,1,1))
 GroverDiffusion(3)
</code></pre>

<hr>
<h2 id='GroverOracle'>GroverOracle</h2><span id='topic+GroverOracle'></span>

<h3>Description</h3>

<p>If integer is input, returns the matrix of GroverOracle operation on the integer number of qubits. If ket given as input, applies a GroverOracle operation to the input ket and returns the resulting ket
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GroverOracle(w,input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GroverOracle_+3A_w">w</code></td>
<td>
<p>Integer specifying the state to search for, between 0 and 2^n-1 where n is the number of qubits</p>
</td></tr>
<tr><td><code id="GroverOracle_+3A_input">input</code></td>
<td>
<p> Either integer specifying size of operation (in number of qubits it is applied to) or input ket to apply GroverOracle to   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either the matrix of the GroverOracle gate of the specified size or ket after a GroverOracle operation is applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'> GroverOracle(0,ket(1,1,1,1,1,1,1,1))
 GroverOracle(0,3)
</code></pre>

<hr>
<h2 id='GroversAlgorithm'>GroversAlgorithm</h2><span id='topic+GroversAlgorithm'></span>

<h3>Description</h3>

<p>Applies Grover's search algorithm to a uniform ket to simulate a quantum search
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GroversAlgorithm(n,w,iterations=n,printOutput=FALSE,plotOutput=FALSE,tag="")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GroversAlgorithm_+3A_n">n</code></td>
<td>
<p>Number of qubits in the problem, not counting the extra ancillary qubit</p>
</td></tr>
<tr><td><code id="GroversAlgorithm_+3A_w">w</code></td>
<td>
<p>Integer specifying the state to search for, between 0 and 2^n-1 where n is the number of qubits</p>
</td></tr>
<tr><td><code id="GroversAlgorithm_+3A_iterations">iterations</code></td>
<td>
<p> Number of iterations to apply the oracle and diffusion, optimal is approximately n </p>
</td></tr>
<tr><td><code id="GroversAlgorithm_+3A_printoutput">printOutput</code></td>
<td>
<p>Boolean specifying if the measurement probabilities should be printed as search progresses</p>
</td></tr>
<tr><td><code id="GroversAlgorithm_+3A_plotoutput">plotOutput</code></td>
<td>
<p>Boolean specifying if the output probabilities should be plotted to a graph</p>
</td></tr>
<tr><td><code id="GroversAlgorithm_+3A_tag">tag</code></td>
<td>
<p>String which is attached to output file name if plotOutput is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Ket after a Grover search has been applied to it
</p>


<h3>Examples</h3>

<pre><code class='language-R'> GroversAlgorithm(7,0,14)
 GroversAlgorithm(7,0,14,printOutput=TRUE)
</code></pre>

<hr>
<h2 id='H'>H</h2><span id='topic+H'></span>

<h3>Description</h3>

<p>If no argument is supplied, returns the matrix of H gate. If ket given as input, applies an H gate to the input ket and returns the resulting ket
</p>


<h3>Usage</h3>

<pre><code class='language-R'>H(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="H_+3A_...">...</code></td>
<td>
<p> No argument, or ket (column vector) that is input to the gate   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matix of the H gate or ket after a Hgate is applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'> H(ket(1,0))
 H()
</code></pre>

<hr>
<h2 id='hermitian'>hermitian</h2><span id='topic+hermitian'></span>

<h3>Description</h3>

<p>Determines whether an operation (matrix) is hermitian by comparing it to its adjoint
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hermitian(m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hermitian_+3A_m">m</code></td>
<td>
<p>  gate operation (gate) that is to be checked   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean indicating whether matrix is hermitian or not
</p>


<h3>Examples</h3>

<pre><code class='language-R'> hermitian(matrix(c(0,1,1,0),nrow=2))
</code></pre>

<hr>
<h2 id='I'>I</h2><span id='topic+I'></span>

<h3>Description</h3>

<p>If no argument is supplied, returns the matrix of I gate. If ket given as input, applies an I gate to the input ket and returns the resulting ket
</p>


<h3>Usage</h3>

<pre><code class='language-R'>I(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="I_+3A_...">...</code></td>
<td>
<p> No argument, or ket (column vector) that is input to the gate   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matix of the I gate or ket after an I gate is applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'> I(ket(1,0))
 I()
</code></pre>

<hr>
<h2 id='inner'>inner</h2><span id='topic+inner'></span>

<h3>Description</h3>

<p>Finds the inner product of two kets, &lt;w|v&gt;. w and v can be the same
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inner(w,v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inner_+3A_w">w</code></td>
<td>
<p> ket (column vector) that is the left side of the innter product, converted to a bra before the dot product   </p>
</td></tr>
<tr><td><code id="inner_+3A_v">v</code></td>
<td>
<p> ket (column vector) that is the right side of the inner product</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of the inner product
</p>


<h3>Examples</h3>

<pre><code class='language-R'> inner(ket(1,0),ket(1,1))
</code></pre>

<hr>
<h2 id='intket'>intket</h2><span id='topic+intket'></span>

<h3>Description</h3>

<p>Returns a ket (column vector) that has the encoded value of the specified integers. Implements what is commonly known as basis encoding. Does not simulate the state creation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intket(x,n,amplitudes=rep(1,length(x)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intket_+3A_x">x</code></td>
<td>
<p> Integer, or vector of integers, specifying the integer encoded state(s) of the ket </p>
</td></tr>
<tr><td><code id="intket_+3A_n">n</code></td>
<td>
<p> Integer specifying the number of qubits in the ket </p>
</td></tr>
<tr><td><code id="intket_+3A_amplitudes">amplitudes</code></td>
<td>
<p> Integer, or vector of integers, specifying the amplitudes for corresponding basis in x. Must be same length as x. Only relative values matter as the ket will be normalized. Default is for all states to have same amplitude.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Column vector containing normalized amplitudes of a ket
</p>


<h3>Examples</h3>

<pre><code class='language-R'> intket(0,1)
 intket(3,2)
 intket(4,3)
 intket( c(0,1), 4)
 intket( c(0,2), 4 , c(1,2) )
</code></pre>

<hr>
<h2 id='ket'>ket</h2><span id='topic+ket'></span>

<h3>Description</h3>

<p>Returns a normalized ket (column vector) 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ket(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ket_+3A_...">...</code></td>
<td>
<p> Variable number of numbers representing the amplitudes of the ket   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Column vector containing normalized amplitudes of a ket
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ket(1,0,1,2)
</code></pre>

<hr>
<h2 id='many'>many</h2><span id='topic+many'></span>

<h3>Description</h3>

<p>Takes as input a gate and generates the matrix for that gate being applied to multiple qubits by creating a tensor product of the matrix. If a ket is supplied, the matrix will be applied to the ket
</p>


<h3>Usage</h3>

<pre><code class='language-R'>many(gate,n,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="many_+3A_gate">gate</code></td>
<td>
<p> Single qubit gate to apply </p>
</td></tr>
<tr><td><code id="many_+3A_n">n</code></td>
<td>
<p> Number of qubits that the gate will be applied to  </p>
</td></tr>
<tr><td><code id="many_+3A_...">...</code></td>
<td>
<p>Either no argument or a ket that the gates will be applied to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix representing the application of many gates or a ket after the gates have been applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'> many(H(),4)
 many(X(),2,ket(1,0,0,0))
</code></pre>

<hr>
<h2 id='measure'>measure</h2><span id='topic+measure'></span>

<h3>Description</h3>

<p>Probabilistically measures the input ket. By default measures all qubits, but if a list of integers is supplied it will measure only those qubits. Returns a list containing the state of the ket after measurement along with integer value of the state that was measured. Additionally, returns a vector of the measured binary values, if a list of qubits to measure was specified. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measure(...,l2r=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure_+3A_...">...</code></td>
<td>
<p> The input ket to measure. Optionally followed by integers specifying which qubits of the ket to measure. Qubits indexed from 0 from right to left </p>
</td></tr>
<tr><td><code id="measure_+3A_l2r">l2r</code></td>
<td>
<p> Boolean which specifices if indexing should be performed from left to right. Is FALSE by default to maintain backwards compatibility, however all other functions index from left to right.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the first item a column vector containing normalized amplitudes of the measured ket and the second item the integer value of the state which was measured. If a list of qubits to measure was specified as an argument, there is a 3rd item in the list which is a vector of the binary measured values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> measure(ket(1,0),l2r=TRUE)
 measure(ket(1,2,2,1),0,l2r=TRUE)
 measure(ket(1,2,3,4,5,6,7,8),0,l2r=TRUE)
 measure(ket(1,2,3,4,5,6,7,8),0,1,l2r=TRUE)
 measure(ket(1,2,3,4,5,6,7,8),0,1,2,l2r=TRUE)
</code></pre>

<hr>
<h2 id='mm'>mm</h2><span id='topic+mm'></span>

<h3>Description</h3>

<p>Returns a matrix containing the specified elements. Values are input column-wise. Used for convenient shorthand creation of matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mm(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mm_+3A_...">...</code></td>
<td>
<p> Variable number of numbers representing the values in the matrix   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix containing the values of the inputs
</p>


<h3>Examples</h3>

<pre><code class='language-R'> mm(1,0,1,2)
</code></pre>

<hr>
<h2 id='nBitAddition'>nBitAddition</h2><span id='topic+nBitAddition'></span>

<h3>Description</h3>

<p>Strings together output from FullAdder function to create multi-(qu)bit addition. It assumes the input operands are laid out as in &lt;DOI:10.1049/el:20020949&gt;. From left to right (top to bottom) the order is C0, a1, b1, C1, a2, b2, C2, .... bn-1, Cn. There must be 3n+1 qubits in order to perform n-(qu)bit addition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nBitAddition(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nBitAddition_+3A_n">n</code></td>
<td>
<p>Length of input (qu)bit strings. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the quantum circuit (each elemented is one cycle of the circuit) performing n-bit addition. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 nBitAddition(2)

## End(Not run)
</code></pre>

<hr>
<h2 id='norm'>norm</h2><span id='topic+norm'></span>

<h3>Description</h3>

<p>Finds the norm of input column vector by taking the inner product with itself
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm(v)
</code></pre>


<h3>Arguments</h3>

	
<table role = "presentation">
<tr><td><code id="norm_+3A_v">v</code></td>
<td>
<p>kcolumn vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Norm of the input column vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'> norm(ket(1,0))
</code></pre>

<hr>
<h2 id='opDM'>opDM</h2><span id='topic+opDM'></span>

<h3>Description</h3>

<p>Applies a quantum operation to a density matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opDM(V,G)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opDM_+3A_v">V</code></td>
<td>
<p> Input density matrix </p>
</td></tr>
<tr><td><code id="opDM_+3A_g">G</code></td>
<td>
<p> Quantum operation to apply to density matrix </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A density matrix which has been modofied by the input quantum operation
</p>


<h3>Examples</h3>

<pre><code class='language-R'> opDM( V=convert_ket2DM(ket(1,0)) , G=X()  )
</code></pre>

<hr>
<h2 id='PauliNoise'>PauliNoise</h2><span id='topic+PauliNoise'></span>

<h3>Description</h3>

<p>Applies stochastic Pauli noise to an input quantum state. If only e is set, it is equally distributed to X, Y, and Z error which is an isotropic Pauli noise model. Otherwise, levels can be set seperately for each.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PauliNoise(p,e=ex+ey+ez,ex=e/3,ey=e/3,ez=e/3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PauliNoise_+3A_p">p</code></td>
<td>
<p> Input quantum state, in density matrix format </p>
</td></tr>
<tr><td><code id="PauliNoise_+3A_e">e</code></td>
<td>
<p> Total amount of noise to apply the state, is the sum of ex, ey, and ez </p>
</td></tr>
<tr><td><code id="PauliNoise_+3A_ex">ex</code></td>
<td>
<p> Amount of X noise to apply to the state </p>
</td></tr>
<tr><td><code id="PauliNoise_+3A_ey">ey</code></td>
<td>
<p> Amount of Y noise to apply to the state </p>
</td></tr>
<tr><td><code id="PauliNoise_+3A_ez">ez</code></td>
<td>
<p> Amount of Z noise to apply to the state </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The quantum state in density matrix format, after Pauli noise has been applied to it
</p>


<h3>Examples</h3>

<pre><code class='language-R'> PauliNoise( p=convert_ket2DM(ket(1,0)) , e=0.01  )
</code></pre>

<hr>
<h2 id='PauliOperators'>PauliOperators</h2><span id='topic+PauliOperators'></span>

<h3>Description</h3>

<p>Generates random Pauli operators (tensor products of random I,X,Y,or Z gates applied to each qubit) that can be applied to register of n qubits. Used with Randomized Compiling, where random Pauli gates are applied to each qubit. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PauliOperators(n,m=4^n,unique=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PauliOperators_+3A_n">n</code></td>
<td>
<p> Size of the Pauli operators to generate, should be equal to the number of target qubits   </p>
</td></tr>
<tr><td><code id="PauliOperators_+3A_m">m</code></td>
<td>
<p> Number of different Pauli operators to generate </p>
</td></tr>
<tr><td><code id="PauliOperators_+3A_unique">unique</code></td>
<td>
<p> Boolean indicating if each Pauli operator generated should be unqiue. Must be false is m &gt; 4^n </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of m Pauli operators of size n
</p>


<h3>Examples</h3>

<pre><code class='language-R'> PauliOperators( n=2,m=2,unique=FALSE)
</code></pre>

<hr>
<h2 id='PhaseDamping'>PhaseDamping</h2><span id='topic+PhaseDamping'></span>

<h3>Description</h3>

<p>Implements Phase Damping noise model on the input quantum state. Formulas taken from &lt;DOI:10.1103/PhysRevA.90.062320&gt;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhaseDamping(p,Ppd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PhaseDamping_+3A_p">p</code></td>
<td>
<p> Input quantum state, in density matrix format  </p>
</td></tr>
<tr><td><code id="PhaseDamping_+3A_ppd">Ppd</code></td>
<td>
<p>The probability of phase Damping. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The quantum state, after Phase Damping has been applied.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> PhaseDamping(p=convert_ket2DM(ket(1,0)),Ppd=0.01)
</code></pre>

<hr>
<h2 id='plotprobs'>plotprobs</h2><span id='topic+plotprobs'></span>

<h3>Description</h3>

<p>Plots the probabilities of each of the amplitudes of ket in a barplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotprobs(v,color=rep("Blue",length(v)),customLegend=FALSE,lgNm="",lgCl="")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotprobs_+3A_v">v</code></td>
<td>
<p> ket that is to be plotted </p>
</td></tr>
<tr><td><code id="plotprobs_+3A_color">color</code></td>
<td>
<p> Text, possibly an array, specifying the colors of the bars  </p>
</td></tr>
<tr><td><code id="plotprobs_+3A_customlegend">customLegend</code></td>
<td>
<p>Boolean specifying if a custom legend should be inserted</p>
</td></tr>
<tr><td><code id="plotprobs_+3A_lgnm">lgNm</code></td>
<td>
<p>Vector of legend names</p>
</td></tr>
<tr><td><code id="plotprobs_+3A_lgcl">lgCl</code></td>
<td>
<p>Vector of legend colors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'> plotprobs(ket(1,0,1,0),color=c("Red","Blue","Red","Blue"))
</code></pre>

<hr>
<h2 id='pp'>pp</h2><span id='topic+pp'></span>

<h3>Description</h3>

<p>Prints a pasted string containing all arguments. Short hand for print(paste(...))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pp(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pp_+3A_...">...</code></td>
<td>
<p> Variable number of inputs to be printed   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints string
</p>


<h3>Examples</h3>

<pre><code class='language-R'> pp("Value is",1,0,1,2)
</code></pre>

<hr>
<h2 id='probs'>probs</h2><span id='topic+probs'></span>

<h3>Description</h3>

<p>Returns a column vector containing the probabilities of measuring the system in each state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probs(ket)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="probs_+3A_ket">ket</code></td>
<td>
<p>  ket (column vector) that is input to the gate   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Column vector containing probabilities
</p>


<h3>Examples</h3>

<pre><code class='language-R'> probs(ket(1,1))
</code></pre>

<hr>
<h2 id='QAOA'>QAOA</h2><span id='topic+QAOA'></span>

<h3>Description</h3>

<p>Implements a clause-based version of Quantum Approximation Optimization Algorithm (Farhi, Goldstone, and Gutmann 2014) &lt;arXiv:1411.4028&gt;. Takes as input a set of clauses and performs Controlled-Phase and Rx gates to perform optimization. See &quot;An Introduction to Quantum Optimization Approximation Algorithm&quot; (Wang and Abdullah 2018) for explanation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QAOA(clauses,p=1,gamma=pi/p,beta=pi/(2*p),displayProgress=FALSE,byCycle=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="QAOA_+3A_clauses">clauses</code></td>
<td>
<p> Matrix that specifies the clauses. Each row is a clause. Each row must contain the same number of columns as qubits, the bit length of the clauses. 0 and 1 are values which are added to clause, ignored bits should be set to any other value. </p>
</td></tr>
<tr><td><code id="QAOA_+3A_p">p</code></td>
<td>
<p> Number of iterations that algorithm will run. Each iteration applies U(C,g) and U(B,b)  </p>
</td></tr>
<tr><td><code id="QAOA_+3A_gamma">gamma</code></td>
<td>
<p>Angle for U(C,g), currently the same for all iterations. Should be between 0 and 2*pi</p>
</td></tr>
<tr><td><code id="QAOA_+3A_beta">beta</code></td>
<td>
<p>Angle for U(B,b), currently the same for all iterations. Should be between 0 and pi</p>
</td></tr>
<tr><td><code id="QAOA_+3A_displayprogress">displayProgress</code></td>
<td>
<p>Boolean which specifies if progress should be shown. If TRUE, a bar plot is continually updated showing the amplitudes</p>
</td></tr>
<tr><td><code id="QAOA_+3A_bycycle">byCycle</code></td>
<td>
<p> Boolean which specifies if function should return the circuit. If TRUE, rather than performing the algorithm it will generate and return the equivalent circuit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Ket after algorithm is applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'> QAOA(rbind(c(0,0),c(0,1)))
</code></pre>

<hr>
<h2 id='QAOA_example'>QAOA_example</h2><span id='topic+QAOA_example'></span>

<h3>Description</h3>

<p>Runs an example of QAOA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QAOA_example(case=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="QAOA_example_+3A_case">case</code></td>
<td>
<p>Integer specifying case to demonstrate. Currently only two, 1 (small) and 2 (medium)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
 QAOA_example(1)
 QAOA_example(2)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='QAOA_maxcut'>QAOA_maxcut</h2><span id='topic+QAOA_maxcut'></span>

<h3>Description</h3>

<p>Takes a connection matrix as input and converts it to a set of clauses, then runs the Quantum Approximation Optimization Algorithm (Farhi, Goldstone, and Gutmann 2014) &lt;arXiv:1411.4028&gt;. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QAOA_maxcut(connectionMatrix,p=1,gamma=pi/p,beta=pi/(2*p),displayProgress=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="QAOA_maxcut_+3A_connectionmatrix">connectionMatrix</code></td>
<td>
<p> Matrix that specifies the edges between nodes. Rows are source nodes and columns are destination nodes. Value of 0 means no edge, value of 1 means edge. If edge is undirected, an edge should be specified going both directions. </p>
</td></tr>
<tr><td><code id="QAOA_maxcut_+3A_p">p</code></td>
<td>
<p> Number of iterations that algorithm will run. Each iteration applies U(C,g) and U(B,b)  </p>
</td></tr>
<tr><td><code id="QAOA_maxcut_+3A_gamma">gamma</code></td>
<td>
<p>Angle for U(C,g), currently the same for all iterations. Should be between 0 and 2*pi</p>
</td></tr>
<tr><td><code id="QAOA_maxcut_+3A_beta">beta</code></td>
<td>
<p>Angle for U(B,b), currently the same for all iterations. Should be between 0 and pi</p>
</td></tr>
<tr><td><code id="QAOA_maxcut_+3A_displayprogress">displayProgress</code></td>
<td>
<p>Boolean which specifies if progress should be shown. If TRUE, a bar plot is continually updated showing the amplitudes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Ket after algorithm is applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'> QAOA_maxcut(randomConnectionMatrix(4,2),p=5)
</code></pre>

<hr>
<h2 id='QFT'>QFT</h2><span id='topic+QFT'></span>

<h3>Description</h3>

<p>If integer is input, returns the matrix of QFT operation on the integer number of qubits. If ket given as input, applies a QFT operation to the input ket and returns the resulting ket. If byCycle is TRUE, it generated the circuit for the QFT and returns a list of the cycles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QFT(input,byCycle=FALSE,swaps=TRUE,CliffordT=FALSE,prec=10,path="./")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="QFT_+3A_input">input</code></td>
<td>
<p> Either integer specifying size of operation (in number of qubits it is applied to) or input ket to apply QFT to   </p>
</td></tr>
<tr><td><code id="QFT_+3A_bycycle">byCycle</code></td>
<td>
<p>Boolean which specifies whether the circuit should be generated or not. If TRUE, rather than returning the matrix or performing the algorithm, the function will generate and return the equivalent circuit.</p>
</td></tr>
<tr><td><code id="QFT_+3A_swaps">swaps</code></td>
<td>
<p>Boolean which specifies if the the SWAP gates required at the end of the QFT should be inserted. May not be necessary if qubit reordering is acceptable. Only valid if byCycle is TRUE.</p>
</td></tr>
<tr><td><code id="QFT_+3A_cliffordt">CliffordT</code></td>
<td>
<p>Boolean which specifies if the generated circuit should be decomposed into the Clifford+T set. Only valid if byCycle is TRUE.</p>
</td></tr>
<tr><td><code id="QFT_+3A_prec">prec</code></td>
<td>
<p>The precision of the decomposition into the Clifford+T set. Only valid if byCycle and CliffordT are both TRUE.</p>
</td></tr>
<tr><td><code id="QFT_+3A_path">path</code></td>
<td>
<p>Path from current working directory to the gridsynth binary. Only used if CliffordT is set to TRUE. The gridsynth binary is not contained in QuantumOps but available from https://www.mathstat.dal.ca/~selinger/newsynth/</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the input is an integer, the matrix of the QFT gate of the specified size. If the input is a ket, the ket after a QFT operation is applied. If byCycle is TRUE, a list of the cycles of the algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> QFT(ket(1,0))
 QFT(ket(1,0,0,1))
 QFT(3)
</code></pre>

<hr>
<h2 id='QuantumClassifier'>QuantumClassifier</h2><span id='topic+QuantumClassifier'></span>

<h3>Description</h3>

<p>Quantum classifier which was proposed by Maria Schuld (2018). Consists of code blocks which have parallel single qubit quantum gates followed by controlled qubit gates. Takes as input samples and a corresponding list of labels indicating the correct output value of each sample. Will update the parameters of the gates in order to correctly identify the samples. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QuantumClassifier(	n=8,B=2,r=c(1,3),
			data=NULL,labels=NULL,digit=0,
			eta=1,decay=1,bsc=1,t=20,tag="",pl=TRUE,train=TRUE,
			validT=FALSE,vdata=NULL,vlabels=NULL,
			pretrained=FALSE,alpha=NULL,beta=NULL,gamma=NULL,bias=NULL,
		       	writeParameters=FALSE,outputPath=NULL	)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="QuantumClassifier_+3A_n">n</code></td>
<td>
<p>Number of qubits that this the classifier will use. </p>
</td></tr>
<tr><td><code id="QuantumClassifier_+3A_b">B</code></td>
<td>
<p>Number of blocks in the circuit. A block consists of n single qubit gates applied to each of the qubits in parallel and then n/(gcd,r) controlled qubit gates to perform a maximal entanglement. r is the specified range of the controlled gates</p>
</td></tr>
<tr><td><code id="QuantumClassifier_+3A_r">r</code></td>
<td>
<p>Vector containing the range for each block. length(r) should be equal to B. r of 1 means controlled gates are performed on adjacent qubits</p>
</td></tr>
<tr><td><code id="QuantumClassifier_+3A_data">data</code></td>
<td>
<p> matrix containing input training data. Rows are individual samples. The number of columns should be equal to 2^n </p>
</td></tr>
<tr><td><code id="QuantumClassifier_+3A_labels">labels</code></td>
<td>
<p> Vector containing labels of digits. Length must be the same as the number of rows in data </p>
</td></tr>
<tr><td><code id="QuantumClassifier_+3A_digit">digit</code></td>
<td>
<p> Individual output to identify. The network will attempt to differentiate between inputs that are labelled as digit (in the labels vector) and inputs that are labelled as any other number </p>
</td></tr>
<tr><td><code id="QuantumClassifier_+3A_eta">eta</code></td>
<td>
<p> learning rate for parameter updates </p>
</td></tr>
<tr><td><code id="QuantumClassifier_+3A_decay">decay</code></td>
<td>
<p> Multiplier for learning rate after each training iteration. If set to less than 1, the learning rate decays in time </p>
</td></tr>
<tr><td><code id="QuantumClassifier_+3A_bsc">bsc</code></td>
<td>
<p> Scaler for the learning rate of the bias. Setting to a low value will result in other parameters updating faster than the bias </p>
</td></tr>
<tr><td><code id="QuantumClassifier_+3A_t">t</code></td>
<td>
<p> Number of training iterations to perform. Total runs is equal to this value multiplied by the number of samples provided </p>
</td></tr>
<tr><td><code id="QuantumClassifier_+3A_tag">tag</code></td>
<td>
<p> String to attach to name of output files</p>
</td></tr>
<tr><td><code id="QuantumClassifier_+3A_pl">pl</code></td>
<td>
<p>Boolean indicating whether training output should be plotted</p>
</td></tr>
<tr><td><code id="QuantumClassifier_+3A_train">train</code></td>
<td>
<p>Boolean specifying if network should trained on training data, only false if passing in pretrained model</p>
</td></tr>
<tr><td><code id="QuantumClassifier_+3A_validt">validT</code></td>
<td>
<p>Boolean specifying if the network should be tested on validation data while being trained</p>
</td></tr>
<tr><td><code id="QuantumClassifier_+3A_vdata">vdata</code></td>
<td>
<p>Validation data, necessary if validT is set to true in which case network is tested on this data while being trained. Can be set to same as data.</p>
</td></tr>
<tr><td><code id="QuantumClassifier_+3A_vlabels">vlabels</code></td>
<td>
<p>Validation labels, necessary if validT is set to true in which case network is tested on vdata while being trained. Can be set to same as labels.</p>
</td></tr>
<tr><td><code id="QuantumClassifier_+3A_pretrained">pretrained</code></td>
<td>
<p>Boolean specifying if a pretrained model is being passed in. If so, alpha, beta, and gamme will be set to intputs, rather than randomized.</p>
</td></tr>
<tr><td><code id="QuantumClassifier_+3A_alpha">alpha</code></td>
<td>
<p>alpha values for gates if pretrained is set to TRUE, should be a vector of length equal to the number of gates in the circuit.</p>
</td></tr>
<tr><td><code id="QuantumClassifier_+3A_beta">beta</code></td>
<td>
<p>beta values for gates if pretrained is set to TRUE, should be a vector of length equal to the number of gates in the circuit.</p>
</td></tr>
<tr><td><code id="QuantumClassifier_+3A_gamma">gamma</code></td>
<td>
<p>gamma values for gates if pretrained is set to TRUE, should be a vector of length equal to the number of gates in the circuit. </p>
</td></tr>
<tr><td><code id="QuantumClassifier_+3A_bias">bias</code></td>
<td>
<p>Bias applied to the output of the circuit.</p>
</td></tr>
<tr><td><code id="QuantumClassifier_+3A_writeparameters">writeParameters</code></td>
<td>
<p> Boolean specifying whether function should write the parameters as it trains. Useful when training takes a long time.</p>
</td></tr>
<tr><td><code id="QuantumClassifier_+3A_outputpath">outputPath</code></td>
<td>
<p>String which specifies path to write output parameters to if writeParameters is TRUE. Must have write priveleges in this directory. The function will create two directories inside outputPath, named 0 and 1, and will alternate output to each folder. This prevents corruption of output if interrupted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing a list of the 33 gates and the matrix representing the entire circuit of the trained classifier
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
 QuantumClassifier(n=8,B=2,r=c(1,3),
    matrix(sample(256,replace=TRUE),nrow=1),
	array(1),0,1,1,.001,1,"test")
 
## End(Not run)
</code></pre>

<hr>
<h2 id='QuantumMNIST256Classifier'>QuantumMNIST256Classifier</h2><span id='topic+QuantumMNIST256Classifier'></span>

<h3>Description</h3>

<p>Quantum classifier which was proposed by Maria Schuld (2018). Consists of 33 quantum gates with a depth of 19. Takes as input samples with dimensions of 256 and a corresponding list of labels indicating the correct output value of each sample. Will update the parameters of the gates in order to correctly identify one of the digits specified. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QuantumMNIST256Classifier(
	data=NULL,labels=NULL,digit=0,
	eta=1,decay=1,bsc=1,t=20,tag="",pl=TRUE,train=TRUE,
	validT=FALSE,vdata=NULL,vlabels=NULL,
	pretrained=FALSE,alpha=NULL,beta=NULL,gamma=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="QuantumMNIST256Classifier_+3A_data">data</code></td>
<td>
<p> matrix containing input training data. Rows are individual samples. There must be 256 columns </p>
</td></tr>
<tr><td><code id="QuantumMNIST256Classifier_+3A_labels">labels</code></td>
<td>
<p> Vector containing labels of digits. Length must be the same as the number of rows in data </p>
</td></tr>
<tr><td><code id="QuantumMNIST256Classifier_+3A_digit">digit</code></td>
<td>
<p> Individual digit (0-9) to identify </p>
</td></tr>
<tr><td><code id="QuantumMNIST256Classifier_+3A_eta">eta</code></td>
<td>
<p> learning rate for parameter updates </p>
</td></tr>
<tr><td><code id="QuantumMNIST256Classifier_+3A_decay">decay</code></td>
<td>
<p> Multiplier for learning rate after each training iteration. If set to less than 1, the learning rate decays in time </p>
</td></tr>
<tr><td><code id="QuantumMNIST256Classifier_+3A_bsc">bsc</code></td>
<td>
<p> Scaler for the learning rate of the bias. Setting to a low value will result in other parameters updating faster than the bias </p>
</td></tr>
<tr><td><code id="QuantumMNIST256Classifier_+3A_t">t</code></td>
<td>
<p> Number of training iterations to perform. Total runs is equal to this value multiplied by the number of samples provided </p>
</td></tr>
<tr><td><code id="QuantumMNIST256Classifier_+3A_tag">tag</code></td>
<td>
<p> String to attach to name of output files</p>
</td></tr>
<tr><td><code id="QuantumMNIST256Classifier_+3A_pl">pl</code></td>
<td>
<p>Boolean indicating whether training output should be plotted</p>
</td></tr>
<tr><td><code id="QuantumMNIST256Classifier_+3A_train">train</code></td>
<td>
<p>Boolean specifying if network should trained on training data, only false if passing in pretrained model</p>
</td></tr>
<tr><td><code id="QuantumMNIST256Classifier_+3A_validt">validT</code></td>
<td>
<p>Boolean specifying if the network should be tested on validation data while being trained</p>
</td></tr>
<tr><td><code id="QuantumMNIST256Classifier_+3A_vdata">vdata</code></td>
<td>
<p>Validation data, necessary if validT is set to true in which case network is tested on this data while being trained. Can be set to same as data.</p>
</td></tr>
<tr><td><code id="QuantumMNIST256Classifier_+3A_vlabels">vlabels</code></td>
<td>
<p>Validation labels, necessary if validT is set to true in which case network is tested on vdata while being trained. Can be set to same as labels.</p>
</td></tr>
<tr><td><code id="QuantumMNIST256Classifier_+3A_pretrained">pretrained</code></td>
<td>
<p>Boolean specifying if a pretrained model is being passed in. If so, alpha, beta, and gamme will be set to intputs, rather than randomized.</p>
</td></tr>
<tr><td><code id="QuantumMNIST256Classifier_+3A_alpha">alpha</code></td>
<td>
<p>alpha values for gates if pretrained is set to TRUE, should be a vector of length 33</p>
</td></tr>
<tr><td><code id="QuantumMNIST256Classifier_+3A_beta">beta</code></td>
<td>
<p>beta values for gates if pretrained is set to TRUE, should be a vector of length 33</p>
</td></tr>
<tr><td><code id="QuantumMNIST256Classifier_+3A_gamma">gamma</code></td>
<td>
<p>gamma values for gates if pretrained is set to TRUE, should be a vector of length 33</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing a list of the 33 gates and the matrix representing the entire circuit of the trained classifier
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
 QuantumMNIST256Classifier(matrix(sample(256,replace=TRUE),nrow=1),array(1),0,1,1,.001,1,"test")
 
## End(Not run)
</code></pre>

<hr>
<h2 id='R'>R</h2><span id='topic+R'></span>

<h3>Description</h3>

<p>If no second argument is supplied, returns the matrix of an R phase gate of the specified radians. If ket given as second argument, applies the R gate to the input ket and returns the resulting ket. Is equivalent to the more recently added Rz function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R(theta,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="R_+3A_theta">theta</code></td>
<td>
<p>Radians to phase rotate the ket</p>
</td></tr>
<tr><td><code id="R_+3A_...">...</code></td>
<td>
<p> No argument, or ket (column vector) that is input to the gate   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matix of the R gate or ket after an R gate is applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'> R(pi,ket(1,0))
 R(pi)
</code></pre>

<hr>
<h2 id='randomConnectionMatrix'>randomConnectionMatrix</h2><span id='topic+randomConnectionMatrix'></span>

<h3>Description</h3>

<p>Generates a connection matrix for a random undirected graph. Intended for input to QAOA_maxcut.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomConnectionMatrix(nNodes,nEdges)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randomConnectionMatrix_+3A_nnodes">nNodes</code></td>
<td>
<p> Number of nodes in generated graph   </p>
</td></tr>
<tr><td><code id="randomConnectionMatrix_+3A_nedges">nEdges</code></td>
<td>
<p> Number of undirected edges in generated graph </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Connection Matrix specifying the edges of an undirected graph. Rows are source nodes, columns are destination nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> randomConnectionMatrix(5,3)
</code></pre>

<hr>
<h2 id='RandomizeCompile'>RandomizeCompile</h2><span id='topic+RandomizeCompile'></span>

<h3>Description</h3>

<p>Implements Randomized Compiling as described by Wallman and Emerson &lt;DOI:10.1103/PhysRevA.94.052325&gt;. Takes as input a list of easy cycles and a list of hard cycles. In this context, a cycle is the application of one operation to a register of qubits. Inserts randomizing Pauli gates after easy cycles, and corrective operations before the next easy cycle. The randomizations are then combined with the easy cycles. The first and last cycles are easy, with all other cycles alternating betweene asy and hard. Hence, the number of easy cycles should be one more than the number of hard cycles. Easy cycles (C) can be left unset, in which case Idle cycles will be inserted to enabled the randomizations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RandomizeCompile(	C=rep( list(
				repeatTensor(I(),log( dim(G[[1]])[1],base=2))),
						length(G)+1)
				,G,combine=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RandomizeCompile_+3A_c">C</code></td>
<td>
<p> List of easy cycles </p>
</td></tr>
<tr><td><code id="RandomizeCompile_+3A_g">G</code></td>
<td>
<p> List of hard cycles </p>
</td></tr>
<tr><td><code id="RandomizeCompile_+3A_combine">combine</code></td>
<td>
<p> Boolean specifying if the output should be combined into one list or left seperate </p>
</td></tr>
</table>


<h3>Value</h3>

<p>If combine is TRUE, a list of cycles that are now Randomly Compiled. If combine is FALSE, a list of two lists, the first being the Randomly Compiled easy cycles and the second the hard cycles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> RandomizeCompile( G=list( CX(), CX()))
 RandomizeCompile( G=list( controlled(gate=Z(),n=3,cQubits=0,tQubit=1) , 
			single(gate=H(),n=3,t=1) ))
</code></pre>

<hr>
<h2 id='ranket'>ranket</h2><span id='topic+ranket'></span>

<h3>Description</h3>

<p>Generates a random ket by selecting random polar coordinates (theta,phi) for each. Approach taken from &lt;DOI:10.1103/PhysRevA.95.062338&gt;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ranket(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ranket_+3A_n">n</code></td>
<td>
<p>Number of qubits in generated get </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ket with a randomized state
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ranket(4)
</code></pre>

<hr>
<h2 id='reduceMeasure'>reduceMeasure</h2><span id='topic+reduceMeasure'></span>

<h3>Description</h3>

<p>Probabilistically measures the input ket and reduces the size of ket by removing the measured qubits. By default measures all qubits, but if a list of integers is supplied it will measure only those qubits. Returns a list containing the state of the ket after measurement along with integer value of the state that was measured. Additionally, returns a vector of the measured binary value if a list of qubits to measure was specified. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduceMeasure(...,l2r=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reduceMeasure_+3A_...">...</code></td>
<td>
<p> The input ket to measure. Optionally followed by integers specifying which qubits of the ket to measure. Qubits indexed from 0 from right to left </p>
</td></tr>
<tr><td><code id="reduceMeasure_+3A_l2r">l2r</code></td>
<td>
<p> Boolean which specifices if indexing should be performed from left to right. Is FALSE by default to maintain backwards compatibility, however all other functions index from left to right.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the first item a column vector containing normalized amplitudes of the measured ket and the second item the integer value of the state which was measured. If a list of qubits to measure was specified as an argument, there is a 3rd item in the list which is a vector of the binary measured
</p>


<h3>Examples</h3>

<pre><code class='language-R'> reduceMeasure(ket(1,0),l2r=TRUE)
 reduceMeasure(ket(1,2,2,1),0,l2r=TRUE)
 reduceMeasure(ket(1,2,3,4,5,6,7,8),0,l2r=TRUE)
 reduceMeasure(ket(1,2,3,4,5,6,7,8),0,1,l2r=TRUE)
 reduceMeasure(ket(1,2,3,4,5,6,7,8),0,1,2,l2r=TRUE)
</code></pre>

<hr>
<h2 id='repeatTensor'>repeatTensor</h2><span id='topic+repeatTensor'></span>

<h3>Description</h3>

<p>Repeatedly tensors the input with itself
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repeatTensor(g,n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repeatTensor_+3A_g">g</code></td>
<td>
<p> Object, typically a gate, that is to be tensored with itself   </p>
</td></tr>
<tr><td><code id="repeatTensor_+3A_n">n</code></td>
<td>
<p> Number of times to tensor g with itself </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input g tensored by itself n times
</p>


<h3>Examples</h3>

<pre><code class='language-R'> repeatTensor(X(),2)
 repeatTensor(X(),2)
</code></pre>

<hr>
<h2 id='Rx'>Rx</h2><span id='topic+Rx'></span>

<h3>Description</h3>

<p>If no second argument is supplied, returns the matrix of an Rx rotation gate of the specified radians. If ket given as second argument, applies the Rx gate to the input ket and returns the resulting ket. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rx(theta,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Rx_+3A_theta">theta</code></td>
<td>
<p>Radians to phase rotate the ket around the x-axis</p>
</td></tr>
<tr><td><code id="Rx_+3A_...">...</code></td>
<td>
<p> No argument, or ket (column vector) that is input to the gate   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matix of the Rx gate or ket after an Rz gate is applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'> Rx(pi,ket(1,0))
 Rx(pi)
</code></pre>

<hr>
<h2 id='Ry'>Ry</h2><span id='topic+Ry'></span>

<h3>Description</h3>

<p>If no second argument is supplied, returns the matrix of an Ry rotation gate of the specified radians. If ket given as second argument, applies the Ry gate to the input ket and returns the resulting ket. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ry(theta,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Ry_+3A_theta">theta</code></td>
<td>
<p>Radians to phase rotate the ket around the y-axis</p>
</td></tr>
<tr><td><code id="Ry_+3A_...">...</code></td>
<td>
<p> No argument, or ket (column vector) that is input to the gate   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matix of the Rz gate or ket after an Rz gate is applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'> Ry(pi,ket(1,0))
 Ry(pi)
</code></pre>

<hr>
<h2 id='Rz'>Rz</h2><span id='topic+Rz'></span>

<h3>Description</h3>

<p>If no second argument is supplied, returns the matrix of an Rz rotation gate of the specified radians. If ket given as second argument, applies the Rz gate to the input ket and returns the resulting ket. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rz(theta,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Rz_+3A_theta">theta</code></td>
<td>
<p>Radians to phase rotate the ket around the z-axis</p>
</td></tr>
<tr><td><code id="Rz_+3A_...">...</code></td>
<td>
<p> No argument, or ket (column vector) that is input to the gate   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matix of the Rz gate or ket after an Rz gate is applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'> Rz(pi,ket(1,0))
 Rz(pi)
</code></pre>

<hr>
<h2 id='S'>S</h2><span id='topic+S'></span>

<h3>Description</h3>

<p>If no argument is supplied, returns the matrix of S gate. If ket given as input, applies an S gate to the input ket and returns the resulting ket
</p>


<h3>Usage</h3>

<pre><code class='language-R'>S(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="S_+3A_...">...</code></td>
<td>
<p>  No argument, or ket (column vector) that is input to the gate   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matix of the S gate or ket after an S gate is applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'> S(ket(1,1))
 S()
</code></pre>

<hr>
<h2 id='Shor'>Shor</h2><span id='topic+Shor'></span>

<h3>Description</h3>

<p>Implements Shor's algorithm by applying the quantum oracle, performing a QFT, measuring the output, and using continued fractions algorithm to find period. Period is then used with Euclidean algorithm to check if factors are legitimate prime factors. Is probabilistic and may fail. Factors 15 with ease and 21 occassionally. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Shor(N,trials=150,random=FALSE)
</code></pre>


<h3>Arguments</h3>

	
<table role = "presentation">
<tr><td><code id="Shor_+3A_n">N</code></td>
<td>
<p>Number that Shor's algorithm is to factor</p>
</td></tr>
<tr><td><code id="Shor_+3A_trials">trials</code></td>
<td>
<p>Number of times to attempt before giving up</p>
</td></tr>
<tr><td><code id="Shor_+3A_random">random</code></td>
<td>
<p>Boolean which determines whether seed is random or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector containing prime factors
</p>


<h3>Examples</h3>

<pre><code class='language-R'> Shor(15,trials=2)
</code></pre>

<hr>
<h2 id='single'>single</h2><span id='topic+single'></span>

<h3>Description</h3>

<p>Takes as input a gate and generates the matrix for that gate being applied to a single qubit in a ket by creating a tensor product of the matrix with Identity matrices. If a ket is supplied, the matrix will be applied to the ket
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single(gate,n,t,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="single_+3A_gate">gate</code></td>
<td>
<p> Single qubit gate to apply </p>
</td></tr>
<tr><td><code id="single_+3A_n">n</code></td>
<td>
<p> Number of qubits that are in the target ket  </p>
</td></tr>
<tr><td><code id="single_+3A_t">t</code></td>
<td>
<p> Target qubit that the gate will be applied to, other qubits are unmodified. Indexed from 0.</p>
</td></tr>
<tr><td><code id="single_+3A_...">...</code></td>
<td>
<p>Either no argument or a ket that the gate will be applied to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix representing the application of a single gate to one of the qubits in a ket or a ket after the gate has been applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'> single(H(),4,1)
 single(H(),2,1,ket(1,0,0,0))
 single(X(),2,0,ket(1,0,0,0))
</code></pre>

<hr>
<h2 id='singleSWAP'>singleSWAP</h2><span id='topic+singleSWAP'></span>

<h3>Description</h3>

<p>Implements the SWAP gate between two qubits, which can be in a larger ket. If no argument is supplied, returns the matrix of the gate. If ket given as input, applies the gate to the input ket and returns the resulting ket. In its default configuration it is the same as standard SWAP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>singleSWAP(nQubits=2,a=0,b=1,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="singleSWAP_+3A_nqubits">nQubits</code></td>
<td>
<p> Number of qubits in target ket</p>
</td></tr>
<tr><td><code id="singleSWAP_+3A_a">a</code></td>
<td>
<p>Index of first qubit to swap, indexed from 0</p>
</td></tr>
<tr><td><code id="singleSWAP_+3A_b">b</code></td>
<td>
<p>Index of second qubit to swap, indexed from 0</p>
</td></tr>
<tr><td><code id="singleSWAP_+3A_...">...</code></td>
<td>
<p> No argument, or ket (column vector) that is input to the gate   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of the singleSWAP gate or ket after an singleSWAP gate is applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'> singleSWAP(2,0,1, ket(1,2,3,4) )
 singleSWAP(4,0,3, intket( c(1,5),4,c(1,2)) )
</code></pre>

<hr>
<h2 id='Steane'>Steane</h2><span id='topic+Steane'></span>

<h3>Description</h3>

<p>Takes an unencoded single qubit ket and converts it to a 7-qubit Steane encoded ket
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Steane(v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Steane_+3A_v">v</code></td>
<td>
<p> Single qubit ket to Steane encode </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Steane encoded ket containing 7 qubits
</p>


<h3>Examples</h3>

<pre><code class='language-R'> Steane(ket(1,0))
 Steane(ket(0,1))
 Steane(ket(1,1))
</code></pre>

<hr>
<h2 id='SteaneCorrect'>SteaneCorrect</h2><span id='topic+SteaneCorrect'></span>

<h3>Description</h3>

<p>Performs Steane error correction on an encoded qubit. Useful explanation provided by Devitt &lt;DOI:10.1088/0034-4885/76/7/076001&gt;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SteaneCorrect(v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SteaneCorrect_+3A_v">v</code></td>
<td>
<p> Steane encoded qubit ket </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Steane encoded ket after error correction has been performed
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
 SteaneCorrect(Steane(ket(1,0)))
 SteaneCorrect(Steane(ket(0,1)))
 SteaneCorrect(Steane(ket(1,1)))
 SteaneCorrect(single(X(),n=7,t=2,Steane(ket(1,0))))
 
## End(Not run)
</code></pre>

<hr>
<h2 id='SWAP'>SWAP</h2><span id='topic+SWAP'></span>

<h3>Description</h3>

<p>If no argument is supplied, returns the matrix of SWAP gate. If ket given as input, applies an SWAP gate to the input ket and returns the resulting ket
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SWAP(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SWAP_+3A_...">...</code></td>
<td>
<p> No argument, or ket (column vector) that is input to the gate   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of the SWAP gate or ket after an SWAP gate is applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'> SWAP(ket(0,1,0,0))
 SWAP()
</code></pre>

<hr>
<h2 id='swapTest'>swapTest</h2><span id='topic+swapTest'></span>

<h3>Description</h3>

<p>Encodes absolute square of inner product of two states, |&lt;a|b&gt;|^2, into an ancilliary qubit. It swaps the states of |a&gt; and |b&gt; conditioned on the ancilla which results in a state where the probability of measuring the ancilla qubit in the 0 state is equal to 1/2 - 1/2*(|&lt;a|b&gt;|^2). The ancilla qubit is inserted before qubit index 0, as the most significant qubit. Full explanation can be found in &quot;Supervised Learning with Quantum Computers&quot; &lt;DOI:10.1007/978-3-319-96424-9&gt;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swapTest(v,a,b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="swapTest_+3A_v">v</code></td>
<td>
<p> Ket (column vector) that swap test is applied to. Should be a tensor product of two quantum state. </p>
</td></tr>
<tr><td><code id="swapTest_+3A_a">a</code></td>
<td>
<p> Vector of indices of |a&gt; within v </p>
</td></tr>
<tr><td><code id="swapTest_+3A_b">b</code></td>
<td>
<p> Vector of indices of |b&gt; within v</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Ket which contains the modified input ket, v, along with a leading ancillary qubit. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'> swapTest(intket(3,4),a=0:1,b=2:3)
 swapTest(intket(5,4),a=0:1,b=2:3)
</code></pre>

<hr>
<h2 id='SynthesizeCircuit'>SynthesizeCircuit</h2><span id='topic+SynthesizeCircuit'></span>

<h3>Description</h3>

<p>Converts the list form of a quantum circuit into a matrix representation. If the input is a single list, this function multiplies each entry. If each entry is a 4x4 unitary matrix, this function will multiply all, starting with the first, and generate a single 4x4 unitary matrix. If the input is a list of lists, this function will perform the same operation but interleave each list. The lists can be of different lengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SynthesizeCircuit(l)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SynthesizeCircuit_+3A_l">l</code></td>
<td>
<p> list containing the quantum operators of each cycle. The quantum operators should be unitary matrices which act on a number of qubits. Each entry in l should be of the same dimension. Optionally, l can be a of such lists, in which case each list will be interleaved. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix representing the result of applying each operation listed in l
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 SynthesizeCircuit( list( tensor(X(),X()) , tensor(Y(),X()),
		 tensor(I(),X()) , tensor(Z(),Z())  ))

## End(Not run)
## Not run: 
 SynthesizeCircuit( list(  list(  tensor(X(),X()) , tensor(I(),X()) ),
		 list( tensor(Y(),X()) , tensor(Z(),Z()) ) ) )

## End(Not run)
</code></pre>

<hr>
<h2 id='T'>T</h2><span id='topic+T'></span>

<h3>Description</h3>

<p>If no argument is supplied, returns the matrix of T gate. If ket given as input, applies a T gate to the input ket and returns the resulting ket
</p>


<h3>Usage</h3>

<pre><code class='language-R'>T(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="T_+3A_...">...</code></td>
<td>
<p>  No argument, or ket (column vector) that is input to the gate   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matix of the T gate or ket after an T gate is applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'> T(ket(1,1))
 T()
</code></pre>

<hr>
<h2 id='teleport'>teleport</h2><span id='topic+teleport'></span>

<h3>Description</h3>

<p>Shows the steps of teleporting a single qubit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>teleport(v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="teleport_+3A_v">v</code></td>
<td>
<p> Ket (column vector) to teleport   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>String describing teleportation process
</p>


<h3>Examples</h3>

<pre><code class='language-R'> teleport(ket(2,1))
</code></pre>

<hr>
<h2 id='tensor'>tensor</h2><span id='topic+tensor'></span>

<h3>Description</h3>

<p>Takes all arguments and combines them as a tensor product. Can be used to create a unified vector that represents multiple qubits or to create higher dimensional gates. If the inputs are two n-dimensional kets, the output is a 2-n dimensional ket representing the combined system. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tensor(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tensor_+3A_...">...</code></td>
<td>
<p> kets (column vectosr) or gates (matrices) to take tensor product of </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The tensor product of all supplied arguments
</p>


<h3>Examples</h3>

<pre><code class='language-R'> tensor(ket(1,0),ket(0,1),ket(1,0),ket(1,0))
 tensor(ket(1,1,1,1),ket(1,0,0,1))
 tensor(X(),I())
 tensor(H(),H(),H())
</code></pre>

<hr>
<h2 id='testGate'>testGate</h2><span id='topic+testGate'></span>

<h3>Description</h3>

<p>Takes a given quantum gate and tests it with computational basis states as input. Can test a subset of possible inputs if specified, otherwise it tests all possible inputs. Useful for testing user defined gates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testGate(g,inputs=0:(dim(g)[1]-1) )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testGate_+3A_g">g</code></td>
<td>
<p> Matrix that represents a quantum gate (operation) </p>
</td></tr>
<tr><td><code id="testGate_+3A_inputs">inputs</code></td>
<td>
<p> Vector of indices of computational basis states to test. Default is that all computational basis states will be tested </p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'> testGate(CX())
 testGate(CX(),inputs=c(0,1))
</code></pre>

<hr>
<h2 id='TOFFOLI'>TOFFOLI</h2><span id='topic+TOFFOLI'></span>

<h3>Description</h3>

<p>If no argument is supplied, returns the matrix of TOFFOLI gate. If ket given as input, applies a TOFFOLI gate to the input ket and returns the resulting ket. If byCycle is TRUE, it generates the cycles which implement the TOFFOLI gate with standard gates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TOFFOLI(...,byCycle=FALSE,n=3,cQubits=c(0,1),tQubit=2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TOFFOLI_+3A_...">...</code></td>
<td>
<p> No argument, or an 8 dimensional (3 qubit) ket (column vector) that is input to the gate   </p>
</td></tr>
<tr><td><code id="TOFFOLI_+3A_bycycle">byCycle</code></td>
<td>
<p>Boolean specifying if the circuit should be generated. If TRUE, rather than returning a matrix or performing a TOFFOLI gate, it returns a list of cycles of standard gates which implements the TOFFOLI gate.</p>
</td></tr>
<tr><td><code id="TOFFOLI_+3A_n">n</code></td>
<td>
<p>Number of qubits in the system.</p>
</td></tr>
<tr><td><code id="TOFFOLI_+3A_cqubits">cQubits</code></td>
<td>
<p>Vector of control qubit indices. Indexed from 0.</p>
</td></tr>
<tr><td><code id="TOFFOLI_+3A_tqubit">tQubit</code></td>
<td>
<p>Index of target qubit. Indexed from 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matix of the TOFFOLI gate or ket after a TOFFOLI gate is applied. If byCycle is TRUE, a list of cycles implementing the TOFFOLI.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> TOFFOLI(ket(1,1,1,1,0,1,0,1))
 TOFFOLI()
</code></pre>

<hr>
<h2 id='U'>U</h2><span id='topic+U'></span>

<h3>Description</h3>

<p>Takes as input a list of gates (in matrix form) and creates the tensor product, forming a higher dimensional gate. If the last argument is a ket, the gate is applied to the ket and the ket returned. If last argument is another gate, it returns the tensor product of all gates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>U(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="U_+3A_...">...</code></td>
<td>
<p> List of quantum gates in matrix form, optionally the last argument is ket (column vector) that is input to the gate   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matix of the gate that is the tensor product of all input gates, or the ket which is the result of the gate applied to the input ket
</p>


<h3>Examples</h3>

<pre><code class='language-R'> U(X(),ket(1,0))
 U(H(),H(),ket(1,0,0,0))
 U(I(),X(),ket(1,0,1,0))
 U(I(),X())
</code></pre>

<hr>
<h2 id='Uf'>Uf</h2><span id='topic+Uf'></span>

<h3>Description</h3>

<p>Generates an operator (oracle) of specified size that implements the function that is passed to it. Assumes there are n qubits in data register and m qubits in target register.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Uf(fun,n,m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Uf_+3A_fun">fun</code></td>
<td>
<p> Function of an n-bit argument that produces an m-bit result</p>
</td></tr>
<tr><td><code id="Uf_+3A_n">n</code></td>
<td>
<p>Integer that specifies the number of qubits in the data register, same as number of bits to function</p>
</td></tr>
<tr><td><code id="Uf_+3A_m">m</code></td>
<td>
<p>Integer that specifies the number of qubits in the target register, same as number of bits as output of function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of the operator (oracle) which implements the specified function)
</p>


<h3>Examples</h3>

<pre><code class='language-R'> Uf(function(x){x - floor(x/2)*2},1,1)
 Uf(function(x){0},2,2)
 Uf(function(x){1},2,2)
 Uf(function(x){x - floor(x/4)*4},2,2)
 Uf(function(x){x^3},3,4)
</code></pre>

<hr>
<h2 id='unitary'>unitary</h2><span id='topic+unitary'></span>

<h3>Description</h3>

<p>Determines whether an operation (matrix) is unitary by comparing its inverse to its adjoint
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unitary(m,epsilon=1e-13)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unitary_+3A_m">m</code></td>
<td>
<p>  gate operation (gate) that is to be checked   </p>
</td></tr>
<tr><td><code id="unitary_+3A_epsilon">epsilon</code></td>
<td>
<p> Amount of error to tolerate. Accounts for numerical precision on practical computing systems</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean indicating whether matrix is unitary or not
</p>


<h3>Examples</h3>

<pre><code class='language-R'> unitary(mm(0,1,1,0))
 unitary(mm(0,1,1,0),1e-15)
</code></pre>

<hr>
<h2 id='X'>X</h2><span id='topic+X'></span>

<h3>Description</h3>

<p>If no argument is supplied, returns the matrix of X gate. If ket given as input, applies an X gate to the input ket and returns the resulting ket
</p>


<h3>Usage</h3>

<pre><code class='language-R'>X(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="X_+3A_...">...</code></td>
<td>
<p> No argument, or ket (column vector) that is input to the gate   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matix of the X gate or ket after an X gate is applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'> X(ket(1,0))
 X()
</code></pre>

<hr>
<h2 id='Y'>Y</h2><span id='topic+Y'></span>

<h3>Description</h3>

<p>If no argument is supplied, returns the matrix of the Y gate. If ket given as input, applies a Y gate to the input ket and return the resulting ket
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Y(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Y_+3A_...">...</code></td>
<td>
<p> No argument, or ket (column vector) that is input to the gate   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of the Y gate or ket after a Y gate is applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'> Y(ket(1,0))
 Y()
</code></pre>

<hr>
<h2 id='Z'>Z</h2><span id='topic+Z'></span>

<h3>Description</h3>

<p>If no argument is supplied, returns the matrix of Z gate. If ket given as input, applies a Z gate to the input ket and returns the resulting ket
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Z(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Z_+3A_...">...</code></td>
<td>
<p> No argument, or ket (column vector) that is input to the gate   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matix of the Z gate or ket after a Z gate is applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'> Z(ket(1,0))
 Z()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
