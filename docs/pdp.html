<!DOCTYPE html><html><head><title>Help for package pdp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pdp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#autoplot.partial'><p>Plotting Partial Dependence Functions</p></a></li>
<li><a href='#boston'><p>Boston Housing Data</p></a></li>
<li><a href='#exemplar'><p>Exemplar observation</p></a></li>
<li><a href='#get_training_data'><p>#' @keywords internal</p>
where &lt;- function(name, env = parent.frame())
if (identical(env, emptyenv()))
stop(&quot;Can't find &quot;, name, &quot;.&quot;, call. = FALSE)
else if (exists(name, envir = env, inherits = FALSE))
env
else
where(name, parent.env(env))
</a></li>
<li><a href='#partial'><p>Partial Dependence Functions</p></a></li>
<li><a href='#pdp'><p>pdp: A general framework for constructing partial dependence (i.e., marginal</p>
effect) plots from various types machine learning models in R.</a></li>
<li><a href='#pima'><p>Pima Indians Diabetes Data</p></a></li>
<li><a href='#plotPartial'><p>Plotting Partial Dependence Functions</p></a></li>
<li><a href='#topPredictors'><p>Extract Most &quot;Important&quot; Predictors (Experimental)</p></a></li>
<li><a href='#trellis.last.object'><p>Retrieve the last trellis object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Partial Dependence Plots</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A general framework for constructing partial dependence (i.e.,
        marginal effect) plots from various types machine learning models
        in R.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/bgreenwell/pdp">https://github.com/bgreenwell/pdp</a>,
<a href="http://bgreenwell.github.io/pdp/">http://bgreenwell.github.io/pdp/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bgreenwell/pdp/issues">https://github.com/bgreenwell/pdp/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>adabag, AmesHousing, C50, caret, covr, Cubist, doParallel,
dplyr, e1071, earth, gbm, gridExtra, ICEbox, ipred, keras,
kernlab, magrittr, MASS, Matrix, mda, mlbench, nnet, party,
partykit, randomForest, ranger, reticulate, rpart, tinytest,
xgboost (&ge; 0.6-0), knitr, rmarkdown, vip</td>
</tr>
<tr>
<td>Imports:</td>
<td>foreach, ggplot2 (&ge; 3.0.0), grDevices, lattice, methods,
rlang (&ge; 0.3.0), stats, utils</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-07 16:30:46 UTC; bgreenwell</td>
</tr>
<tr>
<td>Author:</td>
<td>Brandon M. Greenwell
    <a href="https://orcid.org/0000-0002-8120-0084"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brandon M. Greenwell &lt;greenwell.brandon@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-07 20:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='autoplot.partial'>Plotting Partial Dependence Functions</h2><span id='topic+autoplot.partial'></span><span id='topic+autoplot.ice'></span><span id='topic+autoplot.cice'></span>

<h3>Description</h3>

<p>Plots partial dependence functions (i.e., marginal effects) using
<code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'partial'
autoplot(
  object,
  center = FALSE,
  plot.pdp = TRUE,
  pdp.color = "red",
  pdp.size = 1,
  pdp.linetype = 1,
  rug = FALSE,
  smooth = FALSE,
  smooth.method = "auto",
  smooth.formula = y ~ x,
  smooth.span = 0.75,
  smooth.method.args = list(),
  contour = FALSE,
  contour.color = "white",
  train = NULL,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  legend.title = "yhat",
  ...
)

## S3 method for class 'ice'
autoplot(
  object,
  center = FALSE,
  plot.pdp = TRUE,
  pdp.color = "red",
  pdp.size = 1,
  pdp.linetype = 1,
  rug = FALSE,
  train = NULL,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  ...
)

## S3 method for class 'cice'
autoplot(
  object,
  plot.pdp = TRUE,
  pdp.color = "red",
  pdp.size = 1,
  pdp.linetype = 1,
  rug = FALSE,
  train = NULL,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.partial_+3A_object">object</code></td>
<td>
<p>An object that inherits from the <code>"partial"</code> class.</p>
</td></tr>
<tr><td><code id="autoplot.partial_+3A_center">center</code></td>
<td>
<p>Logical indicating whether or not to produce centered ICE
curves (c-ICE curves). Only useful when <code>object</code> represents a set of ICE
curves; see <code><a href="#topic+partial">partial</a></code> for details. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="autoplot.partial_+3A_plot.pdp">plot.pdp</code></td>
<td>
<p>Logical indicating whether or not to plot the partial
dependence function on top of the ICE curves. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="autoplot.partial_+3A_pdp.color">pdp.color</code></td>
<td>
<p>Character string specifying the color to use for the partial
dependence function when <code>plot.pdp = TRUE</code>. Default is <code>"red"</code>.</p>
</td></tr>
<tr><td><code id="autoplot.partial_+3A_pdp.size">pdp.size</code></td>
<td>
<p>Positive number specifying the line width to use for the
partial dependence function when <code>plot.pdp = TRUE</code>. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="autoplot.partial_+3A_pdp.linetype">pdp.linetype</code></td>
<td>
<p>Positive number specifying the line type to use for the
partial dependence function when <code>plot.pdp = TRUE</code>. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="autoplot.partial_+3A_rug">rug</code></td>
<td>
<p>Logical indicating whether or not to include rug marks on the
predictor axes. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="autoplot.partial_+3A_smooth">smooth</code></td>
<td>
<p>Logical indicating whether or not to overlay a LOESS smooth.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="autoplot.partial_+3A_smooth.method">smooth.method</code></td>
<td>
<p>Character string specifying the smoothing method
(function) to use (e.g., <code>"auto"</code>, <code>"lm"</code>, <code>"glm"</code>,
<code>"gam"</code>, <code>"loess"</code>, or <code>"rlm"</code>). Default is <code>"auto"</code>.
See <code><a href="ggplot2.html#topic+geom_smooth">geom_smooth</a></code> for details.</p>
</td></tr>
<tr><td><code id="autoplot.partial_+3A_smooth.formula">smooth.formula</code></td>
<td>
<p>Formula to use in smoothing function (e.g.,
<code>y ~ x</code>, <code>y ~ poly(x, 2)</code>, or <code>y ~ log(x)</code>).</p>
</td></tr>
<tr><td><code id="autoplot.partial_+3A_smooth.span">smooth.span</code></td>
<td>
<p>Controls the amount of smoothing for the default loess
smoother. Smaller numbers produce wigglier lines, larger numbers produce
smoother lines. Default is <code>0.75</code>.</p>
</td></tr>
<tr><td><code id="autoplot.partial_+3A_smooth.method.args">smooth.method.args</code></td>
<td>
<p>List containing additional arguments to be passed
on to the modeling function defined by <code>smooth.method</code>.</p>
</td></tr>
<tr><td><code id="autoplot.partial_+3A_contour">contour</code></td>
<td>
<p>Logical indicating whether or not to add contour lines to the
level plot.</p>
</td></tr>
<tr><td><code id="autoplot.partial_+3A_contour.color">contour.color</code></td>
<td>
<p>Character string specifying the color to use for the
contour lines when <code>contour = TRUE</code>. Default is <code>"white"</code>.</p>
</td></tr>
<tr><td><code id="autoplot.partial_+3A_train">train</code></td>
<td>
<p>Data frame containing the original training data. Only required
if <code>rug = TRUE</code> or <code>chull = TRUE</code>.</p>
</td></tr>
<tr><td><code id="autoplot.partial_+3A_xlab">xlab</code></td>
<td>
<p>Character string specifying the text for the x-axis label.</p>
</td></tr>
<tr><td><code id="autoplot.partial_+3A_ylab">ylab</code></td>
<td>
<p>Character string specifying the text for the y-axis label.</p>
</td></tr>
<tr><td><code id="autoplot.partial_+3A_main">main</code></td>
<td>
<p>Character string specifying the text for the main title of the
plot.</p>
</td></tr>
<tr><td><code id="autoplot.partial_+3A_legend.title">legend.title</code></td>
<td>
<p>Character string specifying the text for the legend title.
Default is <code>"yhat"</code>.</p>
</td></tr>
<tr><td><code id="autoplot.partial_+3A_...">...</code></td>
<td>
<p>Additional (optional) arguments to be passed onto
<code><a href="ggplot2.html#topic+geom_line">geom_line</a></code>, <code><a href="ggplot2.html#topic+geom_point">geom_point</a></code>, or
<code><a href="ggplot2.html#topic+scale_fill_viridis_c">scale_fill_viridis_c</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"ggplot"</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#
# Regression example (requires randomForest package to run)
#

# Load required packages
library(ggplot2)  # for autoplot() generic
library(gridExtra)  # for `grid.arrange()`
library(magrittr)  # for forward pipe operator `%&gt;%`
library(randomForest)

# Fit a random forest to the Boston housing data
data (boston)  # load the boston housing data
set.seed(101)  # for reproducibility
boston.rf &lt;- randomForest(cmedv ~ ., data = boston)

# Partial dependence of cmedv on lstat
boston.rf %&gt;%
  partial(pred.var = "lstat") %&gt;%
  autoplot(rug = TRUE, train = boston) + theme_bw()

# Partial dependence of cmedv on lstat and rm
boston.rf %&gt;%
  partial(pred.var = c("lstat", "rm"), chull = TRUE, progress = TRUE) %&gt;%
  autoplot(contour = TRUE, legend.title = "cmedv",
           option = "B", direction = -1) + theme_bw()

# ICE curves and c-ICE curves
age.ice &lt;- partial(boston.rf, pred.var = "lstat", ice = TRUE)
grid.arrange(
  autoplot(age.ice, alpha = 0.1),                 # ICE curves
  autoplot(age.ice, center = TRUE, alpha = 0.1),  # c-ICE curves
  ncol = 2
)

## End(Not run)
</code></pre>

<hr>
<h2 id='boston'>Boston Housing Data</h2><span id='topic+boston'></span>

<h3>Description</h3>

<p>Data on median housing values from 506 census tracts in the suburbs of Boston
from the 1970 census. This data frame is a corrected version of the original
data by Harrison and Rubinfeld (1978) with additional spatial information.
The data were taken directly from <code><a href="mlbench.html#topic+BostonHousing2">BostonHousing2</a></code> and
unneeded columns (i.e., name of town, census tract, and the uncorrected
median home value) were removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(boston)
</code></pre>


<h3>Format</h3>

<p>A data frame with 506 rows and 16 variables.
</p>

<ul>
<li> <p><code>lon</code> Longitude of census tract.
</p>
</li>
<li> <p><code>lat</code> Latitude of census tract.
</p>
</li>
<li> <p><code>cmedv</code> Corrected median value of owner-occupied homes in USD 1000's
</p>
</li>
<li> <p><code>crim</code> Per capita crime rate by town.
</p>
</li>
<li> <p><code>zn</code> Proportion of residential land zoned for lots over 25,000 sq.ft.
</p>
</li>
<li> <p><code>indus</code> Proportion of non-retail business acres per town.
</p>
</li>
<li> <p><code>chas</code> Charles River dummy variable (= 1 if tract bounds river; 0 otherwise).
</p>
</li>
<li> <p><code>nox</code> Nitric oxides concentration (parts per 10 million).
</p>
</li>
<li> <p><code>rm</code> Average number of rooms per dwelling.
</p>
</li>
<li> <p><code>age</code> Proportion of owner-occupied units built prior to 1940.
</p>
</li>
<li> <p><code>dis</code> Weighted distances to five Boston employment centers.
</p>
</li>
<li> <p><code>rad</code> Index of accessibility to radial highways.
</p>
</li>
<li> <p><code>tax</code> Full-value property-tax rate per USD 10,000.
</p>
</li>
<li> <p><code>ptratio</code> Pupil-teacher ratio by town.
</p>
</li>
<li> <p><code>b</code> $1000(B - 0.63)^2$ where B is the proportion of blacks by town.
</p>
</li>
<li> <p><code>lstat</code> Percentage of lower status of the population.
</p>
</li></ul>



<h3>References</h3>

<p>Harrison, D. and Rubinfeld, D.L. (1978). Hedonic prices and the demand for
clean air. Journal of Environmental Economics and Management, 5, 81-102.
</p>
<p>Gilley, O.W., and R. Kelley Pace (1996). On the Harrison and Rubinfeld Data.
Journal of Environmental Economics and Management, 31, 403-405.
</p>
<p>Newman, D.J. &amp; Hettich, S. &amp; Blake, C.L. &amp; Merz, C.J. (1998). UCI Repository
of machine learning databases
[http://www.ics.uci.edu/~mlearn/MLRepository.html] Irvine, CA: University of
California, Department of Information and Computer Science.
</p>
<p>Pace, R. Kelley, and O.W. Gilley (1997). Using the Spatial Configuration of
the Data to Improve Estimation. Journal of the Real Estate Finance and
Economics, 14, 333-340.
</p>
<p>Friedrich Leisch &amp; Evgenia Dimitriadou (2010). mlbench: Machine Learning
Benchmark Problems. R package version 2.1-1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(boston)

</code></pre>

<hr>
<h2 id='exemplar'>Exemplar observation</h2><span id='topic+exemplar'></span><span id='topic+exemplar.data.frame'></span><span id='topic+exemplar.matrix'></span><span id='topic+exemplar.dgCMatrix'></span>

<h3>Description</h3>

<p>Construct a single &quot;exemplar&quot; record from a data frame. For now, all numeric
columns (including <code>"<a href="base.html#topic+Date">Date</a>"</code> objects) are replaced with their
corresponding median value and non-numeric columns are replaced with their
most frequent value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exemplar(object)

## S3 method for class 'data.frame'
exemplar(object)

## S3 method for class 'matrix'
exemplar(object)

## S3 method for class 'dgCMatrix'
exemplar(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exemplar_+3A_object">object</code></td>
<td>
<p>A data frame, matrix, or
<code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code> (the latter two are
supported by <code><a href="xgboost.html#topic+xgboost">xgboost</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the same number of columns as <code>object</code> and a
single row.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1554)  # for reproducibility
train &lt;- data.frame(
  x = rnorm(100),
  y = sample(letters[1L:3L], size = 100, replace = TRUE,
             prob = c(0.1, 0.1, 0.8))
)
exemplar(train)
</code></pre>

<hr>
<h2 id='get_training_data'>#' @keywords internal
where &lt;- function(name, env = parent.frame()) 
if (identical(env, emptyenv())) 
stop(&quot;Can't find &quot;, name, &quot;.&quot;, call. = FALSE)
 else if (exists(name, envir = env, inherits = FALSE)) 
env
 else 
where(name, parent.env(env))

</h2><span id='topic+get_training_data'></span>

<h3>Description</h3>

<p>#' @keywords internal
where &lt;- function(name, env = parent.frame()) 
if (identical(env, emptyenv())) 
stop(&quot;Can't find &quot;, name, &quot;.&quot;, call. = FALSE)
 else if (exists(name, envir = env, inherits = FALSE)) 
env
 else 
where(name, parent.env(env))


</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_training_data(object)
</code></pre>

<hr>
<h2 id='partial'>Partial Dependence Functions</h2><span id='topic+partial'></span><span id='topic+partial.default'></span><span id='topic+partial.model_fit'></span>

<h3>Description</h3>

<p>Compute partial dependence functions (i.e., marginal effects) for various
model fitting objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partial(object, ...)

## Default S3 method:
partial(
  object,
  pred.var,
  pred.grid,
  pred.fun = NULL,
  grid.resolution = NULL,
  ice = FALSE,
  center = FALSE,
  approx = FALSE,
  quantiles = FALSE,
  probs = 1:9/10,
  trim.outliers = FALSE,
  type = c("auto", "regression", "classification"),
  inv.link = NULL,
  which.class = 1L,
  prob = FALSE,
  recursive = TRUE,
  plot = FALSE,
  plot.engine = c("lattice", "ggplot2"),
  smooth = FALSE,
  rug = FALSE,
  chull = FALSE,
  levelplot = TRUE,
  contour = FALSE,
  contour.color = "white",
  alpha = 1,
  train,
  cats = NULL,
  check.class = TRUE,
  progress = FALSE,
  parallel = FALSE,
  paropts = NULL,
  ...
)

## S3 method for class 'model_fit'
partial(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partial_+3A_object">object</code></td>
<td>
<p>A fitted model object of appropriate class (e.g., <code>"gbm"</code>,
<code>"lm"</code>, <code>"randomForest"</code>, <code>"train"</code>, etc.).</p>
</td></tr>
<tr><td><code id="partial_+3A_...">...</code></td>
<td>
<p>Additional optional arguments to be passed onto
<code><a href="stats.html#topic+predict">predict</a></code>.</p>
</td></tr>
<tr><td><code id="partial_+3A_pred.var">pred.var</code></td>
<td>
<p>Character string giving the names of the predictor variables
of interest. For reasons of computation/interpretation, this should include
no more than three variables.</p>
</td></tr>
<tr><td><code id="partial_+3A_pred.grid">pred.grid</code></td>
<td>
<p>Data frame containing the joint values of interest for the
variables listed in <code>pred.var</code>.</p>
</td></tr>
<tr><td><code id="partial_+3A_pred.fun">pred.fun</code></td>
<td>
<p>Optional prediction function that requires two arguments:
<code>object</code> and <code>newdata</code>. If specified, then the function must return
a single prediction or a vector of predictions (i.e., not a matrix or data
frame). Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="partial_+3A_grid.resolution">grid.resolution</code></td>
<td>
<p>Integer giving the number of equally spaced points to
use for the continuous variables listed in <code>pred.var</code> when
<code>pred.grid</code> is not supplied. If left <code>NULL</code>, it will default to
the minimum between <code>51</code> and the number of unique data points for each
of the continuous independent variables listed in <code>pred.var</code>.</p>
</td></tr>
<tr><td><code id="partial_+3A_ice">ice</code></td>
<td>
<p>Logical indicating whether or not to compute individual
conditional expectation (ICE) curves. Default is <code>FALSE</code>. See
Goldstein et al. (2014) for details.</p>
</td></tr>
<tr><td><code id="partial_+3A_center">center</code></td>
<td>
<p>Logical indicating whether or not to produce centered ICE
curves (c-ICE curves). Only used when <code>ice = TRUE</code>. Default is
<code>FALSE</code>. See Goldstein et al. (2014) for details.</p>
</td></tr>
<tr><td><code id="partial_+3A_approx">approx</code></td>
<td>
<p>Logical indicating whether or not to compute a faster, but
approximate, marginal effect plot (similar in spirit to the
<strong>plotmo</strong> package). If <code>TRUE</code>, then <code>partial()</code> will compute
predictions across the predictors specified in <code>pred.var</code> while holding
the other predictors constant (a &quot;poor man's partial dependence&quot; function as
Stephen Milborrow, the author of <strong>plotmo</strong>, puts it).
Default is <code>FALSE</code>. Note this works with <code>ice = TRUE</code> as well.
WARNING: This option is currently experimental. Use at your own risk. It is
possible (and arguably safer) to do this manually by passing a specific
&quot;exemplar&quot; observation to the train argument and specifying <code>pred.grid</code>
manually.</p>
</td></tr>
<tr><td><code id="partial_+3A_quantiles">quantiles</code></td>
<td>
<p>Logical indicating whether or not to use the sample
quantiles of the continuous predictors listed in <code>pred.var</code>. If
<code>quantiles = TRUE</code> and <code>grid.resolution = NULL</code> the sample
quantiles will be used to generate the grid of joint values for which the
partial dependence is computed.</p>
</td></tr>
<tr><td><code id="partial_+3A_probs">probs</code></td>
<td>
<p>Numeric vector of probabilities with values in [0,1]. (Values up
to 2e-14 outside that range are accepted and moved to the nearby endpoint.)
Default is <code>1:9/10</code> which corresponds to the deciles of the predictor
variables. These specify which quantiles to use for the continuous predictors
listed in <code>pred.var</code> when <code>quantiles = TRUE</code>.</p>
</td></tr>
<tr><td><code id="partial_+3A_trim.outliers">trim.outliers</code></td>
<td>
<p>Logical indicating whether or not to trim off outliers
from the continuous predictors listed in <code>pred.var</code> (using the simple
boxplot method) before generating the grid of joint values for which the
partial dependence is computed. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="partial_+3A_type">type</code></td>
<td>
<p>Character string specifying the type of supervised learning.
Current options are <code>"auto"</code>, <code>"regression"</code> or
<code>"classification"</code>. If <code>type = "auto"</code> then <code>partial</code> will try
to extract the necessary information from <code>object</code>.</p>
</td></tr>
<tr><td><code id="partial_+3A_inv.link">inv.link</code></td>
<td>
<p>Function specifying the transformation to be applied to the
predictions before the partial dependence function is computed
(experimental). Default is <code>NULL</code> (i.e., no transformation). This option
is intended to be used for models that allow for non-Gaussian response
variables (e.g., counts). For these models, predictions are not typically
returned on the original response scale by default. For example, Poisson GBMs
typically return predictions on the log scale. In this case setting
<code>inv.link = exp</code> will return the partial dependence function on the
response (i.e., raw count) scale.</p>
</td></tr>
<tr><td><code id="partial_+3A_which.class">which.class</code></td>
<td>
<p>Integer specifying which column of the matrix of predicted
probabilities to use as the &quot;focus&quot; class. Default is to use the first class.
Only used for classification problems (i.e., when
<code>type = "classification"</code>).</p>
</td></tr>
<tr><td><code id="partial_+3A_prob">prob</code></td>
<td>
<p>Logical indicating whether or not partial dependence for
classification problems should be returned on the probability scale, rather
than the centered logit. If <code>FALSE</code>, the partial dependence function is
on a scale similar to the logit. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="partial_+3A_recursive">recursive</code></td>
<td>
<p>Logical indicating whether or not to use the weighted tree
traversal method described in Friedman (2001). This only applies to objects
that inherit from class <code>"gbm"</code>. Default is <code>TRUE</code> which is much
faster than the exact brute force approach used for all other models. (Based
on the C++ code behind <code><a href="gbm.html#topic+plot.gbm">plot.gbm</a></code>.)</p>
</td></tr>
<tr><td><code id="partial_+3A_plot">plot</code></td>
<td>
<p>Logical indicating whether to return a data frame containing the
partial dependence values (<code>FALSE</code>) or plot the partial dependence
function directly (<code>TRUE</code>). Default is <code>FALSE</code>. See
<code><a href="#topic+plotPartial">plotPartial</a></code> for plotting details.</p>
</td></tr>
<tr><td><code id="partial_+3A_plot.engine">plot.engine</code></td>
<td>
<p>Character string specifying which plotting engine to use
whenever <code>plot = TRUE</code>. Options include <code>"lattice"</code> (default) or
<code>"ggplot2"</code>.</p>
</td></tr>
<tr><td><code id="partial_+3A_smooth">smooth</code></td>
<td>
<p>Logical indicating whether or not to overlay a LOESS smooth.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="partial_+3A_rug">rug</code></td>
<td>
<p>Logical indicating whether or not to include a rug display on the
predictor axes. The tick marks indicate the min/max and deciles of the
predictor distributions. This helps reduce the risk of interpreting the
partial dependence plot outside the region of the data (i.e., extrapolating).
Only used when <code>plot = TRUE</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="partial_+3A_chull">chull</code></td>
<td>
<p>Logical indicating whether or not to restrict the values of the
first two variables in <code>pred.var</code> to lie within the convex hull of their
training values; this affects <code>pred.grid</code>. This helps reduce the risk of
interpreting the partial dependence plot outside the region of the data
(i.e., extrapolating).Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="partial_+3A_levelplot">levelplot</code></td>
<td>
<p>Logical indicating whether or not to use a false color level
plot (<code>TRUE</code>) or a 3-D surface (<code>FALSE</code>). Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="partial_+3A_contour">contour</code></td>
<td>
<p>Logical indicating whether or not to add contour lines to the
level plot. Only used when <code>levelplot = TRUE</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="partial_+3A_contour.color">contour.color</code></td>
<td>
<p>Character string specifying the color to use for the
contour lines when <code>contour = TRUE</code>. Default is <code>"white"</code>.</p>
</td></tr>
<tr><td><code id="partial_+3A_alpha">alpha</code></td>
<td>
<p>Numeric value in <code>[0, 1]</code> specifying the opacity alpha (
most useful when plotting ICE/c-ICE curves). Default is 1 (i.e., no
transparency). In fact, this option only affects ICE/c-ICE curves and level
plots.</p>
</td></tr>
<tr><td><code id="partial_+3A_train">train</code></td>
<td>
<p>An optional data frame, matrix, or sparse matrix containing the
original training data. This may be required depending on the class of
<code>object</code>. For objects that do not store a copy of the original training
data, this argument is required. For reasons discussed below, it is good
practice to always specify this argument.</p>
</td></tr>
<tr><td><code id="partial_+3A_cats">cats</code></td>
<td>
<p>Character string indicating which columns of <code>train</code> should
be treated as categorical variables. Only used when <code>train</code> inherits
from class <code>"matrix"</code> or <code>"dgCMatrix"</code>.</p>
</td></tr>
<tr><td><code id="partial_+3A_check.class">check.class</code></td>
<td>
<p>Logical indicating whether or not to make sure each column
in <code>pred.grid</code> has the correct class, levels, etc. Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="partial_+3A_progress">progress</code></td>
<td>
<p>Logical indicating whether or not to display a text-based
progress bar. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="partial_+3A_parallel">parallel</code></td>
<td>
<p>Logical indicating whether or not to run <code>partial</code> in
parallel using a backend provided by the <code>foreach</code> package. Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="partial_+3A_paropts">paropts</code></td>
<td>
<p>List containing additional options to be passed onto
<code><a href="foreach.html#topic+foreach">foreach</a></code> when <code>parallel = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, <code>partial</code> returns an object of class
<code>c("data.frame", "partial")</code>. If <code>ice = TRUE</code> and
<code>center = FALSE</code> then an object of class <code>c("data.frame", "ice")</code>
is returned. If <code>ice = TRUE</code> and <code>center = TRUE</code> then an object of
class <code>c("data.frame", "cice")</code> is returned. These three classes
determine the behavior of the <code>plotPartial</code> function which is
automatically called whenever <code>plot = TRUE</code>. Specifically, when
<code>plot = TRUE</code>, a <code>"trellis"</code> object is returned (see
<code><a href="lattice.html#topic+lattice">lattice</a></code> for details); the <code>"trellis"</code> object will
also include an additional attribute, <code>"partial.data"</code>, containing the
data displayed in the plot.
</p>


<h3>Note</h3>

<p>In some cases it is difficult for <code>partial</code> to extract the original
training data from <code>object</code>. In these cases an error message is
displayed requesting the user to supply the training data via the
<code>train</code> argument in the call to <code>partial</code>. In most cases where
<code>partial</code> can extract the required training data from <code>object</code>,
it is taken from the same environment in which <code>partial</code> is called.
Therefore, it is important to not change the training data used to construct
<code>object</code> before calling <code>partial</code>. This problem is completely
avoided when the training data are passed to the <code>train</code> argument in the
call to <code>partial</code>.
</p>
<p>It is recommended to call <code>partial</code> with <code>plot = FALSE</code> and store
the results. This allows for more flexible plotting, and the user will not
have to waste time calling <code>partial</code> again if the default plot is not
sufficient.
</p>
<p>It is possible to retrieve the last printed <code>"trellis"</code> object, such as
those produced by <code>plotPartial</code>, using <code>trellis.last.object()</code>.
</p>
<p>If <code>ice = TRUE</code> or the prediction function given to <code>pred.fun</code>
returns a prediction for each observation in <code>newdata</code>, then the result
will be a curve for each observation. These are called individual conditional
expectation (ICE) curves; see Goldstein et al. (2015) and
<code><a href="ICEbox.html#topic+ice">ice</a></code> for details.
</p>


<h3>References</h3>

<p>J. H. Friedman. Greedy function approximation: A gradient boosting machine.
<em>Annals of Statistics</em>, <b>29</b>: 1189-1232, 2001.
</p>
<p>Goldstein, A., Kapelner, A., Bleich, J., and Pitkin, E., Peeking Inside the
Black Box: Visualizing Statistical Learning With Plots of Individual
Conditional Expectation. (2014) <em>Journal of Computational and Graphical
Statistics</em>, <b>24</b>(1): 44-65, 2015.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#
# Regression example (requires randomForest package to run)
#

# Fit a random forest to the boston housing data
library(randomForest)
data (boston)  # load the boston housing data
set.seed(101)  # for reproducibility
boston.rf &lt;- randomForest(cmedv ~ ., data = boston)

# Using randomForest's partialPlot function
partialPlot(boston.rf, pred.data = boston, x.var = "lstat")

# Using pdp's partial function
head(partial(boston.rf, pred.var = "lstat"))  # returns a data frame
partial(boston.rf, pred.var = "lstat", plot = TRUE, rug = TRUE)

# The partial function allows for multiple predictors
partial(boston.rf, pred.var = c("lstat", "rm"), grid.resolution = 40,
        plot = TRUE, chull = TRUE, progress = TRUE)

# The plotPartial function offers more flexible plotting
pd &lt;- partial(boston.rf, pred.var = c("lstat", "rm"), grid.resolution = 40)
plotPartial(pd, levelplot = FALSE, zlab = "cmedv", drape = TRUE,
            colorkey = FALSE, screen = list(z = -20, x = -60))

# The autplot function can be used to produce graphics based on ggplot2
library(ggplot2)
autoplot(pd, contour = TRUE, legend.title = "Partial\ndependence")

#
# Individual conditional expectation (ICE) curves
#

# Use partial to obtain ICE/c-ICE curves
rm.ice &lt;- partial(boston.rf, pred.var = "rm", ice = TRUE)
plotPartial(rm.ice, rug = TRUE, train = boston, alpha = 0.2)
autoplot(rm.ice, center = TRUE, alpha = 0.2, rug = TRUE, train = boston)

#
# Classification example (requires randomForest package to run)
#

# Fit a random forest to the Pima Indians diabetes data
data (pima)  # load the boston housing data
set.seed(102)  # for reproducibility
pima.rf &lt;- randomForest(diabetes ~ ., data = pima, na.action = na.omit)

# Partial dependence of positive test result on glucose (default logit scale)
partial(pima.rf, pred.var = "glucose", plot = TRUE, chull = TRUE,
        progress = TRUE)

# Partial dependence of positive test result on glucose (probability scale)
partial(pima.rf, pred.var = "glucose", prob = TRUE, plot = TRUE,
        chull = TRUE, progress = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='pdp'>pdp: A general framework for constructing partial dependence (i.e., marginal
effect) plots from various types machine learning models in R.</h2><span id='topic+pdp'></span>

<h3>Description</h3>

<p>Partial dependence plots (PDPs) help visualize the relationship between a
subset of the features (typically 1-3) and the response while accounting for
the average effect of the other predictors in the model. They are
particularly effective with black box models like random forests and support
vector machines.
</p>


<h3>Details</h3>

<p>The development version can be found on GitHub: https://github.com/bgreenwell/pdp.
As of right now, <code>pdp</code> exports four functions:
</p>

<ul>
<li><p><code>partial</code> - construct partial dependence functions (i.e., objects of class <code>"partial"</code>) from various fitted model objects;
</p>
</li>
<li><p><code>plotPartial</code> - plot partial dependence functions (i.e., objects of class <code>"partial"</code>) using <code><a href="lattice.html#topic+lattice">lattice</a></code> graphics;
</p>
</li>
<li><p><code>autoplot</code> - plot partial dependence functions (i.e., objects of class <code>"partial"</code>) using <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> graphics;
</p>
</li>
<li><p><code>topPredictors</code> - extract most &quot;important&quot; predictors from various types of fitted models.
</p>
</li></ul>


<hr>
<h2 id='pima'>Pima Indians Diabetes Data</h2><span id='topic+pima'></span>

<h3>Description</h3>

<p>Diabetes test results collected by the the US National Institute of Diabetes
and Digestive and Kidney Diseases from a population of women who were at
least 21 years old, of Pima Indian heritage, and living near Phoenix,
Arizona. The data were taken directly from
<code><a href="mlbench.html#topic+PimaIndiansDiabetes2">PimaIndiansDiabetes2</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pima)
</code></pre>


<h3>Format</h3>

<p>A data frame with 768 observations on 9 variables.
</p>

<ul>
<li> <p><code>pregnant</code> Number of times pregnant.
</p>
</li>
<li> <p><code>glucose</code> Plasma glucose concentration (glucose tolerance test).
</p>
</li>
<li> <p><code>pressure</code> Diastolic blood pressure (mm Hg).
</p>
</li>
<li> <p><code>triceps</code> Triceps skin fold thickness (mm).
</p>
</li>
<li> <p><code>insulin</code> 2-Hour serum insulin (mu U/ml).
</p>
</li>
<li> <p><code>mass</code> Body mass index (weight in kg/(height in m)^2).
</p>
</li>
<li> <p><code>pedigree</code> Diabetes pedigree function.
</p>
</li>
<li> <p><code>age</code> Age (years).
</p>
</li>
<li> <p><code>diabetes</code> Factor indicating the diabetes test result (<code>neg</code>/<code>pos</code>).
</p>
</li></ul>



<h3>References</h3>

<p>Newman, D.J. &amp; Hettich, S. &amp; Blake, C.L. &amp; Merz, C.J. (1998). UCI Repository
of machine learning databases
[http://www.ics.uci.edu/~mlearn/MLRepository.html]. Irvine, CA: University of
California, Department of Information and Computer Science.
</p>
<p>Brian D. Ripley (1996), Pattern Recognition and Neural Networks, Cambridge
University Press, Cambridge.
</p>
<p>Grace Whaba, Chong Gu, Yuedong Wang, and Richard Chappell (1995), Soft
Classification a.k.a. Risk Estimation via Penalized Log Likelihood and
Smoothing Spline Analysis of Variance, in D. H. Wolpert (1995), The
Mathematics of Generalization, 331-359, Addison-Wesley, Reading, MA.
</p>
<p>Friedrich Leisch &amp; Evgenia Dimitriadou (2010). mlbench: Machine Learning
Benchmark Problems. R package version 2.1-1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(pima)

</code></pre>

<hr>
<h2 id='plotPartial'>Plotting Partial Dependence Functions</h2><span id='topic+plotPartial'></span><span id='topic+plotPartial.ice'></span><span id='topic+plotPartial.cice'></span><span id='topic+plotPartial.partial'></span>

<h3>Description</h3>

<p>Plots partial dependence functions (i.e., marginal effects) using
<code><a href="lattice.html#topic+lattice">lattice</a></code> graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPartial(object, ...)

## S3 method for class 'ice'
plotPartial(
  object,
  center = FALSE,
  plot.pdp = TRUE,
  pdp.col = "red2",
  pdp.lwd = 2,
  pdp.lty = 1,
  rug = FALSE,
  train = NULL,
  ...
)

## S3 method for class 'cice'
plotPartial(
  object,
  plot.pdp = TRUE,
  pdp.col = "red2",
  pdp.lwd = 2,
  pdp.lty = 1,
  rug = FALSE,
  train = NULL,
  ...
)

## S3 method for class 'partial'
plotPartial(
  object,
  center = FALSE,
  plot.pdp = TRUE,
  pdp.col = "red2",
  pdp.lwd = 2,
  pdp.lty = 1,
  smooth = FALSE,
  rug = FALSE,
  chull = FALSE,
  levelplot = TRUE,
  contour = FALSE,
  contour.color = "white",
  col.regions = NULL,
  number = 4,
  overlap = 0.1,
  train = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPartial_+3A_object">object</code></td>
<td>
<p>An object that inherits from the <code>"partial"</code> class.</p>
</td></tr>
<tr><td><code id="plotPartial_+3A_...">...</code></td>
<td>
<p>Additional optional arguments to be passed onto <code>dotplot</code>,
<code>levelplot</code>, <code>xyplot</code>, or <code>wireframe</code>.</p>
</td></tr>
<tr><td><code id="plotPartial_+3A_center">center</code></td>
<td>
<p>Logical indicating whether or not to produce centered ICE
curves (c-ICE curves). Only useful when <code>object</code> represents a set of ICE
curves; see <code><a href="#topic+partial">partial</a></code> for details. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotPartial_+3A_plot.pdp">plot.pdp</code></td>
<td>
<p>Logical indicating whether or not to plot the partial
dependence function on top of the ICE curves. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotPartial_+3A_pdp.col">pdp.col</code></td>
<td>
<p>Character string specifying the color to use for the partial
dependence function when <code>plot.pdp = TRUE</code>. Default is <code>"red"</code>.</p>
</td></tr>
<tr><td><code id="plotPartial_+3A_pdp.lwd">pdp.lwd</code></td>
<td>
<p>Integer specifying the line width to use for the partial
dependence function when <code>plot.pdp = TRUE</code>. Default is <code>1</code>. See
<code><a href="graphics.html#topic+par">par</a></code> for more details.</p>
</td></tr>
<tr><td><code id="plotPartial_+3A_pdp.lty">pdp.lty</code></td>
<td>
<p>Integer or character string specifying the line type to use
for the partial dependence function when  <code>plot.pdp = TRUE</code>. Default is
<code>1</code>. See <code><a href="graphics.html#topic+par">par</a></code> for more details.</p>
</td></tr>
<tr><td><code id="plotPartial_+3A_rug">rug</code></td>
<td>
<p>Logical indicating whether or not to include rug marks on the
predictor axes. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotPartial_+3A_train">train</code></td>
<td>
<p>Data frame containing the original training data. Only required
if <code>rug = TRUE</code> or <code>chull = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotPartial_+3A_smooth">smooth</code></td>
<td>
<p>Logical indicating whether or not to overlay a LOESS smooth.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotPartial_+3A_chull">chull</code></td>
<td>
<p>Logical indicating whether or not to restrict the first two
variables in <code>pred.var</code> to lie within the convex hull of their training
values; this affects <code>pred.grid</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotPartial_+3A_levelplot">levelplot</code></td>
<td>
<p>Logical indicating whether or not to use a false color level
plot (<code>TRUE</code>) or a 3-D surface (<code>FALSE</code>). Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotPartial_+3A_contour">contour</code></td>
<td>
<p>Logical indicating whether or not to add contour lines to the
level plot. Only used when <code>levelplot = TRUE</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotPartial_+3A_contour.color">contour.color</code></td>
<td>
<p>Character string specifying the color to use for the
contour lines when <code>contour = TRUE</code>. Default is <code>"white"</code>.</p>
</td></tr>
<tr><td><code id="plotPartial_+3A_col.regions">col.regions</code></td>
<td>
<p>Vector of colors to be passed on to
<code><a href="lattice.html#topic+levelplot">levelplot</a></code>'s <code>col.region</code> argument. Defaults to
<code>grDevices::hcl.colors(100)</code> (which is the same viridis color palette
used in the past).</p>
</td></tr>
<tr><td><code id="plotPartial_+3A_number">number</code></td>
<td>
<p>Integer specifying the number of conditional intervals to use
for the continuous panel variables. See <code><a href="graphics.html#topic+co.intervals">co.intervals</a></code>
and <code><a href="lattice.html#topic+equal.count">equal.count</a></code> for further details.</p>
</td></tr>
<tr><td><code id="plotPartial_+3A_overlap">overlap</code></td>
<td>
<p>The fraction of overlap of the conditioning variables. See
<code><a href="graphics.html#topic+co.intervals">co.intervals</a></code> and <code><a href="lattice.html#topic+equal.count">equal.count</a></code>
for further details.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#
# Regression example (requires randomForest package to run)
#

# Load required packages
library(gridExtra)  # for `grid.arrange()`
library(magrittr)  # for forward pipe operator `%&gt;%`
library(randomForest)

# Fit a random forest to the Boston housing data
data (boston)  # load the boston housing data
set.seed(101)  # for reproducibility
boston.rf &lt;- randomForest(cmedv ~ ., data = boston)

# Partial dependence of cmedv on lstat
boston.rf %&gt;%
  partial(pred.var = "lstat") %&gt;%
  plotPartial(rug = TRUE, train = boston)

# Partial dependence of cmedv on lstat and rm
boston.rf %&gt;%
  partial(pred.var = c("lstat", "rm"), chull = TRUE, progress = TRUE) %&gt;%
  plotPartial(contour = TRUE, legend.title = "rm")

# ICE curves and c-ICE curves
age.ice &lt;- partial(boston.rf, pred.var = "lstat", ice = TRUE)
p1 &lt;- plotPartial(age.ice, alpha = 0.1)
p2 &lt;- plotPartial(age.ice, center = TRUE, alpha = 0.1)
grid.arrange(p1, p2, ncol = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='topPredictors'>Extract Most &quot;Important&quot; Predictors (Experimental)</h2><span id='topic+topPredictors'></span><span id='topic+topPredictors.default'></span><span id='topic+topPredictors.train'></span>

<h3>Description</h3>

<p>Extract the most &quot;important&quot; predictors for regression and classification
models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topPredictors(object, n = 1L, ...)

## Default S3 method:
topPredictors(object, n = 1L, ...)

## S3 method for class 'train'
topPredictors(object, n = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topPredictors_+3A_object">object</code></td>
<td>
<p>A fitted model object of appropriate class (e.g., <code>"gbm"</code>,
<code>"lm"</code>, <code>"randomForest"</code>, etc.).</p>
</td></tr>
<tr><td><code id="topPredictors_+3A_n">n</code></td>
<td>
<p>Integer specifying the number of predictors to return. Default is
<code>1</code> meaning return the single most important predictor.</p>
</td></tr>
<tr><td><code id="topPredictors_+3A_...">...</code></td>
<td>
<p>Additional optional arguments to be passed onto
<code><a href="caret.html#topic+varImp">varImp</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the generic function <code><a href="caret.html#topic+varImp">varImp</a></code> to
calculate variable importance scores for each predictor. After that, they are
sorted at the names of the <code>n</code> highest scoring predictors are returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#
# Regression example (requires randomForest package to run)
#

Load required packages
library(ggplot2)
library(randomForest)

# Fit a random forest to the mtcars dataset
data(mtcars, package = "datasets")
set.seed(101)
mtcars.rf &lt;- randomForest(mpg ~ ., data = mtcars, mtry = 5, importance = TRUE)

# Topfour predictors
top4 &lt;- topPredictors(mtcars.rf, n = 4)

# Construct partial dependence functions for top four predictors
pd &lt;- NULL
for (i in top4) {
  tmp &lt;- partial(mtcars.rf, pred.var = i)
  names(tmp) &lt;- c("x", "y")
  pd &lt;- rbind(pd,  cbind(tmp, predictor = i))
}

# Display partial dependence functions
ggplot(pd, aes(x, y)) +
  geom_line() +
  facet_wrap(~ predictor, scales = "free") +
  theme_bw() +
  ylab("mpg")


## End(Not run)
</code></pre>

<hr>
<h2 id='trellis.last.object'>Retrieve the last trellis object</h2><span id='topic+trellis.last.object'></span>

<h3>Description</h3>

<p>See <code><a href="lattice.html#topic+trellis.last.object">trellis.last.object</a></code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trellis.last.object(..., prefix)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
