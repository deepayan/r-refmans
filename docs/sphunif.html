<!DOCTYPE html><html><head><title>Help for package sphunif</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sphunif}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sphunif-package'><p><code>sphunif</code>: Uniformity Tests on the Circle, Sphere, and</p>
Hypersphere</a></li>
<li><a href='#A_theta_x'><p>Surface area of the intersection of two hyperspherical caps</p></a></li>
<li><a href='#angles_to_sphere'><p>Conversion between angular and Cartesian coordinates of the</p>
(hyper)sphere</a></li>
<li><a href='#avail_tests'><p>Available circular and (hyper)spherical uniformity tests</p></a></li>
<li><a href='#beta_inc'><p>The incomplete beta function and its inverse</p></a></li>
<li><a href='#chisq'><p>Density and distribution of a chi squared</p></a></li>
<li><a href='#cir_coord_conv'><p>Transforming between polar and Cartesian coordinates</p></a></li>
<li><a href='#cir_gaps'><p>Circular gaps</p></a></li>
<li><a href='#cir_stat_Kuiper'><p>Statistics for testing circular uniformity</p></a></li>
<li><a href='#comets'><p>Comet orbits</p></a></li>
<li><a href='#craters'><p>Craters named by the IUA</p></a></li>
<li><a href='#ecdf_bin'><p>Efficient evaluation of the empirical cumulative distribution</p>
function</a></li>
<li><a href='#F_from_f'><p>Distribution and quantile functions from angular function</p></a></li>
<li><a href='#Gauss_Legen'><p>Gauss&ndash;Legendre quadrature</p></a></li>
<li><a href='#Gegenbauer'><p>Gegenbauer polynomials and coefficients</p></a></li>
<li><a href='#harmonics'><p>(Hyper)spherical harmonics</p></a></li>
<li><a href='#int_sph_MC'><p>Monte Carlo integration of functions on the (hyper)sphere</p></a></li>
<li><a href='#locdev'><p>Local projected alternatives to uniformity</p></a></li>
<li><a href='#p_Kolmogorov'><p>Asymptotic distributions for circular uniformity statistics</p></a></li>
<li><a href='#p_sph_stat_Bingham'><p>Asymptotic distributions for spherical uniformity statistics</p></a></li>
<li><a href='#planets'><p>Planet orbits</p></a></li>
<li><a href='#Pn'><p>Utilities for projected-ecdf statistics of spherical uniformity</p></a></li>
<li><a href='#proj_unif'><p>Projection of the spherical uniform distribution</p></a></li>
<li><a href='#Psi'><p>Shortest angles matrix</p></a></li>
<li><a href='#r_alt'><p>Sample non-uniformly distributed spherical data</p></a></li>
<li><a href='#r_unif'><p>Sample uniformly distributed circular and spherical data</p></a></li>
<li><a href='#rhea'><p>Rhea craters from Hirata (2016)</p></a></li>
<li><a href='#Sobolev'><p>Asymptotic distributions of Sobolev statistics of spherical uniformity</p></a></li>
<li><a href='#Sobolev_coefs'><p>Transformation between different coefficients in Sobolev statistics</p></a></li>
<li><a href='#sort_each_col'><p>Sort the columns of a matrix</p></a></li>
<li><a href='#sph_stat_Rayleigh'><p>Statistics for testing (hyper)spherical uniformity</p></a></li>
<li><a href='#sph_stat_Sobolev'><p>Finite Sobolev statistics for testing (hyper)spherical uniformity</p></a></li>
<li><a href='#unif_stat'><p>Circular and (hyper)spherical uniformity statistics</p></a></li>
<li><a href='#unif_stat_distr'><p>Null distributions for circular and (hyper)spherical uniformity</p>
statistics</a></li>
<li><a href='#unif_stat_MC'><p>Monte Carlo simulation of circular and (hyper)spherical uniformity</p>
statistics</a></li>
<li><a href='#unif_test'><p>Circular and (hyper)spherical uniformity tests</p></a></li>
<li><a href='#utils'><p>Low-level utilities for <span class="pkg">sphunif</span></p></a></li>
<li><a href='#venus'><p>Venus craters</p></a></li>
<li><a href='#wschisq'><p>Weighted sums of non-central chi squared random variables</p></a></li>
<li><a href='#wschisq_utils'><p>Utilities for weighted sums of non-central chi squared random</p>
variables</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Uniformity Tests on the Circle, Sphere, and Hypersphere</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-04</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of uniformity tests on the circle and
    (hyper)sphere. The main function of the package is unif_test(), which
    conveniently collects more than 30 tests for assessing uniformity on
    S^{p-1}={x in R^p : ||x||=1}, p &gt;= 2. The test statistics are implemented
    in the unif_stat() function, which allows computing several statistics to
    several samples within a single call, thus facilitating Monte Carlo
    experiments. Furthermore, the unif_stat_MC() function allows
    parallelizing them in a simple way. The asymptotic null distributions of
    the statistics are available through the function unif_stat_distr(). The
    core of 'sphunif' is coded in C++ by relying on the 'Rcpp' package.
    The package also provides several novel datasets and gives the
    replicability for the data application in García-Portugués,
    Navarro-Esteban and Cuesta-Albertos (2023) &lt;<a href="https://doi.org/10.48550/arXiv.2008.09897">doi:10.48550/arXiv.2008.09897</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>doFuture, doRNG, foreach, future, gsl, rotasym</td>
</tr>
<tr>
<td>Suggests:</td>
<td>CompQuadForm, dgof, goftest, knitr, markdown, mvtnorm,
numDeriv, progress, progressr, rmarkdown, scatterplot3d,
testthat, viridisLite</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/egarpor/sphunif">https://github.com/egarpor/sphunif</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/egarpor/sphunif">https://github.com/egarpor/sphunif</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-04 19:21:20 UTC; Eduardo</td>
</tr>
<tr>
<td>Author:</td>
<td>Eduardo García-Portugués
    <a href="https://orcid.org/0000-0002-9224-4111"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Thomas Verdebout <a href="https://orcid.org/0000-0002-3277-9587"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Paula Navarro [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eduardo García-Portugués &lt;edgarcia@est-econ.uc3m.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-04 19:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='sphunif-package'><code>sphunif</code>: Uniformity Tests on the Circle, Sphere, and
Hypersphere</h2><span id='topic+sphunif-package'></span><span id='topic+sphunif'></span>

<h3>Description</h3>

<p>Implementation of uniformity tests on the circle and
(hyper)sphere. The main function of the package is <code><a href="#topic+unif_test">unif_test</a></code>,
which conveniently collects more than 30 tests for assessing uniformity on
<code class="reqn">S^{p-1}=\{{\bf x}\in R^p:||{\bf x}||=1\}</code>, <code class="reqn">p\ge 2</code>. The test statistics are
implemented in the <code><a href="#topic+unif_stat">unif_stat</a></code> function, which allows computing
several statistics to different samples within a single call, thus
facilitating Monte Carlo experiments. Furthermore, the
<code><a href="#topic+unif_stat_MC">unif_stat_MC</a></code> function allows parallelizing them in
a simple way. The asymptotic null distributions of the statistics are
available through the function <code><a href="#topic+unif_stat_distr">unif_stat_distr</a></code>. The core of
<code><a href="#topic+sphunif-package">sphunif-package</a></code> is coded in C++ by relying on the
<code><a href="Rcpp.html#topic+Rcpp-package">Rcpp-package</a></code>. The package also provides several
novel datasets and gives the replicability for the data application
in García-Portugués, Navarro-Esteban and Cuesta-Albertos (2023)
&lt;doi:10.3150/21-BEJ1454&gt;.
</p>


<h3>Author(s)</h3>

<p>Eduardo García-Portugués and Thomas Verdebout.
</p>


<h3>References</h3>

<p>García-Portugués, E. and Verdebout, T. (2018) An overview of uniformity
tests on the hypersphere. <em>arXiv:1804.00286</em>.
<a href="https://arxiv.org/abs/1804.00286">https://arxiv.org/abs/1804.00286</a>.
</p>
<p>García-Portugués, E., Navarro-Esteban, P., Cuesta-Albertos, J. A. (2023)
On a projection-based class of uniformity tests on the hypersphere.
<em>Bernoulli</em>, 29(1):181&ndash;204. <a href="https://doi.org/10.3150/21-BEJ1454">doi:10.3150/21-BEJ1454</a>.
</p>
<p>García-Portugués, E., Navarro-Esteban, P., and Cuesta-Albertos, J. A. (2021).
A Cramér–von Mises test of uniformity on the hypersphere. In Balzano, S.,
Porzio, G. C., Salvatore, R., Vistocco, D., and Vichi, M. (Eds.), <em>
Statistical Learning and Modeling in Data Analysis</em>, Studies in
Classification, Data Analysis and Knowledge Organization, pp. 107–-116.
Springer, Cham. <a href="https://doi.org/10.1007/978-3-030-69944-4_12">doi:10.1007/978-3-030-69944-4_12</a>.
</p>
<p>García-Portugués, E., Paindaveine, D., and Verdebout, T. (2021). On the
power of Sobolev tests for isotropy under local rotationally symmetric
alternatives. <em>arXiv:2108.09874</em>. <a href="https://arxiv.org/abs/2108.09874">https://arxiv.org/abs/2108.09874</a>
</p>

<hr>
<h2 id='A_theta_x'>Surface area of the intersection of two hyperspherical caps</h2><span id='topic+A_theta_x'></span>

<h3>Description</h3>

<p>Computation of
</p>
<p style="text-align: center;"><code class="reqn">A_x(\theta_{ij}) := \frac{1}{\omega_p}
\int_{S^{p - 1}} 1_{\{{\bf X}_i'\boldsymbol\gamma \le x,
{\bf X}_j'\boldsymbol\gamma \le x\}}\,\mathrm{d}\boldsymbol\gamma,</code>
</p>

<p>where <code class="reqn">\theta_{ij} := \cos^{-1}({\bf X}_i'{\bf X}_j)
\in [0, \pi]</code>,
<code class="reqn">x \in [-1, 1]</code>, and <code class="reqn">\omega_{p}</code> is the surface area of
<code class="reqn">S^{p - 1}</code>. <code class="reqn">A_x(\theta_{ij})</code> is the proportion of surface area
of <code class="reqn">S^{p - 1}</code> covered by the intersection of two hyperspherical caps
centered at <code class="reqn">{\bf X}_i</code> and <code class="reqn">{\bf X}_j</code> and with
common solid angle <code class="reqn">\pi - \cos^{-1}(x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>A_theta_x(theta, x, p, N = 160L, as_matrix = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="A_theta_x_+3A_theta">theta</code></td>
<td>
<p>vector with values in <code class="reqn">[0, \pi]</code>.</p>
</td></tr>
<tr><td><code id="A_theta_x_+3A_x">x</code></td>
<td>
<p>vector with values in <code class="reqn">[-1, 1]</code>.</p>
</td></tr>
<tr><td><code id="A_theta_x_+3A_p">p</code></td>
<td>
<p>integer giving the dimension of the ambient space <code class="reqn">R^p</code> that
contains <code class="reqn">S^{p-1}</code>.</p>
</td></tr>
<tr><td><code id="A_theta_x_+3A_n">N</code></td>
<td>
<p>number of points used in the
<a href="#topic+Gauss_Legen_nodes">Gauss-Legendre quadrature</a>. Defaults to
<code>160</code>.</p>
</td></tr>
<tr><td><code id="A_theta_x_+3A_as_matrix">as_matrix</code></td>
<td>
<p>return a matrix with the values of <code class="reqn">A_x(\theta)</code> on
the grid formed by <code>theta</code> and <code>x</code>? If <code>FALSE</code>,
<code class="reqn">A_x(\theta)</code> is evaluated on <code>theta</code> and <code>x</code> if they equal
in size. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See García-Portugués et al. (2023) for more details about the
<code class="reqn">A_x(\theta)</code> function.
</p>


<h3>Value</h3>

<p>A matrix of size <code>c(length(theta), length(x))</code> containing the
evaluation of <code class="reqn">A_x(\theta)</code> if <code>as_matrix = TRUE</code>. Otherwise,
a vector of size <code>c(length(theta)</code> if <code>theta</code> and <code>x</code> equal
in size.
</p>


<h3>References</h3>

<p>García-Portugués, E., Navarro-Esteban, P., Cuesta-Albertos, J. A. (2023)
On a projection-based class of uniformity tests on the hypersphere.
<em>Bernoulli</em>, 29(1):181&ndash;204. <a href="https://doi.org/10.3150/21-BEJ1454">doi:10.3150/21-BEJ1454</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot A_x(theta) for several dimensions and x's
A_lines &lt;- function(x, th = seq(0, pi, l = 200)) {

  plot(th, A_theta_x(theta = th, x = x, p = 2), type = "l",
       col = 1, ylim = c(0, 1.25), main = paste("x =", x),
       ylab = expression(A[x](theta)),
       xlab = expression(theta), axes = FALSE)
  axis(1, at = c(0, pi / 4, pi / 2, 3 * pi / 4, pi),
       labels = expression(0, pi / 4, pi / 2, 3 * pi / 4, pi))
  axis(2); box()
  abline(h = c(0, 1), lty = 2)
  lines(th, A_theta_x(theta = th, x = x, p = 3), col = 2)
  lines(th, A_theta_x(theta = th, x = x, p = 4), col = 3)
  lines(th, A_theta_x(theta = th, x = x, p = 5), col = 4)
  legend("top", lwd = 2, legend = paste("p =", 2:5),
         col = 1:4, cex = 0.75, horiz = TRUE)

}
old_par &lt;- par(mfrow = c(2, 3))
A_lines(x = -0.75)
A_lines(x = -0.25)
A_lines(x = 0)
A_lines(x = 0.25)
A_lines(x = 0.5)
A_lines(x = 0.75)
par(old_par)

# As surface of (theta, x) for several dimensions
A_surf &lt;- function(p, x = seq(-1, 1, l = 201), th = seq(0, pi, l = 201)) {

  col &lt;- c("white", viridisLite::viridis(20))
  breaks &lt;- c(-1, seq(1e-15, 1, l = 21))
  A &lt;- A_theta_x(theta = th, x = x, p = p)
  image(th, x, A, main = paste("p =", p), col = col, breaks = breaks,
        xlab = expression(theta), axes = FALSE)
  axis(1, at = c(0, pi / 4, pi / 2, 3 * pi / 4, pi),
       labels = expression(0, pi / 4, pi / 2, 3 * pi / 4, pi))
  axis(2); box()
  contour(th, x, A, levels = breaks, add = TRUE)

}
old_par &lt;- par(mfrow = c(2, 2))
A_surf(p = 2)
A_surf(p = 3)
A_surf(p = 4)
A_surf(p = 5)
par(old_par)

# No matrix return
th &lt;- seq(0, pi, l = 5)
x &lt;- seq(-1, 1, l = 5)
diag(A_theta_x(theta = th, x = x, p = 2))
A_theta_x(theta = th, x = x, p = 2, as_matrix = FALSE)
</code></pre>

<hr>
<h2 id='angles_to_sphere'>Conversion between angular and Cartesian coordinates of the
(hyper)sphere</h2><span id='topic+angles_to_sphere'></span><span id='topic+sphere_to_angles'></span>

<h3>Description</h3>

<p>Transforms the angles <code class="reqn">(\theta_1,\ldots,\theta_{p-1})'</code> in
<code class="reqn">[0,\pi)^{p-2}\times[-\pi,\pi)</code> into the Cartesian coordinates
</p>
<p style="text-align: center;"><code class="reqn">(\cos(x_1),\sin(x_1)\cos(x_2),\ldots,
\sin(x_1)\cdots\sin(x_{p-2})\cos(x_{p-1}),
\sin(x_1)\cdots\sin(x_{p-2})\sin(x_{p-1}))'</code>
</p>

<p>of <code class="reqn">S^{p-1}</code>, and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angles_to_sphere(theta)

sphere_to_angles(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angles_to_sphere_+3A_theta">theta</code></td>
<td>
<p>matrix of size <code>c(n, p - 1)</code> with the angles.</p>
</td></tr>
<tr><td><code id="angles_to_sphere_+3A_x">x</code></td>
<td>
<p>matrix of size <code>c(n, p)</code> with the Cartesian coordinates.
Assumed to be of unit norm by rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>angles_to_sphere</code>, the matrix <code>x</code>. For
<code>sphere_to_angles</code>, the matrix <code>theta</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Check changes of coordinates
sphere_to_angles(angles_to_sphere(c(pi / 2, 0, pi)))
sphere_to_angles(angles_to_sphere(rbind(c(pi / 2, 0, pi), c(pi, pi / 2, 0))))
angles_to_sphere(sphere_to_angles(c(0, sqrt(0.5), sqrt(0.1), sqrt(0.4))))
angles_to_sphere(sphere_to_angles(
  rbind(c(0, sqrt(0.5), sqrt(0.1), sqrt(0.4)),
        c(0, sqrt(0.5), sqrt(0.5), 0),
        c(0, 1, 0, 0),
        c(0, 0, 0, -1),
        c(0, 0, 1, 0))))

# Circle
sphere_to_angles(angles_to_sphere(0))
sphere_to_angles(angles_to_sphere(cbind(0:3)))
angles_to_sphere(cbind(sphere_to_angles(rbind(c(0, 1), c(1, 0)))))
angles_to_sphere(cbind(sphere_to_angles(rbind(c(0, 1)))))
</code></pre>

<hr>
<h2 id='avail_tests'>Available circular and (hyper)spherical uniformity tests</h2><span id='topic+avail_tests'></span><span id='topic+avail_cir_tests'></span><span id='topic+avail_sph_tests'></span>

<h3>Description</h3>

<p>Listing of the tests implemented in the <code><a href="#topic+sphunif">sphunif</a></code>
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avail_cir_tests

avail_sph_tests
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 33.
</p>
<p>An object of class <code>character</code> of length 18.
</p>


<h3>Value</h3>

<p>A character vector whose elements are valid inputs for the
<code>type</code> argument in <code><a href="#topic+unif_test">unif_test</a></code>, <code><a href="#topic+unif_stat">unif_stat</a></code>,
<code><a href="#topic+unif_stat_distr">unif_stat_distr</a></code>, and <code><a href="#topic+unif_stat_MC">unif_stat_MC</a></code>.
<code>avail_cir_tests</code> provides the available circular tests and
<code>avail_sph_tests</code> the (hyper)spherical tests.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Circular tests
avail_cir_tests

# Spherical tests
avail_sph_tests
</code></pre>

<hr>
<h2 id='beta_inc'>The incomplete beta function and its inverse</h2><span id='topic+beta_inc'></span><span id='topic+beta_inc_inv'></span>

<h3>Description</h3>

<p>Computes the incomplete beta function
</p>
<p style="text-align: center;"><code class="reqn">I_x(a,b):=\int_0^x u^{a-1}(1-u)^{b-1}\,d\mathrm{u},\quad a,b&gt;0</code>
</p>

<p>and its inverse function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta_inc(x, a, b, lower_tail = TRUE, log = FALSE)

beta_inc_inv(u, a, b, lower_tail = TRUE, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta_inc_+3A_x">x</code></td>
<td>
<p>a vector of size <code>nx</code> or a matrix of size <code>c(nx, 1)</code>.</p>
</td></tr>
<tr><td><code id="beta_inc_+3A_a">a</code>, <code id="beta_inc_+3A_b">b</code></td>
<td>
<p>scalars giving the parameters of the beta function.</p>
</td></tr>
<tr><td><code id="beta_inc_+3A_lower_tail">lower_tail</code></td>
<td>
<p>accumulate the probability from the lower tail? If
<code>FALSE</code>, the probability is accumulated from the <em>upper</em> tail.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="beta_inc_+3A_log">log</code></td>
<td>
<p>use log-scale? If <code>TRUE</code>, returns the logarithm of the
incomplete beta function and uses log-scale for <code>u</code> in <code>beta_inc</code>.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="beta_inc_+3A_u">u</code></td>
<td>
<p>a vector of probabilities of size <code>nu</code> or a matrix of size
<code>c(nu, 1)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions are mere wrappers to R's internal <code>pbeta</code> and
<code>qbeta</code> functions.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>beta_inc</code>: a matrix of size <code>c(nx, 1)</code> with the
evaluation of the incomplete beta function at <code>x</code>.
</p>
</li>
<li> <p><code>beta_inc_inv</code>: a matrix of size <code>c(nu, 1)</code> with the
evaluation of the inverse incomplete beta function at <code>u</code>.
</p>
</li></ul>


<hr>
<h2 id='chisq'>Density and distribution of a chi squared</h2><span id='topic+chisq'></span><span id='topic+d_chisq'></span><span id='topic+p_chisq'></span>

<h3>Description</h3>

<p>Computation of the density and distribution functions of a chi
squared.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_chisq(x, df, ncp = 0L)

p_chisq(x, df, ncp = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chisq_+3A_x">x</code></td>
<td>
<p>a vector of size <code>nx</code> or a matrix of size <code>c(nx, 1)</code>.</p>
</td></tr>
<tr><td><code id="chisq_+3A_df">df</code></td>
<td>
<p>degrees of freedom.</p>
</td></tr>
<tr><td><code id="chisq_+3A_ncp">ncp</code></td>
<td>
<p>non-centrality parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size <code>c(nx, 1)</code> with the evaluation of the
density or distribution function at <code>x</code>.
</p>

<hr>
<h2 id='cir_coord_conv'>Transforming between polar and Cartesian coordinates</h2><span id='topic+cir_coord_conv'></span><span id='topic+Theta_to_X'></span><span id='topic+X_to_Theta'></span>

<h3>Description</h3>

<p>Transformation between a matrix <code>Theta</code> containing
<code>M</code> circular samples of size <code>n</code> on <code class="reqn">[0, 2\pi)</code> and an array
<code>X</code> containing the associated Cartesian coordinates on
<code class="reqn">S^1:=\{{\bf x}\in R^2:||{\bf x}||=1\}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Theta_to_X(Theta)

X_to_Theta(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cir_coord_conv_+3A_theta">Theta</code></td>
<td>
<p>a <b>matrix</b> of size <code>c(n, M)</code> with <code>M</code> samples
of size <code>n</code> of circular data on <code class="reqn">[0, 2\pi)</code>. Must not contain
<code>NA</code>'s.</p>
</td></tr>
<tr><td><code id="cir_coord_conv_+3A_x">X</code></td>
<td>
<p>an <b>array</b> of size <code>c(n, 2, M)</code> containing the Cartesian
coordinates of <code>M</code> samples of size <code>n</code> of directions on
<code class="reqn">S^{1}</code>. Must not contain <code>NA</code>'s.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>Theta_to_X</code>: the corresponding <code>X</code>.
</p>
</li>
<li> <p><code>X_to_Theta</code>: the corresponding <code>Theta</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Sample
Theta &lt;- r_unif_cir(n = 10, M = 2)
X &lt;- r_unif_sph(n = 10, p = 2, M = 2)

# Check equality
sum(abs(X - Theta_to_X(X_to_Theta(X))))
sum(abs(Theta - X_to_Theta(Theta_to_X(Theta))))
</code></pre>

<hr>
<h2 id='cir_gaps'>Circular gaps</h2><span id='topic+cir_gaps'></span>

<h3>Description</h3>

<p>Computation of the circular gaps of an angular sample
<code class="reqn">\Theta_1,\ldots,\Theta_n</code> on <code class="reqn">[0, 2\pi)</code>, defined as
</p>
<p style="text-align: center;"><code class="reqn">\Theta_{(2)} - \Theta_{(1)},\ldots,\Theta_{(n)} - \Theta_{(n - 1)},
2\pi - \Theta_{(n)} - \Theta_{(1)},</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">0 \le \Theta_{(1)} \le \Theta_{(2)} \le \ldots \le
\Theta_{(n)} \le 2\pi.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>cir_gaps(Theta, sorted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cir_gaps_+3A_theta">Theta</code></td>
<td>
<p>a <b>matrix</b> of size <code>c(n, M)</code> with <code>M</code> samples
of size <code>n</code> of circular data on <code class="reqn">[0, 2\pi)</code>. Must not contain
<code>NA</code>'s.</p>
</td></tr>
<tr><td><code id="cir_gaps_+3A_sorted">sorted</code></td>
<td>
<p>are the columns of <code>Theta</code> sorted increasingly? If
<code>TRUE</code>, performance is improved. If <code>FALSE</code> (default), each
column of <code>Theta</code> is sorted internally.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size <code>c(n, M)</code> containing the <code>n</code> circular
gaps for each of the <code>M</code> circular samples.
</p>


<h3>Warning</h3>

<p>Be careful on avoiding the next bad usages of <code>cir_gaps</code>, which will
produce spurious results:
</p>

<ul>
<li><p> The entries of <code>Theta</code> are <em>not</em> in <code class="reqn">[0, 2\pi)</code>.
</p>
</li>
<li> <p><code>Theta</code> is <em>not</em> sorted increasingly when
<code>data_sorted = TRUE</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>Theta &lt;- cbind(c(pi, 0, 3 * pi / 2), c(0, 3 * pi / 2, pi), c(5, 3, 1))
cir_gaps(Theta)
</code></pre>

<hr>
<h2 id='cir_stat_Kuiper'>Statistics for testing circular uniformity</h2><span id='topic+cir_stat_Kuiper'></span><span id='topic+cir_stat_Watson'></span><span id='topic+cir_stat_Watson_1976'></span><span id='topic+cir_stat_Range'></span><span id='topic+cir_stat_Rao'></span><span id='topic+cir_stat_Greenwood'></span><span id='topic+cir_stat_Log_gaps'></span><span id='topic+cir_stat_Vacancy'></span><span id='topic+cir_stat_Max_uncover'></span><span id='topic+cir_stat_Num_uncover'></span><span id='topic+cir_stat_Gini'></span><span id='topic+cir_stat_Gini_squared'></span><span id='topic+cir_stat_Ajne'></span><span id='topic+cir_stat_Rothman'></span><span id='topic+cir_stat_Hodges_Ajne'></span><span id='topic+cir_stat_Cressie'></span><span id='topic+cir_stat_FG01'></span><span id='topic+cir_stat_Rayleigh'></span><span id='topic+cir_stat_Bingham'></span><span id='topic+cir_stat_Hermans_Rasson'></span><span id='topic+cir_stat_Gine_Gn'></span><span id='topic+cir_stat_Gine_Fn'></span><span id='topic+cir_stat_Pycke'></span><span id='topic+cir_stat_Pycke_q'></span><span id='topic+cir_stat_Bakshaev'></span><span id='topic+cir_stat_Riesz'></span><span id='topic+cir_stat_PCvM'></span><span id='topic+cir_stat_PRt'></span><span id='topic+cir_stat_PAD'></span><span id='topic+cir_stat_Poisson'></span><span id='topic+cir_stat_Softmax'></span><span id='topic+cir_stat_CCF09'></span><span id='topic+cir_stat'></span>

<h3>Description</h3>

<p>Low-level implementation of several statistics for assessing
circular uniformity on <code class="reqn">[0, 2\pi)</code> or, equivalently,
<code class="reqn">S^1:=\{{\bf x}\in R^2:||{\bf x}||=1\}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cir_stat_Kuiper(Theta, sorted = FALSE, KS = FALSE, Stephens = FALSE)

cir_stat_Watson(Theta, sorted = FALSE, CvM = FALSE, Stephens = FALSE)

cir_stat_Watson_1976(Theta, sorted = FALSE, minus = FALSE)

cir_stat_Range(Theta, sorted = FALSE, gaps_in_Theta = FALSE,
  max_gap = TRUE)

cir_stat_Rao(Theta, sorted = FALSE, gaps_in_Theta = FALSE)

cir_stat_Greenwood(Theta, sorted = FALSE, gaps_in_Theta = FALSE)

cir_stat_Log_gaps(Theta, sorted = FALSE, gaps_in_Theta = FALSE,
  abs_val = TRUE)

cir_stat_Vacancy(Theta, a = 2 * pi, sorted = FALSE,
  gaps_in_Theta = FALSE)

cir_stat_Max_uncover(Theta, a = 2 * pi, sorted = FALSE,
  gaps_in_Theta = FALSE)

cir_stat_Num_uncover(Theta, a = 2 * pi, sorted = FALSE,
  gaps_in_Theta = FALSE, minus_val = TRUE)

cir_stat_Gini(Theta, sorted = FALSE, gaps_in_Theta = FALSE)

cir_stat_Gini_squared(Theta, sorted = FALSE, gaps_in_Theta = FALSE)

cir_stat_Ajne(Theta, Psi_in_Theta = FALSE)

cir_stat_Rothman(Theta, Psi_in_Theta = FALSE, t = 1/3)

cir_stat_Hodges_Ajne(Theta, asymp_std = FALSE, sorted = FALSE,
  use_Cressie = TRUE)

cir_stat_Cressie(Theta, t = 1/3, sorted = FALSE)

cir_stat_FG01(Theta, sorted = FALSE)

cir_stat_Rayleigh(Theta, m = 1L)

cir_stat_Bingham(Theta)

cir_stat_Hermans_Rasson(Theta, Psi_in_Theta = FALSE)

cir_stat_Gine_Gn(Theta, Psi_in_Theta = FALSE)

cir_stat_Gine_Fn(Theta, Psi_in_Theta = FALSE)

cir_stat_Pycke(Theta, Psi_in_Theta = FALSE)

cir_stat_Pycke_q(Theta, Psi_in_Theta = FALSE, q = 0.5)

cir_stat_Bakshaev(Theta, Psi_in_Theta = FALSE)

cir_stat_Riesz(Theta, Psi_in_Theta = FALSE, s = 1)

cir_stat_PCvM(Theta, Psi_in_Theta = FALSE)

cir_stat_PRt(Theta, Psi_in_Theta = FALSE, t = 1/3)

cir_stat_PAD(Theta, Psi_in_Theta = FALSE, AD = FALSE, sorted = FALSE)

cir_stat_Poisson(Theta, Psi_in_Theta = FALSE, rho = 0.5)

cir_stat_Softmax(Theta, Psi_in_Theta = FALSE, kappa = 1)

cir_stat_CCF09(Theta, dirs, K_CCF09 = 25L, original = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cir_stat_Kuiper_+3A_theta">Theta</code></td>
<td>
<p>a <b>matrix</b> of size <code>c(n, M)</code> with <code>M</code> samples
of size <code>n</code> of circular data on <code class="reqn">[0, 2\pi)</code>. Must not contain
<code>NA</code>'s.</p>
</td></tr>
<tr><td><code id="cir_stat_Kuiper_+3A_sorted">sorted</code></td>
<td>
<p>are the columns of <code>Theta</code> sorted increasingly? If
<code>TRUE</code>, performance is improved. If <code>FALSE</code> (default), each
column of <code>Theta</code> is sorted internally.</p>
</td></tr>
<tr><td><code id="cir_stat_Kuiper_+3A_ks">KS</code></td>
<td>
<p>compute the Kolmogorov-Smirnov statistic (which is
<em>not</em> invariant under origin shifts) instead of the Kuiper statistic?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cir_stat_Kuiper_+3A_stephens">Stephens</code></td>
<td>
<p>compute Stephens (1970) modification so that the null
distribution of the is less dependent on the sample size? The modification
does not alter the test decision.</p>
</td></tr>
<tr><td><code id="cir_stat_Kuiper_+3A_cvm">CvM</code></td>
<td>
<p>compute the Cramér-von Mises statistic (which is <em>not</em>
invariant under origin shifts) instead of the Watson statistic? Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cir_stat_Kuiper_+3A_minus">minus</code></td>
<td>
<p>compute the invariant <code class="reqn">D_n^-</code> instead of <code class="reqn">D_n^+</code>?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cir_stat_Kuiper_+3A_gaps_in_theta">gaps_in_Theta</code></td>
<td>
<p>does <code>Theta</code> contain the matrix of
<em>circular gaps</em> that is obtained with <br /><code><a href="#topic+cir_gaps">cir_gaps</a>(Theta)</code>?
If <code>FALSE</code> (default), the circular gaps are computed internally.</p>
</td></tr>
<tr><td><code id="cir_stat_Kuiper_+3A_max_gap">max_gap</code></td>
<td>
<p>compute the maximum gap for the range statistic? If
<code>TRUE</code> (default), rejection happens for <em>large</em> values of
the statistic, which is consistent with the rest of tests. Otherwise,
the minimum gap is computed and rejection happens for <em>low</em> values.</p>
</td></tr>
<tr><td><code id="cir_stat_Kuiper_+3A_abs_val">abs_val</code></td>
<td>
<p>return the absolute value of the Darling's log gaps
statistic? If <code>TRUE</code> (default), rejection happens for <em>large</em>
values of the statistic, which is consistent with the rest of tests.
Otherwise, the signed statistic is computed and rejection happens for
large <em>absolute</em> values.</p>
</td></tr>
<tr><td><code id="cir_stat_Kuiper_+3A_a">a</code></td>
<td>
<p>either: </p>

<ul>
<li> <p><code class="reqn">a_n = a / n</code> parameter used in the length of the arcs
of the coverage-based tests. Must be positive. Defaults to <code>2 * pi</code>.
</p>
</li>
<li> <p><code class="reqn">a</code> parameter for the Stereo test, a real in <code class="reqn">[-1, 1]</code>.
Defaults to <code>0</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="cir_stat_Kuiper_+3A_minus_val">minus_val</code></td>
<td>
<p>return the negative value of the (standardized) number of
uncovered spacings? If <code>TRUE</code> (default), rejection happens for
<em>large</em> values of the statistic, which is consistent with the rest of
tests. Otherwise, rejection happens for <em>low</em> values.</p>
</td></tr>
<tr><td><code id="cir_stat_Kuiper_+3A_psi_in_theta">Psi_in_Theta</code></td>
<td>
<p>does <code>Theta</code> contain the shortest angles matrix
<code class="reqn">\boldsymbol\Psi</code> that is obtained with
<br /><code><a href="#topic+Psi_mat">Psi_mat</a>(array(Theta, dim = c(n, 1, M)))</code>? If <code>FALSE</code>
(default), <code class="reqn">\boldsymbol\Psi</code> is computed internally.</p>
</td></tr>
<tr><td><code id="cir_stat_Kuiper_+3A_t">t</code></td>
<td>
<p><code class="reqn">t</code> parameter for the Rothman and Cressie tests, a real in
<code class="reqn">(0, 1)</code>. Defaults to <code>1 / 3</code>.</p>
</td></tr>
<tr><td><code id="cir_stat_Kuiper_+3A_asymp_std">asymp_std</code></td>
<td>
<p>normalize the Hodges-Ajne statistic in terms of its
asymptotic distribution? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cir_stat_Kuiper_+3A_use_cressie">use_Cressie</code></td>
<td>
<p>compute the Hodges-Ajne statistic as a particular case
of the Cressie statistic? Defaults to <code>TRUE</code> as it is more efficient.
If <code>FALSE</code>, the geometric construction in Ajne (1968) is employed.</p>
</td></tr>
<tr><td><code id="cir_stat_Kuiper_+3A_m">m</code></td>
<td>
<p>integer <code class="reqn">m</code> for the <code class="reqn">m</code>-modal Rayleigh test. Defaults to
<code>m = 1</code> (the standard Rayleigh test).</p>
</td></tr>
<tr><td><code id="cir_stat_Kuiper_+3A_q">q</code></td>
<td>
<p><code class="reqn">q</code> parameter for the Pycke &quot;<code class="reqn">q</code>-test&quot;, a real in
<code class="reqn">(0, 1)</code>. Defaults to <code>1 / 2</code>.</p>
</td></tr>
<tr><td><code id="cir_stat_Kuiper_+3A_s">s</code></td>
<td>
<p><code class="reqn">s</code> parameter for the <code class="reqn">s</code>-Riesz test, a real in
<code class="reqn">(0, 2)</code>. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="cir_stat_Kuiper_+3A_ad">AD</code></td>
<td>
<p>compute the Anderson-Darling statistic (which is <em>not</em>
invariant under origin shifts) instead of the Projected Anderson-Darling
statistic? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cir_stat_Kuiper_+3A_rho">rho</code></td>
<td>
<p><code class="reqn">\rho</code> parameter for the Poisson test, a real in
<code class="reqn">[0, 1)</code>. Defaults to <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="cir_stat_Kuiper_+3A_kappa">kappa</code></td>
<td>
<p><code class="reqn">\kappa</code> parameter for the Softmax test, a
non-negative real. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="cir_stat_Kuiper_+3A_dirs">dirs</code></td>
<td>
<p>a matrix of size <code>c(n_proj, 2)</code> containing <code>n_proj</code>
random directions (in Cartesian coordinates) on <code class="reqn">S^1</code> to perform the
CCF09 test.</p>
</td></tr>
<tr><td><code id="cir_stat_Kuiper_+3A_k_ccf09">K_CCF09</code></td>
<td>
<p>integer giving the truncation of the series present in the
asymptotic distribution of the Kolmogorov-Smirnov statistic. Defaults to
<code>25</code>.</p>
</td></tr>
<tr><td><code id="cir_stat_Kuiper_+3A_original">original</code></td>
<td>
<p>return the CCF09 statistic as originally defined?
If <code>FALSE</code> (default), a faster and equivalent statistic is computed,
and rejection happens for <em>large</em> values of the statistic, which is
consistent with the rest of tests. Otherwise, rejection happens for
<em>low</em> values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Descriptions and references for most of the statistics are available
in García-Portugués and Verdebout (2018).
</p>
<p>The statistics <code>cir_stat_PCvM</code> and <code>cir_stat_PRt</code> are provided
for the sake of completion, but they equal the more efficiently-implemented
statistics <code>2 * cir_stat_Watson</code> and <code>cir_stat_Rothman</code>,
respectively.
</p>


<h3>Value</h3>

<p>A matrix of size <code>c(M, 1)</code> containing the statistics for each
of the <code>M</code> samples.
</p>


<h3>Warning</h3>

<p>Be careful on avoiding the next bad usages of the functions, which will
produce spurious results:
</p>

<ul>
<li><p> The entries of <code>Theta</code> are <em>not</em> in <code class="reqn">[0, 2\pi)</code>.
</p>
</li>
<li> <p><code>Theta</code> does <em>not</em> contain the circular gaps when
<code>gaps_in_Theta = TRUE</code>.
</p>
</li>
<li> <p><code>Theta</code> is <em>not</em> sorted increasingly when
<code>data_sorted = TRUE</code>.
</p>
</li>
<li> <p><code>Theta</code> does <em>not</em> contain
<code><a href="#topic+Psi_mat">Psi_mat</a>(array(Theta, dim = c(n, 1, M)))</code> when
<br /><code>Psi_in_Theta = TRUE</code>.
</p>
</li>
<li><p> The directions in <code>dirs</code> do <em>not</em> have unit norm.
</p>
</li></ul>



<h3>References</h3>

<p>García-Portugués, E. and Verdebout, T. (2018) An overview of uniformity
tests on the hypersphere. <em>arXiv:1804.00286</em>.
<a href="https://arxiv.org/abs/1804.00286">https://arxiv.org/abs/1804.00286</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Sample uniform circular data

M &lt;- 2
n &lt;- 100
set.seed(987202226)
Theta &lt;- r_unif_cir(n = n, M = M)

## Tests based on the empirical cumulative distribution function

# Kuiper
cir_stat_Kuiper(Theta)
cir_stat_Kuiper(Theta, Stephens = TRUE)

# Watson
cir_stat_Watson(Theta)
cir_stat_Watson(Theta, Stephens = TRUE)

# Watson (1976)
cir_stat_Watson_1976(Theta)

## Partition-based tests

# Ajne
Theta_array &lt;- Theta
dim(Theta_array) &lt;- c(nrow(Theta), 1, ncol(Theta))
Psi &lt;- Psi_mat(Theta_array)
cir_stat_Ajne(Theta)
cir_stat_Ajne(Psi, Psi_in_Theta = TRUE)

# Rothman
cir_stat_Rothman(Theta, t = 0.5)
cir_stat_Rothman(Theta)
cir_stat_Rothman(Psi, Psi_in_Theta = TRUE)

# Hodges-Ajne
cir_stat_Hodges_Ajne(Theta)
cir_stat_Hodges_Ajne(Theta, use_Cressie = FALSE)

# Cressie
cir_stat_Cressie(Theta, t = 0.5)
cir_stat_Cressie(Theta)

# FG01
cir_stat_FG01(Theta)

## Spacings-based tests

# Range
cir_stat_Range(Theta)

# Rao
cir_stat_Rao(Theta)

# Greenwood
cir_stat_Greenwood(Theta)

# Log gaps
cir_stat_Log_gaps(Theta)

# Vacancy
cir_stat_Vacancy(Theta)

# Maximum uncovered spacing
cir_stat_Max_uncover(Theta)

# Number of uncovered spacings
cir_stat_Num_uncover(Theta)

# Gini mean difference
cir_stat_Gini(Theta)

# Gini mean squared difference
cir_stat_Gini_squared(Theta)

## Sobolev tests

# Rayleigh
cir_stat_Rayleigh(Theta)
cir_stat_Rayleigh(Theta, m = 2)

# Bingham
cir_stat_Bingham(Theta)

# Hermans-Rasson
cir_stat_Hermans_Rasson(Theta)
cir_stat_Hermans_Rasson(Psi, Psi_in_Theta = TRUE)

# Gine Fn
cir_stat_Gine_Fn(Theta)
cir_stat_Gine_Fn(Psi, Psi_in_Theta = TRUE)

# Gine Gn
cir_stat_Gine_Gn(Theta)
cir_stat_Gine_Gn(Psi, Psi_in_Theta = TRUE)

# Pycke
cir_stat_Pycke(Theta)
cir_stat_Pycke(Psi, Psi_in_Theta = TRUE)

# Pycke q
cir_stat_Pycke_q(Theta)
cir_stat_Pycke_q(Psi, Psi_in_Theta = TRUE)

# Bakshaev
cir_stat_Bakshaev(Theta)
cir_stat_Bakshaev(Psi, Psi_in_Theta = TRUE)

# Riesz
cir_stat_Riesz(Theta, s = 1)
cir_stat_Riesz(Psi, Psi_in_Theta = TRUE, s = 1)
# Projected Cramér-von Mises
cir_stat_PCvM(Theta)
cir_stat_PCvM(Psi, Psi_in_Theta = TRUE)

# Projected Rothman
cir_stat_PRt(Theta, t = 0.5)
cir_stat_PRt(Theta)
cir_stat_PRt(Psi, Psi_in_Theta = TRUE)

# Projected Anderson-Darling
cir_stat_PAD(Theta)
cir_stat_PAD(Psi, Psi_in_Theta = TRUE)

## Other tests

# CCF09
dirs &lt;- r_unif_sph(n = 3, p = 2, M = 1)[, , 1]
cir_stat_CCF09(Theta, dirs = dirs)

## Connection of Kuiper and Watson statistics with KS and CvM, respectively

# Rotate sample for KS and CvM
alpha &lt;- seq(0, 2 * pi, l = 1e4)
KS_alpha &lt;- sapply(alpha, function(a) {
  cir_stat_Kuiper((Theta[, 2, drop = FALSE] + a) %% (2 * pi), KS = TRUE)
})
CvM_alpha &lt;- sapply(alpha, function(a) {
  cir_stat_Watson((Theta[, 2, drop = FALSE] + a) %% (2 * pi), CvM = TRUE)
})
AD_alpha &lt;- sapply(alpha, function(a) {
  cir_stat_PAD((Theta[, 2, drop = FALSE] + a) %% (2 * pi), AD = TRUE)
})

# Kuiper is the maximum rotated KS
plot(alpha, KS_alpha, type = "l")
abline(h = cir_stat_Kuiper(Theta[, 2, drop = FALSE]), col = 2)
points(alpha[which.max(KS_alpha)], max(KS_alpha), col = 2, pch = 16)

# Watson is the minimum rotated CvM
plot(alpha, CvM_alpha, type = "l")
abline(h = cir_stat_Watson(Theta[, 2, drop = FALSE]), col = 2)
points(alpha[which.min(CvM_alpha)], min(CvM_alpha), col = 2, pch = 16)

# Anderson-Darling is the average rotated AD?
plot(alpha, AD_alpha, type = "l")
abline(h = cir_stat_PAD(Theta[, 2, drop = FALSE]), col = 2)
abline(h = mean(AD_alpha), col = 3)
</code></pre>

<hr>
<h2 id='comets'>Comet orbits</h2><span id='topic+comets'></span>

<h3>Description</h3>

<p>Comet orbits data from the
<a href="https://ssd.jpl.nasa.gov/tools/sbdb_query.html">
JPL Small-Body Database Search Engine</a>. The normal vector of a comet orbit
represents is a vector on <code class="reqn">S^2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comets
</code></pre>


<h3>Format</h3>

<p>A data frame with 3798 rows and 13 variables:
</p>

<dl>
<dt>id</dt><dd><p>database ID.</p>
</dd>
<dt>spkid</dt><dd><p>object primary SPK-ID.</p>
</dd>
<dt>full_name</dt><dd><p>full name/designation following the
<a href="https://www.iau.org/public/themes/naming/#comets">
IUA naming convention</a>.</p>
</dd>
<dt>pdes</dt><dd><p>object primary designation.</p>
</dd>
<dt>frag</dt><dd><p>flag indicating if the record is a comet fragment.</p>
</dd>
<dt>diameter</dt><dd><p>diameter from equivalent sphere (in km).</p>
</dd>
<dt>i</dt><dd><p>inclination; the orbit's plane angle with respect to the
ecliptic plane, in radians in <code class="reqn">[0, \pi]</code>.</p>
</dd>
<dt>om</dt><dd><p>longitude of the ascending node; the counterclockwise angle from
the vector pointing to the First Point of Aries and that pointing to
the ascending node (the intersection between orbit and ecliptic plane), in
radians in <code class="reqn">[0, 2\pi)</code>. (Both vectors are heliocentric and within
the ecliptic plane.)</p>
</dd>
<dt>per_y</dt><dd><p>sidereal orbital period (in years).</p>
</dd>
<dt>class</dt><dd><p>orbit classification. A factor with levels given below.</p>
</dd>
<dt>e</dt><dd><p>eccentricity of the orbit.</p>
</dd>
<dt>a</dt><dd><p>semi-major axis of the orbit (in AU).</p>
</dd>
<dt>w</dt><dd><p>argument of perihelion; the (shortest) angle between the vector
pointing to the ascending node and that pointing to the perihelion
(nearest orbit point to the Sun), in radians in <code class="reqn">[0, \pi]</code>. (Both
vectors are heliocentric and within the orbit's plane.)</p>
</dd>
<dt>first_obs, last_obs</dt><dd><p><code><a href="base.html#topic+Dates">Date</a></code> of the first and
last recorded observations used in the orbit fit.</p>
</dd>
<dt>ccf09</dt><dd><p>flag indicating if the comet was considered in the data
application in Cuesta-Albertos et al. (2009); see details below.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The normal vector to the ecliptic plane of the comet with inclination
<code class="reqn">i</code> and longitude of the ascending node <code class="reqn">\omega</code> is
</p>
<p style="text-align: center;"><code class="reqn">(\sin(i) \sin(\omega), -\sin(i) \cos(\omega), \cos(i))'.</code>
</p>

<p>A prograde comet has positive <code class="reqn">\cos(i)</code>, negative
<code class="reqn">\cos(i)</code> represents a retrograde comet.
</p>
<p><code>class</code> has the following levels:
</p>

<ul>
<li> <p><code>COM</code>: comet orbit not matching any defined orbit class.
</p>
</li>
<li> <p><code>CTc</code>: Chiron-type comet, as defined by Levison and Duncan
(T_Jupiter &gt; 3; a &gt; a_Jupiter).
</p>
</li>
<li> <p><code>ETc</code>: Encke-type comet, as defined by Levison and Duncan
(T_Jupiter &gt; 3; a &lt; a_Jupiter).
</p>
</li>
<li> <p><code>HTC</code>: Halley-type comet, classical definition (20y &lt; P &lt; 200y).
</p>
</li>
<li> <p><code>HYP</code>: comets on hyperbolic orbits.
</p>
</li>
<li> <p><code>JFc</code>: Jupiter-family comet, as defined by Levison and Duncan
(2 &lt; T_Jupiter &lt; 3).
</p>
</li>
<li> <p><code>JFC</code>: Jupiter-family comet, classical definition (P &lt; 20y).
</p>
</li>
<li> <p><code>PAR</code>: comets on parabolic orbits.
</p>
</li></ul>

<p>Hyperbolic and parabolic comets are not periodic; only elliptical comets
are periodic.
</p>
<p>The <code>ccf09</code> variable gives the observations considered in
Cuesta-Albertos et al. (2009) after fetching in the database in 2007-12-14
for the comets such that <code>!(class %in% c("HYP", "PAR")) &amp;
per_y &gt;= 200</code>. Due to the dynamic nature of the data, more comets were added
to the database since 2007 and also some past records were updated.
</p>
<p>The script performing the data preprocessing is available at
<a href="https://github.com/egarpor/sphunif/blob/master/data-raw/comets.R">
<code>comets.R</code></a>. The data was retrieved on 2022-05-28. A previous version
of this dataset based on the old NASA's JPL Database (accessed on
2020-05-07) is available at
<a href="https://github.com/egarpor/sphunif/blob/master/data-raw/comets-old.rda">
<code>comets-old.rda</code></a> and was obtained with
<a href="https://github.com/egarpor/sphunif/blob/master/data-raw/comets-old.R">
<code>comets-old.R</code></a>.
</p>


<h3>Source</h3>

<p><a href="https://ssd.jpl.nasa.gov/tools/sbdb_query.html">https://ssd.jpl.nasa.gov/tools/sbdb_query.html</a>
</p>


<h3>References</h3>

<p>Cuesta-Albertos, J. A., Cuevas, A., Fraiman, R. (2009) On projection-based
tests for directional and compositional data. <em>Statistics and
Computing</em>, 19:367&ndash;380. <a href="https://doi.org/10.1007/s11222-008-9098-3">doi:10.1007/s11222-008-9098-3</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data("comets")

# Add normal vectors
comets$normal &lt;- cbind(sin(comets$i) * sin(comets$om),
                       -sin(comets$i) * cos(comets$om),
                       cos(comets$i))

# Tests to be performed
type_tests &lt;- c("PCvM", "PAD", "PRt")

# Excluding the C/1882 R1-X (Great September comet) records with X = B, C, D
comets_ccf09 &lt;- comets[comets$ccf09, ][-c(13:15), ]

# Sample size
nrow(comets_ccf09)

# Tests for the data in Cuesta-Albertos et al. (2009)
tests_ccf09 &lt;- unif_test(data = comets_ccf09$normal, type = type_tests,
                         p_value = "asymp")
tests_ccf09
</code></pre>

<hr>
<h2 id='craters'>Craters named by the IUA</h2><span id='topic+craters'></span>

<h3>Description</h3>

<p><em>Named</em> craters of the Solar System by the
<a href="https://planetarynames.wr.usgs.gov">Gazetteer of Planetary
Nomenclature</a> of the International Astronomical Union (IUA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>craters
</code></pre>


<h3>Format</h3>

<p>A data frame with 5235 rows and 7 variables:
</p>

<dl>
<dt>ID</dt><dd><p>database ID.</p>
</dd>
<dt>name</dt><dd><p>name of the crater.</p>
</dd>
<dt>target</dt><dd><p>name of the celestial body. A factor with 43 levels,
such as <code>"Moon"</code>, <code>"Venus"</code>, or <code>"Europa"</code>.</p>
</dd>
<dt>target_type</dt><dd><p>type of celestial body. A factor with 3 levels:
<code>"Planet"</code>, <code>"Moon"</code>, <code>"Dwarf planet"</code>, or
<code>"Asteroid"</code>.</p>
</dd>
<dt>diameter</dt><dd><p>diameter of the crater (in km).</p>
</dd>
<dt>theta</dt><dd><p>longitude angle <code class="reqn">\theta \in [0, 2\pi)</code> of the
crater center.</p>
</dd>
<dt>phi</dt><dd><p>latitude angle <code class="reqn">\phi \in [-\pi/2, \pi/2]</code> of the
crater center.</p>
</dd>
</dl>



<h3>Details</h3>

<p>&quot;Craters&quot; are understood in the Gazetteer of Planetary Nomenclature as
roughly circular depressions resulting from impact or volcanic activity
(the geological origin is
<a href="https://planetarynames.wr.usgs.gov/DescriptorTerms">unspecified</a>).
</p>
<p>Be aware that the dataset only contains <em>named</em> craters by the IUA.
Therefore, there is likely a <b>high uniform bias</b> on the distribution
of craters. Presumably the naming process attempts to cover the planet in
a somehow uniform fashion (distant craters are more likely to be named than
neighboring craters). Also, there are substantially more craters in the
listed bodies than those named by the IUA. See <code><a href="#topic+venus">venus</a></code> and
<code><a href="#topic+rhea">rhea</a></code> for more detailed and specific crater datasets.
</p>
<p>The <code class="reqn">(\theta, \phi)</code> angles are such their associated planetocentric
coordinates are:
</p>
<p style="text-align: center;"><code class="reqn">(\cos(\phi) \cos(\theta), \cos(\phi) \sin(\theta), \sin(\phi))',</code>
</p>

<p>with <code class="reqn">(0, 0, 1)'</code> denoting the north pole.
</p>
<p>The script performing the data preprocessing is available at
<a href="https://github.com/egarpor/sphunif/blob/master/data-raw/craters.R">
<code>craters.R</code></a>. The data was retrieved on 2020-05-31.
</p>


<h3>Source</h3>

<p><a href="https://planetarynames.wr.usgs.gov/AdvancedSearch">https://planetarynames.wr.usgs.gov/AdvancedSearch</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data("craters")

# Add Cartesian coordinates
craters$X &lt;- cbind(cos(craters$theta) * cos(craters$phi),
                   sin(craters$theta) * cos(craters$phi),
                   sin(craters$phi))

# Tests to be performed
type_tests &lt;- c("PCvM", "PAD", "PRt")

# Tests for Venus and Rhea
unif_test(data = craters$X[craters$target == "Venus", ], type = type_tests,
          p_value = "asymp")
unif_test(data = craters$X[craters$target == "Rhea", ], type = type_tests,
          p_value = "asymp")
</code></pre>

<hr>
<h2 id='ecdf_bin'>Efficient evaluation of the empirical cumulative distribution
function</h2><span id='topic+ecdf_bin'></span>

<h3>Description</h3>

<p>Evaluates the empirical cumulative distribution function
(ecdf) of a sample <code>data</code> at the evaluation points <code>sorted_x</code>.
This is done through binary search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ecdf_bin(data, sorted_x, data_sorted = FALSE, efic = TRUE,
  divide_n = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ecdf_bin_+3A_data">data</code></td>
<td>
<p>a vector or column matrix containing the sample.</p>
</td></tr>
<tr><td><code id="ecdf_bin_+3A_sorted_x">sorted_x</code></td>
<td>
<p>a vector or column matrix with the evaluation points
<b>sorted increasingly</b>.</p>
</td></tr>
<tr><td><code id="ecdf_bin_+3A_data_sorted">data_sorted</code></td>
<td>
<p>is <code>data</code> is already sorted increasingly?
This avoids sorting the data internally.</p>
</td></tr>
<tr><td><code id="ecdf_bin_+3A_efic">efic</code></td>
<td>
<p>use the more efficient version of the ecdf evaluation? Set to
<code>FALSE</code> only for debugging purposes.</p>
</td></tr>
<tr><td><code id="ecdf_bin_+3A_divide_n">divide_n</code></td>
<td>
<p>if <code>FALSE</code>, returns the absolute frequencies instead
of the relative frequencies. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The ecdf evaluated at <code>sorted_x</code>.
</p>


<h3>Warning</h3>

<p>Be careful on avoiding the next bad usages of the function, which will
produce spurious results:
</p>

<ul>
<li> <p><code>sorted_x</code> is not sorted increasingly.
</p>
</li>
<li> <p><code>data</code> is not sorted increasingly when
<code>data_sorted = TRUE</code>-
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Original code from Douglas Bates'
<a href="https://github.com/dmbates/ecdfExample">https://github.com/dmbates/ecdfExample</a>. Minor adaptations by Eduardo
García-Portugués.
</p>

<hr>
<h2 id='F_from_f'>Distribution and quantile functions from angular function</h2><span id='topic+F_from_f'></span><span id='topic+F_inv_from_f'></span>

<h3>Description</h3>

<p>Numerical computation of the distribution function <code class="reqn">F</code> and
the quantile function <code class="reqn">F^{-1}</code> for an <a href="#topic+locdev">angular function</a>
<code class="reqn">f</code> in a <a href="rotasym.html#topic+tang-norm-decomp">tangent-normal decomposition</a>.
<code class="reqn">F^{-1}(x)</code> results from the inversion of
</p>
<p style="text-align: center;"><code class="reqn">F(x) = \int_{-1}^x \omega_{p - 1}c_f f(z) (1 - z^2)^{(p - 3) / 2}
\,\mathrm{d}z</code>
</p>

<p>for <code class="reqn">x\in [-1, 1]</code>, where <code class="reqn">c_f</code> is a normalizing constant and
<code class="reqn">\omega_{p - 1}</code> is the surface area of <code class="reqn">S^{p - 2}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F_from_f(f, p, Gauss = TRUE, N = 320, K = 1000, tol = 1e-06, ...)

F_inv_from_f(f, p, Gauss = TRUE, N = 320, K = 1000, tol = 1e-06, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F_from_f_+3A_f">f</code></td>
<td>
<p>angular function defined on <code class="reqn">[-1, 1]</code>. Must be vectorized.</p>
</td></tr>
<tr><td><code id="F_from_f_+3A_p">p</code></td>
<td>
<p>integer giving the dimension of the ambient space <code class="reqn">R^p</code> that
contains <code class="reqn">S^{p-1}</code>.</p>
</td></tr>
<tr><td><code id="F_from_f_+3A_gauss">Gauss</code></td>
<td>
<p>use a <a href="#topic+Gauss_Legen_nodes">Gauss&ndash;Legendre quadrature</a>
rule to integrate <code class="reqn">f</code> with <code>N</code> nodes? Otherwise, rely on
<code><a href="stats.html#topic+integrate">integrate</a></code> Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="F_from_f_+3A_n">N</code></td>
<td>
<p>number of points used in the Gauss&ndash;Legendre quadrature. Defaults
to <code>320</code>.</p>
</td></tr>
<tr><td><code id="F_from_f_+3A_k">K</code></td>
<td>
<p>number of equispaced points on <code class="reqn">[-1, 1]</code> used for evaluating
<code class="reqn">F^{-1}</code> and then interpolating. Defaults to <code>1e3</code>.</p>
</td></tr>
<tr><td><code id="F_from_f_+3A_tol">tol</code></td>
<td>
<p>tolerance passed to <code><a href="stats.html#topic+uniroot">uniroot</a></code> for the inversion of
<code class="reqn">F</code>. Also, passed to <code><a href="stats.html#topic+integrate">integrate</a></code>'s <code>rel.tol</code> and
<code>abs.tol</code> if <code>Gauss = FALSE</code>. Defaults to <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="F_from_f_+3A_...">...</code></td>
<td>
<p>further parameters passed to <code>f</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The normalizing constant <code class="reqn">c_f</code> is such that <code class="reqn">F(1) = 1</code>. It does not
need to be part of <code>f</code> as it is computed internally.
</p>
<p>Interpolation is performed by a monotone cubic spline. <code>Gauss = TRUE</code>
yields more accurate results, at expenses of a heavier computation.
</p>
<p>If <code>f</code> yields negative values, these are silently truncated to zero.
</p>


<h3>Value</h3>

<p>A <code><a href="stats.html#topic+splinefun">splinefun</a></code> object ready to evaluate <code class="reqn">F</code> or
<code class="reqn">F^{-1}</code>, as specified.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) rep(1, length(x))
plot(F_from_f(f = f, p = 4, Gauss = TRUE), ylab = "F(x)", xlim = c(-1, 1))
plot(F_from_f(f = f, p = 4, Gauss = FALSE), col = 2, add = TRUE,
     xlim = c(-1, 1))
curve(p_proj_unif(x = x, p = 4), col = 3, add = TRUE, n = 300)
plot(F_inv_from_f(f = f, p = 4, Gauss = TRUE), ylab = "F^{-1}(x)")
plot(F_inv_from_f(f = f, p = 4, Gauss = FALSE), col = 2, add = TRUE)
curve(q_proj_unif(u = x, p = 4), col = 3, add = TRUE, n = 300)
</code></pre>

<hr>
<h2 id='Gauss_Legen'>Gauss&ndash;Legendre quadrature</h2><span id='topic+Gauss_Legen'></span><span id='topic+Gauss_Legen_nodes'></span><span id='topic+Gauss_Legen_weights'></span>

<h3>Description</h3>

<p>Convenience for computing the nodes <code class="reqn">x_k</code> and weights
<code class="reqn">w_k</code> of the <em>Gauss&ndash;Legendre</em> quadrature formula
in <code class="reqn">(a, b)</code>:
</p>
<p style="text-align: center;"><code class="reqn">\int_a^b f(x) w(x)\,\mathrm{d}x\approx\sum_{k=1}^N w_k f(x_k).</code>
</p>
<p>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gauss_Legen_nodes(a = -1, b = 1, N = 40L)

Gauss_Legen_weights(a = -1, b = 1, N = 40L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gauss_Legen_+3A_a">a</code>, <code id="Gauss_Legen_+3A_b">b</code></td>
<td>
<p>scalars giving the interval <code class="reqn">(a, b)</code>. Defaults to
<code class="reqn">(-1, 1)</code>.</p>
</td></tr>
<tr><td><code id="Gauss_Legen_+3A_n">N</code></td>
<td>
<p>number of points used in the Gauss&ndash;Legendre quadrature. The
following choices are supported: <code>5</code>, <code>10</code>, <code>20</code>,
<code>40</code>, <code>80</code>, <code>160</code>, <code>320</code>, <code>640</code>, <code>1280</code>,
<code>2560</code>, and <code>5120</code>. Defaults to <code>40</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code class="reqn">C^\infty</code> functions, Gauss&ndash;Legendre quadrature
can be very efficient. It is exact for polynomials up to degree
<code class="reqn">2N - 1</code>.
</p>
<p>The nodes and weights up to <code class="reqn">N = 80</code> were retrieved from
<a href="https://dlmf.nist.gov/3.5#v">NIST</a> and have <code class="reqn">10^{-21}</code> precision.
For <code class="reqn">N = 160</code> onwards, the nodes and weights were computed with the
<code>gauss.quad</code> function from the <a href="https://CRAN.R-project.org/package=statmod">
<code>statmod</code></a> package (Smyth, 1998), and have <code class="reqn">10^{-15}</code> precision.
</p>


<h3>Value</h3>

<p>A matrix of size <code>c(N, 1)</code> with the nodes <code class="reqn">x_k</code>
(<code>Gauss_Legen_nodes</code>) or the corresponding weights <code class="reqn">w_k</code>
(<code>Gauss_Legen_weights</code>).
</p>


<h3>References</h3>

<p><em>NIST Digital Library of Mathematical Functions</em>. Release
1.0.20 of 2018-09-15. F. W. J. Olver, A. B. Olde Daalhuis, D. W. Lozier,
B. I. Schneider, R. F. Boisvert, C. W. Clark, B. R. Miller,
and B. V. Saunders, eds. <a href="https://dlmf.nist.gov/">https://dlmf.nist.gov/</a>
</p>
<p>Smyth, G. K. (1998). Numerical integration. In: <em>Encyclopedia of
Biostatistics</em>, P. Armitage and T. Colton (eds.), Wiley, London,
pp. 3088-3095.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Integration of a smooth function in (1, 10)

# Weights and nodes for integrating
x_k &lt;- Gauss_Legen_nodes(a = 1, b = 10, N = 40)
w_k &lt;- Gauss_Legen_weights(a = 1, b = 10, N = 40)

# Check quadrature
f &lt;- function(x) sin(x) * x^2 - log(x + 1)
integrate(f, lower = 1, upper = 10, rel.tol = 1e-12)
sum(w_k * f(x_k))

# Exact for polynomials up to degree 2 * N - 1
f &lt;- function(x) (((x + 0.5) / 1e3)^5 - ((x - 0.5)/ 5)^4 +
  ((x - 0.25) / 10)^2 + 1)^20
sum(w_k * f(x_k))
integrate(f, lower = -1, upper = 1, rel.tol = 1e-12)

## Integration on (0, pi)

# Weights and nodes for integrating
th_k &lt;- Gauss_Legen_nodes(a = 0, b = pi, N = 40)
w_k &lt;- Gauss_Legen_weights(a = 0, b = pi, N = 40)

# Check quadrature
p &lt;- 4
psi &lt;- function(th) -sin(th / 2)
w &lt;- function(th) sin(th)^(p - 2)
integrate(function(th) psi(th) * w(th), lower = 0, upper = pi,
          rel.tol = 1e-12)
sum(w_k * psi(th_k) * w(th_k))

# Integral with Gegenbauer polynomial
k &lt;- 3
C_k &lt;- function(th) drop(Gegen_polyn(theta = th, k = k, p = p))
integrate(function(th) psi(th) * C_k(th) * w(th), lower = 0, upper = pi,
          rel.tol = 1e-12)
th_k &lt;- drop(Gauss_Legen_nodes(a = 0, b = pi, N = 80))
w_k &lt;- drop(Gauss_Legen_weights(a = 0, b = pi, N = 80))
sum(w_k * psi(th_k) * C_k(th_k) * w(th_k))
</code></pre>

<hr>
<h2 id='Gegenbauer'>Gegenbauer polynomials and coefficients</h2><span id='topic+Gegenbauer'></span><span id='topic+Gegen_polyn'></span><span id='topic+Gegen_coefs'></span><span id='topic+Gegen_series'></span><span id='topic+Gegen_norm'></span><span id='topic+Gegen_polyn_2d'></span><span id='topic+Gegen_coefs_2d'></span><span id='topic+Gegen_series_2d'></span><span id='topic+Gegen_norm_2d'></span>

<h3>Description</h3>

<p>The <a href="https://dlmf.nist.gov/18.3">Gegenbauer polynomials</a>
<code class="reqn">\{C_k^{(\lambda)}(x)\}_{k = 0}^\infty</code>
form a family of orthogonal polynomials on the interval <code class="reqn">[-1, 1]</code>
with respect to the weight function <code class="reqn">(1 - x^2)^{\lambda - 1/2}</code>,
for <code class="reqn">\lambda &gt; -1/2</code>, <code class="reqn">\lambda \neq 0</code>. They usually appear
when dealing with functions defined on
<code class="reqn">S^{p-1} := \{{\bf x} \in R^p : ||{\bf x}|| = 1\}</code> with index <code class="reqn">\lambda = p / 2 - 1</code>.
</p>
<p>The Gegenbauer polynomials are somehow simpler to evaluate for
<code class="reqn">x = \cos(\theta)</code>, with <code class="reqn">\theta \in [0, \pi]</code>. This simplifies
also the connection with the Chebyshev polynomials
<code class="reqn">\{T_k(x)\}_{k = 0}^\infty</code>, which admit
the <a href="https://dlmf.nist.gov/18.5.E1">explicit expression</a>
<code class="reqn">T_k(\cos(\theta)) = \cos(k\theta)</code>. The Chebyshev polynomials
appear as the limit of the Gegenbauer polynomials
(divided by <code class="reqn">\lambda</code>) when <code class="reqn">\lambda</code> goes to <code class="reqn">0</code>, so they
can be regarded as the extension by continuity of
<code class="reqn">\{C_k^{(p/2 - 1)}(x)\}_{k = 0}^\infty</code> to the case <code class="reqn">p = 2</code>.
</p>
<p>For a <a href="https://dlmf.nist.gov/18.18.i">reasonably smooth</a> function
<code class="reqn">\psi</code> defined on <code class="reqn">[0, \pi]</code>,
</p>
<p style="text-align: center;"><code class="reqn">\psi(\theta) = \sum_{k = 0}^\infty b_{k, p}
C_k^{(p/2 - 1)}(\cos(\theta)),</code>
</p>

<p>provided that the coefficients
</p>
<p style="text-align: center;"><code class="reqn">b_{k, p} := \frac{1}{c_{k, p}} \int_0^\pi \psi(\theta)
C_k^{(p/2 - 1)}(\cos(\theta)) (\sin(\theta))^{p - 2}\,\mathrm{d}\theta</code>
</p>

<p>are finite, where the normalizing constants are
</p>
<p style="text-align: center;"><code class="reqn">c_{k, p} := \int_0^\pi (C_k^{(p/2 - 1)}(\cos(\theta)))^2
(\sin(\theta))^{p - 2} \,\mathrm{d}\theta.</code>
</p>

<p>The (squared) &quot;Gegenbauer norm&quot; of <code class="reqn">\psi</code> is
</p>
<p style="text-align: center;"><code class="reqn">\|\psi\|_{G, p}^2 := \int_0^\pi \psi(\theta)^2
C_k^{(p/2 - 1)}(\cos(\theta)) (\sin(\theta))^{p - 2}\,\mathrm{d}\theta.</code>
</p>

<p>The previous expansion can be generalized for a 2-dimensional function
<code class="reqn">\psi</code> defined on <code class="reqn">[0, \pi] \times [0, \pi]</code>:
</p>
<p style="text-align: center;"><code class="reqn">\psi(\theta_1, \theta_2) = \sum_{k = 0}^\infty \sum_{m = 0}^\infty
b_{k, m, p} C_k^{(p/2 - 1)}(\cos(\theta_1))
C_k^{(p/2 - 1)}(\cos(\theta_2)),</code>
</p>

<p>with coefficients
</p>
<p style="text-align: center;"><code class="reqn">b_{k, m, p} := \frac{1}{c_{k, p} c_{m, p}} \int_0^\pi\int_0^\pi
\psi(\theta_1, \theta_2) C_k^{(p/2 - 1)}(\cos(\theta_1))
C_k^{(p/2 - 1)}(\cos(\theta_2)) (\sin(\theta_1))^{p - 2}
(\sin(\theta_2))^{p - 2}\,\mathrm{d}\theta_1\,\mathrm{d}\theta_2.</code>
</p>

<p>The (squared) &quot;Gegenbauer norm&quot; of <code class="reqn">\psi</code> is
</p>
<p style="text-align: center;"><code class="reqn">\|\psi\|_{G, p}^2 := \int_0^\pi\int_0^\pi \psi(\theta_1, \theta_2)^2
C_k^{(p/2 - 1)}(\cos(\theta_1)) C_k^{(p/2 - 1)}(\cos(\theta_2))
(\sin(\theta_1))^{p - 2} (\sin(\theta_2))^{p - 2}
\,\mathrm{d}\theta_1\,\mathrm{d}\theta_2.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>Gegen_polyn(theta, k, p)

Gegen_coefs(k, p, psi, Gauss = TRUE, N = 320, normalize = TRUE,
  only_const = FALSE, tol = 1e-06, ...)

Gegen_series(theta, coefs, k, p, normalize = TRUE)

Gegen_norm(coefs, k, p, normalize = TRUE, cumulative = FALSE)

Gegen_polyn_2d(theta_1, theta_2, k, m, p)

Gegen_coefs_2d(k, m, p, psi, Gauss = TRUE, N = 320, normalize = TRUE,
  only_const = FALSE, tol = 1e-06, ...)

Gegen_series_2d(theta_1, theta_2, coefs, k, m, p, normalize = TRUE)

Gegen_norm_2d(coefs, k, m, p, normalize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gegenbauer_+3A_theta">theta</code>, <code id="Gegenbauer_+3A_theta_1">theta_1</code>, <code id="Gegenbauer_+3A_theta_2">theta_2</code></td>
<td>
<p>vectors with values in <code class="reqn">[0, \pi]</code>.</p>
</td></tr>
<tr><td><code id="Gegenbauer_+3A_k">k</code>, <code id="Gegenbauer_+3A_m">m</code></td>
<td>
<p>vectors with the orders of the Gegenbauer polynomials. Must
be integers larger or equal than <code>0</code>.</p>
</td></tr>
<tr><td><code id="Gegenbauer_+3A_p">p</code></td>
<td>
<p>integer giving the dimension of the ambient space <code class="reqn">R^p</code> that
contains <code class="reqn">S^{p-1}</code>.</p>
</td></tr>
<tr><td><code id="Gegenbauer_+3A_psi">psi</code></td>
<td>
<p>function defined in <code class="reqn">[0, \pi]</code> and whose Gegenbauer
coefficients are to be computed. Must be vectorized. For
<code>Gegen_coefs_2d</code>, it must return a matrix of size
<code>c(length(theta_1), length(theta_2))</code>.</p>
</td></tr>
<tr><td><code id="Gegenbauer_+3A_gauss">Gauss</code></td>
<td>
<p>use a Gauss&ndash;Legendre quadrature rule of <code>N</code> nodes
in the computation of the Gegenbauer coefficients? Otherwise, call
<code><a href="stats.html#topic+integrate">integrate</a></code>. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="Gegenbauer_+3A_n">N</code></td>
<td>
<p>number of points used in the <a href="#topic+Gauss_Legen_nodes">
Gauss&ndash;Legendre quadrature</a> for computing the Gegenbauer coefficients.
Defaults to <code>320</code>.</p>
</td></tr>
<tr><td><code id="Gegenbauer_+3A_normalize">normalize</code></td>
<td>
<p>consider normalized coefficients (divided by
<code class="reqn">c_{k, p}</code>)? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="Gegenbauer_+3A_only_const">only_const</code></td>
<td>
<p>return only the normalizing constants <code class="reqn">c_{k, p}</code>?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Gegenbauer_+3A_tol">tol</code></td>
<td>
<p>tolerance passed to <code><a href="stats.html#topic+integrate">integrate</a></code>'s <code>rel.tol</code> and
<code>abs.tol</code> if <code>Gauss = FALSE</code>. Defaults to <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="Gegenbauer_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>psi</code>.</p>
</td></tr>
<tr><td><code id="Gegenbauer_+3A_coefs">coefs</code></td>
<td>
<p>for <code>Gegen_series</code> and <code>Gegen_norm</code>, a vector of
coefficients <code class="reqn">b_{k, p}</code> with length <code>length(k)</code>. For
<code>Gegen_series_2d</code> and <code>Gegen_norm_2d</code>, a matrix of coefficients
<code class="reqn">b_{k, m, p}</code> with size <code>c(length(k), length(m))</code>. The
order of the coefficients is given by <code>k</code> and <code>m</code>.</p>
</td></tr>
<tr><td><code id="Gegenbauer_+3A_cumulative">cumulative</code></td>
<td>
<p>return the cumulative norm for increasing truncation of
the series? Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>Gegen_polyn</code> function is a wrapper to the functions
<code><a href="gsl.html#topic+Gegenbauer">gegenpoly_n</a></code> and
<code><a href="gsl.html#topic+Gegenbauer">gegenpoly_array</a></code> in the
<code><a href="gsl.html#topic+gsl-package">gsl-package</a></code>, which they interface the functions
defined in the header file <code>gsl_sf_gegenbauer.h</code> (documented
<a href="https://www.gnu.org/software/gsl/doc/html/specfunc.html#gegenbauer-functions">
here</a>) of the <a href="https://www.gnu.org/software/gsl/">
GNU Scientific Library</a>.
</p>
<p>Note that the function <code>Gegen_polyn</code> computes the regular
<em>unnormalized</em> Gegenbauer polynomials.
</p>
<p>For the case <code class="reqn">p = 2</code>, the Chebyshev polynomials are considered.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>Gegen_polyn</code>: a matrix of size
<code>c(length(theta), length(k))</code> containing the evaluation of the
<code>length(k)</code> Gegenbauer polynomials at <code>theta</code>.
</p>
</li>
<li> <p><code>Gegen_coefs</code>: a vector of size <code>length(k)</code> containing
the coefficients <code class="reqn">b_{k, p}</code>.
</p>
</li>
<li> <p><code>Gegen_series</code>: the evaluation of the truncated series
expansion, a vector of size <code>length(theta)</code>.
</p>
</li>
<li> <p><code>Gegen_norm</code>: the Gegenbauer norm of the truncated series,
a scalar if <code>cumulative = FALSE</code>, otherwise a vector of size
<code>length(k)</code>.
</p>
</li>
<li> <p><code>Gegen_polyn_2d</code>: a 4-dimensional array of size
<code>c(length(theta_1), length(theta_2), length(k), length(m))</code>
containing the evaluation of the <code>length(k) * length(m)</code>
2-dimensional Gegenbauer polynomials at the bivariate grid
spanned by <code>theta_1</code> and <code>theta_2</code>.
</p>
</li>
<li> <p><code>Gegen_coefs_2d</code>: a matrix of size
<code>c(length(k), length(m))</code> containing the coefficients
<code class="reqn">b_{k, m, p}</code>.
</p>
</li>
<li> <p><code>Gegen_series_2d</code>: the evaluation of the truncated series
expansion, a matrix of size <code>c(length(theta_1), length(theta_2))</code>.
</p>
</li>
<li> <p><code>Gegen_norm_2d</code>: the 2-dimensional Gegenbauer norm of the
truncated series, a scalar.
</p>
</li></ul>



<h3>References</h3>

<p>Galassi, M., Davies, J., Theiler, J., Gough, B., Jungman, G., Alken, P.,
Booth, M., and Rossi, F. (2009) <em>GNU Scientific Library Reference
Manual</em>. Network Theory Ltd. <a href="http://www.gnu.org/software/gsl/">http://www.gnu.org/software/gsl/</a>
</p>
<p><em>NIST Digital Library of Mathematical Functions</em>. Release
1.0.20 of 2018-09-15. F. W. J. Olver, A. B. Olde Daalhuis, D. W. Lozier,
B. I. Schneider, R. F. Boisvert, C. W. Clark, B. R. Miller,
and B. V. Saunders, eds. <a href="https://dlmf.nist.gov/">https://dlmf.nist.gov/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Representation of Gegenbauer polynomials (Chebyshev polynomials for p = 2)

th &lt;- seq(0, pi, l = 500)
k &lt;- 0:3
old_par &lt;- par(mfrow = c(2, 2))
for (p in 2:5) {
  matplot(th, t(Gegen_polyn(theta = th, k = k, p = p)), lty = 1,
          type = "l", main = substitute(p == d, list(d = p)),
          axes = FALSE, xlab = expression(theta), ylab = "")
  axis(1, at = c(0, pi / 4, pi / 2, 3 * pi / 4, pi),
       labels = expression(0, pi / 4, pi / 2, 3 * pi / 4, pi))
  axis(2); box()
  mtext(text = expression({C[k]^{p/2 - 1}}(cos(theta))), side = 2,
        line = 2, cex = 0.75)
  legend("bottomleft", legend = paste("k =", k), lwd = 2, col = seq_along(k))
}
par(old_par)

## Coefficients and series in p = 2

# Function in [0, pi] to be projected in Chebyshev polynomials
psi &lt;- function(th) -sin(th / 2)

# Coefficients
p &lt;- 2
k &lt;- 0:4
(coefs &lt;- Gegen_coefs(k = k, p = p, psi = psi))

# Series
plot(th, psi(th), type = "l", axes = FALSE, xlab = expression(theta),
      ylab = "", ylim = c(-1.25, 0))
axis(1, at = c(0, pi / 4, pi / 2, 3 * pi / 4, pi),
     labels = expression(0, pi / 4, pi / 2, 3 * pi / 4, pi))
axis(2); box()
col &lt;- viridisLite::viridis(length(coefs))
for (i in seq_along(coefs)) {
  lines(th, Gegen_series(theta = th, coefs = coefs[1:(i + 1)], k = 0:i,
                         p = p), col = col[i])
}
lines(th, psi(th), lwd = 2)

## Coefficients and series in p = 3

# Function in [0, pi] to be projected in Gegenbauer polynomials
psi &lt;- function(th) tan(th / 3)

# Coefficients
p &lt;- 3
k &lt;- 0:10
(coefs &lt;- Gegen_coefs(k = k, p = p, psi = psi))

# Series
plot(th, psi(th), type = "l", axes = FALSE, xlab = expression(theta),
      ylab = "", ylim = c(0, 2))
axis(1, at = c(0, pi / 4, pi / 2, 3 * pi / 4, pi),
     labels = expression(0, pi / 4, pi / 2, 3 * pi / 4, pi))
axis(2); box()
col &lt;- viridisLite::viridis(length(coefs))
for (i in seq_along(coefs)) {
  lines(th, Gegen_series(theta = th, coefs = coefs[1:(i + 1)], k = 0:i,
                         p = p), col = col[i])
}
lines(th, psi(th), lwd = 2)

## Surface representation

# Surface in [0, pi]^2 to be projected in Gegenbauer polynomials
p &lt;- 3
psi &lt;- function(th_1, th_2) A_theta_x(theta = th_1, x = cos(th_2),
                                      p = p, as_matrix = TRUE)

# Coefficients
k &lt;- 0:20
m &lt;- 0:10
coefs &lt;- Gegen_coefs_2d(k = k, m = m, p = p, psi = psi)

# Series
th &lt;- seq(0, pi, l = 100)
col &lt;- viridisLite::viridis(20)
old_par &lt;- par(mfrow = c(2, 2))
image(th, th, A_theta_x(theta = th, x = cos(th), p = p), axes = FALSE,
      col = col, zlim = c(0, 1), xlab = expression(theta[1]),
      ylab = expression(theta[2]), main = "Original")
axis(1, at = c(0, pi / 4, pi / 2, 3 * pi / 4, pi),
     labels = expression(0, pi / 4, pi / 2, 3 * pi / 4, pi))
axis(2, at = c(0, pi / 4, pi / 2, 3 * pi / 4, pi),
     labels = expression(0, pi / 4, pi / 2, 3 * pi / 4, pi))
box()
for(K in c(5, 10, 20)) {
  A &lt;- Gegen_series_2d(theta_1 = th, theta_2 = th,
                       coefs = coefs[1:(K + 1), ], k = 0:K, m = m, p = p)
  image(th, th, A, axes = FALSE, col = col, zlim = c(0, 1),
        xlab = expression(theta[1]), ylab = expression(theta[2]),
        main = paste(K, "x", m[length(m)], "coefficients"))
  axis(1, at = c(0, pi / 4, pi / 2, 3 * pi / 4, pi),
       labels = expression(0, pi / 4, pi / 2, 3 * pi / 4, pi))
  axis(2, at = c(0, pi / 4, pi / 2, 3 * pi / 4, pi),
       labels = expression(0, pi / 4, pi / 2, 3 * pi / 4, pi))
  box()
}
par(old_par)

</code></pre>

<hr>
<h2 id='harmonics'>(Hyper)spherical harmonics</h2><span id='topic+harmonics'></span><span id='topic+g_i_k'></span>

<h3>Description</h3>

<p>Computation of a certain explicit representation of
(hyper)spherical harmonics on
<code class="reqn">S^{p-1}:=\{{\bf x}\in R^p:||{\bf x}||=1\}</code>, <code class="reqn">p\ge 2</code>. Details are available in
García-Portugués et al. (2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_i_k(x, i = 1, k = 1, m = NULL, show_m = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="harmonics_+3A_x">x</code></td>
<td>
<p>locations in <code class="reqn">S^{p-1}</code> to evaluate <code class="reqn">g_{i,k}</code>. Either a
matrix of size <code>c(nx, p)</code> or a vector of size <code>p</code>. Normalized
internally if required (with a <code>warning</code> message).</p>
</td></tr>
<tr><td><code id="harmonics_+3A_i">i</code>, <code id="harmonics_+3A_k">k</code></td>
<td>
<p>alternative indexing to refer to the <code>i</code>-th (hyper)spherical
harmonic of order <code>k</code>. <code>i</code> is a positive integer smaller than
<code><a href="#topic+Sobolev">d_p_k</a></code> and <code>k</code> is a non-negative integer.</p>
</td></tr>
<tr><td><code id="harmonics_+3A_m">m</code></td>
<td>
<p>(hyper)spherical harmonic index, as used in Proposition 2.1. The
index is computed internally from <code>i</code> and <code>k</code>. Defaults to
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="harmonics_+3A_show_m">show_m</code></td>
<td>
<p>flag to print <code>m</code> if computed internally when
<code>m = NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation uses Proposition 2.1 in García-Portugués et al. (2021),
which adapts Theorem 1.5.1 in Dai and Xu (2013) with the correction of
typos in the normalizing constant <code class="reqn">h_\alpha</code> and in the definition of
the function <code class="reqn">g_\alpha</code> of the latter theorem.
</p>


<h3>Value</h3>

<p>A vector of size <code>nrow(x)</code>.
</p>


<h3>References</h3>

<p>Dai, F. and Xu, Y. (2013). <em>Approximation Theory and Harmonic Analysis
on Spheres and Balls</em>. Springer, New York. <a href="https://doi.org/10.1007/978-1-4614-6660-4">doi:10.1007/978-1-4614-6660-4</a>
</p>
<p>García-Portugués, E., Paindaveine, D., and Verdebout, T. (2021). On the
power of Sobolev tests for isotropy under local rotationally symmetric
alternatives. <em>arXiv:2108.09874</em>. <a href="https://arxiv.org/abs/2108.09874">https://arxiv.org/abs/2108.09874</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 3e3
old_par &lt;- par(mfrow = c(2, 3))
k &lt;- 2
for (i in 1:d_p_k(p = 3, k = k)) {
  X &lt;- r_unif_sph(n = n, p = 3, M = 1)[, , 1]
  col &lt;- rainbow(n)[rank(g_i_k(x = X, k = k, i = i, show_m = TRUE))]
  scatterplot3d::scatterplot3d(X[, 1], X[, 2], X[, 3], color = col,
                               axis = FALSE, pch = 19)
}
for (k in 0:5) {
  X &lt;- r_unif_sph(n = n, p = 3, M = 1)[, , 1]
  col &lt;- rainbow(n)[rank(g_i_k(x = X, k = k, i = 1, show_m = TRUE))]
  scatterplot3d::scatterplot3d(X[, 1], X[, 2], X[, 3], color = col,
                               axis = FALSE, pch = 19)
}
par(old_par)
</code></pre>

<hr>
<h2 id='int_sph_MC'>Monte Carlo integration of functions on the (hyper)sphere</h2><span id='topic+int_sph_MC'></span>

<h3>Description</h3>

<p>Monte Carlo approximation of the integral
</p>
<p style="text-align: center;"><code class="reqn">\int_{S^{p-1}}f(x)\,\mathrm{d}x</code>
</p>

<p>of a function <code class="reqn">f:S^{p-1} \rightarrow R</code> defined on the (hyper)sphere
<code class="reqn">S^{p-1}:=\{{\bf x}\in R^p:||{\bf x}||=1\}</code>, <code class="reqn">p\ge 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int_sph_MC(f, p, M = 10000, cores = 1, chunks = ceiling(M/1000),
  seeds = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="int_sph_MC_+3A_f">f</code></td>
<td>
<p>function to be integrated. Its first argument must be the
(hyper)sphere position. Must be vectorized and return a vector of size
<code>nrow(x)</code> for a matrix input <code>x</code>. See examples.</p>
</td></tr>
<tr><td><code id="int_sph_MC_+3A_p">p</code></td>
<td>
<p>integer giving the dimension of the ambient space <code class="reqn">R^p</code> that
contains <code class="reqn">S^{p-1}</code>.</p>
</td></tr>
<tr><td><code id="int_sph_MC_+3A_m">M</code></td>
<td>
<p>number of Monte Carlo samples. Defaults to <code>1e4</code>.</p>
</td></tr>
<tr><td><code id="int_sph_MC_+3A_cores">cores</code></td>
<td>
<p>number of cores to perform the integration. Defaults to
<code>1</code>.</p>
</td></tr>
<tr><td><code id="int_sph_MC_+3A_chunks">chunks</code></td>
<td>
<p>number of chunks to split the <code>M</code> Monte Carlo
samples. Useful for parallelizing the integration in <code>chunks</code>
tasks containing <code>ceiling(M / chunks)</code> replications. Useful also for
avoiding memory bottlenecks when <code>M</code> is large. Defaults to
<br /><code>ceiling(M / 1e3)</code>.</p>
</td></tr>
<tr><td><code id="int_sph_MC_+3A_seeds">seeds</code></td>
<td>
<p>if provided, a vector of size <code>chunks</code> for fixing the
seeds on each of the simulation chunks (useful for reproducing parallel
simulations). Specifically, for <code>k in 1:chunks</code>, seeds are
set as <code>set.seed(seeds[k], kind = "Mersenne-Twister")</code> in each chunk.
Defaults to <code>NULL</code> (no seed setting is done).</p>
</td></tr>
<tr><td><code id="int_sph_MC_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code>f</code> or to
<code><a href="foreach.html#topic+foreach">foreach</a></code> (for example, <code>.export</code> to export global
variables or other functions to the <code>foreach</code> environment).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is possible to have a progress bar if <code>int_sph_MC</code> is wrapped with
<code><a href="progressr.html#topic+with_progress">progressr::with_progress</a></code> or if
<code>progressr::handlers(global = TRUE)</code> is invoked (once) by the user.
See the examples below. The progress bar is updated with the number of
finished chunks.
</p>


<h3>Value</h3>

<p>A scalar with the approximate integral.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Sequential simulation

# Vectorized functions to be integrated
x1 &lt;- function(x) x[, 1]
quad &lt;- function(x, a = 0) a + rowSums(x^4)

# Approximate \int_{S^{p-1}} x_1 dx = 0
int_sph_MC(f = x1, p = 3, M = 1e4, chunks = 2)

# Approximate \int_{S^{p-1}} (a + \sum_i x_i^4) dx
int_sph_MC(f = quad, p = 2, M = 1e4, a = 0, chunks = 2)

# Compare with Gauss--Legendre integration on S^2
th_k &lt;- Gauss_Legen_nodes(a = 0, b = 2 * pi, N = 40)
w_k &lt;- Gauss_Legen_weights(a = 0, b = 2 * pi, N = 40)
sum(w_k * quad(cbind(cos(th_k), sin(th_k)), a = 1))

## Parallel simulation with a progress bar

# Define a progress bar
require(progress)
require(progressr)
handlers(handler_progress(
  format = ":spin [:bar] :percent Total: :elapsedfull End \u2248 :eta",
  clear = FALSE))

# Call int_sph_MC() within with_progress()
with_progress(int_sph_MC(f = x1, p = 3, cores = 2, M = 1e5, chunks = 100))

# Instead of using with_progress() each time, it is more practical to run
# handlers(global = TRUE)
# once to activate progress bars in your R session

</code></pre>

<hr>
<h2 id='locdev'>Local projected alternatives to uniformity</h2><span id='topic+locdev'></span><span id='topic+f_locdev'></span><span id='topic+con_f'></span><span id='topic+d_locdev'></span><span id='topic+r_locdev'></span><span id='topic+cutoff_locdev'></span>

<h3>Description</h3>

<p>Density and random generation for local projected alternatives
to uniformity with densities
</p>
<p style="text-align: center;"><code class="reqn">f_{\kappa, \boldsymbol{\mu}}({\bf x}): =
\frac{1 - \kappa}{\omega_p} + \kappa f({\bf x}'\boldsymbol{\mu})</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">f(z) = \frac{1}{\omega_p}\left\{1 + \sum_{k = 1}^\infty u_{k, p}
C_k^{p / 2 - 1}(z)\right\}</code>
</p>

<p>is the <em>angular function</em> controlling the local alternative in a
<a href="#topic+Gegenbauer">Gegenbauer series</a>, <code class="reqn">0\le \kappa \le 1</code>,
<code class="reqn">\boldsymbol{\mu}</code> is a direction on <code class="reqn">S^{p - 1}</code>, and
<code class="reqn">\omega_p</code> is the surface area of <code class="reqn">S^{p - 1}</code>. The sequence
<code class="reqn">\{u_{k, p}\}</code> is typically such that
<code class="reqn">u_{k, p} = \left(1 + \frac{2k}{p - 2}\right) b_{k, p}</code> for the Gegenbauer coefficients
<code class="reqn">\{b_{k, p}\}</code> of the kernel function of a Sobolev statistic (see the
<a href="#topic+Sobolev_coefs">transformation</a> between the coefficients <code class="reqn">u_{k, p}</code>
and <code class="reqn">b_{k, p}</code>).
</p>
<p>Also, automatic truncation of the series <code class="reqn">\sum_{k = 1}^\infty u_{k, p}
C_k^{p / 2 - 1}(z)</code>
according to the proportion of <a href="#topic+Gegenbauer">&quot;Gegenbauer norm&quot;</a>
explained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_locdev(z, p, uk)

con_f(f, p, N = 320)

d_locdev(x, mu, f, kappa)

r_locdev(n, mu, f, kappa, F_inv = NULL, ...)

cutoff_locdev(p, K_max = 10000, thre = 0.001, type, Rothman_t = 1/3,
  Pycke_q = 0.5, verbose = FALSE, Gauss = TRUE, N = 320, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locdev_+3A_z">z</code></td>
<td>
<p>projected evaluation points for <code class="reqn">f</code>, a vector with entries on
<code class="reqn">[-1, 1]</code>.</p>
</td></tr>
<tr><td><code id="locdev_+3A_p">p</code></td>
<td>
<p>integer giving the dimension of the ambient space <code class="reqn">R^p</code> that
contains <code class="reqn">S^{p-1}</code>.</p>
</td></tr>
<tr><td><code id="locdev_+3A_uk">uk</code></td>
<td>
<p>coefficients <code class="reqn">u_{k, p}</code> associated to the indexes
<code>1:length(uk)</code>, a vector.</p>
</td></tr>
<tr><td><code id="locdev_+3A_f">f</code></td>
<td>
<p>angular function defined on <code class="reqn">[-1, 1]</code>. Must be vectorized.</p>
</td></tr>
<tr><td><code id="locdev_+3A_n">N</code></td>
<td>
<p>number of points used in the <a href="#topic+Gauss_Legen_nodes">
Gauss&ndash;Legendre quadrature</a> for computing the Gegenbauer coefficients.
Defaults to <code>320</code>.</p>
</td></tr>
<tr><td><code id="locdev_+3A_x">x</code></td>
<td>
<p>locations in <code class="reqn">S^{p-1}</code> to evaluate the density. Either a
matrix of size <code>c(nx, p)</code> or a vector of length <code>p</code>. Normalized
internally if required (with a <code>warning</code> message).</p>
</td></tr>
<tr><td><code id="locdev_+3A_mu">mu</code></td>
<td>
<p>a unit norm vector of size <code>p</code> giving the axis of rotational
symmetry.</p>
</td></tr>
<tr><td><code id="locdev_+3A_kappa">kappa</code></td>
<td>
<p>the strength of the local alternative, between <code>0</code>
and <code>1</code>.</p>
</td></tr>
<tr><td><code id="locdev_+3A_n">n</code></td>
<td>
<p>sample size, a positive integer.</p>
</td></tr>
<tr><td><code id="locdev_+3A_f_inv">F_inv</code></td>
<td>
<p>quantile function associated to <code class="reqn">f</code>. Computed by
<code><a href="#topic+F_inv_from_f">F_inv_from_f</a></code> if <code>NULL</code> (default).</p>
</td></tr>
<tr><td><code id="locdev_+3A_...">...</code></td>
<td>
<p>further parameters passed to <code><a href="#topic+F_inv_from_f">F_inv_from_f</a></code>.</p>
</td></tr>
<tr><td><code id="locdev_+3A_k_max">K_max</code></td>
<td>
<p>integer giving the truncation of the series. Defaults to
<code>1e4</code>.</p>
</td></tr>
<tr><td><code id="locdev_+3A_thre">thre</code></td>
<td>
<p>proportion of norm <em>not</em> explained by the first terms of the
truncated series. Defaults to <code>1e-3</code>.</p>
</td></tr>
<tr><td><code id="locdev_+3A_type">type</code></td>
<td>
<p>Sobolev statistic. For <code class="reqn">p = 2</code>, either <code>"Watson"</code>,
<code>"Rothman"</code>, <code>"Pycke_q"</code>, or <code>"Hermans_Rasson"</code>.
For <code class="reqn">p \ge 2</code>, <code>"Ajne"</code>, <code>"Gine_Gn"</code>, <code>"Gine_Fn"</code>,
<code>"Bakshaev"</code>, <code>"Riesz"</code>, <code>"PCvM"</code>, <code>"PAD"</code>, or
<code>"PRt"</code>.</p>
</td></tr>
<tr><td><code id="locdev_+3A_rothman_t">Rothman_t</code></td>
<td>
<p><code class="reqn">t</code> parameter for the Rothman test, a real in
<code class="reqn">(0, 1)</code>. Defaults to <code>1 / 3</code>.</p>
</td></tr>
<tr><td><code id="locdev_+3A_pycke_q">Pycke_q</code></td>
<td>
<p><code class="reqn">q</code> parameter for the Pycke &quot;<code class="reqn">q</code>-test&quot;, a real in
<code class="reqn">(0, 1)</code>. Defaults to <code>1 / 2</code>.</p>
</td></tr>
<tr><td><code id="locdev_+3A_verbose">verbose</code></td>
<td>
<p>output information about the truncation (<code>TRUE</code> or
<code>1</code>) and a diagnostic plot (<code>2</code>)? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="locdev_+3A_gauss">Gauss</code></td>
<td>
<p>use a Gauss&ndash;Legendre quadrature rule of <code>N</code> nodes
in the computation of the Gegenbauer coefficients? Otherwise, call
<code><a href="stats.html#topic+integrate">integrate</a></code>. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="locdev_+3A_tol">tol</code></td>
<td>
<p>tolerance passed to <code><a href="stats.html#topic+integrate">integrate</a></code>'s <code>rel.tol</code> and
<code>abs.tol</code> if <code>Gauss = FALSE</code>. Defaults to <code>1e-6</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the definitions of local alternatives in Prentice (1978) and in
García-Portugués et al. (2023).
</p>
<p>The truncation of <code class="reqn">\sum_{k = 1}^\infty u_{k, p} C_k^{p / 2 - 1}(z)</code> is done to the first
<code>K_max</code> terms and then up to the index such that the first terms
leave unexplained the proportion <code>thre</code> of the norm of the whole series.
Setting <code>thre = 0</code> truncates to <code>K_max</code> terms exactly. If the
series only contains odd or even non-zero terms, then only <code>K_max / 2</code>
addends are <em>effectively</em> taken into account in the first truncation.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>f_locdev</code>: angular function evaluated at <code>x</code>, a vector.
</p>
</li>
<li> <p><code>con_f</code>: normalizing constant <code class="reqn">c_f</code> of <code class="reqn">f</code>, a scalar.
</p>
</li>
<li> <p><code>d_locdev</code>: density function evaluated at <code>x</code>, a vector.
</p>
</li>
<li> <p><code>r_locdev</code>: a matrix of size <code>c(n, p)</code> containing a random
sample from the density <code class="reqn">f_{\kappa, \boldsymbol{\mu}}</code>.
</p>
</li>
<li> <p><code>cutoff_locdev</code>: vector of coefficients <code class="reqn">\{u_{k, p}\}</code>
automatically truncated according to <code>K_max</code> and <code>thre</code>
(see details).
</p>
</li></ul>



<h3>References</h3>

<p>García-Portugués, E., Navarro-Esteban, P., Cuesta-Albertos, J. A. (2023)
On a projection-based class of uniformity tests on the hypersphere.
<em>Bernoulli</em>, 29(1):181&ndash;204. <a href="https://doi.org/10.3150/21-BEJ1454">doi:10.3150/21-BEJ1454</a>.
</p>
<p>Prentice, M. J. (1978). On invariant tests of uniformity for directions and
orientations. <em>The Annals of Statistics</em>, 6(1):169&ndash;176.
<a href="https://doi.org/10.1214/aos/1176344075">doi:10.1214/aos/1176344075</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Local alternatives diagnostics

loc_alt_diagnostic  &lt;- function(p, type, thre = 1e-3, K_max = 1e3) {

  # Coefficients of the alternative
  uk &lt;- cutoff_locdev(K_max = K_max, p = p, type = type, thre = thre,
                      N = 640)

  old_par &lt;- par(mfrow = c(2, 2))

  # Construction of f
  z &lt;- seq(-1, 1, l = 1e3)
  f &lt;- function(z) f_locdev(z = z, p = p, uk = uk)
  plot(z, f(z), type = "l", xlab = expression(z), ylab = expression(f(z)),
       main = paste0("Local alternative f, ", type, ", p = ", p), log = "y")

  # Projected density on [-1, 1]
  f_proj &lt;- function(z) rotasym::w_p(p = p - 1) * f(z) *
    (1 - z^2)^((p - 3) / 2)
  plot(z, f_proj(z), type = "l", xlab = expression(z),
       ylab = expression(omega[p - 1] * f(z) * (1 - z^2)^{(p - 3) / 2}),
       main = paste0("Projected density, ", type, ", p = ", p), log = "y",
       sub = paste("Integral:", round(con_f(f = f, p = p), 4)))

  # Quantile function for projected density
  mu &lt;- c(rep(0, p - 1), 1)
  F_inv &lt;- F_inv_from_f(f = f, p = p, K = 5e2)
  plot(F_inv, xlab = expression(x), ylab = expression(F^{-1}*(x)),
       main = paste0("Quantile function, ", type, ", p = ", p))

  # Sample from the alternative and plot the projected sample
  n &lt;- 5e4
  samp &lt;- r_locdev(n = n, mu = mu, f = f, kappa = 1, F_inv = F_inv)
  plot(z, f_proj(z), col = 2, type = "l",
       main = paste0("Simulated projected data, ", type, ", p = ", p),
       ylim = c(0, 1.75))
  hist(samp %*% mu, freq = FALSE, breaks = seq(-1, 1, l = 50), add = TRUE)

  par(old_par)

}

## Local alternatives for the PCvM test

loc_alt_diagnostic(p = 2, type = "PCvM")
loc_alt_diagnostic(p = 3, type = "PCvM")
loc_alt_diagnostic(p = 4, type = "PCvM")
loc_alt_diagnostic(p = 5, type = "PCvM")
loc_alt_diagnostic(p = 11, type = "PCvM")

## Local alternatives for the PAD test

loc_alt_diagnostic(p = 2, type = "PAD")
loc_alt_diagnostic(p = 3, type = "PAD")
loc_alt_diagnostic(p = 4, type = "PAD")
loc_alt_diagnostic(p = 5, type = "PAD")
loc_alt_diagnostic(p = 11, type = "PAD")

## Local alternatives for the PRt test

loc_alt_diagnostic(p = 2, type = "PRt")
loc_alt_diagnostic(p = 3, type = "PRt")
loc_alt_diagnostic(p = 4, type = "PRt")
loc_alt_diagnostic(p = 5, type = "PRt")
loc_alt_diagnostic(p = 11, type = "PRt")

</code></pre>

<hr>
<h2 id='p_Kolmogorov'>Asymptotic distributions for circular uniformity statistics</h2><span id='topic+p_Kolmogorov'></span><span id='topic+d_Kolmogorov'></span><span id='topic+p_cir_stat_Ajne'></span><span id='topic+d_cir_stat_Ajne'></span><span id='topic+p_cir_stat_Bingham'></span><span id='topic+d_cir_stat_Bingham'></span><span id='topic+p_cir_stat_Greenwood'></span><span id='topic+d_cir_stat_Greenwood'></span><span id='topic+p_cir_stat_Gini'></span><span id='topic+d_cir_stat_Gini'></span><span id='topic+p_cir_stat_Gini_squared'></span><span id='topic+d_cir_stat_Gini_squared'></span><span id='topic+p_cir_stat_Hodges_Ajne2'></span><span id='topic+p_cir_stat_Hodges_Ajne'></span><span id='topic+d_cir_stat_Hodges_Ajne'></span><span id='topic+p_cir_stat_Kuiper'></span><span id='topic+d_cir_stat_Kuiper'></span><span id='topic+p_cir_stat_Log_gaps'></span><span id='topic+d_cir_stat_Log_gaps'></span><span id='topic+p_cir_stat_Max_uncover'></span><span id='topic+d_cir_stat_Max_uncover'></span><span id='topic+p_cir_stat_Num_uncover'></span><span id='topic+d_cir_stat_Num_uncover'></span><span id='topic+p_cir_stat_Pycke'></span><span id='topic+d_cir_stat_Pycke'></span><span id='topic+p_cir_stat_Vacancy'></span><span id='topic+d_cir_stat_Vacancy'></span><span id='topic+p_cir_stat_Watson'></span><span id='topic+d_cir_stat_Watson'></span><span id='topic+p_cir_stat_Watson_1976'></span><span id='topic+d_cir_stat_Watson_1976'></span><span id='topic+p_cir_stat_Range'></span><span id='topic+d_cir_stat_Range'></span><span id='topic+p_cir_stat_Rao'></span><span id='topic+d_cir_stat_Rao'></span><span id='topic+p_cir_stat_Rayleigh'></span><span id='topic+d_cir_stat_Rayleigh'></span><span id='topic+cir_stat_distr'></span><span id='topic+p_cir_stat_Bakshaev'></span><span id='topic+d_cir_stat_Bakshaev'></span><span id='topic+p_cir_stat_Gine_Fn'></span><span id='topic+d_cir_stat_Gine_Fn'></span><span id='topic+p_cir_stat_Gine_Gn'></span><span id='topic+d_cir_stat_Gine_Gn'></span><span id='topic+p_cir_stat_Hermans_Rasson'></span><span id='topic+d_cir_stat_Hermans_Rasson'></span><span id='topic+p_cir_stat_PAD'></span><span id='topic+d_cir_stat_PAD'></span><span id='topic+p_cir_stat_PCvM'></span><span id='topic+d_cir_stat_PCvM'></span><span id='topic+p_cir_stat_PRt'></span><span id='topic+d_cir_stat_PRt'></span><span id='topic+p_cir_stat_Pycke_q'></span><span id='topic+d_cir_stat_Pycke_q'></span><span id='topic+p_cir_stat_Rothman'></span><span id='topic+d_cir_stat_Rothman'></span><span id='topic+p_cir_stat_Riesz'></span><span id='topic+d_cir_stat_Riesz'></span><span id='topic+p_cir_stat_Sobolev'></span><span id='topic+d_cir_stat_Sobolev'></span>

<h3>Description</h3>

<p>Computation of the asymptotic null distributions of circular
uniformity statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_Kolmogorov(x, K_Kolmogorov = 25L, alternating = TRUE)

d_Kolmogorov(x, K_Kolmogorov = 25L, alternating = TRUE)

p_cir_stat_Ajne(x, K_Ajne = 15L)

d_cir_stat_Ajne(x, K_Ajne = 15L)

p_cir_stat_Bingham(x)

d_cir_stat_Bingham(x)

p_cir_stat_Greenwood(x)

d_cir_stat_Greenwood(x)

p_cir_stat_Gini(x)

d_cir_stat_Gini(x)

p_cir_stat_Gini_squared(x)

d_cir_stat_Gini_squared(x)

p_cir_stat_Hodges_Ajne2(x, n, asymp_std = FALSE)

p_cir_stat_Hodges_Ajne(x, n, exact = TRUE, asymp_std = FALSE)

d_cir_stat_Hodges_Ajne(x, n, exact = TRUE, asymp_std = FALSE)

p_cir_stat_Kuiper(x, n, K_Kuiper = 12L, second_term = TRUE,
  Stephens = FALSE)

d_cir_stat_Kuiper(x, n, K_Kuiper = 12L, second_term = TRUE,
  Stephens = FALSE)

p_cir_stat_Log_gaps(x, abs_val = TRUE)

d_cir_stat_Log_gaps(x, abs_val = TRUE)

p_cir_stat_Max_uncover(x)

d_cir_stat_Max_uncover(x)

p_cir_stat_Num_uncover(x)

d_cir_stat_Num_uncover(x)

p_cir_stat_Pycke(x)

d_cir_stat_Pycke(x)

p_cir_stat_Vacancy(x)

d_cir_stat_Vacancy(x)

p_cir_stat_Watson(x, n = 0L, K_Watson = 25L, Stephens = FALSE)

d_cir_stat_Watson(x, n = 0L, K_Watson = 25L, Stephens = FALSE)

p_cir_stat_Watson_1976(x, K_Watson_1976 = 8L, N = 40L)

d_cir_stat_Watson_1976(x, K_Watson_1976 = 8L)

p_cir_stat_Range(x, n, max_gap = TRUE)

d_cir_stat_Range(x, n, max_gap = TRUE)

p_cir_stat_Rao(x)

d_cir_stat_Rao(x)

p_cir_stat_Rayleigh(x)

d_cir_stat_Rayleigh(x)

p_cir_stat_Bakshaev(x, K_max = 1000, thre = 0, ...)

d_cir_stat_Bakshaev(x, K_max = 1000, thre = 0, ...)

p_cir_stat_Gine_Fn(x, K_max = 1000, thre = 0, ...)

d_cir_stat_Gine_Fn(x, K_max = 1000, thre = 0, ...)

p_cir_stat_Gine_Gn(x, K_max = 1000, thre = 0, ...)

d_cir_stat_Gine_Gn(x, K_max = 1000, thre = 0, ...)

p_cir_stat_Hermans_Rasson(x, K_max = 1000, thre = 0, ...)

d_cir_stat_Hermans_Rasson(x, K_max = 1000, thre = 0, ...)

p_cir_stat_PAD(x, K_max = 1000, thre = 0, ...)

d_cir_stat_PAD(x, K_max = 1000, thre = 0, ...)

p_cir_stat_PCvM(x, K_max = 1000, thre = 0, ...)

d_cir_stat_PCvM(x, K_max = 1000, thre = 0, ...)

p_cir_stat_PRt(x, t = 1/3, K_max = 1000, thre = 0, ...)

d_cir_stat_PRt(x, t = 1/3, K_max = 1000, thre = 0, ...)

p_cir_stat_Pycke_q(x, q = 0.5, K_max = 1000, thre = 0, ...)

d_cir_stat_Pycke_q(x, q = 0.5, K_max = 1000, thre = 0, ...)

p_cir_stat_Rothman(x, t = 1/3, K_max = 1000, thre = 0, ...)

d_cir_stat_Rothman(x, t = 1/3, K_max = 1000, thre = 0, ...)

p_cir_stat_Riesz(x, s = 1, K_max = 1000, thre = 0, ...)

d_cir_stat_Riesz(x, s = 1, K_max = 1000, thre = 0, ...)

p_cir_stat_Sobolev(x, vk2 = c(0, 0, 1), ...)

d_cir_stat_Sobolev(x, vk2 = c(0, 0, 1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p_Kolmogorov_+3A_x">x</code></td>
<td>
<p>a vector of size <code>nx</code> or a matrix of size <code>c(nx, 1)</code>.</p>
</td></tr>
<tr><td><code id="p_Kolmogorov_+3A_k_kolmogorov">K_Kolmogorov</code>, <code id="p_Kolmogorov_+3A_k_kuiper">K_Kuiper</code>, <code id="p_Kolmogorov_+3A_k_watson">K_Watson</code>, <code id="p_Kolmogorov_+3A_k_watson_1976">K_Watson_1976</code>, <code id="p_Kolmogorov_+3A_k_ajne">K_Ajne</code></td>
<td>
<p>integer giving
the truncation of the series present in the null asymptotic distributions.
For the Kolmogorov-Smirnov-related series defaults to <code>25</code>; for the
others series defaults to a smaller number.</p>
</td></tr>
<tr><td><code id="p_Kolmogorov_+3A_alternating">alternating</code></td>
<td>
<p>use the alternating series expansion for the distribution
of the Kolmogorov-Smirnov statistic? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="p_Kolmogorov_+3A_n">n</code></td>
<td>
<p>sample size employed for computing the statistic.</p>
</td></tr>
<tr><td><code id="p_Kolmogorov_+3A_asymp_std">asymp_std</code></td>
<td>
<p>compute the distribution associated to the normalized
Hodges-Ajne statistic? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="p_Kolmogorov_+3A_exact">exact</code></td>
<td>
<p>use the exact distribution for the Hodges-Ajne statistic?
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="p_Kolmogorov_+3A_second_term">second_term</code></td>
<td>
<p>use the second-order series expansion for the
distribution of the Kuiper statistic? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="p_Kolmogorov_+3A_stephens">Stephens</code></td>
<td>
<p>compute Stephens (1970) modification so that the null
distribution of the is less dependent on the sample size? The modification
does not alter the test decision.</p>
</td></tr>
<tr><td><code id="p_Kolmogorov_+3A_abs_val">abs_val</code></td>
<td>
<p>compute the distribution associated to the absolute value of
the Darling's log gaps statistic? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="p_Kolmogorov_+3A_n">N</code></td>
<td>
<p>number of points used in the
<a href="#topic+Gauss_Legen_nodes">Gauss-Legendre quadrature</a>. Defaults to <code>40</code>.</p>
</td></tr>
<tr><td><code id="p_Kolmogorov_+3A_max_gap">max_gap</code></td>
<td>
<p>compute the distribution associated to the maximum gap for
the range statistic? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="p_Kolmogorov_+3A_k_max">K_max</code></td>
<td>
<p>integer giving the truncation of the series that compute the
asymptotic p-value of a Sobolev test. Defaults to <code>1e3</code>.</p>
</td></tr>
<tr><td><code id="p_Kolmogorov_+3A_thre">thre</code></td>
<td>
<p>error threshold for the tail probability given by the
the first terms of the truncated series of a Sobolev test. Defaults to
<code>0</code> (no further truncation).</p>
</td></tr>
<tr><td><code id="p_Kolmogorov_+3A_...">...</code></td>
<td>
<p>further parameters passed to <code><a href="#topic+p_Sobolev">p_Sobolev</a></code> or
<code><a href="#topic+d_Sobolev">d_Sobolev</a></code> (such as <code>x_tail</code>).</p>
</td></tr>
<tr><td><code id="p_Kolmogorov_+3A_t">t</code></td>
<td>
<p><code class="reqn">t</code> parameter for the Rothman and Cressie tests, a real in
<code class="reqn">(0, 1)</code>. Defaults to <code>1 / 3</code>.</p>
</td></tr>
<tr><td><code id="p_Kolmogorov_+3A_q">q</code></td>
<td>
<p><code class="reqn">q</code> parameter for the Pycke &quot;<code class="reqn">q</code>-test&quot;, a real in
<code class="reqn">(0, 1)</code>. Defaults to <code>1 / 2</code>.</p>
</td></tr>
<tr><td><code id="p_Kolmogorov_+3A_s">s</code></td>
<td>
<p><code class="reqn">s</code> parameter for the <code class="reqn">s</code>-Riesz test, a real in
<code class="reqn">(0, 2)</code>. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="p_Kolmogorov_+3A_vk2">vk2</code></td>
<td>
<p>weights for the finite Sobolev test. A non-negative vector or
matrix. Defaults to <code>c(0, 0, 1)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Descriptions and references for most of the tests are available
in García-Portugués and Verdebout (2018).
</p>


<h3>Value</h3>

<p>A matrix of size <code>c(nx, 1)</code> with the evaluation of the
distribution or density function at <code>x</code>.
</p>


<h3>References</h3>

<p>García-Portugués, E. and Verdebout, T. (2018) An overview of
uniformity tests on the hypersphere. <em>arXiv:1804.00286</em>.
<a href="https://arxiv.org/abs/1804.00286">https://arxiv.org/abs/1804.00286</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Ajne
curve(d_cir_stat_Ajne(x), to = 1.5, n = 2e2, ylim = c(0, 4))
curve(p_cir_stat_Ajne(x), n = 2e2, col = 2, add = TRUE)

# Bakshaev
curve(d_cir_stat_Bakshaev(x, method = "HBE"), to = 6, n = 2e2,
      ylim = c(0, 1))
curve(p_cir_stat_Bakshaev(x, method = "HBE"), n = 2e2, add = TRUE, col = 2)

# Bingham
curve(d_cir_stat_Bingham(x), to = 12, n = 2e2, ylim = c(0, 1))
curve(p_cir_stat_Bingham(x), n = 2e2, col = 2, add = TRUE)
# Greenwood
curve(d_cir_stat_Greenwood(x), from = -6, to = 6, n = 2e2, ylim = c(0, 1))
curve(p_cir_stat_Greenwood(x), n = 2e2, col = 2, add = TRUE)

# Hermans-Rasson
curve(p_cir_stat_Hermans_Rasson(x, method = "HBE"), to = 10, n = 2e2,
      ylim = c(0, 1))
curve(d_cir_stat_Hermans_Rasson(x, method = "HBE"), n = 2e2, add = TRUE,
      col = 2)

# Hodges-Ajne
plot(25:45, d_cir_stat_Hodges_Ajne(cbind(25:45), n = 50), type = "h",
     lwd = 2, ylim = c(0, 1))
lines(25:45, p_cir_stat_Hodges_Ajne(cbind(25:45), n = 50), type = "s",
      col = 2)

# Kolmogorov-Smirnov
curve(d_Kolmogorov(x), to = 3, n = 2e2, ylim = c(0, 2))
curve(p_Kolmogorov(x), n = 2e2, col = 2, add = TRUE)

# Kuiper
curve(d_cir_stat_Kuiper(x, n = 50), to = 3, n = 2e2, ylim = c(0, 2))
curve(p_cir_stat_Kuiper(x, n = 50), n = 2e2, col = 2, add = TRUE)

# Kuiper and Watson with Stephens modification
curve(d_cir_stat_Kuiper(x, n = 8, Stephens = TRUE), to = 2.5, n = 2e2,
      ylim = c(0, 10))
curve(d_cir_stat_Watson(x, n = 8, Stephens = TRUE), n = 2e2, lty = 2,
      add = TRUE)
n &lt;- c(10, 20, 30, 40, 50, 100, 500)
col &lt;- rainbow(length(n))
for (i in seq_along(n)) {
  curve(d_cir_stat_Kuiper(x, n = n[i], Stephens = TRUE), n = 2e2,
        col = col[i], add = TRUE)
  curve(d_cir_stat_Watson(x, n = n[i], Stephens = TRUE), n = 2e2,
        col = col[i], lty = 2, add = TRUE)
}

# Maximum uncovered spacing
curve(d_cir_stat_Max_uncover(x), from = -3, to = 6, n = 2e2, ylim = c(0, 1))
curve(p_cir_stat_Max_uncover(x), n = 2e2, col = 2, add = TRUE)

# Number of uncovered spacing
curve(d_cir_stat_Num_uncover(x), from = -4, to = 4, n = 2e2, ylim = c(0, 1))
curve(p_cir_stat_Num_uncover(x), n = 2e2, col = 2, add = TRUE)

# Log gaps
curve(d_cir_stat_Log_gaps(x), from = -1, to = 4, n = 2e2, ylim = c(0, 1))
curve(p_cir_stat_Log_gaps(x), n = 2e2, col = 2, add = TRUE)

# Gine Fn
curve(d_cir_stat_Gine_Fn(x, method = "HBE"), to = 2.5, n = 2e2,
      ylim = c(0, 2))
curve(p_cir_stat_Gine_Fn(x, method = "HBE"), n = 2e2, add = TRUE, col = 2)

# Gine Gn
curve(d_cir_stat_Gine_Gn(x, method = "HBE"), to = 2.5, n = 2e2,
      ylim = c(0, 2))
curve(p_cir_stat_Gine_Gn(x, method = "HBE"), n = 2e2, add = TRUE, col = 2)

# Gini mean difference
curve(d_cir_stat_Gini(x), from = -4, to = 4, n = 2e2, ylim = c(0, 1))
curve(p_cir_stat_Gini(x), n = 2e2, col = 2, add = TRUE)

# Gini mean squared difference
curve(d_cir_stat_Gini_squared(x), from = -10, to = 10, n = 2e2,
      ylim = c(0, 1))
curve(p_cir_stat_Gini_squared(x), n = 2e2, col = 2, add = TRUE)

# PAD
curve(d_cir_stat_PAD(x, method = "HBE"), to = 3, n = 2e2, ylim = c(0, 1.5))
curve(p_cir_stat_PAD(x, method = "HBE"), n = 2e2, add = TRUE, col = 2)

# PCvM
curve(d_cir_stat_PCvM(x, method = "HBE"), to = 4, n = 2e2, ylim = c(0, 2))
curve(p_cir_stat_PCvM(x, method = "HBE"), n = 2e2, add = TRUE, col = 2)

# PRt
curve(d_cir_stat_PRt(x, method = "HBE"), n = 2e2, ylim = c(0, 5))
curve(p_cir_stat_PRt(x, method = "HBE"), n = 2e2, add = TRUE, col = 2)

# Pycke
curve(d_cir_stat_Pycke(x), from = -5, to = 10, n = 2e2, ylim = c(0, 1))
curve(p_cir_stat_Pycke(x), n = 2e2, col = 2, add = TRUE)

# Pycke q
curve(d_cir_stat_Pycke_q(x, method = "HBE"), to = 15, n = 2e2,
      ylim = c(0, 1))
curve(p_cir_stat_Pycke_q(x, method = "HBE"), n = 2e2, add = TRUE, col = 2)

# Range
curve(d_cir_stat_Range(x, n = 50), to = 2, n = 2e2, ylim = c(0, 4))
curve(p_cir_stat_Range(x, n = 50), n = 2e2, col = 2, add = TRUE)

# Rao
curve(d_cir_stat_Rao(x), from = -6, to = 6, n = 2e2, ylim = c(0, 1))
curve(p_cir_stat_Rao(x), n = 2e2, col = 2, add = TRUE)

# Rayleigh
curve(d_cir_stat_Rayleigh(x), to = 12, n = 2e2, ylim = c(0, 1))
curve(p_cir_stat_Rayleigh(x), n = 2e2, col = 2, add = TRUE)

# Riesz
curve(d_cir_stat_Riesz(x, method = "HBE"), to = 6, n = 2e2,
      ylim = c(0, 1))
curve(p_cir_stat_Riesz(x, method = "HBE"), n = 2e2, add = TRUE, col = 2)

# Rothman
curve(d_cir_stat_Rothman(x, method = "HBE"), n = 2e2, ylim = c(0, 5))
curve(p_cir_stat_Rothman(x, method = "HBE"), n = 2e2, add = TRUE, col = 2)

# Vacancy
curve(d_cir_stat_Vacancy(x), from = -4, to = 4, n = 2e2, ylim = c(0, 1))
curve(p_cir_stat_Vacancy(x), n = 2e2, col = 2, add = TRUE)

# Watson
curve(d_cir_stat_Watson(x), to = 0.5, n = 2e2, ylim = c(0, 15))
curve(p_cir_stat_Watson(x), n = 2e2, col = 2, add = TRUE)

# Watson (1976)
curve(d_cir_stat_Watson_1976(x), to = 1.5, n = 2e2, ylim = c(0, 3))
curve(p_cir_stat_Watson_1976(x), n = 2e2, col = 2, add = TRUE)

# Sobolev
vk2 &lt;- c(0.5, 0)
curve(d_cir_stat_Sobolev(x = x, vk2 = vk2), to = 3, n = 2e2, ylim = c(0, 2))
curve(p_cir_stat_Sobolev(x = x, vk2 = vk2), n = 2e2, col = 2, add = TRUE)
</code></pre>

<hr>
<h2 id='p_sph_stat_Bingham'>Asymptotic distributions for spherical uniformity statistics</h2><span id='topic+p_sph_stat_Bingham'></span><span id='topic+d_sph_stat_Bingham'></span><span id='topic+p_sph_stat_CJ12'></span><span id='topic+d_sph_stat_CJ12'></span><span id='topic+p_sph_stat_Rayleigh'></span><span id='topic+d_sph_stat_Rayleigh'></span><span id='topic+p_sph_stat_Rayleigh_HD'></span><span id='topic+d_sph_stat_Rayleigh_HD'></span><span id='topic+sph_stat_distr'></span><span id='topic+p_sph_stat_Ajne'></span><span id='topic+d_sph_stat_Ajne'></span><span id='topic+p_sph_stat_Bakshaev'></span><span id='topic+d_sph_stat_Bakshaev'></span><span id='topic+p_sph_stat_Gine_Fn'></span><span id='topic+d_sph_stat_Gine_Fn'></span><span id='topic+p_sph_stat_Gine_Gn'></span><span id='topic+d_sph_stat_Gine_Gn'></span><span id='topic+p_sph_stat_PAD'></span><span id='topic+d_sph_stat_PAD'></span><span id='topic+p_sph_stat_PCvM'></span><span id='topic+d_sph_stat_PCvM'></span><span id='topic+p_sph_stat_PRt'></span><span id='topic+d_sph_stat_PRt'></span><span id='topic+p_sph_stat_Riesz'></span><span id='topic+d_sph_stat_Riesz'></span><span id='topic+p_sph_stat_Sobolev'></span><span id='topic+d_sph_stat_Sobolev'></span>

<h3>Description</h3>

<p>Computation of the asymptotic null distributions of
spherical uniformity statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_sph_stat_Bingham(x, p)

d_sph_stat_Bingham(x, p)

p_sph_stat_CJ12(x, regime = 1L, beta = 0)

d_sph_stat_CJ12(x, regime = 3L, beta = 0)

p_sph_stat_Rayleigh(x, p)

d_sph_stat_Rayleigh(x, p)

p_sph_stat_Rayleigh_HD(x, p)

d_sph_stat_Rayleigh_HD(x, p)

p_sph_stat_Ajne(x, p, K_max = 1000, thre = 0, ...)

d_sph_stat_Ajne(x, p, K_max = 1000, thre = 0, ...)

p_sph_stat_Bakshaev(x, p, K_max = 1000, thre = 0, ...)

d_sph_stat_Bakshaev(x, p, K_max = 1000, thre = 0, ...)

p_sph_stat_Gine_Fn(x, p, K_max = 1000, thre = 0, ...)

d_sph_stat_Gine_Fn(x, p, K_max = 1000, thre = 0, ...)

p_sph_stat_Gine_Gn(x, p, K_max = 1000, thre = 0, ...)

d_sph_stat_Gine_Gn(x, p, K_max = 1000, thre = 0, ...)

p_sph_stat_PAD(x, p, K_max = 1000, thre = 0, ...)

d_sph_stat_PAD(x, p, K_max = 1000, thre = 0, ...)

p_sph_stat_PCvM(x, p, K_max = 1000, thre = 0, ...)

d_sph_stat_PCvM(x, p, K_max = 1000, thre = 0, ...)

p_sph_stat_PRt(x, p, t = 1/3, K_max = 1000, thre = 0, ...)

d_sph_stat_PRt(x, p, t = 1/3, K_max = 1000, thre = 0, ...)

p_sph_stat_Riesz(x, p, s = 1, K_max = 1000, thre = 0, ...)

d_sph_stat_Riesz(x, p, s = 1, K_max = 1000, thre = 0, ...)

p_sph_stat_Sobolev(x, p, vk2 = c(0, 0, 1), K_max = 1000, thre = 0, ...)

d_sph_stat_Sobolev(x, p, vk2 = c(0, 0, 1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p_sph_stat_Bingham_+3A_x">x</code></td>
<td>
<p>a vector of size <code>nx</code> or a matrix of size <code>c(nx, 1)</code>.</p>
</td></tr>
<tr><td><code id="p_sph_stat_Bingham_+3A_p">p</code></td>
<td>
<p>integer giving the dimension of the ambient space <code class="reqn">R^p</code> that
contains <code class="reqn">S^{p-1}</code>.</p>
</td></tr>
<tr><td><code id="p_sph_stat_Bingham_+3A_regime">regime</code></td>
<td>
<p>type of asymptotic regime for the CJ12 test, either <code>1</code>
(sub-exponential regime), <code>2</code> (exponential), or <code>3</code>
(super-exponential; default).</p>
</td></tr>
<tr><td><code id="p_sph_stat_Bingham_+3A_beta">beta</code></td>
<td>
<p><code class="reqn">\beta</code> parameter in the exponential regime of the CJ12
test, a non-negative real. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="p_sph_stat_Bingham_+3A_k_max">K_max</code></td>
<td>
<p>integer giving the truncation of the series that compute the
asymptotic p-value of a Sobolev test. Defaults to <code>1e3</code>.</p>
</td></tr>
<tr><td><code id="p_sph_stat_Bingham_+3A_thre">thre</code></td>
<td>
<p>error threshold for the tail probability given by the
the first terms of the truncated series of a Sobolev test. Defaults to
<code>0</code> (no further truncation).</p>
</td></tr>
<tr><td><code id="p_sph_stat_Bingham_+3A_...">...</code></td>
<td>
<p>further parameters passed to <code><a href="#topic+p_Sobolev">p_Sobolev</a></code> or
<code><a href="#topic+d_Sobolev">d_Sobolev</a></code> (such as <code>x_tail</code>).</p>
</td></tr>
<tr><td><code id="p_sph_stat_Bingham_+3A_t">t</code></td>
<td>
<p><code class="reqn">t</code> parameter for the Rothman and Cressie tests, a real in
<code class="reqn">(0, 1)</code>. Defaults to <code>1 / 3</code>.</p>
</td></tr>
<tr><td><code id="p_sph_stat_Bingham_+3A_s">s</code></td>
<td>
<p><code class="reqn">s</code> parameter for the <code class="reqn">s</code>-Riesz test, a real in
<code class="reqn">(0, 2)</code>. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="p_sph_stat_Bingham_+3A_vk2">vk2</code></td>
<td>
<p>weights for the finite Sobolev test. A non-negative vector or
matrix. Defaults to <code>c(0, 0, 1)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Descriptions and references on most of the asymptotic distributions
are available in García-Portugués and Verdebout (2018).
</p>


<h3>Value</h3>


<ul>
<li> <p><code>r_sph_stat_*</code>: a matrix of size <code>c(n, 1)</code> containing
the sample.
</p>
</li>
<li> <p><code>p_sph_stat_*</code>, <code>d_sph_stat_*</code>: a matrix of size
<code>c(nx, 1)</code> with the evaluation of the distribution or density
functions at <code>x</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Ajne
curve(d_sph_stat_Ajne(x, p = 3, method = "HBE"), n = 2e2, ylim = c(0, 4))
curve(p_sph_stat_Ajne(x, p = 3, method = "HBE"), n = 2e2, col = 2,
      add = TRUE)

# Bakshaev
curve(d_sph_stat_Bakshaev(x, p = 3, method = "HBE"), to = 5, n = 2e2,
      ylim = c(0, 2))
curve(p_sph_stat_Bakshaev(x, p = 3, method = "HBE"), n = 2e2, col = 2,
      add = TRUE)

# Bingham
curve(d_sph_stat_Bingham(x, p = 3), to = 20, n = 2e2, ylim = c(0, 1))
curve(p_sph_stat_Bingham(x, p = 3), n = 2e2, col = 2, add = TRUE)

# CJ12
curve(d_sph_stat_CJ12(x, regime = 1), from = -10, to = 10, n = 2e2,
      ylim = c(0, 1))
curve(d_sph_stat_CJ12(x, regime = 2, beta = 0.1), n = 2e2, col = 2,
      add = TRUE)
curve(d_sph_stat_CJ12(x, regime = 3), n = 2e2, col = 3, add = TRUE)
curve(p_sph_stat_CJ12(x, regime = 1), n = 2e2, col = 1, add = TRUE)
curve(p_sph_stat_CJ12(x, regime = 2, beta = 0.1), n = 2e2, col = 2,
      add = TRUE)
curve(p_sph_stat_CJ12(x, regime = 3), col = 3, add = TRUE)

# Gine Fn
curve(d_sph_stat_Gine_Fn(x, p = 3, method = "HBE"), to = 2, n = 2e2,
      ylim = c(0, 2))
curve(p_sph_stat_Gine_Fn(x, p = 3, method = "HBE"), n = 2e2, col = 2,
      add = TRUE)

# Gine Gn
curve(d_sph_stat_Gine_Gn(x, p = 3, method = "HBE"), to = 1.5, n = 2e2,
      ylim = c(0, 2.5))
curve(p_sph_stat_Gine_Gn(x, p = 3, method = "HBE"), n = 2e2, col = 2,
      add = TRUE)

# PAD
curve(d_sph_stat_PAD(x, p = 3, method = "HBE"), to = 3, n = 2e2,
      ylim = c(0, 1.5))
curve(p_sph_stat_PAD(x, p = 3, method = "HBE"), n = 2e2, col = 2,
      add = TRUE)

# PCvM
curve(d_sph_stat_PCvM(x, p = 3, method = "HBE"), to = 0.6, n = 2e2,
      ylim = c(0, 7))
curve(p_sph_stat_PCvM(x, p = 3, method = "HBE"), n = 2e2, col = 2,
      add = TRUE)

# PRt
curve(d_sph_stat_PRt(x, p = 3, method = "HBE"), n = 2e2, ylim = c(0, 5))
curve(p_sph_stat_PRt(x, p = 3, method = "HBE"), n = 2e2, col = 2, add = TRUE)

# Rayleigh
curve(d_sph_stat_Rayleigh(x, p = 3), to = 15, n = 2e2, ylim = c(0, 1))
curve(p_sph_stat_Rayleigh(x, p = 3), n = 2e2, col = 2, add = TRUE)

# HD-standardized Rayleigh
curve(d_sph_stat_Rayleigh_HD(x, p = 3), from = -4, to = 4, n = 2e2,
      ylim = c(0, 1))
curve(p_sph_stat_Rayleigh_HD(x, p = 3), n = 2e2, col = 2, add = TRUE)

# Riesz
curve(d_sph_stat_Riesz(x, p = 3, method = "HBE"), n = 2e2, from = 0, to = 5,
      ylim = c(0, 2))
curve(p_sph_stat_Riesz(x, p = 3, method = "HBE"), n = 2e2, col = 2,
      add = TRUE)

# Sobolev
x &lt;- seq(-1, 5, by = 0.05)
vk2 &lt;- diag(rep(0.3, 2))
matplot(x, d_sph_stat_Sobolev(x = x, vk2 = vk2, p = 3), type = "l",
        ylim = c(0, 1), lty = 1)
matlines(x, p_sph_stat_Sobolev(x = x, vk2 = vk2, p = 3), lty = 1)
matlines(x, d_sph_stat_Sobolev(x = x, vk2 = vk2 + 0.01, p = 3), lty = 2)
matlines(x, p_sph_stat_Sobolev(x = x, vk2 = vk2 + 0.01, p = 3), lty = 2)
</code></pre>

<hr>
<h2 id='planets'>Planet orbits</h2><span id='topic+planets'></span>

<h3>Description</h3>

<p>Planet orbits data from the
<a href="https://ssd.jpl.nasa.gov/planets/approx_pos.html">
JPL Keplerian Elements for Approximate Positions of the Major Planets</a>.
The normal vector of a planet orbit represents is a vector on <code class="reqn">S^2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>planets
</code></pre>


<h3>Format</h3>

<p>A data frame with 9 rows and 3 variables:
</p>

<dl>
<dt>planet</dt><dd><p>names of the planets and Pluto.</p>
</dd>
<dt>i</dt><dd><p>inclination; the orbit's plane angle with respect to the
ecliptic plane, in radians in <code class="reqn">[0, \pi]</code>.</p>
</dd>
<dt>om</dt><dd><p>longitude of the ascending node; the counterclockwise angle from
the vector pointing to the First Point of Aries and that pointing to
the ascending node (the intersection between orbit and ecliptic plane), in
radians in <code class="reqn">[0, 2\pi)</code>. (Both vectors are heliocentric and within
the ecliptic plane.)</p>
</dd>
</dl>



<h3>Details</h3>

<p>The normal vector to the ecliptic plane of the planet with inclination
<code class="reqn">i</code> and longitude of the ascending node <code class="reqn">\omega</code> is
</p>
<p style="text-align: center;"><code class="reqn">(\sin(i) \sin(\omega), -\sin(i) \cos(\omega), \cos(i))'.</code>
</p>

<p>The script performing the data preprocessing is available at
<a href="https://github.com/egarpor/sphunif/blob/master/data-raw/planets.R">
<code>planets.R</code></a>. The data was retrieved on 2020-05-16.
</p>


<h3>Source</h3>

<p>Table 2a in <a href="https://ssd.jpl.nasa.gov/planets/approx_pos.html">https://ssd.jpl.nasa.gov/planets/approx_pos.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data("planets")

# Add normal vectors
planets$normal &lt;- cbind(sin(planets$i) * sin(planets$om),
                       -sin(planets$i) * cos(planets$om),
                       cos(planets$i))

# Tests to be performed
type_tests &lt;- c("PCvM", "PAD", "PRt")

# Tests with Pluto
unif_test(data = planets$normal, type = type_tests, p_value = "MC")

# Tests without Pluto
unif_test(data = planets$normal[-9, ], type = type_tests, p_value = "MC")
</code></pre>

<hr>
<h2 id='Pn'>Utilities for projected-ecdf statistics of spherical uniformity</h2><span id='topic+Pn'></span><span id='topic+psi_Pn'></span><span id='topic+Gegen_coefs_Pn'></span><span id='topic+akx'></span><span id='topic+f_locdev_Pn'></span>

<h3>Description</h3>

<p>Computation of the kernels
</p>
<p style="text-align: center;"><code class="reqn">\psi_p^W(\theta) := \int_{-1}^1 A_x(\theta)\,\mathrm{d}W(F_p(x)),</code>
</p>

<p>where <code class="reqn">A_x(\theta)</code> is the proportion of area surface of
<code class="reqn">S^{p - 1}</code> covered by the
<a href="#topic+A_theta_x">intersection of two hyperspherical caps</a> with common solid
angle <code class="reqn">\pi - \cos^{-1}(x)</code> and centers separated by
an angle <code class="reqn">\theta \in [0, \pi]</code>, <code class="reqn">F_p</code> is the distribution function
of the <a href="#topic+p_proj_unif">projected spherical uniform distribution</a>,
and <code class="reqn">W</code> is a measure on <code class="reqn">[0, 1]</code>.
</p>
<p>Also, computation of the <a href="#topic+Gegen_coefs">Gegenbauer coefficients</a> of
<code class="reqn">\psi_p^W</code>:
</p>
<p style="text-align: center;"><code class="reqn">b_{k, p}^W := \frac{1}{c_{k, p}}\int_0^\pi \psi_p^W(\theta)
C_k^{p / 2 - 1}(\cos\theta)\,\mathrm{d}\theta.</code>
</p>

<p>These coefficients can also be computed via
</p>
<p style="text-align: center;"><code class="reqn">b_{k, p}^W = \int_{-1}^1 a_{k, p}^x\,\mathrm{d}W(F_p(x))</code>
</p>

<p>for a certain function <code class="reqn">x\rightarrow a_{k, p}^x</code>. They serve to define
<a href="#topic+locdev">projected alternatives to uniformity</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psi_Pn(theta, q, type, Rothman_t = 1/3, tilde = FALSE, psi_Gauss = TRUE,
  psi_N = 320, tol = 1e-06)

Gegen_coefs_Pn(k, p, type, Rothman_t = 1/3, Gauss = TRUE, N = 320,
  tol = 1e-06, verbose = FALSE)

akx(x, p, k, sqr = FALSE)

f_locdev_Pn(p, type, K = 1000, N = 320, K_max = 10000, thre = 0.001,
  Rothman_t = 1/3, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pn_+3A_theta">theta</code></td>
<td>
<p>vector with values in <code class="reqn">[0, \pi]</code>.</p>
</td></tr>
<tr><td><code id="Pn_+3A_q">q</code></td>
<td>
<p>integer giving the dimension of the sphere <code class="reqn">S^q</code>.</p>
</td></tr>
<tr><td><code id="Pn_+3A_type">type</code></td>
<td>
<p>type of projected-ecdf test statistic. Must be either
<code>"PCvM"</code> (Cramér&ndash;von Mises), <code>"PAD"</code> (Anderson&ndash;Darling), or
<code>"PRt"</code> (Rothman).</p>
</td></tr>
<tr><td><code id="Pn_+3A_rothman_t">Rothman_t</code></td>
<td>
<p><code class="reqn">t</code> parameter for the Rothman test, a real in
<code class="reqn">(0, 1)</code>. Defaults to <code>1 / 3</code>.</p>
</td></tr>
<tr><td><code id="Pn_+3A_tilde">tilde</code></td>
<td>
<p>include the constant and bias term? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Pn_+3A_psi_gauss">psi_Gauss</code></td>
<td>
<p>use a <a href="#topic+Gauss_Legen_nodes">Gauss&ndash;Legendre quadrature</a>
rule with <code>psi_N</code> nodes in the computation of the kernel function?
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="Pn_+3A_psi_n">psi_N</code></td>
<td>
<p>number of points used in the Gauss&ndash;Legendre quadrature for
computing the kernel function. Defaults to <code>320</code>.</p>
</td></tr>
<tr><td><code id="Pn_+3A_tol">tol</code></td>
<td>
<p>tolerance passed to <code><a href="stats.html#topic+integrate">integrate</a></code>'s <code>rel.tol</code> and
<code>abs.tol</code> if <code>Gauss = FALSE</code>. Defaults to <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="Pn_+3A_k">k</code></td>
<td>
<p>vector with the index of coefficients.</p>
</td></tr>
<tr><td><code id="Pn_+3A_p">p</code></td>
<td>
<p>integer giving the dimension of the ambient space <code class="reqn">R^p</code> that
contains <code class="reqn">S^{p-1}</code>.</p>
</td></tr>
<tr><td><code id="Pn_+3A_gauss">Gauss</code></td>
<td>
<p>use a Gauss&ndash;Legendre quadrature rule of <code>N</code> nodes
in the computation of the Gegenbauer coefficients? Otherwise, call
<code><a href="stats.html#topic+integrate">integrate</a></code>. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="Pn_+3A_n">N</code></td>
<td>
<p>number of points used in the <a href="#topic+Gauss_Legen_nodes">
Gauss&ndash;Legendre quadrature</a> for computing the Gegenbauer coefficients.
Defaults to <code>320</code>.</p>
</td></tr>
<tr><td><code id="Pn_+3A_verbose">verbose</code></td>
<td>
<p>flag to print informative messages. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Pn_+3A_x">x</code></td>
<td>
<p>evaluation points for <code class="reqn">a_{k, p}^x</code>, a vector with values in
<code class="reqn">[-1, 1]</code>.</p>
</td></tr>
<tr><td><code id="Pn_+3A_sqr">sqr</code></td>
<td>
<p>return the <em>signed</em> square root of <code class="reqn">a_{k, p}^x</code>?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Pn_+3A_k">K</code></td>
<td>
<p>number of equispaced points on <code class="reqn">[-1, 1]</code> used for evaluating
<code class="reqn">f</code> and then interpolating. Defaults to <code>1e3</code>.</p>
</td></tr>
<tr><td><code id="Pn_+3A_k_max">K_max</code></td>
<td>
<p>integer giving the truncation of the series. Defaults to
<code>1e4</code>.</p>
</td></tr>
<tr><td><code id="Pn_+3A_thre">thre</code></td>
<td>
<p>proportion of norm <em>not</em> explained by the first terms of the
truncated series. Defaults to <code>1e-3</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The evaluation of <code class="reqn">\psi_p^W</code> and <code class="reqn">b_{k, p}^W</code> depends on the type of
projected-ecdf statistic:
</p>

<ul>
<li><p> PCvM: closed-form expressions for <code class="reqn">\psi_p^W</code> and <code class="reqn">b_{k, p}^W</code>
with <code class="reqn">p = 2, 3, 4</code>, numerical integration required for <code class="reqn">p \ge 5</code>.
</p>
</li>
<li><p> PAD: closed-form expressions for <code class="reqn">\psi_2^W</code> and <code class="reqn">b_{k, 3}^W</code>,
numerical integration required for <code class="reqn">\psi_p^W</code> with <code class="reqn">p \ge 3</code> and
<code class="reqn">b_{k, p}^W</code> with <code class="reqn">p = 2</code> and <code class="reqn">p \ge 4</code>.
</p>
</li>
<li><p> PRt: closed-form expressions for <code class="reqn">\psi_p^W</code> and <code class="reqn">b_{k, p}^W</code>
for any <code class="reqn">p \ge 2</code>.
</p>
</li></ul>

<p>See García-Portugués et al. (2023) for more details.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>psi_Pn</code>: a vector of size <code>length(theta)</code> with the
evaluation of <code class="reqn">\psi</code>.
</p>
</li>
<li> <p><code>Gegen_coefs_Pn</code>: a vector of size <code>length(k)</code> containing
the coefficients <code class="reqn">b_{k, p}^W</code>.
</p>
</li>
<li> <p><code>akx</code>: a matrix of size <code>c(length(x), length(k))</code>
containing the coefficients <code class="reqn">a_{k, p}^x</code>.
</p>
</li>
<li> <p><code>f_locdev_Pn</code>: the projected alternative <code class="reqn">f</code> as a function
ready to be evaluated.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Eduardo García-Portugués and Paula Navarro-Esteban.
</p>


<h3>References</h3>

<p>García-Portugués, E., Navarro-Esteban, P., Cuesta-Albertos, J. A. (2023)
On a projection-based class of uniformity tests on the hypersphere.
<em>Bernoulli</em>, 29(1):181&ndash;204. <a href="https://doi.org/10.3150/21-BEJ1454">doi:10.3150/21-BEJ1454</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Kernels in the projected-ecdf test statistics
k &lt;- 0:10
coefs &lt;- list()
(coefs$PCvM &lt;- t(sapply(2:5, function(p)
  Gegen_coefs_Pn(k = k, p = p, type = "PCvM"))))
(coefs$PAD &lt;- t(sapply(2:5, function(p)
  Gegen_coefs_Pn(k = k, p = p, type = "PAD"))))
(coefs$PRt &lt;- t(sapply(2:5, function(p)
  Gegen_coefs_Pn(k = k, p = p, type = "PRt"))))

# Gegenbauer expansion
th &lt;- seq(0, pi, length.out = 501)[-501]
old_par &lt;- par(mfrow = c(3, 4))
for (type in c("PCvM", "PAD", "PRt")) {

  for (p in 2:5) {

    plot(th, psi_Pn(theta = th, q = p - 1, type = type), type = "l",
         main = paste0(type, ", p = ", p), xlab = expression(theta),
         ylab = expression(psi(theta)), axes = FALSE, ylim = c(-1.5, 1))
    axis(1, at = c(0, pi / 4, pi / 2, 3 * pi / 4, pi),
         labels = expression(0, pi / 4, pi / 2, 3 * pi / 4, pi))
    axis(2); box()
    lines(th, Gegen_series(theta = th, coefs = coefs[[type]][p - 1, ],
                           k = k, p = p), col = 2)

  }

}
par(old_par)

# Analytical coefficients vs. numerical integration
test_coef &lt;- function(type, p, k = 0:20) {

  plot(k, log1p(abs(Gegen_coefs_Pn(k = k, p = p, type = type))),
       ylab = "Coefficients", main = paste0(type, ", p = ", p))
  points(k, log1p(abs(Gegen_coefs(k = k, p = p, psi = psi_Pn, type = type,
                                  q = p - 1))), col = 2)
  legend("topright", legend = c("log(1 + Gegen_coefs_Pn))",
                                "log(1 + Gegen_coefs(psi_Pn))"),
         lwd = 2, col = 1:2)

}

# PCvM statistic
old_par &lt;- par(mfrow = c(2, 2))
for (p in 2:5) test_coef(type = "PCvM", p = p)
par(old_par)

# PAD statistic
old_par &lt;- par(mfrow = c(2, 2))
for (p in 2:5) test_coef(type = "PAD", p = p)
par(old_par)

# PRt statistic
old_par &lt;- par(mfrow = c(2, 2))
for (p in 2:5) test_coef(type = "PRt", p = p)
par(old_par)

# akx
akx(x = seq(-1, 1, l = 5), k = 1:4, p = 2)
akx(x = 0, k = 1:4, p = 3)

# PRt alternative to uniformity
z &lt;- seq(-1, 1, l = 1e3)
p &lt;- c(2:5, 10, 15, 17)
col &lt;- viridisLite::viridis(length(p))
plot(z, f_locdev_Pn(p = p[1], type = "PRt")(z), type = "s",
     col = col[1], ylim = c(0, 0.6), ylab = expression(f[Rt](z)))
for (k in 2:length(p)) {
  lines(z, f_locdev_Pn(p = p[k], type = "PRt")(z), type = "s", col = col[k])
}
legend("topleft", legend = paste("p =", p), col = col, lwd = 2)
</code></pre>

<hr>
<h2 id='proj_unif'>Projection of the spherical uniform distribution</h2><span id='topic+proj_unif'></span><span id='topic+d_proj_unif'></span><span id='topic+p_proj_unif'></span><span id='topic+q_proj_unif'></span><span id='topic+r_proj_unif'></span>

<h3>Description</h3>

<p>Density, distribution, and quantile functions of the
projection of the spherical uniform random variable on an arbitrary
direction, that is, the random variable
<code class="reqn">\boldsymbol{\gamma}'{\bf X}</code>, where <code class="reqn">{\bf X}</code>
is uniformly distributed on the (hyper)sphere
<code class="reqn">S^{p-1}:=\{{\bf x}\in R^p:||{\bf x}||=1\}</code>, <code class="reqn">p\ge 2</code>, and
<code class="reqn">\boldsymbol{\gamma}\in S^{p-1}</code> is an
<em>arbitrary</em> projection direction. Note that the distribution is
invariant to the choice of <code class="reqn">\boldsymbol{\gamma}</code>. Also,
efficient simulation of <code class="reqn">\boldsymbol{\gamma}'{\bf X}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_proj_unif(x, p, log = FALSE)

p_proj_unif(x, p, log = FALSE)

q_proj_unif(u, p)

r_proj_unif(n, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proj_unif_+3A_x">x</code></td>
<td>
<p>a vector of size <code>nx</code> or a matrix of size <code>c(nx, 1)</code>.</p>
</td></tr>
<tr><td><code id="proj_unif_+3A_p">p</code></td>
<td>
<p>integer giving the dimension of the ambient space <code class="reqn">R^p</code> that
contains <code class="reqn">S^{p-1}</code>.</p>
</td></tr>
<tr><td><code id="proj_unif_+3A_log">log</code></td>
<td>
<p>compute the logarithm of the density or distribution?</p>
</td></tr>
<tr><td><code id="proj_unif_+3A_u">u</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="proj_unif_+3A_n">n</code></td>
<td>
<p>sample size employed for computing the statistic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size <code>c(nx, 1)</code> with the evaluation of the
density, distribution, or quantile function at <code>x</code> or <code>u</code>.
For <code>r_proj_unif</code>, a random vector of size <code>n</code>.
</p>


<h3>Author(s)</h3>

<p>Eduardo García-Portugués and Paula Navarro-Esteban.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Density function
curve(d_proj_unif(x, p = 2), from = -2, to = 2, n = 2e2, ylim = c(0, 2))
curve(d_proj_unif(x, p = 3), n = 2e2, col = 2, add = TRUE)
curve(d_proj_unif(x, p = 4), n = 2e2, col = 3, add = TRUE)
curve(d_proj_unif(x, p = 5), n = 2e2, col = 4, add = TRUE)
curve(d_proj_unif(x, p = 6), n = 2e2, col = 5, add = TRUE)

# Distribution function
curve(p_proj_unif(x, p = 2), from = -2, to = 2, n = 2e2, ylim = c(0, 1))
curve(p_proj_unif(x, p = 3), n = 2e2, col = 2, add = TRUE)
curve(p_proj_unif(x, p = 4), n = 2e2, col = 3, add = TRUE)
curve(p_proj_unif(x, p = 5), n = 2e2, col = 4, add = TRUE)
curve(p_proj_unif(x, p = 6), n = 2e2, col = 5, add = TRUE)

# Quantile function
curve(q_proj_unif(u = x, p = 2), from = 0, to = 1, n = 2e2, ylim = c(-1, 1))
curve(q_proj_unif(u = x, p = 3), n = 2e2, col = 2, add = TRUE)
curve(q_proj_unif(u = x, p = 4), n = 2e2, col = 3, add = TRUE)
curve(q_proj_unif(u = x, p = 5), n = 2e2, col = 4, add = TRUE)
curve(q_proj_unif(u = x, p = 6), n = 2e2, col = 5, add = TRUE)

# Sampling
hist(r_proj_unif(n = 1e4, p = 4), freq = FALSE, breaks = 50)
curve(d_proj_unif(x, p = 4), n = 2e2, col = 3, add = TRUE)
</code></pre>

<hr>
<h2 id='Psi'>Shortest angles matrix</h2><span id='topic+Psi'></span><span id='topic+Psi_mat'></span><span id='topic+upper_tri_ind'></span>

<h3>Description</h3>

<p>Efficient computation of the shortest angles matrix
<code class="reqn">\boldsymbol\Psi</code>, defined as
</p>
<p style="text-align: center;"><code class="reqn">\Psi_{ij}:=\cos^{-1}({\bf X}_i'{\bf X}_j),\quad
i,j=1,\ldots,n,</code>
</p>

<p>for a sample <code class="reqn">{\bf X}_1,\ldots,{\bf X}_n\in S^{p-1}:=\{{\bf x}\in
R^p:||{\bf x}||=1\}</code>, <code class="reqn">p\ge 2</code>.
</p>
<p>For a circular sample <code class="reqn">\Theta_1, \ldots, \Theta_n \in [0, 2\pi)</code>,
<code class="reqn">\boldsymbol\Psi</code> can be expressed as
</p>
<p style="text-align: center;"><code class="reqn">\Psi_{ij}=\pi-|\pi-|\Theta_i-\Theta_j||,\quad
i,j=1,\ldots,n.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>Psi_mat(data, ind_tri = 0L, use_ind_tri = FALSE, scalar_prod = FALSE,
  angles_diff = FALSE)

upper_tri_ind(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Psi_+3A_data">data</code></td>
<td>
<p>an array of size <code>c(n, p, M)</code> containing the Cartesian
coordinates of <code>M</code> samples of size <code>n</code> of directions on
<code class="reqn">S^{p-1}</code>. Alternatively if <code>p = 2</code>, an array of size
<code>c(n, 1, M)</code> containing the angles on <code class="reqn">[0, 2\pi)</code> of the <code>M</code>
circular samples of size <code>n</code> on <code class="reqn">S^{1}</code>. Must not contain
<code>NA</code>'s.</p>
</td></tr>
<tr><td><code id="Psi_+3A_ind_tri">ind_tri</code></td>
<td>
<p>if <code>use_ind_tri = TRUE</code>, the vector of 0-based indexes
provided by <code>upper_tri_ind(n)</code>, which allows to extract the upper
triangular part of the matrix <code class="reqn">\boldsymbol\Psi</code>. See the examples.</p>
</td></tr>
<tr><td><code id="Psi_+3A_use_ind_tri">use_ind_tri</code></td>
<td>
<p>use the already computed vector index <code>ind_tri</code>? If
<code>FALSE</code> (default), <code>ind_tri</code> is computed internally.</p>
</td></tr>
<tr><td><code id="Psi_+3A_scalar_prod">scalar_prod</code></td>
<td>
<p>return the scalar products
<code class="reqn">{\bf X}_i'{\bf X}</code> instead of the shortest angles? Only taken
into account for data in <em>Cartesian</em> form. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Psi_+3A_angles_diff">angles_diff</code></td>
<td>
<p>return the (unwrapped) angles difference
<code class="reqn">\Theta_i-\Theta_j</code> instead of the shortest angles? Only taken into
account for data in <em>angular</em> form. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Psi_+3A_n">n</code></td>
<td>
<p>sample size, used to determine the index vector that gives the
upper triangular part of <code class="reqn">\boldsymbol\Psi</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>Psi_mat</code>: a matrix of size
<code>c(n * (n - 1) / 2, M)</code> containing, for each column, the vector
half of <code class="reqn">\boldsymbol\Psi</code> for each of the <code>M</code> samples.
</p>
</li>
<li> <p><code>upper_tri_ind</code>: a matrix of size <code>n * (n - 1) / 2</code>
containing the 0-based linear indexes for extracting the upper triangular
matrix of a matrix of size <code>c(n, n)</code>, diagonal excluded, assuming
column-major order.
</p>
</li></ul>



<h3>Warning</h3>

<p>Be careful on avoiding the next bad usages of <code>Psi_mat</code>, which will
produce spurious results:
</p>

<ul>
<li><p> The directions in <code>data</code> do <em>not</em> have unit norm when
Cartesian coordinates are employed.
</p>
</li>
<li><p> The entries of <code>data</code> are <em>not</em> in <code class="reqn">[0, 2\pi)</code> when
polar coordinates are employed.
</p>
</li>
<li> <p><code>ind_tri</code> is a vector of size <code>n * (n - 1) / 2</code> that
does <em>not</em> contain the indexes produced by <code>upper_tri_ind(n)</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Shortest angles
n &lt;- 5
X &lt;- r_unif_sph(n = n, p = 2, M = 2)
Theta &lt;- X_to_Theta(X)
dim(Theta) &lt;- c(n, 1, 2)
Psi_mat(X)
Psi_mat(Theta)

# Precompute ind_tri
ind_tri &lt;- upper_tri_ind(n)
Psi_mat(X, ind_tri = ind_tri, use_ind_tri = TRUE)

# Compare with R
A &lt;- acos(tcrossprod(X[, , 1]))
ind &lt;- upper.tri(A)
A[ind]

# Reconstruct matrix
Psi_vec &lt;- Psi_mat(Theta[, , 1, drop = FALSE])
Psi &lt;- matrix(0, nrow = n, ncol = n)
Psi[upper.tri(Psi)] &lt;- Psi_vec
Psi &lt;- Psi + t(Psi)
</code></pre>

<hr>
<h2 id='r_alt'>Sample non-uniformly distributed spherical data</h2><span id='topic+r_alt'></span>

<h3>Description</h3>

<p>Simple simulation of prespecified non-uniform spherical
distributions: von Mises&ndash;Fisher (vMF), Mixture of vMF (MvMF),
Angular Central Gaussian (ACG), Small Circle (SC), Watson (W), or
Cauchy-like (C).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_alt(n, p, M = 1, alt = "vMF", kappa = 1, nu = 0.5, F_inv = NULL,
  K = 1000, axial_MvMF = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r_alt_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="r_alt_+3A_p">p</code></td>
<td>
<p>integer giving the dimension of the ambient space <code class="reqn">R^p</code> that
contains <code class="reqn">S^{p-1}</code>.</p>
</td></tr>
<tr><td><code id="r_alt_+3A_m">M</code></td>
<td>
<p>number of samples of size <code>n</code>. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="r_alt_+3A_alt">alt</code></td>
<td>
<p>alternative, must be <code>"vMF"</code>, <code>"MvMF"</code>,
<code>"ACG"</code>, <code>"SC"</code>, <code>"W"</code>, or <code>"C"</code>. See details below.</p>
</td></tr>
<tr><td><code id="r_alt_+3A_kappa">kappa</code></td>
<td>
<p>non-negative parameter measuring the strength of the deviation
with respect to uniformity (obtained with <code class="reqn">\kappa = 0</code>).</p>
</td></tr>
<tr><td><code id="r_alt_+3A_nu">nu</code></td>
<td>
<p>projection along <code class="reqn">{\bf e}_p</code> controlling the modal
strip of the small circle distribution. Must be in (-1, 1). Defaults to
<code>0.5</code>.</p>
</td></tr>
<tr><td><code id="r_alt_+3A_f_inv">F_inv</code></td>
<td>
<p>quantile function returned by <code><a href="#topic+F_inv_from_f">F_inv_from_f</a></code>. Used
for <code>"SC"</code>, <code>"W"</code>, and <code>"C"</code>. Computed by internally if
<code>NULL</code> (default).</p>
</td></tr>
<tr><td><code id="r_alt_+3A_k">K</code></td>
<td>
<p>number of equispaced points on <code class="reqn">[-1, 1]</code> used for evaluating
<code class="reqn">F^{-1}</code> and then interpolating. Defaults to <code>1e3</code>.</p>
</td></tr>
<tr><td><code id="r_alt_+3A_axial_mvmf">axial_MvMF</code></td>
<td>
<p>use a mixture of vMF that is axial (i.e., symmetrically
distributed about the origin)? Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>kappa</code> is used as <code class="reqn">\kappa</code> in the following
distributions:
</p>

<ul>
<li> <p><code>"vMF"</code>: von Mises&ndash;Fisher distribution with concentration
<code class="reqn">\kappa</code> and directional mean <code class="reqn">{\bf e}_p = (0, 0, \ldots, 1)</code>.
</p>
</li>
<li> <p><code>"MvMF"</code>: equally-weighted mixture of <code class="reqn">p</code> von Mises&ndash;Fisher
distributions with common concentration <code class="reqn">\kappa</code> and directional means
<code class="reqn">\pm{\bf e}_1, \ldots, \pm{\bf e}_p</code> if
<code>axial_MvMF = TRUE</code>. If <code>axial_MvMF = FALSE</code>, then only means
with positive signs are considered.
</p>
</li>
<li> <p><code>"ACG"</code>: Angular Central Gaussian distribution with diagonal
shape matrix with diagonal given by
</p>
<p style="text-align: center;"><code class="reqn">(1, \ldots, 1, 1 + \kappa) / (p + \kappa).</code>
</p>

</li>
<li> <p><code>"SC"</code>: Small Circle distribution with axis mean
<code class="reqn">{\bf e}_p = (0, 0, \ldots, 1)</code> and
concentration <code class="reqn">\kappa</code> about the projection along the mean, <code class="reqn">\nu</code>.
</p>
</li>
<li> <p><code>"W"</code>: Watson distribution with axis mean
<code class="reqn">{\bf e}_p = (0, 0, \ldots, 1)</code> and
concentration <code class="reqn">\kappa</code>. The Watson distribution is a particular case
of the Bingham distribution.
</p>
</li>
<li> <p><code>"C"</code>: Cauchy-like distribution with directional mode
<code class="reqn">{\bf e}_p = (0, 0, \ldots, 1)</code> and
concentration <code class="reqn">\kappa = \rho / (1 - \rho^2)</code>. The circular Wrapped
Cauchy distribution is a particular case of this Cauchy-like distribution.
</p>
</li></ul>

<p>Much faster sampling for <code>"SC"</code>, <code>"W"</code>, and <code>"C"</code> is achieved
providing <code>F_inv</code>, see examples.
</p>


<h3>Value</h3>

<p>An <b>array</b> of size <code>c(n, p, M)</code> with <code>M</code> random
samples of size <code>n</code> of non-uniformly-generated directions on
<code class="reqn">S^{p-1}</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulation with p = 2

p &lt;- 2
n &lt;- 200
kappa &lt;- 20
nu &lt;- 0.5
rho &lt;- ((2 * kappa + 1) - sqrt(4 * kappa + 1)) / (2 * kappa)
F_inv_SC_2 &lt;- F_inv_from_f(f = function(z) exp(-kappa * (z - nu)^2), p = 2)
F_inv_W_2 &lt;- F_inv_from_f(f = function(z) exp(kappa * z^2), p = 2)
F_inv_C_2 &lt;- F_inv_from_f(f = function(z) (1 - rho^2) /
                            (1 + rho^2 - 2 * rho * z)^(p / 2), p = 2)
x1 &lt;- r_alt(n = n, p = p, alt = "vMF", kappa = kappa)[, , 1]
x2 &lt;- r_alt(n = n, p = p, alt = "MvMF", kappa = kappa)[, , 1]
x3 &lt;- r_alt(n = n, p = p, alt = "ACG", kappa = kappa)[, , 1]
x4 &lt;- r_alt(n = n, p = p, alt = "SC", F_inv = F_inv_SC_2)[, , 1]
x5 &lt;- r_alt(n = n, p = p, alt = "W", F_inv = F_inv_W_2)[, , 1]
x6 &lt;- r_alt(n = n, p = p, alt = "C", F_inv = F_inv_C_2)[, , 1]
r &lt;- runif(n, 0.95, 1.05) # Radius perturbation to improve visualization
plot(r * x1, pch = 16, xlim = c(-1.1, 1.1), ylim = c(-1.1, 1.1), col = 1)
points(r * x2, pch = 16, col = 2)
points(r * x3, pch = 16, col = 3)
points(r * x4, pch = 16, col = 4)
points(r * x5, pch = 16, col = 5)
points(r * x6, pch = 16, col = 6)

## Simulation with p = 3

n &lt;- 200
p &lt;- 3
kappa &lt;- 20
nu &lt;- 0.5
rho &lt;- ((2 * kappa + 1) - sqrt(4 * kappa + 1)) / (2 * kappa)
F_inv_SC_3 &lt;- F_inv_from_f(f = function(z) exp(-kappa * (z - nu)^2), p = 3)
F_inv_W_3 &lt;- F_inv_from_f(f = function(z) exp(kappa * z^2), p = 3)
F_inv_C_3 &lt;- F_inv_from_f(f = function(z) (1 - rho^2) /
                            (1 + rho^2 - 2 * rho * z)^(p / 2), p = 3)
x1 &lt;- r_alt(n = n, p = p, alt = "vMF", kappa = kappa)[, , 1]
x2 &lt;- r_alt(n = n, p = p, alt = "MvMF", kappa = kappa)[, , 1]
x3 &lt;- r_alt(n = n, p = p, alt = "ACG", kappa = kappa)[, , 1]
x4 &lt;- r_alt(n = n, p = p, alt = "SC", F_inv = F_inv_SC_3)[, , 1]
x5 &lt;- r_alt(n = n, p = p, alt = "W", F_inv = F_inv_W_3)[, , 1]
x6 &lt;- r_alt(n = n, p = p, alt = "C", F_inv = F_inv_C_3)[, , 1]
s3d &lt;- scatterplot3d::scatterplot3d(x1, pch = 16, xlim = c(-1.1, 1.1),
                                    ylim = c(-1.1, 1.1), zlim = c(-1.1, 1.1))
s3d$points3d(x2, pch = 16, col = 2)
s3d$points3d(x3, pch = 16, col = 3)
s3d$points3d(x4, pch = 16, col = 4)
s3d$points3d(x5, pch = 16, col = 5)
s3d$points3d(x6, pch = 16, col = 6)
</code></pre>

<hr>
<h2 id='r_unif'>Sample uniformly distributed circular and spherical data</h2><span id='topic+r_unif'></span><span id='topic+r_unif_cir'></span><span id='topic+r_unif_sph'></span>

<h3>Description</h3>

<p>Simulation of the uniform distribution on <code class="reqn">[0, 2\pi)</code> and
<code class="reqn">S^{p-1}:=\{{\bf x}\in R^p:||{\bf x}||=1\}</code>, <code class="reqn">p\ge 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_unif_cir(n, M = 1L, sorted = FALSE)

r_unif_sph(n, p, M = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r_unif_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="r_unif_+3A_m">M</code></td>
<td>
<p>number of samples of size <code>n</code>. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="r_unif_+3A_sorted">sorted</code></td>
<td>
<p>return each circular sample sorted? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="r_unif_+3A_p">p</code></td>
<td>
<p>integer giving the dimension of the ambient space <code class="reqn">R^p</code> that
contains <code class="reqn">S^{p-1}</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>r_unif_cir</code>: a <b>matrix</b> of size <code>c(n, M)</code> with
<code>M</code> random samples of size <code>n</code> of uniformly-generated circular
data on <code class="reqn">[0, 2\pi)</code>.
</p>
</li>
<li> <p><code>r_unif_sph</code>: an <b>array</b> of size <code>c(n, p, M)</code> with
<code>M</code> random samples of size <code>n</code> of uniformly-generated
directions on <code class="reqn">S^{p-1}</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># A sample on [0, 2*pi)
n &lt;- 5
r_unif_cir(n = n)

# A sample on S^1
p &lt;- 2
samp &lt;- r_unif_sph(n = n, p = p)
samp
rowSums(samp^2)

# A sample on S^2
p &lt;- 3
samp &lt;- r_unif_sph(n = n, p = p)
samp
rowSums(samp^2)
</code></pre>

<hr>
<h2 id='rhea'>Rhea craters from Hirata (2016)</h2><span id='topic+rhea'></span>

<h3>Description</h3>

<p>Craters on Rhea from Hirata (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhea
</code></pre>


<h3>Format</h3>

<p>A data frame with 3596 rows and 4 variables:
</p>

<dl>
<dt>name</dt><dd><p>name of the crater (if named).</p>
</dd>
<dt>diameter</dt><dd><p>diameter of the crater (in km).</p>
</dd>
<dt>theta</dt><dd><p>longitude angle <code class="reqn">\theta \in [0, 2\pi)</code> of the
crater center.</p>
</dd>
<dt>phi</dt><dd><p>latitude angle <code class="reqn">\phi \in [-\pi/2, \pi/2]</code> of the
crater center.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The <code class="reqn">(\theta, \phi)</code> angles are such their associated planetocentric
coordinates are:
</p>
<p style="text-align: center;"><code class="reqn">(\cos(\phi) \cos(\theta), \cos(\phi) \sin(\theta), \sin(\phi))',</code>
</p>

<p>with <code class="reqn">(0, 0, 1)'</code> denoting the north pole.
</p>
<p>The script performing the data preprocessing is available at
<a href="https://github.com/egarpor/sphunif/blob/master/data-raw/rhea.R">
<code>rhea.R</code></a>.
</p>


<h3>Source</h3>

<p><a href="https://agupubs.onlinelibrary.wiley.com/action/downloadSupplement?doi=10.1002%2F2015JE004940&amp;file=jgre20485-sup-0002-TableS1.txt">https://agupubs.onlinelibrary.wiley.com/action/downloadSupplement?doi=10.1002%2F2015JE004940&amp;file=jgre20485-sup-0002-TableS1.txt</a>
</p>


<h3>References</h3>

<p>Hirata, N. (2016) Differential impact cratering of Saturn's satellites by
heliocentric impactors. <em>Journal of Geophysical Research: Planets</em>,
121:111&ndash;117. <a href="https://doi.org/10.1002/2015JE004940">doi:10.1002/2015JE004940</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data("rhea")

# Add Cartesian coordinates
rhea$X &lt;- cbind(cos(rhea$theta) * cos(rhea$phi),
                sin(rhea$theta) * cos(rhea$phi),
                sin(rhea$phi))

# Tests
unif_test(data = rhea$X[rhea$diam &gt; 15 &amp; rhea$diam &lt; 20, ],
          type = c("PCvM", "PAD", "PRt"), p_value = "asymp")
</code></pre>

<hr>
<h2 id='Sobolev'>Asymptotic distributions of Sobolev statistics of spherical uniformity</h2><span id='topic+Sobolev'></span><span id='topic+d_p_k'></span><span id='topic+weights_dfs_Sobolev'></span><span id='topic+d_Sobolev'></span><span id='topic+p_Sobolev'></span><span id='topic+q_Sobolev'></span>

<h3>Description</h3>

<p>Approximated density, distribution, and quantile functions for
the asymptotic null distributions of Sobolev statistics of uniformity
on <code class="reqn">S^{p-1}:=\{{\bf x}\in R^p:||{\bf x}||=1\}</code>. These asymptotic distributions are infinite
weighted sums of (central) chi squared random variables:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{k = 1}^\infty v_k^2 \chi^2_{d_{p, k}},</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">d_{p, k} := {{p + k - 3}\choose{p - 2}} + {{p + k - 2}\choose{p - 2}}</code>
</p>

<p>is the dimension of the space of eigenfunctions of the Laplacian on
<code class="reqn">S^{p-1}</code>, <code class="reqn">p\ge 2</code>, associated to the <code class="reqn">k</code>-th
eigenvalue, <code class="reqn">k\ge 1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_p_k(p, k, log = FALSE)

weights_dfs_Sobolev(p, K_max = 1000, thre = 0.001, type, Rothman_t = 1/3,
  Pycke_q = 0.5, Riesz_s = 1, Poisson_rho = 0.5, Softmax_kappa = 1,
  Stereo_a = 0, Sobolev_vk2 = c(0, 0, 1), log = FALSE, verbose = TRUE,
  Gauss = TRUE, N = 320, tol = 1e-06, force_positive = TRUE,
  x_tail = NULL)

d_Sobolev(x, p, type, method = c("I", "SW", "HBE")[1], K_max = 1000,
  thre = 0.001, Rothman_t = 1/3, Pycke_q = 0.5, Riesz_s = 1,
  Poisson_rho = 0.5, Softmax_kappa = 1, Stereo_a = 0,
  Sobolev_vk2 = c(0, 0, 1), ncps = 0, verbose = TRUE, N = 320,
  x_tail = NULL, ...)

p_Sobolev(x, p, type, method = c("I", "SW", "HBE", "MC")[1], K_max = 1000,
  thre = 0.001, Rothman_t = 1/3, Pycke_q = 0.5, Riesz_s = 1,
  Poisson_rho = 0.5, Softmax_kappa = 1, Stereo_a = 0,
  Sobolev_vk2 = c(0, 0, 1), ncps = 0, verbose = TRUE, N = 320,
  x_tail = NULL, ...)

q_Sobolev(u, p, type, method = c("I", "SW", "HBE", "MC")[1], K_max = 1000,
  thre = 0.001, Rothman_t = 1/3, Pycke_q = 0.5, Riesz_s = 1,
  Poisson_rho = 0.5, Softmax_kappa = 1, Stereo_a = 0,
  Sobolev_vk2 = c(0, 0, 1), ncps = 0, verbose = TRUE, N = 320,
  x_tail = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sobolev_+3A_p">p</code></td>
<td>
<p>integer giving the dimension of the ambient space <code class="reqn">R^p</code> that
contains <code class="reqn">S^{p-1}</code>.</p>
</td></tr>
<tr><td><code id="Sobolev_+3A_k">k</code></td>
<td>
<p>sequence of integer indexes.</p>
</td></tr>
<tr><td><code id="Sobolev_+3A_log">log</code></td>
<td>
<p>compute the logarithm of <code class="reqn">d_{p,k}</code>? Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Sobolev_+3A_k_max">K_max</code></td>
<td>
<p>integer giving the truncation of the series that compute the
asymptotic p-value of a Sobolev test. Defaults to <code>1e3</code>.</p>
</td></tr>
<tr><td><code id="Sobolev_+3A_thre">thre</code></td>
<td>
<p>error threshold for the tail probability given by the
the first terms of the truncated series of a Sobolev test. Defaults to
<code>1e-3</code>.</p>
</td></tr>
<tr><td><code id="Sobolev_+3A_type">type</code></td>
<td>
<p>Sobolev statistic. For <code class="reqn">p = 2</code>, either <code>"Watson"</code>,
<code>"Rothman"</code>, <code>"Pycke_q"</code>, or <code>"Hermans_Rasson"</code>.
For <code class="reqn">p \ge 2</code>, <code>"Ajne"</code>, <code>"Gine_Gn"</code>, <code>"Gine_Fn"</code>,
<code>"Bakshaev"</code>, <code>"Riesz"</code>, <code>"PCvM"</code>, <code>"PAD"</code>, or
<code>"PRt"</code>.</p>
</td></tr>
<tr><td><code id="Sobolev_+3A_rothman_t">Rothman_t</code></td>
<td>
<p><code class="reqn">t</code> parameter for the Rothman test, a real in
<code class="reqn">(0, 1)</code>. Defaults to <code>1 / 3</code>.</p>
</td></tr>
<tr><td><code id="Sobolev_+3A_pycke_q">Pycke_q</code></td>
<td>
<p><code class="reqn">q</code> parameter for the Pycke &quot;<code class="reqn">q</code>-test&quot;, a real in
<code class="reqn">(0, 1)</code>. Defaults to <code>1 / 2</code>.</p>
</td></tr>
<tr><td><code id="Sobolev_+3A_riesz_s">Riesz_s</code></td>
<td>
<p><code class="reqn">s</code> parameter for the <code class="reqn">s</code>-Riesz test, a real in
<code class="reqn">(0, 2)</code>. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="Sobolev_+3A_poisson_rho">Poisson_rho</code></td>
<td>
<p><code class="reqn">\rho</code> parameter for the Poisson test, a real in
<code class="reqn">[0, 1)</code>. Defaults to <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="Sobolev_+3A_softmax_kappa">Softmax_kappa</code></td>
<td>
<p><code class="reqn">\kappa</code> parameter for the Softmax test, a
non-negative real. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="Sobolev_+3A_stereo_a">Stereo_a</code></td>
<td>
<p><code class="reqn">a</code> parameter for the Stereo test, a real in
<code class="reqn">[-1, 1]</code>. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="Sobolev_+3A_sobolev_vk2">Sobolev_vk2</code></td>
<td>
<p>weights for the finite Sobolev test. A non-negative
vector or matrix. Defaults to <code>c(0, 0, 1)</code>.</p>
</td></tr>
<tr><td><code id="Sobolev_+3A_verbose">verbose</code></td>
<td>
<p>output information about the truncation? Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="Sobolev_+3A_gauss">Gauss</code></td>
<td>
<p>use a Gauss&ndash;Legendre quadrature rule of <code>N</code> nodes
in the computation of the Gegenbauer coefficients? Otherwise, call
<code><a href="stats.html#topic+integrate">integrate</a></code>. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="Sobolev_+3A_n">N</code></td>
<td>
<p>number of points used in the <a href="#topic+Gauss_Legen_nodes">
Gauss&ndash;Legendre quadrature</a> for computing the Gegenbauer coefficients.
Defaults to <code>320</code>.</p>
</td></tr>
<tr><td><code id="Sobolev_+3A_tol">tol</code></td>
<td>
<p>tolerance passed to <code><a href="stats.html#topic+integrate">integrate</a></code>'s <code>rel.tol</code> and
<code>abs.tol</code> if <code>Gauss = FALSE</code>. Defaults to <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="Sobolev_+3A_force_positive">force_positive</code></td>
<td>
<p>set negative</p>
</td></tr>
<tr><td><code id="Sobolev_+3A_x_tail">x_tail</code></td>
<td>
<p>scalar evaluation point for determining the upper tail
probability. If <code>NULL</code>, set to the <code>0.90</code> quantile of the whole
series, computed by the <code>"HBE"</code> approximation.</p>
</td></tr>
<tr><td><code id="Sobolev_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Sobolev_+3A_method">method</code></td>
<td>
<p>method for approximating the density, distribution, or
quantile function. Must be <code>"I"</code> (Imhof), <code>"SW"</code>
(Satterthwaite&ndash;Welch), <code>"HBE"</code> (Hall&ndash;Buckley&ndash;Eagleson), or
<code>"MC"</code> (Monte Carlo; only for distribution or quantile functions).
Defaults to <code>"I"</code>.</p>
</td></tr>
<tr><td><code id="Sobolev_+3A_ncps">ncps</code></td>
<td>
<p>non-centrality parameters. Either <code>0</code> (default) or a
vector with the same length as <code>weights</code>.</p>
</td></tr>
<tr><td><code id="Sobolev_+3A_...">...</code></td>
<td>
<p>further parameters passed to <code>*_<a href="#topic+wschisq">wschisq</a></code>.</p>
</td></tr>
<tr><td><code id="Sobolev_+3A_u">u</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The truncation of <code class="reqn">\sum_{k = 1}^\infty v_k^2 \chi^2_{d_{p, k}}</code> is
done to the first <code>K_max</code> terms and then up to the index such that
the first terms explain the tail probability at the <code>x_tail</code> with
an absolute error smaller than <code>thre</code> (see details in
<code><a href="#topic+cutoff_wschisq">cutoff_wschisq</a></code>). This automatic truncation takes place when
calling <code>*_Sobolev</code>. Setting <code>thre = 0</code> truncates to <code>K_max</code>
terms exactly. If the series only contains odd or even non-zero terms, then
only <code>K_max / 2</code> addends are <em>effectively</em> taken into account
in the first truncation.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>d_p_k</code>: a vector of size <code>length(k)</code> with the
evaluation of <code class="reqn">d_{p,k}</code>.
</p>
</li>
<li> <p><code>weights_dfs_Sobolev</code>: a list with entries <code>weights</code> and
<code>dfs</code>, automatically truncated according to <code>K_max</code> and
<code>thre</code> (see details).
</p>
</li>
<li> <p><code>d_Sobolev</code>: density function evaluated at <code>x</code>, a vector.
</p>
</li>
<li> <p><code>p_Sobolev</code>: distribution function evaluated at <code>x</code>,
a vector.
</p>
</li>
<li> <p><code>q_Sobolev</code>: quantile function evaluated at <code>u</code>, a vector.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Eduardo García-Portugués and Paula Navarro-Esteban.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Circular-specific statistics
curve(p_Sobolev(x = x, p = 2, type = "Watson", method = "HBE"),
      n = 2e2, ylab = "Distribution", main = "Watson")
curve(p_Sobolev(x = x, p = 2, type = "Rothman", method = "HBE"),
      n = 2e2, ylab = "Distribution", main = "Rothman")
curve(p_Sobolev(x = x, p = 2, type = "Pycke_q", method = "HBE"), to = 10,
      n = 2e2, ylab = "Distribution", main = "Pycke_q")
curve(p_Sobolev(x = x, p = 2, type = "Hermans_Rasson", method = "HBE"),
      to = 10, n = 2e2, ylab = "Distribution", main = "Hermans_Rasson")

# Statistics for arbitrary dimensions
test_statistic &lt;- function(type, to = 1, pmax = 5, M = 1e3, ...) {

  col &lt;- viridisLite::viridis(pmax - 1)
  curve(p_Sobolev(x = x, p = 2, type = type, method = "MC", M = M,
                  ...), to = to, n = 2e2, col = col[pmax - 1],
                  ylab = "Distribution", main = type, ylim = c(0, 1))
  for (p in 3:pmax) {
    curve(p_Sobolev(x = x, p = p, type = type, method = "MC", M = M,
                    ...), add = TRUE, n = 2e2, col = col[pmax - p + 1])
  }
  legend("bottomright", legend = paste("p =", 2:pmax), col = rev(col),
         lwd = 2)

}

# Ajne
test_statistic(type = "Ajne")

# Gine_Gn
test_statistic(type = "Gine_Gn", to = 1.5)

# Gine_Fn
test_statistic(type = "Gine_Fn", to = 2)

# Bakshaev
test_statistic(type = "Bakshaev", to = 3)

# Riesz
test_statistic(type = "Riesz", Riesz_s = 0.5, to = 3)

# PCvM
test_statistic(type = "PCvM", to = 0.6)

# PAD
test_statistic(type = "PAD", to = 3)

# PRt
test_statistic(type = "PRt", Rothman_t = 0.5)

# Quantiles
p &lt;- c(2, 3, 4, 11)
t(sapply(p, function(p) q_Sobolev(u = c(0.10, 0.05, 0.01), p = p,
                                  type = "PCvM")))
t(sapply(p, function(p) q_Sobolev(u = c(0.10, 0.05, 0.01), p = p,
                                  type = "PAD")))
t(sapply(p, function(p) q_Sobolev(u = c(0.10, 0.05, 0.01), p = p,
                                  type = "PRt")))

# Series truncation for thre = 1e-5
sapply(p, function(p) length(weights_dfs_Sobolev(p = p, type = "PCvM")$dfs))
sapply(p, function(p) length(weights_dfs_Sobolev(p = p, type = "PRt")$dfs))
sapply(p, function(p) length(weights_dfs_Sobolev(p = p, type = "PAD")$dfs))

</code></pre>

<hr>
<h2 id='Sobolev_coefs'>Transformation between different coefficients in Sobolev statistics</h2><span id='topic+Sobolev_coefs'></span><span id='topic+bk_to_vk2'></span><span id='topic+bk_to_uk'></span><span id='topic+vk2_to_bk'></span><span id='topic+vk2_to_uk'></span><span id='topic+uk_to_vk2'></span><span id='topic+uk_to_bk'></span>

<h3>Description</h3>

<p>Given a Sobolev statistic
</p>
<p style="text-align: center;"><code class="reqn">S_{n, p} = \sum_{i, j = 1}^n \psi(\cos^{-1}({\bf X}_i'{\bf X}_j)),</code>
</p>

<p>for a sample <code class="reqn">{\bf X}_1, \ldots, {\bf X}_n \in S^{p - 1} := \{{\bf x}
\in R^p : ||{\bf x}|| = 1\}</code>, <code class="reqn">p\ge 2</code>, three important sequences
are related to <code class="reqn">S_{n, p}</code>.
</p>

<ul>
<li> <p><a href="#topic+Gegen_coefs">Gegenbauer coefficients</a> <code class="reqn">\{b_{k, p}\}</code> of
<code class="reqn">\psi_p</code> (see, e.g., the <a href="#topic+Pn">projected-ecdf statistics</a>), given
by
</p>
<p style="text-align: center;"><code class="reqn">b_{k, p} := \frac{1}{c_{k, p}}\int_0^\pi \psi_p(\theta)
C_k^{p / 2 - 1}(\cos\theta)\,\mathrm{d}\theta.</code>
</p>

</li>
<li><p> Weights <code class="reqn">\{v_{k, p}^2\}</code> of the
<a href="#topic+Sobolev">asymptotic distribution</a> of the Sobolev statistic,
<code class="reqn">\sum_{k = 1}^\infty v_k^2 \chi^2_{d_{p, k}}</code>, given by
</p>
<p style="text-align: center;"><code class="reqn">v_{k, p}^2 = \left(1 + \frac{2k}{p - 2}\right)^{-1} b_{k, p},
\quad p \ge 3.</code>
</p>

</li>
<li><p> Gegenbauer coefficients <code class="reqn">\{u_{k, p}\}</code> of the
<a href="#topic+locdev">local projected alternative</a> associated to <code class="reqn">S_{n, p}</code>,
given by
</p>
<p style="text-align: center;"><code class="reqn">u_{k, p} = \left(1 + \frac{2k}{p - 2}\right) v_{k, p},
\quad p \ge 3.</code>
</p>

</li></ul>

<p>For <code class="reqn">p = 2</code>, the factor <code class="reqn">(1 + 2k / (p - 2))</code> is replaced by <code class="reqn">2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bk_to_vk2(bk, p, log = FALSE)

bk_to_uk(bk, p, signs = 1)

vk2_to_bk(vk2, p, log = FALSE)

vk2_to_uk(vk2, p, signs = 1)

uk_to_vk2(uk, p)

uk_to_bk(uk, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sobolev_coefs_+3A_bk">bk</code></td>
<td>
<p>coefficients <code class="reqn">b_{k, p}</code> associated to the indexes
<code>1:length(bk)</code>, a vector.</p>
</td></tr>
<tr><td><code id="Sobolev_coefs_+3A_p">p</code></td>
<td>
<p>integer giving the dimension of the ambient space <code class="reqn">R^p</code> that
contains <code class="reqn">S^{p-1}</code>.</p>
</td></tr>
<tr><td><code id="Sobolev_coefs_+3A_log">log</code></td>
<td>
<p>do operations in log scale (log-in, log-out)? Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Sobolev_coefs_+3A_signs">signs</code></td>
<td>
<p>signs of the coefficients <code class="reqn">u_{k, p}</code>, a vector of the
same size as <code>vk2</code> or <code>bk</code>, or a scalar. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="Sobolev_coefs_+3A_vk2">vk2</code></td>
<td>
<p><b>squared</b> coefficients <code class="reqn">v_{k, p}^2</code> associated to the
indexes <code>1:length(vk2)</code>, a vector.</p>
</td></tr>
<tr><td><code id="Sobolev_coefs_+3A_uk">uk</code></td>
<td>
<p>coefficients <code class="reqn">u_{k, p}</code> associated to the indexes
<code>1:length(uk)</code>, a vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See more details in Prentice (1978) and García-Portugués et al. (2023). The
adequate signs of <code>uk</code> for the <code>"PRt"</code> <a href="#topic+Pn">Rothman test</a>
can be retrieved with <code><a href="#topic+akx">akx</a></code> and <code>sqr = TRUE</code>, see the
examples.
</p>


<h3>Value</h3>

<p>The corresponding vectors of coefficients <code>vk2</code>, <code>bk</code>, or
<code>uk</code>, depending on the call.
</p>


<h3>References</h3>

<p>García-Portugués, E., Navarro-Esteban, P., Cuesta-Albertos, J. A. (2023)
On a projection-based class of uniformity tests on the hypersphere.
<em>Bernoulli</em>, 29(1):181&ndash;204. <a href="https://doi.org/10.3150/21-BEJ1454">doi:10.3150/21-BEJ1454</a>.
</p>
<p>Prentice, M. J. (1978). On invariant tests of uniformity for directions and
orientations. <em>The Annals of Statistics</em>, 6(1):169&ndash;176.
<a href="https://doi.org/10.1214/aos/1176344075">doi:10.1214/aos/1176344075</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># bk, vk2, and uk for the PCvM test in p = 3
(bk &lt;- Gegen_coefs_Pn(k = 1:5, type = "PCvM", p = 3))
(vk2 &lt;- bk_to_vk2(bk = bk, p = 3))
(uk &lt;- bk_to_uk(bk = bk, p = 3))

# vk2 is the same as
weights_dfs_Sobolev(K_max = 10, thre = 0, p = 3, type = "PCvM")$weights

# bk and uk for the Rothman test in p = 3, with adequate signs
t &lt;- 1 / 3
(bk &lt;- Gegen_coefs_Pn(k = 1:5, type = "PRt", p = 3, Rothman_t = t))
(ak &lt;- akx(x = drop(q_proj_unif(t, p = 3)), p = 3, k = 1:5, sqr = TRUE))
(uk &lt;- bk_to_uk(bk = bk, p = 3, signs = ak))
</code></pre>

<hr>
<h2 id='sort_each_col'>Sort the columns of a matrix</h2><span id='topic+sort_each_col'></span><span id='topic+sort_index_each_col'></span>

<h3>Description</h3>

<p>Convenience functions to sort the columns of a matrix in an
increasing way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_each_col(A)

sort_index_each_col(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_each_col_+3A_a">A</code></td>
<td>
<p>a matrix of arbitrary dimensions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the same dimensions as <code>A</code> such that each
column is sorted increasingly (for <code>sort_each_col</code>) or contains the
sorting indexes (for <code>sort_index_each_col</code>).
<code>sort_index_each_col</code>.
</p>

<hr>
<h2 id='sph_stat_Rayleigh'>Statistics for testing (hyper)spherical uniformity</h2><span id='topic+sph_stat_Rayleigh'></span><span id='topic+sph_stat_Bingham'></span><span id='topic+sph_stat_Ajne'></span><span id='topic+sph_stat_Gine_Gn'></span><span id='topic+sph_stat_Gine_Fn'></span><span id='topic+sph_stat_Pycke'></span><span id='topic+sph_stat_Bakshaev'></span><span id='topic+sph_stat_Riesz'></span><span id='topic+sph_stat_PCvM'></span><span id='topic+sph_stat_PRt'></span><span id='topic+sph_stat_PAD'></span><span id='topic+sph_stat_Poisson'></span><span id='topic+sph_stat_Softmax'></span><span id='topic+sph_stat_Stereo'></span><span id='topic+sph_stat_CCF09'></span><span id='topic+sph_stat_Rayleigh_HD'></span><span id='topic+sph_stat_CJ12'></span><span id='topic+sph_stat'></span>

<h3>Description</h3>

<p>Low-level implementation of several statistics for assessing
uniformity on the (hyper)sphere
<code class="reqn">S^{p-1}:=\{{\bf x}\in R^p:||{\bf x}||=1\}</code>, <code class="reqn">p\ge 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sph_stat_Rayleigh(X)

sph_stat_Bingham(X)

sph_stat_Ajne(X, Psi_in_X = FALSE)

sph_stat_Gine_Gn(X, Psi_in_X = FALSE, p = 0L)

sph_stat_Gine_Fn(X, Psi_in_X = FALSE, p = 0L)

sph_stat_Pycke(X, Psi_in_X = FALSE, p = 0L)

sph_stat_Bakshaev(X, Psi_in_X = FALSE, p = 0L)

sph_stat_Riesz(X, Psi_in_X = FALSE, p = 0L, s = 1)

sph_stat_PCvM(X, Psi_in_X = FALSE, p = 0L, N = 160L, L = 1000L)

sph_stat_PRt(X, Psi_in_X = FALSE, p = 0L, t = 1/3, N = 160L,
  L = 1000L)

sph_stat_PAD(X, Psi_in_X = FALSE, p = 0L, N = 160L, L = 1000L)

sph_stat_Poisson(X, Psi_in_X = FALSE, p = 0L, rho = 0.5)

sph_stat_Softmax(X, Psi_in_X = FALSE, p = 0L, kappa = 1)

sph_stat_Stereo(X, Psi_in_X = FALSE, p = 0L, a = 0)

sph_stat_CCF09(X, dirs, K_CCF09 = 25L, original = FALSE)

sph_stat_Rayleigh_HD(X)

sph_stat_CJ12(X, Psi_in_X = FALSE, p = 0L, regime = 3L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sph_stat_Rayleigh_+3A_x">X</code></td>
<td>
<p>an <b>array</b> of size <code>c(n, p, M)</code> containing the Cartesian
coordinates of <code>M</code> samples of size <code>n</code> of directions on
<code class="reqn">S^{p-1}</code>. Must not contain <code>NA</code>'s.</p>
</td></tr>
<tr><td><code id="sph_stat_Rayleigh_+3A_psi_in_x">Psi_in_X</code></td>
<td>
<p>does <code>X</code> contain the shortest angles matrix
<code class="reqn">\boldsymbol\Psi</code> that is obtained with <code><a href="#topic+Psi_mat">Psi_mat</a>(X)</code>?
If <code>FALSE</code> (default), <code class="reqn">\boldsymbol\Psi</code> is computed
internally.</p>
</td></tr>
<tr><td><code id="sph_stat_Rayleigh_+3A_p">p</code></td>
<td>
<p>integer giving the dimension of the ambient space <code class="reqn">R^p</code> that
contains <code class="reqn">S^{p-1}</code>.</p>
</td></tr>
<tr><td><code id="sph_stat_Rayleigh_+3A_s">s</code></td>
<td>
<p><code class="reqn">s</code> parameter for the <code class="reqn">s</code>-Riesz test, a real in
<code class="reqn">(0, 2)</code>. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="sph_stat_Rayleigh_+3A_n">N</code></td>
<td>
<p>number of points used in the
<a href="#topic+Gauss_Legen_nodes">Gauss-Legendre quadrature</a>. Defaults to
<code>160</code>.</p>
</td></tr>
<tr><td><code id="sph_stat_Rayleigh_+3A_l">L</code></td>
<td>
<p>number of discretization points to interpolate angular functions
that require evaluating an integral. Defaults to <code>1e3</code>.</p>
</td></tr>
<tr><td><code id="sph_stat_Rayleigh_+3A_t">t</code></td>
<td>
<p><code class="reqn">t</code> parameter for the Rothman and Cressie tests, a real in
<code class="reqn">(0, 1)</code>. Defaults to <code>1 / 3</code>.</p>
</td></tr>
<tr><td><code id="sph_stat_Rayleigh_+3A_rho">rho</code></td>
<td>
<p><code class="reqn">\rho</code> parameter for the Poisson test, a real in
<code class="reqn">[0, 1)</code>. Defaults to <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="sph_stat_Rayleigh_+3A_kappa">kappa</code></td>
<td>
<p><code class="reqn">\kappa</code> parameter for the Softmax test, a
non-negative real. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="sph_stat_Rayleigh_+3A_a">a</code></td>
<td>
<p>either: </p>

<ul>
<li> <p><code class="reqn">a_n = a / n</code> parameter used in the length of the arcs
of the coverage-based tests. Must be positive. Defaults to <code>2 * pi</code>.
</p>
</li>
<li> <p><code class="reqn">a</code> parameter for the Stereo test, a real in <code class="reqn">[-1, 1]</code>.
Defaults to <code>0</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="sph_stat_Rayleigh_+3A_dirs">dirs</code></td>
<td>
<p>a matrix of size <code>c(n_proj, p)</code> containing <code>n_proj</code>
random directions (in Cartesian coordinates) on <code class="reqn">S^{p-1}</code> to perform
the CCF09 test.</p>
</td></tr>
<tr><td><code id="sph_stat_Rayleigh_+3A_k_ccf09">K_CCF09</code></td>
<td>
<p>integer giving the truncation of the series present in the
asymptotic distribution of the Kolmogorov-Smirnov statistic. Defaults to
<code>5e2</code>.</p>
</td></tr>
<tr><td><code id="sph_stat_Rayleigh_+3A_original">original</code></td>
<td>
<p>return the CCF09 statistic as originally defined?
If <code>FALSE</code> (default), a faster and equivalent statistic is computed,
and rejection happens for <em>large</em> values of the statistic, which is
consistent with the rest of tests. Otherwise, rejection happens for
<em>low</em> values.</p>
</td></tr>
<tr><td><code id="sph_stat_Rayleigh_+3A_regime">regime</code></td>
<td>
<p>type of asymptotic regime for the CJ12 test, either <code>1</code>
(sub-exponential regime), <code>2</code> (exponential), or <code>3</code>
(super-exponential; default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Detailed descriptions and references of the statistics are available
in García-Portugués and Verdebout (2018).
</p>
<p>The Pycke and CJ12 statistics employ the <em>scalar products</em> matrix,
rather than the shortest angles matrix, when <code>Psi_in_X = TRUE</code>. This
matrix is obtained by setting <code>scalar_prod = TRUE</code> in
<code><a href="#topic+Psi_mat">Psi_mat</a></code>.
</p>


<h3>Value</h3>

<p>A matrix of size <code>c(M, 1)</code> containing the statistics for each
of the <code>M</code> samples.
</p>


<h3>Warning</h3>

<p>Be careful on avoiding the next bad usages of the functions, which will
produce spurious results:
</p>

<ul>
<li><p> The directions in <code>X</code> do <em>not</em> have unit norm.
</p>
</li>
<li> <p><code>X</code> does <em>not</em> contain <code>Psi_mat(X)</code> when
<code>X_in_Theta = TRUE</code>.
</p>
</li>
<li><p> The parameter <code>p</code> does <em>not</em> match with the dimension of
<code class="reqn">R^p</code>.
</p>
</li>
<li> <p><em>Not</em> passing the scalar products matrix to <code>sph_stat_CJ12</code>
when <code>Psi_in_X = TRUE</code>.
</p>
</li>
<li><p> The directions in <code>dirs</code> do <em>not</em> have unit norm.
</p>
</li></ul>



<h3>References</h3>

<p>García-Portugués, E. and Verdebout, T. (2018) An overview of uniformity
tests on the hypersphere. <em>arXiv:1804.00286</em>.
<a href="https://arxiv.org/abs/1804.00286">https://arxiv.org/abs/1804.00286</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Sample uniform spherical data

M &lt;- 2
n &lt;- 100
p &lt;- 3
set.seed(123456789)
X &lt;- r_unif_sph(n = n, p = p, M = M)

## Sobolev tests

# Rayleigh
sph_stat_Rayleigh(X)

# Bingham
sph_stat_Bingham(X)

# Ajne
Psi &lt;- Psi_mat(X)
dim(Psi) &lt;- c(dim(Psi), 1)
sph_stat_Ajne(X)
sph_stat_Ajne(Psi, Psi_in_X = TRUE)

# Gine Gn
sph_stat_Gine_Gn(X)
sph_stat_Gine_Gn(Psi, Psi_in_X = TRUE, p = p)

# Gine Fn
sph_stat_Gine_Fn(X)
sph_stat_Gine_Fn(Psi, Psi_in_X = TRUE, p = p)

# Pycke
sph_stat_Pycke(X)
sph_stat_Pycke(Psi, Psi_in_X = TRUE, p = p)

# Bakshaev
sph_stat_Bakshaev(X)
sph_stat_Bakshaev(Psi, Psi_in_X = TRUE, p = p)

# Riesz
sph_stat_Riesz(X, s = 1)
sph_stat_Riesz(Psi, Psi_in_X = TRUE, p = p, s = 1)

# Projected Cramér-von Mises
sph_stat_PCvM(X)
sph_stat_PCvM(Psi, Psi_in_X = TRUE, p = p)

# Projected Rothman
sph_stat_PRt(X)
sph_stat_PRt(Psi, Psi_in_X = TRUE, p = p)

# Projected Anderson-Darling
sph_stat_PAD(X)
sph_stat_PAD(Psi, Psi_in_X = TRUE, p = p)

## Other tests

# CCF09
dirs &lt;- r_unif_sph(n = 3, p = p, M = 1)[, , 1]
sph_stat_CCF09(X, dirs = dirs)

## High-dimensional tests

# Rayleigh HD-Standardized
sph_stat_Rayleigh_HD(X)

# CJ12
sph_stat_CJ12(X, regime = 1)
sph_stat_CJ12(Psi, regime = 1, Psi_in_X = TRUE, p = p)
sph_stat_CJ12(X, regime = 2)
sph_stat_CJ12(Psi, regime = 2, Psi_in_X = TRUE, p = p)
sph_stat_CJ12(X, regime = 3)
sph_stat_CJ12(Psi, regime = 3, Psi_in_X = TRUE, p = p)
</code></pre>

<hr>
<h2 id='sph_stat_Sobolev'>Finite Sobolev statistics for testing (hyper)spherical uniformity</h2><span id='topic+sph_stat_Sobolev'></span><span id='topic+cir_stat_Sobolev'></span>

<h3>Description</h3>

<p>Computes the finite Sobolev statistic </p>
<p style="text-align: center;"><code class="reqn">
S_{n, p}(\{b_{k, p}\}_{k=1}^K) = \sum_{i, j = 1}^n
\sum_{k = 1}^K b_{k, p}C_k^(p / 2 - 1)(\cos^{-1}({\bf X}_i'{\bf X}_j)),</code>
</p>

<p>for a sequence  <code class="reqn">\{b_{k, p}\}_{k = 1}^K</code> of non-negative weights. For
<code class="reqn">p = 2</code>, the Gegenbauer polynomials are replaced by Chebyshev ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sph_stat_Sobolev(X, Psi_in_X = FALSE, p = 0, vk2 = c(0, 0, 1))

cir_stat_Sobolev(Theta, Psi_in_Theta = FALSE, vk2 = c(0, 0, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sph_stat_Sobolev_+3A_x">X</code></td>
<td>
<p>an <b>array</b> of size <code>c(n, p, M)</code> containing the Cartesian
coordinates of <code>M</code> samples of size <code>n</code> of directions on
<code class="reqn">S^{p-1}</code>. Must not contain <code>NA</code>'s.</p>
</td></tr>
<tr><td><code id="sph_stat_Sobolev_+3A_psi_in_x">Psi_in_X</code></td>
<td>
<p>does <code>X</code> contain the shortest angles matrix
<code class="reqn">\boldsymbol\Psi</code> that is obtained with <code><a href="#topic+Psi_mat">Psi_mat</a>(X)</code>?
If <code>FALSE</code> (default), <code class="reqn">\boldsymbol\Psi</code> is computed
internally.</p>
</td></tr>
<tr><td><code id="sph_stat_Sobolev_+3A_p">p</code></td>
<td>
<p>integer giving the dimension of the ambient space <code class="reqn">R^p</code> that
contains <code class="reqn">S^{p-1}</code>.</p>
</td></tr>
<tr><td><code id="sph_stat_Sobolev_+3A_vk2">vk2</code></td>
<td>
<p>weights for the finite Sobolev test. A non-negative vector or
matrix. Defaults to <code>c(0, 0, 1)</code>.</p>
</td></tr>
<tr><td><code id="sph_stat_Sobolev_+3A_theta">Theta</code></td>
<td>
<p>a <b>matrix</b> of size <code>c(n, M)</code> with <code>M</code> samples
of size <code>n</code> of circular data on <code class="reqn">[0, 2\pi)</code>. Must not contain
<code>NA</code>'s.</p>
</td></tr>
<tr><td><code id="sph_stat_Sobolev_+3A_psi_in_theta">Psi_in_Theta</code></td>
<td>
<p>does <code>Theta</code> contain the shortest angles matrix
<code class="reqn">\boldsymbol\Psi</code> that is obtained with
<br /><code><a href="#topic+Psi_mat">Psi_mat</a>(array(Theta, dim = c(n, 1, M)))</code>? If <code>FALSE</code>
(default), <code class="reqn">\boldsymbol\Psi</code> is computed internally.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size <code>c(M, ncol(vk2))</code> containing the statistics for
each of the <code>M</code> samples.
</p>

<hr>
<h2 id='unif_stat'>Circular and (hyper)spherical uniformity statistics</h2><span id='topic+unif_stat'></span>

<h3>Description</h3>

<p>Implementation of several statistics for assessing uniformity
on the (hyper)sphere
<code class="reqn">S^{p-1} := \{{\bf x} \in R^p : ||{\bf x}|| = 1\}</code>, <code class="reqn">p\ge 2</code>, for a sample
<code class="reqn">{\bf X}_1,\ldots,{\bf X}_n\in S^{p-1}</code>.
</p>
<p><code>unif_stat</code> receives a (several) sample(s) of directions in
<em>Cartesian coordinates</em>, except for the circular case (<code class="reqn">p=2</code>) in
which the sample(s) can be <em>angles</em>
<code class="reqn">\Theta_1,\ldots,\Theta_n\in [0, 2\pi)</code>.
</p>
<p><code>unif_stat</code> allows to compute several statistics to several samples
within a single call, facilitating thus Monte Carlo experiments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unif_stat(data, type = "all", data_sorted = FALSE, Rayleigh_m = 1,
  cov_a = 2 * pi, Rothman_t = 1/3, Cressie_t = 1/3, Pycke_q = 0.5,
  Riesz_s = 1, CCF09_dirs = NULL, K_CCF09 = 25, CJ12_reg = 3,
  Poisson_rho = 0.5, Softmax_kappa = 1, Stereo_a = 0,
  Sobolev_vk2 = c(0, 0, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unif_stat_+3A_data">data</code></td>
<td>
<p>sample to compute the test statistic. An <b>array</b> of size
<code>c(n, p, M)</code> containing <code>M</code> samples of size <code>n</code> of directions
(in Cartesian coordinates) on <code class="reqn">S^{p-1}</code>. Alternatively, a
<b>matrix</b> of size <code>c(n, M)</code> with the angles on <code class="reqn">[0, 2\pi)</code> of
the <code>M</code> circular samples of size <code>n</code> on <code class="reqn">S^{1}</code>. Other objects
accepted are an array of size <code>c(n, 1, M)</code> or a vector of size
<code>n</code> with angular data. Must not contain <code>NA</code>'s.</p>
</td></tr>
<tr><td><code id="unif_stat_+3A_type">type</code></td>
<td>
<p>type of test to be applied. A character vector containing any of
the following types of tests, depending on the dimension <code class="reqn">p</code>:
</p>

<ul>
<li><p> Circular data: any of the names available at object
<code><a href="#topic+avail_cir_tests">avail_cir_tests</a></code>.
</p>
</li>
<li><p> (Hyper)spherical data: any of the names available at object
<code><a href="#topic+avail_sph_tests">avail_sph_tests</a></code>.
</p>
</li></ul>

<p>If <code>type = "all"</code> (default), then <code>type</code> is set as
<code>avail_cir_tests</code> or <code>avail_sph_tests</code>, depending on the value of
<code class="reqn">p</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_+3A_data_sorted">data_sorted</code></td>
<td>
<p>is the circular data sorted? If <code>TRUE</code>, certain
statistics are faster to compute. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_+3A_rayleigh_m">Rayleigh_m</code></td>
<td>
<p>integer <code class="reqn">m</code> for the <code class="reqn">m</code>-modal Rayleigh test.
Defaults to <code>m = 1</code> (the standard Rayleigh test).</p>
</td></tr>
<tr><td><code id="unif_stat_+3A_cov_a">cov_a</code></td>
<td>
<p><code class="reqn">a_n = a / n</code> parameter used in the length of the arcs
of the coverage-based tests. Must be positive. Defaults to <code>2 * pi</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_+3A_rothman_t">Rothman_t</code></td>
<td>
<p><code class="reqn">t</code> parameter for the Rothman test, a real in
<code class="reqn">(0, 1)</code>. Defaults to <code>1 / 3</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_+3A_cressie_t">Cressie_t</code></td>
<td>
<p><code class="reqn">t</code> parameter for the Cressie test, a real in
<code class="reqn">(0, 1)</code>. Defaults to <code>1 / 3</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_+3A_pycke_q">Pycke_q</code></td>
<td>
<p><code class="reqn">q</code> parameter for the Pycke &quot;<code class="reqn">q</code>-test&quot;, a real in
<code class="reqn">(0, 1)</code>. Defaults to <code>1 / 2</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_+3A_riesz_s">Riesz_s</code></td>
<td>
<p><code class="reqn">s</code> parameter for the <code class="reqn">s</code>-Riesz test, a real in
<code class="reqn">(0, 2)</code>. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_+3A_ccf09_dirs">CCF09_dirs</code></td>
<td>
<p>a matrix of size <code>c(n_proj, p)</code> containing
<code>n_proj</code> random directions (in Cartesian coordinates) on <code class="reqn">S^{p-1}</code>
to perform the CCF09 test. If <code>NULL</code> (default), a sample of size
<code>n_proj = 50</code> directions is computed internally.</p>
</td></tr>
<tr><td><code id="unif_stat_+3A_k_ccf09">K_CCF09</code></td>
<td>
<p>integer giving the truncation of the series present in the
asymptotic distribution of the Kolmogorov-Smirnov statistic. Defaults to
<code>5e2</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_+3A_cj12_reg">CJ12_reg</code></td>
<td>
<p>type of asymptotic regime for CJ12 test, either <code>1</code>
(sub-exponential regime), <code>2</code> (exponential), or <code>3</code>
(super-exponential; default).</p>
</td></tr>
<tr><td><code id="unif_stat_+3A_poisson_rho">Poisson_rho</code></td>
<td>
<p><code class="reqn">\rho</code> parameter for the Poisson test, a real in
<code class="reqn">[0, 1)</code>. Defaults to <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_+3A_softmax_kappa">Softmax_kappa</code></td>
<td>
<p><code class="reqn">\kappa</code> parameter for the Softmax test, a
non-negative real. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_+3A_stereo_a">Stereo_a</code></td>
<td>
<p><code class="reqn">a</code> parameter for the Stereo test, a real in
<code class="reqn">[-1, 1]</code>. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_+3A_sobolev_vk2">Sobolev_vk2</code></td>
<td>
<p>weights for the finite Sobolev test. A non-negative
vector or matrix. Defaults to <code>c(0, 0, 1)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Except <code>CCF09_dirs</code>, <code>K_CCF09</code>, and <code>CJ12_reg</code>, all the
test-specific parameters are vectorized.
</p>
<p>Descriptions and references for most of the statistics are available
in García-Portugués and Verdebout (2018).
</p>


<h3>Value</h3>

<p>A data frame of size <code>c(M, length(type))</code>, with column names
given by <code>type</code>, that contains the values of the test statistics.
</p>


<h3>References</h3>

<p>García-Portugués, E. and Verdebout, T. (2018) An overview of uniformity
tests on the hypersphere. <em>arXiv:1804.00286</em>.
<a href="https://arxiv.org/abs/1804.00286">https://arxiv.org/abs/1804.00286</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Circular data

# Sample
n &lt;- 10
M &lt;- 2
Theta &lt;- r_unif_cir(n = n, M = M)

# Matrix
unif_stat(data = Theta, type = "all")

# Array
unif_stat(data = array(Theta, dim = c(n, 1, M)), type = "all")

# Vector
unif_stat(data = Theta[, 1], type = "all")

## Spherical data

# Circular sample in Cartesian coordinates
n &lt;- 10
M &lt;- 2
X &lt;- array(dim = c(n, 2, M))
for (i in 1:M) X[, , i] &lt;- cbind(cos(Theta[, i]), sin(Theta[, i]))

# Array
unif_stat(data = X, type = "all")

# High-dimensional data
X &lt;- r_unif_sph(n = n, p = 3, M = M)
unif_stat(data = X, type = "all")

## Specific arguments

# Rothman
unif_stat(data = Theta, type = "Rothman", Rothman_t = 0.5)

# CCF09
unif_stat(data = X, type = "CCF09", CCF09_dirs = X[, , 1])
unif_stat(data = X, type = "CCF09", CCF09_dirs = X[, , 1], K_CCF09 = 1)

# CJ12
unif_stat(data = X, type = "CJ12", CJ12_reg = 3)
unif_stat(data = X, type = "CJ12", CJ12_reg = 1)
</code></pre>

<hr>
<h2 id='unif_stat_distr'>Null distributions for circular and (hyper)spherical uniformity
statistics</h2><span id='topic+unif_stat_distr'></span>

<h3>Description</h3>

<p>Approximate computation of the null distributions of several
statistics for assessing uniformity on the (hyper)sphere
<code class="reqn">S^{p-1}:=\{{\bf x}\in R^p:||{\bf x}||=1\}</code>, <code class="reqn">p\ge 2</code>. The approximation is done either by
means of the asymptotic distribution or by Monte Carlo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unif_stat_distr(x, type, p, n, approx = "asymp", M = 10000,
  stats_MC = NULL, Rayleigh_m = 1, cov_a = 2 * pi, Rothman_t = 1/3,
  Cressie_t = 1/3, Pycke_q = 0.5, Riesz_s = 1, CCF09_dirs = NULL,
  K_CCF09 = 25, CJ12_reg = 3, Poisson_rho = 0.5, Softmax_kappa = 1,
  Stereo_a = 0, Sobolev_vk2 = c(0, 0, 1), CJ12_beta = 0,
  Stephens = FALSE, K_Kuiper = 25, K_Watson = 25, K_Watson_1976 = 5,
  K_Ajne = 500, K_max = 10000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unif_stat_distr_+3A_x">x</code></td>
<td>
<p>evaluation points for the null distribution(s). Either a vector of
size <code>nx</code>, if the evaluation points are common for the tests in
<code>type</code>, or a matrix of size <code>c(nx, length(type))</code> with columns
containing the evaluation points for each test. Must not contain <code>NA</code>'s.</p>
</td></tr>
<tr><td><code id="unif_stat_distr_+3A_type">type</code></td>
<td>
<p>type of test to be applied. A character vector containing any of
the following types of tests, depending on the dimension <code class="reqn">p</code>:
</p>

<ul>
<li><p> Circular data: any of the names available at object
<code><a href="#topic+avail_cir_tests">avail_cir_tests</a></code>.
</p>
</li>
<li><p> (Hyper)spherical data: any of the names available at object
<code><a href="#topic+avail_sph_tests">avail_sph_tests</a></code>.
</p>
</li></ul>

<p>If <code>type = "all"</code> (default), then <code>type</code> is set as
<code>avail_cir_tests</code> or <code>avail_sph_tests</code>, depending on the value of
<code class="reqn">p</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_distr_+3A_p">p</code></td>
<td>
<p>integer giving the dimension of the ambient space <code class="reqn">R^p</code> that
contains <code class="reqn">S^{p-1}</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_distr_+3A_n">n</code></td>
<td>
<p>sample size employed for computing the statistic.</p>
</td></tr>
<tr><td><code id="unif_stat_distr_+3A_approx">approx</code></td>
<td>
<p>type of approximation to the null distribution, either
<code>"asymp"</code> (default) for employing the asymptotic null distribution, if
available, or <code>"MC"</code>, for employing the Monte Carlo approximation of
the exact null distribution.</p>
</td></tr>
<tr><td><code id="unif_stat_distr_+3A_m">M</code></td>
<td>
<p>number of Monte Carlo replications for approximating the null
distribution when <code>approx = "MC"</code>. Also, number of Monte Carlo samples
for approximating the asymptotic distributions based on weighted sums of chi
squared random variables. Defaults to <code>1e4</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_distr_+3A_stats_mc">stats_MC</code></td>
<td>
<p>a data frame of size <code>c(M, length(type))</code>, with column
names containing the character vector <code>type</code>, that results from
extracting <code>$stats_MC</code> from a call to <code><a href="#topic+unif_stat_MC">unif_stat_MC</a></code>. If
provided, the computation of Monte Carlo statistics when <code>approx = "MC"</code>
is skipped. <code>stats_MC</code> is checked internally to see if it is sorted.
Internally computed if <code>NULL</code> (default).</p>
</td></tr>
<tr><td><code id="unif_stat_distr_+3A_rayleigh_m">Rayleigh_m</code></td>
<td>
<p>integer <code class="reqn">m</code> for the <code class="reqn">m</code>-modal Rayleigh test.
Defaults to <code>m = 1</code> (the standard Rayleigh test).</p>
</td></tr>
<tr><td><code id="unif_stat_distr_+3A_cov_a">cov_a</code></td>
<td>
<p><code class="reqn">a_n = a / n</code> parameter used in the length of the arcs
of the coverage-based tests. Must be positive. Defaults to <code>2 * pi</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_distr_+3A_rothman_t">Rothman_t</code></td>
<td>
<p><code class="reqn">t</code> parameter for the Rothman test, a real in
<code class="reqn">(0, 1)</code>. Defaults to <code>1 / 3</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_distr_+3A_cressie_t">Cressie_t</code></td>
<td>
<p><code class="reqn">t</code> parameter for the Cressie test, a real in
<code class="reqn">(0, 1)</code>. Defaults to <code>1 / 3</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_distr_+3A_pycke_q">Pycke_q</code></td>
<td>
<p><code class="reqn">q</code> parameter for the Pycke &quot;<code class="reqn">q</code>-test&quot;, a real in
<code class="reqn">(0, 1)</code>. Defaults to <code>1 / 2</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_distr_+3A_riesz_s">Riesz_s</code></td>
<td>
<p><code class="reqn">s</code> parameter for the <code class="reqn">s</code>-Riesz test, a real in
<code class="reqn">(0, 2)</code>. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_distr_+3A_ccf09_dirs">CCF09_dirs</code></td>
<td>
<p>a matrix of size <code>c(n_proj, p)</code> containing
<code>n_proj</code> random directions (in Cartesian coordinates) on <code class="reqn">S^{p-1}</code>
to perform the CCF09 test. If <code>NULL</code> (default), a sample of size
<code>n_proj = 50</code> directions is computed internally.</p>
</td></tr>
<tr><td><code id="unif_stat_distr_+3A_k_ccf09">K_CCF09</code></td>
<td>
<p>integer giving the truncation of the series present in the
asymptotic distribution of the Kolmogorov-Smirnov statistic. Defaults to
<code>5e2</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_distr_+3A_cj12_reg">CJ12_reg</code></td>
<td>
<p>type of asymptotic regime for CJ12 test, either <code>1</code>
(sub-exponential regime), <code>2</code> (exponential), or <code>3</code>
(super-exponential; default).</p>
</td></tr>
<tr><td><code id="unif_stat_distr_+3A_poisson_rho">Poisson_rho</code></td>
<td>
<p><code class="reqn">\rho</code> parameter for the Poisson test, a real in
<code class="reqn">[0, 1)</code>. Defaults to <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_distr_+3A_softmax_kappa">Softmax_kappa</code></td>
<td>
<p><code class="reqn">\kappa</code> parameter for the Softmax test, a
non-negative real. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_distr_+3A_stereo_a">Stereo_a</code></td>
<td>
<p><code class="reqn">a</code> parameter for the Stereo test, a real in
<code class="reqn">[-1, 1]</code>. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_distr_+3A_sobolev_vk2">Sobolev_vk2</code></td>
<td>
<p>weights for the finite Sobolev test. A non-negative
vector or matrix. Defaults to <code>c(0, 0, 1)</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_distr_+3A_cj12_beta">CJ12_beta</code></td>
<td>
<p><code class="reqn">\beta</code> parameter in the exponential regime of CJ12
test, a positive real.</p>
</td></tr>
<tr><td><code id="unif_stat_distr_+3A_stephens">Stephens</code></td>
<td>
<p>compute Stephens (1970) modification so that the null
distribution of the is less dependent on the sample size? The modification
does not alter the test decision.</p>
</td></tr>
<tr><td><code id="unif_stat_distr_+3A_k_kuiper">K_Kuiper</code>, <code id="unif_stat_distr_+3A_k_watson">K_Watson</code>, <code id="unif_stat_distr_+3A_k_watson_1976">K_Watson_1976</code>, <code id="unif_stat_distr_+3A_k_ajne">K_Ajne</code></td>
<td>
<p>integer giving the truncation
of the series present in the null asymptotic distributions. For the
Kolmogorov-Smirnov-related series defaults to <code>25</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_distr_+3A_k_max">K_max</code></td>
<td>
<p>integer giving the truncation of the series that compute the
asymptotic p-value of a Sobolev test. Defaults to <code>1e4</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_distr_+3A_...">...</code></td>
<td>
<p>if <code>approx = "MC"</code>, optional performance parameters to be
passed to <br /><code><a href="#topic+unif_stat_MC">unif_stat_MC</a></code>: <code>chunks</code>, <code>cores</code>,
and <code>seed</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>approx = "asymp"</code>, statistics that do not have an implemented or
known asymptotic are omitted, and a warning is generated.
</p>
<p>For Sobolev tests, <code>K_max = 1e4</code> produces probabilities uniformly
accurate with three digits for the <code>"PCvM"</code>, <code>"PAD"</code>, and
<code>"PRt"</code> tests, for dimensions <code class="reqn">p \le 11</code>. With <code>K_max = 5e4</code>,
these probabilities are uniformly accurate in the fourth digit. With
<code>K_max = 1e3</code>, only two-digit uniform accuracy is obtained. Uniform
accuracy deteriorates when <code class="reqn">p</code> increases, e.g., a digit accuracy is lost
when <code class="reqn">p = 51</code>.
</p>
<p>Descriptions and references on most of the asymptotic distributions
are available in García-Portugués and Verdebout (2018).
</p>


<h3>Value</h3>

<p>A data frame of size <code>c(nx, length(type))</code>, with column names
given by <code>type</code>, that contains the values of the null distributions of
the statistics evaluated at <code>x</code>.
</p>


<h3>References</h3>

<p>García-Portugués, E. and Verdebout, T. (2018) An overview of uniformity
tests on the hypersphere. <em>arXiv:1804.00286</em>.
<a href="https://arxiv.org/abs/1804.00286">https://arxiv.org/abs/1804.00286</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Asymptotic distribution

# Circular statistics
x &lt;- seq(0, 1, l = 5)
unif_stat_distr(x = x, type = "Kuiper", p = 2, n = 10)
unif_stat_distr(x = x, type = c("Ajne", "Kuiper"), p = 2, n = 10)
unif_stat_distr(x = x, type = c("Ajne", "Kuiper"), p = 2, n = 10, K_Ajne = 5)

# All circular statistics
unif_stat_distr(x = x, type = avail_cir_tests, p = 2, n = 10, K_max = 1e3)

# Spherical statistics
unif_stat_distr(x = cbind(x, x + 1), type = c("Rayleigh", "Bingham"),
                p = 3, n = 10)
unif_stat_distr(x = cbind(x, x + 1), type = c("Rayleigh", "Bingham"),
                p = 3, n = 10, M = 100)

# All spherical statistics
unif_stat_distr(x = x, type = avail_sph_tests, p = 3, n = 10, K_max = 1e3)

## Monte Carlo distribution

# Circular statistics
x &lt;- seq(0, 5, l = 10)
unif_stat_distr(x = x, type = avail_cir_tests, p = 2, n = 10, approx = "MC")
unif_stat_distr(x = x, type = "Kuiper", p = 2, n = 10, approx = "MC")
unif_stat_distr(x = x, type = c("Ajne", "Kuiper"), p = 2, n = 10,
                approx = "MC")

# Spherical statistics
unif_stat_distr(x = x, type = avail_sph_tests, p = 3, n = 10,
                approx = "MC")
unif_stat_distr(x = cbind(x, x + 1), type = c("Rayleigh", "Bingham"),
                p = 3, n = 10, approx = "MC")
unif_stat_distr(x = cbind(x, x + 1), type = c("Rayleigh", "Bingham"),
                p = 3, n = 10, approx = "MC")

## Specific arguments

# Rothman
unif_stat_distr(x = x, type = "Rothman", p = 2, n = 10, Rothman_t = 0.5,
                approx = "MC")

# CCF09
dirs &lt;- r_unif_sph(n = 5, p = 3, M = 1)[, , 1]
x &lt;- seq(0, 1, l = 10)
unif_stat_distr(x = x, type = "CCF09", p = 3, n = 10, approx = "MC",
                CCF09_dirs = dirs)
unif_stat_distr(x = x, type = "CCF09", p = 3, n = 10, approx = "MC")

# CJ12
unif_stat_distr(x = x, type = "CJ12", p = 3, n = 100, CJ12_reg = 3)
unif_stat_distr(x = x, type = "CJ12", p = 3, n = 100, CJ12_reg = 2,
               CJ12_beta = 0.01)
unif_stat_distr(x = x, type = "CJ12", p = 3, n = 100, CJ12_reg = 1)

## Sobolev

x &lt;- seq(0, 1, l = 10)
vk2 &lt;- diag(1, nrow = 3)
unif_stat_distr(x = x, type = "Sobolev", approx = "asymp", p = 3, n = 100,
                Sobolev_vk2 = vk2)
sapply(1:3, function(i)
  unif_stat_distr(x = x, type = "Sobolev", approx = "asymp", p = 3, n = 100,
                  Sobolev_vk2 = vk2[i, ])$Sobolev)
sapply(1:3, function(i)
  unif_stat_distr(x = x, type = "Sobolev", approx = "MC", p = 3, n = 100,
                  Sobolev_vk2 = vk2[i, ], M = 1e3)$Sobolev)
unif_stat_distr(x = x, type = "Sobolev", approx = "MC", p = 3, n = 100,
                Sobolev_vk2 = vk2, M = 1e3)

</code></pre>

<hr>
<h2 id='unif_stat_MC'>Monte Carlo simulation of circular and (hyper)spherical uniformity
statistics</h2><span id='topic+unif_stat_MC'></span>

<h3>Description</h3>

<p>Utility for performing Monte Carlo simulation of several
statistics for assessing uniformity on the (hyper)sphere
<code class="reqn">S^{p-1}:=\{{\bf x}\in R^p:||{\bf x}||=1\}</code>, <code class="reqn">p\ge 2</code>.
</p>
<p><code>unif_stat_MC</code> provides a convenient wrapper for parallel
evaluation of <code>unif_stat</code>, the estimation of critical values under the
null distribution, and the computation of empirical powers under the
alternative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unif_stat_MC(n, type = "all", p, M = 10000, r_H1 = NULL,
  crit_val = NULL, alpha = c(0.1, 0.05, 0.01), return_stats = TRUE,
  stats_sorted = FALSE, chunks = ceiling((n * M)/1e+05), cores = 1,
  seeds = NULL, Rayleigh_m = 1, cov_a = 2 * pi, Rothman_t = 1/3,
  Cressie_t = 1/3, Pycke_q = 0.5, Riesz_s = 1, CCF09_dirs = NULL,
  K_CCF09 = 25, CJ12_reg = 3, Poisson_rho = 0.5, Softmax_kappa = 1,
  Stereo_a = 0, Sobolev_vk2 = c(0, 0, 1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unif_stat_MC_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="unif_stat_MC_+3A_type">type</code></td>
<td>
<p>type of test to be applied. A character vector containing any of
the following types of tests, depending on the dimension <code class="reqn">p</code>:
</p>

<ul>
<li><p> Circular data: any of the names available at object
<code><a href="#topic+avail_cir_tests">avail_cir_tests</a></code>.
</p>
</li>
<li><p> (Hyper)spherical data: any of the names available at object
<code><a href="#topic+avail_sph_tests">avail_sph_tests</a></code>.
</p>
</li></ul>

<p>If <code>type = "all"</code> (default), then <code>type</code> is set as
<code>avail_cir_tests</code> or <code>avail_sph_tests</code>, depending on the value of
<code class="reqn">p</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_MC_+3A_p">p</code></td>
<td>
<p>integer giving the dimension of the ambient space <code class="reqn">R^p</code> that
contains <code class="reqn">S^{p-1}</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_MC_+3A_m">M</code></td>
<td>
<p>number of Monte Carlo replications. Defaults to <code>1e4</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_MC_+3A_r_h1">r_H1</code></td>
<td>
<p>if provided, the computation of empirical powers is
carried out for the alternative hypothesis sampled with <code>r_H1</code>.
This must be a function with the same arguments and value as
<code><a href="#topic+r_unif_sph">r_unif_sph</a></code> (see examples). Defaults to <code>NULL</code>, indicating
that the critical values are estimated from samples of <code>r_unif_sph</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_MC_+3A_crit_val">crit_val</code></td>
<td>
<p>if provided, must be the critical values as returned by
<code>$stats_MC</code> in a call to <code>unif_stat_MC</code>. They are used for
computing the empirical powers of the tests present in <code>type</code>.
Defaults to <code>NULL</code>, which means that no power computation is done.</p>
</td></tr>
<tr><td><code id="unif_stat_MC_+3A_alpha">alpha</code></td>
<td>
<p>vector with significance levels. Defaults to
<code>c(0.10, 0.05, 0.01)</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_MC_+3A_return_stats">return_stats</code></td>
<td>
<p>return the Monte Carlo statistics? If only the critical
values or powers are desired, <code>FALSE</code> saves memory in the returned
object. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_MC_+3A_stats_sorted">stats_sorted</code></td>
<td>
<p>sort the returned Monte Carlo statistics? If
<code>TRUE</code>, this is useful for evaluating faster the empirical cumulative
distribution function when approximating the distribution in
<code><a href="#topic+unif_stat_distr">unif_stat_distr</a></code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_MC_+3A_chunks">chunks</code></td>
<td>
<p>number of chunks to split the <code>M</code> Monte Carlo
replications. Useful for parallelizing the simulation study in <code>chunks</code>
tasks containing <code>ceiling(M / chunks)</code> replications. Useful also for
avoiding memory bottlenecks when <code>M</code> is large. Defaults to
<br /><code>ceiling((n * M) / 1e5)</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_MC_+3A_cores">cores</code></td>
<td>
<p>number of cores to perform the simulation. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_MC_+3A_seeds">seeds</code></td>
<td>
<p>if provided, a vector of size <code>chunks</code> for fixing the
seeds on each of the simulation chunks (useful for reproducing parallel
simulations). Specifically, for <code>k in 1:chunks</code>, seeds are
set as <code>set.seed(seeds[k], kind = "Mersenne-Twister")</code> in each chunk.
Defaults to <code>NULL</code> (no seed setting is done).</p>
</td></tr>
<tr><td><code id="unif_stat_MC_+3A_rayleigh_m">Rayleigh_m</code></td>
<td>
<p>integer <code class="reqn">m</code> for the <code class="reqn">m</code>-modal Rayleigh test.
Defaults to <code>m = 1</code> (the standard Rayleigh test).</p>
</td></tr>
<tr><td><code id="unif_stat_MC_+3A_cov_a">cov_a</code></td>
<td>
<p><code class="reqn">a_n = a / n</code> parameter used in the length of the arcs
of the coverage-based tests. Must be positive. Defaults to <code>2 * pi</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_MC_+3A_rothman_t">Rothman_t</code></td>
<td>
<p><code class="reqn">t</code> parameter for the Rothman test, a real in
<code class="reqn">(0, 1)</code>. Defaults to <code>1 / 3</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_MC_+3A_cressie_t">Cressie_t</code></td>
<td>
<p><code class="reqn">t</code> parameter for the Cressie test, a real in
<code class="reqn">(0, 1)</code>. Defaults to <code>1 / 3</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_MC_+3A_pycke_q">Pycke_q</code></td>
<td>
<p><code class="reqn">q</code> parameter for the Pycke &quot;<code class="reqn">q</code>-test&quot;, a real in
<code class="reqn">(0, 1)</code>. Defaults to <code>1 / 2</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_MC_+3A_riesz_s">Riesz_s</code></td>
<td>
<p><code class="reqn">s</code> parameter for the <code class="reqn">s</code>-Riesz test, a real in
<code class="reqn">(0, 2)</code>. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_MC_+3A_ccf09_dirs">CCF09_dirs</code></td>
<td>
<p>a matrix of size <code>c(n_proj, p)</code> containing
<code>n_proj</code> random directions (in Cartesian coordinates) on <code class="reqn">S^{p-1}</code>
to perform the CCF09 test. If <code>NULL</code> (default), a sample of size
<code>n_proj = 50</code> directions is computed internally.</p>
</td></tr>
<tr><td><code id="unif_stat_MC_+3A_k_ccf09">K_CCF09</code></td>
<td>
<p>integer giving the truncation of the series present in the
asymptotic distribution of the Kolmogorov-Smirnov statistic. Defaults to
<code>5e2</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_MC_+3A_cj12_reg">CJ12_reg</code></td>
<td>
<p>type of asymptotic regime for CJ12 test, either <code>1</code>
(sub-exponential regime), <code>2</code> (exponential), or <code>3</code>
(super-exponential; default).</p>
</td></tr>
<tr><td><code id="unif_stat_MC_+3A_poisson_rho">Poisson_rho</code></td>
<td>
<p><code class="reqn">\rho</code> parameter for the Poisson test, a real in
<code class="reqn">[0, 1)</code>. Defaults to <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_MC_+3A_softmax_kappa">Softmax_kappa</code></td>
<td>
<p><code class="reqn">\kappa</code> parameter for the Softmax test, a
non-negative real. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_MC_+3A_stereo_a">Stereo_a</code></td>
<td>
<p><code class="reqn">a</code> parameter for the Stereo test, a real in
<code class="reqn">[-1, 1]</code>. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_MC_+3A_sobolev_vk2">Sobolev_vk2</code></td>
<td>
<p>weights for the finite Sobolev test. A non-negative
vector or matrix. Defaults to <code>c(0, 0, 1)</code>.</p>
</td></tr>
<tr><td><code id="unif_stat_MC_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to the <code>r_H1</code> sampler or to
<code><a href="foreach.html#topic+foreach">foreach</a></code> (for example, <code>.export</code> to export global
variables or other functions to the <code>foreach</code> environment).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is possible to have a progress bar if <code>unif_stat_MC</code> is wrapped with
<code><a href="progressr.html#topic+with_progress">progressr::with_progress</a></code> or if
<code>progressr::handlers(global = TRUE)</code> is invoked (once) by the user.
See the examples below. The progress bar is updated with the number of
finished chunks.
</p>
<p>All the tests reject for large values of the test statistic
(<code>max_gap = TRUE</code> is assumed for the Range test), so the critical
values for the significance levels <code>alpha</code> correspond to the
<code>alpha</code>-upper quantiles of the null distribution of the test statistic.
</p>
<p>The Monte Carlo simulation for the CCF09 test is made conditionally
on the choice of <code>CCF09_dirs</code>. That is, all the Monte Carlo statistics
share the same random directions.
</p>
<p>Except <code>CCF09_dirs</code>, <code>K_CCF09</code>, and <code>CJ12_reg</code>, all the
test-specific parameters are vectorized.
</p>


<h3>Value</h3>

<p>A list with the following entries:
</p>

<ul>
<li> <p><code>crit_val_MC</code>: a data frame of size
<code>c(length(alpha), length(type))</code>, with column names given by
<code>type</code> and rows corresponding to the significance levels <code>alpha</code>,
that contains the estimated critical values of the tests.
</p>
</li>
<li> <p><code>power_MC</code>: a data frame of size
<code>c(nrow(crit_val), length(type))</code>, with column names given by
<code>type</code> and rows corresponding to the significance levels of
<code>crit_val</code>, that contains the empirical powers of the tests. <code>NA</code>
if <code>crit_val = NULL</code>.
</p>
</li>
<li> <p><code>stats_MC</code>: a data frame of size <code>c(M, length(type))</code>, with
column names given by <code>type</code>, that contains the Monte Carlo
statistics.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Critical values

# Single statistic, specific alpha
cir &lt;- unif_stat_MC(n = 10, M = 1e2, type = "Ajne", p = 2, alpha = 0.15)
summary(cir$stats_MC)
cir$crit_val_MC

# All circular statistics
cir &lt;- unif_stat_MC(n = 10, M = 1e2, p = 2)
head(cir$stats_MC)
cir$crit_val_MC

# All spherical statistics
sph &lt;- unif_stat_MC(n = 10, M = 1e2, p = 3)
head(sph$stats_MC)
sph$crit_val_MC

## Using a progress bar

# Define a progress bar
require(progress)
require(progressr)
handlers(handler_progress(
  format = ":spin [:bar] :percent Total: :elapsedfull End \u2248 :eta",
  clear = FALSE))

# Call unif_stat_MC() within with_progress()
with_progress(unif_stat_MC(n = 10, M = 1e2, p = 3, chunks = 10))

# With several cores
with_progress(unif_stat_MC(n = 10, M = 1e2, p = 3, chunks = 10, cores = 2))

# Instead of using with_progress() each time, it is more practical to run
# handlers(global = TRUE)
# once to activate progress bars in your R session

## Power computation

# Single statistic
cir_pow &lt;- unif_stat_MC(n = 10, M = 1e2, type = "Ajne", p = 2,
                        crit_val = cir$crit_val_MC)
cir_pow$crit_val_MC
cir_pow$power_MC

# All circular statistics
cir_pow &lt;- unif_stat_MC(n = 10, M = 1e2, p = 2, crit_val = cir$crit_val_MC)
cir_pow$crit_val_MC
cir_pow$power_MC

# All spherical statistics
sph_pow &lt;- unif_stat_MC(n = 10, M = 1e2, p = 3, crit_val = sph$crit_val_MC)
sph_pow$crit_val_MC
sph_pow$power_MC

## Custom r_H1

# Circular
r_H1 &lt;- function(n, p, M, l = 0.05) {

  stopifnot(p == 2)
  Theta_to_X(matrix(runif(n * M, 0, (2 - l) * pi), n, M))

}
dirs &lt;- r_unif_sph(n = 5, p = 2, M = 1)[, , 1]
cir &lt;- unif_stat_MC(n = 50, M = 1e2, p = 2, CCF09_dirs = dirs)
cir_pow &lt;- unif_stat_MC(n = 50, M = 1e2, p = 2, r_H1 = r_H1, l = 0.10,
                        crit_val = cir$crit_val_MC, CCF09_dirs = dirs)
cir_pow$crit_val_MC
cir_pow$power_MC

# Spherical
r_H1 &lt;- function(n, p, M, l = 0.5) {

  samp &lt;- array(dim = c(n, p, M))
  for (j in 1:M) {

    samp[, , j] &lt;- mvtnorm::rmvnorm(n = n, mean = c(l, rep(0, p - 1)),
                                    sigma = diag(rep(1, p)))
    samp[, , j] &lt;- samp[, , j] / sqrt(rowSums(samp[, , j]^2))

  }
  return(samp)

}
dirs &lt;- r_unif_sph(n = 5, p = 3, M = 1)[, , 1]
sph &lt;- unif_stat_MC(n = 50, M = 1e2, p = 3, CCF09_dirs = dirs)
sph_pow &lt;- unif_stat_MC(n = 50, M = 1e2, p = 3, r_H1 = r_H1, l = 0.5,
                       crit_val = sph$crit_val_MC, CCF09_dirs = dirs)
sph_pow$power_MC

## Pre-built r_H1

# Circular
dirs &lt;- r_unif_sph(n = 5, p = 2, M = 1)[, , 1]
cir_pow &lt;- unif_stat_MC(n = 50, M = 1e2, p = 2, r_H1 = r_alt, alt = "vMF",
                        kappa = 1, crit_val = cir$crit_val_MC,
                        CCF09_dirs = dirs)
cir_pow$power_MC

# Spherical
dirs &lt;- r_unif_sph(n = 5, p = 3, M = 1)[, , 1]
sph_pow &lt;- unif_stat_MC(n = 50, M = 1e2, p = 3, r_H1 = r_alt, alt = "vMF",
                        kappa = 1, crit_val = sph$crit_val_MC,
                        CCF09_dirs = dirs)
sph_pow$power_MC

</code></pre>

<hr>
<h2 id='unif_test'>Circular and (hyper)spherical uniformity tests</h2><span id='topic+unif_test'></span>

<h3>Description</h3>

<p>Implementation of several uniformity tests on the (hyper)sphere
<code class="reqn">S^{p-1}:=\{{\bf x}\in R^p:||{\bf x}||=1\}</code>, <code class="reqn">p\ge 2</code>, with calibration either in
terms of their asymptotic/exact distributions, if available, or Monte Carlo.
</p>
<p><code>unif_test</code> receives a sample of directions
<code class="reqn">{\bf X}_1,\ldots,{\bf X}_n\in S^{p-1}</code> in
<em>Cartesian coordinates</em>, except for the circular case (<code class="reqn">p=2</code>) in
which the sample can be represented in terms of <em>angles</em>
<code class="reqn">\Theta_1,\ldots,\Theta_n\in [0, 2\pi)</code>.
</p>
<p><code>unif_test</code> allows to perform several tests within a single call,
facilitating thus the exploration of a dataset by applying several tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unif_test(data, type = "all", p_value = "asymp", alpha = c(0.1, 0.05,
  0.01), M = 10000, stats_MC = NULL, crit_val = NULL,
  data_sorted = FALSE, Rayleigh_m = 1, cov_a = 2 * pi, Rothman_t = 1/3,
  Cressie_t = 1/3, Pycke_q = 0.5, Riesz_s = 1, CCF09_dirs = NULL,
  K_CCF09 = 25, CJ12_reg = 3, CJ12_beta = 0, Poisson_rho = 0.5,
  Softmax_kappa = 1, Stereo_a = 0, Sobolev_vk2 = c(0, 0, 1),
  K_max = 10000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unif_test_+3A_data">data</code></td>
<td>
<p>sample to perform the test. A matrix of size <code>c(n, p)</code>
containing a sample of size <code>n</code> of directions (in Cartesian
coordinates) on <code class="reqn">S^{p-1}</code>. Alternatively if <code>p = 2</code>, a matrix of
size <code>c(n, 1)</code> containing the <code>n</code> angles on <code class="reqn">[0, 2\pi)</code> of the
circular sample on <code class="reqn">S^{1}</code>. Other objects accepted are an array of size
<code>c(n, p, 1)</code> with directions (in Cartesian coordinates), or a vector of
size <code>n</code> or an array of size <code>c(n, 1, 1)</code> with angular data.
Must not contain <code>NA</code>'s.</p>
</td></tr>
<tr><td><code id="unif_test_+3A_type">type</code></td>
<td>
<p>type of test to be applied. A character vector containing any of
the following types of tests, depending on the dimension <code class="reqn">p</code>:
</p>

<ul>
<li><p> Circular data: any of the names available at object
<code><a href="#topic+avail_cir_tests">avail_cir_tests</a></code>.
</p>
</li>
<li><p> (Hyper)spherical data: any of the names available at object
<code><a href="#topic+avail_sph_tests">avail_sph_tests</a></code>.
</p>
</li></ul>

<p>If <code>type = "all"</code> (default), then <code>type</code> is set as
<code>avail_cir_tests</code> or <code>avail_sph_tests</code>, depending on the value of
<code class="reqn">p</code>.</p>
</td></tr>
<tr><td><code id="unif_test_+3A_p_value">p_value</code></td>
<td>
<p>type of <code class="reqn">p</code>-value computation. Either <code>"MC"</code> for
employing the approximation by Monte Carlo of the exact null distribution,
<code>"asymp"</code> (default) for the use of the asymptotic/exact null
distribution (if available), or <code>"crit_val"</code> for approximation by means
of the table of critical values <code>crit_val</code>.</p>
</td></tr>
<tr><td><code id="unif_test_+3A_alpha">alpha</code></td>
<td>
<p>vector with significance levels. Defaults to
<code>c(0.10, 0.05, 0.01)</code>.</p>
</td></tr>
<tr><td><code id="unif_test_+3A_m">M</code></td>
<td>
<p>number of Monte Carlo replications for approximating the null
distribution when <code>approx = "MC"</code>. Also, number of Monte Carlo samples
for approximating the asymptotic distributions based on weighted sums of chi
squared random variables. Defaults to <code>1e4</code>.</p>
</td></tr>
<tr><td><code id="unif_test_+3A_stats_mc">stats_MC</code></td>
<td>
<p>a data frame of size <code>c(M, length(type))</code>, with column
names containing the character vector <code>type</code>, that results from
extracting <code>$stats_MC</code> from a call to <code><a href="#topic+unif_stat_MC">unif_stat_MC</a></code>. If
provided, the computation of Monte Carlo statistics when <code>approx = "MC"</code>
is skipped. <code>stats_MC</code> is checked internally to see if it is sorted.
Internally computed if <code>NULL</code> (default).</p>
</td></tr>
<tr><td><code id="unif_test_+3A_crit_val">crit_val</code></td>
<td>
<p>table with critical values for the tests, to be used if
<code>p_value = "crit_val"</code>. A data frame, with column names containing the
character vector <code>type</code> and rows corresponding to the significance
levels <code>alpha</code>, that results from extracting <code>$crit_val_MC</code> from
a call to <code><a href="#topic+unif_stat_MC">unif_stat_MC</a></code>. Internally computed if
<code>NULL</code> (default).</p>
</td></tr>
<tr><td><code id="unif_test_+3A_data_sorted">data_sorted</code></td>
<td>
<p>is the circular data sorted? If <code>TRUE</code>, certain
statistics are faster to compute. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="unif_test_+3A_rayleigh_m">Rayleigh_m</code></td>
<td>
<p>integer <code class="reqn">m</code> for the <code class="reqn">m</code>-modal Rayleigh test.
Defaults to <code>m = 1</code> (the standard Rayleigh test).</p>
</td></tr>
<tr><td><code id="unif_test_+3A_cov_a">cov_a</code></td>
<td>
<p><code class="reqn">a_n = a / n</code> parameter used in the length of the arcs
of the coverage-based tests. Must be positive. Defaults to <code>2 * pi</code>.</p>
</td></tr>
<tr><td><code id="unif_test_+3A_rothman_t">Rothman_t</code></td>
<td>
<p><code class="reqn">t</code> parameter for the Rothman test, a real in
<code class="reqn">(0, 1)</code>. Defaults to <code>1 / 3</code>.</p>
</td></tr>
<tr><td><code id="unif_test_+3A_cressie_t">Cressie_t</code></td>
<td>
<p><code class="reqn">t</code> parameter for the Cressie test, a real in
<code class="reqn">(0, 1)</code>. Defaults to <code>1 / 3</code>.</p>
</td></tr>
<tr><td><code id="unif_test_+3A_pycke_q">Pycke_q</code></td>
<td>
<p><code class="reqn">q</code> parameter for the Pycke &quot;<code class="reqn">q</code>-test&quot;, a real in
<code class="reqn">(0, 1)</code>. Defaults to <code>1 / 2</code>.</p>
</td></tr>
<tr><td><code id="unif_test_+3A_riesz_s">Riesz_s</code></td>
<td>
<p><code class="reqn">s</code> parameter for the <code class="reqn">s</code>-Riesz test, a real in
<code class="reqn">(0, 2)</code>. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="unif_test_+3A_ccf09_dirs">CCF09_dirs</code></td>
<td>
<p>a matrix of size <code>c(n_proj, p)</code> containing
<code>n_proj</code> random directions (in Cartesian coordinates) on <code class="reqn">S^{p-1}</code>
to perform the CCF09 test. If <code>NULL</code> (default), a sample of size
<code>n_proj = 50</code> directions is computed internally.</p>
</td></tr>
<tr><td><code id="unif_test_+3A_k_ccf09">K_CCF09</code></td>
<td>
<p>integer giving the truncation of the series present in the
asymptotic distribution of the Kolmogorov-Smirnov statistic. Defaults to
<code>5e2</code>.</p>
</td></tr>
<tr><td><code id="unif_test_+3A_cj12_reg">CJ12_reg</code></td>
<td>
<p>type of asymptotic regime for CJ12 test, either <code>1</code>
(sub-exponential regime), <code>2</code> (exponential), or <code>3</code>
(super-exponential; default).</p>
</td></tr>
<tr><td><code id="unif_test_+3A_cj12_beta">CJ12_beta</code></td>
<td>
<p><code class="reqn">\beta</code> parameter in the exponential regime of CJ12
test, a positive real.</p>
</td></tr>
<tr><td><code id="unif_test_+3A_poisson_rho">Poisson_rho</code></td>
<td>
<p><code class="reqn">\rho</code> parameter for the Poisson test, a real in
<code class="reqn">[0, 1)</code>. Defaults to <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="unif_test_+3A_softmax_kappa">Softmax_kappa</code></td>
<td>
<p><code class="reqn">\kappa</code> parameter for the Softmax test, a
non-negative real. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="unif_test_+3A_stereo_a">Stereo_a</code></td>
<td>
<p><code class="reqn">a</code> parameter for the Stereo test, a real in
<code class="reqn">[-1, 1]</code>. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="unif_test_+3A_sobolev_vk2">Sobolev_vk2</code></td>
<td>
<p>weights for the finite Sobolev test. A non-negative
vector or matrix. Defaults to <code>c(0, 0, 1)</code>.</p>
</td></tr>
<tr><td><code id="unif_test_+3A_k_max">K_max</code></td>
<td>
<p>integer giving the truncation of the series that compute the
asymptotic p-value of a Sobolev test. Defaults to <code>1e4</code>.</p>
</td></tr>
<tr><td><code id="unif_test_+3A_...">...</code></td>
<td>
<p>If <code>p_value = "MC"</code> or <code>p_value = "crit_val"</code>, optional
performance parameters to be passed to <code><a href="#topic+unif_stat_MC">unif_stat_MC</a></code>:
<code>chunks</code>, <code>cores</code>, and <code>seed</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All the tests reject for large values of the test statistic, so the critical
values for the significance levels <code>alpha</code> correspond to the
<code>alpha</code>-upper quantiles of the null distribution of the test statistic.
</p>
<p>When <code>p_value = "asymp"</code>, tests that do not have an implemented or
known asymptotic are omitted, and a warning is generated.
</p>
<p>When <code>p_value = "MC"</code>, it is possible to have a progress bar indicating
the Monte Carlo simulation progress if <code>unif_test</code> is wrapped with
<code><a href="progressr.html#topic+with_progress">progressr::with_progress</a></code> or if
<code>progressr::handlers(global = TRUE)</code> is invoked (once) by the user.
See the examples below. The progress bar is updated with the number of
finished chunks.
</p>
<p>All the statistics are continuous random variables except the
Hodges&ndash;Ajne statistic (<code>"Hodges_Ajne"</code>), the Cressie statistic
(<code>"Cressie"</code>), and the number of (different) uncovered spacings
(<code>"Num_uncover"</code>). These three statistics are discrete random variables.
</p>
<p>The Monte Carlo calibration for the CCF09 test is made conditionally
on the choice of <br /><code>CCF09_dirs</code>. That is, all the Monte
Carlo statistics share the same random directions.
</p>
<p>Except <code>CCF09_dirs</code>, <code>K_CCF09</code>, and <code>CJ12_reg</code>, all the
test-specific parameters are vectorized.
</p>
<p>Descriptions and references for most of the tests are available
in García-Portugués and Verdebout (2018).
</p>


<h3>Value</h3>

<p>If only a <b>single test</b> is performed, a list with class
<code>htest</code> containing the following components:
</p>

<ul>
<li> <p><code>statistic</code>: the value of the test statistic.
</p>
</li>
<li> <p><code>p.value</code>: the p-value of the test. If
<code>p_value = "crit_val"</code>, an <code>NA</code>.
</p>
</li>
<li> <p><code>alternative</code>: a character string describing the alternative
hypothesis.
</p>
</li>
<li> <p><code>method</code>: a character string indicating what type of test was
performed.
</p>
</li>
<li> <p><code>data.name</code>: a character string giving the name of the data.
</p>
</li>
<li> <p><code>reject</code>: the rejection decision for the levels of significance
<code>alpha</code>.
</p>
</li>
<li> <p><code>crit_val</code>: a vector with the critical values for the
significance levels <code>alpha</code> used with <code>p_value = "MC"</code> or
<code>p_value = "asymp"</code>.
</p>
</li>
<li> <p><code>param</code>: parameter(s) used in the test (if any).
</p>
</li></ul>

<p>If <b>several tests</b> are performed, a <code>type</code>-named list with
entries for each test given by the above list.
</p>


<h3>References</h3>

<p>García-Portugués, E. and Verdebout, T. (2018) An overview of uniformity
tests on the hypersphere. <em>arXiv:1804.00286</em>.
<a href="https://arxiv.org/abs/1804.00286">https://arxiv.org/abs/1804.00286</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Asymptotic distribution

# Circular data
n &lt;- 10
samp_cir &lt;- r_unif_cir(n = n)

# Matrix
unif_test(data = samp_cir, type = "Ajne", p_value = "asymp")

# Vector
unif_test(data = samp_cir[, 1], type = "Ajne", p_value = "asymp")

# Array
unif_test(data = array(samp_cir, dim = c(n, 1, 1)), type = "Ajne",
          p_value = "asymp")

# Several tests
unif_test(data = samp_cir, type = avail_cir_tests, p_value = "asymp")

# Spherical data
n &lt;- 10
samp_sph &lt;- r_unif_sph(n = n, p = 3)

# Array
unif_test(data = samp_sph, type = "Bingham", p_value = "asymp")

# Matrix
unif_test(data = samp_sph[, , 1], type = "Bingham", p_value = "asymp")

# Several tests
unif_test(data = samp_sph, type = avail_sph_tests, p_value = "asymp")

## Monte Carlo

# Circular data
unif_test(data = samp_cir, type = "Ajne", p_value = "MC")
unif_test(data = samp_cir, type = avail_cir_tests, p_value = "MC")

# Spherical data
unif_test(data = samp_sph, type = "Bingham", p_value = "MC")
unif_test(data = samp_sph, type = avail_sph_tests, p_value = "MC")

# Caching stats_MC
stats_MC_cir &lt;- unif_stat_MC(n = nrow(samp_cir), p = 2)$stats_MC
stats_MC_sph &lt;- unif_stat_MC(n = nrow(samp_sph), p = 3)$stats_MC
unif_test(data = samp_cir, type = avail_cir_tests,
          p_value = "MC", stats_MC = stats_MC_cir)
unif_test(data = samp_sph, type = avail_sph_tests, p_value = "MC",
          stats_MC = stats_MC_sph)

## Critical values

# Circular data
unif_test(data = samp_cir, type = avail_cir_tests, p_value = "crit_val")

# Spherical data
unif_test(data = samp_sph, type = avail_sph_tests, p_value = "crit_val")

# Caching crit_val
crit_val_cir &lt;- unif_stat_MC(n = n, p = 2)$crit_val_MC
crit_val_sph &lt;- unif_stat_MC(n = n, p = 3)$crit_val_MC
unif_test(data = samp_cir, type = avail_cir_tests,
          p_value = "crit_val", crit_val = crit_val_cir)
unif_test(data = samp_sph, type = avail_sph_tests, p_value = "crit_val",
          crit_val = crit_val_sph)

## Specific arguments

# Rothman
unif_test(data = samp_cir, type = "Rothman", Rothman_t = 0.5)

# CCF09
unif_test(data = samp_sph, type = "CCF09", p_value = "MC",
          CCF09_dirs = samp_sph[1:2, , 1])
unif_test(data = samp_sph, type = "CCF09", p_value = "MC",
          CCF09_dirs = samp_sph[3:4, , 1])

## Using a progress bar when p_value = "MC"

# Define a progress bar
require(progress)
require(progressr)
handlers(handler_progress(
  format = ":spin [:bar] :percent Total: :elapsedfull End \u2248 :eta",
  clear = FALSE))

# Call unif_test() within with_progress()
with_progress(
  unif_test(data = samp_sph, type = avail_sph_tests, p_value = "MC",
            chunks = 10, M = 1e3)
)

# With several cores
with_progress(
  unif_test(data = samp_sph, type = avail_sph_tests, p_value = "MC",
            cores = 2, chunks = 10, M = 1e3)
)

# Instead of using with_progress() each time, it is more practical to run
# handlers(global = TRUE)
# once to activate progress bars in your R session

</code></pre>

<hr>
<h2 id='utils'>Low-level utilities for <span class="pkg">sphunif</span></h2><span id='topic+utils'></span><span id='topic+n_from_dist_vector'></span><span id='topic+t_inv_sqrt_one'></span>

<h3>Description</h3>

<p>Internal and undocumented low-level utilities for
<span class="pkg">sphunif</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_from_dist_vector(n_dist)

t_inv_sqrt_one(t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utils_+3A_n_dist">n_dist</code></td>
<td>
<p>a positive integer <code class="reqn">(n - 1) * n / 2</code> for which <code class="reqn">n</code>
is to be recovered.</p>
</td></tr>
<tr><td><code id="utils_+3A_t">t</code></td>
<td>
<p>a vector to evaluate <code class="reqn">t / \sqrt{1 - t^2}</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='venus'>Venus craters</h2><span id='topic+venus'></span>

<h3>Description</h3>

<p>Craters on Venus from the
<a href="https://astrogeology.usgs.gov/search/map/Venus/venuscraters">
USGS Astrogeology Science Center</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>venus
</code></pre>


<h3>Format</h3>

<p>A data frame with 967 rows and 4 variables:
</p>

<dl>
<dt>name</dt><dd><p>name of the crater (if named).</p>
</dd>
<dt>diameter</dt><dd><p>diameter of the crater (in km).</p>
</dd>
<dt>theta</dt><dd><p>longitude angle <code class="reqn">\theta \in [0, 2\pi)</code> of the
crater center.</p>
</dd>
<dt>phi</dt><dd><p>latitude angle <code class="reqn">\phi \in [-\pi/2, \pi/2]</code> of the
crater center.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The <code class="reqn">(\theta, \phi)</code> angles are such their associated planetocentric
coordinates are:
</p>
<p style="text-align: center;"><code class="reqn">(\cos(\phi) \cos(\theta), \cos(\phi) \sin(\theta), \sin(\phi))',</code>
</p>

<p>with <code class="reqn">(0, 0, 1)'</code> denoting the north pole.
</p>
<p>The script performing the data preprocessing is available at
<a href="https://github.com/egarpor/sphunif/blob/master/data-raw/venus.R">
<code>venus.R</code></a>.
</p>


<h3>Source</h3>

<p><a href="https://astrogeology.usgs.gov/search/map/Venus/venuscraters">https://astrogeology.usgs.gov/search/map/Venus/venuscraters</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data("venus")

# Add Cartesian coordinates
venus$X &lt;- cbind(cos(venus$theta) * cos(venus$phi),
                 sin(venus$theta) * cos(venus$phi),
                 sin(venus$phi))

# Tests
unif_test(data = venus$X, type = c("PCvM", "PAD", "PRt"), p_value = "asymp")
</code></pre>

<hr>
<h2 id='wschisq'>Weighted sums of non-central chi squared random variables</h2><span id='topic+wschisq'></span><span id='topic+d_wschisq'></span><span id='topic+p_wschisq'></span><span id='topic+q_wschisq'></span><span id='topic+r_wschisq'></span><span id='topic+cutoff_wschisq'></span>

<h3>Description</h3>

<p>Approximated density, distribution, and quantile functions for
weighted sums of non-central chi squared random variables:
</p>
<p style="text-align: center;"><code class="reqn">Q_K = \sum_{i = 1}^K w_i \chi^2_{d_i}(\lambda_i),</code>
</p>

<p>where <code class="reqn">w_1, \ldots, w_n</code> are positive weights, <code class="reqn">d_1, \ldots, d_n</code>
are positive degrees of freedom, and <code class="reqn">\lambda_1, \ldots, \lambda_n</code>
are non-negative non-centrality parameters. Also, simulation of <code class="reqn">Q_K</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_wschisq(x, weights, dfs, ncps = 0, method = c("I", "SW", "HBE")[1],
  exact_chisq = TRUE, imhof_epsabs = 1e-06, imhof_epsrel = 1e-06,
  imhof_limit = 10000, grad_method = "simple",
  grad_method.args = list(eps = 1e-07))

p_wschisq(x, weights, dfs, ncps = 0, method = c("I", "SW", "HBE", "MC")[1],
  exact_chisq = TRUE, imhof_epsabs = 1e-06, imhof_epsrel = 1e-06,
  imhof_limit = 10000, M = 10000, MC_sample = NULL)

q_wschisq(u, weights, dfs, ncps = 0, method = c("I", "SW", "HBE", "MC")[1],
  exact_chisq = TRUE, imhof_epsabs = 1e-06, imhof_epsrel = 1e-06,
  imhof_limit = 10000, nlm_gradtol = 1e-06, nlm_iterlim = 1000,
  M = 10000, MC_sample = NULL)

r_wschisq(n, weights, dfs, ncps = 0)

cutoff_wschisq(thre = 1e-04, weights, dfs, ncps = 0, log = FALSE,
  x_tail = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wschisq_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="wschisq_+3A_weights">weights</code></td>
<td>
<p>vector with the positive weights of the sum. Must have the
same length as <code>dfs</code>.</p>
</td></tr>
<tr><td><code id="wschisq_+3A_dfs">dfs</code></td>
<td>
<p>vector with the positive degrees of freedom of the chi squared
random variables. Must have the same length as <code>weights</code>.</p>
</td></tr>
<tr><td><code id="wschisq_+3A_ncps">ncps</code></td>
<td>
<p>non-centrality parameters. Either <code>0</code> (default) or a
vector with the same length as <code>weights</code>.</p>
</td></tr>
<tr><td><code id="wschisq_+3A_method">method</code></td>
<td>
<p>method for approximating the density, distribution, or
quantile function. Must be <code>"I"</code> (Imhof), <code>"SW"</code>
(Satterthwaite&ndash;Welch), <code>"HBE"</code> (Hall&ndash;Buckley&ndash;Eagleson), or
<code>"MC"</code> (Monte Carlo; only for distribution or quantile functions).
Defaults to <code>"I"</code>.</p>
</td></tr>
<tr><td><code id="wschisq_+3A_exact_chisq">exact_chisq</code></td>
<td>
<p>if <code>weights</code> and <code>dfs</code> have length one, shall
the <code><a href="stats.html#topic+Chisquare">Chisquare</a></code> functions be called? Otherwise, the
approximations are computed for this exact case. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="wschisq_+3A_imhof_epsabs">imhof_epsabs</code>, <code id="wschisq_+3A_imhof_epsrel">imhof_epsrel</code>, <code id="wschisq_+3A_imhof_limit">imhof_limit</code></td>
<td>
<p>precision parameters passed to
<code><a href="CompQuadForm.html#topic+imhof">imhof</a></code>'s <code>epsabs</code>, <code>epsrel</code>, and
<code>limit</code>, respectively. They default to <code>1e-6</code>, <code>1e-6</code>,
and <code>1e4</code>.</p>
</td></tr>
<tr><td><code id="wschisq_+3A_grad_method">grad_method</code>, <code id="wschisq_+3A_grad_method.args">grad_method.args</code></td>
<td>
<p>numerical differentiation parameters
passed to <code><a href="numDeriv.html#topic+grad">grad</a></code>'s <code>method</code> and
<code>method.args</code>, respectively. They default to <code>"simple"</code>,
and <code>list(eps = 1e-7)</code> (better precision than <code>imhof_epsabs</code> to
avoid numerical artifacts).</p>
</td></tr>
<tr><td><code id="wschisq_+3A_m">M</code></td>
<td>
<p>number of Monte Carlo samples for approximating the distribution if
<code>method = "MC"</code>. Defaults to <code>1e4</code>.</p>
</td></tr>
<tr><td><code id="wschisq_+3A_mc_sample">MC_sample</code></td>
<td>
<p>if provided, it is employed when <code>method = "MC"</code>. If
not, it is computed internally.</p>
</td></tr>
<tr><td><code id="wschisq_+3A_u">u</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="wschisq_+3A_nlm_gradtol">nlm_gradtol</code>, <code id="wschisq_+3A_nlm_iterlim">nlm_iterlim</code></td>
<td>
<p>convergence control parameters passed to
<code><a href="stats.html#topic+nlm">nlm</a></code>'s <code>gradtol</code> and <code>iterlim</code>, respectively.
They default to <code>1e-6</code> and <code>1e3</code>.</p>
</td></tr>
<tr><td><code id="wschisq_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="wschisq_+3A_thre">thre</code></td>
<td>
<p>vector with the error thresholds of the tail probability and
mean/variance explained by the first terms of the series. Defaults to
<code>1e-4</code>. See details.</p>
</td></tr>
<tr><td><code id="wschisq_+3A_log">log</code></td>
<td>
<p>are <code>weights</code> and <code>dfs</code> given in log-scale? Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="wschisq_+3A_x_tail">x_tail</code></td>
<td>
<p>scalar evaluation point for determining the upper tail
probability. If <code>NULL</code>, set to the <code>0.90</code> quantile of the whole
series, computed by the <code>"HBE"</code> approximation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Four methods are implemented for approximating the distribution of a
weighted sum of chi squared random variables:
</p>

<ul>
<li> <p><code>"I"</code>: Imhof's approximation (Imhof, 1961) for the evaluation
of the distribution function. If this method is selected, the function
is simply a wrapper to <code><a href="CompQuadForm.html#topic+imhof">imhof</a></code> from the
<code>CompQuadForm</code> package (Duchesne and Lafaye De Micheaux, 2010).
</p>
</li>
<li> <p><code>"SW"</code>: Satterthwaite&ndash;Welch (Satterthwaite, 1946; Welch, 1938)
approximation, consisting in matching the first <em>two</em> moments of
<code class="reqn">Q_K</code> with a gamma distribution.
</p>
</li>
<li> <p><code>"HBE"</code>: Hall&ndash;Buckley&ndash;Eagleson (Hall, 1983; Buckley and
Eagleson, 1988) approximation, consisting in matching the first
<em>three</em> moments of <code class="reqn">Q_K</code> with a gamma distribution.
</p>
</li>
<li> <p><code>"MC"</code>: Monte Carlo approximation using the empirical
cumulative distribution function with <code>M</code> simulated samples.
</p>
</li></ul>

<p>The Imhof method is exact up to the prescribed numerical accuracy. It is
also the most time-consuming method. The density and quantile functions
for this approximation are obtained by numerical differentiation and
inversion, respectively, of the approximated distribution.
</p>
<p>For the methods based on gamma matching, the <code><a href="stats.html#topic+GammaDist">GammaDist</a></code>
density, distribution, and quantile functions are invoked. The
Hall&ndash;Buckley&ndash;Eagleson approximation tends to overperform the
Satterthwaite&ndash;Welch approximation.
</p>
<p>The Monte Carlo method is relatively inaccurate and slow, but serves as an
unbiased reference of the true distribution function. The inversion of the
empirical cumulative distribution is done by <code><a href="stats.html#topic+quantile">quantile</a></code>.
</p>
<p>An empirical comparison of these and other approximation methods is
given in Bodenham and Adams (2016).
</p>
<p><code>cutoff_wschisq</code> removes <code>NA</code>s/<code>NaN</code>s in <code>weights</code> or
<code>dfs</code> with a message. The threshold <code>thre</code> ensures that the
tail probability of the truncated and whole series differ less than
<code>thre</code> at <code>x_tail</code>, or that <code>thre</code> is the proportion of the
mean/variance of the whole series that is <em>not</em> retained. The (upper)
tail probabilities for evaluating truncation are computed using the
Hall&ndash;Buckley&ndash;Eagleson approximation at <code>x_tail</code>.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>d_wschisq</code>: density function evaluated at <code>x</code>, a vector.
</p>
</li>
<li> <p><code>p_wschisq</code>: distribution function evaluated at <code>x</code>,
a vector.
</p>
</li>
<li> <p><code>q_wschisq</code>: quantile function evaluated at <code>u</code>, a vector.
</p>
</li>
<li> <p><code>r_wschisq</code>: a vector of size <code>n</code> containing a random
sample.
</p>
</li>
<li> <p><code>cutoff_wschisq</code>: a data frame with the indexes up to which the
truncated series explains the tail probability with absolute error
<code>thre</code>, or the proportion of the mean/variance of the whole series
that is <em>not</em> explained by the truncated series.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Eduardo García-Portugués and Paula Navarro-Esteban.
</p>


<h3>References</h3>

<p>Bodenham, D. A. and Adams, N. M. (2016). A comparison of efficient
approximations for a weighted sum of chi-squared random variables.
<em>Statistics and Computing</em>, 26(4):917&ndash;928.
<a href="https://doi.org/10.1007/s11222-015-9583-4">doi:10.1007/s11222-015-9583-4</a>
</p>
<p>Buckley, M. J. and Eagleson, G. K. (1988). An approximation to the
distribution of quadratic forms in normal random variables.
<em>Australian Journal of Statistics</em>, 30(1):150&ndash;159.
<a href="https://doi.org/10.1111/j.1467-842X.1988.tb00471.x">doi:10.1111/j.1467-842X.1988.tb00471.x</a>
</p>
<p>Duchesne, P. and Lafaye De Micheaux, P. (2010) Computing the distribution
of quadratic forms: Further comparisons between the Liu&ndash;Tang&ndash;Zhang
approximation and exact methods. <em>Computational Statistics and Data
Analysis</em>, 54(4):858&ndash;862. <a href="https://doi.org/10.1016/j.csda.2009.11.025">doi:10.1016/j.csda.2009.11.025</a>
</p>
<p>Hall, P. (1983). Chi squared approximations to the distribution of a sum
of independent random variables. <em>Annals of Probability</em>,
11(4):1028&ndash;1036. <a href="https://doi.org/10.1214/aop/1176993451">doi:10.1214/aop/1176993451</a>
</p>
<p>Imhof, J. P. (1961). Computing the distribution of quadratic forms in normal
variables. <em>Biometrika</em>, 48(3/4):419&ndash;426.
<a href="https://doi.org/10.2307/2332763">doi:10.2307/2332763</a>
</p>
<p>Satterthwaite, F. E. (1946). An approximate distribution of estimates of
variance components. <em>Biometrics Bulletin</em>, 2(6):110&ndash;114.
<a href="https://doi.org/10.2307/3002019">doi:10.2307/3002019</a>
</p>
<p>Welch, B. L. (1938). The significance of the difference between two means
when the population variances are unequal. <em>Biometrika</em>,
29(3/4):350&ndash;362. <a href="https://doi.org/10.2307/2332010">doi:10.2307/2332010</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plotting functions for the examples
add_approx_dens &lt;- function(x, dfs, weights, ncps) {

  lines(x, d_wschisq(x, weights = weights, dfs = dfs, ncps = ncps,
                     method = "SW", exact_chisq = FALSE), col = 3)
  lines(x, d_wschisq(x, weights = weights, dfs = dfs, ncps = ncps,
                     method = "HBE", exact_chisq = FALSE), col = 4)
  lines(x, d_wschisq(x, weights = weights, dfs = dfs, ncps = ncps,
                     method = "I", exact_chisq = TRUE), col = 2)
  legend("topright", legend = c("True", "SW", "HBE", "I"), lwd = 2,
         col = c(1, 3:4, 2))

}
add_approx_distr &lt;- function(x, dfs, weights, ncps, ...) {

  lines(x, p_wschisq(x, weights = weights, dfs = dfs, ncps = ncps,
                     method = "SW", exact_chisq = FALSE), col = 3)
  lines(x, p_wschisq(x, weights = weights, dfs = dfs, ncps = ncps,
                     method = "HBE", exact_chisq = FALSE), col = 4)
  lines(x, p_wschisq(x, weights = weights, dfs = dfs, ncps = ncps,
                     method = "MC", exact_chisq = FALSE), col = 5,
                     type = "s")
  lines(x, p_wschisq(x, weights = weights, dfs = dfs, ncps = ncps,
                     method = "I", exact_chisq = TRUE), col = 2)
  legend("bottomright", legend = c("True", "SW", "HBE", "MC", "I"), lwd = 2,
         col = c(1, 3:5, 2))

}
add_approx_quant &lt;- function(u, dfs, weights, ncps, ...) {

  lines(u, q_wschisq(u, weights = weights, dfs = dfs, ncps = ncps,
                     method = "SW", exact_chisq = FALSE), col = 3)
  lines(u, q_wschisq(u, weights = weights, dfs = dfs, ncps = ncps,
                     method = "HBE", exact_chisq = FALSE), col = 4)
  lines(u, q_wschisq(u, weights = weights, dfs = dfs, ncps = ncps,
                     method = "MC", exact_chisq = FALSE), col = 5,
                     type = "s")
  lines(u, q_wschisq(u, weights = weights, dfs = dfs, ncps = ncps,
                     method = "I", exact_chisq = TRUE), col = 2)
  legend("topleft", legend = c("True", "SW", "HBE", "MC", "I"), lwd = 2,
         col = c(1, 3:5, 2))

}

# Validation plots for density, distribution, and quantile functions
u &lt;- seq(0.01, 0.99, l = 100)
old_par &lt;- par(mfrow = c(1, 3))

# Case 1: 1 * ChiSq_3(0) + 1 * ChiSq_3(0) = ChiSq_6(0)
weights &lt;- c(1, 1)
dfs &lt;- c(3, 3)
ncps &lt;- 0
x &lt;- seq(-1, 30, l = 100)
main &lt;- expression(1 * chi[3]^2 * (0) + 1 * chi[3]^2 * (0))
plot(x, dchisq(x, df = 6), type = "l", main = main, ylab = "Density")
add_approx_dens(x = x, weights = weights, dfs = dfs, ncps = ncps)
plot(x, pchisq(x, df = 6), type = "l", main = main, ylab = "Distribution")
add_approx_distr(x = x, weights = weights, dfs = dfs, ncps = ncps)
plot(u, qchisq(u, df = 6), type = "l", main = main, ylab = "Quantile")
add_approx_quant(u = u, weights = weights, dfs = dfs, ncps = ncps)

# Case 2: 2 * ChiSq_3(1) + 1 * ChiSq_6(0.5) + 0.5 * ChiSq_12(0.25)
weights &lt;- c(2, 1, 0.5)
dfs &lt;- c(3, 6, 12)
ncps &lt;- c(1, 0.5, 0.25)
x &lt;- seq(0, 70, l = 100)
main &lt;- expression(2 * chi[3]^2 * (1)+ 1 * chi[6]^2 * (0.5) +
                   0.5 * chi[12]^2 * (0.25))
samp &lt;- r_wschisq(n = 1e4, weights = weights, dfs = dfs, ncps = ncps)
hist(samp, breaks = 50, freq = FALSE, main = main, ylab = "Density",
     xlim = range(x), xlab = "x"); box()
add_approx_dens(x = x, weights = weights, dfs = dfs, ncps = ncps)
plot(x, ecdf(samp)(x), main = main, ylab = "Distribution", type = "s")
add_approx_distr(x = x, weights = weights, dfs = dfs, ncps = ncps)
plot(u, quantile(samp, probs = u), type = "s", main = main,
     ylab = "Quantile")
add_approx_quant(u = u, weights = weights, dfs = dfs, ncps = ncps)

# Case 3: \sum_{k = 1}^K k^(-3) * ChiSq_{5k}(1 / k^2)
K &lt;- 1e2
weights&lt;- 1 / (1:K)^3
dfs &lt;- 5 * 1:K
ncps &lt;- 1 / (1:K)^2
x &lt;- seq(0, 25, l = 100)
main &lt;- substitute(sum(k^(-3) * chi[5 * k]^2 * (1 / k^2), k == 1, K),
                   list(K = K))
samp &lt;- r_wschisq(n = 1e4, weights = weights, dfs = dfs, ncps = ncps)
hist(samp, breaks = 50, freq = FALSE, main = main, ylab = "Density",
     xlim = range(x), xlab = "x"); box()
add_approx_dens(x = x, weights = weights, dfs = dfs, ncps = ncps)
plot(x, ecdf(samp)(x), main = main, ylab = "Distribution", type = "s")
add_approx_distr(x = x, weights = weights, dfs = dfs, ncps = ncps)
plot(u, quantile(samp, probs = u), type = "s", main = main,
     ylab = "Quantile")
add_approx_quant(u = u, weights = weights, dfs = dfs, ncps = ncps)
par(old_par)

# Cutoffs for infinite series of the last example
K &lt;- 1e7
log_weights&lt;- -3 * log(1:K)
log_dfs &lt;- log(5) + log(1:K)
(cutoff &lt;- cutoff_wschisq(thre = 10^(-(1:4)), weights = log_weights,
                          dfs = log_dfs, log = TRUE))

# Approximation
x &lt;- seq(0, 25, l = 100)
l &lt;- length(cutoff$mean)
main &lt;- expression(sum(k^(-3) * chi[5 * k]^2, k == 1, K))
col &lt;- viridisLite::viridis(l)
plot(x, d_wschisq(x, weights = exp(log_weights[1:cutoff$mean[l]]),
                  dfs = exp(log_dfs[1:cutoff$mean[l]])), type = "l",
     ylab = "Density", col = col[l], lwd = 3)
for(i in rev(seq_along(cutoff$mean)[-l])) {
  lines(x, d_wschisq(x, weights = exp(log_weights[1:cutoff$mean[i]]),
                     dfs = exp(log_dfs[1:cutoff$mean[i]])), col = col[i])
}
legend("topright", legend = paste0(rownames(cutoff), " (", cutoff$mean, ")"),
       lwd = 2, col = col)

</code></pre>

<hr>
<h2 id='wschisq_utils'>Utilities for weighted sums of non-central chi squared random
variables</h2><span id='topic+wschisq_utils'></span><span id='topic+r_wschisq_Cpp'></span><span id='topic+p_wschisq_MC'></span>

<h3>Description</h3>

<p>Simulation from a weighted sum of non-central chi squared
random variables and Monte Carlo approximation of its distribution function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_wschisq_Cpp(n, weights, dfs, ncps)

p_wschisq_MC(x, weights = 0L, dfs = 0L, ncps = 0L, M = 10000L,
  sample = 0L, use_sample = FALSE, x_sorted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wschisq_utils_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="wschisq_utils_+3A_weights">weights</code></td>
<td>
<p>vector with the positive weights of the sum. Must have the
same length as <code>dfs</code>.</p>
</td></tr>
<tr><td><code id="wschisq_utils_+3A_dfs">dfs</code></td>
<td>
<p>vector with the positive degrees of freedom of the chi squared
random variables. Must have the same length as <code>weights</code>.</p>
</td></tr>
<tr><td><code id="wschisq_utils_+3A_ncps">ncps</code></td>
<td>
<p>non-negative non-centrality parameters. A vector with the same
length as <code>weights</code>.</p>
</td></tr>
<tr><td><code id="wschisq_utils_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="wschisq_utils_+3A_m">M</code></td>
<td>
<p>number of Monte Carlo samples for approximating the distribution.
Defaults to <code>1e4</code>.</p>
</td></tr>
<tr><td><code id="wschisq_utils_+3A_sample">sample</code></td>
<td>
<p>if <code>use_sample = TRUE</code>, the Monte Carlo sample to
approximate the distribution. If not, it is computed internally. Defaults
to <code>1e4</code>.</p>
</td></tr>
<tr><td><code id="wschisq_utils_+3A_use_sample">use_sample</code></td>
<td>
<p>use the already computed <code>sample</code>? If <code>FALSE</code>
(default), <code>sample</code> is computed internally.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>r_wschisq_Cpp</code>: a matrix of size <code>c(n, 1)</code>
containing a random sample.
</p>
</li>
<li> <p><code>p_wschisq_MC</code>: a matrix of size <code>c(nx, 1)</code>
with the evaluation of the distribution function at <code>x</code>.
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
