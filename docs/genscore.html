<!DOCTYPE html><html lang="en"><head><title>Help for package genscore</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {genscore}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AUC'><p>Calculates the AUC of an ROC curve.</p></a></li>
<li><a href='#avgrocs'><p>Takes the vertical average of ROC curves.</p></a></li>
<li><a href='#beautify_rule'><p>Replaces consecutive &quot;&amp;&quot;s and &quot;|&quot;s in a string to a single &amp; and |.</p></a></li>
<li><a href='#binarySearch_bin'><p>Finds the index of the bin a number belongs to using binary search.</p></a></li>
<li><a href='#calc_crit'><p>Calculates penalized or unpenalized loss in K and eta given arbitrary data</p></a></li>
<li><a href='#check_endpoints'><p>Checks if two equally sized numeric vectors satisfy the requirements for being left and right endpoints of a domain defined as a union of intervals.</p></a></li>
<li><a href='#compare_two_results'><p>Compares two lists returned from estimate().</p></a></li>
<li><a href='#compare_two_sub_results'><p>Compares two lists returned from get_results().</p></a></li>
<li><a href='#cov_cons'><p>Random generator of inverse covariance matrices.</p></a></li>
<li><a href='#crbound_mu'><p>The Cram\'er-Rao lower bound (times <code>n</code>) for estimating the mean parameter from a univariate truncated normal sample with known variance parameter.</p></a></li>
<li><a href='#crbound_sigma'><p>The Cram\'er-Rao lower bound (times <code>n</code>) for estimating the variance parameter from a univariate truncated normal sample with known mean parameter.</p></a></li>
<li><a href='#diff_lists'><p>Computes the sum of absolute differences between two lists.</p></a></li>
<li><a href='#diff_vecs'><p>Computes the sum of absolute differences in the finite non-NA/NULL elements between two vectors.</p></a></li>
<li><a href='#domain_for_C'><p>Returns a list to be passed to C that represents the domain.</p></a></li>
<li><a href='#eBIC'><p>eBIC score with or without refitting.</p></a></li>
<li><a href='#estimate'><p>The main function for the generalized score-matching estimator for graphical models.</p></a></li>
<li><a href='#find_max_ind'><p>Finds the max index in a vector that does not exceed a target number.</p></a></li>
<li><a href='#frac_pow'><p>Evaluate x^(a/b) and |x|^(a/b) with integer a and b with extension to conventional operations.</p></a></li>
<li><a href='#gcd'><p>Finds the greatest (positive) common divisor of two integers.</p></a></li>
<li><a href='#gen'><p>Random data generator from general <code>a</code>-<code>b</code> distributions with general domain types, assuming a and b are rational numbers.</p></a></li>
<li><a href='#get_crit_nopenalty'><p>Minimized loss for unpenalized restricted asymmetric models.</p></a></li>
<li><a href='#get_dist'><p>Finds the distance of each element in a matrix x to the its boundary of the domain while fixing the others in the same row.</p></a></li>
<li><a href='#get_elts'><p>The function wrapper to get the elements necessary for calculations for all settings.</p></a></li>
<li><a href='#get_elts_ab'><p>The R implementation to get the elements necessary for calculations for general a and b.</p></a></li>
<li><a href='#get_elts_exp'><p>The R implementation to get the elements necessary for calculations for the exponential square-root setting (a=0.5, b=0.5).</p></a></li>
<li><a href='#get_elts_gamma'><p>The R implementation to get the elements necessary for calculations for the gamma setting (a=0.5, b=0).</p></a></li>
<li><a href='#get_elts_gauss'><p>The R implementation to get the elements necessary for calculations for the gaussian setting on R^p.</p></a></li>
<li><a href='#get_elts_loglog'><p>The R implementation to get the elements necessary for calculations for the log-log setting (a=0, b=0).</p></a></li>
<li><a href='#get_elts_loglog_simplex'><p>The R implementation to get the elements necessary for calculations for the log-log setting (a=0, b=0) on the p-simplex.</p></a></li>
<li><a href='#get_elts_trun_gauss'><p>The R implementation to get the elements necessary for calculations for the gaussian setting (a=1, b=1) on domains other than R^p.</p></a></li>
<li><a href='#get_g0'><p>Calculates the l2 distance to the boundary of the domain and its gradient for some domains.</p></a></li>
<li><a href='#get_g0_ada'><p>Adaptively truncates the l2 distance to the boundary of the domain and its gradient for some domains.</p></a></li>
<li><a href='#get_h_hp'><p>Generator of h and hp (derivative of h) functions.</p></a></li>
<li><a href='#get_h_hp_adaptive'><p>Generator of adaptive h and hp (derivative of h) functions.</p></a></li>
<li><a href='#get_h_hp_vector'><p>Generator of h and hp (derivative of h) functions.</p></a></li>
<li><a href='#get_postfix_rule'><p>Changes a logical expression in infix notation to postfix notation using the shunting-yard algorithm.</p></a></li>
<li><a href='#get_results'><p>Estimate <code class="reqn">\mathbf{K}</code> and <code class="reqn">\boldsymbol{\eta}</code> using elts from <code>get_elts()</code> given one <code class="reqn">\lambda_{\mathbf{K}}</code> (and <code class="reqn">\lambda_{\boldsymbol{\eta}}</code> if non-profiled non-centered) and applying warm-start with strong screening rules.</p></a></li>
<li><a href='#get_safe_log_h_hp'><p>Asymptotic log of <code>h</code> and <code>hp</code> functions for large <code>x</code> for modes with an unbounded <code>h</code>.</p></a></li>
<li><a href='#get_trun'><p>The truncation point for <code>h</code> for <code>h</code> that is truncated (bounded but not naturally bounded).</p></a></li>
<li><a href='#h_of_dist'><p>Finds the distance of each element in a matrix x to the its boundary of the domain while fixing the others in the same row (dist(x, domain)), and calculates element-wise h(dist(x, domain)) and h\'(dist(x, domain)) (w.r.t. each element in x).</p></a></li>
<li><a href='#in_bound'><p>Returns whether a vector or each row of a matrix falls inside a domain.</p></a></li>
<li><a href='#interval_intersection'><p>Finds the intersection between two unions of intervals.</p></a></li>
<li><a href='#interval_union'><p>Finds the union between two unions of intervals.</p></a></li>
<li><a href='#lambda_max'><p>Analytic solution for the minimum <code class="reqn">\lambda_{\mathbf{K}}</code> that gives the empty graph.</p></a></li>
<li><a href='#make_domain'><p>Creates a list of elements that defines the domain for a multivariate distribution.</p></a></li>
<li><a href='#make_folds'><p>Helper function for making fold IDs for cross validation.</p></a></li>
<li><a href='#makecoprime'><p>Makes two integers coprime.</p></a></li>
<li><a href='#mu_sigmasqhat'><p>Estimates the mu and sigma squared parameters from a univariate truncated normal sample.</p></a></li>
<li><a href='#naiveSearch_bin'><p>Finds the index of the bin a number belongs to using naive search.</p></a></li>
<li><a href='#parse_ab'><p>Parses an ab setting into rational numbers a and b.</p></a></li>
<li><a href='#parse_ineq'><p>Parses an ineq expression into a list of elements that represents the ineq.</p></a></li>
<li><a href='#ran_mat'><p>Random generator of matrices with given eigenvalues.</p></a></li>
<li><a href='#random_init_polynomial'><p>Randomly generate an initial point in the domain defined by a single polynomial with no negative coefficient.</p></a></li>
<li><a href='#random_init_simplex'><p>Generates a random point in the (p-1)-simplex.</p></a></li>
<li><a href='#random_init_uniform'><p>Generates random numbers from a finite union of intervals.</p></a></li>
<li><a href='#read_exponent'><p>Parses the exponent part into power_numer and power_denom.</p></a></li>
<li><a href='#read_exponential'><p>Parses the integer coefficient in an exponential term.</p></a></li>
<li><a href='#read_one_term'><p>Parses the first term of a non-uniform expression.</p></a></li>
<li><a href='#read_uniform_term'><p>Attempts to parse a single term in x into power_numer and power_denom.</p></a></li>
<li><a href='#refit'><p>Loss for a refitted (restricted) unpenalized model</p></a></li>
<li><a href='#rexp_truncated'><p>Generates translated and truncated exponential variables.</p></a></li>
<li><a href='#rlaplace_truncated'><p>Generates laplace variables truncated to a finite union of intervals.</p></a></li>
<li><a href='#rlaplace_truncated_centered'><p>Generates centered laplace variables with scale 1.</p></a></li>
<li><a href='#s_at'><p>Returns the character at a position of a string.</p></a></li>
<li><a href='#s_output'><p>Helper function for outputting if verbose.</p></a></li>
<li><a href='#search_bin'><p>Finds the index of the bin a number belongs to.</p></a></li>
<li><a href='#test_lambda_bounds'><p>Searches for a tight bound for <code class="reqn">\lambda_{\boldsymbol{K}}</code> that gives the empty or complete graph starting from a given lambda with a given step size</p></a></li>
<li><a href='#test_lambda_bounds2'><p>Searches for a tight bound for <code class="reqn">\lambda_{\boldsymbol{K}}</code> that gives the empty or complete graph starting from a given lambda</p></a></li>
<li><a href='#tp_fp'><p>Calculates the true and false positive rates given the estimated and true edges.</p></a></li>
<li><a href='#update_finite_infinity_for_uniform'><p>Maximum between finite_infinity and 10 times the max abs value of finite elements in <code>lefts</code> and <code>rights</code>.</p></a></li>
<li><a href='#varhat'><p>Asymptotic variance (times <code>n</code>) of the estimator for <code>mu</code> or <code>sigmasq</code> for the univariate normal on a general domain assuming the other parameter is known.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized Score Matching Estimators</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Shiqing Yu, Lina Lin, Wally Gilks</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Shiqing Yu &lt;syu.phd@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of the Generalized Score Matching estimator in Yu et al. (2019) <a href="https://jmlr.org/papers/v20/18-278.html">https://jmlr.org/papers/v20/18-278.html</a> for non-negative graphical models (truncated Gaussian, exponential square-root, gamma, a-b models) and univariate truncated Gaussian distributions. Also includes the original estimator for untruncated Gaussian graphical models from Lin et al. (2016) &lt;<a href="https://doi.org/10.1214%2F16-EJS1126">doi:10.1214/16-EJS1126</a>&gt;, with the addition of a diagonal multiplier.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Matrix, igraph, zoo, knitr, rmarkdown, cubature</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rdpack, mvtnorm, tmvtnorm, stringr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/sqyu/genscore">https://github.com/sqyu/genscore</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/sqyu/genscore/issues">https://github.com/sqyu/genscore/issues</a></td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-16 10:12:22 UTC; shimizumasami</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-16 10:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AUC'>Calculates the AUC of an ROC curve.</h2><span id='topic+AUC'></span>

<h3>Description</h3>

<p>Calculates the area under an ROC curve (AUC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AUC(tpfp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AUC_+3A_tpfp">tpfp</code></td>
<td>
<p>A matrix with two columns, the true positive and the false positive rates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number between 0 and 1, the area under the curve (AUC).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 40
p &lt;- 50
mu &lt;- rep(0, p)
tol &lt;- 1e-8
K &lt;- cov_cons(mode="sub", p=p, seed=1, spars=0.2, eig=0.1, subgraphs=10)
true_edges &lt;- which(abs(K) &gt; tol &amp; diag(p) == 0)
dm &lt;- 1 + (1-1/(1+4*exp(1)*max(6*log(p)/n, sqrt(6*log(p)/n))))
set.seed(1)
domain &lt;- make_domain("R+", p=p)
x &lt;- tmvtnorm::rtmvnorm(n, mean = mu, sigma = solve(K),
       lower = rep(0, p), upper = rep(Inf, p), algorithm = "gibbs",
       burn.in.samples = 100, thinning = 10)
est &lt;- estimate(x, setting="gaussian", elts=NULL, domain=domain, centered=TRUE,
         symmetric="symmetric", lambda_length=100, mode="min_pow",
         param1=1, param2=3, diagonal_multiplier=dm)
# Apply tp_fp to each estimated edges set for each lambda
TP_FP &lt;- t(sapply(est$edgess, function(edges){tp_fp(edges, true_edges, p)}))
old.par &lt;- par(mfrow=c(1,1), mar=c(5,5,5,5))
auc &lt;- AUC(TP_FP)
plot(c(), c(),  ylim=c(0,1), xlim=c(0,1), cex.lab=1,
  main=paste("ROC curve, AUC",round(auc,4)), xlab="False Positives",
  ylab="True Positives")
points(TP_FP[,2], TP_FP[,1], type="l")
points(c(0,1), c(0,1), type = "l", lty = 2)
par(old.par)
</code></pre>

<hr>
<h2 id='avgrocs'>Takes the vertical average of ROC curves.</h2><span id='topic+avgrocs'></span>

<h3>Description</h3>

<p>Takes the vertical average of ROC curves using algorithm 3 from Fawcett (2006). The resulting ROC curve preserves the average AUC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avgrocs(rocs, num_true_edges, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="avgrocs_+3A_rocs">rocs</code></td>
<td>
<p>A list of ROC curves, each of which is a matrix with two columns corresponding to the true positive and false positive rates, respectively.</p>
</td></tr>
<tr><td><code id="avgrocs_+3A_num_true_edges">num_true_edges</code></td>
<td>
<p>A positive integer, the number of true edges</p>
</td></tr>
<tr><td><code id="avgrocs_+3A_p">p</code></td>
<td>
<p>A positive integer, the dimension</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The averaged ROC curve, a matrix with 2 columns and <code>(p^2-p-num_true_edges+1)</code> rows.
</p>


<h3>References</h3>

<p>Fawcett T (2006).
&ldquo;An introduction to ROC analysis.&rdquo;
<em>Pattern Recognition Letters</em>, <b>27</b>(8), 861&ndash;874.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 40
p &lt;- 50
mu &lt;- rep(0, p)
tol &lt;- 1e-8
domain &lt;- make_domain("R+", p=p)
K &lt;- cov_cons(mode="sub", p=p, seed=1, spars=0.2, eig=0.1, subgraphs=10)
true_edges &lt;- which(abs(K) &gt; tol &amp; diag(p) == 0)
dm &lt;- 1 + (1-1/(1+4*exp(1)*max(6*log(p)/n, sqrt(6*log(p)/n))))
ROCs &lt;- list()
old.par &lt;- par(mfrow=c(2,2), mar=c(5,5,5,5))
for (i in 1:3){
  set.seed(i)
  x &lt;- tmvtnorm::rtmvnorm(n, mean = mu, sigma = solve(K),
         lower = rep(0, p), upper = rep(Inf, p), algorithm = "gibbs",
         burn.in.samples = 100, thinning = 10)
  est &lt;- estimate(x, setting="gaussian", elts=NULL, domain=domain, centered=TRUE,
           symmetric="symmetric", lambda_length=100, mode="min_pow",
           param1=1, param2=3, diag=dm)
  # Apply tp_fp to each estimated edges set for each lambda
  TP_FP &lt;- t(sapply(est$edgess, function(edges){tp_fp(edges, true_edges, p)}))
  ROCs[[i]] &lt;- TP_FP
  plot(c(), c(),  ylim=c(0,1), xlim=c(0,1), cex.lab=1,
    main=paste("ROC, trial ",i,", AUC ",round(AUC(TP_FP),4),sep=""),
    xlab="False Positives", ylab="True Positives")
  points(TP_FP[,2], TP_FP[,1], type="l")
  points(c(0,1), c(0,1), type = "l", lty = 2)
}
average_ROC &lt;- avgrocs(ROCs, length(true_edges), p)
plot(c(), c(),  ylim=c(0,1), xlim=c(0,1), cex.lab=1,
  main=paste("Average ROC, AUC",round(AUC(average_ROC),4)),
  xlab="False Positives", ylab="True Positives")
points(average_ROC[,2], average_ROC[,1], type="l")
points(c(0,1), c(0,1), type = "l", lty = 2)
par(old.par)
</code></pre>

<hr>
<h2 id='beautify_rule'>Replaces consecutive &quot;&amp;&quot;s and &quot;|&quot;s in a string to a single &amp; and |.</h2><span id='topic+beautify_rule'></span>

<h3>Description</h3>

<p>Replaces consecutive <code>"&amp;"</code>s and <code>"|"</code>s in a string to a single <code>"&amp;"</code> and <code>"|"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beautify_rule(rule)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="beautify_rule_+3A_rule">rule</code></td>
<td>
<p>A string containing positive integers, parentheses, and <code>"&amp;"</code> and <code>"|"</code> only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Applied to <code>domain$rule</code> if <code>domain$type == "polynomial"</code>.
</p>


<h3>Value</h3>

<p>A string with extra <code>"&amp;"</code>s and <code>"|"</code>s removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>beautify_rule("(1 &amp; 2 &amp;&amp; 3 &amp;&amp;&amp; 4) | 5 || 6 ||| 7")
</code></pre>

<hr>
<h2 id='binarySearch_bin'>Finds the index of the bin a number belongs to using binary search.</h2><span id='topic+binarySearch_bin'></span>

<h3>Description</h3>

<p>Finds the index of the bin a number belongs to using binary search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binarySearch_bin(arr, l, r, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binarySearch_bin_+3A_arr">arr</code></td>
<td>
<p>A vector of size at least 2.</p>
</td></tr>
<tr><td><code id="binarySearch_bin_+3A_l">l</code></td>
<td>
<p>An integer between 1 and <code>length(arr)</code>. Must be smaller than <code>1</code>.</p>
</td></tr>
<tr><td><code id="binarySearch_bin_+3A_r">r</code></td>
<td>
<p>An integer between 1 and <code>length(arr)</code>. Must be larger than <code>l</code>.</p>
</td></tr>
<tr><td><code id="binarySearch_bin_+3A_x">x</code></td>
<td>
<p>A number. Must be within the range of [<code>arr[l]</code>, <code>arr[r]</code>].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Finds the smallest index <code>i</code> such that <code>arr[i] &lt;= x &lt;= arr[i+1]</code>.
</p>


<h3>Value</h3>

<p>The index <code>i</code> such that <code>arr[i] &lt;= x &lt;= arr[i+1]</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>binarySearch_bin(1:10, 1, 10, seq(1, 10, by=0.5))
binarySearch_bin(1:10, 5, 8, seq(5, 8, by=0.5))
</code></pre>

<hr>
<h2 id='calc_crit'>Calculates penalized or unpenalized loss in K and eta given arbitrary data</h2><span id='topic+calc_crit'></span>

<h3>Description</h3>

<p>Calculates penalized or unpenalized loss in K and eta given arbitrary data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_crit(elts, res, penalty)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_crit_+3A_elts">elts</code></td>
<td>
<p>An element list returned from <code>get_elts()</code>. Need not be the same as the elements used to estimate <code>res</code>, but they must be both centered or both non-centered, and their dimension <code>p</code> must match. <code>elts</code> cannot be profiled as this is supposed to be elements for a new data unseen by <code>res</code>, in which case the loss must be explicitly written in <code>K</code> and <code>eta</code> with <code>Gamma</code> and <code>g</code> from a new dataset <code>x</code>.</p>
</td></tr>
<tr><td><code id="calc_crit_+3A_res">res</code></td>
<td>
<p>A result list returned from <code>get_results()</code>. Must be centered if <code>elts</code> is centered, and must be non-centered otherwise. Can be profiled. <code>res$p</code> must be equal to <code>elts$p</code>.</p>
</td></tr>
<tr><td><code id="calc_crit_+3A_penalty">penalty</code></td>
<td>
<p>A boolean, indicates whether the loss should be penalized (using <code>elts$diagonals_with_multiplier</code>, <code>res$lambda1</code> and <code>res$lambda2</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the loss in some estimated <code>K</code> and <code>eta</code> given an <code>elts</code> generated using <code>get_elts()</code> with a new dataset <code>x</code>. This is helpful for cross-validation.
</p>


<h3>Value</h3>

<p>A number, the loss.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In the following examples, all printed numbers should be close to 0.
# In practice, \code{res} need not be estimates fit to \code{elts},
# but in the examples we use \code{res &lt;- get_results(elts)} just to
# demonstrate that the loss this function returns matches that returned
# by the C code during estimation using \code{get_results}.

n &lt;- 6
p &lt;- 3
eta &lt;- rep(0, p)
K &lt;- diag(p)
dm &lt;- 1 + (1-1/(1+4*exp(1)*max(6*log(p)/n, sqrt(6*log(p)/n))))

domains &lt;- list(make_domain("R", p=p),
                make_domain("R+", p=p),
                make_domain("uniform", p=p, lefts=c(0,2), rights=c(1,3)),
                make_domain("polynomial", p=p,
                  ineqs=list(list("expression"="sum(x^2)&lt;=1", nonnegative=FALSE, abs=FALSE))))

domains &lt;- c(domains,
             list(make_domain("polynomial", p=p,
                    ineqs=list(list("expression"="sum(x^2)&lt;=1", nonnegative=TRUE, abs=FALSE))),
                  make_domain("polynomial", p=p,
                    ineqs=list(list("expression"=paste(paste(sapply(1:p,
                      function(j){paste(j, "x", j, sep="")}), collapse="+"), "&lt;1"),
                      abs=FALSE, nonnegative=TRUE))),
                  make_domain("simplex", p=p)))

for (domain in domains) {
  if (domain$type == "R" ||
       (domain$type == "uniform" &amp;&amp; any(domain$lefts &lt; 0)) ||
       (domain$type == "polynomial" &amp;&amp; !domain$ineqs[[1]]$nonnegative))
    settings &lt;- c("gaussian")
  else if (domain$type == "simplex")
    settings &lt;- c("log_log", "log_log_sum0")
  else
    settings &lt;- c("gaussian", "exp", "gamma", "log_log", "ab_3/4_2/3")

  if (domain$type == "simplex")
    symms &lt;- c("symmetric")
  else
    symms &lt;- c("symmetric", "and", "or")

  for (setting in settings) {
    x &lt;- gen(n, setting=setting, abs=FALSE, eta=eta, K=K, domain=domain,
         finite_infinity=100, xinit=NULL, burn_in=1000, thinning=100, verbose=FALSE)
    h_hp &lt;- get_h_hp("min_pow", 1, 3)

    for (symm in symms) {

       # Centered, penalized loss
       elts &lt;- get_elts(h_hp, x, setting, domain, centered=TRUE, scale="", diag=dm)
       res &lt;- get_results(elts, symm, 0.1)
       print(calc_crit(elts, res, penalty=TRUE) - res$crit) # Close to 0

       # Non-centered, unpenalized loss
       elts_nopen &lt;- get_elts(h_hp, x, setting, domain, centered=TRUE, scale="", diag=1)
       res_nopen &lt;- get_results(elts_nopen, symm, 0)
       print(calc_crit(elts_nopen, res_nopen, penalty=FALSE) - res_nopen$crit) # Close to 0

       # Non-centered, non-profiled, penalized loss
       elts_nc_np &lt;- get_elts(h_hp, x, setting, domain, centered=FALSE,
         profiled_if_noncenter=FALSE, scale="", diag=dm)
       res_nc_np &lt;- get_results(elts_nc_np, symm, lambda1=0.1, lambda2=0.05)
       print(calc_crit(elts_nc_np, res_nc_np, penalty=TRUE) - res_nc_np$crit) # Close to 0

       # Non-centered, non-profiled, unpenalized loss
       elts_nc_np_nopen &lt;- get_elts(h_hp, x, setting, domain, centered=FALSE,
         profiled_if_noncenter=FALSE, scale="", diag=1)
       res_nc_np_nopen &lt;- get_results(elts_nc_np_nopen, symm, lambda1=0, lambda2=0)
       print(calc_crit(elts_nc_np_nopen, res_nc_np_nopen, penalty=FALSE) -
         res_nc_np_nopen$crit) # Close to 0

       if (domain$type != "simplex") {
         # Non-centered, profiled, penalized loss
         elts_nc_p &lt;- get_elts(h_hp, x, setting, domain, centered=FALSE,
           profiled_if_noncenter=TRUE, scale="", diag=dm)
         res_nc_p &lt;- get_results(elts_nc_p, symm, lambda1=0.1)
         if (elts_nc_np$setting != setting || elts_nc_np$domain_type != "R")
           res_nc_p$crit &lt;- res_nc_p$crit - sum(elts_nc_np$g_eta ^ 2 / elts_nc_np$Gamma_eta) / 2
         print(calc_crit(elts_nc_np, res_nc_p, penalty=TRUE) - res_nc_p$crit)  # Close to 0
         # Note that the elts argument cannot be profiled, so
         # calc_crit(elts_nc_p, res_nc_p, penalty=TRUE) is not allowed

         # Non-centered, profiled, unpenalized loss
         elts_nc_p_nopen &lt;- get_elts(h_hp, x, setting, domain, centered=FALSE,
           profiled_if_noncenter=TRUE, scale="", diag=1)
         res_nc_p_nopen &lt;- get_results(elts_nc_p_nopen, symm, lambda1=0)
         if (elts_nc_np_nopen$setting != setting || elts_nc_np_nopen$domain_type != "R")
           res_nc_p_nopen$crit &lt;- (res_nc_p_nopen$crit -
              sum(elts_nc_np_nopen$g_eta ^ 2 / elts_nc_np_nopen$Gamma_eta) / 2)
         print(calc_crit(elts_nc_np_nopen, res_nc_p_nopen, penalty=TRUE) -
           res_nc_p_nopen$crit) # Close to 0
          # Again, calc_crit(elts_nc_p_nopen, res_nc_p, penalty=TRUE) is not allowed
       } # if domain$type != "simplex"

    } # for symm in symms
  } # for setting in settings
} # for domain in domains
</code></pre>

<hr>
<h2 id='check_endpoints'>Checks if two equally sized numeric vectors satisfy the requirements for being left and right endpoints of a domain defined as a union of intervals.</h2><span id='topic+check_endpoints'></span>

<h3>Description</h3>

<p>Checks if two equally sized numeric vectors satisfy the requirements for being left and right endpoints of a domain defined as a union of intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_endpoints(lefts, rights)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_endpoints_+3A_lefts">lefts</code></td>
<td>
<p>A non-empty vector of numbers (may contain <code>-Inf</code>), the left endpoints of a domain defined as a union of intervals.</p>
</td></tr>
<tr><td><code id="check_endpoints_+3A_rights">rights</code></td>
<td>
<p>A non-empty vector of numbers (may contain <code>Inf</code>), the right endpoints of a domain defined as a union of intervals. Must have the same size as <code>lefts</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both <code>lefts</code> and <code>rights</code> must be non-empty and should have the same length.
Suppose <code>lefts</code> and <code>rights</code> both have length l, [lefts[1], rights[1]], ..., [lefts[l], rights[l]] must be an increasing and non-overlapping set of valid intervals, meaning lefts[i] &lt;= rights[i] &lt;= lefts[j] for any i &lt; j (singletons and overlapping at the boundary points are allowed).
<code>Inf</code> is not allowed in <code>lefts</code> and <code>-Inf</code> is not allowed in <code>rights</code>.
</p>


<h3>Value</h3>

<p><code>NULL</code>. Program stops if <code>lefts</code> and <code>rights</code> do not define valid left and right endpoints.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## [-4,-3], [-2,-1], [0,1], [2,3], [4,5]
check_endpoints(lefts=c(-4,-2,0,2,4), rights=c(-3,-1,1,3,5))
## Not run: 
check_endpoints(lefts=c(), rights=c()) # Cannot be empty
check_endpoints(lefts=c(-4,-2,0,2,4), rights=c(-3,-1,1,3)) # Unequal length
check_endpoints(lefts=c(Inf), rights=c(Inf)) # No Inf in lefts, otherwise invalid interval
check_endpoints(lefts=c(-Inf), rights=c(-Inf)) # No -Inf in rights, otherwise invalid interval
check_endpoints(lefts=c(0, 1), rights=c(2, 3)) # [0,2] and [1,3] overlap, not allowed
check_endpoints(lefts=c(2, 0), rights=c(3, 1)) # [2,3], [0,1] not increasing, not allowed

## End(Not run)
## Singletons and overlapping at the boundary points allowed
check_endpoints(lefts=c(0, 1, 2), rights=c(0, 2, 3))
</code></pre>

<hr>
<h2 id='compare_two_results'>Compares two lists returned from estimate().</h2><span id='topic+compare_two_results'></span>

<h3>Description</h3>

<p>Compares two lists returned from <code>estimate</code>().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_two_results(res, res2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_two_results_+3A_res">res</code></td>
<td>
<p>A res list returned from <code>estimate()</code>.</p>
</td></tr>
<tr><td><code id="compare_two_results_+3A_res2">res2</code></td>
<td>
<p>A res list returned from <code>estimate()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of numbers all of which should be close to 0 if <code>res</code> and <code>res2</code> are expected to be the same.
</p>

<hr>
<h2 id='compare_two_sub_results'>Compares two lists returned from get_results().</h2><span id='topic+compare_two_sub_results'></span>

<h3>Description</h3>

<p>Compares two lists returned from <code>get_results()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_two_sub_results(res, res2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_two_sub_results_+3A_res">res</code></td>
<td>
<p>A res list returned from <code>get_results()</code>.</p>
</td></tr>
<tr><td><code id="compare_two_sub_results_+3A_res2">res2</code></td>
<td>
<p>A res list returned from <code>get_results()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of numbers all of which should be close to 0 if <code>res</code> and <code>res2</code> are expected to be the same.
</p>

<hr>
<h2 id='cov_cons'>Random generator of inverse covariance matrices.</h2><span id='topic+cov_cons'></span>

<h3>Description</h3>

<p>Random generator of inverse covariance matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_cons(mode, p, seed = NULL, spars = 1, eig = 0.1, subgraphs = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cov_cons_+3A_mode">mode</code></td>
<td>
<p>A string, see details.</p>
</td></tr>
<tr><td><code id="cov_cons_+3A_p">p</code></td>
<td>
<p>A positive integer &gt;= 2, the dimension.</p>
</td></tr>
<tr><td><code id="cov_cons_+3A_seed">seed</code></td>
<td>
<p>A number, the seed for the generator. Ignored if <code>NULL</code> or <code>mode == "band"</code> or <code>mode == "chain"</code>.</p>
</td></tr>
<tr><td><code id="cov_cons_+3A_spars">spars</code></td>
<td>
<p>A number, see details. Ignored if <code>mode == "chain"</code>. Default to 1.</p>
</td></tr>
<tr><td><code id="cov_cons_+3A_eig">eig</code></td>
<td>
<p>A positive number, the minimum eigenvalue of the returned matrix. Default to 0.1.</p>
</td></tr>
<tr><td><code id="cov_cons_+3A_subgraphs">subgraphs</code></td>
<td>
<p>A positive integer, the number of subgraphs for the <code>"sub"</code> mode. Note that <code>p</code> must be divisible by <code>subgraphs</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<p>The function generates an inverse covariance matrix according to the <code>mode</code> argument as follows. The diagonal entries of the matrix are set to the same value such that the minimum eigenvalue of the returned matrix is equal to <code>eig</code>.
</p>
<dl>
<dt>&quot;random&quot;</dt><dd><p>Takes the <code>Q</code> matrix from the <code>QR</code> decomposition of a <code>p</code> by <code>p</code> random matrix with independent <code class="reqn">Normal(0,1)</code> entries, and calculates <code class="reqn">Q' diag(ev) Q</code>. Randomly zeros out its upper triangular entries using independent uniform Bernoulli(<code>spars</code>) variables, and then symmetrizes the matrix using the upper triangular part.</p>
</dd>
<dt>&quot;sub&quot;</dt><dd><p>Constructs a block diagonal matrix with <code>subgraphs</code> disconnected subgraphs with equal number of nodes. In each subgraph, takes each entry independently from <code class="reqn">Uniform(0.5,1)</code>, and randomly zeros out its upper triangular entries using independent uniform Bernoulli(<code>spars</code>) variables, and finally symmetrizes the matrix using the upper triangular part. The construction from Section 4.2 of Lin et al. (2016).</p>
</dd>
<dt>&quot;er&quot;</dt><dd><p>Constructs an Erd\H{o}s-R\'enyi game with probability <code>spars</code>, and sets the edges to independent <code class="reqn">Uniform(0.5,1)</code> variables, and finally symmetrizes the matrix using the lower triangular entries.</p>
</dd>
<dt>&quot;band&quot;</dt><dd><p>Constructs a banded matrix so that the <code>(i,j)</code>-th matrix is nonzero if and only if <code class="reqn">|i-j|&lt;=spars</code>, and is equal to <code class="reqn">1-|i-j|/(spars+1)</code> if <code class="reqn">i!=j</code>.</p>
</dd>
<dt>&quot;chain&quot;</dt><dd><p>A chain graph, where the <code>(i,j)</code>-th matrix is nonzero if and only if <code class="reqn">|i-j|&lt;=1</code>, and is equal to 0.5 if <code class="reqn">|i-j|==1</code>. A special case of the <code>"band"</code> construction with <code>spars</code> equal to 1.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A <code>p</code> by <code>p</code> inverse covariance matrix. See details.
</p>


<h3>References</h3>

<p>Lin L, Drton M, Shojaie A (2016).
&ldquo;Estimation of high-dimensional graphical models using regularized score matching.&rdquo;
<em>Electron. J. Stat.</em>, <b>10</b>(1), 806&ndash;854.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 100
K1 &lt;- cov_cons("random", p, seed = 1, spars = 0.05, eig = 0.1)
K2 &lt;- cov_cons("sub", p, seed = 2, spars = 0.5, eig = 0.1, subgraphs=10)
K3 &lt;- cov_cons("er", p, seed = 3, spars = 0.05, eig = 0.1)
K4 &lt;- cov_cons("band", p, spars = 2, eig = 0.1)
K5 &lt;- cov_cons("chain", p, eig = 0.1)
</code></pre>

<hr>
<h2 id='crbound_mu'>The Cram\'er-Rao lower bound (times <code>n</code>) for estimating the mean parameter from a univariate truncated normal sample with known variance parameter.</h2><span id='topic+crbound_mu'></span>

<h3>Description</h3>

<p>The Cram\'er-Rao lower bound (times <code>n</code>) on the variance for estimating the mean parameter <code>mu</code> from a univariate truncated normal sample, assuming the true variance parameter <code>sigmasq</code> is known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crbound_mu(mu, sigmasq)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crbound_mu_+3A_mu">mu</code></td>
<td>
<p>The mean parameter.</p>
</td></tr>
<tr><td><code id="crbound_mu_+3A_sigmasq">sigmasq</code></td>
<td>
<p>The variance parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Cram\'er-Rao lower bound in this case is defined as <code class="reqn">\sigma^4/var(X-\mu)</code>.
</p>


<h3>Value</h3>

<p>A number, the Cram\'er-Rao lower bound.
</p>

<hr>
<h2 id='crbound_sigma'>The Cram\'er-Rao lower bound (times <code>n</code>) for estimating the variance parameter from a univariate truncated normal sample with known mean parameter.</h2><span id='topic+crbound_sigma'></span>

<h3>Description</h3>

<p>The Cram\'er-Rao lower bound (times <code>n</code>) on the variance for estimating the variance parameter <code>sigmasq</code> from a univariate truncated normal sample, assuming the true mean parameter <code>mu</code> is known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crbound_sigma(mu, sigmasq)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crbound_sigma_+3A_mu">mu</code></td>
<td>
<p>The mean parameter.</p>
</td></tr>
<tr><td><code id="crbound_sigma_+3A_sigmasq">sigmasq</code></td>
<td>
<p>The variance parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Cram\'er-Rao lower bound in this case is defined as <code class="reqn">4\sigma^8/var((X-\mu)^2)</code>.
</p>


<h3>Value</h3>

<p>A number, the Cram\'er-Rao lower bound .
</p>

<hr>
<h2 id='diff_lists'>Computes the sum of absolute differences between two lists.</h2><span id='topic+diff_lists'></span>

<h3>Description</h3>

<p>Computes the sum of absolute differences between two lists using diff_vecs().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_lists(l1, l2, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diff_lists_+3A_l1">l1</code></td>
<td>
<p>A list.</p>
</td></tr>
<tr><td><code id="diff_lists_+3A_l2">l2</code></td>
<td>
<p>A list.</p>
</td></tr>
<tr><td><code id="diff_lists_+3A_name">name</code></td>
<td>
<p>A string, default to <code>NULL</code>. If not <code>NULL</code>, computes the differences in the <code>l1[[name]]</code> and <code>l2[[name]]</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the sum of absolute differences between <code>l1</code> and <code>l2</code> if <code>name</code> is <code>NULL</code>, or that between <code>l1[[name]]</code> and <code>l2[[name]]</code> otherwise. If <code>name</code> is not <code>NULL</code> and if <code>name</code> is in exactly one of <code>l1</code> and <code>l2</code>, returns <code>Inf</code>; if <code>name</code> is in neither, returns <code>NA</code>. Exception: Returns a positive integer if the two elements compared hold <code>NA</code>, <code>NULL</code> or <code>Inf</code> values in different places.
</p>

<hr>
<h2 id='diff_vecs'>Computes the sum of absolute differences in the finite non-NA/NULL elements between two vectors.</h2><span id='topic+diff_vecs'></span>

<h3>Description</h3>

<p>Computes the sum of absolute differences in the finite non-<code>NA</code>/<code>NULL</code> elements between two vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_vecs(l1, l2, relative = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diff_vecs_+3A_l1">l1</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="diff_vecs_+3A_l2">l2</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="diff_vecs_+3A_relative">relative</code></td>
<td>
<p>A boolean, default to <code>FALSE</code>. If <code>TRUE</code>, returns the relative difference (sum of absolute differences divided by the elementwise minimum between <code>l1</code> and <code>l2</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sum of (relative) absolute differences in <code>l1</code> and <code>l2</code>, or a positive integer if two vectors differ in length or hold <code>NA</code>, <code>NULL</code> or <code>Inf</code> values in different places.
</p>

<hr>
<h2 id='domain_for_C'>Returns a list to be passed to C that represents the domain.</h2><span id='topic+domain_for_C'></span>

<h3>Description</h3>

<p>Returns a list to be passed to C that represents the domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>domain_for_C(domain)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="domain_for_C_+3A_domain">domain</code></td>
<td>
<p>A list returned from <code>make_domain()</code> that represents the domain.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Construct a list to be read by C code that represents the domain.
</p>


<h3>Value</h3>

<p>A list of the following elements.
</p>
<table role = "presentation">
<tr><td><code>num_char_params</code></td>
<td>
<p>An integer, length of <code>char_params</code>.</p>
</td></tr>
<tr><td><code>char_params</code></td>
<td>
<p>A vector of string (<code>char *</code> or <code>char **</code>) parameters.</p>
</td></tr>
<tr><td><code>num_int_params</code></td>
<td>
<p>An integer, length of <code>int_params</code>.</p>
</td></tr>
<tr><td><code>int_params</code></td>
<td>
<p>A vector of integer (<code>int</code>) parameters.</p>
</td></tr>
<tr><td><code>num_double_params</code></td>
<td>
<p>An integer, length of <code>double_params</code>.</p>
</td></tr>
<tr><td><code>double_params</code></td>
<td>
<p>A vector of double (<code>double</code>) parameters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 30
# The 30-dimensional real space R^30
domain &lt;- make_domain("R", p=p)
domain_for_C(domain)

# The non-negative orthant of the 30-dimensional real space, R+^30
domain &lt;- make_domain("R+", p=p)
domain_for_C(domain)

# x such that sum(x^2) &gt; 10 &amp;&amp; sum(x^(1/3)) &gt; 10 with x allowed to be negative
domain &lt;- make_domain("polynomial", p=p, rule="1 &amp;&amp; 2",
       ineqs=list(list("expression"="sum(x^2)&gt;10", abs=FALSE, nonnegative=FALSE),
                      list("expression"="sum(x^(1/3))&gt;10", abs=FALSE, nonnegative=FALSE)))
domain_for_C(domain)

# ([0, 1] v [2,3]) ^ p
domain &lt;- make_domain("uniform", p=p, lefts=c(0,2), rights=c(1,3))
domain_for_C(domain)

# x such that {x1 &gt; 1 &amp;&amp; log(1.3) &lt; x2 &lt; 1 &amp;&amp; x3 &gt; log(1.3) &amp;&amp; ... &amp;&amp; xp &gt; log(1.3)}
domain &lt;- make_domain("polynomial", p=p, rule="1 &amp;&amp; 2 &amp;&amp; 3",
       ineqs=list(list("expression"="x1&gt;1", abs=FALSE, nonnegative=TRUE),
                      list("expression"="x2&lt;1", abs=FALSE, nonnegative=TRUE),
                      list("expression"="exp(x)&gt;1.3", abs=FALSE, nonnegative=FALSE)))
domain_for_C(domain)

# x in R_+^p such that {sum(log(x))&lt;2 || (x1^(2/3)-1.3x2^(-3)&lt;1 &amp;&amp; exp(x1)+2.3*x2&gt;2)}
domain &lt;- make_domain("polynomial", p=p, rule="1 || (2 &amp;&amp; 3)",
       ineqs=list(list("expression"="sum(log(x))&lt;2", abs=FALSE, nonnegative=TRUE),
                      list("expression"="x1^(2/3)-1.3x2^(-3)&lt;1", abs=FALSE, nonnegative=TRUE),
                      list("expression"="exp(x1)+2.3*x2^2&gt;2", abs=FALSE, nonnegative=TRUE)))
domain_for_C(domain)

# x in R_+^p such that {x in R_+^p: sum_j j * xj &lt;= 1}
domain &lt;- make_domain("polynomial", p=p,
       ineqs=list(list("expression"=paste(paste(sapply(1:p,
                           function(j){paste(j, "x", j, sep="")}), collapse="+"), "&lt;1"),
                     abs=FALSE, nonnegative=TRUE)))
domain_for_C(domain)

# The (p-1)-simplex
domain &lt;- make_domain("simplex", p=p)
domain_for_C(domain)

# The l-1 ball {sum(|x|) &lt; 1}
domain &lt;- make_domain("polynomial", p=p,
       ineqs=list(list("expression"="sum(x)&lt;1", abs=TRUE, nonnegative=FALSE)))
domain_for_C(domain)
</code></pre>

<hr>
<h2 id='eBIC'>eBIC score with or without refitting.</h2><span id='topic+eBIC'></span>

<h3>Description</h3>

<p>Calculates the eBIC score both with and without refitting an unpenalized model restricted to the estimated support.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eBIC(res, elts, BIC_refit = TRUE, gammas = c(0, 0.5, 1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eBIC_+3A_res">res</code></td>
<td>
<p>A list of results returned by get_results().</p>
</td></tr>
<tr><td><code id="eBIC_+3A_elts">elts</code></td>
<td>
<p>A list, elements necessary for calculations returned by get_elts().</p>
</td></tr>
<tr><td><code id="eBIC_+3A_bic_refit">BIC_refit</code></td>
<td>
<p>A boolean, whether to get the BIC scores by refitting an unpenalized model restricted to the estimated edges, with <code>lambda1=0</code>, <code>lambda2=0</code> and <code>diagonal_multiplier=1</code>. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="eBIC_+3A_gammas">gammas</code></td>
<td>
<p>Optional. A number of a vector of numbers. The <code class="reqn">\gamma</code> parameter in eBIC. Default to <code>c(0,0.5,1)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>2*length(gammas)</code>. The first <code>length(gammas)</code> numbers are the eBIC scores without refitting for each <code>gamma</code> value, and the rest are those with refitting if <code>BIC_refit == TRUE</code>, or <code>Inf</code> if <code>BIC_refit == FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Examples are shown for Gaussian truncated to R+^p only. For other distributions
#   on other types of domains, please refer to \code{gen()} or \code{get_elts()},
#   as the way to call this function (\code{eBIC()}) is exactly the same in those cases.
n &lt;- 50
p &lt;- 30
domain &lt;- make_domain("R+", p=p)
h_hp &lt;- get_h_hp("min_pow", 1, 3)
mu &lt;- rep(0, p)
K &lt;- diag(p)
dm &lt;- 1 + (1-1/(1+4*exp(1)*max(6*log(p)/n, sqrt(6*log(p)/n))))
x &lt;- tmvtnorm::rtmvnorm(n, mean = mu, sigma = solve(K),
       lower = rep(0, p), upper = rep(Inf, p), algorithm = "gibbs",
       burn.in.samples = 100, thinning = 10)

elts_gauss_np &lt;- get_elts(h_hp, x, setting="gaussian", domain=domain,
                centered=FALSE, profiled=FALSE, diag=dm)
res_nc_np &lt;- get_results(elts_gauss_np, symmetric="symmetric",
               lambda1=0.35, lambda2=2, previous_res=NULL,
               is_refit=FALSE)
eBIC(res_nc_np, elts_gauss_np, BIC_refit=TRUE, gammas=c(0,0.5,1))
</code></pre>

<hr>
<h2 id='estimate'>The main function for the generalized score-matching estimator for graphical models.</h2><span id='topic+estimate'></span>

<h3>Description</h3>

<p>The main function for the generalized score-matching estimator for graphical models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate(
  x,
  setting,
  domain,
  elts = NULL,
  centered = TRUE,
  symmetric = "symmetric",
  scale = "",
  lambda1s = NULL,
  lambda_length = NULL,
  lambda_ratio = Inf,
  mode = NULL,
  param1 = NULL,
  param2 = NULL,
  h_hp = NULL,
  unif_dist = NULL,
  verbose = TRUE,
  verbosetext = "",
  tol = 1e-06,
  maxit = 1000,
  BIC_refit = TRUE,
  warmstart = TRUE,
  diagonal_multiplier = NULL,
  eBIC_gammas = c(0, 0.5, 1),
  cv_fold = NULL,
  cv_fold_seed = NULL,
  return_raw = FALSE,
  return_elts = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_+3A_x">x</code></td>
<td>
<p>An <code>n</code> by <code>p</code> matrix, the data matrix, where <code>n</code> is the sample size and <code>p</code> the dimension.</p>
</td></tr>
<tr><td><code id="estimate_+3A_setting">setting</code></td>
<td>
<p>A string that indicates the distribution type, must be one of <code>"exp"</code>, <code>"gamma"</code>, <code>"gaussian"</code>, <code>"log_log"</code>, <code>"log_log_sum0"</code>, or of the form <code>"ab_NUM1_NUM2"</code>, where <code>NUM1</code> is the <code>a</code> value and <code>NUM2</code> is the <code>b</code> value, and <code>NUM1</code> and <code>NUM2</code> must be integers or two integers separated by &quot;/&quot;, e.g. &quot;ab_2_2&quot;, &quot;ab_2_5/4&quot; or &quot;ab_2/3_1/2&quot;.</p>
</td></tr>
<tr><td><code id="estimate_+3A_domain">domain</code></td>
<td>
<p>A list returned from <code>make_domain()</code> that represents the domain.</p>
</td></tr>
<tr><td><code id="estimate_+3A_elts">elts</code></td>
<td>
<p>A list (optional), elements necessary for calculations returned by get_elts().</p>
</td></tr>
<tr><td><code id="estimate_+3A_centered">centered</code></td>
<td>
<p>A boolean, whether in the centered setting (assume <code class="reqn">\boldsymbol{\mu}=\boldsymbol{\eta}=0</code>) or not. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="estimate_+3A_symmetric">symmetric</code></td>
<td>
<p>A string. If equals <code>"symmetric"</code>, estimates the minimizer <code class="reqn">\mathbf{K}</code> over all symmetric matrices; if <code>"and"</code> or <code>"or"</code>, use the &quot;and&quot;/&quot;or&quot; rule to get the support. Default to <code>"symmetric"</code>.</p>
</td></tr>
<tr><td><code id="estimate_+3A_scale">scale</code></td>
<td>
<p>A string indicating the scaling method. If contains <code>"sd"</code>, columns are scaled by standard deviation; if contains <code>"norm"</code>, columns are scaled by l2 norm; if contains <code>"center"</code> and <code>setting == "gaussian" &amp;&amp; domain$type == "R"</code>, columns are centered to have mean zero. Default to <code>"norm"</code>.</p>
</td></tr>
<tr><td><code id="estimate_+3A_lambda1s">lambda1s</code></td>
<td>
<p>A vector of lambdas, the penalty parameter for K.</p>
</td></tr>
<tr><td><code id="estimate_+3A_lambda_length">lambda_length</code></td>
<td>
<p>An integer &gt;= 2, the number of lambda1s. Ignored if <code>lambda1s</code> is provided, otherwise a grid of lambdas is automatically chosen so that the results range from an empty graph to a complete graph. Default to <code>10</code> if neither <code>lambda1s</code> nor <code>lambda_length</code> is provided.</p>
</td></tr>
<tr><td><code id="estimate_+3A_lambda_ratio">lambda_ratio</code></td>
<td>
<p>A positive number, the fixed ratio between <code class="reqn">\lambda_{\mathbf{K}}</code> and <code class="reqn">\lambda_{\boldsymbol{\eta}}</code>, if <code class="reqn">\lambda_{\boldsymbol{\eta}}\neq 0</code> (non-profiled) in the non-centered setting.</p>
</td></tr>
<tr><td><code id="estimate_+3A_mode">mode</code></td>
<td>
<p>A string, the class of the <code>h</code> function. Ignored if <code>elts</code>, or <code>h</code> and <code>hp</code> are provided, or if <code>setting == "gaussian" &amp;&amp; domain$type == "R"</code>.</p>
</td></tr>
<tr><td><code id="estimate_+3A_param1">param1</code></td>
<td>
<p>A number, the first parameter to the <code>h</code> function. Ignored if <code>elts</code>, or <code>h</code> and <code>hp</code> are provided, or if <code>setting == "gaussian" &amp;&amp; domain$type == "R"</code>.</p>
</td></tr>
<tr><td><code id="estimate_+3A_param2">param2</code></td>
<td>
<p>A number, the second parameter (may be optional depending on <code>mode</code>) to the <code>h</code> function. Ignored if <code>elts</code>, or <code>h</code> and <code>hp</code> are provided, or if <code>setting == "gaussian" &amp;&amp; domain$type == "R"</code>.</p>
</td></tr>
<tr><td><code id="estimate_+3A_h_hp">h_hp</code></td>
<td>
<p>A function that returns a list containing <code>hx=h(x)</code> (element-wise) and <code>hpx=hp(x)</code> (element-wise derivative of <code class="reqn">h</code>) when applied to a vector or a matrix <code>x</code>, both of which has the same shape as <code>x</code>.</p>
</td></tr>
<tr><td><code id="estimate_+3A_unif_dist">unif_dist</code></td>
<td>
<p>Optional, defaults to <code>NULL</code>. If not <code>NULL</code>, <code>h_hp</code> must be <code>NULL</code> and <code>unif_dist(x)</code> must return a list containing <code>"g0"</code> of length <code>nrow(x)</code> and <code>"g0d"</code> of dimension <code>dim(x)</code>, representing the l2 distance and the gradient of the l2 distance to the boundary: the true l2 distance function to the boundary is used for all coordinates in place of h_of_dist; see &quot;Estimating Density Models with Complex Truncation Boundaries&quot; by Liu et al, 2019. That is, <code class="reqn">(h_j\circ \phi_j)(x_i)</code> in the score-matching loss is replaced by <code class="reqn">g_0(x_i)</code>, the l2 distance of xi to the boundary of the domain.</p>
</td></tr>
<tr><td><code id="estimate_+3A_verbose">verbose</code></td>
<td>
<p>Optional. A boolean, whether to output intermediate results.</p>
</td></tr>
<tr><td><code id="estimate_+3A_verbosetext">verbosetext</code></td>
<td>
<p>Optional. A string, text to be added to the end of each printout if <code>verbose == TRUE</code>.</p>
</td></tr>
<tr><td><code id="estimate_+3A_tol">tol</code></td>
<td>
<p>Optional. A number, the tolerance parameter. Default to <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="estimate_+3A_maxit">maxit</code></td>
<td>
<p>Optional. A positive integer, the maximum number of iterations for each fit. Default to <code>1000</code>.</p>
</td></tr>
<tr><td><code id="estimate_+3A_bic_refit">BIC_refit</code></td>
<td>
<p>A boolean, whether to get the BIC scores by refitting an unpenalized model restricted to the estimated edges, with <code>lambda1=lambda2=0</code> and <code>diagonal_multiplier=1</code>. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="estimate_+3A_warmstart">warmstart</code></td>
<td>
<p>Optional. A boolean, whether to use the results from a previous (larger) lambda as a warm start for each new lambda. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="estimate_+3A_diagonal_multiplier">diagonal_multiplier</code></td>
<td>
<p>A number &gt;= 1, the diagonal multiplier. Optional and ignored if elts is provided. If <code>ncol(x) &gt; ncol(n)</code>, a value strictly larger than 1 is recommended. Default to <code class="reqn">1+\left(1-\left(1+4e\max\left(6\log p/n, \sqrt{6\log p/n}\right)\right)^{-1}\right)</code>.</p>
</td></tr>
<tr><td><code id="estimate_+3A_ebic_gammas">eBIC_gammas</code></td>
<td>
<p>Optional. A number of a vector of numbers. The <code class="reqn">\gamma</code> parameter in eBIC. Default to <code>c(0,0.5,1)</code>.</p>
</td></tr>
<tr><td><code id="estimate_+3A_cv_fold">cv_fold</code></td>
<td>
<p>Optional. An integer larger than 1 if provided. The number of folds used for cross validation. If provided, losses will be calculated on each fold with model fitted on the other folds, and a <code>lambda_length x cv_fold</code> matrix <code>cv_losses</code> will be returned.</p>
</td></tr>
<tr><td><code id="estimate_+3A_cv_fold_seed">cv_fold_seed</code></td>
<td>
<p>Optional. Seed for generating folds for cross validation.</p>
</td></tr>
<tr><td><code id="estimate_+3A_return_raw">return_raw</code></td>
<td>
<p>A boolean, whether to return the raw estimates of <code>K</code>. Default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="estimate_+3A_return_elts">return_elts</code></td>
<td>
<p>A boolean, whether to return the <code>elts</code> used for estimation. Default to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>edgess</code></td>
<td>
<p>A list of vectors of integers: indices of the non-zero edges.</p>
</td></tr>
<tr><td><code>BICs</code></td>
<td>
<p>A <code>lambda_length</code> by <code>length(eBIC_gammas)</code> matrix of raw eBIC scores (without refitting). If <code>return_raw == FALSE</code>, may contain <code>Inf</code>s for rows after the first lambda that gives the complete graph.</p>
</td></tr>
<tr><td><code>lambda1s</code></td>
<td>
<p>A vector of numbers of length <code>lambda_length</code>: the grid of <code>lambda1</code>s over which the estimates are obtained.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>A vector of booleans of length <code>lambda_length</code>: indicators of convergence for each fit. If <code>return_raw == FALSE</code>, may contain <code>0</code>s for all lambdas after the first lambda that gives the complete graph.</p>
</td></tr>
<tr><td><code>iters</code></td>
<td>
<p>A vector of integers of length <code>lambda_length</code>: the number of iterations run for each fit. If <code>return_raw == FALSE</code>, may contain <code>0</code>s for all lambdas after the first lambda that gives the complete graph.</p>
</td></tr>
</table>
<p>In addition,
if <code>centered == FALSE</code>,
</p>
<table role = "presentation">
<tr><td><code>etas</code></td>
<td>
<p>A <code>lambda_length</code>*<code>p</code> matrix of <code>eta</code> estimates with the <code class="reqn">i</code>-th row corresponding to the <code class="reqn">i</code>-th <code>lambda1</code>. If <code>return_raw == FALSE</code>,  may contain <code>NA</code>s after the first lambda that gives the complete graph.</p>
</td></tr>
</table>
<p>if <code>centered == FALSE</code> and non-profiled,
</p>
<table role = "presentation">
<tr><td><code>lambda2s</code></td>
<td>
<p>A vector of numbers of length <code>lambda_length</code>: the grid of <code>lambda2</code>s over which the estimates are obtained.</p>
</td></tr>
</table>
<p>if <code>return_raw == TRUE</code>,
</p>
<table role = "presentation">
<tr><td><code>raw_estimate</code></td>
<td>
<p>A list that contains <code>lambda_length</code> estimates for <code>K</code> of size <code>ncol(x)</code>*<code>ncol(x)</code>.</p>
</td></tr>
</table>
<p>if <code>BIC_refit == TRUE</code>,
</p>
<table role = "presentation">
<tr><td><code>BIC_refits</code></td>
<td>
<p>A <code>lambda_length</code> by <code>length(eBIC_gammas)</code> matrix of refitted eBIC scores, obtained by refitting unpenalized models restricted to the estimated edges. May contain <code>Inf</code>s for rows after the first lambda that gives the graph restricted to which an unpenalized model does not have a solution (loss unbounded from below).</p>
</td></tr>
</table>
<p>if <code>cv_fold</code> is not <code>NULL</code>,
</p>
<table role = "presentation">
<tr><td><code>cv_losses</code></td>
<td>
<p>A <code>lambda_length x cv_fold</code> matrix of cross validation losses. If <code>return_raw == FALSE</code>, may contain <code>Inf</code>s for all lambdas after the first lambda that gives the complete graph.</p>
</td></tr>
</table>
<p>if <code>return_elts == TRUE</code>,
</p>
<table role = "presentation">
<tr><td><code>elts</code></td>
<td>
<p>A list of elements returned from <code>get_elts()</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Examples are shown for Gaussian truncated to R+^p only. For other distributions
#   on other types of domains, please refer to \code{gen()} or \code{get_elts()},
#   as the way to call this function (\code{estimate()}) is exactly the same in those cases.
n &lt;- 30
p &lt;- 20
domain &lt;- make_domain("R+", p=p)
mu &lt;- rep(0, p)
K &lt;- diag(p)
lambda1s &lt;- c(0.01,0.1,0.2,0.3,0.4,0.5)
dm &lt;- 1 + (1-1/(1+4*exp(1)*max(6*log(p)/n, sqrt(6*log(p)/n))))
x &lt;- tmvtnorm::rtmvnorm(n, mean = mu, sigma = solve(K),
       lower = rep(0, p), upper = rep(Inf, p), algorithm = "gibbs",
       burn.in.samples = 100, thinning = 10)

## Centered estimates, no elts or h provided, mode and params provided
est1 &lt;- estimate(x, "gaussian", domain=domain, elts=NULL, centered=TRUE,
          symmetric="symmetric", lambda1s=lambda1s, mode="min_pow", 
          param1=1, param2=3, diag=dm, return_raw=TRUE, verbose=FALSE)

h_hp &lt;- get_h_hp("min_pow", 1, 3)
## Centered estimates, no elts provided, h provided; equivalent to est1
est2 &lt;- estimate(x, "gaussian", domain=domain, elts=NULL, centered=TRUE,
          symmetric="symmetric", lambda1s=lambda1s, h_hp=h_hp, diag=dm, 
          return_raw=TRUE, verbose=FALSE)
compare_two_results(est1, est2) ## Should be almost all 0

elts_gauss_c &lt;- get_elts(h_hp, x, setting="gaussian", domain=domain,
            centered=TRUE, diag=dm)
## Centered estimates, elts provided; equivalent to est1 and est2
## Here diagonal_multiplier will be set to the default value, equal to dm above
est3 &lt;- estimate(x, "gaussian", domain=domain, elts=elts_gauss_c,
          symmetric="symmetric", lambda1s=lambda1s, diag=NULL,
          return_raw=TRUE, verbose=FALSE)
compare_two_results(est1, est3) ## Should be almost all 0

## Non-centered estimates with Inf penalty on eta; equivalent to est1~3
est4 &lt;- estimate(x, "gaussian", domain=domain, elts=NULL, centered=FALSE,
          lambda_ratio=0, symmetric="symmetric", lambda1s=lambda1s,
          h=h_hp, diag=dm, return_raw=TRUE, verbose=FALSE)
sum(abs(est4$etas)) ## Should be 0 since non-centered with lambda ratio 0 is equivalent to centered
est4$etas &lt;- NULL ## But different from est1 in that the zero etas are returned in est4
compare_two_results(est1, est4) ## Should be almost all 0


## Profiled estimates, no elts or h provided, mode and params provided
est5 &lt;- estimate(x, "gaussian", domain=domain, elts=NULL, centered=FALSE,
          lambda_ratio=Inf, symmetric="or", lambda1s=lambda1s, mode="min_pow", 
          param1=1, param2=3, diag=dm, return_raw=TRUE, verbose=FALSE)

## Profiled estimates, no elts provided, h provided; equivalent to est5
est6 &lt;- estimate(x, "gaussian", domain=domain, elts=NULL, centered=FALSE,
          lambda_ratio=Inf, symmetric="or", lambda1s=lambda1s,
          h_hp=h_hp, diag=dm, return_raw=TRUE, verbose=FALSE)
compare_two_results(est5, est6) ## Should be almost all 0

elts_gauss_p &lt;- get_elts(h_hp, x, setting="gaussian", domain=domain,
                centered=FALSE, profiled=TRUE, diag=dm)
## Profiled estimates, elts provided; equivalent to est5~6
est7 &lt;- estimate(x, "gaussian", domain=domain, elts=elts_gauss_p, centered=FALSE,
          lambda_ratio=Inf, symmetric="or", lambda1s=lambda1s,
          diagonal_multiplier=NULL, return_raw=TRUE, verbose=FALSE)
compare_two_results(est5, est7) ## Should be almost all 0


## Non-centered estimates, no elts or h provided, mode and params provided
## Using 5-fold cross validation and no BIC refit
est8 &lt;- estimate(x, "gaussian", domain=domain, elts=NULL, centered=FALSE,
          lambda_ratio=2, symmetric="and", lambda_length=100,
          mode="min_pow", param1=1, param2=3, diag=dm, return_raw=TRUE,
          BIC_refit=FALSE, cv_fold=5, cv_fold_seed=2, verbose=FALSE)

## Non-centered estimates, no elts provided, h provided; equivalent to est5
## Using 5-fold cross validation and no BIC refit
est9 &lt;- estimate(x, "gaussian", domain=domain, elts=NULL, centered=FALSE,
          lambda_ratio=2, symmetric="and", lambda_length=100, h_hp=h_hp, diag=dm, 
          return_raw=TRUE, BIC_refit=FALSE, cv_fold=5, cv_fold_seed=2, verbose=FALSE)
compare_two_results(est8, est9) ## Should be almost all 0

elts_gauss_np &lt;- get_elts(h_hp, x, setting="gaussian", domain=domain, centered=FALSE,
                profiled=FALSE, diag=dm)
## Non-centered estimates, elts provided; equivalent to est8~9
## Using 5-fold cross validation and no BIC refit
est10 &lt;- estimate(x, "gaussian", domain, elts=elts_gauss_np, centered=FALSE,
           lambda_ratio=2, symmetric="and", lambda_length=100, diag=NULL,
           return_raw=TRUE, BIC_refit=FALSE, cv_fold=5, cv_fold_seed=2, verbose=FALSE)
compare_two_results(est8, est10) ## Should be almost all 0

</code></pre>

<hr>
<h2 id='find_max_ind'>Finds the max index in a vector that does not exceed a target number.</h2><span id='topic+find_max_ind'></span>

<h3>Description</h3>

<p>Finds the max index in a vector that does not exceed a target number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_max_ind(vals, target, start = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_max_ind_+3A_vals">vals</code></td>
<td>
<p>A vector of numbers.</p>
</td></tr>
<tr><td><code id="find_max_ind_+3A_target">target</code></td>
<td>
<p>A number. Must not be smaller than <code>vals[start]</code>.</p>
</td></tr>
<tr><td><code id="find_max_ind_+3A_start">start</code></td>
<td>
<p>A number, the starting index; default to 1. Must be such that <code>vals[start] &lt;= target</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The max index <code>i</code> such that <code>vals[i] &lt;= target</code> and <code>i &gt;= start</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>for (i in 1:100) {
   vals &lt;- 1:i
   for (start in 1:i)
      for (target in seq(start, i+0.5, by=0.5))
         if (find_max_ind(vals, target, start) != floor(target))
            stop()
}
</code></pre>

<hr>
<h2 id='frac_pow'>Evaluate x^(a/b) and |x|^(a/b) with integer a and b with extension to conventional operations.</h2><span id='topic+frac_pow'></span>

<h3>Description</h3>

<p>Evaluate x^(a/b) and |x|^(a/b) with integer a and b with extension to conventional operations (listed under details) that would otherwise result in <code>NaN</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frac_pow(x, a, b, abs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="frac_pow_+3A_x">x</code></td>
<td>
<p>A number or a vector of numbers.</p>
</td></tr>
<tr><td><code id="frac_pow_+3A_a">a</code></td>
<td>
<p>An integer.</p>
</td></tr>
<tr><td><code id="frac_pow_+3A_b">b</code></td>
<td>
<p>An integer.</p>
</td></tr>
<tr><td><code id="frac_pow_+3A_abs">abs</code></td>
<td>
<p>TRUE or FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Replace <code>x</code> by <code>abs(x)</code> below if <code>abs == TRUE</code>.
If <code>a == 0 &amp;&amp; b == 0</code>, returns <code>log(x)</code>.
If <code>a != 0 &amp;&amp; b == 0</code>, returns <code>exp(a*x)</code>.
Otherwise, for <code>b != 0</code>, evaluates <code>x^(a/b)</code> with the following extensions.
<code>0^0</code> evaluates to <code>1</code>.
If <code>x &lt; 0</code>, returns <code>(-1)^a * |x|^(a/b)</code> if <code>b</code> is odd, or <code>NaN</code> otherwise.
If <code>x == 0 &amp;&amp; a &lt; 0</code>, returns <code>NaN</code>.
</p>


<h3>Value</h3>

<p>A vector of numbers of the same size as <code>x</code>. See details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>frac_pow(-5:5, 3, 2, TRUE) - abs(-5:5)^(3/2)
frac_pow(-5:5, 5, 3, FALSE) - sign(-5:5)^5*abs(-5:5)^(5/3)
frac_pow(-5:5, 2, 3, FALSE) - ((-5:5)^2)^(1/3)
frac_pow(c(-5:-1,1:5), 0, 0, TRUE) - log(abs(c(-5:-1,1:5)))
frac_pow(-5:5, 0, 1, FALSE) - 1
frac_pow(-5:5, 3, 0, FALSE) - exp(3*-5:5)
</code></pre>

<hr>
<h2 id='gcd'>Finds the greatest (positive) common divisor of two integers.</h2><span id='topic+gcd'></span>

<h3>Description</h3>

<p>Finds the greatest (positive) common divisor of two integers; if one of them is 0, returns the absolute value of the other number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcd(a, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gcd_+3A_a">a</code></td>
<td>
<p>An integer.</p>
</td></tr>
<tr><td><code id="gcd_+3A_b">b</code></td>
<td>
<p>An integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The greatest (positive) common divisor of two integers; if one of them is 0, returns the absolute value of the other number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gcd(1, 2)
gcd(1, -2)
gcd(12, -18)
gcd(-12, 18)
gcd(15, 0)
gcd(0, -15)
gcd(0, 0)
</code></pre>

<hr>
<h2 id='gen'>Random data generator from general <code>a</code>-<code>b</code> distributions with general domain types, assuming a and b are rational numbers.</h2><span id='topic+gen'></span>

<h3>Description</h3>

<p>Random data generator from general <code>a</code>-<code>b</code> graphs with general domain types using adaptive rejection metropolis sampling (ARMS). x^(0/0) treated as log(x) and x^(n/0) as exp(x) for n non-zero. Density only guaranteed to be a proper density when 2*a &gt; b &gt;= 0 or when a = b = 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen(
  n,
  setting,
  abs,
  eta,
  K,
  domain,
  finite_infinity = NULL,
  xinit = NULL,
  seed = NULL,
  burn_in = 1000,
  thinning = 100,
  verbose = TRUE,
  remove_outofbound = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_+3A_n">n</code></td>
<td>
<p>An integer, number of observations.</p>
</td></tr>
<tr><td><code id="gen_+3A_setting">setting</code></td>
<td>
<p>A string that indicates the distribution type, must be one of <code>"exp"</code>, <code>"gamma"</code>, <code>"gaussian"</code>, <code>"log_log"</code>, <code>"log_log_sum0"</code>, or of the form <code>"ab_NUM1_NUM2"</code>, where <code>NUM1</code> is the <code>a</code> value and <code>NUM2</code> is the <code>b</code> value, and <code>NUM1</code> and <code>NUM2</code> must be integers or two integers separated by &quot;/&quot;, e.g. &quot;ab_2_2&quot;, &quot;ab_2_5/4&quot; or &quot;ab_2/3_1/2&quot;.</p>
</td></tr>
<tr><td><code id="gen_+3A_abs">abs</code></td>
<td>
<p>A boolean. If TRUE, density is rewritten as f(|x|), i.e. with |x|^(a_numer/a_denom) and |x|^(b_numer/b_denom)</p>
</td></tr>
<tr><td><code id="gen_+3A_eta">eta</code></td>
<td>
<p>A vector, the linear part in the distribution.</p>
</td></tr>
<tr><td><code id="gen_+3A_k">K</code></td>
<td>
<p>A square matrix, the interaction matrix. There should exist some C &gt; 0 such that </p>
<p style="text-align: center;"><code class="reqn">{\boldsymbol{x}^a}^{\top}\mathbf{K}{\boldsymbol{x}}^a/({\boldsymbol{x}^a}^{\top}{\boldsymbol{x}}^a) &gt;= C</code>
</p>
<p> for all x in the domain (i.e. <code>K</code> is positive definite if <code>domain$type == "R"</code> and <code>K</code> is co-positive if <code>domain$type == "R+"</code>.). If <code>a_numer == a_denom == b_numer == b_denom == 0 &amp;&amp; domain$type == "simplex"</code>, K can also have all row and column sums equal to 0 but have all but one eigenvalues (0) positive.</p>
</td></tr>
<tr><td><code id="gen_+3A_domain">domain</code></td>
<td>
<p>A list returned from <code>make_domain()</code> that represents the domain.</p>
</td></tr>
<tr><td><code id="gen_+3A_finite_infinity">finite_infinity</code></td>
<td>
<p>A finite positive number. <code>Inf</code> in actual generation will be truncated to <code>finite_infinity</code> if applicable. Although the code will adaptively increase <code>finite_infinity</code>, the user should set it to a large number initially so that <code>abs(x) &gt; finite_infinity</code> with very small probability.</p>
</td></tr>
<tr><td><code id="gen_+3A_xinit">xinit</code></td>
<td>
<p>Optional. A <code>p</code>-vector, an initial point in the domain. If the domain is defined by more than one ineq or by one ineq containing negative coefficients, this must be provided. In the unlikely case where the function fails to automatically generate an initial point this should also be provided.</p>
</td></tr>
<tr><td><code id="gen_+3A_seed">seed</code></td>
<td>
<p>Optional. A number, the seed for the random generator.</p>
</td></tr>
<tr><td><code id="gen_+3A_burn_in">burn_in</code></td>
<td>
<p>Optional. A positive integer, the number of burn-in samples in ARMS to be discarded, meaning that samples from the first <code>burn_in</code> x <code>thinning</code> iterations will be discarded.</p>
</td></tr>
<tr><td><code id="gen_+3A_thinning">thinning</code></td>
<td>
<p>Optional. A positive integer, thinning factor in ARMS. Samples are taken at iteration steps <code class="reqn">(\mathrm{burn\_in}+1)\times\mathrm{thinning}</code>, ..., <code class="reqn">(\mathrm{burn\_in}+n)\times\mathrm{thinning}</code>. Default to <code>100</code>.</p>
</td></tr>
<tr><td><code id="gen_+3A_verbose">verbose</code></td>
<td>
<p>Optional. A boolean. If <code>TRUE</code>, prints a progress bar showing the progress. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="gen_+3A_remove_outofbound">remove_outofbound</code></td>
<td>
<p>Optional. A logical, defaults to <code>TRUE</code>. If <code>TRUE</code>, a test whether each sample lies inside the domain will be done, which may take a while for larger sample sizes, and rows that do not lie in the domain will be removed (may happen for <code>domain$type == "polynomial"</code> with more than 1 ineq and an OR (&quot;|&quot;) in <code>domain$rule</code>.).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE: For polynomial domains with many ineqs and a rule containing &quot;OR&quot; (&quot;|&quot;), not all samples generated are guaranteed to be inside the domain. It is thus recommended to set <code>remove_outofbound</code> to <code>TRUE</code> and rerun the function with new initial points until the desired number of in-bound samples have been generated.
</p>
<p>Randomly generates <code>n</code> samples from the <code>p</code>-variate <code>a</code>-<code>b</code> distributions with parameters <code class="reqn">\boldsymbol{\eta}</code> and <code class="reqn">\mathbf{K}</code>, where <code>p</code> is the length of <code class="reqn">\boldsymbol{\eta}</code> or the dimension of the square matrix <code class="reqn">\mathbf{K}</code>.
</p>
<p>Letting <code>a=a_numer/a_denom</code> and <code>b=b_numer/b_denom</code>, the <code>a</code>-<code>b</code> distribution is proportional to
</p>
<p style="text-align: center;"><code class="reqn">\exp\left(-\frac{1}{2a}{\boldsymbol{x}^a}^{\top}\mathbf{K}{\boldsymbol{x}}^a+\boldsymbol{\eta}^{\top}\frac{\boldsymbol{x}^b-\mathbf{1}_p}{b}\right)</code>
</p>
<p>.
Note that <code>x^(0/0)</code> is understood as <code>log(x)</code>, and <code>x^(n/0)</code> with nonzero <code>n</code> is <code>exp(n*x)</code>, and in both cases the <code>a</code> and <code>b</code> in the denominators in the density are treated as 1.
</p>


<h3>Value</h3>

<p>An <code class="reqn">n\times p</code> matrix of samples, where <code class="reqn">p</code> is the length of <code>eta</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 20
p &lt;- 10
eta &lt;- rep(0, p)
K &lt;- diag(p)
dm &lt;- 1 + (1-1/(1+4*exp(1)*max(6*log(p)/n, sqrt(6*log(p)/n))))

# Gaussian on sum(x^2) &gt; 10 &amp;&amp; sum(x^(1/3)) &gt; 10 with x allowed to be negative
domain &lt;- make_domain("polynomial", p=p, rule="1 &amp;&amp; 2",
       ineqs=list(list("expression"="sum(x^2)&gt;10", abs=FALSE, nonnegative=FALSE),
                      list("expression"="sum(x^(1/3))&gt;10", abs=FALSE, nonnegative=FALSE)))
xinit &lt;- rep(sqrt(20/p), p)
x &lt;- gen(n, setting="gaussian", abs=FALSE, eta=eta,  K=K, domain=domain, finite_infinity=100, 
       xinit=xinit, seed=2, burn_in=500, thinning=100, verbose=FALSE)

# exp on ([0, 1] v [2,3])^p
domain &lt;- make_domain("uniform", p=p, lefts=c(0,2), rights=c(1,3))
x &lt;- gen(n, setting="exp", abs=FALSE, eta=eta, K=K, domain=domain, xinit=NULL, 
       seed=2, burn_in=500, thinning=100, verbose=TRUE)

# gamma on {x1 &gt; 1 &amp;&amp; log(1.3) &lt; x2 &lt; 1 &amp;&amp; x3 &gt; log(1.3) &amp;&amp; ... &amp;&amp; xp &gt; log(1.3)}
domain &lt;- make_domain("polynomial", p=p, rule="1 &amp;&amp; 2 &amp;&amp; 3",
       ineqs=list(list("expression"="x1&gt;1", abs=FALSE, nonnegative=TRUE),
                      list("expression"="x2&lt;1", abs=FALSE, nonnegative=TRUE),
                      list("expression"="exp(x)&gt;1.3", abs=FALSE, nonnegative=FALSE)))
set.seed(1)
xinit &lt;- c(1.5, 0.5, abs(stats::rnorm(p-2))+log(1.3))
x &lt;- gen(n, setting="gamma", abs=FALSE, eta=eta, K=K, domain=domain, finite_infinity=100, 
       xinit=xinit, seed=2, burn_in=500, thinning=100, verbose=FALSE)

# a0.6_b0.7 on {x in R_+^p: sum(log(x))&lt;2 || (x1^(2/3)-1.3x2^(-3)&lt;1 &amp;&amp; exp(x1)+2.3*x2&gt;2)}
domain &lt;- make_domain("polynomial", p=p, rule="1 || (2 &amp;&amp; 3)",
       ineqs=list(list("expression"="sum(log(x))&lt;2", abs=FALSE, nonnegative=TRUE),
                      list("expression"="x1^(2/3)-1.3x2^(-3)&lt;1", abs=FALSE, nonnegative=TRUE),
                      list("expression"="exp(x1)+2.3*x2^2&gt;2", abs=FALSE, nonnegative=TRUE)))
xinit &lt;- rep(1, p)
x &lt;- gen(n, setting="ab_3/5_7/10", abs=FALSE, eta=eta, K=K, domain=domain, finite_infinity=1e4, 
       xinit=xinit, seed=2, burn_in=500, thinning=100, verbose=FALSE)

# log_log model exp(-log(x) %*% K %*% log(x)/2 + eta %*% log(x)) on {x in R_+^p: sum_j j * xj &lt;= 1}
domain &lt;- make_domain("polynomial", p=p,
       ineqs=list(list("expression"=paste(paste(sapply(1:p,
                           function(j){paste(j, "x", j, sep="")}), collapse="+"), "&lt;1"),
                     abs=FALSE, nonnegative=TRUE)))
x &lt;- gen(n, setting="log_log", abs=FALSE, eta=eta, K=K, domain=domain, finite_infinity=100, 
       xinit=NULL, seed=2, burn_in=500, thinning=100, verbose=FALSE)

# log_log model on the simplex with K having row and column sums 0 (Aitchison model)
domain &lt;- make_domain("simplex", p=p)
K &lt;- -cov_cons("band", p=p, spars=3, eig=1)
diag(K) &lt;- diag(K) - rowSums(K) # So that rowSums(K) == colSums(K) == 0
eigen(K)$val[(p-1):p] # Make sure K has one 0 and p-1 positive eigenvalues
x &lt;- gen(n, setting="log_log_sum0", abs=FALSE, eta=eta, K=K, domain=domain, xinit=NULL, 
       seed=2, burn_in=500, thinning=100, verbose=FALSE)

# Gumbel_Gumbel model exp(-exp(2x) %*% K %*% exp(2x)/2 + eta %*% exp(-3x)) on {sum(|x|) &lt; 1}
domain &lt;- make_domain("polynomial", p=p,
       ineqs=list(list("expression"="sum(x)&lt;1", abs=TRUE, nonnegative=FALSE)))
K &lt;- diag(p)
x &lt;- gen(n, setting="ab_2/0_-3/0", abs=FALSE, eta=eta, K=K, domain=domain, finite_infinity=100, 
       xinit=NULL, seed=2, burn_in=500, thinning=100, verbose=FALSE)
</code></pre>

<hr>
<h2 id='get_crit_nopenalty'>Minimized loss for unpenalized restricted asymmetric models.</h2><span id='topic+get_crit_nopenalty'></span>

<h3>Description</h3>

<p>Analytic solution of the minimized loss for an unpenalized asymmetric model restricted to a given support. Does not work if <code>symmetric == "symmetric"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_crit_nopenalty(
  elts,
  exclude = NULL,
  exclude_eta = NULL,
  previous_res = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_crit_nopenalty_+3A_elts">elts</code></td>
<td>
<p>A list, elements necessary for calculations returned by get_elts().</p>
</td></tr>
<tr><td><code id="get_crit_nopenalty_+3A_exclude">exclude</code></td>
<td>
<p>Optional. A p*p binary matrix or a p^2 binary vector, where <code>1</code> indicates the entry in K was estimated to 0 in the previous estimate. Default to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get_crit_nopenalty_+3A_exclude_eta">exclude_eta</code></td>
<td>
<p>Optional. A p-binary vector, similar to <code>exclude</code>. Default to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get_crit_nopenalty_+3A_previous_res">previous_res</code></td>
<td>
<p>Optional. A list, the returned list by <code>get_results()</code> run previously with another lambda value. Default to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>previous_res</code> is provided, <code>exclude</code> and <code>exclude_eta</code> must be <code>NULL</code> or be consistent with the estimated support in <code>previous_res</code>. If <code>previous_res</code> and <code>exclude</code> are both <code>NULL</code>, assume all edges are present. The same applies to the non-profiled non-centered case when <code>previous_res</code> and <code>exclude_eta</code> are both <code>NULL</code>.
</p>


<h3>Value</h3>

<p>A number, the refitted loss.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Examples are shown for Gaussian truncated to R+^p only. For other distributions
#   on other types of domains, please refer to \code{gen()} or \code{get_elts()}, as the
#   way to call this function (\code{get_crit_nopenalty()}) is exactly the same in those cases.
n &lt;- 50
p &lt;- 30
domain &lt;- make_domain("R+", p=p)
h_hp &lt;- get_h_hp("min_pow", 1, 3)
mu &lt;- rep(0, p)
K &lt;- diag(p)
dm &lt;- 1 + (1-1/(1+4*exp(1)*max(6*log(p)/n, sqrt(6*log(p)/n))))
x &lt;- tmvtnorm::rtmvnorm(n, mean = mu, sigma = solve(K),
       lower = rep(0, p), upper = rep(Inf, p), algorithm = "gibbs",
       burn.in.samples = 100, thinning = 10)

elts_gauss_np &lt;- get_elts(h_hp, x, setting="gaussian", domain=domain,
                centered=FALSE, profiled=FALSE, diag=dm)
res_nc_np &lt;- get_results(elts_gauss_np, symmetric="symmetric", lambda1=0.35,
               lambda2=2, previous_res=NULL, is_refit=FALSE)
get_crit_nopenalty(elts_gauss_np, previous_res=res_nc_np)
</code></pre>

<hr>
<h2 id='get_dist'>Finds the distance of each element in a matrix x to the its boundary of the domain while fixing the others in the same row.</h2><span id='topic+get_dist'></span>

<h3>Description</h3>

<p>Finds the distance of each element in a matrix <code>x</code> to its boundary of the <code>domain</code> while fixing the others in the same row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dist(x, domain)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_dist_+3A_x">x</code></td>
<td>
<p>An <code>n</code> by <code>p</code> matrix, the data matrix, where <code>n</code> is the sample size and <code>p</code> the dimension.</p>
</td></tr>
<tr><td><code id="get_dist_+3A_domain">domain</code></td>
<td>
<p>A list returned from <code>make_domain()</code> that represents the domain.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returned matrix <code>dx</code> has its <code>i,j</code>-th component the distance of <code class="reqn">x_{i,j}</code> to the boundary of <code>domain</code>, assuming <code class="reqn">x_{i,-j}</code> are fixed. The matrix has the same size of <code>x</code> (<code>n</code> by <code>p</code>), or if <code>domain$type == "simplex"</code> and <code>x</code> has full dimension <code>p</code>, it has <code>p-1</code> columns.
Returned matrix <code>dpx</code> contains the component-wise derivatives of <code>dx</code> in its components. That is, its <code>i,j</code>-th component is 0 if <code class="reqn">x_{i,j}</code> is unbounded or is bounded from both below and above or is at the boundary, or -1 if <code class="reqn">x_{i,j}</code> is closer to its lower boundary (or if its bounded from below but unbounded from above), or 1 otherwise.
</p>


<h3>Value</h3>

<p>A list that contains <code>h(dist(x, domain))</code> and <code>h\'(dist(x, domain))</code>.
</p>
<table role = "presentation">
<tr><td><code>dx</code></td>
<td>
<p>Coordinate-wise distance to the boundary.</p>
</td></tr>
<tr><td><code>dpx</code></td>
<td>
<p>Coordinate-wise derivative of <code>dx</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 20
p &lt;- 10
eta &lt;- rep(0, p)
K &lt;- diag(p)
dm &lt;- 1 + (1-1/(1+4*exp(1)*max(6*log(p)/n, sqrt(6*log(p)/n))))

# Gaussian on R^p:
domain &lt;- make_domain("R", p=p)
x &lt;- mvtnorm::rmvnorm(n, mean=solve(K, eta), sigma=solve(K))
# Equivalently:

x2 &lt;- gen(n, setting="gaussian", abs=FALSE, eta=eta, K=K, domain=domain, finite_infinity=100, 
        xinit=NULL, burn_in=1000, thinning=100, verbose=FALSE)

dist &lt;- get_dist(x, domain)
# dx is all Inf and dpx is all 0 since each coordinate is unbounded with domain R
c(all(is.infinite(dist$dx)), all(dist$dpx==0))

# exp on R_+^p:
domain &lt;- make_domain("R+", p=p)
x &lt;- gen(n, setting="exp", abs=FALSE, eta=eta, K=K, domain=domain, finite_infinity=100, 
       xinit=NULL, seed=2, burn_in=1000, thinning=100, verbose=FALSE)
dist &lt;- get_dist(x, domain)
# dx is x and dpx is 1; with domain R+, the distance of x to the boundary is just x itself
c(max(abs(dist$dx - x))&lt;.Machine$double.eps^0.5, all(dist$dpx == 1))

# Gaussian on sum(x^2) &gt; p with x allowed to be negative
domain &lt;- make_domain("polynomial", p=p,
       ineqs=list(list("expression"=paste("sum(x^2)&gt;", p), abs=FALSE, nonnegative=FALSE)))
x &lt;- gen(n, setting="gaussian", abs=FALSE, eta=eta, K=K, domain=domain, finite_infinity=100, 
       xinit=NULL, seed=2, burn_in=1000, thinning=100, verbose=FALSE)
dist &lt;- get_dist(x, domain)
quota &lt;- p - (rowSums(x^2) - x^2) # How much should xij^2 at least be so that sum(xi^2) &gt; p?
# How far is xij from +/-sqrt(quota), if quota &gt;= 0?
dist_to_bound &lt;- abs(x[quota &gt;= 0]) - abs(sqrt(quota[quota &gt;= 0]))
max(abs(dist$dx[is.finite(dist$dx)] - dist_to_bound)) # Should be equal to our own calculations
# dist'(x) should be the same as the sign of x
all(dist$dpx[is.finite(dist$dx)] == sign(x[quota &gt;= 0]))
# quota is negative &lt;-&gt; sum of x_{i,-j}^2 already &gt; p &lt;-&gt; xij unbounded
#   given others &lt;-&gt; distance to boundary is Inf
all(quota[is.infinite(dist$dx)] &lt; 0)

# gamma on ([0, 1] v [2,3])^p
domain &lt;- make_domain("uniform", p=p, lefts=c(0,2), rights=c(1,3))
x &lt;- gen(n, setting="gamma", abs=FALSE, eta=eta, K=K, domain=domain,
       xinit=NULL, seed=2, burn_in=1000, thinning=100, verbose=FALSE)
dist &lt;- get_dist(x, domain)
# If 0 &lt;= xij &lt;= 1, distance to boundary is min(x-0, 1-x)
max(abs(dist$dx - pmin(x, 1-x))[x &gt;= 0 &amp; x &lt;= 1])
# If 0 &lt;= xij &lt;= 1, dist'(xij) is 1 if it is closer to 0, or -1 if it is closer 1,
#   assuming xij %in% c(0, 0.5, 1) with probability 0
all((dist$dpx == 2 * (1-x &gt; x) - 1)[x &gt;= 0 &amp; x &lt;= 1])
# If 2 &lt;= xij &lt;= 3, distance to boundary is min(x-2, 3-x)
max(abs(dist$dx - pmin(x-2, 3-x))[x &gt;= 2 &amp; x &lt;= 3])
# If 2 &lt;= xij &lt;= 3, dist'(xij) is 1 if it is closer to 2, or -1 if it is closer 3,
#   assuming xij %in% c(2, 2.5, 3) with probability 0
all((dist$dpx == 2 * (3-x &gt; x-2) - 1)[x &gt;= 2 &amp; x &lt;= 3])

# a0.6_b0.7 on {x1 &gt; 1 &amp;&amp; 0 &lt; x2 &lt; 1 &amp;&amp; x3 &gt; 0 &amp;&amp; ... &amp;&amp; xp &gt; 0}
domain &lt;- make_domain("polynomial", p=p, rule="1 &amp;&amp; 2 &amp;&amp; 3",
       ineqs=list(list("expression"="x1&gt;1", abs=FALSE, nonnegative=TRUE),
                      list("expression"="x2&lt;1", abs=FALSE, nonnegative=TRUE),
                      list("expression"="exp(x)&gt;1.3", abs=FALSE, nonnegative=FALSE)))
set.seed(1)
xinit &lt;- c(1.5, 0.5, abs(stats::rnorm(p-2)) + log(1.3))
x &lt;- gen(n, setting="ab_3/5_7/10", abs=FALSE, eta=eta, K=K, domain=domain,
       finite_infinity=100, xinit=xinit, seed=2, burn_in=1000, thinning=100,
       verbose=FALSE)
dist &lt;- get_dist(x, domain)
# x_{i1} has uniform bound [1, +Inf), so its distance to its boundary is x_{i1} - 1
max(abs(dist$dx[,1] - (x[,1] - 1)))
# x_{i2} has uniform bound [log(1.3), 1], so its distance to its boundary
#   is min(x_{i2} - log(1.3), 1 - x_{i2})
max(abs(dist$dx[,2] - pmin(x[,2] - log(1.3), 1 - x[,2])))
# x_{ij} for j &gt;= 3 has uniform bound [log(1.3), +Inf), so its distance to its boundary
#   is simply x_{ij} - log(1.3)
max(abs(dist$dx[,3:p] - (x[,3:p] - log(1.3))))
# dist\'(xi2) is 1 if it is closer to log(1.3), or -1 if it is closer 1,
#   assuming x_{i2} %in% c(log(1.3), (1+log(1.3))/2, 1) with probability 0
all((dist$dpx[,2] == 2 * (1 - x[,2] &gt; x[,2] - log(1.3)) - 1))
# x_{ij} for j != 2 is bounded from below but unbounded from above, so dist\'(xij) is always 1
all(dist$dpx[,-2] == 1)

# log_log model on {x in R_+^p: sum_j j * xj &lt;= 1}
domain &lt;- make_domain("polynomial", p=p,
       ineqs=list(list("expression"=paste(paste(sapply(1:p,
                           function(j){paste(j, "x", j, sep="")}), collapse="+"), "&lt;1"),
                     abs=FALSE, nonnegative=TRUE)))
x &lt;- gen(n, setting="log_log", abs=FALSE, eta=eta, K=K, domain=domain, finite_infinity=100, 
       xinit=NULL, seed=2, burn_in=1000, thinning=100, verbose=FALSE)
dist &lt;- get_dist(x, domain)
# Upper bound for j * xij so that sum_j j * xij &lt;= 1
quota &lt;- 1 - (rowSums(t(t(x) * 1:p)) - t(t(x) * 1:p))
# Distance of xij to its boundary is min(xij - 0, quota_{i,j} / j - xij)
max(abs(dist$dx - pmin((t(t(quota) / 1:p) - x), x)))

# log_log model on the simplex with K having row and column sums 0 (Aitchison model)
domain &lt;- make_domain("simplex", p=p)
K &lt;- -cov_cons("band", p=p, spars=3, eig=1)
diag(K) &lt;- diag(K) - rowSums(K) # So that rowSums(K) == colSums(K) == 0
eigen(K)$val[(p-1):p] # Make sure K has one 0 and p-1 positive eigenvalues
x &lt;- gen(n, setting="log_log_sum0", abs=FALSE, eta=eta, K=K, domain=domain,
        xinit=NULL, seed=2, burn_in=1000, thinning=100, verbose=FALSE)
# Note that dist$dx and dist$dpx only has p-1 columns -- excluding the last coordinate in x
dist &lt;- get_dist(x, domain)
# Upper bound for x_{i,j} so that x_{i,1} + ... + x_{i,p-1} &lt;= 1
quota &lt;- 1 - (rowSums(x[,-p]) - x[,-p])
# Distance of x_{i,j} to its boundary is min(xij - 0, quota_{i,j} - xij)
max(abs(dist$dx - pmin(quota - x[,-p], x[,-p])))
</code></pre>

<hr>
<h2 id='get_elts'>The function wrapper to get the elements necessary for calculations for all settings.</h2><span id='topic+get_elts'></span>

<h3>Description</h3>

<p>The function wrapper to get the elements necessary for calculations for all settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_elts(
  h_hp,
  x,
  setting,
  domain,
  centered = TRUE,
  profiled_if_noncenter = TRUE,
  scale = "",
  diagonal_multiplier = 1,
  use_C = TRUE,
  tol = .Machine$double.eps^0.5,
  unif_dist = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_elts_+3A_h_hp">h_hp</code></td>
<td>
<p>A function that returns a list containing <code>hx=h(x)</code> (element-wise) and <code>hpx=hp(x)</code> (element-wise derivative of <code class="reqn">h</code>) when applied to a vector or a matrix <code>x</code>, both of which has the same shape as <code>x</code>.</p>
</td></tr>
<tr><td><code id="get_elts_+3A_x">x</code></td>
<td>
<p>An <code>n</code> by <code>p</code> matrix, the data matrix, where <code>n</code> is the sample size and <code>p</code> the dimension.</p>
</td></tr>
<tr><td><code id="get_elts_+3A_setting">setting</code></td>
<td>
<p>A string that indicates the distribution type, must be one of <code>"exp"</code>, <code>"gamma"</code>, <code>"gaussian"</code>, <code>"log_log"</code>, <code>"log_log_sum0"</code>, or of the form <code>"ab_NUM1_NUM2"</code>, where <code>NUM1</code> is the <code>a</code> value and <code>NUM2</code> is the <code>b</code> value, and <code>NUM1</code> and <code>NUM2</code> must be integers or two integers separated by &quot;/&quot;, e.g. &quot;ab_2_2&quot;, &quot;ab_2_5/4&quot; or &quot;ab_2/3_1/2&quot;. If <code>domain$type == "simplex"</code>, only <code>"log_log"</code> and <code>"log_log_sum0"</code> are supported, and on the other hand <code>"log_log_sum0"</code> is supported for <code>domain$type == "simplex"</code> only.</p>
</td></tr>
<tr><td><code id="get_elts_+3A_domain">domain</code></td>
<td>
<p>A list returned from <code>make_domain()</code> that represents the domain.</p>
</td></tr>
<tr><td><code id="get_elts_+3A_centered">centered</code></td>
<td>
<p>A boolean, whether in the centered setting(assume <code class="reqn">\boldsymbol{\mu}=\boldsymbol{\eta}=0</code>) or not. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_elts_+3A_profiled_if_noncenter">profiled_if_noncenter</code></td>
<td>
<p>A boolean, whether in the profiled setting (<code class="reqn">\lambda_{\boldsymbol{\eta}}=0</code>) if non-centered. Parameter ignored if <code>centered=TRUE</code>. Default to <code>TRUE</code>. Can only be <code>FALSE</code> if <code>setting == "log_log_sum0" &amp;&amp; centered == FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_elts_+3A_scale">scale</code></td>
<td>
<p>A string indicating the scaling method. If contains <code>"sd"</code>, columns are scaled by standard deviation; if contains <code>"norm"</code>, columns are scaled by l2 norm; if contains <code>"center"</code> and <code>setting == "gaussian" &amp;&amp; domain$type == "R"</code>, columns are centered to have mean zero. Default to <code>"norm"</code>.</p>
</td></tr>
<tr><td><code id="get_elts_+3A_diagonal_multiplier">diagonal_multiplier</code></td>
<td>
<p>A number &gt;= 1, the diagonal multiplier.</p>
</td></tr>
<tr><td><code id="get_elts_+3A_use_c">use_C</code></td>
<td>
<p>Optional. A boolean, use C (<code>TRUE</code>) or R (<code>FALSE</code>) functions for computation. Default to <code>TRUE</code>. Ignored if <code>setting == "gaussian" &amp;&amp; domain$type == "R"</code>.</p>
</td></tr>
<tr><td><code id="get_elts_+3A_tol">tol</code></td>
<td>
<p>Optional. A positive number. If <code>setting != "gaussian" || domain$type != "R"</code>, function stops if any entry if smaller than -tol, and all entries between -tol and 0 are set to tol, for numerical stability and to avoid violating the assumption that <code class="reqn">h(\mathbf{x})&gt;0</code> almost surely.</p>
</td></tr>
<tr><td><code id="get_elts_+3A_unif_dist">unif_dist</code></td>
<td>
<p>Optional, defaults to <code>NULL</code>. If not <code>NULL</code>, <code>h_hp</code> must be <code>NULL</code> and <code>unif_dist(x)</code> must return a list containing <code>"g0"</code> of length <code>nrow(x)</code> and <code>"g0d"</code> of dimension <code>dim(x)</code>, representing the l2 distance and the gradient of the l2 distance to the boundary: the true l2 distance function to the boundary is used for all coordinates in place of h_of_dist; see &quot;Estimating Density Models with Complex Truncation Boundaries&quot; by Liu et al, 2019. That is, <code class="reqn">(h_j\circ \phi_j)(x_i)</code> in the score-matching loss is replaced by <code class="reqn">g_0(x_i)</code>, the l2 distance of xi to the boundary of the domain.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the <code class="reqn">\boldsymbol{\Gamma}</code> matrix and the <code class="reqn">\boldsymbol{g}</code> vector for generalized score matching.
</p>
<p>Here, <code class="reqn">\boldsymbol{\Gamma}</code> is block-diagonal, and in the non-profiled non-centered setting, the <code class="reqn">j</code>-th block is composed of <code class="reqn">\boldsymbol{\Gamma}_{\mathbf{KK},j}</code>, <code class="reqn">\boldsymbol{\Gamma}_{\mathbf{K}\boldsymbol{\eta},j}</code> and its transpose, and finally <code class="reqn">\boldsymbol{\Gamma}_{\boldsymbol{\eta\eta},j}</code>. In the centered case, only <code class="reqn">\boldsymbol{\Gamma}_{\mathbf{KK},j}</code> is computed. In the profiled non-centered case, </p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{\Gamma}_{j}\equiv\boldsymbol{\Gamma}_{\mathbf{KK},j}-\boldsymbol{\Gamma}_{\mathbf{K}\boldsymbol{\eta},j}\boldsymbol{\Gamma}_{\boldsymbol{\eta}\boldsymbol{\eta},j}^{-1}\boldsymbol{\Gamma}_{\mathbf{K}\boldsymbol{\eta}}^{\top}.</code>
</p>

<p>Similarly, in the non-profiled non-centered setting, <code class="reqn">\boldsymbol{g}</code> can be partitioned <code class="reqn">p</code> parts, each with a <code class="reqn">p</code>-vector <code class="reqn">\boldsymbol{g}_{\mathbf{K},j}</code> and a scalar <code class="reqn">g_{\boldsymbol{\eta},j}</code>. In the centered setting, only <code class="reqn">\boldsymbol{g}_{\mathbf{K},j}</code> is needed. In the profiled non-centered case, </p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{g}_j\equiv\boldsymbol{g}_{\mathbf{K},j}-\boldsymbol{\Gamma}_{\mathbf{K}\boldsymbol{\eta},j}\boldsymbol{\Gamma}_{\boldsymbol{\eta\eta},j}^{-1}g_{\boldsymbol{\eta},j}.</code>
</p>

<p>The formulae for the pieces above are
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{\Gamma}_{\mathbf{KK},j}\equiv\frac{1}{n}\sum_{i=1}^nh\left(X_j^{(i)}\right){X_j^{(i)}}^{2a-2}{\boldsymbol{X}^{(i)}}^a{{\boldsymbol{X}^{(i)}}^a}^{\top},</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{\Gamma}_{\mathbf{K}\boldsymbol{\eta},j}\equiv-\frac{1}{n}\sum_{i=1}^nh\left(X_j^{(i)}\right){X_j^{(i)}}^{a+b-2}{\boldsymbol{X}^{(i)}}^a,</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{\Gamma}_{\boldsymbol{\eta\eta},j}\equiv\frac{1}{n}\sum_{i=1}^nh\left(X_j^{(i)}\right){X_j^{(i)}}^{2b-2},</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{g}_{\mathbf{K},j}\equiv\frac{1}{n}\sum_{i=1}^n\left(h'\left(X_j^{(i)}\right){X_j^{(i)}}^{a-1}+(a-1)h\left(X_j^{(i)}\right){X_j^{(i)}}^{a-2}\right){\boldsymbol{X}^{(i)}}^a+ah\left(X_j^{(i)}\right){X_j^{(i)}}^{2a-2}\boldsymbol{e}_{j,p},</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{g}_{\boldsymbol{\eta},j}\equiv\frac{1}{n}\sum_{i=1}^n-h'\left(X_j^{(i)}\right){X_j^{(i)}}^{b-1}-(b-1)h\left(X_j^{(i)}\right){X_j^{(i)}}^{b-2},</code>
</p>

<p>where <code class="reqn">\boldsymbol{e}_{j,p}</code> is the <code class="reqn">p</code>-vector with 1 at the <code class="reqn">j</code>-th position and 0 elsewhere.
</p>
<p>In the profiled non-centered setting, the function also returns <code class="reqn">t_1</code> and <code class="reqn">t_2</code> defined as
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{t}_1\equiv\boldsymbol{\Gamma}_{\boldsymbol{\eta\eta}}^{-1}\boldsymbol{g}_{\boldsymbol{\eta}},\quad\boldsymbol{t}_2\equiv\boldsymbol{\Gamma}_{\boldsymbol{\eta\eta}}^{-1}\boldsymbol{\Gamma}_{\mathbf{K}\boldsymbol{\eta}}^{\top},</code>
</p>

<p>so that <code class="reqn">\hat{\boldsymbol{\eta}}=\boldsymbol{t}_1-\boldsymbol{t}_2\mathrm{vec}(\hat{\mathbf{K}}).</code>
</p>


<h3>Value</h3>

<p>A list that contains the elements necessary for estimation.
</p>
<table role = "presentation">
<tr><td><code>n</code></td>
<td>
<p>The sample size.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>The dimension.</p>
</td></tr>
<tr><td><code>centered</code></td>
<td>
<p>The centered setting or not. Same as input.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>The scaling method. Same as input.</p>
</td></tr>
<tr><td><code>diagonal_multiplier</code></td>
<td>
<p>The diagonal multiplier. Same as input.</p>
</td></tr>
<tr><td><code>diagonals_with_multiplier</code></td>
<td>
<p>A vector that contains the diagonal entries of <code class="reqn">\boldsymbol{\Gamma}</code> after applying the multiplier.</p>
</td></tr>
<tr><td><code>domain_type</code></td>
<td>
<p>The domain type. Same as domain$type in the input.</p>
</td></tr>
<tr><td><code>setting</code></td>
<td>
<p>The setting. Same as input.</p>
</td></tr>
<tr><td><code>g_K</code></td>
<td>
<p>The <code class="reqn">\boldsymbol{g}</code> vector. In the non-profiled non-centered setting, this is the <code class="reqn">\boldsymbol{g}</code> sub-vector corresponding to <code class="reqn">\mathbf{K}</code>. A <code class="reqn">p^2</code>-vector. Not returned if <code>setting == "gaussian" &amp;&amp; domain$type == "R"</code> since it is just <code class="reqn">diag(p)</code>.</p>
</td></tr>
<tr><td><code>Gamma_K</code></td>
<td>
<p>The <code class="reqn">\boldsymbol{\Gamma}</code> matrix with no diagonal multiplier. In the non-profiled non-centered setting, this is the <code class="reqn">\boldsymbol{\Gamma}</code> sub-matrix corresponding to <code class="reqn">\mathbf{K}</code>. A vector of length <code class="reqn">p^2</code> if <code>setting == "gaussian" &amp;&amp; domain$type == "R"</code> or <code class="reqn">p^3</code> otherwise.</p>
</td></tr>
<tr><td><code>g_eta</code></td>
<td>
<p>Returned in the non-profiled non-centered setting. The <code class="reqn">\boldsymbol{g}</code> sub-vector corresponding to <code class="reqn">\boldsymbol{\eta}</code>. A <code class="reqn">p</code>-vector. Not returned if <code>setting == "gaussian" &amp;&amp; domain$type == "R"</code> since it is just <code class="reqn">numeric(p)</code>.</p>
</td></tr>
<tr><td><code>Gamma_K_eta</code></td>
<td>
<p>Returned in the non-profiled non-centered setting. The <code class="reqn">\boldsymbol{\Gamma}</code> sub-matrix corresponding to interaction between <code class="reqn">\mathbf{K}</code> and <code class="reqn">\boldsymbol{\eta}</code>. If <code>setting == "gaussian" &amp;&amp; domain$type == "R"</code>, returns a vector of length <code class="reqn">p</code>, or <code class="reqn">p^2</code> otherwise.</p>
</td></tr>
<tr><td><code>Gamma_eta</code></td>
<td>
<p>Returned in the non-profiled non-centered setting. The <code class="reqn">\boldsymbol{\Gamma}</code> sub-matrix corresponding to <code class="reqn">\boldsymbol{\eta}</code>. A <code class="reqn">p</code>-vector. Not returned if <code>setting == "gaussian" &amp;&amp; domain$type == "R"</code> since it is just <code>rep(1,p)</code>.</p>
</td></tr>
<tr><td><code>t1</code>, <code>t2</code></td>
<td>
<p>Returned in the profiled non-centered setting, where the <code class="reqn">\boldsymbol{\eta}</code> estimate can be retrieved from <code class="reqn">\boldsymbol{t_1}-\boldsymbol{t_2}\hat{\mathbf{K}}</code> after appropriate resizing.</p>
</td></tr>
</table>
<p>If <code>domain$type == "simplex", the following are also returned.</code>
</p>
<table role = "presentation">
<tr><td><code>Gamma_K_jp</code></td>
<td>
<p>A matrix of size <code>p</code> by <code>p(p-1)</code>. The <code>(j-1)*p+1</code> through <code>j*p</code> columns represent the interaction matrix between the <code>j</code>-th column and the <code>m</code>-th column of <code>K</code>.</p>
</td></tr>
<tr><td><code>Gamma_Kj_etap</code></td>
<td>
<p>Non-centered only. A matrix of size <code>p</code> by <code>p(p-1)</code>. The <code>j</code>-th column represents the interaction between the <code>j</code>-th column of <code>K</code> and <code>eta[p]</code>.</p>
</td></tr>
<tr><td><code>Gamma_Kp_etaj</code></td>
<td>
<p>Non-centered only. A matrix of size <code>p</code> by <code>p(p-1)</code>. The <code>j</code>-th column represents the interaction between the <code>p</code>-th column of <code>K</code> and <code>eta[j]</code>. Note that it is equal to <code>Gamma_Kj_etap</code> if <code>setting</code> does not contain substring <code>"sum0"</code>.</p>
</td></tr>
<tr><td><code>Gamma_eta_jp</code></td>
<td>
<p>Non-centered only. A vector of size <code>p-1</code>. The <code>j</code>-th component represents the interaction between <code>eta[j]</code> and <code>eta[p]</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 30
p &lt;- 10
eta &lt;- rep(0, p)
K &lt;- diag(p)
dm &lt;- 1 + (1-1/(1+4*exp(1)*max(6*log(p)/n, sqrt(6*log(p)/n))))

# Gaussian on R^p:
domain &lt;- make_domain("R", p=p)
x &lt;- mvtnorm::rmvnorm(n, mean=solve(K, eta), sigma=solve(K))
# Equivalently:

x2 &lt;- gen(n, setting="gaussian", abs=FALSE, eta=eta, K=K, domain=domain, finite_infinity=100, 
        xinit=NULL, burn_in=1000, thinning=100, verbose=FALSE)

elts &lt;- get_elts(NULL, x, "gaussian", domain, centered=TRUE, scale="norm", diag=dm)
elts &lt;- get_elts(NULL, x, "gaussian", domain, FALSE, profiled=FALSE, scale="sd", diag=dm)

# Gaussian on R_+^p:
domain &lt;- make_domain("R+", p=p)
x &lt;- tmvtnorm::rtmvnorm(n, mean = solve(K, eta), sigma = solve(K),
       lower = rep(0, p), upper = rep(Inf, p), algorithm = "gibbs",
       burn.in.samples = 100, thinning = 10)
# Equivalently:

x2 &lt;- gen(n, setting="gaussian", abs=FALSE, eta=eta, K=K, domain=domain,
       finite_infinity=100, xinit=NULL, burn_in=1000, thinning=100, verbose=FALSE)

h_hp &lt;- get_h_hp("min_pow", 1, 3)
elts &lt;- get_elts(h_hp, x, "gaussian", domain, centered=TRUE, scale="norm", diag=dm)

# Gaussian on sum(x^2) &gt; 1 &amp;&amp; sum(x^(1/3)) &gt; 1 with x allowed to be negative
domain &lt;- make_domain("polynomial", p=p, rule="1 &amp;&amp; 2",
       ineqs=list(list("expression"="sum(x^2)&gt;1", abs=FALSE, nonnegative=FALSE),
                      list("expression"="sum(x^(1/3))&gt;1", abs=FALSE, nonnegative=FALSE)))
xinit &lt;- rep(sqrt(2/p), p)
x &lt;- gen(n, setting="gaussian", abs=FALSE, eta=eta, K=K, domain=domain, finite_infinity=100, 
       xinit=xinit, seed=2, burn_in=1000, thinning=100, verbose=FALSE)
h_hp &lt;- get_h_hp("min_pow", 1, 3)
elts &lt;- get_elts(h_hp, x, "gaussian", domain, centered=FALSE,
       profiled_if_noncenter=TRUE, scale="", diag=dm)

# exp on ([0, 1] v [2,3])^p
domain &lt;- make_domain("uniform", p=p, lefts=c(0,2), rights=c(1,3))
x &lt;- gen(n, setting="exp", abs=FALSE, eta=eta, K=K, domain=domain,
       xinit=NULL, seed=2, burn_in=1000, thinning=100, verbose=FALSE)
h_hp &lt;- get_h_hp("min_pow", 1.5, 3)
elts &lt;- get_elts(h_hp, x, "exp", domain, centered=TRUE, scale="", diag=dm)
elts &lt;- get_elts(h_hp, x, "exp", domain, centered=FALSE,
       profiled_if_noncenter=FALSE, scale="", diag=dm)

# gamma on {x1 &gt; 1 &amp;&amp; log(1.3) &lt; x2 &lt; 1 &amp;&amp; x3 &gt; log(1.3) &amp;&amp; ... &amp;&amp; xp &gt; log(1.3)}
domain &lt;- make_domain("polynomial", p=p, rule="1 &amp;&amp; 2 &amp;&amp; 3",
       ineqs=list(list("expression"="x1&gt;1", abs=FALSE, nonnegative=TRUE),
                      list("expression"="x2&lt;1", abs=FALSE, nonnegative=TRUE),
                      list("expression"="exp(x)&gt;1.3", abs=FALSE, nonnegative=TRUE)))
set.seed(1)
xinit &lt;- c(1.5, 0.5, abs(stats::rnorm(p-2))+log(1.3))
x &lt;- gen(n, setting="gamma", abs=FALSE, eta=eta, K=K, domain=domain, finite_infinity=100, 
       xinit=xinit, seed=2, burn_in=1000, thinning=100, verbose=FALSE)
h_hp &lt;- get_h_hp("min_pow", 1.5, 3)
elts &lt;- get_elts(h_hp, x, "gamma", domain, centered=TRUE, scale="", diag=dm)
elts &lt;- get_elts(h_hp, x, "gamma", domain, centered=FALSE,
       profiled_if_noncenter=FALSE, scale="", diag=dm)

# a0.6_b0.7 on {x in R_+^p: sum(log(x))&lt;2 || (x1^(2/3)-1.3x2^(-3)&lt;1 &amp;&amp; exp(x1)+2.3*x2&gt;2)}
domain &lt;- make_domain("polynomial", p=p, rule="1 || (2 &amp;&amp; 3)",
       ineqs=list(list("expression"="sum(log(x))&lt;2", abs=FALSE, nonnegative=TRUE),
                      list("expression"="x1^(2/3)-1.3x2^(-3)&lt;1", abs=FALSE, nonnegative=TRUE),
                      list("expression"="exp(x1)+2.3*x2^2&gt;2", abs=FALSE, nonnegative=TRUE)))
xinit &lt;- rep(1, p)
x &lt;- gen(n, setting="ab_3/5_7/10", abs=FALSE, eta=eta, K=K, domain=domain, finite_infinity=100, 
       xinit=xinit, seed=2, burn_in=1000, thinning=100, verbose=FALSE)
h_hp &lt;- get_h_hp("min_pow", 1.4, 3)
elts &lt;- get_elts(h_hp, x, "ab_3/5_7/10", domain, centered=TRUE, scale="", diag=dm)
elts &lt;- get_elts(h_hp, x, "ab_3/5_7/10", domain, centered=FALSE,
       profiled_if_noncenter=TRUE, scale="", diag=dm)

# log_log model on {x in R_+^p: sum_j j * xj &lt;= 1}
domain &lt;- make_domain("polynomial", p=p,
       ineqs=list(list("expression"=paste(paste(sapply(1:p,
                           function(j){paste(j, "x", j, sep="")}), collapse="+"), "&lt;1"),
                     abs=FALSE, nonnegative=TRUE)))
x &lt;- gen(n, setting="log_log", abs=FALSE, eta=eta, K=K, domain=domain,
       finite_infinity=100, xinit=NULL, seed=2, burn_in=1000, thinning=100,
       verbose=FALSE)
h_hp &lt;- get_h_hp("min_pow", 2, 3)
elts &lt;- get_elts(h_hp, x, "log_log", domain, centered=TRUE, scale="", diag=dm)
elts &lt;- get_elts(h_hp, x, "log_log", domain, centered=FALSE,
       profiled_if_noncenter=FALSE, scale="", diag=dm)
# Example of using the uniform distance function to boundary as in Liu (2019)
g0 &lt;- function(x) {
       row_min &lt;- apply(x, 1, min)
       row_which_min &lt;- apply(x, 1, which.min)
       dist_to_sum_boundary &lt;- apply(x, 1, function(xx){
                   (1 - sum(1:p * xx)) / sqrt(p*(p+1)*(2*p+1)/6)})
       grad_sum_boundary &lt;- -(1:p) / sqrt(p*(p+1)*(2*p+1)/6)
       g0 &lt;- pmin(row_min, dist_to_sum_boundary)
       g0d &lt;- t(sapply(1:nrow(x), function(i){
          if (row_min[i] &lt; dist_to_sum_boundary[i]){
             tmp &lt;- numeric(ncol(x)); tmp[row_which_min[i]] &lt;- 1
          } else {tmp &lt;- grad_sum_boundary}
          tmp
       }))
       list("g0"=g0, "g0d"=g0d)
}
elts &lt;- get_elts(NULL, x, "exp", domain, centered=TRUE, profiled_if_noncenter=FALSE,
       scale="", diag=dm, unif_dist=g0)

# log_log_sum0 model on the simplex with K having row and column sums 0 (Aitchison model)
domain &lt;- make_domain("simplex", p=p)
K &lt;- -cov_cons("band", p=p, spars=3, eig=1)
diag(K) &lt;- diag(K) - rowSums(K) # So that rowSums(K) == colSums(K) == 0
eigen(K)$val[(p-1):p] # Make sure K has one 0 and p-1 positive eigenvalues
x &lt;- gen(n, setting="log_log_sum0", abs=FALSE, eta=eta, K=K, domain=domain,
       xinit=NULL, seed=2, burn_in=1000, thinning=100, verbose=FALSE)
h_hp &lt;- get_h_hp("min_pow", 2, 3)
h_hp_dx &lt;- h_of_dist(h_hp, x, domain) # h and h' applied to distance from x to boundary

# Does not assume K has 0 row and column sums
elts_simplex_0 &lt;- get_elts(h_hp, x, "log_log", domain, centered=TRUE, profiled=FALSE,
       scale="", diag=1.5)

# If want K to have row sums and column sums equal to 0 (Aitchison); estimate off-diagonals only
elts_simplex_1 &lt;- get_elts(h_hp, x, "log_log_sum0", domain, centered=FALSE,
       profiled=FALSE, scale="", diag=1.5)
# All entries corresponding to the diagonals of K should be 0:
max(abs(sapply(1:p, function(j){c(elts_simplex_1$Gamma_K[j, (j-1)*p+1:p],
       elts_simplex_1$Gamma_K[, (j-1)*p+j])})))
max(abs(diag(elts_simplex_1$Gamma_K_eta)))
max(abs(diag(matrix(elts_simplex_1$g_K, nrow=p))))
</code></pre>

<hr>
<h2 id='get_elts_ab'>The R implementation to get the elements necessary for calculations for general a and b.</h2><span id='topic+get_elts_ab'></span>

<h3>Description</h3>

<p>The R implementation to get the elements necessary for calculations for general <code class="reqn">a</code> and <code class="reqn">b</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_elts_ab(
  hdx,
  hpdx,
  x,
  a,
  b,
  setting,
  centered = TRUE,
  profiled_if_noncenter = TRUE,
  scale = "",
  diagonal_multiplier = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_elts_ab_+3A_hdx">hdx</code></td>
<td>
<p>A matrix, <code class="reqn">h(\mathbf{x})</code> applied to the distance of x from the boundary of the domain, should be of the same dimension as <code>x</code>.</p>
</td></tr>
<tr><td><code id="get_elts_ab_+3A_hpdx">hpdx</code></td>
<td>
<p>A matrix, <code class="reqn">h'(\mathbf{x})</code> applied to the distance of x from the boundary of the domain, should be of the same dimension as <code>x</code>.</p>
</td></tr>
<tr><td><code id="get_elts_ab_+3A_x">x</code></td>
<td>
<p>An <code>n</code> by <code>p</code> matrix, the data matrix, where <code>n</code> is the sample size and <code>p</code> the dimension.</p>
</td></tr>
<tr><td><code id="get_elts_ab_+3A_a">a</code></td>
<td>
<p>A number, must be strictly larger than <code class="reqn">b/2</code>.</p>
</td></tr>
<tr><td><code id="get_elts_ab_+3A_b">b</code></td>
<td>
<p>A number, must be &gt;= 0.</p>
</td></tr>
<tr><td><code id="get_elts_ab_+3A_setting">setting</code></td>
<td>
<p>A string that indicates the distribution type. Returned without being checked or used in the function body.</p>
</td></tr>
<tr><td><code id="get_elts_ab_+3A_centered">centered</code></td>
<td>
<p>A boolean, whether in the centered setting (assume <code class="reqn">\boldsymbol{\mu}=\boldsymbol{\eta}=0</code>) or not. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_elts_ab_+3A_profiled_if_noncenter">profiled_if_noncenter</code></td>
<td>
<p>A boolean, whether in the profiled setting (<code class="reqn">\lambda_{\boldsymbol{\eta}}=0</code>) if non-centered. Parameter ignored if <code>centered=TRUE</code>. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_elts_ab_+3A_scale">scale</code></td>
<td>
<p>A string indicating the scaling method. Returned without being checked or used in the function body. Default to <code>"norm"</code>.</p>
</td></tr>
<tr><td><code id="get_elts_ab_+3A_diagonal_multiplier">diagonal_multiplier</code></td>
<td>
<p>A number &gt;= 1, the diagonal multiplier.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the <code class="reqn">\boldsymbol{\Gamma}</code> matrix and the <code class="reqn">\boldsymbol{g}</code> vector for generalized score matching.
</p>
<p>Here, <code class="reqn">\boldsymbol{\Gamma}</code> is block-diagonal, and in the non-profiled non-centered setting, the <code class="reqn">j</code>-th block is composed of <code class="reqn">\boldsymbol{\Gamma}_{\mathbf{KK},j}</code>, <code class="reqn">\boldsymbol{\Gamma}_{\mathbf{K}\boldsymbol{\eta},j}</code> and its transpose, and finally <code class="reqn">\boldsymbol{\Gamma}_{\boldsymbol{\eta\eta},j}</code>. In the centered case, only <code class="reqn">\boldsymbol{\Gamma}_{\mathbf{KK},j}</code> is computed. In the profiled non-centered case, </p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{\Gamma}_{j}\equiv\boldsymbol{\Gamma}_{\mathbf{KK},j}-\boldsymbol{\Gamma}_{\mathbf{K}\boldsymbol{\eta},j}\boldsymbol{\Gamma}_{\boldsymbol{\eta}\boldsymbol{\eta},j}^{-1}\boldsymbol{\Gamma}_{\mathbf{K}\boldsymbol{\eta}}^{\top}.</code>
</p>

<p>Similarly, in the non-profiled non-centered setting, <code class="reqn">\boldsymbol{g}</code> can be partitioned <code class="reqn">p</code> parts, each with a <code class="reqn">p</code>-vector <code class="reqn">\boldsymbol{g}_{\mathbf{K},j}</code> and a scalar <code class="reqn">g_{\boldsymbol{\eta},j}</code>. In the centered setting, only <code class="reqn">\boldsymbol{g}_{\mathbf{K},j}</code> is needed. In the profiled non-centered case, </p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{g}_j\equiv\boldsymbol{g}_{\mathbf{K},j}-\boldsymbol{\Gamma}_{\mathbf{K}\boldsymbol{\eta},j}\boldsymbol{\Gamma}_{\boldsymbol{\eta\eta},j}^{-1}g_{\boldsymbol{\eta},j}.</code>
</p>

<p>The formulae for the pieces above are
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{\Gamma}_{\mathbf{KK},j}\equiv\frac{1}{n}\sum_{i=1}^nh\left(X_j^{(i)}\right){X_j^{(i)}}^{2a-2}{\boldsymbol{X}^{(i)}}^a{{\boldsymbol{X}^{(i)}}^a}^{\top},</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{\Gamma}_{\mathbf{K}\boldsymbol{\eta},j}\equiv-\frac{1}{n}\sum_{i=1}^nh\left(X_j^{(i)}\right){X_j^{(i)}}^{a+b-2}{\boldsymbol{X}^{(i)}}^a,</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{\Gamma}_{\boldsymbol{\eta\eta},j}\equiv\frac{1}{n}\sum_{i=1}^nh\left(X_j^{(i)}\right){X_j^{(i)}}^{2b-2},</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{g}_{\mathbf{K},j}\equiv\frac{1}{n}\sum_{i=1}^n\left(h'\left(X_j^{(i)}\right){X_j^{(i)}}^{a-1}+(a-1)h\left(X_j^{(i)}\right){X_j^{(i)}}^{a-2}\right){\boldsymbol{X}^{(i)}}^a+ah\left(X_j^{(i)}\right){X_j^{(i)}}^{2a-2}\boldsymbol{e}_{j,p},</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{g}_{\boldsymbol{\eta},j}\equiv\frac{1}{n}\sum_{i=1}^n-h'\left(X_j^{(i)}\right){X_j^{(i)}}^{b-1}-(b-1)h\left(X_j^{(i)}\right){X_j^{(i)}}^{b-2},</code>
</p>

<p>where <code class="reqn">\boldsymbol{e}_{j,p}</code> is the <code class="reqn">p</code>-vector with 1 at the <code class="reqn">j</code>-th position and 0 elsewhere.
</p>
<p>In the profiled non-centered setting, the function also returns <code class="reqn">t_1</code> and <code class="reqn">t_2</code> defined as
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{t}_1\equiv\boldsymbol{\Gamma}_{\boldsymbol{\eta\eta}}^{-1}\boldsymbol{g}_{\boldsymbol{\eta}},\quad\boldsymbol{t}_2\equiv\boldsymbol{\Gamma}_{\boldsymbol{\eta\eta}}^{-1}\boldsymbol{\Gamma}_{\mathbf{K}\boldsymbol{\eta}}^{\top},</code>
</p>

<p>so that <code class="reqn">\hat{\boldsymbol{\eta}}=\boldsymbol{t}_1-\boldsymbol{t}_2\mathrm{vec}(\hat{\mathbf{K}}).</code>
</p>


<h3>Value</h3>

<p>A list that contains the elements necessary for estimation.
</p>
<table role = "presentation">
<tr><td><code>n</code></td>
<td>
<p>The sample size.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>The dimension.</p>
</td></tr>
<tr><td><code>centered</code></td>
<td>
<p>The centered setting or not. Same as input.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>The scaling method. Same as input.</p>
</td></tr>
<tr><td><code>diagonal_multiplier</code></td>
<td>
<p>The diagonal multiplier. Same as input.</p>
</td></tr>
<tr><td><code>diagonals_with_multiplier</code></td>
<td>
<p>A vector that contains the diagonal entries of <code class="reqn">\boldsymbol{\Gamma}</code> after applying the multiplier.</p>
</td></tr>
<tr><td><code>setting</code></td>
<td>
<p>The setting. Same as input.</p>
</td></tr>
<tr><td><code>g_K</code></td>
<td>
<p>The <code class="reqn">\boldsymbol{g}</code> vector. In the non-profiled non-centered setting, this is the <code class="reqn">\boldsymbol{g}</code> sub-vector corresponding to <code class="reqn">\mathbf{K}</code>.</p>
</td></tr>
<tr><td><code>Gamma_K</code></td>
<td>
<p>The <code class="reqn">\boldsymbol{\Gamma}</code> matrix with no diagonal multiplier. In the non-profiled non-centered setting, this is the <code class="reqn">\boldsymbol{\Gamma}</code> sub-matrix corresponding to <code class="reqn">\mathbf{K}</code>.</p>
</td></tr>
<tr><td><code>g_eta</code></td>
<td>
<p>Returned in the non-profiled non-centered setting. The <code class="reqn">\boldsymbol{g}</code> sub-vector corresponding to <code class="reqn">\boldsymbol{\eta}</code>.</p>
</td></tr>
<tr><td><code>Gamma_K_eta</code></td>
<td>
<p>Returned in the non-profiled non-centered setting. The <code class="reqn">\boldsymbol{\Gamma}</code> sub-matrix corresponding to interaction between <code class="reqn">\mathbf{K}</code> and <code class="reqn">\boldsymbol{\eta}</code>.</p>
</td></tr>
<tr><td><code>Gamma_eta</code></td>
<td>
<p>Returned in the non-profiled non-centered setting. The <code class="reqn">\boldsymbol{\Gamma}</code> sub-matrix corresponding to <code class="reqn">\boldsymbol{\eta}</code>.</p>
</td></tr>
<tr><td><code>t1</code>, <code>t2</code></td>
<td>
<p>Returned in the profiled non-centered setting, where the <code class="reqn">\boldsymbol{\eta}</code> estimate can be retrieved from <code class="reqn">\boldsymbol{t_1}-\boldsymbol{t_2}\hat{\mathbf{K}}</code> after appropriate resizing.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 50
p &lt;- 30
eta &lt;- rep(0, p)
K &lt;- diag(p)
domain &lt;- make_domain("R+", p=p)
x &lt;- gen(n, setting="ab_1/2_7/10", abs=FALSE, eta=eta, K=K, domain=domain, finite_infinity=100, 
       xinit=NULL, seed=2, burn_in=1000, thinning=100, verbose=FALSE)
h_hp &lt;- get_h_hp("min_pow", 1.5, 3)
h_hp_dx &lt;- h_of_dist(h_hp, x, domain) # h and h' applied to distance from x to boundary
elts &lt;- get_elts_ab(h_hp_dx$hdx, h_hp_dx$hpdx, x, a=0.5, b=0.7, setting="ab_1/2_7/10",
            centered=TRUE, scale="norm", diag=1.5)
elts &lt;- get_elts_ab(h_hp_dx$hdx, h_hp_dx$hpdx, x, a=0.5, b=0.7, setting="ab_1/2_7/10",
            centered=FALSE, profiled_if_noncenter=TRUE, scale="norm", diag=1.7)
elts &lt;- get_elts_ab(h_hp_dx$hdx, h_hp_dx$hpdx, x, a=0.5, b=0.7, setting="ab_1/2_7/10",
            centered=FALSE, profiled_if_noncenter=FALSE, scale="norm", diag=1.9)
</code></pre>

<hr>
<h2 id='get_elts_exp'>The R implementation to get the elements necessary for calculations for the exponential square-root setting (a=0.5, b=0.5).</h2><span id='topic+get_elts_exp'></span>

<h3>Description</h3>

<p>The R implementation to get the elements necessary for calculations for the exponential square-root setting (a=0.5, b=0.5).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_elts_exp(
  hdx,
  hpdx,
  x,
  centered = TRUE,
  profiled_if_noncenter = TRUE,
  scale = "",
  diagonal_multiplier = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_elts_exp_+3A_hdx">hdx</code></td>
<td>
<p>A matrix, <code class="reqn">h(\mathbf{x})</code> applied to the distance of x from the boundary of the domain, should be of the same dimension as <code>x</code>.</p>
</td></tr>
<tr><td><code id="get_elts_exp_+3A_hpdx">hpdx</code></td>
<td>
<p>A matrix, <code class="reqn">h'(\mathbf{x})</code> applied to the distance of x from the boundary of the domain, should be of the same dimension as <code>x</code>.</p>
</td></tr>
<tr><td><code id="get_elts_exp_+3A_x">x</code></td>
<td>
<p>An <code>n</code> by <code>p</code> matrix, the data matrix, where <code>n</code> is the sample size and <code>p</code> the dimension.</p>
</td></tr>
<tr><td><code id="get_elts_exp_+3A_centered">centered</code></td>
<td>
<p>A boolean, whether in the centered setting (assume <code class="reqn">\boldsymbol{\mu}=\boldsymbol{\eta}=0</code>) or not. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_elts_exp_+3A_profiled_if_noncenter">profiled_if_noncenter</code></td>
<td>
<p>A boolean, whether in the profiled setting (<code class="reqn">\lambda_{\boldsymbol{\eta}}=0</code>) if non-centered. Parameter ignored if centered=TRUE. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_elts_exp_+3A_scale">scale</code></td>
<td>
<p>A string indicating the scaling method. Returned without being checked or used in the function body. Default to <code>"norm"</code>.</p>
</td></tr>
<tr><td><code id="get_elts_exp_+3A_diagonal_multiplier">diagonal_multiplier</code></td>
<td>
<p>A number &gt;= 1, the diagonal multiplier.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on the returned values, please refer to <code>get_elts_ab</code> or <code>get_elts</code>.
</p>


<h3>Value</h3>

<p>A list that contains the elements necessary for estimation.
</p>
<table role = "presentation">
<tr><td><code>n</code></td>
<td>
<p>The sample size.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>The dimension.</p>
</td></tr>
<tr><td><code>centered</code></td>
<td>
<p>The centered setting or not. Same as input.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>The scaling method. Same as input.</p>
</td></tr>
<tr><td><code>diagonal_multiplier</code></td>
<td>
<p>The diagonal multiplier. Same as input.</p>
</td></tr>
<tr><td><code>diagonals_with_multiplier</code></td>
<td>
<p>A vector that contains the diagonal entries of <code class="reqn">\boldsymbol{\Gamma}</code> after applying the multiplier.</p>
</td></tr>
<tr><td><code>setting</code></td>
<td>
<p>The setting <code>"exp"</code>.</p>
</td></tr>
<tr><td><code>g_K</code></td>
<td>
<p>The <code class="reqn">\boldsymbol{g}</code> vector. In the non-profiled non-centered setting, this is the <code class="reqn">\boldsymbol{g}</code> sub-vector corresponding to <code class="reqn">\mathbf{K}</code>.</p>
</td></tr>
<tr><td><code>Gamma_K</code></td>
<td>
<p>The <code class="reqn">\boldsymbol{\Gamma}</code> matrix with no diagonal multiplier. In the non-profiled non-centered setting, this is the <code class="reqn">\boldsymbol{\Gamma}</code> sub-matrix corresponding to <code class="reqn">\mathbf{K}</code>.</p>
</td></tr>
<tr><td><code>g_eta</code></td>
<td>
<p>Returned in the non-profiled non-centered setting. The <code class="reqn">\boldsymbol{g}</code> sub-vector corresponding to <code class="reqn">\boldsymbol{\eta}</code>.</p>
</td></tr>
<tr><td><code>Gamma_K_eta</code></td>
<td>
<p>Returned in the non-profiled non-centered setting. The <code class="reqn">\boldsymbol{\Gamma}</code> sub-matrix corresponding to interaction between <code class="reqn">\mathbf{K}</code> and <code class="reqn">\boldsymbol{\eta}</code>.</p>
</td></tr>
<tr><td><code>Gamma_eta</code></td>
<td>
<p>Returned in the non-profiled non-centered setting. The <code class="reqn">\boldsymbol{\Gamma}</code> sub-matrix corresponding to <code class="reqn">\boldsymbol{\eta}</code>.</p>
</td></tr>
<tr><td><code>t1</code>, <code>t2</code></td>
<td>
<p>Returned in the profiled non-centered setting, where the <code class="reqn">\boldsymbol{\eta}</code> estimate can be retrieved from <code class="reqn">\boldsymbol{t_1}-\boldsymbol{t_2}\hat{\mathbf{K}}</code> after appropriate resizing.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 50
p &lt;- 30
eta &lt;- rep(0, p)
K &lt;- diag(p)
domain &lt;- make_domain("R+", p=p)
x &lt;- gen(n, setting="exp", abs=FALSE, eta=eta, K=K, domain=domain, finite_infinity=100,
       xinit=NULL, seed=2, burn_in=1000, thinning=100, verbose=FALSE)
h_hp &lt;- get_h_hp("min_pow", 1, 3)
h_hp_dx &lt;- h_of_dist(h_hp, x, domain) # h and h' applied to distance from x to boundary
elts &lt;- get_elts_exp(h_hp_dx$hdx, h_hp_dx$hpdx, x, centered=TRUE, scale="norm", diag=1.5)
elts &lt;- get_elts_exp(h_hp_dx$hdx, h_hp_dx$hpdx, x, centered=FALSE, profiled_if_noncenter=TRUE,
      scale="norm", diag=1.7)
elts &lt;- get_elts_exp(h_hp_dx$hdx, h_hp_dx$hpdx, x, centered=FALSE, profiled_if_noncenter=FALSE,
      scale="norm", diag=1.7)
</code></pre>

<hr>
<h2 id='get_elts_gamma'>The R implementation to get the elements necessary for calculations for the gamma setting (a=0.5, b=0).</h2><span id='topic+get_elts_gamma'></span>

<h3>Description</h3>

<p>The R implementation to get the elements necessary for calculations for the gamma setting (a=0.5, b=0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_elts_gamma(
  hdx,
  hpdx,
  x,
  centered = TRUE,
  profiled_if_noncenter = TRUE,
  scale = "",
  diagonal_multiplier = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_elts_gamma_+3A_hdx">hdx</code></td>
<td>
<p>A matrix, <code class="reqn">h(\mathbf{x})</code> applied to the distance of x from the boundary of the domain, should be of the same dimension as <code>x</code>.</p>
</td></tr>
<tr><td><code id="get_elts_gamma_+3A_hpdx">hpdx</code></td>
<td>
<p>A matrix, <code class="reqn">h'(\mathbf{x})</code> applied to the distance of x from the boundary of the domain, should be of the same dimension as <code>x</code>.</p>
</td></tr>
<tr><td><code id="get_elts_gamma_+3A_x">x</code></td>
<td>
<p>An <code>n</code> by <code>p</code> matrix, the data matrix, where <code>n</code> is the sample size and <code>p</code> the dimension.</p>
</td></tr>
<tr><td><code id="get_elts_gamma_+3A_centered">centered</code></td>
<td>
<p>A boolean, whether in the centered setting (assume <code class="reqn">\boldsymbol{\mu}=\boldsymbol{\eta}=0</code>) or not. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_elts_gamma_+3A_profiled_if_noncenter">profiled_if_noncenter</code></td>
<td>
<p>A boolean, whether in the profiled setting (<code class="reqn">\lambda_{\boldsymbol{\eta}}=0</code>) if non-centered. Parameter ignored if centered=TRUE. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_elts_gamma_+3A_scale">scale</code></td>
<td>
<p>A string indicating the scaling method. Returned without being checked or used in the function body. Default to <code>"norm"</code>.</p>
</td></tr>
<tr><td><code id="get_elts_gamma_+3A_diagonal_multiplier">diagonal_multiplier</code></td>
<td>
<p>A number &gt;= 1, the diagonal multiplier.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on the returned values, please refer to <code>get_elts_ab</code> or <code>get_elts</code>.
</p>


<h3>Value</h3>

<p>A list that contains the elements necessary for estimation.
</p>
<table role = "presentation">
<tr><td><code>n</code></td>
<td>
<p>The sample size.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>The dimension.</p>
</td></tr>
<tr><td><code>centered</code></td>
<td>
<p>The centered setting or not. Same as input.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>The scaling method. Same as input.</p>
</td></tr>
<tr><td><code>diagonal_multiplier</code></td>
<td>
<p>The diagonal multiplier. Same as input.</p>
</td></tr>
<tr><td><code>diagonals_with_multiplier</code></td>
<td>
<p>A vector that contains the diagonal entries of <code class="reqn">\boldsymbol{\Gamma}</code> after applying the multiplier.</p>
</td></tr>
<tr><td><code>setting</code></td>
<td>
<p>The setting <code>"gamma"</code>.</p>
</td></tr>
<tr><td><code>g_K</code></td>
<td>
<p>The <code class="reqn">\boldsymbol{g}</code> vector. In the non-profiled non-centered setting, this is the <code class="reqn">\boldsymbol{g}</code> sub-vector corresponding to <code class="reqn">\mathbf{K}</code>.</p>
</td></tr>
<tr><td><code>Gamma_K</code></td>
<td>
<p>The <code class="reqn">\boldsymbol{\Gamma}</code> matrix with no diagonal multiplier. In the non-profiled non-centered setting, this is the <code class="reqn">\boldsymbol{\Gamma}</code> sub-matrix corresponding to <code class="reqn">\mathbf{K}</code>.</p>
</td></tr>
<tr><td><code>g_eta</code></td>
<td>
<p>Returned in the non-profiled non-centered setting. The <code class="reqn">\boldsymbol{g}</code> sub-vector corresponding to <code class="reqn">\boldsymbol{\eta}</code>.</p>
</td></tr>
<tr><td><code>Gamma_K_eta</code></td>
<td>
<p>Returned in the non-profiled non-centered setting. The <code class="reqn">\boldsymbol{\Gamma}</code> sub-matrix corresponding to interaction between <code class="reqn">\mathbf{K}</code> and <code class="reqn">\boldsymbol{\eta}</code>.</p>
</td></tr>
<tr><td><code>Gamma_eta</code></td>
<td>
<p>Returned in the non-profiled non-centered setting. The <code class="reqn">\boldsymbol{\Gamma}</code> sub-matrix corresponding to <code class="reqn">\boldsymbol{\eta}</code>.</p>
</td></tr>
<tr><td><code>t1</code>, <code>t2</code></td>
<td>
<p>Returned in the profiled non-centered setting, where the <code class="reqn">\boldsymbol{\eta}</code> estimate can be retrieved from <code class="reqn">\boldsymbol{t_1}-\boldsymbol{t_2}\hat{\mathbf{K}}</code> after appropriate resizing.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 50
p &lt;- 30
eta &lt;- rep(0, p)
K &lt;- diag(p)
domain &lt;- make_domain("R+", p=p)
x &lt;- gen(n, setting="gamma", abs=FALSE, eta=eta, K=K, domain=domain, finite_infinity=100,
       xinit=NULL, seed=2, burn_in=1000, thinning=100, verbose=FALSE)
h_hp &lt;- get_h_hp("min_pow", 1.5, 3)
h_hp_dx &lt;- h_of_dist(h_hp, x, domain) # h and h' applied to distance from x to boundary
elts &lt;- get_elts_gamma(h_hp_dx$hdx, h_hp_dx$hpdx, x, centered=TRUE, scale="norm", diag=1.5)
elts &lt;- get_elts_gamma(h_hp_dx$hdx, h_hp_dx$hpdx, x, centered=FALSE, profiled_if_noncenter=TRUE,
       scale="norm", diag=1.7)
elts &lt;- get_elts_gamma(h_hp_dx$hdx, h_hp_dx$hpdx, x, centered=FALSE, profiled_if_noncenter=FALSE,
       scale="norm", diag=1.9)
</code></pre>

<hr>
<h2 id='get_elts_gauss'>The R implementation to get the elements necessary for calculations for the gaussian setting on R^p.</h2><span id='topic+get_elts_gauss'></span>

<h3>Description</h3>

<p>The R implementation to get the elements necessary for calculations for the gaussian setting on R^p.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_elts_gauss(
  x,
  centered = TRUE,
  profiled_if_noncenter = TRUE,
  scale = "",
  diagonal_multiplier = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_elts_gauss_+3A_x">x</code></td>
<td>
<p>An <code>n</code> by <code>p</code> matrix, the data matrix, where <code>n</code> is the sample size and <code>p</code> the dimension.</p>
</td></tr>
<tr><td><code id="get_elts_gauss_+3A_centered">centered</code></td>
<td>
<p>A boolean, whether in the centered setting (assume <code class="reqn">\boldsymbol{\mu}=\boldsymbol{\eta}=0</code>) or not. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_elts_gauss_+3A_profiled_if_noncenter">profiled_if_noncenter</code></td>
<td>
<p>A boolean, whether in the profiled setting (<code class="reqn">\lambda_{\boldsymbol{\eta}}=0</code>) if non-centered. Parameter ignored if <code>centered==TRUE</code>. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_elts_gauss_+3A_scale">scale</code></td>
<td>
<p>A string indicating the scaling method. Returned without being checked or used in the function body. Default to <code>"norm"</code>.</p>
</td></tr>
<tr><td><code id="get_elts_gauss_+3A_diagonal_multiplier">diagonal_multiplier</code></td>
<td>
<p>A number &gt;= 1, the diagonal multiplier.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on the returned values, please refer to <code>get_elts_ab</code> or <code>get_elts</code>.
</p>


<h3>Value</h3>

<p>A list that contains the elements necessary for estimation.
</p>
<table role = "presentation">
<tr><td><code>n</code></td>
<td>
<p>The sample size.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>The dimension.</p>
</td></tr>
<tr><td><code>centered</code></td>
<td>
<p>The centered setting or not. Same as input.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>The scaling method. Same as input.</p>
</td></tr>
<tr><td><code>diagonal_multiplier</code></td>
<td>
<p>The diagonal multiplier. Same as input.</p>
</td></tr>
<tr><td><code>diagonals_with_multiplier</code></td>
<td>
<p>A vector that contains the diagonal entries of <code class="reqn">\boldsymbol{\Gamma}</code> after applying the multiplier.</p>
</td></tr>
<tr><td><code>setting</code></td>
<td>
<p>The setting <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code>Gamma_K</code></td>
<td>
<p>The <code class="reqn">\boldsymbol{\Gamma}</code> matrix with no diagonal multiplier. In the non-profiled non-centered setting, this is the <code class="reqn">\boldsymbol{\Gamma}</code> sub-matrix corresponding to <code class="reqn">\mathbf{K}</code>. Except for the <em>profiled</em> setting, this is <code class="reqn">\mathbf{xx}^{\top}/n</code>.</p>
</td></tr>
<tr><td><code>Gamma_K_eta</code></td>
<td>
<p>Returned in the non-profiled non-centered setting. The <code class="reqn">\boldsymbol{\Gamma}</code> sub-matrix corresponding to interaction between <code class="reqn">\mathbf{K}</code> and <code class="reqn">\boldsymbol{\eta}</code>. The minus column means of <code>x</code>.</p>
</td></tr>
<tr><td><code>t1</code>, <code>t2</code></td>
<td>
<p>Returned in the profiled non-centered setting, where the<code class="reqn">\boldsymbol{\eta}</code> estimate can be retrieved from <code class="reqn">\boldsymbol{t_1}-\boldsymbol{t_2}\hat{\mathbf{K}}</code> after appropriate resizing.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 50
p &lt;- 30
mu &lt;- rep(0, p)
K &lt;- diag(p)
x &lt;- mvtnorm::rmvnorm(n, mean=mu, sigma=solve(K))
# Equivalently:

x2 &lt;- gen(n, setting="gaussian", abs=FALSE, eta=c(K%*%mu), K=K, domain=make_domain("R",p),
       finite_infinity=100, xinit=NULL, burn_in=1000, thinning=100, verbose=FALSE)

elts &lt;- get_elts_gauss(x, centered=TRUE, scale="norm", diag=1.5)
elts &lt;- get_elts_gauss(x, centered=FALSE, profiled=FALSE, scale="sd", diag=1.9)
</code></pre>

<hr>
<h2 id='get_elts_loglog'>The R implementation to get the elements necessary for calculations for the log-log setting (a=0, b=0).</h2><span id='topic+get_elts_loglog'></span>

<h3>Description</h3>

<p>The R implementation to get the elements necessary for calculations for the log-log setting (a=0, b=0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_elts_loglog(
  hdx,
  hpdx,
  x,
  setting,
  centered = TRUE,
  profiled_if_noncenter = TRUE,
  scale = "",
  diagonal_multiplier = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_elts_loglog_+3A_hdx">hdx</code></td>
<td>
<p>A matrix, <code class="reqn">h(\mathbf{x})</code> applied to the distance of x from the boundary of the domain, should be of the same dimension as <code>x</code>.</p>
</td></tr>
<tr><td><code id="get_elts_loglog_+3A_hpdx">hpdx</code></td>
<td>
<p>A matrix, <code class="reqn">h'(\mathbf{x})</code> applied to the distance of x from the boundary of the domain, should be of the same dimension as <code>x</code>.</p>
</td></tr>
<tr><td><code id="get_elts_loglog_+3A_x">x</code></td>
<td>
<p>An <code>n</code> by <code>p</code> matrix, the data matrix, where <code>n</code> is the sample size and <code>p</code> the dimension.</p>
</td></tr>
<tr><td><code id="get_elts_loglog_+3A_setting">setting</code></td>
<td>
<p>A string, log_log.</p>
</td></tr>
<tr><td><code id="get_elts_loglog_+3A_centered">centered</code></td>
<td>
<p>A boolean, whether in the centered setting (assume <code class="reqn">\boldsymbol{\mu}=\boldsymbol{\eta}=0</code>) or not. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_elts_loglog_+3A_profiled_if_noncenter">profiled_if_noncenter</code></td>
<td>
<p>A boolean, whether in the profiled setting (<code class="reqn">\lambda_{\boldsymbol{\eta}}=0</code>) if non-centered. Parameter ignored if centered=TRUE. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_elts_loglog_+3A_scale">scale</code></td>
<td>
<p>A string indicating the scaling method. Returned without being checked or used in the function body. Default to <code>"norm"</code>.</p>
</td></tr>
<tr><td><code id="get_elts_loglog_+3A_diagonal_multiplier">diagonal_multiplier</code></td>
<td>
<p>A number &gt;= 1, the diagonal multiplier.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on the returned values, please refer to <code>get_elts_ab</code> or <code>get_elts</code>.
</p>


<h3>Value</h3>

<p>A list that contains the elements necessary for estimation.
</p>
<table role = "presentation">
<tr><td><code>n</code></td>
<td>
<p>The sample size.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>The dimension.</p>
</td></tr>
<tr><td><code>centered</code></td>
<td>
<p>The centered setting or not. Same as input.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>The scaling method. Same as input.</p>
</td></tr>
<tr><td><code>diagonal_multiplier</code></td>
<td>
<p>The diagonal multiplier. Same as input.</p>
</td></tr>
<tr><td><code>diagonals_with_multiplier</code></td>
<td>
<p>A vector that contains the diagonal entries of <code class="reqn">\boldsymbol{\Gamma}</code> after applying the multiplier.</p>
</td></tr>
<tr><td><code>setting</code></td>
<td>
<p>The same setting as in the function argument.</p>
</td></tr>
<tr><td><code>g_K</code></td>
<td>
<p>The <code class="reqn">\boldsymbol{g}</code> vector. In the non-profiled non-centered setting, this is the <code class="reqn">\boldsymbol{g}</code> sub-vector corresponding to <code class="reqn">\mathbf{K}</code>.</p>
</td></tr>
<tr><td><code>Gamma_K</code></td>
<td>
<p>The <code class="reqn">\boldsymbol{\Gamma}</code> matrix with no diagonal multiplier. In the non-profiled non-centered setting, this is the <code class="reqn">\boldsymbol{\Gamma}</code> sub-matrix corresponding to <code class="reqn">\mathbf{K}</code>.</p>
</td></tr>
<tr><td><code>g_eta</code></td>
<td>
<p>Returned in the non-profiled non-centered setting. The <code class="reqn">\boldsymbol{g}</code> sub-vector corresponding to <code class="reqn">\boldsymbol{\eta}</code>.</p>
</td></tr>
<tr><td><code>Gamma_K_eta</code></td>
<td>
<p>Returned in the non-profiled non-centered setting. The <code class="reqn">\boldsymbol{\Gamma}</code> sub-matrix corresponding to interaction between <code class="reqn">\mathbf{K}</code> and <code class="reqn">\boldsymbol{\eta}</code>.</p>
</td></tr>
<tr><td><code>Gamma_eta</code></td>
<td>
<p>Returned in the non-profiled non-centered setting. The <code class="reqn">\boldsymbol{\Gamma}</code> sub-matrix corresponding to <code class="reqn">\boldsymbol{\eta}</code>.</p>
</td></tr>
<tr><td><code>t1</code>, <code>t2</code></td>
<td>
<p>Returned in the profiled non-centered setting, where the <code class="reqn">\boldsymbol{\eta}</code> estimate can be retrieved from <code class="reqn">\boldsymbol{t_1}-\boldsymbol{t_2}\hat{\mathbf{K}}</code> after appropriate resizing.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 50
p &lt;- 30
eta &lt;- rep(0, p)
K &lt;- diag(p)
domain &lt;- make_domain("uniform", p=p, lefts=c(0), rights=c(1))
x &lt;- gen(n, setting="log_log", abs=FALSE, eta=eta, K=K, domain=domain,
       xinit=NULL, seed=2, burn_in=1000, thinning=100, verbose=FALSE)
h_hp &lt;- get_h_hp("min_pow", 1.5, 3)
h_hp_dx &lt;- h_of_dist(h_hp, x, domain) # h and h' applied to distance from x to boundary
elts &lt;- get_elts_loglog(h_hp_dx$hdx, h_hp_dx$hpdx, x, setting="log_log", centered=TRUE,
       scale="", diag=1.5)
elts &lt;- get_elts_loglog(h_hp_dx$hdx, h_hp_dx$hpdx, x, setting="log_log", centered=FALSE,
       profiled_if_noncenter=TRUE, scale="", diag=1.7)
elts &lt;- get_elts_loglog(h_hp_dx$hdx, h_hp_dx$hpdx, x, setting="log_log", centered=FALSE,
       profiled_if_noncenter=FALSE, scale="", diag=1.9)
</code></pre>

<hr>
<h2 id='get_elts_loglog_simplex'>The R implementation to get the elements necessary for calculations for the log-log setting (a=0, b=0) on the p-simplex.</h2><span id='topic+get_elts_loglog_simplex'></span>

<h3>Description</h3>

<p>The R implementation to get the elements necessary for calculations for the log-log setting (a=0, b=0) on the p-simplex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_elts_loglog_simplex(
  hdx,
  hpdx,
  x,
  setting,
  centered = TRUE,
  profiled_if_noncenter = TRUE,
  scale = "",
  diagonal_multiplier = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_elts_loglog_simplex_+3A_hdx">hdx</code></td>
<td>
<p>A matrix, <code class="reqn">h(\mathbf{x})</code> applied to the distance of x from the boundary of the domain, should be of the same dimension as <code>x</code>.</p>
</td></tr>
<tr><td><code id="get_elts_loglog_simplex_+3A_hpdx">hpdx</code></td>
<td>
<p>A matrix, <code class="reqn">h'(\mathbf{x})</code> applied to the distance of x from the boundary of the domain, should be of the same dimension as <code>x</code>.</p>
</td></tr>
<tr><td><code id="get_elts_loglog_simplex_+3A_x">x</code></td>
<td>
<p>An <code>n</code> by <code>p</code> matrix, the data matrix, where <code>n</code> is the sample size and <code>p</code> the dimension.</p>
</td></tr>
<tr><td><code id="get_elts_loglog_simplex_+3A_setting">setting</code></td>
<td>
<p>A string, log_log or log_log_sum0. If log_log_sum0, assumes that the true K has row and column sums 0 (see the A^d model), so only the off-diagonal entries will be estimated; the diagonal entries will be profiled out in the loss), so elements corresponding to the diagonals of K will be set to 0, and the loss will be rewritten in the off-diagonal entries only.</p>
</td></tr>
<tr><td><code id="get_elts_loglog_simplex_+3A_centered">centered</code></td>
<td>
<p>A boolean, whether in the centered setting (assume <code class="reqn">\boldsymbol{\mu}=\boldsymbol{\eta}=0</code>) or not. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_elts_loglog_simplex_+3A_profiled_if_noncenter">profiled_if_noncenter</code></td>
<td>
<p>A boolean, whether in the profiled setting (<code class="reqn">\lambda_{\boldsymbol{\eta}}=0</code>) if non-centered. Parameter ignored if centered=TRUE. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_elts_loglog_simplex_+3A_scale">scale</code></td>
<td>
<p>A string indicating the scaling method. Returned without being checked or used in the function body. Default to <code>"norm"</code>.</p>
</td></tr>
<tr><td><code id="get_elts_loglog_simplex_+3A_diagonal_multiplier">diagonal_multiplier</code></td>
<td>
<p>A number &gt;= 1, the diagonal multiplier.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on the returned values, please refer to <code>get_elts_ab</code> or <code>get_elts</code>.
</p>


<h3>Value</h3>

<p>A list that contains the elements necessary for estimation.
</p>
<table role = "presentation">
<tr><td><code>n</code></td>
<td>
<p>The sample size.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>The dimension.</p>
</td></tr>
<tr><td><code>centered</code></td>
<td>
<p>The centered setting or not. Same as input.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>The scaling method. Same as input.</p>
</td></tr>
<tr><td><code>diagonal_multiplier</code></td>
<td>
<p>The diagonal multiplier. Same as input.</p>
</td></tr>
<tr><td><code>diagonals_with_multiplier</code></td>
<td>
<p>A vector that contains the diagonal entries of <code class="reqn">\boldsymbol{\Gamma}</code> after applying the multiplier.</p>
</td></tr>
<tr><td><code>setting</code></td>
<td>
<p>The same setting as in the function argument.</p>
</td></tr>
<tr><td><code>g_K</code></td>
<td>
<p>The <code class="reqn">\boldsymbol{g}</code> vector. In the non-profiled non-centered setting, this is the <code class="reqn">\boldsymbol{g}</code> sub-vector corresponding to <code class="reqn">\mathbf{K}</code>.</p>
</td></tr>
<tr><td><code>Gamma_K</code></td>
<td>
<p>The <code class="reqn">\boldsymbol{\Gamma}</code> matrix with no diagonal multiplier. In the non-profiled non-centered setting, this is the <code class="reqn">\boldsymbol{\Gamma}</code> sub-matrix corresponding to <code class="reqn">\mathbf{K}</code>.</p>
</td></tr>
<tr><td><code>g_eta</code></td>
<td>
<p>Returned in the non-profiled non-centered setting. The <code class="reqn">\boldsymbol{g}</code> sub-vector corresponding to <code class="reqn">\boldsymbol{\eta}</code>.</p>
</td></tr>
<tr><td><code>Gamma_K_eta</code></td>
<td>
<p>Returned in the non-profiled non-centered setting. The <code class="reqn">\boldsymbol{\Gamma}</code> sub-matrix corresponding to interaction between <code class="reqn">\mathbf{K}</code> and <code class="reqn">\boldsymbol{\eta}</code>.</p>
</td></tr>
<tr><td><code>Gamma_eta</code></td>
<td>
<p>Returned in the non-profiled non-centered setting. The <code class="reqn">\boldsymbol{\Gamma}</code> sub-matrix corresponding to <code class="reqn">\boldsymbol{\eta}</code>.</p>
</td></tr>
<tr><td><code>t1</code>, <code>t2</code></td>
<td>
<p>Returned in the profiled non-centered setting, where the <code class="reqn">\boldsymbol{\eta}</code> estimate can be retrieved from <code class="reqn">\boldsymbol{t_1}-\boldsymbol{t_2}\hat{\mathbf{K}}</code> after appropriate resizing.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 50
p &lt;- 30
eta &lt;- rep(0, p)
K &lt;- -cov_cons("band", p=p, spars=3, eig=1)
diag(K) &lt;- diag(K) - rowSums(K) # So that rowSums(K) == colSums(K) == 0
eigen(K)$val[(p-1):p] # Make sure K has one 0 and p-1 positive eigenvalues
domain &lt;- make_domain("simplex", p=p)
x &lt;- gen(n, setting="log_log_sum0", abs=FALSE, eta=eta, K=K, domain=domain,
       xinit=NULL, seed=2, burn_in=1000, thinning=100, verbose=FALSE)
h_hp &lt;- get_h_hp("min_pow", 2, 3)
h_hp_dx &lt;- h_of_dist(h_hp, x, domain) # h and h' applied to distance from x to boundary

elts_simplex_0 &lt;- get_elts_loglog_simplex(h_hp_dx$hdx, h_hp_dx$hpdx, x,
       setting="log_log", centered=FALSE, profiled=FALSE, scale="", diag=1.5)

# If want K to have row sums and column sums equal to 0; estimate off-diagonals only
elts_simplex_1 &lt;- get_elts_loglog_simplex(h_hp_dx$hdx, h_hp_dx$hpdx, x,
       setting="log_log_sum0", centered=FALSE, profiled=FALSE, scale="", diag=1.5)
# All entries corresponding to the diagonals of K should be 0:
max(abs(sapply(1:p, function(j){c(elts_simplex_1$Gamma_K[j, (j-1)*p+1:p],
       elts_simplex_1$Gamma_K[, (j-1)*p+j])})))
max(abs(diag(elts_simplex_1$Gamma_K_eta)))
max(abs(diag(matrix(elts_simplex_1$g_K, nrow=p))))
</code></pre>

<hr>
<h2 id='get_elts_trun_gauss'>The R implementation to get the elements necessary for calculations for the gaussian setting (a=1, b=1) on domains other than R^p.</h2><span id='topic+get_elts_trun_gauss'></span>

<h3>Description</h3>

<p>The R implementation to get the elements necessary for calculations for the gaussian setting (a=1, b=1) on domains other than R^p.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_elts_trun_gauss(
  hdx,
  hpdx,
  x,
  centered = TRUE,
  profiled_if_noncenter = TRUE,
  scale = "",
  diagonal_multiplier = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_elts_trun_gauss_+3A_hdx">hdx</code></td>
<td>
<p>A matrix, <code class="reqn">h(\mathbf{x})</code> applied to the distance of x from the boundary of the domain, should be of the same dimension as <code>x</code>.</p>
</td></tr>
<tr><td><code id="get_elts_trun_gauss_+3A_hpdx">hpdx</code></td>
<td>
<p>A matrix, <code class="reqn">h'(\mathbf{x})</code> applied to the distance of x from the boundary of the domain, should be of the same dimension as <code>x</code>.</p>
</td></tr>
<tr><td><code id="get_elts_trun_gauss_+3A_x">x</code></td>
<td>
<p>An <code>n</code> by <code>p</code> matrix, the data matrix, where <code>n</code> is the sample size and <code>p</code> the dimension.</p>
</td></tr>
<tr><td><code id="get_elts_trun_gauss_+3A_centered">centered</code></td>
<td>
<p>A boolean, whether in the centered setting (assume <code class="reqn">\boldsymbol{\mu}=\boldsymbol{\eta}=0</code>) or not. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_elts_trun_gauss_+3A_profiled_if_noncenter">profiled_if_noncenter</code></td>
<td>
<p>A boolean, whether in the profiled setting (<code class="reqn">\lambda_{\boldsymbol{\eta}}=0</code>) if non-centered. Parameter ignored if centered=TRUE. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_elts_trun_gauss_+3A_scale">scale</code></td>
<td>
<p>A string indicating the scaling method. Returned without being checked or used in the function body. Default to <code>"norm"</code>.</p>
</td></tr>
<tr><td><code id="get_elts_trun_gauss_+3A_diagonal_multiplier">diagonal_multiplier</code></td>
<td>
<p>A number &gt;= 1, the diagonal multiplier.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on the returned values, please refer to <code>get_elts_ab</code> or <code>get_elts</code>.
</p>


<h3>Value</h3>

<p>A list that contains the elements necessary for estimation.
</p>
<table role = "presentation">
<tr><td><code>n</code></td>
<td>
<p>The sample size.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>The dimension.</p>
</td></tr>
<tr><td><code>centered</code></td>
<td>
<p>The centered setting or not. Same as input.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>The scaling method. Same as input.</p>
</td></tr>
<tr><td><code>diagonal_multiplier</code></td>
<td>
<p>The diagonal multiplier. Same as input.</p>
</td></tr>
<tr><td><code>diagonals_with_multiplier</code></td>
<td>
<p>A vector that contains the diagonal entries of <code class="reqn">\boldsymbol{\Gamma}</code> after applying the multiplier.</p>
</td></tr>
<tr><td><code>setting</code></td>
<td>
<p>The setting <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code>g_K</code></td>
<td>
<p>The <code class="reqn">\boldsymbol{g}</code> vector. In the non-profiled non-centered setting, this is the <code class="reqn">\boldsymbol{g}</code> sub-vector corresponding to <code class="reqn">\mathbf{K}</code>.</p>
</td></tr>
<tr><td><code>Gamma_K</code></td>
<td>
<p>The <code class="reqn">\boldsymbol{\Gamma}</code> matrix with no diagonal multiplier. In the non-profiled non-centered setting, this is the <code class="reqn">\boldsymbol{\Gamma}</code> sub-matrix corresponding to <code class="reqn">\mathbf{K}</code>.</p>
</td></tr>
<tr><td><code>g_eta</code></td>
<td>
<p>Returned in the non-profiled non-centered setting. The <code class="reqn">\boldsymbol{g}</code> sub-vector corresponding to <code class="reqn">\boldsymbol{\eta}</code>.</p>
</td></tr>
<tr><td><code>Gamma_K_eta</code></td>
<td>
<p>Returned in the non-profiled non-centered setting. The <code class="reqn">\boldsymbol{\Gamma}</code> sub-matrix corresponding to interaction between <code class="reqn">\mathbf{K}</code> and <code class="reqn">\boldsymbol{\eta}</code>.</p>
</td></tr>
<tr><td><code>Gamma_eta</code></td>
<td>
<p>Returned in the non-profiled non-centered setting. The <code class="reqn">\boldsymbol{\Gamma}</code> sub-matrix corresponding to <code class="reqn">\boldsymbol{\eta}</code>.</p>
</td></tr>
<tr><td><code>t1</code>, <code>t2</code></td>
<td>
<p>Returned in the profiled non-centered setting, where the <code class="reqn">\boldsymbol{\eta}</code> estimate can be retrieved from <code class="reqn">\boldsymbol{t_1}-\boldsymbol{t_2}\hat{\mathbf{K}}</code> after appropriate resizing.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 50
p &lt;- 30
mu &lt;- rep(0, p)
K &lt;- diag(p)
eta &lt;- K %*% mu
domain &lt;- make_domain("R+", p=p)
x &lt;- gen(n, setting="gaussian", abs=FALSE, eta=eta, K=K, domain=domain, finite_infinity=100, 
       xinit=NULL, seed=2, burn_in=1000, thinning=100, verbose=FALSE)
h_hp &lt;- get_h_hp("min_pow", 1, 3)
h_hp_dx &lt;- h_of_dist(h_hp, x, domain) # h and h' applied to distance from x to boundary
elts &lt;- get_elts_trun_gauss(h_hp_dx$hdx, h_hp_dx$hpdx, x, centered=TRUE, scale="norm", diag=1.5)
elts &lt;- get_elts_trun_gauss(h_hp_dx$hdx, h_hp_dx$hpdx, x, centered=FALSE,
       profiled_if_noncenter=TRUE, scale="norm", diag=1.7)
elts &lt;- get_elts_trun_gauss(h_hp_dx$hdx, h_hp_dx$hpdx, x, centered=FALSE,
       profiled_if_noncenter=FALSE, scale="norm", diag=1.9)
</code></pre>

<hr>
<h2 id='get_g0'>Calculates the l2 distance to the boundary of the domain and its gradient for some domains.</h2><span id='topic+get_g0'></span>

<h3>Description</h3>

<p>Calculates the l2 distance to the boundary of the domain and its gradient for some domains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_g0(domain, C)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_g0_+3A_domain">domain</code></td>
<td>
<p>A list returned from <code>make_domain()</code> that represents the domain.</p>
</td></tr>
<tr><td><code id="get_g0_+3A_c">C</code></td>
<td>
<p>A positive number, cannot be <code>Inf</code> if <code>domain$type == "R"</code>. If not <code>Inf</code>, the l2 distance will be truncated to <code>C</code>, i.e. the function returns <code>pmin(g0(x), C)</code> and its gradient.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the l2 distance to the boundary of the domain, with the distance truncated above by a constant <code>C</code>. Matches the <code>g0</code> function and its gradient from Liu (2019) if <code>C == Inf</code> and domain is bounded.
Currently only R, R+, simplex, uniform and polynomial-type domains of the form sum(x^2) &lt;= d or sum(x^2) &gt;= d or sum(abs(x)) &lt;= d are implemented.
</p>


<h3>Value</h3>

<p>A function that takes <code>x</code> and returns a list of a vector <code>g0</code> and a matrix <code>g0d</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 15
p &lt;- 5
K &lt;- diag(p)
eta &lt;- numeric(p)

domain &lt;- make_domain("R", p=p)
x &lt;- gen(n, "gaussian", FALSE, eta, K, domain, 100)
get_g0(domain, 1)(x)

domain &lt;- make_domain("R+", p=p)
x &lt;- gen(n, "gaussian", FALSE, eta, K, domain, 100)
get_g0(domain, 1)(x)

domain &lt;- make_domain("uniform", p=p, lefts=c(-Inf,-3,3), rights=c(-5,1,Inf))
x &lt;- gen(n, "gaussian", FALSE, eta, K, domain, 100)
get_g0(domain, 1)(x)

domain &lt;- make_domain("simplex", p=p)
x &lt;- gen(n, "gaussian", FALSE, eta, K, domain, 100)
max(abs(get_g0(domain, 1)(x)$g0 - get_g0(domain, 1)(x[,-p])$g0))
max(abs(get_g0(domain, 1)(x)$g0d - get_g0(domain, 1)(x[,-p])$g0d))

domain &lt;- make_domain("polynomial", p=p, ineqs=
     list(list("expression"="sum(x^2)&gt;1.3", "nonnegative"=FALSE, "abs"=FALSE)))
x &lt;- gen(n, "gaussian", FALSE, eta, K, domain, 100)
get_g0(domain, 1)(x)

domain &lt;- make_domain("polynomial", p=p, ineqs=
     list(list("expression"="sum(x^2)&gt;1.3", "nonnegative"=TRUE, "abs"=FALSE)))
x &lt;- gen(n, "gaussian", FALSE, eta, K, domain, 100)
get_g0(domain, 1)(x)

domain &lt;- make_domain("polynomial", p=p, ineqs=
     list(list("expression"="sum(x^2)&lt;1.3", "nonnegative"=FALSE, "abs"=FALSE)))
x &lt;- gen(n, "gaussian", FALSE, eta, K, domain, 100)
get_g0(domain, 1)(x)

domain &lt;- make_domain("polynomial", p=p, ineqs=
     list(list("expression"="sum(x^2)&lt;1.3", "nonnegative"=TRUE, "abs"=FALSE)))
x &lt;- gen(n, "gaussian", FALSE, eta, K, domain, 100)
get_g0(domain, 1)(x)

domain &lt;- make_domain("polynomial", p=p, ineqs=
     list(list("expression"="sum(x)&lt;1.3", "nonnegative"=FALSE, "abs"=TRUE)))
x &lt;- gen(n, "gaussian", FALSE, eta, K, domain, 100)
get_g0(domain, 1)(x)

domain &lt;- make_domain("polynomial", p=p, ineqs=
     list(list("expression"="sum(x)&lt;1.3", "nonnegative"=TRUE, "abs"=TRUE)))
x &lt;- gen(n, "gaussian", FALSE, eta, K, domain, 100)
get_g0(domain, 1)(x)

</code></pre>

<hr>
<h2 id='get_g0_ada'>Adaptively truncates the l2 distance to the boundary of the domain and its gradient for some domains.</h2><span id='topic+get_g0_ada'></span>

<h3>Description</h3>

<p>Adaptively truncates the l2 distance to the boundary of the domain and its gradient for some domains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_g0_ada(domain, percentile)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_g0_ada_+3A_domain">domain</code></td>
<td>
<p>A list returned from <code>make_domain()</code> that represents the domain.</p>
</td></tr>
<tr><td><code id="get_g0_ada_+3A_percentile">percentile</code></td>
<td>
<p>A number between 0 and 1, the percentile. The returned l2 distance will be truncated to its <code>percentile</code>-th quantile, i.e. the function returns <code>pmin(g0(x), stats::quantile(g0(x), percentile))</code> and its gradient. The quantile is calculated using finite values only, and if no finite values exist the quantile is set to 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the l2 distance to the boundary of the domain, with the distance truncated above at a specified quantile. Matches the <code>g0</code> function and its gradient from Liu (2019) if <code>percentile == 1</code> and domain is bounded.
Currently only R, R+, simplex, uniform and polynomial-type domains of the form sum(x^2) &lt;= d or sum(x^2) &gt;= d or sum(abs(x)) &lt;= d are implemented.
</p>


<h3>Value</h3>

<p>A function that takes <code>x</code> and returns a list of a vector <code>g0</code> and a matrix <code>g0d</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 15
p &lt;- 5
K &lt;- diag(p)
eta &lt;- numeric(p)

domain &lt;- make_domain("R", p=p)
x &lt;- gen(n, "gaussian", FALSE, eta, K, domain, 100)
get_g0_ada(domain, 0.3)(x)

domain &lt;- make_domain("R+", p=p)
x &lt;- gen(n, "gaussian", FALSE, eta, K, domain, 100)
get_g0_ada(domain, 0.3)(x)

domain &lt;- make_domain("uniform", p=p, lefts=c(-Inf,-3,3), rights=c(-5,1,Inf))
x &lt;- gen(n, "gaussian", FALSE, eta, K, domain, 100)
get_g0_ada(domain, 0.6)(x)

domain &lt;- make_domain("simplex", p=p)
x &lt;- gen(n, "gaussian", FALSE, eta, K, domain, 100)
max(abs(get_g0_ada(domain, 0.4)(x)$g0 - get_g0_ada(domain, 0.4)(x[,-p])$g0))
max(abs(get_g0_ada(domain, 0.4)(x)$g0d - get_g0_ada(domain, 0.4)(x[,-p])$g0d))

domain &lt;- make_domain("polynomial", p=p, ineqs=
     list(list("expression"="sum(x^2)&gt;1.3", "nonnegative"=FALSE, "abs"=FALSE)))
x &lt;- gen(n, "gaussian", FALSE, eta, K, domain, 100)
get_g0_ada(domain, 0.5)(x)

domain &lt;- make_domain("polynomial", p=p, ineqs=
     list(list("expression"="sum(x^2)&gt;1.3", "nonnegative"=TRUE, "abs"=FALSE)))
x &lt;- gen(n, "gaussian", FALSE, eta, K, domain, 100)
get_g0_ada(domain, 0.7)(x)

domain &lt;- make_domain("polynomial", p=p, ineqs=
     list(list("expression"="sum(x^2)&lt;1.3", "nonnegative"=FALSE, "abs"=FALSE)))
x &lt;- gen(n, "gaussian", FALSE, eta, K, domain, 100)
get_g0_ada(domain, 0.6)(x)

domain &lt;- make_domain("polynomial", p=p, ineqs=
     list(list("expression"="sum(x^2)&lt;1.3", "nonnegative"=TRUE, "abs"=FALSE)))
x &lt;- gen(n, "gaussian", FALSE, eta, K, domain, 100)
get_g0_ada(domain, 0.25)(x)

domain &lt;- make_domain("polynomial", p=p, ineqs=
     list(list("expression"="sum(x)&lt;1.3", "nonnegative"=FALSE, "abs"=TRUE)))
x &lt;- gen(n, "gaussian", FALSE, eta, K, domain, 100)
get_g0_ada(domain, 0.37)(x)

domain &lt;- make_domain("polynomial", p=p, ineqs=
     list(list("expression"="sum(x)&lt;1.3", "nonnegative"=TRUE, "abs"=TRUE)))
x &lt;- gen(n, "gaussian", FALSE, eta, K, domain, 100)
get_g0_ada(domain, 0.45)(x)

</code></pre>

<hr>
<h2 id='get_h_hp'>Generator of h and hp (derivative of h) functions.</h2><span id='topic+get_h_hp'></span>

<h3>Description</h3>

<p>Generator of <code>h</code> and <code>hp</code> (derivative of <code class="reqn">h</code>) functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_h_hp(mode, para = NULL, para2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_h_hp_+3A_mode">mode</code></td>
<td>
<p>A string, see details.</p>
</td></tr>
<tr><td><code id="get_h_hp_+3A_para">para</code></td>
<td>
<p>May be optional. A number, the first parameter. Default to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get_h_hp_+3A_para2">para2</code></td>
<td>
<p>May be optional. A number, the second parameter. If <code>mode</code> is one of the adaptive mode below, this specifies the percentile (see details). Default to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>mode</code> parameter can be chosen from the options listed below along with the corresponding definitions of <code>h</code> under appropriate choices of <code>para</code> and <code>para2</code> parameters. Unless otherwise noted, <code>para</code> and <code>para2</code>, must both be strictly positive if provided, and are set to 1 if not provided. Functions <code>h</code> and <code>hp</code> should only be applied to non-negative values <code>x</code> and this is not enforced or checked by the functions.
Internally calls <code>get_h_hp_vector</code>.
</p>

<dl>
<dt><code>asinh</code></dt><dd><p>An asinh function <code class="reqn">\boldsymbol{h}(\boldsymbol{x})=\mathrm{asinh}(\mathrm{para}\cdot\boldsymbol{x})=\log\left(\mathrm{para}\cdot\boldsymbol{x}+\sqrt{(\mathrm{para}\cdot\boldsymbol{x})^2+1}\right)</code>. Unbounded and takes one parameter. Equivalent to <code>min_asinh(x, para, Inf)</code>.</p>
</dd>
<dt><code>cosh</code></dt><dd><p>A shifted cosh function <code class="reqn">\boldsymbol{h}(\boldsymbol{x})=\cosh(\mathrm{para}\cdot\boldsymbol{x})-1</code>. Unbounded and takes one parameter. Equivalent to <code>min_cosh(x, para, Inf)</code>.</p>
</dd>
<dt><code>exp</code></dt><dd><p>A shifted exponential function <code class="reqn">\boldsymbol{h}(\boldsymbol{x})=\exp(\mathrm{para}\cdot\boldsymbol{x})-1</code>. Unbounded and takes one parameter. Equivalent to <code>min_exp(x, para, Inf)</code>.</p>
</dd>
<dt><code>identity</code></dt><dd><p>The identity function <code class="reqn">\boldsymbol{h}(\boldsymbol{x})=\boldsymbol{x}</code>. Unbounded and does not take any parameter. Equivalent to <code>pow(x, 1)</code> or <code>min_pow(x, 1, Inf)</code>.</p>
</dd>
<dt><code>log_pow</code></dt><dd><p>A power function on a log scale <code class="reqn">\boldsymbol{h}(\boldsymbol{x})=\log(1+\boldsymbol{x})^{\mathrm{para}}</code>. Unbounded and takes one parameter. Equivalent to <code>min_log_pow(x, para, Inf)</code>.</p>
</dd>
<dt><code>mcp</code></dt><dd><p>Treating <code class="reqn">\lambda</code>=para, <code class="reqn">\gamma</code>=para2, the step-wise MCP function applied element-wise: <code class="reqn">\lambda x-x^2/(2\gamma)</code> if <code class="reqn">x\leq\lambda\gamma</code>, or <code class="reqn">\gamma\lambda^2/2</code> otherwise. Bounded and takes two parameters.</p>
</dd>
<dt><code>min_asinh</code></dt><dd><p>A truncated asinh function applied element-wise: <code class="reqn">\min(\mathrm{asinh}(\mathrm{para}\cdot\boldsymbol{x}),\mathrm{para}_2)</code>. Bounded and takes two parameters.</p>
</dd>
<dt><code>min_asinh_ada</code></dt><dd><p>Adaptive version of <code>min_asinh</code>.</p>
</dd>
<dt><code>min_cosh</code></dt><dd><p>A truncated shifted cosh function applied element-wise: <code class="reqn">\min(\cosh(\mathrm{para}\cdot\boldsymbol{x})-1,\mathrm{para}_2)</code>. Bounded and takes two parameters.</p>
</dd>
<dt><code>min_cosh_ada</code></dt><dd><p>Adaptive version of <code>min_cosh</code>.</p>
</dd>
<dt><code>min_exp</code></dt><dd><p>A truncated shifted exponential function applied element-wise: <code class="reqn">\boldsymbol{h}(\boldsymbol{x})=\min(\exp(\mathrm{para}\cdot\boldsymbol{x})-1,\mathrm{para}_2)</code>. Bounded and takes two parameters.</p>
</dd>
<dt><code>min_exp_ada</code></dt><dd><p>Adaptive version of <code>min_exp</code>.</p>
</dd>
<dt><code>min_log_pow</code></dt><dd><p>A truncated power on a log scale applied element-wise: <code class="reqn">\boldsymbol{h}(\boldsymbol{x})=\min(\log(1+\boldsymbol{x}),\mathrm{para}_2)^{\mathrm{para}}</code>. Bounded and takes two parameters.</p>
</dd>
<dt><code>min_log_pow_ada</code></dt><dd><p>Adaptive version of <code>min_log_pow</code>.</p>
</dd>
<dt><code>min_pow</code></dt><dd><p>A truncated power function applied element-wise: <code class="reqn">\boldsymbol{h}(\boldsymbol{x})=\min(\boldsymbol{x},\mathrm{para}_2)^{\mathrm{para}}</code>. Bounded and takes two parameters.</p>
</dd>
<dt><code>min_pow_ada</code></dt><dd><p>Adaptive version of <code>min_pow</code>.</p>
</dd>
<dt><code>min_sinh</code></dt><dd><p>A truncated sinh function applied element-wise: <code class="reqn">\min(\sinh(\mathrm{para}\cdot\boldsymbol{x}),\mathrm{para}_2)</code>. Bounded and takes two parameters.</p>
</dd>
<dt><code>min_sinh_ada</code></dt><dd><p>Adaptive version of <code>min_sinh</code>.</p>
</dd>
<dt><code>min_softplus</code></dt><dd><p>A truncated shifted softplus function applied element-wise: <code class="reqn">\min(\log(1+\exp(\mathrm{para}\cdot\boldsymbol{x}))-\log(2),\mathrm{para}_2)</code>. Bounded and takes two parameters.</p>
</dd>
<dt><code>min_softplus_ada</code></dt><dd><p>Adaptive version of <code>min_softplus</code>.</p>
</dd>
<dt><code>pow</code></dt><dd><p>A power function <code class="reqn">\boldsymbol{h}(\boldsymbol{x})=\boldsymbol{x}^{\mathrm{para}}</code>. Unbounded and takes two parameter. Equivalent to <code>min_pow(x, para, Inf)</code>.</p>
</dd>
<dt><code>scad</code></dt><dd><p>Treating <code class="reqn">\lambda</code>=para, <code class="reqn">\gamma</code>=para2, the step-wise SCAD function applied element-wise: <code class="reqn">\lambda x</code> if <code class="reqn">x\leq\lambda</code>, or <code class="reqn">(2\gamma\lambda x-x^2-\lambda^2)/(2(\gamma-1))</code> if <code class="reqn">\lambda&lt;x&lt;\gamma\lambda</code>, or <code class="reqn">\lambda^2(\gamma+1)/2</code> otherwise. Bounded and takes two parameters, where <code>para2</code> must be larger than 1, and will be set to 2 by default if not provided.</p>
</dd>
<dt><code>sinh</code></dt><dd><p>A sinh function <code class="reqn">\boldsymbol{h}(\boldsymbol{x})=\sinh(\mathrm{para}\cdot\boldsymbol{x})</code>. Unbounded and takes one parameter. Equivalent to <code>min_sinh(x, para, Inf)</code>.</p>
</dd>
<dt><code>softplus</code></dt><dd><p>A shifted softplus function <code class="reqn">\boldsymbol{h}(\boldsymbol{x})=\log(1+\exp(\mathrm{para}\cdot\boldsymbol{x}))-\log(2)</code>. Unbounded and takes one parameter. Equivalent to <code>min_softplus(x, para, Inf)</code>.</p>
</dd>
<dt><code>tanh</code></dt><dd><p>A tanh function <code class="reqn">\boldsymbol{h}(\boldsymbol{x})=\tanh(\mathrm{para}\cdot\boldsymbol{x})</code>. Bounded and takes one parameter.</p>
</dd>
<dt><code>truncated_sin</code></dt><dd><p>A truncated sin function applied element-wise: <code class="reqn">\sin(\mathrm{para}\cdot x)</code> if <code class="reqn">\mathrm{para}\cdot x\leq\pi/2</code>, or 1 otherwise. Bounded and takes one parameter.</p>
</dd>
<dt><code>truncated_tan</code></dt><dd><p>A truncated tan function applied element-wise: <code class="reqn">\tan(\mathrm{para}\cdot x)</code> if <code class="reqn">\mathrm{para}\cdot x\leq\pi/4</code>, or 1 otherwise. Bounded and takes one parameter.</p>
</dd>
</dl>

<p>For the adaptive modes (names ending with <code>"_ada"</code>), <code>h</code> and <code>hp</code> are first applied to <code>x</code> without truncation. Then inside each column, values that are larger than the <code>para2</code>-th quantile will be truncated. The quantile is calculated using finite values only, and if no finite values exist the quantile is set to 1.
For example, if <code>mode == "min_pow_ada"</code>, <code>para == 2</code>, <code>para2 == 0.4</code>, the <code>j</code>-th column of the returned <code>hx</code> will be <code>pmin(x[,j]^2, stats::quantile(x[,j]^2, 0.4))</code>, and the <code>j</code>-th column of <code>hpx</code> will be <code>2*x[,j]*(x[,j] &lt;= stats::quantile(x[,j]^2, 0.4))</code>.
</p>


<h3>Value</h3>

<p>A function that returns a list containing <code>hx=h(x)</code> (element-wise) and <code>hpx=hp(x)</code> (element-wise derivative of <code class="reqn">h</code>) when applied to a vector (for mode names not ending with <code>"_ada"</code> only) or a matrix <code>x</code>, with both of the results having the same shape as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_h_hp("mcp", 2, 4)(0:10)
get_h_hp("min_log_pow", 1, log(1+3))(matrix(0:11, nrow=3))
get_h_hp("min_pow", 1.5, 3)(seq(0, 5, by=0.5))
get_h_hp("min_softplus")(matrix(seq(0, 2, by=0.1), nrow=7))

get_h_hp("min_log_pow_ada", 1, 0.4)(matrix(0:49, nrow=10))
get_h_hp("min_pow_ada", 2, 0.3)(matrix(0:49, nrow=10))
get_h_hp("min_softplus_ada", 2, 0.6)(matrix(seq(0, 0.49, by=0.01), nrow=10))
</code></pre>

<hr>
<h2 id='get_h_hp_adaptive'>Generator of adaptive h and hp (derivative of h) functions.</h2><span id='topic+get_h_hp_adaptive'></span>

<h3>Description</h3>

<p>Generator of adaptive <code>h</code> and <code>hp</code> (derivative of <code class="reqn">h</code>) functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_h_hp_adaptive(mode, para, percentile)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_h_hp_adaptive_+3A_mode">mode</code></td>
<td>
<p>A string, the corresponding mode (with the suffix <code>"_ada"</code> removed from the input to <code>get_h_hp()</code>). Must be one of the modes starting with <code>"min_"</code> supported by <code>get_h_hp_vector()</code>.</p>
</td></tr>
<tr><td><code id="get_h_hp_adaptive_+3A_para">para</code></td>
<td>
<p>Must be provided, but can be <code>NULL</code>. A number, the first parameter; see <code>get_h_hp()</code> or <code>get_h_hp_vector()</code>.</p>
</td></tr>
<tr><td><code id="get_h_hp_adaptive_+3A_percentile">percentile</code></td>
<td>
<p>A number, the percentile for column-wise truncation on <code>hx</code> and <code>hpx</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Helper function of <code>get_h_hp()</code>. Please refer to <code>get_hs_hp()</code>.
</p>


<h3>Value</h3>

<p>A function that returns a list containing <code>hx=h(x)</code> (element-wise) and <code>hpx=hp(x)</code> (element-wise derivative of <code class="reqn">h</code>) when applied to a matrix <code>x</code>, with both of the results having the same shape as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_h_hp_adaptive("min_log_pow", 1, 0.4)(matrix(0:49, nrow=10))
get_h_hp_adaptive("min_pow", 2, 0.3)(matrix(0:49, nrow=10))
get_h_hp_adaptive("min_softplus", 2, 0.6)(matrix(seq(0, 0.49, by=0.01), nrow=10))

hx_hpx &lt;- get_h_hp_adaptive("min_log_pow", 1, 0.4)(matrix(0:49, nrow=10))
hx_hpx2 &lt;- get_h_hp("min_log_pow_ada", 1, 0.4)(matrix(0:49, nrow=10))
c(max(abs(hx_hpx$hx - hx_hpx2$hx)), max(abs(hx_hpx$hpx - hx_hpx2$hpx)))
</code></pre>

<hr>
<h2 id='get_h_hp_vector'>Generator of h and hp (derivative of h) functions.</h2><span id='topic+get_h_hp_vector'></span>

<h3>Description</h3>

<p>Generator of <code>h</code> and <code>hp</code> (derivative of <code class="reqn">h</code>) functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_h_hp_vector(mode, para = NULL, para2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_h_hp_vector_+3A_mode">mode</code></td>
<td>
<p>A string, see details.</p>
</td></tr>
<tr><td><code id="get_h_hp_vector_+3A_para">para</code></td>
<td>
<p>May be optional. A number, the first parameter. Default to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get_h_hp_vector_+3A_para2">para2</code></td>
<td>
<p>May be optional. A number, the second parameter. Default to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Helper function of <code>get_h_hp()</code>. Please refer to <code>get_hs_hp()</code>.
</p>


<h3>Value</h3>

<p>A function that returns a matrix with <code>hx=h(x)</code> (element-wise) and <code>hpx=hp(x)</code> (element-wise derivative of <code class="reqn">h</code>) <code>cbind</code>ed when applied to a vector or a matrix <code>x</code>, where if <code>x</code> is a vector, the returned value will have two columns and number of rows equal to <code>length(x)</code>, otherwise it will have the same number of rows as <code>x</code> and number of columns doubled.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_h_hp_vector("mcp", 2, 4)
get_h_hp_vector("min_log_pow", 1, log(1+3))
get_h_hp_vector("min_pow", 1, 3)
get_h_hp_vector("min_softplus")
</code></pre>

<hr>
<h2 id='get_postfix_rule'>Changes a logical expression in infix notation to postfix notation using the shunting-yard algorithm.</h2><span id='topic+get_postfix_rule'></span>

<h3>Description</h3>

<p>Changes a logical expression in infix notation to postfix notation using the shunting-yard algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_postfix_rule(rule, num_eqs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_postfix_rule_+3A_rule">rule</code></td>
<td>
<p>A string containing positive integers, parentheses, and <code>"&amp;"</code> and <code>"|"</code> only. <code>"&amp;&amp;"</code> and <code>"&amp;"</code> are not differentiated, and similarly for <code>"||"</code> and <code>"|"</code>. Chained operations are only allowed for the same operation (<code>"&amp;"</code> or <code>"|"</code>), so instead of <code>"1 &amp;&amp; 2 || 3"</code> one should write either <code>"(1 &amp;&amp; 2) || 3"</code> or <code>"1 &amp;&amp; (2 || 3)"</code> to avoid ambiguity.</p>
</td></tr>
<tr><td><code id="get_postfix_rule_+3A_num_eqs">num_eqs</code></td>
<td>
<p>An integer, must be larger than or equal to the largest integer appearing in <code>rule</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Applied to <code>domain$rule</code> if <code>domain$type == "polynomial"</code>, and internally calls <code>beautify_rule()</code>.
</p>


<h3>Value</h3>

<p><code>rule</code> in postfix notation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_postfix_rule("1 &amp; 2 &amp;&amp; 3", 3)
get_postfix_rule("1 &amp; (2 || 3)", 3)
get_postfix_rule("(1 &amp; 2) || 3 | (4 &amp; (5 || 6) &amp;&amp; 7) | 8 | (9 &amp;&amp; (10 || 11 | 12) &amp; 13)", 13)
## Not run: 
get_postfix_rule("1 &amp;&amp; 2 &amp; 3 &amp;&amp; 4", 3) # Error, ineq number 4 appearing in \code{rule}.

## End(Not run)
## Not run: 
# Error, ambigious rule. Change to either \code{"1 &amp; (2 | 3)"} or \code{"(1 &amp; 2) | 3"}.
get_postfix_rule("1 &amp; 2 | 3", 3)

## End(Not run)
</code></pre>

<hr>
<h2 id='get_results'>Estimate <code class="reqn">\mathbf{K}</code> and <code class="reqn">\boldsymbol{\eta}</code> using elts from <code>get_elts()</code> given one <code class="reqn">\lambda_{\mathbf{K}}</code> (and <code class="reqn">\lambda_{\boldsymbol{\eta}}</code> if non-profiled non-centered) and applying warm-start with strong screening rules.</h2><span id='topic+get_results'></span>

<h3>Description</h3>

<p>Estimate <code class="reqn">\mathbf{K}</code> and <code class="reqn">\boldsymbol{\eta}</code> using elts from <code>get_elts()</code> given one <code class="reqn">\lambda_{\mathbf{K}}</code> (and <code class="reqn">\lambda_{\boldsymbol{\eta}}</code> if non-profiled non-centered) and applying warm-start with strong screening rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_results(
  elts,
  symmetric,
  lambda1,
  lambda2 = 0,
  tol = 1e-06,
  maxit = 10000,
  previous_res = NULL,
  is_refit = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_results_+3A_elts">elts</code></td>
<td>
<p>A list, elements necessary for calculations returned by <code>get_elts()</code>.</p>
</td></tr>
<tr><td><code id="get_results_+3A_symmetric">symmetric</code></td>
<td>
<p>A string. If equals <code>"symmetric"</code>, estimates the minimizer <code class="reqn">\mathbf{K}</code> over all symmetric matrices; if <code>"and"</code> or <code>"or"</code>, use the &quot;and&quot;/&quot;or&quot; rule to get the support.</p>
</td></tr>
<tr><td><code id="get_results_+3A_lambda1">lambda1</code></td>
<td>
<p>A number, the penalty parameter for <code class="reqn">\mathbf{K}</code>.</p>
</td></tr>
<tr><td><code id="get_results_+3A_lambda2">lambda2</code></td>
<td>
<p>A number, the penalty parameter for <code class="reqn">\boldsymbol{\eta}</code>. Default to <code>0</code>. Cannot be <code>Inf</code> if non-profiled non-centered.</p>
</td></tr>
<tr><td><code id="get_results_+3A_tol">tol</code></td>
<td>
<p>Optional. A number, the tolerance parameter.</p>
</td></tr>
<tr><td><code id="get_results_+3A_maxit">maxit</code></td>
<td>
<p>Optional. A positive integer, the maximum number of iterations.</p>
</td></tr>
<tr><td><code id="get_results_+3A_previous_res">previous_res</code></td>
<td>
<p>Optional. A list or <code>NULL</code>, the returned list by this function run previously with another lambda value.</p>
</td></tr>
<tr><td><code id="get_results_+3A_is_refit">is_refit</code></td>
<td>
<p>A boolean, in the refit mode for BIC estimation if <code>TRUE</code>. If <code>TRUE</code>, <code>lambda1</code>, <code>previous_lambda1</code> and <code>lambda2</code> are all set to <code>0</code>, and estimation is restricted to entries in exclude that are <code>0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>elts$domain_type == "simplex"</code>, <code>symmetric != "symmetric"</code> or <code>elts$centered == FALSE &amp;&amp; elts$profiled_if_noncenter</code> are currently not supported.
If <code>elts$domain_type == "simplex"</code> and <code>elts$setting</code> contains substring <code>"sum0"</code>, it is assumed that the column and row sums of <code>K</code> are all 0 and estimation will be done by profiling out the diagonal entries.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>converged</code></td>
<td>
<p>A boolean indicating convergence.</p>
</td></tr>
<tr><td><code>crit</code></td>
<td>
<p>A number, the final penalized loss.</p>
</td></tr>
<tr><td><code>edges</code></td>
<td>
<p>A vector of the indices of entries in the <code>K</code> estimate that are non-zero.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>A p-vector, the <code>eta</code> estimate. Returned only if <code>elts$centered == FALSE</code>.</p>
</td></tr>
<tr><td><code>eta_support</code></td>
<td>
<p>A vector of the indices of entries in the <code>eta</code> estimate that are non-zero. Returned only if <code>elts$centered == FALSE &amp;&amp; elts$profiled_if_noncenter == TRUE</code>.</p>
</td></tr>
<tr><td><code>iters</code></td>
<td>
<p>An integer, number of iterations run.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>A p*p matrix, the <code>K</code> estimate.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>An integer, the number of samples.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>An integer, the dimension.</p>
</td></tr>
<tr><td><code>is_refit</code>, <code>lambda1</code>, <code>maxit</code>, <code>previous_lambda1</code>, <code>symmetric</code>, <code>tol</code></td>
<td>
<p>Same as in the input.</p>
</td></tr>
<tr><td><code>lambda2</code></td>
<td>
<p>Same as in the input, and returned only if <code>elts$centered == FALSE</code> and <br />
<code>elts$profiled_if_noncenter == FALSE</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Examples are shown for Gaussian truncated to R+^p only. For other distributions
#   on other types of domains, please refer to \code{gen()} or \code{get_elts()}, as the
#   way to call this function (\code{get_results()}) is exactly the same in those cases.
n &lt;- 50
p &lt;- 30
domain &lt;- make_domain("R+", p=p)
mu &lt;- rep(0, p)
K &lt;- diag(p)
x &lt;- tmvtnorm::rtmvnorm(n, mean = mu, sigma = solve(K),
       lower = rep(0, p), upper = rep(Inf, p), algorithm = "gibbs",
       burn.in.samples = 100, thinning = 10)

h_hp &lt;- get_h_hp("min_pow", 1, 3)
dm &lt;- 1 + (1-1/(1+4*exp(1)*max(6*log(p)/n, sqrt(6*log(p)/n))))
elts_gauss_np &lt;- get_elts(h_hp, x, setting="gaussian", domain=domain,
                centered=FALSE, profiled=FALSE, scale="norm", diag=dm)
test_nc_np &lt;- get_results(elts_gauss_np, symmetric="symmetric", lambda1=0.35,
                lambda2=2, previous_res=NULL, is_refit=FALSE)
test_nc_np2 &lt;- get_results(elts_gauss_np, symmetric="and", lambda1=0.25,
                 lambda2=2, previous_res=test_nc_np, is_refit=FALSE)

elts_gauss_p &lt;- get_elts(h_hp, x, setting="gaussian", domain=domain,
               centered=FALSE, profiled=TRUE, scale="norm", diag=dm)
test_nc_p &lt;- get_results(elts_gauss_p, symmetric="symmetric",
               lambda1=0.35, lambda2=NULL, previous_res=NULL, is_refit=FALSE)

elts_gauss_c &lt;- get_elts(h_hp, x, setting="gaussian", domain=domain,
               centered=TRUE, scale="norm", diag=dm)
test_c &lt;- get_results(elts_gauss_c, symmetric="or", lambda1=0.35,
               lambda2=NULL, previous_res=NULL, is_refit=FALSE)

</code></pre>

<hr>
<h2 id='get_safe_log_h_hp'>Asymptotic log of <code>h</code> and <code>hp</code> functions for large <code>x</code> for modes with an unbounded <code>h</code>.</h2><span id='topic+get_safe_log_h_hp'></span>

<h3>Description</h3>

<p>Asymptotic log of <code>h</code> and <code>hp</code> functions for large <code>x</code> for modes with an unbounded <code>h</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_safe_log_h_hp(mode, para)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_safe_log_h_hp_+3A_mode">mode</code></td>
<td>
<p>A string, the class of the <code>h</code> function. Must be one of <code>"asinh"</code>, <code>"cosh"</code>, <code>"exp"</code>, <code>"identity"</code>, <code>"log_pow"</code>, <code>"pow"</code>, <code>"sinh"</code>, <code>"softplus"</code>, and <code>"tanh"</code>.</p>
</td></tr>
<tr><td><code id="get_safe_log_h_hp_+3A_para">para</code></td>
<td>
<p>A number, the first parameter to the <code>h</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two vectorized functions, <code>logh</code> and <code>loghp</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>para &lt;- 2.3
x &lt;- seq(from=0.1, to=150, by=0.1)
for (mode in c("asinh", "cosh", "exp", "identity", "log_pow", "pow", "sinh", "softplus", "tanh")) {
  print(mode)
  hx_hpx &lt;- get_h_hp(mode, para)(x)
  print(c(max(abs(get_safe_log_h_hp(mode, para)$logh(x) - log(hx_hpx$hx))), 
          max(abs(get_safe_log_h_hp(mode, para)$loghp(x) - log(hx_hpx$hpx)))))
}
</code></pre>

<hr>
<h2 id='get_trun'>The truncation point for <code>h</code> for <code>h</code> that is truncated (bounded but not naturally bounded).</h2><span id='topic+get_trun'></span>

<h3>Description</h3>

<p>The truncation point for <code>h</code> for <code>h</code> that is truncated (bounded but not naturally bounded).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_trun(mode, param1, param2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_trun_+3A_mode">mode</code></td>
<td>
<p>A string, the class of the <code>h</code> function. Must be one of <code>"mcp"</code>, <code>"scad"</code>, <code>"min_asinh"</code>, <code>"min_cosh"</code>, <code>"min_exp"</code>, <code>"min_log_pow"</code>, <code>"min_pow"</code>, <code>"min_sinh"</code>, <code>"min_softplus"</code>, <code>"truncated_sin"</code>, and <code>"truncated_tan"</code>.</p>
</td></tr>
<tr><td><code id="get_trun_+3A_param1">param1</code></td>
<td>
<p>A number, the first parameter to the <code>h</code> function.</p>
</td></tr>
<tr><td><code id="get_trun_+3A_param2">param2</code></td>
<td>
<p>A number, the second parameter (may be optional depending on <code>mode</code>) to the <code>h</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the truncation point (the point <code>x0</code> such that <code>h</code> becomes constant and <code>hp</code> becomes 0 for <code>x &gt;= x0</code>) for some selected modes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param1 &lt;- 1.3; param2 &lt;- 2.3
for (mode in c("mcp", "scad", "min_asinh", "min_cosh", "min_exp", "min_log_pow",
    "min_pow", "min_sinh", "min_softplus", "truncated_tan")) {
  # Valgrind complains about "truncated_sin" for unknown reason; omitted
  print(mode)
  trun &lt;- get_trun(mode, param1, param2)
  x &lt;- trun + -3:3 / 1e5
  hx_hpx &lt;- get_h_hp(mode, param1, param2)(x)
  print(round(x, 6))
  print(paste("hx:", paste(hx_hpx$hx, collapse=" ")))
  print(paste("hpx:", paste(hx_hpx$hpx, collapse=" ")))
}
</code></pre>

<hr>
<h2 id='h_of_dist'>Finds the distance of each element in a matrix x to the its boundary of the domain while fixing the others in the same row (dist(x, domain)), and calculates element-wise h(dist(x, domain)) and h\'(dist(x, domain)) (w.r.t. each element in x).</h2><span id='topic+h_of_dist'></span>

<h3>Description</h3>

<p>Finds the distance of each element in a matrix  <code>x</code> to its boundary of the <code>domain</code> while fixing the others in the same row (<code>dist(x, domain)</code>), and calculates element-wise <code>h(dist(x, domain))</code> and <code>h\'(dist(x, domain))</code> (w.r.t. each element in <code>x</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_of_dist(h_hp, x, domain, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="h_of_dist_+3A_h_hp">h_hp</code></td>
<td>
<p>A function, the <code class="reqn">h</code> and <code class="reqn">hp</code> (the derivative of <code>h</code>) functions. <code>h_hp(x)</code> should return a list of elements <code>hx</code> (<code>h(x)</code>) and <code>hpx</code> (<code>hp(x)</code>), both of which have the same size as <code>x</code>.</p>
</td></tr>
<tr><td><code id="h_of_dist_+3A_x">x</code></td>
<td>
<p>An <code>n</code> by <code>p</code> matrix, the data matrix, where <code>n</code> is the sample size and <code>p</code> the dimension.</p>
</td></tr>
<tr><td><code id="h_of_dist_+3A_domain">domain</code></td>
<td>
<p>A list returned from <code>make_domain()</code> that represents the domain.</p>
</td></tr>
<tr><td><code id="h_of_dist_+3A_log">log</code></td>
<td>
<p>A logical, defaults to <code>FALSE</code>. If <code>TRUE</code>, assumes that <code>h_hp</code> contains in fact the log of <code>h</code> and <code>hp</code>, and this function will return the log of <code>h(dist(x, domain))</code> and <code>abs(h\'(dist(x, domain)))</code> along with the sign of <code>h\'(dist(x, domain))</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Define <code>dist(x, domain)</code> as the matrix whose <code>i,j</code>-th component is the distance of <code class="reqn">x_{i,j}</code> to the boundary of <code>domain</code>, assuming <code class="reqn">x_{i,-j}</code> are fixed. The matrix has the same size of <code>x</code> (<code>n</code> by <code>p</code>), or if <code>domain$type == "simplex"</code> and <code>x</code> has full dimension <code>p</code>, it has <code>p-1</code> columns.<br />
Define <code>dist\'(x, domain)</code> as the component-wise derivative of <code>dist(x, domain)</code> in its components. That is, its <code>i,j</code>-th component is 0 if <code class="reqn">x_{i,j}</code> is unbounded or is bounded from both below and above or is at the boundary, or -1 if <code class="reqn">x_{i,j}</code> is closer to its lower boundary (or if its bounded from below but unbounded from above), or 1 otherwise.<br />
<code>h_of_dist(h_hp, x, domain)</code> simply returns <code>h_hp(dist(x, domain))$hx</code> and <code>h_hp(dist(x, domain))$hpx * dist\'(x, domain)</code> (element-wise derivative of <code>h_hp(dist(x, domain))$hx</code> w.r.t. <code>x</code>).
</p>


<h3>Value</h3>

<p>If <code>log == FALSE</code>, a list that contains <code>h(dist(x, domain))</code> and <code>h\'(dist(x, domain))</code>.
</p>
<table role = "presentation">
<tr><td><code>hdx</code></td>
<td>
<p><code>h(dist(x, domain))</code>.</p>
</td></tr>
<tr><td><code>hpdx</code></td>
<td>
<p><code>hp(dist(x, domain))</code>.</p>
</td></tr>
</table>
<p>If <code>log == TRUE</code>, a list that contains the log of <code>h(dist(x, domain))</code> and <code>abs(h\'(dist(x, domain)))</code> as well as the sign of <code>h\'(dist(x, domain))</code>.
</p>
<table role = "presentation">
<tr><td><code>log_hdx</code></td>
<td>
<p><code>log(h(dist(x, domain)))</code>.</p>
</td></tr>
<tr><td><code>log_hpdx</code></td>
<td>
<p><code>log(abs(hp(dist(x, domain))))</code>.</p>
</td></tr>
<tr><td><code>sign_hpdx</code></td>
<td>
<p><code>sign(hp(dist(x, domain)))</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 20
p &lt;- 10
eta &lt;- rep(0, p)
K &lt;- diag(p)
dm &lt;- 1 + (1-1/(1+4*exp(1)*max(6*log(p)/n, sqrt(6*log(p)/n))))

# Gaussian on R^p:
domain &lt;- make_domain("R", p=p)
x &lt;- mvtnorm::rmvnorm(n, mean=solve(K, eta), sigma=solve(K))
# Equivalently:

x2 &lt;- gen(n, setting="gaussian", abs=FALSE, eta=eta, K=K, domain=domain,
       finite_infinity=100, xinit=NULL, burn_in=1000, thinning=100, verbose=FALSE)

h_hp &lt;- get_h_hp("pow", 2) # For demonstration only
hd &lt;- h_of_dist(h_hp, x, domain)
# hdx is all Inf and hpdx is all 0 since each coordinate is unbounded with domain R
c(all(is.infinite(hd$hdx)), all(hd$hpdx==0))


# exp on R_+^p:
domain &lt;- make_domain("R+", p=p)
x &lt;- gen(n, setting="exp", abs=FALSE, eta=eta, K=K, domain=domain, finite_infinity=100, 
       xinit=NULL, seed=2, burn_in=1000, thinning=100, verbose=FALSE)
h_hp &lt;- get_h_hp("pow", 2) # For demonstration only
hd &lt;- h_of_dist(h_hp, x, domain)
# hdx is x^2 and hpdx is 2*x; with domain R+, the distance of x to the boundary is just x itself
c(max(abs(hd$hdx - x^2)), max(abs(hd$hpdx - 2*x)))


# Gaussian on sum(x^2) &gt; p with x allowed to be negative
domain &lt;- make_domain("polynomial", p=p,
       ineqs=list(list("expression"=paste("sum(x^2)&gt;", p), abs=FALSE, nonnegative=FALSE)))
x &lt;- gen(n, setting="gaussian", abs=FALSE, eta=eta, K=K, domain=domain, finite_infinity=100, 
       xinit=NULL, seed=2, burn_in=1000, thinning=100, verbose=FALSE)
dist &lt;- get_dist(x, domain)
quota &lt;- p - (rowSums(x^2) - x^2) # How much should xij^2 at least be so that sum(xi^2) &gt; p?
# How far is xij from +/-sqrt(quota), if quota &gt;= 0?
dist_to_bound &lt;- abs(x[quota &gt;= 0]) - abs(sqrt(quota[quota &gt;= 0]))
# Should be equal to our own calculations
max(abs(dist$dx[is.finite(dist$dx)] - dist_to_bound))
# dist'(x) should be the same as the sign of x
all(dist$dpx[is.finite(dist$dx)] == sign(x[quota &gt;= 0]))
# quota is negative &lt;-&gt; sum of x_{i,-j}^2 already &gt; p &lt;-&gt; xij unbounded given others
#      &lt;-&gt; distance to boundary is Inf
all(quota[is.infinite(dist$dx)] &lt; 0)

h_hp &lt;- get_h_hp("pow", 2) # For demonstration only
# Now confirm that h_of_dist indeed applies h and hp to dists
hd &lt;- h_of_dist(h_hp, x, domain)
# hdx = dist ^ 2
print(max(abs(hd$hdx[is.finite(dist$dx)] - dist$dx[is.finite(dist$dx)]^2)))
# hdx = Inf if dist = Inf
print(all(is.infinite(hd$hdx[is.infinite(dist$dx)])))
 # hpdx = 2 * dist' * dist
print(max(abs(hd$hpdx[is.finite(dist$dx)] - 2*(dist$dpx*dist$dx)[is.finite(dist$dx)])))
print(all(hd$hpdx[is.infinite(dist$dx)] == 0)) # hpdx = 0 if dist = Inf


# gamma on ([0, 1] v [2,3])^p
domain &lt;- make_domain("uniform", p=p, lefts=c(0,2), rights=c(1,3))
x &lt;- gen(n, setting="gamma", abs=FALSE, eta=eta, K=K, domain=domain,
       xinit=NULL, seed=2, burn_in=1000, thinning=100, verbose=FALSE)
dist &lt;- get_dist(x, domain)
# If 0 &lt;= xij &lt;= 1, distance to boundary is min(x-0, 1-x)
max(abs(dist$dx - pmin(x, 1-x))[x &gt;= 0 &amp; x &lt;= 1])
# If 0 &lt;= xij &lt;= 1, dist'(xij) is 1 if it is closer to 0, or -1 if it is closer 1,
#   assuming xij %in% c(0, 0.5, 1) with probability 0
all((dist$dpx == 2 * (1-x &gt; x) - 1)[x &gt;= 0 &amp; x &lt;= 1])
# If 2 &lt;= xij &lt;= 3, distance to boundary is min(x-2, 3-x)
max(abs(dist$dx - pmin(x-2, 3-x))[x &gt;= 2 &amp; x &lt;= 3])
# If 2 &lt;= xij &lt;= 3, dist'(xij) is 1 if it is closer to 2, or -1 if it is closer 3,
#   assuming xij %in% c(2, 2.5, 3) with probability 0
all((dist$dpx == 2 * (3-x &gt; x-2) - 1)[x &gt;= 2 &amp; x &lt;= 3])
h_hp &lt;- get_h_hp("pow", 2) # For demonstration only
# Now confirm that h_of_dist indeed applies h and hp to dists
hd &lt;- h_of_dist(h_hp, x, domain)
# hdx = dist ^ 2
print(max(abs(hd$hdx - dist$dx^2)))
# hpdx = 2 * dist' * dist
print(max(abs(hd$hpdx - 2*dist$dpx*dist$dx)))


# a0.6_b0.7 on {x1 &gt; 1 &amp;&amp; log(1.3) &lt; x2 &lt; 1 &amp;&amp; x3 &gt; log(1.3) &amp;&amp; ... &amp;&amp; xp &gt; log(1.3)}
domain &lt;- make_domain("polynomial", p=p, rule="1 &amp;&amp; 2 &amp;&amp; 3",
       ineqs=list(list("expression"="x1&gt;1", abs=FALSE, nonnegative=TRUE),
                      list("expression"="x2&lt;1", abs=FALSE, nonnegative=TRUE),
                      list("expression"="exp(x)&gt;1.3", abs=FALSE, nonnegative=FALSE)))
set.seed(1)
xinit &lt;- c(1.5, 0.5, abs(stats::rnorm(p-2)) + log(1.3))
x &lt;- gen(n, setting="ab_3/5_7/10", abs=FALSE, eta=eta, K=K, domain=domain, finite_infinity=100, 
       xinit=xinit, seed=2, burn_in=1000, thinning=100, verbose=FALSE)
dist &lt;- get_dist(x, domain)
# x_{i1} has uniform bound [1, +Inf), so its distance to its boundary is x_{i1} - 1
max(abs(dist$dx[,1] - (x[,1] - 1)))
# x_{i2} has uniform bound [log(1.3), 1], so its distance to its boundary
#    is min(x_{i2} - log(1.3), 1 - x_{i2})
max(abs(dist$dx[,2] - pmin(x[,2] - log(1.3), 1 - x[,2])))
# x_{ij} for j &gt;= 3 has uniform bound [log(1.3), +Inf), so its distance to its boundary is
#    simply x_{ij} - log(1.3)
max(abs(dist$dx[,3:p] - (x[,3:p] - log(1.3))))
# dist'(xi2) is 1 if it is closer to log(1.3), or -1 if it is closer 1,
#    assuming x_{i2} %in% c(log(1.3), (1+log(1.3))/2, 1) with probability 0
all((dist$dpx[,2] == 2 * (1 - x[,2] &gt; x[,2] - log(1.3)) - 1))
all(dist$dpx[,-2] == 1) # x_{ij} for j != 2 is bounded from below but unbounded from above,
#    so dist'(xij) is always 1
h_hp &lt;- get_h_hp("pow", 2) # For demonstration only
# Now confirm that h_of_dist indeed applies h and hp to dists
hd &lt;- h_of_dist(h_hp, x, domain)
# hdx = dist ^ 2
print(max(abs(hd$hdx - dist$dx^2)))
# hpdx = 2 * dist' * dist
print(max(abs(hd$hpdx - 2*dist$dpx*dist$dx)))


# log_log model on {x in R_+^p: sum_j j * xj &lt;= 1}
domain &lt;- make_domain("polynomial", p=p,
       ineqs=list(list("expression"=paste(paste(sapply(1:p,
                           function(j){paste(j, "x", j, sep="")}), collapse="+"), "&lt;1"),
                     abs=FALSE, nonnegative=TRUE)))
x &lt;- gen(n, setting="log_log", abs=FALSE, eta=eta, K=K, domain=domain, finite_infinity=100, 
       xinit=NULL, seed=2, burn_in=1000, thinning=100, verbose=FALSE)
dist &lt;- get_dist(x, domain)
# Upper bound for j * xij so that sum_j j * xij &lt;= 1
quota &lt;- 1 - (rowSums(t(t(x) * 1:p)) - t(t(x) * 1:p))
# Distance of xij to its boundary is min(xij - 0, quota_{i,j} / j - xij)
max(abs(dist$dx - pmin((t(t(quota) / 1:p) - x), x)))
h_hp &lt;- get_h_hp("pow", 2) # For demonstration only
# Now confirm that h_of_dist indeed applies h and hp to dists
hd &lt;- h_of_dist(h_hp, x, domain)
# hdx = dist ^ 2
print(max(abs(hd$hdx - dist$dx^2)))
# hpdx = 2 * dist' * dist
print(max(abs(hd$hpdx - 2*dist$dpx*dist$dx)))


# log_log_sum0 model on the simplex with K having row and column sums 0 (Aitchison model)
domain &lt;- make_domain("simplex", p=p)
K &lt;- -cov_cons("band", p=p, spars=3, eig=1)
diag(K) &lt;- diag(K) - rowSums(K) # So that rowSums(K) == colSums(K) == 0
eigen(K)$val[(p-1):p] # Make sure K has one 0 and p-1 positive eigenvalues
x &lt;- gen(n, setting="log_log_sum0", abs=FALSE, eta=eta, K=K, domain=domain,
       xinit=NULL, seed=2, burn_in=1000, thinning=100, verbose=FALSE)
# Note that dist$dx and dist$dpx only has p-1 columns -- excluding the last coordinate in x
dist &lt;- get_dist(x, domain)
# Upper bound for x_{i,j} so that x_{i,1} + ... + x_{i,p-1} &lt;= 1
quota &lt;- 1 - (rowSums(x[,-p]) - x[,-p])
# Distance of x_{i,j} to its boundary is min(xij - 0, quota_{i,j} - xij)
max(abs(dist$dx - pmin(quota - x[,-p], x[,-p])))
h_hp &lt;- get_h_hp("pow", 2) # For demonstration only
# Now confirm that h_of_dist indeed applies h and hp to dists
hd &lt;- h_of_dist(h_hp, x, domain)
# hdx = dist ^ 2
print(max(abs(hd$hdx - dist$dx^2)))
# hpdx = 2 * dist' * dist
print(max(abs(hd$hpdx - 2*dist$dpx*dist$dx)))
</code></pre>

<hr>
<h2 id='in_bound'>Returns whether a vector or each row of a matrix falls inside a domain.</h2><span id='topic+in_bound'></span>

<h3>Description</h3>

<p>Returns whether a vector or each row of a matrix falls inside a domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in_bound(x, domain)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="in_bound_+3A_x">x</code></td>
<td>
<p>A vector of length or a matrix of number of columns equal to <code>domain$p</code> if <code>domain$type != "simplex"</code>, or either <code>domain$p</code> or <code>domain$p-1</code> otherwise.</p>
</td></tr>
<tr><td><code id="in_bound_+3A_domain">domain</code></td>
<td>
<p>A list returned from <code>make_domain()</code> that represents the domain.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns whether a vector or each row of a matrix falls inside a domain.
If <code>domain$type == "simplex"</code>, if the length/number of columns is <code>domain$p</code>, returns <code>all(x &gt; 0) &amp;&amp; abs(sum(x) - 1) &lt; domain$simplex_tol</code>; if the dimension is <code>domain$p-1</code>, returns <code>all(x &gt; 0) &amp;&amp; sum(x) &lt; 1</code>.
</p>


<h3>Value</h3>

<p>A logical vector of length equal to the number of rows in <code>x</code> (<code>1</code> if <code>x</code> is a vector).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 30
n &lt;- 10

# The 30-dimensional real space R^30, assuming probability of
domain &lt;- make_domain("R", p=p)
in_bound(1:p, domain)
in_bound(matrix(1:(p*n), ncol=p), domain)

# The non-negative orthant of the 30-dimensional real space, R+^30
domain &lt;- make_domain("R+", p=p)
in_bound(matrix(1:(p*n), ncol=p), domain)
in_bound(matrix(1:(p*n) * (2*rbinom(p*n, 1, 0.98)-1), ncol=p), domain)

# x such that sum(x^2) &gt; 10 &amp;&amp; sum(x^(1/3)) &gt; 10 with x allowed to be negative
domain &lt;- make_domain("polynomial", p=p, rule="1 &amp;&amp; 2",
       ineqs=list(list("expression"="sum(x^2)&gt;10", abs=FALSE, nonnegative=FALSE),
                      list("expression"="sum(x^(1/3))&gt;10", abs=FALSE, nonnegative=FALSE)))
in_bound(rep((5/p)^3, p), domain)
in_bound(rep((10/p)^3, p), domain)
in_bound(rep((15/p)^3, p), domain)
in_bound(rep((5/p)^(1/2), p), domain)
in_bound(rep((10/p)^(1/2), p), domain)
in_bound(rep((15/p)^(1/2), p), domain)

# ([0, 1] v [2,3]) ^ p
domain &lt;- make_domain("uniform", p=p, lefts=c(0,2), rights=c(1,3))
in_bound(c(0.5, 2.5)[rbinom(p, 1, 0.5)+1], domain)
in_bound(c(rep(0.5, p/2), rep(2.5, p/2)), domain)
in_bound(c(rep(0.5, p/2), rep(2.5, p/2-1), 4), domain)

# x such that {x1 &gt; 1 &amp;&amp; log(1.3) &lt; x2 &lt; 1 &amp;&amp; x3 &gt; log(1.3) &amp;&amp; ... &amp;&amp; xp &gt; log(1.3)}
domain &lt;- make_domain("polynomial", p=p, rule="1 &amp;&amp; 2 &amp;&amp; 3",
       ineqs=list(list("expression"="x1&gt;1", abs=FALSE, nonnegative=TRUE),
                      list("expression"="x2&lt;1", abs=FALSE, nonnegative=TRUE),
                      list("expression"="exp(x)&gt;1.3", abs=FALSE, nonnegative=FALSE)))
in_bound(c(1.5, (log(1.3)+1)/2, rep(log(1.3)*2, p-2)), domain)
in_bound(c(0.5, (log(1.3)+1)/2, rep(log(1.3)*2, p-2)), domain)
in_bound(c(1.5, log(1.3)/2, rep(log(1.3)*2, p-2)), domain)
in_bound(c(1.5, (log(1.3)+1)/2, rep(log(1.3)/2, p-2)), domain)

# x in R_+^p such that {sum(log(x))&lt;2 || (x1^(2/3)-1.3x2^(-3)&lt;1 &amp;&amp; exp(x1)+2.3*x2&gt;2)}
domain &lt;- make_domain("polynomial", p=p, rule="1 || (2 &amp;&amp; 3)",
       ineqs=list(list("expression"="sum(log(x))&lt;2", abs=FALSE, nonnegative=TRUE),
                      list("expression"="x1^(2/3)-1.3x2^(-3)&lt;1", abs=FALSE, nonnegative=TRUE),
                      list("expression"="exp(x1)+2.3*x2^2&gt;2", abs=FALSE, nonnegative=TRUE)))
in_bound(rep(exp(1/p), p), domain)
in_bound(c(1, 1, rep(1e5, p-2)), domain)

# x in R_+^p such that {x in R_+^p: sum_j j * xj &lt;= 1}
domain &lt;- make_domain("polynomial", p=p,
       ineqs=list(list("expression"=paste(paste(sapply(1:p,
                           function(j){paste(j, "x", j, sep="")}), collapse="+"), "&lt;1"),
                     abs=FALSE, nonnegative=TRUE)))
in_bound(0.5/p/1:p, domain)
in_bound(2/p/1:p, domain)
in_bound(rep(1/p, p), domain)
in_bound(rep(1/p^2, p), domain)

# The (p-1)-simplex
domain &lt;- make_domain("simplex", p=p)
x &lt;- abs(matrix(rnorm(p*n), ncol=p))
x &lt;- x / rowSums(x)
in_bound(x, domain) # TRUE
in_bound(x[,1:(p-1)], domain) # TRUE
x2 &lt;- x
x2[,1] &lt;- -x2[,1]
in_bound(x2, domain) # FALSE since the first component is now negative
in_bound(x2[,1:(p-1)], domain) # FALSE since the first component is now negative
x3 &lt;- x
x3[,1] &lt;- x3[,1] + domain$simplex_tol * 10
in_bound(x3, domain) # FALSE since the rows do not sum to 1
in_bound(x3[,1:(p-1)], domain) # TRUE since the first (p-1) elts in each row still sum to &lt; 1
x3[,1] &lt;- x3[,1] + x3[,p]
in_bound(x3[,1:(p-1)], domain) # FALSE since the first (p-1) elts in each row now sum to &gt; 1

# The l-1 ball {sum(|x|) &lt; 1}
domain &lt;- make_domain("polynomial", p=p,
       ineqs=list(list("expression"="sum(x)&lt;1", abs=TRUE, nonnegative=FALSE)))
in_bound(rep(0.5/p, p)*(2*rbinom(p, 1, 0.5)-1), domain)
in_bound(rep(1.5/p, p)*(2*rbinom(p, 1, 0.5)-1), domain)
</code></pre>

<hr>
<h2 id='interval_intersection'>Finds the intersection between two unions of intervals.</h2><span id='topic+interval_intersection'></span>

<h3>Description</h3>

<p>Finds the intersection between two unions of intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interval_intersection(A, B)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interval_intersection_+3A_a">A</code></td>
<td>
<p>A list of vectors of size 2, each representing an interval. It is required that <code>A[[i]][1] &lt;= A[[i]][2] &lt;= A[[j]][1]</code> for any <code>i &lt; j</code>.</p>
</td></tr>
<tr><td><code id="interval_intersection_+3A_b">B</code></td>
<td>
<p>A list of vectors of size 2, each representing an interval. It is required that <code>A[[i]][1] &lt;= A[[i]][2] &lt;= A[[j]][1]</code> for any <code>i &lt; j</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Finds the intersection between the union of all intervals in <code>A</code> and the union of all intervals in <code>B</code>.
</p>


<h3>Value</h3>

<p>A list of vectors of size 2, whose union represents the intersection between <code>A</code> and <code>B</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>interval_intersection(list(c(1.2,1.5), c(2.3,2.7)),
       list(c(0.6,1.4), c(2.5,3.6), c(6.3,6.9)))
interval_intersection(list(c(-0.3,0.55), c(2.35,2.8)),
       list(c(0.54,0.62), c(2.5,2.9)))
interval_intersection(list(c(0,1)), list(c(1,2)))
interval_intersection(list(c(0,1+1e-8)), list(c(1,2)))
interval_intersection(list(c(0,1), c(2,3)),
       list(c(1,2)))
interval_intersection(list(c(0,1+1e-8), c(2-1e-8,3)),
       list(c(1,2)))
interval_intersection(list(c(0,1)), list())
</code></pre>

<hr>
<h2 id='interval_union'>Finds the union between two unions of intervals.</h2><span id='topic+interval_union'></span>

<h3>Description</h3>

<p>Finds the union between two unions of intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interval_union(A, B)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interval_union_+3A_a">A</code></td>
<td>
<p>A list of vectors of size 2, each representing an interval. It is required that <code>A[[i]][1] &lt;= A[[i]][2] &lt;= A[[j]][1]</code> for any <code>i &lt; j</code>.</p>
</td></tr>
<tr><td><code id="interval_union_+3A_b">B</code></td>
<td>
<p>A list of vectors of size 2, each representing an interval. It is required that <code>A[[i]][1] &lt;= A[[i]][2] &lt;= A[[j]][1]</code> for any <code>i &lt; j</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Finds the union between the union of all intervals in <code>A</code> and the union of all intervals in <code>B</code>.
</p>


<h3>Value</h3>

<p>A list of vectors of size 2, whose union represents the union between <code>A</code> and <code>B</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>interval_union(list(c(1.2,1.5), c(2.3,2.7)),
       list(c(0.6,1.4), c(2.5,3.6), c(6.3,6.9)))
interval_union(list(c(-0.3,0.55), c(2.35,2.8)),
       list(c(0.54,0.62), c(2.5,2.9)))
interval_union(list(c(0,1)), list(c(1,2)))
interval_union(list(c(0,1-1e-8)), list(c(1,2)))
interval_union(list(c(0,1), c(2,3)),
       list(c(1,2)))
interval_union(list(c(0,1-1e-8), c(2+1e-8,3)),
       list(c(1,2)))
interval_union(list(c(0,1)), list())
</code></pre>

<hr>
<h2 id='lambda_max'>Analytic solution for the minimum <code class="reqn">\lambda_{\mathbf{K}}</code> that gives the empty graph.</h2><span id='topic+lambda_max'></span>

<h3>Description</h3>

<p>Analytic solution for the minimum <code class="reqn">\lambda_{\mathbf{K}}</code> that gives the empty graph. In the non-centered setting the bound is not tight, as it is such that both <code class="reqn">\mathbf{K}</code> and <code class="reqn">\boldsymbol{\eta}</code> are empty. The bound is also not tight if <code>symmetric == "and"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda_max(elts, symmetric, lambda_ratio = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lambda_max_+3A_elts">elts</code></td>
<td>
<p>A list, elements necessary for calculations returned by <code>get_elts()</code>.</p>
</td></tr>
<tr><td><code id="lambda_max_+3A_symmetric">symmetric</code></td>
<td>
<p>A string. If equals <code>"symmetric"</code>, estimates the minimizer <code class="reqn">\mathbf{K}</code> over all symmetric matrices; if <code>"and"</code> or <code>"or"</code>, use the &quot;and&quot;/&quot;or&quot; rule to get the support.</p>
</td></tr>
<tr><td><code id="lambda_max_+3A_lambda_ratio">lambda_ratio</code></td>
<td>
<p>A positive number (or <code>Inf</code>), the fixed ratio <code class="reqn">\lambda_{\mathbf{K}}</code> and <code class="reqn">\lambda_{\boldsymbol{\eta}}</code>, if <code class="reqn">\lambda_{\boldsymbol{\eta}}\neq 0</code> (non-profiled) in the non-centered setting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number, the smallest lambda that produces the empty graph in the centered case, or that gives zero solutions for <code class="reqn">\mathbf{K}</code> and <code class="reqn">\boldsymbol{\eta}</code> in the non-centered case. If <code>symmetric == "and"</code>, it is not a tight bound for the empty graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Examples are shown for Gaussian truncated to R+^p only. For other distributions
#   on other types of domains, please refer to \code{gen()} or \code{get_elts()},
#   as the way to call this function (\code{lambda_max()}) is exactly the same in those cases.
n &lt;- 50
p &lt;- 30
domain &lt;- make_domain("R+", p=p)
mu &lt;- rep(0, p)
K &lt;- diag(p)
x &lt;- tmvtnorm::rtmvnorm(n, mean = mu, sigma = solve(K),
       lower = rep(0, p), upper = rep(Inf, p), algorithm = "gibbs",
       burn.in.samples = 100, thinning = 10)

dm &lt;- 1 + (1-1/(1+4*exp(1)*max(6*log(p)/n, sqrt(6*log(p)/n))))
h_hp &lt;- get_h_hp("min_pow", 1, 3)
elts_gauss_np &lt;- get_elts(h_hp, x, setting="gaussian", domain=domain,
                centered=FALSE, profiled=FALSE, diag=dm)

# Exact analytic solution for the smallest lambda such that K and eta are both zero,
#  but not a tight bound for K ONLY
lambda_max(elts_gauss_np, "symmetric", 2)
# Use the upper bound as a starting point for numerical search
test_lambda_bounds2(elts_gauss_np, "symmetric", lambda_ratio=2, lower = FALSE,
     lambda_start = lambda_max(elts_gauss_np, "symmetric", 2))

# Exact analytic solution for the smallest lambda such that K and eta are both zero,
#  but not a tight bound for K ONLY
lambda_max(elts_gauss_np, "or", 2)
# Use the upper bound as a starting point for numerical search
test_lambda_bounds2(elts_gauss_np, "or", lambda_ratio=2, lower = FALSE,
     lambda_start = lambda_max(elts_gauss_np, "or", 2))

# An upper bound, not tight.
lambda_max(elts_gauss_np, "and", 2)
# Use the upper bound as a starting point for numerical search
test_lambda_bounds2(elts_gauss_np, "and", lambda_ratio=2, lower = FALSE,
     lambda_start = lambda_max(elts_gauss_np, "and", 2))


elts_gauss_p &lt;- get_elts(h_hp, x, setting="gaussian", domain=domain,
              centered=FALSE, profiled=TRUE, diag=dm)
# Exact analytic solution
lambda_max(elts_gauss_p, "symmetric")
# Numerical solution, should be close to the analytic solution
test_lambda_bounds2(elts_gauss_p, "symmetric", lambda_ratio=Inf, lower = FALSE,
     lambda_start = NULL)

# Exact analytic solution
lambda_max(elts_gauss_p, "or")
# Numerical solution, should be close to the analytic solution
test_lambda_bounds2(elts_gauss_p, "or", lambda_ratio=Inf, lower = FALSE,
     lambda_start = NULL)

# An upper bound, not tight
lambda_max(elts_gauss_p, "and")
# Use the upper bound as a starting point for numerical search
test_lambda_bounds2(elts_gauss_p, "and", lambda_ratio=Inf, lower = FALSE,
     lambda_start = lambda_max(elts_gauss_p, "and"))
</code></pre>

<hr>
<h2 id='make_domain'>Creates a list of elements that defines the domain for a multivariate distribution.</h2><span id='topic+make_domain'></span>

<h3>Description</h3>

<p>Creates a list of elements that define the domain for a multivariate distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_domain(type, p, lefts = NULL, rights = NULL, ineqs = NULL, rule = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_domain_+3A_type">type</code></td>
<td>
<p>A string, the domain type. Currently support <code>"R"</code>, <code>"R+"</code>, <code>"uniform"</code>, <code>"polynomial"</code>, <code>"simplex"</code>. See details.</p>
</td></tr>
<tr><td><code id="make_domain_+3A_p">p</code></td>
<td>
<p>An integer, the dimension of the domain.</p>
</td></tr>
<tr><td><code id="make_domain_+3A_lefts">lefts</code></td>
<td>
<p>Optional, required if <code>type == "uniform"</code> and must have the same length as <code>rights</code>. A non-empty vector of numbers (may contain <code>-Inf</code>), the left endpoints of a domain defined as a union of intervals. It is required that <code>lefts[i] &lt;= rights[i] &lt;= lefts[j]</code> for any <code>i &lt; j</code>.</p>
</td></tr>
<tr><td><code id="make_domain_+3A_rights">rights</code></td>
<td>
<p>Optional, required if <code>type == "uniform"</code> and must have the same length as <code>lefts</code>. A non-empty vector of numbers (may contain <code>Inf</code>), the right endpoints of a domain defined as a union of intervals. It is required that <code>lefts[i] &lt;= rights[i] &lt;= lefts[j]</code> for any <code>i &lt; j</code>.</p>
</td></tr>
<tr><td><code id="make_domain_+3A_ineqs">ineqs</code></td>
<td>
<p>Optional, required if <code>type == "polynomial"</code>. A list of lists, each sublist representing an inequality that defines the domain. Each sublist must contain fields <code>abs</code> (logical) and <code>nonnegative</code> (logical), and in addition either a single <code>expression</code> (string), or all of the following: <code>uniform</code> (logical), <code>larger</code> (logical), <code>power_numers</code> (1 or <code>p</code> integers), <code>power_denoms</code> (1 or <code>p</code> integers), <code>const</code> (a number), <code>coeffs</code> (1 or <code>p</code> numbers).</p>
</td></tr>
<tr><td><code id="make_domain_+3A_rule">rule</code></td>
<td>
<p>Optional, required if <code>type == "polynomial" &amp;&amp; length(ineqs) &gt; 1</code>. A string containing inequality numbers, spaces, parentheses, '&amp;' and '|' only. Used to indicate the logic operation on how to combine the domains defined by each inequality, i.e. &quot;(1 &amp; 2 &amp;&amp; 3) || 4 | 5&quot;. Chained operations not separated by parentheses are only allowed for the same type of operation ('&amp;'/'|'), i.e. &quot;1 &amp; 2 | 3&quot; is not allowed; it should be either &quot;(1 &amp; 2) | 3&quot; or &quot;1 &amp; (2 | 3)&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following types of domains are supported:
</p>

<dl>
<dt><code>"R"</code></dt><dd><p>The entire <code>p</code>-dimensional real space. Equivalent to <code>"uniform"</code> type with <code>lefts=-Inf</code> and <code>rights=Inf</code>.</p>
</dd>
<dt><code>"R+"</code></dt><dd><p>The non-negative orthant of the <code>p</code>-dimensional real space. Equivalent to <code>"uniform"</code> type with <code>lefts=0</code> and <code>rights=Inf</code>.</p>
</dd>
<dt><code>"uniform"</code></dt><dd><p>A union of finitely many disjoint intervals as a uniform domain for all components. The left endpoints should be specified through <code>lefts</code> and the right endpoints through <code>rights</code>. The intervals must be disjoint and strictly increasing, i.e. <code>lefts[i] &lt;= rights[i] &lt;= lefts[j]</code> for any <code>i &lt; j</code>. E.g. <code>lefts=c(0, 10)</code> and <code>rights=c(5, Inf)</code> represents the domain ([0,5]v[10,+Inf])^p.</p>
</dd>
<dt><code>"simplex"</code></dt><dd><p>The standard <code>p-1</code>-simplex with all components positive and sum to 1, i.e. <code>sum(x) == 1</code> and <code>x &gt; 0</code>.</p>
</dd>
<dt><code>"polynomial"</code></dt><dd><p>A finite intersection/union of domains defined by comparing a constant to a polynomial with at most one term in each component and no interaction terms (e.g. <code>x1^3+x1^2&gt;1</code> or <code>x1*x2&gt;1</code> not supported). The following is supported: <code>{x1^2 + 2*x2^(3/2) &gt; 1} &amp;&amp; ({3.14*x1 - 0.7*x3^3 &lt; 1} || {-exp(3*x2) + 3.7*log(x3) + 2.4*x4^(-3/2)})</code>.</p>
</dd>
</dl>
<p>To specify a polynomial-type domain, one should define the <code>ineqs</code>, and in case of more than one inequality, the logical <code>rule</code> to combine the domains defined by each inequality.
</p>
<dl>
<dt><code>rule</code></dt><dd><p>A logical rule in infix notation, e.g. <code>"(1 &amp;&amp; 2 &amp;&amp; 3) || (4 &amp;&amp; 5) || 6"</code>, where the numbers represent the inequality numbers starting from 1. <code>"&amp;&amp;"</code> and <code>"&amp;"</code> are not differentiated, and similarly for <code>"||"</code> and <code>"|"</code>. Chained operations are only allowed for the same operation (<code>"&amp;"</code> or <code>"|"</code>), so instead of <code>"1 &amp;&amp; 2 || 3"</code> one should write either <code>"(1 &amp;&amp; 2) || 3"</code> or <code>"1 &amp;&amp; (2 || 3)"</code> to avoid ambiguity.</p>
</dd>
<dt><code>ineqs</code></dt><dd><p>A list of lists, each sublist represents one inequality, and must contain the following fields:
</p>

<dl>
<dt><code>abs</code></dt><dd><p>A logical, indicates whether one should evaluate the polynomial in <code>abs(x)</code> instead of <code>x</code> (e.g. <code>"sum(x) &gt; 1"</code> with <code>abs == TRUE</code> is interpreted as <code>sum(abs(x)) &gt; 1</code>).</p>
</dd>
<dt><code>nonnegative</code></dt><dd><p>A logical, indicates whether the domain of this inequality should be restricted to the non-negative orthant.</p>
</dd>
</dl>

<p>In addition, one must in addition specify either a single string <code>"expression"</code> (highly recommended, detailed below), or all of the following fields (discouraged usage):
</p>

<dl>
<dt><code>uniform</code></dt><dd><p>A logical, indicates whether the inequality should be uniformly applied to all components (e.g. <code>"x&gt;1"</code> -&gt; <code>"x1&gt;1 &amp;&amp; ... &amp;&amp; xp&gt;1"</code>).</p>
</dd>
<dt><code>larger</code></dt><dd><p>A logical, indicates whether the polynomial should be larger or smaller than the constant (e.g. <code>TRUE</code> for <code>x1 + ... + xp &gt; C</code>, and <code>FALSE</code> for <code>x1 + ... + xp &lt; C</code>).</p>
</dd>
<dt><code>const</code></dt><dd><p>A number, the constant the polynomial should be compared to  (e.g. <code>2.3</code> for <code>x1 + ... + xp &gt; 2.3</code>).</p>
</dd>
<dt><code>power_numers</code></dt><dd><p>A single integer or a vector of <code>p</code> integers. <code>x[i]</code> will be raised to the power of <code>power_numers[i] / power_denoms[i]</code> (or without subscript if a singer integer). Note that <code>x^(0/0)</code> is interpreted as <code>log(x)</code>, and <code>x^(n/0)</code> as <code>exp(n*x)</code> for <code>n</code> non-zero. For a negative <code>x</code>, <code>x^(a/b)</code> is defined as <code>(-1)^a*|x|^(a/b)</code> if <code>b</code> is odd, or <code>NaN</code> otherwise. (Example: <code>c(2,3,5,0,-2)</code> for <code>x1^2+2*x2^(3/2)+3*x3^(5/3)+4*log(x4)+5*exp(-2*x)&gt;1</code>).</p>
</dd>
<dt><code>power_denoms</code></dt><dd><p>A single integer or a vector of <code>p</code> integers.  (Example: <code>c(1,2,3,0,0)</code> for <code>x1^2+2*x2^(3/2)+3*x3^(5/3)+4*log(x4)+5*exp(-2*x)&gt;1</code>).</p>
</dd>
<dt><code>coeffs</code></dt><dd><p>Required if <code>uniform == FALSE</code>. A vector of <code>p</code> doubles, where <code>coeffs[i]</code> is the coefficient on <code>x[i]</code> in the inequality.</p>
</dd>
</dl>

<p>The user is recommended to use a single <code>expression</code> for ease and to avoid potential errors. The user may safely skip the explanations and directly look at the examples to get a better understanding.<br />
</p>
<p>The expression should have the form <code>"POLYNOMIAL SIGN CONST"</code>, where <code>"SIGN"</code> is one of <code>"&lt;"</code>, <code>"&lt;="</code>, <code>"&gt;"</code>, <code>"&gt;="</code>, and <code>"CONST"</code> is a single number (scientific notation allowed).<br />
</p>
<p><code>"POLYNOMIAL"</code> must be (1) a single term (see below) in <code>"x"</code> with no coefficient (e.g. <code>"x^(2/3)"</code>, <code>"exp(3x)"</code>), or (2) such a term surrounded by <code>"sum()"</code> (e.g. <code>"sum(x^(2/3))"</code>, <code>"sum(exp(3x))"</code>), or (3) a sum of such terms in <code>"x1"</code> through <code>"xp"</code> (one term max for each component) with or without coefficients, separated by the plus or the minus sign (e.g. <br /><code>"2.3x1^(2/3)-3.4exp(x2)+x3^(-3/5)"</code>).<br />
</p>
<p>For (1) and (2), the term must be in one of the following forms: <code>"x"</code>, <code>"x^2"</code>, <code>"x^(-2)"</code>, <code>"x^(2/3)"</code>, <code>"x^(-2/3)"</code>, <code>"log(x)"</code>, <code>"exp(x)"</code>, <code>"exp(2x)"</code>, <code>"exp(2*x)"</code>, <code>"exp(-3x)"</code>, where the <code>2</code> and <code>3</code> can be changed to any other non-zero integers.<br />
For (3), each term should be as above but in <code>"x1"</code>, ..., <code>"xp"</code> instead of <code>"x"</code>, following an optional double number and optionally a <code>"*"</code> sign.<br />
</p>
<p>Examples: For <code>p=10</code>, <br />
(1) <code>"x^2 &gt; 2"</code> defines the domain <code>abs(x1) &gt; sqrt(2) &amp;&amp; ... &amp;&amp; abs(x10) &gt; sqrt(2)</code>.<br />
(2) <code>"sum(x^2) &gt; 2"</code> defines the domain <code>x1^2 + ... + x10^2 &gt; 2</code>.<br />
(3) <code>"2.3x3^(2/3)-3.4x4+x5^(-3/5)+3.7*x6^(-4)-1.9*log(x7)+1.3e5*exp(-3x8)}\cr
          \code{-2*exp(x9)+0.5exp(2*x10) &lt;= 2"</code> defines a domain using a polynomial in <code>x3</code> through <code>x10</code>, and <code>x1</code> and <code>x2</code> are thus allowed to vary freely.<br />
</p>
<p>Note that <code>"&gt;"</code> and <code>"&gt;="</code> are not differentiated, and so are <code>"&lt;"</code> and <code>"&lt;="</code>.
</p>
</dd></dl>



<h3>Value</h3>

<p>A list containing the elements that define the domain.
For all types of domains, the following are returned.
</p>
<table role = "presentation">
<tr><td><code>type</code></td>
<td>
<p>A string, same as the input.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>An integer, same as the input.</p>
</td></tr>
<tr><td><code>p_deemed</code></td>
<td>
<p>An integer, equal to <code>p-1</code> if <code>type == "simplex"</code> or <code>p</code> otherwise.</p>
</td></tr>
<tr><td><code>checked</code></td>
<td>
<p>A logical, <code>TRUE</code>. Used in other functions to test whether a list is returned by this function.</p>
</td></tr>
</table>
<p>In addition,
</p>

<ul>
<li><p>For <code>type == "simplex"</code>, returns in addition
</p>

<dl>
<dt><code>simplex_tol</code></dt><dd><p>Tolerance used for simplex domains. Defaults to <code>1e-10</code>.</p>
</dd>
</dl>

</li>
<li><p>For <code>type == "uniform"</code>, returns in addition
</p>

<dl>
<dt><code>lefts</code></dt><dd><p>A non-empty vector of numbers, same as the input.</p>
</dd>
<dt><code>rights</code></dt><dd><p>A non-empty vector of numbers, same as the input.</p>
</dd>
<dt><code>left_inf</code></dt><dd><p>A logical, indicates whether <code>lefts[1]</code> is <code>-Inf</code>.</p>
</dd>
<dt><code>right_inf</code></dt><dd><p>A logical, indicates whether <code>rights[length(rights)]</code> is <code>Inf</code>.</p>
</dd>
</dl>

</li>
<li><p>For <code>type == "polynomial"</code>, returns in addition
</p>

<dl>
<dt><code>rule</code></dt><dd><p>A string, same as the input if provided and valid; if not provided and <code>length(ineqs) == 1</code>, set to <code>"1"</code> by default.</p>
</dd>
<dt><code>postfix_rule</code></dt><dd><p>A string, <code>rule</code> in postfix notation (reverse Polish notation) containing numbers, <code>" "</code>, <code>"&amp;"</code> and <code>"|"</code> only.</p>
</dd>
<dt><code>ineqs</code></dt><dd><p>A list of lists, each sublist representing one inequality containing the following fields:
</p>

<dl>
<dt><code>uniform</code></dt><dd><p>A logical, indicates whether the inequality should be uniformly applied to all components (e.g. <code>"x&gt;1"</code> -&gt; <code>"x1&gt;1 &amp;&amp; ... &amp;&amp; xp&gt;1"</code>).</p>
</dd>
<dt><code>larger</code></dt><dd><p>A logical, indicates whether the polynomial should be larger or smaller than the constant (e.g. <code>TRUE</code> for <code>x1 + ... + xp &gt; C</code>, and <code>FALSE</code> for <code>x1 + ... + xp &lt; C</code>).</p>
</dd>
<dt><code>const</code></dt><dd><p>A number, the constant the polynomial should be compared to  (e.g. <code>2.3</code> for <code>x1 + ... + xp &gt; 2.3</code>).</p>
</dd>
<dt><code>abs</code></dt><dd><p>A logical, indicates whether one should evaluate the polynomial in <code>abs(x)</code> instead of <code>x</code>.</p>
</dd>
<dt><code>nonnegative</code></dt><dd><p>A logical, indicates whether the domain of this inequality should be restricted to the non-negative orthant.</p>
</dd>
<dt><code>power_numers</code></dt><dd><p>A single integer or a vector of <code>p</code> integers. <code>x[i]</code> will be raised to the power of <code>power_numers[i] / power_denoms[i]</code> (or without subscript if a singer integer). Note that <code>x^(0/0)</code> is interpreted as <code>log(x)</code>, and <code>x^(n/0)</code> as <code>exp(n*x)</code> for <code>n</code> non-zero. For a negative <code>x</code>, <code>x^(a/b)</code> is defined as <code>(-1)^a*|x|^(a/b)</code> if <code>b</code> is odd, or <code>NaN</code> otherwise.</p>
</dd>
<dt><code>power_denoms</code></dt><dd><p>A single integer or a vector of <code>p</code> integers.</p>
</dd>
<dt><code>coeffs</code></dt><dd><p><code>NULL</code> if <code>uniform == TRUE</code>. A vector of <code>p</code> doubles, where <code>coeffs[i]</code> is the coefficient on <code>x[i]</code> in the inequality</p>
</dd>
</dl>
</dd></dl>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 30
# The 30-dimensional real space R^30
domain &lt;- make_domain("R", p=p)

# The non-negative orthant of the 30-dimensional real space, R+^30
domain &lt;- make_domain("R+", p=p)

# x such that sum(x^2) &gt; 10 &amp;&amp; sum(x^(1/3)) &gt; 10 with x allowed to be negative
domain &lt;- make_domain("polynomial", p=p, rule="1 &amp;&amp; 2",
       ineqs=list(list("expression"="sum(x^2)&gt;10", abs=FALSE, nonnegative=FALSE),
                      list("expression"="sum(x^(1/3))&gt;10", abs=FALSE, nonnegative=FALSE)))
# Alternatively
domain2 &lt;- make_domain("polynomial", p=p, rule="1 &amp;&amp; 2",
       ineqs=list(list(uniform=FALSE, power_numers=2, power_denoms=1, const=10, coeffs=1,
                 larger=1, abs=FALSE, nonnegative=FALSE),
                 list(uniform=FALSE, power_numers=1, power_denoms=3, const=10, coeffs=1,
                 larger=1, abs=FALSE, nonnegative=FALSE)))


# ([0, 1] v [2,3]) ^ p
domain &lt;- make_domain("uniform", p=p, lefts=c(0,2), rights=c(1,3))

# x such that {x1 &gt; 1 &amp;&amp; log(1.3) &lt; x2 &lt; 1 &amp;&amp; x3 &gt; log(1.3) &amp;&amp; ... &amp;&amp; xp &gt; log(1.3)}
domain &lt;- make_domain("polynomial", p=p, rule="1 &amp;&amp; 2 &amp;&amp; 3",
       ineqs=list(list("expression"="x1&gt;1", abs=FALSE, nonnegative=TRUE),
                      list("expression"="x2&lt;1", abs=FALSE, nonnegative=TRUE),
                      list("expression"="exp(x)&gt;1.3", abs=FALSE, nonnegative=FALSE)))
# Alternatively
domain2 &lt;- make_domain("polynomial", p=p, rule="1 &amp;&amp; 2",
       ineqs=list(list(uniform=FALSE, power_numers=1, power_denoms=1, const=1,
                 coeffs=c(1,rep(0,p-1)), larger=1, abs=FALSE, nonnegative=TRUE),
                 list(uniform=FALSE, power_numers=1, power_denoms=1, const=1,
                 coeffs=c(0,1,rep(0,p-2)), larger=0, abs=FALSE, nonnegative=TRUE),
                 list(uniform=TRUE, power_numers=1, power_denoms=0, const=1.3,
                 larger=1, abs=FALSE, nonnegative=FALSE)))


# x in R_+^p such that {sum(log(x))&lt;2 || (x1^(2/3)-1.3x2^(-3)&lt;1 &amp;&amp; exp(x1)+2.3*x2&gt;2)}
domain &lt;- make_domain("polynomial", p=p, rule="1 || (2 &amp;&amp; 3)",
       ineqs=list(list("expression"="sum(log(x))&lt;2", abs=FALSE, nonnegative=TRUE),
                      list("expression"="x1^(2/3)-1.3x2^(-3)&lt;1", abs=FALSE, nonnegative=TRUE),
                      list("expression"="exp(x1)+2.3*x2^2&gt;2", abs=FALSE, nonnegative=TRUE)))
# Alternatively
domain2 &lt;- make_domain("polynomial", p=p, rule="1 &amp;&amp; 2",
       ineqs=list(list(uniform=FALSE, power_numers=0, power_denoms=0, const=2,
                 coeffs=1, larger=0, abs=FALSE, nonnegative=TRUE),
                 list(uniform=FALSE, power_numers=c(2,-3,rep(1,p-2)), power_denoms=c(3,rep(1,p-1)),
                 const=1, coeffs=c(1.0,-1.3,rep(0,p-2)), larger=0, abs=FALSE, nonnegative=TRUE),
                 list(uniform=FALSE, power_numers=c(1,2,rep(1,p-2)), power_denoms=c(0,rep(1,p-1)),
                 const=2, coeffs=c(1,2.3,rep(0,p-2)), larger=1, abs=FALSE, nonnegative=TRUE)))


# x in R_+^p such that {x in R_+^p: sum_j j * xj &lt;= 1}
domain &lt;- make_domain("polynomial", p=p,
       ineqs=list(list("expression"=paste(paste(sapply(1:p,
                           function(j){paste(j, "x", j, sep="")}), collapse="+"), "&lt;1"),
                     abs=FALSE, nonnegative=TRUE)))
# Alternatively
domain2 &lt;- make_domain("polynomial", p=p,
       ineqs=list(list(uniform=FALSE, power_numers=1, power_denoms=1, const=1,
                 coeffs=1:p, larger=0, abs=FALSE, nonnegative=TRUE)))


# The (p-1)-simplex
domain &lt;- make_domain("simplex", p=p)

# The l-1 ball {sum(|x|) &lt; 1}
domain &lt;- make_domain("polynomial", p=p,
       ineqs=list(list("expression"="sum(x)&lt;1", abs=TRUE, nonnegative=FALSE)))
</code></pre>

<hr>
<h2 id='make_folds'>Helper function for making fold IDs for cross validation.</h2><span id='topic+make_folds'></span>

<h3>Description</h3>

<p>Helper function for making fold IDs for cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_folds(nsamp, nfold, cv_fold_seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_folds_+3A_nsamp">nsamp</code></td>
<td>
<p>Number of samples.</p>
</td></tr>
<tr><td><code id="make_folds_+3A_nfold">nfold</code></td>
<td>
<p>Number of cross validation folds.</p>
</td></tr>
<tr><td><code id="make_folds_+3A_cv_fold_seed">cv_fold_seed</code></td>
<td>
<p>Seed for random shuffling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>nsamp</code> vectors, numbers 1 to <code>nsamp</code> shuffled and grouped into vectors of length <code>floor(nsamp/nfold)</code> followed by vectors of length <code>floor(nsamp/nfold)+1</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_folds(37, 5, NULL)
make_folds(100, 5, 2)
make_folds(100, 10, 3)
</code></pre>

<hr>
<h2 id='makecoprime'>Makes two integers coprime.</h2><span id='topic+makecoprime'></span>

<h3>Description</h3>

<p>Divides both integers by their greatest common divisor, switching their signs if the second integer is negative. If either integer is 0, returns without modification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makecoprime(a, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makecoprime_+3A_a">a</code></td>
<td>
<p>An integer.</p>
</td></tr>
<tr><td><code id="makecoprime_+3A_b">b</code></td>
<td>
<p>An integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The greatest (positive) common divisor of two integers; if one of them is 0, returns the absolute value of the other number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>makecoprime(1, 2)
makecoprime(1, -2)
makecoprime(12, -18)
makecoprime(-12, 18)
makecoprime(15, 0)
makecoprime(0, -15)
makecoprime(0, 0)
</code></pre>

<hr>
<h2 id='mu_sigmasqhat'>Estimates the mu and sigma squared parameters from a univariate truncated normal sample.</h2><span id='topic+mu_sigmasqhat'></span>

<h3>Description</h3>

<p>Estimates the mu and sigma squared parameters from a univariate truncated normal sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mu_sigmasqhat(x, mode, param1, param2, mu = NULL, sigmasq = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mu_sigmasqhat_+3A_x">x</code></td>
<td>
<p>A vector, the data.</p>
</td></tr>
<tr><td><code id="mu_sigmasqhat_+3A_mode">mode</code></td>
<td>
<p>A string, the class of the <code>h</code> function.</p>
</td></tr>
<tr><td><code id="mu_sigmasqhat_+3A_param1">param1</code></td>
<td>
<p>A number, the first parameter to the <code>h</code> function.</p>
</td></tr>
<tr><td><code id="mu_sigmasqhat_+3A_param2">param2</code></td>
<td>
<p>A number, the second parameter (may be optional depending on <code>mode</code>) to the <code>h</code> function.</p>
</td></tr>
<tr><td><code id="mu_sigmasqhat_+3A_mu">mu</code></td>
<td>
<p>A number, may be <code>NULL</code>. If <code>NULL</code>, an estimate will be given; otherwise, the value will be treated as the known true <code>mu</code> parameter and is used to calculate an estimate for <code>sigmasq</code>, if <code>sigmasq</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mu_sigmasqhat_+3A_sigmasq">sigmasq</code></td>
<td>
<p>A number, may be <code>NULL</code>. If <code>NULL</code>, an estimate will be given; otherwise, the value will be treated as the known true <code>sigmasq</code> parameter and is used to calculate an estimate for <code>mu</code>, if <code>mu</code> is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If both <code>mu</code> and <code>sigmasq</code> are provided, they are returned immediately. If neither is provided, the estimates are given as </p>
<p style="text-align: center;"><code class="reqn">[1/\sigma^2,\mu/\sigma^2]=\left\{\sum_{i=1}^nh(X_i)[X_i,-1][X_i,-1]^{\top}\right\}^{-1}\left\{\sum_{i=1}^n\left[h(X_i)+h'(X_i)X_i,-h'(X_i)\right]\right\}.</code>
</p>
<p> If only <code>sigmasq</code> is provided, the estimate for <code>mu</code> is given as </p>
<p style="text-align: center;"><code class="reqn">\sum_{i=1}^n[h(X_i)X_i-\sigma^2 h'(X_i)]/\sum_{i=1}^nh(X_i).</code>
</p>
<p> If only <code>mu</code> is given, the estimate for <code>sigmasq</code> is given as </p>
<p style="text-align: center;"><code class="reqn">\sum_{i=1}^n h(X_i)(X_i-\mu)^2/\sum_{i=1}^n[h(X_i)+h'(X_i)(X_i-\mu)].</code>
</p>



<h3>Value</h3>

<p>A vector that contains the <code>mu</code> and the <code>sigmasq</code> estimates.
</p>

<hr>
<h2 id='naiveSearch_bin'>Finds the index of the bin a number belongs to using naive search.</h2><span id='topic+naiveSearch_bin'></span>

<h3>Description</h3>

<p>Finds the index of the bin a number belongs to using naive search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>naiveSearch_bin(arr, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="naiveSearch_bin_+3A_arr">arr</code></td>
<td>
<p>A vector of size at least 2.</p>
</td></tr>
<tr><td><code id="naiveSearch_bin_+3A_x">x</code></td>
<td>
<p>A number. Must be within the range of [<code>arr[1]</code>, <code>arr[length(arr)]</code>].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Finds the smallest index <code>i</code> such that <code>arr[i] &lt;= x &lt;= arr[i+1]</code>.
</p>


<h3>Value</h3>

<p>The index <code>i</code> such that <code>arr[i] &lt;= x &lt;= arr[i+1]</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>naiveSearch_bin(1:10, seq(1, 10, by=0.5))
</code></pre>

<hr>
<h2 id='parse_ab'>Parses an ab setting into rational numbers a and b.</h2><span id='topic+parse_ab'></span>

<h3>Description</h3>

<p>Parses an ab setting into rational numbers a and b.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_ab(s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_ab_+3A_s">s</code></td>
<td>
<p>A string starting with &quot;ab_&quot;, followed by rational numbers a and b separated by &quot;_&quot;. a and b must be integers or rational numbers of the form &quot;int/int&quot;. See examples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the following elements:
</p>
<table role = "presentation">
<tr><td><code>a_numer</code></td>
<td>
<p>The numerator of <code>a</code>.</p>
</td></tr>
<tr><td><code>a_denom</code></td>
<td>
<p>The denominator of <code>a</code>.</p>
</td></tr>
<tr><td><code>b_numer</code></td>
<td>
<p>The numerator of <code>b</code>.</p>
</td></tr>
<tr><td><code>b_denom</code></td>
<td>
<p>The denominator of <code>b</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>parse_ab("ab_1_1") # gaussian: a = 1, b = 1
parse_ab("ab_2_5/4") # a = 2, b = 5/4
parse_ab("ab_5/4_3/2") # a = 5/4, b = 3/2
parse_ab("ab_3/2_0/0") # a = 3/2, b = 0/0 (log)
parse_ab("ab_1/2_0/0") # exp: a = 1/2, b = 0/0 (log)
</code></pre>

<hr>
<h2 id='parse_ineq'>Parses an ineq expression into a list of elements that represents the ineq.</h2><span id='topic+parse_ineq'></span>

<h3>Description</h3>

<p>Parses an ineq expression into a list of elements that represents the ineq.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_ineq(s, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_ineq_+3A_s">s</code></td>
<td>
<p>A string, an ineq expression. Please refer <code>make_domain()</code>.</p>
</td></tr>
<tr><td><code id="parse_ineq_+3A_p">p</code></td>
<td>
<p>An integer, the dimension.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please refer <code>make_domain()</code> for the syntax of the expression.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table role = "presentation">
<tr><td><code>uniform</code></td>
<td>
<p>A logical, indicates whether the ineq is a uniform expression that applies to each component independently (e.g. <code>x^2&gt;1</code>, <code>exp(3*|x|)&lt;3.4</code>).</p>
</td></tr>
<tr><td><code>const</code></td>
<td>
<p>A number, the constant side of the ineq that the variable side should compare to (e.g. <code>1.3</code> in <code>x1^2+2*x2^3&gt;1.3</code>).</p>
</td></tr>
<tr><td><code>larger</code></td>
<td>
<p>A logical, indicates whether the variable side of the expression should be larger or smaller than <code>const</code>.</p>
</td></tr>
<tr><td><code>power_numers</code></td>
<td>
<p>A single number or a vector of length <code>p</code>. The numerators of the powers in the ineq for each component (e.g. <code>c(2,3,5,0,-2)</code> for <br />
<code>x1^2+2*x2^(3/2)+3*x3^(5/3)+4*log(x4)+5*exp(-2*x)&gt;1</code>).</p>
</td></tr>
<tr><td><code>power_denoms</code></td>
<td>
<p>A single number or a vector of length <code>p</code>. The denominators of the powers in the ineq for each component (e.g. <code>c(1,2,3,0,0)</code> for <br />
<code>x1^2+2*x2^(3/2)+3*x3^(5/3)+4*log(x4)+5*exp(-2*x)&gt;1</code>).</p>
</td></tr>
<tr><td><code>coeffs</code></td>
<td>
<p>A vector of length <code>p</code> that represents the coefficients in the ineq associated with each component. Returned only if <code>uniform == FALSE</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 30
parse_ineq("sum(x^2)&gt;10", p)
parse_ineq("sum(x^(1/3))&gt;10", p)
parse_ineq("x1&gt;1", p)
parse_ineq("x2&lt;1", p)
parse_ineq("exp(x)&gt;1.3", p)
parse_ineq("sum(log(x)) &lt; 2", p)
parse_ineq("x1^(2/3)-1.3x2^(-3)&lt;1", p)
parse_ineq("exp(x1)+2.3*x2^2 &gt; 2", p)
parse_ineq(paste(paste(sapply(1:p,
                           function(j){paste(j, "x", j, sep="")}), collapse="+"), "&lt;1"), p)

parse_ineq("0.5*x1^(-2/3)-x3^3 + 2log(x2)- 1.3e4exp(-25*x6)+x8-.3x5^(-3/-4) &gt;= 2", 8)
parse_ineq("0.5*x1^(-2/3)-x2^(4/-6)+2e3x3^(-6/9) &lt; 3.5e5", 3)
parse_ineq("x^(-2/3)&lt;=3e3", 5)
parse_ineq("sum(x^(-2/3))&lt;=3e3", 5)
parse_ineq("x&lt;=3e3", 5)
parse_ineq("sum(x)&lt;=3e3", 5)
parse_ineq("exp(-23x)&lt;=3e3", 5)
parse_ineq("sum(exp(-23x))&lt;=3e3", 5)
</code></pre>

<hr>
<h2 id='ran_mat'>Random generator of matrices with given eigenvalues.</h2><span id='topic+ran_mat'></span>

<h3>Description</h3>

<p>Random generator of matrices with given eigenvalues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ran_mat(p, ev = stats::runif(p, 0, 10), seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ran_mat_+3A_p">p</code></td>
<td>
<p>A positive integer &gt;= 2, the dimension.</p>
</td></tr>
<tr><td><code id="ran_mat_+3A_ev">ev</code></td>
<td>
<p>A vector of length <code>p</code>, the eigenvalues of the output matrix.</p>
</td></tr>
<tr><td><code id="ran_mat_+3A_seed">seed</code></td>
<td>
<p>A number, the seed for the generator. Ignored if <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function randomly fills a <code>p</code> by <code>p</code> matrix with independent <code class="reqn">Normal(0,1)</code> entries, takes the <code>Q</code> matrix from its <code>QR</code> decomposition, and returns <code class="reqn">Q' diag(ev) Q</code>.
</p>


<h3>Value</h3>

<p>A <code>p</code> by <code>p</code> matrix whose eigenvalues equal to <code>ev</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 30
eigen_values &lt;- (0.1*p-1+1:p)/p
K &lt;- ran_mat(p, ev=eigen_values, seed=1)
sort(eigen(K)$val)-eigen_values
</code></pre>

<hr>
<h2 id='random_init_polynomial'>Randomly generate an initial point in the domain defined by a single polynomial with no negative coefficient.</h2><span id='topic+random_init_polynomial'></span>

<h3>Description</h3>

<p>Randomly generate an initial point in the domain defined by a single polynomial with no negative coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_init_polynomial(domain)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_init_polynomial_+3A_domain">domain</code></td>
<td>
<p>A list returned from <code>make_domain()</code> that represents the domain. Currently only supports <code>domain$type == "polynomial" &amp;&amp; length(domain$ineqs) == 1</code>. If <code>domain$ineqs[[1]]$uniform == FALSE</code>, <code>domain$ineqs[[1]]$coeffs</code> must not contain negative numbers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If inequality is uniform, find the uniform bound for each component and generate each coordinate using <code>random_init_uniform()</code>.
Otherwise, first randomly generate centered laplace variables for components with coefficient 0 (free variables).
Then assign a <code>quota</code> of <code>eq$const / length(nonzero_coefficient)</code> to each coordinate (so that each <br />
<code>frac_pow(x[i], eq$power_numers[i], eq$power_denoms[i], eq$abs) * eq$coeffs[i]</code> is compared to <code>quota</code>).
Deal with components with <code>exp()</code> term first, and generate each coordinate while fulfilling <code>quota</code> if possible; if not, randomly generate from <br />
<code>[-0.01,0.01]/abs(eq$power_numers[i])</code>.
Then recalculate the new <code>quota</code> which subtracts the exp() terms from <code>eq$const</code>, and this time divided by the number of remaining components.
If <code>quota</code> becomes negative and <code>eq$larger == FALSE</code>, each component, after <code>frac_pow()</code> is assumed to give a negative number.
This is not possible if the term has the form x^{even_number/even_number}, or if the term is not log() in the case where <code>eq$nonnegative == TRUE || eq$abs == TRUE</code>.
Change quota to a positive smaller in absolute value for these bad terms and generate.
Finally, recalculate quota as before and generate the rest of the &quot;good&quot; components.
</p>
<p>In some extreme domains the function may fail to generate a point within the domain.
Also, it is not guaranteed that the function returns a point in an area with a high probability density.
</p>


<h3>Value</h3>

<p>A <code>p</code> vector inside the domain defined by <code>domain</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 30
poly_d &lt;- function(ex, abs, nng){
   return (make_domain("polynomial", p=p, 
                       ineqs=list(list(expression=ex, abs=abs, nonnegative=nng))))
}

random_init_polynomial(poly_d(paste("sum(exp(x))&lt;=", p*1.01), abs=TRUE, nng=TRUE))
random_init_polynomial(poly_d(paste("sum(exp(x))&lt;=", p*1.01), abs=FALSE, nng=FALSE))
random_init_polynomial(poly_d(paste("sum(exp(x))&gt;", p*1.01), abs=TRUE, nng=TRUE))
random_init_polynomial(poly_d(paste("sum(exp(x))&gt;", p*1.01), abs=TRUE, nng=FALSE))
random_init_polynomial(poly_d(paste("sum(log(x))&lt;=", 0.01), abs=TRUE, nng=TRUE))
random_init_polynomial(poly_d(paste("sum(log(x))&gt;", 0.01), abs=TRUE, nng=TRUE))
random_init_polynomial(poly_d(paste("sum(x^2)&lt;=", 0.01), abs=TRUE, nng=TRUE))
random_init_polynomial(poly_d(paste("sum(x^2)&gt;", 0.01), abs=TRUE, nng=TRUE))

random_init_polynomial(poly_d(paste("exp(x)&lt;=", 1.01), abs=TRUE, nng=TRUE))
random_init_polynomial(poly_d(paste("exp(x)&lt;=", 1.01), abs=FALSE, nng=FALSE))
random_init_polynomial(poly_d(paste("exp(x)&gt;", 1.01), abs=TRUE, nng=TRUE))
random_init_polynomial(poly_d(paste("exp(x)&gt;", 1.01), abs=TRUE, nng=FALSE))
random_init_polynomial(poly_d(paste("log(x)&lt;=", 0.01), abs=TRUE, nng=TRUE))
random_init_polynomial(poly_d(paste("log(x)&gt;", 0.01), abs=TRUE, nng=TRUE))
random_init_polynomial(poly_d(paste("x^2&lt;=", 0.01), abs=TRUE, nng=TRUE))
random_init_polynomial(poly_d(paste("x^2&gt;", 0.01), abs=TRUE, nng=TRUE))

random_init_polynomial(poly_d("x1^2+x2^2+log(x3)&lt;-2", abs=TRUE, nng=TRUE))
random_init_polynomial(poly_d("x1^2+x2^2+log(x3)&gt;-2", abs=FALSE, nng=FALSE))
random_init_polynomial(poly_d("x1^(3/5)+x2^2+x3^(1/3)&lt;-2", abs=FALSE, nng=FALSE))
random_init_polynomial(poly_d("x1^(3/5)+x2^2+x3^(1/3)&gt;-2", abs=FALSE, nng=FALSE))
random_init_polynomial(poly_d("x1^(3/5)+1.2*exp(2*x2)+2.3*exp(-3*x3)&lt;-2", abs=FALSE, nng=FALSE))
random_init_polynomial(poly_d("x1^(3/5)+1.2*exp(2*x2)+2.3*exp(-3*x3)&lt;2", abs=TRUE, nng=FALSE))
random_init_polynomial(poly_d("x1^(3/5)+1.2*exp(2*x2)+2.3*exp(-3*x3)&gt;-2", abs=TRUE, nng=FALSE))
random_init_polynomial(poly_d("x1^(3/5)+2.3*log(x4)+1.3*exp(2*x2)+0.7*exp(-3*x3)&lt;-2", 
                       abs=TRUE, nng=FALSE))
random_init_polynomial(poly_d("x1^(3/5)+2.3*log(x4)+1.3*exp(2*x2)+0.7*exp(-3*x3)&gt;-2", 
                       abs=FALSE, nng=FALSE))
random_init_polynomial(poly_d(
   "x1^(3/5)+0.9*x2^(2/3)+2.7*x3^(-3/2)+1.1*x4^(-5)+1.1*exp(2x5)+1.3*exp(-3x6)+0.7*log(x7)&lt;-2", 
                       abs=TRUE, nng=FALSE))
random_init_polynomial(poly_d(
   "x1^(3/5)+0.9*x2^(2/3)+2.7*x3^(-3/2)+1.1*x4^(-5)+1.1*exp(2x5)+1.3*exp(-3x6)+0.7*log(x7)&lt;-2", 
                       abs=FALSE, nng=TRUE))
random_init_polynomial(poly_d(
   "x1^(3/5)+0.9*x2^(2/3)+2.7*x3^(-3/2)+1.1*x4^(-5)+1.1*exp(2x5)+1.3*exp(-3x6)+0.7*log(x7)&gt;-2", 
                       abs=TRUE, nng=FALSE))
random_init_polynomial(poly_d(
   "x1^(3/5)+0.9*x2^(2/3)+2.7*x3^(-3/2)+1.1*x4^(-5)+1.1*exp(2x5)+1.3*exp(-3x6)+0.7*log(x7)&gt;2", 
                       abs=TRUE, nng=TRUE))
random_init_polynomial(poly_d(
   "x1^(3/5)+0.9*x2^(2/3)+2.7*x3^(-3/2)+1.1*x4^(-5)+1.1*exp(2x5)+1.3*exp(-3x6)+0.7*log(x7)&gt;2", 
                       abs=FALSE, nng=FALSE))
</code></pre>

<hr>
<h2 id='random_init_simplex'>Generates a random point in the (p-1)-simplex.</h2><span id='topic+random_init_simplex'></span>

<h3>Description</h3>

<p>Generates a random point in the <code>(p-1)</code>-simplex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_init_simplex(p, rdist = stats::rnorm, tol = 1e-10, maxtimes = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_init_simplex_+3A_p">p</code></td>
<td>
<p>An integer, the dimension.</p>
</td></tr>
<tr><td><code id="random_init_simplex_+3A_rdist">rdist</code></td>
<td>
<p>A function that generates a random number when called using <code>rdist(1)</code>. Must return a non-zero number with a large enough probability.</p>
</td></tr>
<tr><td><code id="random_init_simplex_+3A_tol">tol</code></td>
<td>
<p>A small positive number. Samples are regenerated until each of the <code>p</code> components are at least of size <code>tol</code>.</p>
</td></tr>
<tr><td><code id="random_init_simplex_+3A_maxtimes">maxtimes</code></td>
<td>
<p>An integer, maximum number of attempts.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>p</code> numbers are generated from <code>rdist</code> and their absolute values are normalized to sum to 1. This will be repeated up to <code>maxtimes</code> times until all <code>p</code> components are larger than or equal to <code>tol</code>.
</p>


<h3>Value</h3>

<p>A random point (<code>p</code>-vector) in the <code>(p-1)</code>-simplex, i.e. <code>sum(x) == 1 &amp;&amp; x &gt; 0</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>random_init_simplex(100, stats::rnorm, 1e-10, 100)
</code></pre>

<hr>
<h2 id='random_init_uniform'>Generates random numbers from a finite union of intervals.</h2><span id='topic+random_init_uniform'></span>

<h3>Description</h3>

<p>Generates random numbers from a finite union of intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_init_uniform(n, lefts, rights)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_init_uniform_+3A_n">n</code></td>
<td>
<p>An integer, the number of samples to return.</p>
</td></tr>
<tr><td><code id="random_init_uniform_+3A_lefts">lefts</code></td>
<td>
<p>A vector of numbers, must have the same length as <code>rights</code>. A non-empty vector of numbers (may contain <code>-Inf</code>), the left endpoints of a domain defined as a union of intervals. It is required that <code>lefts[i] &lt;= rights[i] &lt;= lefts[j]</code> for any <code>i &lt; j</code>.</p>
</td></tr>
<tr><td><code id="random_init_uniform_+3A_rights">rights</code></td>
<td>
<p>A vector of numbers, must have the same length as <code>lefts</code>. A non-empty vector of numbers (may contain <code>Inf</code>), the right endpoints of a domain defined as a union of intervals. It is required that <code>lefts[i] &lt;= rights[i] &lt;= lefts[j]</code> for any <code>i &lt; j</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each sample, a random bin <code>i</code> is uniformly chosen from 1 through <code>length(lefts)</code>; if the <code>lefts[i]</code> and <code>rights[i]</code> define a finite interval, a random uniform variable is drawn from the interval; if the interval is infinite, a truncated laplace variable with location 0 and scale 1 is drawn. Used for randomly generating initial points for generators of truncated multivariate distributions.
</p>


<h3>Value</h3>

<p><code>n</code> random numbers from the union of intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hist(random_init_uniform(1e4, -Inf, Inf), breaks=200)
hist(random_init_uniform(1e4, c(0, 5), c(2, Inf)), breaks=200)
hist(random_init_uniform(1e4, c(-Inf, 0, 3), c(-3, 1, 12)), breaks=200)
hist(random_init_uniform(1e4, c(-5, 0), c(-2, 2)), breaks=200)
hist(random_init_uniform(1e4, c(-10, 1), c(-7, 10)), breaks=200)
hist(random_init_uniform(1e4, c(-Inf, 100), c(-100, Inf)), breaks=200)
hist(random_init_uniform(1e4, c(-100, -90), c(-95, -85)), breaks=200)
</code></pre>

<hr>
<h2 id='read_exponent'>Parses the exponent part into power_numer and power_denom.</h2><span id='topic+read_exponent'></span>

<h3>Description</h3>

<p>Parses the exponent part into power_numer and power_denom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_exponent(s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_exponent_+3A_s">s</code></td>
<td>
<p>A string. Must be of the form &quot;&quot; (empty string), &quot;^2&quot;, &quot;^(-5/3)&quot; followed by other terms (starting with &quot;+&quot; or &quot;-&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parses the exponential part of the first term into power_numer and power_denom and returns the rest of the terms. Please refer to the examples. <code>s</code> must be of the form &quot;&quot;, &quot;^2&quot;, &quot;^(-5/3)&quot; followed by other terms, e.g. &quot;+x2^2&quot;, &quot;^2+x2^2&quot;, &quot;^(-5/3)+x2^2&quot;. Assuming these come from &quot;x1+x2^2&quot;, &quot;x1^2+x2^2&quot; and &quot;x1^(-5/3)+x2^2&quot;, respectively, these will parsed into <code>power_numer=1, power_denom=1</code>, <code>power_numer=2, power_denom=1</code>, and <code>power_numer=-5, power_denom=3</code>, respectively.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table role = "presentation">
<tr><td><code>power_numer</code></td>
<td>
<p>An integer, the numerator of the power.</p>
</td></tr>
<tr><td><code>power_denom</code></td>
<td>
<p>An integer, the denominator of the power.</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>A string, the rest of the unparsed string.</p>
</td></tr>
</table>
<p>If parsing is unsuccessful, <code>NULL</code> is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>read_exponent("")
read_exponent("^(-2*4)") # Unsuccessful parsing, returns \code{NULL}.
read_exponent("+x2^(2/3)+x3^(-3/4)") # Comes from "x1+x2^(2/3)+x3^(-3/4)"
read_exponent("^2+x2^(2/3)+x3^(-3/4)") # Comes from "x1^2+x2^(2/3)+x3^(-3/4)"
read_exponent("^(2/3)+x2^(2/3)+x3^(-3/4)") # Comes from "x1^(2/3)+x2^(2/3)+x3^(-3/4)"
read_exponent("^(-2)+x2^(2/3)+x3^(-3/4)") # Comes from "x1^(-2)+x2^(2/3)+x3^(-3/4)"
read_exponent("^(-2/3)+x2^(2/3)+x3^(-3/4)") # Comes from "x1^(-2/3)+x2^(2/3)+x3^(-3/4)"
</code></pre>

<hr>
<h2 id='read_exponential'>Parses the integer coefficient in an exponential term.</h2><span id='topic+read_exponential'></span>

<h3>Description</h3>

<p>Parses the integer coefficient in an exponential term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_exponential(s, has_index)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_exponential_+3A_s">s</code></td>
<td>
<p>A string that starts with one of the following forms: <code>exp(x)</code>, <code>exp(-x)</code>, <code>exp(2x)</code>, <code>exp(-2x)</code>, <code>exp(12*x)</code>, <code>exp(-123*x)</code>, followed by other terms. If <code>has_index == TRUE</code>, the first term should be rewritten in <code>x</code> with an index (e.g. <code>exp(x1)</code>, <code>exp(-2*x2)</code>).</p>
</td></tr>
<tr><td><code id="read_exponential_+3A_has_index">has_index</code></td>
<td>
<p>A logical, indicates whether the term is written in a component (e.g. <code>x1</code>, <code>x2</code>) as opposed to a uniform term (i.e. <code>x</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parses the coefficient in the first exponential term and returns the rest of the terms.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table role = "presentation">
<tr><td><code>power_numer</code></td>
<td>
<p>An integer, the integer coefficient inside the first exponential term.</p>
</td></tr>
<tr><td><code>idx</code></td>
<td>
<p>An integer, the index of the term matched (e.g. <code>3</code> for <code>exp(2*x3)</code>). <code>NULL</code> if <code>has_index == FALSE</code>.</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>A string, the rest of the unparsed string.</p>
</td></tr>
</table>
<p>If parsing is unsuccessful, <code>NULL</code> is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Unsuccessful parsing, not starting with exponential, returns \code{NULL}.
read_exponential("x", FALSE)
# Unsuccessful parsing, not starting with exponential, returns \code{NULL}.
read_exponential("x1^2+exp(2x2)", TRUE)
read_exponential("exp(x)", FALSE)
read_exponential("exp(x1)", TRUE)
read_exponential("exp(-x)", FALSE)
read_exponential("exp(-x1)+x2^2", TRUE)
read_exponential("exp(2x)", FALSE)
read_exponential("exp(2x1)+x2^(-2/3)", TRUE)
read_exponential("exp(-2x)", FALSE)
read_exponential("exp(-2x1)+exp(x3)", TRUE)
read_exponential("exp(12x)", FALSE)
read_exponential("exp(12x2)+x3^(-3)+x4^2", TRUE)
read_exponential("exp(-12x)", FALSE)
read_exponential("exp(-12x3)+x1^(2/5)+log(x2)", TRUE)
read_exponential("exp(123*x)", FALSE)
read_exponential("exp(123*x1)+x2^4", TRUE)
read_exponential("exp(-123*x)", FALSE)
read_exponential("exp(-123*x4)+exp(2*x3)", TRUE)
</code></pre>

<hr>
<h2 id='read_one_term'>Parses the first term of a non-uniform expression.</h2><span id='topic+read_one_term'></span>

<h3>Description</h3>

<p>Parses the first term of a non-uniform expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_one_term(s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_one_term_+3A_s">s</code></td>
<td>
<p>A string, the variable side of a non-uniform inequality expression (i.e. terms must be rewritten in e.g. <code>x1</code>, <code>x2</code> as opposed to <code>x</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parses the first term in a non-uniform expression and returns the rest of the terms.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table role = "presentation">
<tr><td><code>idx</code></td>
<td>
<p>An integer, the index of the first term (e.g. <code>3</code> for <code>1.3*x3^(-2/5))</code>).</p>
</td></tr>
<tr><td><code>power_numer</code></td>
<td>
<p>An integer, the power_numer of the first term.</p>
</td></tr>
<tr><td><code>power_denom</code></td>
<td>
<p>An integer, the power_denom of the first term.</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>A number, the coefficient on the first term (e.g. <code>1.3</code> for <code>1.3*x3^(-2/5)</code>).</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>A string, the rest of the unparsed string.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>read_one_term("0.5*x1+x2^2")
read_one_term("2e3x1^(2/3)-1.3x2^(-3)")
read_one_term("2exp(3x1)+2.3*x2^2")
read_one_term(paste(sapply(1:10, function(j){paste(j, "x", j, "^", (11-j), sep="")}), collapse="+"))
read_one_term("0.5*x1^(-2/3)-x3^3 + 2log(x2)- 1.3e4exp(-25*x6)+x8-.3x5^(-3/-4)")
read_one_term("-1e-4x1^(-2/3)-x2^(4/-6)+2e3x3^(-6/9) &lt; 3.5e5")
</code></pre>

<hr>
<h2 id='read_uniform_term'>Attempts to parse a single term in x into power_numer and power_denom.</h2><span id='topic+read_uniform_term'></span>

<h3>Description</h3>

<p>Attempts to parse a single term in x into power_numer and power_denom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_uniform_term(s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_uniform_term_+3A_s">s</code></td>
<td>
<p>A string, the variable side of an inequality expression. Please refer to <code>make_domain()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns <code>NULL</code> if <code>s</code> is not a single uniform term in <code>x</code> (e.g. <code>x^2</code> is uniform, while <code>x1^2+x2^2</code> is not uniform).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>power_numers</code></td>
<td>
<p>The uniform numerator in the power (e.g. <code>-2</code> for <code>x^(-2/3)</code>).</p>
</td></tr>
<tr><td><code>power_denoms</code></td>
<td>
<p>The uniform denominator in the power (e.g. <code>3</code> for <code>x^(-2/3)</code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 30
read_uniform_term("x^2")
read_uniform_term("x^(1/3)")
read_uniform_term("exp(x)")
read_uniform_term("log(x)")
read_uniform_term("x^(-2/3)")
read_uniform_term("x")
read_uniform_term("exp(-23x)")
</code></pre>

<hr>
<h2 id='refit'>Loss for a refitted (restricted) unpenalized model</h2><span id='topic+refit'></span>

<h3>Description</h3>

<p>Refits an unpenalized model restricted to the estimated edges, with <code>lambda1=0</code>, <code>lambda2=0</code> and <code>diagonal_multiplier=1</code>. Returns <code>Inf</code> if no unique solution exists (when the loss is unbounded from below or has infinitely many minimizers).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refit(res, elts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="refit_+3A_res">res</code></td>
<td>
<p>A list of results returned by <code>get_results()</code>.</p>
</td></tr>
<tr><td><code id="refit_+3A_elts">elts</code></td>
<td>
<p>A list, elements necessary for calculations returned by <code>get_elts()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently the function only returns <code>Inf</code> when the maximum node degree is &gt;= the sample size, which is a sufficient and necessary condition for nonexistence of a unique solution with probability 1 if <code>symmetric != "symmetric"</code>. In practice it is also a sufficient and necessary condition for most cases and <code>symmetric == "symmetric"</code>.
</p>


<h3>Value</h3>

<p>A number, the loss of the refitted model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Examples are shown for Gaussian truncated to R+^p only. For other distributions
#   on other types of domains, please refer to \code{gen()} or \code{get_elts()},
#   as the way to call this function (\code{refit()}) is exactly the same in those cases.
n &lt;- 50
p &lt;- 30
domain &lt;- make_domain("R+", p=p)
h_hp &lt;- get_h_hp("min_pow", 1, 3)
mu &lt;- rep(0, p)
K &lt;- diag(p)
dm &lt;- 1 + (1-1/(1+4*exp(1)*max(6*log(p)/n, sqrt(6*log(p)/n))))
x &lt;- tmvtnorm::rtmvnorm(n, mean = mu, sigma = solve(K),
       lower = rep(0, p), upper = rep(Inf, p), algorithm = "gibbs",
       burn.in.samples = 100, thinning = 10)

elts_gauss_np &lt;- get_elts(h_hp, x, setting="gaussian", domain=domain,
                centered=FALSE, profiled=FALSE, diag=dm)
res_nc_np &lt;- get_results(elts_gauss_np, symmetric="symmetric",
               lambda1=0.35, lambda2=2, previous_res=NULL, is_refit=FALSE)
refit(res_nc_np, elts_gauss_np)

elts_gauss_p &lt;- get_elts(h_hp, x, setting="gaussian", domain=domain,
               centered=FALSE, profiled=TRUE, diag=dm)
res_nc_p &lt;- get_results(elts_gauss_p, symmetric="symmetric",
              lambda1=0.35, lambda2=NULL, previous_res=NULL, is_refit=FALSE)
refit(res_nc_p, elts_gauss_p)

elts_gauss_c &lt;- get_elts(h_hp, x, setting="gaussian", domain=domain,
            centered=TRUE, diag=dm)
res_c &lt;- get_results(elts_gauss_c, symmetric="or", lambda1=0.35,
           lambda2=NULL, previous_res=NULL, is_refit=FALSE)
refit(res_c, elts_gauss_c)

</code></pre>

<hr>
<h2 id='rexp_truncated'>Generates translated and truncated exponential variables.</h2><span id='topic+rexp_truncated'></span>

<h3>Description</h3>

<p>Generates translated and truncated exponential variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rexp_truncated(n, lo, hi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rexp_truncated_+3A_n">n</code></td>
<td>
<p>An integer, the number of samples to return.</p>
</td></tr>
<tr><td><code id="rexp_truncated_+3A_lo">lo</code></td>
<td>
<p>A double, the lower limit of the distribution, cannot be <code>-Inf</code>.</p>
</td></tr>
<tr><td><code id="rexp_truncated_+3A_hi">hi</code></td>
<td>
<p>A double, the upper limit of the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns <code>n</code> random variables from the translated truncated exponential distribution with density <code class="reqn">\exp(-(x-lo))/(1-\exp(lo-hi))</code> on <code>[lo,hi]</code>.
</p>


<h3>Value</h3>

<p><code>n</code> random variables from the translated truncated exponential distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hist(rexp_truncated(1e4, 0, Inf), breaks=200)
hist(rexp_truncated(1e4, 10, 12), breaks=200)
hist(rexp_truncated(1e4, -2, 2), breaks=200)
hist(rexp_truncated(1e4, -10, 0), breaks=200)
hist(rexp_truncated(1e4, -100, Inf), breaks=200)
hist(rexp_truncated(1e4, -100, -95), breaks=200)
</code></pre>

<hr>
<h2 id='rlaplace_truncated'>Generates laplace variables truncated to a finite union of intervals.</h2><span id='topic+rlaplace_truncated'></span>

<h3>Description</h3>

<p>Generates laplace variables truncated to a finite union of intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlaplace_truncated(n, lefts, rights, m = 0, s = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rlaplace_truncated_+3A_n">n</code></td>
<td>
<p>An integer, the number of samples to return.</p>
</td></tr>
<tr><td><code id="rlaplace_truncated_+3A_lefts">lefts</code></td>
<td>
<p>A vector of numbers, must have the same length as <code>rights</code>. A non-empty vector of numbers (may contain <code>-Inf</code>), the left endpoints of a domain defined as a union of intervals. It is required that <code>lefts[i] &lt;= rights[i] &lt;= lefts[j]</code> for any <code>i &lt; j</code>.</p>
</td></tr>
<tr><td><code id="rlaplace_truncated_+3A_rights">rights</code></td>
<td>
<p>A vector of numbers, must have the same length as <code>lefts</code>. A non-empty vector of numbers (may contain <code>Inf</code>), the right endpoints of a domain defined as a union of intervals. It is required that <code>lefts[i] &lt;= rights[i] &lt;= lefts[j]</code> for any <code>i &lt; j</code>.</p>
</td></tr>
<tr><td><code id="rlaplace_truncated_+3A_m">m</code></td>
<td>
<p>A number, the location parameter of the laplace distribution.</p>
</td></tr>
<tr><td><code id="rlaplace_truncated_+3A_s">s</code></td>
<td>
<p>A number, the scale/dispersion parameter of the laplace distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns <code>n</code> random variables from the truncated laplace distribution with density proportional to <code class="reqn">\exp(-|x-m|/s)</code> truncated to the domain defined by the union of [<code>lefts[i]</code>, <code>rights[i]</code>].
</p>


<h3>Value</h3>

<p><code>n</code> random variables from the truncated laplace distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hist(rlaplace_truncated(1e4, -Inf, Inf), breaks=200)
hist(rlaplace_truncated(1e4, c(0, 5), c(2, Inf), m=2, s=3), breaks=200)
hist(rlaplace_truncated(1e4, c(-Inf, 0, 3), c(-3, 1, 12), m=8, s=4), breaks=200)
hist(rlaplace_truncated(1e4, c(-5, 0), c(-2, 2), s=0.8), breaks=200)
hist(rlaplace_truncated(1e4, c(-10, 1), c(-7, 10), m=-4), breaks=200)
hist(rlaplace_truncated(1e4, c(-Inf, 100), c(-100, Inf), m=100), breaks=200)
hist(rlaplace_truncated(1e4, c(-Inf, 100), c(-100, Inf), m=-100), breaks=200)
hist(rlaplace_truncated(1e4, c(-100, -90), c(-95, -85), s=2), breaks=200)
</code></pre>

<hr>
<h2 id='rlaplace_truncated_centered'>Generates centered laplace variables with scale 1.</h2><span id='topic+rlaplace_truncated_centered'></span>

<h3>Description</h3>

<p>Generates centered laplace variables with scale 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlaplace_truncated_centered(n, lo, hi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rlaplace_truncated_centered_+3A_n">n</code></td>
<td>
<p>An integer, the number of samples to return.</p>
</td></tr>
<tr><td><code id="rlaplace_truncated_centered_+3A_lo">lo</code></td>
<td>
<p>A double, the lower limit of the distribution.</p>
</td></tr>
<tr><td><code id="rlaplace_truncated_centered_+3A_hi">hi</code></td>
<td>
<p>A double, the upper limit of the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns <code>n</code> random variables from the truncated laplace distribution with density proportional to <code class="reqn">\exp(-|x|)</code> on <code>[lo,hi]</code>.
</p>


<h3>Value</h3>

<p><code>n</code> random variables from the truncated laplace distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hist(rlaplace_truncated_centered(1e4, -Inf, Inf), breaks=200)
hist(rlaplace_truncated_centered(1e4, 0, Inf), breaks=200)
hist(rlaplace_truncated_centered(1e4, 10, 12), breaks=200)
hist(rlaplace_truncated_centered(1e4, -2, 2), breaks=200)
hist(rlaplace_truncated_centered(1e4, -10, 0), breaks=200)
hist(rlaplace_truncated_centered(1e4, -100, Inf), breaks=200)
hist(rlaplace_truncated_centered(1e4, -100, -95), breaks=200)
</code></pre>

<hr>
<h2 id='s_at'>Returns the character at a position of a string.</h2><span id='topic+s_at'></span>

<h3>Description</h3>

<p>Returns the character at a position of a string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_at(string, position)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="s_at_+3A_string">string</code></td>
<td>
<p>A string.</p>
</td></tr>
<tr><td><code id="s_at_+3A_position">position</code></td>
<td>
<p>A positive number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calls <code>substr(string, position, position)</code>.
</p>


<h3>Value</h3>

<p>A character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s_at("123", 1)
s_at("123", 2)
s_at("123", 3)
s_at("123", 4)
s_at("123", 0)
</code></pre>

<hr>
<h2 id='s_output'>Helper function for outputting if verbose.</h2><span id='topic+s_output'></span>

<h3>Description</h3>

<p>Helper function for outputting if verbose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_output(out, verbose, verbosetext)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="s_output_+3A_out">out</code></td>
<td>
<p>Text string.</p>
</td></tr>
<tr><td><code id="s_output_+3A_verbose">verbose</code></td>
<td>
<p>Boolean.</p>
</td></tr>
<tr><td><code id="s_output_+3A_verbosetext">verbosetext</code></td>
<td>
<p>Text string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>verbose == TRUE</code>, outputs a string that concatenates <code>verbosetext</code> and <code>out</code>.
</p>

<hr>
<h2 id='search_bin'>Finds the index of the bin a number belongs to.</h2><span id='topic+search_bin'></span>

<h3>Description</h3>

<p>Finds the index of the bin a number belongs to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_bin(arr, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="search_bin_+3A_arr">arr</code></td>
<td>
<p>A vector of size at least 2.</p>
</td></tr>
<tr><td><code id="search_bin_+3A_x">x</code></td>
<td>
<p>A number. Must be within the range of [<code>arr[1]</code>, <code>arr[length(arr)]</code>].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Finds the smallest index <code>i</code> such that <code>arr[i] &lt;= x &lt;= arr[i+1]</code>. Calls <code>binarySearch_bin()</code> if <code>length(arr) &gt; 8</code> and calls <code>naiveSearch_bin()</code> otherwise.
</p>


<h3>Value</h3>

<p>The index <code>i</code> such that <code>arr[i] &lt;= x &lt;= arr[i+1]</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>search_bin(1:10, seq(1, 10, by=0.5))
</code></pre>

<hr>
<h2 id='test_lambda_bounds'>Searches for a tight bound for <code class="reqn">\lambda_{\boldsymbol{K}}</code> that gives the empty or complete graph starting from a given lambda with a given step size</h2><span id='topic+test_lambda_bounds'></span>

<h3>Description</h3>

<p>Searches for the smallest lambda that gives the empty graph (if <code>lower == FALSE</code>) or the largest that gives the complete graph (if <code>lower == TRUE</code>) starting from the given lambda, each time updating by multiplying or dividing by <code>step</code> depending on the search direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_lambda_bounds(
  elts,
  symmetric,
  lambda = 1,
  lambda_ratio = 1,
  step = 2,
  lower = TRUE,
  verbose = TRUE,
  tol = 1e-06,
  maxit = 10000,
  cur_res = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_lambda_bounds_+3A_elts">elts</code></td>
<td>
<p>A list, elements necessary for calculations returned by <code>get_elts()</code>.</p>
</td></tr>
<tr><td><code id="test_lambda_bounds_+3A_symmetric">symmetric</code></td>
<td>
<p>A string. If equals <code>"symmetric"</code>, estimates the minimizer <code class="reqn">\mathbf{K}</code> over all symmetric matrices; if <code>"and"</code> or <code>"or"</code>, use the &quot;and&quot;/&quot;or&quot; rule to get the support</p>
</td></tr>
<tr><td><code id="test_lambda_bounds_+3A_lambda">lambda</code></td>
<td>
<p>A number, the initial searching point for <code class="reqn">\lambda_{\mathbf{K}}</code>.</p>
</td></tr>
<tr><td><code id="test_lambda_bounds_+3A_lambda_ratio">lambda_ratio</code></td>
<td>
<p>A positive number (or <code>Inf</code>), the fixed ratio <code class="reqn">\lambda_{\mathbf{K}}</code> and <code class="reqn">\lambda_{\boldsymbol{\eta}}</code>, if <code class="reqn">\lambda_{\boldsymbol{\eta}}\neq 0</code> (non-profiled) in the non-centered setting.</p>
</td></tr>
<tr><td><code id="test_lambda_bounds_+3A_step">step</code></td>
<td>
<p>A number, the multiplicative constant applied to lambda at each iteration. Must be strictly larger than 1.</p>
</td></tr>
<tr><td><code id="test_lambda_bounds_+3A_lower">lower</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, finds the largest possible lambda that gives the complete graph (a <code class="reqn">lower</code> bound). If <code>FALSE</code>, finds the smallest possible lambda that gives the empty graph (an <code class="reqn">upper</code> bound).</p>
</td></tr>
<tr><td><code id="test_lambda_bounds_+3A_verbose">verbose</code></td>
<td>
<p>Optional. A boolean. If <code>TRUE</code>, prints out the lambda value at each iteration.</p>
</td></tr>
<tr><td><code id="test_lambda_bounds_+3A_tol">tol</code></td>
<td>
<p>Optional. A number, the tolerance parameter.</p>
</td></tr>
<tr><td><code id="test_lambda_bounds_+3A_maxit">maxit</code></td>
<td>
<p>Optional. A positive integer, the maximum number of iterations in model fitting for each lambda.</p>
</td></tr>
<tr><td><code id="test_lambda_bounds_+3A_cur_res">cur_res</code></td>
<td>
<p>Optional. A list, current results returned from a previous lambda. If provided, used as a warm start. Default to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>lambda</code></td>
<td>
<p>A number, the best <code>lambda</code> that produces the desired number of edges. <code>1e-10</code> or <code>1e15</code> is returned if out of bound.</p>
</td></tr>
<tr><td><code>cur_res</code></td>
<td>
<p>A list, results for this <code>lambda</code>. May be <code>NULL</code> if <code>lambda</code> is out of bound.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Examples are shown for Gaussian truncated to R+^p only. For other distributions
#   on other types of domains, please refer to \code{gen()} or \code{get_elts()}, as the
#   way to call this function (\code{test_lambda_bounds()}) is exactly the same in those cases.
n &lt;- 50
p &lt;- 30
domain &lt;- make_domain("R+", p=p)
mu &lt;- rep(0, p)
K &lt;- diag(p)
x &lt;- tmvtnorm::rtmvnorm(n, mean = mu, sigma = solve(K),
       lower = rep(0, p), upper = rep(Inf, p), algorithm = "gibbs",
       burn.in.samples = 100, thinning = 10)

h_hp &lt;- get_h_hp("min_pow", 1, 3)
dm &lt;- 1 + (1-1/(1+4*exp(1)*max(6*log(p)/n, sqrt(6*log(p)/n))))
elts_gauss_np &lt;- get_elts(h_hp, x, setting="gaussian", domain=domain,
                 centered=FALSE, profiled=FALSE, diag=dm)
lambda_cur_res &lt;- test_lambda_bounds(elts_gauss_np, "symmetric", lambda=1,
                  lambda_ratio=1, step=1.5, lower=TRUE, cur_res=NULL)
lambda_cur_res2 &lt;- test_lambda_bounds(elts_gauss_np, "symmetric", lambda=1,
                  lambda_ratio=1, step=1.5, lower=FALSE, cur_res=lambda_cur_res$cur_res)
</code></pre>

<hr>
<h2 id='test_lambda_bounds2'>Searches for a tight bound for <code class="reqn">\lambda_{\boldsymbol{K}}</code> that gives the empty or complete graph starting from a given lambda</h2><span id='topic+test_lambda_bounds2'></span>

<h3>Description</h3>

<p>Searches for the smallest lambda that gives the empty graph (if <code>lower == FALSE</code>) or the largest that gives the complete graph (if <code>lower == TRUE</code>) starting from the given lambda.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_lambda_bounds2(
  elts,
  symmetric,
  lambda_ratio = Inf,
  lower = TRUE,
  verbose = TRUE,
  tol = 1e-06,
  maxit = 10000,
  lambda_start = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_lambda_bounds2_+3A_elts">elts</code></td>
<td>
<p>A list, elements necessary for calculations returned by get_elts().</p>
</td></tr>
<tr><td><code id="test_lambda_bounds2_+3A_symmetric">symmetric</code></td>
<td>
<p>A string. If equals <code>"symmetric"</code>, estimates the minimizer <code class="reqn">\mathbf{K}</code> over all symmetric matrices; if <code>"and"</code> or <code>"or"</code>, use the &quot;and&quot;/&quot;or&quot; rule to get the support</p>
</td></tr>
<tr><td><code id="test_lambda_bounds2_+3A_lambda_ratio">lambda_ratio</code></td>
<td>
<p>A positive number (or <code>Inf</code>), the fixed ratio <code class="reqn">\lambda_{\mathbf{K}}</code> and <code class="reqn">\lambda_{\boldsymbol{\eta}}</code>, if <code class="reqn">\lambda_{\boldsymbol{\eta}}\neq 0</code> (non-profiled) in the non-centered setting.</p>
</td></tr>
<tr><td><code id="test_lambda_bounds2_+3A_lower">lower</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, finds the largest possible lambda that gives the complete graph (a <code class="reqn">lower</code> bound). If <code>FALSE</code>, finds the smallest possible lambda that gives the empty graph (an <code class="reqn">upper</code> bound).</p>
</td></tr>
<tr><td><code id="test_lambda_bounds2_+3A_verbose">verbose</code></td>
<td>
<p>Optional.  A boolean. If <code>TRUE</code>, prints out the lambda value at each iteration.</p>
</td></tr>
<tr><td><code id="test_lambda_bounds2_+3A_tol">tol</code></td>
<td>
<p>Optional. A number, the tolerance parameter.</p>
</td></tr>
<tr><td><code id="test_lambda_bounds2_+3A_maxit">maxit</code></td>
<td>
<p>Optional. A positive integer, the maximum number of iterations in model fitting for each lambda.</p>
</td></tr>
<tr><td><code id="test_lambda_bounds2_+3A_lambda_start">lambda_start</code></td>
<td>
<p>Optional. A number, the starting point for searching. If <code>NULL</code>, set to <code>1e-4</code> if <code>lower == TRUE</code>, or <code>1</code> if <code>lower == FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code>test_lambda_bounds</code> three times with <code>step</code> set to <code>10</code>, <code>10^(1/4)</code>, <code>10^(1/16)</code>, respectively.
</p>


<h3>Value</h3>

<p>A number, the best lambda that produces the desired number of edges. <code>1e-10</code> or <code>1e15</code> is returned if out of bound.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Examples are shown for Gaussian truncated to R+^p only. For other distributions
#   on other types of domains, please refer to \code{gen()} or \code{get_elts()}, as the
#   way to call this function (\code{test_lambda_bounds2()}) is exactly the same in those cases.
n &lt;- 50
p &lt;- 30
domain &lt;- make_domain("R+", p=p)
mu &lt;- rep(0, p)
K &lt;- diag(p)
x &lt;- tmvtnorm::rtmvnorm(n, mean = mu, sigma = solve(K),
       lower = rep(0, p), upper = rep(Inf, p), algorithm = "gibbs",
       burn.in.samples = 100, thinning = 10)
h_hp &lt;- get_h_hp("min_pow", 1, 3)
dm &lt;- 1 + (1-1/(1+4*exp(1)*max(6*log(p)/n, sqrt(6*log(p)/n))))
elts_gauss_np &lt;- get_elts(h_hp, x, setting="gaussian", domain=domain,
                centered=FALSE, profiled=FALSE, diag=dm)
test_lambda_bounds2(elts_gauss_np, "symmetric", lambda_ratio=2,
     lower=TRUE, verbose=TRUE, lambda_start=NULL)
test_lambda_bounds2(elts_gauss_np, "symmetric", lambda_ratio=2,
     lower=FALSE, verbose=TRUE, lambda_start=1.0)
</code></pre>

<hr>
<h2 id='tp_fp'>Calculates the true and false positive rates given the estimated and true edges.</h2><span id='topic+tp_fp'></span>

<h3>Description</h3>

<p>Calculates the true and false positive rates given the estimated and true edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tp_fp(edges, true_edges, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tp_fp_+3A_edges">edges</code></td>
<td>
<p>A vector of indices corresponding to the estimated edges. Should not contain the diagonals.</p>
</td></tr>
<tr><td><code id="tp_fp_+3A_true_edges">true_edges</code></td>
<td>
<p>A vector of indices corresponding to the true edges.</p>
</td></tr>
<tr><td><code id="tp_fp_+3A_p">p</code></td>
<td>
<p>A positive integer, the dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the true positive rate and the false positive rate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 40
p &lt;- 50
mu &lt;- rep(0, p)
tol &lt;- 1e-8
K &lt;- cov_cons(mode="sub", p=p, seed=1, spars=0.2, eig=0.1, subgraphs=10)
true_edges &lt;- which(abs(K) &gt; tol &amp; diag(p) == 0)
dm &lt;- 1 + (1-1/(1+4*exp(1)*max(6*log(p)/n, sqrt(6*log(p)/n))))
set.seed(1)
domain &lt;- make_domain("R+", p=p)
x &lt;- tmvtnorm::rtmvnorm(n, mean = mu, sigma = solve(K),
       lower = rep(0, p), upper = rep(Inf, p), algorithm = "gibbs",
       burn.in.samples = 100, thinning = 10)
est &lt;- estimate(x, setting="gaussian", elts=NULL, domain=domain, centered=TRUE,
         symmetric="symmetric", lambda_length=100, mode="min_pow",
         param1=1, param2=3, diagonal_multiplier=dm, verbose=FALSE)
# Apply tp_fp to each estimated edges set for each lambda
TP_FP &lt;- t(sapply(est$edgess, function(edges){tp_fp(edges, true_edges, p)}))
old.par &lt;- par(mfrow=c(1,1), mar=c(5,5,5,5))
plot(c(), c(),  ylim=c(0,1), xlim=c(0,1), cex.lab=1, main = "ROC curve",
  xlab="False Positives", ylab="True Positives")
points(TP_FP[,2], TP_FP[,1], type="l")
points(c(0,1), c(0,1), type = "l", lty = 2)
par(old.par)
</code></pre>

<hr>
<h2 id='update_finite_infinity_for_uniform'>Maximum between finite_infinity and 10 times the max abs value of finite elements in <code>lefts</code> and <code>rights</code>.</h2><span id='topic+update_finite_infinity_for_uniform'></span>

<h3>Description</h3>

<p>Maximum between <code>finite_infinity</code> and 10 times the max abs value of finite elements in <code>lefts</code> and <code>rights</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_finite_infinity_for_uniform(lefts, rights, finite_infinity)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_finite_infinity_for_uniform_+3A_lefts">lefts</code></td>
<td>
<p>A non-empty vector of numbers (may contain <code>-Inf</code>), the left endpoints of a domain defined as a union of intervals. Must pass <code>check_endpoints(lefts, rights)</code>.</p>
</td></tr>
<tr><td><code id="update_finite_infinity_for_uniform_+3A_rights">rights</code></td>
<td>
<p>A non-empty vector of numbers (may contain <code>Inf</code>), the right endpoints of a domain defined as a union of intervals. Must pass <code>check_endpoints(lefts, rights)</code>.</p>
</td></tr>
<tr><td><code id="update_finite_infinity_for_uniform_+3A_finite_infinity">finite_infinity</code></td>
<td>
<p>A finite positive number. <code>Inf</code> will be truncated to <code>finite_infinity</code> if applicable. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since we assume that <code>lefts[i] &lt;= rights[i] &lt;= lefts[j]</code> for any <code>i &lt; j</code>, the function takes the maximum between <code>finite_infinity</code> and 10 times the absolute values of <code>lefts[1]</code>, <code>lefts[length(lefts)]</code>, <code>rights[1]</code>, and <code>rights[length(rights)]</code>, if they are finite.
</p>


<h3>Value</h3>

<p>A double, larger than or equal to <code>finite_infinity</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Does not change since 1000 &gt; 12 * 10
update_finite_infinity_for_uniform(c(-10,-5,0,5,9), c(-8,-3,2,7,12), 1000)
# Changed to 12 * 10
update_finite_infinity_for_uniform(c(-10,-5,0,5,9), c(-8,-3,2,7,12), 10)
# Changed to 12 * 10
update_finite_infinity_for_uniform(c(-Inf,-5,0,5,9), c(-8,-3,2,7,12), 10)
# Changed to 9 * 10
update_finite_infinity_for_uniform(c(-Inf,-5,0,5,9), c(-8,-3,2,7,Inf), 10)
</code></pre>

<hr>
<h2 id='varhat'>Asymptotic variance (times <code>n</code>) of the estimator for <code>mu</code> or <code>sigmasq</code> for the univariate normal on a general domain assuming the other parameter is known.</h2><span id='topic+varhat'></span>

<h3>Description</h3>

<p>Asymptotic variance (times <code>n</code>) of the estimator for <code>mu</code> or <code>sigmasq</code> for the univariate normal on a general domain assuming the other parameter is known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varhat(mu, sigmasq, mode, param1, param2, est_mu, domain, tol = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varhat_+3A_mu">mu</code></td>
<td>
<p>A number, the true <code>mu</code> parameter.</p>
</td></tr>
<tr><td><code id="varhat_+3A_sigmasq">sigmasq</code></td>
<td>
<p>A number, the true <code>sigmasq</code> parameter.</p>
</td></tr>
<tr><td><code id="varhat_+3A_mode">mode</code></td>
<td>
<p>A string, the class of the <code>h</code> function.</p>
</td></tr>
<tr><td><code id="varhat_+3A_param1">param1</code></td>
<td>
<p>A number, the first parameter to the <code>h</code> function.</p>
</td></tr>
<tr><td><code id="varhat_+3A_param2">param2</code></td>
<td>
<p>A number, the second parameter (may be optional depending on <code>mode</code>) to the <code>h</code> function.</p>
</td></tr>
<tr><td><code id="varhat_+3A_est_mu">est_mu</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, returns the asymptotic variance of muhat assuming sigmasq is known; if <code>FALSE</code>, returns the asymptotic variance of sigmasqhat assuming mu is known.</p>
</td></tr>
<tr><td><code id="varhat_+3A_domain">domain</code></td>
<td>
<p>A list returned from <code>make_domain()</code> that represents the domain.</p>
</td></tr>
<tr><td><code id="varhat_+3A_tol">tol</code></td>
<td>
<p>A positive number, tolerance for numerical integration. Defaults to <code>1e-10</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimates may be off from the empirical variance, or may even be <code>Inf</code> or <code>NaN</code> if <code>"mode"</code> is one of <code>"cosh"</code>, <code>"exp"</code>, and <code>"sinh")</code> as the functions grow too fast.
If <code>est_mu == TRUE</code>, the function numerically calculates
</p>
<p style="text-align: center;"><code class="reqn">E\left[\sigma^2 h^2(X)+\sigma^4 {h'}^2(X)\right]/E^2[h(X)],</code>
</p>

<p>and if <code>est_mu == FALSE</code>, the function numerically calculates
</p>
<p style="text-align: center;"><code class="reqn">E\left[\left(2\sigma^6h^2(X)+\sigma^8{h'}^2(X)\right)(X-\mu)^2\right]/E^2\left[h(X)(X-\mu)^2\right],</code>
</p>

<p>where <code class="reqn">E</code> is the expectation over the true distribution <code class="reqn">TN(\mu,\sigma)</code> of <code class="reqn">X</code>.
</p>


<h3>Value</h3>

<p>A number, the asymptotic variance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>varhat(0, 1, "min_log_pow", 1, 1, TRUE, make_domain("R+", 1))
varhat(0.5, 4, "min_pow", 1, 1, TRUE, make_domain("R+", 1))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
