<!DOCTYPE html><html><head><title>Help for package LocaTT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LocaTT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#binomial_test'><p>Binomial Test</p></a></li>
<li><a href='#blast_command_found'><p>Check BLAST Installation</p></a></li>
<li><a href='#blast_version'><p>Get BLAST Version</p></a></li>
<li><a href='#contains_wildcards'><p>Check Whether DNA Sequences Contain Wildcard Characters</p></a></li>
<li><a href='#decode_quality_scores'><p>Decode DNA Sequence Quality Scores</p></a></li>
<li><a href='#format_reference_database'><p>Format Reference Databases</p></a></li>
<li><a href='#get_consensus_taxonomy'><p>Get Consensus Taxonomy from Taxonomic Strings</p></a></li>
<li><a href='#get_taxonomic_level'><p>Get Specified Taxonomic Level from Taxonomic Strings</p></a></li>
<li><a href='#get_taxonomies.IUCN'><p>Get Taxonomies from IUCN Red List Files</p></a></li>
<li><a href='#get_taxonomies.species_binomials'><p>Get NCBI Taxonomies from Species Binomials</p></a></li>
<li><a href='#isolate_amplicon'><p>Trim DNA Sequences to an Amplicon Region Using Forward and Reverse Primer Sequences</p></a></li>
<li><a href='#local_taxa_tool'><p>Perform Geographically-Conscious Taxonomic Assignment</p></a></li>
<li><a href='#merge_pairs'><p>Merge Forward and Reverse DNA Sequence Reads</p></a></li>
<li><a href='#read.fasta'><p>Read FASTA Files</p></a></li>
<li><a href='#read.fastq'><p>Read FASTQ Files</p></a></li>
<li><a href='#reverse_complement'><p>Get the Reverse Complement of a DNA Sequence</p></a></li>
<li><a href='#substitute_wildcards'><p>Substitute Wildcard Characters in a DNA Sequence</p></a></li>
<li><a href='#trim_sequences'><p>Trim Target Nucleotide Sequence from DNA Sequences</p></a></li>
<li><a href='#truncate_sequences.length'><p>Truncate DNA Sequences to Specified Length</p></a></li>
<li><a href='#truncate_sequences.probability'><p>Truncate DNA Sequences at Specified Probability that All Bases were Called Correctly</p></a></li>
<li><a href='#truncate_sequences.quality_score'><p>Truncate DNA Sequences at Specified Quality Score</p></a></li>
<li><a href='#write.fasta'><p>Write FASTA Files</p></a></li>
<li><a href='#write.fastq'><p>Write FASTQ Files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Geographically-Conscious Taxonomic Assignment for Metabarcoding</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A bioinformatics pipeline for performing taxonomic
    assignment of DNA metabarcoding sequence data while considering
    geographic location. A detailed tutorial is available at
    <a href="https://urodelan.github.io/Local_Taxa_Tool_Tutorial/">https://urodelan.github.io/Local_Taxa_Tool_Tutorial/</a>.
    A manuscript describing these methods is in preparation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Urodelan/LocaTT">https://github.com/Urodelan/LocaTT</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Urodelan/LocaTT/issues">https://github.com/Urodelan/LocaTT/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, stats, taxize</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-28 20:33:44 UTC; kenengoodwin</td>
</tr>
<tr>
<td>Author:</td>
<td>Kenen Goodwin <a href="https://orcid.org/0000-0002-9219-7693"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Taal Levi [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kenen Goodwin &lt;urodelan@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-30 13:00:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='binomial_test'>Binomial Test</h2><span id='topic+binomial_test'></span>

<h3>Description</h3>

<p>Performs binomial tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binomial_test(k, n, p, alternative = "greater")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binomial_test_+3A_k">k</code></td>
<td>
<p>A numeric vector of the number of successes.</p>
</td></tr>
<tr><td><code id="binomial_test_+3A_n">n</code></td>
<td>
<p>A numeric vector of the number of trials.</p>
</td></tr>
<tr><td><code id="binomial_test_+3A_p">p</code></td>
<td>
<p>A numeric vector of the hypothesized probabilities of success.</p>
</td></tr>
<tr><td><code id="binomial_test_+3A_alternative">alternative</code></td>
<td>
<p>A string specifying the alternative hypothesis. Must be <code>"less"</code> or <code>"greater"</code> (the default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calls on the <code><a href="stats.html#topic+Binomial">pbinom</a></code> function in the <a href="stats.html#topic+stats-package">stats</a> package to perform vectorized binomial tests. Arguments are recycled as in <code><a href="stats.html#topic+Binomial">pbinom</a></code>. Only one-sided tests are supported, and only p-values are returned.
</p>


<h3>Value</h3>

<p>A numeric vector of p-values from the binomial tests.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>binomial_test(k=c(5,1,7,4),
              n=c(10,3,15,5),
              p=c(0.2,0.1,0.5,0.6),
              alternative="greater")
</code></pre>

<hr>
<h2 id='blast_command_found'>Check BLAST Installation</h2><span id='topic+blast_command_found'></span>

<h3>Description</h3>

<p>Checks whether a BLAST program can be found.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blast_command_found(blast_command)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blast_command_found_+3A_blast_command">blast_command</code></td>
<td>
<p>String specifying the path to a BLAST program.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical. Returns <code>TRUE</code> if the BLAST program could be found.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>blast_command_found(blast_command="blastn")
</code></pre>

<hr>
<h2 id='blast_version'>Get BLAST Version</h2><span id='topic+blast_version'></span>

<h3>Description</h3>

<p>Gets the version of a BLAST program.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blast_version(blast_command = "blastn")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blast_version_+3A_blast_command">blast_command</code></td>
<td>
<p>String specifying the path to a BLAST program. The default (<code>'blastn'</code>) should return the version of the blastn program for standard BLAST installations. The user can provide a path to a BLAST program for non-standard BLAST installations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a string of the version of the BLAST program.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>blast_version()
</code></pre>

<hr>
<h2 id='contains_wildcards'>Check Whether DNA Sequences Contain Wildcard Characters</h2><span id='topic+contains_wildcards'></span>

<h3>Description</h3>

<p>Checks whether DNA sequences contain wildcard characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contains_wildcards(sequences)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contains_wildcards_+3A_sequences">sequences</code></td>
<td>
<p>A character vector of DNA sequences.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector indicating whether each DNA sequence contains wildcard characters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>contains_wildcards(sequences=c("TKCTAGGTGW","CATAATTAGG","ATYGGCTATG"))
</code></pre>

<hr>
<h2 id='decode_quality_scores'>Decode DNA Sequence Quality Scores</h2><span id='topic+decode_quality_scores'></span>

<h3>Description</h3>

<p>Decodes Phred quality scores in Sanger format from symbols to numeric values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decode_quality_scores(symbols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decode_quality_scores_+3A_symbols">symbols</code></td>
<td>
<p>A string containing quality scores encoded as symbols in Sanger format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of Phred quality scores.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>decode_quality_scores(symbols="989!.C;F@\"")
</code></pre>

<hr>
<h2 id='format_reference_database'>Format Reference Databases</h2><span id='topic+format_reference_database'></span>

<h3>Description</h3>

<p>Formats reference databases from MIDORI or UNITE for use with the <code><a href="#topic+local_taxa_tool">local_taxa_tool</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_reference_database(
  path_to_input_reference_database,
  path_to_output_BLAST_database,
  input_reference_database_source = "MIDORI",
  path_to_taxonomy_edits = NA,
  path_to_sequence_edits = NA,
  path_to_list_of_local_taxa_to_subset = NA,
  makeblastdb_command = "makeblastdb"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_reference_database_+3A_path_to_input_reference_database">path_to_input_reference_database</code></td>
<td>
<p>String specifying path to input reference database in FASTA format.</p>
</td></tr>
<tr><td><code id="format_reference_database_+3A_path_to_output_blast_database">path_to_output_BLAST_database</code></td>
<td>
<p>String specifying path to output BLAST database in FASTA format. File path cannot contain spaces.</p>
</td></tr>
<tr><td><code id="format_reference_database_+3A_input_reference_database_source">input_reference_database_source</code></td>
<td>
<p>String specifying input reference database source (<code>'MIDORI'</code> or <code>'UNITE'</code>). The default is <code>'MIDORI'</code>.</p>
</td></tr>
<tr><td><code id="format_reference_database_+3A_path_to_taxonomy_edits">path_to_taxonomy_edits</code></td>
<td>
<p>String specifying path to taxonomy edits file in CSV format. The file must contain the following fields: 'Old_Taxonomy', 'New_Taxonomy', 'Notes'. Old taxonomies are replaced with new taxonomies in the order the records appear in the file. The taxonomic levels in the 'Old_Taxonomy' and 'New_Taxonomy' fields should be delimited by a semi-colon. If no taxonomy edits are desired, then set this variable to <code>NA</code> (the default).</p>
</td></tr>
<tr><td><code id="format_reference_database_+3A_path_to_sequence_edits">path_to_sequence_edits</code></td>
<td>
<p>String specifying path to sequence edits file in CSV format. The file must contain the following fields: 'Action', 'Common_Name', 'Domain', 'Phylum', 'Class', 'Order', 'Family', 'Genus', 'Species', 'Sequence', 'Notes'. The values in the 'Action' field must be either 'Add' or 'Remove', which will add or remove the respective sequence from the reference database. Values in the 'Common_Name' field are optional. Values should be supplied to all taxonomy fields. If using a reference database from MIDORI, then use NCBI superkingdom names (<em>e.g.</em>, 'Eukaryota') in the 'Domain' field. If using a reference database from UNITE, then use kingdom names (<em>e.g.</em>, 'Fungi') in the 'Domain' field. The 'Species' field should contain species binomials. Sequence edits are performed after taxonomy edits, if applied. If no sequence edits are desired, then set this variable to <code>NA</code> (the default).</p>
</td></tr>
<tr><td><code id="format_reference_database_+3A_path_to_list_of_local_taxa_to_subset">path_to_list_of_local_taxa_to_subset</code></td>
<td>
<p>String specifying path to list of species (in CSV format) to subset the reference database to. This option is helpful if the user wants the reference database to include only the sequences of local species. The file should contain the following fields: 'Common_Name', 'Domain', 'Phylum', 'Class', 'Order', 'Family', 'Genus', 'Species'. There should be no 'NA's or blanks in the taxonomy fields. The species field should contain the binomial name without subspecies or other information below the species level. There should be no duplicate species (<em>i.e.</em>, multiple records with the same species binomial and taxonomy) in the species list. Subsetting the reference database to the sequences of certain species is performed after taxonomy and sequence edits are applied to the reference database, and species must match at all taxonomic levels in order to be retained in the reference database. If subsetting the reference database to the sequences of certain species is not desired, set this variable to <code>NA</code> (the default).</p>
</td></tr>
<tr><td><code id="format_reference_database_+3A_makeblastdb_command">makeblastdb_command</code></td>
<td>
<p>String specifying path to the makeblastdb program, which is a part of BLAST. The default (<code>'makeblastdb'</code>) should work for standard BLAST installations. The user can provide a path to the makeblastdb program for non-standard BLAST installations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Writes formatted BLAST database files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Get path to example reference sequences FASTA file.
path_to_input_file&lt;-system.file("extdata",
                                "example_reference_sequences.fasta",
                                 package="LocaTT",
                                 mustWork=TRUE)

# Create a temporary file path for the output reference database FASTA file.
path_to_output_file&lt;-tempfile(fileext=".fasta")

# Format reference database.
format_reference_database(path_to_input_reference_database=path_to_input_file,
                          path_to_output_BLAST_database=path_to_output_file)

</code></pre>

<hr>
<h2 id='get_consensus_taxonomy'>Get Consensus Taxonomy from Taxonomic Strings</h2><span id='topic+get_consensus_taxonomy'></span>

<h3>Description</h3>

<p>Gets the consensus taxonomy from a vector of taxonomic strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_consensus_taxonomy(taxonomies, full_names = TRUE, delimiter = ";")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_consensus_taxonomy_+3A_taxonomies">taxonomies</code></td>
<td>
<p>A character vector of taxonomic strings.</p>
</td></tr>
<tr><td><code id="get_consensus_taxonomy_+3A_full_names">full_names</code></td>
<td>
<p>Logical. If <code>TRUE</code> (the default), then the full consensus taxonomy is returned. If <code>FALSE</code>, then only the lowest taxonomic level of the consensus taxonomy is returned.</p>
</td></tr>
<tr><td><code id="get_consensus_taxonomy_+3A_delimiter">delimiter</code></td>
<td>
<p>A character string of the delimiter between taxonomic levels in the input taxonomies. The default is <code>";"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string containing the taxonomy agreed upon by all input taxonomies. If the input taxonomies are not the same at any taxonomic level, then <code>NA</code> is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_consensus_taxonomy(taxonomies=
   c("Eukaryota;Chordata;Amphibia;Caudata;Ambystomatidae;Ambystoma;Ambystoma_mavortium",
     "Eukaryota;Chordata;Amphibia;Anura;Bufonidae;Anaxyrus;Anaxyrus_boreas",
     "Eukaryota;Chordata;Amphibia;Anura;Ranidae;Rana;Rana_luteiventris"),
                       full_names=TRUE,
                       delimiter=";")
</code></pre>

<hr>
<h2 id='get_taxonomic_level'>Get Specified Taxonomic Level from Taxonomic Strings</h2><span id='topic+get_taxonomic_level'></span>

<h3>Description</h3>

<p>Gets the specified taxonomic level from a vector of taxonomic strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_taxonomic_level(taxonomies, level, full_names = TRUE, delimiter = ";")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_taxonomic_level_+3A_taxonomies">taxonomies</code></td>
<td>
<p>A character vector of taxonomic strings.</p>
</td></tr>
<tr><td><code id="get_taxonomic_level_+3A_level">level</code></td>
<td>
<p>A numeric value representing the taxonomic level to be extracted. A value of <code>1</code> retrieves the highest taxonomic level (<em>e.g.</em>, domain) from the input taxonomies, with each sequentially higher value retrieving sequentially lower taxonomic levels. <code>0</code> is a special value which retrieves the lowest taxonomic level available in the input taxonomies.</p>
</td></tr>
<tr><td><code id="get_taxonomic_level_+3A_full_names">full_names</code></td>
<td>
<p>Logical. If <code>TRUE</code> (the default), then full taxonomies are returned down to the requested taxonomic level. If <code>FALSE</code>, then only the requested taxonomic level is returned.</p>
</td></tr>
<tr><td><code id="get_taxonomic_level_+3A_delimiter">delimiter</code></td>
<td>
<p>A character string of the delimiter between taxonomic levels in the input taxonomies. The default is <code>";"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing the requested taxonomic level for each element of the input taxonomies.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_taxonomic_level(taxonomies=
   c("Eukaryota;Chordata;Amphibia;Caudata;Ambystomatidae;Ambystoma;Ambystoma_mavortium",
     "Eukaryota;Chordata;Amphibia;Anura;Bufonidae;Anaxyrus;Anaxyrus_boreas",
     "Eukaryota;Chordata;Amphibia;Anura;Ranidae;Rana;Rana_luteiventris"),
   level=5,
   full_names=TRUE,
   delimiter=";")
</code></pre>

<hr>
<h2 id='get_taxonomies.IUCN'>Get Taxonomies from IUCN Red List Files</h2><span id='topic+get_taxonomies.IUCN'></span>

<h3>Description</h3>

<p>Formats taxonomies from IUCN Red List taxonomy.csv and common_names.csv files for use with the <code><a href="#topic+local_taxa_tool">local_taxa_tool</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_taxonomies.IUCN(
  path_to_IUCN_taxonomies,
  path_to_IUCN_common_names,
  path_to_output_local_taxa_list,
  domain_name = "Eukaryota",
  path_to_taxonomy_edits = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_taxonomies.IUCN_+3A_path_to_iucn_taxonomies">path_to_IUCN_taxonomies</code></td>
<td>
<p>String specifying path to input IUCN Red List taxonomy.csv file.</p>
</td></tr>
<tr><td><code id="get_taxonomies.IUCN_+3A_path_to_iucn_common_names">path_to_IUCN_common_names</code></td>
<td>
<p>String specifying path to input IUCN Red List common_names.csv file.</p>
</td></tr>
<tr><td><code id="get_taxonomies.IUCN_+3A_path_to_output_local_taxa_list">path_to_output_local_taxa_list</code></td>
<td>
<p>String specifying path to output species list (in CSV format) with formatted taxonomies.</p>
</td></tr>
<tr><td><code id="get_taxonomies.IUCN_+3A_domain_name">domain_name</code></td>
<td>
<p>String specifying the domain name to use for all species. The IUCN Red List files do not include domain information, so a domain name must be provided. If using a reference database from UNITE, provide a kingdom name here (<em>e.g.</em>, <code>'Fungi'</code>). The default is <code>'Eukaryota'</code>.</p>
</td></tr>
<tr><td><code id="get_taxonomies.IUCN_+3A_path_to_taxonomy_edits">path_to_taxonomy_edits</code></td>
<td>
<p>String specifying path to taxonomy edits file in CSV format. The file must contain the following fields: 'Old_Taxonomy', 'New_Taxonomy', 'Notes'. Old taxonomies are replaced with new taxonomies in the order the records appear in the file. The taxonomic levels in the 'Old_Taxonomy' and 'New_Taxonomy' fields should be delimited by a semi-colon. If no taxonomy edits are desired, then set this variable to <code>NA</code> (the default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Writes an output CSV file with formatted taxonomies.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_taxonomies.species_binomials">get_taxonomies.species_binomials</a></code> for remotely fetching NCBI taxonomies from species binomials.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get path to example taxonomy CSV file.
path_to_taxonomy_file&lt;-system.file("extdata",
                                   "example_taxonomy.csv",
                                   package="LocaTT",
                                   mustWork=TRUE)

# Get path to example common names CSV file.
path_to_common_names_file&lt;-system.file("extdata",
                                       "example_common_names.csv",
                                       package="LocaTT",
                                       mustWork=TRUE)

# Create a temporary file path for the output CSV file.
path_to_output_file&lt;-tempfile(fileext=".csv")

# Format common names and taxonomies.
get_taxonomies.IUCN(path_to_IUCN_taxonomies=path_to_taxonomy_file,
                    path_to_IUCN_common_names=path_to_common_names_file,
                    path_to_output_local_taxa_list=path_to_output_file)
</code></pre>

<hr>
<h2 id='get_taxonomies.species_binomials'>Get NCBI Taxonomies from Species Binomials</h2><span id='topic+get_taxonomies.species_binomials'></span>

<h3>Description</h3>

<p>Remotely fetches taxonomies from the NCBI taxonomy database for a list of species binomials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_taxonomies.species_binomials(
  path_to_input_species_binomials,
  path_to_output_local_taxa_list,
  path_to_taxonomy_edits = NA,
  print_taxize_queries = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_taxonomies.species_binomials_+3A_path_to_input_species_binomials">path_to_input_species_binomials</code></td>
<td>
<p>String specifying path to input species list with common and scientific names. The file should be in CSV format and contain the following fields: 'Common_Name', 'Scientific_Name'. Values in the 'Common_Name' field are optional. Values in the 'Scientific_Name' field are required.</p>
</td></tr>
<tr><td><code id="get_taxonomies.species_binomials_+3A_path_to_output_local_taxa_list">path_to_output_local_taxa_list</code></td>
<td>
<p>String specifying path to output species list with added NCBI taxonomies. The output file will be in CSV format.</p>
</td></tr>
<tr><td><code id="get_taxonomies.species_binomials_+3A_path_to_taxonomy_edits">path_to_taxonomy_edits</code></td>
<td>
<p>String specifying path to taxonomy edits file in CSV format. The file must contain the following fields: 'Old_Taxonomy', 'New_Taxonomy', 'Notes'. Old taxonomies are replaced with new taxonomies in the order the records appear in the file. The taxonomic levels in the 'Old_Taxonomy' and 'New_Taxonomy' fields should be delimited by a semi-colon. If no taxonomy edits are desired, then set this variable to <code>NA</code> (the default).</p>
</td></tr>
<tr><td><code id="get_taxonomies.species_binomials_+3A_print_taxize_queries">print_taxize_queries</code></td>
<td>
<p>Logical. Whether taxa queries should be printed. The default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Writes an output CSV file with added taxonomies.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_taxonomies.IUCN">get_taxonomies.IUCN</a></code> for formatting taxonomies from the IUCN Red List.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Get path to example input species binomials CSV file.
path_to_input_file&lt;-system.file("extdata",
                                "example_species_binomials.csv",
                                 package="LocaTT",
                                 mustWork=TRUE)

# Create a temporary file path for the output CSV file.
path_to_output_file&lt;-tempfile(fileext=".csv")

# Fetch taxonomies from species binomials.
get_taxonomies.species_binomials(path_to_input_species_binomials=path_to_input_file,
                                 path_to_output_local_taxa_list=path_to_output_file,
                                 print_taxize_queries=FALSE)

</code></pre>

<hr>
<h2 id='isolate_amplicon'>Trim DNA Sequences to an Amplicon Region Using Forward and Reverse Primer Sequences</h2><span id='topic+isolate_amplicon'></span>

<h3>Description</h3>

<p>Trims DNA sequences to an amplicon region using forward and reverse primer sequences. Ambiguous nucleotides in forward and reverse primers are supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isolate_amplicon(sequences, forward_primer, reverse_primer)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isolate_amplicon_+3A_sequences">sequences</code></td>
<td>
<p>A character vector of DNA sequences to trim to the amplicon region.</p>
</td></tr>
<tr><td><code id="isolate_amplicon_+3A_forward_primer">forward_primer</code></td>
<td>
<p>A string specifying the forward primer sequence. Can contain ambiguous nucleotides.</p>
</td></tr>
<tr><td><code id="isolate_amplicon_+3A_reverse_primer">reverse_primer</code></td>
<td>
<p>A string specifying the reverse primer sequence. Can contain ambiguous nucletodies.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each DNA sequence, nucleotides matching and preceding the forward primer are removed, and nucleotides matching and following the reverse complement of the reverse primer are removed. The reverse complement of the reverse primer is internally derived from the reverse primer using the <code><a href="#topic+reverse_complement">reverse_complement</a></code> function. Ambiguous nucleotides in primers (<em>i.e.</em>, the forward and reverse primer arguments) are supported through the internal use of the <code><a href="#topic+substitute_wildcards">substitute_wildcards</a></code> function on the forward primer and the reverse complement of the reverse primer, and primer regions in DNA sequences are located using regular expressions. Trimming will fail for DNA sequences which contain ambiguous nucleotides in their primer regions (<em>e.g.</em>, Ns), resulting in <code>NA</code>s for those sequences.
</p>


<h3>Value</h3>

<p>A character vector of DNA sequences trimmed to the amplicon region. <code>NA</code>s are returned for DNA sequences which could not be trimmed, which occurs when either primer region is missing from the DNA sequence or when the forward primer region occurs after a region matching the reverse complement of the reverse primer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isolate_amplicon(sequences=c("ACACAATCGTGTTTATATTAACTTCAAGAGTGGGCATAGG",
                             "CGTGACAATCATGTTTGTGATTCGTACAAAAGTGCGTCCT"),
                 forward_primer="AATCRTGTTT",
                 reverse_primer="CSCACTHTTG")
</code></pre>

<hr>
<h2 id='local_taxa_tool'>Perform Geographically-Conscious Taxonomic Assignment</h2><span id='topic+local_taxa_tool'></span>

<h3>Description</h3>

<p>Performs taxonomic assignment of DNA metabarcoding sequences while considering geographic location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_taxa_tool(
  path_to_sequences_to_classify,
  path_to_BLAST_database,
  path_to_output_file,
  path_to_list_of_local_taxa = NA,
  include_missing = FALSE,
  blast_e_value = 1e-05,
  blast_max_target_seqs = 2000,
  blast_task = "megablast",
  full_names = FALSE,
  underscores = FALSE,
  separator = ", ",
  blastn_command = "blastn"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_taxa_tool_+3A_path_to_sequences_to_classify">path_to_sequences_to_classify</code></td>
<td>
<p>String specifying path to FASTA file containing sequences to classify. File path cannot contain spaces.</p>
</td></tr>
<tr><td><code id="local_taxa_tool_+3A_path_to_blast_database">path_to_BLAST_database</code></td>
<td>
<p>String specifying path to BLAST reference database in FASTA format. File path cannot contain spaces.</p>
</td></tr>
<tr><td><code id="local_taxa_tool_+3A_path_to_output_file">path_to_output_file</code></td>
<td>
<p>String specifying path to output file of classified sequences in CSV format.</p>
</td></tr>
<tr><td><code id="local_taxa_tool_+3A_path_to_list_of_local_taxa">path_to_list_of_local_taxa</code></td>
<td>
<p>String specifying path to list of local species in CSV format. The file should contain the following fields: 'Common_Name', 'Domain', 'Phylum', 'Class', 'Order', 'Family', 'Genus', 'Species'. There should be no 'NA's or blanks in the taxonomy fields. The species field should contain the binomial name without subspecies or other information below the species level. There should be no duplicate species (<em>i.e.</em>, multiple records with the same species binomial and taxonomy) in the local species list. If local taxa suggestions are not desired, set this variable to <code>NA</code> (the default).</p>
</td></tr>
<tr><td><code id="local_taxa_tool_+3A_include_missing">include_missing</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then additional fields are included in the output CSV file in which local sister taxonomic groups without reference sequences are added to the local taxa suggestions. If <code>FALSE</code> (the default), then this is not performed.</p>
</td></tr>
<tr><td><code id="local_taxa_tool_+3A_blast_e_value">blast_e_value</code></td>
<td>
<p>Numeric. Maximum E-value of returned BLAST hits (lower E-values are associated with more 'significant' matches). The default is <code>1e-05</code>.</p>
</td></tr>
<tr><td><code id="local_taxa_tool_+3A_blast_max_target_seqs">blast_max_target_seqs</code></td>
<td>
<p>Numeric. Maximum number of BLAST target sequences returned per query sequence. Enough target sequences should be returned to ensure that all minimum E-value matches are returned for each query sequence. A warning will be produced if this value is not sufficient. The default is <code>2000</code>.</p>
</td></tr>
<tr><td><code id="local_taxa_tool_+3A_blast_task">blast_task</code></td>
<td>
<p>String specifying BLAST task specification. Use <code>'megablast'</code> (the default) to find very similar sequences (<em>e.g.</em>, intraspecies or closely related species). Use <code>'blastn-short'</code> for sequences shorter than 50 bases. See the blastn program help documentation for additional options and details.</p>
</td></tr>
<tr><td><code id="local_taxa_tool_+3A_full_names">full_names</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then full taxonomies are returned in the output CSV file. If <code>FALSE</code> (the default), then only the lowest taxonomic levels (<em>e.g.</em>, species binomials instead of the full species taxonomies) are returned in the output CSV file.</p>
</td></tr>
<tr><td><code id="local_taxa_tool_+3A_underscores">underscores</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then taxa names in the output CSV file use underscores instead of spaces. If <code>FALSE</code> (the default), then taxa names in the output CSV file use spaces.</p>
</td></tr>
<tr><td><code id="local_taxa_tool_+3A_separator">separator</code></td>
<td>
<p>String specifying the separator to use between taxa names in the output CSV file. The default is <code>', '</code>.</p>
</td></tr>
<tr><td><code id="local_taxa_tool_+3A_blastn_command">blastn_command</code></td>
<td>
<p>String specifying path to the blastn program. The default (<code>'blastn'</code>) should work for standard BLAST installations. The user can provide a path to the blastn program for non-standard BLAST installations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sequences are BLASTed against a global reference database, and the tool suggests locally occurring species which are most closely related (by taxonomy) to any of the best-matching BLAST hits (by bit score). Optionally, local sister taxonomic groups without reference sequences can be added to the local taxa suggestions by setting the <code>include_missing</code> argument to <code>TRUE</code>. If a local taxa list is not provided, then local taxa suggestions will be disabled, but all best-matching BLAST hits will still be returned. Alternatively, a reference database containing just the sequences of local species can be used, and local taxa suggestions can be disabled to return all best BLAST matches of local species. The reference database should be formatted with the <code><a href="#topic+format_reference_database">format_reference_database</a></code> function, and the local taxa lists can be prepared using the <code><a href="#topic+get_taxonomies.species_binomials">get_taxonomies.species_binomials</a></code> and <code><a href="#topic+get_taxonomies.IUCN">get_taxonomies.IUCN</a></code> functions. Output field definitions are:
</p>

<ul>
<li><p> Sequence_name: The query sequence name.
</p>
</li>
<li><p> Sequence: The query sequence.
</p>
</li>
<li><p> Best_match_references: Species binomials of all best-matching BLAST hits (by bit score) from the reference database.
</p>
</li>
<li><p> Best_match_E_value: The E-value associated with the best-matching BLAST hits.
</p>
</li>
<li><p> Best_match_bit_score: The bit score associated with the best-matching BLAST hits.
</p>
</li>
<li><p> Best_match_query_cover.mean: The mean query cover of all best-matching BLAST hits.
</p>
</li>
<li><p> Best_match_query_cover.SD: The standard deviation of query cover of all best-matching BLAST hits.
</p>
</li>
<li><p> Best_match_PID.mean: The mean percent identity of all best-matching BLAST hits.
</p>
</li>
<li><p> Best_match_PID.SD: The standard deviation of percent identity of all best-matching BLAST hits.
</p>
</li>
<li><p> Local_taxa (Field only present if a path to a local taxa list is provided): The finest taxonomic unit(s) which include both any species of the best-matching BLAST hits and any local species. If the species of any of the best-matching BLAST hits are local, then the finest taxonomic unit(s) are at the species level.
</p>
</li>
<li><p> Local_species (Field only present if a path to a local taxa list is provided): Species binomials of all local species which belong to the taxonomic unit(s) in the Local_taxa field.
</p>
</li>
<li><p> Local_taxa.include_missing (Field only present if both a path to a local taxa list is provided and the <code>include_missing</code> argument is set to <code>TRUE</code>): Local sister taxonomic groups without reference sequences are added to the local taxa suggestions from the Local_taxa field.
</p>
</li>
<li><p> Local_species.include_missing (Field only present if both a path to a local taxa list is provided and <code>include_missing</code> argument is set to <code>TRUE</code>): Species binomials of all local species which belong to the taxonomic unit(s) in the Local_taxa.include_missing field.
</p>
</li></ul>



<h3>Value</h3>

<p>No return value. Writes an output CSV file with fields defined in the details section.
</p>


<h3>References</h3>

<p>A manuscript describing this taxonomic assignment method is in preparation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Get path to example query sequences FASTA file.
path_to_query_sequences&lt;-system.file("extdata",
                                     "example_query_sequences.fasta",
                                     package="LocaTT",
                                     mustWork=TRUE)

# Get path to example reference database FASTA file.
path_to_reference_database&lt;-system.file("extdata",
                                        "example_blast_database.fasta",
                                        package="LocaTT",
                                        mustWork=TRUE)

# Get path to example local taxa list CSV file.
path_to_local_taxa_list&lt;-system.file("extdata",
                                     "example_local_taxa_list.csv",
                                     package="LocaTT",
                                     mustWork=TRUE)

# Create a temporary file path for the output CSV file.
path_to_output_CSV_file&lt;-tempfile(fileext=".csv")

# Run the local taxa tool.
local_taxa_tool(path_to_sequences_to_classify=path_to_query_sequences,
                path_to_BLAST_database=path_to_reference_database,
                path_to_output_file=path_to_output_CSV_file,
                path_to_list_of_local_taxa=path_to_local_taxa_list,
                include_missing=TRUE,
                full_names=TRUE,
                underscores=TRUE)

</code></pre>

<hr>
<h2 id='merge_pairs'>Merge Forward and Reverse DNA Sequence Reads</h2><span id='topic+merge_pairs'></span>

<h3>Description</h3>

<p>Merges forward and reverse DNA sequence reads.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_pairs(forward_reads, reverse_reads, minimum_overlap = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_pairs_+3A_forward_reads">forward_reads</code></td>
<td>
<p>A character vector of forward DNA sequence reads.</p>
</td></tr>
<tr><td><code id="merge_pairs_+3A_reverse_reads">reverse_reads</code></td>
<td>
<p>A character vector of reverse DNA sequence reads.</p>
</td></tr>
<tr><td><code id="merge_pairs_+3A_minimum_overlap">minimum_overlap</code></td>
<td>
<p>Numeric. The minimum length of an overlap that must be found between the end of the forward read and the start of the reverse complement of the reverse read in order for a read pair to be merged. The default is <code>10</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each pair of forward and reverse DNA sequence reads, the reverse complement of the reverse read is internally derived using the <code><a href="#topic+reverse_complement">reverse_complement</a></code> function, and the read pair is merged into a single sequence if an overlap of at least the minimum length is found between the end of the forward read and the start of the reverse complement of the reverse read. If an overlap of the minimum length is not found, then an <code>NA</code> is returned for the merged read pair.
</p>


<h3>Value</h3>

<p>A character vector of merged DNA sequence read pairs. <code>NA</code>s are returned for read pairs which could not be merged, which occurs when an overlap of at least the minimum length is not found between the end of the forward read and the start of the reverse complement of the reverse read.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>merge_pairs(forward_reads=c("CCTTACGAATCCTGT","TTCTCCACCCGCGGATA","CGCCCGGAGTCCCTGTAGTA"),
            reverse_reads=c("GACAAACAGGATTCG","CAATATCCGCGGGTG","TACTACAGGGACTCC"))
</code></pre>

<hr>
<h2 id='read.fasta'>Read FASTA Files</h2><span id='topic+read.fasta'></span>

<h3>Description</h3>

<p>Reads FASTA files. Supports the reading of FASTA files with sequences wrapping multiple lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fasta(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fasta_+3A_file">file</code></td>
<td>
<p>A string specifying the path to a FASTA file to read.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with fields for sequence names and sequences.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.fasta">write.fasta</a></code> for writing FASTA files. <br />
<code><a href="#topic+read.fastq">read.fastq</a></code> for reading FASTQ files. <br />
<code><a href="#topic+write.fastq">write.fastq</a></code> for writing FASTQ files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get path to example FASTA file.
path_to_fasta_file&lt;-system.file("extdata",
                                "example_query_sequences.fasta",
                                package="LocaTT",
                                mustWork=TRUE)

# Read the example FASTA file.
read.fasta(file=path_to_fasta_file)
</code></pre>

<hr>
<h2 id='read.fastq'>Read FASTQ Files</h2><span id='topic+read.fastq'></span>

<h3>Description</h3>

<p>Reads FASTQ files. Does not support the reading of FASTQ files with sequences or quality scores wrapping multiple lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fastq(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fastq_+3A_file">file</code></td>
<td>
<p>A string specifying the path to a FASTQ file to read.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with fields for sequence names, sequences, comments, and quality scores.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.fastq">write.fastq</a></code> for writing FASTQ files. <br />
<code><a href="#topic+read.fasta">read.fasta</a></code> for reading FASTA files. <br />
<code><a href="#topic+write.fasta">write.fasta</a></code> for writing FASTA files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get path to example FASTQ file.
path_to_fastq_file&lt;-system.file("extdata",
                                "example_query_sequences.fastq",
                                package="LocaTT",
                                mustWork=TRUE)

# Read the example FASTQ file.
read.fastq(file=path_to_fastq_file)
</code></pre>

<hr>
<h2 id='reverse_complement'>Get the Reverse Complement of a DNA Sequence</h2><span id='topic+reverse_complement'></span>

<h3>Description</h3>

<p>Gets the reverse complement of a DNA sequence. Ambiguous nucleotides are supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverse_complement(sequence)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reverse_complement_+3A_sequence">sequence</code></td>
<td>
<p>A string specifying the DNA sequence. Can contain ambiguous nucleotides.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string of the reverse complement of the DNA sequence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reverse_complement(sequence="TTCTCCASCCGCGGATHTTG")
</code></pre>

<hr>
<h2 id='substitute_wildcards'>Substitute Wildcard Characters in a DNA Sequence</h2><span id='topic+substitute_wildcards'></span>

<h3>Description</h3>

<p>Substitutes wildcard characters in a DNA sequence with their associated nucleotides surrounded by square brackets. The output is useful for matching in regular expressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>substitute_wildcards(sequence)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="substitute_wildcards_+3A_sequence">sequence</code></td>
<td>
<p>A string specifying the DNA sequence containing wildcard characters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string of the DNA sequence in which wildcard characters are replaced with their associated nucleotides surrounded by square brackets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>substitute_wildcards(sequence="CAADATCCGCGGSTGGAGAA")
</code></pre>

<hr>
<h2 id='trim_sequences'>Trim Target Nucleotide Sequence from DNA Sequences</h2><span id='topic+trim_sequences'></span>

<h3>Description</h3>

<p>Trims a target nucleotide sequence from the front or back of DNA sequences. Ambiguous nucleotides in the target nucleotide sequence are supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_sequences(
  sequences,
  target,
  anchor = "start",
  fixed = TRUE,
  required = TRUE,
  quality_scores
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_sequences_+3A_sequences">sequences</code></td>
<td>
<p>A character vector of DNA sequences to trim.</p>
</td></tr>
<tr><td><code id="trim_sequences_+3A_target">target</code></td>
<td>
<p>A string specifying the target nucleotide sequence.</p>
</td></tr>
<tr><td><code id="trim_sequences_+3A_anchor">anchor</code></td>
<td>
<p>A string specifying whether the target nucleotide sequence should be trimmed from the start or end of the DNA sequences. Allowable values are <code>"start"</code> (the default) and <code>"end"</code>.</p>
</td></tr>
<tr><td><code id="trim_sequences_+3A_fixed">fixed</code></td>
<td>
<p>A logical value specifying whether the position of the target nucleotide sequence should be fixed at the ends of the DNA sequences. If <code>TRUE</code> (the default), then the position of the target nucleotide sequence is fixed at either the start or end of the DNA sequences, depending on the value of the anchor argument. If <code>FALSE</code>, then the target nucleotide sequence is searched for anywhere in the DNA sequences.</p>
</td></tr>
<tr><td><code id="trim_sequences_+3A_required">required</code></td>
<td>
<p>A logical value specifying whether trimming is required. If <code>TRUE</code> (the default), then sequences which could not be trimmed are returned as <code>NA</code>s. If <code>FALSE</code>, then untrimmed sequences are returned along with DNA sequences for which trimming was successful.</p>
</td></tr>
<tr><td><code id="trim_sequences_+3A_quality_scores">quality_scores</code></td>
<td>
<p>An optional character vector of DNA sequence quality scores. If supplied, these will be trimmed to their corresponding trimmed DNA sequences.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each DNA sequence, the target nucleotide sequence is searched for at either the front or back of the DNA sequence, depending on the value of the anchor argument. If the target nucleotide sequence is found, then it is removed from the DNA sequence. If the required argument is set to <code>TRUE</code>, then DNA sequences in which the target nucleotide sequence was not found will be returned as <code>NA</code>s. If the required argument is set to <code>FALSE</code>, then untrimmed DNA sequences will be returned along with DNA sequences for which trimming was successful. Ambiguous nucleotides in the target nucleotide sequence are supported through the internal use of the <code><a href="#topic+substitute_wildcards">substitute_wildcards</a></code> function on the target nucleotide sequence, and a regular expression with a leading or ending anchor is used to search for the target nucleotide sequence in the DNA sequences. If the fixed argument is set to <code>FALSE</code>, then any number of characters are allowed between the start or end of the DNA sequences and the target nucleotide sequence. Trimming will fail for DNA sequences which contain ambiguous nucleotides (<em>e.g.</em>, Ns) in their target nucleotide sequence region, resulting in <code>NA</code>s for those sequences if the required argument is set to <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>If quality scores are not provided, then a character vector of trimmed DNA sequences is returned. If quality scores are provided, then a list containing two elements is returned. The first element is a character vector of trimmed DNA sequences, and the second element is a character vector of quality scores which have been trimmed to their corresponding trimmed DNA sequences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trim_sequences(sequences=c("ATATAGCGCG","TGCATATACG","ATCTATCACCGC"),
               target="ATMTA",
               anchor="start",
               fixed=TRUE,
               required=TRUE,
               quality_scores=c("989!.C;F@\"","A((#-#;,2F","HD8I/+67=1&gt;?"))
</code></pre>

<hr>
<h2 id='truncate_sequences.length'>Truncate DNA Sequences to Specified Length</h2><span id='topic+truncate_sequences.length'></span>

<h3>Description</h3>

<p>Truncates DNA sequences to a specified length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>truncate_sequences.length(sequences, length, quality_scores)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="truncate_sequences.length_+3A_sequences">sequences</code></td>
<td>
<p>A character vector of DNA sequences to truncate.</p>
</td></tr>
<tr><td><code id="truncate_sequences.length_+3A_length">length</code></td>
<td>
<p>Numeric. The length to truncate DNA sequences to.</p>
</td></tr>
<tr><td><code id="truncate_sequences.length_+3A_quality_scores">quality_scores</code></td>
<td>
<p>An optional character vector of DNA sequence quality scores. If supplied, these will be truncated to their corresponding truncated DNA sequences.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If quality scores are not provided, then a character vector of truncated DNA sequences is returned. If quality scores are provided, then a list containing two elements is returned. The first element is a character vector of truncated DNA sequences, and the second element is a character vector of quality scores which have been truncated to their corresponding truncated DNA sequences.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+truncate_sequences.quality_score">truncate_sequences.quality_score</a></code> for truncating DNA sequences by Phred quality score. <br />
<code><a href="#topic+truncate_sequences.probability">truncate_sequences.probability</a></code> for truncating DNA sequences by cumulative probability that all bases were called correctly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>truncate_sequences.length(sequences=c("ATATAGCGCG","TGCCGATATA","ATCTATCACCGC"),
                          length=5,
                          quality_scores=c("989!.C;F@\"","A((#-#;,2F","HD8I/+67=1&gt;?"))
</code></pre>

<hr>
<h2 id='truncate_sequences.probability'>Truncate DNA Sequences at Specified Probability that All Bases were Called Correctly</h2><span id='topic+truncate_sequences.probability'></span>

<h3>Description</h3>

<p>Calculates the cumulative probability that all bases were called correctly along each DNA sequence and truncates the DNA sequence immediately prior to the first occurrence of a probability being equal to or less than a specified value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>truncate_sequences.probability(sequences, quality_scores, threshold = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="truncate_sequences.probability_+3A_sequences">sequences</code></td>
<td>
<p>A character vector of DNA sequences to truncate.</p>
</td></tr>
<tr><td><code id="truncate_sequences.probability_+3A_quality_scores">quality_scores</code></td>
<td>
<p>A character vector of DNA sequence quality scores encoded in Sanger format.</p>
</td></tr>
<tr><td><code id="truncate_sequences.probability_+3A_threshold">threshold</code></td>
<td>
<p>Numeric. The probability threshold used for truncation. The default is <code>0.5</code> (<em>i.e.</em>, each trimmed sequence has a greater than 50% probability that all bases were called correctly).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two elements. The first element is a character vector of truncated DNA sequences, and the second element is a character vector of quality scores which have been truncated to their corresponding truncated DNA sequences.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+truncate_sequences.length">truncate_sequences.length</a></code> for truncating DNA sequences to a specified length. <br />
<code><a href="#topic+truncate_sequences.quality_score">truncate_sequences.quality_score</a></code> for truncating DNA sequences by Phred quality score.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>truncate_sequences.probability(sequences=c("ATATAGCGCG","TGCCGATATA","ATCTATCACCGC"),
                               quality_scores=c("989!.C;F@\"","A((#-#;,2F","HD8I/+67=1&gt;?"),
                               threshold=0.5)
</code></pre>

<hr>
<h2 id='truncate_sequences.quality_score'>Truncate DNA Sequences at Specified Quality Score</h2><span id='topic+truncate_sequences.quality_score'></span>

<h3>Description</h3>

<p>Truncates DNA sequences immediately prior to the first occurrence of a Phred quality score being equal to or less than a specified value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>truncate_sequences.quality_score(sequences, quality_scores, threshold = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="truncate_sequences.quality_score_+3A_sequences">sequences</code></td>
<td>
<p>A character vector of DNA sequences to truncate.</p>
</td></tr>
<tr><td><code id="truncate_sequences.quality_score_+3A_quality_scores">quality_scores</code></td>
<td>
<p>A character vector of DNA sequence quality scores encoded in Sanger format.</p>
</td></tr>
<tr><td><code id="truncate_sequences.quality_score_+3A_threshold">threshold</code></td>
<td>
<p>Numeric. The Phred quality score threshold used for truncation. The default is <code>3</code> (<em>i.e.</em>, each base in a trimmed sequence has a greater than 50% probability of having been called correctly).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two elements. The first element is a character vector of truncated DNA sequences, and the second element is a character vector of quality scores which have been truncated to their corresponding truncated DNA sequences.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+truncate_sequences.length">truncate_sequences.length</a></code> for truncating DNA sequences to a specified length. <br />
<code><a href="#topic+truncate_sequences.probability">truncate_sequences.probability</a></code> for truncating DNA sequences by cumulative probability that all bases were called correctly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>truncate_sequences.quality_score(sequences=c("ATATAGCGCG","TGCCGATATA","ATCTATCACCGC"),
                                 quality_scores=c("989!.C;F@\"","A((#-#;,2F","HD8I/+67=1&gt;?"),
                                 threshold=3)
</code></pre>

<hr>
<h2 id='write.fasta'>Write FASTA Files</h2><span id='topic+write.fasta'></span>

<h3>Description</h3>

<p>Writes FASTA files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fasta(names, sequences, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fasta_+3A_names">names</code></td>
<td>
<p>A character vector of sequence names.</p>
</td></tr>
<tr><td><code id="write.fasta_+3A_sequences">sequences</code></td>
<td>
<p>A character vector of sequences.</p>
</td></tr>
<tr><td><code id="write.fasta_+3A_file">file</code></td>
<td>
<p>A string specifying the path to a FASTA file to write.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Writes a FASTA file.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.fasta">read.fasta</a></code> for reading FASTA files. <br />
<code><a href="#topic+write.fastq">write.fastq</a></code> for writing FASTQ files. <br />
<code><a href="#topic+read.fastq">read.fastq</a></code> for reading FASTQ files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get path to example sequences CSV file.
path_to_CSV_file&lt;-system.file("extdata",
                              "example_query_sequences.csv",
                              package="LocaTT",
                              mustWork=TRUE)

# Read the example sequences CSV file.
df&lt;-read.csv(file=path_to_CSV_file,stringsAsFactors=FALSE)

# Create a temporary file path for the FASTA file to write.
path_to_FASTA_file&lt;-tempfile(fileext=".fasta")

# Write the example sequences as a FASTA file.
write.fasta(names=df$Name,
            sequences=df$Sequence,
            file=path_to_FASTA_file)
</code></pre>

<hr>
<h2 id='write.fastq'>Write FASTQ Files</h2><span id='topic+write.fastq'></span>

<h3>Description</h3>

<p>Writes FASTQ files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fastq(names, sequences, quality_scores, file, comments)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fastq_+3A_names">names</code></td>
<td>
<p>A character vector of sequence names.</p>
</td></tr>
<tr><td><code id="write.fastq_+3A_sequences">sequences</code></td>
<td>
<p>A character vector of sequences.</p>
</td></tr>
<tr><td><code id="write.fastq_+3A_quality_scores">quality_scores</code></td>
<td>
<p>A character vector of quality scores.</p>
</td></tr>
<tr><td><code id="write.fastq_+3A_file">file</code></td>
<td>
<p>A string specifying the path to a FASTQ file to write.</p>
</td></tr>
<tr><td><code id="write.fastq_+3A_comments">comments</code></td>
<td>
<p>An optional character vector of sequence comments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Writes a FASTQ file.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.fastq">read.fastq</a></code> for reading FASTQ files. <br />
<code><a href="#topic+write.fasta">write.fasta</a></code> for writing FASTA files. <br />
<code><a href="#topic+read.fasta">read.fasta</a></code> for reading FASTA files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get path to example sequences CSV file.
path_to_CSV_file&lt;-system.file("extdata",
                              "example_query_sequences.csv",
                              package="LocaTT",
                              mustWork=TRUE)

# Read the example sequences CSV file.
df&lt;-read.csv(file=path_to_CSV_file,stringsAsFactors=FALSE)

# Create a temporary file path for the FASTQ file to write.
path_to_FASTQ_file&lt;-tempfile(fileext=".fastq")

# Write the example sequences as a FASTQ file.
write.fastq(names=df$Name,
            sequences=df$Sequence,
            quality_scores=df$Quality_score,
            file=path_to_FASTQ_file,
            comments=df$Comment)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
