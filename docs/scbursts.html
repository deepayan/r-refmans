<!DOCTYPE html><html><head><title>Help for package scbursts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {scbursts}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bursts.check_subconductance'><p>Check if segment contains subconductive states</p></a></li>
<li><a href='#bursts.conductance_states'><p>Return a list of all the (sub)conductance states.</p></a></li>
<li><a href='#bursts.copy'><p>Copy a list of bursts (by value)</p></a></li>
<li><a href='#bursts.defined_by_tcrit'><p>Divide a recording into bursts defined by a critical time.</p></a></li>
<li><a href='#bursts.get_gaps'><p>Get the gaps between bursts.</p></a></li>
<li><a href='#bursts.impose_deadtime'><p>Imposes a deadtime to each segment in a burst.</p></a></li>
<li><a href='#bursts.modify_conductance'><p>Transform the conductance states according to a user-defined function of conductance level.</p></a></li>
<li><a href='#bursts.pcloseds'><p>Return pcloseds of every burst.</p></a></li>
<li><a href='#bursts.popens'><p>Return popens of every burst.</p></a></li>
<li><a href='#bursts.recombine'><p>Combine bursts into one recording (with obvious spaces between them).</p></a></li>
<li><a href='#bursts.remove_first_and_last'><p>Remove the first and last burst from the list.</p></a></li>
<li><a href='#bursts.select'><p>From a list of bursts, extract those that interest you by passing a selecting function.</p></a></li>
<li><a href='#bursts.sort'><p>Order a list of bursts by some function. For instance, popen.</p></a></li>
<li><a href='#bursts.space_out'><p>Artificially add amount of time between bursts (in absence of recording information).</p></a></li>
<li><a href='#bursts.start_times_update'><p>(DON'T USE THIS) Fix meta-data of bursts.</p></a></li>
<li><a href='#bursts.subconductance_as'><p>Imposes a fixed conductance level (0 or 1) to all dwells with subconductance levels to each segment in a burst</p></a></li>
<li><a href='#clampfit.read'><p>Read a .xlsx file output from clampfit</p></a></li>
<li><a href='#cplot.conductance_hist'><p>Histogram of Conductance States</p></a></li>
<li><a href='#cplot.log_root_axes'><p>Add log-root axes to histogram plot</p></a></li>
<li><a href='#cplot.pclosed_ts'><p>Plot Time Series (ts) of P(Closed).</p></a></li>
<li><a href='#cplot.popen_ts'><p>Plot Time Series (ts) of P(Open).</p></a></li>
<li><a href='#dwt.read'><p>Read a .dwt file.</p></a></li>
<li><a href='#dwt.write'><p>Write a dwt file to disk. Writes DOS line endings. Dwells are in milliseconds</p></a></li>
<li><a href='#evt.extract_header'><p>Extract header from evt file.</p></a></li>
<li><a href='#evt.from_dwells'><p>Converts dwell durations to absolute transition times.</p></a></li>
<li><a href='#evt.read'><p>Read a .evt file to a table. Times are in seconds</p></a></li>
<li><a href='#evt.to_dwells'><p>Calculate pulse lengths. Converts transition times to dwell durations.</p></a></li>
<li><a href='#evt.write'><p>Write bursts to a .evt file.</p></a></li>
<li><a href='#hst.extract_header'><p>Extract header from hst file.</p></a></li>
<li><a href='#hst.read'><p>Read a MIL &quot;.hst&quot; file to a table.</p></a></li>
<li><a href='#hst.write'><p>Write bursts to a log10(ms)-sqrt(Frequency) .hst file from open and closed tables.</p></a></li>
<li><a href='#risetime.correct_gaussian'><p>Undo the effect of the gaussian filter.</p></a></li>
<li><a href='#scan.read'><p>Read a scan results text file. scan.read returns a 1 segment list</p>
Reads in scan results and puts them in the same format as the output
of dwt.read. See 'dwt', and 'segment' for more information.</a></li>
<li><a href='#segment.check_subconductance'><p>Check if segment contains subconductive states</p></a></li>
<li><a href='#segment.closed_dwells'><p>Extract closed dwells.</p></a></li>
<li><a href='#segment.conductance_states'><p>Return a list of all the (sub)conductance states.</p></a></li>
<li><a href='#segment.consecutives_to_dwells'><p>Collapses a segment into dwells with alternating conductance levels.</p></a></li>
<li><a href='#segment.copy'><p>Copy a segment</p></a></li>
<li><a href='#segment.count_closed'><p>Extract number of closed dwells. In the case of subconductive states,</p>
a dwell is only closed if the conductance is exactly zero.</a></li>
<li><a href='#segment.count_dwells'><p>Extract number of dwells in segment.</p></a></li>
<li><a href='#segment.count_open'><p>Extract number of open dwells. In the case of subconductive states,</p>
count the number of non-zero states.</a></li>
<li><a href='#segment.create'><p>Create a &quot;segment&quot; object</p></a></li>
<li><a href='#segment.duration'><p>Get duration of a segment.</p></a></li>
<li><a href='#segment.dwells_by_conductance'><p>Extract dwells in conductance range. lower &lt;= x &lt;= upper</p></a></li>
<li><a href='#segment.dwells_by_conductance_range'><p>Extract dwells in conductance range. lower &lt;= x &lt;= upper</p></a></li>
<li><a href='#segment.impose_deadtime'><p>Imposes a deadtime to a segment by removing any dwell that is shorter than the deadtime.</p></a></li>
<li><a href='#segment.modify_conductance'><p>Transform the conductance states according to a user-defined function of conductance level.</p></a></li>
<li><a href='#segment.name'><p>Extract name from segment.</p></a></li>
<li><a href='#segment.open_dwells'><p>Extract open dwells. (Any conductance greater than zero)</p></a></li>
<li><a href='#segment.pclosed'><p>Calculate empirical P(Closed) of a segment.</p></a></li>
<li><a href='#segment.pconductance'><p>Calculate empirical P(Lower &lt;= Conductance &lt;= Upper) of a segment.</p></a></li>
<li><a href='#segment.pconductance_range'><p>Calculate empirical P(Lower &lt;= Conductance &lt;= Upper) of a segment.</p></a></li>
<li><a href='#segment.popen'><p>Calculate empirical P(Open) of a segment. (A state is considered open if the conductance is non-zero)</p></a></li>
<li><a href='#segment.seg'><p>Extract segment number from segment.</p></a></li>
<li><a href='#segment.start_time'><p>Extract start_time from segment.</p></a></li>
<li><a href='#segment.subconductance_as'><p>Imposes a fixed conductance level (0 or 1) to all dwells with subconductance levels.</p></a></li>
<li><a href='#segment.verify'><p>Detect misrecorded data.</p></a></li>
<li><a href='#util.basename'><p>Remove suffix and path from filename.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-06-24</td>
</tr>
<tr>
<td>Title:</td>
<td>Single Channel Bursts Analysis</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools to import and export from several existing pieces of ion-channel analysis software such as 'TAC', 'QUB', 'SCAN', and 'Clampfit', implements procedures such as dwell-time correction and defining bursts with a critical time, and provides tools for analysis of bursts, such as tools for sorting and plotting.</td>
</tr>
<tr>
<td>Author:</td>
<td>Blair Drummomd [aut], Mathieu Dextraze [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Blair Drummond &lt;blair.robert.drummond@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, tinytex</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>readxl, tibble</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-07-06 03:17:59 UTC; blair</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-07-06 15:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='bursts.check_subconductance'>Check if segment contains subconductive states</h2><span id='topic+bursts.check_subconductance'></span>

<h3>Description</h3>

<p>Check if segment contains subconductive states
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bursts.check_subconductance(bursts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bursts.check_subconductance_+3A_bursts">bursts</code></td>
<td>
<p>The list of all bursts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>True if it contains an conductance other than 0 or 1, False otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
infile &lt;- system.file("extdata", "example4.dwt", package = "scbursts")
dwells &lt;- dwt.read(infile)
dwells_c &lt;- risetime.correct_gaussian(Tr=35.0052278, dwells, units="us")
bursts &lt;- bursts.defined_by_tcrit(dwells_c, 100, units="ms")

bursts.check_subconductance(bursts)

</code></pre>

<hr>
<h2 id='bursts.conductance_states'>Return a list of all the (sub)conductance states.</h2><span id='topic+bursts.conductance_states'></span>

<h3>Description</h3>

<p>Return a list of all the (sub)conductance states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bursts.conductance_states(bursts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bursts.conductance_states_+3A_bursts">bursts</code></td>
<td>
<p>The list of all bursts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of all the (sub)conductance states.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
infile &lt;- system.file("extdata", "example4.dwt", package = "scbursts")
dwells &lt;- dwt.read(infile)
dwells_c &lt;- risetime.correct_gaussian(Tr=35.0052278, dwells, units="us")
bursts &lt;- bursts.defined_by_tcrit(dwells_c, 100, units="ms")

bursts.conductance_states(bursts)

</code></pre>

<hr>
<h2 id='bursts.copy'>Copy a list of bursts (by value)</h2><span id='topic+bursts.copy'></span>

<h3>Description</h3>

<p>Copy a list of bursts (by value)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bursts.copy(bursts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bursts.copy_+3A_bursts">bursts</code></td>
<td>
<p>bursts to copy</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of the bursts.
</p>

<hr>
<h2 id='bursts.defined_by_tcrit'>Divide a recording into bursts defined by a critical time.</h2><span id='topic+bursts.defined_by_tcrit'></span>

<h3>Description</h3>

<p>Split segment at long pauses, dividing the segment into multiple -shorter- segments (which are the bursts), Along with the interburst closings, which are referred to as &quot;gaps&quot;. (Default time units are seconds)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bursts.defined_by_tcrit(segments, t_crit, units = "s")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bursts.defined_by_tcrit_+3A_segments">segments</code></td>
<td>
<p>A segment or multiple segments with $states and $dwells.
NOTE: separate segments will remain split, regardless of why they were originally divided.</p>
</td></tr>
<tr><td><code id="bursts.defined_by_tcrit_+3A_t_crit">t_crit</code></td>
<td>
<p>Critical time at which to divide bursts (in seconds by default)</p>
</td></tr>
<tr><td><code id="bursts.defined_by_tcrit_+3A_units">units</code></td>
<td>
<p>what unit the critical time is in ('s','ms','us', or 'ns')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>bursts. Which is a list of segments
starting and ending in 1 states (open dwell)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
infile &lt;- system.file("extdata", "example1_tac.evt", package = "scbursts")
transitions &lt;- evt.read(infile)
dwells &lt;- evt.to_dwells(transitions)
dwells_c &lt;- risetime.correct_gaussian(Tr=35.0052278, dwells, units="us")

bursts &lt;- bursts.defined_by_tcrit(dwells_c, 100, units="ms")
head(bursts[[1]])

</code></pre>

<hr>
<h2 id='bursts.get_gaps'>Get the gaps between bursts.</h2><span id='topic+bursts.get_gaps'></span>

<h3>Description</h3>

<p>Extract vector of gaps from the bursts. This is done using the start_time attribute, which is mostly hidden in the data. (The gaps at the ends may have length 0)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bursts.get_gaps(bursts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bursts.get_gaps_+3A_bursts">bursts</code></td>
<td>
<p>The list of segments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of N+1 gaps for N bursts times
</p>


<h3>Examples</h3>

<pre><code class='language-R'>infile &lt;- system.file("extdata", "example1_tac.evt", package = "scbursts")
transitions &lt;- evt.read(infile)
dwells &lt;- evt.to_dwells(transitions)
dwells_c &lt;- risetime.correct_gaussian(Tr=35.0052278, dwells, units="us")

bursts &lt;- bursts.defined_by_tcrit(dwells_c, 100, units="ms")
gaps &lt;- bursts.get_gaps(bursts)

head(gaps)
</code></pre>

<hr>
<h2 id='bursts.impose_deadtime'>Imposes a deadtime to each segment in a burst.</h2><span id='topic+bursts.impose_deadtime'></span>

<h3>Description</h3>

<p>The user specifies a deadtime in microseconds. The function applies
segment.impose_deadtime to each segment in the burst.
(See segment.impose_deadtime for details.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bursts.impose_deadtime(bursts, deadtime)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bursts.impose_deadtime_+3A_bursts">bursts</code></td>
<td>
<p>a burst containing segments of dwells and states.</p>
</td></tr>
<tr><td><code id="bursts.impose_deadtime_+3A_deadtime">deadtime</code></td>
<td>
<p>the briefest possible event in microseconds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified copy of the original burst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
infile &lt;- system.file("extdata", "example4.dwt", package = "scbursts")
dwells &lt;- dwt.read(infile)
dwells_c &lt;- risetime.correct_gaussian(Tr=35.0052278, dwells, units="us")
bursts &lt;- bursts.defined_by_tcrit(dwells_c, 100, units="ms")

bursts_d &lt;- bursts.impose_deadtime(bursts, deadtime=0.01)

</code></pre>

<hr>
<h2 id='bursts.modify_conductance'>Transform the conductance states according to a user-defined function of conductance level.</h2><span id='topic+bursts.modify_conductance'></span>

<h3>Description</h3>

<p>Transform the conductance states according to a user-defined function of conductance level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bursts.modify_conductance(bursts, fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bursts.modify_conductance_+3A_bursts">bursts</code></td>
<td>
<p>the list of segments</p>
</td></tr>
<tr><td><code id="bursts.modify_conductance_+3A_fun">fun</code></td>
<td>
<p>a function on conductance levels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified copy of the original bursts
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
infile &lt;- system.file("extdata", "example4.dwt", package = "scbursts")
dwells &lt;- dwt.read(infile)
dwells_c &lt;- risetime.correct_gaussian(Tr=35.0052278, dwells, units="us")
bursts &lt;- bursts.defined_by_tcrit(dwells_c, 100, units="ms")

### Collapse into three subconductance states
fun &lt;- function(amp) {
    if (amp &lt; 0.3)
        return(0)
    else if (amp &gt;= 0.3 &amp;&amp; amp &lt; 0.6)
        return(0.5)
    else
        return(1)
}

bursts_d &lt;- bursts.modify_conductance(bursts, fun)

</code></pre>

<hr>
<h2 id='bursts.pcloseds'>Return pcloseds of every burst.</h2><span id='topic+bursts.pcloseds'></span>

<h3>Description</h3>

<p>Return pcloseds of every burst.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bursts.pcloseds(bursts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bursts.pcloseds_+3A_bursts">bursts</code></td>
<td>
<p>The list of all bursts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The pclosed values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
infile &lt;- system.file("extdata", "example1_qub.dwt", package = "scbursts")
dwells &lt;- dwt.read(infile)
dwells_c &lt;- risetime.correct_gaussian(Tr=35.0052278, dwells, units="us")
bursts &lt;- bursts.defined_by_tcrit(dwells_c, 100, units="ms")

pcloseds &lt;- bursts.popens(bursts)
hist(pcloseds)

</code></pre>

<hr>
<h2 id='bursts.popens'>Return popens of every burst.</h2><span id='topic+bursts.popens'></span>

<h3>Description</h3>

<p>Return popens of every burst.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bursts.popens(bursts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bursts.popens_+3A_bursts">bursts</code></td>
<td>
<p>The list of all bursts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The popen values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
infile &lt;- system.file("extdata", "example1_qub.dwt", package = "scbursts")
dwells &lt;- dwt.read(infile)
dwells_c &lt;- risetime.correct_gaussian(Tr=35.0052278, dwells, units="us")

bursts &lt;- bursts.defined_by_tcrit(dwells_c, 100, units="ms")

popens &lt;- bursts.popens(bursts)
hist(popens)

</code></pre>

<hr>
<h2 id='bursts.recombine'>Combine bursts into one recording (with obvious spaces between them).</h2><span id='topic+bursts.recombine'></span>

<h3>Description</h3>

<p>From a list of segments, return the concatenated  segment containing all bursts. Inverse of functions like bursts.defined_by_tcrit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bursts.recombine(bursts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bursts.recombine_+3A_bursts">bursts</code></td>
<td>
<p>The list of all bursts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The segment containing all bursts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
infile &lt;- system.file("extdata", "example1_qub.dwt", package = "scbursts")
dwells &lt;- dwt.read(infile)
dwells_c &lt;- risetime.correct_gaussian(Tr=35.0052278, dwells, units="us")

bursts &lt;- bursts.defined_by_tcrit(dwells_c, 100, units="ms")

# This is a single segment!
record &lt;- bursts.recombine(bursts)

# Which means you can do stuff like this
open_dwells &lt;- segment.open_dwells(bursts.recombine(bursts))

</code></pre>

<hr>
<h2 id='bursts.remove_first_and_last'>Remove the first and last burst from the list.</h2><span id='topic+bursts.remove_first_and_last'></span>

<h3>Description</h3>

<p>Remove the first and last burst from the list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bursts.remove_first_and_last(bursts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bursts.remove_first_and_last_+3A_bursts">bursts</code></td>
<td>
<p>The list of all bursts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A shorter list of bursts
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
infile &lt;- system.file("extdata", "example1_tac.evt", package = "scbursts")
transitions &lt;- evt.read(infile)
dwells &lt;- evt.to_dwells(transitions)
dwells_c &lt;- risetime.correct_gaussian(Tr=35.0052278, dwells, units="us")

bursts &lt;- bursts.defined_by_tcrit(dwells_c, 100, units="ms")

# If there seem to be bad bursts at the ends
bursts &lt;- bursts.remove_first_and_last(bursts)

</code></pre>

<hr>
<h2 id='bursts.select'>From a list of bursts, extract those that interest you by passing a selecting function.</h2><span id='topic+bursts.select'></span>

<h3>Description</h3>

<p>From a list of bursts, extract those that interest you by passing a selecting function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bursts.select(bursts, func, one_file = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bursts.select_+3A_bursts">bursts</code></td>
<td>
<p>The list of all bursts</p>
</td></tr>
<tr><td><code id="bursts.select_+3A_func">func</code></td>
<td>
<p>A function of a segment that returns either TRUE or FALSE</p>
</td></tr>
<tr><td><code id="bursts.select_+3A_one_file">one_file</code></td>
<td>
<p>TRUE or FALSE: Return a single file to write to disk, or a list of bursts.
The one_file will return a file with all unselected bursts zeroed out.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A shorter list of bursts OR if one_file is passed one segment with zeros where the other bursts might have been originally. Defaults to FALSE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
high_popen &lt;- function (seg) {
    segment.popen(seg) &gt; 0.7
}

infile &lt;- system.file("extdata", "example1_qub.dwt", package = "scbursts")
dwells &lt;- dwt.read(infile)
dwells_c &lt;- risetime.correct_gaussian(Tr=35.0052278, dwells, units="us")

bursts &lt;- bursts.defined_by_tcrit(dwells_c, 100, units="ms")

subset &lt;- bursts.select(bursts, high_popen)

# To export to one .dwt file
subset_f &lt;- bursts.select(bursts, high_popen, one_file=TRUE)

</code></pre>

<hr>
<h2 id='bursts.sort'>Order a list of bursts by some function. For instance, popen.</h2><span id='topic+bursts.sort'></span>

<h3>Description</h3>

<p>Order a list of bursts by some function. For instance, popen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bursts.sort(bursts, func, reverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bursts.sort_+3A_bursts">bursts</code></td>
<td>
<p>The list of all bursts</p>
</td></tr>
<tr><td><code id="bursts.sort_+3A_func">func</code></td>
<td>
<p>A function of a segment that returns a numeric value</p>
</td></tr>
<tr><td><code id="bursts.sort_+3A_reverse">reverse</code></td>
<td>
<p>By default, return in ascending order. Use reverse=TRUE to change that.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list sorted by func. By default in ascending order (unless reversed)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
infile &lt;- system.file("extdata", "example1_qub.dwt", package = "scbursts")
dwells &lt;- dwt.read(infile)
dwells_c &lt;- risetime.correct_gaussian(Tr=35.0052278, dwells, units="us")
bursts &lt;- bursts.defined_by_tcrit(dwells_c, 100, units="ms")

# A sorted list of bursts. 
sorted &lt;- bursts.sort(bursts, segment.popen)

# You can also write your own functions. If you want P(Open) =~ P(Closed)
variance_fun &lt;- function (seg) {
    # Any function that maps a segment to a number works.
    return(  segment.popen(seg) * segment.pclosed(seg)  )
}

weird_sort &lt;- bursts.sort(bursts, variance_fun)

</code></pre>

<hr>
<h2 id='bursts.space_out'>Artificially add amount of time between bursts (in absence of recording information).</h2><span id='topic+bursts.space_out'></span>

<h3>Description</h3>

<p>Given a list of segments separated by an unknown amount of time, one may want to space the segments by some amount of time, so that they can be plotted. This function takes a separating factor, and splits up the segments by either that factor (in seconds), or that many multiples of the largest observed dwell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bursts.space_out(segments, sep_factor = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bursts.space_out_+3A_segments">segments</code></td>
<td>
<p>The segments to space out</p>
</td></tr>
<tr><td><code id="bursts.space_out_+3A_sep_factor">sep_factor</code></td>
<td>
<p>the factor by which to separate the segments.
Either the factor in seconds, or a multiple of the longest observed dwell.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The segments again, but with modified meta-data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>infile &lt;- system.file("extdata", "example_multiple_segments.dwt", package = "scbursts")
dwells &lt;- dwt.read(infile)

# Still a list, but the meta-data is fixed
spaced_records &lt;- bursts.space_out(dwells, sep_factor=1000)

# Combine them, and they'll be nicely spaced out.
single_record &lt;- bursts.recombine(spaced_records)

# You can now plot that single_record using one of the plot functions.

</code></pre>

<hr>
<h2 id='bursts.start_times_update'>(DON'T USE THIS) Fix meta-data of bursts.</h2><span id='topic+bursts.start_times_update'></span>

<h3>Description</h3>

<p>YOU PROBABLY WON'T EVER HAVE TO CALL THIS DIRECTLY. Attach the meta-data to each segment saying when it began. It interleaves the durations of the bursts and gaps, and assigns the sum of those durations up to a point as the starting time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bursts.start_times_update(bursts, gaps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bursts.start_times_update_+3A_bursts">bursts</code></td>
<td>
<p>List of segments</p>
</td></tr>
<tr><td><code id="bursts.start_times_update_+3A_gaps">gaps</code></td>
<td>
<p>vector of gap times.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of segments, one per burst, with updated start_times
</p>

<hr>
<h2 id='bursts.subconductance_as'>Imposes a fixed conductance level (0 or 1) to all dwells with subconductance levels to each segment in a burst</h2><span id='topic+bursts.subconductance_as'></span>

<h3>Description</h3>

<p>The user specifies the desired level ('open' or 'closed'). The function applies
segment.subconductance_as to each segment in the burst.
(See segment.subconductance_as for details.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bursts.subconductance_as(bursts, level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bursts.subconductance_as_+3A_bursts">bursts</code></td>
<td>
<p>the list of segments</p>
</td></tr>
<tr><td><code id="bursts.subconductance_as_+3A_level">level</code></td>
<td>
<p>either 'open' or 'closed'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified copy of the original burst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
infile &lt;- system.file("extdata", "example4.dwt", package = "scbursts")
dwells &lt;- dwt.read(infile)
dwells_c &lt;- risetime.correct_gaussian(Tr=35.0052278, dwells, units="us")
bursts &lt;- bursts.defined_by_tcrit(dwells_c, 100, units="ms")

bursts_d &lt;- bursts.subconductance_as(bursts, "open")

</code></pre>

<hr>
<h2 id='clampfit.read'>Read a .xlsx file output from clampfit</h2><span id='topic+clampfit.read'></span>

<h3>Description</h3>

<p>Read a .xlsx file output from clampfit. Result is a list of &quot;segments&quot;, which is a dataframe extra data. See &quot;segment&quot; for more details. Converts millisecond dwells to seconds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clampfit.read(filename, separating_factor = 1000, header = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clampfit.read_+3A_filename">filename</code></td>
<td>
<p>Filename to read from</p>
</td></tr>
<tr><td><code id="clampfit.read_+3A_separating_factor">separating_factor</code></td>
<td>
<p>In lieu of a known time between segments, seperate with a multple of the longest dwell.</p>
</td></tr>
<tr><td><code id="clampfit.read_+3A_header">header</code></td>
<td>
<p>Does the file include a header?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of bursts (possibly a singleton)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
infile &lt;- system.file("extdata", "example1_clampfit.xlsx", package = "scbursts")
dwells &lt;- clampfit.read(infile)
head(dwells)

</code></pre>

<hr>
<h2 id='cplot.conductance_hist'>Histogram of Conductance States</h2><span id='topic+cplot.conductance_hist'></span>

<h3>Description</h3>

<p>Histogram of Conductance States
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cplot.conductance_hist(bursts, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cplot.conductance_hist_+3A_bursts">bursts</code></td>
<td>
<p>List of multiple segments</p>
</td></tr>
<tr><td><code id="cplot.conductance_hist_+3A_...">...</code></td>
<td>
<p>other arguments passed to histogram</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
infile &lt;- system.file("extdata", "example4.dwt", package = "scbursts")
dwells &lt;- dwt.read(infile)
dwells_c &lt;- risetime.correct_gaussian(Tr=35.0052278, dwells, units="us")
bursts &lt;- bursts.defined_by_tcrit(dwells_c, 100, units="ms")

cplot.conductance_hist(bursts, main="example4.dwt conductance state histogram")

</code></pre>

<hr>
<h2 id='cplot.log_root_axes'>Add log-root axes to histogram plot</h2><span id='topic+cplot.log_root_axes'></span>

<h3>Description</h3>

<p>Add log-root axes to histogram plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cplot.log_root_axes(points)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cplot.log_root_axes_+3A_points">points</code></td>
<td>
<p>The data to plot</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
infile &lt;- system.file("extdata", "example1_qub.dwt", package = "scbursts")
dwells &lt;- dwt.read(infile)
dwells_c &lt;- risetime.correct_gaussian(Tr=35.0052278, dwells, units="us")
bursts &lt;- bursts.defined_by_tcrit(dwells_c, 100, units="ms")

open_dwells &lt;- segment.open_dwells(bursts.recombine(bursts))
hist(log10(open_dwells), axes=FALSE, breaks=30)
cplot.log_root_axes(open_dwells)

</code></pre>

<hr>
<h2 id='cplot.pclosed_ts'>Plot Time Series (ts) of P(Closed).</h2><span id='topic+cplot.pclosed_ts'></span>

<h3>Description</h3>

<p>Plot Time Series (ts) of P(Closed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cplot.pclosed_ts(bursts, main = "P(Closed) Time Series", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cplot.pclosed_ts_+3A_bursts">bursts</code></td>
<td>
<p>List of multiple segments</p>
</td></tr>
<tr><td><code id="cplot.pclosed_ts_+3A_main">main</code></td>
<td>
<p>The title of the plot.</p>
</td></tr>
<tr><td><code id="cplot.pclosed_ts_+3A_...">...</code></td>
<td>
<p>Options to pass to plot</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
infile &lt;- system.file("extdata", "example1_qub.dwt", package = "scbursts")
dwells &lt;- dwt.read(infile)
dwells_c &lt;- risetime.correct_gaussian(Tr=35.0052278, dwells, units="us")
bursts &lt;- bursts.defined_by_tcrit(dwells_c, 100, units="ms")

cplot.pclosed_ts(bursts, main="P(Closed) Time Series, 2018-09-20")

</code></pre>

<hr>
<h2 id='cplot.popen_ts'>Plot Time Series (ts) of P(Open).</h2><span id='topic+cplot.popen_ts'></span>

<h3>Description</h3>

<p>Plot Time Series (ts) of P(Open).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cplot.popen_ts(bursts, main = "P(Open) Time Series", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cplot.popen_ts_+3A_bursts">bursts</code></td>
<td>
<p>List of multiple segments</p>
</td></tr>
<tr><td><code id="cplot.popen_ts_+3A_main">main</code></td>
<td>
<p>The title of the plot.</p>
</td></tr>
<tr><td><code id="cplot.popen_ts_+3A_...">...</code></td>
<td>
<p>Options to pass to plot</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
infile &lt;- system.file("extdata", "example1_qub.dwt", package = "scbursts")
dwells &lt;- dwt.read(infile)
dwells_c &lt;- risetime.correct_gaussian(Tr=35.0052278, dwells, units="us")
bursts &lt;- bursts.defined_by_tcrit(dwells_c, 100, units="ms")

cplot.popen_ts(bursts, "P(Open) Time Series, 2018-09-20")

</code></pre>

<hr>
<h2 id='dwt.read'>Read a .dwt file.</h2><span id='topic+dwt.read'></span>

<h3>Description</h3>

<p>Read a .dwt file. Result is a list of &quot;segments&quot;, which is a dataframe extra data. See &quot;segment&quot; for more details. Converts millisecond dwells to seconds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dwt.read(filename, separating_factor = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dwt.read_+3A_filename">filename</code></td>
<td>
<p>Filename to read from</p>
</td></tr>
<tr><td><code id="dwt.read_+3A_separating_factor">separating_factor</code></td>
<td>
<p>In lieu of a known time between segments, seperate with a multple of the longest dwell.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of bursts (possibly a singleton)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
infile &lt;- system.file("extdata", "example1_tac.evt", package = "scbursts")
transitions &lt;- evt.read(infile)
dwells &lt;- evt.to_dwells(transitions)

dwt.write(dwells, file=file.path(tempdir(), "dwells.dwt"))

# Quit R, come back the next day
## Not run: 
dwells &lt;- dwt.read("dwells.dwt")

## End(Not run)

</code></pre>

<hr>
<h2 id='dwt.write'>Write a dwt file to disk. Writes DOS line endings. Dwells are in milliseconds</h2><span id='topic+dwt.write'></span>

<h3>Description</h3>

<p>Write a dwt file to disk. Writes DOS line endings. Dwells are in milliseconds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dwt.write(segments, file = "", seg = 1, append = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dwt.write_+3A_segments">segments</code></td>
<td>
<p>A segment or multiple segments with $dwells and $states</p>
</td></tr>
<tr><td><code id="dwt.write_+3A_file">file</code></td>
<td>
<p>Filename to write to</p>
</td></tr>
<tr><td><code id="dwt.write_+3A_seg">seg</code></td>
<td>
<p>Segment number to write in .dwt header.</p>
</td></tr>
<tr><td><code id="dwt.write_+3A_append">append</code></td>
<td>
<p>Add ot the end of a file or overwrite? (defaults to false)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
infile &lt;- system.file("extdata", "example1_tac.evt", package = "scbursts")
transitions &lt;- evt.read(infile)
dwells &lt;- evt.to_dwells(transitions)

dwt.write(dwells, file=file.path(tempdir(), "dwells.dwt"))

</code></pre>

<hr>
<h2 id='evt.extract_header'>Extract header from evt file.</h2><span id='topic+evt.extract_header'></span>

<h3>Description</h3>

<p>Extract header from evt file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evt.extract_header(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evt.extract_header_+3A_filename">filename</code></td>
<td>
<p>The filename</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string containing the header
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
infile &lt;- system.file("extdata", "example1_tac.evt", package = "scbursts")

# Get Dwells
transitions &lt;- evt.read(infile)
dwells &lt;- evt.to_dwells(transitions)
dwells_c &lt;- risetime.correct_gaussian(Tr=35.0052278, dwells, units="us")

# Get Header
header &lt;- evt.extract_header(infile)

evt.write(dwells_c, header=header, file=file.path(tempdir(), "fixed_example1_tac.evt"))
</code></pre>

<hr>
<h2 id='evt.from_dwells'>Converts dwell durations to absolute transition times.</h2><span id='topic+evt.from_dwells'></span>

<h3>Description</h3>

<p>Converts dwell durations to absolute transition times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evt.from_dwells(segments)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evt.from_dwells_+3A_segments">segments</code></td>
<td>
<p>A segment or multiple segemtns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe or multiple dataframes of states and transition times
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dwells_file &lt;- system.file("extdata", "example1_qub.dwt", package = "scbursts")
dwells &lt;- dwt.read(dwells_file)

transitions &lt;- evt.from_dwells(dwells)

</code></pre>

<hr>
<h2 id='evt.read'>Read a .evt file to a table. Times are in seconds</h2><span id='topic+evt.read'></span>

<h3>Description</h3>

<p>Read a .evt file to a table. Times are in seconds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evt.read(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evt.read_+3A_filename">filename</code></td>
<td>
<p>The filename</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of tables with columns &quot;states&quot; and &quot;times&quot;.
Each table corresponds to a contiguous segment from a recording.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# import some of the data included with the package
infile &lt;- system.file("extdata", "example1_tac.evt", package = "scbursts")
transitions &lt;- evt.read(infile)

head(transitions[[1]])

</code></pre>

<hr>
<h2 id='evt.to_dwells'>Calculate pulse lengths. Converts transition times to dwell durations.</h2><span id='topic+evt.to_dwells'></span>

<h3>Description</h3>

<p>Calculate pulse lengths. Converts transition times to dwell durations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evt.to_dwells(tables)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evt.to_dwells_+3A_tables">tables</code></td>
<td>
<p>Either a single table or a list of tables with columns &quot;states&quot; and &quot;times&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A segment or a list of segments with one less row, where each row
represents pulse in state 0 (closed dwell) of duration 0.51231, instead
of the time at which the state transitioned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
infile &lt;- system.file("extdata", "example1_tac.evt", package = "scbursts")
transitions &lt;- evt.read(infile)
dwells &lt;- evt.to_dwells(transitions)
head(dwells[[1]])

</code></pre>

<hr>
<h2 id='evt.write'>Write bursts to a .evt file.</h2><span id='topic+evt.write'></span>

<h3>Description</h3>

<p>Write bursts to a .evt file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evt.write(segments, filename = "", header = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evt.write_+3A_segments">segments</code></td>
<td>
<p>A segment or list of segments to write to filename</p>
</td></tr>
<tr><td><code id="evt.write_+3A_filename">filename</code></td>
<td>
<p>The filename</p>
</td></tr>
<tr><td><code id="evt.write_+3A_header">header</code></td>
<td>
<p>The header information for the evt file, if available</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
infile &lt;- system.file("extdata", "example1_tac.evt", package = "scbursts")

# Get Dwells
transitions &lt;- evt.read(infile)
dwells &lt;- evt.to_dwells(transitions)
dwells_c &lt;- risetime.correct_gaussian(Tr=35.0052278, dwells, units="us")

# Get Header
header &lt;- evt.extract_header(infile)

evt.write(dwells_c, header=header, file=file.path(tempdir(), "fixed_example1_tac.evt"))
</code></pre>

<hr>
<h2 id='hst.extract_header'>Extract header from hst file.</h2><span id='topic+hst.extract_header'></span>

<h3>Description</h3>

<p>Extract header from hst file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hst.extract_header(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hst.extract_header_+3A_filename">filename</code></td>
<td>
<p>The filename</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string containing the header
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# import some of the data included with the package
infile &lt;- system.file("extdata", "example1_hst.hst", package = "scbursts")

open_table &lt;- hst.read(infile, extract="open")
closed_table &lt;- hst.read(infile, extract="closed")
header &lt;- hst.extract_header(infile)

# Make adjustments to the histogram, if you wish
hst.write(open_table, closed_table, file=file.path(tempdir(), "output_hist.hst"), header=header)

</code></pre>

<hr>
<h2 id='hst.read'>Read a MIL &quot;.hst&quot; file to a table.</h2><span id='topic+hst.read'></span>

<h3>Description</h3>

<p>Read a MIL &quot;.hst&quot; file to a table. By default these files are in log10(Milliseconds)-sqrt(Freq), but unless &quot;raw&quot; is set to TRUE, this function returns a table containing Seconds-Freq
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hst.read(filename, extract = "open", raw = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hst.read_+3A_filename">filename</code></td>
<td>
<p>The filename</p>
</td></tr>
<tr><td><code id="hst.read_+3A_extract">extract</code></td>
<td>
<p>Extract either &quot;open&quot; or &quot;closed&quot; histogram</p>
</td></tr>
<tr><td><code id="hst.read_+3A_raw">raw</code></td>
<td>
<p>Data is given as log10(milliseconds)-Sqrt(Freq). Setting raw=FALSE yields output as Seconds-Frequency</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tables with columns &quot;bin&quot;, &quot;freq&quot; and &quot;fit&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# import some of the data included with the package
infile &lt;- system.file("extdata", "example1_hst.hst", package = "scbursts")
open_hst   &lt;- hst.read(infile, extract="open")
closed_hst &lt;- hst.read(infile, extract="closed")

head(open_hst)
head(closed_hst)

</code></pre>

<hr>
<h2 id='hst.write'>Write bursts to a log10(ms)-sqrt(Frequency) .hst file from open and closed tables.</h2><span id='topic+hst.write'></span>

<h3>Description</h3>

<p>Write bursts to a log10(ms)-sqrt(Frequency) .hst file from open and closed tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hst.write(open_hist, closed_hist, file = "", header = NULL,
  fromraw = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hst.write_+3A_open_hist">open_hist</code></td>
<td>
<p>The table (bin,freq,fit) for open times</p>
</td></tr>
<tr><td><code id="hst.write_+3A_closed_hist">closed_hist</code></td>
<td>
<p>The table (bin,freq,fit) for closed times</p>
</td></tr>
<tr><td><code id="hst.write_+3A_file">file</code></td>
<td>
<p>The filename</p>
</td></tr>
<tr><td><code id="hst.write_+3A_header">header</code></td>
<td>
<p>The header info</p>
</td></tr>
<tr><td><code id="hst.write_+3A_fromraw">fromraw</code></td>
<td>
<p>Unless FALSE, assume we need to write a log10(milliseconds)-sqrt(Frequency) plot</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
infile &lt;- system.file("extdata", "example1_hst.hst", package = "scbursts")

open = hst.read(infile, extract="open")
closed = hst.read(infile, extract="closed")
header = hst.extract_header(infile)

### Do stuff
hst.write(open, closed, file=file.path(tempdir(), "new_histogram.hst"), header=header)
</code></pre>

<hr>
<h2 id='risetime.correct_gaussian'>Undo the effect of the gaussian filter.</h2><span id='topic+risetime.correct_gaussian'></span>

<h3>Description</h3>

<p>Undo the effect of the gaussian filter. See section 4.1.1 of Colquhoun and Sigworth, &quot;Fitting and Analysis of Single-Channel segments&quot;. NOTE: This is potentially problematic, in that this unfiltering lengthens every dwell. A less naive algorithm would take into account the infulence of the surroundings, as they impact the effects of the filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>risetime.correct_gaussian(Tr, segments, units = "s")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="risetime.correct_gaussian_+3A_tr">Tr</code></td>
<td>
<p>Rise time of the filter in (us)</p>
</td></tr>
<tr><td><code id="risetime.correct_gaussian_+3A_segments">segments</code></td>
<td>
<p>A segment or multiple segments with $states and $dwells to correct.</p>
</td></tr>
<tr><td><code id="risetime.correct_gaussian_+3A_units">units</code></td>
<td>
<p>What unit the risetime is input in (defaults to seconds)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Segment or multiple segments with corrected risetimes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
infile &lt;- system.file("extdata", "example1_tac.evt", package = "scbursts")
transitions &lt;- evt.read(infile)
dwells &lt;- evt.to_dwells(transitions)

dwells_c &lt;- risetime.correct_gaussian(Tr=35.0052278, dwells, units="us")

</code></pre>

<hr>
<h2 id='scan.read'>Read a scan results text file. scan.read returns a 1 segment list
Reads in scan results and puts them in the same format as the output
of dwt.read. See 'dwt', and 'segment' for more information.</h2><span id='topic+scan.read'></span>

<h3>Description</h3>

<p>Data is in seconds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan.read(filename, separating_factor = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan.read_+3A_filename">filename</code></td>
<td>
<p>the file name to read from.</p>
</td></tr>
<tr><td><code id="scan.read_+3A_separating_factor">separating_factor</code></td>
<td>
<p>In lieu of a known time between segments, 
seperate with a multple of the longest dwell.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of recording segments from the scan file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
infile &lt;- system.file("extdata", "example1_scan.txt", package = "scbursts")
record &lt;- scan.read(infile)
head(record)

</code></pre>

<hr>
<h2 id='segment.check_subconductance'>Check if segment contains subconductive states</h2><span id='topic+segment.check_subconductance'></span>

<h3>Description</h3>

<p>Check if segment contains subconductive states
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment.check_subconductance(segment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment.check_subconductance_+3A_segment">segment</code></td>
<td>
<p>The dwells and states table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>True if it contains an conductance other than 0 or 1, False otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# It's more likely that you created states or dwells with some function
states  &lt;-  c(0,    0.2,    0,    1,    0,  0.5,    0,  0.7,    0,    1)
dwells  &lt;-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst &lt;- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

segment.check_subconductance(my_burst)

</code></pre>

<hr>
<h2 id='segment.closed_dwells'>Extract closed dwells.</h2><span id='topic+segment.closed_dwells'></span>

<h3>Description</h3>

<p>Extract closed dwells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment.closed_dwells(segment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment.closed_dwells_+3A_segment">segment</code></td>
<td>
<p>the segment object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the closed dwells
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# It's more likely that you created states or dwells with some function
states  &lt;-  c(0,      1,    0,    1,    0,    1,    0,    1,    0,    1)
dwells  &lt;-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst &lt;- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

closed_dwells &lt;- segment.closed_dwells(my_burst)
head(closed_dwells)

</code></pre>

<hr>
<h2 id='segment.conductance_states'>Return a list of all the (sub)conductance states.</h2><span id='topic+segment.conductance_states'></span>

<h3>Description</h3>

<p>Return a list of all the (sub)conductance states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment.conductance_states(segment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment.conductance_states_+3A_segment">segment</code></td>
<td>
<p>The dwells and states table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of all the (sub)conductance states.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# It's more likely that you created states or dwells with some function
states  &lt;-  c(0,    0.2,    0,    1,    0,  0.5,    0,  0.7,    0,    1)
dwells  &lt;-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst &lt;- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

segment.conductance_states(my_burst)

</code></pre>

<hr>
<h2 id='segment.consecutives_to_dwells'>Collapses a segment into dwells with alternating conductance levels.</h2><span id='topic+segment.consecutives_to_dwells'></span>

<h3>Description</h3>

<p>Segments may contain consecutive dwells with the same conductance level. 
consecutives_to_dwells sums together all consecutive dwells with the same
conductance level. The result is a segment containing dwells that alternate
in conductance level (i.e. 1,0,1,0,1,...)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment.consecutives_to_dwells(segment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment.consecutives_to_dwells_+3A_segment">segment</code></td>
<td>
<p>The dwells and states table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified copy of the original segment
</p>

<hr>
<h2 id='segment.copy'>Copy a segment</h2><span id='topic+segment.copy'></span>

<h3>Description</h3>

<p>This is a low-level function, mostly for use internally by other functions. There aren't many reasons to use this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment.copy(segment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment.copy_+3A_segment">segment</code></td>
<td>
<p>The segment to copy</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A duplicate identical content.
</p>

<hr>
<h2 id='segment.count_closed'>Extract number of closed dwells. In the case of subconductive states,
a dwell is only closed if the conductance is exactly zero.</h2><span id='topic+segment.count_closed'></span>

<h3>Description</h3>

<p>Extract number of closed dwells. In the case of subconductive states,
a dwell is only closed if the conductance is exactly zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment.count_closed(segment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment.count_closed_+3A_segment">segment</code></td>
<td>
<p>the segment object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number of closed dwells
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# It's more likely that you created states or dwells with some function
states  &lt;-  c(0,      1,    0,    1,    0,    1,    0,    1,    0,    1)
dwells  &lt;-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst &lt;- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

segment.count_closed(my_burst)

</code></pre>

<hr>
<h2 id='segment.count_dwells'>Extract number of dwells in segment.</h2><span id='topic+segment.count_dwells'></span>

<h3>Description</h3>

<p>Extract number of dwells in segment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment.count_dwells(segment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment.count_dwells_+3A_segment">segment</code></td>
<td>
<p>the segment object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number of dwells
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# It's more likely that you created states or dwells with some function
states  &lt;-  c(0,      1,    0,    1,    0,    1,    0,    1,    0,    1)
dwells  &lt;-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst &lt;- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

segment.count_dwells(my_burst)

</code></pre>

<hr>
<h2 id='segment.count_open'>Extract number of open dwells. In the case of subconductive states,
count the number of non-zero states.</h2><span id='topic+segment.count_open'></span>

<h3>Description</h3>

<p>Extract number of open dwells. In the case of subconductive states,
count the number of non-zero states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment.count_open(segment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment.count_open_+3A_segment">segment</code></td>
<td>
<p>the segment object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number of open dwells
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# It's more likely that you created states or dwells with some function
states  &lt;-  c(0,      1,    0,    1,    0,    1,    0,    1,    0,    1)
dwells  &lt;-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst &lt;- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

segment.count_open(my_burst)

</code></pre>

<hr>
<h2 id='segment.create'>Create a &quot;segment&quot; object</h2><span id='topic+segment.create'></span>

<h3>Description</h3>

<p>This is a low-level function, mostly for use internally by other functions. There aren't many reasons to use this. Create object containing table data and metadata. The object can be used as a dataframe, and the metadata can be accessed with the functions: segment.seg, segment.start_time, segment.filename
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment.create(states, dwells, seg = 1, start_time = 0,
  name = "burst", ignore_errors = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment.create_+3A_states">states</code></td>
<td>
<p>a vector of states</p>
</td></tr>
<tr><td><code id="segment.create_+3A_dwells">dwells</code></td>
<td>
<p>a vector of dwell durations (same length as states)</p>
</td></tr>
<tr><td><code id="segment.create_+3A_seg">seg</code></td>
<td>
<p>The segment number. Defaults to 1</p>
</td></tr>
<tr><td><code id="segment.create_+3A_start_time">start_time</code></td>
<td>
<p>When the dwells began. Defaults to 0</p>
</td></tr>
<tr><td><code id="segment.create_+3A_name">name</code></td>
<td>
<p>Suffix-less version of the original filename. 60uM.dwt -&gt; '60uM'</p>
</td></tr>
<tr><td><code id="segment.create_+3A_ignore_errors">ignore_errors</code></td>
<td>
<p>Do not report faulty segments (not many reasons to do this)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The segment object: A dataframe with extra metadata.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# It's more likely that you created states or dwells with some function
states  &lt;-  c(0,      1,    0,    1,    0,    1,    0,    1,    0,    1)
dwells  &lt;-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst &lt;- segment.create(states, dwells, seg=1, start_time=0, name="example_segment")

segment.name(my_burst)

</code></pre>

<hr>
<h2 id='segment.duration'>Get duration of a segment.</h2><span id='topic+segment.duration'></span>

<h3>Description</h3>

<p>Get duration of a segment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment.duration(segment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment.duration_+3A_segment">segment</code></td>
<td>
<p>the segment object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the duration
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# It's more likely that you created states or dwells with some function
states  &lt;-  c(0,      1,    0,    1,    0,    1,    0,    1,    0,    1)
dwells  &lt;-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst &lt;- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

segment.duration(my_burst)

</code></pre>

<hr>
<h2 id='segment.dwells_by_conductance'>Extract dwells in conductance range. lower &lt;= x &lt;= upper</h2><span id='topic+segment.dwells_by_conductance'></span>

<h3>Description</h3>

<p>Extract dwells in conductance range. lower &lt;= x &lt;= upper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment.dwells_by_conductance(segment, level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment.dwells_by_conductance_+3A_segment">segment</code></td>
<td>
<p>the segment object</p>
</td></tr>
<tr><td><code id="segment.dwells_by_conductance_+3A_level">level</code></td>
<td>
<p>The conductance to extract</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the dwells in a given range
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# It's more likely that you created states or dwells with some function
states  &lt;-  c(0,    0.2,    0,    1,    0,  0.5,    0,  0.7,    0,    1)
dwells  &lt;-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst &lt;- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

half_open &lt;- segment.dwells_by_conductance(my_burst, 0.5)
head(half_open)

</code></pre>

<hr>
<h2 id='segment.dwells_by_conductance_range'>Extract dwells in conductance range. lower &lt;= x &lt;= upper</h2><span id='topic+segment.dwells_by_conductance_range'></span>

<h3>Description</h3>

<p>Extract dwells in conductance range. lower &lt;= x &lt;= upper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment.dwells_by_conductance_range(segment, lower = 0, upper = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment.dwells_by_conductance_range_+3A_segment">segment</code></td>
<td>
<p>the segment object</p>
</td></tr>
<tr><td><code id="segment.dwells_by_conductance_range_+3A_lower">lower</code></td>
<td>
<p>lower bound on conductance (defaults to 0)</p>
</td></tr>
<tr><td><code id="segment.dwells_by_conductance_range_+3A_upper">upper</code></td>
<td>
<p>upper bound on conductance (defaults to infinity)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the dwells in a given range
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# It's more likely that you created states or dwells with some function
states  &lt;-  c(0,    0.2,    0,    1,    0,  0.5,    0,  0.7,    0,    1)
dwells  &lt;-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst &lt;- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

half_open &lt;- segment.dwells_by_conductance_range(my_burst, lower=0.2, upper=0.7)
head(half_open)

</code></pre>

<hr>
<h2 id='segment.impose_deadtime'>Imposes a deadtime to a segment by removing any dwell that is shorter than the deadtime.</h2><span id='topic+segment.impose_deadtime'></span>

<h3>Description</h3>

<p>The user specifies a deadtime in microseconds. The function effectively undoes
the work of the event detection algorithm by reverting the conductance level 
(of the brief dwell) back to the previous conductance level in the time sequence.
The function then returns a collapsed segment containing alternating dwells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment.impose_deadtime(segment, deadtime)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment.impose_deadtime_+3A_segment">segment</code></td>
<td>
<p>the segment containing dwells and states.</p>
</td></tr>
<tr><td><code id="segment.impose_deadtime_+3A_deadtime">deadtime</code></td>
<td>
<p>the briefest possible event in microseconds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified copy of the original segment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# It's more likely that you created states or dwells with some function
states  &lt;-  c(0,    0.2,    0,    1,    0,  0.5,    0,  0.7,    0,    1)
dwells  &lt;-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst &lt;- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

my_burst_d &lt;- segment.impose_deadtime(my_burst, deadtime=0.3)

</code></pre>

<hr>
<h2 id='segment.modify_conductance'>Transform the conductance states according to a user-defined function of conductance level.</h2><span id='topic+segment.modify_conductance'></span>

<h3>Description</h3>

<p>Transform the conductance states according to a user-defined function of conductance level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment.modify_conductance(segment, fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment.modify_conductance_+3A_segment">segment</code></td>
<td>
<p>the segment containing dwells and states.</p>
</td></tr>
<tr><td><code id="segment.modify_conductance_+3A_fun">fun</code></td>
<td>
<p>a function on conductance levels (states)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified copy of the original segment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# It's more likely that you created states or dwells with some function
states  &lt;-  c(0,    0.2,    0,    1,    0,  0.5,    0,  0.7,    0,    1)
dwells  &lt;-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst &lt;- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

### Collapse into three subconductance states
fun &lt;- function(amp) {
    if (amp &lt; 0.3)
        return(0)
    else if (amp &gt;= 0.3 &amp;&amp; amp &lt; 0.6)
        return(0.5)
    else
        return(1)
}

my_burst_d &lt;- segment.modify_conductance(my_burst, fun)

</code></pre>

<hr>
<h2 id='segment.name'>Extract name from segment.</h2><span id='topic+segment.name'></span>

<h3>Description</h3>

<p>Extract name from segment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment.name(segment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment.name_+3A_segment">segment</code></td>
<td>
<p>the segment object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Segment name (string)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# It's more likely that you created states or dwells with some function
states  &lt;-  c(0,      1,    0,    1,    0,    1,    0,    1,    0,    1)
dwells  &lt;-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst &lt;- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

segment.name(my_burst)

</code></pre>

<hr>
<h2 id='segment.open_dwells'>Extract open dwells. (Any conductance greater than zero)</h2><span id='topic+segment.open_dwells'></span>

<h3>Description</h3>

<p>Extract open dwells. (Any conductance greater than zero)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment.open_dwells(segment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment.open_dwells_+3A_segment">segment</code></td>
<td>
<p>the segment object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the open dwells
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# It's more likely that you created states or dwells with some function
states  &lt;-  c(0,      1,    0,    1,    0,    1,    0,    1,    0,    1)
dwells  &lt;-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst &lt;- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

open_dwells &lt;- segment.open_dwells(my_burst)
head(open_dwells)

</code></pre>

<hr>
<h2 id='segment.pclosed'>Calculate empirical P(Closed) of a segment.</h2><span id='topic+segment.pclosed'></span>

<h3>Description</h3>

<p>Calculate empirical P(Closed) of a segment. NOTE: Assuming that burst starts and ends with 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment.pclosed(segment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment.pclosed_+3A_segment">segment</code></td>
<td>
<p>The dwells and states table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The ratio of closed time to total time
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# It's more likely that you created states or dwells with some function
states  &lt;-  c(0,      1,    0,    1,    0,    1,    0,    1,    0,    1)
dwells  &lt;-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst &lt;- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

# P(Closed) of this burst
segment.pclosed(my_burst)

</code></pre>

<hr>
<h2 id='segment.pconductance'>Calculate empirical P(Lower &lt;= Conductance &lt;= Upper) of a segment.</h2><span id='topic+segment.pconductance'></span>

<h3>Description</h3>

<p>Calculate empirical P(Lower &lt;= Conductance &lt;= Upper) of a segment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment.pconductance(segment, level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment.pconductance_+3A_segment">segment</code></td>
<td>
<p>the segment object</p>
</td></tr>
<tr><td><code id="segment.pconductance_+3A_level">level</code></td>
<td>
<p>conductance level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The probability of being in this conductance state
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# It's more likely that you created states or dwells with some function
states  &lt;-  c(0,    0.2,    0,    1,    0,  0.5,    0,  0.7,    0,    1)
dwells  &lt;-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst &lt;- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

segment.pconductance(my_burst, 0.5)

</code></pre>

<hr>
<h2 id='segment.pconductance_range'>Calculate empirical P(Lower &lt;= Conductance &lt;= Upper) of a segment.</h2><span id='topic+segment.pconductance_range'></span>

<h3>Description</h3>

<p>Calculate empirical P(Lower &lt;= Conductance &lt;= Upper) of a segment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment.pconductance_range(segment, lower = 0, upper = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment.pconductance_range_+3A_segment">segment</code></td>
<td>
<p>the segment object</p>
</td></tr>
<tr><td><code id="segment.pconductance_range_+3A_lower">lower</code></td>
<td>
<p>lower bound on conductance (defaults to 0)</p>
</td></tr>
<tr><td><code id="segment.pconductance_range_+3A_upper">upper</code></td>
<td>
<p>upper bound on conductance (defaults to infinity)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The probability of being in these conductance states
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# It's more likely that you created states or dwells with some function
states  &lt;-  c(0,    0.2,    0,    1,    0,  0.5,    0,  0.7,    0,    1)
dwells  &lt;-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst &lt;- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

segment.pconductance_range(my_burst, lower=0.5, upper=0.5)

</code></pre>

<hr>
<h2 id='segment.popen'>Calculate empirical P(Open) of a segment. (A state is considered open if the conductance is non-zero)</h2><span id='topic+segment.popen'></span>

<h3>Description</h3>

<p>Calculate empirical P(Open) of a segment. NOTE: Assuming that burst starts and ends with 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment.popen(segment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment.popen_+3A_segment">segment</code></td>
<td>
<p>The dwells and states table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The ratio of open time to total time
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# It's more likely that you created states or dwells with some function
states  &lt;-  c(0,      1,    0,    1,    0,    1,    0,    1,    0,    1)
dwells  &lt;-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst &lt;- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

# P(Open) of this burst
segment.popen(my_burst)

</code></pre>

<hr>
<h2 id='segment.seg'>Extract segment number from segment.</h2><span id='topic+segment.seg'></span>

<h3>Description</h3>

<p>Extract segment number from segment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment.seg(segment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment.seg_+3A_segment">segment</code></td>
<td>
<p>the segment object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Segment number (integer)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# It's more likely that you created states or dwells with some function
states  &lt;-  c(0,      1,    0,    1,    0,    1,    0,    1,    0,    1)
dwells  &lt;-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst &lt;- segment.create(states, dwells, seg=1, start_time=0, name="example_segment")

segment.seg(my_burst)

</code></pre>

<hr>
<h2 id='segment.start_time'>Extract start_time from segment.</h2><span id='topic+segment.start_time'></span>

<h3>Description</h3>

<p>Extract start_time from segment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment.start_time(segment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment.start_time_+3A_segment">segment</code></td>
<td>
<p>the segment object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Segment start_time (float)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# It's more likely that you created states or dwells with some function
states  &lt;-  c(0,      1,    0,    1,    0,    1,    0,    1,    0,    1)
dwells  &lt;-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst &lt;- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

segment.start_time(my_burst)

</code></pre>

<hr>
<h2 id='segment.subconductance_as'>Imposes a fixed conductance level (0 or 1) to all dwells with subconductance levels.</h2><span id='topic+segment.subconductance_as'></span>

<h3>Description</h3>

<p>The user specifies the desired level ('open' or 'closed'). The function will modify
any subconductance level (that is not 0 or 1) to be the desired level 1 for 'open'
or 0 for 'closed'. The function then reutrns a collapsed segment containing 
alternating dwells.
(See segment.consecutives_to_dwells for details about the collapsed segment.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment.subconductance_as(segment, level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment.subconductance_as_+3A_segment">segment</code></td>
<td>
<p>the segment containing dwells and states.</p>
</td></tr>
<tr><td><code id="segment.subconductance_as_+3A_level">level</code></td>
<td>
<p>either 'open' or 'closed'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified copy of the original segment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# It's more likely that you created states or dwells with some function
states  &lt;-  c(0,    0.2,    0,    1,    0,  0.5,    0,  0.7,    0,    1)
dwells  &lt;-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst &lt;- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

my_burst_d &lt;- segment.subconductance_as(my_burst, "open")

</code></pre>

<hr>
<h2 id='segment.verify'>Detect misrecorded data.</h2><span id='topic+segment.verify'></span>

<h3>Description</h3>

<p>Segments should have a very specific shape, but recordings can produce errors that make non-sensical segments. In particular, ones contain multiple consecutive states of equal conductance, or end in closings. This function detects whether a segment satisfies the constraint that the segment conductances are not the same from one dwell to the next, and begin and end with a closing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment.verify(segment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment.verify_+3A_segment">segment</code></td>
<td>
<p>The dwells and states table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>True if a valid segment, False otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# It's more likely that you created states or dwells with some function
states  &lt;-  c(0,      1,    0,    1,    0,    1,    0,    1,    0,    1)
dwells  &lt;-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst &lt;- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

segment.verify(my_burst)

# Now, a bad burst with two adjacent open dwells
states  &lt;-  c(0,      1,    0,    1,    1,    0,    1,    0,    1)
dwells  &lt;-  c(0.1,  1.1,  0.5,  0.2,  1.1,  0.6,  1.1,  0.8,  1.1)

# This will issue a warning
faulty_burst &lt;- segment.create(states, dwells, seg=1, start_time=3.14159, name="faulty_segment")

# This will differentiate good and faulty bursts
segment.verify(faulty_burst)

# If you have a list of bursts, you can select the good ones with
# vbursts &lt;- bursts.select(bursts, segment.verify)

</code></pre>

<hr>
<h2 id='util.basename'>Remove suffix and path from filename.</h2><span id='topic+util.basename'></span>

<h3>Description</h3>

<p>Remove suffix and path from filename.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>util.basename(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="util.basename_+3A_filename">filename</code></td>
<td>
<p>string to extract basename from</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Name with suffix and path removed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>util.basename("bursts/60uM-2017-08-18-16-32/60uM-712.dwt")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
