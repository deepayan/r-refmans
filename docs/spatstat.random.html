<!DOCTYPE html><html><head><title>Help for package spatstat.random</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spatstat.random}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.owin.rmhmodel'><p>Convert Data To Class owin</p></a></li>
<li><a href='#clusterfield'><p>Field of clusters</p></a></li>
<li><a href='#clusterkernel'>
<p>Extract Cluster Offspring Kernel</p></a></li>
<li><a href='#clusterradius'>
<p>Compute or Extract Effective Range of Cluster Kernel</p></a></li>
<li><a href='#default.expand'><p>Default Expansion Rule for Simulation of Model</p></a></li>
<li><a href='#default.rmhcontrol'><p>Set Default Control Parameters for Metropolis-Hastings Algorithm.</p></a></li>
<li><a href='#dmixpois'>
<p>Mixed Poisson Distribution</p></a></li>
<li><a href='#domain.rmhmodel'>
<p>Extract the Domain of any Spatial Object</p></a></li>
<li><a href='#dpakes'>
<p>Pakes distribution</p></a></li>
<li><a href='#expand.owin'><p>Apply Expansion Rule</p></a></li>
<li><a href='#gauss.hermite'>
<p>Gauss-Hermite Quadrature Approximation to Expectation for Normal Distribution</p></a></li>
<li><a href='#indefinteg'>
<p>Indefinite Integral</p></a></li>
<li><a href='#is.stationary'>
<p>Recognise Stationary and Poisson Point Process Models</p></a></li>
<li><a href='#quadratresample'><p>Resample a Point Pattern by Resampling Quadrats</p></a></li>
<li><a href='#rags'>
<p>Alternating Gibbs Sampler for Multitype Point Processes</p></a></li>
<li><a href='#ragsAreaInter'>
<p>Alternating Gibbs Sampler for Area-Interaction Process</p></a></li>
<li><a href='#ragsMultiHard'>
<p>Alternating Gibbs Sampler for Multitype Hard Core Process</p></a></li>
<li><a href='#rCauchy'><p>Simulate Neyman-Scott Point Process with Cauchy cluster kernel</p></a></li>
<li><a href='#rcell'><p>Simulate Baddeley-Silverman Cell Process</p></a></li>
<li><a href='#rcellnumber'>
<p>Generate Random Numbers of Points for Cell Process</p></a></li>
<li><a href='#rclusterBKBC'>
<p>Simulate Cluster Process using Brix-Kendall Algorithm or Modifications</p></a></li>
<li><a href='#rDGS'><p>Perfect Simulation of the Diggle-Gates-Stibbard Process</p></a></li>
<li><a href='#rDiggleGratton'><p>Perfect Simulation of the Diggle-Gratton Process</p></a></li>
<li><a href='#reach'><p>Interaction Distance of a Point Process Model</p></a></li>
<li><a href='#recipEnzpois'>
<p>First Reciprocal Moment of the Truncated Poisson Distribution</p></a></li>
<li><a href='#rGaussPoisson'><p>Simulate Gauss-Poisson Process</p></a></li>
<li><a href='#rHardcore'><p>Perfect Simulation of the Hardcore Process</p></a></li>
<li><a href='#rjitter.psp'><p>Random Perturbation of Line Segment Pattern</p></a></li>
<li><a href='#rknn'>
<p>Theoretical Distribution of Nearest Neighbour Distance</p></a></li>
<li><a href='#rlabel'><p>Random Re-Labelling of Point Pattern</p></a></li>
<li><a href='#rLGCP'><p>Simulate Log-Gaussian Cox Process</p></a></li>
<li><a href='#rMatClust'><p>Simulate Matern Cluster Process</p></a></li>
<li><a href='#rMaternI'><p>Simulate Matern Model I</p></a></li>
<li><a href='#rMaternII'><p>Simulate Matern Model II</p></a></li>
<li><a href='#rmh'><p>Simulate point patterns using the Metropolis-Hastings algorithm.</p></a></li>
<li><a href='#rmh.default'><p>Simulate Point Process Models using the Metropolis-Hastings Algorithm.</p></a></li>
<li><a href='#rmhcontrol'><p>Set Control Parameters for Metropolis-Hastings Algorithm.</p></a></li>
<li><a href='#rmhexpand'>
<p>Specify Simulation Window or Expansion Rule</p></a></li>
<li><a href='#rmhmodel'><p>Define Point Process Model for Metropolis-Hastings Simulation.</p></a></li>
<li><a href='#rmhmodel.default'><p>Build Point Process Model for Metropolis-Hastings Simulation.</p></a></li>
<li><a href='#rmhmodel.list'><p>Define Point Process Model for Metropolis-Hastings Simulation.</p></a></li>
<li><a href='#rmhstart'><p>Determine Initial State for Metropolis-Hastings Simulation.</p></a></li>
<li><a href='#rMosaicField'><p>Mosaic Random Field</p></a></li>
<li><a href='#rMosaicSet'><p>Mosaic Random Set</p></a></li>
<li><a href='#rmpoint'><p>Generate N Random Multitype Points</p></a></li>
<li><a href='#rmpoispp'><p>Generate Multitype Poisson Point Pattern</p></a></li>
<li><a href='#rNeymanScott'><p>Simulate Neyman-Scott Process</p></a></li>
<li><a href='#rnoise'>
<p>Random Pixel Noise</p></a></li>
<li><a href='#rPenttinen'><p>Perfect Simulation of the Penttinen Process</p></a></li>
<li><a href='#rpoint'><p>Generate N Random Points</p></a></li>
<li><a href='#rpoisline'><p>Generate Poisson Random Line Process</p></a></li>
<li><a href='#rpoislinetess'><p>Poisson Line Tessellation</p></a></li>
<li><a href='#rpoispp'><p>Generate Poisson Point Pattern</p></a></li>
<li><a href='#rpoispp3'>
<p>Generate Poisson Point Pattern in Three Dimensions</p></a></li>
<li><a href='#rpoisppOnLines'><p>Generate Poisson Point Pattern on Line Segments</p></a></li>
<li><a href='#rpoisppx'>
<p>Generate Poisson Point Pattern in Any Dimensions</p></a></li>
<li><a href='#rPoissonCluster'><p>Simulate Poisson Cluster Process</p></a></li>
<li><a href='#rpoistrunc'>
<p>Random Values from the Truncated Poisson Distribution</p></a></li>
<li><a href='#rPSNCP'><p>Simulate Product Shot-noise Cox Process</p></a></li>
<li><a href='#rshift'><p>Random Shift</p></a></li>
<li><a href='#rshift.ppp'><p>Randomly Shift a Point Pattern</p></a></li>
<li><a href='#rshift.psp'><p>Randomly Shift a Line Segment Pattern</p></a></li>
<li><a href='#rshift.splitppp'><p>Randomly Shift a List of Point Patterns</p></a></li>
<li><a href='#rSSI'><p>Simulate Simple Sequential Inhibition</p></a></li>
<li><a href='#rstrat'><p>Simulate Stratified Random Point Pattern</p></a></li>
<li><a href='#rStrauss'><p>Perfect Simulation of the Strauss Process</p></a></li>
<li><a href='#rStraussHard'><p>Perfect Simulation of the Strauss-Hardcore Process</p></a></li>
<li><a href='#rtemper'>
<p>Simulated Annealing or Simulated Tempering for Gibbs Point Processes</p></a></li>
<li><a href='#rthin'><p>Random Thinning</p></a></li>
<li><a href='#rthinclumps'><p>Random Thinning of Clumps</p></a></li>
<li><a href='#rThomas'><p>Simulate Thomas Process</p></a></li>
<li><a href='#runifdisc'><p>Generate N Uniform Random Points in a Disc</p></a></li>
<li><a href='#runifpoint'><p>Generate N Uniform Random Points</p></a></li>
<li><a href='#runifpoint3'>
<p>Generate N Uniform Random Points in Three Dimensions</p></a></li>
<li><a href='#runifpointOnLines'><p>Generate N Uniform Random Points On Line Segments</p></a></li>
<li><a href='#runifpointx'>
<p>Generate N Uniform Random Points in Any Dimensions</p></a></li>
<li><a href='#rVarGamma'><p>Simulate Neyman-Scott Point Process with Variance Gamma cluster kernel</p></a></li>
<li><a href='#spatstat.random-internal'><p>Internal spatstat.random functions</p></a></li>
<li><a href='#spatstat.random-package'><p>The spatstat.random Package</p></a></li>
<li><a href='#update.rmhcontrol'><p>Update Control Parameters of Metropolis-Hastings Algorithm</p></a></li>
<li><a href='#will.expand'>
<p>Test Expansion Rule</p></a></li>
<li><a href='#Window.rmhmodel'><p>Extract Window of Spatial Object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>3.2-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-29</td>
</tr>
<tr>
<td>Title:</td>
<td>Random Generation Functionality for the 'spatstat' Family</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adrian Baddeley &lt;Adrian.Baddeley@curtin.edu.au&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), spatstat.data (&ge; 3.0), spatstat.geom (&ge;
3.2-9), stats, utils, methods, grDevices</td>
</tr>
<tr>
<td>Imports:</td>
<td>spatstat.utils (&ge; 3.0-2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spatial, spatstat.linnet (&ge; 3.0), spatstat.explore,
spatstat.model, spatstat (&ge; 3.0), gsl</td>
</tr>
<tr>
<td>Description:</td>
<td>Functionality for random generation of spatial data in the 'spatstat' family of packages.
	     Generates random spatial patterns of points according to many simple rules (complete spatial randomness,
	     Poisson, binomial, random grid, systematic, cell), randomised alteration of patterns
	     (thinning, random shift, jittering),  simulated realisations of random point processes including
	     simple sequential inhibition, Matern inhibition models, Neyman-Scott cluster processes
	     (using direct, Brix-Kendall, or hybrid algorithms),
	     log-Gaussian Cox processes, product shot noise cluster processes
	     and Gibbs point processes (using Metropolis-Hastings birth-death-shift algorithm,
	     alternating Gibbs sampler, or coupling-from-the-past perfect simulation).
	     Also generates random spatial patterns of line segments,
	     random tessellations, and random images (random noise, random mosaics).
	     Excludes random generation on a linear network,
	     which is covered by the separate package 'spatstat.linnet'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://spatstat.org/">http://spatstat.org/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/spatstat/spatstat.random/issues">https://github.com/spatstat/spatstat.random/issues</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-29 07:50:19 UTC; adrian</td>
</tr>
<tr>
<td>Author:</td>
<td>Adrian Baddeley <a href="https://orcid.org/0000-0001-9499-8382"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Rolf Turner <a href="https://orcid.org/0000-0001-5521-5218"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cph],
  Ege Rubak <a href="https://orcid.org/0000-0002-6675-533X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cph],
  Tilman Davies <a href="https://orcid.org/0000-0003-0565-1825"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Kasper Klitgaard Berthelsen [ctb, cph],
  David Bryant [ctb, cph],
  Ya-Mei Chang [ctb, cph],
  Ute Hahn [ctb],
  Abdollah Jalilian [ctb],
  Dominic Schuhmacher [ctb, cph],
  Rasmus Plenge Waagepetersen [ctb, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-29 11:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.owin.rmhmodel'>Convert Data To Class owin</h2><span id='topic+as.owin.rmhmodel'></span>

<h3>Description</h3>

<p>Converts data specifying an observation window
in any of several formats, into an object of class <code>"owin"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'rmhmodel'
as.owin(W, ..., fatal=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.owin.rmhmodel_+3A_w">W</code></td>
<td>

<p>Data specifying an observation window, in any of several formats
described under <em>Details</em> below.
</p>
</td></tr>
<tr><td><code id="as.owin.rmhmodel_+3A_fatal">fatal</code></td>
<td>

<p>Logical value determining what to do
if the data cannot be converted to an observation window.
See Details.
</p>
</td></tr>
<tr><td><code id="as.owin.rmhmodel_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The class <code>"owin"</code> is a way of specifying the observation window
for a point pattern. See <code>owin.object</code> for an overview.
</p>
<p>The generic function <code>as.owin</code> converts data in any of several formats 
into an object of class <code>"owin"</code> for use by the <span class="pkg">spatstat</span>
package. The function <code>as.owin</code> is generic, with methods
for different classes of objects, and a default method.
</p>
<p>The argument <code>W</code> may be
</p>

<ul>
<li>
<p>an object of class <code>"owin"</code>
</p>
</li>
<li>
<p>a structure with entries <code>xrange</code>, <code>yrange</code> specifying the 
<code class="reqn">x</code> and <code class="reqn">y</code> dimensions of a rectangle
</p>
</li>
<li>
<p>a structure with entries named <code>xmin</code>, <code>xmax</code>, <code>ymin</code>,
<code>ymax</code> (in any order) 
specifying the <code class="reqn">x</code> and <code class="reqn">y</code> dimensions of a rectangle.
This will accept objects of class <code>bbox</code> in the <code>sf</code> package.
</p>
</li>
<li>
<p>a numeric vector of length 4
(interpreted as <code>(xmin, xmax, ymin, ymax)</code> in that order)
specifying the <code class="reqn">x</code> and <code class="reqn">y</code> dimensions of a rectangle
</p>
</li>
<li>
<p>a structure with entries named <code>xl</code>, <code>xu</code>, <code>yl</code>, <code>yu</code>
(in any order)
specifying the <code class="reqn">x</code> and <code class="reqn">y</code> dimensions of a rectangle
as <code>(xmin, xmax) = (xl, xu)</code> and 
<code>(ymin, ymax) = (yl, yu)</code>. This will accept objects of
class <code>spp</code> used in the Venables and Ripley <span class="pkg">spatial</span>
package.
</p>
</li>
<li>
<p>an object of class <code>"ppp"</code> representing a point pattern.
In this case, the object's <code>window</code> structure will be
extracted.
</p>
</li>
<li>
<p>an object of class <code>"psp"</code> representing a line segment pattern.
In this case, the object's <code>window</code> structure will be
extracted.
</p>
</li>
<li>
<p>an object of class <code>"tess"</code> representing a tessellation.
In this case, the object's <code>window</code> structure will be
extracted.
</p>
</li>
<li>
<p>an object of class <code>"quad"</code> representing a quadrature scheme.
In this case, the window of the <code>data</code> component will be
extracted.
</p>
</li>
<li>
<p>an object of class <code>"im"</code> representing a pixel image.
In this case, a window of type <code>"mask"</code> will be returned,
with the same pixel raster coordinates as the image.
An image pixel value of <code>NA</code>, signifying that the pixel
lies outside the window, is transformed into the logical value
<code>FALSE</code>, which is the corresponding convention for window masks.
</p>
</li>
<li>
<p>an object of class <code>"ppm"</code>, <code>"kppm"</code>, <code>"slrm"</code>
or <code>"dppm"</code>
representing a fitted point process
model. In this case, if <code>from="data"</code> (the default),
<code>as.owin</code> extracts the  original point
pattern data to which the model was fitted, and returns the
observation window of this point pattern. If
<code>from="covariates"</code> then <code>as.owin</code> extracts the
covariate images to which the model was fitted,
and returns a binary mask window that specifies the pixel locations.
</p>
</li>
<li>
<p>an object of class <code>"lpp"</code>
representing a point pattern on a linear network.
In this case, <code>as.owin</code> extracts the linear network
and returns a window containing this network. 
</p>
</li>
<li>
<p>an object of class <code>"lppm"</code>
representing a fitted point process model on a linear network.
In this case, <code>as.owin</code> extracts the linear network
and returns a window containing this network. 
</p>
</li>
<li>
<p>A <code>data.frame</code> with exactly three columns. Each row of the
data frame corresponds to one pixel. Each row contains the
<code class="reqn">x</code> and <code class="reqn">y</code> coordinates of a pixel, and a logical value
indicating whether the pixel lies inside the window.   
</p>
</li>
<li>
<p>A <code>data.frame</code> with exactly two columns. Each row of the
data frame contains the <code class="reqn">x</code> and <code class="reqn">y</code> coordinates of a pixel
that lies inside the window.
</p>
</li>
<li>
<p>an object of class <code>"distfun"</code>, <code>"nnfun"</code>
or <code>"funxy"</code> representing a function of spatial location,
defined on a spatial domain. The spatial domain of the function will be
extracted.
</p>
</li>
<li>
<p>an object of class <code>"rmhmodel"</code> representing a
point process model that can be simulated using <code><a href="#topic+rmh">rmh</a></code>.
The window (spatial domain) of the model will be extracted.
The window may be <code>NULL</code> in some circumstances (indicating that the
simulation window has not yet been determined). This is not treated
as an error, because the argument <code>fatal</code> defaults to
<code>FALSE</code> for this method.
</p>
</li>
<li>
<p>an object of class <code>"layered"</code> representing a
list of spatial objects. See <code>layered</code>.
In this case, <code>as.owin</code> will be applied to each
of the objects in the list, and the union of these windows
will be returned.
</p>
</li>
<li>
<p>an object of another suitable class from another package.
For full details, see <code>vignette('shapefiles')</code>.
</p>
</li></ul>

<p>If the argument <code>W</code> is not in one of these formats
and cannot be converted to a window, then an error will
be generated (if <code>fatal=TRUE</code>) or a value of <code>NULL</code>
will be returned (if <code>fatal=FALSE</code>).
</p>
<p>When <code>W</code> is a data frame, the argument <code>step</code>
can be used to specify the pixel grid spacing; otherwise, the spacing
will be guessed from the data.
</p>


<h3>Value</h3>

<p>An object of class <code>"owin"</code> (see <code>owin.object</code>)
specifying an observation window.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+as.owin">as.owin</a></code>,
<code><a href="spatstat.model.html#topic+as.owin.ppm">as.owin.ppm</a></code>,
<code><a href="spatstat.linnet.html#topic+as.owin.lpp">as.owin.lpp</a></code>.
</p>
<p><code>owin.object</code>,
<code>owin</code>.
</p>
<p>Additional methods for <code>as.owin</code> may be provided
by other packages outside the <span class="pkg">spatstat</span> family.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  m &lt;- rmhmodel(cif='poisson', par=list(beta=1), w=square(2))
  as.owin(m)
</code></pre>

<hr>
<h2 id='clusterfield'>Field of clusters</h2><span id='topic+clusterfield'></span><span id='topic+clusterfield.character'></span><span id='topic+clusterfield.function'></span>

<h3>Description</h3>

<p>Calculate the superposition of cluster kernels at the location of a
point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  clusterfield(model, locations = NULL, ...)

  ## S3 method for class 'character'
clusterfield(model, locations = NULL, ...)

  ## S3 method for class 'function'
clusterfield(model, locations = NULL, ..., mu = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterfield_+3A_model">model</code></td>
<td>

<p>Cluster model. Either a fitted cluster model (object of class
<code>"kppm"</code>), a character string specifying the type of cluster
model, or a function defining the cluster kernel. See Details.
</p>
</td></tr>
<tr><td><code id="clusterfield_+3A_locations">locations</code></td>
<td>

<p>A point pattern giving the locations of the kernels. Defaults to the
centroid of the observation window for the <code>"kppm"</code> method and
to the center of a unit square otherwise.
</p>
</td></tr>
<tr><td><code id="clusterfield_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="spatstat.explore.html#topic+density.ppp">density.ppp</a></code> or the
cluster kernel. See Details.
</p>
</td></tr>
<tr><td><code id="clusterfield_+3A_mu">mu</code></td>
<td>

<p>Mean number of offspring per cluster. 
A single number or a pixel image.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>clusterfield</code> is generic,
with methods for <code>"character"</code> and <code>"function"</code> (described here)
and a method for <code>"kppm"</code>
(described in <code><a href="spatstat.model.html#topic+clusterfield.kppm">clusterfield.kppm</a></code>).
</p>
<p>The calculations are performed by <code><a href="spatstat.explore.html#topic+density.ppp">density.ppp</a></code> and
<code>...</code> arguments are passed thereto for control over the pixel
resolution etc.
(These arguments are then passed on to <code><a href="spatstat.geom.html#topic+pixellate.ppp">pixellate.ppp</a></code>
and <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code>.)
</p>
<p>For the method <code>clusterfield.function</code>,
the given kernel function should accept
vectors of x and y coordinates as its first two arguments. Any
additional arguments may be passed through the <code>...</code>.
</p>
<p>The method <code>clusterfield.function</code>
also accepts the optional parameter <code>mu</code>
(defaulting to 1) specifying the mean number of points per cluster (as
a numeric) or the inhomogeneous reference cluster intensity (as an
<code>"im"</code> object or a <code>function(x,y)</code>). The interpretation of
<code>mu</code> is as explained in the simulation functions referenced in
the See Also section below.
</p>
<p>For the method <code>clusterfield.character</code>, the
argument <code>model</code> must be one of
the following character strings:
<code>model="Thomas"</code> for the Thomas process,
<code>model="MatClust"</code> for the Matern cluster process,
<code>model="Cauchy"</code> for the Neyman-Scott cluster process with
Cauchy kernel, or <code>model="VarGamma"</code> for the Neyman-Scott
cluster process with Variance Gamma kernel. For all these models the
parameter <code>scale</code> is required and passed through <code>...</code> as
well as the parameter <code>nu</code> when <code>model="VarGamma"</code>. This
method calls <code>clusterfield.function</code> so the parameter <code>mu</code>
may also be passed through <code>...</code> and will be interpreted as
explained above.
</p>


<h3>Value</h3>

<p>A pixel image (object of class <code>"im"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.model.html#topic+clusterfield.kppm">clusterfield.kppm</a></code>.
</p>
<p><code><a href="spatstat.explore.html#topic+density.ppp">density.ppp</a></code> and <code><a href="spatstat.model.html#topic+kppm">kppm</a></code>.
</p>
<p>Simulation algorithms for cluster models:
<code><a href="#topic+rCauchy">rCauchy</a></code>
<code><a href="#topic+rMatClust">rMatClust</a></code>
<code><a href="#topic+rThomas">rThomas</a></code>
<code><a href="#topic+rVarGamma">rVarGamma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # method for functions
  kernel &lt;- function(x,y,scal) { 
      r &lt;- sqrt(x^2 + y^2)
      ifelse(r &gt; 0,
             dgamma(r, shape=5, scale=scal)/(2 * pi * r),
             0)               
  }
  X &lt;- runifpoint(10)
  clusterfield(kernel, X, scal=0.05)
</code></pre>

<hr>
<h2 id='clusterkernel'>
Extract Cluster Offspring Kernel
</h2><span id='topic+clusterkernel'></span><span id='topic+clusterkernel.character'></span>

<h3>Description</h3>

<p>Given a cluster point process model, this command
returns the probability density of the cluster offspring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterkernel(model, ...)
## S3 method for class 'character'
clusterkernel(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterkernel_+3A_model">model</code></td>
<td>

<p>Cluster model. Either a fitted cluster or Cox model
(object of class <code>"kppm"</code>), or a character string
specifying the type of cluster model.
</p>
</td></tr>
<tr><td><code id="clusterkernel_+3A_...">...</code></td>
<td>

<p>Parameter values for the model,
when <code>model</code> is a character string.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a specification of a cluster point process model, this command
returns a <code>function(x,y)</code> giving the two-dimensional
probability density of the cluster offspring points assuming a cluster parent
located at the origin.
</p>
<p>The function <code>clusterkernel</code> is generic,
with methods for class <code>"character"</code> (described here)
and <code>"kppm"</code> (described in <code><a href="spatstat.model.html#topic+clusterkernel.kppm">clusterkernel.kppm</a></code>).
</p>


<h3>Value</h3>

<p>A function in the <span class="rlang"><b>R</b></span> language with arguments <code>x,y,...</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.model.html#topic+clusterkernel.kppm">clusterkernel.kppm</a></code>),
<code><a href="#topic+clusterfield">clusterfield</a></code>, <code><a href="spatstat.model.html#topic+kppm">kppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  f &lt;- clusterkernel("Thomas", kappa=10, scale=0.5)
  f(0.1, 0.2)
</code></pre>

<hr>
<h2 id='clusterradius'>
Compute or Extract Effective Range of Cluster Kernel
</h2><span id='topic+clusterradius'></span><span id='topic+clusterradius.character'></span>

<h3>Description</h3>

<p>Given a cluster point process model, this command
returns a value beyond which the the probability density of the
cluster offspring is neglible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterradius(model, ...)

## S3 method for class 'character'
clusterradius(model, ..., thresh = NULL, precision = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterradius_+3A_model">model</code></td>
<td>

<p>Cluster model. Either a fitted cluster or Cox model
(object of class <code>"kppm"</code>), or a character string
specifying the type of cluster model.
</p>
</td></tr>
<tr><td><code id="clusterradius_+3A_...">...</code></td>
<td>

<p>Parameter values for the model,
when <code>model</code> is a character string.
</p>
</td></tr>
<tr><td><code id="clusterradius_+3A_thresh">thresh</code></td>
<td>

<p>Numerical threshold relative to the cluster kernel value at the
origin (parent location) determining when the cluster kernel
will be considered neglible. A sensible default is provided.
</p>
</td></tr>
<tr><td><code id="clusterradius_+3A_precision">precision</code></td>
<td>

<p>Logical. If <code>precision=TRUE</code> the precision of the calculated
range is returned as an attribute to the range. See details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a cluster model this function by default returns the effective
range of the model with the given parameters as used in spatstat. For
the Matern cluster model (see e.g. <code><a href="#topic+rMatClust">rMatClust</a></code>) this is
simply the finite radius of the offsring density given by the paramter
<code>scale</code> irrespective of other options given to this function. The
remaining models in spatstat have infinite theoretical range, and an
effective finite value is given as follows: For the Thomas model (see
e.g. <code><a href="#topic+rThomas">rThomas</a></code> the default is <code>4*scale</code> where scale
is the scale or standard deviation parameter of the model. If
<code>thresh</code> is given the value is instead found as described for the
other models below.
</p>
<p>For the Cauchy model (see e.g. <code><a href="#topic+rCauchy">rCauchy</a></code>) and the Variance
Gamma (Bessel) model (see e.g. <code><a href="#topic+rVarGamma">rVarGamma</a></code>) the value of
<code>thresh</code> defaults to 0.001, and then this is used to compute the
range numerically as follows. If <code class="reqn">k(x,y)=k_0(r)</code>
with <code class="reqn">r=\sqrt(x^2+y^2)</code>
denotes the isotropic cluster kernel then <code class="reqn">f(r) = 2 \pi r
  k_0(r)</code> is the
density function of the offspring distance from the parent. The range
is determined as the value of <code class="reqn">r</code> where <code class="reqn">f(r)</code> falls below
<code>thresh</code> times <code class="reqn">k_0(r)</code>.
</p>
<p>If <code>precision=TRUE</code> the precision related to the chosen range is
returned as an attribute. Here the precision is defined as the polar
integral of the kernel from distance 0 to the calculated
range. Ideally this should be close to the value 1 which would be
obtained for the true theretical infinite range.
</p>


<h3>Value</h3>

<p>A positive numeric.
</p>
<p>Additionally, the precision related to this range value is returned as
an attribute <code>"prec"</code>, if <code>precision=TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+clusterkernel">clusterkernel</a></code>, <code><a href="spatstat.model.html#topic+kppm">kppm</a></code>,
<code><a href="#topic+rMatClust">rMatClust</a></code>, <code><a href="#topic+rThomas">rThomas</a></code>,
<code><a href="#topic+rCauchy">rCauchy</a></code>,
<code><a href="#topic+rVarGamma">rVarGamma</a></code>, <code><a href="#topic+rNeymanScott">rNeymanScott</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  clusterradius("Thomas", scale = .1)
  clusterradius("Thomas", scale = .1, thresh = 0.001)
  clusterradius("VarGamma", scale = .1, nu = 2, precision = TRUE)
</code></pre>

<hr>
<h2 id='default.expand'>Default Expansion Rule for Simulation of Model</h2><span id='topic+default.expand'></span>

<h3>Description</h3>

<p>Defines the default expansion window or expansion rule
for simulation of a point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  default.expand(object, m=2, epsilon=1e-6, w=Window(object))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="default.expand_+3A_object">object</code></td>
<td>

<p>A point process model (object of class <code>"ppm"</code>
or <code>"rmhmodel"</code>).
</p>
</td></tr>
<tr><td><code id="default.expand_+3A_m">m</code></td>
<td>

<p>A single numeric value.
The window will be expanded by a distance 
<code>m * reach(object)</code> along each side.
</p>
</td></tr>
<tr><td><code id="default.expand_+3A_epsilon">epsilon</code></td>
<td>

<p>Threshold argument passed to <code><a href="#topic+reach">reach</a></code> to determine
<code>reach(object)</code>.
</p>
</td></tr>
<tr><td><code id="default.expand_+3A_w">w</code></td>
<td>

<p>Optional. The un-expanded window in which the model is defined.
The resulting simulated point patterns will lie in this window. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a default value for the
expansion rule (the argument <code>expand</code> in <code><a href="#topic+rmhcontrol">rmhcontrol</a></code>)
given a fitted point process model <code>object</code>.
This default is used by
<code><a href="#topic+rmh">rmh</a></code>,
<code><a href="spatstat.model.html#topic+simulate.ppm">simulate.ppm</a></code>,
<code><a href="spatstat.explore.html#topic+envelope">envelope</a></code>, 
<code><a href="spatstat.model.html#topic+qqplot.ppm">qqplot.ppm</a></code>,
and other functions.
</p>
<p>Suppose we wish to generate simulated realisations
of a fitted point process model inside a window <code>w</code>.
It is advisable to first simulate
the pattern on a larger window, and then clip it to the original
window <code>w</code>. This avoids edge effects in the simulation.
It is called <em>expansion</em> of the simulation window.
</p>
<p>Accordingly, for the Metropolis-Hastings simulation algorithm
<code><a href="#topic+rmh">rmh</a></code>, the algorithm control parameters specified by
<code><a href="#topic+rmhcontrol">rmhcontrol</a></code> include an argument <code>expand</code> that
determines the expansion of the simulation window.
</p>
<p>The function <code>default.expand</code> determines the default expansion
rule for a fitted point process model <code>object</code>.
</p>
<p>If the model is Poisson, then no expansion is necessary.
No expansion is performed by default,
and <code>default.expand</code> returns a rule representing no expansion.
The simulation window is the original window <code>w = Window(object)</code>.
</p>
<p>If the model depends on external covariates (i.e.\ covariates other than
the Cartesian covariates <code>x</code> and <code>y</code> and the <code>marks</code>)
then no expansion is feasible, in general, because the spatial domain
of the covariates is not guaranteed to be large enough.
<code>default.expand</code> returns a rule representing no expansion.
The simulation window is the original window <code>w = Window(object)</code>.
</p>
<p>If the model depends on the Cartesian covariates <code>x</code> and <code>y</code>,
it would be feasible to expand the simulation window, and this was the
default for <span class="pkg">spatstat</span> version 1.24-1 and earlier.
However this sometimes produces artefacts (such as an empty point pattern)
or memory overflow, because the fitted trend, extrapolated outside the
original window of the data, may become very large.
In <span class="pkg">spatstat</span> version 1.24-2 and later, the
default rule is <em>not</em> to expand if the model depends
on <code>x</code> or <code>y</code>.
Again <code>default.expand</code> returns a rule representing no expansion.
</p>
<p>Otherwise, expansion will occur.
The original window <code>w = Window(object)</code> is expanded by
a distance <code>m * rr</code>, where
<code>rr</code> is the interaction range of the model, computed by
<code><a href="#topic+reach">reach</a></code>. If <code>w</code> is a rectangle then
each edge of <code>w</code> is displaced outward by distance <code>m * rr</code>.
If <code>w</code> is not a rectangle then <code>w</code> is dilated by
distance <code>m * rr</code> using <code><a href="spatstat.geom.html#topic+dilation">dilation</a></code>.
</p>


<h3>Value</h3>

<p>A window expansion rule (object of class <code>"rmhexpand"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmhexpand">rmhexpand</a></code>,
<code><a href="#topic+rmhcontrol">rmhcontrol</a></code>,
<code><a href="#topic+rmh">rmh</a></code>,
<code><a href="spatstat.explore.html#topic+envelope">envelope</a></code>,
<code><a href="spatstat.model.html#topic+qqplot.ppm">qqplot.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(spatstat.model)) {
  fit &lt;- ppm(cells ~1, Strauss(0.07))
  default.expand(fit)
}
  mod &lt;- rmhmodel(cif="strauss", par=list(beta=100, gamma=0.5, r=0.07))
  default.expand(mod)
</code></pre>

<hr>
<h2 id='default.rmhcontrol'>Set Default Control Parameters for Metropolis-Hastings Algorithm.</h2><span id='topic+default.rmhcontrol'></span>

<h3>Description</h3>

<p>For a Gibbs point process model (either a fitted model,
or a model specified by its parameters), this command
sets appropriate default values of the
parameters controlling the iterative behaviour
of the Metropolis-Hastings algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   default.rmhcontrol(model, w=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="default.rmhcontrol_+3A_model">model</code></td>
<td>

<p>A fitted point process model (object of class <code>"ppm"</code>)
or a description of a Gibbs point process model
(object of class <code>"rmhmodel"</code>).
</p>
</td></tr>
<tr><td><code id="default.rmhcontrol_+3A_w">w</code></td>
<td>

<p>Optional. Window for the resulting simulated patterns.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function sets the values of 
the parameters controlling the iterative behaviour
of the Metropolis-Hastings
simulation algorithm. It uses default values
that would be appropriate for the fitted point
process model <code>model</code>.
</p>
<p>The expansion parameter <code>expand</code> is set to
<code><a href="#topic+default.expand">default.expand</a>(model, w)</code>.
</p>
<p>All other parameters revert to their defaults given in
<code><a href="#topic+rmhcontrol.default">rmhcontrol.default</a></code>.
</p>
<p>See <code><a href="#topic+rmhcontrol">rmhcontrol</a></code> for the full list of control parameters.
To override default parameters, use <code><a href="#topic+update.rmhcontrol">update.rmhcontrol</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"rmhcontrol"</code>. See <code><a href="#topic+rmhcontrol">rmhcontrol</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmhcontrol">rmhcontrol</a></code>,
<code><a href="#topic+update.rmhcontrol">update.rmhcontrol</a></code>,
<code><a href="spatstat.model.html#topic+ppm">ppm</a></code>,
<code><a href="#topic+default.expand">default.expand</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(spatstat.model)) {
  fit &lt;- ppm(cells, ~1, Strauss(0.1))
  default.rmhcontrol(fit)
  default.rmhcontrol(fit, w=square(2))
}
   m &lt;- rmhmodel(cif='strauss',
                 par=list(beta=100, gamma=0.5, r=0.1),
                 w=unit.square())
  default.rmhcontrol(m)
  default.rmhcontrol(m, w=square(2))
</code></pre>

<hr>
<h2 id='dmixpois'>
Mixed Poisson Distribution
</h2><span id='topic+dmixpois'></span><span id='topic+pmixpois'></span><span id='topic+qmixpois'></span><span id='topic+rmixpois'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for a mixture of Poisson distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmixpois(x, mu, sd, invlink = exp, GHorder = 5)
pmixpois(q, mu, sd, invlink = exp, lower.tail = TRUE, GHorder = 5)
qmixpois(p, mu, sd, invlink = exp, lower.tail = TRUE, GHorder = 5)
rmixpois(n, mu, sd, invlink = exp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmixpois_+3A_x">x</code></td>
<td>
<p>vector of (non-negative integer) quantiles.</p>
</td></tr>
<tr><td><code id="dmixpois_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dmixpois_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="dmixpois_+3A_n">n</code></td>
<td>
<p>number of random values to return.</p>
</td></tr>
<tr><td><code id="dmixpois_+3A_mu">mu</code></td>
<td>

<p>Mean of the linear predictor. A single numeric value.
</p>
</td></tr>
<tr><td><code id="dmixpois_+3A_sd">sd</code></td>
<td>

<p>Standard deviation of the linear predictor. A single numeric value.
</p>
</td></tr>
<tr><td><code id="dmixpois_+3A_invlink">invlink</code></td>
<td>

<p>Inverse link function. A function in the <span class="rlang"><b>R</b></span> language,
used to transform the linear predictor into the
parameter <code>lambda</code> of the Poisson distribution.
</p>
</td></tr>
<tr><td><code id="dmixpois_+3A_lower.tail">lower.tail</code></td>
<td>

<p>Logical. If <code>TRUE</code> (the default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.
</p>
</td></tr>
<tr><td><code id="dmixpois_+3A_ghorder">GHorder</code></td>
<td>

<p>Number of quadrature points in the Gauss-Hermite quadrature approximation.
A small positive integer.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are analogous to
<code><a href="stats.html#topic+dpois">dpois</a></code>
<code><a href="stats.html#topic+ppois">ppois</a></code>,
<code><a href="stats.html#topic+qpois">qpois</a></code> and
<code><a href="stats.html#topic+rpois">rpois</a></code>
except that they apply to a mixture of Poisson distributions.
</p>
<p>In effect, the Poisson mean parameter <code>lambda</code> is randomised
by setting <code>lambda = invlink(Z)</code> where <code>Z</code>
has a Gaussian <code class="reqn">N(\mu,\sigma^2)</code> distribution.
The default is <code>invlink=exp</code> which means that
<code>lambda</code> is lognormal. Set <code>invlink=I</code> to assume
that <code>lambda</code> is approximately Normal.
</p>
<p>For <code>dmixpois</code>, <code>pmixpois</code> and <code>qmixpois</code>,
the probability distribution is approximated using Gauss-Hermite
quadrature. For <code>rmixpois</code>, the deviates are simulated
exactly.
</p>


<h3>Value</h3>

<p>Numeric vector:
<code>dmixpois</code> gives probability masses,
<code>ppois</code> gives cumulative probabilities,
<code>qpois</code> gives (non-negative integer) quantiles, and
<code>rpois</code> generates (non-negative integer) random deviates.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>,
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dpois">dpois</a></code>,
<code><a href="#topic+gauss.hermite">gauss.hermite</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  dmixpois(7, 10, 1, invlink = I)
  dpois(7, 10)

  pmixpois(7, log(10), 0.2)
  ppois(7, 10)

  qmixpois(0.95, log(10), 0.2)
  qpois(0.95, 10)

  x &lt;- rmixpois(100, log(10), log(1.2))
  mean(x)
  var(x)
</code></pre>

<hr>
<h2 id='domain.rmhmodel'>
Extract the Domain of any Spatial Object
</h2><span id='topic+domain.rmhmodel'></span>

<h3>Description</h3>

<p>Given a spatial object such as a point pattern, in any number of dimensions,
this function extracts the spatial domain in which the object is defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>



 ## S3 method for class 'rmhmodel'
domain(X, ...)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="domain.rmhmodel_+3A_x">X</code></td>
<td>

<p>A spatial object such as a point pattern (in any number
of dimensions), line segment pattern or pixel image.
</p>
</td></tr>
<tr><td><code id="domain.rmhmodel_+3A_...">...</code></td>
<td>

<p>Extra arguments. They are ignored by all the methods listed here.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="spatstat.geom.html#topic+domain">domain</a></code> is generic.
</p>
<p>For a spatial object <code>X</code> in any number of dimensions, 
<code>domain(X)</code> extracts the spatial domain in which <code>X</code> is
defined.
</p>
<p>For a two-dimensional object <code>X</code>, typically <code>domain(X)</code>
is the same as <code>Window(X)</code>.
</p>
<p>Exceptions occur for methods related to linear networks.
</p>


<h3>Value</h3>

<p>A spatial object representing the domain of <code>X</code>.
Typically a window (object of class <code>"owin"</code>),
a three-dimensional box (<code>"box3"</code>), a multidimensional
box (<code>"boxx"</code>) or a linear network (<code>"linnet"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+domain">domain</a></code>,
<code><a href="spatstat.geom.html#topic+domain.quadratcount">domain.quadratcount</a></code>,
<code><a href="spatstat.model.html#topic+domain.ppm">domain.ppm</a></code>,
<code><a href="spatstat.explore.html#topic+domain.quadrattest">domain.quadrattest</a></code>,
<code><a href="spatstat.linnet.html#topic+domain.lpp">domain.lpp</a></code>.
<code>Window</code>,
<code>Frame</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  domain(rmhmodel(cif='poisson', par=list(beta=1), w=square(2)))
</code></pre>

<hr>
<h2 id='dpakes'>
Pakes distribution
</h2><span id='topic+dpakes'></span><span id='topic+ppakes'></span><span id='topic+qpakes'></span><span id='topic+rpakes'></span>

<h3>Description</h3>

<p>Probability density, cumulative distribution function,
quantile function, and random generation for the Pakes
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpakes(x, zeta)
ppakes(q, zeta)
qpakes(p, zeta)
rpakes(n, zeta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dpakes_+3A_x">x</code>, <code id="dpakes_+3A_q">q</code></td>
<td>

<p>Numeric vector of quantiles.
</p>
</td></tr>
<tr><td><code id="dpakes_+3A_p">p</code></td>
<td>
<p>Numeric vector of probabilities</p>
</td></tr>
<tr><td><code id="dpakes_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="dpakes_+3A_zeta">zeta</code></td>
<td>

<p>Mean of distribution. A single, non-negative, numeric value.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions concern the probability distribution of the random
variable
</p>
<p style="text-align: center;"><code class="reqn">
    X = \sum_{n=1}^\infty \prod_{j=1}^n U_j^{1/\zeta}
  </code>
</p>

<p>where <code class="reqn">U_1, U_2, \ldots</code> are independent
random variables uniformly distributed on <code class="reqn">[0,1]</code>
and <code class="reqn">\zeta</code> is a parameter.
</p>
<p>This distribution arises in many contexts. For example, 
for a homogeneous Poisson point process in two-dimensional space
with intensity <code class="reqn">\lambda</code>,
the standard Gaussian kernel estimator of intensity
with bandwidth <code class="reqn">\sigma</code>, evaluated at any fixed location <code class="reqn">u</code>,
has the same distribution as <code class="reqn">(\lambda/\zeta) X</code>
where
<code class="reqn">\zeta = 2 \pi \lambda\sigma^2</code>.
</p>
<p>Following the usual convention,
<code>dpakes</code> computes the probability density,
<code>ppakes</code> the cumulative distribution function,
and <code>qpakes</code> the quantile function,
and <code>rpakes</code> generates random variates with this distribution.
</p>
<p>The computation is based on a recursive integral equation
for the cumulative distribution function, due to Professor Tony Pakes,
presented in Baddeley, Moller and Pakes (2008).
The solution uses the fact that the random variable
satisfies the distributional equivalence
</p>
<p style="text-align: center;"><code class="reqn">
    X \equiv U^{1/\zeta} (1 + X)
  </code>
</p>

<p>where <code class="reqn">U</code> is uniformly distributed on <code class="reqn">[0,1]</code> and independent
of <code class="reqn">X</code>.
</p>


<h3>Value</h3>

<p>A numeric vector. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley.
</p>


<h3>References</h3>

<p>Baddeley, A.,  Moller, J. and Pakes, A.G. (2008)
Properties of residuals for spatial point processes,
<em>Annals of the Institute of Statistical Mathematics</em>
<b>60</b>, 627&ndash;649.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> curve(dpakes(x, 1.5), to=4)
 rpakes(3, 1.5)
</code></pre>

<hr>
<h2 id='expand.owin'>Apply Expansion Rule</h2><span id='topic+expand.owin'></span>

<h3>Description</h3>

<p>Applies an expansion rule to a window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> expand.owin(W, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand.owin_+3A_w">W</code></td>
<td>
<p>A window.</p>
</td></tr>
<tr><td><code id="expand.owin_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+rmhexpand">rmhexpand</a></code> to
determine an expansion rule.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>W</code> should be a window (an object of class
<code>"owin"</code>).
</p>
<p>This command applies the expansion rule specified by the
arguments <code>...</code> to the window <code>W</code>, yielding another
window.
</p>
<p>The arguments <code>...</code> are passed to <code><a href="#topic+rmhexpand">rmhexpand</a></code>
to determine the expansion rule.
</p>
<p>For other transformations of the scale, location and orientation
of a window, see <code><a href="data.table.html#topic+shift">shift</a></code>, <code>affine</code>
and <code><a href="ape.html#topic+rotate">rotate</a></code>.
</p>


<h3>Value</h3>

<p>A window (object of class <code>"owin"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmhexpand">rmhexpand</a></code> about expansion rules.
</p>
<p><code><a href="data.table.html#topic+shift">shift</a></code>,
<code><a href="ape.html#topic+rotate">rotate</a></code>,
<code>affine</code> for other types of manipulation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   expand.owin(square(1), 9)
   expand.owin(square(1), distance=0.5)
   expand.owin(letterR, length=2)
   expand.owin(letterR, distance=0.1)
</code></pre>

<hr>
<h2 id='gauss.hermite'>
Gauss-Hermite Quadrature Approximation to Expectation for Normal Distribution
</h2><span id='topic+gauss.hermite'></span>

<h3>Description</h3>

<p>Calculates an approximation to the expected value of any function of a
normally-distributed random variable, using Gauss-Hermite quadrature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gauss.hermite(f, mu = 0, sd = 1, ..., order = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gauss.hermite_+3A_f">f</code></td>
<td>

<p>The function whose moment should be approximated.
</p>
</td></tr>
<tr><td><code id="gauss.hermite_+3A_mu">mu</code></td>
<td>

<p>Mean of the normal distribution.
</p>
</td></tr>
<tr><td><code id="gauss.hermite_+3A_sd">sd</code></td>
<td>

<p>Standard deviation of the normal distribution.
</p>
</td></tr>
<tr><td><code id="gauss.hermite_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code>f</code>.
</p>
</td></tr>
<tr><td><code id="gauss.hermite_+3A_order">order</code></td>
<td>

<p>Number of quadrature points in the Gauss-Hermite quadrature
approximation. A small positive integer.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm calculates the approximate expected value of
<code>f(Z)</code> when <code>Z</code> is a normally-distributed random
variable with mean <code>mu</code> and standard deviation <code>sd</code>.
The expected value is an integral with respect to the
Gaussian density; this integral is approximated
using Gauss-Hermite quadrature.
</p>
<p>The argument <code>f</code> should be a function in the <span class="rlang"><b>R</b></span> language
whose first argument is the variable <code>Z</code>. Additional arguments
may be passed through <code>...</code>. The value returned by <code>f</code>
may be a single numeric value, a vector, or a matrix. The values
returned by <code>f</code> for different values of <code>Z</code> must have
compatible dimensions.
</p>
<p>The result is a weighted average of several values of <code>f</code>.
</p>


<h3>Value</h3>

<p>Numeric value, vector or matrix.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>,
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  gauss.hermite(function(x) x^2, 3, 1)
</code></pre>

<hr>
<h2 id='indefinteg'>
Indefinite Integral
</h2><span id='topic+indefinteg'></span>

<h3>Description</h3>

<p>Computes the indefinite integral of the given function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  indefinteg(f, x, ...,
             method=c("trapezoid", "quadrature"),
             lower=min(x), nfine=8192) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indefinteg_+3A_f">f</code></td>
<td>

<p>an <span class="rlang"><b>R</b></span> function taking a numeric first argument and returning a
numeric vector of the same length.
</p>
</td></tr>
<tr><td><code id="indefinteg_+3A_x">x</code></td>
<td>

<p>Vector of values of the argument for which the indefinite integral
should be evaluated. 
</p>
</td></tr>
<tr><td><code id="indefinteg_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed to <code>f</code>.
</p>
</td></tr>
<tr><td><code id="indefinteg_+3A_method">method</code></td>
<td>

<p>String (partially matched) specifying how to compute the integrals.
</p>
</td></tr>
<tr><td><code id="indefinteg_+3A_lower">lower</code></td>
<td>

<p>Lower limit of integration. A single number.
</p>
</td></tr>
<tr><td><code id="indefinteg_+3A_nfine">nfine</code></td>
<td>

<p>Number of sub-intervals to use for computation
if <code>method='trapezoid'</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The indefinite integral of the given function <code>f</code>
is computed numerically at each of the desired values <code>x</code>.
The lower limit of integration is taken to be <code>min(x)</code>.
</p>
<p>The result is a numeric vector <code>y</code> of the same length as
<code>x</code>, with entries
</p>
<p style="text-align: center;"><code class="reqn">
    y_i = \int_{\mbox{lower}}^{x_i} f(t) dt
  </code>
</p>

<p>If <code>method='trapezoid'</code> (the default),
the integrals are computed rapidly using the trapezoid rule.
If <code>method='quadrature'</code> the integrals are computed
accurately but much more slowly, using the numerical quadrature routine
<code><a href="stats.html#topic+integrate">integrate</a></code>.
</p>
<p>If <code>method='trapezoid'</code> 
the function <code>f</code> is first evaluated 
on a finer grid of values of the function argument.
The fine grid contains <code>nfine</code> sample points.
The values of the indefinite integral on the fine grid
are computed using the trapezoidal approximation.
Finally the values of the indefinite integral are extracted at
the desired argument values <code>x</code>.
</p>


<h3>Value</h3>

<p>Numeric vector of the same length as <code>x</code>. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+integrate">integrate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  curve(indefinteg(sin, x), to=pi)
</code></pre>

<hr>
<h2 id='is.stationary'>
Recognise Stationary and Poisson Point Process Models
</h2><span id='topic+is.stationary'></span><span id='topic+is.stationary.rmhmodel'></span><span id='topic+is.poisson'></span><span id='topic+is.poisson.rmhmodel'></span>

<h3>Description</h3>

<p>Given a point process model (either a model that has been fitted to
data, or a model specified by its parameters), 
determine whether the model is a stationary point process,
and whether it is a Poisson point process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.stationary(x)
## S3 method for class 'rmhmodel'
is.stationary(x)

is.poisson(x)
## S3 method for class 'rmhmodel'
is.poisson(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.stationary_+3A_x">x</code></td>
<td>

<p>A fitted spatial point process model
(object of class <code>"ppm"</code>, <code>"kppm"</code>,
<code>"lppm"</code>, <code>"dppm"</code> or <code>"slrm"</code>)
or a specification of a Gibbs point process model
(object of class <code>"rmhmodel"</code>)
or a similar object.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>x</code> represents a fitted spatial point process model
or a similar object.
</p>
<p><code>is.stationary(x)</code> returns <code>TRUE</code> if <code>x</code> represents
a stationary point process, and <code>FALSE</code> if not.
</p>
<p><code>is.poisson(x)</code> returns <code>TRUE</code> if <code>x</code> represents
a Poisson point process, and <code>FALSE</code> if not.
</p>
<p>The functions <code>is.stationary</code> and <code>is.poisson</code> are generic,
with methods for the classes <code>"ppm"</code> (Gibbs point process models),
<code>"kppm"</code> (cluster or Cox point process models),
<code>"slrm"</code> (spatial logistic regression models) and
<code>"rmhmodel"</code> (model specifications for the
Metropolis-Hastings algorithm).
Additionally <code>is.stationary</code> has a method for
classes <code>"detpointprocfamily"</code> and <code>"dppm"</code>
(both determinantal point processes) and
<code>is.poisson</code> has a method for 
class <code>"interact"</code> (interaction structures for Gibbs models). 
</p>
<p><code>is.poisson.kppm</code> will return <code>FALSE</code>, unless
the model <code>x</code> is degenerate:
either <code>x</code> has zero intensity so that its realisations are empty
with probability 1, or it is a log-Gaussian Cox process
where the log intensity has zero variance.
</p>
<p><code>is.poisson.slrm</code> will always return <code>TRUE</code>,
by convention.
</p>


<h3>Value</h3>

<p>A logical value.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code>is.marked</code> to determine whether a model is a marked
point process. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  m &lt;- rmhmodel(cif='strauss', par=list(beta=10, gamma=0.1, r=1))
  is.stationary(m)
  is.poisson(m)
  is.poisson(rmhmodel(cif='strauss', par=list(beta=10, gamma=1, r=1)))
</code></pre>

<hr>
<h2 id='quadratresample'>Resample a Point Pattern by Resampling Quadrats</h2><span id='topic+quadratresample'></span>

<h3>Description</h3>

<p>Given a point pattern dataset, create a resampled point pattern
by dividing the window into rectangular quadrats and randomly
resampling the list of quadrats. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadratresample(X, nx, ny=nx, ...,
                replace = FALSE, nsamples = 1,
                verbose = (nsamples &gt; 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quadratresample_+3A_x">X</code></td>
<td>

<p>A point pattern dataset (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="quadratresample_+3A_nx">nx</code>, <code id="quadratresample_+3A_ny">ny</code></td>
<td>

<p>Numbers of quadrats in the <code class="reqn">x</code> and <code class="reqn">y</code> directions.
</p>
</td></tr>
<tr><td><code id="quadratresample_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="quadratresample_+3A_replace">replace</code></td>
<td>

<p>Logical value. Specifies whether quadrats should be sampled
with or without replacement.
</p>
</td></tr>
<tr><td><code id="quadratresample_+3A_nsamples">nsamples</code></td>
<td>
<p>Number of randomised point patterns to be generated.</p>
</td></tr>
<tr><td><code id="quadratresample_+3A_verbose">verbose</code></td>
<td>
<p>Logical value indicating whether to print progress reports.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command implements a very simple bootstrap resampling procedure
for spatial point patterns <code>X</code>.
</p>
<p>The dataset <code>X</code> must be a point pattern (object of class
<code>"ppp"</code>) and its observation window must be a rectangle.
</p>
<p>The window is first divided into <code>N = nx * ny</code> rectangular tiles
(quadrats) of equal size and shape. 
To generate one resampled point pattern, a random sample of
<code>N</code> quadrats is selected from the list of <code>N</code> quadrats,
with replacement (if <code>replace=TRUE</code>) or without replacement
(if <code>replace=FALSE</code>). The <code class="reqn">i</code>th quadrat in the original
dataset is then replaced by the <code class="reqn">i</code>th sampled quadrat, after the
latter is shifted so that it
occupies the correct spatial position. The quadrats are then
reconstituted into a point pattern inside the same window as <code>X</code>.
</p>
<p>If <code>replace=FALSE</code>, this procedure effectively involves a random
permutation of the quadrats. The resulting resampled point pattern has
the same number of points as <code>X</code>.
If <code>replace=TRUE</code>, the number of points in the resampled point
pattern is random.
</p>


<h3>Value</h3>

<p>A point pattern (if <code>nsamples = 1</code>) or a 
list of point patterns (if <code>nsamples &gt; 1</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+quadrats">quadrats</a></code>,
<code><a href="spatstat.geom.html#topic+quadratcount">quadratcount</a></code>.
</p>
<p>See <code><a href="spatstat.explore.html#topic+varblock">varblock</a></code> to estimate the variance of
a summary statistic by block resampling.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  quadratresample(bei, 6, 3)
</code></pre>

<hr>
<h2 id='rags'>
Alternating Gibbs Sampler for Multitype Point Processes
</h2><span id='topic+rags'></span>

<h3>Description</h3>

<p>Simulate a realisation of a point process model using the
alternating Gibbs sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rags(model, ..., ncycles = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rags_+3A_model">model</code></td>
<td>

<p>Data specifying some kind of point process model.
</p>
</td></tr>
<tr><td><code id="rags_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to other code.
</p>
</td></tr>
<tr><td><code id="rags_+3A_ncycles">ncycles</code></td>
<td>

<p>Number of cycles of the alternating Gibbs sampler that should be
performed. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Alternating Gibbs Sampler for a multitype point process
is an iterative simulation procedure. Each step of the sampler
updates the pattern of points of a particular type <code>i</code>,
by drawing a realisation from the conditional distribution of
points of type <code>i</code> given the points of all other types.
Successive steps of the sampler update the points of type 1, then
type 2, type 3, and so on. 
</p>
<p>This is an experimental implementation which currently works only
for multitype hard core processes (see <code><a href="spatstat.model.html#topic+MultiHard">MultiHard</a></code>)
in which there is no interaction between points of the same type. 
</p>
<p>The argument <code>model</code> should be an object describing a point
process model. At the moment, the only permitted format for
<code>model</code> is of the form <code>list(beta, hradii)</code> where
<code>beta</code> gives the first order trend and <code>hradii</code> is the
matrix of interaction radii. See <code><a href="#topic+ragsMultiHard">ragsMultiHard</a></code> for
full details.
</p>


<h3>Value</h3>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ragsMultiHard">ragsMultiHard</a></code>,
<code><a href="#topic+ragsAreaInter">ragsAreaInter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  mo &lt;- list(beta=c(30, 20),
             hradii = 0.05 * matrix(c(0,1,1,0), 2, 2))
  rags(mo, ncycles=10)
</code></pre>

<hr>
<h2 id='ragsAreaInter'>
Alternating Gibbs Sampler for Area-Interaction Process
</h2><span id='topic+ragsAreaInter'></span>

<h3>Description</h3>

<p>Generate a realisation of the area-interaction process
using the alternating Gibbs sampler.
Applies only when the interaction parameter <code class="reqn">eta</code> is greater than 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>     ragsAreaInter(beta, eta, r, ...,
                   win = NULL, bmax = NULL, periodic = FALSE, ncycles = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ragsAreaInter_+3A_beta">beta</code></td>
<td>

<p>First order trend. A number, a pixel image (object of class
<code>"im"</code>), or a <code>function(x,y)</code>.
</p>
</td></tr>
<tr><td><code id="ragsAreaInter_+3A_eta">eta</code></td>
<td>

<p>Interaction parameter (canonical form) as described in
the help for <code><a href="spatstat.model.html#topic+AreaInter">AreaInter</a></code>.
A number greater than 1.
</p>
</td></tr>
<tr><td><code id="ragsAreaInter_+3A_r">r</code></td>
<td>

<p>Disc radius in the model. A number greater than 1.
</p>
</td></tr>
<tr><td><code id="ragsAreaInter_+3A_...">...</code></td>
<td>

<p>Additional arguments for <code>beta</code> if it is a function.
</p>
</td></tr>
<tr><td><code id="ragsAreaInter_+3A_win">win</code></td>
<td>

<p>Simulation window. An object of class <code>"owin"</code>.
(Ignored if <code>beta</code> is a pixel image.)
</p>
</td></tr>
<tr><td><code id="ragsAreaInter_+3A_bmax">bmax</code></td>
<td>

<p>Optional. The maximum possible value of <code>beta</code>,
or a number larger than this. 
</p>
</td></tr>
<tr><td><code id="ragsAreaInter_+3A_periodic">periodic</code></td>
<td>

<p>Logical value indicating whether to treat opposite sides of the
simulation window as being the same, so that points close to one
side may interact with points close to the opposite side.
Feasible only when the window is a rectangle.
</p>
</td></tr>
<tr><td><code id="ragsAreaInter_+3A_ncycles">ncycles</code></td>
<td>

<p>Number of cycles of the alternating Gibbs sampler to be performed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a simulated realisation of the
area-interaction process (see <code><a href="spatstat.model.html#topic+AreaInter">AreaInter</a></code>)
using the alternating Gibbs sampler (see <code><a href="#topic+rags">rags</a></code>).
</p>
<p>It exploits a mathematical relationship between the
(unmarked) area-interaction process and the two-type
hard core process (Baddeley and Van Lieshout, 1995;
Widom and Rowlinson, 1970). This relationship only holds
when the interaction parameter <code>eta</code> is greater than 1
so that the area-interaction process is clustered.
</p>
<p>The parameters <code>beta,eta</code> are the canonical parameters described
in the help for <code><a href="spatstat.model.html#topic+AreaInter">AreaInter</a></code>.
The first order trend <code>beta</code> may be a constant, a function,
or a pixel image.
</p>
<p>The simulation window is determined by <code>beta</code> if it is a pixel
image, and otherwise by the argument <code>win</code> (the default is the
unit square).
</p>


<h3>Value</h3>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A.J. and Van Lieshout, M.N.M. (1995).
Area-interaction point processes.
<em>Annals of the Institute of Statistical Mathematics</em>
<b>47</b> (1995) 601&ndash;619.
</p>
<p>Widom, B. and Rowlinson, J.S. (1970).
New model for the study of liquid-vapor phase transitions.
<em>The Journal of Chemical Physics</em>
<b>52</b> (1970) 1670&ndash;1684.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rags">rags</a></code>,
<code><a href="#topic+ragsMultiHard">ragsMultiHard</a></code>
</p>
<p><code><a href="spatstat.model.html#topic+AreaInter">AreaInter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   plot(ragsAreaInter(100, 2, 0.07, ncycles=15))
</code></pre>

<hr>
<h2 id='ragsMultiHard'>
Alternating Gibbs Sampler for Multitype Hard Core Process
</h2><span id='topic+ragsMultiHard'></span>

<h3>Description</h3>

<p>Generate a realisation of the multitype hard core point process
using the alternating Gibbs sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ragsMultiHard(beta, hradii, ..., types=NULL, bmax = NULL,
              periodic=FALSE, ncycles = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ragsMultiHard_+3A_beta">beta</code></td>
<td>

<p>First order trend. A numeric vector, a pixel image,
a function, a list of functions, or a list of pixel images.
</p>
</td></tr>
<tr><td><code id="ragsMultiHard_+3A_hradii">hradii</code></td>
<td>

<p>Matrix of hard core radii between each pair of types.
Diagonal entries should be <code>0</code> or <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="ragsMultiHard_+3A_types">types</code></td>
<td>

<p>Vector of all possible types for the multitype point pattern.
</p>
</td></tr>
<tr><td><code id="ragsMultiHard_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+rmpoispp">rmpoispp</a></code>
when generating random points. 
</p>
</td></tr>
<tr><td><code id="ragsMultiHard_+3A_bmax">bmax</code></td>
<td>

<p>Optional upper bound on <code>beta</code>.
</p>
</td></tr>
<tr><td><code id="ragsMultiHard_+3A_periodic">periodic</code></td>
<td>

<p>Logical value indicating whether to measure distances in the
periodic sense, so that opposite sides of the (rectangular) window
are treated as identical.
</p>
</td></tr>
<tr><td><code id="ragsMultiHard_+3A_ncycles">ncycles</code></td>
<td>

<p>Number of cycles of the sampler to be performed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Alternating Gibbs Sampler for a multitype point process
is an iterative simulation procedure. Each step of the sampler
updates the pattern of points of a particular type <code>i</code>,
by drawing a realisation from the conditional distribution of
points of type <code>i</code> given the points of all other types.
Successive steps of the sampler update the points of type 1, then
type 2, type 3, and so on. 
</p>
<p>This is an experimental implementation which currently works only
for multitype hard core processes (see <code><a href="spatstat.model.html#topic+MultiHard">MultiHard</a></code>)
in which there is no interaction between points of the same type,
and for the area-interaction process (see <code><a href="#topic+ragsAreaInter">ragsAreaInter</a></code>).
</p>
<p>The argument <code>beta</code> gives the first order trend for
each possible type of point. It may be a single number, a numeric
vector, a <code>function(x,y)</code>, a pixel image, a list of functions,
a <code>function(x,y,m)</code>, or a list of pixel images. 
</p>
<p>The argument <code>hradii</code> is the matrix of hard core radii
between each pair of possible types of points. Two points of types
<code>i</code> and <code>j</code> respectively are forbidden to lie closer than
a distance <code>hradii[i,j]</code> apart. The diagonal of this matrix must
contain <code>NA</code> or <code>0</code> values, indicating that there is no hard
core constraint applying between points of the same type.
</p>


<h3>Value</h3>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rags">rags</a></code>,
<code><a href="#topic+ragsAreaInter">ragsAreaInter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  b &lt;- c(30,20)
  h &lt;- 0.05 * matrix(c(0,1,1,0), 2, 2)
  ragsMultiHard(b, h, ncycles=10)
  ragsMultiHard(b, h, ncycles=5, periodic=TRUE)
</code></pre>

<hr>
<h2 id='rCauchy'>Simulate Neyman-Scott Point Process with Cauchy cluster kernel</h2><span id='topic+rCauchy'></span>

<h3>Description</h3>

<p>Generate a random point pattern, a simulated realisation of the
Neyman-Scott process with Cauchy cluster kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> rCauchy(kappa, scale, mu, win = square(1),
            nsim=1, drop=TRUE,
            ...,
            algorithm=c("BKBC", "naive"),
            nonempty=TRUE, 
            thresh = 0.001, poisthresh=1e-6,
            expand = NULL,
            saveparents=FALSE, saveLambda=FALSE,
            kappamax=NULL, mumax=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rCauchy_+3A_kappa">kappa</code></td>
<td>

<p>Intensity of the Poisson process of cluster centres.
A single positive number, a function, or a pixel image.
</p>
</td></tr>
<tr><td><code id="rCauchy_+3A_scale">scale</code></td>
<td>

<p>Scale parameter for cluster kernel. Determines the size of clusters.
A single positive number, in the same units as the spatial coordinates.
</p>
</td></tr>
<tr><td><code id="rCauchy_+3A_mu">mu</code></td>
<td>

<p>Mean number of points per cluster (a single positive number)
or reference intensity for the cluster points (a function or
a pixel image).
</p>
</td></tr>
<tr><td><code id="rCauchy_+3A_win">win</code></td>
<td>

<p>Window in which to simulate the pattern.
An object of class <code>"owin"</code>
or something acceptable to <code><a href="spatstat.geom.html#topic+as.owin">as.owin</a></code>.
</p>
</td></tr>
<tr><td><code id="rCauchy_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rCauchy_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
<tr><td><code id="rCauchy_+3A_...">...</code></td>
<td>

<p>Passed to <code><a href="#topic+clusterfield">clusterfield</a></code> to control the image
resolution when <code>saveLambda=TRUE</code>, and to 
<code><a href="#topic+clusterradius">clusterradius</a></code> when
<code>expand</code> is missing or <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="rCauchy_+3A_algorithm">algorithm</code></td>
<td>

<p>String (partially matched) specifying the simulation algorithm.
See Details.
</p>
</td></tr>
<tr><td><code id="rCauchy_+3A_nonempty">nonempty</code></td>
<td>

<p>Logical. If <code>TRUE</code> (the default), a more efficient algorithm is
used, in which parents are generated conditionally on having at
least one offspring point. If <code>FALSE</code>, parents are generated
even if they have no offspring. Both choices are valid; the default
is recommended unless you need to simulate all the parent points
for some other purpose.
</p>
</td></tr>
<tr><td><code id="rCauchy_+3A_thresh">thresh</code></td>
<td>

<p>Threshold relative to the cluster kernel value at the origin (parent
location) determining when the cluster kernel will be treated as
zero for simulation purposes. Will be overridden by argument
<code>expand</code> if that is given.
</p>
</td></tr>
<tr><td><code id="rCauchy_+3A_poisthresh">poisthresh</code></td>
<td>

<p>Numerical threshold below which the model will be treated
as a Poisson process. See Details.
</p>
</td></tr>
<tr><td><code id="rCauchy_+3A_expand">expand</code></td>
<td>

<p>Window expansion distance. A single number.
The distance by which the original window will be expanded
in order to generate parent points.
Has a sensible default, determined by calling
<code><a href="#topic+clusterradius">clusterradius</a></code>
with the numeric threshold value given
in <code>thresh</code>.
</p>
</td></tr>
<tr><td><code id="rCauchy_+3A_saveparents">saveparents</code></td>
<td>

<p>Logical value indicating whether to save the locations of the
parent points as an attribute.
</p>
</td></tr>
<tr><td><code id="rCauchy_+3A_savelambda">saveLambda</code></td>
<td>

<p>Logical. If <code>TRUE</code> then the random intensity corresponding to
the simulated parent points will also be calculated and saved,
and returns as an attribute of the point pattern.
</p>
</td></tr>
<tr><td><code id="rCauchy_+3A_kappamax">kappamax</code></td>
<td>

<p>Optional. Numerical value which is an upper bound for the
values of <code>kappa</code>, when <code>kappa</code> is a pixel image or a
function.
</p>
</td></tr>
<tr><td><code id="rCauchy_+3A_mumax">mumax</code></td>
<td>

<p>Optional. Numerical value which is an upper bound for the
values of <code>mu</code>, when <code>mu</code> is a pixel image or a
function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm generates a realisation of the Neyman-Scott process
with Cauchy cluster kernel, inside the window <code>win</code>.
</p>
<p>The process is constructed by first
generating a Poisson point process of &ldquo;parent&rdquo; points 
with intensity <code>kappa</code>. Then each parent point is
replaced by a random cluster of points, the number of points in each
cluster being random with a Poisson (<code>mu</code>) distribution,
and the points being placed independently and uniformly
according to a Cauchy kernel.
</p>
<p>Note that, for correct simulation of the model,
the parent points are not restricted to lie inside the 
window <code>win</code>;
the parent process is effectively the uniform Poisson process
on the infinite plane.
</p>
<p>The algorithm can also generate spatially inhomogeneous versions of
the cluster process:
</p>

<ul>
<li><p> The parent points can be spatially inhomogeneous.
If the argument <code>kappa</code> is a <code>function(x,y)</code>
or a pixel image (object of class <code>"im"</code>), then it is taken
as specifying the intensity function of an inhomogeneous Poisson
process that generates the parent points.
</p>
</li>
<li><p> The offspring points can be inhomogeneous. If the
argument <code>mu</code> is a <code>function(x,y)</code>
or a pixel image (object of class <code>"im"</code>), then it is
interpreted as the reference density for offspring points,
in the sense of Waagepetersen (2006).
</p>
</li></ul>

<p>When the parents are homogeneous (<code>kappa</code> is a single number)
and the offspring are inhomogeneous (<code>mu</code> is a
function or pixel image), the model can be fitted to data
using <code><a href="spatstat.model.html#topic+kppm">kppm</a></code>.  
</p>
<p>If the pair correlation function of the model is very close
to that of a Poisson process, deviating by less than
<code>poisthresh</code>, then the model is approximately a Poisson process,
and will be simulated as a Poisson process with intensity
<code>kappa * mu</code>, using <code><a href="#topic+rpoispp">rpoispp</a></code>. 
This avoids computations that would otherwise require huge amounts
of memory.
</p>


<h3>Value</h3>

<p>A point pattern (an object of class <code>"ppp"</code>) if <code>nsim=1</code>,
or a list of point patterns if <code>nsim &gt; 1</code>.
</p>
<p>Additionally, some intermediate results of the simulation are returned
as attributes of this point pattern (see
<code><a href="#topic+rNeymanScott">rNeymanScott</a></code>).
Furthermore, the simulated intensity
function is returned as an attribute <code>"Lambda"</code>, if
<code>saveLambda=TRUE</code>.
</p>


<h3>Simulation Algorithm</h3>

<p>Two simulation algorithms are implemented.
</p>

<ul>
<li><p> The <em>naive</em> algorithm generates the cluster process 
by directly following the description given above. First the window
<code>win</code> is expanded by a distance equal to <code>expand</code>.
Then the parent points are generated in the expanded window according to
a Poisson process with intensity <code>kappa</code>. Then each parent
point is replaced by a finite cluster of offspring points as
described above.
The naive algorithm is used if <code>algorithm="naive"</code> or if
<code>nonempty=FALSE</code>.
</p>
</li>
<li><p> The <em>BKBC</em> algorithm, proposed by Baddeley and Chang
(2023), is a modification of the algorithm of Brix and Kendall (2002). 
Parents are generated in the infinite plane, subject to the
condition that they have at least one offspring point inside the
window <code>win</code>.
The BKBC algorithm is used when <code>algorithm="BKBC"</code> (the default)
and <code>nonempty=TRUE</code> (the default).
</p>
</li></ul>

<p>The naive algorithm becomes very slow when <code>scale</code> is large,
while the BKBC algorithm is uniformly fast (Baddeley and Chang, 2023).
</p>
<p>If <code>saveparents=TRUE</code>, then the simulated point pattern will
have an attribute <code>"parents"</code> containing the coordinates of the
parent points, and an attribute <code>"parentid"</code> mapping each
offspring point to its parent.
</p>
<p>If <code>nonempty=TRUE</code> (the default), then parents are generated
subject to the condition that they have at least one offspring point 
in the window <code>win</code>. 
<code>nonempty=FALSE</code>, then parents without offspring will be included;
this option is not available in the <em>BKBC</em> algorithm.
</p>
<p>Note that if <code>kappa</code> is a pixel image, its domain must be larger
than the window <code>win</code>. This is because an offspring point inside
<code>win</code> could have its parent point lying outside <code>win</code>.
In order to allow this, the naive simulation algorithm
first expands the original window <code>win</code>
by a distance equal to <code>expand</code> and generates the Poisson process of
parent points on this larger window. If <code>kappa</code> is a pixel image,
its domain must contain this larger window.
</p>
<p>If the pair correlation function of the model is very close
to that of a Poisson process, with maximum deviation less than
<code>poisthresh</code>, then the model is approximately a Poisson process.
This is detected by the naive algorithm which then
simulates a Poisson process with intensity
<code>kappa * mu</code>, using <code><a href="#topic+rpoispp">rpoispp</a></code>. 
This avoids computations that would otherwise require huge amounts
of memory.
</p>


<h3>Fitting cluster models to data</h3>

<p>The Cauchy cluster model with homogeneous parents
(i.e. where <code>kappa</code> is a single number)
where the offspring are either homogeneous or inhomogeneous (<code>mu</code>
is a single number, a function or pixel image)
can be fitted to point pattern data using <code><a href="spatstat.model.html#topic+kppm">kppm</a></code>,
or fitted to the inhomogeneous <code class="reqn">K</code> function
using <code><a href="spatstat.model.html#topic+cauchy.estK">cauchy.estK</a></code>
or <code><a href="spatstat.model.html#topic+cauchy.estpcf">cauchy.estpcf</a></code>.
</p>
<p>Currently <span class="pkg">spatstat</span> does not support fitting the
Cauchy cluster process model
with inhomogeneous parents.
</p>
<p>A Cauchy cluster process model fitted by <code><a href="spatstat.model.html#topic+kppm">kppm</a></code>
can be simulated automatically using <code><a href="spatstat.model.html#topic+simulate.kppm">simulate.kppm</a></code>
(which invokes <code>rCauchy</code> to perform the simulation).
</p>


<h3>Author(s)</h3>

<p>Original algorithm by Abdollah Jalilian and Rasmus Waagepetersen.
Adapted for <span class="pkg">spatstat</span> by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
Brix-Kendall-Baddeley-Chang algorithm implemented by
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> and Ya-Mei Chang <a href="mailto:yamei628@gmail.com">yamei628@gmail.com</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. and Chang, Y.-M. (2023) Robust algorithms for simulating cluster point processes. <em>Journal of Statistical Computation and Simulation</em>. In Press. DOI <code>10.1080/00949655.2023.2166045</code>.
</p>
<p>Brix, A. and Kendall, W.S. (2002)
Simulation of cluster point processes without edge effects.
<em>Advances in Applied Probability</em> <b>34</b>, 267&ndash;280.
</p>
<p>Ghorbani, M. (2013) Cauchy cluster process.
<em>Metrika</em> <b>76</b>, 697-706.
</p>
<p>Jalilian, A., Guan, Y. and Waagepetersen, R. (2013)
Decomposition of variance for spatial Cox processes.
<em>Scandinavian Journal of Statistics</em> <b>40</b>, 119-137.
</p>
<p>Waagepetersen, R. (2007)
An estimating function approach to inference for
inhomogeneous Neyman-Scott processes.
<em>Biometrics</em> <b>63</b>, 252&ndash;258.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpoispp">rpoispp</a></code>,    
<code><a href="#topic+rMatClust">rMatClust</a></code>,  
<code><a href="#topic+rThomas">rThomas</a></code>,    
<code><a href="#topic+rVarGamma">rVarGamma</a></code>,  
<code><a href="#topic+rNeymanScott">rNeymanScott</a></code>, 
<code><a href="#topic+rGaussPoisson">rGaussPoisson</a></code>.
</p>
<p>For fitting the model, see
<code><a href="spatstat.model.html#topic+kppm">kppm</a></code>, 
<code><a href="spatstat.model.html#topic+clusterfit">clusterfit</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # homogeneous
 X &lt;- rCauchy(30, 0.01, 5)
 # inhomogeneous
 ff &lt;- function(x,y){ exp(2 - 3 * abs(x)) }
 Z &lt;- as.im(ff, W= owin())
 Y &lt;- rCauchy(50, 0.01, Z)
 YY &lt;- rCauchy(ff, 0.01, 5)
</code></pre>

<hr>
<h2 id='rcell'>Simulate Baddeley-Silverman Cell Process</h2><span id='topic+rcell'></span>

<h3>Description</h3>

<p>Generates a random point pattern, a simulated realisation of the
Baddeley-Silverman cell process model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> rcell(win=square(1), nx=NULL, ny=nx, ..., dx=NULL, dy=dx,
       N=10, nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcell_+3A_win">win</code></td>
<td>

<p>A window. 
An object of class <code><a href="spatstat.geom.html#topic+owin">owin</a></code>,
or data in any format acceptable to <code><a href="spatstat.geom.html#topic+as.owin">as.owin</a>()</code>.
</p>
</td></tr>
<tr><td><code id="rcell_+3A_nx">nx</code></td>
<td>

<p>Number of columns of cells in the window.
Incompatible with <code>dx</code>.
</p>
</td></tr>
<tr><td><code id="rcell_+3A_ny">ny</code></td>
<td>

<p>Number of rows of cells in the window.
Incompatible with <code>dy</code>.
</p>
</td></tr>
<tr><td><code id="rcell_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="rcell_+3A_dx">dx</code></td>
<td>

<p>Width of the cells. Incompatible with <code>nx</code>.
</p>
</td></tr>
<tr><td><code id="rcell_+3A_dy">dy</code></td>
<td>

<p>Height of the cells.
Incompatible with <code>ny</code>.
</p>
</td></tr>
<tr><td><code id="rcell_+3A_n">N</code></td>
<td>

<p>Integer. Distributional parameter:
the maximum number of random points in each cell.
Passed to <code><a href="#topic+rcellnumber">rcellnumber</a></code>.
</p>
</td></tr>
<tr><td><code id="rcell_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rcell_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>This function generates a simulated realisation of the &ldquo;cell process&rdquo;
(Baddeley and Silverman, 1984), a random point process
with the same second-order properties as the uniform Poisson process.
In particular, the <code class="reqn">K</code> function of this process is identical to
the <code class="reqn">K</code> function of the uniform Poisson process (aka Complete
Spatial Randomness). The same holds for the pair correlation function
and all other second-order properties.
The cell process is a counterexample to the claim that the
<code class="reqn">K</code> function completely characterises a point pattern.
</p>
<p>A cell process is generated by dividing space into equal rectangular
tiles. In each tile, a random number of random points is placed.
By default, there are either <code class="reqn">0</code>, <code class="reqn">1</code> or <code class="reqn">10</code> points,
with probabilities <code class="reqn">1/10</code>, <code class="reqn">8/9</code> and <code class="reqn">1/90</code>
respectively. 
The points within a tile are independent and uniformly distributed in
that tile, and the numbers of points in different tiles are
independent random integers. 
</p>
<p>The tile width is determined
either by the number of columns <code>nx</code> or by the
horizontal spacing <code>dx</code>.
The tile height is determined
either by the number of rows <code>ny</code> or by the
vertical spacing <code>dy</code>. 
The cell process is then generated in these tiles.
The random numbers of points are generated by <code><a href="#topic+rcellnumber">rcellnumber</a></code>.
</p>
<p>Some of the resulting random points may lie outside the window <code>win</code>:
if they do, they are deleted.
The result is a point pattern inside the window <code>win</code>.
</p>


<h3>Value</h3>

<p>A point pattern (an object of class <code>"ppp"</code>)
if <code>nsim=1</code>, or a list of point patterns if <code>nsim &gt; 1</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A.J. and Silverman, B.W. (1984)
A cautionary example on the use of second-order methods for analyzing
point patterns. <em>Biometrics</em> <b>40</b>, 1089-1094.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcellnumber">rcellnumber</a></code>,
<code><a href="#topic+rstrat">rstrat</a></code>,
<code>rsyst</code>,
<code><a href="#topic+runifpoint">runifpoint</a></code>,
<code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rcell(nx=15)
  plot(X)
  if(require(spatstat.explore)) {
     plot(Kest(X))
  }
</code></pre>

<hr>
<h2 id='rcellnumber'>
Generate Random Numbers of Points for Cell Process
</h2><span id='topic+rcellnumber'></span>

<h3>Description</h3>

<p>Generates random integers for the Baddeley-Silverman counterexample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> rcellnumber(n, N = 10, mu=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcellnumber_+3A_n">n</code></td>
<td>

<p>Number of random integers to be generated.
</p>
</td></tr>
<tr><td><code id="rcellnumber_+3A_n">N</code></td>
<td>

<p>Distributional parameter: the largest possible value
(when <code>mu &lt;= 1</code>).
An integer greater than 1.
</p>
</td></tr>
<tr><td><code id="rcellnumber_+3A_mu">mu</code></td>
<td>

<p>Mean of the distribution (equals the variance).
Any positive real number.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>mu = 1</code> (the default),
this function generates random integers which have mean and variance
equal to 1, but which do not have a Poisson distribution. 
The random integers take the values <code class="reqn">0</code>, <code class="reqn">1</code> and <code class="reqn">N</code>
with probabilities <code class="reqn">1/N</code>, <code class="reqn">(N-2)/(N-1)</code> and <code class="reqn">1/(N(N-1))</code>
respectively.
See Baddeley and Silverman (1984).
</p>
<p>If <code>mu</code> is another positive number, the random integers will
have mean and variance equal to <code>mu</code>. They are obtained by
generating the
one-dimensional counterpart of the cell process and counting the
number of points in the interval from <code>0</code> to <code>mu</code>. The
maximum possible value of each random integer is <code>N * ceiling(mu)</code>.
</p>


<h3>Value</h3>

<p>An integer vector of length <code>n</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A.J. and Silverman, B.W. (1984)
A cautionary example on the use of second-order methods for analyzing
point patterns. <em>Biometrics</em> <b>40</b>, 1089-1094.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcell">rcell</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   rcellnumber(30, 3)
</code></pre>

<hr>
<h2 id='rclusterBKBC'>
Simulate Cluster Process using Brix-Kendall Algorithm or Modifications
</h2><span id='topic+rclusterBKBC'></span>

<h3>Description</h3>

<p>Generates simulated realisations of a stationary Neyman-Scott
cluster point process, using the Brix-Kendall (2002) algorithm or various
modifications proposed by Baddeley and Chang (2023).
For advanced research use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rclusterBKBC(clusters="Thomas",
   kappa, mu, scale,
   ...,
   W = unit.square(),
   nsim = 1, drop = TRUE,
   best = FALSE,
   external = c("BK", "superBK", "border"),
   internal = c("dominating", "naive"),
   inflate = 1,
   psmall = 1e-04,
   use.inverse=TRUE,
   use.special=TRUE,
   integralmethod=c("quadrature", "trapezoid"),
   verbose = TRUE, warn=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rclusterBKBC_+3A_clusters">clusters</code></td>
<td>

<p>Character string (partially matched) specifying the cluster process.
Current options include <code>"Thomas"</code>, <code>"MatClust"</code>,
<code>"Cauchy"</code> and <code>"VarGamma"</code>.
</p>
</td></tr>
<tr><td><code id="rclusterBKBC_+3A_kappa">kappa</code></td>
<td>

<p>Intensity of the parent process. A nonnegative number.
</p>
</td></tr>
<tr><td><code id="rclusterBKBC_+3A_mu">mu</code></td>
<td>

<p>Mean number of offspring per parent. A nonnegative number.
</p>
</td></tr>
<tr><td><code id="rclusterBKBC_+3A_scale">scale</code></td>
<td>

<p>Cluster scale. Interpretation depends on the model.
</p>
</td></tr>
<tr><td><code id="rclusterBKBC_+3A_...">...</code></td>
<td>

<p>Additional arguments controlling the shape of the cluster kernel, if any.
</p>
</td></tr>
<tr><td><code id="rclusterBKBC_+3A_w">W</code></td>
<td>

<p>Window in which the simulation should be generated.
An object of class <code>"owin"</code>.
</p>
</td></tr>
<tr><td><code id="rclusterBKBC_+3A_nsim">nsim</code></td>
<td>

<p>The number of simulated point patterns to be generated. A positive integer.
</p>
</td></tr>
<tr><td><code id="rclusterBKBC_+3A_drop">drop</code></td>
<td>

<p>Logical value. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
<tr><td><code id="rclusterBKBC_+3A_best">best</code></td>
<td>

<p>Logical value. If <code>best=TRUE</code>, the code will choose the fastest
algorithm. If <code>best=FALSE</code> (the default), the algorithm will be
specified by the other arguments <code>external</code> and
<code>internal</code>.
See Details.
</p>
</td></tr>
<tr><td><code id="rclusterBKBC_+3A_external">external</code></td>
<td>

<p>Algorithm to be used to generate parent points which lie outside the
bounding window. See Details. 
</p>
</td></tr>
<tr><td><code id="rclusterBKBC_+3A_internal">internal</code></td>
<td>

<p>Algorithm to be used to generate parent points which lie inside the
bounding window. See Details.
</p>
</td></tr>
<tr><td><code id="rclusterBKBC_+3A_inflate">inflate</code></td>
<td>

<p>Numerical value determining the position of the bounding window.
See Details.
</p>
</td></tr>
<tr><td><code id="rclusterBKBC_+3A_psmall">psmall</code></td>
<td>

<p>Threshold of small probability for use in the algorithm.
</p>
</td></tr>
<tr><td><code id="rclusterBKBC_+3A_use.inverse">use.inverse</code></td>
<td>

<p>Logical value specifying whether to compute the inverse function
analytically, if possible (<code>use.inverse=TRUE</code>, the default)
or by numerical root-finding (<code>use.inverse=FALSE</code>).
This is mainly for checking validity of code.
</p>
</td></tr>
<tr><td><code id="rclusterBKBC_+3A_use.special">use.special</code></td>
<td>

<p>Logical value specifying whether to use efficient special code
(if available) to generate the simulations (<code>use.special=TRUE</code>,
the default) or to use generic code (<code>use.special=FALSE</code>).
This is mainly for checking validity of code.
</p>
</td></tr>
<tr><td><code id="rclusterBKBC_+3A_integralmethod">integralmethod</code></td>
<td>

<p>Character string (partially matched)
specifying how to perform numerical computation of integrals
when required. This argument is passed to
<code><a href="#topic+indefinteg">indefinteg</a></code>.
The default <code>integralmethod="quadrature"</code> is accurate but
can be slow. 
Faster, but possibly less accurate, integration can be performed
by setting <code>integralmethod="trapezoid"</code>.
</p>
</td></tr>
<tr><td><code id="rclusterBKBC_+3A_verbose">verbose</code></td>
<td>

<p>Logical value specifying whether to print detailed information about
the simulation algorithm during execution.
</p>
</td></tr>
<tr><td><code id="rclusterBKBC_+3A_warn">warn</code></td>
<td>

<p>Logical value specifying whether to issue a warning
if the number of random proposal points is very large.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended for advanced research use.
It implements the algorithm of Brix and Kendall (2002)
for generating simulated realisations of a stationary Neyman-Scott
process, and various modifications of this algorithm proposed
in Baddeley and Chang (2023).
It is an alternative to <code><a href="#topic+rNeymanScott">rNeymanScott</a></code>.
</p>
<p>The function supports the following models:
</p>

<ul>
<li> <p><code>clusters="Thomas"</code>: the (modified) Thomas cluster process
which can also be simulated by
<code><a href="#topic+rThomas">rThomas</a></code>.  
</p>
</li>
<li> <p><code>clusters="MatClust"</code>: the Matern cluster process
which can also be simulated by
<code><a href="#topic+rMatClust">rMatClust</a></code>.  
</p>
</li>
<li> <p><code>clusters="Cauchy"</code>: the Cauchy cluster process
which can also be simulated by
<code><a href="#topic+rCauchy">rCauchy</a></code>.  
</p>
</li>
<li> <p><code>clusters="VarGamma"</code>: the variance-gamma cluster process
which can also be simulated by
<code><a href="#topic+rVarGamma">rVarGamma</a></code>.  
</p>
</li>
<li> 
<p>any other Poisson cluster process models that may be recognised by 
<code><a href="spatstat.model.html#topic+kppm">kppm</a></code>. 
</p>
</li></ul>

<p>By default, the code executes the original Brix-Kendall algorithm
described in Sections 2.3 and 3.1 of Brix and Kendall (2002).
</p>
<p>Modifications of this algorithm, proposed in Baddeley and Chang
(2023), can be selected using the
arguments <code>external</code> and <code>internal</code>, or <code>best</code>.
</p>
<p>If <code>best=TRUE</code>, the code will choose the algorithm
that would run fastest with the given parameters.
If <code>best=FALSE</code> (the default), the choice of algorithm
is determined by the arguments <code>external</code> and <code>internal</code>.
</p>
<p>First the window <code>W</code> is enclosed in a disc <code>D</code>
and Monte Carlo proposal densities are defined with reference to <code>D</code>
as described in Brix and Kendall (2002).
Then <code>D</code> is inflated by the scale factor <code>inflate</code>
to produce a larger disc <code>E</code> (by default <code>inflate=1</code>
implying <code>E=D</code>). 
Then the parent points of the clusters are generated, possibly
using different mechanisms inside and outside <code>E</code>.
</p>
<p>The argument <code>external</code> determines the algorithm for generating
parent points outside <code>E</code>.
</p>

<ul>
<li>
<p>If <code>external="BK"</code> (the default), proposed parents outside
<code>E</code> will be generated from a dominating point process as described in
Section 3.1 of Brix and Kendall (2002). These points will be thinned
to obtain the correct intensity of parent points.
For each accepted parent, offspring points are generated inside <code>D</code>,
subject to the condition that the parent has at least one offspring inside <code>D</code>.
Offspring points are subsequently clipped to the true window <code>W</code>.
</p>
</li>
<li> 
<p>If <code>external="superBK"</code>, proposed parents will initially be generated
from a process that dominates the dominating point process
as described in Baddeley and Chang (2023).
These proposals will then be thinned to obtain the correct intensity
of the dominating process, then thinned again to obtain the correct
intensity of parent points. This procedure reduces computation time
when <code>scale</code> is large.
For each accepted parent, offspring points are generated inside <code>D</code>,
subject to the condition that the parent has at least one offspring inside <code>D</code>.
Offspring points are subsequently clipped to the true window <code>W</code>.
</p>
</li>
<li>
<p>If <code>external="border"</code> then proposed parents will be generated
with uniform intensity in a border region
surrounding the disc <code>D</code>.
For each proposed parent, offspring points are generated in the
entire plane according to the cluster offspring distribution, without
any restriction.
Offspring points are subsequently clipped to the true window <code>W</code>.
This is the technique currently used in
<code><a href="#topic+rNeymanScott">rNeymanScott</a></code>.
</p>
</li></ul>

<p>The argument <code>internal</code> determines the algorithm for generating
proposed parent points inside <code>E</code>.
</p>

<ul>
<li>
<p>If <code>internal="dominating"</code>, parent points in <code>E</code> are generated
according to the dominating point process described in 
Sections 2.3 and 3.1 of Brix and Kendall (2002), and then thinned
to obtain the correct intensity of parent points. 
For each accepted parent, offspring points are generated inside <code>D</code>,
subject to the condition that the parent has at least one offspring inside <code>D</code>.
Offspring points are subsequently clipped to the true window <code>W</code>.
</p>
</li>
<li>
<p>If <code>internal="naive"</code>, parent points in <code>E</code> are generated with
uniform intensity inside <code>E</code> and are not thinned.
For each proposed parent, offspring points are generated in the
entire plane according to the cluster offspring distribution, without
any restriction.
Offspring points are subsequently clipped to the true window
<code>W</code>.
This is the technique currently used in <code><a href="#topic+rNeymanScott">rNeymanScott</a></code>.
</p>
</li></ul>

<p>If <code>warn=TRUE</code>, then a warning will be issued if
the number of random proposal points (proposed parents and proposed
offspring) is very large.
The threshold is <code>spatstat.options("huge.npoints")</code>.
This warning has no consequences,
but it helps to trap a number of common problems.
</p>


<h3>Value</h3>

<p>A point pattern, or a list of point patterns.
</p>
<p>If <code>nsim=1</code> and <code>drop=TRUE</code>, the result is 
a point pattern (an object of class <code>"ppp"</code>).
</p>
<p>Otherwise, the result is a list of <code>nsim</code> point patterns,
and also belongs to the class <code>"solist"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> and Ya-Mei Chang <a href="mailto:yamei628@gmail.com">yamei628@gmail.com</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. and Chang, Y.-M. (2023) Robust algorithms for simulating cluster point processes. <em>Journal of Statistical Computation and Simulation</em>. In Press. DOI <code>10.1080/00949655.2023.2166045</code>.
</p>
<p>Brix, A. and Kendall, W.S. (2002)
Simulation of cluster point processes without edge effects.
<em>Advances in Applied Probability</em> <b>34</b>, 267&ndash;280.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rNeymanScott">rNeymanScott</a></code>,
<code><a href="#topic+rMatClust">rMatClust</a></code>,
<code><a href="#topic+rThomas">rThomas</a></code>,
<code><a href="#topic+rCauchy">rCauchy</a></code>,
<code><a href="#topic+rVarGamma">rVarGamma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Y &lt;- rclusterBKBC("Thomas", 10,5,0.2)
  Y
  Z &lt;- rclusterBKBC("VarGamma", 10,5,0.2,
          nu=-1/4,
          internal="naive", external="super",
          verbose=FALSE)
</code></pre>

<hr>
<h2 id='rDGS'>Perfect Simulation of the Diggle-Gates-Stibbard Process</h2><span id='topic+rDGS'></span>

<h3>Description</h3>

<p>Generate a random pattern of points, a simulated realisation
of the Diggle-Gates-Stibbard process, using a perfect simulation algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rDGS(beta, rho, W = owin(), expand=TRUE, nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rDGS_+3A_beta">beta</code></td>
<td>

<p>intensity parameter (a positive number).
</p>
</td></tr>
<tr><td><code id="rDGS_+3A_rho">rho</code></td>
<td>

<p>interaction range (a non-negative number).
</p>
</td></tr>
<tr><td><code id="rDGS_+3A_w">W</code></td>
<td>

<p>window (object of class <code>"owin"</code>) in which to
generate the random pattern. 
</p>
</td></tr>
<tr><td><code id="rDGS_+3A_expand">expand</code></td>
<td>

<p>Logical. If <code>FALSE</code>, simulation is performed
in the window <code>W</code>, which must be rectangular.
If <code>TRUE</code> (the default), simulation is performed
on a larger window, and the result is clipped to the original
window <code>W</code>.
Alternatively <code>expand</code> can be an object of class 
<code>"rmhexpand"</code> (see <code><a href="#topic+rmhexpand">rmhexpand</a></code>)
determining the expansion method.
</p>
</td></tr>
<tr><td><code id="rDGS_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>  
<tr><td><code id="rDGS_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a realisation of the 
Diggle-Gates-Stibbard point process in the window <code>W</code>
using a &lsquo;perfect simulation&rsquo; algorithm.
</p>
<p>Diggle, Gates and Stibbard (1987) proposed a pairwise interaction
point process in which each pair of points separated by
a distance <code class="reqn">d</code> contributes a factor <code class="reqn">e(d)</code> to the
probability density, where
</p>
<p style="text-align: center;"><code class="reqn">
    e(d) = \sin^2\left(\frac{\pi d}{2\rho}\right)
  </code>
</p>

<p>for <code class="reqn">d &lt; \rho</code>, and <code class="reqn">e(d)</code> is equal to 1
for <code class="reqn">d \ge \rho</code>.
</p>
<p>The simulation algorithm used to generate the point pattern
is &lsquo;dominated coupling from the past&rsquo;
as implemented by Berthelsen and Moller (2002, 2003).
This is a &lsquo;perfect simulation&rsquo; or &lsquo;exact simulation&rsquo;
algorithm, so called because the output of the algorithm is guaranteed
to have the correct probability distribution exactly (unlike the
Metropolis-Hastings algorithm used in <code><a href="#topic+rmh">rmh</a></code>, whose output
is only approximately correct).
</p>
<p>There is a tiny chance that the algorithm will 
run out of space before it has terminated. If this occurs, an error
message will be generated.
</p>


<h3>Value</h3>

<p>If <code>nsim = 1</code>, a point pattern (object of class <code>"ppp"</code>).
If <code>nsim &gt; 1</code>, a list of point patterns.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>,
based on original code for the Strauss process by 
Kasper Klitgaard Berthelsen.
</p>


<h3>References</h3>

<p>Berthelsen, K.K. and Moller, J. (2002)
A primer on perfect simulation for spatial point processes.
<em>Bulletin of the Brazilian Mathematical Society</em> 33, 351-367.
</p>
<p>Berthelsen, K.K. and Moller, J. (2003)
Likelihood and non-parametric Bayesian MCMC inference 
for spatial point processes based on perfect simulation and
path sampling. 
<em>Scandinavian Journal of Statistics</em> 30, 549-564.
</p>
<p>Diggle, P.J., Gates, D.J., and Stibbard, A. (1987)
A nonparametric estimator for pairwise-interaction point processes.
Biometrika <b>74</b>, 763 &ndash; 770.
<em>Scandinavian Journal of Statistics</em> <b>21</b>, 359&ndash;373.
</p>
<p>Moller, J. and Waagepetersen, R. (2003).
<em>Statistical Inference and Simulation for Spatial Point Processes.</em>
Chapman and Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmh">rmh</a></code>,
<code><a href="spatstat.model.html#topic+DiggleGatesStibbard">DiggleGatesStibbard</a></code>.
</p>
<p><code><a href="#topic+rStrauss">rStrauss</a></code>,
<code><a href="#topic+rHardcore">rHardcore</a></code>,
<code><a href="#topic+rStraussHard">rStraussHard</a></code>,
<code><a href="#topic+rDiggleGratton">rDiggleGratton</a></code>,
<code><a href="#topic+rPenttinen">rPenttinen</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- rDGS(50, 0.05)
   Z &lt;- rDGS(50, 0.03, nsim=2)
</code></pre>

<hr>
<h2 id='rDiggleGratton'>Perfect Simulation of the Diggle-Gratton Process</h2><span id='topic+rDiggleGratton'></span>

<h3>Description</h3>

<p>Generate a random pattern of points, a simulated realisation
of the Diggle-Gratton process, using a perfect simulation algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rDiggleGratton(beta, delta, rho, kappa=1, W = owin(),
                 expand=TRUE, nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rDiggleGratton_+3A_beta">beta</code></td>
<td>

<p>intensity parameter (a positive number).
</p>
</td></tr>
<tr><td><code id="rDiggleGratton_+3A_delta">delta</code></td>
<td>

<p>hard core distance (a non-negative number).
</p>
</td></tr>
<tr><td><code id="rDiggleGratton_+3A_rho">rho</code></td>
<td>

<p>interaction range (a number greater than <code>delta</code>).
</p>
</td></tr>
<tr><td><code id="rDiggleGratton_+3A_kappa">kappa</code></td>
<td>

<p>interaction exponent (a non-negative number).
</p>
</td></tr>
<tr><td><code id="rDiggleGratton_+3A_w">W</code></td>
<td>

<p>window (object of class <code>"owin"</code>) in which to
generate the random pattern. Currently this must be a rectangular
window.
</p>
</td></tr>
<tr><td><code id="rDiggleGratton_+3A_expand">expand</code></td>
<td>

<p>Logical. If <code>FALSE</code>, simulation is performed
in the window <code>W</code>, which must be rectangular.
If <code>TRUE</code> (the default), simulation is performed
on a larger window, and the result is clipped to the original
window <code>W</code>.
Alternatively <code>expand</code> can be an object of class 
<code>"rmhexpand"</code> (see <code><a href="#topic+rmhexpand">rmhexpand</a></code>)
determining the expansion method.
</p>
</td></tr>
<tr><td><code id="rDiggleGratton_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rDiggleGratton_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a realisation of the 
Diggle-Gratton point process in the window <code>W</code>
using a &lsquo;perfect simulation&rsquo; algorithm.
</p>
<p>Diggle and Gratton (1984, pages 208-210)
introduced the pairwise interaction point
process with pair potential <code class="reqn">h(t)</code> of the form
</p>
<p style="text-align: center;"><code class="reqn">
    h(t) = \left( \frac{t-\delta}{\rho-\delta} \right)^\kappa
    \quad\quad \mbox{  if  } \delta \le t \le \rho
  </code>
</p>

<p>with <code class="reqn">h(t) = 0</code> for <code class="reqn">t &lt; \delta</code>
and  <code class="reqn">h(t) = 1</code> for <code class="reqn">t &gt; \rho</code>.
Here <code class="reqn">\delta</code>, <code class="reqn">\rho</code> and <code class="reqn">\kappa</code>
are parameters.
</p>
<p>Note that we use the symbol <code class="reqn">\kappa</code>
where Diggle and Gratton (1984) 
use <code class="reqn">\beta</code>, since in <span class="pkg">spatstat</span> we reserve the symbol
<code class="reqn">\beta</code> for an intensity parameter.
</p>
<p>The parameters must all be nonnegative,
and must satisfy <code class="reqn">\delta \le \rho</code>.
</p>
<p>The simulation algorithm used to generate the point pattern
is &lsquo;dominated coupling from the past&rsquo;
as implemented by Berthelsen and Moller (2002, 2003).
This is a &lsquo;perfect simulation&rsquo; or &lsquo;exact simulation&rsquo;
algorithm, so called because the output of the algorithm is guaranteed
to have the correct probability distribution exactly (unlike the
Metropolis-Hastings algorithm used in <code><a href="#topic+rmh">rmh</a></code>, whose output
is only approximately correct).
</p>
<p>There is a tiny chance that the algorithm will 
run out of space before it has terminated. If this occurs, an error
message will be generated.
</p>


<h3>Value</h3>

<p>If <code>nsim = 1</code>, a point pattern (object of class <code>"ppp"</code>).
If <code>nsim &gt; 1</code>, a list of point patterns.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>based on original code for the Strauss process by 
Kasper Klitgaard Berthelsen.
</p>


<h3>References</h3>

<p>Berthelsen, K.K. and Moller, J. (2002)
A primer on perfect simulation for spatial point processes.
<em>Bulletin of the Brazilian Mathematical Society</em> 33, 351-367.
</p>
<p>Berthelsen, K.K. and Moller, J. (2003)
Likelihood and non-parametric Bayesian MCMC inference 
for spatial point processes based on perfect simulation and
path sampling. 
<em>Scandinavian Journal of Statistics</em> 30, 549-564.
</p>
<p>Diggle, P.J. and Gratton, R.J. (1984)
Monte Carlo methods of inference for implicit statistical models.
<em>Journal of the Royal Statistical Society, series B</em>
<b>46</b>, 193 &ndash; 212.
</p>
<p>Moller, J. and Waagepetersen, R. (2003).
<em>Statistical Inference and Simulation for Spatial Point Processes.</em>
Chapman and Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmh">rmh</a></code>,
<code><a href="#topic+rStrauss">rStrauss</a></code>,
<code><a href="#topic+rHardcore">rHardcore</a></code>,
<code><a href="#topic+rStraussHard">rStraussHard</a></code>,
<code><a href="#topic+rDGS">rDGS</a></code>,
<code><a href="#topic+rPenttinen">rPenttinen</a></code>.
</p>
<p>For fitting the model, see <code><a href="spatstat.model.html#topic+DiggleGratton">DiggleGratton</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- rDiggleGratton(50, 0.02, 0.07)
   Z &lt;- rDiggleGratton(50, 0.02, 0.07, 2, nsim=2)
</code></pre>

<hr>
<h2 id='reach'>Interaction Distance of a Point Process Model</h2><span id='topic+reach'></span><span id='topic+reach.rmhmodel'></span>

<h3>Description</h3>

<p>Computes the interaction distance of a point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  reach(x, ...)

  ## S3 method for class 'rmhmodel'
reach(x, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reach_+3A_x">x</code></td>
<td>
<p>Either a fitted point process model (object of class
<code>"ppm"</code>), an interpoint interaction (object of class
<code>"interact"</code>), a fitted interpoint interaction (object of
class <code>"fii"</code>) or a point process model for simulation
(object of class <code>"rmhmodel"</code>).
</p>
</td></tr>
<tr><td><code id="reach_+3A_...">...</code></td>
<td>

<p>Other arguments are ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>reach</code> computes the 
&lsquo;interaction distance&rsquo; or &lsquo;interaction range&rsquo; of a point process
model.
</p>
<p>The definition of the interaction distance depends on the
type of point process model. This help page explains the
interaction distance for a Gibbs point process. For other kinds of
models, see <code><a href="spatstat.model.html#topic+reach.kppm">reach.kppm</a></code> and
<code><a href="spatstat.model.html#topic+reach.dppm">reach.dppm</a></code>.
</p>
<p>For a Gibbs point process model, the interaction distance
is the shortest distance <code class="reqn">D</code> such that any two points in the
process which are separated by a distance greater than <code class="reqn">D</code> do not
interact with each other.
</p>
<p>For example, the interaction range of a Strauss process
(see <code><a href="spatstat.model.html#topic+Strauss">Strauss</a></code> or <code><a href="#topic+rStrauss">rStrauss</a></code>)
with parameters <code class="reqn">\beta,\gamma,r</code> is equal to
<code class="reqn">r</code>, unless <code class="reqn">\gamma=1</code> in which case the model is
Poisson and the interaction
range is <code class="reqn">0</code>.
The interaction range of a Poisson process is zero.
The interaction range of the Ord threshold process
(see <code><a href="spatstat.model.html#topic+OrdThresh">OrdThresh</a></code>) is infinite, since two points <em>may</em>
interact at any distance apart.
</p>
<p>The function <code>reach</code> is generic, with methods
for the case where <code>x</code> is 
</p>

<ul>
<li>
<p>a fitted point process model
(object of class <code>"ppm"</code>, usually obtained from the model-fitting
function <code><a href="spatstat.model.html#topic+ppm">ppm</a></code>);
</p>
</li>
<li>
<p>an interpoint interaction structure (object of class
<code>"interact"</code>)
</p>
</li>
<li>
<p>a fitted interpoint interaction (object of class
<code>"fii"</code>)
</p>
</li>
<li>
<p>a point process model for simulation (object of class
<code>"rmhmodel"</code>), usually obtained from <code><a href="#topic+rmhmodel">rmhmodel</a></code>.
</p>
</li></ul>



<h3>Value</h3>

<p>The interaction distance, or <code>NA</code> if this cannot be
computed from the information given.
</p>


<h3>Other types of models</h3>

<p>Methods for <code>reach</code> are also defined for
point process models of class <code>"kppm"</code> and <code>"dppm"</code>.
Their technical definition is different from this one.
See <code><a href="spatstat.model.html#topic+reach.kppm">reach.kppm</a></code> and <code><a href="spatstat.model.html#topic+reach.dppm">reach.dppm</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.model.html#topic+reach.ppm">reach.ppm</a></code>
</p>
<p><code><a href="#topic+rmhmodel">rmhmodel</a></code>
</p>
<p>See <code><a href="spatstat.model.html#topic+reach.kppm">reach.kppm</a></code> and <code><a href="spatstat.model.html#topic+reach.dppm">reach.dppm</a></code>
for other types of point process models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    reach(rmhmodel(cif='poisson', par=list(beta=100)))
    # returns 0

    reach(rmhmodel(cif='strauss', par=list(beta=100, gamma=0.1, r=7)))
    # returns 7

    reach(rmhmodel(cif='sftcr', par=list(beta=100, sigma=1, kappa=0.7)))
    # returns Inf
    
    reach(rmhmodel(cif='multihard',
                   par=list(beta=c(10,10), hradii=matrix(c(1,3,3,1),2,2))))
    # returns 3
</code></pre>

<hr>
<h2 id='recipEnzpois'>
First Reciprocal Moment of the Truncated Poisson Distribution
</h2><span id='topic+recipEnzpois'></span>

<h3>Description</h3>

<p>Computes the first reciprocal moment (first negative moment)
of the truncated Poisson distribution
(the Poisson distribution conditioned to have a nonzero value).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  recipEnzpois(mu, exact=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recipEnzpois_+3A_mu">mu</code></td>
<td>

<p>The mean of the original Poisson distribution.
A single positive numeric value, or a vector of positive numbers.
</p>
</td></tr>
<tr><td><code id="recipEnzpois_+3A_exact">exact</code></td>
<td>

<p>Logical value specifying whether to use the exact analytic formula
if possible.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the expected value of <code class="reqn">1/N</code>
given <code class="reqn">N &gt; 0</code>, where <code class="reqn">N</code> is a Poisson random variable
with mean <code class="reqn">\mu</code>.
</p>
<p>If the library <span class="pkg">gsl</span> is loaded, and if <code>exact=TRUE</code> (the
default), then the calculation uses
the exact analytic formula
</p>
<p style="text-align: center;"><code class="reqn">
    \nu = \frac{e^{-\mu}}{1- e^{-\mu}}
    \left( Ei(\mu) - \log \mu - \gamma \right)
  </code>
</p>

<p>(see e.g. Grab and Savage, 1954)
where <code class="reqn">\nu</code> is the desired reciprocal moment, and
</p>
<p style="text-align: center;"><code class="reqn">
    Ei(x) = \int_{-\infty}^x t e^{-t} dt
  </code>
</p>

<p>is the first exponential integral, and
<code class="reqn">\gamma \approx 0.577</code>
is the Euler-Mascheroni constant.
</p>
<p>If <span class="pkg">gsl</span> is not loaded, or if <code>exact=FALSE</code> is specified,
the value is computed approximately (and more slowly)
by summing over the possible values of <code class="reqn">N</code> up to a finite limit.
</p>


<h3>Value</h3>

<p>A single numerical value or a numeric vector.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Grab, E.L. and Savage, I.R. (1954)
Tables of the expected value of 1/X for positive
Bernoulli and Poisson variables.
<em>Journal of the American Statistical Association</em>
<b>49</b>, 169&ndash;177.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpoisnonzero">rpoisnonzero</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if(require(gsl)) {
    v &lt;- recipEnzpois(10)
    print(v)
  }
  recipEnzpois(10, exact=FALSE)
</code></pre>

<hr>
<h2 id='rGaussPoisson'>Simulate Gauss-Poisson Process</h2><span id='topic+rGaussPoisson'></span>

<h3>Description</h3>

<p>Generate a random point pattern, a simulated realisation of the
Gauss-Poisson Process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> rGaussPoisson(kappa, r, p2, win = owin(c(0,1),c(0,1)),
               ..., nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rGaussPoisson_+3A_kappa">kappa</code></td>
<td>

<p>Intensity of the Poisson process of cluster centres.
A single positive number, a function, or a pixel image.
</p>
</td></tr>
<tr><td><code id="rGaussPoisson_+3A_r">r</code></td>
<td>

<p>Diameter of each cluster that consists of exactly 2 points.
</p>
</td></tr>
<tr><td><code id="rGaussPoisson_+3A_p2">p2</code></td>
<td>

<p>Probability that a cluster contains exactly 2 points.
</p>
</td></tr>
<tr><td><code id="rGaussPoisson_+3A_win">win</code></td>
<td>

<p>Window in which to simulate the pattern.
An object of class <code>"owin"</code>
or something acceptable to <code>as.owin</code>.
</p>
</td></tr>
<tr><td><code id="rGaussPoisson_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="rGaussPoisson_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rGaussPoisson_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm generates a realisation of the Gauss-Poisson
point process inside the window <code>win</code>.
The process is constructed by first
generating a Poisson point process of parent points 
with intensity <code>kappa</code>. Then each parent point is either retained
(with probability <code>1 - p2</code>)
or replaced by a pair of points at a fixed distance <code>r</code> apart
(with probability <code>p2</code>). In the case of clusters of 2 points,
the line joining the two points has uniform random orientation.
</p>
<p>In this implementation, parent points are not restricted to lie in the
window; the parent process is effectively the uniform
Poisson process on the infinite plane.
</p>


<h3>Value</h3>

<p>A point pattern (an object of class <code>"ppp"</code>)
if <code>nsim=1</code>, or a list of point patterns if <code>nsim &gt; 1</code>.
</p>
<p>Additionally, some intermediate results of the simulation are
returned as attributes of the point pattern.
See <code><a href="#topic+rNeymanScott">rNeymanScott</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpoispp">rpoispp</a></code>,
<code><a href="#topic+rThomas">rThomas</a></code>,
<code><a href="#topic+rMatClust">rMatClust</a></code>,
<code><a href="#topic+rNeymanScott">rNeymanScott</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> pp &lt;- rGaussPoisson(30, 0.07, 0.5)
</code></pre>

<hr>
<h2 id='rHardcore'>Perfect Simulation of the Hardcore Process</h2><span id='topic+rHardcore'></span>

<h3>Description</h3>

<p>Generate a random pattern of points, a simulated realisation
of the Hardcore process, using a perfect simulation algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rHardcore(beta, R = 0, W = owin(), expand=TRUE, nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rHardcore_+3A_beta">beta</code></td>
<td>

<p>intensity parameter (a positive number).
</p>
</td></tr>
<tr><td><code id="rHardcore_+3A_r">R</code></td>
<td>

<p>hard core distance (a non-negative number).
</p>
</td></tr>
<tr><td><code id="rHardcore_+3A_w">W</code></td>
<td>

<p>window (object of class <code>"owin"</code>) in which to
generate the random pattern. Currently this must be a rectangular
window.
</p>
</td></tr>
<tr><td><code id="rHardcore_+3A_expand">expand</code></td>
<td>

<p>Logical. If <code>FALSE</code>, simulation is performed
in the window <code>W</code>, which must be rectangular.
If <code>TRUE</code> (the default), simulation is performed
on a larger window, and the result is clipped to the original
window <code>W</code>.
Alternatively <code>expand</code> can be an object of class 
<code>"rmhexpand"</code> (see <code><a href="#topic+rmhexpand">rmhexpand</a></code>)
determining the expansion method.
</p>
</td></tr>
<tr><td><code id="rHardcore_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rHardcore_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a realisation of the 
Hardcore point process in the window <code>W</code>
using a &lsquo;perfect simulation&rsquo; algorithm.
</p>
<p>The Hardcore process is a model for strong spatial inhibition.
Two points of the process are forbidden to lie closer than
<code>R</code> units apart.
The Hardcore process is the special case of the Strauss process
(see <code><a href="#topic+rStrauss">rStrauss</a></code>)
with interaction parameter <code class="reqn">\gamma</code> equal to zero.
</p>
<p>The simulation algorithm used to generate the point pattern
is &lsquo;dominated coupling from the past&rsquo;
as implemented by Berthelsen and Moller (2002, 2003).
This is a &lsquo;perfect simulation&rsquo; or &lsquo;exact simulation&rsquo;
algorithm, so called because the output of the algorithm is guaranteed
to have the correct probability distribution exactly (unlike the
Metropolis-Hastings algorithm used in <code><a href="#topic+rmh">rmh</a></code>, whose output
is only approximately correct).
</p>
<p>There is a tiny chance that the algorithm will 
run out of space before it has terminated. If this occurs, an error
message will be generated.
</p>


<h3>Value</h3>

<p>If <code>nsim = 1</code>, a point pattern (object of class <code>"ppp"</code>).
If <code>nsim &gt; 1</code>, a list of point patterns.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>,
based on original code for the Strauss process by 
Kasper Klitgaard Berthelsen.
</p>


<h3>References</h3>

<p>Berthelsen, K.K. and Moller, J. (2002)
A primer on perfect simulation for spatial point processes.
<em>Bulletin of the Brazilian Mathematical Society</em> 33, 351-367.
</p>
<p>Berthelsen, K.K. and Moller, J. (2003)
Likelihood and non-parametric Bayesian MCMC inference 
for spatial point processes based on perfect simulation and
path sampling. 
<em>Scandinavian Journal of Statistics</em> 30, 549-564.
</p>
<p>Moller, J. and Waagepetersen, R. (2003).
<em>Statistical Inference and Simulation for Spatial Point Processes.</em>
Chapman and Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmh">rmh</a></code>,
<code><a href="#topic+rStrauss">rStrauss</a></code>,
<code><a href="#topic+rStraussHard">rStraussHard</a></code>,
<code><a href="#topic+rDiggleGratton">rDiggleGratton</a></code>.
<code><a href="#topic+rDGS">rDGS</a></code>,
<code><a href="#topic+rPenttinen">rPenttinen</a></code>.
</p>
<p>For fitting the model, see
<code><a href="spatstat.model.html#topic+Hardcore">Hardcore</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- rHardcore(0.05,1.5,square(50))
</code></pre>

<hr>
<h2 id='rjitter.psp'>Random Perturbation of Line Segment Pattern</h2><span id='topic+rjitter.psp'></span>

<h3>Description</h3>

<p>Randomly pertubs a spatial pattern of line segments by applying
independent random displacements to the segment endpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'psp'
rjitter(X, radius, ..., clip=TRUE, nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rjitter.psp_+3A_x">X</code></td>
<td>

<p>A point pattern on a linear network
(object of class <code>"psp"</code>).
</p>
</td></tr>
<tr><td><code id="rjitter.psp_+3A_radius">radius</code></td>
<td>

<p>Scale of perturbations. A positive numerical value.
Each point will be displaced by a random distance,
with maximum displacement equal to this value.
</p>
</td></tr>
<tr><td><code id="rjitter.psp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="rjitter.psp_+3A_clip">clip</code></td>
<td>

<p>Logical value specifying what to do if segments cross the boundary
of the window. See Details.
</p>
</td></tr>
<tr><td><code id="rjitter.psp_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rjitter.psp_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a spatial pattern of line segments (class
<code>"psp"</code>) rather than a list of length 1 containing this pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="spatstat.geom.html#topic+rjitter">rjitter</a></code> is generic. This function is
the method for the class <code>"psp"</code> of line segment patterns.
</p>
<p>Each of the endpoints of each segment in <code>X</code> will be
subjected to an independent random displacement. The displacement vectors are
uniformly distributed in a circle of radius <code>radius</code>.
</p>
<p>If <code>clip=TRUE</code> (the default), segment endpoints
are permitted to move to locations slightly outside the window of <code>X</code>,
and the resulting segments will be clipped to the window.
If <code>clip=FALSE</code>, segment endpoints are conditioned to fall
inside the window.
</p>
<p>If <code>nsim=1</code> and <code>drop=TRUE</code>, the result is another
spatial pattern of line segments (object of class <code>"psp"</code>).
Otherwise, the result is a list of <code>nsim</code> line segment patterns.
</p>


<h3>Value</h3>

<p>A spatial pattern of line segments
(object of class <code>"psp"</code>)
or a list of such patterns.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+rjitter">rjitter</a></code> for point patterns in two dimensions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   E &lt;- edges(letterR)
   Window(E) &lt;- owin(c(1.9, 4.1), c(0.5, 3.5))
   plot(rjitter(E, 0.1))
</code></pre>

<hr>
<h2 id='rknn'>
Theoretical Distribution of Nearest Neighbour Distance
</h2><span id='topic+dknn'></span><span id='topic+pknn'></span><span id='topic+qknn'></span><span id='topic+rknn'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the random distance to the <code class="reqn">k</code>th nearest neighbour
in a Poisson point process in <code class="reqn">d</code> dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dknn(x, k = 1, d = 2, lambda = 1)
pknn(q, k = 1, d = 2, lambda = 1)
qknn(p, k = 1, d = 2, lambda = 1)
rknn(n, k = 1, d = 2, lambda = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rknn_+3A_x">x</code>, <code id="rknn_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="rknn_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="rknn_+3A_n">n</code></td>
<td>
<p>number of observations to be generated.</p>
</td></tr>
<tr><td><code id="rknn_+3A_k">k</code></td>
<td>
<p>order of neighbour.</p>
</td></tr>
<tr><td><code id="rknn_+3A_d">d</code></td>
<td>
<p>dimension of space.</p>
</td></tr>
<tr><td><code id="rknn_+3A_lambda">lambda</code></td>
<td>
<p>intensity of Poisson point process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a Poisson point process in <code class="reqn">d</code>-dimensional space, let
the random variable <code class="reqn">R</code> be
the distance from a fixed point to the <code class="reqn">k</code>-th nearest random point,
or the distance from a random point to the
<code class="reqn">k</code>-th nearest other random point.
</p>
<p>Then <code class="reqn">R^d</code> has a Gamma distribution with shape parameter <code class="reqn">k</code>
and rate <code class="reqn">\lambda * \alpha</code> where
<code class="reqn">\alpha</code> is a constant (equal to the volume of the
unit ball in <code class="reqn">d</code>-dimensional space).
See e.g. Cressie (1991, page 61).
</p>
<p>These functions support calculation and simulation for the
distribution of <code class="reqn">R</code>. 
</p>


<h3>Value</h3>

<p>A numeric vector:
<code>dknn</code> returns the probability density,
<code>pknn</code> returns cumulative probabilities (distribution function),
<code>qknn</code> returns quantiles,
and <code>rknn</code> generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Cressie, N.A.C. (1991)
<em>Statistics for spatial data</em>.
John Wiley and Sons, 1991.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- seq(0, 5, length=20)
  densities &lt;- dknn(x, k=3, d=2)
  cdfvalues &lt;- pknn(x, k=3, d=2)
  randomvalues &lt;- rknn(100, k=3, d=2)
  deciles &lt;- qknn((1:9)/10, k=3, d=2)
</code></pre>

<hr>
<h2 id='rlabel'>Random Re-Labelling of Point Pattern</h2><span id='topic+rlabel'></span>

<h3>Description</h3>

<p>Randomly allocates marks to a point pattern,
or permutes the existing marks, or resamples
from the existing marks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   rlabel(X, labels=marks(X), permute=TRUE, group=NULL, ..., nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlabel_+3A_x">X</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code>,
<code>"lpp"</code>, <code>"pp3"</code> or <code>"ppx"</code>)
or line segment pattern (object of class <code>"psp"</code>).
</p>
</td></tr>
<tr><td><code id="rlabel_+3A_labels">labels</code></td>
<td>

<p>Vector of values from which the new marks will be drawn
at random. Defaults to the vector of existing marks.
</p>
</td></tr>
<tr><td><code id="rlabel_+3A_permute">permute</code></td>
<td>

<p>Logical value indicating whether to generate new marks
by randomly permuting <code>labels</code> or
by drawing a random sample with replacement.
</p>
</td></tr>
<tr><td><code id="rlabel_+3A_group">group</code></td>
<td>

<p>Optional. A factor, or other data dividing the points into groups.
Random relabelling will be performed separately within each group.
See Details.
</p>
</td></tr>
<tr><td><code id="rlabel_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>cut.ppp</code> to
determine the grouping factor, when <code>group</code> is given.
</p>
</td></tr>
<tr><td><code id="rlabel_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rlabel_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This very simple function allocates random marks to
an existing point pattern <code>X</code>. It is useful
for hypothesis testing purposes. (The function can also be applied
to line segment patterns.)
</p>
<p>In the simplest case, the command <code>rlabel(X)</code> yields
a point pattern obtained from <code>X</code> by randomly permuting
the marks of the points.
</p>
<p>If <code>permute=TRUE</code>, then <code>labels</code> should be a vector of
length equal to the number of points in <code>X</code>.
The result of <code>rlabel</code> will be a point pattern
with locations given by <code>X</code> and marks given by
a random permutation of <code>labels</code> (i.e. a random sample without
replacement).
</p>
<p>If <code>permute=FALSE</code>, then <code>labels</code> may be a vector of
any length. 
The result of <code>rlabel</code> will be a point pattern
with locations given by <code>X</code> and marks given by
a random sample from <code>labels</code> (with replacement).
</p>
<p>The argument <code>group</code> specifies that the points are
divided into several different groups, and that the random labelling
shall be performed separately on each group.
The arguments <code>group</code> and <code>...</code> are passed to
<code>cut.ppp</code> to determine the grouping. Thus <code>group</code>
could be a <code>factor</code>, or the name of a column of marks in
<code>X</code>, or a tessellation, or a factor-valued pixel image, etc.
</p>


<h3>Value</h3>

<p>If <code>nsim = 1</code> and <code>drop=TRUE</code>,
a marked point pattern (of the same class as <code>X</code>).
If <code>nsim &gt; 1</code>, a list of point patterns.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code>marks&lt;-</code> to assign arbitrary marks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   amacrine

   # Randomly permute the marks "on" and "off"
   # Result always has 142 "off" and 152 "on"
   Y &lt;- rlabel(amacrine)

   # randomly allocate marks "on" and "off"
   # with probabilities p(off) = 0.48, p(on) = 0.52
   Y &lt;- rlabel(amacrine, permute=FALSE)

   # randomly allocate marks "A" and "B" with equal probability
   Y &lt;- rlabel(cells, labels=factor(c("A", "B")), permute=FALSE)

   # divide the window into tiles and 
   # randomly permute the marks within each tile
   Z &lt;- rlabel(amacrine, group=quadrats(Window(amacrine), 4, 3))
</code></pre>

<hr>
<h2 id='rLGCP'>Simulate Log-Gaussian Cox Process</h2><span id='topic+rLGCP'></span>

<h3>Description</h3>

<p>Generate a random point pattern, a realisation of the
log-Gaussian Cox process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> rLGCP(model=c("exponential", "gauss", "stable", "gencauchy", "matern"),
       mu = 0, param = NULL,
       ...,
       win=NULL, saveLambda=TRUE, nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rLGCP_+3A_model">model</code></td>
<td>

<p>character string (partially matched) giving the name of a
covariance model for the Gaussian random field. 
</p>
</td></tr>
<tr><td><code id="rLGCP_+3A_mu">mu</code></td>
<td>

<p>mean function of the Gaussian random field. Either a
single number, a <code>function(x,y, ...)</code> or a pixel
image (object of class <code>"im"</code>).
</p>
</td></tr>
<tr><td><code id="rLGCP_+3A_param">param</code></td>
<td>

<p>List of parameters for the covariance.
Standard arguments are <code>var</code> and <code>scale</code>.
</p>
</td></tr>
<tr><td><code id="rLGCP_+3A_...">...</code></td>
<td>

<p>Additional parameters for the covariance,
or arguments passed to <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code> to determine
the pixel resolution.
</p>
</td></tr>
<tr><td><code id="rLGCP_+3A_win">win</code></td>
<td>

<p>Window in which to simulate the pattern.
An object of class <code>"owin"</code>.
</p>
</td></tr>
<tr><td><code id="rLGCP_+3A_savelambda">saveLambda</code></td>
<td>

<p>Logical. If <code>TRUE</code> (the default) then the
simulated random intensity will also be saved,
and returns as an attribute of the point pattern.
</p>
</td></tr>
<tr><td><code id="rLGCP_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rLGCP_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a realisation of a log-Gaussian Cox
process (LGCP). This is a Cox point process in which
the logarithm of the random intensity is a Gaussian random
field with mean function <code class="reqn">\mu</code> and covariance function
<code class="reqn">c(r)</code>. Conditional on the random intensity, the point process
is a Poisson process with this intensity.
</p>
<p>The string <code>model</code> specifies the covariance 
function of the Gaussian random field, and the parameters
of the covariance are determined by <code>param</code> and <code>...</code>.
</p>
<p>All models recognise the parameters <code>var</code>
for the variance at distance zero, and <code>scale</code> for the scale
parameter. Some models require additional parameters which are listed
below. 
</p>
<p>The available models are as follows:
</p>

<dl>
<dt><code>model="exponential"</code>:</dt><dd>
<p>the exponential covariance function
</p>
<p style="text-align: center;"><code class="reqn">C(r) = \sigma^2 \exp(-r/h)</code>
</p>

<p>where <code class="reqn">\sigma^2</code> is the variance parameter <code>var</code>,
and <code class="reqn">h</code> is the scale parameter <code>scale</code>.
</p>
</dd>
<dt><code>model="gauss"</code>:</dt><dd>
<p>the Gaussian covariance function
</p>
<p style="text-align: center;"><code class="reqn">C(r) = \sigma^2 \exp(-(r/h)^2)</code>
</p>

<p>where <code class="reqn">\sigma^2</code> is the variance parameter <code>var</code>,
and <code class="reqn">h</code> is the scale parameter <code>scale</code>.
</p>
</dd>
<dt><code>model="stable"</code>:</dt><dd>
<p>the stable covariance function
</p>
<p style="text-align: center;"><code class="reqn">
	C(r) = \sigma^2 \exp(-(r/h)^\alpha)
      </code>
</p>

<p>where <code class="reqn">\sigma^2</code> is the variance parameter <code>var</code>,
<code class="reqn">h</code> is the scale parameter <code>scale</code>,
and <code class="reqn">\alpha</code> is the shape parameter <code>alpha</code>.
The parameter <code>alpha</code> must be given, either as a stand-alone
argument, or as an entry in the list <code>param</code>.
</p>
</dd>
<dt><code>model="gencauchy"</code>:</dt><dd>
<p>the generalised Cauchy covariance function
</p>
<p style="text-align: center;"><code class="reqn">
	C(r) = \sigma^2 (1 + (x/h)^\alpha)^{-\beta/\alpha}
      </code>
</p>

<p>where <code class="reqn">\sigma^2</code> is the variance parameter <code>var</code>,
<code class="reqn">h</code> is the scale parameter <code>scale</code>,
and <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> are the shape parameters
<code>alpha</code> and <code>beta</code>.
The parameters <code>alpha</code> and <code>beta</code>
must be given, either as stand-alone arguments, or as entries
in the list <code>param</code>.
</p>
</dd>
<dt><code>model="matern"</code>:</dt><dd>
<p>the Whittle-Matern covariance function
</p>
<p style="text-align: center;"><code class="reqn">
	C(r) = \sigma^2 \frac{1}{2^{\nu-1} \Gamma(\nu)}
	       (\sqrt{2 \nu} \, r/h)^\nu K_\nu(\sqrt{2\nu}\, r/h)
      </code>
</p>

<p>where <code class="reqn">\sigma^2</code> is the variance parameter <code>var</code>,
<code class="reqn">h</code> is the scale parameter <code>scale</code>,
and <code class="reqn">\nu</code> is the shape parameter <code>nu</code>.
The parameter <code>nu</code> must be given, either as a stand-alone
argument, or as an entry in the list <code>param</code>.
</p>
</dd>
</dl>

<p>The algorithm uses the circulant embedding technique to 
generate values of a Gaussian random field,
with the specified mean function <code>mu</code>
and the covariance specified by the arguments <code>model</code> and
<code>param</code>, on the points of a regular grid. The exponential
of this random field is taken as the intensity of a Poisson point
process, and a realisation of the Poisson process is then generated by the 
function <code><a href="#topic+rpoispp">rpoispp</a></code> in the <span class="pkg">spatstat.random</span> package.
</p>
<p>If the simulation window <code>win</code> is missing or <code>NULL</code>,
then it defaults to 
<code>Window(mu)</code> if <code>mu</code> is a pixel image,
and it defaults to the unit square otherwise.
</p>
<p>The LGCP model can be fitted to data using <code><a href="spatstat.model.html#topic+kppm">kppm</a></code>.
</p>


<h3>Value</h3>

<p>A point pattern (object of class <code>"ppp"</code>)
or a list of point patterns.
</p>
<p>Additionally, the simulated intensity function for each point pattern is
returned as an attribute <code>"Lambda"</code> of the point pattern,
if <code>saveLambda=TRUE</code>.
</p>


<h3>Warning: new implementation</h3>

<p>The simulation algorithm for <code>rLGCP</code> has been completely re-written
in <span class="pkg">spatstat.random</span> version <code>3.2-0</code> to avoid depending on
the package <span class="pkg">RandomFields</span> which is now defunct (and is sadly missed).
</p>
<p>It is no longer possible to replicate results that were obtained using
<code>rLGCP</code> in previous versions of <span class="pkg">spatstat.random</span>.
</p>
<p>The current code is a new implementation and should be considered
vulnerable to new bugs. 
</p>


<h3>Author(s)</h3>

<p>Abdollah Jalilian and Rasmus Waagepetersen.
Modified by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Moller, J., Syversveen, A. and Waagepetersen, R. (1998)
Log Gaussian Cox Processes.
<em>Scandinavian Journal of Statistics</em> <b>25</b>, 451&ndash;482.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpoispp">rpoispp</a></code>,
<code><a href="#topic+rMatClust">rMatClust</a></code>,
<code><a href="#topic+rGaussPoisson">rGaussPoisson</a></code>,
<code><a href="#topic+rNeymanScott">rNeymanScott</a></code>.
</p>
<p>For fitting the model, see <code><a href="spatstat.model.html#topic+kppm">kppm</a></code>,
<code><a href="spatstat.model.html#topic+lgcp.estK">lgcp.estK</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    online &lt;- interactive()

    # homogeneous LGCP with exponential covariance function
    X &lt;- rLGCP("exp", 3, var=0.2, scale=.1)

    # inhomogeneous LGCP with Gaussian covariance function
    m &lt;- as.im(function(x, y){5 - 1.5 * (x - 0.5)^2 + 2 * (y - 0.5)^2}, W=owin())
    X &lt;- rLGCP("gauss", m, var=0.15, scale =0.1)

    if(online) {
     plot(attr(X, "Lambda"))
     points(X)
    }

    # inhomogeneous LGCP with Matern covariance function
    X &lt;- rLGCP("matern", function(x, y){ 1 - 0.4 * x},
               var=2, scale=0.7, nu=0.5,
               win = owin(c(0, 10), c(0, 10)))
    if(online) plot(X)
</code></pre>

<hr>
<h2 id='rMatClust'>Simulate Matern Cluster Process</h2><span id='topic+rMatClust'></span>

<h3>Description</h3>

<p>Generate a random point pattern, a simulated realisation of the
Matern Cluster Process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> rMatClust(kappa, scale, mu, win = square(1),
           nsim=1, drop=TRUE, ...,
           n.cond=NULL, w.cond=NULL,
           algorithm=c("BKBC", "naive"),
           nonempty=TRUE, 
           poisthresh=1e-6, saveparents=FALSE, saveLambda=FALSE,
           kappamax=NULL, mumax=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rMatClust_+3A_kappa">kappa</code></td>
<td>

<p>Intensity of the Poisson process of cluster centres.
A single positive number, a function, or a pixel image.
</p>
</td></tr>
<tr><td><code id="rMatClust_+3A_scale">scale</code></td>
<td>

<p>Radius of the clusters. A single positive number.
</p>
</td></tr>
<tr><td><code id="rMatClust_+3A_mu">mu</code></td>
<td>

<p>Mean number of points per cluster (a single positive number)
or reference intensity for the cluster points (a function or
a pixel image).
</p>
</td></tr>
<tr><td><code id="rMatClust_+3A_win">win</code></td>
<td>

<p>Window in which to simulate the pattern.
An object of class <code>"owin"</code>
or something acceptable to <code><a href="spatstat.geom.html#topic+as.owin">as.owin</a></code>.
</p>
</td></tr>
<tr><td><code id="rMatClust_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rMatClust_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
<tr><td><code id="rMatClust_+3A_...">...</code></td>
<td>

<p>Passed to <code><a href="#topic+clusterfield">clusterfield</a></code> to control the image
resolution when <code>saveLambda=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="rMatClust_+3A_n.cond">n.cond</code></td>
<td>

<p>Optional. Integer specifying a fixed number of points.
See the section on <em>Conditional Simulation</em>.
</p>
</td></tr>
<tr><td><code id="rMatClust_+3A_w.cond">w.cond</code></td>
<td>

<p>Optional. Conditioning region. A window (object of class <code>"owin"</code>)
specifying the region which must contain exactly <code>n.cond</code> points.
See the section on <em>Conditional Simulation</em>.
</p>
</td></tr>
<tr><td><code id="rMatClust_+3A_algorithm">algorithm</code></td>
<td>

<p>String (partially matched) specifying the simulation algorithm.
See Details.
</p>
</td></tr>
<tr><td><code id="rMatClust_+3A_nonempty">nonempty</code></td>
<td>

<p>Logical. If <code>TRUE</code> (the default), a more efficient algorithm is
used, in which parents are generated conditionally on having at
least one offspring point in the window.
If <code>FALSE</code>, parents are generated
even if they have no offspring in the window. The default
is recommended unless you need to simulate all the parent points
for some other purpose.
</p>
</td></tr>
<tr><td><code id="rMatClust_+3A_poisthresh">poisthresh</code></td>
<td>

<p>Numerical threshold below which the model will be treated
as a Poisson process. See Details.
</p>
</td></tr>
<tr><td><code id="rMatClust_+3A_saveparents">saveparents</code></td>
<td>

<p>Logical value indicating whether to save the locations of the
parent points as an attribute.
</p>
</td></tr>
<tr><td><code id="rMatClust_+3A_savelambda">saveLambda</code></td>
<td>

<p>Logical. If <code>TRUE</code> then the random intensity corresponding to
the simulated parent points will also be calculated and saved,
and returns as an attribute of the point pattern.
</p>
</td></tr>
<tr><td><code id="rMatClust_+3A_kappamax">kappamax</code></td>
<td>

<p>Optional. Numerical value which is an upper bound for the
values of <code>kappa</code>, when <code>kappa</code> is a pixel image or a
function.
</p>
</td></tr>
<tr><td><code id="rMatClust_+3A_mumax">mumax</code></td>
<td>

<p>Optional. Numerical value which is an upper bound for the
values of <code>mu</code>, when <code>mu</code> is a pixel image or a
function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm generates a realisation of
Matern's cluster process,
a special case of the Neyman-Scott process, inside the window <code>win</code>.
</p>
<p>In the simplest case, where <code>kappa</code> and <code>mu</code>
are single numbers, the cluster process is formed by first
generating a uniform Poisson point process of &ldquo;parent&rdquo; points 
with intensity <code>kappa</code>. Then each parent point is
replaced by a random cluster of &ldquo;offspring&rdquo; points,
the number of points per cluster being Poisson (<code>mu</code>)
distributed, and their
positions being placed and uniformly inside
a disc of radius <code>scale</code> centred on the parent point.
The resulting point pattern
is a realisation of the classical
&ldquo;stationary Matern cluster process&rdquo;.
This point process has intensity <code>kappa * mu</code>.
</p>
<p>The algorithm can also generate spatially inhomogeneous versions of
the Matern cluster process:
</p>

<ul>
<li><p> The parent points can be spatially inhomogeneous.
If the argument <code>kappa</code> is a <code>function(x,y)</code>
or a pixel image (object of class <code>"im"</code>), then it is taken
as specifying the intensity function of an inhomogeneous Poisson
process that generates the parent points.
</p>
</li>
<li><p> The offspring points can be inhomogeneous. If the
argument <code>mu</code> is a <code>function(x,y)</code>
or a pixel image (object of class <code>"im"</code>), then it is
interpreted as the reference density for offspring points,
in the sense of Waagepetersen (2007).
For a given parent point, the offspring constitute a Poisson process
with intensity function equal to 
<code>mu/(pi * scale^2)</code>
inside the disc of radius <code>scale</code> centred on the parent
point, and zero intensity outside this disc.
Equivalently we first generate,
for each parent point, a Poisson (<code class="reqn">M</code>) random number of
offspring (where <code class="reqn">M</code> is the maximum value of <code>mu</code>)
placed independently and uniformly in the disc of radius <code>scale</code>
centred on the parent location, and then randomly thin the
offspring points, with retention probability <code>mu/M</code>.
</p>
</li>
<li>
<p>Both the parent points and the offspring points can be
inhomogeneous, as described above.
</p>
</li></ul>

<p>The intensity of the Matern cluster
process is <code>kappa * mu</code>
if either <code>kappa</code> or <code>mu</code> is a single number. In the general
case the intensity is an integral involving <code>kappa</code>, <code>mu</code>
and <code>scale</code>.
</p>


<h3>Value</h3>

<p>A point pattern (an object of class <code>"ppp"</code>) if <code>nsim=1</code>,
or a list of point patterns if <code>nsim &gt; 1</code>.
</p>
<p>Additionally, some intermediate results of the simulation are returned
as attributes of this point pattern (see <code><a href="#topic+rNeymanScott">rNeymanScott</a></code>).
Furthermore, the simulated intensity
function is returned as an attribute <code>"Lambda"</code>, if
<code>saveLambda=TRUE</code>.
</p>


<h3>Simulation Algorithm</h3>

<p>Two simulation algorithms are implemented.
</p>

<ul>
<li><p> The <em>naive</em> algorithm generates the cluster process 
by directly following the description given above. First the window
<code>win</code> is expanded by a distance equal to <code>scale</code>.
Then the parent points are generated in the expanded window according to
a Poisson process with intensity <code>kappa</code>. Then each parent
point is replaced by a finite cluster of offspring points as
described above.
The naive algorithm is used if <code>algorithm="naive"</code> or if
<code>nonempty=FALSE</code>.
</p>
</li>
<li><p> The <em>BKBC</em> algorithm, proposed by Baddeley and Chang
(2023), is a modification of the algorithm of Brix and Kendall (2002). 
Parents are generated in the infinite plane, subject to the
condition that they have at least one offspring point inside the
window <code>win</code>.
The BKBC algorithm is used when <code>algorithm="BKBC"</code> (the default)
and <code>nonempty=TRUE</code> (the default).
</p>
</li></ul>

<p>The naive algorithm becomes very slow when <code>scale</code> is large,
while the BKBC algorithm is uniformly fast (Baddeley and Chang, 2023).
</p>
<p>If <code>saveparents=TRUE</code>, then the simulated point pattern will
have an attribute <code>"parents"</code> containing the coordinates of the
parent points, and an attribute <code>"parentid"</code> mapping each
offspring point to its parent.
</p>
<p>If <code>nonempty=TRUE</code> (the default), then parents are generated
subject to the condition that they have at least one offspring point 
in the window <code>win</code>. 
<code>nonempty=FALSE</code>, then parents without offspring will be included;
this option is not available in the <em>BKBC</em> algorithm.
</p>
<p>Note that if <code>kappa</code> is a pixel image, its domain must be larger
than the window <code>win</code>. This is because an offspring point inside
<code>win</code> could have its parent point lying outside <code>win</code>.
In order to allow this, the naive simulation algorithm
first expands the original window <code>win</code>
by a distance equal to <code>scale</code> and generates the Poisson process of
parent points on this larger window. If <code>kappa</code> is a pixel image,
its domain must contain this larger window.
</p>
<p>If the pair correlation function of the model is very close
to that of a Poisson process, with maximum deviation less than
<code>poisthresh</code>, then the model is approximately a Poisson process.
This is detected by the naive algorithm which then
simulates a Poisson process with intensity
<code>kappa * mu</code>, using <code><a href="#topic+rpoispp">rpoispp</a></code>. 
This avoids computations that would otherwise require huge amounts
of memory.
</p>


<h3>Fitting cluster models to data</h3>

<p>The Matern cluster process model with homogeneous parents
(i.e. where <code>kappa</code> is a single number)
where the offspring are either homogeneous or inhomogeneous (<code>mu</code>
is a single number, a function or pixel image)
can be fitted to point pattern data using <code><a href="spatstat.model.html#topic+kppm">kppm</a></code>,
or fitted to the inhomogeneous <code class="reqn">K</code> function
using <code><a href="spatstat.model.html#topic+matclust.estK">matclust.estK</a></code>
or <code><a href="spatstat.model.html#topic+matclust.estpcf">matclust.estpcf</a></code>.
</p>
<p>Currently <span class="pkg">spatstat</span> does not support fitting the
Matern cluster process model
with inhomogeneous parents.
</p>
<p>A fitted Matern cluster process model can be simulated automatically
using   <code><a href="spatstat.model.html#topic+simulate.kppm">simulate.kppm</a></code>
(which invokes <code>rMatClust</code> to perform the simulation).
</p>


<h3>Conditional Simulation</h3>

<p>If <code>n.cond</code> is specified, it should be a single integer.
Simulation will be conditional on the event 
that the pattern contains exactly <code>n.cond</code> points
(or contains exactly <code>n.cond</code> points inside
the region <code>w.cond</code> if it is given).
</p>
<p>Conditional simulation uses the rejection algorithm described
in Section 6.2 of Moller, Syversveen and Waagepetersen (1998).
There is a maximum number of proposals which will be attempted.
Consequently the return value may contain fewer
than <code>nsim</code> point patterns.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Ya-Mei Chang <a href="mailto:yamei628@gmail.com">yamei628@gmail.com</a> and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. and Chang, Y.-M. (2023) Robust algorithms for simulating cluster point processes. <em>Journal of Statistical Computation and Simulation</em>. In Press. DOI <code>10.1080/00949655.2023.2166045</code>.
</p>
<p>Brix, A. and Kendall, W.S. (2002)
Simulation of cluster point processes without edge effects.
<em>Advances in Applied Probability</em> <b>34</b>, 267&ndash;280.
</p>
<p>Matern, B. (1960)
<em>Spatial Variation</em>.
Meddelanden fraan
Statens Skogsforskningsinstitut,
volume 59, number 5.  Statens Skogsforskningsinstitut, Sweden.
</p>
<p>Matern, B. (1986)
<em>Spatial Variation</em>.
Lecture Notes in Statistics 36, Springer-Verlag, New York.
</p>
<p>Moller, J., Syversveen, A. and Waagepetersen, R. (1998)
Log Gaussian Cox Processes.
<em>Scandinavian Journal of Statistics</em> <b>25</b>, 451&ndash;482.
</p>
<p>Waagepetersen, R. (2007)
An estimating function approach to inference for
inhomogeneous Neyman-Scott processes.
<em>Biometrics</em> <b>63</b>, 252&ndash;258.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpoispp">rpoispp</a></code>, 
<code><a href="#topic+rThomas">rThomas</a></code>, 
<code><a href="#topic+rCauchy">rCauchy</a></code>, 
<code><a href="#topic+rVarGamma">rVarGamma</a></code>, 
<code><a href="#topic+rNeymanScott">rNeymanScott</a></code>, 
<code><a href="#topic+rGaussPoisson">rGaussPoisson</a></code>.
</p>
<p>For fitting the model, see 
<code><a href="spatstat.model.html#topic+kppm">kppm</a></code>,
<code><a href="spatstat.model.html#topic+clusterfit">clusterfit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # homogeneous
 X &lt;- rMatClust(10, 0.05, 4)
 # inhomogeneous
 ff &lt;- function(x,y){ 4 * exp(2 * abs(x) - 1) }
 Z &lt;- as.im(ff, owin())
 Y &lt;- rMatClust(10, 0.05, Z)
 YY &lt;- rMatClust(ff, 0.05, 3)
</code></pre>

<hr>
<h2 id='rMaternI'>Simulate Matern Model I</h2><span id='topic+rMaternI'></span>

<h3>Description</h3>

<p>Generate a random point pattern, a simulated realisation of the
Matern Model I inhibition process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> rMaternI(kappa, r, win = owin(c(0,1),c(0,1)), stationary=TRUE, ...,
          nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rMaternI_+3A_kappa">kappa</code></td>
<td>

<p>Intensity of the Poisson process of proposal points.
A single positive number.
</p>
</td></tr>
<tr><td><code id="rMaternI_+3A_r">r</code></td>
<td>

<p>Inhibition distance.
</p>
</td></tr>
<tr><td><code id="rMaternI_+3A_win">win</code></td>
<td>

<p>Window in which to simulate the pattern.
An object of class <code>"owin"</code>
or something acceptable to <code>as.owin</code>.
Alternatively a higher-dimensional box of class
<code>"box3"</code> or <code>"boxx"</code>.
</p>
</td></tr>
<tr><td><code id="rMaternI_+3A_stationary">stationary</code></td>
<td>

<p>Logical. Whether to start with a stationary process of proposal points
(<code>stationary=TRUE</code>) or to generate the
proposal points only inside the window (<code>stationary=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="rMaternI_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="rMaternI_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rMaternI_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm generates one or more realisations
of Matern's Model I
inhibition process inside the window <code>win</code>.
</p>
<p>The process is constructed by first
generating a uniform Poisson point process of &ldquo;proposal&rdquo; points 
with intensity <code>kappa</code>. If <code>stationary = TRUE</code> (the
default), the proposal points are generated in a window larger than
<code>win</code> that effectively means the proposals are stationary.
If <code>stationary=FALSE</code> then the proposal points are
only generated inside the window <code>win</code>.
</p>
<p>A proposal point is then deleted if it lies within <code>r</code> units' distance
of another proposal point. Otherwise it is retained.
</p>
<p>The retained points constitute Matern's Model I.
</p>


<h3>Value</h3>

<p>A point pattern
if <code>nsim=1</code>, or a list of point patterns if <code>nsim &gt; 1</code>.
Each point pattern is normally an object of class <code>"ppp"</code>,
but may be of class <code>"pp3"</code> or <code>"ppx"</code> depending on the window.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>,
Ute Hahn,
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpoispp">rpoispp</a></code>,
<code><a href="#topic+rMatClust">rMatClust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> X &lt;- rMaternI(20, 0.05)
 Y &lt;- rMaternI(20, 0.05, stationary=FALSE)
</code></pre>

<hr>
<h2 id='rMaternII'>Simulate Matern Model II</h2><span id='topic+rMaternII'></span>

<h3>Description</h3>

<p>Generate a random point pattern, a simulated realisation of the
Matern Model II inhibition process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> rMaternII(kappa, r, win = owin(c(0,1),c(0,1)), stationary=TRUE, ...,
           nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rMaternII_+3A_kappa">kappa</code></td>
<td>

<p>Intensity of the Poisson process of proposal points.
A single positive number.
</p>
</td></tr>
<tr><td><code id="rMaternII_+3A_r">r</code></td>
<td>

<p>Inhibition distance.
</p>
</td></tr>
<tr><td><code id="rMaternII_+3A_win">win</code></td>
<td>

<p>Window in which to simulate the pattern.
An object of class <code>"owin"</code>
or something acceptable to <code>as.owin</code>.
Alternatively a higher-dimensional box of class
<code>"box3"</code> or <code>"boxx"</code>.
</p>
</td></tr>
<tr><td><code id="rMaternII_+3A_stationary">stationary</code></td>
<td>

<p>Logical. Whether to start with a stationary process of proposal points
(<code>stationary=TRUE</code>) or to generate the
proposal points only inside the window (<code>stationary=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="rMaternII_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="rMaternII_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rMaternII_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm generates one or more realisations
of Matern's Model II
inhibition process inside the window <code>win</code>.
</p>
<p>The process is constructed by first
generating a uniform Poisson point process of &ldquo;proposal&rdquo; points 
with intensity <code>kappa</code>. If <code>stationary = TRUE</code> (the
default), the proposal points are generated in a window larger than
<code>win</code> that effectively means the proposals are stationary.
If <code>stationary=FALSE</code> then the proposal points are
only generated inside the window <code>win</code>.
</p>
<p>Then each proposal point is marked by an &ldquo;arrival time&rdquo;, a number
uniformly distributed in <code class="reqn">[0,1]</code> independently of other variables.
</p>
<p>A proposal point is deleted if it lies within <code>r</code> units' distance
of another proposal point <em>that has an earlier arrival time</em>.
Otherwise it is retained.
The retained points constitute Matern's Model II.
</p>
<p>The difference between Matern's Model I and II is the italicised
statement above. Model II has a higher intensity
for the same parameter values.
</p>


<h3>Value</h3>

<p>A point pattern
if <code>nsim=1</code>, or a list of point patterns if <code>nsim &gt; 1</code>.
Each point pattern is normally an object of class <code>"ppp"</code>,
but may be of class <code>"pp3"</code> or <code>"ppx"</code> depending on the window.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>,
Ute Hahn,
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpoispp">rpoispp</a></code>,
<code><a href="#topic+rMatClust">rMatClust</a></code>,
<code><a href="#topic+rMaternI">rMaternI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> X &lt;- rMaternII(20, 0.05)
 Y &lt;- rMaternII(20, 0.05, stationary=FALSE)
</code></pre>

<hr>
<h2 id='rmh'>Simulate point patterns using the Metropolis-Hastings algorithm.</h2><span id='topic+rmh'></span>

<h3>Description</h3>

<p>Generic function for running the Metropolis-Hastings algorithm
to produce simulated realisations of a point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmh(model, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmh_+3A_model">model</code></td>
<td>
<p>The point process model to be simulated.
</p>
</td></tr>
<tr><td><code id="rmh_+3A_...">...</code></td>
<td>
<p>Further arguments controlling the simulation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Metropolis-Hastings algorithm can be used to
generate simulated realisations from a wide range of
spatial point processes. For caveats, see below.
</p>
<p>The function <code>rmh</code> is generic; it has methods
<code><a href="spatstat.model.html#topic+rmh.ppm">rmh.ppm</a></code> (for objects of class <code>"ppm"</code>)
and  <code><a href="#topic+rmh.default">rmh.default</a></code> (the default).
The actual implementation of the Metropolis-Hastings algorithm is
contained in <code><a href="#topic+rmh.default">rmh.default</a></code>.
For details of its use, see 
<code><a href="spatstat.model.html#topic+rmh.ppm">rmh.ppm</a></code> or <code><a href="#topic+rmh.default">rmh.default</a></code>.
</p>
<p>[If the model is a Poisson process, then Metropolis-Hastings
is not used; the Poisson model is generated directly
using <code><a href="#topic+rpoispp">rpoispp</a></code> or <code><a href="#topic+rmpoispp">rmpoispp</a></code>.]
</p>
<p>In brief, the Metropolis-Hastings algorithm is a Markov Chain,
whose states are spatial point patterns, and whose limiting
distribution is the desired point process. After
running the algorithm for a very large number of iterations,
we may regard the state of the algorithm as a realisation
from the desired point process.
</p>
<p>However, there are difficulties in deciding whether the
algorithm has run for &ldquo;long enough&rdquo;. The convergence of the
algorithm may indeed be extremely slow. No guarantees of
convergence are given!
</p>
<p>While it is fashionable to decry the Metropolis-Hastings algorithm
for its poor convergence and other properties, it has the advantage
of being easy to implement for a wide range of models.
</p>


<h3>Value</h3>

<p>A point pattern, in the form of an object of class <code>"ppp"</code>.
See <code><a href="#topic+rmh.default">rmh.default</a></code> for details.
</p>


<h3>Warning</h3>

<p>As of version 1.22-1 of <code>spatstat</code> a subtle change was
made to <code>rmh.default()</code>.  We had noticed that the results
produced were sometimes not &ldquo;scalable&rdquo; in that two models,
differing in effect only by the units in which distances are
measured and starting from the same seed, gave different results.
This was traced to an idiosyncracy of floating point arithmetic.
The code of <code>rmh.default()</code> has been changed so that the
results produced by <code>rmh</code> are now scalable.  The downside of
this is that code which users previously ran may now give results
which are different from what they formerly were.
</p>
<p>In order to recover former behaviour (so that previous results
can be reproduced) set <code>spatstat.options(scalable=FALSE)</code>.
See the last example in the help for <code><a href="#topic+rmh.default">rmh.default</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmh.default">rmh.default</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # See examples in rmh.default and rmh.ppm
</code></pre>

<hr>
<h2 id='rmh.default'>Simulate Point Process Models using the Metropolis-Hastings Algorithm.</h2><span id='topic+rmh.default'></span>

<h3>Description</h3>

<p>Generates a random point pattern, simulated from
a chosen point process model, using the Metropolis-Hastings
algorithm. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## Default S3 method:
rmh(model, start=NULL,
   control=default.rmhcontrol(model),
   ...,
   nsim=1, drop=TRUE, saveinfo=TRUE,
   verbose=TRUE, snoop=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmh.default_+3A_model">model</code></td>
<td>
<p>Data specifying the point process model
that is to be simulated.
</p>
</td></tr>
<tr><td><code id="rmh.default_+3A_start">start</code></td>
<td>
<p>Data determining the initial state of
the algorithm.
</p>
</td></tr>
<tr><td><code id="rmh.default_+3A_control">control</code></td>
<td>
<p>Data controlling the iterative behaviour
and termination of the algorithm.
</p>
</td></tr>
<tr><td><code id="rmh.default_+3A_...">...</code></td>
<td>

<p>Further arguments passed to <code><a href="#topic+rmhcontrol">rmhcontrol</a></code>
or to trend functions in <code>model</code>.
</p>
</td></tr>
<tr><td><code id="rmh.default_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulated point patterns that should be generated.
</p>
</td></tr>
<tr><td><code id="rmh.default_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a single point pattern.
</p>
</td></tr>
<tr><td><code id="rmh.default_+3A_saveinfo">saveinfo</code></td>
<td>

<p>Logical value indicating whether to save auxiliary information.
</p>
</td></tr>
<tr><td><code id="rmh.default_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print progress reports.
</p>
</td></tr>
<tr><td><code id="rmh.default_+3A_snoop">snoop</code></td>
<td>

<p>Logical. If <code>TRUE</code>, activate the visual debugger. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates simulated realisations from any of a range of
spatial point processes, using the Metropolis-Hastings algorithm.
It is the default method for the generic function <code><a href="#topic+rmh">rmh</a></code>.
</p>
<p>This function executes a Metropolis-Hastings algorithm
with birth, death and shift proposals as described in
Geyer and Moller (1994).
</p>
<p>The argument <code>model</code> specifies the point process model to be
simulated. It is either a list, or an object of class
<code>"rmhmodel"</code>, with the following components:
</p>

<dl>
<dt>cif</dt><dd><p>A character string specifying the choice of
interpoint interaction for the point process.
</p>
</dd>
<dt>par</dt><dd>
<p>Parameter values for the conditional
intensity function.
</p>
</dd>
<dt>w</dt><dd>
<p>(Optional) window in which the pattern is
to be generated. An object of class <code>"owin"</code>,
or data acceptable to <code>as.owin</code>.
</p>
</dd>
<dt>trend</dt><dd>
<p>Data specifying the spatial trend in the model, if it has a trend.
This may be a function, a pixel image (of class <code>"im"</code>),
(or a list of functions or images if the model
is multitype).
</p>
<p>If the trend is a function or functions,
any auxiliary arguments <code>...</code> to <code>rmh.default</code>
will be passed to these functions, which
should be of the form <code>function(x, y, ...)</code>.
</p>
</dd>
<dt>types</dt><dd>
<p>List of possible types, for a multitype point process.
</p>
</dd>
</dl>

<p>For full details of these parameters, see <code><a href="#topic+rmhmodel.default">rmhmodel.default</a></code>.
</p>
<p>The argument <code>start</code> determines the initial state of the
Metropolis-Hastings algorithm. It is either <code>NULL</code>,
or an object of class <code>"rmhstart"</code>,
or a list with the following components:
</p>

<dl>
<dt>n.start</dt><dd>
<p>Number of points in the initial point pattern.
A single integer, or a vector of integers giving the
numbers of points of each type in a multitype point pattern.
Incompatible with <code>x.start</code>.
</p>
</dd>
<dt>x.start</dt><dd>
<p>Initial point pattern configuration.
Incompatible with <code>n.start</code>.
</p>
<p><code>x.start</code> may be a point pattern (an
object of class <code>"ppp"</code>), or data which can be coerced
to this class by <code>as.ppp</code>,  or an object with
components <code>x</code> and <code>y</code>, or a two-column matrix.
In the last two cases, the window for the pattern is determined
by <code>model$w</code>.
In the first two cases, if <code>model$w</code> is also present,
then the final simulated pattern will be clipped to
the window <code>model$w</code>.
</p>
</dd>
</dl>

<p>For full details of these parameters, see <code><a href="#topic+rmhstart">rmhstart</a></code>.
</p>
<p>The third argument <code>control</code> controls the simulation
procedure (including <em>conditional simulation</em>),
iterative behaviour, and termination of the
Metropolis-Hastings algorithm. It is either <code>NULL</code>, or
a list, or an object of class <code>"rmhcontrol"</code>, with components:
</p>

<dl>
<dt>p</dt><dd><p>The probability of proposing a &ldquo;shift&rdquo;
(as opposed to a birth or death) in the Metropolis-Hastings
algorithm.
</p>
</dd>
<dt>q</dt><dd><p>The conditional probability of proposing a death
(rather than a birth)
given that birth/death has been chosen over shift.  
</p>
</dd>
<dt>nrep</dt><dd><p>The number of repetitions or iterations
to be made by the Metropolis-Hastings algorithm.  It should
be large.
</p>
</dd>
<dt>expand</dt><dd>
<p>Either a numerical expansion factor, or
a window (object of class <code>"owin"</code>). Indicates that
the process is to be simulated on a larger domain than the
original data window <code>w</code>, then clipped to <code>w</code>
when the algorithm has finished.
</p>
<p>The default is to expand the simulation window
if the model is stationary and non-Poisson
(i.e. it has no trend and the interaction is not Poisson)
and not to expand in all other cases. 
</p>
<p>If the model has a trend, then in order for expansion to
be feasible, the trend must be given either as a function,
or an image whose bounding box is large enough to contain
the expanded window.
</p>
</dd>
<dt>periodic</dt><dd><p>A logical scalar; if <code>periodic</code> is <code>TRUE</code>
we simulate a process on the torus formed by identifying
opposite edges of a rectangular window.  
</p>
</dd>
<dt>ptypes</dt><dd><p>A vector of probabilities (summing to 1) to be used
in assigning a random type to a new point.
</p>
</dd>
<dt>fixall</dt><dd><p>A logical scalar specifying whether to condition on
the number of points of each type.
</p>
</dd>
<dt>nverb</dt><dd><p>An integer specifying how often &ldquo;progress reports&rdquo;
(which consist simply of the number of repetitions completed)
should be printed out.  If nverb is left at 0, the default,
the simulation proceeds silently.
</p>
</dd>
<dt>x.cond</dt><dd><p>If this argument is present, then
<em>conditional simulation</em> will be performed, and <code>x.cond</code>
specifies the conditioning points and the type of conditioning.
</p>
</dd>
<dt>nsave,nburn</dt><dd>
<p>If these values are specified, then
intermediate states of the simulation algorithm will be saved
every <code>nsave</code> iterations, after an initial burn-in period of
<code>nburn</code> iterations.
</p>
</dd>
<dt>track</dt><dd>
<p>Logical flag indicating whether to save the transition
history of the simulations.
</p>
</dd>
</dl>

<p>For full details of these parameters, see <code><a href="#topic+rmhcontrol">rmhcontrol</a></code>.
The control parameters can also be given in the <code>...</code> arguments.
</p>


<h3>Value</h3>

<p>A point pattern (an object of class <code>"ppp"</code>, see
<code>ppp.object</code>) or a list of point patterns.
</p>
<p>The returned value has an attribute <code>info</code> containing
modified versions of the arguments
<code>model</code>, <code>start</code>, and <code>control</code> which together specify
the exact simulation procedure. The <code>info</code> attribute can be
printed (and is printed automatically by <code>summary.ppp</code>).
For computational efficiency, the <code>info</code> attribute can be omitted
by setting <code>saveinfo=FALSE</code>.
</p>
<p>The value of <code><a href="base.html#topic+Random">.Random.seed</a></code> at the start
of the simulations is also saved and returned as an attribute
<code>seed</code>.
</p>
<p>If the argument <code>track=TRUE</code> was given (see <code><a href="#topic+rmhcontrol">rmhcontrol</a></code>),
the transition history of the algorithm
is saved, and returned as an attribute <code>history</code>. The transition
history is a data frame containing a factor <code>proposaltype</code>
identifying the proposal type (Birth, Death or Shift) and
a logical vector <code>accepted</code> indicating whether the proposal was
accepted.
The data frame also has columns <code>numerator</code>, <code>denominator</code>
which give the numerator and denominator of the Hastings ratio for
the proposal.
</p>
<p>If the argument <code>nsave</code> was given (see <code><a href="#topic+rmhcontrol">rmhcontrol</a></code>),
the return value has an attribute <code>saved</code> which is a list of
point patterns, containing the intermediate states of the algorithm.
</p>


<h3>Conditional Simulation</h3>

<p>There are several kinds of conditional simulation.
</p>

<ul>
<li>
<p>Simulation <em>conditional upon the number of points</em>,
that is, holding the number of points fixed.
To do this, set <code>control$p</code> (the probability of a shift) equal to 1.
The number of points is then determined by the starting state, which
may be specified either by setting <code>start$n.start</code> to be a
scalar, or by setting the initial pattern <code>start$x.start</code>.
</p>
</li>
<li> 
<p>In the case of multitype processes, it is possible to simulate the
model <em>conditionally upon the number of points of each type</em>,
i.e. holding the number of points of each type
to be fixed. To do this, set <code>control$p</code> equal to 1
and <code>control$fixall</code> to be <code>TRUE</code>.
The number of points is then determined by the starting state, which
may be specified either by setting <code>start$n.start</code> to be an
integer vector, or by setting the initial pattern <code>start$x.start</code>.
</p>
</li>
<li>
<p>Simulation 
<em>conditional on the configuration observed in a sub-window</em>,
that is, requiring that, inside a specified sub-window <code class="reqn">V</code>,
the simulated pattern should agree with a specified point pattern
<code class="reqn">y</code>.To do this, set <code>control$x.cond</code> to equal the
specified point pattern <code class="reqn">y</code>, making sure that it is an object of class
<code>"ppp"</code> and that the window <code>Window(control$x.cond)</code>
is the conditioning window <code class="reqn">V</code>.
</p>
</li>
<li>
<p>Simulation <em>conditional on the presence of specified points</em>,
that is, requiring that the simulated pattern should include a
specified set of points. This is simulation from the Palm
distribution of the point process given a pattern <code class="reqn">y</code>.
To do this, set <code>control$x.cond</code> to be a
<code>data.frame</code> containing the coordinates (and marks,
if appropriate) of the specified points.
</p>
</li></ul>

<p>For further information, see <code><a href="#topic+rmhcontrol">rmhcontrol</a></code>.
</p>
<p>Note that, when we simulate conditionally on the number of points, or
conditionally on the number of points of each type,
no expansion of the window is possible.
</p>


<h3>Visual Debugger</h3>

<p>If <code>snoop = TRUE</code>, an interactive debugger is activated.
On the current plot device, the debugger displays the current
state of the Metropolis-Hastings algorithm together with
the proposed transition to the next state.
Clicking on this graphical display (using the left mouse button)
will re-centre the display at the clicked location.
Surrounding this graphical display is an array of boxes representing
different actions.
Clicking on one of the action boxes (using the left mouse button)
will cause the action to be performed.
Debugger actions include:
</p>

<ul>
<li><p> Zooming in or out
</p>
</li>
<li><p> Panning (shifting the field of view) left, right, up or down
</p>
</li>
<li><p> Jumping to the next iteration
</p>
</li>
<li><p> Skipping 10, 100, 1000, 10000 or 100000 iterations
</p>
</li>
<li><p> Jumping to the next Birth proposal (etc)
</p>
</li>
<li><p> Changing the fate of the proposal (i.e. changing whether
the proposal is accepted or rejected)
</p>
</li>
<li><p> Dumping the current state and proposal to a file
</p>
</li>
<li><p> Printing detailed information at the terminal
</p>
</li>
<li><p> Exiting the debugger (so that the simulation
algorithm continues without further interruption).
</p>
</li></ul>

<p>Right-clicking the mouse will also cause the debugger to exit.
</p>


<h3>Warnings</h3>

<p>There is never a guarantee that the Metropolis-Hastings algorithm
has converged to its limiting distribution.
</p>
<p>If <code>start$x.start</code> is specified then <code>expand</code> is set equal to 1
and simulation takes place in <code>Window(x.start)</code>.  Any specified
value for <code>expand</code> is simply ignored.
</p>
<p>The presence of both a component <code>w</code> of <code>model</code> and a
non-null value for <code>Window(x.start)</code> makes sense ONLY if <code>w</code>
is contained in <code>Window(x.start)</code>.  
</p>
<p>For multitype processes make sure that, even if there is to be no
trend corresponding to a particular type, there is still a component
(a NULL component) for that type, in the list.
</p>


<h3>Other models</h3>

<p>In theory, any finite point process model can be simulated using
the Metropolis-Hastings algorithm, provided the conditional
intensity is uniformly bounded.
</p>
<p>In practice, the list of point process models that can be simulated using
<code>rmh.default</code> is limited to those that have been implemented
in the package's internal C code. More options will be added in the future.
</p>
<p>Note that the <code>lookup</code> conditional intensity function
permits the simulation (in theory, to any desired degree
of approximation) of any pairwise interaction process for
which the interaction depends only on the distance between
the pair of points.
</p>


<h3>Reproducible simulations</h3>

<p>If the user wants the simulation to be exactly reproducible
(e.g. for a figure in a journal article, where it is useful to
have the figure consistent from draft to draft) then the state of
the random number generator should be set before calling
<code>rmh.default</code>. This can be done either by calling
<code><a href="base.html#topic+Random">set.seed</a></code> or by assigning a value to
<code><a href="base.html#topic+Random">.Random.seed</a></code>. In the examples below, we use
<code><a href="base.html#topic+Random">set.seed</a></code>.  
</p>
<p>If a simulation has been performed and the user now wants to 
repeat it exactly, the random seed should be extracted from
the simulated point pattern <code>X</code> by <code>seed &lt;- attr(x, "seed")</code>,
then assigned to the system random nunber state by
<code>.Random.seed &lt;- seed</code> before calling <code>rmh.default</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A. and Turner, R. (2000) Practical maximum
pseudolikelihood for spatial point patterns.
<em>Australian and New Zealand Journal of Statistics</em>
<b>42</b>, 283 &ndash; 322.
</p>
<p>Diggle, P. J. (2003) <em>Statistical Analysis of Spatial Point
Patterns</em> (2nd ed.) Arnold, London.
</p>
<p>Diggle, P.J. and Gratton, R.J. (1984)
Monte Carlo methods of inference for implicit statistical models.
<em>Journal of the Royal Statistical Society, series B</em>
<b>46</b>, 193 &ndash; 212.
</p>
<p>Diggle, P.J., Gates, D.J., and Stibbard, A. (1987)
A nonparametric estimator for pairwise-interaction point processes.
Biometrika <b>74</b>, 763 &ndash; 770.
</p>
<p>Geyer, C.J. and Moller, J. (1994)
Simulation procedures and likelihood inference for spatial
point processes.
<em>Scandinavian Journal of Statistics</em> <b>21</b>, 359&ndash;373.
</p>
<p>Geyer, C.J. (1999)
Likelihood Inference for Spatial Point
Processes. Chapter 3 in  O.E. Barndorff-Nielsen, W.S. Kendall and
M.N.M. Van Lieshout (eds) <em>Stochastic Geometry: Likelihood and
Computation</em>, Chapman and Hall / CRC,  Monographs on Statistics and
Applied Probability, number 80. Pages 79&ndash;140.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmh">rmh</a></code>,
<code><a href="spatstat.model.html#topic+rmh.ppm">rmh.ppm</a></code>,
<code><a href="#topic+rStrauss">rStrauss</a></code>,
<code>ppp</code>,
<code><a href="spatstat.model.html#topic+ppm">ppm</a></code>
</p>
<p>Interactions: <code><a href="spatstat.model.html#topic+AreaInter">AreaInter</a></code>, <code><a href="spatstat.model.html#topic+BadGey">BadGey</a></code>, <code><a href="spatstat.model.html#topic+DiggleGatesStibbard">DiggleGatesStibbard</a></code>, <code><a href="spatstat.model.html#topic+DiggleGratton">DiggleGratton</a></code>, <code><a href="spatstat.model.html#topic+Fiksel">Fiksel</a></code>, <code><a href="spatstat.model.html#topic+Geyer">Geyer</a></code>, <code><a href="spatstat.model.html#topic+Hardcore">Hardcore</a></code>, <code><a href="spatstat.model.html#topic+Hybrid">Hybrid</a></code>, <code><a href="spatstat.model.html#topic+LennardJones">LennardJones</a></code>, <code><a href="spatstat.model.html#topic+MultiStrauss">MultiStrauss</a></code>, <code><a href="spatstat.model.html#topic+MultiStraussHard">MultiStraussHard</a></code>, <code><a href="spatstat.model.html#topic+PairPiece">PairPiece</a></code>, <code><a href="spatstat.model.html#topic+Penttinen">Penttinen</a></code>, <code><a href="spatstat.model.html#topic+Poisson">Poisson</a></code>, <code><a href="spatstat.model.html#topic+Softcore">Softcore</a></code>, <code><a href="spatstat.model.html#topic+Strauss">Strauss</a></code>, <code><a href="spatstat.model.html#topic+StraussHard">StraussHard</a></code> and <code><a href="spatstat.model.html#topic+Triplets">Triplets</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   if(interactive()) {
     nr   &lt;- 1e5
     nv  &lt;- 5000
     ns &lt;- 200
   } else {
     nr  &lt;- 20
     nv &lt;- 5
     ns &lt;- 20
     oldopt &lt;- spatstat.options()
     spatstat.options(expand=1.05)
   }
   set.seed(961018)
   
   # Strauss process.
   mod01 &lt;- list(cif="strauss",par=list(beta=2,gamma=0.2,r=0.7),
                 w=c(0,10,0,10))
   X1.strauss &lt;- rmh(model=mod01,start=list(n.start=ns),
                     control=list(nrep=nr,nverb=nv))

   if(interactive()) plot(X1.strauss)
   
   # Strauss process, conditioning on n = 42:
   X2.strauss &lt;- rmh(model=mod01,start=list(n.start=42),
                     control=list(p=1,nrep=nr,nverb=nv))

   # Tracking algorithm progress:
   # (a) saving intermediate states:
   X &lt;- rmh(model=mod01,start=list(n.start=ns),
            control=list(nrep=nr, nsave=nr/5, nburn=nr/2))
   Saved &lt;- attr(X, "saved")
   plot(Saved)

   # (b) inspecting transition history:
   X &lt;- rmh(model=mod01,start=list(n.start=ns),
            control=list(nrep=nr, track=TRUE))
   History &lt;- attr(X, "history")
   head(History)

   # Hard core process:
   mod02 &lt;- list(cif="hardcore",par=list(beta=2,hc=0.7),w=c(0,10,0,10))
   X3.hardcore &lt;- rmh(model=mod02,start=list(n.start=ns),
                     control=list(nrep=nr,nverb=nv))
   
   if(interactive()) plot(X3.hardcore)

   # Strauss process equal to pure hardcore:
   mod02s &lt;- list(cif="strauss",par=list(beta=2,gamma=0,r=0.7),w=c(0,10,0,10))
   X3.strauss &lt;- rmh(model=mod02s,start=list(n.start=ns),
                     control=list(nrep=nr,nverb=nv))
   
   # Strauss process in a polygonal window.
   x     &lt;- c(0.55,0.68,0.75,0.58,0.39,0.37,0.19,0.26,0.42)
   y     &lt;- c(0.20,0.27,0.68,0.99,0.80,0.61,0.45,0.28,0.33)
   mod03 &lt;- list(cif="strauss",par=list(beta=2000,gamma=0.6,r=0.07),
                w=owin(poly=list(x=x,y=y)))
   X4.strauss &lt;- rmh(model=mod03,start=list(n.start=ns),
                     control=list(nrep=nr,nverb=nv))
   if(interactive()) plot(X4.strauss)
   
   # Strauss process in a polygonal window, conditioning on n = 80.
   X5.strauss &lt;- rmh(model=mod03,start=list(n.start=ns),
                     control=list(p=1,nrep=nr,nverb=nv))
   
   # Strauss process, starting off from X4.strauss, but with the
   # polygonal window replace by a rectangular one.  At the end,
   # the generated pattern is clipped to the original polygonal window.
   xxx &lt;- X4.strauss
   Window(xxx) &lt;- as.owin(c(0,1,0,1))
   X6.strauss &lt;- rmh(model=mod03,start=list(x.start=xxx),
                     control=list(nrep=nr,nverb=nv))
   
   # Strauss with hardcore:
   mod04 &lt;- list(cif="straush",par=list(beta=2,gamma=0.2,r=0.7,hc=0.3),
                w=c(0,10,0,10))
   X1.straush &lt;- rmh(model=mod04,start=list(n.start=ns),
                     control=list(nrep=nr,nverb=nv))
   
   # Another Strauss with hardcore (with a perhaps surprising result):
   mod05 &lt;- list(cif="straush",par=list(beta=80,gamma=0.36,r=45,hc=2.5),
                w=c(0,250,0,250))
   X2.straush &lt;- rmh(model=mod05,start=list(n.start=ns),
                     control=list(nrep=nr,nverb=nv))
   
   # Pure hardcore (identical to X3.strauss).
   mod06 &lt;- list(cif="straush",par=list(beta=2,gamma=1,r=1,hc=0.7),
                w=c(0,10,0,10))
   X3.straush &lt;- rmh(model=mod06,start=list(n.start=ns),
                     control=list(nrep=nr,nverb=nv))
   
   # Soft core:
   w    &lt;- c(0,10,0,10)
   mod07 &lt;- list(cif="sftcr",par=list(beta=0.8,sigma=0.1,kappa=0.5),
                w=c(0,10,0,10))
   X.sftcr &lt;- rmh(model=mod07,start=list(n.start=ns),
                  control=list(nrep=nr,nverb=nv))
   if(interactive()) plot(X.sftcr)

   # Area-interaction process:
   mod42 &lt;- rmhmodel(cif="areaint",par=list(beta=2,eta=1.6,r=0.7),
                 w=c(0,10,0,10))
   X.area &lt;- rmh(model=mod42,start=list(n.start=ns),
                  control=list(nrep=nr,nverb=nv))
   if(interactive()) plot(X.area)

   # Triplets process
   modtrip &lt;- list(cif="triplets",par=list(beta=2,gamma=0.2,r=0.7),
                   w=c(0,10,0,10))
   X.triplets &lt;- rmh(model=modtrip,
                     start=list(n.start=ns),
                     control=list(nrep=nr,nverb=nv))
   if(interactive()) plot(X.triplets)
   
   # Multitype Strauss:
   beta &lt;- c(0.027,0.008)
   gmma &lt;- matrix(c(0.43,0.98,0.98,0.36),2,2)
   r    &lt;- matrix(c(45,45,45,45),2,2)
   mod08 &lt;- list(cif="straussm",par=list(beta=beta,gamma=gmma,radii=r),
                w=c(0,250,0,250))
   X1.straussm &lt;- rmh(model=mod08,start=list(n.start=ns),
                      control=list(ptypes=c(0.75,0.25),nrep=nr,nverb=nv))
   if(interactive()) plot(X1.straussm)
   
   # Multitype Strauss conditioning upon the total number
   # of points being 80:
   X2.straussm &lt;- rmh(model=mod08,start=list(n.start=ns),
                      control=list(p=1,ptypes=c(0.75,0.25),nrep=nr,
                                   nverb=nv))
   
   # Conditioning upon the number of points of type 1 being 60
   # and the number of points of type 2 being 20:
   X3.straussm &lt;- rmh(model=mod08,start=list(n.start=c(60,20)),
                      control=list(fixall=TRUE,p=1,ptypes=c(0.75,0.25),
                                   nrep=nr,nverb=nv))
   
   # Multitype Strauss hardcore:
   rhc  &lt;- matrix(c(9.1,5.0,5.0,2.5),2,2)
   mod09 &lt;- list(cif="straushm",par=list(beta=beta,gamma=gmma,
                iradii=r,hradii=rhc),w=c(0,250,0,250))
   X.straushm &lt;- rmh(model=mod09,start=list(n.start=ns),
                     control=list(ptypes=c(0.75,0.25),nrep=nr,nverb=nv))
   
   # Multitype Strauss hardcore with trends for each type:
   beta  &lt;- c(0.27,0.08)
   tr3   &lt;- function(x,y){x &lt;- x/250; y &lt;- y/250;
   			   exp((6*x + 5*y - 18*x^2 + 12*x*y - 9*y^2)/6)
                         }
                         # log quadratic trend
   tr4   &lt;- function(x,y){x &lt;- x/250; y &lt;- y/250;
                         exp(-0.6*x+0.5*y)}
                        # log linear trend
   mod10 &lt;- list(cif="straushm",par=list(beta=beta,gamma=gmma,
                 iradii=r,hradii=rhc),w=c(0,250,0,250),
                 trend=list(tr3,tr4))
   X1.straushm.trend &lt;- rmh(model=mod10,start=list(n.start=ns),
                            control=list(ptypes=c(0.75,0.25),
                            nrep=nr,nverb=nv))
   if(interactive()) plot(X1.straushm.trend)
   
   # Multitype Strauss hardcore with trends for each type, given as images:
   bigwin &lt;- square(250)
   i1 &lt;- as.im(tr3, bigwin)
   i2 &lt;- as.im(tr4, bigwin)   
   mod11 &lt;- list(cif="straushm",par=list(beta=beta,gamma=gmma,
                 iradii=r,hradii=rhc),w=bigwin,
                 trend=list(i1,i2))
   X2.straushm.trend &lt;- rmh(model=mod11,start=list(n.start=ns),
                            control=list(ptypes=c(0.75,0.25),expand=1,
                            nrep=nr,nverb=nv))
   
   # Diggle, Gates, and Stibbard:
   mod12 &lt;- list(cif="dgs",par=list(beta=3600,rho=0.08),w=c(0,1,0,1))
   X.dgs &lt;- rmh(model=mod12,start=list(n.start=ns),
                control=list(nrep=nr,nverb=nv))
   if(interactive()) plot(X.dgs)
   
   # Diggle-Gratton:
   mod13 &lt;- list(cif="diggra",
                 par=list(beta=1800,kappa=3,delta=0.02,rho=0.04),
                 w=square(1))
   X.diggra &lt;- rmh(model=mod13,start=list(n.start=ns),
                   control=list(nrep=nr,nverb=nv))
   if(interactive()) plot(X.diggra)
   
   # Fiksel:
   modFik &lt;- list(cif="fiksel",
                 par=list(beta=180,r=0.15,hc=0.07,kappa=2,a= -1.0),
                 w=square(1))
   X.fiksel &lt;- rmh(model=modFik,start=list(n.start=ns),
                   control=list(nrep=nr,nverb=nv))
   if(interactive()) plot(X.fiksel)
   
   # Geyer:
   mod14 &lt;- list(cif="geyer",par=list(beta=1.25,gamma=1.6,r=0.2,sat=4.5),
                 w=c(0,10,0,10))
   X1.geyer &lt;- rmh(model=mod14,start=list(n.start=ns),
                   control=list(nrep=nr,nverb=nv))
   if(interactive()) plot(X1.geyer)
   
   # Geyer; same as a Strauss process with parameters
   # (beta=2.25,gamma=0.16,r=0.7):
   
   mod15 &lt;- list(cif="geyer",par=list(beta=2.25,gamma=0.4,r=0.7,sat=10000),
                 w=c(0,10,0,10))
   X2.geyer &lt;- rmh(model=mod15,start=list(n.start=ns),
                   control=list(nrep=nr,nverb=nv))
   
   mod16 &lt;- list(cif="geyer",par=list(beta=8.1,gamma=2.2,r=0.08,sat=3))

   X3.geyer &lt;- rmh(model=mod16,start=list(x.start=redwood),
                   control=list(periodic=TRUE,nrep=nr,nverb=nv))
   
   # Geyer, starting from the redwood data set, simulating
   # on a torus, and conditioning on n:
   X4.geyer &lt;- rmh(model=mod16,start=list(x.start=redwood),
                   control=list(p=1,periodic=TRUE,nrep=nr,nverb=nv))

   # Lookup (interaction function h_2 from page 76, Diggle (2003)):
      r &lt;- seq(from=0,to=0.2,length=101)[-1] # Drop 0.
      h &lt;- 20*(r-0.05)
      h[r&lt;0.05] &lt;- 0
      h[r&gt;0.10] &lt;- 1
      mod17 &lt;- list(cif="lookup",par=list(beta=4000,h=h,r=r),w=c(0,1,0,1))
      X.lookup &lt;- rmh(model=mod17,start=list(n.start=ns),
                      control=list(nrep=nr,nverb=nv))
      if(interactive()) plot(X.lookup)
                   
   # Strauss with trend
   tr &lt;- function(x,y){x &lt;- x/250; y &lt;- y/250;
   			   exp((6*x + 5*y - 18*x^2 + 12*x*y - 9*y^2)/6)
                         }
   beta &lt;- 0.3
   gmma &lt;- 0.5
   r    &lt;- 45
   modStr &lt;- list(cif="strauss",par=list(beta=beta,gamma=gmma,r=r),
                 w=square(250), trend=tr)
   X1.strauss.trend &lt;- rmh(model=modStr,start=list(n.start=ns),
                           control=list(nrep=nr,nverb=nv))
   # Baddeley-Geyer
   r &lt;- seq(0,0.2,length=8)[-1]
   gmma &lt;- c(0.5,0.6,0.7,0.8,0.7,0.6,0.5)
   mod18 &lt;- list(cif="badgey",par=list(beta=4000, gamma=gmma,r=r,sat=5),
                 w=square(1))
   X1.badgey &lt;- rmh(model=mod18,start=list(n.start=ns),
                    control=list(nrep=nr,nverb=nv))
   mod19 &lt;- list(cif="badgey",
                 par=list(beta=4000, gamma=gmma,r=r,sat=1e4),
                 w=square(1))
   set.seed(1329)
   X2.badgey &lt;- rmh(model=mod18,start=list(n.start=ns),
                    control=list(nrep=nr,nverb=nv))

   # Check:
   h &lt;- ((prod(gmma)/cumprod(c(1,gmma)))[-8])^2
   hs &lt;- stepfun(r,c(h,1))
   mod20 &lt;- list(cif="lookup",par=list(beta=4000,h=hs),w=square(1))
   set.seed(1329)
   X.check &lt;- rmh(model=mod20,start=list(n.start=ns),
                      control=list(nrep=nr,nverb=nv))
   # X2.badgey and X.check will be identical.

   mod21 &lt;- list(cif="badgey",par=list(beta=300,gamma=c(1,0.4,1),
                 r=c(0.035,0.07,0.14),sat=5), w=square(1))
   X3.badgey &lt;- rmh(model=mod21,start=list(n.start=ns),
                    control=list(nrep=nr,nverb=nv))
   # Same result as Geyer model with beta=300, gamma=0.4, r=0.07,
   # sat = 5 (if seeds and control parameters are the same)

   # Or more simply:
   mod22 &lt;- list(cif="badgey",
                 par=list(beta=300,gamma=0.4,r=0.07, sat=5),
                 w=square(1))
   X4.badgey &lt;- rmh(model=mod22,start=list(n.start=ns),
                    control=list(nrep=nr,nverb=nv))
   # Same again --- i.e. the BadGey model includes the Geyer model.


   # Illustrating scalability.
   if(FALSE) {
    M1 &lt;- rmhmodel(cif="strauss",par=list(beta=60,gamma=0.5,r=0.04),w=owin())
    set.seed(496)
    X1 &lt;- rmh(model=M1,start=list(n.start=300))
    M2 &lt;- rmhmodel(cif="strauss",par=list(beta=0.6,gamma=0.5,r=0.4),
              w=owin(c(0,10),c(0,10)))
    set.seed(496)
    X2  &lt;- rmh(model=M2,start=list(n.start=300))
    chk &lt;- affine(X1,mat=diag(c(10,10)))
    all.equal(chk,X2,check.attributes=FALSE)
    # Under the default spatstat options the foregoing all.equal()
    # will yield TRUE.  Setting spatstat.options(scalable=FALSE) and
    # re-running the code will reveal differences between X1 and X2.
   }

   if(!interactive()) spatstat.options(oldopt)
</code></pre>

<hr>
<h2 id='rmhcontrol'>Set Control Parameters for Metropolis-Hastings Algorithm.</h2><span id='topic+rmhcontrol'></span><span id='topic+rmhcontrol.default'></span>

<h3>Description</h3>

<p>Sets up a list of parameters controlling the iterative behaviour
of the Metropolis-Hastings algorithm. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   rmhcontrol(...)

   ## Default S3 method:
rmhcontrol(..., p=0.9, q=0.5, nrep=5e5,
                      expand=NULL, periodic=NULL, ptypes=NULL,
                      x.cond=NULL, fixall=FALSE, nverb=0,
                      nsave=NULL, nburn=nsave, track=FALSE,
                      pstage=c("block", "start"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmhcontrol_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td></tr>
<tr><td><code id="rmhcontrol_+3A_p">p</code></td>
<td>
<p>Probability of proposing a shift (as against a birth/death).</p>
</td></tr>
<tr><td><code id="rmhcontrol_+3A_q">q</code></td>
<td>
<p>Conditional probability of proposing a death given that a
birth or death will be proposed.</p>
</td></tr>
<tr><td><code id="rmhcontrol_+3A_nrep">nrep</code></td>
<td>
<p>Total number of steps (proposals) of Metropolis-Hastings
algorithm that should be run.</p>
</td></tr>
<tr><td><code id="rmhcontrol_+3A_expand">expand</code></td>
<td>

<p>Simulation window or expansion rule.
Either a window (object of class <code>"owin"</code>)
or a numerical expansion factor, specifying that
simulations are to be performed in a domain other than the
original data window, then clipped to the original data window.
This argument is passed to <code><a href="#topic+rmhexpand">rmhexpand</a></code>.
A numerical expansion factor can be in several formats:
see <code><a href="#topic+rmhexpand">rmhexpand</a></code>.
</p>
</td></tr>
<tr><td><code id="rmhcontrol_+3A_periodic">periodic</code></td>
<td>

<p>Logical value (or <code>NULL</code>) indicating whether to simulate
&ldquo;periodically&rdquo;, i.e. identifying opposite edges of the rectangular
simulation window. A <code>NULL</code> value means &ldquo;undecided.&rdquo;
</p>
</td></tr>
<tr><td><code id="rmhcontrol_+3A_ptypes">ptypes</code></td>
<td>
<p>For multitype point processes, the distribution of
the mark attached to a new random point (when a birth is
proposed)</p>
</td></tr>
<tr><td><code id="rmhcontrol_+3A_x.cond">x.cond</code></td>
<td>
<p>Conditioning points for conditional simulation.</p>
</td></tr>
<tr><td><code id="rmhcontrol_+3A_fixall">fixall</code></td>
<td>
<p>(Logical) for multitype point processes,
whether to fix the number of points of each type.</p>
</td></tr>
<tr><td><code id="rmhcontrol_+3A_nverb">nverb</code></td>
<td>
<p>Progress reports will be printed every <code>nverb</code>
iterations</p>
</td></tr>
<tr><td><code id="rmhcontrol_+3A_nsave">nsave</code>, <code id="rmhcontrol_+3A_nburn">nburn</code></td>
<td>

<p>If these values are specified, then
intermediate states of the simulation algorithm will be saved
every <code>nsave</code> iterations, after an initial burn-in period of
<code>nburn</code> iterations.
</p>
</td></tr>
<tr><td><code id="rmhcontrol_+3A_track">track</code></td>
<td>

<p>Logical flag indicating whether to save the transition
history of the simulations.
</p>
</td></tr>
<tr><td><code id="rmhcontrol_+3A_pstage">pstage</code></td>
<td>

<p>Character string specifying when to generate
proposal points. Either <code>"start"</code> or <code>"block"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Metropolis-Hastings algorithm, implemented as <code><a href="#topic+rmh">rmh</a></code>,
generates simulated realisations of point process models.
The function <code>rmhcontrol</code>
sets up a list of parameters which control the 
iterative behaviour
and termination of the Metropolis-Hastings algorithm, for use in a
subsequent call to <code><a href="#topic+rmh">rmh</a></code>. It also checks that the
parameters are valid.
</p>
<p>(A separate function <code><a href="#topic+rmhstart">rmhstart</a></code>
determines the initial state of the algorithm,
and <code><a href="#topic+rmhmodel">rmhmodel</a></code> determines the model to be simulated.)
</p>
<p>The parameters are as follows:
</p>

<dl>
<dt>p</dt><dd><p>The probability of proposing a &ldquo;shift&rdquo;
(as opposed to a birth or death) in the Metropolis-Hastings
algorithm.
</p>
<p>If <code class="reqn">p = 1</code> then the algorithm only alters existing points,
so the number of points never changes, i.e. we are
simulating conditionally upon the number of points.
The number of points is determined by the initial state
(specified by <code><a href="#topic+rmhstart">rmhstart</a></code>).
</p>
<p>If <code class="reqn">p=1</code> and <code>fixall=TRUE</code> and the model
is a multitype point process model, then the algorithm
only shifts the locations of existing points and does not
alter their marks (types). 
This is equivalent to simulating conditionally
upon the number of points of each type.
These numbers are again specified by the initial state.
</p>
<p>If <code class="reqn">p = 1</code> then no expansion of the simulation window
is allowed (see <code>expand</code> below).
</p>
<p>The default value of <code>p</code> can be changed by setting
the parameter <code>rmh.p</code> in <code>spatstat.options</code>.
</p>
</dd>
<dt>q</dt><dd><p>The conditional probability of proposing a death
(rather than a birth) given that a shift is not proposed.
This is of course ignored if <code>p</code> is equal to 1.
</p>
<p>The default value of <code>q</code> can be changed by setting
the parameter <code>rmh.q</code> in <code>spatstat.options</code>.
</p>
</dd>
<dt>nrep</dt><dd><p>The number of repetitions or iterations 
to be made by the Metropolis-Hastings algorithm.  It should
be large.
</p>
<p>The default value of <code>nrep</code> can be changed by setting
the parameter <code>rmh.nrep</code> in <code>spatstat.options</code>.
</p>
</dd>
<dt>expand</dt><dd>
<p>Either a number or a window (object of class <code>"owin"</code>).
Indicates that the process is to be simulated on a 
domain other than the original data window <code>w</code>,
then clipped to <code>w</code> when the algorithm has finished.
This would often be done in order to approximate the
simulation of a stationary process (Geyer, 1999)
or more generally a process existing in the
whole plane, rather than just in the window <code>w</code>.
</p>
<p>If <code>expand</code> is a window object, it is taken as the
larger domain in which simulation is performed.
</p>
<p>If <code>expand</code> is numeric, it is interpreted
as an expansion factor or expansion distance
for determining the simulation domain from the data window.
It should be a <em>named</em> scalar, such as
<code>expand=c(area=2)</code>, <code>expand=c(distance=0.1)</code>,
<code>expand=c(length=1.2)</code>.  See <code><a href="#topic+rmhexpand">rmhexpand</a>()</code> for
more details. If the name is omitted, it defaults to <code>area</code>.
</p>
<p>Expansion is not permitted if the number of points has been
fixed by setting <code>p = 1</code> or if the
starting configuration has been specified via the
argument <code>x.start</code> in <code><a href="#topic+rmhstart">rmhstart</a></code>.
</p>
<p>If <code>expand</code> is <code>NULL</code>, this is interpreted to mean
&ldquo;not yet decided&rdquo;. An expansion rule will be determined
at a later stage, using appropriate defaults.
See <code><a href="#topic+rmhexpand">rmhexpand</a></code>.
</p>
</dd>
<dt>periodic</dt><dd><p>A logical value (or <code>NULL</code>)
determining whether to simulate &ldquo;periodically&rdquo;.
If <code>periodic</code> is <code>TRUE</code>, and if the simulation window
is a rectangle, then the simulation algorithm effectively
identifies opposite edges of the rectangle. Points
near the right-hand edge of the rectangle are deemed to be close
to points near the left-hand edge. Periodic simulation usually
gives a better approximation to a stationary point process.
For periodic simulation, the simulation window must be a rectangle.
(The simulation window is determined by <code>expand</code> as described
above.)
</p>
<p>The value <code>NULL</code> means &lsquo;undecided&rsquo;.
The decision is postponed until <code><a href="#topic+rmh">rmh</a></code> is called.
Depending on the point process model to be simulated,
<code>rmh</code> will then set <code>periodic=TRUE</code> if the simulation window
is expanded <em>and</em> the expanded simulation window is rectangular;
otherwise <code>periodic=FALSE</code>.
</p>
<p>Note that <code>periodic=TRUE</code> is only permitted when the
simulation window (i.e. the expanded window) is rectangular.       
</p>
</dd>
<dt>ptypes</dt><dd><p>A vector of probabilities (summing to 1) to be used
in assigning a random type to a new point.  Defaults to a vector
each of whose entries is <code class="reqn">1/nt</code> where <code class="reqn">nt</code> is the number
of types for the process.  Convergence of the simulation
algorithm should be improved if <code>ptypes</code> is close to the
relative frequencies of the types which will result from the
simulation.
</p>
</dd>
<dt>x.cond</dt><dd>
<p>If this argument is given,
then <em>conditional simulation</em> will be performed,
and <code>x.cond</code> specifies the location of the
fixed points as well as the type of conditioning.
It should be either a point pattern
(object of class <code>"ppp"</code>) or a <code>list(x,y)</code>
or a <code>data.frame</code>.
See the section on Conditional Simulation.
</p>
</dd>
<dt>fixall</dt><dd><p>A logical scalar specifying whether to condition on
the number of points of each type.  Meaningful only if a marked
process is being simulated, and if <code class="reqn">p = 1</code>.  A warning message
is given if <code>fixall</code> is set equal to <code>TRUE</code> when it is
not meaningful.
</p>
</dd>
<dt>nverb</dt><dd><p>An integer specifying how often &ldquo;progress reports&rdquo;
(which consist simply of the number of repetitions completed)
should be printed out.  If nverb is left at 0, the default,
the simulation proceeds silently.
</p>
</dd>
<dt>nsave,nburn</dt><dd>
<p>If these integers are given, then the
current state of the simulation algorithm (i.e. the current
random point pattern) will be saved every <code>nsave</code> iterations,
starting from iteration <code>nburn</code>.
(Alternatively <code>nsave</code> can be a vector, specifying
different numbers of iterations between each successive save.
This vector will be recycled until the end of the simulations.)
</p>
</dd>
<dt>track</dt><dd>
<p>Logical flag indicating whether to save the transition
history of the simulations (i.e. information specifying
what type of proposal was made, and whether it was accepted
or rejected, for each iteration).
</p>
</dd>
<dt>pstage</dt><dd>
<p>Character string specifying the stage of the algorithm
at which the randomised proposal points should be generated.
If <code>pstage="start"</code> or if <code>nsave=0</code>,
the entire sequence of <code>nrep</code>
random proposal points is generated at the start of the
algorithm. This is the original
behaviour of the code, and should be used in order to maintain
consistency with older versions of <span class="pkg">spatstat</span>.
If <code>pstage="block"</code> and <code>nsave &gt; 0</code>, then
a set of <code>nsave</code> random proposal points will be generated
before each block of <code>nsave</code> iterations. This is much more
efficient.
The default is <code>pstage="block"</code>.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>An object of class <code>"rmhcontrol"</code>, which is essentially
a list of parameter values for the algorithm.
</p>
<p>There is a <code>print</code> method for this class, which prints
a sensible description of the parameters chosen.
</p>


<h3>Conditional Simulation</h3>

<p>For a Gibbs point process <code class="reqn">X</code>,
the Metropolis-Hastings algorithm easily accommodates several
kinds of conditional simulation:
</p>

<dl>
<dt>conditioning on the total number of points:</dt><dd>
<p>We fix the total number of points <code class="reqn">N(X)</code> to be equal to
<code class="reqn">n</code>. We simulate from the conditional distribution of
<code class="reqn">X</code> given <code class="reqn">N(X) = n</code>. 
</p>
</dd>
<dt>conditioning on the number of points of each type:</dt><dd>
<p>In a multitype point process, where <code class="reqn">Y_j</code> denotes the
process of points of type <code class="reqn">j</code>, we fix the number
<code class="reqn">N(Y_j)</code> of points of type <code class="reqn">j</code> to be equal to
<code class="reqn">n_j</code>, for <code class="reqn">j=1,2,\ldots,m</code>.
We simulate from the conditional distribution of <code class="reqn">X</code>
given <code class="reqn">N(Y_j)=n_j</code> for
<code class="reqn">j=1,2,\ldots,m</code>. 
</p>
</dd>
<dt>conditioning on the realisation in a subwindow:</dt><dd>
<p>We require that the point process <code class="reqn">X</code> should,
within a specified sub-window <code class="reqn">V</code>,
coincide with a specified point pattern <code class="reqn">y</code>.
We simulate from the conditional distribution of <code class="reqn">X</code>
given <code class="reqn">X \cap V = y</code>.
</p>
</dd>
<dt>Palm conditioning:</dt><dd>
<p>We require that the point process <code class="reqn">X</code> include
a specified list of points <code class="reqn">y</code>. We simulate from
the point process with probability density
<code class="reqn">g(x) = c f(x \cup y)</code>
where <code class="reqn">f</code> is the probability density of the original
process <code class="reqn">X</code>, and <code class="reqn">c</code> is a normalising constant.
</p>
</dd>
</dl>

<p>To achieve each of these types of conditioning we
do as follows:
</p>

<dl>
<dt>conditioning on the total number of points:</dt><dd>
<p>Set <code>p=1</code>.
The number of points is determined by the initial state
of the simulation: see <code><a href="#topic+rmhstart">rmhstart</a></code>.
</p>
</dd>
<dt>conditioning on the number of points of each type:</dt><dd>
<p>Set <code>p=1</code> and <code>fixall=TRUE</code>.
The number of points of each type is determined by the initial state
of the simulation: see <code><a href="#topic+rmhstart">rmhstart</a></code>.
</p>
</dd>
<dt>conditioning on the realisation in a subwindow:</dt><dd>
<p>Set <code>x.cond</code> to be a point pattern (object of
class <code>"ppp"</code>). Its window <code>V=Window(x.cond)</code> becomes the
conditioning subwindow <code class="reqn">V</code>.
</p>
</dd>
<dt>Palm conditioning:</dt><dd>
<p>Set <code>x.cond</code> to be a <code>list(x,y)</code> or <code>data.frame</code>
with two columns containing the coordinates of the points, or a 
<code>list(x,y,marks)</code> or <code>data.frame</code> with three columns
containing the coordinates and marks of the points.
</p>
</dd>
</dl>

<p>The arguments <code>x.cond</code>, <code>p</code> and <code>fixall</code> can be
combined.   
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Geyer, C.J. (1999)
Likelihood Inference for Spatial Point
Processes. Chapter 3 in  O.E. Barndorff-Nielsen, W.S. Kendall and
M.N.M. Van Lieshout (eds) <em>Stochastic Geometry: Likelihood and
Computation</em>, Chapman and Hall / CRC,  Monographs on Statistics and
Applied Probability, number 80. Pages 79&ndash;140.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmh">rmh</a></code>,
<code><a href="#topic+rmhmodel">rmhmodel</a></code>,
<code><a href="#topic+rmhstart">rmhstart</a></code>,
<code><a href="#topic+rmhexpand">rmhexpand</a></code>,
<code>spatstat.options</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # parameters given as named arguments
   c1 &lt;- rmhcontrol(p=0.3,periodic=TRUE,nrep=1e6,nverb=1e5)

   # parameters given as a list
   liz &lt;- list(p=0.9, nrep=1e4)
   c2 &lt;- rmhcontrol(liz)

   # parameters given in rmhcontrol object
   c3 &lt;- rmhcontrol(c1)
</code></pre>

<hr>
<h2 id='rmhexpand'>
Specify Simulation Window or Expansion Rule
</h2><span id='topic+rmhexpand'></span>

<h3>Description</h3>

<p>Specify a spatial domain in which point process simulations
will be performed. Alternatively, specify a rule which will be
used to determine the simulation window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmhexpand(x = NULL, ..., area = NULL, length = NULL, distance = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmhexpand_+3A_x">x</code></td>
<td>

<p>Any kind of data determining the simulation window or the
expansion rule.
A window (object of class <code>"owin"</code>) specifying the
simulation window, a numerical value specifying an expansion
factor or expansion distance, a list containing
one numerical value, an object of class <code>"rmhexpand"</code>,
or <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="rmhexpand_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="rmhexpand_+3A_area">area</code></td>
<td>

<p>Area expansion factor. 
Incompatible with other arguments.
</p>
</td></tr>
<tr><td><code id="rmhexpand_+3A_length">length</code></td>
<td>

<p>Length expansion factor.
Incompatible with other arguments.
</p>
</td></tr>
<tr><td><code id="rmhexpand_+3A_distance">distance</code></td>
<td>

<p>Expansion distance (buffer width).
Incompatible with other arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the Metropolis-Hastings algorithm <code><a href="#topic+rmh">rmh</a></code>
for simulating spatial point processes, 
simulations are usually carried out on a spatial domain that is
larger than the original window of the point process model,
then subsequently clipped to the original window.
</p>
<p>The command <code>rmhexpand</code> can be used to specify the simulation window,
or to specify a rule which will later be used to determine the
simulation window from data.
</p>
<p>The arguments are all incompatible: at most one of them should be
given.
</p>
<p>If the first argument <code>x</code> is given, it may be any of the
following:
</p>

<ul>
<li>
<p>a window (object of class <code>"owin"</code>) specifying the
simulation window.
</p>
</li>
<li>
<p>an object of class <code>"rmhexpand"</code> specifying the
expansion rule.
</p>
</li>
<li>
<p>a single numerical value, without attributes.
This will be interpreted as the value of the argument <code>area</code>.
</p>
</li>
<li>
<p>either <code>c(area=v)</code> or <code>list(area=v)</code>,
where <code>v</code> is a single numeric value.
This will be interpreted as the value of the argument <code>area</code>.
</p>
</li>
<li>
<p>either <code>c(length=v)</code> or <code>list(length=v)</code>,
where <code>v</code> is a single numeric value.
This will be interpreted as the value of the argument <code>length</code>.
</p>
</li>
<li>
<p>either <code>c(distance=v)</code> or <code>list(distance=v)</code>,
where <code>v</code> is a single numeric value.
This will be interpreted as the value of the argument <code>distance</code>.
</p>
</li>
<li> 
<p><code>NULL</code>, meaning that the expansion rule is not yet
determined. 
</p>
</li></ul>

<p>If one of the arguments <code>area</code>, <code>length</code> or <code>distance</code>
is given, then the simulation window is determined from the original
data window as follows.
</p>

<dl>
<dt>area</dt><dd>
<p>The bounding box of the original data window will be extracted,
and the simulation window will be a scalar dilation of this rectangle.
The argument <code>area</code> should be a numerical value, greater than
or equal to 1. It specifies the area expansion factor, i.e. the ratio
of the area of the simulation window to the area of the
original point process window's bounding box.
</p>
</dd>
<dt>length</dt><dd>
<p>The bounding box of the original data window will be extracted,
and the simulation window will be a scalar dilation of this rectangle.
The argument <code>length</code> should be a numerical value, greater than
or equal to 1. It specifies the length expansion factor, i.e. the ratio
of the width (height) of the simulation window to the width
(height) of the original point process window's bounding box.
</p>
</dd>
<dt>distance</dt><dd>
<p>The argument <code>distance</code> should be a numerical value, greater than
or equal to 0. It specifies the width of a buffer region around the
original data window. 
If the original data window is a rectangle, then this window
is extended by a margin of width equal to <code>distance</code>
around all sides of the original rectangle. The result is a
rectangle.
If the original data window is not a rectangle, then
morphological dilation is applied using
<code>dilation.owin</code>
so that a margin or buffer of width equal to <code>distance</code>
is created around all sides of the original window. The result
is a non-rectangular window, typically of a different shape.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>An object of class <code>"rmhexpand"</code> specifying the
expansion rule. There is a <code>print</code> method for this class.
</p>


<h3>Undetermined expansion</h3>

<p>If <code>expand=NULL</code>, this is interpreted to mean that the
expansion rule is &ldquo;not yet decided&rdquo;. Expansion will be decided
later, by the simulation algorithm <code><a href="#topic+rmh">rmh</a></code>.
If the model cannot be expanded (for example if the covariate data
in the model are not available on a larger domain) then expansion
will not occur. If the model can be expanded, then
if the point process model has a finite interaction range <code>r</code>,
the default is <code>rmhexpand(distance=2*r)</code>, and
otherwise <code>rmhexpand(area=2)</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expand.owin">expand.owin</a></code> to apply the rule to a window.
</p>
<p><code><a href="#topic+will.expand">will.expand</a></code> to test whether expansion will occur.
</p>
<p><code><a href="#topic+rmh">rmh</a></code>, <code><a href="#topic+rmhcontrol">rmhcontrol</a></code> for background details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  rmhexpand()
  rmhexpand(2)
  rmhexpand(1)
  rmhexpand(length=1.5)
  rmhexpand(distance=0.1)
  rmhexpand(letterR)
</code></pre>

<hr>
<h2 id='rmhmodel'>Define Point Process Model for Metropolis-Hastings Simulation.</h2><span id='topic+rmhmodel'></span>

<h3>Description</h3>

<p>Builds a description of a point process model
for use in simulating the model by the Metropolis-Hastings
algorithm. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rmhmodel(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmhmodel_+3A_...">...</code></td>
<td>
<p>Arguments specifying the point process model
in some format.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulated realisations of many point process models
can be generated using the Metropolis-Hastings algorithm
<code><a href="#topic+rmh">rmh</a></code>. The algorithm requires the model to be specified
in a particular format: an object of class <code>"rmhmodel"</code>.
</p>
<p>The function <code><a href="#topic+rmhmodel">rmhmodel</a></code> takes a
description of a point process model in some other format, and
converts it into an object of class <code>"rmhmodel"</code>.
It also checks that the parameters of the model are valid.
</p>
<p>The function <code><a href="#topic+rmhmodel">rmhmodel</a></code> is generic, with methods
for
</p>

<dl>
<dt>fitted point process models:</dt><dd>
<p>an object of class <code>"ppm"</code>, obtained by a call to the
model-fitting function <code><a href="spatstat.model.html#topic+ppm">ppm</a></code>.
See <code><a href="spatstat.model.html#topic+rmhmodel.ppm">rmhmodel.ppm</a></code>.
</p>
</dd>
<dt>lists:</dt><dd>
<p>a list of parameter values in a certain format.
See <code><a href="#topic+rmhmodel.list">rmhmodel.list</a></code>.
</p>
</dd>
<dt>default:</dt><dd>
<p>parameter values specified as separate arguments to <code>...</code>.
See <code><a href="#topic+rmhmodel.default">rmhmodel.default</a></code>.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>An object of class <code>"rmhmodel"</code>, which is essentially
a list of parameter values for the model.
</p>
<p>There is a <code>print</code> method for this class, which prints
a sensible description of the model chosen.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Diggle, P. J. (2003) <em>Statistical Analysis of Spatial Point
Patterns</em> (2nd ed.) Arnold, London.
</p>
<p>Diggle, P.J. and Gratton, R.J. (1984)
Monte Carlo methods of inference for implicit statistical models.
<em>Journal of the Royal Statistical Society, series B</em>
<b>46</b>, 193 &ndash; 212.
</p>
<p>Diggle, P.J., Gates, D.J., and Stibbard, A. (1987)
A nonparametric estimator for pairwise-interaction point processes.
Biometrika <b>74</b>, 763 &ndash; 770.
<em>Scandinavian Journal of Statistics</em> <b>21</b>, 359&ndash;373.
</p>
<p>Geyer, C.J. (1999)
Likelihood Inference for Spatial Point
Processes. Chapter 3 in  O.E. Barndorff-Nielsen, W.S. Kendall and
M.N.M. Van Lieshout (eds) <em>Stochastic Geometry: Likelihood and
Computation</em>, Chapman and Hall / CRC,  Monographs on Statistics and
Applied Probability, number 80. Pages 79&ndash;140.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.model.html#topic+rmhmodel.ppm">rmhmodel.ppm</a></code>,
<code><a href="#topic+rmhmodel.default">rmhmodel.default</a></code>,
<code><a href="#topic+rmhmodel.list">rmhmodel.list</a></code>,
<code><a href="#topic+rmh">rmh</a></code>,
<code><a href="#topic+rmhcontrol">rmhcontrol</a></code>,
<code><a href="#topic+rmhstart">rmhstart</a></code>,
<code><a href="spatstat.model.html#topic+ppm">ppm</a></code>,
<code><a href="spatstat.model.html#topic+Strauss">Strauss</a></code>,
<code><a href="spatstat.model.html#topic+Softcore">Softcore</a></code>,
<code><a href="spatstat.model.html#topic+StraussHard">StraussHard</a></code>,
<code><a href="spatstat.model.html#topic+Triplets">Triplets</a></code>,
<code><a href="spatstat.model.html#topic+MultiStrauss">MultiStrauss</a></code>,
<code><a href="spatstat.model.html#topic+MultiStraussHard">MultiStraussHard</a></code>,
<code><a href="spatstat.model.html#topic+DiggleGratton">DiggleGratton</a></code>,
<code><a href="spatstat.model.html#topic+PairPiece">PairPiece</a></code>
<code><a href="spatstat.model.html#topic+Penttinen">Penttinen</a></code>
</p>

<hr>
<h2 id='rmhmodel.default'>Build Point Process Model for Metropolis-Hastings Simulation.</h2><span id='topic+rmhmodel.default'></span>

<h3>Description</h3>

<p>Builds a description of a point process model
for use in simulating the model by the Metropolis-Hastings
algorithm. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## Default S3 method:
rmhmodel(..., 
         cif=NULL, par=NULL, w=NULL, trend=NULL, types=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmhmodel.default_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="rmhmodel.default_+3A_cif">cif</code></td>
<td>
<p>Character string specifying the choice of model</p>
</td></tr>
<tr><td><code id="rmhmodel.default_+3A_par">par</code></td>
<td>
<p>Parameters of the model</p>
</td></tr>
<tr><td><code id="rmhmodel.default_+3A_w">w</code></td>
<td>
<p>Spatial window in which to simulate</p>
</td></tr>
<tr><td><code id="rmhmodel.default_+3A_trend">trend</code></td>
<td>
<p>Specification of the trend in the model</p>
</td></tr>
<tr><td><code id="rmhmodel.default_+3A_types">types</code></td>
<td>
<p>A vector of factor levels defining the possible
marks, for a multitype process.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generic function <code><a href="#topic+rmhmodel">rmhmodel</a></code> takes a
description of a point process model in some format, and
converts it into an object of class <code>"rmhmodel"</code>
so that simulations of the model can be generated using
the Metropolis-Hastings algorithm <code><a href="#topic+rmh">rmh</a></code>. 
</p>
<p>This function <code>rmhmodel.default</code> is the default method.
It builds a description of the point process model
from the simple arguments listed.
</p>
<p>The argument <code>cif</code> is a character string specifying the choice of
interpoint interaction for the point process. The current options are
</p>

<dl>
<dt><code>'areaint'</code></dt><dd><p>Area-interaction process.</p>
</dd>
<dt><code>'badgey'</code></dt><dd><p>Baddeley-Geyer (hybrid Geyer) process.</p>
</dd>
<dt><code>'dgs'</code></dt><dd><p>Diggle, Gates and Stibbard (1987) process</p>
</dd>
<dt><code>'diggra'</code></dt><dd><p>Diggle and Gratton (1984) process</p>
</dd>
<dt><code>'fiksel'</code></dt><dd><p>Fiksel double exponential process (Fiksel, 1984).</p>
</dd>
<dt><code>'geyer'</code></dt><dd><p>Saturation process (Geyer, 1999).</p>
</dd>
<dt><code>'hardcore'</code></dt><dd><p>Hard core process</p>
</dd>
<dt><code>'lennard'</code></dt><dd><p>Lennard-Jones process</p>
</dd>
<dt><code>'lookup'</code></dt><dd><p>General isotropic pairwise interaction process,
with the interaction function specified via a &ldquo;lookup table&rdquo;.</p>
</dd>
<dt><code>'multihard'</code></dt><dd><p>Multitype hardcore process</p>
</dd>
<dt><code>'penttinen'</code></dt><dd><p>The Penttinen process</p>
</dd>
<dt><code>'strauss'</code></dt><dd><p>The Strauss process</p>
</dd>
<dt><code>'straush'</code></dt><dd><p>The Strauss process with hard core</p>
</dd>
<dt><code>'sftcr'</code></dt><dd><p>The Softcore process</p>
</dd>
<dt><code>'straussm'</code></dt><dd><p> The multitype Strauss process</p>
</dd>
<dt><code>'straushm'</code></dt><dd><p>Multitype Strauss process with hard core</p>
</dd>
<dt><code>'triplets'</code></dt><dd><p>Triplets process (Geyer, 1999).</p>
</dd>
</dl>

<p>It is also possible to specify a <em>hybrid</em> of these interactions
in the sense of Baddeley et al (2013).
In this case, <code>cif</code> is a character vector containing names from
the list above. For example, <code>cif=c('strauss', 'geyer')</code> would
specify a hybrid of the Strauss and Geyer models.
</p>
<p>The argument <code>par</code> supplies parameter values appropriate to
the conditional intensity function being invoked.
For the interactions listed above, these parameters are:
</p>

<dl>
<dt>areaint:</dt><dd>
<p>(Area-interaction process.) A <b>named</b> list with components
<code>beta,eta,r</code> which are respectively the &ldquo;base&rdquo;
intensity, the scaled interaction parameter and the
interaction radius.  
</p>
</dd>
<dt>badgey:</dt><dd>
<p>(Baddeley-Geyer process.)
A <b>named</b> list with components
<code>beta</code> (the &ldquo;base&rdquo; intensity), <code>gamma</code> (a vector
of non-negative interaction parameters), <code>r</code> (a vector
of interaction radii, of the same length as <code>gamma</code>,
in <em>increasing</em> order), and <code>sat</code> (the saturation
parameter(s); this may be a scalar, or a vector of the same
length as <code>gamma</code> and <code>r</code>; all values should be at
least 1).  Note that because of the presence of &ldquo;saturation&rdquo;
the <code>gamma</code> values are permitted to be larger than 1.
</p>
</dd>
<dt>dgs:</dt><dd>
<p>(Diggle, Gates, and Stibbard process.
See Diggle, Gates, and Stibbard (1987))
A <b>named</b> list with components
<code>beta</code> and <code>rho</code>.  This process has pairwise interaction
function equal to
</p>
<p style="text-align: center;"><code class="reqn">
	e(t) = \sin^2\left(\frac{\pi t}{2\rho}\right)
      </code>
</p>

<p>for <code class="reqn">t &lt; \rho</code>, and equal to 1
for <code class="reqn">t \ge \rho</code>.
</p>
</dd>
<dt>diggra:</dt><dd>
<p>(Diggle-Gratton process. See Diggle and Gratton (1984)
and Diggle, Gates and Stibbard (1987).)
A <b>named</b> list with components <code>beta</code>,
<code>kappa</code>, <code>delta</code> and <code>rho</code>.  This process has
pairwise interaction function <code class="reqn">e(t)</code> equal to 0
for <code class="reqn">t &lt; \delta</code>, equal to
</p>
<p style="text-align: center;"><code class="reqn">
	\left(\frac{t-\delta}{\rho-\delta}\right)^\kappa
      </code>
</p>

<p>for <code class="reqn">\delta \le t &lt; \rho</code>,
and equal to 1 for <code class="reqn">t \ge  \rho</code>.
Note that here we use the symbol
<code class="reqn">\kappa</code> where Diggle, Gates, and Stibbard use
<code class="reqn">\beta</code> since we reserve the symbol <code class="reqn">\beta</code>
for an intensity parameter.
</p>
</dd>
<dt>fiksel:</dt><dd>
<p>(Fiksel double exponential process, see Fiksel (1984))
A <b>named</b> list with components <code>beta</code>,
<code>r</code>, <code>hc</code>, <code>kappa</code> and <code>a</code>.  This process has
pairwise interaction function <code class="reqn">e(t)</code> equal to 0
for <code class="reqn">t &lt; hc</code>, equal to
</p>
<p style="text-align: center;"><code class="reqn">
	\exp(a \exp(- \kappa t))
      </code>
</p>

<p>for <code class="reqn">hc \le t &lt; r</code>,
and equal to 1 for <code class="reqn">t \ge  r</code>.
</p>
</dd>
<dt>geyer:</dt><dd>
<p>(Geyer's saturation process. See Geyer (1999).)
A <b>named</b> list
with components <code>beta</code>, <code>gamma</code>, <code>r</code>, and <code>sat</code>.
The components <code>beta</code>, <code>gamma</code>, <code>r</code> are as for
the Strauss model, and <code>sat</code> is the &ldquo;saturation&rdquo;
parameter.  The model is Geyer's &ldquo;saturation&rdquo; point process
model, a modification of the Strauss process in which
we effectively impose an upper limit (<code>sat</code>) on the number of
neighbours which will be counted as close to a given point.
</p>
<p>Explicitly, a saturation point process with interaction
radius <code class="reqn">r</code>, saturation threshold <code class="reqn">s</code>, and
parameters <code class="reqn">\beta</code> and <code class="reqn">\gamma</code>,
is the point process in which each point <code class="reqn">x_i</code>
in the pattern <code class="reqn">X</code> contributes a factor
</p>
<p style="text-align: center;"><code class="reqn">\beta \gamma^{\min(s, t(x_i,X))}</code>
</p>

<p>to the probability density of the point pattern,
where <code class="reqn">t(x_i,X)</code> denotes the number of
&ldquo;<code class="reqn">r</code>-close neighbours&rdquo; of <code class="reqn">x_i</code> in the
pattern <code class="reqn">X</code>.
</p>
<p>If the saturation threshold <code class="reqn">s</code> is infinite,
the Geyer process reduces to a Strauss process
with interaction parameter <code class="reqn">\gamma^2</code>
rather than <code class="reqn">\gamma</code>.
</p>
</dd>
<dt>hardcore:</dt><dd>
<p>(Hard core process.) A <b>named</b> list
with components <code>beta</code> and <code>hc</code>
where <code>beta</code> is the base intensity and <code>hc</code> is the
hard core distance.
This process has pairwise interaction function <code class="reqn">e(t)</code>
equal to 1 if <code class="reqn">t &gt; hc</code> and 0 if <code class="reqn">t &lt;= hc</code>.
</p>
</dd>
<dt>lennard:</dt><dd>
<p>(Lennard-Jones process.) A <b>named</b> list
with components <code>sigma</code> and <code>epsilon</code>,
where <code>sigma</code> is the characteristic diameter
and <code>epsilon</code> is the well depth.
See <code><a href="spatstat.model.html#topic+LennardJones">LennardJones</a></code> for explanation.
</p>
</dd>
<dt>multihard:</dt><dd>
<p>(Multitype hard core process.) A <b>named</b> list
with components <code>beta</code> and <code>hradii</code>,
where <code>beta</code> is a vector of base intensities for each type
of point, and <code>hradii</code> is a matrix of hard core radii
between each pair of types. 
</p>
</dd>
<dt>penttinen:</dt><dd>
<p>(Penttinen process.) A <b>named</b> list with components
<code>beta,gamma,r</code> which are respectively the &ldquo;base&rdquo;
intensity, the pairwise interaction parameter, and the disc radius.
Note that <code>gamma</code> must be less than or equal to 1.
See <code><a href="spatstat.model.html#topic+Penttinen">Penttinen</a></code> for explanation.
(Note that there is also an algorithm for perfect simulation
of the Penttinen process, <code><a href="#topic+rPenttinen">rPenttinen</a></code>)
</p>
</dd>
<dt>strauss:</dt><dd>
<p>(Strauss process.) A <b>named</b> list with components
<code>beta,gamma,r</code> which are respectively the &ldquo;base&rdquo;
intensity, the pairwise interaction parameter and the
interaction radius.  Note that <code>gamma</code> must be less than
or equal to 1.
(Note that there is also an algorithm for perfect simulation
of the Strauss process, <code><a href="#topic+rStrauss">rStrauss</a></code>)
</p>
</dd>
<dt>straush:</dt><dd>
<p>(Strauss process with hardcore.) A <b>named</b> list with
entries <code>beta,gamma,r,hc</code> where <code>beta</code>, <code>gamma</code>,
and <code>r</code> are as for the Strauss process, and <code>hc</code> is
the hardcore radius.  Of course <code>hc</code> must be less than
<code>r</code>.
</p>
</dd>
<dt>sftcr:</dt><dd>
<p>(Softcore process.) A <b>named</b> list with components
<code>beta,sigma,kappa</code>.  Again <code>beta</code> is a &ldquo;base&rdquo;
intensity. The pairwise interaction between two points
<code class="reqn">u \neq v</code> is
</p>
<p style="text-align: center;"><code class="reqn">
	\exp \left \{
	- \left ( \frac{\sigma}{||u-v||} \right )^{2/\kappa}
	\right \}
      </code>
</p>

<p>Note that it is necessary that <code class="reqn">0 &lt; \kappa &lt; 1</code>.
</p>
</dd>
<dt>straussm:</dt><dd>
<p>(Multitype Strauss process.) A <b>named</b> list with components
</p>

<ul>
<li>
<p><code>beta</code>: 
A vector of &ldquo;base&rdquo; intensities, one for each possible type.
</p>
</li>
<li>
<p><code>gamma</code>:
A <b>symmetric</b> matrix of interaction parameters,
with <code class="reqn">\gamma_{ij}</code> pertaining to the interaction between
type <code class="reqn">i</code> and type <code class="reqn">j</code>.
</p>
</li>
<li>
<p><code>radii</code>:
A <b>symmetric</b> matrix of interaction radii, with
entries <code class="reqn">r_{ij}</code> pertaining to the interaction between type
<code class="reqn">i</code> and type <code class="reqn">j</code>.
</p>
</li></ul>

</dd>
<dt>straushm:</dt><dd>
<p>(Multitype Strauss process with hardcore.)
A <b>named</b> list with components <code>beta</code> and <code>gamma</code>
as for <code>straussm</code> and
<b>two</b> &ldquo;radii&rdquo; components:
</p>

<ul>
<li> <p><code>iradii</code>: the interaction radii
</p>
</li>
<li> <p><code>hradii</code>: the hardcore radii
</p>
</li></ul>

<p>which are both symmetric matrices of nonnegative numbers.
The entries of <code>hradii</code> must be less than the
corresponding entries
of <code>iradii</code>.
</p>
</dd>
<dt>triplets:</dt><dd>
<p>(Triplets process.) A <b>named</b> list with components
<code>beta,gamma,r</code> which are respectively the &ldquo;base&rdquo;
intensity, the triplet interaction parameter and the
interaction radius.  Note that <code>gamma</code> must be less than
or equal to 1.
</p>
</dd>
<dt>lookup:</dt><dd>
<p>(Arbitrary pairwise interaction process with isotropic interaction.)
A <b>named</b> list with components
<code>beta</code>, <code>r</code>, and <code>h</code>, or just with components
<code>beta</code> and <code>h</code>.
</p>
<p>This model is the pairwise interaction process
with an isotropic interaction given by any chosen function <code class="reqn">H</code>.
Each pair of points <code class="reqn">x_i, x_j</code> in the
point pattern contributes
a factor <code class="reqn">H(d(x_i, x_j))</code>
to the probability density, where <code class="reqn">d</code> denotes distance
and <code class="reqn">H</code> is the pair interaction function.
</p>
<p>The component <code>beta</code> is a
(positive) scalar which determines the &ldquo;base&rdquo; intensity
of the process.
</p>
<p>In this implementation, <code class="reqn">H</code> must be a step function.
It is specified by the user in one of two ways.
</p>

<ul>
<li>
<p><b>as a vector of values:</b>
If <code>r</code> is present, then <code>r</code> is assumed to 
give the locations of jumps in the function <code class="reqn">H</code>,
while the vector <code>h</code> gives the corresponding
values of the function.
</p>
<p>Specifically, the interaction function
<code class="reqn">H(t)</code> takes the value <code>h[1]</code>
for distances <code class="reqn">t</code> in the interval 
<code>[0, r[1])</code>; takes the value <code>h[i]</code>
for distances <code class="reqn">t</code> in the interval 
<code>[r[i-1], r[i])</code> where
<code class="reqn">i = 2,\ldots, n</code>;
and takes the value 1 for <code class="reqn">t \ge r[n]</code>.
Here <code class="reqn">n</code> denotes the length of <code>r</code>.
</p>
<p>The components <code>r</code> and <code>h</code>
must be numeric vectors of equal length.
The <code>r</code> values must be strictly positive, and 
sorted in increasing order.
</p>
<p>The entries of <code>h</code> must be non-negative. 
If any entry of <code>h</code> is greater than 1,
then the entry <code>h[1]</code> must be 0 (otherwise the specified
process is non-existent).
</p>
<p>Greatest efficiency is achieved if the values of
<code>r</code> are equally spaced.
</p>
<p>[<b>Note:</b> The usage of <code>r</code> and <code>h</code>
has <em>changed</em> from the previous usage in <span class="pkg">spatstat</span>
versions 1.4-7 to 1.5-1, in which ascending order was not required,
and in which the first entry of <code>r</code> had to be 0.]
</p>
</li>
<li>
<p><b>as a stepfun object:</b>
If <code>r</code> is absent, then <code>h</code> must be
an object of class <code>"stepfun"</code> specifying
a step function. Such objects are created by
<code><a href="stats.html#topic+stepfun">stepfun</a></code>. 
</p>
<p>The stepfun object <code>h</code> must be right-continuous
(which is the default using <code><a href="stats.html#topic+stepfun">stepfun</a></code>.)
</p>
<p>The values of the step function must all be nonnegative.
The values must all be less than 1
unless the function is identically zero on some initial
interval <code class="reqn">[0,r)</code>. The rightmost value (the value of
<code>h(t)</code> for large <code>t</code>) must be equal to 1.
</p>
<p>Greatest efficiency is achieved if the jumps (the
&ldquo;knots&rdquo; of the step function) are equally spaced.
</p>
</li></ul>

</dd>
</dl>

<p>For a hybrid model, the argument <code>par</code> should be a list,
of the same length as <code>cif</code>, such that <code>par[[i]]</code>
is a list of the parameters required for the interaction
<code>cif[i]</code>. See the Examples.
</p>
<p>The optional argument <code>trend</code> determines the spatial trend in the model,
if it has one. It should be a function or image
(or a list of such, if the model is multitype)
to provide the value of the trend at an arbitrary point.
</p>

<dl>
<dt>trend given as a function:</dt><dd><p>A trend
function may be a function of any number of arguments,
but the first two must be the <code class="reqn">x,y</code> coordinates of
a point.  Auxiliary arguments may be passed
to the <code>trend</code> function at the time of simulation,
via the <code>...</code> argument to <code><a href="#topic+rmh">rmh</a></code>.
</p>
<p>The function <b>must</b> be <b>vectorized</b>.
That is, it must be capable of accepting vector valued
<code>x</code> and <code>y</code> arguments.  Put another way,
it must be capable of calculating the trend value at a
number of points, simultaneously, and should return the
<b>vector</b> of corresponding trend values.
</p>
</dd>
<dt>trend given as an image:</dt><dd>
<p>An image (see <code>im.object</code>)
provides the trend values at a grid of
points in the observation window and determines the trend
value at other points as the value at the nearest grid point.
</p>
</dd>
</dl>

<p>Note that the trend or trends must be <b>non-negative</b>;
no checking is done for this.
</p>
<p>The optional argument <code>w</code> specifies the window
in which the pattern is to be generated.  If specified, it must be in
a form which can be coerced to an object of class <code>owin</code>
by <code>as.owin</code>.
</p>
<p>The optional argument <code>types</code> specifies the possible
types in a multitype point process. If the model being simulated
is multitype, and <code>types</code> is not specified, then this vector
defaults to <code>1:ntypes</code> where <code>ntypes</code> is the number of
types.
</p>


<h3>Value</h3>

<p>An object of class <code>"rmhmodel"</code>, which is essentially
a list of parameter values for the model.
</p>
<p>There is a <code>print</code> method for this class, which prints
a sensible description of the model chosen.
</p>


<h3>Warnings in Respect of &ldquo;lookup&rdquo;</h3>

<p>For the <code>lookup</code> cif, 
the entries of the <code>r</code> component of <code>par</code>
must be <em>strictly positive</em> and sorted into ascending order.
</p>
<p>Note that if you specify the <code>lookup</code> pairwise interaction
function via <code><a href="stats.html#topic+stepfun">stepfun</a>()</code> the arguments <code>x</code>
and <code>y</code> which are passed to <code>stepfun()</code> are slightly
different from <code>r</code> and <code>h</code>:  <code>length(y)</code> is equal
to <code>1+length(x)</code>; the final entry of <code>y</code> must be equal
to 1 &mdash; i.e. this value is explicitly supplied by the user rather
than getting tacked on internally.
</p>
<p>The step function returned by <code>stepfun()</code> must be right
continuous (this is the default behaviour of <code>stepfun()</code>)
otherwise an error is given.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A., Turner, R., Mateu, J. and Bevan, A. (2013)
Hybrids of Gibbs point process models and their implementation.
<em>Journal of Statistical Software</em> <b>55</b>:11, 1&ndash;43.
<code>DOI: 10.18637/jss.v055.i11</code>
</p>
<p>Diggle, P. J. (2003) <em>Statistical Analysis of Spatial Point
Patterns</em> (2nd ed.) Arnold, London.
</p>
<p>Diggle, P.J. and Gratton, R.J. (1984)
Monte Carlo methods of inference for implicit statistical models.
<em>Journal of the Royal Statistical Society, series B</em>
<b>46</b>, 193 &ndash; 212.
</p>
<p>Diggle, P.J., Gates, D.J., and Stibbard, A. (1987)
A nonparametric estimator for pairwise-interaction point processes.
Biometrika <b>74</b>, 763 &ndash; 770.
<em>Scandinavian Journal of Statistics</em> <b>21</b>, 359&ndash;373.
</p>
<p>Fiksel, T. (1984)
Estimation of parameterized pair potentials
of marked and non-marked Gibbsian point processes.
<em>Electronische Informationsverabeitung und Kybernetika</em>
<b>20</b>, 270&ndash;278.
</p>
<p>Geyer, C.J. (1999)
Likelihood Inference for Spatial Point
Processes. Chapter 3 in  O.E. Barndorff-Nielsen, W.S. Kendall and
M.N.M. Van Lieshout (eds) <em>Stochastic Geometry: Likelihood and
Computation</em>, Chapman and Hall / CRC,  Monographs on Statistics and
Applied Probability, number 80. Pages 79&ndash;140.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmh">rmh</a></code>,
<code><a href="#topic+rmhcontrol">rmhcontrol</a></code>,
<code><a href="#topic+rmhstart">rmhstart</a></code>,
<code><a href="spatstat.model.html#topic+ppm">ppm</a></code>,
<code><a href="spatstat.model.html#topic+AreaInter">AreaInter</a></code>, <code><a href="spatstat.model.html#topic+BadGey">BadGey</a></code>, <code><a href="spatstat.model.html#topic+DiggleGatesStibbard">DiggleGatesStibbard</a></code>, <code><a href="spatstat.model.html#topic+DiggleGratton">DiggleGratton</a></code>, <code><a href="spatstat.model.html#topic+Fiksel">Fiksel</a></code>, <code><a href="spatstat.model.html#topic+Geyer">Geyer</a></code>, <code><a href="spatstat.model.html#topic+Hardcore">Hardcore</a></code>, <code><a href="spatstat.model.html#topic+Hybrid">Hybrid</a></code>, <code><a href="spatstat.model.html#topic+LennardJones">LennardJones</a></code>, <code><a href="spatstat.model.html#topic+MultiStrauss">MultiStrauss</a></code>, <code><a href="spatstat.model.html#topic+MultiStraussHard">MultiStraussHard</a></code>, <code><a href="spatstat.model.html#topic+PairPiece">PairPiece</a></code>, <code><a href="spatstat.model.html#topic+Penttinen">Penttinen</a></code>, <code><a href="spatstat.model.html#topic+Poisson">Poisson</a></code>, <code><a href="spatstat.model.html#topic+Softcore">Softcore</a></code>, <code><a href="spatstat.model.html#topic+Strauss">Strauss</a></code>, <code><a href="spatstat.model.html#topic+StraussHard">StraussHard</a></code> and <code><a href="spatstat.model.html#topic+Triplets">Triplets</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # Strauss process:
   mod01 &lt;- rmhmodel(cif="strauss",par=list(beta=2,gamma=0.2,r=0.7),
                 w=c(0,10,0,10))
   mod01
   # The above could also be simulated using 'rStrauss'

   # Strauss with hardcore:
   mod04 &lt;- rmhmodel(cif="straush",par=list(beta=2,gamma=0.2,r=0.7,hc=0.3),
                w=owin(c(0,10),c(0,5)))

   # Hard core:
   mod05 &lt;- rmhmodel(cif="hardcore",par=list(beta=2,hc=0.3),
              w=square(5))

   # Soft core:
   w    &lt;- square(10)
   mod07 &lt;- rmhmodel(cif="sftcr",
                     par=list(beta=0.8,sigma=0.1,kappa=0.5),
                     w=w)
   
   # Penttinen process:
   modpen &lt;- rmhmodel(cif="penttinen",par=list(beta=2,gamma=0.6,r=1),
                 w=c(0,10,0,10))

   # Area-interaction process:
   mod42 &lt;- rmhmodel(cif="areaint",par=list(beta=2,eta=1.6,r=0.7),
                 w=c(0,10,0,10))

   # Baddeley-Geyer process:
   mod99 &lt;- rmhmodel(cif="badgey",par=list(beta=0.3,
                     gamma=c(0.2,1.8,2.4),r=c(0.035,0.07,0.14),sat=5),
                     w=unit.square())

   # Multitype Strauss:
   beta &lt;- c(0.027,0.008)
   gmma &lt;- matrix(c(0.43,0.98,0.98,0.36),2,2)
   r    &lt;- matrix(c(45,45,45,45),2,2)
   mod08 &lt;- rmhmodel(cif="straussm",
                     par=list(beta=beta,gamma=gmma,radii=r),
                     w=square(250))
   # specify types
   mod09 &lt;- rmhmodel(cif="straussm",
                     par=list(beta=beta,gamma=gmma,radii=r),
                     w=square(250),
                     types=c("A", "B"))

   # Multitype Hardcore:
   rhc  &lt;- matrix(c(9.1,5.0,5.0,2.5),2,2)
   mod08hard &lt;- rmhmodel(cif="multihard",
                     par=list(beta=beta,hradii=rhc),
                     w=square(250),
                     types=c("A", "B"))

   
   # Multitype Strauss hardcore with trends for each type:
   beta  &lt;- c(0.27,0.08)
   ri    &lt;- matrix(c(45,45,45,45),2,2)
   rhc  &lt;- matrix(c(9.1,5.0,5.0,2.5),2,2)
   tr3   &lt;- function(x,y){x &lt;- x/250; y &lt;- y/250;
   			   exp((6*x + 5*y - 18*x^2 + 12*x*y - 9*y^2)/6)
                         }
                         # log quadratic trend
   tr4   &lt;- function(x,y){x &lt;- x/250; y &lt;- y/250;
                         exp(-0.6*x+0.5*y)}
                        # log linear trend
   mod10 &lt;- rmhmodel(cif="straushm",par=list(beta=beta,gamma=gmma,
                 iradii=ri,hradii=rhc),w=c(0,250,0,250),
                 trend=list(tr3,tr4))

   # Triplets process:
   mod11 &lt;- rmhmodel(cif="triplets",par=list(beta=2,gamma=0.2,r=0.7),
                 w=c(0,10,0,10))

   # Lookup (interaction function h_2 from page 76, Diggle (2003)):
      r &lt;- seq(from=0,to=0.2,length=101)[-1] # Drop 0.
      h &lt;- 20*(r-0.05)
      h[r&lt;0.05] &lt;- 0
      h[r&gt;0.10] &lt;- 1
      mod17 &lt;- rmhmodel(cif="lookup",par=list(beta=4000,h=h,r=r),w=c(0,1,0,1))

  # hybrid model
  modhy &lt;- rmhmodel(cif=c('strauss', 'geyer'),
                    par=list(list(beta=100,gamma=0.5,r=0.05),
                             list(beta=1, gamma=0.7,r=0.1, sat=2)),
                    w=square(1))
  modhy
</code></pre>

<hr>
<h2 id='rmhmodel.list'>Define Point Process Model for Metropolis-Hastings Simulation.</h2><span id='topic+rmhmodel.list'></span>

<h3>Description</h3>

<p>Given a list of parameters,
builds a description of a point process model
for use in simulating the model by the Metropolis-Hastings
algorithm. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'list'
rmhmodel(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmhmodel.list_+3A_model">model</code></td>
<td>
<p>A list of parameters. See Details.</p>
</td></tr>
<tr><td><code id="rmhmodel.list_+3A_...">...</code></td>
<td>

<p>Optional list of additional named parameters.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generic function <code><a href="#topic+rmhmodel">rmhmodel</a></code> takes a
description of a point process model in some format, and
converts it into an object of class <code>"rmhmodel"</code>
so that simulations of the model can be generated using
the Metropolis-Hastings algorithm <code><a href="#topic+rmh">rmh</a></code>. 
</p>
<p>This function <code>rmhmodel.list</code> is the method
for lists. The argument <code>model</code> should be a named list of parameters
of the form
</p>
<p><code>list(cif, par, w, trend, types)</code>
</p>
<p>where <code>cif</code> and <code>par</code> are required and the others are
optional. For details about these components,
see <code><a href="#topic+rmhmodel.default">rmhmodel.default</a></code>.
</p>
<p>The subsequent arguments <code>...</code> (if any) may also
have these names, and they will take precedence over
elements of the list <code>model</code>. 
</p>


<h3>Value</h3>

<p>An object of class <code>"rmhmodel"</code>, which is essentially
a validated list of parameter values for the model.
</p>
<p>There is a <code>print</code> method for this class, which prints
a sensible description of the model chosen.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Diggle, P. J. (2003) <em>Statistical Analysis of Spatial Point
Patterns</em> (2nd ed.) Arnold, London.
</p>
<p>Diggle, P.J. and Gratton, R.J. (1984)
Monte Carlo methods of inference for implicit statistical models.
<em>Journal of the Royal Statistical Society, series B</em>
<b>46</b>, 193 &ndash; 212.
</p>
<p>Diggle, P.J., Gates, D.J., and Stibbard, A. (1987)
A nonparametric estimator for pairwise-interaction point processes.
Biometrika <b>74</b>, 763 &ndash; 770.
<em>Scandinavian Journal of Statistics</em> <b>21</b>, 359&ndash;373.
</p>
<p>Geyer, C.J. (1999)
Likelihood Inference for Spatial Point
Processes. Chapter 3 in  O.E. Barndorff-Nielsen, W.S. Kendall and
M.N.M. Van Lieshout (eds) <em>Stochastic Geometry: Likelihood and
Computation</em>, Chapman and Hall / CRC,  Monographs on Statistics and
Applied Probability, number 80. Pages 79&ndash;140.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmhmodel">rmhmodel</a></code>,
<code><a href="#topic+rmhmodel.default">rmhmodel.default</a></code>,
<code><a href="spatstat.model.html#topic+rmhmodel.ppm">rmhmodel.ppm</a></code>,
<code><a href="#topic+rmh">rmh</a></code>,
<code><a href="#topic+rmhcontrol">rmhcontrol</a></code>,
<code><a href="#topic+rmhstart">rmhstart</a></code>,
<code><a href="spatstat.model.html#topic+ppm">ppm</a></code>,
<code><a href="spatstat.model.html#topic+Strauss">Strauss</a></code>,
<code><a href="spatstat.model.html#topic+Softcore">Softcore</a></code>,
<code><a href="spatstat.model.html#topic+StraussHard">StraussHard</a></code>,
<code><a href="spatstat.model.html#topic+MultiStrauss">MultiStrauss</a></code>,
<code><a href="spatstat.model.html#topic+MultiStraussHard">MultiStraussHard</a></code>,
<code><a href="spatstat.model.html#topic+DiggleGratton">DiggleGratton</a></code>,
<code><a href="spatstat.model.html#topic+PairPiece">PairPiece</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # Strauss process:
   mod01 &lt;- list(cif="strauss",par=list(beta=2,gamma=0.2,r=0.7),
                 w=c(0,10,0,10))
   mod01 &lt;- rmhmodel(mod01)

   # Strauss with hardcore:
   mod04 &lt;- list(cif="straush",par=list(beta=2,gamma=0.2,r=0.7,hc=0.3),
                w=owin(c(0,10),c(0,5)))
   mod04 &lt;- rmhmodel(mod04)

   # Soft core:
   w    &lt;- square(10)
   mod07 &lt;- list(cif="sftcr",
                     par=list(beta=0.8,sigma=0.1,kappa=0.5),
                     w=w)
   mod07 &lt;- rmhmodel(mod07)
   
   # Multitype Strauss:
   beta &lt;- c(0.027,0.008)
   gmma &lt;- matrix(c(0.43,0.98,0.98,0.36),2,2)
   r    &lt;- matrix(c(45,45,45,45),2,2)
   mod08 &lt;- list(cif="straussm",
                     par=list(beta=beta,gamma=gmma,radii=r),
                     w=square(250))
   mod08 &lt;- rmhmodel(mod08)

   # specify types
   mod09 &lt;- rmhmodel(list(cif="straussm",
                     par=list(beta=beta,gamma=gmma,radii=r),
                     w=square(250),
                     types=c("A", "B")))

   # Multitype Strauss hardcore with trends for each type:
   beta  &lt;- c(0.27,0.08)
   ri    &lt;- matrix(c(45,45,45,45),2,2)
   rhc  &lt;- matrix(c(9.1,5.0,5.0,2.5),2,2)
   tr3   &lt;- function(x,y){x &lt;- x/250; y &lt;- y/250;
   			   exp((6*x + 5*y - 18*x^2 + 12*x*y - 9*y^2)/6)
                         }
                         # log quadratic trend
   tr4   &lt;- function(x,y){x &lt;- x/250; y &lt;- y/250;
                         exp(-0.6*x+0.5*y)}
                        # log linear trend
   mod10 &lt;- list(cif="straushm",par=list(beta=beta,gamma=gmma,
                 iradii=ri,hradii=rhc),w=c(0,250,0,250),
                 trend=list(tr3,tr4))
   mod10 &lt;- rmhmodel(mod10)

   # Lookup (interaction function h_2 from page 76, Diggle (2003)):
   r &lt;- seq(from=0,to=0.2,length=101)[-1] # Drop 0.
   h &lt;- 20*(r-0.05)
   h[r&lt;0.05] &lt;- 0
   h[r&gt;0.10] &lt;- 1
   mod17 &lt;- list(cif="lookup",par=list(beta=4000,h=h,r=r),w=c(0,1,0,1))
   mod17 &lt;- rmhmodel(mod17)
</code></pre>

<hr>
<h2 id='rmhstart'>Determine Initial State for Metropolis-Hastings Simulation.</h2><span id='topic+rmhstart'></span><span id='topic+rmhstart.default'></span>

<h3>Description</h3>

<p>Builds a description of the initial state
for the Metropolis-Hastings
algorithm. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   rmhstart(start, ...)
   ## Default S3 method:
rmhstart(start=NULL, ..., n.start=NULL, x.start=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmhstart_+3A_start">start</code></td>
<td>
<p>An existing description of the initial state in some
format. Incompatible with the arguments listed below.
</p>
</td></tr>
<tr><td><code id="rmhstart_+3A_...">...</code></td>
<td>
<p>There should be no other arguments.</p>
</td></tr>
<tr><td><code id="rmhstart_+3A_n.start">n.start</code></td>
<td>

<p>Number of initial points (to be randomly generated).
Incompatible with <code>x.start</code>.
</p>
</td></tr>
<tr><td><code id="rmhstart_+3A_x.start">x.start</code></td>
<td>

<p>Initial point pattern configuration.
Incompatible with <code>n.start</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulated realisations of many point process models
can be generated using the Metropolis-Hastings algorithm
implemented in <code><a href="#topic+rmh">rmh</a></code>.
</p>
<p>This function <code>rmhstart</code>
creates a full description of the initial state of the
Metropolis-Hastings algorithm,
<em>including possibly the initial state of the random number generator</em>,
for use in a subsequent call to <code><a href="#topic+rmh">rmh</a></code>. It also
checks that the initial state is valid.
</p>
<p>The initial state should be specified <b>either</b> by the
first argument <code>start</code> <b>or</b> by the other arguments
<code>n.start</code>, <code>x.start</code> etc.
</p>
<p>If <code>start</code> is a list, then it should have components named 
<code>n.start</code> or <code>x.start</code>,
with the same interpretation as described below.
</p>
<p>The arguments are:
</p>

<dl>
<dt>n.start</dt><dd>
<p>The number of &ldquo;initial&rdquo; points to be randomly
(uniformly) generated in the simulation window <code>w</code>.
Incompatible with <code>x.start</code>.
</p>
<p>For a multitype point process, <code>n.start</code> may be a vector
(of length equal to the number of types) giving the number
of points of each type to be generated.  
</p>
<p>If expansion of the simulation window is selected (see the argument
<code>expand</code> to <code><a href="#topic+rmhcontrol">rmhcontrol</a></code>),
then the actual number of starting points in the simulation
will be <code>n.start</code> multiplied by the expansion factor
(ratio of the areas of the expanded window and original window).
</p>
<p>For faster convergence of the Metropolis-Hastings algorithm,
the value of <code>n.start</code> should be roughly equal to
(an educated guess at) the expected number of points
for the point process inside the window.
</p>
</dd>
<dt>x.start</dt><dd>
<p>Initial point pattern configuration. Incompatible with
<code>n.start</code>.
</p>
<p><code>x.start</code> may be a point pattern (an object
of class <code>ppp</code>), or an object which can be coerced
to this class by <code>as.ppp</code>, or a dataset containing
vectors <code>x</code> and <code>y</code>.  
</p>
<p>If <code>x.start</code> is specified, then expansion of the
simulation window (the argument <code>expand</code>
of <code><a href="#topic+rmhcontrol">rmhcontrol</a></code>) is not permitted.
</p>
</dd>
</dl>

<p>The parameters <code>n.start</code> and <code>x.start</code> are
<em>incompatible</em>.
</p>


<h3>Value</h3>

<p>An object of class <code>"rmhstart"</code>, which is essentially
a list of parameters describing the initial point pattern
and (optionally) the initial state of the random number generator.
</p>
<p>There is a <code>print</code> method for this class, which prints
a sensible description of the initial state.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmh">rmh</a></code>,
<code><a href="#topic+rmhcontrol">rmhcontrol</a></code>,
<code><a href="#topic+rmhmodel">rmhmodel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # 30 random points
   a &lt;- rmhstart(n.start=30)
   a

   # a particular point pattern
   b &lt;- rmhstart(x.start=cells)
</code></pre>

<hr>
<h2 id='rMosaicField'>Mosaic Random Field</h2><span id='topic+rMosaicField'></span>

<h3>Description</h3>

<p>Generate a realisation of a random field
which is piecewise constant on the tiles of a given tessellation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rMosaicField(X, 
    rgen = function(n) { sample(0:1, n, replace = TRUE)},
    ...,
    rgenargs=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rMosaicField_+3A_x">X</code></td>
<td>

<p>A tessellation (object of class <code>"tess"</code>).
</p>
</td></tr>
<tr><td><code id="rMosaicField_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code>
determining the pixel resolution.
</p>
</td></tr>
<tr><td><code id="rMosaicField_+3A_rgen">rgen</code></td>
<td>

<p>Function that generates random values for the
tiles of the tessellation.
</p>
</td></tr>
<tr><td><code id="rMosaicField_+3A_rgenargs">rgenargs</code></td>
<td>

<p>List containing extra arguments that should be passed
to <code>rgen</code> (typically specifying parameters of the
distribution of the values).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a realisation of a random field
which is piecewise constant on the tiles of the given
tessellation <code>X</code>. The values in each tile
are independent and identically distributed.
</p>


<h3>Value</h3>

<p>A pixel image (object of class <code>"im"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+rpoislinetess">rpoislinetess</a></code>,
<code><a href="#topic+rMosaicSet">rMosaicSet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   if(interactive()) {
     lambda &lt;- 3
     d &lt;- 256
     n &lt;- 30
   } else {
     lambda &lt;- 1
     d &lt;- 32
     n &lt;- 5
   }
   X &lt;- rpoislinetess(lambda)
   plot(rMosaicField(X, runif, dimyx=d))
   plot(rMosaicField(X, rnorm, rgenargs=list(mean=10, sd=2), dimyx=d))
   Y &lt;- dirichlet(runifpoint(n))
   plot(rMosaicField(Y, rnorm, dimyx=d))
</code></pre>

<hr>
<h2 id='rMosaicSet'>Mosaic Random Set</h2><span id='topic+rMosaicSet'></span>

<h3>Description</h3>

<p>Generate a random set by taking a random selection of 
tiles of a given tessellation.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rMosaicSet(X, p=0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rMosaicSet_+3A_x">X</code></td>
<td>

<p>A tessellation (object of class <code>"tess"</code>).
</p>
</td></tr>
<tr><td><code id="rMosaicSet_+3A_p">p</code></td>
<td>

<p>Probability of including a given tile.
A number strictly between 0 and 1.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a tessellation <code>X</code>, this function 
randomly selects some of the tiles of <code>X</code>,
including each tile with probability <code class="reqn">p</code> independently of
the other tiles. The selected tiles are then combined to form a
set in the plane. 
</p>
<p>One application of this is Switzer's (1965) example of a random set
which has a Markov property. It is constructed by generating <code>X</code>
according to a Poisson line tessellation (see <code><a href="#topic+rpoislinetess">rpoislinetess</a></code>).
</p>


<h3>Value</h3>

<p>A window (object of class <code>"owin"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a></p>


<h3>References</h3>

<p>Switzer, P.
A random set process in the plane with a Markovian property.
<em>Annals of Mathematical Statistics</em> <b>36</b> (1965) 1859&ndash;1863.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpoislinetess">rpoislinetess</a></code>,
<code><a href="#topic+rMosaicField">rMosaicField</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    if(interactive()) {
     lambda &lt;- 3
     n &lt;- 30
   } else {
     lambda &lt;- 1
     n &lt;- 5
   }
  # Switzer's random set
   X &lt;- rpoislinetess(lambda)
   plot(rMosaicSet(X, 0.5), col="green", border=NA)

   # another example
   Y &lt;- dirichlet(runifpoint(n))
   plot(rMosaicSet(Y, 0.4))
</code></pre>

<hr>
<h2 id='rmpoint'>Generate N Random Multitype Points</h2><span id='topic+rmpoint'></span>

<h3>Description</h3>

<p>Generate a random multitype point pattern
with a fixed number of points, or a fixed number of points of each type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> rmpoint(n, f=1, fmax=NULL, win=unit.square(),
         types, ptypes,
         ..., giveup=1000, verbose=FALSE,
         nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmpoint_+3A_n">n</code></td>
<td>

<p>Number of marked points to generate.
Either a single number specifying the total number of points,
or a vector specifying the number of points of each type.
</p>
</td></tr>
<tr><td><code id="rmpoint_+3A_f">f</code></td>
<td>

<p>The probability density of the multitype points,
usually un-normalised.
Either a constant, a vector,
a function <code>f(x,y,m, ...)</code>, a pixel image,
a list of functions <code>f(x,y,...)</code>
or a list of pixel images.
</p>
</td></tr>
<tr><td><code id="rmpoint_+3A_fmax">fmax</code></td>
<td>

<p>An upper bound on the values of <code>f</code>.
If missing, this number will be estimated.
</p>
</td></tr>
<tr><td><code id="rmpoint_+3A_win">win</code></td>
<td>

<p>Window in which to simulate the pattern.
Ignored if <code>f</code> is a pixel image or list of pixel images.
</p>
</td></tr>
<tr><td><code id="rmpoint_+3A_types">types</code></td>
<td>

<p>All the possible types for the multitype pattern. 
</p>
</td></tr>
<tr><td><code id="rmpoint_+3A_ptypes">ptypes</code></td>
<td>

<p>Optional vector of probabilities for each type.
</p>
</td></tr>
<tr><td><code id="rmpoint_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code>f</code> if it is a function.
</p>
</td></tr>
<tr><td><code id="rmpoint_+3A_giveup">giveup</code></td>
<td>

<p>Number of attempts in the rejection method after which
the algorithm should stop trying to generate new points.
</p>
</td></tr>
<tr><td><code id="rmpoint_+3A_verbose">verbose</code></td>
<td>

<p>Flag indicating whether to report details of performance
of the simulation algorithm.
</p>
</td></tr>
<tr><td><code id="rmpoint_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rmpoint_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates random multitype point patterns
consisting of a fixed number of points.
</p>
<p>Three different models are available:
</p>

<dl>
<dt>I. Random location and type:</dt><dd>
<p>If <code>n</code> is a single number and the argument <code>ptypes</code> is missing,
then <code>n</code> independent, identically distributed
random multitype points are generated.
Their locations
<code>(x[i],y[i])</code> and types <code>m[i]</code> have
joint probability density proportional to <code class="reqn">f(x,y,m)</code>.
</p>
</dd>
<dt>II. Random type, and random location given type:</dt><dd>
<p>If <code>n</code> is a single number and <code>ptypes</code> is given,
then <code>n</code> independent, identically distributed
random multitype points are generated.
Their types <code>m[i]</code> have probability distribution
<code>ptypes</code>. Given the types, the locations <code>(x[i],y[i])</code>
have conditional probability density proportional to
<code class="reqn">f(x,y,m)</code>.
</p>
</dd>
<dt>III. Fixed types, and random location given type:</dt><dd>
<p>If <code>n</code> is a vector, then we generate <code>n[i]</code>
independent, identically distributed random points of type
<code>types[i]</code>. For points of type <code class="reqn">m</code> the conditional probability
density of location <code class="reqn">(x,y)</code> is proportional to
<code class="reqn">f(x,y,m)</code>.
</p>
</dd>
</dl>

<p>Note that the density <code>f</code> is normalised in different ways
in Model I and Models II and III. In Model I the normalised
joint density is <code class="reqn">g(x,y,m)=f(x,y,m)/Z</code> where
</p>
<p style="text-align: center;"><code class="reqn">
    Z = \sum_m \int\int \lambda(x,y,m) {\rm d}x \, {\rm d}y
  </code>
</p>

<p>while in Models II and III the normalised conditional density
is <code class="reqn">g(x,y\mid m) = f(x,y,m)/Z_m</code>
where
</p>
<p style="text-align: center;"><code class="reqn">
    Z_m = \int\int \lambda(x,y,m)  {\rm d}x \, {\rm d}y.
  </code>
</p>

<p>In Model I, the marginal distribution of types
is <code class="reqn">p_m = Z_m/Z</code>.
</p>
<p>The unnormalised density <code>f</code> may be specified
in any of the following ways.
</p>

<dl>
<dt>single number:</dt><dd>
<p>If <code>f</code> is a single number, the conditional density of
location given type is uniform. That is, the points of each type
are uniformly distributed.
In Model I, the marginal distribution of types is also uniform
(all possible types have equal probability).
</p>
</dd>
<dt>vector:</dt><dd>
<p>If <code>f</code> is a numeric vector, the conditional density of
location given type is uniform. That is, the points of each type
are uniformly distributed.
In Model I, the marginal distribution of types is
proportional to the vector <code>f</code>. In Model II, the marginal
distribution of types is <code>ptypes</code>, that is, the values in
<code>f</code> are ignored.
The argument <code>types</code> defaults to <code>names(f)</code>,
or if that is null, <code>1:length(f)</code>.
</p>
</dd>
<dt>function:</dt><dd>
<p>If <code>f</code> is a function, it will be called in the form
<code>f(x,y,m,...)</code> at spatial location <code>(x,y)</code>
for points of type <code>m</code>.
In Model I, the joint probability density of location and type is
proportional to <code>f(x,y,m,...)</code>.
In Models II and III, the conditional probability density of
location <code>(x,y)</code> given type <code>m</code> is
proportional to <code>f(x,y,m,...)</code>.
The function <code>f</code> must work correctly with vectors <code>x</code>,
<code>y</code> and <code>m</code>, returning a vector of function values.
(Note that <code>m</code> will be a factor
with levels <code>types</code>.)
The value <code>fmax</code> must be given and must be an upper bound on the 
values of <code>f(x,y,m,...)</code> for all locations <code>(x, y)</code>
inside the window <code>win</code> and all types <code>m</code>.
The argument <code>types</code> must be given.
</p>
</dd>
<dt>list of functions:</dt><dd>
<p>If <code>f</code> is a list of functions, then the functions will be
called in the form <code>f[[i]](x,y,...)</code> at spatial
location <code>(x,y)</code> for points of type <code>types[i]</code>.
In Model I, the joint probability density of location and type is
proportional to <code>f[[m]](x,y,...)</code>.
In Models II and III, the conditional probability density of
location <code>(x,y)</code> given type <code>m</code> is
proportional to <code>f[[m]](x,y,...)</code>.
The function <code>f[[i]]</code> must work correctly with vectors
<code>x</code> and <code>y</code>, returning a vector of function values.
The value <code>fmax</code> must be given and must be an upper bound on the 
values of <code>f[[i]](x,y,...)</code> for all locations <code>(x, y)</code>
inside the window <code>win</code>. 
The argument <code>types</code> defaults to <code>names(f)</code>,
or if that is null, <code>1:length(f)</code>.
</p>
</dd>
<dt>pixel image:</dt><dd>
<p>If <code>f</code> is a pixel image object of class <code>"im"</code>
(see <code>im.object</code>), the unnormalised density at a location
<code>(x,y)</code> for points of any type is equal to the pixel value
of <code>f</code> for the pixel nearest to <code>(x,y)</code>.
In Model I, the marginal distribution of types is uniform.
The argument <code>win</code> is ignored;
the window of the pixel image is used instead.
The argument <code>types</code> must be given.
</p>
</dd>
<dt>list of pixel images:</dt><dd>
<p>If <code>f</code> is a list of pixel images,
then the image <code>f[[i]]</code> determines the density values
of points of type <code>types[i]</code>. 
The argument <code>win</code> is ignored;
the window of the pixel image is used instead.
The argument <code>types</code> defaults to <code>names(f)</code>,
or if that is null, <code>1:length(f)</code>.
</p>
</dd>
</dl>

<p>The implementation uses the rejection method.
For Model I, <code><a href="#topic+rmpoispp">rmpoispp</a></code> is called repeatedly
until <code>n</code> points have been generated.
It gives up after <code>giveup</code> calls
if there are still fewer than <code>n</code> points.
For Model II, the types are first generated according to
<code>ptypes</code>, then
the locations of the points of each type
are generated using <code><a href="#topic+rpoint">rpoint</a></code>.
For Model III,   the locations of the points of each type
are generated using <code><a href="#topic+rpoint">rpoint</a></code>.
</p>


<h3>Value</h3>

<p>A point pattern (an object of class <code>"ppp"</code>) if <code>nsim=1</code>,
or a list of point patterns if <code>nsim &gt; 1</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code>ppp.object</code>,
<code>owin.object</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
abc &lt;- c("a","b","c")

##### Model I

rmpoint(25, types=abc)
rmpoint(25, 1, types=abc)
# 25 points, equal probability for each type, uniformly distributed locations

rmpoint(25, function(x,y,m) {rep(1, length(x))}, types=abc)
# same as above
rmpoint(25, list(function(x,y){rep(1, length(x))},
                 function(x,y){rep(1, length(x))},
                 function(x,y){rep(1, length(x))}),
             types=abc)
# same as above

rmpoint(25, function(x,y,m) { x }, types=abc)
# 25 points, equal probability for each type,
# locations nonuniform with density proportional to x

rmpoint(25, function(x,y,m) { ifelse(m == "a", 1, x) }, types=abc)
rmpoint(25, list(function(x,y) { rep(1, length(x)) },
                function(x,y) { x },
                function(x,y) { x }),
                types=abc)
# 25 points, UNEQUAL probabilities for each type,
# type "a" points uniformly distributed,
# type "b" and "c" points nonuniformly distributed.

##### Model II

rmpoint(25, 1, types=abc, ptypes=rep(1,3)/3)
rmpoint(25, 1, types=abc, ptypes=rep(1,3))
# 25 points, equal probability for each type,
# uniformly distributed locations

rmpoint(25, function(x,y,m) {rep(1, length(x))}, types=abc, ptypes=rep(1,3))
# same as above
rmpoint(25, list(function(x,y){rep(1, length(x))},
                 function(x,y){rep(1, length(x))},
                 function(x,y){rep(1, length(x))}),
             types=abc, ptypes=rep(1,3))
# same as above

rmpoint(25, function(x,y,m) { x }, types=abc, ptypes=rep(1,3))
# 25 points, equal probability for each type,
# locations nonuniform with density proportional to x

rmpoint(25, function(x,y,m) { ifelse(m == "a", 1, x) }, types=abc, ptypes=rep(1,3))
# 25 points, EQUAL probabilities for each type,
# type "a" points uniformly distributed,
# type "b" and "c" points nonuniformly distributed.

###### Model III

rmpoint(c(12, 8, 4), 1, types=abc)
# 12 points of type "a",
# 8 points of type "b",
# 4 points of type "c",
# each uniformly distributed

rmpoint(c(12, 8, 4), function(x,y,m) { ifelse(m=="a", 1, x)}, types=abc)
rmpoint(c(12, 8, 4), list(function(x,y) { rep(1, length(x)) },
                               function(x,y) { x },
                               function(x,y) { x }),
             types=abc)

# 12 points of type "a", uniformly distributed
# 8 points of type "b", nonuniform
# 4 points of type "c", nonuniform


#########

## Randomising an existing point pattern:
# same numbers of points of each type, uniform random locations (Model III)
rmpoint(table(marks(demopat)), 1, win=Window(demopat))

# same total number of points, distribution of types estimated from X,
# uniform random locations (Model II)
rmpoint(npoints(demopat), 1, types=levels(marks(demopat)), win=Window(demopat),
       ptypes=table(marks(demopat)))

</code></pre>

<hr>
<h2 id='rmpoispp'>Generate Multitype Poisson Point Pattern</h2><span id='topic+rmpoispp'></span>

<h3>Description</h3>

<p>Generate a random point pattern, a realisation of the
(homogeneous or inhomogeneous) multitype Poisson process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> rmpoispp(lambda, lmax=NULL, win, types, ...,
          nsim=1, drop=TRUE, warnwin=!missing(win))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmpoispp_+3A_lambda">lambda</code></td>
<td>

<p>Intensity of the multitype Poisson process.
Either a single positive number, a vector, a <code>function(x,y,m, ...)</code>,
a pixel image, a list of functions <code>function(x,y, ...)</code>,
or a list of pixel images.
</p>
</td></tr>
<tr><td><code id="rmpoispp_+3A_lmax">lmax</code></td>
<td>

<p>An upper bound for the value of <code>lambda</code>.
May be omitted
</p>
</td></tr>
<tr><td><code id="rmpoispp_+3A_win">win</code></td>
<td>

<p>Window in which to simulate the pattern.
An object of class <code>"owin"</code>
or something acceptable to <code>as.owin</code>.
Ignored if <code>lambda</code> is a pixel image or list of images.
</p>
</td></tr>
<tr><td><code id="rmpoispp_+3A_types">types</code></td>
<td>

<p>All the possible types for the multitype pattern.
</p>
</td></tr>
<tr><td><code id="rmpoispp_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code>lambda</code> if it is a function.
</p>
</td></tr>
<tr><td><code id="rmpoispp_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rmpoispp_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
<tr><td><code id="rmpoispp_+3A_warnwin">warnwin</code></td>
<td>

<p>Logical value specifying whether to issue a warning
when <code>win</code> is ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a realisation of the marked Poisson
point process with intensity <code>lambda</code>.
</p>
<p>Note that the intensity function
<code class="reqn">\lambda(x,y,m)</code> is the
average number of points <b>of type m</b> per unit area
near the location <code class="reqn">(x,y)</code>.
Thus a marked point process with a constant intensity of 10
and three possible types will have an average of 30 points per unit
area, with 10 points of each type on average.
</p>
<p>The intensity function may be specified in any of the following ways.
</p>

<dl>
<dt>single number:</dt><dd>
<p>If <code>lambda</code> is a single number,
then this algorithm generates a realisation
of the uniform marked Poisson process inside the window <code>win</code> with 
intensity <code>lambda</code> for each type. The total intensity of
points of all types is <code>lambda * length(types)</code>.
The argument <code>types</code> must be given
and determines the possible types in the multitype pattern.
</p>
</dd>
<dt>vector:</dt><dd>
<p>If <code>lambda</code> is a numeric vector,
then this algorithm generates a realisation
of the stationary marked Poisson process inside the window
<code>win</code> with intensity <code>lambda[i]</code> for points of type
<code>types[i]</code>. The total intensity of points of all types
is <code>sum(lambda)</code>.
The argument <code>types</code> defaults to
<code>names(lambda)</code>, or if that is null, <code>1:length(lambda)</code>.
</p>
</dd>
<dt>function:</dt><dd>
<p>If <code>lambda</code> is a function, the process has intensity
<code>lambda(x,y,m,...)</code> at spatial location <code>(x,y)</code>
for points of type <code>m</code>.
The function <code>lambda</code> must work correctly with vectors <code>x</code>,
<code>y</code> and <code>m</code>, returning a vector of function values.
(Note that <code>m</code> will be a factor
with levels equal to <code>types</code>.)
The value <code>lmax</code>, if present, must be an upper bound on the 
values of <code>lambda(x,y,m,...)</code> for all locations <code>(x, y)</code>
inside the window <code>win</code> and all types <code>m</code>.
The argument <code>types</code> must be given.
</p>
</dd>
<dt>list of functions:</dt><dd>
<p>If <code>lambda</code> is a list of functions,
the process has intensity <code>lambda[[i]](x,y,...)</code> at spatial
location <code>(x,y)</code> for points of type <code>types[i]</code>.
The function <code>lambda[[i]]</code> must work correctly with vectors
<code>x</code> and <code>y</code>, returning a vector of function values.
The value <code>lmax</code>, if given, must be an upper bound on the 
values of <code>lambda(x,y,...)</code> for all locations <code>(x, y)</code>
inside the window <code>win</code>. 
The argument <code>types</code> defaults to
<code>names(lambda)</code>, or if that is null, <code>1:length(lambda)</code>.
</p>
</dd>
<dt>pixel image:</dt><dd>
<p>If <code>lambda</code> is a pixel image object of class <code>"im"</code>
(see <code>im.object</code>), the intensity at a location
<code>(x,y)</code> for points of any type is equal to the pixel value
of <code>lambda</code> for the pixel nearest to <code>(x,y)</code>.
The argument <code>win</code> is ignored;
the window of the pixel image is used instead.
The argument <code>types</code> must be given.
</p>
</dd>
<dt>list of pixel images:</dt><dd>
<p>If <code>lambda</code> is a list of pixel images,
then the image <code>lambda[[i]]</code> determines the intensity
of points of type <code>types[i]</code>. 
The argument <code>win</code> is ignored;
the window of the pixel image is used instead.
The argument <code>types</code> defaults to
<code>names(lambda)</code>, or if that is null, <code>1:length(lambda)</code>.
</p>
</dd>
</dl>

<p>If <code>lmax</code> is missing, an approximate upper bound will be calculated.
</p>
<p>To generate an inhomogeneous Poisson process
the algorithm uses &ldquo;thinning&rdquo;: it first generates a uniform
Poisson process of intensity <code>lmax</code> for points of each type <code>m</code>,
then randomly deletes or retains each point independently,
with retention probability
<code class="reqn">p(x,y,m) = \lambda(x,y,m)/\mbox{lmax}</code>.
</p>


<h3>Value</h3>

<p>A point pattern (an object of class <code>"ppp"</code>) if <code>nsim=1</code>,
or a list of point patterns if <code>nsim &gt; 1</code>.
Each point pattern is multitype (it carries a vector of marks
which is a factor).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpoispp">rpoispp</a></code> for unmarked Poisson point process;
<code><a href="#topic+rmpoint">rmpoint</a></code> for a fixed number of random marked points;
<code>ppp.object</code>,
<code>owin.object</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # uniform bivariate Poisson process with total intensity 100 in unit square
 pp &lt;- rmpoispp(50, types=c("a","b"))
 
 # stationary bivariate Poisson process with intensity A = 30, B = 70
 pp &lt;- rmpoispp(c(30,70), types=c("A","B"))
 pp &lt;- rmpoispp(c(30,70))

 # works in any window
 pp &lt;- rmpoispp(c(30,70), win=letterR, types=c("A","B"))

 # inhomogeneous lambda(x,y,m)
 # note argument 'm' is a factor 
 lam &lt;- function(x,y,m) { 50 * (x^2 + y^3) * ifelse(m=="A", 2, 1)}
 pp &lt;- rmpoispp(lam, win=letterR, types=c("A","B"))
 # extra arguments
 lam &lt;- function(x,y,m,scal) { scal * (x^2 + y^3) * ifelse(m=="A", 2, 1)}
 pp &lt;- rmpoispp(lam, win=letterR, types=c("A","B"), scal=50)

 # list of functions lambda[[i]](x,y)
 lams &lt;- list(function(x,y){50 * x^2}, function(x,y){20 * abs(y)})
 pp &lt;- rmpoispp(lams, win=letterR, types=c("A","B"))
 pp &lt;- rmpoispp(lams, win=letterR)
 # functions with extra arguments
 lams &lt;- list(function(x,y,scal){5 * scal * x^2},
              function(x,y, scal){2 * scal * abs(y)})
 pp &lt;- rmpoispp(lams, win=letterR, types=c("A","B"), scal=10)
 pp &lt;- rmpoispp(lams, win=letterR, scal=10)

 # florid example
 lams &lt;- list(function(x,y){
   			   100*exp((6*x + 5*y - 18*x^2 + 12*x*y - 9*y^2)/6)
                         }
                         # log quadratic trend
              ,
              function(x,y){
                         	   100*exp(-0.6*x+0.5*y)
                         }
                        # log linear trend
              )
  X &lt;- rmpoispp(lams, win=unit.square(), types=c("on", "off"))   

 # pixel image
 Z &lt;- as.im(function(x,y){30 * (x^2 + y^3)}, letterR)
 pp &lt;- rmpoispp(Z, types=c("A","B"))

 # list of pixel images
 ZZ &lt;- list(
          as.im(function(x,y){20 * (x^2 + y^3)}, letterR),
          as.im(function(x,y){40 * (x^3 + y^2)}, letterR))
 pp &lt;- rmpoispp(ZZ, types=c("A","B"))
 pp &lt;- rmpoispp(ZZ)

 # randomising an existing point pattern
 rmpoispp(intensity(amacrine), win=Window(amacrine))
</code></pre>

<hr>
<h2 id='rNeymanScott'>Simulate Neyman-Scott Process</h2><span id='topic+rNeymanScott'></span>

<h3>Description</h3>

<p>Generate a random point pattern, a realisation of the
Neyman-Scott cluster process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> rNeymanScott(kappa, expand, rcluster, win = unit.square(),
              ..., nsim=1, drop=TRUE,
              nonempty=TRUE, saveparents=TRUE,
              kappamax=NULL, mumax=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rNeymanScott_+3A_kappa">kappa</code></td>
<td>

<p>Intensity of the Poisson process of cluster centres.
A single positive number, a function, or a pixel image.
</p>
</td></tr>
<tr><td><code id="rNeymanScott_+3A_expand">expand</code></td>
<td>

<p>Size of the expansion of the simulation window for generating parent
points. A single non-negative number.
</p>
</td></tr>
<tr><td><code id="rNeymanScott_+3A_rcluster">rcluster</code></td>
<td>

<p>A function which generates random clusters,
or other data specifying the random cluster mechanism.
See Details.
</p>
</td></tr>
<tr><td><code id="rNeymanScott_+3A_win">win</code></td>
<td>

<p>Window in which to simulate the pattern.
An object of class <code>"owin"</code>
or something acceptable to <code><a href="spatstat.geom.html#topic+as.owin">as.owin</a></code>.
</p>
</td></tr>
<tr><td><code id="rNeymanScott_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code>rcluster</code>.
</p>
</td></tr>
<tr><td><code id="rNeymanScott_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rNeymanScott_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
<tr><td><code id="rNeymanScott_+3A_nonempty">nonempty</code></td>
<td>

<p>Logical. If <code>TRUE</code> (the default), a more efficient algorithm is
used, in which parents are generated conditionally on having at
least one offspring point. If <code>FALSE</code>, parents are generated
even if they have no offspring. Both choices are valid; the default
is recommended unless you need to simulate all the parent points
for some other purpose.
</p>
</td></tr>
<tr><td><code id="rNeymanScott_+3A_saveparents">saveparents</code></td>
<td>

<p>Logical value indicating whether to save the locations of the
parent points as an attribute.
</p>
</td></tr>
<tr><td><code id="rNeymanScott_+3A_kappamax">kappamax</code></td>
<td>

<p>Optional. Upper bound on the values of <code>kappa</code>
when <code>kappa</code> is a function or pixel image.
</p>
</td></tr>
<tr><td><code id="rNeymanScott_+3A_mumax">mumax</code></td>
<td>

<p>Optional. Upper bound on the values of <code>mu</code>
when <code>mu=rcluster[[1]]</code> is a function or pixel image.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm generates a realisation of the
general Neyman-Scott process, with the cluster mechanism
given by the function <code>rcluster</code>. 
</p>
<p>First, the algorithm generates a Poisson point process of
&ldquo;parent&rdquo; points with intensity <code>kappa</code> in an expanded
window as explained below. Here <code>kappa</code>
may be a single positive number,
a function <code>kappa(x,y)</code>,
or a pixel image object of class <code>"im"</code> (see
<code><a href="spatstat.geom.html#topic+im.object">im.object</a></code>).  See <code><a href="#topic+rpoispp">rpoispp</a></code> for details.
</p>
<p>Second, each parent point is replaced by a random cluster
of points. These clusters are combined together to yield a
single point pattern, and the restriction of this pattern to the
window <code>win</code> is then returned as the result of
<code>rNeymanScott</code>.
</p>
<p>The expanded window consists of <code><a href="spatstat.geom.html#topic+as.rectangle">as.rectangle</a>(win)</code>
extended by the amount <code>expand</code> in each direction. The size of
the expansion is saved in the attribute <code>"expand"</code> and may be
extracted by <code>attr(X, "expand")</code> where <code>X</code> is the generated
point pattern.  
</p>
<p>The argument <code>rcluster</code> specifies the cluster mechanism.
It may be either:
</p>

<ul>
<li>
<p>A <code>function</code> which will be called to generate each random
cluster (the offspring points of each parent point).
The function should expect to be called
in the form <code>rcluster(x0,y0,...)</code> for a parent point at a location
<code>(x0,y0)</code>. The return value of <code>rcluster</code>
should specify the coordinates of the points in the cluster;
it may be a list containing elements
<code>x,y</code>, or a point pattern (object of
class <code>"ppp"</code>). If it is a marked point pattern then the result of
<code>rNeymanScott</code> will be a marked point pattern.
</p>
</li>
<li>
<p>A <code>list(mu, f)</code> where <code>mu</code> specifies the mean
number of offspring points in each cluster, and <code>f</code>
generates the random displacements (vectors pointing from the parent
to the offspring). In this case, the number of offspring
in a cluster is assumed to have a Poisson distribution, implying
that the Neyman-Scott process is also a Cox process.
The first element <code>mu</code> should be either a single nonnegative
number (interpreted as the mean of the Poisson distribution of
cluster size)
or a pixel image or a <code>function(x,y)</code> giving a spatially
varying mean cluster size (interpreted in the sense of
Waagepetersen, 2007).
The second element <code>f</code> should be a function that will be
called once in the form <code>f(n)</code> to generate <code>n</code> independent
and identically distributed displacement vectors (i.e. as if there
were a cluster of size <code>n</code> with a parent at the origin
<code>(0,0)</code>). 
The function should return
a point pattern (object of class <code>"ppp"</code>)
or something acceptable to <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code>
that specifies the coordinates of <code>n</code> points. 
</p>
</li></ul>

<p>If required, the intermediate stages of the simulation (the
parents and the individual clusters) can also be extracted from
the return value of <code>rNeymanScott</code> through the attributes
<code>"parents"</code> and <code>"parentid"</code>.  The attribute
<code>"parents"</code> is the point pattern of parent points.
The attribute <code>"parentid"</code> is an integer vector specifying
the parent for each of the points in the simulated pattern.
</p>
<p>Neyman-Scott models where <code>kappa</code> is a single number
and <code>rcluster = list(mu,f)</code> can be fitted to data
using the function <code><a href="spatstat.model.html#topic+kppm">kppm</a></code>.
</p>


<h3>Value</h3>

<p>A point pattern (an object of class <code>"ppp"</code>) if <code>nsim=1</code>,
or a list of point patterns if <code>nsim &gt; 1</code>.
</p>
<p>Additionally,  some intermediate results of the simulation are
returned as attributes of this point pattern: see Details.
</p>


<h3>Inhomogeneous Neyman-Scott Processes</h3>

<p>There are several different ways of specifying a spatially inhomogeneous
Neyman-Scott process:
</p>

<ul>
<li>
<p>The point process of parent points can be inhomogeneous. 
If the argument <code>kappa</code> is a <code>function(x,y)</code> or a pixel
image (object of class <code>"im"</code>), then it is taken as specifying
the intensity function of an inhomogeneous Poisson process according
to which the parent points are generated.
</p>
</li>
<li>
<p>The number of points in a typical cluster can
be spatially varying.
If the argument <code>rcluster</code> is a list of two elements
<code>mu, f</code> and the first entry <code>mu</code> is a 
<code>function(x,y)</code> or a pixel image (object of class <code>"im"</code>),
then <code>mu</code> is interpreted as the reference intensity
for offspring points, in the sense of Waagepetersen (2007).
For a given parent point, the offspring constitute a Poisson process
with intensity function equal to <code>mu(x, y) * g(x-x0, y-y0)</code>
where <code>g</code> is the probability density of the offspring
displacements generated by the function <code>f</code>.
</p>
<p>Equivalently, clusters are first generated with a constant
expected number of points per cluster: the constant is <code>mumax</code>, the
maximum of <code>mu</code>. Then the offspring are randomly <em>thinned</em>
(see <code><a href="#topic+rthin">rthin</a></code>) with spatially-varying retention
probabilities given by <code>mu/mumax</code>.  
</p>
</li>
<li>
<p>The entire mechanism for generating a cluster can
be dependent on the location of the parent point.
If the argument <code>rcluster</code> is a function,
then the cluster associated with a parent point at location
<code>(x0,y0)</code> will be generated by calling
<code>rcluster(x0, y0, ...)</code>. The behaviour of this function
could depend on the location <code>(x0,y0)</code> in any fashion.
</p>
</li></ul>

<p>Note that if <code>kappa</code> is an
image, the spatial domain covered by this image must be large
enough to include the <em>expanded</em> window in which the parent
points are to be generated. This requirement means that <code>win</code> must
be small enough so that the expansion of <code>as.rectangle(win)</code>
is contained in the spatial domain of <code>kappa</code>.  As a result,
one may wind up having to simulate the process in a window smaller
than what is really desired.
</p>
<p>In the first two cases, the intensity of the Neyman-Scott process
is equal to <code>kappa * mu</code> if at least one of <code>kappa</code> or
<code>mu</code> is a single number, and is otherwise equal to an
integral involving <code>kappa</code>, <code>mu</code> and <code>f</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Neyman, J. and Scott, E.L. (1958)
A statistical approach to problems of cosmology.
<em>Journal of the Royal Statistical Society, Series B</em>
<b>20</b>, 1&ndash;43.
</p>
<p>Waagepetersen, R. (2007)
An estimating function approach to inference for
inhomogeneous Neyman-Scott processes.
<em>Biometrics</em> <b>63</b>, 252&ndash;258.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpoispp">rpoispp</a></code>,
<code><a href="#topic+rThomas">rThomas</a></code>,
<code><a href="#topic+rGaussPoisson">rGaussPoisson</a></code>,
<code><a href="#topic+rMatClust">rMatClust</a></code>,
<code><a href="#topic+rCauchy">rCauchy</a></code>,
<code><a href="#topic+rVarGamma">rVarGamma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # each cluster consist of 10 points in a disc of radius 0.2
  nclust &lt;- function(x0, y0, radius, n) {
              return(runifdisc(n, radius, centre=c(x0, y0)))
            }
  plot(rNeymanScott(10, 0.2, nclust, radius=0.2, n=5))

  # multitype Neyman-Scott process (each cluster is a multitype process)
  nclust2 &lt;- function(x0, y0, radius, n, types=c("a", "b")) {
     X &lt;- runifdisc(n, radius, centre=c(x0, y0))
     M &lt;- sample(types, n, replace=TRUE)
     marks(X) &lt;- M
     return(X)
  }
  plot(rNeymanScott(15,0.1,nclust2, radius=0.1, n=5))
</code></pre>

<hr>
<h2 id='rnoise'>
Random Pixel Noise
</h2><span id='topic+rnoise'></span>

<h3>Description</h3>

<p>Generate a pixel image whose pixel values are random numbers
following a specified probability distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnoise(rgen = runif, w = square(1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnoise_+3A_rgen">rgen</code></td>
<td>

<p>Random generator for the pixel values.
A function in the <span class="rlang"><b>R</b></span> language.
</p>
</td></tr>
<tr><td><code id="rnoise_+3A_w">w</code></td>
<td>

<p>Window (region or pixel raster) in which to generate the image.
Any data acceptable to <code><a href="grid.html#topic+as.mask">as.mask</a></code>.
</p>
</td></tr>
<tr><td><code id="rnoise_+3A_...">...</code></td>
<td>

<p>Arguments, matched by name,
to be passed to <code>rgen</code> to specify the parameters of the
probability distribution, or passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code>
to control the pixel resolution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>w</code> could be a window (class <code>"owin"</code>),
a pixel image (class <code>"im"</code>) or other data. It is 
first converted to a binary mask by <code><a href="grid.html#topic+as.mask">as.mask</a></code>
using any relevant arguments in <code>...</code>.
</p>
<p>Then each pixel inside the window (i.e. with logical value
<code>TRUE</code> in the mask) is assigned a random numerical value
by calling the function <code>rgen</code>.
</p>
<p>The function <code>rgen</code> would typically be one of the standard
random variable generators like <code><a href="stats.html#topic+runif">runif</a></code> (uniformly
distributed random values) or <code><a href="stats.html#topic+rnorm">rnorm</a></code> (Gaussian random
values). Its first argument <code>n</code> is the number of values to be
generated. Other arguments to <code>rgen</code> must be matched by name.
</p>


<h3>Value</h3>

<p>A pixel image (object of class <code>"im"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="grid.html#topic+as.mask">as.mask</a></code>,
<code>as.im</code>,
<code><a href="stats.html#topic+Distributions">Distributions</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(rnoise(), main="Uniform noise")
  plot(rnoise(rnorm, dimyx=32, mean=2, sd=1),
       main="White noise")
</code></pre>

<hr>
<h2 id='rPenttinen'>Perfect Simulation of the Penttinen Process</h2><span id='topic+rPenttinen'></span>

<h3>Description</h3>

<p>Generate a random pattern of points, a simulated realisation
of the Penttinen process, using a perfect simulation algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rPenttinen(beta, gamma=1, R, W = owin(), expand=TRUE, nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rPenttinen_+3A_beta">beta</code></td>
<td>

<p>intensity parameter (a positive number).
</p>
</td></tr>
<tr><td><code id="rPenttinen_+3A_gamma">gamma</code></td>
<td>

<p>Interaction strength parameter (a number between 0 and 1).
</p>
</td></tr>
<tr><td><code id="rPenttinen_+3A_r">R</code></td>
<td>

<p>disc radius (a non-negative number).
</p>
</td></tr>
<tr><td><code id="rPenttinen_+3A_w">W</code></td>
<td>

<p>window (object of class <code>"owin"</code>) in which to
generate the random pattern. 
</p>
</td></tr>
<tr><td><code id="rPenttinen_+3A_expand">expand</code></td>
<td>

<p>Logical. If <code>FALSE</code>, simulation is performed
in the window <code>W</code>, which must be rectangular.
If <code>TRUE</code> (the default), simulation is performed
on a larger window, and the result is clipped to the original
window <code>W</code>.
Alternatively <code>expand</code> can be an object of class 
<code>"rmhexpand"</code> (see <code><a href="#topic+rmhexpand">rmhexpand</a></code>)
determining the expansion method.
</p>
</td></tr>
<tr><td><code id="rPenttinen_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>  
<tr><td><code id="rPenttinen_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a realisation of the 
Penttinen point process in the window <code>W</code>
using a &lsquo;perfect simulation&rsquo; algorithm.
</p>
<p>Penttinen (1984, Example 2.1, page 18), citing Cormack (1979),
described the pairwise interaction point process with interaction factor
</p>
<p style="text-align: center;"><code class="reqn">
    h(d) = e^{\theta A(d)} = \gamma^{A(d)}
  </code>
</p>

<p>between each pair of points separated by a distance $d$.
Here <code class="reqn">A(d)</code> is the area of intersection between two discs
of radius <code class="reqn">R</code> separated by a distance <code class="reqn">d</code>, normalised so that
<code class="reqn">A(0) = 1</code>.
</p>
<p>The simulation algorithm used to generate the point pattern
is &lsquo;dominated coupling from the past&rsquo;
as implemented by
Berthelsen and Moller (2002, 2003).
This is a &lsquo;perfect simulation&rsquo; or &lsquo;exact simulation&rsquo;
algorithm, so called because the output of the algorithm is guaranteed
to have the correct probability distribution exactly (unlike the
Metropolis-Hastings algorithm used in <code><a href="#topic+rmh">rmh</a></code>, whose output
is only approximately correct).
</p>
<p>There is a tiny chance that the algorithm will 
run out of space before it has terminated. If this occurs, an error
message will be generated.
</p>


<h3>Value</h3>

<p>If <code>nsim = 1</code>, a point pattern (object of class <code>"ppp"</code>).
If <code>nsim &gt; 1</code>, a list of point patterns.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>,
based on original code for the Strauss process by 
Kasper Klitgaard Berthelsen.
</p>


<h3>References</h3>

<p>Berthelsen, K.K. and Moller, J. (2002)
A primer on perfect simulation for spatial point processes.
<em>Bulletin of the Brazilian Mathematical Society</em> 33, 351-367.
</p>
<p>Berthelsen, K.K. and Moller, J. (2003)
Likelihood and non-parametric Bayesian MCMC inference 
for spatial point processes based on perfect simulation and
path sampling. 
<em>Scandinavian Journal of Statistics</em> 30, 549-564.
</p>
<p>Cormack, R.M. (1979)
Spatial aspects of competition between individuals.
Pages 151&ndash;212 in <em>Spatial and Temporal Analysis in Ecology</em>,
eds. R.M. Cormack and J.K. Ord, International Co-operative
Publishing House, Fairland, MD, USA. 
</p>
<p>Moller, J. and Waagepetersen, R. (2003).
<em>Statistical Inference and Simulation for Spatial Point Processes.</em>
Chapman and Hall/CRC.
</p>
<p>Penttinen, A. (1984) 
<em>Modelling Interaction in Spatial Point Patterns:
Parameter Estimation by the Maximum Likelihood Method.</em>
Jyvaskyla Studies in Computer Science, Economics and Statistics <b>7</b>,
University of Jyvaskyla, Finland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmh">rmh</a></code>,
</p>
<p><code><a href="#topic+rStrauss">rStrauss</a></code>,
<code><a href="#topic+rHardcore">rHardcore</a></code>,
<code><a href="#topic+rStraussHard">rStraussHard</a></code>,
<code><a href="#topic+rDiggleGratton">rDiggleGratton</a></code>,
<code><a href="#topic+rDGS">rDGS</a></code>.
</p>
<p><code><a href="spatstat.model.html#topic+Penttinen">Penttinen</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- rPenttinen(50, 0.5, 0.02)
   Z &lt;- rPenttinen(50, 0.5, 0.01, nsim=2)
</code></pre>

<hr>
<h2 id='rpoint'>Generate N Random Points</h2><span id='topic+rpoint'></span>

<h3>Description</h3>

<p>Generate a random point pattern
containing <code class="reqn">n</code> independent, identically distributed random points
with any specified distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> rpoint(n, f, fmax=NULL, win=unit.square(),
        ..., giveup=1000, warn=TRUE, verbose=FALSE,
        nsim=1, drop=TRUE, forcewin=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpoint_+3A_n">n</code></td>
<td>

<p>Number of points to generate.
</p>
</td></tr>
<tr><td><code id="rpoint_+3A_f">f</code></td>
<td>

<p>The probability density of the points,
possibly un-normalised.
Either a constant,
a function <code>f(x,y,...)</code>, or a pixel image object.
</p>
</td></tr>
<tr><td><code id="rpoint_+3A_fmax">fmax</code></td>
<td>

<p>An upper bound on the values of <code>f</code>.
If missing, this number will be estimated.
</p>
</td></tr>
<tr><td><code id="rpoint_+3A_win">win</code></td>
<td>

<p>Window in which to simulate the pattern.
(Ignored if <code>f</code> is a pixel image, unless <code>forcewin=TRUE</code>).
</p>
</td></tr>
<tr><td><code id="rpoint_+3A_...">...</code></td>
<td>

<p>Arguments passed to the function <code>f</code>.
</p>
</td></tr>
<tr><td><code id="rpoint_+3A_giveup">giveup</code></td>
<td>

<p>Number of attempts in the rejection method after which
the algorithm should stop trying to generate new points.
</p>
</td></tr>
<tr><td><code id="rpoint_+3A_warn">warn</code></td>
<td>

<p>Logical value specifying whether to issue a warning if <code>n</code> is very large.
See Details.
</p>
</td></tr>
<tr><td><code id="rpoint_+3A_verbose">verbose</code></td>
<td>

<p>Flag indicating whether to report details of performance
of the simulation algorithm.
</p>
</td></tr>
<tr><td><code id="rpoint_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rpoint_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
<tr><td><code id="rpoint_+3A_forcewin">forcewin</code></td>
<td>

<p>Logical. If <code>TRUE</code>, then simulations will be generated
inside <code>win</code> in all cases. If <code>FALSE</code> (the default),
the argument <code>win</code> is ignored when <code>f</code> is a pixel image.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates <code>n</code> independent, identically distributed
random points with common probability density proportional to
<code>f</code>.
</p>
<p>The argument <code>f</code> may be
</p>

<dl>
<dt>a numerical constant:</dt><dd>
<p>uniformly distributed random points will
be generated.
</p>
</dd>
<dt>a function:</dt><dd><p>random points will be generated
in the window <code>win</code> with probability density proportional
to <code>f(x,y,...)</code> where <code>x</code> and <code>y</code> are the cartesian
coordinates. The function <code>f</code> must accept 
two <em>vectors</em> of coordinates <code>x,y</code> and return the corresponding
vector of function values. Additional arguments <code>...</code> of any kind
may be passed to the function.
</p>
</dd>
<dt>a pixel image:</dt><dd>
<p>if <code>f</code> is a pixel image
(object of class <code>"im"</code>, see <code>im.object</code>)
then random points will be generated
with probability density
proportional to the pixel values of <code>f</code>.
To be precise, pixels are selected with probabilities proportional
to the pixel values, and within each selected pixel,
a point is generated with a uniform distribution inside the pixel.
</p>
<p>The window of the simulated point pattern is determined as follows.
If <code>forcewin=FALSE</code> (the default) then the argument
<code>win</code> is ignored, and the simulation window is the
window of the pixel image, <code>Window(f)</code>.
If <code>forcefit=TRUE</code> then the simulation window is <code>win</code>.
</p>
</dd>
</dl>

<p>The algorithm is as follows:
</p>

<ul>
<li>
<p>If <code>f</code> is a constant, we invoke <code><a href="#topic+runifpoint">runifpoint</a></code>.
</p>
</li>
<li>
<p>If <code>f</code> is a function, then we use the rejection method.
Proposal points are generated from the uniform distribution.
A proposal point <code class="reqn">(x,y)</code> is accepted with probability
<code>f(x,y,...)/fmax</code> and otherwise rejected.
The algorithm continues until <code>n</code> points have been
accepted. It gives up after <code>giveup * n</code> proposals
if there are still fewer than <code>n</code> points.
</p>
</li>
<li> 
<p>If <code>f</code> is a pixel image, then a random sequence of 
pixels is selected (using <code><a href="base.html#topic+sample">sample</a></code>)
with probabilities proportional to the
pixel values of <code>f</code>.  Then for each pixel in the sequence
we generate a uniformly distributed random point in that pixel.
</p>
</li></ul>

<p>The algorithm for pixel images is more efficient than that for
functions.
</p>
<p>If <code>warn=TRUE</code> (the default), a warning will be issued if <code>n</code> is very large.
The threshold is <code>spatstat.options("huge.npoints")</code>.
This warning has no consequences,
but it helps to trap a number of common errors.
</p>


<h3>Value</h3>

<p>A point pattern (an object of class <code>"ppp"</code>)
if <code>nsim=1</code>, or a list of point patterns if <code>nsim &gt; 1</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code>ppp.object</code>,
<code>owin.object</code>,
<code><a href="#topic+runifpoint">runifpoint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # 100 uniform random points in the unit square
 X &lt;- rpoint(100)

 # 100 random points with probability density proportional to x^2 + y^2
 X &lt;- rpoint(100, function(x,y) { x^2 + y^2}, 1)

 # `fmax' may be omitted
 X &lt;- rpoint(100, function(x,y) { x^2 + y^2})

 # irregular window
 X &lt;- rpoint(100, function(x,y) { x^2 + y^2}, win=letterR)

 # make a pixel image 
 Z &lt;- setcov(letterR)
 # 100 points with density proportional to pixel values
 X &lt;- rpoint(100, Z)
</code></pre>

<hr>
<h2 id='rpoisline'>Generate Poisson Random Line Process</h2><span id='topic+rpoisline'></span>

<h3>Description</h3>

<p>Generate a random pattern of line segments
obtained from the Poisson line process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> rpoisline(lambda, win=owin())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpoisline_+3A_lambda">lambda</code></td>
<td>

<p>Intensity of the Poisson line process.
A positive number.
</p>
</td></tr>
<tr><td><code id="rpoisline_+3A_win">win</code></td>
<td>

<p>Window in which to simulate the pattern.
An object of class <code>"owin"</code>
or something acceptable to <code>as.owin</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm generates a realisation
of the uniform Poisson line process, and clips it to the window
<code>win</code>.
</p>
<p>The argument <code>lambda</code> must be a positive number.
It controls the intensity of the process. The expected number of
lines intersecting a convex region of the plane is equal to
<code>lambda</code> times the perimeter length of the region.
The expected total length of the lines crossing a region of the plane
is equal to <code>lambda * pi</code> times the area of the region.
</p>


<h3>Value</h3>

<p>A line segment pattern (an object of class <code>"psp"</code>).
</p>
<p>The result also has an attribute called <code>"lines"</code> (an object of
class <code>"infline"</code> specifying the original infinite random lines)
and an attribute <code>"linemap"</code> (an integer vector mapping the line
segments to their parent lines).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code>psp</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # uniform Poisson line process with intensity 10,
 # clipped to the unit square
 rpoisline(10)
</code></pre>

<hr>
<h2 id='rpoislinetess'>Poisson Line Tessellation</h2><span id='topic+rpoislinetess'></span>

<h3>Description</h3>

<p>Generate a tessellation delineated by the lines of
the Poisson line process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpoislinetess(lambda, win = owin())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpoislinetess_+3A_lambda">lambda</code></td>
<td>

<p>Intensity of the Poisson line process.
A positive number.
</p>
</td></tr>
<tr><td><code id="rpoislinetess_+3A_win">win</code></td>
<td>

<p>Window in which to simulate the pattern.
An object of class <code>"owin"</code>
or something acceptable to <code>as.owin</code>.
Currently, the window must be a rectangle.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm generates a realisation
of the uniform Poisson line process, and divides the window
<code>win</code> into tiles separated by these lines.
</p>
<p>The argument <code>lambda</code> must be a positive number.
It controls the intensity of the process. The expected number of
lines intersecting a convex region of the plane is equal to
<code>lambda</code> times the perimeter length of the region.
The expected total length of the lines crossing a region of the plane
is equal to <code>lambda * pi</code> times the area of the region.
</p>


<h3>Value</h3>

<p>A tessellation (object of class <code>"tess"</code>).
</p>
<p>Also has an attribute <code>"lines"</code> containing the realisation of the
Poisson line process, as an object of class <code>"infline"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpoisline">rpoisline</a></code>
to generate the lines only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> X &lt;- rpoislinetess(3)
 plot(as.im(X), main="rpoislinetess(3)")
 plot(X, add=TRUE)
</code></pre>

<hr>
<h2 id='rpoispp'>Generate Poisson Point Pattern</h2><span id='topic+rpoispp'></span>

<h3>Description</h3>

<p>Generate a random point pattern using the
(homogeneous or inhomogeneous) Poisson process.
Includes CSR (complete spatial randomness).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> rpoispp(lambda, lmax=NULL, win=owin(), ...,
         nsim=1, drop=TRUE, ex=NULL,
         forcewin=FALSE, warnwin=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpoispp_+3A_lambda">lambda</code></td>
<td>

<p>Intensity of the Poisson process.
Either a single positive number, a <code>function(x,y, ...)</code>,
or a pixel image.
</p>
</td></tr>
<tr><td><code id="rpoispp_+3A_lmax">lmax</code></td>
<td>

<p>Optional. An upper bound for the value of <code>lambda(x,y)</code>,
if <code>lambda</code> is a function.
</p>
</td></tr>
<tr><td><code id="rpoispp_+3A_win">win</code></td>
<td>

<p>Window in which to simulate the pattern.
An object of class <code>"owin"</code>
or something acceptable to <code>as.owin</code>.
(Ignored if <code>lambda</code> is a pixel image
unless <code>forcewin=TRUE</code>.)
</p>
</td></tr>
<tr><td><code id="rpoispp_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code>lambda</code> if it is a function.
</p>
</td></tr>
<tr><td><code id="rpoispp_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rpoispp_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
<tr><td><code id="rpoispp_+3A_ex">ex</code></td>
<td>

<p>Optional. A point pattern to use as the example.
If <code>ex</code> is given and <code>lambda,lmax,win</code> are missing,
then <code>lambda</code> and <code>win</code> will be calculated from
the point pattern <code>ex</code>.
</p>
</td></tr>
<tr><td><code id="rpoispp_+3A_forcewin">forcewin</code></td>
<td>

<p>Logical value specifying whether to use the argument <code>win</code>
as the simulation window when <code>lambda</code> is an image.
</p>
</td></tr>
<tr><td><code id="rpoispp_+3A_warnwin">warnwin</code></td>
<td>

<p>Logical value specifying whether to issue a warning
when <code>win</code> is ignored (which occurs when <code>lambda</code>
is an image, <code>win</code> is present and <code>forcewin=FALSE</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>lambda</code> is a single number,
then this algorithm generates a realisation
of the uniform Poisson process (also known as 
Complete Spatial Randomness, CSR) inside the window <code>win</code> with 
intensity <code>lambda</code> (points per unit area).
</p>
<p>If <code>lambda</code> is a function, then this algorithm generates a realisation
of the inhomogeneous Poisson process with intensity function
<code>lambda(x,y,...)</code> at spatial location <code>(x,y)</code>
inside the window <code>win</code>.
The function <code>lambda</code> must work correctly with vectors <code>x</code>
and <code>y</code>.
</p>
<p>If <code>lmax</code> is given,
it must be an upper bound on the values of <code>lambda(x,y,...)</code>
for all locations <code>(x, y)</code>
inside the window <code>win</code>. That is, we must have
<code>lambda(x,y,...) &lt;= lmax</code> for all locations <code>(x,y)</code>.
If this is not true then the results of
the algorithm will be incorrect.
</p>
<p>If <code>lmax</code> is missing or <code>NULL</code>,
an approximate upper bound is computed by finding the maximum value
of <code>lambda(x,y,...)</code>
on a grid of locations <code>(x,y)</code> inside the window <code>win</code>,
and adding a safety margin equal to 5 percent of the range of
<code>lambda</code> values. This can be computationally intensive,
so it is advisable to specify <code>lmax</code> if possible.
</p>
<p>If <code>lambda</code> is a pixel image object of class <code>"im"</code>
(see <code>im.object</code>), this algorithm generates a realisation
of the inhomogeneous Poisson process with intensity equal to the
pixel values of the image. (The value of the intensity function at an
arbitrary location is the pixel value of the nearest pixel.)
If <code>forcewin=FALSE</code> (the default),
the simulation window will be the window of the pixel image
(converted to a rectangle if possible using <code>rescue.rectangle</code>).
If <code>forcewin=TRUE</code>, the simulation window will be the argument
<code>win</code>.
</p>
<p>For <em>marked</em> point patterns, use <code><a href="#topic+rmpoispp">rmpoispp</a></code>.
</p>


<h3>Value</h3>

<p>A point pattern (an object of class <code>"ppp"</code>)
if <code>nsim=1</code>, or a list of point patterns if <code>nsim &gt; 1</code>.
</p>


<h3>Warning</h3>

<p>Note that <code>lambda</code> is the <b>intensity</b>, that is,
the expected number of points <b>per unit area</b>.
The total number of points in the simulated
pattern will be random with expected value <code>mu = lambda * a</code>
where <code>a</code> is the area of the window <code>win</code>. 
</p>


<h3>Reproducibility</h3>

<p>The simulation algorithm, for the case where
<code>lambda</code> is a pixel image, was changed in <span class="pkg">spatstat</span>
version <code>1.42-3</code>. Set <code>spatstat.options(fastpois=FALSE)</code>
to use the previous, slower algorithm, if it is desired to reproduce
results obtained with earlier versions.
</p>
<p>The previous slower algorithm uses &ldquo;thinning&rdquo;: it first generates a uniform
Poisson process of intensity <code>lmax</code>,
then randomly deletes or retains each point, independently of other points,
with retention probability
<code class="reqn">p(x,y) = \lambda(x,y)/\mbox{lmax}</code>.
The new faster algorithm randomly selects pixels with
probability proportional to intensity, and generates point locations
inside the selected pixels.
</p>
<p>Thinning is still used when <code>lambda</code> is a <code>function(x,y,...)</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmpoispp">rmpoispp</a></code> for Poisson <em>marked</em> point patterns,
<code><a href="#topic+runifpoint">runifpoint</a></code> for a fixed number of independent
uniform random points;
<code><a href="#topic+rpoint">rpoint</a></code>, <code><a href="#topic+rmpoint">rmpoint</a></code> for a fixed number of
independent random points with any distribution;
<code><a href="#topic+rMaternI">rMaternI</a></code>,
<code><a href="#topic+rMaternII">rMaternII</a></code>,
<code><a href="#topic+rSSI">rSSI</a></code>,
<code><a href="#topic+rStrauss">rStrauss</a></code>,
<code><a href="#topic+rstrat">rstrat</a></code>
for random point processes with spatial inhibition
or regularity; 
<code><a href="#topic+rThomas">rThomas</a></code>,
<code><a href="#topic+rGaussPoisson">rGaussPoisson</a></code>,
<code><a href="#topic+rMatClust">rMatClust</a></code>,
<code><a href="#topic+rcell">rcell</a></code>
for random point processes exhibiting clustering;
<code><a href="#topic+rmh.default">rmh.default</a></code> for Gibbs processes.
See also <code>ppp.object</code>,
<code>owin.object</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # uniform Poisson process with intensity 100 in the unit square
 pp &lt;- rpoispp(100)
 
 # uniform Poisson process with intensity 1 in a 10 x 10 square
 pp &lt;- rpoispp(1, win=owin(c(0,10),c(0,10)))
 # plots should look similar !
 
 # inhomogeneous Poisson process in unit square
 # with intensity lambda(x,y) = 100 * exp(-3*x)
 # Intensity is bounded by 100
 pp &lt;- rpoispp(function(x,y) {100 * exp(-3*x)}, 100)

 # How to tune the coefficient of x
 lamb &lt;- function(x,y,a) { 100 * exp( - a * x)}
 pp &lt;- rpoispp(lamb, 100, a=3)

 # pixel image
 Z &lt;- as.im(function(x,y){100 * sqrt(x+y)}, unit.square())
 pp &lt;- rpoispp(Z)

 # randomising an existing point pattern
 rpoispp(intensity(cells), win=Window(cells))
 rpoispp(ex=cells)
</code></pre>

<hr>
<h2 id='rpoispp3'>
Generate Poisson Point Pattern in Three Dimensions
</h2><span id='topic+rpoispp3'></span>

<h3>Description</h3>

<p>Generate a random three-dimensional point pattern
using the homogeneous Poisson process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpoispp3(lambda, domain = box3(), nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpoispp3_+3A_lambda">lambda</code></td>
<td>

<p>Intensity of the Poisson process.
A single positive number.
</p>
</td></tr>
<tr><td><code id="rpoispp3_+3A_domain">domain</code></td>
<td>

<p>Three-dimensional box in which the process should be generated.
An object of class <code>"box3"</code>.
</p>
</td></tr>
<tr><td><code id="rpoispp3_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rpoispp3_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a realisation
of the homogeneous Poisson process in three dimensions,
with intensity <code>lambda</code> (points per unit volume).
</p>
<p>The realisation is generated inside the three-dimensional region
<code>domain</code> which currently must be a rectangular box (object of
class <code>"box3"</code>).
</p>


<h3>Value</h3>

<p>If <code>nsim = 1</code> and <code>drop=TRUE</code>, a point pattern in
three dimensions (an object of class <code>"pp3"</code>).
If <code>nsim &gt; 1</code>, a list of such point patterns.
</p>


<h3>Note</h3>

<p>The intensity <code>lambda</code> is the expected number of points
<em>per unit volume</em>. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+runifpoint3">runifpoint3</a></code>, 
<code>pp3</code>, 
<code>box3</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- rpoispp3(50)
</code></pre>

<hr>
<h2 id='rpoisppOnLines'>Generate Poisson Point Pattern on Line Segments</h2><span id='topic+rpoisppOnLines'></span>

<h3>Description</h3>

<p>Given a line segment pattern, generate a Poisson random point pattern
on the line segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpoisppOnLines(lambda, L, lmax = NULL, ..., nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpoisppOnLines_+3A_lambda">lambda</code></td>
<td>
<p>Intensity of the Poisson process.
A single number, a <code>function(x,y)</code>, a pixel image
(object of class <code>"im"</code>), or a vector of numbers,
a list of functions, or a list of images.
</p>
</td></tr>
<tr><td><code id="rpoisppOnLines_+3A_l">L</code></td>
<td>
<p>Line segment pattern (object of class <code>"psp"</code>)
on which the points should be generated.
</p>
</td></tr>
<tr><td><code id="rpoisppOnLines_+3A_lmax">lmax</code></td>
<td>

<p>Optional upper bound (for increased computational efficiency).
A known upper bound for the values of <code>lambda</code>,
if <code>lambda</code> is a function or a pixel image.
That is, <code>lmax</code> should be a number which is 
known to be greater than or equal to all values of <code>lambda</code>. 
</p>
</td></tr>
<tr><td><code id="rpoisppOnLines_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>lambda</code> if it is a
function.
</p>
</td></tr>
<tr><td><code id="rpoisppOnLines_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rpoisppOnLines_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command generates a Poisson point process on the one-dimensional
system of line segments in <code>L</code>. The result is a point pattern
consisting of points lying on the line segments in <code>L</code>.
The number of random points falling on any given line segment follows
a Poisson distribution. The patterns of points on different segments
are independent.
</p>
<p>The intensity <code>lambda</code> is the expected number of points
per unit <b>length</b> of line segment. 
It may be constant, or it may depend on spatial location.
</p>
<p>In order to generate an unmarked Poisson process,
the argument <code>lambda</code> may be a single number,
or a <code>function(x,y)</code>, or a pixel image (object of class
<code>"im"</code>). 
</p>
<p>In order to generate a <em>marked</em> Poisson process,
<code>lambda</code> may be a numeric vector, a list of functions,
or a list of images, each entry giving the intensity for
a different mark value.
</p>
<p>If <code>lambda</code> is not numeric, then the (Lewis-Shedler)
rejection method is used. 
The rejection method requires knowledge of <code>lmax</code>,
the maximum possible value of <code>lambda</code>. This should be either
a single number, or a numeric vector of the same length as
<code>lambda</code>. If <code>lmax</code> is not
given, it will be computed approximately, by sampling many values of
<code>lambda</code>.
</p>
<p>If <code>lmax</code> is given, then it <b>must</b> be larger than
any possible value of <code>lambda</code>, otherwise the results of the
algorithm will be incorrect.
</p>


<h3>Value</h3>

<p>If <code>nsim = 1</code>, a point pattern
(object of class <code>"ppp"</code>) in the same window
as <code>L</code>. If <code>nsim &gt; 1</code>, a list of such point patterns.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code>psp</code>,
<code>ppp</code>,
<code><a href="#topic+runifpointOnLines">runifpointOnLines</a></code>,
<code><a href="#topic+rpoispp">rpoispp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  live &lt;- interactive()
  L &lt;- psp(runif(10), runif(10), runif(10), runif(10),  window=owin())
  if(live) plot(L, main="")

  # uniform intensity
  Y &lt;- rpoisppOnLines(4, L)
  if(live) plot(Y, add=TRUE, pch="+")

  # uniform MARKED process with types 'a' and 'b'
  Y &lt;- rpoisppOnLines(c(a=4, b=5), L)
  if(live) {
    plot(L, main="")
    plot(Y, add=TRUE, pch="+")
  }

  # intensity is a function
  Y &lt;- rpoisppOnLines(function(x,y){ 10 * x^2}, L, 10)
  if(live) { 
    plot(L, main="")
    plot(Y, add=TRUE, pch="+")
  }

  # intensity is an image
  Z &lt;- as.im(function(x,y){10 * sqrt(x+y)}, unit.square())
  Y &lt;- rpoisppOnLines(Z, L, 15)
  if(live) {
   plot(L, main="")
   plot(Y, add=TRUE, pch="+")
  }
</code></pre>

<hr>
<h2 id='rpoisppx'>
Generate Poisson Point Pattern in Any Dimensions
</h2><span id='topic+rpoisppx'></span>

<h3>Description</h3>

<p>Generate a random multi-dimensional point pattern
using the homogeneous Poisson process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpoisppx(lambda, domain, nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpoisppx_+3A_lambda">lambda</code></td>
<td>

<p>Intensity of the Poisson process.
A single positive number.
</p>
</td></tr>
<tr><td><code id="rpoisppx_+3A_domain">domain</code></td>
<td>

<p>Multi-dimensional box in which the process should be generated.
An object of class <code>"boxx"</code>.
</p>
</td></tr>
<tr><td><code id="rpoisppx_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rpoisppx_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a single point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a realisation
of the homogeneous Poisson process in multi dimensions,
with intensity <code>lambda</code> (points per unit volume).
</p>
<p>The realisation is generated inside the multi-dimensional region
<code>domain</code> which currently must be a rectangular box (object of
class <code>"boxx"</code>).
</p>


<h3>Value</h3>

<p>If <code>nsim = 1</code> and <code>drop=TRUE</code>,
a point pattern (an object of class <code>"ppx"</code>).
If <code>nsim &gt; 1</code> or <code>drop=FALSE</code>, a list of such point patterns.
</p>


<h3>Note</h3>

<p>The intensity <code>lambda</code> is the expected number of points
<em>per unit volume</em>. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+runifpointx">runifpointx</a></code>, 
<code>ppx</code>, 
<code><a href="cli.html#topic+boxx">boxx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   w &lt;- boxx(x=c(0,1), y=c(0,1), z=c(0,1), t=c(0,3))
   X &lt;- rpoisppx(10, w)
</code></pre>

<hr>
<h2 id='rPoissonCluster'>Simulate Poisson Cluster Process</h2><span id='topic+rPoissonCluster'></span>

<h3>Description</h3>

<p>Generate a random point pattern, a realisation of the
general Poisson cluster process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> rPoissonCluster(kappa, expand, rcluster, win = owin(c(0,1),c(0,1)),
                 ..., nsim=1, drop=TRUE, saveparents=TRUE, kappamax=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rPoissonCluster_+3A_kappa">kappa</code></td>
<td>

<p>Intensity of the Poisson process of cluster centres.
A single positive number, a function, or a pixel image.
</p>
</td></tr>
<tr><td><code id="rPoissonCluster_+3A_expand">expand</code></td>
<td>

<p>Size of the expansion of the simulation window for generating parent
points. A single non-negative number.
</p>
</td></tr>
<tr><td><code id="rPoissonCluster_+3A_rcluster">rcluster</code></td>
<td>

<p>A function which generates random clusters.
</p>
</td></tr>
<tr><td><code id="rPoissonCluster_+3A_win">win</code></td>
<td>

<p>Window in which to simulate the pattern.
An object of class <code>"owin"</code>
or something acceptable to <code>as.owin</code>.
</p>
</td></tr>
<tr><td><code id="rPoissonCluster_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code>rcluster</code>
</p>
</td></tr>
<tr><td><code id="rPoissonCluster_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rPoissonCluster_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
<tr><td><code id="rPoissonCluster_+3A_saveparents">saveparents</code></td>
<td>

<p>Logical value indicating whether to save the locations of the
parent points as an attribute.
</p>
</td></tr>
<tr><td><code id="rPoissonCluster_+3A_kappamax">kappamax</code></td>
<td>

<p>Optional. Upper bound on the values of <code>kappa</code>
when <code>kappa</code> is a function or pixel image.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm generates a realisation of the
general Poisson cluster process, with the cluster mechanism
given by the function <code>rcluster</code>. 
</p>
<p>First, the algorithm
generates a Poisson point process of &ldquo;parent&rdquo; points 
with intensity <code>kappa</code> in an expanded
window as explained below.. Here <code>kappa</code> may be a single
positive number, a function <code>kappa(x, y)</code>, or a pixel image
object of class <code>"im"</code> (see <code>im.object</code>).
See <code><a href="#topic+rpoispp">rpoispp</a></code> for details.
</p>
<p>Second, each parent point is replaced by a random cluster of points,
created by calling the function <code>rcluster</code>.  These clusters are
combined together to yield a single point pattern, and the restriction
of this pattern to the window <code>win</code> is then returned as the
result of <code>rPoissonCluster</code>.
</p>
<p>The expanded window consists of <code>as.rectangle(win)</code>
extended by the amount <code>expand</code> in each direction. The size of
the expansion is saved in the attribute <code>"expand"</code> and may be
extracted by <code>attr(X, "expand")</code> where <code>X</code> is the generated
point pattern.
</p>
<p>The function <code>rcluster</code> should expect to be called as
<code>rcluster(xp[i],yp[i],...)</code> for each parent point at a location
<code>(xp[i],yp[i])</code>. The return value of <code>rcluster</code>
should be a list with elements
<code>x,y</code> which are vectors of equal length giving the absolute
<code class="reqn">x</code> and <code>y</code> coordinates of the points in the cluster.
</p>
<p>If the return value of <code>rcluster</code> is a point pattern (object of
class <code>"ppp"</code>) then it may have marks. The result of
<code>rPoissonCluster</code> will then be a marked point pattern.
</p>
<p>If required, the intermediate stages of the simulation (the parents
and the individual clusters) can also be extracted from
the return value of <code>rPoissonCluster</code>
through the attributes <code>"parents"</code> and <code>"parentid"</code>.
The attribute <code>"parents"</code> is the point pattern of parent points.
The attribute <code>"parentid"</code> is an integer vector specifying
the parent for each of the points in the simulated pattern.
(If these data are not required, it is more efficient to
set <code>saveparents=FALSE</code>.)
</p>


<h3>Value</h3>

<p>A point pattern (an object of class <code>"ppp"</code>)
if <code>nsim=1</code>, or a list of point patterns if <code>nsim &gt; 1</code>.
</p>
<p>Additionally,  some intermediate results of the simulation are
returned as attributes of the point pattern: see Details.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpoispp">rpoispp</a></code>,
<code><a href="#topic+rMatClust">rMatClust</a></code>,
<code><a href="#topic+rThomas">rThomas</a></code>,
<code><a href="#topic+rCauchy">rCauchy</a></code>,
<code><a href="#topic+rVarGamma">rVarGamma</a></code>,
<code><a href="#topic+rNeymanScott">rNeymanScott</a></code>,
<code><a href="#topic+rGaussPoisson">rGaussPoisson</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # each cluster consist of 10 points in a disc of radius 0.2
  nclust &lt;- function(x0, y0, radius, n) {
              return(runifdisc(n, radius, centre=c(x0, y0)))
            }
  plot(rPoissonCluster(10, 0.2, nclust, radius=0.2, n=5))

  # multitype Neyman-Scott process (each cluster is a multitype process)
  nclust2 &lt;- function(x0, y0, radius, n, types=c("a", "b")) {
     X &lt;- runifdisc(n, radius, centre=c(x0, y0))
     M &lt;- sample(types, n, replace=TRUE)
     marks(X) &lt;- M
     return(X)
  }
  plot(rPoissonCluster(15,0.1,nclust2, radius=0.1, n=5))
</code></pre>

<hr>
<h2 id='rpoistrunc'>
Random Values from the Truncated Poisson Distribution
</h2><span id='topic+rpoisnonzero'></span><span id='topic+rpoistrunc'></span>

<h3>Description</h3>

<p>Generate realisations of a Poisson random variable
which are truncated, that is, conditioned to be nonzero, or conditioned
to be at least a given number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpoisnonzero(n, lambda, method=c("harding", "transform"), implem=c("R", "C"))
rpoistrunc(n, lambda, minimum = 1, method=c("harding", "transform"), implem=c("R", "C"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpoistrunc_+3A_n">n</code></td>
<td>
<p>Number of random values to be generated.</p>
</td></tr>
<tr><td><code id="rpoistrunc_+3A_lambda">lambda</code></td>
<td>

<p>Mean value of the un-truncated Poisson distribution.
A nonnegative number, or vector of nonnegative numbers.
</p>
</td></tr>
<tr><td><code id="rpoistrunc_+3A_minimum">minimum</code></td>
<td>

<p>Minimum permitted value for the random variables.
A nonnegative integer, or vector of nonnegative integers.
</p>
</td></tr>
<tr><td><code id="rpoistrunc_+3A_method">method</code></td>
<td>

<p>Character string (partially matched) specifying the simulation
algorithm to be used. See Details.
</p>
</td></tr>
<tr><td><code id="rpoistrunc_+3A_implem">implem</code></td>
<td>

<p>Character string specifying whether to use the implementation
in interpreted R code (<code>implem="R"</code>, the default)
or C code (<code>implem="C"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rpoisnonzero</code>
generates realisations of the
Poisson distribution with mean <code>lambda</code>
conditioned on the event that the values are not equal to zero.
</p>
<p><code>rpoistrunc</code> 
generates realisations of the
Poisson distribution with mean <code>lambda</code>
conditioned on the event that the values are greater than
or equal to <code>minimum</code>.
The default <code>minimum=1</code> is equivalent to
generating zero-truncated Poisson random variables
using <code>rpoisnonzero</code>.
The value <code>minimum=0</code> is equivalent to
generating un-truncated Poisson random variables
using <code><a href="stats.html#topic+rpois">rpois</a></code>.
</p>
<p>The arguments <code>lambda</code> and <code>minimum</code> can be
vectors of length <code>n</code>, specifying different means
for the un-truncated Poisson distribution, and different
minimum values, for each of the <code>n</code> random output values.
</p>
<p>If <code>method="transform"</code> the simulated values are generated
by transforming a uniform random variable using the quantile function
of the Poisson distribution.
If <code>method="harding"</code> (the default) the simulated values are
generated using an algorithm proposed by E.F. Harding which exploits
properties of the Poisson point process. The Harding algorithm seems
to be faster.
</p>


<h3>Value</h3>

<p>An integer vector of length <code>n</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, after ideas of Ted Harding and Peter Dalgaard.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+rpois">rpois</a></code> for Poisson random variables.
</p>
<p><code><a href="#topic+recipEnzpois">recipEnzpois</a></code> for the reciprocal moment of <code>rpoisnonzero</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  rpoisnonzero(10, 0.8)

  rpoistrunc(10, 1, 2)
</code></pre>

<hr>
<h2 id='rPSNCP'>Simulate Product Shot-noise Cox Process</h2><span id='topic+rPSNCP'></span>

<h3>Description</h3>

<p>Generate a random multitype point pattern, a realisation of the
product shot-noise Cox process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> rPSNCP(lambda=rep(100, 4), kappa=rep(25, 4), omega=rep(0.03, 4), 
        alpha=matrix(runif(16, -1, 3), nrow=4, ncol=4), 
        kernels=NULL, nu.ker=NULL, win=owin(), nsim=1, drop=TRUE,
        ...,
        cnames=NULL, epsth=0.001)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rPSNCP_+3A_lambda">lambda</code></td>
<td>

<p>List of intensities of component processes. Either a
numeric vector determining the constant (homogeneous) intensities 
or a list of pixel images (objects of class <code>"im"</code>) determining 
the (inhomogeneous) intensity functions of  component processes. 
The length of <code>lambda</code> determines the number of component processes.
</p>
</td></tr>
<tr><td><code id="rPSNCP_+3A_kappa">kappa</code></td>
<td>

<p>Numeric vector of intensities of the Poisson process of cluster centres
for component processes. Must have the same size as <code>lambda</code>.
</p>
</td></tr>
<tr><td><code id="rPSNCP_+3A_omega">omega</code></td>
<td>

<p>Numeric vector of bandwidths of cluster dispersal kernels
for component processes. Must have the same size as <code>lambda</code> 
and <code>kappa</code>.
</p>
</td></tr>
<tr><td><code id="rPSNCP_+3A_alpha">alpha</code></td>
<td>

<p>Matrix of interaction parameters. Square numeric matrix with the same 
number of rows and columns as the length of <code>lambda</code>,
<code>kappa</code> and <code>omega</code>.
All entries of <code>alpha</code> must be greater than -1.
</p>
</td></tr>
<tr><td><code id="rPSNCP_+3A_kernels">kernels</code></td>
<td>

<p>Vector of character string determining the cluster dispersal kernels
of component processes. Implemented kernels are Gaussian 
kernel (<code>"Thomas"</code>) with bandwidth <code>omega</code>, 
Variance-Gamma (Bessel) kernel (<code>"VarGamma"</code>) with 
bandwidth <code>omega</code> and shape parameter <code>nu.ker</code> 
and Cauchy kernel (<code>"Cauchy"</code>) with bandwidth <code>omega</code>.
Must have the same length as <code>lambda</code>, <code>kappa</code> and <code>omega</code>.
</p>
</td></tr>
<tr><td><code id="rPSNCP_+3A_nu.ker">nu.ker</code></td>
<td>

<p>Numeric vector of bandwidths of shape parameters for Variance-Gamma
kernels. 
</p>
</td></tr>
<tr><td><code id="rPSNCP_+3A_win">win</code></td>
<td>

<p>Window in which to simulate the pattern.
An object of class <code>"owin"</code>.
</p>
</td></tr>
<tr><td><code id="rPSNCP_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rPSNCP_+3A_cnames">cnames</code></td>
<td>

<p>Optional vector of character strings giving the names of
the component processes.
</p>
</td></tr>
<tr><td><code id="rPSNCP_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code>
to determine the pixel array geometry.
See <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code>.
</p>
</td></tr>
<tr><td><code id="rPSNCP_+3A_epsth">epsth</code></td>
<td>

<p>Numerical threshold to determine the maximum interaction range for 
cluster kernels.


</p>
</td></tr>
<tr><td><code id="rPSNCP_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>




</table>


<h3>Details</h3>

<p>This function generates a realisation of a product shot-noise Cox
process (PSNCP). This is a multitype (multivariate) Cox point process 
in which each element of the multivariate random intensity
<code class="reqn">\Lambda(u)</code> 
of the process is obtained by 
</p>
<p style="text-align: center;"><code class="reqn">
    \Lambda_i(u) = \lambda_i(u) S_i(u) \prod_{j \neq i} E_{ji}(u)
  </code>
</p>

<p>where <code class="reqn">\lambda_i(u)</code> is the intensity
of component <code class="reqn">i</code> of the process,
</p>
<p style="text-align: center;"><code class="reqn">
    S_i(u) = \frac{1}{\kappa_{i}} \sum_{v \in \Phi_i} k_{i}(u - v)
  </code>
</p>

<p>is the shot-noise random field for component <code class="reqn">i</code> and 
</p>
<p style="text-align: center;"><code class="reqn">
      E_{ji}(u) = \exp(-\kappa_{j} \alpha_{ji} / k_{j}(0)) \prod_{v \in \Phi_{j}} {1 + \alpha_{ji} \frac{k_j(u-v)}{k_j(0)}}
    </code>
</p>

<p>is a product field controlling impulses from the parent Poisson process 
<code class="reqn">\Phi_j</code> with constant intensity <code class="reqn">\kappa_j</code> of 
component process <code class="reqn">j</code> on <code class="reqn">\Lambda_i(u)</code>.
Here <code class="reqn">k_i(u)</code> is an isotropic kernel (probability
density) function on <code class="reqn">R^2</code> with bandwidth <code class="reqn">\omega_i</code> and 
shape parameter <code class="reqn">\nu_i</code>,
and <code class="reqn">\alpha_{ji}&gt;-1</code> is the interaction parameter.
</p>


<h3>Value</h3>

<p>A point pattern (an object of class <code>"ppp"</code>) if <code>nsim=1</code>, or a
list of point patterns if <code>nsim &gt; 1</code>.  Each point pattern is
multitype (it carries a vector of marks which is a factor).
</p>


<h3>Author(s)</h3>

<p>Abdollah Jalilian.
Modified by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Jalilian, A., Guan, Y., Mateu, J. and Waagepetersen, R. (2015)
Multivariate product-shot-noise Cox point process models. 
<em>Biometrics</em>  <b>71</b>(4), 1022&ndash;1033.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmpoispp">rmpoispp</a></code>,
<code><a href="#topic+rThomas">rThomas</a></code>,
<code><a href="#topic+rVarGamma">rVarGamma</a></code>,
<code><a href="#topic+rCauchy">rCauchy</a></code>,
<code><a href="#topic+rNeymanScott">rNeymanScott</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  online &lt;- interactive()
  # Example 1: homogeneous components
  lambda &lt;- c(250, 300, 180, 400)
  kappa &lt;- c(30, 25, 20, 25)
  omega &lt;- c(0.02, 0.025, 0.03, 0.02)
  alpha &lt;- matrix(runif(16, -1, 1), nrow=4, ncol=4)
  if(!online) {
     lambda &lt;- lambda[1:2]/10
     kappa  &lt;- kappa[1:2]
     omega  &lt;- omega[1:2]
     alpha  &lt;- alpha[1:2, 1:2]
  }
  X &lt;- rPSNCP(lambda, kappa, omega, alpha)
  if(online) {
    plot(X)
    plot(split(X))
  }

  #Example 2: inhomogeneous components
  z1 &lt;- scaletointerval.im(bei.extra$elev, from=0, to=1)
  z2 &lt;- scaletointerval.im(bei.extra$grad, from=0, to=1)
  if(!online) {
    ## reduce resolution to reduce check time
    z1 &lt;- as.im(z1, dimyx=c(40,80))
    z2 &lt;- as.im(z2, dimyx=c(40,80))
  } 
  lambda &lt;- list(
         exp(-8 + 1.5 * z1 + 0.5 * z2),
         exp(-7.25 + 1 * z1  - 1.5 * z2),
         exp(-6 - 1.5 * z1 + 0.5 * z2),
         exp(-7.5 + 2 * z1 - 3 * z2))
  kappa &lt;- c(35, 30, 20, 25) / (1000 * 500)
  omega &lt;- c(15, 35, 40, 25)
  alpha &lt;- matrix(runif(16, -1, 1), nrow=4, ncol=4)
  if(!online) {
     lambda &lt;- lapply(lambda[1:2], "/", e2=10)
     kappa  &lt;- kappa[1:2]
     omega  &lt;- omega[1:2]
     alpha  &lt;- alpha[1:2, 1:2]
  } else {
     sapply(lambda, integral)
  }
  X &lt;- rPSNCP(lambda, kappa, omega, alpha, win = Window(bei), dimyx=dim(z1))
  if(online) {
    plot(X)
    plot(split(X), cex=0.5)
  }
</code></pre>

<hr>
<h2 id='rshift'>Random Shift</h2><span id='topic+rshift'></span>

<h3>Description</h3>

<p>Randomly shifts the points of a point pattern or
line segment pattern. Generic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   rshift(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rshift_+3A_x">X</code></td>
<td>
<p>Pattern to be subjected to a random shift.
A point pattern (class <code>"ppp"</code>),
a line segment pattern (class <code>"psp"</code>)
or an object of class <code>"splitppp"</code>.
</p>
</td></tr>
<tr><td><code id="rshift_+3A_...">...</code></td>
<td>

<p>Arguments controlling the generation of the
random shift vector, or specifying which parts of the pattern
will be shifted. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This operation applies a random shift (vector displacement) to
the points in a point pattern,
or to the segments in a line segment pattern.
</p>
<p>The argument <code>X</code> may be 
</p>

<ul>
<li>
<p>a point pattern
(an object of class <code>"ppp"</code>)
</p>
</li>
<li>
<p>a line segment pattern
(an object of class <code>"psp"</code>)
</p>
</li>
<li>
<p>an object of class <code>"splitppp"</code>
(basically a list of point patterns, obtained from
<code>split.ppp</code>).
</p>
</li></ul>

<p>The function <code>rshift</code> is generic, with
methods for the three classes <code>"ppp"</code>,
<code>"psp"</code> and <code>"splitppp"</code>.
</p>
<p>See the help pages for these methods, <code><a href="#topic+rshift.ppp">rshift.ppp</a></code>,
<code><a href="#topic+rshift.psp">rshift.psp</a></code> and
<code><a href="#topic+rshift.splitppp">rshift.splitppp</a></code>, for further information.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rshift.ppp">rshift.ppp</a></code>,
<code><a href="#topic+rshift.psp">rshift.psp</a></code>,
<code><a href="#topic+rshift.splitppp">rshift.splitppp</a></code>
</p>

<hr>
<h2 id='rshift.ppp'>Randomly Shift a Point Pattern</h2><span id='topic+rshift.ppp'></span>

<h3>Description</h3>

<p>Randomly shifts the points of a point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'ppp'
rshift(X, ..., which=NULL, group, nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rshift.ppp_+3A_x">X</code></td>
<td>
<p>Point pattern to be subjected to a random shift.
An object of class <code>"ppp"</code>
</p>
</td></tr>
<tr><td><code id="rshift.ppp_+3A_...">...</code></td>
<td>

<p>Arguments that determine the random shift. See Details.
</p>
</td></tr>
<tr><td><code id="rshift.ppp_+3A_group">group</code></td>
<td>

<p>Optional. Factor specifying a grouping of the points of <code>X</code>,
or <code>NULL</code> indicating that all points belong to the same group.
Each group will be shifted together, and
separately from other groups.
By default, points in a marked point pattern are grouped
according to their mark values,
while points in an unmarked point pattern are treated as a single group.
</p>
</td></tr>
<tr><td><code id="rshift.ppp_+3A_which">which</code></td>
<td>

<p>Optional. Identifies which groups of the pattern will be shifted,
while other groups are not shifted. A vector of levels of <code>group</code>.
</p>
</td></tr>
<tr><td><code id="rshift.ppp_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rshift.ppp_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This operation randomly shifts the locations of the points
in a point pattern.
</p>
<p>The function <code>rshift</code> is generic. This function <code>rshift.ppp</code>
is the method for point patterns.
</p>
<p>The most common use of this function is to shift the
points in a multitype point pattern.
By default, points of the same type are shifted in parallel
(i.e. points of a common type are shifted by a common displacement vector),
and independently of other types.
This is useful for testing the hypothesis of independence of types
(the null hypothesis that the sub-patterns of points of each type
are independent point processes).
</p>
<p>In general the points of <code>X</code> are divided into groups,
then the points within a group are shifted by a common
random displacement vector. Different groups of points are shifted
independently. The grouping is determined as follows:
</p>

<ul>
<li>
<p>If the argument <code>group</code> is present, then this determines the grouping.
</p>
</li>
<li>
<p>Otherwise, if <code>X</code> is a multitype point pattern,
the marks determine the grouping.
</p>
</li>
<li>
<p>Otherwise, all points belong to a single group.
</p>
</li></ul>

<p>The argument <code>group</code> should be a factor, of length equal to the
number of points in <code>X</code>. Alternatively <code>group</code> may be <code>NULL</code>,
which specifies that all points of <code>X</code> belong to a single group.
</p>
<p>By default, every group of points will be shifted.
The argument <code>which</code> indicates that only some of the groups
should be shifted, while other groups should be left unchanged.
<code>which</code> must be a vector of levels of <code>group</code>
(for example, a vector of types in a multitype pattern)
indicating which groups are to be shifted. 
</p>
<p>The displacement vector, i.e. the vector
by which the data points are shifted,
is generated at random.
Parameters that control the randomisation
and the handling of edge effects are passed through
the <code>...</code> argument. They are
</p>

<dl>
<dt>radius,width,height</dt><dd>
<p>Parameters of the random shift vector.
</p>
</dd>
<dt>edge</dt><dd>
<p>String indicating how to deal with edges of the pattern.
Options are <code>"torus"</code>, <code>"erode"</code> and <code>"none"</code>.
</p>
</dd>
<dt>clip</dt><dd>
<p>Optional. Window to which the final point pattern should be clipped.
</p>
</dd>
</dl>

<p>If the window is a rectangle, the <em>default</em> behaviour is 
to generate a displacement vector at random with equal probability
for all possible displacements. This means that the <code class="reqn">x</code> and
<code class="reqn">y</code> coordinates of the displacement vector are independent random
variables, uniformly distributed over the range of possible coordinates.
</p>
<p>Alternatively, the displacement vector can be generated by
another random mechanism, controlled by the arguments
<code>radius</code>, <code>width</code> and <code>height</code>. 
</p>

<dl>
<dt>rectangular:</dt><dd>
<p>if <code>width</code> and <code>height</code> are given, then 
the displacement vector is uniformly distributed
in a rectangle of these dimensions, centred at
the origin.  The maximum possible displacement in the <code class="reqn">x</code>
direction is <code>width/2</code>. The maximum possible displacement in
the <code class="reqn">y</code> direction is <code>height/2</code>. The <code class="reqn">x</code> and <code class="reqn">y</code>
displacements are independent. (If <code>width</code> and <code>height</code>
are actually equal to the dimensions of the observation window,
then this is equivalent to the default.)
</p>
</dd>
<dt>radial:</dt><dd>
<p>if <code>radius</code> is given, then the displacement vector is
generated by choosing a random point inside a disc of
the given radius, centred at the origin, with uniform probability
density over the disc. Thus the argument <code>radius</code> determines
the maximum possible displacement distance.
The argument <code>radius</code> is incompatible with the
arguments <code>width</code> and <code>height</code>.
</p>
</dd>
</dl>

<p>The argument <code>edge</code> controls what happens when 
a shifted point lies outside the window of <code>X</code>.
Options are:
</p>

<dl>
<dt>&quot;none&quot;:</dt><dd>
<p>Points shifted outside the window of <code>X</code>
simply disappear. 
</p>
</dd>
<dt>&quot;torus&quot;:</dt><dd>
<p>Toroidal or periodic boundary.
Treat opposite edges of the window as identical, so that a point
which disappears off the right-hand edge will re-appear at the
left-hand edge. This is called a &ldquo;toroidal shift&rdquo; because it makes the
rectangle topologically equivalent to the surface of a torus
(doughnut).
</p>
<p>The window must be a rectangle. Toroidal shifts are undefined
if the window is non-rectangular.
</p>
</dd>
<dt>&quot;erode&quot;:</dt><dd>
<p>Clip the point pattern to a smaller window.
</p>
<p>If the random displacements are generated by a radial
mechanism (see above), then the window of <code>X</code>
is eroded by a distance equal to the value of the argument
<code>radius</code>, using <code>erosion</code>.
</p>
<p>If the random displacements are generated by a rectangular
mechanism, then the window of <code>X</code> is
(if it is not rectangular) eroded by a distance
<code>max(height,width)</code> using <code>erosion</code>;
or (if it is rectangular) trimmed by a margin of width <code>width</code>
at the left and right sides and trimmed by a margin of
height <code>height</code> at the top and bottom.
</p>
<p>The rationale for this is that the clipping window is
the largest window for which edge effects can be ignored.
</p>
</dd>
</dl>

<p>The optional argument <code>clip</code> specifies a smaller window
to which the pattern should be restricted.
</p>
<p>If <code>nsim &gt; 1</code>, then the simulation procedure is
performed <code>nsim</code> times; the result is a list of <code>nsim</code>
point patterns.
</p>


<h3>Value</h3>

<p>A point pattern (object of class <code>"ppp"</code>)
or a list of point patterns.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rshift">rshift</a></code>,
<code><a href="#topic+rshift.psp">rshift.psp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # random toroidal shift
   # shift "on" and "off" points separately
   X &lt;- rshift(amacrine)

   # shift "on" points and leave "off" points fixed
   X &lt;- rshift(amacrine, which="on")

   # shift all points simultaneously
   X &lt;- rshift(amacrine, group=NULL)

   # maximum displacement distance 0.1 units
   X &lt;- rshift(amacrine, radius=0.1, nsim=2)

   # shift with erosion
   X &lt;- rshift(amacrine, radius=0.1, edge="erode")
</code></pre>

<hr>
<h2 id='rshift.psp'>Randomly Shift a Line Segment Pattern</h2><span id='topic+rshift.psp'></span>

<h3>Description</h3>

<p>Randomly shifts the segments in a line segment pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'psp'
rshift(X, ..., group=NULL, which=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rshift.psp_+3A_x">X</code></td>
<td>
<p>Line segment pattern to be subjected to a random shift.
An object of class <code>"psp"</code>.
</p>
</td></tr>
<tr><td><code id="rshift.psp_+3A_...">...</code></td>
<td>

<p>Arguments controlling the randomisation and the handling of edge
effects. See <code><a href="#topic+rshift.ppp">rshift.ppp</a></code>.
</p>
</td></tr>
<tr><td><code id="rshift.psp_+3A_group">group</code></td>
<td>

<p>Optional. Factor specifying a grouping of the line segments of <code>X</code>,
or <code>NULL</code> indicating that all line segments belong to the same group.
Each group will be shifted together, and
separately from other groups.
</p>
</td></tr>
<tr><td><code id="rshift.psp_+3A_which">which</code></td>
<td>

<p>Optional. Identifies which groups of the pattern will be shifted,
while other groups are not shifted. A vector of levels of <code>group</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This operation randomly shifts the locations of the line segments
in a line segment pattern.
</p>
<p>The function <code>rshift</code> is generic. This function <code>rshift.psp</code>
is the method for line segment patterns.
</p>
<p>The line segments of <code>X</code> are first divided into groups,
then the line segments within a group are shifted by a common
random displacement vector. Different groups of line segments are shifted
independently.
If the argument <code>group</code> is present, then this determines the grouping.
Otherwise, all line segments belong to a single group.
</p>
<p>The argument <code>group</code> should be a factor, of length equal to the
number of line segments in <code>X</code>.
Alternatively <code>group</code> may be <code>NULL</code>,
which specifies that all line segments of <code>X</code> belong to a single group.
</p>
<p>By default, every group of line segments will be shifted.
The argument <code>which</code> indicates that only some of the groups
should be shifted, while other groups should be left unchanged.
<code>which</code> must be a vector of levels of <code>group</code>
indicating which groups are to be shifted. 
</p>
<p>The displacement vector, i.e. the vector
by which the data line segments are shifted,
is generated at random.
The <em>default</em> behaviour is 
to generate a displacement vector at random with equal probability
for all possible displacements. This means that the <code class="reqn">x</code> and
<code class="reqn">y</code> coordinates of the displacement vector are independent random
variables, uniformly distributed over the range of possible coordinates.
</p>
<p>Alternatively, the displacement vector can be generated by
another random mechanism, controlled by the arguments
<code>radius</code>, <code>width</code> and <code>height</code>. 
</p>

<dl>
<dt>rectangular:</dt><dd>
<p>if <code>width</code> and <code>height</code> are given, then 
the displacement vector is uniformly distributed
in a rectangle of these dimensions, centred at
the origin.  The maximum possible displacement in the <code class="reqn">x</code>
direction is <code>width/2</code>. The maximum possible displacement in
the <code class="reqn">y</code> direction is <code>height/2</code>. The <code class="reqn">x</code> and <code class="reqn">y</code>
displacements are independent. (If <code>width</code> and <code>height</code>
are actually equal to the dimensions of the observation window,
then this is equivalent to the default.)
</p>
</dd>
<dt>radial:</dt><dd>
<p>if <code>radius</code> is given, then the displacement vector is
generated by choosing a random line segment inside a disc of
the given radius, centred at the origin, with uniform probability
density over the disc. Thus the argument <code>radius</code> determines
the maximum possible displacement distance.
The argument <code>radius</code> is incompatible with the
arguments <code>width</code> and <code>height</code>.
</p>
</dd>
</dl>

<p>The argument <code>edge</code> controls what happens when 
a shifted line segment lies partially or completely
outside the window of <code>X</code>. Currently the only option is
<code>"erode"</code> which specifies that the segments will be clipped
to a smaller window. 
</p>
<p>The optional argument <code>clip</code> specifies a smaller window
to which the pattern should be restricted.
</p>


<h3>Value</h3>

<p>A line segment pattern (object of class <code>"psp"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rshift">rshift</a></code>,
<code><a href="#topic+rshift.ppp">rshift.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- psp(runif(20), runif(20), runif(20), runif(20),  window=owin())
  Y &lt;- rshift(X, radius=0.1)
</code></pre>

<hr>
<h2 id='rshift.splitppp'>Randomly Shift a List of Point Patterns</h2><span id='topic+rshift.splitppp'></span>

<h3>Description</h3>

<p>Randomly shifts each point pattern in a list of point patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'splitppp'
rshift(X, ..., which=seq_along(X), nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rshift.splitppp_+3A_x">X</code></td>
<td>

<p>An object of class <code>"splitppp"</code>.
Basically a list of point patterns.
</p>
</td></tr>
<tr><td><code id="rshift.splitppp_+3A_...">...</code></td>
<td>

<p>Parameters controlling the generation of the
random shift vector and the handling of edge effects.
See <code><a href="#topic+rshift.ppp">rshift.ppp</a></code>.
</p>
</td></tr>
<tr><td><code id="rshift.splitppp_+3A_which">which</code></td>
<td>

<p>Optional. Identifies which patterns will be shifted,
while other patterns are not shifted.
Any valid subset index for <code>X</code>.
</p>
</td></tr>
<tr><td><code id="rshift.splitppp_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rshift.splitppp_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a split point pattern object, rather than a list 
containing the split point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This operation applies a random shift to each of the
point patterns in the list <code>X</code>.
</p>
<p>The function <code><a href="#topic+rshift">rshift</a></code> is generic.
This function <code>rshift.splitppp</code>
is the method for objects of class <code>"splitppp"</code>, which are
essentially lists of point patterns, created by the function
<code>split.ppp</code>.
</p>
<p>By default, every pattern in the list <code>X</code> will be shifted.
The argument <code>which</code> indicates that only some of the patterns
should be shifted, while other groups should be left unchanged.
<code>which</code> can be any valid subset index for <code>X</code>.
</p>
<p>Each point pattern in the list <code>X</code>
(or each pattern in <code>X[which]</code>)
is shifted by a random displacement vector.
The shifting is performed by <code><a href="#topic+rshift.ppp">rshift.ppp</a></code>.
</p>
<p>See the help page for <code><a href="#topic+rshift.ppp">rshift.ppp</a></code>
for details of the other arguments.
</p>
<p>If <code>nsim &gt; 1</code>, then the simulation procedure is
performed <code>nsim</code> times; the result is a list of 
split point patterns. 
</p>


<h3>Value</h3>

<p>Another object of class <code>"splitppp"</code>,
or a list of such objects.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rshift">rshift</a></code>,
<code><a href="#topic+rshift.ppp">rshift.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   Y &lt;- split(amacrine)

   # random toroidal shift
   # shift "on" and "off" points separately
   X &lt;- rshift(Y)

   # shift "on" points and leave "off" points fixed
   X &lt;- rshift(Y, which="on")

   # maximum displacement distance 0.1 units
   X &lt;- rshift(Y, radius=0.1)

   # shift with erosion
   X &lt;- rshift(Y, radius=0.1, edge="erode")
</code></pre>

<hr>
<h2 id='rSSI'>Simulate Simple Sequential Inhibition</h2><span id='topic+rSSI'></span>

<h3>Description</h3>

<p>Generate a random point pattern, a realisation of the
Simple Sequential Inhibition (SSI) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> rSSI(r, n=Inf, win = square(1), giveup = 1000, x.init=NULL, ...,
      f=NULL, fmax=NULL, nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rSSI_+3A_r">r</code></td>
<td>

<p>Inhibition distance.
</p>
</td></tr>
<tr><td><code id="rSSI_+3A_n">n</code></td>
<td>

<p>Maximum number of points allowed. 
If <code>n</code> is finite, stop when the <em>total</em> number of points
in the point pattern reaches <code>n</code>.
If <code>n</code> is infinite (the default), stop only when
it is apparently impossible to add any more points.
See <b>Details</b>.
</p>
</td></tr>
<tr><td><code id="rSSI_+3A_win">win</code></td>
<td>

<p>Window in which to simulate the pattern.
An object of class <code>"owin"</code>
or something acceptable to <code>as.owin</code>.
The default window is the unit square, unless 
<code>x.init</code> is specified, when the default window 
is the window of <code>x.init</code>.
</p>
</td></tr>
<tr><td><code id="rSSI_+3A_giveup">giveup</code></td>
<td>

<p>Number of rejected proposals after which the algorithm should terminate.
</p>
</td></tr>
<tr><td><code id="rSSI_+3A_x.init">x.init</code></td>
<td>

<p>Optional. Initial configuration of points. A point pattern
(object of class <code>"ppp"</code>).  The pattern returned by
<code>rSSI</code> consists of this pattern together with the points
added via simple sequential inhibition.  See <b>Details</b>.
</p>
</td></tr>
<tr><td><code id="rSSI_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="rSSI_+3A_f">f</code>, <code id="rSSI_+3A_fmax">fmax</code></td>
<td>

<p>Optional arguments passed to <code><a href="#topic+rpoint">rpoint</a></code>
to specify a non-uniform probability density for the random points.
</p>
</td></tr>
<tr><td><code id="rSSI_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rSSI_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm generates one or more realisations of the Simple Sequential
Inhibition point process inside the window <code>win</code>.
</p>
<p>Starting with an empty window (or with the point pattern
<code>x.init</code> if specified), the algorithm adds points
one-by-one. Each new point is generated uniformly in the window
and independently of preceding points. If the new point lies
closer than <code>r</code> units from an existing point, then it is
rejected and another random point is generated.
The algorithm terminates when either
</p>

<dl>
<dt>(a)</dt><dd>
<p>the desired number <code>n</code> of points is reached, or
</p>
</dd>
<dt>(b)</dt><dd>
<p>the current point configuration
has not changed for <code>giveup</code> iterations,
suggesting that it is no longer possible to add new points.
</p>
</dd>
</dl>

<p>If <code>n</code> is infinite (the default) then the algorithm terminates
only when (b) occurs. The result is sometimes called a
<em>Random Sequential Packing</em>.
</p>
<p>Note that argument <code>n</code> specifies the maximum permitted
<b>total</b> number of points in the pattern returned by
<code>rSSI()</code>. If <code>x.init</code> is not <code>NULL</code> then
the number of points that are <em>added</em>
is at most <code>n - npoints(x.init)</code> if <code>n</code> is finite.
</p>
<p>Thus if <code>x.init</code> is not <code>NULL</code> then argument <code>n</code>
must be at least as large as <code>npoints(x.init)</code>, otherwise
an error is given.  If <code>n==npoints(x.init)</code> then a warning
is given and the call to <code>rSSI()</code> has no real effect;
<code>x.init</code> is returned.
</p>
<p>There is no requirement that the points of <code>x.init</code> be at
a distance at least <code>r</code> from each other.  All of the <em>added</em>
points will be at a distance at least <code>r</code> from each other
and from any point of <code>x.init</code>.
</p>
<p>The points will be generated inside the window <code>win</code>
and the result will be a point pattern in the same window.
</p>
<p>The default window is the unit square, <code>win = square(1)</code>,
unless <code>x.init</code> is specified, when the default
is <code>win=Window(x.init)</code>, the window of <code>x.init</code>.
</p>
<p>If both <code>win</code> and <code>x.init</code> are specified, and if the
two windows are different, then a warning will be issued.
Any points of <code>x.init</code> lying outside <code>win</code> will be removed,
with a warning.
</p>


<h3>Value</h3>

<p>A point pattern (an object of class <code>"ppp"</code>)
if <code>nsim=1</code>, or a list of point patterns if <code>nsim &gt; 1</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpoispp">rpoispp</a></code>,
<code><a href="#topic+rMaternI">rMaternI</a></code>,
<code><a href="#topic+rMaternII">rMaternII</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> Vinf &lt;- rSSI(0.07)

 V100 &lt;- rSSI(0.07, 100)

 X &lt;- runifpoint(100)
 Y &lt;- rSSI(0.03,142,x.init=X) # Y consists of X together with
                              # 42 added points.
 plot(Y, main="rSSI")
 plot(X,add=TRUE,chars=20,cols="red")

 ## inhomogeneous
 Z &lt;- rSSI(0.07, 50, f=function(x,y){x})
 plot(Z)
</code></pre>

<hr>
<h2 id='rstrat'>Simulate Stratified Random Point Pattern</h2><span id='topic+rstrat'></span>

<h3>Description</h3>

<p>Generates a &ldquo;stratified random&rdquo; pattern of points in a window,
by dividing the window into rectangular tiles and placing
<code>k</code> random points independently in each tile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> rstrat(win=square(1), nx, ny=nx, k = 1, nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rstrat_+3A_win">win</code></td>
<td>

<p>A window. 
An object of class <code>owin</code>,
or data in any format acceptable to <code>as.owin()</code>.
</p>
</td></tr>
<tr><td><code id="rstrat_+3A_nx">nx</code></td>
<td>
<p>Number of tiles in each column.
</p>
</td></tr>
<tr><td><code id="rstrat_+3A_ny">ny</code></td>
<td>
<p>Number of tiles in each row.
</p>
</td></tr>
<tr><td><code id="rstrat_+3A_k">k</code></td>
<td>
<p>Number of random points to generate in each tile.
</p>
</td></tr>
<tr><td><code id="rstrat_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rstrat_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a random pattern of points
in a &ldquo;stratified random&rdquo; sampling design. It can be useful
for generating random spatial sampling points.
</p>
<p>The bounding rectangle of <code>win</code> is divided into
a regular <code class="reqn">nx \times ny</code> grid of rectangular tiles.
In each tile, <code>k</code> random points are generated independently
with a uniform distribution in that tile. 
</p>
<p>Some of these grid points may lie outside the window <code>win</code>:
if they do, they are deleted.
</p>
<p>The result is a point pattern inside the window <code>win</code>.
</p>
<p>This function is useful in creating dummy points for quadrature
schemes (see <code>quadscheme</code>) as well as in simulating
random point patterns.
</p>


<h3>Value</h3>

<p>A point pattern (an object of class <code>"ppp"</code>)
if <code>nsim=1</code>, or a list of point patterns if <code>nsim &gt; 1</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code>rsyst</code>,
<code><a href="#topic+runifpoint">runifpoint</a></code>,
<code>quadscheme</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rstrat(nx=10)
  plot(X)

  # polygonal boundary
  X &lt;- rstrat(letterR, 5, 10, k=3)
  plot(X)
</code></pre>

<hr>
<h2 id='rStrauss'>Perfect Simulation of the Strauss Process</h2><span id='topic+rStrauss'></span>

<h3>Description</h3>

<p>Generate a random pattern of points, a simulated realisation
of the Strauss process, using a perfect simulation algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rStrauss(beta, gamma = 1, R = 0, W = owin(), expand=TRUE, nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rStrauss_+3A_beta">beta</code></td>
<td>

<p>intensity parameter (a positive number).
</p>
</td></tr>
<tr><td><code id="rStrauss_+3A_gamma">gamma</code></td>
<td>

<p>interaction parameter (a number between 0 and 1, inclusive).
</p>
</td></tr>
<tr><td><code id="rStrauss_+3A_r">R</code></td>
<td>

<p>interaction radius (a non-negative number).
</p>
</td></tr>
<tr><td><code id="rStrauss_+3A_w">W</code></td>
<td>

<p>window (object of class <code>"owin"</code>) in which to
generate the random pattern. 
</p>
</td></tr>
<tr><td><code id="rStrauss_+3A_expand">expand</code></td>
<td>

<p>Logical. If <code>FALSE</code>, simulation is performed
in the window <code>W</code>, which must be rectangular.
If <code>TRUE</code> (the default), simulation is performed
on a larger window, and the result is clipped to the original
window <code>W</code>.
Alternatively <code>expand</code> can be an object of class 
<code>"rmhexpand"</code> (see <code><a href="#topic+rmhexpand">rmhexpand</a></code>)
determining the expansion method.
</p>
</td></tr>
<tr><td><code id="rStrauss_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rStrauss_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a realisation of the 
Strauss point process in the window <code>W</code>
using a &lsquo;perfect simulation&rsquo; algorithm.
</p>
<p>The Strauss process (Strauss, 1975; Kelly and Ripley, 1976)
is a model for spatial inhibition, ranging from
a strong &lsquo;hard core&rsquo; inhibition to a completely random pattern
according to the value of <code>gamma</code>.
</p>
<p>The Strauss process with interaction radius <code class="reqn">R</code> and 
parameters <code class="reqn">\beta</code> and <code class="reqn">\gamma</code>
is the pairwise interaction point process
with probability density 
</p>
<p style="text-align: center;"><code class="reqn">
    f(x_1,\ldots,x_n) =
    \alpha \beta^{n(x)} \gamma^{s(x)}
  </code>
</p>

<p>where <code class="reqn">x_1,\ldots,x_n</code> represent the 
points of the pattern, <code class="reqn">n(x)</code> is the number of points in the
pattern, <code class="reqn">s(x)</code> is the number of distinct unordered pairs of
points that are closer than <code class="reqn">R</code> units apart,
and <code class="reqn">\alpha</code> is the normalising constant.
Intuitively, each point of the pattern
contributes a factor <code class="reqn">\beta</code> to the 
probability density, and each pair of points
closer than <code class="reqn">r</code> units apart contributes a factor
<code class="reqn">\gamma</code> to the density.
</p>
<p>The interaction parameter <code class="reqn">\gamma</code> must be less than
or equal to <code class="reqn">1</code> in order that the process be well-defined
(Kelly and Ripley, 1976).
This model describes an &ldquo;ordered&rdquo; or &ldquo;inhibitive&rdquo; pattern.
If <code class="reqn">\gamma=1</code> it reduces to a Poisson process
(complete spatial randomness) with intensity <code class="reqn">\beta</code>.
If <code class="reqn">\gamma=0</code> it is called a &ldquo;hard core process&rdquo;
with hard core radius <code class="reqn">R/2</code>, since no pair of points is permitted
to lie closer than <code class="reqn">R</code> units apart.
</p>
<p>The simulation algorithm used to generate the point pattern
is &lsquo;dominated coupling from the past&rsquo;
as implemented by Berthelsen and Moller (2002, 2003).
This is a &lsquo;perfect simulation&rsquo; or &lsquo;exact simulation&rsquo;
algorithm, so called because the output of the algorithm is guaranteed
to have the correct probability distribution exactly (unlike the
Metropolis-Hastings algorithm used in <code><a href="#topic+rmh">rmh</a></code>, whose output
is only approximately correct).
</p>
<p>There is a tiny chance that the algorithm will 
run out of space before it has terminated. If this occurs, an error
message will be generated.
</p>


<h3>Value</h3>

<p>If <code>nsim = 1</code>, a point pattern (object of class <code>"ppp"</code>).
If <code>nsim &gt; 1</code>, a list of point patterns.
</p>


<h3>Author(s)</h3>

<p>Kasper Klitgaard Berthelsen,
adapted for <span class="pkg">spatstat</span> by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>References</h3>

<p>Berthelsen, K.K. and Moller, J. (2002)
A primer on perfect simulation for spatial point processes.
<em>Bulletin of the Brazilian Mathematical Society</em> 33, 351-367.
</p>
<p>Berthelsen, K.K. and Moller, J. (2003)
Likelihood and non-parametric Bayesian MCMC inference 
for spatial point processes based on perfect simulation and
path sampling. 
<em>Scandinavian Journal of Statistics</em> 30, 549-564.
</p>
<p>Kelly, F.P. and Ripley, B.D. (1976)
On Strauss's model for clustering.
<em>Biometrika</em> <b>63</b>, 357&ndash;360.
</p>
<p>Moller, J. and Waagepetersen, R. (2003).
<em>Statistical Inference and Simulation for Spatial Point Processes.</em>
Chapman and Hall/CRC.
</p>
<p>Strauss, D.J. (1975)
A model for clustering.
<em>Biometrika</em> <b>62</b>, 467&ndash;475.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmh">rmh</a></code>,
<code><a href="spatial.html#topic+Strauss">Strauss</a></code>,
<code><a href="#topic+rHardcore">rHardcore</a></code>,
<code><a href="#topic+rStraussHard">rStraussHard</a></code>,
<code><a href="#topic+rDiggleGratton">rDiggleGratton</a></code>,
<code><a href="#topic+rDGS">rDGS</a></code>,
<code><a href="#topic+rPenttinen">rPenttinen</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rStrauss(0.05,0.2,1.5,square(50))
</code></pre>

<hr>
<h2 id='rStraussHard'>Perfect Simulation of the Strauss-Hardcore Process</h2><span id='topic+rStraussHard'></span>

<h3>Description</h3>

<p>Generate a random pattern of points, a simulated realisation
of the Strauss-Hardcore process, using a perfect simulation algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rStraussHard(beta, gamma = 1, R = 0, H = 0, W = owin(),
               expand=TRUE, nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rStraussHard_+3A_beta">beta</code></td>
<td>

<p>intensity parameter (a positive number).
</p>
</td></tr>
<tr><td><code id="rStraussHard_+3A_gamma">gamma</code></td>
<td>

<p>interaction parameter (a number between 0 and 1, inclusive).
</p>
</td></tr>
<tr><td><code id="rStraussHard_+3A_r">R</code></td>
<td>

<p>interaction radius (a non-negative number).
</p>
</td></tr>
<tr><td><code id="rStraussHard_+3A_h">H</code></td>
<td>

<p>hard core distance (a non-negative number smaller than <code>R</code>).
</p>
</td></tr>
<tr><td><code id="rStraussHard_+3A_w">W</code></td>
<td>

<p>window (object of class <code>"owin"</code>) in which to
generate the random pattern. Currently this must be a rectangular
window.
</p>
</td></tr>
<tr><td><code id="rStraussHard_+3A_expand">expand</code></td>
<td>

<p>Logical. If <code>FALSE</code>, simulation is performed
in the window <code>W</code>, which must be rectangular.
If <code>TRUE</code> (the default), simulation is performed
on a larger window, and the result is clipped to the original
window <code>W</code>.
Alternatively <code>expand</code> can be an object of class 
<code>"rmhexpand"</code> (see <code><a href="#topic+rmhexpand">rmhexpand</a></code>)
determining the expansion method.
</p>
</td></tr>
<tr><td><code id="rStraussHard_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rStraussHard_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a realisation of the 
Strauss-Hardcore point process in the window <code>W</code>
using a &lsquo;perfect simulation&rsquo; algorithm.
</p>
<p>The Strauss-Hardcore process is described in <code><a href="spatstat.model.html#topic+StraussHard">StraussHard</a></code>.
</p>
<p>The simulation algorithm used to generate the point pattern
is &lsquo;dominated coupling from the past&rsquo;
as implemented by Berthelsen and Moller (2002, 2003).
This is a &lsquo;perfect simulation&rsquo; or &lsquo;exact simulation&rsquo;
algorithm, so called because the output of the algorithm is guaranteed
to have the correct probability distribution exactly (unlike the
Metropolis-Hastings algorithm used in <code><a href="#topic+rmh">rmh</a></code>, whose output
is only approximately correct).
</p>
<p>A limitation of the perfect simulation algorithm
is that the interaction parameter
<code class="reqn">\gamma</code> must be less than or equal to <code class="reqn">1</code>.
To simulate a Strauss-hardcore process with
<code class="reqn">\gamma &gt; 1</code>, use <code><a href="#topic+rmh">rmh</a></code>.
</p>
<p>There is a tiny chance that the algorithm will 
run out of space before it has terminated. If this occurs, an error
message will be generated.
</p>


<h3>Value</h3>

<p>If <code>nsim = 1</code>, a point pattern (object of class <code>"ppp"</code>).
If <code>nsim &gt; 1</code>, a list of point patterns.
</p>


<h3>Author(s)</h3>

<p>Kasper Klitgaard Berthelsen and Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>References</h3>

<p>Berthelsen, K.K. and Moller, J. (2002)
A primer on perfect simulation for spatial point processes.
<em>Bulletin of the Brazilian Mathematical Society</em> 33, 351-367.
</p>
<p>Berthelsen, K.K. and Moller, J. (2003)
Likelihood and non-parametric Bayesian MCMC inference 
for spatial point processes based on perfect simulation and
path sampling. 
<em>Scandinavian Journal of Statistics</em> 30, 549-564.
</p>
<p>Moller, J. and Waagepetersen, R. (2003).
<em>Statistical Inference and Simulation for Spatial Point Processes.</em>
Chapman and Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmh">rmh</a></code>,
<code><a href="spatstat.model.html#topic+StraussHard">StraussHard</a></code>.
</p>
<p><code><a href="#topic+rHardcore">rHardcore</a></code>,
<code><a href="#topic+rStrauss">rStrauss</a></code>,
<code><a href="#topic+rDiggleGratton">rDiggleGratton</a></code>,
<code><a href="#topic+rDGS">rDGS</a></code>,
<code><a href="#topic+rPenttinen">rPenttinen</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   Z &lt;- rStraussHard(100,0.7,0.05,0.02)
   Y &lt;- rStraussHard(100,0.7,0.05,0.01, nsim=2)
</code></pre>

<hr>
<h2 id='rtemper'>
Simulated Annealing or Simulated Tempering for Gibbs Point Processes
</h2><span id='topic+rtemper'></span>

<h3>Description</h3>

<p>Performs simulated annealing or simulated tempering
for a Gibbs point process model using a specified
annealing schedule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtemper(model, invtemp, nrep, ..., track=FALSE, start = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtemper_+3A_model">model</code></td>
<td>

<p>A Gibbs point process model: a fitted Gibbs point process model
(object of class <code>"ppm"</code>), or any data acceptable to
<code><a href="#topic+rmhmodel">rmhmodel</a></code>.
</p>
</td></tr>
<tr><td><code id="rtemper_+3A_invtemp">invtemp</code></td>
<td>

<p>A numeric vector of positive numbers.
The sequence of values of inverse temperature that will be used.
</p>
</td></tr>
<tr><td><code id="rtemper_+3A_nrep">nrep</code></td>
<td>

<p>An integer vector of the same length as <code>invtemp</code>.
The value <code>nrep[i]</code> specifies the number of steps of the
Metropolis-Hastings algorithm that will be performed
at inverse temperature <code>invtemp[i]</code>.
</p>
</td></tr>
<tr><td><code id="rtemper_+3A_start">start</code></td>
<td>

<p>Initial starting state for the simulation.
Any data acceptable to <code><a href="#topic+rmhstart">rmhstart</a></code>.
</p>
</td></tr>
<tr><td><code id="rtemper_+3A_track">track</code></td>
<td>

<p>Logical flag indicating whether to save the transition
history of the simulations.
</p>
</td></tr>
<tr><td><code id="rtemper_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="#topic+rmh.default">rmh.default</a></code>.
</p>
</td></tr>
<tr><td><code id="rtemper_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print progress reports.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Metropolis-Hastings simulation algorithm
<code><a href="#topic+rmh">rmh</a></code> is run for
<code>nrep[1]</code> steps at inverse temperature <code>invtemp[1]</code>,
then for 
<code>nrep[2]</code> steps at inverse temperature <code>invtemp[2]</code>,
and so on.
</p>
<p>Setting the inverse temperature to a value <code class="reqn">\alpha</code>
means that the probability density of the Gibbs model, <code class="reqn">f(x)</code>,
is replaced by <code class="reqn">g(x) = C\, f(x)^\alpha</code>
where <code class="reqn">C</code> is a normalising constant depending on
<code class="reqn">\alpha</code>.
Larger values of <code class="reqn">\alpha</code> exaggerate the high and low
values of probability density, while smaller values of <code class="reqn">\alpha</code>
flatten out the probability density.
</p>
<p>For example if the original <code>model</code> is a Strauss process,
the modified model is close to a hard core process
for large values of inverse temperature, and close to a Poisson process
for small values of inverse temperature. 
</p>


<h3>Value</h3>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>
<p>If <code>track=TRUE</code>, the result also has an attribute
<code>"history"</code> which is a data frame with columns
<code>proposaltype</code>, <code>accepted</code>, 
<code>numerator</code> and <code>denominator</code>, as described
in <code><a href="#topic+rmh.default">rmh.default</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmh.default">rmh.default</a></code>,
<code><a href="#topic+rmh">rmh</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   stra &lt;- rmhmodel(cif="strauss",
                    par=list(beta=2,gamma=0.2,r=0.7),
                    w=square(10))
   nr &lt;- if(interactive()) 1e5 else 1e3
   Y &lt;- rtemper(stra, c(1, 2, 4, 8), nr * (1:4), verbose=TRUE, track=TRUE)
</code></pre>

<hr>
<h2 id='rthin'>Random Thinning</h2><span id='topic+rthin'></span>

<h3>Description</h3>

<p>Applies independent random thinning to a point pattern or segment pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rthin(X, P, ..., nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rthin_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code> or <code>"lpp"</code>
or <code>"pp3"</code> or <code>"ppx"</code>) or line segment pattern
(object of class <code>"psp"</code>) that will be thinned.
</p>
</td></tr>
<tr><td><code id="rthin_+3A_p">P</code></td>
<td>

<p>Data giving the retention probabilities, i.e. the probability
that each point or line in <code>X</code> will be retained.
Either a single number, or a vector of numbers,
or a <code>function(x,y)</code> in the <span class="rlang"><b>R</b></span> language,
or a function object (class <code>"funxy"</code> or <code>"linfun"</code>),
or a pixel image (object of class <code>"im"</code> or <code>"linim"</code>).
</p>
</td></tr>
<tr><td><code id="rthin_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code>P</code>, if it is a function.
</p>
</td></tr>
<tr><td><code id="rthin_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rthin_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a random thinning operation, each point of the point pattern <code>X</code>
is randomly either deleted or retained (i.e. not deleted).
The result is a point pattern,
consisting of those points of <code>X</code> that were retained.
</p>
<p>Independent random thinning means that the retention/deletion of each
point is independent of other points.
</p>
<p>The argument <code>P</code> determines the probability of <b>retaining</b>
each point. It may be
</p>

<dl>
<dt>a single number,</dt><dd><p>so that each point will be retained with
the same probability <code>P</code>;
</p>
</dd>
<dt>a vector of numbers,</dt><dd><p>so that the <code>i</code>th point of <code>X</code>
will be retained with probability <code>P[i]</code>;
</p>
</dd>
<dt>a function <code>P(x,y)</code>,</dt><dd><p>so that a point at a location
<code>(x,y)</code> will be retained with probability <code>P(x,y)</code>;
</p>
</dd>
<dt>an object of class <code>"funxy"</code> or <code>"linfun"</code>,</dt><dd><p>so that
points in the pattern <code>X</code> will be retained with probabilities
<code>P(X)</code>;
</p>
</dd>
<dt>a pixel image,</dt><dd><p>containing values of the retention probability
for all locations in a region encompassing the point pattern.
</p>
</dd>
</dl>

<p>If <code>P</code> is a function <code>P(x,y)</code>,
it should be &lsquo;vectorised&rsquo;, that is,
it should accept vector arguments <code>x,y</code> and should yield a
numeric vector of the same length. The function may have extra
arguments which are passed through the <code>...</code> argument.
</p>


<h3>Value</h3>

<p>An object of the same kind as <code>X</code>
if <code>nsim=1</code>, or a list of such objects if <code>nsim &gt; 1</code>.
</p>


<h3>Reproducibility</h3>

<p>The algorithm for random thinning was changed in <span class="pkg">spatstat</span>
version <code>1.42-3</code>. Set <code>spatstat.options(fastthin=FALSE)</code>
to use the previous, slower algorithm, if it is desired to reproduce
results obtained with earlier versions.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(redwood, main="thinning")
  
  # delete 20% of points
  Y &lt;- rthin(redwood, 0.8)
  points(Y, col="green", cex=1.4)

  # function
  f &lt;- function(x,y) { ifelse(x &lt; 0.4, 1, 0.5) }
  Y &lt;- rthin(redwood, f)

  # pixel image
  Z &lt;- as.im(f, Window(redwood))
  Y &lt;- rthin(redwood, Z)


  # thin other kinds of patterns
  E &lt;- rthin(osteo$pts[[1]], 0.6)
  L &lt;- rthin(copper$Lines, 0.5)
</code></pre>

<hr>
<h2 id='rthinclumps'>Random Thinning of Clumps</h2><span id='topic+rthinclumps'></span>

<h3>Description</h3>

<p>Finds the topologically-connected clumps of a spatial region
and randomly deletes some of the clumps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rthinclumps(W, p, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rthinclumps_+3A_w">W</code></td>
<td>

<p>Window (object of class <code>"owin"</code>
or pixel image (object of class <code>"im"</code>).
</p>
</td></tr>
<tr><td><code id="rthinclumps_+3A_p">p</code></td>
<td>

<p>Probability of <em>retaining</em> each clump.
A single number between 0 and 1.
</p>
</td></tr>
<tr><td><code id="rthinclumps_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code>connected.im</code>
or <code>connected.owin</code> to determine the connected clumps.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>W</code> specifies a region of space, typically
consisting of several clumps that are not connected to each other.
The algorithm randomly deletes or retains each clump. The fate of
each clump is independent of other clumps.
</p>
<p>If <code>W</code> is a spatial window (class <code>"owin"</code>) then
it will be divided into clumps using 
<code>connected.owin</code>. Each clump will either be
retained (with probability <code>p</code>) or deleted in its entirety
(with probability <code>1-p</code>). 
</p>
<p>If <code>W</code> is a pixel image (class <code>"im"</code>) then its domain
will be divided into clumps using <code>connected.im</code>. The default
behaviour depends on the type of pixel values. If the pixel values are
logical, then the spatial region will be taken to consist of all
pixels whose value is <code>TRUE</code>. Otherwise, the spatial region is
taken to consist of all pixels whose value is defined (i.e. not equal
to <code>NA</code>). This behaviour can be changed using the argument
<code>background</code> passed to <code>connected.im</code>.
</p>
<p>The result is a window comprising all the clumps that were retained.
</p>


<h3>Value</h3>

<p>Window (object of class <code>"owin"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rthin">rthin</a></code> for thinning other kinds of objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  A &lt;- (distmap(cells) &lt; 0.06)
  opa &lt;- par(mfrow=c(1,2))
  plot(A)
  plot(rthinclumps(A, 0.5))
  par(opa)
</code></pre>

<hr>
<h2 id='rThomas'>Simulate Thomas Process</h2><span id='topic+rThomas'></span>

<h3>Description</h3>

<p>Generate a random point pattern, a simulated realisation of the
Thomas cluster process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rThomas(kappa, scale, mu, win = square(1),
             nsim=1, drop=TRUE,
             ...,
             algorithm=c("BKBC", "naive"),
             nonempty=TRUE, 
             poisthresh=1e-6,
             expand = 4*scale,
             saveparents=FALSE, saveLambda=FALSE,
             kappamax=NULL, mumax=NULL, sigma) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rThomas_+3A_kappa">kappa</code></td>
<td>

<p>Intensity of the Poisson process of cluster centres.
A single positive number, a function, or a pixel image.
</p>
</td></tr>
<tr><td><code id="rThomas_+3A_scale">scale</code></td>
<td>

<p>Cluster size.
Standard deviation of random displacement (along each coordinate axis)
of a point from its cluster centre. A single positive number.
</p>
</td></tr>
<tr><td><code id="rThomas_+3A_mu">mu</code></td>
<td>

<p>Mean number of points per cluster (a single positive number)
or reference intensity for the cluster points (a function or
a pixel image).
</p>
</td></tr>
<tr><td><code id="rThomas_+3A_win">win</code></td>
<td>

<p>Window in which to simulate the pattern.
An object of class <code>"owin"</code>
or something acceptable to <code><a href="spatstat.geom.html#topic+as.owin">as.owin</a></code>.
</p>
</td></tr>
<tr><td><code id="rThomas_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rThomas_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
<tr><td><code id="rThomas_+3A_...">...</code></td>
<td>

<p>Passed to <code><a href="#topic+clusterfield">clusterfield</a></code> to control the image
resolution when <code>saveLambda=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="rThomas_+3A_algorithm">algorithm</code></td>
<td>

<p>String (partially matched) specifying the simulation algorithm.
See Details.
</p>
</td></tr>
<tr><td><code id="rThomas_+3A_nonempty">nonempty</code></td>
<td>

<p>Logical. If <code>TRUE</code> (the default), a more efficient algorithm is
used, in which parents are generated conditionally on having at
least one offspring point in the window.
If <code>FALSE</code>, parents are generated
even if they have no offspring in the window. The default
is recommended unless you need to simulate all the parent points
for some other purpose.
</p>
</td></tr>
<tr><td><code id="rThomas_+3A_poisthresh">poisthresh</code></td>
<td>

<p>Numerical threshold below which the model will be treated
as a Poisson process. See Details.
</p>
</td></tr>
<tr><td><code id="rThomas_+3A_expand">expand</code></td>
<td>

<p>Window expansion distance. A single number.
The distance by which the original window will be expanded
in order to generate parent points.
Has a sensible default.
</p>
</td></tr>
<tr><td><code id="rThomas_+3A_saveparents">saveparents</code></td>
<td>

<p>Logical value indicating whether to save the locations of the
parent points as an attribute.
</p>
</td></tr>
<tr><td><code id="rThomas_+3A_savelambda">saveLambda</code></td>
<td>

<p>Logical. If <code>TRUE</code> then the random intensity corresponding to
the simulated parent points will also be calculated and saved,
and returns as an attribute of the point pattern.
</p>
</td></tr>
<tr><td><code id="rThomas_+3A_kappamax">kappamax</code></td>
<td>

<p>Optional. Numerical value which is an upper bound for the
values of <code>kappa</code>, when <code>kappa</code> is a pixel image or a
function.
</p>
</td></tr>
<tr><td><code id="rThomas_+3A_mumax">mumax</code></td>
<td>

<p>Optional. Numerical value which is an upper bound for the
values of <code>mu</code>, when <code>mu</code> is a pixel image or a
function.
</p>
</td></tr>
<tr><td><code id="rThomas_+3A_sigma">sigma</code></td>
<td>

<p>Deprecated. Equivalent to <code>scale</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm generates a realisation of the (&lsquo;modified&rsquo;)
Thomas process, a special case of the Neyman-Scott process,
inside the window <code>win</code>.
</p>
<p>In the simplest case, where <code>kappa</code> and <code>mu</code>
are single numbers, the cluster process is formed by first
generating a uniform Poisson point process of &ldquo;parent&rdquo; points 
with intensity <code>kappa</code>. Then each parent point is
replaced by a random cluster of &ldquo;offspring&rdquo; points,
the number of points per cluster being Poisson (<code>mu</code>)
distributed, and their
positions being isotropic Gaussian displacements from the
cluster parent location. The resulting point pattern
is a realisation of the classical
&ldquo;stationary Thomas process&rdquo; generated inside the window <code>win</code>.
This point process has intensity <code>kappa * mu</code>.
</p>
<p>Note that, for correct simulation of the model,
the parent points are not restricted to lie inside the 
window <code>win</code>;
the parent process is effectively the uniform Poisson process
on the infinite plane.
</p>
<p>The algorithm can also generate spatially inhomogeneous versions of
the Thomas process:
</p>

<ul>
<li><p> The parent points can be spatially inhomogeneous.
If the argument <code>kappa</code> is a <code>function(x,y)</code>
or a pixel image (object of class <code>"im"</code>), then it is taken
as specifying the intensity function of an inhomogeneous Poisson
process that generates the parent points.
</p>
</li>
<li><p> The offspring points can be inhomogeneous. If the
argument <code>mu</code> is a <code>function(x,y)</code>
or a pixel image (object of class <code>"im"</code>), then it is
interpreted as the reference density for offspring points,
in the sense of Waagepetersen (2007).
For a given parent point, the offspring constitute a Poisson process
with intensity function equal to <code>mu * f</code>,
where <code>f</code> is the Gaussian probability density
centred at the parent point. Equivalently we first generate,
for each parent point, a Poisson (<code>mumax</code>) random number of
offspring (where <code class="reqn">M</code> is the maximum value of <code>mu</code>)
with independent Gaussian displacements from the parent
location, and then randomly thin the offspring points, with
retention probability <code>mu/M</code>.
</p>
</li>
<li><p> Both the parent points and the offspring points can be
spatially inhomogeneous, as described above.
</p>
</li></ul>

<p>Note that if <code>kappa</code> is a pixel image, its domain must be larger
than the window <code>win</code>. This is because an offspring point inside
<code>win</code> could have its parent point lying outside <code>win</code>.
In order to allow this, the simulation algorithm
first expands the original window <code>win</code>
by a distance <code>expand</code> and generates the Poisson process of
parent points on this larger window. If <code>kappa</code> is a pixel image,
its domain must contain this larger window.
</p>
<p>The intensity of the Thomas process is <code>kappa * mu</code>
if either <code>kappa</code> or <code>mu</code> is a single number. In the general
case the intensity is an integral involving <code>kappa</code>, <code>mu</code>
and <code>f</code>.
</p>
<p>If the pair correlation function of the model is very close
to that of a Poisson process, deviating by less than
<code>poisthresh</code>, then the model is approximately a Poisson process,
and will be simulated as a Poisson process with intensity
<code>kappa * mu</code>, using <code><a href="#topic+rpoispp">rpoispp</a></code>. 
This avoids computations that would otherwise require huge amounts
of memory.
</p>


<h3>Value</h3>

<p>A point pattern (an object of class <code>"ppp"</code>) if <code>nsim=1</code>,
or a list of point patterns if <code>nsim &gt; 1</code>.
</p>
<p>Additionally, some intermediate results of the simulation are returned
as attributes of this point pattern (see <code><a href="#topic+rNeymanScott">rNeymanScott</a></code>).
Furthermore, the simulated intensity
function is returned as an attribute <code>"Lambda"</code>, if
<code>saveLambda=TRUE</code>.
</p>


<h3>Simulation Algorithm</h3>

<p>Two simulation algorithms are implemented.
</p>

<ul>
<li><p> The <em>naive</em> algorithm generates the cluster process 
by directly following the description given above. First the window
<code>win</code> is expanded by a distance equal to <code>expand</code>.
Then the parent points are generated in the expanded window according to
a Poisson process with intensity <code>kappa</code>. Then each parent
point is replaced by a finite cluster of offspring points as
described above.
The naive algorithm is used if <code>algorithm="naive"</code> or if
<code>nonempty=FALSE</code>.
</p>
</li>
<li><p> The <em>BKBC</em> algorithm, proposed by Baddeley and Chang
(2023), is a modification of the algorithm of Brix and Kendall (2002). 
Parents are generated in the infinite plane, subject to the
condition that they have at least one offspring point inside the
window <code>win</code>.
The BKBC algorithm is used when <code>algorithm="BKBC"</code> (the default)
and <code>nonempty=TRUE</code> (the default).
</p>
</li></ul>

<p>The naive algorithm becomes very slow when <code>scale</code> is large,
while the BKBC algorithm is uniformly fast (Baddeley and Chang, 2023).
</p>
<p>If <code>saveparents=TRUE</code>, then the simulated point pattern will
have an attribute <code>"parents"</code> containing the coordinates of the
parent points, and an attribute <code>"parentid"</code> mapping each
offspring point to its parent.
</p>
<p>If <code>nonempty=TRUE</code> (the default), then parents are generated
subject to the condition that they have at least one offspring point 
in the window <code>win</code>. 
<code>nonempty=FALSE</code>, then parents without offspring will be included;
this option is not available in the <em>BKBC</em> algorithm.
</p>
<p>Note that if <code>kappa</code> is a pixel image, its domain must be larger
than the window <code>win</code>. This is because an offspring point inside
<code>win</code> could have its parent point lying outside <code>win</code>.
In order to allow this, the naive simulation algorithm
first expands the original window <code>win</code>
by a distance equal to <code>expand</code> and generates the Poisson process of
parent points on this larger window. If <code>kappa</code> is a pixel image,
its domain must contain this larger window.
</p>
<p>If the pair correlation function of the model is very close
to that of a Poisson process, with maximum deviation less than
<code>poisthresh</code>, then the model is approximately a Poisson process.
This is detected by the naive algorithm which then
simulates a Poisson process with intensity
<code>kappa * mu</code>, using <code><a href="#topic+rpoispp">rpoispp</a></code>. 
This avoids computations that would otherwise require huge amounts
of memory.
</p>


<h3>Fitting cluster models to data</h3>

<p>The Thomas model with homogeneous parents
(i.e. where <code>kappa</code> is a single number)
where the offspring are either homogeneous or inhomogeneous (<code>mu</code>
is a single number, a function or pixel image)
can be fitted to point pattern data using <code><a href="spatstat.model.html#topic+kppm">kppm</a></code>,
or fitted to the inhomogeneous <code class="reqn">K</code> function
using <code><a href="spatstat.model.html#topic+thomas.estK">thomas.estK</a></code>
or <code><a href="spatstat.model.html#topic+thomas.estpcf">thomas.estpcf</a></code>.
</p>
<p>Currently <span class="pkg">spatstat</span> does not support fitting the
Thomas cluster process model
with inhomogeneous parents.
</p>
<p>A Thomas cluster process model fitted by <code><a href="spatstat.model.html#topic+kppm">kppm</a></code>
can be simulated automatically using <code><a href="spatstat.model.html#topic+simulate.kppm">simulate.kppm</a></code>
(which invokes <code>rThomas</code> to perform the simulation).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ya-Mei Chang <a href="mailto:yamei628@gmail.com">yamei628@gmail.com</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. and Chang, Y.-M. (2023) Robust algorithms for simulating cluster point processes. <em>Journal of Statistical Computation and Simulation</em>. In Press. DOI <code>10.1080/00949655.2023.2166045</code>.
</p>
<p>Brix, A. and Kendall, W.S. (2002)
Simulation of cluster point processes without edge effects.
<em>Advances in Applied Probability</em> <b>34</b>, 267&ndash;280.
</p>
<p>Diggle, P. J., Besag, J. and Gleaves, J. T. (1976)
Statistical analysis of spatial point patterns by
means of distance methods. <em>Biometrics</em> <b>32</b> 659&ndash;667.
</p>
<p>Thomas, M. (1949) A generalisation of Poisson's binomial limit for use
in ecology. <em>Biometrika</em> <b>36</b>, 18&ndash;25.
</p>
<p>Waagepetersen, R. (2007)
An estimating function approach to inference for
inhomogeneous Neyman-Scott processes.
<em>Biometrics</em> <b>63</b>, 252&ndash;258.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpoispp">rpoispp</a></code>,    
<code><a href="#topic+rMatClust">rMatClust</a></code>,  
<code><a href="#topic+rCauchy">rCauchy</a></code>,    
<code><a href="#topic+rVarGamma">rVarGamma</a></code>,   
<code><a href="#topic+rNeymanScott">rNeymanScott</a></code>,  
<code><a href="#topic+rGaussPoisson">rGaussPoisson</a></code>.  
</p>
<p>For fitting the model, see
<code><a href="spatstat.model.html#topic+kppm">kppm</a></code>,  
<code><a href="spatstat.model.html#topic+clusterfit">clusterfit</a></code>.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #homogeneous
  X &lt;- rThomas(10, 0.2, 5)
  #inhomogeneous
  Z &lt;- as.im(function(x,y){ 5 * exp(2 * x - 1) }, owin())
  Y &lt;- rThomas(10, 0.2, Z)
</code></pre>

<hr>
<h2 id='runifdisc'>Generate N Uniform Random Points in a Disc</h2><span id='topic+runifdisc'></span>

<h3>Description</h3>

<p>Generate a random point pattern
containing <code class="reqn">n</code> independent uniform random points
in a circular disc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> runifdisc(n, radius=1, centre=c(0,0), ..., nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runifdisc_+3A_n">n</code></td>
<td>

<p>Number of points.
</p>
</td></tr>
<tr><td><code id="runifdisc_+3A_radius">radius</code></td>
<td>
<p>Radius of the circle.</p>
</td></tr>
<tr><td><code id="runifdisc_+3A_centre">centre</code></td>
<td>
<p>Coordinates of the centre of the circle.</p>
</td></tr>
<tr><td><code id="runifdisc_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code>disc</code> controlling the
accuracy of approximation to the circle.
</p>
</td></tr>
<tr><td><code id="runifdisc_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="runifdisc_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates <code>n</code> independent random points,
uniformly distributed in a circular disc.
</p>
<p>It is faster (for a circular window) than the general
code used in <code><a href="#topic+runifpoint">runifpoint</a></code>.
</p>
<p>To generate random points in an ellipse, first generate points in a
circle using <code>runifdisc</code>,
then transform to an ellipse using <code>affine</code>,
as shown in the examples.
</p>
<p>To generate random points in other windows, use
<code><a href="#topic+runifpoint">runifpoint</a></code>.
To generate non-uniform random points, use <code><a href="#topic+rpoint">rpoint</a></code>.
</p>


<h3>Value</h3>

<p>A point pattern (an object of class <code>"ppp"</code>)
if <code>nsim=1</code>, or a list of point patterns if <code>nsim &gt; 1</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code>disc</code>,
<code><a href="#topic+runifpoint">runifpoint</a></code>,
<code><a href="#topic+rpoint">rpoint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # 100 random points in the unit disc
 plot(runifdisc(100))
 # 42 random points in the ellipse with major axis 3 and minor axis 1
 X &lt;- runifdisc(42)
 Y &lt;- affine(X, mat=diag(c(3,1)))
 plot(Y)
</code></pre>

<hr>
<h2 id='runifpoint'>Generate N Uniform Random Points</h2><span id='topic+runifpoint'></span>

<h3>Description</h3>

<p>Generate a random point pattern
containing <code class="reqn">n</code> independent uniform random points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> runifpoint(n, win=owin(c(0,1),c(0,1)), giveup=1000, warn=TRUE, ...,
            nsim=1, drop=TRUE, ex=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runifpoint_+3A_n">n</code></td>
<td>

<p>Number of points.
</p>
</td></tr>
<tr><td><code id="runifpoint_+3A_win">win</code></td>
<td>

<p>Window in which to simulate the pattern.
An object of class <code>"owin"</code>
or something acceptable to <code>as.owin</code>.
(Alternatively a tessellation; see the section on
tessellations).
</p>
</td></tr>
<tr><td><code id="runifpoint_+3A_giveup">giveup</code></td>
<td>

<p>Number of attempts in the rejection method after which
the algorithm should stop trying to generate new points.
</p>
</td></tr>
<tr><td><code id="runifpoint_+3A_warn">warn</code></td>
<td>

<p>Logical. Whether to issue a warning if <code>n</code> is very large.
See Details.
</p>
</td></tr>
<tr><td><code id="runifpoint_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="runifpoint_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="runifpoint_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
<tr><td><code id="runifpoint_+3A_ex">ex</code></td>
<td>

<p>Optional. A point pattern to use as the example.
If <code>ex</code> is given and <code>n</code> and <code>win</code> are missing,
then <code>n</code> and <code>win</code> will be calculated from
the point pattern <code>ex</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates <code>n</code> independent random points,
uniformly distributed in the window <code>win</code>.
(For nonuniform distributions, see <code><a href="#topic+rpoint">rpoint</a></code>.)
</p>
<p>The algorithm depends on the type of window, as follows:
</p>

<ul>
<li>
<p>If <code>win</code> is a rectangle then 
<code class="reqn">n</code> independent random points, uniformly distributed
in the rectangle, are generated by assigning uniform random values to their
cartesian coordinates.
</p>
</li>
<li>
<p>If <code>win</code> is a binary image mask, then a random sequence of 
pixels is selected (using <code><a href="base.html#topic+sample">sample</a></code>)
with equal probabilities. Then for each pixel in the sequence
we generate a uniformly distributed random point in that pixel.
</p>
</li>
<li>
<p>If <code>win</code> is a polygonal window, the algorithm uses the rejection
method. It finds a rectangle enclosing the window,
generates points in this rectangle, and tests whether they fall in
the desired window. It gives up when <code>giveup * n</code> tests
have been performed without yielding <code>n</code> successes.
</p>
</li></ul>

<p>The algorithm for binary image masks is faster than the rejection
method but involves discretisation.
</p>
<p>If <code>warn=TRUE</code> (the default), a warning will be issued if <code>n</code> is very large.
The threshold is <code>spatstat.options("huge.npoints")</code>.
This warning has no consequences,
but it helps to trap a number of common errors.
</p>


<h3>Value</h3>

<p>A point pattern (an object of class <code>"ppp"</code>)
or a list of point patterns.
</p>


<h3>Tessellation</h3>

<p>The argument <code>win</code> may be a tessellation
(object of class <code>"tess"</code>, see <code>tess</code>).
Then the specified number of points <code>n</code> will be randomly generated
inside each tile of the tessellation. The argument <code>n</code> may be
either a single integer, or an integer vector specifying the number
of points to be generated in each individual tile. The result will
be a point pattern in the window <code>as.owin(win)</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code>ppp.object</code>,
<code>owin.object</code>,
<code><a href="#topic+rpoispp">rpoispp</a></code>,
<code><a href="#topic+rpoint">rpoint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # 100 random points in the unit square
 pp &lt;- runifpoint(100)
 # irregular window
 letterR
 # polygonal
 pp &lt;- runifpoint(100, letterR)
 # binary image mask
 pp &lt;- runifpoint(100, as.mask(letterR))

 # randomising an existing point pattern
 runifpoint(npoints(cells), win=Window(cells))
 runifpoint(ex=cells)

 # tessellation
 A &lt;- quadrats(unit.square(), 2, 3)
 # different numbers of points in each cell
 X &lt;- runifpoint(1:6, A)
</code></pre>

<hr>
<h2 id='runifpoint3'>
Generate N Uniform Random Points in Three Dimensions
</h2><span id='topic+runifpoint3'></span>

<h3>Description</h3>

<p>Generate a random point pattern containing <code>n</code>
independent, uniform random points in three dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runifpoint3(n, domain = box3(), nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runifpoint3_+3A_n">n</code></td>
<td>

<p>Number of points to be generated.
</p>
</td></tr>
<tr><td><code id="runifpoint3_+3A_domain">domain</code></td>
<td>

<p>Three-dimensional box in which the process should be generated.
An object of class <code>"box3"</code>.
</p>
</td></tr>
<tr><td><code id="runifpoint3_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="runifpoint3_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates <code>n</code> independent random points,
uniformly distributed in the three-dimensional box <code>domain</code>.
</p>


<h3>Value</h3>

<p>If <code>nsim = 1</code> and <code>drop=TRUE</code>, a point pattern in
three dimensions (an object of class <code>"pp3"</code>).
If <code>nsim &gt; 1</code>, a list of such point patterns.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpoispp3">rpoispp3</a></code>, 
<code>pp3</code>, 
<code>box3</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- runifpoint3(50)
</code></pre>

<hr>
<h2 id='runifpointOnLines'>Generate N Uniform Random Points On Line Segments</h2><span id='topic+runifpointOnLines'></span>

<h3>Description</h3>

<p>Given a line segment pattern, generate a random point pattern
consisting of <code>n</code> points uniformly distributed on the
line segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runifpointOnLines(n, L, nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runifpointOnLines_+3A_n">n</code></td>
<td>
<p>Number of points to generate.</p>
</td></tr>
<tr><td><code id="runifpointOnLines_+3A_l">L</code></td>
<td>
<p>Line segment pattern (object of class <code>"psp"</code>)
on which the points should lie.
</p>
</td></tr>
<tr><td><code id="runifpointOnLines_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="runifpointOnLines_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command generates a point pattern consisting of <code>n</code>
independent random points, each point uniformly distributed on
the line segment pattern. This means that, for each random point,
</p>

<ul>
<li><p> the
probability of falling on a particular segment is proportional to the
length of the segment; and
</p>
</li>
<li><p> given that the point falls on a particular segment,
it has uniform probability density along that segment.
</p>
</li></ul>

<p>If <code>n</code> is a single integer, the result is an unmarked point
pattern containing <code>n</code> points.
If <code>n</code> is a vector of integers, the result is a marked point
pattern, with <code>m</code> different types of points, where
<code>m = length(n)</code>,
in which there are <code>n[j]</code> points of type <code>j</code>.
</p>


<h3>Value</h3>

<p>If <code>nsim = 1</code>, 
a point pattern (object of class <code>"ppp"</code>) with the same
window as <code>L</code>.
If <code>nsim &gt; 1</code>, a list of point patterns.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code>psp</code>,
<code>ppp</code>,
<code>pointsOnLines</code>,
<code><a href="#topic+runifpoint">runifpoint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- psp(runif(10), runif(10), runif(10), runif(10),  window=owin())
  Y &lt;- runifpointOnLines(20, X)
  plot(X, main="")
  plot(Y, add=TRUE)
  Z &lt;- runifpointOnLines(c(5,5), X)
</code></pre>

<hr>
<h2 id='runifpointx'>
Generate N Uniform Random Points in Any Dimensions
</h2><span id='topic+runifpointx'></span>

<h3>Description</h3>

<p>Generate a random point pattern containing <code>n</code>
independent, uniform random points in any number of spatial dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runifpointx(n, domain, nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runifpointx_+3A_n">n</code></td>
<td>

<p>Number of points to be generated.
</p>
</td></tr>
<tr><td><code id="runifpointx_+3A_domain">domain</code></td>
<td>

<p>Multi-dimensional box in which the process should be generated.
An object of class <code>"boxx"</code>.
</p>
</td></tr>
<tr><td><code id="runifpointx_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="runifpointx_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a single point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a pattern of <code>n</code> independent random points,
uniformly distributed in the multi-dimensional box <code>domain</code>.
</p>


<h3>Value</h3>

<p>If <code>nsim = 1</code> and <code>drop=TRUE</code>,
a point pattern (an object of class <code>"ppx"</code>).
If <code>nsim &gt; 1</code> or <code>drop=FALSE</code>, a list of such point patterns.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpoisppx">rpoisppx</a></code>, 
<code>ppx</code>, 
<code><a href="cli.html#topic+boxx">boxx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   w &lt;- boxx(x=c(0,1), y=c(0,1), z=c(0,1), t=c(0,3))
   X &lt;- runifpointx(50, w)
</code></pre>

<hr>
<h2 id='rVarGamma'>Simulate Neyman-Scott Point Process with Variance Gamma cluster kernel</h2><span id='topic+rVarGamma'></span>

<h3>Description</h3>

<p>Generate a random point pattern, a simulated realisation of the
Neyman-Scott process with Variance Gamma (Bessel) cluster kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> rVarGamma(kappa, scale, mu, 
              nu,
              win = square(1),
              nsim=1, drop=TRUE,
              ...,
              algorithm=c("BKBC", "naive"),
              nonempty=TRUE, 
              thresh = 0.001,
              poisthresh=1e-6,
              expand = NULL,
              saveparents=FALSE, saveLambda=FALSE,
              kappamax=NULL, mumax=NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rVarGamma_+3A_kappa">kappa</code></td>
<td>

<p>Intensity of the Poisson process of cluster centres.
A single positive number, a function, or a pixel image.
</p>
</td></tr>
<tr><td><code id="rVarGamma_+3A_scale">scale</code></td>
<td>

<p>Scale parameter for cluster kernel. Determines the size of clusters.
A single positive number, in the same units as the spatial coordinates.
</p>
</td></tr>
<tr><td><code id="rVarGamma_+3A_mu">mu</code></td>
<td>

<p>Mean number of points per cluster (a single positive number)
or reference intensity for the cluster points (a function or
a pixel image).
</p>
</td></tr>
<tr><td><code id="rVarGamma_+3A_nu">nu</code></td>
<td>

<p>Shape parameter for the cluster kernel. A number greater than -1.
</p>
</td></tr>
<tr><td><code id="rVarGamma_+3A_win">win</code></td>
<td>

<p>Window in which to simulate the pattern.
An object of class <code>"owin"</code>
or something acceptable to <code><a href="spatstat.geom.html#topic+as.owin">as.owin</a></code>.
</p>
</td></tr>
<tr><td><code id="rVarGamma_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rVarGamma_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
<tr><td><code id="rVarGamma_+3A_...">...</code></td>
<td>

<p>Passed to <code><a href="#topic+clusterfield">clusterfield</a></code> to control the image
resolution when <code>saveLambda=TRUE</code>, and to 
<code><a href="#topic+clusterradius">clusterradius</a></code> when
<code>expand</code> is missing or <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="rVarGamma_+3A_algorithm">algorithm</code></td>
<td>

<p>String (partially matched) specifying the simulation algorithm.
See Details.
</p>
</td></tr>
<tr><td><code id="rVarGamma_+3A_nonempty">nonempty</code></td>
<td>

<p>Logical. If <code>TRUE</code> (the default), a more efficient algorithm is
used, in which parents are generated conditionally on having at
least one offspring point. If <code>FALSE</code>, parents are generated
even if they have no offspring. Both choices are valid; the default
is recommended unless you need to simulate all the parent points
for some other purpose.
</p>
</td></tr>
<tr><td><code id="rVarGamma_+3A_thresh">thresh</code></td>
<td>

<p>Threshold relative to the cluster kernel value at the origin (parent
location) determining when the cluster kernel will be treated as
zero for simulation purposes. Will be overridden by argument
<code>expand</code> if that is given.
</p>
</td></tr>
<tr><td><code id="rVarGamma_+3A_poisthresh">poisthresh</code></td>
<td>

<p>Numerical threshold below which the model will be treated
as a Poisson process. See Details.
</p>
</td></tr>
<tr><td><code id="rVarGamma_+3A_expand">expand</code></td>
<td>

<p>Window expansion distance. A single number.
The distance by which the original window will be expanded
in order to generate parent points.
Has a sensible default, determined by calling
<code><a href="#topic+clusterradius">clusterradius</a></code>
with the numeric threshold value given
in <code>thresh</code>.
</p>
</td></tr>
<tr><td><code id="rVarGamma_+3A_saveparents">saveparents</code></td>
<td>

<p>Logical value indicating whether to save the locations of the
parent points as an attribute.
</p>
</td></tr>
<tr><td><code id="rVarGamma_+3A_savelambda">saveLambda</code></td>
<td>

<p>Logical. If <code>TRUE</code> then the random intensity corresponding to
the simulated parent points will also be calculated and saved,
and returns as an attribute of the point pattern.
</p>
</td></tr>
<tr><td><code id="rVarGamma_+3A_kappamax">kappamax</code></td>
<td>

<p>Optional. Numerical value which is an upper bound for the
values of <code>kappa</code>, when <code>kappa</code> is a pixel image or a
function.
</p>
</td></tr>
<tr><td><code id="rVarGamma_+3A_mumax">mumax</code></td>
<td>

<p>Optional. Numerical value which is an upper bound for the
values of <code>mu</code>, when <code>mu</code> is a pixel image or a
function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm generates a realisation of the Neyman-Scott process
with Variance Gamma (Bessel) cluster kernel, inside the window <code>win</code>.
</p>
<p>The process is constructed by first
generating a Poisson point process of &ldquo;parent&rdquo; points 
with intensity <code>kappa</code>. Then each parent point is
replaced by a random cluster of points, the number of points in each
cluster being random with a Poisson (<code>mu</code>) distribution,
and the points being placed independently and uniformly
according to a Variance Gamma kernel.
</p>
<p>Note that, for correct simulation of the model,
the parent points are not restricted to lie inside the 
window <code>win</code>;
the parent process is effectively the uniform Poisson process
on the infinite plane.
</p>
<p>The shape of the kernel is determined by the dimensionless
index <code>nu</code>. This is the parameter <code class="reqn">nu^\prime</code> (nu-prime)
<code class="reqn">\nu^\prime = \alpha/2-1</code> appearing in
equation (12) on page 126 of Jalilian et al (2013). 
</p>
<p>The scale of the kernel is determined by the argument <code>scale</code>,
which is the parameter
<code class="reqn">\eta</code> appearing in equations (12) and (13) of
Jalilian et al (2013). 
It is expressed in units of length (the same as the unit of length for 
the window <code>win</code>).
</p>
<p>The algorithm can also generate spatially inhomogeneous versions of
the cluster process:
</p>

<ul>
<li><p> The parent points can be spatially inhomogeneous.
If the argument <code>kappa</code> is a <code>function(x,y)</code>
or a pixel image (object of class <code>"im"</code>), then it is taken
as specifying the intensity function of an inhomogeneous Poisson
process that generates the parent points.
</p>
</li>
<li><p> The offspring points can be inhomogeneous. If the
argument <code>mu</code> is a <code>function(x,y)</code>
or a pixel image (object of class <code>"im"</code>), then it is
interpreted as the reference density for offspring points,
in the sense of Waagepetersen (2006).
</p>
</li></ul>

<p>If the pair correlation function of the model is very close
to that of a Poisson process, deviating by less than
<code>poisthresh</code>, then the model is approximately a Poisson process,
and will be simulated as a Poisson process with intensity
<code>kappa * mu</code>, using <code><a href="#topic+rpoispp">rpoispp</a></code>. 
This avoids computations that would otherwise require huge amounts
of memory.
</p>


<h3>Value</h3>

<p>A point pattern (an object of class <code>"ppp"</code>) if <code>nsim=1</code>,
or a list of point patterns if <code>nsim &gt; 1</code>.
</p>
<p>Additionally, some intermediate results of the simulation are returned
as attributes of this point pattern (see
<code><a href="#topic+rNeymanScott">rNeymanScott</a></code>). 
Furthermore, the simulated intensity
function is returned as an attribute <code>"Lambda"</code>, if
<code>saveLambda=TRUE</code>.
</p>


<h3>Simulation Algorithm</h3>

<p>Two simulation algorithms are implemented.
</p>

<ul>
<li><p> The <em>naive</em> algorithm generates the cluster process 
by directly following the description given above. First the window
<code>win</code> is expanded by a distance equal to <code>expand</code>.
Then the parent points are generated in the expanded window according to
a Poisson process with intensity <code>kappa</code>. Then each parent
point is replaced by a finite cluster of offspring points as
described above.
The naive algorithm is used if <code>algorithm="naive"</code> or if
<code>nonempty=FALSE</code>.
</p>
</li>
<li><p> The <em>BKBC</em> algorithm, proposed by Baddeley and Chang
(2023), is a modification of the algorithm of Brix and Kendall (2002). 
Parents are generated in the infinite plane, subject to the
condition that they have at least one offspring point inside the
window <code>win</code>.
The BKBC algorithm is used when <code>algorithm="BKBC"</code> (the default)
and <code>nonempty=TRUE</code> (the default).
</p>
</li></ul>

<p>The naive algorithm becomes very slow when <code>scale</code> is large,
while the BKBC algorithm is uniformly fast (Baddeley and Chang, 2023).
</p>
<p>If <code>saveparents=TRUE</code>, then the simulated point pattern will
have an attribute <code>"parents"</code> containing the coordinates of the
parent points, and an attribute <code>"parentid"</code> mapping each
offspring point to its parent.
</p>
<p>If <code>nonempty=TRUE</code> (the default), then parents are generated
subject to the condition that they have at least one offspring point 
in the window <code>win</code>. 
<code>nonempty=FALSE</code>, then parents without offspring will be included;
this option is not available in the <em>BKBC</em> algorithm.
</p>
<p>Note that if <code>kappa</code> is a pixel image, its domain must be larger
than the window <code>win</code>. This is because an offspring point inside
<code>win</code> could have its parent point lying outside <code>win</code>.
In order to allow this, the naive simulation algorithm
first expands the original window <code>win</code>
by a distance equal to <code>expand</code> and generates the Poisson process of
parent points on this larger window. If <code>kappa</code> is a pixel image,
its domain must contain this larger window.
</p>
<p>If the pair correlation function of the model is very close
to that of a Poisson process, with maximum deviation less than
<code>poisthresh</code>, then the model is approximately a Poisson process.
This is detected by the naive algorithm which then
simulates a Poisson process with intensity
<code>kappa * mu</code>, using <code><a href="#topic+rpoispp">rpoispp</a></code>. 
This avoids computations that would otherwise require huge amounts
of memory.
</p>


<h3>Fitting cluster models to data</h3>

<p>The Variance-Gamma cluster model with homogeneous parents
(i.e. where <code>kappa</code> is a single number)
where the offspring are either homogeneous or inhomogeneous (<code>mu</code>
is a single number, a function or pixel image)
can be fitted to point pattern data using <code><a href="spatstat.model.html#topic+kppm">kppm</a></code>,
or fitted to the inhomogeneous <code class="reqn">K</code> function
using <code><a href="spatstat.model.html#topic+vargamma.estK">vargamma.estK</a></code>
or <code><a href="spatstat.model.html#topic+vargamma.estpcf">vargamma.estpcf</a></code>.
</p>
<p>Currently <span class="pkg">spatstat</span> does not support fitting the
Variance-Gamma cluster process model
with inhomogeneous parents.
</p>
<p>A Variance-Gamma cluster process model fitted by <code><a href="spatstat.model.html#topic+kppm">kppm</a></code>
can be simulated automatically using <code><a href="spatstat.model.html#topic+simulate.kppm">simulate.kppm</a></code>
(which invokes <code>rVarGamma</code> to perform the simulation).
</p>


<h3>Warning</h3>

<p>The argument <code>nu</code> is the parameter <code class="reqn">\nu^\prime</code> (nu-prime)
<code class="reqn">\nu^\prime = \alpha/2-1</code> appearing in
equation (12) on page 126 of Jalilian et al (2013).
This is different from the parameter called <code class="reqn">\nu</code> appearing in
equation(14) on page 127 of  Jalilian et al (2013), defined
by <code class="reqn">\nu = \alpha-1</code>. This has been a frequent
source of confusion.
</p>


<h3>Author(s)</h3>

<p>Original algorithm by Abdollah Jalilian and Rasmus Waagepetersen.
Adapted for <span class="pkg">spatstat</span> by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
Brix-Kendall-Baddeley-Chang algorithm implemented by
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> and Ya-Mei Chang <a href="mailto:yamei628@gmail.com">yamei628@gmail.com</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. and Chang, Y.-M. (2023) Robust algorithms for simulating cluster point processes. <em>Journal of Statistical Computation and Simulation</em>. In Press. DOI <code>10.1080/00949655.2023.2166045</code>.
</p>
<p>Brix, A. and Kendall, W.S. (2002)
Simulation of cluster point processes without edge effects.
<em>Advances in Applied Probability</em> <b>34</b>, 267&ndash;280.
</p>
<p>Jalilian, A., Guan, Y. and Waagepetersen, R. (2013)
Decomposition of variance for spatial Cox processes.
<em>Scandinavian Journal of Statistics</em> <b>40</b>, 119-137.
</p>
<p>Waagepetersen, R. (2007)
An estimating function approach to inference for
inhomogeneous Neyman-Scott processes.
<em>Biometrics</em> <b>63</b>, 252&ndash;258.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpoispp">rpoispp</a></code>,    
<code><a href="#topic+rMatClust">rMatClust</a></code>,  
<code><a href="#topic+rThomas">rThomas</a></code>,    
<code><a href="#topic+rCauchy">rCauchy</a></code>,   
<code><a href="#topic+rNeymanScott">rNeymanScott</a></code>,  
<code><a href="#topic+rGaussPoisson">rGaussPoisson</a></code>.  
</p>
<p>For fitting the model, see
<code><a href="spatstat.model.html#topic+kppm">kppm</a></code>,  
<code><a href="spatstat.model.html#topic+clusterfit">clusterfit</a></code>,  
<code><a href="spatstat.model.html#topic+vargamma.estK">vargamma.estK</a></code>, 
<code><a href="spatstat.model.html#topic+vargamma.estpcf">vargamma.estpcf</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # homogeneous
 X &lt;- rVarGamma(kappa=5, scale=2, mu=5, nu=-1/4)
 # inhomogeneous
 ff &lt;- function(x,y){ exp(2 - 3 * abs(x)) }
 fmax &lt;- exp(2)
 Z &lt;- as.im(ff, W= owin())
 Y &lt;- rVarGamma(kappa=5, scale=2, mu=Z, nu=0)
 YY &lt;- rVarGamma(kappa=ff, scale=2, mu=3, nu=0, kappamax=fmax)
</code></pre>

<hr>
<h2 id='spatstat.random-internal'>Internal spatstat.random functions</h2><span id='topic+change.default.expand'></span><span id='topic+datagen.runifpointOnLines'></span><span id='topic+datagen.runifpoisppOnLines'></span><span id='topic+datagen.rpoisppOnLines'></span><span id='topic+default.clipwindow'></span><span id='topic+detect.par.format'></span><span id='topic+expandwinPerfect'></span><span id='topic+fakeNeyScot'></span><span id='topic+getRandomFieldsModelGen'></span><span id='topic+handle.rshift.args'></span><span id='topic+HermiteCoefs'></span><span id='topic+is.cadlag'></span><span id='topic+is.expandable'></span><span id='topic+is.expandable.rmhmodel'></span><span id='topic+kraever'></span><span id='topic+kraeverRandomFields'></span><span id='topic+MultiPair.checkmatrix'></span><span id='topic+optimalinflation'></span><span id='topic+print.rmhcontrol'></span><span id='topic+print.rmhexpand'></span><span id='topic+print.rmhmodel'></span><span id='topic+print.rmhstart'></span><span id='topic+print.rmhInfoList'></span><span id='topic+print.summary.rmhexpand'></span><span id='topic+RandomFieldsSafe'></span><span id='topic+reheat'></span><span id='topic+resolve.vargamma.shape'></span><span id='topic+retrieve.param'></span><span id='topic+rMaternInhibition'></span><span id='topic+rMatClustHom'></span><span id='topic+rThomasHom'></span><span id='topic+rCauchyHom'></span><span id='topic+rGRFcircembed'></span><span id='topic+rGRFgauss'></span><span id='topic+rGRFexpo'></span><span id='topic+rGRFstable'></span><span id='topic+rGRFgencauchy'></span><span id='topic+rGRFmatern'></span><span id='topic+rPoissonClusterEngine'></span><span id='topic+RmhExpandRule'></span><span id='topic+rmhsnoop'></span><span id='topic+rmhResolveControl'></span><span id='topic+rmhResolveExpansion'></span><span id='topic+rmhResolveTypes'></span><span id='topic+rmhSnoopEnv'></span><span id='topic+rmhcontrol.rmhcontrol'></span><span id='topic+rmhcontrol.list'></span><span id='topic+rmhEngine'></span><span id='topic+rmhmodel.rmhmodel'></span><span id='topic+rmhstart.rmhstart'></span><span id='topic+rmhstart.list'></span><span id='topic+rmpoint.I.allim'></span><span id='topic+rpoint.multi'></span><span id='topic+rthinEngine'></span><span id='topic+runifpoispp'></span><span id='topic+runifpoisppOnLines'></span><span id='topic+spatstatClusterModelInfo'></span><span id='topic+spatstatClusterSimInfo'></span><span id='topic+spatstatClusterSimModelMatch'></span><span id='topic+spatstatRmhInfo'></span><span id='topic+summarise.trend'></span><span id='topic+summary.rmhexpand'></span><span id='topic+thinjump'></span><span id='topic+thinParents'></span><span id='topic+update.rmhstart'></span><span id='topic+validate.kappa.mu'></span>

<h3>Description</h3>

<p>Internal spatstat.random functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>


change.default.expand(x, newdefault)
datagen.runifpointOnLines(n, L)
datagen.runifpoisppOnLines(lambda, L)
datagen.rpoisppOnLines(lambda, L, lmax, ..., check)
default.clipwindow(object, epsilon)
expandwinPerfect(W, expand, amount)
detect.par.format(par, native, generic)
fakeNeyScot(Y, lambda, win, saveLambda, saveparents)
getRandomFieldsModelGen(model)
handle.rshift.args(W, ..., radius, width, height,
                   edge, clip, edgedefault)
HermiteCoefs(order)
is.cadlag(s)
is.expandable(x)
## S3 method for class 'rmhmodel'
is.expandable(x) 
kraever(package, fatal)
kraeverRandomFields()
MultiPair.checkmatrix(mat, n, matname, naok, zerook, asymmok)
optimalinflation(clusters, mod, rD)
## S3 method for class 'rmhcontrol'
print(x, ...)
## S3 method for class 'rmhexpand'
print(x, ..., prefix=TRUE)
## S3 method for class 'rmhmodel'
print(x, ...)
## S3 method for class 'rmhstart'
print(x, ...)
## S3 method for class 'rmhInfoList'
print(x, ...)
## S3 method for class 'summary.rmhexpand'
print(x, ...)
RandomFieldsSafe()
reheat(model, invtemp)
resolve.vargamma.shape(..., nu.ker, nu.pcf, nu, allow.nu, allow.default)
retrieve.param(desired, aliases, ..., par)
rMaternInhibition(type, kappa, r, win, stationary, ..., nsim, drop)
rMatClustHom(kappa, mu, R, W, ..., nsim, drop, inflate, saveparents)
rThomasHom(kappa, mu, sigma, W, ...,
           nsim, drop, inflate, saveparents, maxinflate)
rCauchyHom(kappa, mu, scale, W, ...,
           nsim, drop, inflate, saveparents, maxinflate)
rGRFcircembed(W, mu, var, corrfun, ..., nsim, drop)
rGRFgauss(W, mu, var, scale, ..., nsim, drop)
rGRFexpo(W, mu, var, scale, ..., nsim, drop)
rGRFstable(W, mu, var, scale, alpha, ..., nsim, drop)
rGRFgencauchy(W, mu, var, scale, alpha, beta, ..., nsim, drop)
rGRFmatern(W, mu, var, scale, nu, ..., nsim, drop)
rPoissonClusterEngine(kappa, expand, rcluster, win, ...,
                      nsim, drop, saveparents, kappamax, lmax, rmax) 
RmhExpandRule(nama)
## S3 method for class 'rmhcontrol'
rmhcontrol(...) 
## S3 method for class 'list'
rmhcontrol(...) 
rmhEngine(InfoList, ..., verbose, kitchensink, preponly, snoop,
                           overrideXstart, overrideclip) 
rmhResolveControl(control, model)
rmhResolveExpansion(win, control, imagelist, itype)
rmhResolveTypes(model, start, control)
rmhsnoop(..., Wsim, Wclip, R, xcoords, ycoords, mlevels, mcodes, irep, itype, 
     proptype, proplocn, propmark, propindx, numerator, denominator,
     panel.only)
rmhSnoopEnv(Xinit, Wclip, R)
## S3 method for class 'rmhmodel'
rmhmodel(model, ...) 
## S3 method for class 'rmhstart'
rmhstart(start, ...) 
## S3 method for class 'list'
rmhstart(start, ...) 
rmpoint.I.allim(n, f, types, nsim)
rpoint.multi(n, f, fmax, marks, win, giveup, verbose, warn, nsim, drop)
rthinEngine(X, P, ..., nsim, drop, Pmax, na.zero, what, fatal, warn)
runifpoispp(lambda, win, ..., nsim, drop)
runifpoisppOnLines(lambda, L, nsim, drop)
spatstatClusterModelInfo(name, onlyPCP)
spatstatClusterSimInfo(name)
spatstatClusterSimModelMatch(name, verbose)
spatstatRmhInfo(cifname)
summarise.trend(trend, w, a)
## S3 method for class 'rmhexpand'
summary(object, ...)
thinjump(n, p)
thinParents(X, P, Pmax)
## S3 method for class 'rmhstart'
update(object, ...)
validate.kappa.mu(kappa, mu, kappamax, mumax,
                  win, expand, ..., context)


</code></pre>


<h3>Details</h3>

<p>These internal <span class="pkg">spatstat.random</span> functions should not be called
directly by the user. Their names and capabilities may change
without warning from one version of <span class="pkg">spatstat.random</span> to the next.
</p>


<h3>Value</h3>

<p>The return values of these functions are not documented,
and may change without warning.
</p>

<hr>
<h2 id='spatstat.random-package'>The spatstat.random Package</h2><span id='topic+spatstat.random-package'></span><span id='topic+spatstat.random'></span>

<h3>Description</h3>

<p>The <span class="pkg">spatstat.random</span> package
belongs to the <span class="pkg">spatstat</span> family of packages.
It contains the functionality for generating random spatial patterns
and simulation of random point processes.
</p>


<h3>Details</h3>

<p><span class="pkg">spatstat</span> is a family of <span class="rlang"><b>R</b></span> packages
for the statistical analysis of spatial data.
Its main focus is the analysis of
spatial patterns of points in two-dimensional space.
</p>
<p>This sub-package <span class="pkg">spatstat.random</span> contains the
functions that perform random generation of spatial patterns
and simulation of random point processes:
</p>

<ul>
<li>
<p>generation of random spatial patterns of points
according to many simple rules
(completely random patterns, random grids, systematic random
points);
</p>
</li>
<li>
<p>randomised alteration of spatial patterns (thinning, random shifting,
jittering, random labelling);
</p>
</li>
<li>
<p>generation of quasirandom patterns;
</p>
</li>
<li>
<p>direct simulation of random point processes
(Poisson process, binomial process, cell process,
simple sequential inhibition, Matern inhibition models,
log-Gaussian Cox processes;
</p>
</li>
<li>
<p>simulation of Neyman-Scott cluster processes
(truncated direct algorithm, Brix-Kendall and hybrid algorithms)
and product shot noise cluster processes;
</p>
</li>
<li>
<p>simulation of Gibbs point processes
(Metropolis-Hastings birth-death-shift algorithm,
perfect simulation/ dominated coupling from the past,
alternating Gibbs sampler).
</p>
</li></ul>

<p>Some other types of spatial object are also supported:
</p>

<ul>
<li>
<p>generation of random patterns of points in 3 dimensions;
</p>
</li>
<li>
<p>generation of random spatial patterns of line segments;
</p>
</li>
<li>
<p>generation of random tessellations;
</p>
</li>
<li>
<p>generation of random images (random noise, random mosaics).
</p>
</li></ul>

<p>(Functions for linear networks
are in the separate sub-package <span class="pkg">spatstat.linnet</span>.)
</p>


<h3>Structure of the spatstat family</h3>

  
<p>The <span class="pkg">spatstat</span> family of packages
is designed to support a complete statistical analysis
of spatial data. It supports
</p>

<ul>
<li><p> creation, manipulation and plotting of point patterns;
</p>
</li>
<li><p> exploratory data analysis;
</p>
</li>
<li><p> spatial random sampling;
</p>
</li>
<li><p> simulation of point process models;
</p>
</li>
<li><p> parametric model-fitting;
</p>
</li>
<li><p> non-parametric smoothing and regression;
</p>
</li>
<li><p> formal inference (hypothesis tests, confidence intervals);
</p>
</li>
<li><p> model diagnostics.
</p>
</li></ul>

<p>The orginal <span class="pkg">spatstat</span> package grew to be very large.
It has now been divided into several <b>sub-packages</b>:
</p>

<ul>
<li> <p><span class="pkg">spatstat.utils</span> containing basic utilities
</p>
</li>
<li> <p><span class="pkg">spatstat.sparse</span> containing linear algebra utilities
</p>
</li>
<li> <p><span class="pkg">spatstat.data</span> containing datasets
</p>
</li>
<li> <p><span class="pkg">spatstat.geom</span> containing geometrical objects
and geometrical operations
</p>
</li>
<li> <p><span class="pkg">spatstat.random</span> containing functionality for
simulation and random generation
</p>
</li>
<li> <p><span class="pkg">spatstat.explore</span> containing the main functionality
for exploratory data analysis and nonparametric analysis
</p>
</li>
<li> <p><span class="pkg">spatstat.model</span> containing the main functionality
for parametric modelling and formal inference for spatial data
</p>
</li>
<li> <p><span class="pkg">spatstat.linnet</span> containing functions for
spatial data on a linear network
</p>
</li>
<li> <p><span class="pkg">spatstat</span>, which simply loads the other sub-packages
listed above, and provides documentation.
</p>
</li></ul>

<p>When you install <span class="pkg">spatstat</span>, these sub-packages are also
installed. Then if you load the <span class="pkg">spatstat</span> package by typing
<code>library(spatstat)</code>, the other sub-packages listed above will
automatically be loaded or imported.
</p>
<p>For an overview of all the functions available in
the sub-packages of <span class="pkg">spatstat</span>,
see the help file for <code>"spatstat-package"</code>
in the <span class="pkg">spatstat</span> package.
</p>
<p>Additionally there are several <b>extension packages:</b>
</p>

<ul>
<li> <p><span class="pkg">spatstat.gui</span> for interactive graphics
</p>
</li>
<li> <p><span class="pkg">spatstat.local</span> for local likelihood
(including geographically weighted regression)
</p>
</li>
<li> <p><span class="pkg">spatstat.Knet</span> for additional, computationally efficient code
for linear networks
</p>
</li>
<li> <p><span class="pkg">spatstat.sphere</span> (under development) for spatial data
on a sphere, including spatial data on the earth's surface
</p>
</li></ul>

<p>The extension packages must be installed separately
and loaded explicitly if needed. They also have separate documentation.
</p>


<h3>Functionality in <span class="pkg">spatstat.random</span></h3>

<p>Following is a list of the functionality provided in the
<span class="pkg">spatstat.random</span> package only.
</p>
<p><b>To simulate a random point pattern:</b>
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+runifpoint">runifpoint</a></code> </td><td style="text-align: left;">
	generate <code class="reqn">n</code> independent uniform random points </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rpoint">rpoint</a></code> </td><td style="text-align: left;">
	generate <code class="reqn">n</code> independent random points </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rmpoint">rmpoint</a></code> </td><td style="text-align: left;">
	generate <code class="reqn">n</code> independent multitype random points </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rpoispp">rpoispp</a></code> </td><td style="text-align: left;">
	simulate the (in)homogeneous Poisson point process </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rmpoispp">rmpoispp</a></code> </td><td style="text-align: left;">
	simulate the (in)homogeneous multitype Poisson point process </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+runifdisc">runifdisc</a></code> </td><td style="text-align: left;">
	generate <code class="reqn">n</code> independent uniform random points in disc</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rstrat">rstrat</a></code> </td><td style="text-align: left;">
	stratified random sample of points </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rMaternI">rMaternI</a></code>  </td><td style="text-align: left;">
	simulate the Matern Model I inhibition process</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rMaternII">rMaternII</a></code> </td><td style="text-align: left;">
	simulate the Matern Model II inhibition process</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rSSI">rSSI</a></code> </td><td style="text-align: left;">
	simulate Simple Sequential Inhibition process</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rStrauss">rStrauss</a></code> </td><td style="text-align: left;">
	simulate Strauss process (perfect simulation)</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rHardcore">rHardcore</a></code> </td><td style="text-align: left;">
	simulate Hard Core process (perfect simulation)</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rStraussHard">rStraussHard</a></code> </td><td style="text-align: left;">
	simulate Strauss-hard core process (perfect simulation)</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rDiggleGratton">rDiggleGratton</a></code> </td><td style="text-align: left;">
	simulate Diggle-Gratton process (perfect simulation)</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rDGS">rDGS</a></code> </td><td style="text-align: left;">
	simulate Diggle-Gates-Stibbard process (perfect simulation)</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rPenttinen">rPenttinen</a></code> </td><td style="text-align: left;">
	simulate Penttinen process (perfect simulation)</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rNeymanScott">rNeymanScott</a></code> </td><td style="text-align: left;">
	simulate a general Neyman-Scott process</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rPoissonCluster">rPoissonCluster</a></code> </td><td style="text-align: left;">
	simulate a general Poisson cluster process</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rMatClust">rMatClust</a></code> </td><td style="text-align: left;">
	simulate the Matern Cluster process</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rThomas">rThomas</a></code> </td><td style="text-align: left;">
	simulate the Thomas process  </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rGaussPoisson">rGaussPoisson</a></code>  </td><td style="text-align: left;">
	simulate the Gauss-Poisson cluster process</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rCauchy">rCauchy</a></code> </td><td style="text-align: left;">
	simulate Neyman-Scott Cauchy cluster process </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rVarGamma">rVarGamma</a></code> </td><td style="text-align: left;">
	simulate Neyman-Scott Variance Gamma cluster process </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rthin">rthin</a></code> </td><td style="text-align: left;">  random thinning  </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rcell">rcell</a></code> </td><td style="text-align: left;">
	simulate the Baddeley-Silverman cell process  </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rmh">rmh</a></code> </td><td style="text-align: left;">
	simulate Gibbs point process using Metropolis-Hastings </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+runifpointOnLines">runifpointOnLines</a></code> </td><td style="text-align: left;">
	generate <code class="reqn">n</code> random points along specified line segments </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rpoisppOnLines">rpoisppOnLines</a></code> </td><td style="text-align: left;">
	generate Poisson random points along specified line segments 
      </td>
</tr>

</table>

<p><b>To randomly change an existing point pattern:</b>
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rshift">rshift</a></code> </td><td style="text-align: left;"> random shifting of points </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rthin">rthin</a></code> </td><td style="text-align: left;">  random thinning </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rlabel">rlabel</a></code> </td><td style="text-align: left;"> random (re)labelling of a multitype
	point pattern </td>
</tr>
<tr>
 <td style="text-align: left;">
        <code><a href="#topic+quadratresample">quadratresample</a></code> </td><td style="text-align: left;"> block resampling 
      </td>
</tr>

</table>

<p>See also <code><a href="spatstat.geom.html#topic+rjitter">rjitter</a></code> and <code><a href="spatstat.geom.html#topic+rexplode">rexplode</a></code> in the
<span class="pkg">spatstat.geom</span> package.
</p>
<p><b>Random pixel images:</b>
</p>
<p>An object of class <code>"im"</code> represents a pixel image.
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+rnoise">rnoise</a></code> </td><td style="text-align: left;"> random pixel noise
     </td>
</tr>

</table>

<p><b>Line segment patterns</b>
</p>
<p>An object of class <code>"psp"</code> represents a pattern of straight line
segments.
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+rpoisline">rpoisline</a></code> </td><td style="text-align: left;"> generate a realisation of the
      Poisson line process inside a window
    </td>
</tr>

</table>

<p><b>Tessellations</b>
</p>
<p>An object of class <code>"tess"</code> represents a tessellation.
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+rpoislinetess">rpoislinetess</a></code> </td><td style="text-align: left;"> generate tessellation using Poisson line
      process 
    </td>
</tr>

</table>

<p><b>Three-dimensional point patterns</b>
</p>
<p>An object of class <code>"pp3"</code> represents a three-dimensional
point pattern in a rectangular box. The box is represented by
an object of class <code>"box3"</code>.
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+runifpoint3">runifpoint3</a></code> </td><td style="text-align: left;"> generate uniform random points in 3-D </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+rpoispp3">rpoispp3</a></code> </td><td style="text-align: left;"> generate Poisson random points in 3-D </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

<p><b>Multi-dimensional space-time point patterns</b>
</p>
<p>An object of class <code>"ppx"</code> represents a 
point pattern in multi-dimensional space and/or time.
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+runifpointx">runifpointx</a></code> </td><td style="text-align: left;"> generate uniform random points </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+rpoisppx">rpoisppx</a></code> </td><td style="text-align: left;"> generate Poisson random points 
    </td>
</tr>

</table>

<p><b>Probability Distributions</b>
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+rknn">rknn</a></code> </td><td style="text-align: left;"> theoretical distribution of
      nearest neighbour distance </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+dmixpois">dmixpois</a></code> </td><td style="text-align: left;"> mixed Poisson distribution </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td>
</tr>

</table>

<p><b>Simulation</b>
</p>
<p>There are many ways to generate a random point pattern,
line segment pattern, pixel image or tessellation
in <span class="pkg">spatstat</span>. 
</p>
<p><b>Random point patterns:</b>
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+runifpoint">runifpoint</a></code> </td><td style="text-align: left;">
    generate <code class="reqn">n</code> independent uniform random points </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rpoint">rpoint</a></code> </td><td style="text-align: left;">
    generate <code class="reqn">n</code> independent random points </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rmpoint">rmpoint</a></code> </td><td style="text-align: left;">
    generate <code class="reqn">n</code> independent multitype random points </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rpoispp">rpoispp</a></code> </td><td style="text-align: left;">
    simulate the (in)homogeneous Poisson point process </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rmpoispp">rmpoispp</a></code> </td><td style="text-align: left;">
    simulate the (in)homogeneous multitype Poisson point process </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+runifdisc">runifdisc</a></code> </td><td style="text-align: left;">
    generate <code class="reqn">n</code> independent uniform random points in disc</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rstrat">rstrat</a></code> </td><td style="text-align: left;">
    stratified random sample of points </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rMaternI">rMaternI</a></code>  </td><td style="text-align: left;">
    simulate the Matern Model I inhibition process</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rMaternII">rMaternII</a></code> </td><td style="text-align: left;">
    simulate the Matern Model II inhibition process</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rSSI">rSSI</a></code> </td><td style="text-align: left;">
    simulate Simple Sequential Inhibition process</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rHardcore">rHardcore</a></code> </td><td style="text-align: left;">
    simulate hard core process (perfect simulation)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rStrauss">rStrauss</a></code> </td><td style="text-align: left;">
    simulate Strauss process (perfect simulation)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rStraussHard">rStraussHard</a></code> </td><td style="text-align: left;">
    simulate Strauss-hard core process (perfect simulation)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rDiggleGratton">rDiggleGratton</a></code> </td><td style="text-align: left;">
    simulate Diggle-Gratton process (perfect simulation)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rDGS">rDGS</a></code> </td><td style="text-align: left;">
    simulate Diggle-Gates-Stibbard process (perfect simulation)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rPenttinen">rPenttinen</a></code> </td><td style="text-align: left;">
    simulate Penttinen process (perfect simulation)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rNeymanScott">rNeymanScott</a></code> </td><td style="text-align: left;">
    simulate a general Neyman-Scott process</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rMatClust">rMatClust</a></code> </td><td style="text-align: left;">
    simulate the Matern Cluster process</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rThomas">rThomas</a></code> </td><td style="text-align: left;">
    simulate the Thomas process  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rLGCP">rLGCP</a></code> </td><td style="text-align: left;">
    simulate the log-Gaussian Cox process  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rGaussPoisson">rGaussPoisson</a></code>  </td><td style="text-align: left;">
    simulate the Gauss-Poisson cluster process</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rCauchy">rCauchy</a></code> </td><td style="text-align: left;">
    simulate Neyman-Scott process with Cauchy clusters </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rVarGamma">rVarGamma</a></code> </td><td style="text-align: left;">
    simulate Neyman-Scott process with Variance Gamma clusters </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rcell">rcell</a></code> </td><td style="text-align: left;">
    simulate the Baddeley-Silverman cell process  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+runifpointOnLines">runifpointOnLines</a></code> </td><td style="text-align: left;">
    generate <code class="reqn">n</code> random points along specified line segments </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rpoisppOnLines">rpoisppOnLines</a></code> </td><td style="text-align: left;">
    generate Poisson random points along specified line segments 
  </td>
</tr>

</table>

<p><b>Resampling a point pattern:</b>
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+quadratresample">quadratresample</a></code> </td><td style="text-align: left;"> block resampling </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rshift">rshift</a></code> </td><td style="text-align: left;"> random shifting of (subsets of) points</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rthin">rthin</a></code> </td><td style="text-align: left;">  random thinning 
  </td>
</tr>

</table>

<p><b>Other random patterns:</b>
</p>

<table>
<tr>
 <td style="text-align: left;">
     <code><a href="#topic+rpoisline">rpoisline</a></code> </td><td style="text-align: left;">
     simulate the Poisson line process within a window </td>
</tr>
<tr>
 <td style="text-align: left;">
     <code><a href="#topic+rpoislinetess">rpoislinetess</a></code> </td><td style="text-align: left;">
     generate random tessellation using Poisson line process </td>
</tr>
<tr>
 <td style="text-align: left;">
     <code><a href="#topic+rMosaicSet">rMosaicSet</a></code> </td><td style="text-align: left;">
     generate random set by selecting some tiles of a tessellation </td>
</tr>
<tr>
 <td style="text-align: left;">
     <code><a href="#topic+rMosaicField">rMosaicField</a></code> </td><td style="text-align: left;">
     generate random pixel image by assigning random values
     in each tile of a tessellation
   </td>
</tr>

</table>

<p><b>Resampling and randomisation procedures</b>
</p>
<p>You can build your own tests based on randomisation
and resampling using the following capabilities:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+quadratresample">quadratresample</a></code> </td><td style="text-align: left;"> block resampling </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rshift">rshift</a></code> </td><td style="text-align: left;"> random shifting of (subsets of) points</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rthin">rthin</a></code> </td><td style="text-align: left;">  random thinning  
  </td>
</tr>

</table>



<h3>Licence</h3>

<p>This library and its documentation are usable under the terms of the &quot;GNU 
General Public License&quot;, a copy of which is distributed with the package.
</p>


<h3>Acknowledgements</h3>

<p>Kasper Klitgaard Berthelsen,
Ya-Mei Chang,
Tilman Davies,
Ute Hahn,
Abdollah Jalilian,
Dominic Schuhmacher
and
Rasmus Waagepetersen
made substantial contributions of code.
</p>
<p>For comments, corrections, bug alerts and suggestions, we thank
Monsuru Adepeju,
Corey Anderson,
Ang Qi Wei,
Ryan Arellano,
Jens Astrom,
Robert Aue,
Marcel Austenfeld,
Sandro Azaele,
Malissa Baddeley,
Guy Bayegnak,
Colin Beale,
Melanie Bell,
Thomas Bendtsen,
Ricardo Bernhardt,
Andrew Bevan,
Brad Biggerstaff,
Anders Bilgrau,
Leanne Bischof,
Christophe Biscio,
Roger Bivand,
Jose M. Blanco Moreno,
Florent Bonneu,
Jordan Brown,
Ian Buller,
Julian Burgos,
Simon Byers,
Ya-Mei Chang,
Jianbao Chen,
Igor Chernayavsky,
Y.C. Chin,
Bjarke Christensen,
Lucia Cobo Sanchez,
Jean-Francois Coeurjolly,
Kim Colyvas,
Hadrien Commenges,
Rochelle Constantine,
Robin Corria Ainslie,
Richard Cotton,
Marcelino de la Cruz,
Peter Dalgaard,
Mario D'Antuono,
Sourav Das,
Peter Diggle,
Patrick Donnelly,
Ian Dryden,
Stephen Eglen,
Ahmed El-Gabbas,
Belarmain Fandohan,
Olivier Flores,
David Ford,
Peter Forbes,
Shane Frank,
Janet Franklin,
Funwi-Gabga Neba,
Oscar Garcia,
Agnes Gault,
Jonas Geldmann,
Marc Genton,
Shaaban Ghalandarayeshi,
Jason Goldstick,
Pavel Grabarnik,
C. Graf,
Ute Hahn,
Andrew Hardegen,
Martin Bogsted Hansen,
Martin Hazelton,
Juha Heikkinen,
Mandy Hering,
Markus Herrmann,
Maximilian Hesselbarth,
Paul Hewson,
Hamidreza Heydarian,
Kurt Hornik,
Philipp Hunziker,
Jack Hywood,
Ross Ihaka,
Cenk Icos,
Aruna Jammalamadaka,
Robert John-Chandran,
Devin Johnson,
Mahdieh Khanmohammadi,
Bob Klaver,
Lily Kozmian-Ledward,
Peter Kovesi,
Mike Kuhn,
Jeff Laake,
Robert Lamb,
Frederic Lavancier,
Tom Lawrence,
Tomas Lazauskas,
Jonathan Lee,
George Leser,
Angela Li,
Li Haitao,
George Limitsios,
Andrew Lister,
Nestor Luambua,
Ben Madin,
Martin Maechler,
Kiran Marchikanti,
Jeff Marcus,
Robert Mark,
Peter McCullagh,
Monia Mahling,
Jorge Mateu Mahiques,
Ulf Mehlig,
Frederico Mestre,
Sebastian Wastl Meyer,
Mi Xiangcheng,
Lore De Middeleer,
Robin Milne,
Enrique Miranda,
Jesper Moller,
Annie Mollie,
Ines Moncada,
Mehdi Moradi,
Virginia Morera Pujol,
Erika Mudrak,
Gopalan Nair,
Nader Najari,
Nicoletta Nava,
Linda Stougaard Nielsen,
Felipe Nunes,
Jens Randel Nyengaard,
Jens Oehlschlaegel,
Thierry Onkelinx,
Sean O'Riordan,
Evgeni Parilov,
Jeff Picka,
Nicolas Picard,
Tim Pollington,
Mike Porter,
Sergiy Protsiv,
Adrian Raftery,
Ben Ramage,
Pablo Ramon,
Xavier Raynaud,
Nicholas Read,
Matt Reiter,
Ian Renner,
Tom Richardson,
Brian Ripley,
Ted Rosenbaum,
Barry Rowlingson,
Jason Rudokas,
Tyler Rudolph,
John Rudge,
Christopher Ryan,
Farzaneh Safavimanesh,
Aila Sarkka,
Cody Schank,
Katja Schladitz,
Sebastian Schutte,
Bryan Scott,
Olivia Semboli,
Francois Semecurbe,
Vadim Shcherbakov,
Shen Guochun,
Shi Peijian,
Harold-Jeffrey Ship,
Tammy L Silva,
Ida-Maria Sintorn,
Yong Song, 
Malte Spiess,
Mark Stevenson,
Kaspar Stucki,
Jan Sulavik,
Michael Sumner,
P. Surovy,
Ben Taylor,
Thordis Linda Thorarinsdottir,
Leigh Torres,
Berwin Turlach,
Torben Tvedebrink,
Kevin Ummer,
Medha Uppala,
Andrew van Burgel,
Tobias Verbeke,
Mikko Vihtakari,
Alexendre Villers,
Fabrice Vinatier,
Maximilian Vogtland,
Sasha Voss,
Sven Wagner,
Hao Wang,
H. Wendrock,
Jan Wild,
Carl G. Witthoft,
Selene Wong,
Maxime Woringer,
Luke Yates,
Mike Zamboni
and
Achim Zeileis.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>

<hr>
<h2 id='update.rmhcontrol'>Update Control Parameters of Metropolis-Hastings Algorithm</h2><span id='topic+update.rmhcontrol'></span>

<h3>Description</h3>

<p><code>update</code> method for class <code>"rmhcontrol"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'rmhcontrol'
update(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.rmhcontrol_+3A_object">object</code></td>
<td>

<p>Object of class <code>"rmhcontrol"</code> containing control parameters
for a Metropolis-Hastings algorithm.
</p>
</td></tr>
<tr><td><code id="update.rmhcontrol_+3A_...">...</code></td>
<td>

<p>Arguments to be updated in the new call to <code><a href="#topic+rmhcontrol">rmhcontrol</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="stats.html#topic+update">update</a></code>
for the class <code>"rmhcontrol"</code>. An object of class <code>"rmhcontrol"</code>
describes a set of control parameters for the Metropolis-Hastings
simulation algorithm. See <code><a href="#topic+rmhcontrol">rmhcontrol</a></code>).
</p>
<p><code>update.rmhcontrol</code> will modify the parameters
specified by <code>object</code> according to the new arguments given.
</p>


<h3>Value</h3>

<p>Another object of class <code>"rmhcontrol"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  a &lt;- rmhcontrol(expand=1)
  update(a, expand=2)
</code></pre>

<hr>
<h2 id='will.expand'>
Test Expansion Rule
</h2><span id='topic+will.expand'></span>

<h3>Description</h3>

<p>Determines whether an expansion rule will
actually expand the window or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>will.expand(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="will.expand_+3A_x">x</code></td>
<td>

<p>Expansion rule.
An object of class <code>"rmhexpand"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"rmhexpand"</code> describes a rule for
expanding a simulation window. See <code><a href="#topic+rmhexpand">rmhexpand</a></code>
for details.
</p>
<p>One possible expansion rule is to do nothing, i.e. not to expand
the window.
</p>
<p>This command inspects the expansion rule <code>x</code>
and determines whether it will or will not actually expand the window.
It returns <code>TRUE</code> if the window will be expanded.
</p>


<h3>Value</h3>

<p>Logical value.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmhexpand">rmhexpand</a></code>,
<code><a href="#topic+expand.owin">expand.owin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- rmhexpand(distance=0.2)
  y &lt;- rmhexpand(area=1)
  will.expand(x)
  will.expand(y)
</code></pre>

<hr>
<h2 id='Window.rmhmodel'>Extract Window of Spatial Object</h2><span id='topic+Window.rmhmodel'></span>

<h3>Description</h3>

<p>Given a spatial object (such as a point pattern or pixel image)
in two dimensions, these functions extract the window
in which the object is defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>

 ## S3 method for class 'rmhmodel'
Window(X, ...)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Window.rmhmodel_+3A_x">X</code></td>
<td>
<p>A spatial object.</p>
</td></tr>
<tr><td><code id="Window.rmhmodel_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the generic function <code>Window</code>
which extract the spatial window in which the object <code>X</code>
is defined. 
</p>


<h3>Value</h3>

<p>An object of class <code>"owin"</code> (see <code>owin.object</code>)
specifying an observation window.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code>Window</code>,
<code>Window.ppp</code>,
<code>Window.psp</code>.
</p>
<p><code>owin.object</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   A &lt;- rmhmodel(cif='poisson', par=list(beta=10), w=square(2))
   Window(A)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
