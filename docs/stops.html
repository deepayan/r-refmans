<!DOCTYPE html><html><head><title>Help for package stops</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stops}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#stops-package'><p>stops: Structure Optimized Proximity Scaling</p></a></li>
<li><a href='#BankingCrisesDistances'><p>Banking Crises Distances</p></a></li>
<li><a href='#bootmds.stops'><p>MDS Bootstrap for stops objects</p></a></li>
<li><a href='#c_association'><p>c-association</p>
calculates the c-association based on the maximal information coefficient
We define c-association as the aggregated association between any two columns in confs</a></li>
<li><a href='#c_clumpiness'><p>c-clumpiness</p></a></li>
<li><a href='#c_clusteredness'><p>c-clusteredness</p>
calculates c-clusteredness as the OPTICS cordillera. The higher the more clustered.</a></li>
<li><a href='#c_complexity'><p>c-complexity</p>
Calculates the c-complexity based on the minimum cell number
We define c-complexity as the aggregated minimum cell number between any two columns in confs
This is one of few c-structuredness indices not between 0 and 1, but can be between 0 and (theoretically) infinity</a></li>
<li><a href='#c_convexity'><p>c-convexity</p></a></li>
<li><a href='#c_dependence'><p>c-dependence</p>
calculates c-dependence as the aggregated distance correlation of each pair if nonidentical columns</a></li>
<li><a href='#c_faithfulness'><p>c-faithfulness</p>
calculates the c-faithfulness based on the index by Chen and Buja 2013 (M_adj) with equal input neigbourhoods</a></li>
<li><a href='#c_functionality'><p>c-functionality</p>
calculates the c-functionality based on the maximum edge value
We define c-functionality as the aggregated functionality between any two columns of confs</a></li>
<li><a href='#c_hierarchy'><p>c-hierarchy</p>
captures how well a partition/ultrametric (obtained by hclust) explains the configuration distances. Uses variance explained for euclidean distances and deviance explained for everything else.</a></li>
<li><a href='#c_inequality'><p>c-inequality</p>
Calculates c-inequality (as in an economic measure of inequality) as Pearsons coefficient of variation of the fitted distance matrix. This can help with avoiding degenerate solutions.
This is one of few c-structuredness indices not between 0 and 1, but 0 and infinity.</a></li>
<li><a href='#c_linearity'><p>c-linearity</p>
calculates c-linearity as the aggregated multiple correlation of all columns of the configuration.</a></li>
<li><a href='#c_manifoldness'><p>c-manifoldness</p>
calculates c-manifoldness as the aggregated maximal correlation coefficient (i.e., Pearson correlation of the ACE transformed variables) of all pairwise combinations of two different columns in confs. If there is an NA (happens usually when the optimal transformation of any variable is a constant and therefore the covariance is 0 but also one of the sds in the denominator), it gets skipped.</a></li>
<li><a href='#c_mine'><p>wrapper for getting the mine coefficients</p></a></li>
<li><a href='#c_nonmonotonicity'><p>c-nonmonotonicity</p>
calculates the c-nonmonotonicity based on the maximum asymmetric score
We define c-nonmonotonicity as the aggregated nonmonotonicity between any two columns in confs
this is one of few c-structuredness indices not between 0 and 1</a></li>
<li><a href='#c_outlying'><p>c-outlying</p></a></li>
<li><a href='#c_regularity'><p>c-regularity</p>
calculates c-regularity as 1 - OPTICS cordillera for k=2. The higher the more regular.</a></li>
<li><a href='#c_shepardness'><p>c-shepardness</p>
calculates the c-shepardness as the correlation between a loess smoother of the transformed distances and the transformed dissimilarities</a></li>
<li><a href='#c_skinniness'><p>c-skinniness</p></a></li>
<li><a href='#c_sparsity'><p>c-sparsity</p></a></li>
<li><a href='#c_striatedness'><p>c-striatedness</p></a></li>
<li><a href='#c_stringiness'><p>c-stringiness</p></a></li>
<li><a href='#coef.stops'><p>S3 coef method for stops objects</p></a></li>
<li><a href='#jackmds.stops'><p>MDS Jackknife for stops objects</p></a></li>
<li><a href='#knn_dist'><p>calculate k nearest neighbours from a distance matrix</p></a></li>
<li><a href='#ljoptim'><p>(Adaptive) Version of Luus-Jaakola Optimization</p></a></li>
<li><a href='#Pendigits500'><p>Pen digits</p></a></li>
<li><a href='#plot.stops'><p>S3 plot method for stops objects</p></a></li>
<li><a href='#print.stops'><p>S3 print method for stops objects</p></a></li>
<li><a href='#print.summary.stops'><p>S3 print method for summary.stops</p></a></li>
<li><a href='#residuals.stops'><p>S3 residuals method for stops</p></a></li>
<li><a href='#stop_apstress'><p>STOPS version of approximated power stress models.</p></a></li>
<li><a href='#stop_bcmds'><p>STOPS version of Box Cox Stress</p></a></li>
<li><a href='#stop_clca'><p>STOPS version of CLCA.</p></a></li>
<li><a href='#stop_cldae'><p>STOPS version of CLDA with free epsilon.</p></a></li>
<li><a href='#stop_cldak'><p>STOPS version of CLDA with free k.</p></a></li>
<li><a href='#stop_cmdscale'><p>STOPS version of strain</p></a></li>
<li><a href='#stop_elastic'><p>STOPS versions of elastic scaling models (via smacofSym)</p></a></li>
<li><a href='#stop_isomap1'><p>STOPS version of isomap to optimize over integer k.</p></a></li>
<li><a href='#stop_isomap2'><p>STOPS version of isomap over real epsilon.</p></a></li>
<li><a href='#stop_lmds'><p>STOPS version of lMDS</p></a></li>
<li><a href='#stop_powerelastic'><p>STOPS version of elastic scaling with powers for proximities and distances</p></a></li>
<li><a href='#stop_powermds'><p>STOPS version of powermds</p></a></li>
<li><a href='#stop_powersammon'><p>STOPS version of sammon with powers</p></a></li>
<li><a href='#stop_powerstress'><p>STOPS version of powerstress</p></a></li>
<li><a href='#stop_rpowerstress'><p>STOPS version of restricted powerstress</p></a></li>
<li><a href='#stop_rstress'><p>STOPS version of rstress</p></a></li>
<li><a href='#stop_sammon'><p>STOPS version of Sammon mapping</p></a></li>
<li><a href='#stop_sammon2'><p>Another STOPS version of Sammon mapping models (via smacofSym)</p></a></li>
<li><a href='#stop_smacofSphere'><p>STOPS versions of smacofSphere models</p></a></li>
<li><a href='#stop_smacofSym'><p>STOPS version of smacofSym models</p></a></li>
<li><a href='#stop_smddae'><p>STOPS version of sparsified multidimensional distance analysis for fixed eps and tau</p></a></li>
<li><a href='#stop_smddak'><p>STOPS version of sparsified multidimensional distance analysis for fixed k and tau</p></a></li>
<li><a href='#stop_smds'><p>STOPS version of sparsified MDS.</p></a></li>
<li><a href='#stop_spmddae'><p>STOPS version of sparsified post multidimensional distance analysis for fixed tau and epsilon.</p></a></li>
<li><a href='#stop_spmddak'><p>STOPS version of sparsified post multidimensional distance analysis for fixed tau and k.</p></a></li>
<li><a href='#stop_spmds'><p>STOPS version of sparsified POST-MDS for fixed tau</p></a></li>
<li><a href='#stop_sstress'><p>STOPS version of sstress</p></a></li>
<li><a href='#stoploss'><p>Calculate the weighted multiobjective loss function used in STOPS</p></a></li>
<li><a href='#stops'><p>High Level STOPS Function</p></a></li>
<li><a href='#summary.stops'><p>S3 summary method for stops</p></a></li>
<li><a href='#Swissroll'><p>Swiss roll</p></a></li>
<li><a href='#tgpoptim'><p>Bayesian Optimization by a (treed) Bayesian Gaussian Process Prior (with jumps to linear models) surrogate model</p>
Essentially a wrapper for the functionality in tgp that has the same slots as optim with defaults for STOPS models.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Structure Optimized Proximity Scaling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6-2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Rusch &lt;thomas.rusch@wu.ac.at&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods that use flexible variants of multidimensional scaling (MDS) which incorporate parametric nonlinear distance transformations and trade-off the goodness-of-fit fit with structure considerations to find optimal hyperparameters, also known as structure optimized proximity scaling (STOPS) (Rusch, Mair &amp; Hornik, 2023,&lt;<a href="https://doi.org/10.1007%2Fs11222-022-10197-w">doi:10.1007/s11222-022-10197-w</a>&gt;). The package contains various functions, wrappers, methods and classes for fitting, plotting and displaying different 1-way MDS models with ratio, interval, ordinal optimal scaling in a STOPS framework. These cover essentially the functionality of the package smacofx, including Torgerson (classical) scaling with power transformations of dissimilarities, SMACOF MDS with powers of dissimilarities, Sammon mapping with powers of dissimilarities, elastic scaling with powers of dissimilarities, spherical SMACOF with powers of dissimilarities, (ALSCAL) s-stress MDS with powers of dissimilarities, r-stress MDS, MDS with powers of dissimilarities and configuration distances, elastic scaling powers of dissimilarities and configuration distances, Sammon mapping powers of dissimilarities and configuration distances, power stress MDS (POST-MDS), approximate power stress, Box-Cox MDS, local MDS, Isomap, curvilinear component analysis (CLCA), curvilinear distance analysis (CLDA) and sparsified (power) multidimensional scaling and (power) multidimensional distance analysis (experimental models from smacofx influenced by CLCA). All of these models can also be fit by optimizing over hyperparameters based on goodness-of-fit fit only (i.e., no structure considerations). The package further contains functions for optimization, specifically the adaptive Luus-Jaakola algorithm and a wrapper for Bayesian optimization with treed Gaussian process with jumps to linear models, and functions for various c-structuredness indices.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), smacofx</td>
</tr>
<tr>
<td>Imports:</td>
<td>acepack, clue, cmaes, cordillera, dfoptim, DiceOptim,
DiceKriging, energy, minerva, nloptr, pomp, pso, scagnostics,
smacof, tgp, vegan</td>
</tr>
<tr>
<td>Enhances:</td>
<td>stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-forge.r-project.org/projects/stops/">https://r-forge.r-project.org/projects/stops/</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-27 15:45:24 UTC; trusch</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Rusch <a href="https://orcid.org/0000-0002-7773-2096"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Patrick Mair <a href="https://orcid.org/0000-0003-0100-6511"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Kurt Hornik <a href="https://orcid.org/0000-0003-4198-9911"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-28 07:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='stops-package'>stops: Structure Optimized Proximity Scaling</h2><span id='topic+stops-package'></span>

<h3>Description</h3>

<p>A package for &quot;structure optimized proximity scaling&quot; (STOPS), a collection of methods that fit nonlinear distance transformations in multidimensional scaling (MDS) and trade-off the fit with structure considerations to find optimal parameters or optimal configurations. The package contains various functions, wrappers, methods and classes for fitting, plotting and displaying different MDS models in a STOPS framework like Torgerson scaling, SMACOF, Sammon mapping, elastic scaling, symmetric SMACOF, spherical SMACOF, sstress, rstress, powermds, power elastic scaling, power sammon mapping, power stress, Isomap, approximate power stress, restricted power stress. All of these models can also be fit as MDS variants (i.e., no structuredness). The package further contains functions for optimization (Adaptive Luus-Jaakola and for Bayesian optimization with treed Gaussian process with jump to linear models) and functions for various structuredness indices
</p>


<h3>Details</h3>

<p>The stops package provides five categories of important functions:
</p>
<p>Models:
</p>

<ul>
<li><p> stops ... which fits STOPS models as described in Rusch et al. (2023) via argument loss with ratio, interval or ordinal optimal scaling (not all optimal scalings can be used with all loss arguments). By setting cordweight or strucweight to zero they can also be used to fit MDS for many different models:
</p>

<ul>
<li><p> loss=&quot;stress&quot;: One parameter theta, power transformations of dissimilarities. Via stop_smacofSym.
</p>
</li>
<li><p> loss=&quot;sammon&quot;: One parameter theta, power transformations of dissimilarities. Via stop_sammon.
</p>
</li>
<li><p> loss=&quot;strain&quot;: One parameter theta, power transformations of dissimilarities. Via stop_cmdscale.
</p>
</li>
<li><p> loss=&quot;rstress&quot;: One parameter theta, power transformations of fitted distances. Via stop_rstress.
</p>
</li>
<li><p> loss=&quot;smacofSphere&quot;: One parameter theta, power transformations of dissimilarities. Via stop_smacofSphere.
</p>
</li>
<li><p> loss=&quot;sammon2&quot;: One parameter theta, power transformations of dissimilarities. Via stop_sammon2.
</p>
</li>
<li><p> loss=&quot;elastic&quot;: One parameter theta, power transformations of dissimilarities. Via stop_elastic.
</p>
</li>
<li><p> loss=&quot;sstress&quot;: One parameter theta, power transformations of dissimilarities. Via stop_sstress.
</p>
</li>
<li><p> loss=&quot;isomap_k&quot;: One parameter theta, k neighborhood for geodesic distances. Via stop_isomap1.
</p>
</li>
<li><p> loss=&quot;isomap_eps&quot;: One parameter theta, epsilon neighborhood for geodesic distances. Via stop_isomap2.
</p>
</li>
<li><p> loss=&quot;smds&quot;: One parameter theta, neighborhood parameter tau. Via stop_smds.
</p>
</li>
<li><p> loss=&quot;clca&quot;: One parameter theta, neighborhood parameters lambda0. Via stop_clca.
</p>
</li>
<li><p> loss=&quot;powerelastic&quot;: Two parameter theta, power transformations of dissimilarities and fitted distances. Via stop_powerelastic.
</p>
</li>
<li><p> loss=&quot;powersammon&quot;: Two parameter theta, power transformations of dissimilarities and fitted distances. Via stop_powersammon.
</p>
</li>
<li><p> loss=&quot;powermds&quot;: Two parameter theta, power transformations of dissimilarities and fitted distances. Via stop_powermds.
</p>
</li>
<li><p> loss=&quot;rpstress&quot;: Two parameter theta, power transformations of dissimilarities/fitted distances and weights. Via stop_rpowerstress.
</p>
</li>
<li><p> loss=&quot;smdda_k&quot;: Two parameter theta, neighborhood parameters k (geodesic distance) and tau. Via stop_smmdak.
</p>
</li>
<li><p> loss=&quot;smdda_eps&quot;: Two parameter theta, neighborhood parameters eps (geodesic distance) and tau. stop_smddae.
</p>
</li>
<li><p> loss=&quot;lmds&quot;: Two parameter theta, neighbourhood parameters tau and k. Via stop_lmds.
</p>
</li>
<li><p> loss=&quot;clda_eps&quot;: Two parameter theta, neighborhood parameters lambda0 and epsilon (geodesic distance). Via stop_cldae.
</p>
</li>
<li><p> loss=&quot;clda_k&quot;: Two parameter theta, neighborhood parameters lambda0 and k (geodesic distance). Via stop_cldak.
</p>
</li>
<li><p> loss=&quot;powerstress&quot;: Three parameter theta, power transformations of dissimilarities, fitted distances and weights. Via stop_powerstress.
</p>
</li>
<li><p> loss=&quot;bcmds&quot;: Three parameter theta, Box-Cox transformations of dissimilarities, fitted distances and weights. Via stop_bcmds. 
</p>
</li>
<li><p> loss=&quot;apstress&quot;: Three parameter theta, power transformations of dissimilarities, fitted distances and weights. Via stop_apstress.
</p>
</li>
<li><p> loss=&quot;spmds&quot;: Four parameter theta, power transformations of dissimilarities, fitted distances and weights and neighborhood parametr tau. Via stop_spmds.
</p>
</li>
<li><p> loss=&quot;spmdda_k&quot;: Five parameter theta, power transformations for dissimilarities, fitted distances and weights and neighborhood parameters k (geodesic distance) and tau. Via stop_spmddak.
</p>
</li>
<li><p> loss=&quot;spmdda_eps&quot;: Five parameter theta, power transformations for dissimilarities, fitted distances and weights and neighborhood parameters eps (geodesic distance) and tau. Via stop_spmddae.
</p>
</li></ul>

</li></ul>

<p>Structuredness Indices:
Various c-structuredness as c_foo(), where foo is the name of the structuredness.  See Rusch et al. (2023). 
</p>
<p>Optimization functions:
</p>

<ul>
<li><p> ljoptim() ... An (adaptive) version of the Luus-Jakola random search
</p>
</li></ul>

<p>Methods: 
For most of the objects returned by the high-level functions S3 classes and methods for standard generics were implemented, including print, summary, plot, coef (extracting the hyperparameetrs).   
</p>
<p>References:
</p>

<ul>
<li><p> Rusch, T., Mair, P., &amp; Hornik, K. (2023). Structure-based hyperparameter selection with Bayesian optimization in multidimensional scaling. Statistics &amp; Computing, 33, [28]. https://doi.org/10.1007/s11222-022-10197-w
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Thomas Rusch <a href="mailto:thomas.rusch@wu.ac.at">thomas.rusch@wu.ac.at</a> (<a href="https://orcid.org/0000-0002-7773-2096">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Patrick Mair (<a href="https://orcid.org/0000-0003-0100-6511">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Kurt Hornik <a href="mailto:Kurt.Hornik@R-project.org">Kurt.Hornik@R-project.org</a> (<a href="https://orcid.org/0000-0003-4198-9911">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://r-forge.r-project.org/projects/stops/">https://r-forge.r-project.org/projects/stops/</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#data(Swissroll)
#dissm&lt;-as.matrix(dist(Swissroll[,1:3]))
#cols&lt;-Swissroll[,4]
#structures&lt;-c("cregularity","cdependence")
#strucweight&lt;-c(-0.5,0.5)
#strucpars&lt;-list(list(epsilon=10,minpts=2,scale=3),list(NULL))

dissm&lt;-as.matrix(smacof::morse)

#Setting up structurenedness parameters
strucpars&lt;-list(list(epsilon=10,scale=3),list(NULL))
structures&lt;-c("cclusteredness","cdependence")

#STOPS with strain
resstrain&lt;-stops(dissm,loss="strain",theta=1,structures=structures,
strucpars=strucpars,optimmethod="ALJ",lower=0.5,upper=5,itmax=10)
resstrain
summary(resstrain)
plot(resstrain)
#Fun fact: With strain clinearity must be 0 as the
#two principal axes are orthogonal
#and this can't be changed by taking
#the dissimilarities to a power

resstressm&lt;-stops(dissm,loss="stress",theta=1,structures=structures,
strucpars=strucpars,optimmethod="ALJ",lower=0.5,upper=5,itmax=10,stoptype="multiplicative")
resstressm
plot(resstressm)


#STOPS with stress or smacofSym
im&lt;-2 #this is the itmax argument used for testing; use higher itmax in practice 
resstress&lt;-stops(dissm,loss="stress",theta=1,
structures=structures,
strucpars=strucpars,optimmethod="ALJ",lower=0.5,upper=5,itmax=im)
resstress
summary(resstress)
plot(resstress)
plot(resstress,"Shepard")

#STOPS with smacofSphere
ressph&lt;-stops(dissm,loss="smacofSphere",theta=1,
structures=structures,
strucpars=strucpars,optimmethod="ALJ",lower=0.5,upper=5,itmax=im)
ressph
summary(ressph)
plot(ressph)

#STOPS with sammon
ressam&lt;-stops(dissm,loss="sammon",theta=1,
structures=structures,
strucpars=strucpars,optimmethod="ALJ",lower=0.5,upper=5,itmax=im)
ressam
summary(ressam)
plot(ressam)
plot(ressam,"transplot")

#STOPS with sammon2
ressam&lt;-stops(dissm,loss="sammon2",theta=1,
structures=structures,
strucpars=strucpars,optimmethod="ALJ",lower=0.5,upper=5,itmax=im)
ressam
summary(ressam)
plot(ressam)
plot(ressam,"Shepard")

#STOPS with elastic 
ressam&lt;-stops(dissm,loss="elastic",theta=1,
structures=structures,
strucpars=strucpars,optimmethod="ALJ",lower=0.5,upper=5,itmax=im)
ressam
summary(ressam)
plot(ressam)
plot(ressam,"transplot")

#STOPS with sstress
resss&lt;-stops(dissm,loss="sstress",theta=1,
structures=structures,
strucpars=strucpars,optimmethod="ALJ",lower=0.5,upper=5,itmax=im)
resss
summary(resss)
plot(resss)
plot(resss,"Shepard")
plot(resss,"transplot")

#STOPS with powerstress
respstress&lt;-stops(dissm,loss="powerstress",
structures=structures,theta=c(1,1,1),
strucpars=strucpars,weightmat=dissm,
itmaxps=1000,optimmethod="ALJ",lower=c(0.5,0.5,1),upper=c(5,5,5),itmax=im)
respstress
summary(respstress)
plot(respstress)

#STOPS with restricted powerstress
respstressr&lt;-stops(dissm,loss="powerstress",theta=c(1,1),
structures=structures,
strucpars=strucpars,weightmat=dissm,
itmaxps=1000,optimmethod="ALJ",lower=c(0.5,0.5),upper=c(5,5),itmax=im)
respstressr
summary(respstressr)
plot(respstressr)

#STOPS with powermds
respmds&lt;-stops(dissm,loss="powermds",
structures=structures,theta=c(1,1),
strucpars=strucpars,weightmat=dissm,
itmaxps=1000,optimmethod="ALJ",lower=c(0.5,0.5),upper=c(5,5),itmax=im)
respmds
summary(respmds)
plot(respmds)

#STOPS with powersammon
respmds&lt;-stops(dissm,loss="powersammon",theta=c(1,1),
structures=structures,
strucpars=strucpars,weightmat=dissm,
itmaxps=1000,optimmethod="ALJ",lower=c(0.5,0.5),upper=c(5,5),itmax=im)
respmds
summary(respmds)
plot(respmds)

#STOPS with powerelastic
respmds&lt;-stops(dissm,loss="powerelastic",theta=c(1,1),
structures=structures,
strucpars=strucpars,weightmat=dissm,
itmaxps=1000,optimmethod="ALJ",lower=c(0.5,0.5,1),upper=c(5,5,5),itmax=im)
respmds
summary(respmds)
plot(respmds)

#STOPS with ordinal rstress 
resr&lt;-stops(dissm,loss="rstress",type="ordinal",theta=1,
structures=structures,
strucpars=strucpars,weightmat=dissm,
itmaxps=1000,optimmethod="ALJ",lower=0.5,upper=5,itmax=im)
resr
summary(resr)
plot(resr)

#STOPS with approximated powerstress
respstressa&lt;-stops(dissm,loss="powerstress",
structures=structures,
strucpars=strucpars,weightmat=dissm,theta=c(1,1,1),
itmaxps=1000,optimmethod="ALJ",lower=c(0.5,0.5,1),upper=c(5,5,5),itmax=im)
respstressa
summary(respstressa)
plot(respstressa,"transplot")

#STOPS with bcmds
resbcstress&lt;-stops(dissm,loss="bcmds",
structures=structures,
strucpars=strucpars,optimmethod="ALJ",lower=c(0.5,1,0.5),upper=c(5,5,5),itmax=im)
resbcstress
summary(resbcstress)
plot(resbcstress)

#STOPS with lmds
reslmds&lt;-stops(dissm,loss="lmds",theta=c(1,1),
structures=structures,
strucpars=strucpars,optimmethod="ALJ",lower=c(2,0),upper=c(5,1),itmax=im)
reslmds
summary(reslmds)
plot(reslmds)

#STOPS with Isomap (the k version)
resiso2&lt;-stops(dissm,loss="isomap",theta=5,
structures=structures,
strucpars=strucpars,optimmethod="ALJ",lower=3,upper=10,itmax=im)
resiso2
summary(resiso2)
plot(resiso2)

#STOPS with Isomap (the eps version)
resiso&lt;-stops(dissm,loss="isomapeps",
structures=structures,
theta=40,
strucpars=strucpars,optimmethod="ALJ",lower=50,upper=120,itmax=im)
resiso
summary(resiso)
plot(resiso)

strucweight&lt;-c(-0.5,-0.5)

#STOPS with smds
resclca&lt;-stops(dissm,loss="smds",theta=0.3,
structures=structures, strucpars=strucpars,
strucweight=strucweight,lower=0.1,upper=5,
optimmethod="pso",itmax=im*4)
resclca
summary(resclca)
plot(resclca)

#STOPS with spmds
respclca&lt;-stops(dissm,loss="spmds",theta=c(1,1,1,1),
structures=structures,strucpars=strucpars,
strucweight=strucweight,lower=c(0.1,0.1,0.1,0.1),upper=c(5,5,5,5),
optimmethod="ALJ",itmax=im)
respclca
coef(respclca)
summary(respclca)
plot(respclca)

#STOPS with smdda and k 
rescldak&lt;-stops(dissm,loss="smdda_k",theta=c(1,5),
structures=structures,strucpars=strucpars,
strucweight=strucweight,lower=c(0.2,4),upper=c(4,20),
optimmethod="pso",itmax=im*4)
rescldak
summary(rescldak)
plot(rescldak)

#STOPS with smdda in eps
set.seed(123)
rescldae&lt;-stops(dissm,loss="smdda_eps",theta=c(1,2),
structures=structures,strucpars=strucpars,
strucweight=strucweight,lower=c(0.2,1),upper=c(4,10),
optimmethod="SANN",itmax=10*im,stoptype="multiplicative")
rescldae
summary(rescldae)
plot(rescldae)

#STOPS with spmdda with k (five parameters already..)
respcldak&lt;-stops(dissm,loss="spmdda_k",theta=c(1,1,1,1,5),
structures=structures,strucpars=strucpars,
strucweight=strucweight,lower=c(0.8,0.8,0.8,0.8,4),upper=c(5,5,5,5,20),
optimmethod="tgp",itmax=im)
respcldak
summary(respcldak)
plot(respcldak)

#STOPS with spmdda with eps (five parameter already..)
set.seed(123)
respcldae&lt;-stops(dissm,loss="spmdda_eps",theta=c(1,1,1,1,2),
structures=structures,strucpars=strucpars,
strucweight=strucweight,lower=c(0.8,0.8,0.8,0.8,1),upper=c(5,5,5,5,10),
optimmethod="tgp",itmax=im)
respcldae
summary(respcldae)
plot(respcldae)

#STOPS with clca 
set.seed(123)
resclca&lt;-stops(dissm,loss="clca",theta=c(1),
structures=structures,strucpars=strucpars,
strucweight=strucweight,lower=0.1,upper=5,itmax=im)
resclca
summary(resclca)
plot(resclca)

#STOPS with clda with eps 
set.seed(123)
respcldae&lt;-stops(dissm,loss="spmdda_eps",theta=c(1,1,1,1,2),
structures=structures,strucpars=strucpars,
strucweight=strucweight,lower=c(0.1,0.1,0.1,0.1,1),upper=c(5,5,5,5,10),
optimmethod="tgp",itmax=im)
respcldae
summary(respcldae)
plot(respcldae)

</code></pre>

<hr>
<h2 id='BankingCrisesDistances'>Banking Crises Distances</h2><span id='topic+BankingCrisesDistances'></span>

<h3>Description</h3>

<p>Matrix of Jaccard distances between 70 countries (Hungary and Greece were combined to be the same observation) based on their binary time series of having had a banking crises in a year from 1800 to 2010 or not. See data(bankingCrises) in package Ecdat for more info. The last column is Reinhart &amp; Rogoffs classification as a low (3), middle- (2) or high-income country (1).
</p>


<h3>Format</h3>

<p>A 69 x 70 matrix.
</p>


<h3>Source</h3>

<p>data(bankingCrises) in library(Ecdat)
</p>

<hr>
<h2 id='bootmds.stops'>MDS Bootstrap for stops objects</h2><span id='topic+bootmds.stops'></span>

<h3>Description</h3>

<p>Performs a bootstrap on an MDS solution. It works for derived dissimilarities only, i.e. generated by the call dist(data). The original data matrix needs to be provided, as well as the type of dissimilarity measure used to compute the input dissimilarities (note we cannot as of yet have any dissimilarity matrix).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stops'
bootmds(
  object,
  data,
  method.dat = "pearson",
  nrep = 100,
  alpha = 0.05,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootmds.stops_+3A_object">object</code></td>
<td>
<p>Object of class stops or pcops.</p>
</td></tr>
<tr><td><code id="bootmds.stops_+3A_data">data</code></td>
<td>
<p>Initial data (before dissimilarity computation).</p>
</td></tr>
<tr><td><code id="bootmds.stops_+3A_method.dat">method.dat</code></td>
<td>
<p>Dissimilarity computation used as MDS input. This must be one of &quot;pearson&quot;, &quot;spearman&quot;, &quot;kendall&quot;, &quot;euclidean&quot;, &quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot;.</p>
</td></tr>
<tr><td><code id="bootmds.stops_+3A_nrep">nrep</code></td>
<td>
<p>Number of bootstrap replications.</p>
</td></tr>
<tr><td><code id="bootmds.stops_+3A_alpha">alpha</code></td>
<td>
<p>Alpha level for condfidence ellipsoids.</p>
</td></tr>
<tr><td><code id="bootmds.stops_+3A_verbose">verbose</code></td>
<td>
<p>If 'TRUE', bootstrap index is printed out.</p>
</td></tr>
<tr><td><code id="bootmds.stops_+3A_...">...</code></td>
<td>
<p>Additional arguments needed for dissimilarity computation as specified in <code><a href="smacof.html#topic+sim2diss">sim2diss</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to examine the stability solution of an MDS, a bootstrap on the raw data can be performed. This results in confidence ellipses in the configuration plot. The ellipses are returned as list which allows users to produce (and further customize) the plot by hand. See <code><a href="smacof.html#topic+bootmds">bootmds</a></code> for more.
</p>


<h3>Value</h3>

<p>An object of class 'smacofboot', see <code><a href="smacof.html#topic+bootmds">bootmds</a></code>. With values 
</p>

<ul>
<li><p> cov: Covariances for ellipse computation
</p>
</li>
<li><p> bootconf: Configurations bootstrap samples
</p>
</li>
<li><p> stressvec: Bootstrap stress values
</p>
</li>
<li><p> bootci: Stress bootstrap percentile confidence interval
</p>
</li>
<li><p> spp: Stress per point (based on stress.en) 
</p>
</li>
<li><p> stab: Stability coefficient
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>dats &lt;- na.omit(PVQ40[,1:5])
diss &lt;- dist(t(dats))   ## Euclidean distances 
fit &lt;- stops(diss,loss="rstress",itmax=5,lower=0.2,upper=3)       
set.seed(123)
resboot &lt;- bootmds(fit, dats, method.dat = "euclidean", nrep = 2)
resboot
</code></pre>

<hr>
<h2 id='c_association'>c-association
calculates the c-association based on the maximal information coefficient 
We define c-association as the aggregated association between any two columns in confs</h2><span id='topic+c_association'></span>

<h3>Description</h3>

<p>c-association
calculates the c-association based on the maximal information coefficient 
We define c-association as the aggregated association between any two columns in confs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_association(
  confs,
  aggr = max,
  alpha = 0.6,
  C = 15,
  var.thr = 1e-05,
  zeta = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_association_+3A_confs">confs</code></td>
<td>
<p>a numeric matrix or data frame</p>
</td></tr>
<tr><td><code id="c_association_+3A_aggr">aggr</code></td>
<td>
<p>the aggregation function for configurations of more than two dimensions. Defaults to max.</p>
</td></tr>
<tr><td><code id="c_association_+3A_alpha">alpha</code></td>
<td>
<p>an optional number of cells allowed in the X-by-Y search-grid. Default value is 0.6</p>
</td></tr>
<tr><td><code id="c_association_+3A_c">C</code></td>
<td>
<p>an optional number determining the starting point of the X-by-Y search-grid. When trying to partition the x-axis into X columns, the algorithm will start with at most C X clumps. Default value is 15.</p>
</td></tr>
<tr><td><code id="c_association_+3A_var.thr">var.thr</code></td>
<td>
<p>minimum value allowed for the variance of the input variables, since mine can not be computed in case of variance close to 0. Default value is 1e-5.</p>
</td></tr>
<tr><td><code id="c_association_+3A_zeta">zeta</code></td>
<td>
<p>integer in [0,1] (?).  If NULL (default) it is set to 1-MIC. It can be set to zero for noiseless functions, but the default choice is the most appropriate parametrization for general cases (as stated in Reshef et al). It provides robustness.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; association (aggregated maximal information coefficient MIC, see <code><a href="minerva.html#topic+mine">mine</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-seq(-3,3,length.out=200)
y&lt;-sqrt(3^2-x^2)
z&lt;- sin(y-x)
confs&lt;-cbind(x,y,z)
c_association(confs)
</code></pre>

<hr>
<h2 id='c_clumpiness'>c-clumpiness</h2><span id='topic+c_clumpiness'></span>

<h3>Description</h3>

<p>Measures the c-clumpiness structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_clumpiness(conf, aggr = max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_clumpiness_+3A_conf">conf</code></td>
<td>
<p>A numeric matrix.</p>
</td></tr>
<tr><td><code id="c_clumpiness_+3A_aggr">aggr</code></td>
<td>
<p>the aggregation function for configurations of more than two dimensions. Defaults to max.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; clumpiness (see <code><a href="scagnostics.html#topic+scagnostics">scagnostics</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delts&lt;-smacof::kinshipdelta
conf&lt;-smacof::smacofSym(delts)$conf
plot(conf,pch=19,asp=1)
c_clumpiness(conf)
</code></pre>

<hr>
<h2 id='c_clusteredness'>c-clusteredness 
calculates c-clusteredness as the OPTICS cordillera. The higher the more clustered.</h2><span id='topic+c_clusteredness'></span>

<h3>Description</h3>

<p>c-clusteredness 
calculates c-clusteredness as the OPTICS cordillera. The higher the more clustered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_clusteredness(
  confs,
  minpts = 2,
  q = 2,
  epsilon = 2 * max(dist(confs)),
  distmeth = "euclidean",
  dmax = NULL,
  digits = 10,
  scale = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_clusteredness_+3A_confs">confs</code></td>
<td>
<p>a numeric matrix or a dist object</p>
</td></tr>
<tr><td><code id="c_clusteredness_+3A_minpts">minpts</code></td>
<td>
<p>The minimum number of points that must make up a cluster in OPTICS (corresponds to k in the paper). It is passed to <code><a href="dbscan.html#topic+optics">optics</a></code> where it is called minPts. Defaults to 2.</p>
</td></tr>
<tr><td><code id="c_clusteredness_+3A_q">q</code></td>
<td>
<p>The norm used for the Cordillera. Defaults to 2.</p>
</td></tr>
<tr><td><code id="c_clusteredness_+3A_epsilon">epsilon</code></td>
<td>
<p>The epsilon parameter for OPTICS (called epsilon_max in the paper). Defaults to 2 times the maximum distance between any two points.</p>
</td></tr>
<tr><td><code id="c_clusteredness_+3A_distmeth">distmeth</code></td>
<td>
<p>The distance to be computed if X is not a symmetric matrix or a dist object (otherwise ignored). Defaults to Euclidean distance.</p>
</td></tr>
<tr><td><code id="c_clusteredness_+3A_dmax">dmax</code></td>
<td>
<p>The winsorization value for the highest allowed reachability. If used for comparisons between different configurations this should be supplied. If no value is supplied, it is NULL (default); then dmax is taken from the data as the either epsilon or the largest reachability, whatever is smaller.</p>
</td></tr>
<tr><td><code id="c_clusteredness_+3A_digits">digits</code></td>
<td>
<p>The precision to round the raw Cordillera and the norm factor. Defaults to 10.</p>
</td></tr>
<tr><td><code id="c_clusteredness_+3A_scale">scale</code></td>
<td>
<p>Should X be scaled if it is an asymmetric matrix or data frame? Can take values TRUE or FALSE or a numeric value. If TRUE or 1, standardisation is to mean=0 and sd=1. If 2, no centering is applied and scaling of each column is done with the root mean square of each column. If 3, no centering is applied and scaling of all columns is done as X/max(standard deviation(allcolumns)). If 4, no centering is applied and scaling of all columns is done as X/max(rmsq(allcolumns)). If FALSE, 0 or any other numeric value, no standardisation is applied. Defaults to 0.</p>
</td></tr>
<tr><td><code id="c_clusteredness_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>cordillera::cordillera</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; clusteredness (see <code><a href="cordillera.html#topic+cordillera">cordillera</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delts&lt;-smacof::kinshipdelta
dis&lt;-smacofSym(delts)$confdist
c_clusteredness(dis,minpts=3)
</code></pre>

<hr>
<h2 id='c_complexity'>c-complexity
Calculates the c-complexity based on the minimum cell number
We define c-complexity as the aggregated minimum cell number between any two columns in confs 
This is one of few c-structuredness indices not between 0 and 1, but can be between 0 and (theoretically) infinity</h2><span id='topic+c_complexity'></span>

<h3>Description</h3>

<p>c-complexity
Calculates the c-complexity based on the minimum cell number
We define c-complexity as the aggregated minimum cell number between any two columns in confs 
This is one of few c-structuredness indices not between 0 and 1, but can be between 0 and (theoretically) infinity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_complexity(
  confs,
  aggr = min,
  alpha = 1,
  C = 15,
  var.thr = 1e-05,
  zeta = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_complexity_+3A_confs">confs</code></td>
<td>
<p>a numeric matrix or data frame</p>
</td></tr>
<tr><td><code id="c_complexity_+3A_aggr">aggr</code></td>
<td>
<p>the aggregation function for configurations of more than two dimensions. Defaults to min.</p>
</td></tr>
<tr><td><code id="c_complexity_+3A_alpha">alpha</code></td>
<td>
<p>an optional number of cells allowed in the X-by-Y search-grid. Default value is 1</p>
</td></tr>
<tr><td><code id="c_complexity_+3A_c">C</code></td>
<td>
<p>an optional number determining the starting point of the X-by-Y search-grid. When trying to partition the x-axis into X columns, the algorithm will start with at most C X clumps. Default value is 15.</p>
</td></tr>
<tr><td><code id="c_complexity_+3A_var.thr">var.thr</code></td>
<td>
<p>minimum value allowed for the variance of the input variables, since mine can not be computed in case of variance close to 0. Default value is 1e-5.</p>
</td></tr>
<tr><td><code id="c_complexity_+3A_zeta">zeta</code></td>
<td>
<p>integer in [0,1] (?).  If NULL (default) it is set to 1-MIC. It can be set to zero for noiseless functions, but the default choice is the most appropriate parametrization for general cases (as stated in Reshef et al.). It provides robustness.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; complexity (aggregated minimum cell number MCN, see <code><a href="minerva.html#topic+mine">mine</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-seq(-3,3,length.out=200)
y&lt;-sqrt(3^2-x^2)
z&lt;- sin(y-x)
confs&lt;-cbind(x,y,z)
c_complexity(confs)
</code></pre>

<hr>
<h2 id='c_convexity'>c-convexity</h2><span id='topic+c_convexity'></span>

<h3>Description</h3>

<p>Measures the c-convexity structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_convexity(conf, aggr = max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_convexity_+3A_conf">conf</code></td>
<td>
<p>A numeric matrix.</p>
</td></tr>
<tr><td><code id="c_convexity_+3A_aggr">aggr</code></td>
<td>
<p>the aggregation function for configurations of more than two dimensions. Defaults to max.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; convexity (see <code><a href="scagnostics.html#topic+scagnostics">scagnostics</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delts&lt;-smacof::kinshipdelta
conf&lt;-smacof::smacofSym(delts)$conf
plot(conf,pch=19,asp=1)
c_convexity(conf)
</code></pre>

<hr>
<h2 id='c_dependence'>c-dependence
calculates c-dependence as the aggregated distance correlation of each pair if nonidentical columns</h2><span id='topic+c_dependence'></span>

<h3>Description</h3>

<p>c-dependence
calculates c-dependence as the aggregated distance correlation of each pair if nonidentical columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_dependence(confs, aggr = max, index = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_dependence_+3A_confs">confs</code></td>
<td>
<p>a numeric matrix or data frame</p>
</td></tr>
<tr><td><code id="c_dependence_+3A_aggr">aggr</code></td>
<td>
<p>the aggregation function for configurations of more than two dimensions. Defaults to max.</p>
</td></tr>
<tr><td><code id="c_dependence_+3A_index">index</code></td>
<td>
<p>exponent on Euclidean distance, in (0,2]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; dependence (aggregated distance correlation)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-1:10
y&lt;-2+3*x+rnorm(10)
confs&lt;-cbind(x,y)
c_dependence(confs,1.5)
</code></pre>

<hr>
<h2 id='c_faithfulness'>c-faithfulness 
calculates the c-faithfulness based on the index by Chen and Buja 2013 (M_adj) with equal input neigbourhoods</h2><span id='topic+c_faithfulness'></span>

<h3>Description</h3>

<p>c-faithfulness 
calculates the c-faithfulness based on the index by Chen and Buja 2013 (M_adj) with equal input neigbourhoods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_faithfulness(confs, obsdiss, k = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_faithfulness_+3A_confs">confs</code></td>
<td>
<p>a numeric matrix or a dist object</p>
</td></tr>
<tr><td><code id="c_faithfulness_+3A_obsdiss">obsdiss</code></td>
<td>
<p>a symmetric numeric matrix or a dist object</p>
</td></tr>
<tr><td><code id="c_faithfulness_+3A_k">k</code></td>
<td>
<p>the number of nearest neighbours to be looked at</p>
</td></tr>
<tr><td><code id="c_faithfulness_+3A_...">...</code></td>
<td>
<p>additional arguments passed to dist()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; faithfulness
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delts&lt;-smacof::kinshipdelta
dis&lt;-smacofSym(delts)$confdist
c_faithfulness(dis,delts,k=3)
</code></pre>

<hr>
<h2 id='c_functionality'>c-functionality
calculates the c-functionality based on the maximum edge value 
We define c-functionality as the aggregated functionality between any two columns of confs</h2><span id='topic+c_functionality'></span>

<h3>Description</h3>

<p>c-functionality
calculates the c-functionality based on the maximum edge value 
We define c-functionality as the aggregated functionality between any two columns of confs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_functionality(
  confs,
  aggr = max,
  alpha = 1,
  C = 15,
  var.thr = 1e-05,
  zeta = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_functionality_+3A_confs">confs</code></td>
<td>
<p>a numeric matrix or data frame</p>
</td></tr>
<tr><td><code id="c_functionality_+3A_aggr">aggr</code></td>
<td>
<p>the aggregation function for configurations of more than two dimensions. Defaults to mean</p>
</td></tr>
<tr><td><code id="c_functionality_+3A_alpha">alpha</code></td>
<td>
<p>an optional number of cells allowed in the X-by-Y search-grid. Default value is 1</p>
</td></tr>
<tr><td><code id="c_functionality_+3A_c">C</code></td>
<td>
<p>an optional number determining the starting point of the X-by-Y search-grid. When trying to partition the x-axis into X columns, the algorithm will start with at most C X clumps. Default value is 15.</p>
</td></tr>
<tr><td><code id="c_functionality_+3A_var.thr">var.thr</code></td>
<td>
<p>minimum value allowed for the variance of the input variables, since mine can not be computed in case of variance close to 0. Default value is 1e-5.</p>
</td></tr>
<tr><td><code id="c_functionality_+3A_zeta">zeta</code></td>
<td>
<p>integer in [0,1] (?).  If NULL (default) it is set to 1-MIC. It can be set to zero for noiseless functions, but the default choice is the most appropriate parametrization for general cases (as stated in Reshef et al.). It provides robustness.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; functionality (aggregated maximaum edge value MEV, see <code><a href="minerva.html#topic+mine">mine</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-seq(-3,3,length.out=200)
y&lt;-sqrt(3^2-x^2)
z&lt;- sin(y-x)
confs&lt;-cbind(x,y,z)
c_functionality(confs)
</code></pre>

<hr>
<h2 id='c_hierarchy'>c-hierarchy
captures how well a partition/ultrametric (obtained by hclust) explains the configuration distances. Uses variance explained for euclidean distances and deviance explained for everything else.</h2><span id='topic+c_hierarchy'></span>

<h3>Description</h3>

<p>c-hierarchy
captures how well a partition/ultrametric (obtained by hclust) explains the configuration distances. Uses variance explained for euclidean distances and deviance explained for everything else.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_hierarchy(confs, p = 2, agglmethod = "complete")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_hierarchy_+3A_confs">confs</code></td>
<td>
<p>a numeric matrix</p>
</td></tr>
<tr><td><code id="c_hierarchy_+3A_p">p</code></td>
<td>
<p>the parameter of the Minokwski distances (p=2 euclidean and p=1 is manhattan)</p>
</td></tr>
<tr><td><code id="c_hierarchy_+3A_agglmethod">agglmethod</code></td>
<td>
<p>the method used for creating the clustering, see <code><a href="stats.html#topic+hclust">hclust</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; hierarchy (see <code><a href="clue.html#topic+cl_validity">cl_validity</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delts&lt;-smacof::kinshipdelta
conf&lt;-smacofSym(delts)$conf
c_hierarchy(conf,p=2,agglmethod="single")
</code></pre>

<hr>
<h2 id='c_inequality'>c-inequality
Calculates c-inequality (as in an economic measure of inequality) as Pearsons coefficient of variation of the fitted distance matrix. This can help with avoiding degenerate solutions.   
This is one of few c-structuredness indices not between 0 and 1, but 0 and infinity.</h2><span id='topic+c_inequality'></span>

<h3>Description</h3>

<p>c-inequality
Calculates c-inequality (as in an economic measure of inequality) as Pearsons coefficient of variation of the fitted distance matrix. This can help with avoiding degenerate solutions.   
This is one of few c-structuredness indices not between 0 and 1, but 0 and infinity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_inequality(confs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_inequality_+3A_confs">confs</code></td>
<td>
<p>a numeric matrix or data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; inequality (Pearsons coefficient of variation of the fitted distance matrix)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-1:10
y&lt;-2+3*x+rnorm(10)
z&lt;- sin(y-x)
confs&lt;-cbind(z,y,x)
c_inequality(confs)
</code></pre>

<hr>
<h2 id='c_linearity'>c-linearity
calculates c-linearity as the aggregated multiple correlation of all columns of the configuration.</h2><span id='topic+c_linearity'></span>

<h3>Description</h3>

<p>c-linearity
calculates c-linearity as the aggregated multiple correlation of all columns of the configuration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_linearity(confs, aggr = max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_linearity_+3A_confs">confs</code></td>
<td>
<p>a numeric matrix or data frame</p>
</td></tr>
<tr><td><code id="c_linearity_+3A_aggr">aggr</code></td>
<td>
<p>the aggregation function for configurations of more than two dimensions. Defaults to max.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; linearity (aggregated multiple correlation of all columns of the configuration)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-1:10
y&lt;-2+3*x+rnorm(10)
z&lt;- sin(y-x)
confs&lt;-cbind(z,y,x)
c_linearity(confs)
</code></pre>

<hr>
<h2 id='c_manifoldness'>c-manifoldness
calculates c-manifoldness as the aggregated maximal correlation coefficient (i.e., Pearson correlation of the ACE transformed variables) of all pairwise combinations of two different columns in confs. If there is an NA (happens usually when the optimal transformation of any variable is a constant and therefore the covariance is 0 but also one of the sds in the denominator), it gets skipped.</h2><span id='topic+c_manifoldness'></span>

<h3>Description</h3>

<p>c-manifoldness
calculates c-manifoldness as the aggregated maximal correlation coefficient (i.e., Pearson correlation of the ACE transformed variables) of all pairwise combinations of two different columns in confs. If there is an NA (happens usually when the optimal transformation of any variable is a constant and therefore the covariance is 0 but also one of the sds in the denominator), it gets skipped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_manifoldness(confs, aggr = max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_manifoldness_+3A_confs">confs</code></td>
<td>
<p>a numeric matrix or data frame</p>
</td></tr>
<tr><td><code id="c_manifoldness_+3A_aggr">aggr</code></td>
<td>
<p>the aggregation function for configurations of more than two dimensions. Defaults to max.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; manifoldness (aggregated maximal correlation, correlation of ACE tranformed x and y, see <code><a href="acepack.html#topic+ace">ace</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;--100:100
y&lt;-sqrt(100^2-x^2)
confs&lt;-cbind(x,y)
c_manifoldness(confs)
</code></pre>

<hr>
<h2 id='c_mine'>wrapper for getting the mine coefficients</h2><span id='topic+c_mine'></span>

<h3>Description</h3>

<p>wrapper for getting the mine coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_mine(confs, master = NULL, alpha = 0.6, C = 15, var.thr = 1e-05, zeta = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_mine_+3A_confs">confs</code></td>
<td>
<p>a numeric matrix or data frame with two columns</p>
</td></tr>
<tr><td><code id="c_mine_+3A_master">master</code></td>
<td>
<p>the master column</p>
</td></tr>
<tr><td><code id="c_mine_+3A_alpha">alpha</code></td>
<td>
<p>an optional number of cells allowed in the X-by-Y search-grid. Default value is 0.6</p>
</td></tr>
<tr><td><code id="c_mine_+3A_c">C</code></td>
<td>
<p>an optional number determining the starting point of the X-by-Y search-grid. When trying to partition the x-axis into X columns, the algorithm will start with at most C X clumps. Default value is 15.</p>
</td></tr>
<tr><td><code id="c_mine_+3A_var.thr">var.thr</code></td>
<td>
<p>minimum value allowed for the variance of the input variables, since mine can not be computed in case of variance close to 0. Default value is 1e-5.</p>
</td></tr>
<tr><td><code id="c_mine_+3A_zeta">zeta</code></td>
<td>
<p>integer in [0,1] (?).  If NULL (default) it is set to 1-MIC. It can be set to zero for noiseless functions, but the default choice is the most appropriate parametrization for general cases (as stated in Reshef et al. SOM; they call it epsilon in the paper). It provides robustness.</p>
</td></tr>
</table>

<hr>
<h2 id='c_nonmonotonicity'>c-nonmonotonicity
calculates the c-nonmonotonicity based on the maximum asymmetric score 
We define c-nonmonotonicity as the aggregated nonmonotonicity between any two columns in confs
this is one of few c-structuredness indices not between 0 and 1</h2><span id='topic+c_nonmonotonicity'></span>

<h3>Description</h3>

<p>c-nonmonotonicity
calculates the c-nonmonotonicity based on the maximum asymmetric score 
We define c-nonmonotonicity as the aggregated nonmonotonicity between any two columns in confs
this is one of few c-structuredness indices not between 0 and 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_nonmonotonicity(
  confs,
  aggr = max,
  alpha = 1,
  C = 15,
  var.thr = 1e-05,
  zeta = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_nonmonotonicity_+3A_confs">confs</code></td>
<td>
<p>a numeric matrix or data frame</p>
</td></tr>
<tr><td><code id="c_nonmonotonicity_+3A_aggr">aggr</code></td>
<td>
<p>the aggregation function for configurations of more than two dimensions. Defaults to max.</p>
</td></tr>
<tr><td><code id="c_nonmonotonicity_+3A_alpha">alpha</code></td>
<td>
<p>an optional number of cells allowed in the X-by-Y search-grid. Default value is 1</p>
</td></tr>
<tr><td><code id="c_nonmonotonicity_+3A_c">C</code></td>
<td>
<p>an optional number determining the starting point of the X-by-Y search-grid. When trying to partition the x-axis into X columns, the algorithm will start with at most C X clumps. Default value is 15.</p>
</td></tr>
<tr><td><code id="c_nonmonotonicity_+3A_var.thr">var.thr</code></td>
<td>
<p>minimum value allowed for the variance of the input variables, since mine can not be computed in case of variance close to 0. Default value is 1e-5.</p>
</td></tr>
<tr><td><code id="c_nonmonotonicity_+3A_zeta">zeta</code></td>
<td>
<p>integer in [0,1] (?).  If NULL (default) it is set to 1-MIC. It can be set to zero for noiseless functions, but the default choice is the most appropriate parametrization for general cases (as stated in Reshef et al. SOM). It provides robustness.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; nonmonotonicity (aggregated maximal asymmetric score MAS, see <code><a href="minerva.html#topic+mine">mine</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-seq(-3,3,length.out=200)
y&lt;-sqrt(3^2-x^2)
z&lt;- sin(y-x)
confs&lt;-cbind(x,y,z)
c_nonmonotonicity(confs)
</code></pre>

<hr>
<h2 id='c_outlying'>c-outlying</h2><span id='topic+c_outlying'></span>

<h3>Description</h3>

<p>Measures the c-outlying structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_outlying(conf, aggr = max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_outlying_+3A_conf">conf</code></td>
<td>
<p>A numeric matrix.</p>
</td></tr>
<tr><td><code id="c_outlying_+3A_aggr">aggr</code></td>
<td>
<p>the aggregation function for configurations of more than two dimensions. Defaults to max.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; outlying (see <code><a href="scagnostics.html#topic+scagnostics">scagnostics</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delts&lt;-smacof::kinshipdelta
conf3&lt;-smacof::smacofSym(delts,ndim=3)$conf
c_outlying(conf3)
</code></pre>

<hr>
<h2 id='c_regularity'>c-regularity 
calculates c-regularity as 1 - OPTICS cordillera for k=2. The higher the more regular.</h2><span id='topic+c_regularity'></span>

<h3>Description</h3>

<p>c-regularity 
calculates c-regularity as 1 - OPTICS cordillera for k=2. The higher the more regular.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_regularity(
  confs,
  q = 1,
  epsilon = 2 * max(dist(confs)),
  distmeth = "euclidean",
  dmax = NULL,
  digits = 10,
  scale = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_regularity_+3A_confs">confs</code></td>
<td>
<p>a numeric matrix or a dist object</p>
</td></tr>
<tr><td><code id="c_regularity_+3A_q">q</code></td>
<td>
<p>The norm used for the Cordillera. Defaults to 1 (and should always be 1 imo).</p>
</td></tr>
<tr><td><code id="c_regularity_+3A_epsilon">epsilon</code></td>
<td>
<p>The epsilon parameter for OPTICS (called epsilon_max in the paper). Defaults to 2 times the maximum distance between any two points.</p>
</td></tr>
<tr><td><code id="c_regularity_+3A_distmeth">distmeth</code></td>
<td>
<p>The distance to be computed if X is not a symmetric matrix or a dist object (otherwise ignored). Defaults to Euclidean distance.</p>
</td></tr>
<tr><td><code id="c_regularity_+3A_dmax">dmax</code></td>
<td>
<p>The winsorization value for the highest allowed reachability. If used for comparisons this should be supplied. If no value is supplied, it is NULL (default), then dmax is taken from the data as minimum of epsilon or the largest reachability.</p>
</td></tr>
<tr><td><code id="c_regularity_+3A_digits">digits</code></td>
<td>
<p>The precision to round the raw Cordillera and the norm factor. Defaults to 10.</p>
</td></tr>
<tr><td><code id="c_regularity_+3A_scale">scale</code></td>
<td>
<p>Should X be scaled if it is an asymmetric matrix or data frame? Can take values TRUE or FALSE or a numeric value. If TRUE or 1, standardisation is to mean=0 and sd=1. If 2, no centering is applied and scaling of each column is done with the root mean square of each column. If 3, no centering is applied and scaling of all columns is done as X/max(standard deviation(allcolumns)). If 4, no centering is applied and scaling of all columns is done as X/max(rmsq(allcolumns)). If FALSE, 0 or any other numeric value, no standardisation is applied. Defaults to 0.</p>
</td></tr>
<tr><td><code id="c_regularity_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="cordillera.html#topic+cordillera">cordillera</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; regularity
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hpts&lt;-expand.grid(seq(-5,5),seq(-5,5))
c_regularity(hpts)
hpts2&lt;-cbind(jitter(hpts[,1]),jitter(hpts[,2]))
c_regularity(hpts2)
</code></pre>

<hr>
<h2 id='c_shepardness'>c-shepardness 
calculates the c-shepardness as the correlation between a loess smoother of the transformed distances and the transformed dissimilarities</h2><span id='topic+c_shepardness'></span>

<h3>Description</h3>

<p>c-shepardness 
calculates the c-shepardness as the correlation between a loess smoother of the transformed distances and the transformed dissimilarities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_shepardness(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_shepardness_+3A_object">object</code></td>
<td>
<p>an object of class smacofP</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delts&lt;-smacof::kinshipdelta
res&lt;-smacofx::postmds(delts)
c_shepardness(res)
</code></pre>

<hr>
<h2 id='c_skinniness'>c-skinniness</h2><span id='topic+c_skinniness'></span>

<h3>Description</h3>

<p>Measures the c-skinniness structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_skinniness(conf, aggr = max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_skinniness_+3A_conf">conf</code></td>
<td>
<p>A numeric matrix.</p>
</td></tr>
<tr><td><code id="c_skinniness_+3A_aggr">aggr</code></td>
<td>
<p>the aggregation function for configurations of more than two dimensions. Defaults to max.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; skinniness (see <code><a href="scagnostics.html#topic+scagnostics">scagnostics</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delts&lt;-smacof::kinshipdelta
conf&lt;-smacof::smacofSym(delts)$conf
plot(conf,pch=19,asp=1)
c_skinniness(conf)
</code></pre>

<hr>
<h2 id='c_sparsity'>c-sparsity</h2><span id='topic+c_sparsity'></span>

<h3>Description</h3>

<p>Measures the c-sparsity structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_sparsity(conf, aggr = max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_sparsity_+3A_conf">conf</code></td>
<td>
<p>A numeric matrix.</p>
</td></tr>
<tr><td><code id="c_sparsity_+3A_aggr">aggr</code></td>
<td>
<p>the aggregation function for configurations of more than two dimensions. Defaults to max.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; sparsity (see <code><a href="scagnostics.html#topic+scagnostics">scagnostics</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delts&lt;-smacof::kinshipdelta
conf&lt;-smacof::smacofSym(delts)$conf
plot(conf,pch=19,asp=1)
c_sparsity(conf)
</code></pre>

<hr>
<h2 id='c_striatedness'>c-striatedness</h2><span id='topic+c_striatedness'></span>

<h3>Description</h3>

<p>Measures the c-striatedness structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_striatedness(conf, aggr = max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_striatedness_+3A_conf">conf</code></td>
<td>
<p>A numeric matrix.</p>
</td></tr>
<tr><td><code id="c_striatedness_+3A_aggr">aggr</code></td>
<td>
<p>the aggregation function for configurations of more than two dimensions. Defaults to max.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; striatedness (see <code><a href="scagnostics.html#topic+scagnostics">scagnostics</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delts&lt;-smacof::kinshipdelta
conf&lt;-smacof::smacofSym(delts)$conf
plot(conf,pch=19,asp=1)
c_striatedness(conf)
</code></pre>

<hr>
<h2 id='c_stringiness'>c-stringiness</h2><span id='topic+c_stringiness'></span>

<h3>Description</h3>

<p>Measures the c-stringiness structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_stringiness(conf, aggr = max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_stringiness_+3A_conf">conf</code></td>
<td>
<p>A numeric matrix.</p>
</td></tr>
<tr><td><code id="c_stringiness_+3A_aggr">aggr</code></td>
<td>
<p>the aggregation function for configurations of more than two dimensions. Defaults to max.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; stringiness (see <code><a href="scagnostics.html#topic+scagnostics">scagnostics</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delts&lt;-smacof::kinshipdelta
conf&lt;-smacof::smacofSym(delts)$conf
plot(conf,pch=19,asp=1)
c_stringiness(conf)
</code></pre>

<hr>
<h2 id='coef.stops'>S3 coef method for stops objects</h2><span id='topic+coef.stops'></span>

<h3>Description</h3>

<p>S3 coef method for stops objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stops'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.stops_+3A_object">object</code></td>
<td>
<p>object of class stops</p>
</td></tr>
<tr><td><code id="coef.stops_+3A_...">...</code></td>
<td>
<p>addditional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of hyperparmeters theta
</p>

<hr>
<h2 id='jackmds.stops'>MDS Jackknife for stops objects</h2><span id='topic+jackmds.stops'></span>

<h3>Description</h3>

<p>These functions perform an MDS Jackknife and plot the corresponding solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stops'
jackmds(object, eps = 1e-06, itmax = 100, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jackmds.stops_+3A_object">object</code></td>
<td>
<p>Object of class pcops.</p>
</td></tr>
<tr><td><code id="jackmds.stops_+3A_eps">eps</code></td>
<td>
<p>Convergence criterion</p>
</td></tr>
<tr><td><code id="jackmds.stops_+3A_itmax">itmax</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="jackmds.stops_+3A_verbose">verbose</code></td>
<td>
<p>If 'TRUE', intermediate stress is printed out.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to examine the stability solution of an MDS, a Jackknife on the configurations can be performed (see de Leeuw &amp; Meulman, 1986) and plotted. The plot shows the jackknife configurations which are connected to their centroid. In addition, the original configuration (transformed through Procrustes) is plotted. The Jackknife function itself returns also a stability measure (as ratio of between and total variance), a measure for cross validity, and the dispersion around the original smacof solution.
</p>
<p>Note that this jackknife only resamples the configuration given the selected hyperparameters, so uncertainty with respect to the hyperparameter selection is not incorporated.
</p>


<h3>Value</h3>

<p>An object of class 'smacofJK', see <code><a href="smacof.html#topic+jackmds">jackmds</a></code>. With values 
</p>

<ul>
<li><p> smacof.conf: Original configuration
</p>
</li>
<li><p> jackknife.confboot: An array of n-1 configuration matrices for each Jackknife MDS solution
</p>
</li>
<li><p> comparison.conf: Centroid Jackknife configurations (comparison matrix)
</p>
</li>
<li><p> cross: Cross validity
</p>
</li>
<li><p> stab: Stability coefficient
</p>
</li>
<li><p> disp: Dispersion
</p>
</li>
<li><p> loss: Value of the loss function (just used internally)
</p>
</li>
<li><p> ndim: Number of dimensions
</p>
</li>
<li><p> call: Model call
</p>
</li>
<li><p> niter: Number of iterations
</p>
</li>
<li><p> nobj: Number of objects
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>diso&lt;-kinshipdelta
fit &lt;- stops(diso,loss="powermds",lower=c(1,1),upper=c(5,5),itmaxps=100)
res.jk &lt;- jackmds(fit)
plot(res.jk)
</code></pre>

<hr>
<h2 id='knn_dist'>calculate k nearest neighbours from a distance matrix</h2><span id='topic+knn_dist'></span>

<h3>Description</h3>

<p>calculate k nearest neighbours from a distance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knn_dist(dis, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knn_dist_+3A_dis">dis</code></td>
<td>
<p>distance matrix</p>
</td></tr>
<tr><td><code id="knn_dist_+3A_k">k</code></td>
<td>
<p>number of nearest neighbours (Note that with a tie, the function returns the alphanumerically first one!)</p>
</td></tr>
</table>

<hr>
<h2 id='ljoptim'>(Adaptive) Version of Luus-Jaakola Optimization</h2><span id='topic+ljoptim'></span>

<h3>Description</h3>

<p>Adaptive means that the search space reduction factors in the number of iterations; makes convergence faster at about 100 iterations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ljoptim(
  x,
  fun,
  ...,
  red = ifelse(adaptive, 0.99, 0.95),
  lower,
  upper,
  acc = 1e-06,
  accd = 1e-04,
  itmax = 1000,
  verbose = 0,
  adaptive = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ljoptim_+3A_x">x</code></td>
<td>
<p>optional starting values</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_fun">fun</code></td>
<td>
<p>function to minimize</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the function to be optimized</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_red">red</code></td>
<td>
<p>value of the reduction of the search region</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_lower">lower</code></td>
<td>
<p>The lower contraints of the search region</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_upper">upper</code></td>
<td>
<p>The upper contraints of the search region</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_acc">acc</code></td>
<td>
<p>if the numerical accuracy of two successive target function values is below this, stop the optimization; defaults to 1e-6</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_accd">accd</code></td>
<td>
<p>if the width of the search space is below this, stop the optimization; defaults to 1e-4</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_adaptive">adaptive</code></td>
<td>
<p>should the adaptive version be used? defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components (<code><a href="stats.html#topic+optim">optim</a></code>)
</p>

<ul>
<li><p> par The position of the optimimum in the search space (parameters that minimize the function; argmin fun)
</p>
</li>
<li><p> value The value of the objective function at the optimum (min fun)
</p>
</li>
<li><p> counts The number of iterations performed at convergence with entries fnction for the number of iterations and gradient which is always NA at the moment
</p>
</li>
<li><p> convergence 0 successful completion by the accd or acc criterion, 1 indicate iteration limit was reached, 99 is a problem 
</p>
</li>
<li><p> message is NULL (only for compatibility or future use)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>fbana &lt;- function(x) {
x1 &lt;- x[1]
x2 &lt;- x[2]
100 * (x2 - x1 * x1)^2 + (1 - x1)^2
}
res1&lt;-ljoptim(c(-1.2,1),fbana,lower=-5,upper=5,accd=1e-16,acc=1e-16)
res1

set.seed(210485)
fwild &lt;- function (x) 10*sin(0.3*x)*sin(1.3*x^2) + 0.00001*x^4 + 0.2*x+80
plot(fwild, -50, 50, n = 1000, main = "ljoptim() minimising 'wild function'")
res2&lt;-ljoptim(50, fwild,lower=-50,upper=50,adaptive=FALSE,accd=1e-16,acc=1e-16)
points(res2$par,res2$value,col="red",pch=19)
res2

</code></pre>

<hr>
<h2 id='Pendigits500'>Pen digits</h2><span id='topic+Pendigits500'></span>

<h3>Description</h3>

<p>These data are a random sample of 500 of the 10992 pendigits data from Alimoglu (1996). The original data were from 44 writers who handwrote 250 times the digits 0,...,9. The digits were written inside a rectangular box with a resolution of 500 x 500 pixels and the first 10 per writer were ignored for further analysis. This led to 10992 digits. They were recorded in small time intervals by following the trajectory of the pen on the 500 x 500 grid and then normalized. From the normalized trajectory 8 points (x and y axis position) were randomly selected for each handwritten digit, leading to 16 predictors variables. We extarcted a random sample of 500 of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Pendigits500)
</code></pre>


<h3>Format</h3>

<p>A data frame with 500 rows and 17 variables
</p>


<h3>Details</h3>

<p>The variables are
</p>

<ul>
<li><p> The rownames of Pendigits500 refer to the data point of the 10992 original data
</p>
</li>
<li><p> V1-V16: trajectory points (x, y coordinate) of the grid
</p>
</li>
<li><p> digits: The digit actually written (the label)
</p>
</li></ul>



<h3>Source</h3>

<p>From A. Izenman (2010) Modern multivariate statistical techniques. Springer.
</p>

<hr>
<h2 id='plot.stops'>S3 plot method for stops objects</h2><span id='topic+plot.stops'></span>

<h3>Description</h3>

<p>S3 plot method for stops objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stops'
plot(x, plot.type = "confplot", main, asp = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.stops_+3A_x">x</code></td>
<td>
<p>an object of class stops</p>
</td></tr>
<tr><td><code id="plot.stops_+3A_plot.type">plot.type</code></td>
<td>
<p>String indicating which type of plot to be produced: &quot;confplot&quot;, &quot;resplot&quot;, &quot;Shepard&quot;, &quot;stressplot&quot;, &quot;bubbleplot&quot; (see details)</p>
</td></tr>
<tr><td><code id="plot.stops_+3A_main">main</code></td>
<td>
<p>the main title of the plot</p>
</td></tr>
<tr><td><code id="plot.stops_+3A_asp">asp</code></td>
<td>
<p>aspect ratio of x/y axis; defaults to 1; setting to 1 will lead to an accurate represenation of the fitted distances.</p>
</td></tr>
<tr><td><code id="plot.stops_+3A_...">...</code></td>
<td>
<p>Further plot arguments passed: see 'plot.smacof' and 'plot' for detailed information.
</p>
<p>Details:
See plot.smacofP</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value, just plots
</p>

<hr>
<h2 id='print.stops'>S3 print method for stops objects</h2><span id='topic+print.stops'></span>

<h3>Description</h3>

<p>S3 print method for stops objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stops'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.stops_+3A_x">x</code></td>
<td>
<p>stops object</p>
</td></tr>
<tr><td><code id="print.stops_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value, just prints
</p>

<hr>
<h2 id='print.summary.stops'>S3 print method for summary.stops</h2><span id='topic+print.summary.stops'></span>

<h3>Description</h3>

<p>S3 print method for summary.stops
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.stops'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.stops_+3A_x">x</code></td>
<td>
<p>object of class summary.stops</p>
</td></tr>
<tr><td><code id="print.summary.stops_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value, just prints
</p>

<hr>
<h2 id='residuals.stops'>S3 residuals method for stops</h2><span id='topic+residuals.stops'></span>

<h3>Description</h3>

<p>S3 residuals method for stops
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stops'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.stops_+3A_object">object</code></td>
<td>
<p>object of class stops</p>
</td></tr>
<tr><td><code id="residuals.stops_+3A_...">...</code></td>
<td>
<p>addditional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of residuals (observed minus fitted distances)
</p>

<hr>
<h2 id='stop_apstress'>STOPS version of approximated power stress models.</h2><span id='topic+stop_apstress'></span>

<h3>Description</h3>

<p>This uses an approximation to power stress that can make use of smacof as workhorse. Free parameters are kappa, lambda and nu.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_apstress(
  dis,
  theta = c(1, 1, 1),
  type = "ratio",
  ndim = 2,
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  itmaxi = 1000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  stoptype = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_apstress_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_apstress_+3A_theta">theta</code></td>
<td>
<p>the theta vector of parameters to optimize over. Must be of length three, with the first the kappa argument, the second the lambda argument and the third the nu argument. One cannot supply upsilon and tau as of yet. Defaults to 1 1 1.</p>
</td></tr>
<tr><td><code id="stop_apstress_+3A_type">type</code></td>
<td>
<p>MDS type.</p>
</td></tr>
<tr><td><code id="stop_apstress_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_apstress_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a binary matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_apstress_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_apstress_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. default is 1000.</p>
</td></tr>
<tr><td><code id="stop_apstress_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_apstress_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_apstress_+3A_structures">structures</code></td>
<td>
<p>a character vector listing the structure indices to use. They always are called &quot;cfoo&quot; with foo being the structure.</p>
</td></tr>
<tr><td><code id="stop_apstress_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structures; defaults to 1/number of structures</p>
</td></tr>
<tr><td><code id="stop_apstress_+3A_strucpars">strucpars</code></td>
<td>
<p>a list of list of parameters for the structuredness indices; each list element corresponds to one index in the order of the appearance in structures vector. See examples.</p>
</td></tr>
<tr><td><code id="stop_apstress_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_apstress_+3A_stoptype">stoptype</code></td>
<td>
<p>which weighting to be used in the multi-objective optimization? Either 'additive' (default) or 'multiplicative'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: the stress-1 value (sqrt stress.m)
</p>
</li>
<li><p>stress.m: default normalized stress
</p>
</li>
<li><p> stoploss: the weighted loss value
</p>
</li>
<li><p> struc: the structuredness indices
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda, nu)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object 
</p>
</li></ul>


<hr>
<h2 id='stop_bcmds'>STOPS version of Box Cox Stress</h2><span id='topic+stop_bcmds'></span>

<h3>Description</h3>

<p>STOPS version of Box Cox Stress
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_bcmds(
  dis,
  theta = c(1, 1, 0),
  type = "ratio",
  weightmat = NULL,
  init = NULL,
  ndim = 2,
  itmaxi = 5000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  stoptype = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_bcmds_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_bcmds_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; the first is mu (for the fitted distances), the second lambda (for the  proximities), the third nu (for the weights). If a scalar is given it is recycled.  Defaults to 1 1 0.</p>
</td></tr>
<tr><td><code id="stop_bcmds_+3A_type">type</code></td>
<td>
<p>MDS type. Is ignored here.</p>
</td></tr>
<tr><td><code id="stop_bcmds_+3A_weightmat">weightmat</code></td>
<td>
<p>(not used)</p>
</td></tr>
<tr><td><code id="stop_bcmds_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_bcmds_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_bcmds_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_bcmds_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_bcmds_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_bcmds_+3A_structures">structures</code></td>
<td>
<p>which structures to look for</p>
</td></tr>
<tr><td><code id="stop_bcmds_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structures; defaults to 0.5</p>
</td></tr>
<tr><td><code id="stop_bcmds_+3A_strucpars">strucpars</code></td>
<td>
<p>a list of parameters for the structuredness indices; each list element corresponds to one index in the order of the appeacrance in structures</p>
</td></tr>
<tr><td><code id="stop_bcmds_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_bcmds_+3A_stoptype">stoptype</code></td>
<td>
<p>which weighting to be used in the multi-objective optimization? Either 'additive' (default) or 'multiplicative'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress-1
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> stoploss: the weighted loss value
</p>
</li>
<li><p> struc: the structuredness indices
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object 
</p>
</li></ul>


<hr>
<h2 id='stop_clca'>STOPS version of CLCA.</h2><span id='topic+stop_clca'></span>

<h3>Description</h3>

<p>CLCA with free lambda0 and 20 epochs. Should we add alpha0?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_clca(
  dis,
  theta = 3 * max(sd(dis)),
  type = "ratio",
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  ndim = 2,
  itmaxi = 10000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  stoptype = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_clca_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_clca_+3A_theta">theta</code></td>
<td>
<p>the theta vector of explicit parameters; lambda0 for the maximal neighbourhood. Defaults to 100.</p>
</td></tr>
<tr><td><code id="stop_clca_+3A_type">type</code></td>
<td>
<p>MDS type.</p>
</td></tr>
<tr><td><code id="stop_clca_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_clca_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_clca_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_clca_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_clca_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_clca_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_clca_+3A_structures">structures</code></td>
<td>
<p>a character vector listing the structure indices to use. They always are called &quot;cfoo&quot; with foo being the structure.</p>
</td></tr>
<tr><td><code id="stop_clca_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structures; defaults to 1/number of structures</p>
</td></tr>
<tr><td><code id="stop_clca_+3A_strucpars">strucpars</code></td>
<td>
<p>a list of parameters for the structuredness indices; each list element corresponds to one index in the order of the appearance in structures</p>
</td></tr>
<tr><td><code id="stop_clca_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_clca_+3A_stoptype">stoptype</code></td>
<td>
<p>which weighting to be used in the multi-objective optimization? Either 'additive' (default) or 'multiplicative'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress-1 value
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> stoploss: the weighted loss value
</p>
</li>
<li><p> struc: the structuredness indices
</p>
</li>
<li><p> parameters: the parameters used for fitting (tau)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object 
</p>
</li></ul>


<hr>
<h2 id='stop_cldae'>STOPS version of CLDA with free epsilon.</h2><span id='topic+stop_cldae'></span>

<h3>Description</h3>

<p>CLDA with free lambda0 and epsilon and 20 epochs. Should we add alpha0?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_cldae(
  dis,
  theta = rep(3 * max(sd(dis)), 2),
  type = "ratio",
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  ndim = 2,
  itmaxi = 10000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  stoptype = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_cldae_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_cldae_+3A_theta">theta</code></td>
<td>
<p>the theta vector of explicit parameters; first is lambda0 for the maximal neighbourhood and second is k for the number of neighbours for the geodesic distance.</p>
</td></tr>
<tr><td><code id="stop_cldae_+3A_type">type</code></td>
<td>
<p>MDS type.</p>
</td></tr>
<tr><td><code id="stop_cldae_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_cldae_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_cldae_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_cldae_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_cldae_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_cldae_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_cldae_+3A_structures">structures</code></td>
<td>
<p>a character vector listing the structure indices to use. They always are called &quot;cfoo&quot; with foo being the structure.</p>
</td></tr>
<tr><td><code id="stop_cldae_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structures; defaults to 1/number of structures</p>
</td></tr>
<tr><td><code id="stop_cldae_+3A_strucpars">strucpars</code></td>
<td>
<p>a list of parameters for the structuredness indices; each list element corresponds to one index in the order of the appearance in structures</p>
</td></tr>
<tr><td><code id="stop_cldae_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_cldae_+3A_stoptype">stoptype</code></td>
<td>
<p>which weighting to be used in the multi-objective optimization? Either 'additive' (default) or 'multiplicative'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress-1 value
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> stoploss: the weighted loss value
</p>
</li>
<li><p> struc: the structuredness indices
</p>
</li>
<li><p> parameters: the parameters used for fitting (tau)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object 
</p>
</li></ul>


<hr>
<h2 id='stop_cldak'>STOPS version of CLDA with free k.</h2><span id='topic+stop_cldak'></span>

<h3>Description</h3>

<p>CLDA with free lambda0 and k and 20 epochs. Should we add alpha0?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_cldak(
  dis,
  theta = c(3 * max(sd(dis)), nrow(dis)/4),
  type = "ratio",
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  ndim = 2,
  itmaxi = 10000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  stoptype = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_cldak_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_cldak_+3A_theta">theta</code></td>
<td>
<p>the theta vector of explicit parameters; first is lambda0 for the maximal neighbourhood and second is k for the number of neighbours for the geodesic distance.</p>
</td></tr>
<tr><td><code id="stop_cldak_+3A_type">type</code></td>
<td>
<p>MDS type.</p>
</td></tr>
<tr><td><code id="stop_cldak_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_cldak_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_cldak_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_cldak_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_cldak_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_cldak_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_cldak_+3A_structures">structures</code></td>
<td>
<p>a character vector listing the structure indices to use. They always are called &quot;cfoo&quot; with foo being the structure.</p>
</td></tr>
<tr><td><code id="stop_cldak_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structures; defaults to 1/number of structures</p>
</td></tr>
<tr><td><code id="stop_cldak_+3A_strucpars">strucpars</code></td>
<td>
<p>a list of parameters for the structuredness indices; each list element corresponds to one index in the order of the appearance in structures</p>
</td></tr>
<tr><td><code id="stop_cldak_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_cldak_+3A_stoptype">stoptype</code></td>
<td>
<p>which weighting to be used in the multi-objective optimization? Either 'additive' (default) or 'multiplicative'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress-1 value
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> stoploss: the weighted loss value
</p>
</li>
<li><p> struc: the structuredness indices
</p>
</li>
<li><p> parameters: the parameters used for fitting (tau)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object 
</p>
</li></ul>


<hr>
<h2 id='stop_cmdscale'>STOPS version of strain</h2><span id='topic+stop_cmdscale'></span>

<h3>Description</h3>

<p>The free parameter is lambda for power transformations of the observed proximities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_cmdscale(
  dis,
  theta = 1,
  type = "ratio",
  weightmat = NULL,
  ndim = 2,
  init = NULL,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  stoptype = c("additive", "multiplicative"),
  itmaxi = 1000,
  add = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_cmdscale_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_cmdscale_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; this must be a scalar of the lambda transformation for the observed proximities.</p>
</td></tr>
<tr><td><code id="stop_cmdscale_+3A_type">type</code></td>
<td>
<p>MDS type. Ignored here.</p>
</td></tr>
<tr><td><code id="stop_cmdscale_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights. Not used.</p>
</td></tr>
<tr><td><code id="stop_cmdscale_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_cmdscale_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_cmdscale_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_cmdscale_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_cmdscale_+3A_structures">structures</code></td>
<td>
<p>which structuredness indices to be included in the loss</p>
</td></tr>
<tr><td><code id="stop_cmdscale_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structuredness indices; ; defaults to 1/#number of structures</p>
</td></tr>
<tr><td><code id="stop_cmdscale_+3A_strucpars">strucpars</code></td>
<td>
<p>the parameters for the structuredness indices</p>
</td></tr>
<tr><td><code id="stop_cmdscale_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_cmdscale_+3A_stoptype">stoptype</code></td>
<td>
<p>How to construct the target function for the multi objective optimization? Either 'additive' (default) or 'multiplicative'</p>
</td></tr>
<tr><td><code id="stop_cmdscale_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. No effect here.</p>
</td></tr>
<tr><td><code id="stop_cmdscale_+3A_add">add</code></td>
<td>
<p>if TRUE dis is made to Euclidean disatnces</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: the badness-of-fit value (this isn't stress here but 1-(sum_ndim(max(eigenvalues,0))/sum_n(max(eigenvalues,0)), 1-GOF[2])
</p>
</li>
<li><p>stress.m: explictly normalized stress (manually calculated)
</p>
</li>
<li><p>stoploss: the weighted loss value
</p>
</li>
<li><p>indices: the values of the structuredness indices
</p>
</li>
<li><p>parameters: the parameters used for fitting (lambda)
</p>
</li>
<li><p>fit: the returned object of the fitting procedure, which is cmdscalex object with some extra slots for the parameters and stresses
</p>
</li>
<li><p>stopobj: the stopobj object
</p>
</li></ul>


<hr>
<h2 id='stop_elastic'>STOPS versions of elastic scaling models (via smacofSym)</h2><span id='topic+stop_elastic'></span>

<h3>Description</h3>

<p>The free parameter is lambda for power transformations the observed proximities. The fitted distances power is internally fixed to 1 and the power for the weights=delta is -2. Allows for a weight matrix because of smacof.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_elastic(
  dis,
  theta = 1,
  type = "ratio",
  ndim = 2,
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  itmaxi = 1000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  stoptype = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_elastic_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_elastic_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; this must be a scalar of the lambda transformation for the observed proximities. Defaults to 1.</p>
</td></tr>
<tr><td><code id="stop_elastic_+3A_type">type</code></td>
<td>
<p>MDS type. Defaults ot 'ratio'.</p>
</td></tr>
<tr><td><code id="stop_elastic_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_elastic_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights (NOT the elscal weights)</p>
</td></tr>
<tr><td><code id="stop_elastic_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_elastic_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_elastic_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_elastic_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_elastic_+3A_structures">structures</code></td>
<td>
<p>which structuredness indices to be included in the loss</p>
</td></tr>
<tr><td><code id="stop_elastic_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structuredness indices; ; defaults to 1/#number of structures</p>
</td></tr>
<tr><td><code id="stop_elastic_+3A_strucpars">strucpars</code></td>
<td>
<p>the parameters for the structuredness indices</p>
</td></tr>
<tr><td><code id="stop_elastic_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_elastic_+3A_stoptype">stoptype</code></td>
<td>
<p>How to construct the target function for the multi objective optimization? Either 'additive' (default) or 'multiplicative'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: the stress-1 (sqrt(stress.m))
</p>
</li>
<li><p>stress.m: default normalized stress (used for STOPS)
</p>
</li>
<li><p>stoploss: the weighted loss value
</p>
</li>
<li><p>indices: the values of the structuredness indices
</p>
</li>
<li><p>parameters: the parameters used for fitting (lambda)
</p>
</li>
<li><p>fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj objects
</p>
</li></ul>


<hr>
<h2 id='stop_isomap1'>STOPS version of isomap to optimize over integer k.</h2><span id='topic+stop_isomap1'></span>

<h3>Description</h3>

<p>Free parameter is k.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_isomap1(
  dis,
  theta = 3,
  type = "ratio",
  weightmat = NULL,
  ndim = 2,
  init = NULL,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  stoptype = c("additive", "multiplicative"),
  itmaxi = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_isomap1_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_isomap1_+3A_theta">theta</code></td>
<td>
<p>the number of shortest dissimilarities retained for a point (nearest neighbours), the isomap parameter. Must be a numeric scalar. Defaults to 3.</p>
</td></tr>
<tr><td><code id="stop_isomap1_+3A_type">type</code></td>
<td>
<p>MDS type. Is &quot;ratio&quot;.</p>
</td></tr>
<tr><td><code id="stop_isomap1_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_isomap1_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_isomap1_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_isomap1_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_isomap1_+3A_structures">structures</code></td>
<td>
<p>which structuredness indices to be included in the loss</p>
</td></tr>
<tr><td><code id="stop_isomap1_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structuredness indices; ; defaults to 1/#number of structures</p>
</td></tr>
<tr><td><code id="stop_isomap1_+3A_strucpars">strucpars</code></td>
<td>
<p>the parameters for the structuredness indices</p>
</td></tr>
<tr><td><code id="stop_isomap1_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_isomap1_+3A_stoptype">stoptype</code></td>
<td>
<p>How to construct the target function for the multi objective optimization? Either 'additive' (default) or 'multiplicative'</p>
</td></tr>
<tr><td><code id="stop_isomap1_+3A_itmaxi">itmaxi</code></td>
<td>
<p>placeholder for compatibility in stops call; not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently this version is a bit less flexible than the vegan one, as the only allowed parameter for isomap is the theta (k in isomap, no epsilon) and the shortest path is always estimated with argument &quot;shortest&quot;. Also note that fragmentedOK is always set to TRUE which means that for theta that is too small only the largest conected group will be analyzed. If that's not wanted just set the theta higher.
</p>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: Not really stress but 1-GOF[2] where GOF is the second element returned from smacofx::cmdscale (the sum of the first ndim eigenvalues divided by the sum of all absolute eigenvalues).
</p>
</li>
<li><p>stress.m: default normalized stress (sqrt explicitly normalized stress; really the stress this time)
</p>
</li>
<li><p>stoploss: the weighted loss value
</p>
</li>
<li><p>indices: the values of the structuredness indices
</p>
</li>
<li><p>parameters: the parameters used for fitting 
</p>
</li>
<li><p>fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object
</p>
</li></ul>


<hr>
<h2 id='stop_isomap2'>STOPS version of isomap over real epsilon.</h2><span id='topic+stop_isomap2'></span>

<h3>Description</h3>

<p>Free parameter is eps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_isomap2(
  dis,
  theta = stats::quantile(dis, 0.1),
  type = "ratio",
  weightmat = NULL,
  ndim = 2,
  init = NULL,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  stoptype = c("additive", "multiplicative"),
  itmaxi = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_isomap2_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_isomap2_+3A_theta">theta</code></td>
<td>
<p>the number of shortest dissimilarities retained for a point (neighbourhood region), the isomap parameter. Defaults to the 0.1 quantile of the empirical distribution of dis.</p>
</td></tr>
<tr><td><code id="stop_isomap2_+3A_type">type</code></td>
<td>
<p>MDS type. Is &quot;ratio&quot;.</p>
</td></tr>
<tr><td><code id="stop_isomap2_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_isomap2_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_isomap2_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_isomap2_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_isomap2_+3A_structures">structures</code></td>
<td>
<p>which structuredness indices to be included in the loss</p>
</td></tr>
<tr><td><code id="stop_isomap2_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structuredness indices; ; defaults to 1/#number of structures</p>
</td></tr>
<tr><td><code id="stop_isomap2_+3A_strucpars">strucpars</code></td>
<td>
<p>the parameters for the structuredness indices</p>
</td></tr>
<tr><td><code id="stop_isomap2_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_isomap2_+3A_stoptype">stoptype</code></td>
<td>
<p>How to construct the target function for the multi objective optimization? Either 'additive' (default) or 'multiplicative'</p>
</td></tr>
<tr><td><code id="stop_isomap2_+3A_itmaxi">itmaxi</code></td>
<td>
<p>placeholder for compatibility in stops call; not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently this version is a bit less flexible than the vegan one, as the only allowed parameter for isomap is the theta (epsilon in isomap) and the shortest path is always estimated with argument &quot;shortest&quot;. Also note that fragmentedOK is always set to TRUE which means that for theta that is too small only the largest conected group will be analyzed. If that's not wanted just set the theta higher.
</p>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: Not really stress but 1-GOF[2] where GOF is the second element returned from cmdscale (the sum of the first ndim absolute eigenvalues divided by the sum of all absolute eigenvalues).
</p>
</li>
<li><p>stress.m: default normalized stress (sqrt explicitly normalized stress; really the stress this time)
</p>
</li>
<li><p>stoploss: the weighted loss value
</p>
</li>
<li><p>indices: the values of the structuredness indices
</p>
</li>
<li><p>parameters: the parameters used for fitting 
</p>
</li>
<li><p>fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object
</p>
</li></ul>


<hr>
<h2 id='stop_lmds'>STOPS version of lMDS</h2><span id='topic+stop_lmds'></span>

<h3>Description</h3>

<p>STOPS version of lMDS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_lmds(
  dis,
  theta = c(2, 0.5),
  type = "ratio",
  weightmat = NULL,
  init = NULL,
  ndim = 2,
  itmaxi = 5000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  stoptype = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_lmds_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_lmds_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; the first is k (for the neighbourhood), the second tau (for the penalty) . If a scalar is given it is recycled.  Defaults to 2 and 0.5.</p>
</td></tr>
<tr><td><code id="stop_lmds_+3A_type">type</code></td>
<td>
<p>MDS type. Ignored.</p>
</td></tr>
<tr><td><code id="stop_lmds_+3A_weightmat">weightmat</code></td>
<td>
<p>(not used)</p>
</td></tr>
<tr><td><code id="stop_lmds_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_lmds_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_lmds_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_lmds_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_lmds_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_lmds_+3A_structures">structures</code></td>
<td>
<p>which structures to look for</p>
</td></tr>
<tr><td><code id="stop_lmds_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structures; defaults to 0.5</p>
</td></tr>
<tr><td><code id="stop_lmds_+3A_strucpars">strucpars</code></td>
<td>
<p>a list of parameters for the structuredness indices; each list element corresponds to one index in the order of the appeacrance in structure</p>
</td></tr>
<tr><td><code id="stop_lmds_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_lmds_+3A_stoptype">stoptype</code></td>
<td>
<p>which weighting to be used in the multi-objective optimization? Either 'additive' (default) or 'multiplicative'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress-1
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> stoploss: the weighted loss value
</p>
</li>
<li><p> struc: the structuredness indices
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object 
</p>
</li></ul>


<hr>
<h2 id='stop_powerelastic'>STOPS version of elastic scaling with powers for proximities and distances</h2><span id='topic+stop_powerelastic'></span>

<h3>Description</h3>

<p>This is power stress with free kappa and lambda but rho is fixed to -2 and the weights are delta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_powerelastic(
  dis,
  theta = c(1, 1),
  type = "ratio",
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  ndim = 2,
  itmaxi = 1e+05,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  stoptype = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_powerelastic_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_powerelastic_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers;  a vector of length two where the first element is kappa (for the fitted distances), the second lambda (for the observed proximities). If a scalar for the free parameters is given it is recycled.  Defaults to 1 1.</p>
</td></tr>
<tr><td><code id="stop_powerelastic_+3A_type">type</code></td>
<td>
<p>MDS type. Defaults to &quot;ratio&quot;.</p>
</td></tr>
<tr><td><code id="stop_powerelastic_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_powerelastic_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_powerelastic_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_powerelastic_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_powerelastic_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_powerelastic_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_powerelastic_+3A_structures">structures</code></td>
<td>
<p>which strcutures to look for</p>
</td></tr>
<tr><td><code id="stop_powerelastic_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structures; defaults to 0.5</p>
</td></tr>
<tr><td><code id="stop_powerelastic_+3A_strucpars">strucpars</code></td>
<td>
<p>a list of parameters for the structuredness indices; each list element corresponds to one index in the order of the appeacrance in structures</p>
</td></tr>
<tr><td><code id="stop_powerelastic_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_powerelastic_+3A_stoptype">stoptype</code></td>
<td>
<p>which weighting to be used in the multi-objective optimization? Either 'additive' (default) or 'multiplicative'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress-1 value
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> stoploss: the weighted loss value
</p>
</li>
<li><p> struc: the structuredness indices
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object 
</p>
</li></ul>


<hr>
<h2 id='stop_powermds'>STOPS version of powermds</h2><span id='topic+stop_powermds'></span>

<h3>Description</h3>

<p>This is power stress with free kappa and lambda but rho is fixed to 1, so no weight transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_powermds(
  dis,
  theta = c(1, 1),
  type = "ratio",
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  ndim = 2,
  itmaxi = 10000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  stoptype = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_powermds_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_powermds_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; a vector of length 2 where the first element is kappa (for the fitted distances), the second lambda (for the observed proximities). If a scalar is given it is recycled.  Defaults to 1,1.</p>
</td></tr>
<tr><td><code id="stop_powermds_+3A_type">type</code></td>
<td>
<p>MDS type. Defaults to &quot;ratio&quot;.</p>
</td></tr>
<tr><td><code id="stop_powermds_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_powermds_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_powermds_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_powermds_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_powermds_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_powermds_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_powermds_+3A_structures">structures</code></td>
<td>
<p>which structures to look for</p>
</td></tr>
<tr><td><code id="stop_powermds_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structures; defaults to 0.5</p>
</td></tr>
<tr><td><code id="stop_powermds_+3A_strucpars">strucpars</code></td>
<td>
<p>a list of parameters for the structuredness indices; each list element corresponds to one index in the order of the appeacrance in structures</p>
</td></tr>
<tr><td><code id="stop_powermds_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_powermds_+3A_stoptype">stoptype</code></td>
<td>
<p>which weighting to be used in the multi-objective optimization? Either 'additive' (default) or 'multiplicative'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress-1 value
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> stoploss: the weighted loss value
</p>
</li>
<li><p> struc: the structuredness indices
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object 
</p>
</li></ul>


<hr>
<h2 id='stop_powersammon'>STOPS version of sammon with powers</h2><span id='topic+stop_powersammon'></span>

<h3>Description</h3>

<p>This is power stress with free kappa and lambda but rho is fixed to -1 and the weights are delta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_powersammon(
  dis,
  theta = c(1, 1),
  type = "ratio",
  weightmat = NULL,
  init = NULL,
  ndim = 2,
  itmaxi = 10000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  stoptype = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_powersammon_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_powersammon_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; a vector of length two where the first element is kappa (for the fitted distances), the second lambda (for the observed proximities). If a scalar is given it is recycled for the free parameters.  Defaults to 1 1.</p>
</td></tr>
<tr><td><code id="stop_powersammon_+3A_type">type</code></td>
<td>
<p>MDS type. Defaults to &quot;ratio&quot;.</p>
</td></tr>
<tr><td><code id="stop_powersammon_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_powersammon_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_powersammon_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_powersammon_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_powersammon_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_powersammon_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_powersammon_+3A_structures">structures</code></td>
<td>
<p>which structures to look for</p>
</td></tr>
<tr><td><code id="stop_powersammon_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structures; defaults to 0.5</p>
</td></tr>
<tr><td><code id="stop_powersammon_+3A_strucpars">strucpars</code></td>
<td>
<p>a list of parameters for the structuredness indices; each list element corresponds to one index in the order of the appeacrance in structures</p>
</td></tr>
<tr><td><code id="stop_powersammon_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_powersammon_+3A_stoptype">stoptype</code></td>
<td>
<p>which weighting to be used in the multi-objective optimization? Either 'additive' (default) or 'multiplicative'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> stoploss: the weighted loss value
</p>
</li>
<li><p> struc: the structuredness indices
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object 
</p>
</li></ul>


<hr>
<h2 id='stop_powerstress'>STOPS version of powerstress</h2><span id='topic+stop_powerstress'></span>

<h3>Description</h3>

<p>Power stress with free kappa and lambda and rho.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_powerstress(
  dis,
  theta = c(1, 1, 1),
  type = "ratio",
  weightmat = NULL,
  init = NULL,
  ndim = 2,
  itmaxi = 10000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  stoptype = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_powerstress_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_powerstress_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; the first is kappa (for the fitted distances), the second lambda (for the observed proximities), the third nu (for the weights). If a scalar is given it is recycled.  Defaults to 1 1 1.</p>
</td></tr>
<tr><td><code id="stop_powerstress_+3A_type">type</code></td>
<td>
<p>MDS type.</p>
</td></tr>
<tr><td><code id="stop_powerstress_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_powerstress_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_powerstress_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_powerstress_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_powerstress_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_powerstress_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_powerstress_+3A_structures">structures</code></td>
<td>
<p>a character vector listing the structure indices to use. They always are called &quot;cfoo&quot; with foo being the structure.</p>
</td></tr>
<tr><td><code id="stop_powerstress_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structures; defaults to 1/number of structures</p>
</td></tr>
<tr><td><code id="stop_powerstress_+3A_strucpars">strucpars</code></td>
<td>
<p>a list of parameters for the structuredness indices; each list element corresponds to one index in the order of the appearance in structures</p>
</td></tr>
<tr><td><code id="stop_powerstress_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_powerstress_+3A_stoptype">stoptype</code></td>
<td>
<p>which weighting to be used in the multi-objective optimization? Either 'additive' (default) or 'multiplicative'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress-1 value
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> stoploss: the weighted loss value
</p>
</li>
<li><p> struc: the structuredness indices
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda, nu)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object 
</p>
</li></ul>


<hr>
<h2 id='stop_rpowerstress'>STOPS version of restricted powerstress</h2><span id='topic+stop_rpowerstress'></span>

<h3>Description</h3>

<p>STOPS version of restricted powerstress
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_rpowerstress(
  dis,
  theta = c(1, 1, 1),
  type = "ratio",
  weightmat = NULL,
  init = NULL,
  ndim = 2,
  itmaxi = 10000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  stoptype = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_rpowerstress_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_rpowerstress_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; the first two arguments are for kappa and lambda and should be equal (for the fitted distances and observed proximities), the third nu (for the weights). Internally the kappa and lambda are equated. If a scalar is given it is recycled (so all elements of theta are equal); if a vector of length 2 is given, it gets expanded to c(theta[1],theta[1],theta[2]). Defaults to 1 1 1.</p>
</td></tr>
<tr><td><code id="stop_rpowerstress_+3A_type">type</code></td>
<td>
<p>MDS type. Defaults to &quot;ratio&quot;.</p>
</td></tr>
<tr><td><code id="stop_rpowerstress_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_rpowerstress_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_rpowerstress_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_rpowerstress_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. default is 10000.</p>
</td></tr>
<tr><td><code id="stop_rpowerstress_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure powerStressMin</p>
</td></tr>
<tr><td><code id="stop_rpowerstress_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_rpowerstress_+3A_structures">structures</code></td>
<td>
<p>a character vector listing the structure indices to use. They always are called &quot;cfoo&quot; with foo being the structure.</p>
</td></tr>
<tr><td><code id="stop_rpowerstress_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structures; defaults to 1/number of structures</p>
</td></tr>
<tr><td><code id="stop_rpowerstress_+3A_strucpars">strucpars</code></td>
<td>
<p>a list of list of parameters for the structuredness indices; each list element corresponds to one index in the order of the appearance in structures vector. See examples.</p>
</td></tr>
<tr><td><code id="stop_rpowerstress_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_rpowerstress_+3A_stoptype">stoptype</code></td>
<td>
<p>which weighting to be used in the multi-objective optimization? Either 'additive' (default) or 'multiplicative'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress-1 value
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> stoploss: the weighted loss value
</p>
</li>
<li><p> struc: the structuredness indices
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa=lambda, nu)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object 
</p>
</li></ul>


<hr>
<h2 id='stop_rstress'>STOPS version of rstress</h2><span id='topic+stop_rstress'></span>

<h3>Description</h3>

<p>Free parameter is kappa=2r for the fitted distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_rstress(
  dis,
  theta = 1,
  type = "ratio",
  weightmat = NULL,
  init = NULL,
  ndim = 2,
  itmaxi = 10000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  stoptype = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_rstress_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_rstress_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; this must be a scalar of the kappa=2*r transformation for the fitted distances proximities. Defaults to 1. Note that what is returned is r, not kappa.</p>
</td></tr>
<tr><td><code id="stop_rstress_+3A_type">type</code></td>
<td>
<p>MDS type. Default is &quot;ratio&quot;</p>
</td></tr>
<tr><td><code id="stop_rstress_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_rstress_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_rstress_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_rstress_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations.</p>
</td></tr>
<tr><td><code id="stop_rstress_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_rstress_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_rstress_+3A_structures">structures</code></td>
<td>
<p>which structuredness indices to be included in the loss</p>
</td></tr>
<tr><td><code id="stop_rstress_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structuredness indices; ; defaults to 1/#number of structures</p>
</td></tr>
<tr><td><code id="stop_rstress_+3A_strucpars">strucpars</code></td>
<td>
<p>the parameters for the structuredness indices</p>
</td></tr>
<tr><td><code id="stop_rstress_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_rstress_+3A_stoptype">stoptype</code></td>
<td>
<p>How to construct the target function for the multi objective optimization? Either 'additive' (default) or 'multiplicative'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: the stress-1 value
</p>
</li>
<li><p>stress.m: default normalized stress
</p>
</li>
<li><p>stoploss: the weighted loss value
</p>
</li>
<li><p>indices: the values of the structuredness indices
</p>
</li>
<li><p>parameters: the parameters used for fitting 
</p>
</li>
<li><p>fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object
</p>
</li></ul>


<hr>
<h2 id='stop_sammon'>STOPS version of Sammon mapping</h2><span id='topic+stop_sammon'></span>

<h3>Description</h3>

<p>Uses smacofx::sammon. The free parameter is lambda for power transformations of the observed proximities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_sammon(
  dis,
  theta = 1,
  type = "ratio",
  ndim = 2,
  init = NULL,
  weightmat = NULL,
  itmaxi = 1000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "chierarchy", "cconvexity", "cstriatedness", "coutlying", "cskinniness", "csparsity",
    "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  stoptype = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_sammon_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_sammon_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; this must be  a scalar of the lambda transformation for the observed proximities. Defaults to 1.</p>
</td></tr>
<tr><td><code id="stop_sammon_+3A_type">type</code></td>
<td>
<p>MDS type. Ignored here.</p>
</td></tr>
<tr><td><code id="stop_sammon_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_sammon_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_sammon_+3A_weightmat">weightmat</code></td>
<td>
<p>a matrix of nonnegative weights. Has no effect here.</p>
</td></tr>
<tr><td><code id="stop_sammon_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_sammon_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_sammon_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_sammon_+3A_structures">structures</code></td>
<td>
<p>which structuredness indices to be included in the loss</p>
</td></tr>
<tr><td><code id="stop_sammon_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structuredness indices; ; defaults to 1/#number of structures</p>
</td></tr>
<tr><td><code id="stop_sammon_+3A_strucpars">strucpars</code></td>
<td>
<p>the parameters for the structuredness indices</p>
</td></tr>
<tr><td><code id="stop_sammon_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_sammon_+3A_stoptype">stoptype</code></td>
<td>
<p>How to construct the target function for the multi objective optimization? Either 'additive' (default) or 'multiplicative'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: the stress/1 *sqrt stress(
</p>
</li>
<li><p>stress.m: default normalized stress
</p>
</li>
<li><p>stoploss: the weighted loss value
</p>
</li>
<li><p>indices: the values of the structuredness indices
</p>
</li>
<li><p>parameters: the parameters used for fitting 
</p>
</li>
<li><p>fit: the returned object of the fitting procedure  smacofx::sammon 
</p>
</li>
<li><p>stopobj: the stopobj object
</p>
</li></ul>


<hr>
<h2 id='stop_sammon2'>Another STOPS version of Sammon mapping models (via smacofSym)</h2><span id='topic+stop_sammon2'></span>

<h3>Description</h3>

<p>Uses Smacof, so it can deal with a weight matrix too.  The free parameter is lambda for power transformations of the observed proximities. The fitted distances power is internally fixed to 1 and the power for the weights=delta is -1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_sammon2(
  dis,
  theta = 1,
  type = "ratio",
  ndim = 2,
  weightmat = NULL,
  init = NULL,
  itmaxi = 1000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  stoptype = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_sammon2_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_sammon2_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; this must be a scalar of the lambda transformation for the observed proximities. Defaults to 1.</p>
</td></tr>
<tr><td><code id="stop_sammon2_+3A_type">type</code></td>
<td>
<p>MDS type</p>
</td></tr>
<tr><td><code id="stop_sammon2_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_sammon2_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_sammon2_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_sammon2_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_sammon2_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_sammon2_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_sammon2_+3A_structures">structures</code></td>
<td>
<p>which structuredness indices to be included in the loss</p>
</td></tr>
<tr><td><code id="stop_sammon2_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structuredness indices; ; defaults to 1/#number of structures</p>
</td></tr>
<tr><td><code id="stop_sammon2_+3A_strucpars">strucpars</code></td>
<td>
<p>the parameters for the structuredness indices</p>
</td></tr>
<tr><td><code id="stop_sammon2_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_sammon2_+3A_stoptype">stoptype</code></td>
<td>
<p>How to construct the target function for the multi objective optimization? Either 'additive' (default) or 'multiplicative'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: the stress-1 (sqrt(stress.m))
</p>
</li>
<li><p>stress.m: default normalized stress (used for STOPS)
</p>
</li>
<li><p>stoploss: the weighted loss value
</p>
</li>
<li><p>indices: the values of the structuredness indices
</p>
</li>
<li><p>parameters: the parameters used for fitting (lambda)
</p>
</li>
<li><p>fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object
</p>
</li></ul>


<hr>
<h2 id='stop_smacofSphere'>STOPS versions of smacofSphere models</h2><span id='topic+stop_smacofSphere'></span>

<h3>Description</h3>

<p>The free parameter is lambda for power transformations the observed proximities. The fitted distances power is internally fixed to 1 and the power for the weights is 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_smacofSphere(
  dis,
  theta = 1,
  type = "ratio",
  ndim = 2,
  weightmat = NULL,
  init = NULL,
  itmaxi = 1000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  stoptype = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_smacofSphere_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_smacofSphere_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; this must be a scalar of the lambda transformation for the observed proximities. Defaults to 1.</p>
</td></tr>
<tr><td><code id="stop_smacofSphere_+3A_type">type</code></td>
<td>
<p>MDS type.</p>
</td></tr>
<tr><td><code id="stop_smacofSphere_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_smacofSphere_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_smacofSphere_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_smacofSphere_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_smacofSphere_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_smacofSphere_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_smacofSphere_+3A_structures">structures</code></td>
<td>
<p>which structuredness indices to be included in the loss</p>
</td></tr>
<tr><td><code id="stop_smacofSphere_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structuredness indices; ; defaults to 1/#number of structures</p>
</td></tr>
<tr><td><code id="stop_smacofSphere_+3A_strucpars">strucpars</code></td>
<td>
<p>the parameters for the structuredness indices</p>
</td></tr>
<tr><td><code id="stop_smacofSphere_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_smacofSphere_+3A_stoptype">stoptype</code></td>
<td>
<p>How to construct the target function for the multi objective optimization? Either 'additive' (default) or 'multiplicative'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: the stress-1 value
</p>
</li>
<li><p>stress.m: default normalized stress
</p>
</li>
<li><p>stoploss: the weighted loss value
</p>
</li>
<li><p>indices: the values of the structuredness indices
</p>
</li>
<li><p>parameters: the parameters used for fitting 
</p>
</li>
<li><p>fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object
</p>
</li></ul>


<hr>
<h2 id='stop_smacofSym'>STOPS version of smacofSym models</h2><span id='topic+stop_smacofSym'></span>

<h3>Description</h3>

<p>The free parameter is lambda for power transformations the observed proximities. The fitted distances power is internally fixed to 1 and the power for the weights is 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_smacofSym(
  dis,
  theta = 1,
  type = "ratio",
  ndim = 2,
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  itmaxi = 1000,
  ...,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "chierarchy", "cconvexity", "cstriatedness", "coutlying", "cskinniness", "csparsity",
    "cstringiness", "cclumpiness", "cinequality"),
  stressweight = 1,
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  stoptype = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_smacofSym_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_smacofSym_+3A_theta">theta</code></td>
<td>
<p>the theta vector; must be a scalar for the lambda (proximity) transformation. Defaults to 1.</p>
</td></tr>
<tr><td><code id="stop_smacofSym_+3A_type">type</code></td>
<td>
<p>MDS type. Defaults ot 'ratio'.</p>
</td></tr>
<tr><td><code id="stop_smacofSym_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_smacofSym_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_smacofSym_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_smacofSym_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_smacofSym_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting</p>
</td></tr>
<tr><td><code id="stop_smacofSym_+3A_structures">structures</code></td>
<td>
<p>which structuredness indices to be included in the loss</p>
</td></tr>
<tr><td><code id="stop_smacofSym_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_smacofSym_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structuredness indices; ; defaults to 1/#number of structures</p>
</td></tr>
<tr><td><code id="stop_smacofSym_+3A_strucpars">strucpars</code></td>
<td>
<p>the parameters for the structuredness indices</p>
</td></tr>
<tr><td><code id="stop_smacofSym_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_smacofSym_+3A_stoptype">stoptype</code></td>
<td>
<p>How to construct the target function for the multi objective optimization? Either 'additive' (default) or 'multiplicative'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: the stress-1 (sqrt(stress.m))
</p>
</li>
<li><p>stress.m: default normalized stress (used for STOPS)
</p>
</li>
<li><p>stoploss: the weighted loss value
</p>
</li>
<li><p>indices: the values of the structuredness indices
</p>
</li>
<li><p>parameters: the parameters used for fitting (lambda) 
</p>
</li>
<li><p>fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stops object
</p>
</li></ul>


<hr>
<h2 id='stop_smddae'>STOPS version of sparsified multidimensional distance analysis for fixed eps and tau</h2><span id='topic+stop_smddae'></span>

<h3>Description</h3>

<p>smdda with free parameters tau and epsilon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_smddae(
  dis,
  theta = c(100, 100),
  type = "ratio",
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  ndim = 2,
  itmaxi = 10000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  stoptype = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_smddae_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_smddae_+3A_theta">theta</code></td>
<td>
<p>the theta vector of explicit parameters; first is tau for the neighboourhood, second is epsilon for isomapdist. Defaults to 100, 100.</p>
</td></tr>
<tr><td><code id="stop_smddae_+3A_type">type</code></td>
<td>
<p>MDS type.</p>
</td></tr>
<tr><td><code id="stop_smddae_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_smddae_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_smddae_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_smddae_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_smddae_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_smddae_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_smddae_+3A_structures">structures</code></td>
<td>
<p>a character vector listing the structure indices to use. They always are called &quot;cfoo&quot; with foo being the structure.</p>
</td></tr>
<tr><td><code id="stop_smddae_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structures; defaults to 1/number of structures</p>
</td></tr>
<tr><td><code id="stop_smddae_+3A_strucpars">strucpars</code></td>
<td>
<p>a list of parameters for the structuredness indices; each list element corresponds to one index in the order of the appearance in structures</p>
</td></tr>
<tr><td><code id="stop_smddae_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_smddae_+3A_stoptype">stoptype</code></td>
<td>
<p>which weighting to be used in the multi-objective optimization? Either 'additive' (default) or 'multiplicative'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress-1 value
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> stoploss: the weighted loss value
</p>
</li>
<li><p> struc: the structuredness indices
</p>
</li>
<li><p> parameters: the parameters used for fitting (tau)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object 
</p>
</li></ul>


<hr>
<h2 id='stop_smddak'>STOPS version of sparsified multidimensional distance analysis for fixed k and tau</h2><span id='topic+stop_smddak'></span>

<h3>Description</h3>

<p>smdda with free parameters tau and k.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_smddak(
  dis,
  theta = c(100, 10),
  type = "ratio",
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  ndim = 2,
  itmaxi = 10000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  stoptype = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_smddak_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_smddak_+3A_theta">theta</code></td>
<td>
<p>the theta vector of explicit parameters; first is tau for the neighbourhood, second is k. Defaults to 100, 10.</p>
</td></tr>
<tr><td><code id="stop_smddak_+3A_type">type</code></td>
<td>
<p>MDS type.</p>
</td></tr>
<tr><td><code id="stop_smddak_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_smddak_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_smddak_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_smddak_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_smddak_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_smddak_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_smddak_+3A_structures">structures</code></td>
<td>
<p>a character vector listing the structure indices to use. They always are called &quot;cfoo&quot; with foo being the structure.</p>
</td></tr>
<tr><td><code id="stop_smddak_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structures; defaults to 1/number of structures</p>
</td></tr>
<tr><td><code id="stop_smddak_+3A_strucpars">strucpars</code></td>
<td>
<p>a list of parameters for the structuredness indices; each list element corresponds to one index in the order of the appearance in structures</p>
</td></tr>
<tr><td><code id="stop_smddak_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_smddak_+3A_stoptype">stoptype</code></td>
<td>
<p>which weighting to be used in the multi-objective optimization? Either 'additive' (default) or 'multiplicative'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress-1 value
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> stoploss: the weighted loss value
</p>
</li>
<li><p> struc: the structuredness indices
</p>
</li>
<li><p> parameters: the parameters used for fitting (tau)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object 
</p>
</li></ul>


<hr>
<h2 id='stop_smds'>STOPS version of sparsified MDS.</h2><span id='topic+stop_smds'></span>

<h3>Description</h3>

<p>smds with free tau.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_smds(
  dis,
  theta = c(100),
  type = "ratio",
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  ndim = 2,
  itmaxi = 10000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  stoptype = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_smds_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_smds_+3A_theta">theta</code></td>
<td>
<p>the theta vector of explicit parameters; tau for the neighbourhood. Defaults to 100.</p>
</td></tr>
<tr><td><code id="stop_smds_+3A_type">type</code></td>
<td>
<p>MDS type.</p>
</td></tr>
<tr><td><code id="stop_smds_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_smds_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_smds_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_smds_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_smds_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_smds_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_smds_+3A_structures">structures</code></td>
<td>
<p>a character vector listing the structure indices to use. They always are called &quot;cfoo&quot; with foo being the structure.</p>
</td></tr>
<tr><td><code id="stop_smds_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structures; defaults to 1/number of structures</p>
</td></tr>
<tr><td><code id="stop_smds_+3A_strucpars">strucpars</code></td>
<td>
<p>a list of parameters for the structuredness indices; each list element corresponds to one index in the order of the appearance in structures</p>
</td></tr>
<tr><td><code id="stop_smds_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_smds_+3A_stoptype">stoptype</code></td>
<td>
<p>which weighting to be used in the multi-objective optimization? Either 'additive' (default) or 'multiplicative'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress-1 value
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> stoploss: the weighted loss value
</p>
</li>
<li><p> struc: the structuredness indices
</p>
</li>
<li><p> parameters: the parameters used for fitting (tau)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object 
</p>
</li></ul>


<hr>
<h2 id='stop_spmddae'>STOPS version of sparsified post multidimensional distance analysis for fixed tau and epsilon.</h2><span id='topic+stop_spmddae'></span>

<h3>Description</h3>

<p>Sparsified POST MDDA with free kappa, lambda, rho, tau and epsilon. Phew.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_spmddae(
  dis,
  theta = c(1, 1, 1, 100, 100),
  type = "ratio",
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  ndim = 2,
  itmaxi = 10000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  stoptype = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_spmddae_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_spmddae_+3A_theta">theta</code></td>
<td>
<p>the theta vector of explicit parameters; the first is kappa (for the fitted distances), the second lambda (for the observed proximities), the third nu (for the weights), the fourth tau (for the neighbourhood), the fifth the epsilon for the geodesic distances. If a scalar or vector shorter than 5 is given it is recycled.  Defaults to 1 1 1 100 10.</p>
</td></tr>
<tr><td><code id="stop_spmddae_+3A_type">type</code></td>
<td>
<p>MDS type.</p>
</td></tr>
<tr><td><code id="stop_spmddae_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_spmddae_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_spmddae_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_spmddae_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_spmddae_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_spmddae_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_spmddae_+3A_structures">structures</code></td>
<td>
<p>a character vector listing the structure indices to use. They always are called &quot;cfoo&quot; with foo being the structure.</p>
</td></tr>
<tr><td><code id="stop_spmddae_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structures; defaults to 1/number of structures</p>
</td></tr>
<tr><td><code id="stop_spmddae_+3A_strucpars">strucpars</code></td>
<td>
<p>a list of parameters for the structuredness indices; each list element corresponds to one index in the order of the appearance in structures</p>
</td></tr>
<tr><td><code id="stop_spmddae_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_spmddae_+3A_stoptype">stoptype</code></td>
<td>
<p>which weighting to be used in the multi-objective optimization? Either 'additive' (default) or 'multiplicative'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress-1 value
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> stoploss: the weighted loss value
</p>
</li>
<li><p> struc: the structuredness indices
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda, nu, tau)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object 
</p>
</li></ul>


<hr>
<h2 id='stop_spmddak'>STOPS version of sparsified post multidimensional distance analysis for fixed tau and k.</h2><span id='topic+stop_spmddak'></span>

<h3>Description</h3>

<p>Sparsified Post MDDA with free kappa, lambda, rho, tau and k. Phew.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_spmddak(
  dis,
  theta = c(1, 1, 1, 100, 10),
  type = "ratio",
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  ndim = 2,
  itmaxi = 10000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  stoptype = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_spmddak_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_spmddak_+3A_theta">theta</code></td>
<td>
<p>the theta vector of explicit parameters; the first is kappa (for the fitted distances), the second lambda (for the observed proximities), the third nu (for the weights), the fourth tau (for the neighbourhood), the fifth the k for the geodesic distances. If a scalar or vector shorter than 5 is given it is recycled.  Defaults to 1 1 1 100 10.</p>
</td></tr>
<tr><td><code id="stop_spmddak_+3A_type">type</code></td>
<td>
<p>MDS type.</p>
</td></tr>
<tr><td><code id="stop_spmddak_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_spmddak_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_spmddak_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_spmddak_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_spmddak_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_spmddak_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_spmddak_+3A_structures">structures</code></td>
<td>
<p>a character vector listing the structure indices to use. They always are called &quot;cfoo&quot; with foo being the structure.</p>
</td></tr>
<tr><td><code id="stop_spmddak_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structures; defaults to 1/number of structures</p>
</td></tr>
<tr><td><code id="stop_spmddak_+3A_strucpars">strucpars</code></td>
<td>
<p>a list of parameters for the structuredness indices; each list element corresponds to one index in the order of the appearance in structures</p>
</td></tr>
<tr><td><code id="stop_spmddak_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_spmddak_+3A_stoptype">stoptype</code></td>
<td>
<p>which weighting to be used in the multi-objective optimization? Either 'additive' (default) or 'multiplicative'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress-1 value
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> stoploss: the weighted loss value
</p>
</li>
<li><p> struc: the structuredness indices
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda, nu, tau)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object 
</p>
</li></ul>


<hr>
<h2 id='stop_spmds'>STOPS version of sparsified POST-MDS for fixed tau</h2><span id='topic+stop_spmds'></span>

<h3>Description</h3>

<p>Sparsified power stress with free kappa, lambda, rho and tau.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_spmds(
  dis,
  theta = c(1, 1, 1, 100),
  type = "ratio",
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  ndim = 2,
  itmaxi = 10000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  stoptype = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_spmds_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_spmds_+3A_theta">theta</code></td>
<td>
<p>the theta vector of explicit parameters; the first is kappa (for the fitted distances), the second lambda (for the observed proximities), the third nu (for the weights), the fourth tau (for the neighbourhood). If a scalar or vector shorter than 4 is given it is recycled.  Defaults to 1 1 1 100.</p>
</td></tr>
<tr><td><code id="stop_spmds_+3A_type">type</code></td>
<td>
<p>MDS type.</p>
</td></tr>
<tr><td><code id="stop_spmds_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_spmds_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_spmds_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_spmds_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_spmds_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_spmds_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_spmds_+3A_structures">structures</code></td>
<td>
<p>a character vector listing the structure indices to use. They always are called &quot;cfoo&quot; with foo being the structure.</p>
</td></tr>
<tr><td><code id="stop_spmds_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structures; defaults to 1/number of structures</p>
</td></tr>
<tr><td><code id="stop_spmds_+3A_strucpars">strucpars</code></td>
<td>
<p>a list of parameters for the structuredness indices; each list element corresponds to one index in the order of the appearance in structures</p>
</td></tr>
<tr><td><code id="stop_spmds_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_spmds_+3A_stoptype">stoptype</code></td>
<td>
<p>which weighting to be used in the multi-objective optimization? Either 'additive' (default) or 'multiplicative'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress-1 value
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> stoploss: the weighted loss value
</p>
</li>
<li><p> struc: the structuredness indices
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda, nu, tau)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object 
</p>
</li></ul>


<hr>
<h2 id='stop_sstress'>STOPS version of sstress</h2><span id='topic+stop_sstress'></span>

<h3>Description</h3>

<p>Free parameter is lambda for the observed proximities. Fitted distances are transformed with power 2, weights have exponent of 1. Note that the lambda here works as a multiplicator of 2 (as sstress has f(delta^2)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_sstress(
  dis,
  theta = 1,
  type = type,
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  ndim = 2,
  itmaxi = 1e+05,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  stoptype = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_sstress_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_sstress_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; this must be a scalar of the lambda transformation for the observed proximities. Defaults to 1. Note that the lambda here works as a multiplicator of 2 (as sstress has f(delta^2)).</p>
</td></tr>
<tr><td><code id="stop_sstress_+3A_type">type</code></td>
<td>
<p>MDS type.</p>
</td></tr>
<tr><td><code id="stop_sstress_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_sstress_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_sstress_+3A_ndim">ndim</code></td>
<td>
<p>the number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_sstress_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_sstress_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_sstress_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_sstress_+3A_structures">structures</code></td>
<td>
<p>which structuredness indices to be included in the loss</p>
</td></tr>
<tr><td><code id="stop_sstress_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structuredness indices; ; defaults to 1/#number of structures</p>
</td></tr>
<tr><td><code id="stop_sstress_+3A_strucpars">strucpars</code></td>
<td>
<p>the parameters for the structuredness indices</p>
</td></tr>
<tr><td><code id="stop_sstress_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_sstress_+3A_stoptype">stoptype</code></td>
<td>
<p>How to construct the target function for the multi objective optimization? Either 'additive' (default) or 'multiplicative'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: the stress-1 value
</p>
</li>
<li><p>stress.m: default normalized stress
</p>
</li>
<li><p>stoploss: the weighted loss value
</p>
</li>
<li><p>indices: the values of the structuredness indices
</p>
</li>
<li><p>parameters: the parameters used for fitting (lambda)
</p>
</li>
<li><p>fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object
</p>
</li></ul>


<hr>
<h2 id='stoploss'>Calculate the weighted multiobjective loss function used in STOPS</h2><span id='topic+stoploss'></span>

<h3>Description</h3>

<p>Calculate the weighted multiobjective loss function used in STOPS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stoploss(
  obj,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(-1/length(structures), length(structures)),
  strucpars,
  stoptype = c("additive", "multiplicative"),
  verbose = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stoploss_+3A_obj">obj</code></td>
<td>
<p>object returned inside a stop_* function. Uses the stress.m slot for getting the stress.</p>
</td></tr>
<tr><td><code id="stoploss_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stoploss_+3A_structures">structures</code></td>
<td>
<p>which c-structuredness indices to be included in the loss</p>
</td></tr>
<tr><td><code id="stoploss_+3A_strucweight">strucweight</code></td>
<td>
<p>the weights of the structuredness indices; defaults to -1/#number of structures</p>
</td></tr>
<tr><td><code id="stoploss_+3A_strucpars">strucpars</code></td>
<td>
<p>a list of parameters to be passed to the c-structuredness indices in the same order as the values in structures. If the index has no parameters or you want to use the defaults, supply NULL. (alternatively a named list that has the structure name as the element name).</p>
</td></tr>
<tr><td><code id="stoploss_+3A_stoptype">stoptype</code></td>
<td>
<p>what type of weighted combination should be used? Can be 'additive' or 'multiplicative'.</p>
</td></tr>
<tr><td><code id="stoploss_+3A_verbose">verbose</code></td>
<td>
<p>verbose output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with calculated stoploss ($stoploss), structuredness indices ($strucinidices) and hyperparameters ($parameters and $theta)
</p>

<hr>
<h2 id='stops'>High Level STOPS Function</h2><span id='topic+stops'></span>

<h3>Description</h3>

<p>This allows to fit STOPS models as described in Rusch, Mair, Hornik (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stops(
  dis,
  loss = "stress",
  theta = 1,
  type = "ratio",
  structures,
  ndim = 2,
  weightmat = NULL,
  init = NULL,
  stressweight = 1,
  strucweight,
  strucpars,
  optimmethod = c("SANN", "ALJ", "pso", "Kriging", "tgp", "direct", "stogo", "cobyla",
    "crs2lm", "isres", "mlsl", "neldermead", "sbplx", "hjk", "cmaes"),
  lower,
  upper,
  verbose = 0,
  stoptype = c("additive", "multiplicative"),
  initpoints = 10,
  itmax = 50,
  itmaxps = 10000,
  model,
  control,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stops_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stops_+3A_loss">loss</code></td>
<td>
<p>which loss function to be used for fitting, defaults to stress.</p>
</td></tr>
<tr><td><code id="stops_+3A_theta">theta</code></td>
<td>
<p>hyperparameter vector starting values for the transformation functions. If the length is smaller than the number of hyperparameters for the MDS version the vector gets recycled (see the corresponding stop_XXX function or the vignette for how theta must look like exactly for each loss). If larger than the number of hyperparameters for the MDS method, an error is thrown. If completely missing theta is set to 1 and recycled.</p>
</td></tr>
<tr><td><code id="stops_+3A_type">type</code></td>
<td>
<p>type of MDS optimal scaling (implicit transformation). One of &quot;ratio&quot;, &quot;interval&quot; or &quot;ordinal&quot;. Default is &quot;ratio&quot;. Not every type can be used with every loss, only ratio works with all.</p>
</td></tr>
<tr><td><code id="stops_+3A_structures">structures</code></td>
<td>
<p>character vector of which c-structuredness indices should be considered; if missing no structure is considered.</p>
</td></tr>
<tr><td><code id="stops_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stops_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights; defaults to 1 for all off diagonals</p>
</td></tr>
<tr><td><code id="stops_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stops_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stops_+3A_strucweight">strucweight</code></td>
<td>
<p>vector of weights to be used for the c-structuredness indices (in the same order as in structures); defaults to -1/length(structures) for each index</p>
</td></tr>
<tr><td><code id="stops_+3A_strucpars">strucpars</code></td>
<td>
<p>(possibly named with the structure). Metaparameters for the structuredness indices (gamma in the article). It's safest for it be a list of lists with the named arguments for the structuredness indices and the order of the lists must be like the order of structures. So something like this <code>list(list(par1Struc1=par1Struc1,par2Struc1=par2Struc1),list(par1Struc2=par1Struc2,par2Struc2=par2Struc2),...)</code> where parYStrucX are the named arguments for the metaparameter Y of the structure X the list elements corresponds to. For a structure without parameters, set NULL. Parameters in different list elements parYStrucX can have the same name. For example, say we want to use cclusteredness with metaparameters epsilon=10 and k=4 (and the default for the other parameters), cdependence with no metaparameters and cfaithfulness with metaparameter k=7 one would <code>list(list(epsilon=10,k=4),list(NULL),list(dis=obdiss,k=6))</code>  for structures vector (&quot;cclusteredness&quot;,&quot;cdependence&quot;,&quot;cfaithfulness&quot;). The parameter lists must be in the same ordering as the indices in structures. If missing it is set to NULL and defaults are used. It is also possible to supply a structure's metaparameters as a list of vectors with named elements if the metaparameters are scalars, so like <code>list(c(par1Struc1=parStruc1,par2Struc1=par1Struc1,...),c(par1Struc2=par1Struc2,par2Struc2=par2Struc2,...))</code>. That can have unintended consequences if the metaparameter is a vector or matrix.</p>
</td></tr>
<tr><td><code id="stops_+3A_optimmethod">optimmethod</code></td>
<td>
<p>What solver to use. Currently supported are Bayesian optimization with Gaussian Process priors and Kriging (&quot;Kriging&quot;, see <code><a href="DiceOptim.html#topic+EGO.nsteps">EGO.nsteps</a></code>), Bayesian optimization with treed Gaussian processes with jump to linear models (&quot;tgp&quot;, see <code><a href="tgp.html#topic+dopt.gp">dopt.gp</a></code>), Adaptive LJ Search (&quot;ALJ&quot;), Particle Swarm optimization (&quot;pso&quot;, see <code><a href="pso.html#topic+psoptim">psoptim</a></code>), simulated annealing (&quot;SANN&quot;, <code><a href="stats.html#topic+optim">optim</a></code>), &quot;direct (<code><a href="nloptr.html#topic+direct">direct</a></code>)&quot;, Stochastic Global Optimization (&quot;stogo&quot;, <code><a href="nloptr.html#topic+stogo">stogo</a></code>), COBYLA (&quot;cobyla&quot;, <code><a href="nloptr.html#topic+cobyla">cobyla</a></code>), Controlled Random Search 2 with local mutation (&quot;crs2lm&quot;, <code><a href="nloptr.html#topic+crs2lm">crs2lm</a></code>), Improved Stochastic Ranking Evolution Strategy (&quot;isres&quot;, <code><a href="nloptr.html#topic+isres">isres</a></code>), Multi-Level Single-Linkage (&quot;mlsl&quot;, <code><a href="nloptr.html#topic+mlsl">mlsl</a></code>), Nelder-Mead (&quot;neldermead&quot;, <code><a href="nloptr.html#topic+neldermead">neldermead</a></code>), Subplex (&quot;sbplx&quot;, <code><a href="nloptr.html#topic+sbplx">sbplx</a></code>), Hooke-Jeeves Pattern Search (&quot;hjk&quot;, <code><a href="dfoptim.html#topic+hjk">hjk</a></code>), CMA-ES (&quot;cmaes&quot;, <code><a href="cmaes.html#topic+cma_es">cma_es</a></code>). Defaults to &quot;ALJ&quot; version. &quot;tgp&quot;, &quot;ALJ&quot;, &quot;Kriging&quot; and &quot;pso&quot; usually work well for relatively low values of 'itmax'.</p>
</td></tr>
<tr><td><code id="stops_+3A_lower">lower</code></td>
<td>
<p>The lower contraints of the search region. Needs to be a numeric vector of the same length as the parameter vector theta.</p>
</td></tr>
<tr><td><code id="stops_+3A_upper">upper</code></td>
<td>
<p>The upper contraints of the search region. Needs to be a numeric vector of the same length as the parameter vector theta.</p>
</td></tr>
<tr><td><code id="stops_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is very verbose.</p>
</td></tr>
<tr><td><code id="stops_+3A_stoptype">stoptype</code></td>
<td>
<p>which aggregation for the multi objective target function? Either 'additive' (default) or 'multiplicative'</p>
</td></tr>
<tr><td><code id="stops_+3A_initpoints">initpoints</code></td>
<td>
<p>number of initial points to fit the surrogate model for Bayesian optimization; default is 10.</p>
</td></tr>
<tr><td><code id="stops_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations of the outer optimization (for theta) or number of steps of Bayesian optimization; default is 50. We recommend a higher number for ALJ (around 150). Note that due to the inner workings of some solvers, this may or may not correspond to the actual number of function evaluations performed (or PS models fitted). E.g., with tgp the actual number of function evaluation of the PS method is between itmax and 6*itmax as tgp samples 1-6 candidates from the posterior and uses the best candidate. For pso it is the number of particles s times itmax. For cmaes it is usually a bit higher than itmax. This currently may get overruled by a control argument if it is used (and then set to either ewhat is supplie dby control or to the default of the method).</p>
</td></tr>
<tr><td><code id="stops_+3A_itmaxps">itmaxps</code></td>
<td>
<p>maximum number of iterations of the inner optimization (to obtain the PS configuration)</p>
</td></tr>
<tr><td><code id="stops_+3A_model">model</code></td>
<td>
<p>a character specifying the surrogate model to use. For Kriging it specifies the covariance kernel for the GP prior; see <code><a href="DiceKriging.html#topic+covTensorProduct-class">covTensorProduct-class</a></code> defaults to &quot;powerexp&quot;. For tgp it specifies the non stationary process used see <code><a href="tgp.html#topic+bgp">bgp</a></code>, defaults to &quot;btgpllm&quot;</p>
</td></tr>
<tr><td><code id="stops_+3A_control">control</code></td>
<td>
<p>a control argument passed to the outer optimization procedure. Will override any other control arguents passed, especially verbose and itmax. For the effect of control, see the functions pomp::sannbox for SANN and pso::psoptim for pso, cmaes::cma_es for cmaes, dfoptim::hjkb for hjk and the nloptr docs for the algorithms direct, stogo, cobyla, crs2lm, isres, mlsl, neldermead, sbplx.</p>
</td></tr>
<tr><td><code id="stops_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the outer optimization procedures (not fully tested).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The combination of c-structurednes indices and stress uses the stress.m values, which are the explictly normalized stresses. Reported however is the stress-1 value which is sqrt(stress.m).
</p>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stoploss: the stoploss value
</p>
</li>
<li><p> optim: the object returned from the optimization procedure
</p>
</li>
<li><p> stressweight: the stressweight
</p>
</li>
<li><p> strucweight: the vector of structure weights
</p>
</li>
<li><p> call: the call
</p>
</li>
<li><p> optimmethod: The solver selected
</p>
</li>
<li><p> loss: The PS badness-of-fit function
</p>
</li>
<li><p> nobj: the number of objects in the configuration
</p>
</li>
<li><p> type: The type of stoploss scalacrisation (additive or multiplicative)
</p>
</li>
<li><p> fit: The fitted PS object (most importantly $fit$conf the fitted configuration)
</p>
</li>
<li><p> stoptype: Type of stoploss combinatio
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(kinshipdelta,package="smacof")
strucpar&lt;-list(NULL,NULL) #parameters for indices
res1&lt;-stops(kinshipdelta,loss="stress",
structures=c("cclumpiness","cassociation"),strucpars=strucpar,
lower=0,upper=10,itmax=10)
res1


#use higher itmax in general, we use 5 just to shorten the tests
data(BankingCrisesDistances)
strucpar&lt;-list(c(epsilon=10,minpts=2),NULL) #parameters for indices
res1&lt;-stops(BankingCrisesDistances[,1:69],loss="stress",verbose=0,
structures=c("cclusteredness","clinearity"),strucpars=strucpar,
lower=0,upper=10,itmax=5)
res1

strucpar&lt;-list(list(alpha=0.6,C=15,var.thr=1e-5,zeta=NULL),
list(alpha=0.6,C=15,var.thr=1e-5,zeta=NULL))
res1&lt;-stops(BankingCrisesDistances[,1:69],loss="stress",verbose=0,
structures=c("cfunctionality","ccomplexity"),strucpars=strucpar,
lower=0,upper=10,itmax=5)
res1


</code></pre>

<hr>
<h2 id='summary.stops'>S3 summary method for stops</h2><span id='topic+summary.stops'></span>

<h3>Description</h3>

<p>S3 summary method for stops
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stops'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.stops_+3A_object">object</code></td>
<td>
<p>object of class stops</p>
</td></tr>
<tr><td><code id="summary.stops_+3A_...">...</code></td>
<td>
<p>addditional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class 'summary.stops'
</p>

<hr>
<h2 id='Swissroll'>Swiss roll</h2><span id='topic+Swissroll'></span>

<h3>Description</h3>

<p>A swiss roll data example where 150 data points are arranged on a swiss roll embedded in a 3D space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Swissroll)
</code></pre>


<h3>Format</h3>

<p>A data frame with 150 rows and 4 columns
</p>


<h3>Details</h3>

<p>A data frame with the variables (columns)
</p>

<ul>
<li><p> x The x axis coordinate for each point
</p>
</li>
<li><p> y The y axis coordinate for each point
</p>
</li>
<li><p> z The z axis coordinate for each point
</p>
</li>
<li><p> col a color code for each point with points along the y axis having the same color (based on the viridis palette) 
</p>
</li></ul>


<hr>
<h2 id='tgpoptim'>Bayesian Optimization by a (treed) Bayesian Gaussian Process Prior (with jumps to linear models) surrogate model
Essentially a wrapper for the functionality in tgp that has the same slots as optim with defaults for STOPS models.</h2><span id='topic+tgpoptim'></span>

<h3>Description</h3>

<p>Bayesian Optimization by a (treed) Bayesian Gaussian Process Prior (with jumps to linear models) surrogate model
Essentially a wrapper for the functionality in tgp that has the same slots as optim with defaults for STOPS models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tgpoptim(
  x,
  fun,
  ...,
  initpoints = 10,
  lower,
  upper,
  acc = 1e-08,
  itmax = 10,
  verbose = 0,
  model = "bgp"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tgpoptim_+3A_x">x</code></td>
<td>
<p>optional starting values</p>
</td></tr>
<tr><td><code id="tgpoptim_+3A_fun">fun</code></td>
<td>
<p>function to minimize</p>
</td></tr>
<tr><td><code id="tgpoptim_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the function to be optimized</p>
</td></tr>
<tr><td><code id="tgpoptim_+3A_initpoints">initpoints</code></td>
<td>
<p>the number of points to sample initially to fit the surrogate model</p>
</td></tr>
<tr><td><code id="tgpoptim_+3A_lower">lower</code></td>
<td>
<p>The lower contraints of the search region</p>
</td></tr>
<tr><td><code id="tgpoptim_+3A_upper">upper</code></td>
<td>
<p>The upper contraints of the search region</p>
</td></tr>
<tr><td><code id="tgpoptim_+3A_acc">acc</code></td>
<td>
<p>if the numerical accuracy of two successive target function values is below this, stop the optimization; defaults to 1e-8</p>
</td></tr>
<tr><td><code id="tgpoptim_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="tgpoptim_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="tgpoptim_+3A_model">model</code></td>
<td>
<p>which surrogate model class to use (currently uses defaults only, will extend this to tweak the model)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components (for compatibility with <code><a href="stats.html#topic+optim">optim</a></code>)
</p>

<ul>
<li><p> par The position of the optimum in the search space (parameters that minimize the function; argmin fun). 
</p>
</li>
<li><p> value The value of the objective function at the optimum (min fun). Note we do not use the last value in the candidate list but the best candidate (which can but need not coincide). 
</p>
</li>
<li><p> svalue The value of the surrogate objective function at the optimal parameters
</p>
</li>
<li><p> counts The number of iterations performed at convergence with entries fnction for the number of iterations and gradient which is always NA at the moment
</p>
</li>
<li><p> convergence 0 successful completion by the accd or acc criterion, 1 indicate iteration limit was reached, 99 is a problem 
</p>
</li>
<li><p> message is NULL (only for compatibility or future use)
</p>
</li>
<li><p> history the improvement history
</p>
</li>
<li><p> tgpout the output of the tgp model    
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
fbana &lt;- function(x) {
x1 &lt;- x[1]
x2 &lt;- x[2]
100 * (x2 - x1 * x1)^2 + (1 - x1)^2
}
res1&lt;-tgpoptim(c(-1.2,1),fbana,lower=c(-5,-5),upper=c(5,5),acc=1e-16,itmax=20)
res1

fwild &lt;- function (x) 10*sin(0.3*x)*sin(1.3*x^2) + 0.00001*x^4 + 0.2*x+80
plot(fwild, -50, 50, n = 1000, main = "Bayesian GP Optimization minimizing 'wild function'")
set.seed(210485)
res2&lt;-tgpoptim(50, fwild,lower=-50,upper=50,acc=1e-16,itmax=20,model="btgpllm")
points(res2$par,res2$value,col="red",pch=19)
res2

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
