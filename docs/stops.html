<!DOCTYPE html><html><head><title>Help for package stops</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stops}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#apStressMin'><p>Approximate Power Stress SMACOF</p></a></li>
<li><a href='#BankingCrisesDistances'><p>Banking Crises Distances</p></a></li>
<li><a href='#bcStressMin'><p>An MDS version for minimizing BoxCox Stress (Chen &amp; Buja 2013)</p></a></li>
<li><a href='#c_association'><p>c-association</p>
calculates the c-association based on the maximal information coefficient
We define c-association as the aggregated association between any two columns in confs</a></li>
<li><a href='#c_clumpiness'><p>c-clumpiness</p></a></li>
<li><a href='#c_clusteredness'><p>c-clusteredness</p>
calculates c-clusteredness as the OPTICS cordillera. The higher the more clustered.</a></li>
<li><a href='#c_complexity'><p>c-complexity</p>
Calculates the c-complexity based on the minimum cell number
We define c-complexity as the aggregated minimum cell number between any two columns in confs
This is one of few c-structuredness indices not between 0 and 1, but can be between 0 and (theoretically) infinity</a></li>
<li><a href='#c_convexity'><p>c-convexity</p></a></li>
<li><a href='#c_dependence'><p>c-dependence</p>
calculates c-dependence as the aggregated distance correlation of each pair if nonidentical columns</a></li>
<li><a href='#c_faithfulness'><p>c-faithfulness</p>
calculates the c-faithfulness based on the index by Chen and Buja 2013 (M_adj) with equal input neigbourhoods</a></li>
<li><a href='#c_functionality'><p>c-functionality</p>
calculates the c-functionality based on the maximum edge value
We define c-functionality as the aggregated functionality between any two columns of confs</a></li>
<li><a href='#c_hierarchy'><p>c-hierarchy</p>
captures how well a partition/ultrametric (obtained by hclust) explains the configuration distances. Uses variance explained for euclidean distances and deviance explained for everything else.</a></li>
<li><a href='#c_inequality'><p>c-inequality</p>
Calculates c-inequality (as in an economic measure of inequality) as Pearsons coefficient of variation of the fitted distance matrix. This can help with avoiding degenerate solutions.
This is one of few c-structuredness indices not between 0 and 1, but 0 and infinity.</a></li>
<li><a href='#c_linearity'><p>c-linearity</p>
calculates c-linearity as the aggregated multiple correlation of all columns of the configuration.</a></li>
<li><a href='#c_manifoldness'><p>c-manifoldness</p>
calculates c-manifoldness as the aggregated maximal correlation coefficient (i.e., Pearson correlation of the ACE transformed variables) of all pairwise combinations of two different columns in confs. If there is an NA (happens usually when the optimal transformation of any variable is a constant and therefore the covariance is 0 but also one of the sds in the denominator), it gets skipped.</a></li>
<li><a href='#c_mine'><p>wrapper for getting the mine coefficients</p></a></li>
<li><a href='#c_nonmonotonicity'><p>c-nonmonotonicity</p>
calculates the c-nonmonotonicity based on the maximum asymmetric score
We define c-nonmonotonicity as the aggregated nonmonotonicity between any two columns in confs
this is one of few c-structuredness indices not between 0 and 1</a></li>
<li><a href='#c_outlying'><p>c-outlying</p></a></li>
<li><a href='#c_regularity'><p>c-regularity</p>
calculates c-regularity as 1 - OPTICS cordillera for k=2. The higher the more regular.</a></li>
<li><a href='#c_skinniness'><p>c-skinniness</p></a></li>
<li><a href='#c_sparsity'><p>c-sparsity</p></a></li>
<li><a href='#c_striatedness'><p>c-striatedness</p></a></li>
<li><a href='#c_stringiness'><p>c-stringiness</p></a></li>
<li><a href='#cmds'><p>normalization function</p>
Classical Scaling</a></li>
<li><a href='#cmdscale'><p>Wrapper to <code>cmdscale</code> for S3 class</p></a></li>
<li><a href='#coef.stops'><p>S3 coef method for stops objects</p></a></li>
<li><a href='#conf_adjust'><p>conf_adjust: a function to procrustes adjust two matrices</p></a></li>
<li><a href='#doubleCenter'><p>double centering</p></a></li>
<li><a href='#enorm'><p>Explicit Norm</p></a></li>
<li><a href='#knn_dist'><p>calculate k nearest neighbours from a distance matrix</p></a></li>
<li><a href='#ljoptim'><p>(Adaptive) Version of Luus-Jaakola Optimization</p></a></li>
<li><a href='#lmds'><p>An function for local MDS (Chen &amp; Buja 2006)</p></a></li>
<li><a href='#mkBmat'><p>MkBmat function (internal)</p></a></li>
<li><a href='#mkPower'><p>MakePower Old</p></a></li>
<li><a href='#mkPower2'><p>MakePower</p></a></li>
<li><a href='#Pendigits500'><p>Pen digits</p></a></li>
<li><a href='#plot.cmdscaleE'><p>S3 plot method for cmdscaleE</p></a></li>
<li><a href='#plot.smacofP'><p>S3 plot method for smacofP objects</p></a></li>
<li><a href='#plot.stops'><p>S3 plot method for stops objects</p></a></li>
<li><a href='#plot3d.cmdscaleE'><p>S3 plot3d method for class cmdscaleE</p></a></li>
<li><a href='#plot3d.stops'><p>S3 plot3d method for class stops</p></a></li>
<li><a href='#plot3dstatic'><p>plot3dstatic: static 3D plots</p></a></li>
<li><a href='#plot3dstatic.cmdscaleE'><p>3D plots: plot3dstatic method for class cmdscaleE</p></a></li>
<li><a href='#plot3dstatic.stops'><p>S3 plot3dstatic method for class stops</p></a></li>
<li><a href='#powerStressMin'><p>Power Stress SMACOF</p></a></li>
<li><a href='#print.cmdscale'><p>S3 print method for cmdscale</p></a></li>
<li><a href='#print.sammon'><p>S3 print method for sammon objects</p></a></li>
<li><a href='#print.stops'><p>S3 print method for stops objects</p></a></li>
<li><a href='#print.summary.smacofP'><p>S3 print method for summary.smacofP</p></a></li>
<li><a href='#print.summary.stops'><p>S3 print method for summary.stops</p></a></li>
<li><a href='#procruster'><p>procruster: a procrustes function</p></a></li>
<li><a href='#residuals.stops'><p>S3 residuals method for stops</p></a></li>
<li><a href='#sammon'><p>Wrapper to <code>sammon</code> for S3 class</p></a></li>
<li><a href='#secularEq'><p>Secular Equation</p></a></li>
<li><a href='#sqdist'><p>Squared distances</p></a></li>
<li><a href='#stop_apstress'><p>STOPS version of approximated power stress models.</p></a></li>
<li><a href='#stop_bcstress'><p>STOPS version of Box Cox Stress</p></a></li>
<li><a href='#stop_cmdscale'><p>STOPS version of strain</p></a></li>
<li><a href='#stop_elastic'><p>STOPS versions of elastic scaling models (via smacofSym)</p></a></li>
<li><a href='#stop_isomap1'><p>STOPS version of isomap to optimize over integer k.</p></a></li>
<li><a href='#stop_isomap2'><p>STOPS version of isomap over real epsilon.</p></a></li>
<li><a href='#stop_lmds'><p>STOPS version of lMDS</p></a></li>
<li><a href='#stop_powerelastic'><p>STOPS version of elastic scaling with powers for proximities and distances</p></a></li>
<li><a href='#stop_powermds'><p>STOPS version of powermds</p></a></li>
<li><a href='#stop_powersammon'><p>STOPS version of sammon with powers</p></a></li>
<li><a href='#stop_powerstress'><p>STOPS version of powerstress</p></a></li>
<li><a href='#stop_rpowerstress'><p>STOPS version of restricted powerstress</p></a></li>
<li><a href='#stop_rstress'><p>STOPS version of rstress</p></a></li>
<li><a href='#stop_sammon'><p>STOPS version of Sammon mapping</p></a></li>
<li><a href='#stop_sammon2'><p>Another STOPS version of Sammon mapping models (via smacofSym)</p></a></li>
<li><a href='#stop_smacofSphere'><p>STOPS versions of smacofSphere models</p></a></li>
<li><a href='#stop_smacofSym'><p>STOPS version of smacofSym models</p></a></li>
<li><a href='#stop_sstress'><p>STOPS version of sstress</p></a></li>
<li><a href='#stoploss'><p>Calculate the weighted multiobjective loss function used in STOPS</p></a></li>
<li><a href='#stops'><p>stops: structure optimized proximity scaling</p></a></li>
<li><a href='#summary.cmdscale'><p>S3 summary method for cmdscale</p></a></li>
<li><a href='#summary.sammon'><p>S3 summary method for sammon</p></a></li>
<li><a href='#summary.smacofP'><p>S3 summary method for smacofP</p></a></li>
<li><a href='#summary.stops'><p>S3 summary method for stops</p></a></li>
<li><a href='#Swissroll'><p>Swiss roll</p></a></li>
<li><a href='#tgpoptim'><p>Bayesian Optimization by a (treed) Bayesian Gaussian Process Prior (with jumps to linear models) surrogate model</p>
Essentially a wrapper for the functionality in tgp that has the same slots as optim with defaults for STOPS models.</a></li>
<li><a href='#torgerson'><p>Torgerson scaling</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Structure Optimized Proximity Scaling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-18</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Rusch [aut, cre],
  Jan de Leeuw [aut],
  Lisha Chen [aut],
  Patrick Mair [aut],
  Kurt Hornik [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Rusch &lt;thomas.rusch@wu.ac.at&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of methods that fit nonlinear distance transformations in multidimensional scaling (MDS) and trade-off the fit with structure considerations to find optimal parameters also known as structure optimized proximity scaling (STOPS) (Rusch, Mair &amp; Hornik, 2023,&lt;<a href="https://doi.org/10.1007%2Fs11222-022-10197-w">doi:10.1007/s11222-022-10197-w</a>&gt;). The package contains various functions, wrappers, methods and classes for fitting, plotting and displaying different MDS models in a STOPS framework like Torgerson (classical) scaling, scaling by majorizing a complex function (SMACOF), Sammon mapping, elastic scaling, symmetric SMACOF, spherical SMACOF, s-stress, r-stress, power MDS, power elastic scaling, power Sammon mapping, power stress MDS (POST-MDS), approximate power stress, Box-Cox MDS, local MDS and Isomap. All of these models can also be fit individually with given hyperparameters or by optimizing over hyperparameters based on fit only (i.e., no structure considerations). The package further contains functions for optimization, specifically the adaptive Luus-Jaakola algorithm and a wrapper for Bayesian optimization with treed Gaussian process with jumps to linear models, and functions for various c-structuredness indices.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), smacof, rgl</td>
</tr>
<tr>
<td>Imports:</td>
<td>cordillera, MASS, pso, scatterplot3d, acepack, minerva,
energy, DiceOptim, DiceKriging, tgp, pomp, vegan, scagnostics,
clue, cmaes, dfoptim, nloptr</td>
</tr>
<tr>
<td>Enhances:</td>
<td>stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sp, R.rsp</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-forge.r-project.org/projects/stops/">https://r-forge.r-project.org/projects/stops/</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-18 21:02:27 UTC; trusch</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-20 10:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='apStressMin'>Approximate Power Stress SMACOF</h2><span id='topic+apStressMin'></span>

<h3>Description</h3>

<p>Minimize approximate power stress by minimization-majorization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apStressMin(
  delta,
  tau = 1,
  ups = 1,
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  ndim = 2,
  eps = 1e-06,
  itmax = 1000,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apStressMin_+3A_delta">delta</code></td>
<td>
<p>dist object or a symmetric, numeric data.frame or matrix of distances</p>
</td></tr>
<tr><td><code id="apStressMin_+3A_tau">tau</code></td>
<td>
<p>the power of the transformation of the proximities; defaults to 1</p>
</td></tr>
<tr><td><code id="apStressMin_+3A_ups">ups</code></td>
<td>
<p>the power of the transformation for weightmat; defaults to 1</p>
</td></tr>
<tr><td><code id="apStressMin_+3A_weightmat">weightmat</code></td>
<td>
<p>a square, symmetric matrix of finite weights (same dimensions as delta)</p>
</td></tr>
<tr><td><code id="apStressMin_+3A_init">init</code></td>
<td>
<p>starting configuration</p>
</td></tr>
<tr><td><code id="apStressMin_+3A_ndim">ndim</code></td>
<td>
<p>dimension of the configuration; defaults to 2</p>
</td></tr>
<tr><td><code id="apStressMin_+3A_eps">eps</code></td>
<td>
<p>numeric accuracy of the iteration</p>
</td></tr>
<tr><td><code id="apStressMin_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="apStressMin_+3A_verbose">verbose</code></td>
<td>
<p>should iteration output be printed; if TRUE then yes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class 'smacofP' (inheriting from 'smacofB', see <code>smacofSym</code>). It is a list with the components
</p>

<ul>
<li><p> delta: Observed dissimilarities, not normalized
</p>
</li>
<li><p> obsdiss: Observed transformed dissimilarities
</p>
</li>
<li><p> dhats: Observed transformed dissimilarities, normalized 
</p>
</li>
<li><p> confdist: Configuration dissimilarities, NOT normalized 
</p>
</li>
<li><p> conf: Matrix of fitted configuration, NOT normalized
</p>
</li>
<li><p> stress: Default stress  (stress 1; sqrt of explicitly normalized stress)
</p>
</li>
<li><p> spp: Stress per point (based on stress.en) 
</p>
</li>
<li><p> ndim: Number of dimensions
</p>
</li>
<li><p> model: Name of MDS model
</p>
</li>
<li><p> niter: Number of iterations
</p>
</li>
<li><p> nobj: Number of objects
</p>
</li>
<li><p> type: Type of MDS model
</p>
</li>
<li><p> weightmat: weighting matrix
</p>
</li>
<li><p> pars: hyperparameter vector theta
</p>
</li></ul>

<p>and some additional components
</p>

<ul>
<li><p> stress.m: default stress for the COPS and STOP defaults to the explicitly normalized stress on the normalized, transformed dissimilarities. The square of stress-1 in stress. 
</p>
</li>
<li><p> deltaorig: observed, untransformed dissimilarities
</p>
</li>
<li><p> tau: tau parameter
</p>
</li>
<li><p> ups: upsilon parameter 
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thomas Rusch
</p>


<h3>See Also</h3>

<p><code>smacofSym</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-smacof::kinshipdelta
res&lt;-apStressMin(as.matrix(dis),tau=2,ups=0.7)
res
summary(res)
plot(res)

</code></pre>

<hr>
<h2 id='BankingCrisesDistances'>Banking Crises Distances</h2><span id='topic+BankingCrisesDistances'></span>

<h3>Description</h3>

<p>Matrix of Jaccard distances between 70 countries (Hungary and Greece were combined to be the same observation) based on their binary time series of having had a banking crises in a year from 1800 to 2010 or not. See data(bankingCrises) in package Ecdat for more info. The last column is Reinhart &amp; Rogoffs classification as a low (3), middle- (2) or high-income country (1).
</p>


<h3>Format</h3>

<p>A 69 x 70 matrix.
</p>


<h3>Source</h3>

<p>data(bankingCrises) in library(Ecdat)
</p>

<hr>
<h2 id='bcStressMin'>An MDS version for minimizing BoxCox Stress (Chen &amp; Buja 2013)</h2><span id='topic+bcStressMin'></span>

<h3>Description</h3>

<p>An MDS version for minimizing BoxCox Stress (Chen &amp; Buja 2013)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bcStressMin(
  delta,
  init = NULL,
  verbose = 0,
  ndim = 2,
  mu = 1,
  lambda = 1,
  rho = 0,
  itmax = 2000,
  addD0 = 1e-04
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bcStressMin_+3A_delta">delta</code></td>
<td>
<p>dissimilarity or distance matrix</p>
</td></tr>
<tr><td><code id="bcStressMin_+3A_init">init</code></td>
<td>
<p>initial configuration. If NULL a classical scaling solution is used.</p>
</td></tr>
<tr><td><code id="bcStressMin_+3A_verbose">verbose</code></td>
<td>
<p>prints progress if &gt; 3.</p>
</td></tr>
<tr><td><code id="bcStressMin_+3A_ndim">ndim</code></td>
<td>
<p>the dimension of the configuration</p>
</td></tr>
<tr><td><code id="bcStressMin_+3A_mu">mu</code></td>
<td>
<p>mu parameter. Should be 0 or larger for everything working ok. If mu&lt;0 it works but the model is strange and normalized stress tends towards 0 regardless of fit. Use normalized stress at your own risk in that case.</p>
</td></tr>
<tr><td><code id="bcStressMin_+3A_lambda">lambda</code></td>
<td>
<p>lambda parameter. Must be larger than 0.</p>
</td></tr>
<tr><td><code id="bcStressMin_+3A_rho">rho</code></td>
<td>
<p>the rho parameter.</p>
</td></tr>
<tr><td><code id="bcStressMin_+3A_itmax">itmax</code></td>
<td>
<p>number of optimizing iterations, defaults to 2000.</p>
</td></tr>
<tr><td><code id="bcStressMin_+3A_addd0">addD0</code></td>
<td>
<p>a small number that's added for D(X)=0 for numerical evaluation of worst fit (numerical reasons, see details). If addD0=0 the normalized stress for mu!=0 and mu+lambda!=0 is correct, but will give useless normalized stress for mu=0 or mu+lambda!=0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For numerical reasons with certain parameter combinations, the normalized stress uses a configuration as worst result where every d(X) is 0+addD0. The same number is not added to the delta so there is a small inaccuracy of the normalized stress (but negligible if min(delta)&gt;&gt;addD0). Also, for mu&lt;0 or mu+lambda&lt;0 the normalization cannot generally be trusted (in the worst case of D(X)=0 one would have an 0^(-a)).
</p>


<h3>Value</h3>

<p>an object of class 'bcmds' (also inherits from 'smacofP'). It is a list with the components
</p>

<ul>
<li><p> delta: Observed dissimilarities, not normalized
</p>
</li>
<li><p> obsdiss: Observed transformed dissimilarities, not normalized
</p>
</li>
<li><p> confdist: Configuration dissimilarities, NOT normalized 
</p>
</li>
<li><p> conf: Matrix of fitted configuration, NOT normalized
</p>
</li>
<li><p> stress: Default stress  (stress 1; sqrt of explicitly normalized stress)
</p>
</li>
<li><p> ndim: Number of dimensions
</p>
</li>
<li><p> model: Name of MDS model
</p>
</li>
<li><p> niter: Number of iterations
</p>
</li>
<li><p> nobj: Number of objects
</p>
</li>
<li><p> pars: hyperparameter vector theta 
</p>
</li></ul>

<p>and some additional components
</p>

<ul>
<li><p> stress.m: default stress is the explicitly normalized stress on the normalized, transformed dissimilarities
</p>
</li>
<li><p> deltaorig: observed, untransformed dissimilarities
</p>
</li>
<li><p> mu: mu parameter (for attraction)
</p>
</li>
<li><p> lambda: lambda parameter (for repulsion)
</p>
</li>
<li><p> rho: rho parameter (for weights) 
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Lisha Chen &amp; Thomas Rusch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-smacof::kinshipdelta
res&lt;-bcStressMin(as.matrix(dis),mu=2,lambda=1.5,rho=0)
res
summary(res)
plot(res)

</code></pre>

<hr>
<h2 id='c_association'>c-association
calculates the c-association based on the maximal information coefficient 
We define c-association as the aggregated association between any two columns in confs</h2><span id='topic+c_association'></span>

<h3>Description</h3>

<p>c-association
calculates the c-association based on the maximal information coefficient 
We define c-association as the aggregated association between any two columns in confs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_association(
  confs,
  aggr = max,
  alpha = 0.6,
  C = 15,
  var.thr = 1e-05,
  zeta = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_association_+3A_confs">confs</code></td>
<td>
<p>a numeric matrix or data frame</p>
</td></tr>
<tr><td><code id="c_association_+3A_aggr">aggr</code></td>
<td>
<p>the aggregation function for configurations of more than two dimensions. Defaults to max.</p>
</td></tr>
<tr><td><code id="c_association_+3A_alpha">alpha</code></td>
<td>
<p>an optional number of cells allowed in the X-by-Y search-grid. Default value is 0.6</p>
</td></tr>
<tr><td><code id="c_association_+3A_c">C</code></td>
<td>
<p>an optional number determining the starting point of the X-by-Y search-grid. When trying to partition the x-axis into X columns, the algorithm will start with at most C X clumps. Default value is 15.</p>
</td></tr>
<tr><td><code id="c_association_+3A_var.thr">var.thr</code></td>
<td>
<p>minimum value allowed for the variance of the input variables, since mine can not be computed in case of variance close to 0. Default value is 1e-5.</p>
</td></tr>
<tr><td><code id="c_association_+3A_zeta">zeta</code></td>
<td>
<p>integer in [0,1] (?).  If NULL (default) it is set to 1-MIC. It can be set to zero for noiseless functions, but the default choice is the most appropriate parametrization for general cases (as stated in Reshef et al). It provides robustness.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; association (aggregated maximal information coefficient MIC, see <code><a href="minerva.html#topic+mine">mine</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-seq(-3,3,length.out=200)
y&lt;-sqrt(3^2-x^2)
z&lt;- sin(y-x)
confs&lt;-cbind(x,y,z)
c_association(confs)
</code></pre>

<hr>
<h2 id='c_clumpiness'>c-clumpiness</h2><span id='topic+c_clumpiness'></span>

<h3>Description</h3>

<p>Measures the c-clumpiness structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_clumpiness(conf, aggr = max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_clumpiness_+3A_conf">conf</code></td>
<td>
<p>A numeric matrix.</p>
</td></tr>
<tr><td><code id="c_clumpiness_+3A_aggr">aggr</code></td>
<td>
<p>the aggregation function for configurations of more than two dimensions. Defaults to max.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; clumpiness (see <code>scagnostics</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delts&lt;-smacof::kinshipdelta
conf&lt;-smacof::smacofSym(delts)$conf
plot(conf,pch=19,asp=1)
c_clumpiness(conf)
</code></pre>

<hr>
<h2 id='c_clusteredness'>c-clusteredness 
calculates c-clusteredness as the OPTICS cordillera. The higher the more clustered.</h2><span id='topic+c_clusteredness'></span>

<h3>Description</h3>

<p>c-clusteredness 
calculates c-clusteredness as the OPTICS cordillera. The higher the more clustered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_clusteredness(
  confs,
  minpts = 2,
  q = 2,
  epsilon = 2 * max(dist(confs)),
  distmeth = "euclidean",
  dmax = NULL,
  digits = 10,
  scale = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_clusteredness_+3A_confs">confs</code></td>
<td>
<p>a numeric matrix or a dist object</p>
</td></tr>
<tr><td><code id="c_clusteredness_+3A_minpts">minpts</code></td>
<td>
<p>The minimum number of points that must make up a cluster in OPTICS (corresponds to k in the paper). It is passed to <code><a href="dbscan.html#topic+optics">optics</a></code> where it is called minPts. Defaults to 2.</p>
</td></tr>
<tr><td><code id="c_clusteredness_+3A_q">q</code></td>
<td>
<p>The norm used for the Cordillera. Defaults to 2.</p>
</td></tr>
<tr><td><code id="c_clusteredness_+3A_epsilon">epsilon</code></td>
<td>
<p>The epsilon parameter for OPTICS (called epsilon_max in the paper). Defaults to 2 times the maximum distance between any two points.</p>
</td></tr>
<tr><td><code id="c_clusteredness_+3A_distmeth">distmeth</code></td>
<td>
<p>The distance to be computed if X is not a symmetric matrix or a dist object (otherwise ignored). Defaults to Euclidean distance.</p>
</td></tr>
<tr><td><code id="c_clusteredness_+3A_dmax">dmax</code></td>
<td>
<p>The winsorization value for the highest allowed reachability. If used for comparisons between different configurations this should be supplied. If no value is supplied, it is NULL (default); then dmax is taken from the data as the either epsilon or the largest reachability, whatever is smaller.</p>
</td></tr>
<tr><td><code id="c_clusteredness_+3A_digits">digits</code></td>
<td>
<p>The precision to round the raw Cordillera and the norm factor. Defaults to 10.</p>
</td></tr>
<tr><td><code id="c_clusteredness_+3A_scale">scale</code></td>
<td>
<p>Should X be scaled if it is an asymmetric matrix or data frame? Can take values TRUE or FALSE or a numeric value. If TRUE or 1, standardisation is to mean=0 and sd=1. If 2, no centering is applied and scaling of each column is done with the root mean square of each column. If 3, no centering is applied and scaling of all columns is done as X/max(standard deviation(allcolumns)). If 4, no centering is applied and scaling of all columns is done as X/max(rmsq(allcolumns)). If FALSE, 0 or any other numeric value, no standardisation is applied. Defaults to 0.</p>
</td></tr>
<tr><td><code id="c_clusteredness_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>cordillera::cordillera</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; clusteredness (see <code><a href="cordillera.html#topic+cordillera">cordillera</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delts&lt;-smacof::kinshipdelta
dis&lt;-smacofSym(delts)$confdist
c_clusteredness(dis,minpts=3)
</code></pre>

<hr>
<h2 id='c_complexity'>c-complexity
Calculates the c-complexity based on the minimum cell number
We define c-complexity as the aggregated minimum cell number between any two columns in confs 
This is one of few c-structuredness indices not between 0 and 1, but can be between 0 and (theoretically) infinity</h2><span id='topic+c_complexity'></span>

<h3>Description</h3>

<p>c-complexity
Calculates the c-complexity based on the minimum cell number
We define c-complexity as the aggregated minimum cell number between any two columns in confs 
This is one of few c-structuredness indices not between 0 and 1, but can be between 0 and (theoretically) infinity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_complexity(
  confs,
  aggr = min,
  alpha = 1,
  C = 15,
  var.thr = 1e-05,
  zeta = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_complexity_+3A_confs">confs</code></td>
<td>
<p>a numeric matrix or data frame</p>
</td></tr>
<tr><td><code id="c_complexity_+3A_aggr">aggr</code></td>
<td>
<p>the aggregation function for configurations of more than two dimensions. Defaults to min.</p>
</td></tr>
<tr><td><code id="c_complexity_+3A_alpha">alpha</code></td>
<td>
<p>an optional number of cells allowed in the X-by-Y search-grid. Default value is 1</p>
</td></tr>
<tr><td><code id="c_complexity_+3A_c">C</code></td>
<td>
<p>an optional number determining the starting point of the X-by-Y search-grid. When trying to partition the x-axis into X columns, the algorithm will start with at most C X clumps. Default value is 15.</p>
</td></tr>
<tr><td><code id="c_complexity_+3A_var.thr">var.thr</code></td>
<td>
<p>minimum value allowed for the variance of the input variables, since mine can not be computed in case of variance close to 0. Default value is 1e-5.</p>
</td></tr>
<tr><td><code id="c_complexity_+3A_zeta">zeta</code></td>
<td>
<p>integer in [0,1] (?).  If NULL (default) it is set to 1-MIC. It can be set to zero for noiseless functions, but the default choice is the most appropriate parametrization for general cases (as stated in Reshef et al.). It provides robustness.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; complexity (aggregated minimum cell number MCN, see <code><a href="minerva.html#topic+mine">mine</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-seq(-3,3,length.out=200)
y&lt;-sqrt(3^2-x^2)
z&lt;- sin(y-x)
confs&lt;-cbind(x,y,z)
c_complexity(confs)
</code></pre>

<hr>
<h2 id='c_convexity'>c-convexity</h2><span id='topic+c_convexity'></span>

<h3>Description</h3>

<p>Measures the c-convexity structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_convexity(conf, aggr = max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_convexity_+3A_conf">conf</code></td>
<td>
<p>A numeric matrix.</p>
</td></tr>
<tr><td><code id="c_convexity_+3A_aggr">aggr</code></td>
<td>
<p>the aggregation function for configurations of more than two dimensions. Defaults to max.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; convexity (see <code>scagnostics</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delts&lt;-smacof::kinshipdelta
conf&lt;-smacof::smacofSym(delts)$conf
plot(conf,pch=19,asp=1)
c_convexity(conf)
</code></pre>

<hr>
<h2 id='c_dependence'>c-dependence
calculates c-dependence as the aggregated distance correlation of each pair if nonidentical columns</h2><span id='topic+c_dependence'></span>

<h3>Description</h3>

<p>c-dependence
calculates c-dependence as the aggregated distance correlation of each pair if nonidentical columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_dependence(confs, aggr = max, index = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_dependence_+3A_confs">confs</code></td>
<td>
<p>a numeric matrix or data frame</p>
</td></tr>
<tr><td><code id="c_dependence_+3A_aggr">aggr</code></td>
<td>
<p>the aggregation function for configurations of more than two dimensions. Defaults to max.</p>
</td></tr>
<tr><td><code id="c_dependence_+3A_index">index</code></td>
<td>
<p>exponent on Euclidean distance, in (0,2]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; dependence (aggregated distance correlation)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-1:10
y&lt;-2+3*x+rnorm(10)
confs&lt;-cbind(x,y)
c_dependence(confs,1.5)
</code></pre>

<hr>
<h2 id='c_faithfulness'>c-faithfulness 
calculates the c-faithfulness based on the index by Chen and Buja 2013 (M_adj) with equal input neigbourhoods</h2><span id='topic+c_faithfulness'></span>

<h3>Description</h3>

<p>c-faithfulness 
calculates the c-faithfulness based on the index by Chen and Buja 2013 (M_adj) with equal input neigbourhoods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_faithfulness(confs, obsdiss, k = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_faithfulness_+3A_confs">confs</code></td>
<td>
<p>a numeric matrix or a dist object</p>
</td></tr>
<tr><td><code id="c_faithfulness_+3A_obsdiss">obsdiss</code></td>
<td>
<p>a symmetric numeric matrix or a dist object</p>
</td></tr>
<tr><td><code id="c_faithfulness_+3A_k">k</code></td>
<td>
<p>the number of nearest neighbours to be looked at</p>
</td></tr>
<tr><td><code id="c_faithfulness_+3A_...">...</code></td>
<td>
<p>additional arguments passed to dist()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; faithfulness
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delts&lt;-smacof::kinshipdelta
dis&lt;-smacofSym(delts)$confdist
c_faithfulness(dis,delts,k=3)
</code></pre>

<hr>
<h2 id='c_functionality'>c-functionality
calculates the c-functionality based on the maximum edge value 
We define c-functionality as the aggregated functionality between any two columns of confs</h2><span id='topic+c_functionality'></span>

<h3>Description</h3>

<p>c-functionality
calculates the c-functionality based on the maximum edge value 
We define c-functionality as the aggregated functionality between any two columns of confs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_functionality(
  confs,
  aggr = max,
  alpha = 1,
  C = 15,
  var.thr = 1e-05,
  zeta = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_functionality_+3A_confs">confs</code></td>
<td>
<p>a numeric matrix or data frame</p>
</td></tr>
<tr><td><code id="c_functionality_+3A_aggr">aggr</code></td>
<td>
<p>the aggregation function for configurations of more than two dimensions. Defaults to mean</p>
</td></tr>
<tr><td><code id="c_functionality_+3A_alpha">alpha</code></td>
<td>
<p>an optional number of cells allowed in the X-by-Y search-grid. Default value is 1</p>
</td></tr>
<tr><td><code id="c_functionality_+3A_c">C</code></td>
<td>
<p>an optional number determining the starting point of the X-by-Y search-grid. When trying to partition the x-axis into X columns, the algorithm will start with at most C X clumps. Default value is 15.</p>
</td></tr>
<tr><td><code id="c_functionality_+3A_var.thr">var.thr</code></td>
<td>
<p>minimum value allowed for the variance of the input variables, since mine can not be computed in case of variance close to 0. Default value is 1e-5.</p>
</td></tr>
<tr><td><code id="c_functionality_+3A_zeta">zeta</code></td>
<td>
<p>integer in [0,1] (?).  If NULL (default) it is set to 1-MIC. It can be set to zero for noiseless functions, but the default choice is the most appropriate parametrization for general cases (as stated in Reshef et al.). It provides robustness.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; functionality (aggregated maximaum edge value MEV, see <code><a href="minerva.html#topic+mine">mine</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-seq(-3,3,length.out=200)
y&lt;-sqrt(3^2-x^2)
z&lt;- sin(y-x)
confs&lt;-cbind(x,y,z)
c_functionality(confs)
</code></pre>

<hr>
<h2 id='c_hierarchy'>c-hierarchy
captures how well a partition/ultrametric (obtained by hclust) explains the configuration distances. Uses variance explained for euclidean distances and deviance explained for everything else.</h2><span id='topic+c_hierarchy'></span>

<h3>Description</h3>

<p>c-hierarchy
captures how well a partition/ultrametric (obtained by hclust) explains the configuration distances. Uses variance explained for euclidean distances and deviance explained for everything else.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_hierarchy(confs, p = 2, agglmethod = "complete")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_hierarchy_+3A_confs">confs</code></td>
<td>
<p>a numeric matrix</p>
</td></tr>
<tr><td><code id="c_hierarchy_+3A_p">p</code></td>
<td>
<p>the parameter of the Minokwski distances (p=2 euclidean and p=1 is manhattan)</p>
</td></tr>
<tr><td><code id="c_hierarchy_+3A_agglmethod">agglmethod</code></td>
<td>
<p>the method used for creating the clustering, see <code><a href="stats.html#topic+hclust">hclust</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; hierarchy (see <code><a href="clue.html#topic+cl_validity">cl_validity</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delts&lt;-smacof::kinshipdelta
conf&lt;-smacofSym(delts)$conf
c_hierarchy(conf,p=2,agglmethod="single")
</code></pre>

<hr>
<h2 id='c_inequality'>c-inequality
Calculates c-inequality (as in an economic measure of inequality) as Pearsons coefficient of variation of the fitted distance matrix. This can help with avoiding degenerate solutions.   
This is one of few c-structuredness indices not between 0 and 1, but 0 and infinity.</h2><span id='topic+c_inequality'></span>

<h3>Description</h3>

<p>c-inequality
Calculates c-inequality (as in an economic measure of inequality) as Pearsons coefficient of variation of the fitted distance matrix. This can help with avoiding degenerate solutions.   
This is one of few c-structuredness indices not between 0 and 1, but 0 and infinity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_inequality(confs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_inequality_+3A_confs">confs</code></td>
<td>
<p>a numeric matrix or data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; inequality (Pearsons coefficient of variation of the fitted distance matrix)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-1:10
y&lt;-2+3*x+rnorm(10)
z&lt;- sin(y-x)
confs&lt;-cbind(z,y,x)
c_inequality(confs)
</code></pre>

<hr>
<h2 id='c_linearity'>c-linearity
calculates c-linearity as the aggregated multiple correlation of all columns of the configuration.</h2><span id='topic+c_linearity'></span>

<h3>Description</h3>

<p>c-linearity
calculates c-linearity as the aggregated multiple correlation of all columns of the configuration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_linearity(confs, aggr = max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_linearity_+3A_confs">confs</code></td>
<td>
<p>a numeric matrix or data frame</p>
</td></tr>
<tr><td><code id="c_linearity_+3A_aggr">aggr</code></td>
<td>
<p>the aggregation function for configurations of more than two dimensions. Defaults to max.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; linearity (aggregated multiple correlation of all columns of the configuration)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-1:10
y&lt;-2+3*x+rnorm(10)
z&lt;- sin(y-x)
confs&lt;-cbind(z,y,x)
c_linearity(confs)
</code></pre>

<hr>
<h2 id='c_manifoldness'>c-manifoldness
calculates c-manifoldness as the aggregated maximal correlation coefficient (i.e., Pearson correlation of the ACE transformed variables) of all pairwise combinations of two different columns in confs. If there is an NA (happens usually when the optimal transformation of any variable is a constant and therefore the covariance is 0 but also one of the sds in the denominator), it gets skipped.</h2><span id='topic+c_manifoldness'></span>

<h3>Description</h3>

<p>c-manifoldness
calculates c-manifoldness as the aggregated maximal correlation coefficient (i.e., Pearson correlation of the ACE transformed variables) of all pairwise combinations of two different columns in confs. If there is an NA (happens usually when the optimal transformation of any variable is a constant and therefore the covariance is 0 but also one of the sds in the denominator), it gets skipped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_manifoldness(confs, aggr = max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_manifoldness_+3A_confs">confs</code></td>
<td>
<p>a numeric matrix or data frame</p>
</td></tr>
<tr><td><code id="c_manifoldness_+3A_aggr">aggr</code></td>
<td>
<p>the aggregation function for configurations of more than two dimensions. Defaults to max.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; manifoldness (aggregated maximal correlation, correlation of ACE tranformed x and y, see <code><a href="acepack.html#topic+ace">ace</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;--100:100
y&lt;-sqrt(100^2-x^2)
confs&lt;-cbind(x,y)
c_manifoldness(confs)
</code></pre>

<hr>
<h2 id='c_mine'>wrapper for getting the mine coefficients</h2><span id='topic+c_mine'></span>

<h3>Description</h3>

<p>wrapper for getting the mine coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_mine(confs, master = NULL, alpha = 0.6, C = 15, var.thr = 1e-05, zeta = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_mine_+3A_confs">confs</code></td>
<td>
<p>a numeric matrix or data frame with two columns</p>
</td></tr>
<tr><td><code id="c_mine_+3A_master">master</code></td>
<td>
<p>the master column</p>
</td></tr>
<tr><td><code id="c_mine_+3A_alpha">alpha</code></td>
<td>
<p>an optional number of cells allowed in the X-by-Y search-grid. Default value is 0.6</p>
</td></tr>
<tr><td><code id="c_mine_+3A_c">C</code></td>
<td>
<p>an optional number determining the starting point of the X-by-Y search-grid. When trying to partition the x-axis into X columns, the algorithm will start with at most C X clumps. Default value is 15.</p>
</td></tr>
<tr><td><code id="c_mine_+3A_var.thr">var.thr</code></td>
<td>
<p>minimum value allowed for the variance of the input variables, since mine can not be computed in case of variance close to 0. Default value is 1e-5.</p>
</td></tr>
<tr><td><code id="c_mine_+3A_zeta">zeta</code></td>
<td>
<p>integer in [0,1] (?).  If NULL (default) it is set to 1-MIC. It can be set to zero for noiseless functions, but the default choice is the most appropriate parametrization for general cases (as stated in Reshef et al. SOM; they call it epsilon in the paper). It provides robustness.</p>
</td></tr>
</table>

<hr>
<h2 id='c_nonmonotonicity'>c-nonmonotonicity
calculates the c-nonmonotonicity based on the maximum asymmetric score 
We define c-nonmonotonicity as the aggregated nonmonotonicity between any two columns in confs
this is one of few c-structuredness indices not between 0 and 1</h2><span id='topic+c_nonmonotonicity'></span>

<h3>Description</h3>

<p>c-nonmonotonicity
calculates the c-nonmonotonicity based on the maximum asymmetric score 
We define c-nonmonotonicity as the aggregated nonmonotonicity between any two columns in confs
this is one of few c-structuredness indices not between 0 and 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_nonmonotonicity(
  confs,
  aggr = max,
  alpha = 1,
  C = 15,
  var.thr = 1e-05,
  zeta = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_nonmonotonicity_+3A_confs">confs</code></td>
<td>
<p>a numeric matrix or data frame</p>
</td></tr>
<tr><td><code id="c_nonmonotonicity_+3A_aggr">aggr</code></td>
<td>
<p>the aggregation function for configurations of more than two dimensions. Defaults to max.</p>
</td></tr>
<tr><td><code id="c_nonmonotonicity_+3A_alpha">alpha</code></td>
<td>
<p>an optional number of cells allowed in the X-by-Y search-grid. Default value is 1</p>
</td></tr>
<tr><td><code id="c_nonmonotonicity_+3A_c">C</code></td>
<td>
<p>an optional number determining the starting point of the X-by-Y search-grid. When trying to partition the x-axis into X columns, the algorithm will start with at most C X clumps. Default value is 15.</p>
</td></tr>
<tr><td><code id="c_nonmonotonicity_+3A_var.thr">var.thr</code></td>
<td>
<p>minimum value allowed for the variance of the input variables, since mine can not be computed in case of variance close to 0. Default value is 1e-5.</p>
</td></tr>
<tr><td><code id="c_nonmonotonicity_+3A_zeta">zeta</code></td>
<td>
<p>integer in [0,1] (?).  If NULL (default) it is set to 1-MIC. It can be set to zero for noiseless functions, but the default choice is the most appropriate parametrization for general cases (as stated in Reshef et al. SOM). It provides robustness.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; nonmonotonicity (aggregated maximal asymmetric score MAS, see <code><a href="minerva.html#topic+mine">mine</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-seq(-3,3,length.out=200)
y&lt;-sqrt(3^2-x^2)
z&lt;- sin(y-x)
confs&lt;-cbind(x,y,z)
c_nonmonotonicity(confs)
</code></pre>

<hr>
<h2 id='c_outlying'>c-outlying</h2><span id='topic+c_outlying'></span>

<h3>Description</h3>

<p>Measures the c-outlying structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_outlying(conf, aggr = max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_outlying_+3A_conf">conf</code></td>
<td>
<p>A numeric matrix.</p>
</td></tr>
<tr><td><code id="c_outlying_+3A_aggr">aggr</code></td>
<td>
<p>the aggregation function for configurations of more than two dimensions. Defaults to max.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; outlying (see <code>scagnostics</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delts&lt;-smacof::kinshipdelta
conf3&lt;-smacof::smacofSym(delts,ndim=3)$conf
c_outlying(conf3)
</code></pre>

<hr>
<h2 id='c_regularity'>c-regularity 
calculates c-regularity as 1 - OPTICS cordillera for k=2. The higher the more regular.</h2><span id='topic+c_regularity'></span>

<h3>Description</h3>

<p>c-regularity 
calculates c-regularity as 1 - OPTICS cordillera for k=2. The higher the more regular.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_regularity(
  confs,
  q = 1,
  epsilon = 2 * max(dist(confs)),
  distmeth = "euclidean",
  dmax = NULL,
  digits = 10,
  scale = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_regularity_+3A_confs">confs</code></td>
<td>
<p>a numeric matrix or a dist object</p>
</td></tr>
<tr><td><code id="c_regularity_+3A_q">q</code></td>
<td>
<p>The norm used for the Cordillera. Defaults to 1 (and should always be 1 imo).</p>
</td></tr>
<tr><td><code id="c_regularity_+3A_epsilon">epsilon</code></td>
<td>
<p>The epsilon parameter for OPTICS (called epsilon_max in the paper). Defaults to 2 times the maximum distance between any two points.</p>
</td></tr>
<tr><td><code id="c_regularity_+3A_distmeth">distmeth</code></td>
<td>
<p>The distance to be computed if X is not a symmetric matrix or a dist object (otherwise ignored). Defaults to Euclidean distance.</p>
</td></tr>
<tr><td><code id="c_regularity_+3A_dmax">dmax</code></td>
<td>
<p>The winsorization value for the highest allowed reachability. If used for comparisons this should be supplied. If no value is supplied, it is NULL (default), then dmax is taken from the data as minimum of epsilon or the largest reachability.</p>
</td></tr>
<tr><td><code id="c_regularity_+3A_digits">digits</code></td>
<td>
<p>The precision to round the raw Cordillera and the norm factor. Defaults to 10.</p>
</td></tr>
<tr><td><code id="c_regularity_+3A_scale">scale</code></td>
<td>
<p>Should X be scaled if it is an asymmetric matrix or data frame? Can take values TRUE or FALSE or a numeric value. If TRUE or 1, standardisation is to mean=0 and sd=1. If 2, no centering is applied and scaling of each column is done with the root mean square of each column. If 3, no centering is applied and scaling of all columns is done as X/max(standard deviation(allcolumns)). If 4, no centering is applied and scaling of all columns is done as X/max(rmsq(allcolumns)). If FALSE, 0 or any other numeric value, no standardisation is applied. Defaults to 0.</p>
</td></tr>
<tr><td><code id="c_regularity_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="cordillera.html#topic+cordillera">cordillera</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; regularity
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hpts&lt;-expand.grid(seq(-5,5),seq(-5,5))
c_regularity(hpts)
hpts2&lt;-cbind(jitter(hpts[,1]),jitter(hpts[,2]))
c_regularity(hpts2)
</code></pre>

<hr>
<h2 id='c_skinniness'>c-skinniness</h2><span id='topic+c_skinniness'></span>

<h3>Description</h3>

<p>Measures the c-skinniness structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_skinniness(conf, aggr = max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_skinniness_+3A_conf">conf</code></td>
<td>
<p>A numeric matrix.</p>
</td></tr>
<tr><td><code id="c_skinniness_+3A_aggr">aggr</code></td>
<td>
<p>the aggregation function for configurations of more than two dimensions. Defaults to max.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; skininess (see <code>scagnostics</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delts&lt;-smacof::kinshipdelta
conf&lt;-smacof::smacofSym(delts)$conf
plot(conf,pch=19,asp=1)
c_skinniness(conf)
</code></pre>

<hr>
<h2 id='c_sparsity'>c-sparsity</h2><span id='topic+c_sparsity'></span>

<h3>Description</h3>

<p>Measures the c-sparsity structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_sparsity(conf, aggr = max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_sparsity_+3A_conf">conf</code></td>
<td>
<p>A numeric matrix.</p>
</td></tr>
<tr><td><code id="c_sparsity_+3A_aggr">aggr</code></td>
<td>
<p>the aggregation function for configurations of more than two dimensions. Defaults to max.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; sparsity (see <code>scagnostics</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delts&lt;-smacof::kinshipdelta
conf&lt;-smacof::smacofSym(delts)$conf
plot(conf,pch=19,asp=1)
c_sparsity(conf)
</code></pre>

<hr>
<h2 id='c_striatedness'>c-striatedness</h2><span id='topic+c_striatedness'></span>

<h3>Description</h3>

<p>Measures the c-striatedness structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_striatedness(conf, aggr = max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_striatedness_+3A_conf">conf</code></td>
<td>
<p>A numeric matrix.</p>
</td></tr>
<tr><td><code id="c_striatedness_+3A_aggr">aggr</code></td>
<td>
<p>the aggregation function for configurations of more than two dimensions. Defaults to max.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; striatedness (see <code>scagnostics</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delts&lt;-smacof::kinshipdelta
conf&lt;-smacof::smacofSym(delts)$conf
plot(conf,pch=19,asp=1)
c_striatedness(conf)
</code></pre>

<hr>
<h2 id='c_stringiness'>c-stringiness</h2><span id='topic+c_stringiness'></span>

<h3>Description</h3>

<p>Measures the c-stringiness structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_stringiness(conf, aggr = max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_stringiness_+3A_conf">conf</code></td>
<td>
<p>A numeric matrix.</p>
</td></tr>
<tr><td><code id="c_stringiness_+3A_aggr">aggr</code></td>
<td>
<p>the aggregation function for configurations of more than two dimensions. Defaults to max.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value; stringiness (see <code>scagnostics</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delts&lt;-smacof::kinshipdelta
conf&lt;-smacof::smacofSym(delts)$conf
plot(conf,pch=19,asp=1)
c_stringiness(conf)
</code></pre>

<hr>
<h2 id='cmds'>normalization function
Classical Scaling</h2><span id='topic+cmds'></span>

<h3>Description</h3>

<p>normalization function
Classical Scaling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmds(Do)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmds_+3A_do">Do</code></td>
<td>
<p>dissimilarity matrix</p>
</td></tr>
</table>

<hr>
<h2 id='cmdscale'>Wrapper to <code>cmdscale</code> for S3 class</h2><span id='topic+cmdscale'></span>

<h3>Description</h3>

<p>Wrapper to <code>cmdscale</code> for S3 class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmdscale(d, k = 2, eig = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmdscale_+3A_d">d</code></td>
<td>
<p>a distance structure such as that returned by 'dist' or a full symmetric matrix containing the dissimilarities</p>
</td></tr>
<tr><td><code id="cmdscale_+3A_k">k</code></td>
<td>
<p>the maximum dimension of the space which the data are to be represented in</p>
</td></tr>
<tr><td><code id="cmdscale_+3A_eig">eig</code></td>
<td>
<p>indicates whether eigenvalues should be returned.</p>
</td></tr>
<tr><td><code id="cmdscale_+3A_...">...</code></td>
<td>
<p>additional parameters passed to cmdscale. See <code><a href="#topic+cmdscale">cmdscale</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>overloads base::cmdscale and adds class attributes for which there are methods. The functionality is duplicated in the cops package.
</p>


<h3>Value</h3>

<p>An object of class 'cmdscaleE' and inheriting from <code><a href="#topic+cmdscale">cmdscale</a></code>. This function just adds an extra slot to the list with the call, adds column labels to the $points.
</p>

<hr>
<h2 id='coef.stops'>S3 coef method for stops objects</h2><span id='topic+coef.stops'></span>

<h3>Description</h3>

<p>S3 coef method for stops objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stops'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.stops_+3A_object">object</code></td>
<td>
<p>object of class stops</p>
</td></tr>
<tr><td><code id="coef.stops_+3A_...">...</code></td>
<td>
<p>addditional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of hyperparmeters theta
</p>

<hr>
<h2 id='conf_adjust'>conf_adjust: a function to procrustes adjust two matrices</h2><span id='topic+conf_adjust'></span>

<h3>Description</h3>

<p>conf_adjust: a function to procrustes adjust two matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conf_adjust(conf1, conf2, verbose = FALSE, eps = 1e-12, itmax = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conf_adjust_+3A_conf1">conf1</code></td>
<td>
<p>reference configuration, a numeric matrix</p>
</td></tr>
<tr><td><code id="conf_adjust_+3A_conf2">conf2</code></td>
<td>
<p>another configuration to be adjusted, a numeric matrix</p>
</td></tr>
<tr><td><code id="conf_adjust_+3A_verbose">verbose</code></td>
<td>
<p>should adjustment be output; default to FALSE</p>
</td></tr>
<tr><td><code id="conf_adjust_+3A_eps">eps</code></td>
<td>
<p>numerical accuracy</p>
</td></tr>
<tr><td><code id="conf_adjust_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of configuration matrices. The 'ref.conf' is the reference configuration, the 'other.conf' is the Procrustes adjusted configuration and the 'comparison.conf' is the one that was adjusted.
</p>

<hr>
<h2 id='doubleCenter'>double centering</h2><span id='topic+doubleCenter'></span>

<h3>Description</h3>

<p>double centering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doubleCenter(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doubleCenter_+3A_x">x</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
</table>

<hr>
<h2 id='enorm'>Explicit Norm</h2><span id='topic+enorm'></span>

<h3>Description</h3>

<p>Explicit Norm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enorm(x, w = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enorm_+3A_x">x</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
<tr><td><code id="enorm_+3A_w">w</code></td>
<td>
<p>weight</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric scalar; the sum(w*x^2)
</p>

<hr>
<h2 id='knn_dist'>calculate k nearest neighbours from a distance matrix</h2><span id='topic+knn_dist'></span>

<h3>Description</h3>

<p>calculate k nearest neighbours from a distance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knn_dist(dis, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knn_dist_+3A_dis">dis</code></td>
<td>
<p>distance matrix</p>
</td></tr>
<tr><td><code id="knn_dist_+3A_k">k</code></td>
<td>
<p>number of nearest neighbours (Note that with a tie, the function returns the alphanumerically first one!)</p>
</td></tr>
</table>

<hr>
<h2 id='ljoptim'>(Adaptive) Version of Luus-Jaakola Optimization</h2><span id='topic+ljoptim'></span>

<h3>Description</h3>

<p>Adaptive means that the search space reduction factors in the number of iterations; makes convergence faster at about 100 iterations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ljoptim(
  x,
  fun,
  ...,
  red = ifelse(adaptive, 0.99, 0.95),
  lower,
  upper,
  acc = 1e-06,
  accd = 1e-04,
  itmax = 1000,
  verbose = 0,
  adaptive = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ljoptim_+3A_x">x</code></td>
<td>
<p>optional starting values</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_fun">fun</code></td>
<td>
<p>function to minimize</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the function to be optimized</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_red">red</code></td>
<td>
<p>value of the reduction of the search region</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_lower">lower</code></td>
<td>
<p>The lower contraints of the search region</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_upper">upper</code></td>
<td>
<p>The upper contraints of the search region</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_acc">acc</code></td>
<td>
<p>if the numerical accuracy of two successive target function values is below this, stop the optimization; defaults to 1e-6</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_accd">accd</code></td>
<td>
<p>if the width of the search space is below this, stop the optimization; defaults to 1e-4</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_adaptive">adaptive</code></td>
<td>
<p>should the adaptive version be used? defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components (<code><a href="stats.html#topic+optim">optim</a></code>)
</p>

<ul>
<li><p> par The position of the optimimum in the search space (parameters that minimize the function; argmin fun)
</p>
</li>
<li><p> value The value of the objective function at the optimum (min fun)
</p>
</li>
<li><p> counts The number of iterations performed at convergence with entries fnction for the number of iterations and gradient which is always NA at the moment
</p>
</li>
<li><p> convergence 0 successful completion by the accd or acc criterion, 1 indicate iteration limit was reached, 99 is a problem 
</p>
</li>
<li><p> message is NULL (only for compatibility or future use)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>fbana &lt;- function(x) {
x1 &lt;- x[1]
x2 &lt;- x[2]
100 * (x2 - x1 * x1)^2 + (1 - x1)^2
}
res1&lt;-ljoptim(c(-1.2,1),fbana,lower=-5,upper=5,accd=1e-16,acc=1e-16)
res1

set.seed(210485)
fwild &lt;- function (x) 10*sin(0.3*x)*sin(1.3*x^2) + 0.00001*x^4 + 0.2*x+80
plot(fwild, -50, 50, n = 1000, main = "ljoptim() minimising 'wild function'")
res2&lt;-ljoptim(50, fwild,lower=-50,upper=50,adaptive=FALSE,accd=1e-16,acc=1e-16)
points(res2$par,res2$value,col="red",pch=19)
res2

</code></pre>

<hr>
<h2 id='lmds'>An function for local MDS (Chen &amp; Buja 2006)</h2><span id='topic+lmds'></span>

<h3>Description</h3>

<p>An function for local MDS (Chen &amp; Buja 2006)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmds(delta, init = NULL, ndim = 3, k = 2, tau = 1, itmax = 5000, verbose = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmds_+3A_delta">delta</code></td>
<td>
<p>dissimilarity or distance matrix</p>
</td></tr>
<tr><td><code id="lmds_+3A_init">init</code></td>
<td>
<p>initial configuration. If NULL a classical scaling solution is used.</p>
</td></tr>
<tr><td><code id="lmds_+3A_ndim">ndim</code></td>
<td>
<p>the dimension of the configuration</p>
</td></tr>
<tr><td><code id="lmds_+3A_k">k</code></td>
<td>
<p>the k neighbourhood parameter</p>
</td></tr>
<tr><td><code id="lmds_+3A_tau">tau</code></td>
<td>
<p>the penalty parameter (suggested to be in [0,1])</p>
</td></tr>
<tr><td><code id="lmds_+3A_itmax">itmax</code></td>
<td>
<p>number of optimizing iterations, defaults to 5000.</p>
</td></tr>
<tr><td><code id="lmds_+3A_verbose">verbose</code></td>
<td>
<p>prints progress if &gt; 4.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that k and tau are not independent. It is possible for normalized stress to become negative if the tau and k combination is so that the absolute repulsion for the found configuration dominates the local stress substantially less than the repulsion term does for the solution of D(X)=Delta, so that the local stress difference between the found solution and perfect solution is nullified. This can typically be avoided if tau is between 0 and 1. If not, set k and or tau to a smaller value.
</p>


<h3>Value</h3>

<p>an object of class 'lmds' (also inherits from 'smacofP'). See <code><a href="#topic+powerStressMin">powerStressMin</a></code>. It is a list with the components as in power stress
</p>

<ul>
<li><p> delta: Observed dissimilarities, not normalized
</p>
</li>
<li><p> obsdiss: Observed transformed dissimilarities, not normalized
</p>
</li>
<li><p> confdist: Configuration dissimilarities, NOT normalized 
</p>
</li>
<li><p> conf: Matrix of fitted configuration, NOT normalized
</p>
</li>
<li><p> stress: Default stress  (stress 1; sqrt of explicitly normalized stress)
</p>
</li>
<li><p> ndim: Number of dimensions
</p>
</li>
<li><p> model: Name of MDS model
</p>
</li>
<li><p> niter: Number of iterations
</p>
</li>
<li><p> nobj: Number of objects
</p>
</li>
<li><p> pars: hyperparameter vector theta 
</p>
</li></ul>

<p>and some additional components
</p>

<ul>
<li><p> stress.m: default stress is the explicitly normalized stress on the normalized, transformed dissimilarities
</p>
</li>
<li><p> deltaorig: observed, untransformed dissimilarities
</p>
</li>
<li><p> tau: tau parameter
</p>
</li>
<li><p> k: k parameter
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Lisha Chen &amp; Thomas Rusch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-smacof::kinshipdelta
res&lt;- lmds(as.matrix(dis),k=2,tau=0.1)
res
summary(res)
plot(res)

</code></pre>

<hr>
<h2 id='mkBmat'>MkBmat function (internal)</h2><span id='topic+mkBmat'></span>

<h3>Description</h3>

<p>MkBmat function (internal)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkBmat(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkBmat_+3A_x">x</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>

<hr>
<h2 id='mkPower'>MakePower Old</h2><span id='topic+mkPower'></span>

<h3>Description</h3>

<p>MakePower Old
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkPower(x, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkPower_+3A_x">x</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="mkPower_+3A_r">r</code></td>
<td>
<p>numeric (power)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the matrix to a power
</p>

<hr>
<h2 id='mkPower2'>MakePower</h2><span id='topic+mkPower2'></span>

<h3>Description</h3>

<p>MakePower
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkPower2(x, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkPower2_+3A_x">x</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="mkPower2_+3A_theta">theta</code></td>
<td>
<p>numeric (power)</p>
</td></tr>
</table>

<hr>
<h2 id='Pendigits500'>Pen digits</h2><span id='topic+Pendigits500'></span>

<h3>Description</h3>

<p>These data are a random sample of 500 of the 10992 pendigits data from Alimoglu (1996). The original data were from 44 writers who handwrote 250 times the digits 0,...,9. The digits were written inside a rectangular box with a resolution of 500 x 500 pixels and the first 10 per writer were ignored for further analysis. This led to 10992 digits. They were recorded in small time intervals by following the trajectory of the pen on the 500 x 500 grid and then normalized. From the normalized trajectory 8 points (x and y axis position) were randomly selected for each handwritten digit, leading to 16 predictors variables. We extarcted a random sample of 500 of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Pendigits500)
</code></pre>


<h3>Format</h3>

<p>A data frame with 500 rows and 17 variables
</p>


<h3>Details</h3>

<p>The variables are
</p>

<ul>
<li><p> The rownames of Pendigits500 refer to the data point of the 10992 original data
</p>
</li>
<li><p> V1-V16: trajectory points (x, y coordinate) of the grid
</p>
</li>
<li><p> digits: The digit actually written (the label)
</p>
</li></ul>



<h3>Source</h3>

<p>From A. Izenman (2010) Modern multivariate statistical techniques. Springer.
</p>

<hr>
<h2 id='plot.cmdscaleE'>S3 plot method for cmdscaleE</h2><span id='topic+plot.cmdscaleE'></span>

<h3>Description</h3>

<p>S3 plot method for cmdscaleE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cmdscaleE'
plot(
  x,
  plot.type = c("confplot"),
  plot.dim = c(1, 2),
  col,
  label.conf = list(label = TRUE, pos = 3, col = 1, cex = 0.8),
  identify = FALSE,
  type = "p",
  pch = 20,
  asp = 1,
  main,
  xlab,
  ylab,
  xlim,
  ylim,
  legpos,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cmdscaleE_+3A_x">x</code></td>
<td>
<p>cmdscaleE object</p>
</td></tr>
<tr><td><code id="plot.cmdscaleE_+3A_plot.type">plot.type</code></td>
<td>
<p>type of plot</p>
</td></tr>
<tr><td><code id="plot.cmdscaleE_+3A_plot.dim">plot.dim</code></td>
<td>
<p>dimensions used for plotting</p>
</td></tr>
<tr><td><code id="plot.cmdscaleE_+3A_col">col</code></td>
<td>
<p>color</p>
</td></tr>
<tr><td><code id="plot.cmdscaleE_+3A_label.conf">label.conf</code></td>
<td>
<p>list of label options</p>
</td></tr>
<tr><td><code id="plot.cmdscaleE_+3A_identify">identify</code></td>
<td>
<p>boolean flag for interactively identify points</p>
</td></tr>
<tr><td><code id="plot.cmdscaleE_+3A_type">type</code></td>
<td>
<p>type of plot</p>
</td></tr>
<tr><td><code id="plot.cmdscaleE_+3A_pch">pch</code></td>
<td>
<p>plotting character</p>
</td></tr>
<tr><td><code id="plot.cmdscaleE_+3A_asp">asp</code></td>
<td>
<p>aspect ratio (defaults to 1)</p>
</td></tr>
<tr><td><code id="plot.cmdscaleE_+3A_main">main</code></td>
<td>
<p>main title</p>
</td></tr>
<tr><td><code id="plot.cmdscaleE_+3A_xlab">xlab</code></td>
<td>
<p>label of x axis</p>
</td></tr>
<tr><td><code id="plot.cmdscaleE_+3A_ylab">ylab</code></td>
<td>
<p>label of y axis</p>
</td></tr>
<tr><td><code id="plot.cmdscaleE_+3A_xlim">xlim</code></td>
<td>
<p>limits of x axis</p>
</td></tr>
<tr><td><code id="plot.cmdscaleE_+3A_ylim">ylim</code></td>
<td>
<p>limits of y axis</p>
</td></tr>
<tr><td><code id="plot.cmdscaleE_+3A_legpos">legpos</code></td>
<td>
<p>position of legend</p>
</td></tr>
<tr><td><code id="plot.cmdscaleE_+3A_...">...</code></td>
<td>
<p>additional arguments passed to plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function duplicates the plot method for smacof so it can be used with cmdscaleE objects. See <code><a href="smacof.html#topic+plot.smacof">plot.smacof</a></code> for the arguments.
</p>


<h3>Value</h3>

<p>No return value, just plots a 'cmdscaleE' object.
</p>

<hr>
<h2 id='plot.smacofP'>S3 plot method for smacofP objects</h2><span id='topic+plot.smacofP'></span>

<h3>Description</h3>

<p>S3 plot method for smacofP objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smacofP'
plot(
  x,
  plot.type = "confplot",
  plot.dim = c(1, 2),
  bubscale = 5,
  col,
  label.conf = list(label = TRUE, pos = 3, col = 1, cex = 0.8),
  identify = FALSE,
  type = "p",
  pch = 20,
  asp = 1,
  main,
  xlab,
  ylab,
  xlim,
  ylim,
  legend = TRUE,
  legpos,
  loess = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.smacofP_+3A_x">x</code></td>
<td>
<p>an object of class smacofP</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_plot.type">plot.type</code></td>
<td>
<p>String indicating which type of plot to be produced: &quot;confplot&quot;, &quot;resplot&quot;, &quot;Shepard&quot;, &quot;stressplot&quot;,&quot;transplot&quot;, &quot;bubbleplot&quot; (see details)</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_plot.dim">plot.dim</code></td>
<td>
<p>dimensions to be plotted in confplot; defaults to c(1, 2)</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_bubscale">bubscale</code></td>
<td>
<p>Scaling factor (size) for the bubble plot</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_col">col</code></td>
<td>
<p>vector of colors for the points</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_label.conf">label.conf</code></td>
<td>
<p>List with arguments for plotting the labels of the configurations in a configuration plot (logical value whether to plot labels or not, label position, label color)</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_identify">identify</code></td>
<td>
<p>If 'TRUE', the 'identify()' function is called internally that allows to add configuration labels by mouse click</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_type">type</code></td>
<td>
<p>What type of plot should be drawn (see also 'plot')</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_pch">pch</code></td>
<td>
<p>Plot symbol</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_asp">asp</code></td>
<td>
<p>Aspect ratio; defaults to 1 so distances between x and y are represented accurately; can lead to slighlty weird looking plots if the variance on one axis is much smaller than on the other axis; use NA if the standard type of R plot is wanted where the ylim and xlim arguments define the aspect ratio - but then the distances seen are no longer accurate</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_main">main</code></td>
<td>
<p>plot title</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_xlab">xlab</code></td>
<td>
<p>label of x axis</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_ylab">ylab</code></td>
<td>
<p>label of y axis</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_xlim">xlim</code></td>
<td>
<p>scale of x axis</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_ylim">ylim</code></td>
<td>
<p>scale of y axis</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_legend">legend</code></td>
<td>
<p>Flag whether legends should be drawn for plots that have legends</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_legpos">legpos</code></td>
<td>
<p>Position of legend in plots with legends</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_loess">loess</code></td>
<td>
<p>should loess fit be added to Shepard plot</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_...">...</code></td>
<td>
<p>Further plot arguments passed: see 'plot.smacof' and 'plot' for detailed information.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p>  Configuration plot (plot.type = &quot;confplot&quot;): Plots the MDS configurations.
</p>
</li>
<li><p> Residual plot (plot.type = &quot;resplot&quot;): Plots the dissimilarities against the fitted distances with a linear regression line (without an intercept as in ratio MDS).
</p>
</li>
<li><p> Linearized Shepard diagram (plot.type = &quot;Shepard&quot;): Diagram with the transformed observed dissimilarities against the transformed fitted distance as well as loess curve and a least squares line. The fitted lines do not have an intercept.
</p>
</li>
<li><p> Transformation Plot (plot.type = &quot;transplot&quot;): Diagram with the observed dissimilarities (lighter) and the transformed observed dissimilarities (darker) against the fitted distances together with the nonlinear regression curve (no intercept). Works for lmds or bcStress models too, but is somewhat nonsensical due to them being energy models.
</p>
</li>
<li><p> Stress decomposition plot (plot.type = &quot;stressplot&quot;): Plots the stress contribution in of each observation. Note that it rescales the stress-per-point (SPP) from the corresponding smacof function to percentages (sum is 100). The higher the contribution, the worse the fit. Only implemented for models from the classical stress world, not for bcmds or lmds (throws an error).
</p>
</li>
<li><p> Bubble plot (plot.type = &quot;bubbleplot&quot;): Combines the configuration plot with the point stress contribution. The larger the bubbles, the better the fit.Only implemented for models from the classical stress world, bcmds or lmds (throws an error).
</p>
</li></ul>



<h3>Value</h3>

<p>no return value; just plot for class 'smacofP' (see details)
</p>

<hr>
<h2 id='plot.stops'>S3 plot method for stops objects</h2><span id='topic+plot.stops'></span>

<h3>Description</h3>

<p>S3 plot method for stops objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stops'
plot(x, plot.type = c("confplot"), main, asp = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.stops_+3A_x">x</code></td>
<td>
<p>an object of class stops</p>
</td></tr>
<tr><td><code id="plot.stops_+3A_plot.type">plot.type</code></td>
<td>
<p>String indicating which type of plot to be produced: &quot;confplot&quot;, &quot;resplot&quot;, &quot;Shepard&quot;, &quot;stressplot&quot;, &quot;bubbleplot&quot; (see details)</p>
</td></tr>
<tr><td><code id="plot.stops_+3A_main">main</code></td>
<td>
<p>the main title of the plot</p>
</td></tr>
<tr><td><code id="plot.stops_+3A_asp">asp</code></td>
<td>
<p>aspect ratio of x/y axis; defaults to NA; setting to 1 will lead to an accurate represenation of the fitted distances.</p>
</td></tr>
<tr><td><code id="plot.stops_+3A_...">...</code></td>
<td>
<p>Further plot arguments passed: see 'plot.smacof' and 'plot' for detailed information.
</p>
<p>Details:
</p>

<ul>
<li><p> Configuration plot (plot.type = &quot;confplot&quot;): Plots the MDS configurations.
</p>
</li>
<li><p> Residual plot (plot.type = &quot;resplot&quot;): Plots the dissimilarities against the fitted distances.
</p>
</li>
<li><p> Linearized Shepard diagram (plot.type = &quot;Shepard&quot;): Diagram with the transformed observed dissimilarities against the transformed fitted distance as well as loess smooth and a least squares line.
</p>
</li>
<li><p> Stress decomposition plot (plot.type = &quot;stressplot&quot;, only for SMACOF objects in $fit): Plots the stress contribution in of each observation. Note that it rescales the stress-per-point (SPP) from the corresponding smacof function to percentages (sum is 100). The higher the contribution, the worse the fit.
</p>
</li>
<li><p> Bubble plot (plot.type = &quot;bubbleplot&quot;, only available for SMACOF objects $fit): Combines the configuration plot with the point stress contribution. The larger the bubbles, the better the fit.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value, just plots
</p>

<hr>
<h2 id='plot3d.cmdscaleE'>S3 plot3d method for class cmdscaleE</h2><span id='topic+plot3d.cmdscaleE'></span>

<h3>Description</h3>

<p>This methods produces a dynamic 3D configuration plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cmdscaleE'
plot3d(
  x,
  plot.dim = c(1, 2, 3),
  xlab,
  ylab,
  zlab,
  col,
  main,
  bgpng = NULL,
  ax.grid = TRUE,
  sphere.rgl = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3d.cmdscaleE_+3A_x">x</code></td>
<td>
<p>object of class cmdscaleE</p>
</td></tr>
<tr><td><code id="plot3d.cmdscaleE_+3A_plot.dim">plot.dim</code></td>
<td>
<p>vector of length 3 with dimensions to be plotted</p>
</td></tr>
<tr><td><code id="plot3d.cmdscaleE_+3A_xlab">xlab</code></td>
<td>
<p>label of x axis</p>
</td></tr>
<tr><td><code id="plot3d.cmdscaleE_+3A_ylab">ylab</code></td>
<td>
<p>label of y axis</p>
</td></tr>
<tr><td><code id="plot3d.cmdscaleE_+3A_zlab">zlab</code></td>
<td>
<p>label of z axis</p>
</td></tr>
<tr><td><code id="plot3d.cmdscaleE_+3A_col">col</code></td>
<td>
<p>color of the text labels</p>
</td></tr>
<tr><td><code id="plot3d.cmdscaleE_+3A_main">main</code></td>
<td>
<p>plot title</p>
</td></tr>
<tr><td><code id="plot3d.cmdscaleE_+3A_bgpng">bgpng</code></td>
<td>
<p>Background image from rgl library; 'NULL' for white background</p>
</td></tr>
<tr><td><code id="plot3d.cmdscaleE_+3A_ax.grid">ax.grid</code></td>
<td>
<p>If 'TRUE', axes grid is plotted.</p>
</td></tr>
<tr><td><code id="plot3d.cmdscaleE_+3A_sphere.rgl">sphere.rgl</code></td>
<td>
<p>If 'TRUE', rgl sphere (background) is plotted.</p>
</td></tr>
<tr><td><code id="plot3d.cmdscaleE_+3A_...">...</code></td>
<td>
<p>Further plot arguments passed: see 'plot3d' in package 'rgl' for detailed information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, just plots a 'cmdscale' object.
</p>

<hr>
<h2 id='plot3d.stops'>S3 plot3d method for class stops</h2><span id='topic+plot3d.stops'></span>

<h3>Description</h3>

<p>This methods produces a dynamic 3D configuration plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stops'
plot3d(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3d.stops_+3A_x">x</code></td>
<td>
<p>object of class stops</p>
</td></tr>
<tr><td><code id="plot3d.stops_+3A_...">...</code></td>
<td>
<p>Further plot arguments to the method of the class of slot $fit, see <code>plot.smacof</code> or <code><a href="#topic+plot3d.cmdscaleE">plot3d.cmdscaleE</a></code> . Also see 'rgl' in package 'rgl'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value, just plots
</p>

<hr>
<h2 id='plot3dstatic'>plot3dstatic: static 3D plots</h2><span id='topic+plot3dstatic'></span>

<h3>Description</h3>

<p>A static 3d plot S3 generic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot3dstatic(x, plot.dim = c(1, 2, 3), main, xlab, ylab, zlab, col, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3dstatic_+3A_x">x</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="plot3dstatic_+3A_plot.dim">plot.dim</code></td>
<td>
<p>dimensions to plot</p>
</td></tr>
<tr><td><code id="plot3dstatic_+3A_main">main</code></td>
<td>
<p>main title</p>
</td></tr>
<tr><td><code id="plot3dstatic_+3A_xlab">xlab</code></td>
<td>
<p>label for x axis</p>
</td></tr>
<tr><td><code id="plot3dstatic_+3A_ylab">ylab</code></td>
<td>
<p>label for y axis</p>
</td></tr>
<tr><td><code id="plot3dstatic_+3A_zlab">zlab</code></td>
<td>
<p>label for z axis</p>
</td></tr>
<tr><td><code id="plot3dstatic_+3A_col">col</code></td>
<td>
<p>color</p>
</td></tr>
<tr><td><code id="plot3dstatic_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A static 3d plot
</p>


<h3>Value</h3>

<p>No return value, just plots.
</p>

<hr>
<h2 id='plot3dstatic.cmdscaleE'>3D plots: plot3dstatic method for class cmdscaleE</h2><span id='topic+plot3dstatic.cmdscaleE'></span>

<h3>Description</h3>

<p>This methods produces a static 3D configuration plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cmdscaleE'
plot3dstatic(x, plot.dim = c(1, 2, 3), main, xlab, ylab, zlab, col, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3dstatic.cmdscaleE_+3A_x">x</code></td>
<td>
<p>object of class cmdscaleE</p>
</td></tr>
<tr><td><code id="plot3dstatic.cmdscaleE_+3A_plot.dim">plot.dim</code></td>
<td>
<p>vector of length 3 with dimensions to be plotted</p>
</td></tr>
<tr><td><code id="plot3dstatic.cmdscaleE_+3A_main">main</code></td>
<td>
<p>plot title</p>
</td></tr>
<tr><td><code id="plot3dstatic.cmdscaleE_+3A_xlab">xlab</code></td>
<td>
<p>label of x axis</p>
</td></tr>
<tr><td><code id="plot3dstatic.cmdscaleE_+3A_ylab">ylab</code></td>
<td>
<p>label of y axis</p>
</td></tr>
<tr><td><code id="plot3dstatic.cmdscaleE_+3A_zlab">zlab</code></td>
<td>
<p>label of z axis</p>
</td></tr>
<tr><td><code id="plot3dstatic.cmdscaleE_+3A_col">col</code></td>
<td>
<p>color of the text labels</p>
</td></tr>
<tr><td><code id="plot3dstatic.cmdscaleE_+3A_...">...</code></td>
<td>
<p>Further plot arguments passed: see 'scatterplot3d' in package 'scatterplot3d' for detailed information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, just plots a 'cmdscaleE' object.
</p>

<hr>
<h2 id='plot3dstatic.stops'>S3 plot3dstatic method for class stops</h2><span id='topic+plot3dstatic.stops'></span>

<h3>Description</h3>

<p>This methods produces a static 3D configuration plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stops'
plot3dstatic(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3dstatic.stops_+3A_x">x</code></td>
<td>
<p>object of class stops</p>
</td></tr>
<tr><td><code id="plot3dstatic.stops_+3A_...">...</code></td>
<td>
<p>Further plot arguments to the method of the class of slot fit, see <code><a href="#topic+plot3dstatic">plot3dstatic</a></code> or <code><a href="#topic+plot3dstatic.cmdscaleE">plot3dstatic.cmdscaleE</a></code> . Also see 'scatterplot3d' in package 'scatterplot3d'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value, just plots
</p>

<hr>
<h2 id='powerStressMin'>Power Stress SMACOF</h2><span id='topic+powerStressMin'></span>

<h3>Description</h3>

<p>An implementation to minimize power stress by minimization-majorization. Usually more accurate but slower than powerStressFast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerStressMin(
  delta,
  kappa = 1,
  lambda = 1,
  nu = 1,
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  ndim = 2,
  acc = 1e-10,
  itmax = 50000,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powerStressMin_+3A_delta">delta</code></td>
<td>
<p>dist object or a symmetric, numeric data.frame or matrix of distances</p>
</td></tr>
<tr><td><code id="powerStressMin_+3A_kappa">kappa</code></td>
<td>
<p>power of the transformation of the fitted distances; defaults to 1</p>
</td></tr>
<tr><td><code id="powerStressMin_+3A_lambda">lambda</code></td>
<td>
<p>the power of the transformation of the proximities; defaults to 1</p>
</td></tr>
<tr><td><code id="powerStressMin_+3A_nu">nu</code></td>
<td>
<p>the power of the transformation for weightmat; defaults to 1</p>
</td></tr>
<tr><td><code id="powerStressMin_+3A_weightmat">weightmat</code></td>
<td>
<p>a matrix of finite weights</p>
</td></tr>
<tr><td><code id="powerStressMin_+3A_init">init</code></td>
<td>
<p>starting configuration</p>
</td></tr>
<tr><td><code id="powerStressMin_+3A_ndim">ndim</code></td>
<td>
<p>dimension of the configuration; defaults to 2</p>
</td></tr>
<tr><td><code id="powerStressMin_+3A_acc">acc</code></td>
<td>
<p>numeric accuracy of the iteration</p>
</td></tr>
<tr><td><code id="powerStressMin_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations. Defaults to 50000.</p>
</td></tr>
<tr><td><code id="powerStressMin_+3A_verbose">verbose</code></td>
<td>
<p>should iteration output be printed; if &gt; 1 then yes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class 'smacofP' (inheriting form 'smacofB', see <code>smacofSym</code>). It is a list with the components
</p>

<ul>
<li><p> delta: Observed dissimilarities, not normalized
</p>
</li>
<li><p> obsdiss: Observed transformed dissimilarities, not normalized
</p>
</li>
<li><p> confdist: Configuration dissimilarities, NOT normalized 
</p>
</li>
<li><p> conf: Matrix of fitted configuration, NOT normalized
</p>
</li>
<li><p> stress: Default stress  (stress 1; sqrt of explicitly normalized stress)
</p>
</li>
<li><p> spp: Stress per point (based on stress.en) 
</p>
</li>
<li><p> ndim: Number of dimensions
</p>
</li>
<li><p> model: Name of smacof model
</p>
</li>
<li><p> niter: Number of iterations
</p>
</li>
<li><p> nobj: Number of objects
</p>
</li>
<li><p> type: Type of MDS model
</p>
</li>
<li><p> weightmat: weighting matrix
</p>
</li>
<li><p> pars: hyperparameter vector theta
</p>
</li></ul>

<p>and some additional components
</p>

<ul>
<li><p> stress.m: default stress is the explicitly normalized stress on the normalized, transformed dissimilarities
</p>
</li>
<li><p> deltaorig: observed, untransformed dissimilarities
</p>
</li>
<li><p> kappa: kappa parameter
</p>
</li>
<li><p> lambda: lambda parameter
</p>
</li>
<li><p> nu: nu parameter (aka rho)
</p>
</li></ul>



<h3>Note</h3>

<p>The functionality related to power stress and the 'smacofP' class is also available in the 'cops' package. Expect masking when both are loaded.
</p>


<h3>Author(s)</h3>

<p>Jan de Leeuw &amp; Thomas Rusch
</p>


<h3>See Also</h3>

<p><code>smacofSym</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-smacof::kinshipdelta
res&lt;-powerStressMin(as.matrix(dis),kappa=2,lambda=1.5,nu=2,
                    weightmat=as.matrix(dis/2),itmax=1000)
res
summary(res)
plot(res)

</code></pre>

<hr>
<h2 id='print.cmdscale'>S3 print method for cmdscale</h2><span id='topic+print.cmdscale'></span>

<h3>Description</h3>

<p>S3 print method for cmdscale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cmdscale'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cmdscale_+3A_x">x</code></td>
<td>
<p>cmdscale object</p>
</td></tr>
<tr><td><code id="print.cmdscale_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, just prints.
</p>

<hr>
<h2 id='print.sammon'>S3 print method for sammon objects</h2><span id='topic+print.sammon'></span>

<h3>Description</h3>

<p>S3 print method for sammon objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sammon'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.sammon_+3A_x">x</code></td>
<td>
<p>cmdscale object</p>
</td></tr>
<tr><td><code id="print.sammon_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, just prints.
</p>

<hr>
<h2 id='print.stops'>S3 print method for stops objects</h2><span id='topic+print.stops'></span>

<h3>Description</h3>

<p>S3 print method for stops objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stops'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.stops_+3A_x">x</code></td>
<td>
<p>stops object</p>
</td></tr>
<tr><td><code id="print.stops_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value, just prints
</p>

<hr>
<h2 id='print.summary.smacofP'>S3 print method for summary.smacofP</h2><span id='topic+print.summary.smacofP'></span>

<h3>Description</h3>

<p>S3 print method for summary.smacofP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.smacofP'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.smacofP_+3A_x">x</code></td>
<td>
<p>object of class summary.smacofP</p>
</td></tr>
<tr><td><code id="print.summary.smacofP_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, just prints a 'summary.smacofP'
</p>

<hr>
<h2 id='print.summary.stops'>S3 print method for summary.stops</h2><span id='topic+print.summary.stops'></span>

<h3>Description</h3>

<p>S3 print method for summary.stops
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.stops'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.stops_+3A_x">x</code></td>
<td>
<p>object of class summary.stops</p>
</td></tr>
<tr><td><code id="print.summary.stops_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value, just prints
</p>

<hr>
<h2 id='procruster'>procruster: a procrustes function</h2><span id='topic+procruster'></span>

<h3>Description</h3>

<p>procruster: a procrustes function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>procruster(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="procruster_+3A_x">x</code></td>
<td>
<p>mumeric matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A double or complex matrix.
</p>

<hr>
<h2 id='residuals.stops'>S3 residuals method for stops</h2><span id='topic+residuals.stops'></span>

<h3>Description</h3>

<p>S3 residuals method for stops
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stops'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.stops_+3A_object">object</code></td>
<td>
<p>object of class stops</p>
</td></tr>
<tr><td><code id="residuals.stops_+3A_...">...</code></td>
<td>
<p>addditional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of residuals (observed minus fitted distances)
</p>

<hr>
<h2 id='sammon'>Wrapper to <code>sammon</code> for S3 class</h2><span id='topic+sammon'></span>

<h3>Description</h3>

<p>Wrapper to <code>sammon</code> for S3 class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sammon(d, y = NULL, k = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sammon_+3A_d">d</code></td>
<td>
<p>a distance structure such as that returned by 'dist' or a full symmetric matrix.  Data are assumed to be dissimilarities or relative distances, but must be positive except for self-distance.  This can contain missing values.</p>
</td></tr>
<tr><td><code id="sammon_+3A_y">y</code></td>
<td>
<p>An initial configuration. If NULL, 'cmdscale' is used to provide the classical solution.  (If there are missing values in 'd', an initial configuration must be provided.)  This must not have duplicates.</p>
</td></tr>
<tr><td><code id="sammon_+3A_k">k</code></td>
<td>
<p>The dimension of the configuration</p>
</td></tr>
<tr><td><code id="sammon_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>sammon</code>, see <code><a href="#topic+sammon">sammon</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>overloads MASS::sammon and adds class attributes for which there are methods. The functionality is duplicated in the cops package.
</p>


<h3>Value</h3>

<p>An object of class 'sammonE' that inherits from <code><a href="#topic+sammon">sammon</a></code>. This function only adds an extra slot to the list with the call, adds column labels to the $points and assigns S3 classes 'sammonE', 'cmdscale'. It also adds a slot obsdiss with normalized dissimilarities.
</p>

<hr>
<h2 id='secularEq'>Secular Equation</h2><span id='topic+secularEq'></span>

<h3>Description</h3>

<p>Secular Equation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>secularEq(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="secularEq_+3A_a">a</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="secularEq_+3A_b">b</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>

<hr>
<h2 id='sqdist'>Squared distances</h2><span id='topic+sqdist'></span>

<h3>Description</h3>

<p>Squared distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqdist(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqdist_+3A_x">x</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of squared distances
</p>

<hr>
<h2 id='stop_apstress'>STOPS version of approximated power stress models.</h2><span id='topic+stop_apstress'></span>

<h3>Description</h3>

<p>This uses an approximation to power stress that can make use of smacof as workhorse. Free parameters are tau and upsilon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_apstress(
  dis,
  theta = c(1, 1),
  ndim = 2,
  weightmat = NULL,
  init = NULL,
  itmax = 1000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  type = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_apstress_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_apstress_+3A_theta">theta</code></td>
<td>
<p>the theta vector of parameters to optimize over. Must be of length two, with the first the tau argument and the second the upsilon argument. It can also be a scalar of the tau and upsilon transformation for the observed proximities and gets recycled for both ups and tau (so they are equal). Defaults to 1 1.</p>
</td></tr>
<tr><td><code id="stop_apstress_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_apstress_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a binary matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_apstress_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_apstress_+3A_itmax">itmax</code></td>
<td>
<p>number of iterations. default is 1000.</p>
</td></tr>
<tr><td><code id="stop_apstress_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_apstress_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_apstress_+3A_structures">structures</code></td>
<td>
<p>a character vector listing the structure indices to use. They always are called &quot;cfoo&quot; with foo being the structure.</p>
</td></tr>
<tr><td><code id="stop_apstress_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structures; defaults to 1/number of structures</p>
</td></tr>
<tr><td><code id="stop_apstress_+3A_strucpars">strucpars</code></td>
<td>
<p>a list of list of parameters for the structuredness indices; each list element corresponds to one index in the order of the appearance in structures vector. See examples.</p>
</td></tr>
<tr><td><code id="stop_apstress_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_apstress_+3A_type">type</code></td>
<td>
<p>which weighting to be used in the multi-objective optimization? Either 'additive' (default) or 'multiplicative'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: the stress 1 (sqrt stress.m)
</p>
</li>
<li><p>stress.m: default normalized stress
</p>
</li>
<li><p> stoploss: the weighted loss value
</p>
</li>
<li><p> struc: the structuredness indices
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa=1, tau, ups)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object 
</p>
</li></ul>


<hr>
<h2 id='stop_bcstress'>STOPS version of Box Cox Stress</h2><span id='topic+stop_bcstress'></span>

<h3>Description</h3>

<p>STOPS version of Box Cox Stress
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_bcstress(
  dis,
  theta = c(1, 1, 0),
  weightmat = NULL,
  init = NULL,
  ndim = 2,
  itmax = 5000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  type = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_bcstress_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_bcstress_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; the first is mu (for the fitted distances), the second lambda (for the  proximities), the third nu (for the weights). If a scalar is given it is recycled.  Defaults to 1 1 0.</p>
</td></tr>
<tr><td><code id="stop_bcstress_+3A_weightmat">weightmat</code></td>
<td>
<p>(not used)</p>
</td></tr>
<tr><td><code id="stop_bcstress_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_bcstress_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_bcstress_+3A_itmax">itmax</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_bcstress_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_bcstress_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_bcstress_+3A_structures">structures</code></td>
<td>
<p>which structures to look for</p>
</td></tr>
<tr><td><code id="stop_bcstress_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structures; defaults to 0.5</p>
</td></tr>
<tr><td><code id="stop_bcstress_+3A_strucpars">strucpars</code></td>
<td>
<p>a list of parameters for the structuredness indices; each list element corresponds to one index in the order of the appeacrance in structures</p>
</td></tr>
<tr><td><code id="stop_bcstress_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_bcstress_+3A_type">type</code></td>
<td>
<p>which weighting to be used in the multi-objective optimization? Either 'additive' (default) or 'multiplicative'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> stoploss: the weighted loss value
</p>
</li>
<li><p> struc: the structuredness indices
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object 
</p>
</li></ul>


<hr>
<h2 id='stop_cmdscale'>STOPS version of strain</h2><span id='topic+stop_cmdscale'></span>

<h3>Description</h3>

<p>The free parameter is lambda for power transformations of the observed proximities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_cmdscale(
  dis,
  theta = 1,
  weightmat = NULL,
  ndim = 2,
  init = NULL,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  type = c("additive", "multiplicative"),
  itmax = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_cmdscale_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_cmdscale_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; this must be a scalar of the lambda transformation for the observed proximities.</p>
</td></tr>
<tr><td><code id="stop_cmdscale_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights. Not used.</p>
</td></tr>
<tr><td><code id="stop_cmdscale_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_cmdscale_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_cmdscale_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_cmdscale_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_cmdscale_+3A_structures">structures</code></td>
<td>
<p>which structuredness indices to be included in the loss</p>
</td></tr>
<tr><td><code id="stop_cmdscale_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structuredness indices; ; defaults to 1/#number of structures</p>
</td></tr>
<tr><td><code id="stop_cmdscale_+3A_strucpars">strucpars</code></td>
<td>
<p>the parameters for the structuredness indices</p>
</td></tr>
<tr><td><code id="stop_cmdscale_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_cmdscale_+3A_type">type</code></td>
<td>
<p>How to construct the target function for the multi objective optimization? Either 'additive' (default) or 'multiplicative'</p>
</td></tr>
<tr><td><code id="stop_cmdscale_+3A_itmax">itmax</code></td>
<td>
<p>placeholder for compatibility in stops call; not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: Sqrt of explicitly normalized stress. 
</p>
</li>
<li><p>stress.m: explictly normalized stress
</p>
</li>
<li><p>stoploss: the weighted loss value
</p>
</li>
<li><p>indices: the values of the structuredness indices
</p>
</li>
<li><p>parameters: the parameters used for fitting 
</p>
</li>
<li><p>fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object
</p>
</li></ul>


<hr>
<h2 id='stop_elastic'>STOPS versions of elastic scaling models (via smacofSym)</h2><span id='topic+stop_elastic'></span>

<h3>Description</h3>

<p>The free parameter is lambda for power transformations the observed proximities. The fitted distances power is internally fixed to 1 and the power for the weights=delta is -2. Allows for a weight matrix because of smacof.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_elastic(
  dis,
  theta = 1,
  ndim = 2,
  weightmat = NULL,
  init = NULL,
  itmax = 1000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  type = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_elastic_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_elastic_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; this must be a scalar of the lambda transformation for the observed proximities. Defaults to 1.</p>
</td></tr>
<tr><td><code id="stop_elastic_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_elastic_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights (NOT the elscal weights)</p>
</td></tr>
<tr><td><code id="stop_elastic_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_elastic_+3A_itmax">itmax</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_elastic_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_elastic_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_elastic_+3A_structures">structures</code></td>
<td>
<p>which structuredness indices to be included in the loss</p>
</td></tr>
<tr><td><code id="stop_elastic_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structuredness indices; ; defaults to 1/#number of structures</p>
</td></tr>
<tr><td><code id="stop_elastic_+3A_strucpars">strucpars</code></td>
<td>
<p>the parameters for the structuredness indices</p>
</td></tr>
<tr><td><code id="stop_elastic_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_elastic_+3A_type">type</code></td>
<td>
<p>How to construct the target function for the multi objective optimization? Either 'additive' (default) or 'multiplicative'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: the stress-1 (sqrt(stress.m))
</p>
</li>
<li><p>stress.m: default normalized stress (used for STOPS)
</p>
</li>
<li><p>stoploss: the weighted loss value
</p>
</li>
<li><p>indices: the values of the structuredness indices
</p>
</li>
<li><p>parameters: the parameters used for fitting 
</p>
</li>
<li><p>fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj objects
</p>
</li></ul>


<hr>
<h2 id='stop_isomap1'>STOPS version of isomap to optimize over integer k.</h2><span id='topic+stop_isomap1'></span>

<h3>Description</h3>

<p>Free parameter is k.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_isomap1(
  dis,
  theta = 3,
  weightmat = NULL,
  ndim = 2,
  init = NULL,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  type = c("additive", "multiplicative"),
  itmax = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_isomap1_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_isomap1_+3A_theta">theta</code></td>
<td>
<p>the number of shortest dissimilarities retained for a point (nearest neighbours), the isomap parameter. Must be a numeric scalar. Defaults to 3.</p>
</td></tr>
<tr><td><code id="stop_isomap1_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_isomap1_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_isomap1_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_isomap1_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_isomap1_+3A_structures">structures</code></td>
<td>
<p>which structuredness indices to be included in the loss</p>
</td></tr>
<tr><td><code id="stop_isomap1_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structuredness indices; ; defaults to 1/#number of structures</p>
</td></tr>
<tr><td><code id="stop_isomap1_+3A_strucpars">strucpars</code></td>
<td>
<p>the parameters for the structuredness indices</p>
</td></tr>
<tr><td><code id="stop_isomap1_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_isomap1_+3A_type">type</code></td>
<td>
<p>How to construct the target function for the multi objective optimization? Either 'additive' (default) or 'multiplicative'</p>
</td></tr>
<tr><td><code id="stop_isomap1_+3A_itmax">itmax</code></td>
<td>
<p>placeholder for compatibility in stops call; not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently this version is a bit less flexible than the vegan one, as the only allowed parameter for isomap is the theta (k in isomap, no epsilon) and the shortest path is always estimated with argument &quot;shortest&quot;. Also note that fragmentedOK is always set to TRUE which means that for theta that is too small only the largest conected group will be analyzed. If that's not wanted just set the theta higher.
</p>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: Not really stress but 1-GOF where GOF is the first element returned from cmdscale (the sum of the first ndim absolute eigenvalues divided by the sum of all absolute eigenvalues).
</p>
</li>
<li><p>stress.m: default normalized stress (sqrt explicitly normalized stress; really the stress this time)
</p>
</li>
<li><p>stoploss: the weighted loss value
</p>
</li>
<li><p>indices: the values of the structuredness indices
</p>
</li>
<li><p>parameters: the parameters used for fitting 
</p>
</li>
<li><p>fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object
</p>
</li></ul>


<hr>
<h2 id='stop_isomap2'>STOPS version of isomap over real epsilon.</h2><span id='topic+stop_isomap2'></span>

<h3>Description</h3>

<p>Free parameter is eps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_isomap2(
  dis,
  theta = stats::quantile(dis, 0.1),
  weightmat = NULL,
  ndim = 2,
  init = NULL,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  type = c("additive", "multiplicative"),
  itmax = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_isomap2_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_isomap2_+3A_theta">theta</code></td>
<td>
<p>the number of shortest dissimilarities retained for a point (neighbourhood region), the isomap parameter. Defaults to the 0.1 quantile of the empirical distribution of dis.</p>
</td></tr>
<tr><td><code id="stop_isomap2_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_isomap2_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_isomap2_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_isomap2_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_isomap2_+3A_structures">structures</code></td>
<td>
<p>which structuredness indices to be included in the loss</p>
</td></tr>
<tr><td><code id="stop_isomap2_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structuredness indices; ; defaults to 1/#number of structures</p>
</td></tr>
<tr><td><code id="stop_isomap2_+3A_strucpars">strucpars</code></td>
<td>
<p>the parameters for the structuredness indices</p>
</td></tr>
<tr><td><code id="stop_isomap2_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_isomap2_+3A_type">type</code></td>
<td>
<p>How to construct the target function for the multi objective optimization? Either 'additive' (default) or 'multiplicative'</p>
</td></tr>
<tr><td><code id="stop_isomap2_+3A_itmax">itmax</code></td>
<td>
<p>placeholder for compatibility in stops call; not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently this version is a bit less flexible than the vegan one, as the only allowed parameter for isomap is the theta (epsilon in isomap) and the shortest path is always estimated with argument &quot;shortest&quot;. Also note that fragmentedOK is always set to TRUE which means that for theta that is too small only the largest conected group will be analyzed. If that's not wanted just set the theta higher.
</p>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: Not really stress but 1-GOF where GOF is the first element returned from cmdscale (the sum of the first ndim absolute eigenvalues divided by the sum of all absolute eigenvalues).
</p>
</li>
<li><p>stress.m: default normalized stress (sqrt explicitly normalized stress; really the stress this time)
</p>
</li>
<li><p>stoploss: the weighted loss value
</p>
</li>
<li><p>indices: the values of the structuredness indices
</p>
</li>
<li><p>parameters: the parameters used for fitting 
</p>
</li>
<li><p>fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object
</p>
</li></ul>


<hr>
<h2 id='stop_lmds'>STOPS version of lMDS</h2><span id='topic+stop_lmds'></span>

<h3>Description</h3>

<p>STOPS version of lMDS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_lmds(
  dis,
  theta = c(2, 0.5),
  weightmat = NULL,
  init = NULL,
  ndim = 2,
  itmax = 5000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  type = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_lmds_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_lmds_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; the first is k (for the neighbourhood), the second tau (for the penalty) . If a scalar is given it is recycled.  Defaults to 2 and 0.5.</p>
</td></tr>
<tr><td><code id="stop_lmds_+3A_weightmat">weightmat</code></td>
<td>
<p>(not used)</p>
</td></tr>
<tr><td><code id="stop_lmds_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_lmds_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_lmds_+3A_itmax">itmax</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_lmds_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_lmds_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_lmds_+3A_structures">structures</code></td>
<td>
<p>which structures to look for</p>
</td></tr>
<tr><td><code id="stop_lmds_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structures; defaults to 0.5</p>
</td></tr>
<tr><td><code id="stop_lmds_+3A_strucpars">strucpars</code></td>
<td>
<p>a list of parameters for the structuredness indices; each list element corresponds to one index in the order of the appeacrance in structures</p>
</td></tr>
<tr><td><code id="stop_lmds_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_lmds_+3A_type">type</code></td>
<td>
<p>which weighting to be used in the multi-objective optimization? Either 'additive' (default) or 'multiplicative'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> stoploss: the weighted loss value
</p>
</li>
<li><p> struc: the structuredness indices
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object 
</p>
</li></ul>


<hr>
<h2 id='stop_powerelastic'>STOPS version of elastic scaling with powers for proximities and distances</h2><span id='topic+stop_powerelastic'></span>

<h3>Description</h3>

<p>This is power stress with free kappa and lambda but rho is fixed to -2 and the weights are delta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_powerelastic(
  dis,
  theta = c(1, 1, -2),
  weightmat = NULL,
  init = NULL,
  ndim = 2,
  itmax = 1e+05,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  type = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_powerelastic_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_powerelastic_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers;  a vector of length two where the first element is kappa (for the fitted distances), the second lambda (for the observed proximities). If a scalar for the free parameters is given it is recycled.  Defaults to 1 1.</p>
</td></tr>
<tr><td><code id="stop_powerelastic_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_powerelastic_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_powerelastic_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_powerelastic_+3A_itmax">itmax</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_powerelastic_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_powerelastic_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_powerelastic_+3A_structures">structures</code></td>
<td>
<p>which strcutures to look for</p>
</td></tr>
<tr><td><code id="stop_powerelastic_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structures; defaults to 0.5</p>
</td></tr>
<tr><td><code id="stop_powerelastic_+3A_strucpars">strucpars</code></td>
<td>
<p>a list of parameters for the structuredness indices; each list element corresponds to one index in the order of the appeacrance in structures</p>
</td></tr>
<tr><td><code id="stop_powerelastic_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_powerelastic_+3A_type">type</code></td>
<td>
<p>which weighting to be used in the multi-objective optimization? Either 'additive' (default) or 'multiplicative'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> stoploss: the weighted loss value
</p>
</li>
<li><p> struc: the structuredness indices
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object 
</p>
</li></ul>


<hr>
<h2 id='stop_powermds'>STOPS version of powermds</h2><span id='topic+stop_powermds'></span>

<h3>Description</h3>

<p>This is power stress with free kappa and lambda but rho is fixed to 1, so no weight transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_powermds(
  dis,
  theta = c(1, 1),
  weightmat = NULL,
  init = NULL,
  ndim = 2,
  itmax = 1e+05,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  type = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_powermds_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_powermds_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; a vector of length 2 where the first element is kappa (for the fitted distances), the second lambda (for the observed proximities). If a scalar is given it is recycled.  Defaults to 1.</p>
</td></tr>
<tr><td><code id="stop_powermds_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_powermds_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_powermds_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_powermds_+3A_itmax">itmax</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_powermds_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_powermds_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_powermds_+3A_structures">structures</code></td>
<td>
<p>which structures to look for</p>
</td></tr>
<tr><td><code id="stop_powermds_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structures; defaults to 0.5</p>
</td></tr>
<tr><td><code id="stop_powermds_+3A_strucpars">strucpars</code></td>
<td>
<p>a list of parameters for the structuredness indices; each list element corresponds to one index in the order of the appeacrance in structures</p>
</td></tr>
<tr><td><code id="stop_powermds_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_powermds_+3A_type">type</code></td>
<td>
<p>which weighting to be used in the multi-objective optimization? Either 'additive' (default) or 'multiplicative'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> stoploss: the weighted loss value
</p>
</li>
<li><p> struc: the structuredness indices
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object 
</p>
</li></ul>


<hr>
<h2 id='stop_powersammon'>STOPS version of sammon with powers</h2><span id='topic+stop_powersammon'></span>

<h3>Description</h3>

<p>This is power stress with free kappa and lambda but rho is fixed to -1 and the weights are delta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_powersammon(
  dis,
  theta = c(1, 1),
  weightmat = NULL,
  init = NULL,
  ndim = 2,
  itmax = 1e+05,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  type = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_powersammon_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_powersammon_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; a vector of length two where the first element is kappa (for the fitted distances), the second lambda (for the observed proximities). If a scalar is given it is recycled for the free parameters.  Defaults to 1 1.</p>
</td></tr>
<tr><td><code id="stop_powersammon_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_powersammon_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_powersammon_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_powersammon_+3A_itmax">itmax</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_powersammon_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_powersammon_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_powersammon_+3A_structures">structures</code></td>
<td>
<p>which structures to look for</p>
</td></tr>
<tr><td><code id="stop_powersammon_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structures; defaults to 0.5</p>
</td></tr>
<tr><td><code id="stop_powersammon_+3A_strucpars">strucpars</code></td>
<td>
<p>a list of parameters for the structuredness indices; each list element corresponds to one index in the order of the appeacrance in structures</p>
</td></tr>
<tr><td><code id="stop_powersammon_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_powersammon_+3A_type">type</code></td>
<td>
<p>which weighting to be used in the multi-objective optimization? Either 'additive' (default) or 'multiplicative'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> stoploss: the weighted loss value
</p>
</li>
<li><p> struc: the structuredness indices
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object 
</p>
</li></ul>


<hr>
<h2 id='stop_powerstress'>STOPS version of powerstress</h2><span id='topic+stop_powerstress'></span>

<h3>Description</h3>

<p>Power stress with free kappa and lambda and rho.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_powerstress(
  dis,
  theta = c(1, 1, 1),
  weightmat = NULL,
  init = NULL,
  ndim = 2,
  itmax = 10000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  type = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_powerstress_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_powerstress_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; the first is kappa (for the fitted distances), the second lambda (for the observed proximities), the third nu (for the weights). If a scalar is given it is recycled.  Defaults to 1 1 1.</p>
</td></tr>
<tr><td><code id="stop_powerstress_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_powerstress_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_powerstress_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_powerstress_+3A_itmax">itmax</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_powerstress_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_powerstress_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_powerstress_+3A_structures">structures</code></td>
<td>
<p>a character vector listing the structure indices to use. They always are called &quot;cfoo&quot; with foo being the structure.</p>
</td></tr>
<tr><td><code id="stop_powerstress_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structures; defaults to 1/number of structures</p>
</td></tr>
<tr><td><code id="stop_powerstress_+3A_strucpars">strucpars</code></td>
<td>
<p>a list of parameters for the structuredness indices; each list element corresponds to one index in the order of the appeacrance in structures</p>
</td></tr>
<tr><td><code id="stop_powerstress_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_powerstress_+3A_type">type</code></td>
<td>
<p>which weighting to be used in the multi-objective optimization? Either 'additive' (default) or 'multiplicative'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> stoploss: the weighted loss value
</p>
</li>
<li><p> struc: the structuredness indices
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda, nu)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object 
</p>
</li></ul>


<hr>
<h2 id='stop_rpowerstress'>STOPS version of restricted powerstress</h2><span id='topic+stop_rpowerstress'></span>

<h3>Description</h3>

<p>STOPS version of restricted powerstress
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_rpowerstress(
  dis,
  theta = c(1, 1, 1),
  weightmat = NULL,
  init = NULL,
  ndim = 2,
  itmax = 10000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  type = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_rpowerstress_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_rpowerstress_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; the first two arguments are for kappa and lambda and should be equal (for the fitted distances and observed proximities), the third nu (for the weights). Internally the kappa and lambda are equated. If a scalar is given it is recycled (so all elements of theta are equal); if a vector of length 2 is given, it gets expanded to c(theta[1],theta[1],theta[2]). Defaults to 1 1 1.</p>
</td></tr>
<tr><td><code id="stop_rpowerstress_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_rpowerstress_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_rpowerstress_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_rpowerstress_+3A_itmax">itmax</code></td>
<td>
<p>number of iterations. default is 10000.</p>
</td></tr>
<tr><td><code id="stop_rpowerstress_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure powerStressMin</p>
</td></tr>
<tr><td><code id="stop_rpowerstress_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_rpowerstress_+3A_structures">structures</code></td>
<td>
<p>a character vector listing the structure indices to use. They always are called &quot;cfoo&quot; with foo being the structure.</p>
</td></tr>
<tr><td><code id="stop_rpowerstress_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structures; defaults to 1/number of structures</p>
</td></tr>
<tr><td><code id="stop_rpowerstress_+3A_strucpars">strucpars</code></td>
<td>
<p>a list of list of parameters for the structuredness indices; each list element corresponds to one index in the order of the appearance in structures vector. See examples.</p>
</td></tr>
<tr><td><code id="stop_rpowerstress_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_rpowerstress_+3A_type">type</code></td>
<td>
<p>which weighting to be used in the multi-objective optimization? Either 'additive' (default) or 'multiplicative'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> stoploss: the weighted loss value
</p>
</li>
<li><p> struc: the structuredness indices
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa=lambda, nu)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object 
</p>
</li></ul>


<hr>
<h2 id='stop_rstress'>STOPS version of rstress</h2><span id='topic+stop_rstress'></span>

<h3>Description</h3>

<p>Free parameter is kappa for the fitted distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_rstress(
  dis,
  theta = 1,
  weightmat = NULL,
  init = NULL,
  ndim = 2,
  itmax = 1e+05,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  type = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_rstress_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_rstress_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; this must be a scalar of the kappa transformation for the fitted distances proximities. Defaults to 1. Note the kappa here differs from Jan's version where the parameter was called r and the relationship is r=kappa/2 or kappa=2r.</p>
</td></tr>
<tr><td><code id="stop_rstress_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_rstress_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_rstress_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_rstress_+3A_itmax">itmax</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_rstress_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_rstress_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_rstress_+3A_structures">structures</code></td>
<td>
<p>which structuredness indices to be included in the loss</p>
</td></tr>
<tr><td><code id="stop_rstress_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structuredness indices; ; defaults to 1/#number of structures</p>
</td></tr>
<tr><td><code id="stop_rstress_+3A_strucpars">strucpars</code></td>
<td>
<p>the parameters for the structuredness indices</p>
</td></tr>
<tr><td><code id="stop_rstress_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_rstress_+3A_type">type</code></td>
<td>
<p>How to construct the target function for the multi objective optimization? Either 'additive' (default) or 'multiplicative'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: the stress
</p>
</li>
<li><p>stress.m: default normalized stress
</p>
</li>
<li><p>stoploss: the weighted loss value
</p>
</li>
<li><p>indices: the values of the structuredness indices
</p>
</li>
<li><p>parameters: the parameters used for fitting 
</p>
</li>
<li><p>fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object
</p>
</li></ul>


<hr>
<h2 id='stop_sammon'>STOPS version of Sammon mapping</h2><span id='topic+stop_sammon'></span>

<h3>Description</h3>

<p>Uses MASS::sammon. The free parameter is lambda for power transformations of the observed proximities. The fitted distances power is internally fixed to 1 and the power for the weights=delta is -1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_sammon(
  dis,
  theta = 1,
  ndim = 2,
  init = NULL,
  weightmat = NULL,
  itmax = 1000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "chierarchy", "cconvexity", "cstriatedness", "coutlying", "cskinniness", "csparsity",
    "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  type = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_sammon_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_sammon_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; this must be  a scalar of the lambda transformation for the observed proximities. Defaults to 1.</p>
</td></tr>
<tr><td><code id="stop_sammon_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_sammon_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_sammon_+3A_weightmat">weightmat</code></td>
<td>
<p>a matrix of nonnegative weights. Has no effect here.</p>
</td></tr>
<tr><td><code id="stop_sammon_+3A_itmax">itmax</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_sammon_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_sammon_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_sammon_+3A_structures">structures</code></td>
<td>
<p>which structuredness indices to be included in the loss</p>
</td></tr>
<tr><td><code id="stop_sammon_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structuredness indices; ; defaults to 1/#number of structures</p>
</td></tr>
<tr><td><code id="stop_sammon_+3A_strucpars">strucpars</code></td>
<td>
<p>the parameters for the structuredness indices</p>
</td></tr>
<tr><td><code id="stop_sammon_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_sammon_+3A_type">type</code></td>
<td>
<p>How to construct the target function for the multi objective optimization? Either 'additive' (default) or 'multiplicative'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: the stress
</p>
</li>
<li><p>stress.m: default normalized stress
</p>
</li>
<li><p>stoploss: the weighted loss value
</p>
</li>
<li><p>indices: the values of the structuredness indices
</p>
</li>
<li><p>parameters: the parameters used for fitting 
</p>
</li>
<li><p>fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object
</p>
</li></ul>


<hr>
<h2 id='stop_sammon2'>Another STOPS version of Sammon mapping models (via smacofSym)</h2><span id='topic+stop_sammon2'></span>

<h3>Description</h3>

<p>Uses Smacof, so it can deal with a weight matrix too.  The free parameter is lambda for power transformations of the observed proximities. The fitted distances power is internally fixed to 1 and the power for the weights=delta is -1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_sammon2(
  dis,
  theta = 1,
  ndim = 2,
  weightmat = NULL,
  init = NULL,
  itmax = 1000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  type = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_sammon2_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_sammon2_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; this must be a scalar of the lambda transformation for the observed proximities. Defaults to 1.</p>
</td></tr>
<tr><td><code id="stop_sammon2_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_sammon2_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_sammon2_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_sammon2_+3A_itmax">itmax</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_sammon2_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_sammon2_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_sammon2_+3A_structures">structures</code></td>
<td>
<p>which structuredness indices to be included in the loss</p>
</td></tr>
<tr><td><code id="stop_sammon2_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structuredness indices; ; defaults to 1/#number of structures</p>
</td></tr>
<tr><td><code id="stop_sammon2_+3A_strucpars">strucpars</code></td>
<td>
<p>the parameters for the structuredness indices</p>
</td></tr>
<tr><td><code id="stop_sammon2_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_sammon2_+3A_type">type</code></td>
<td>
<p>How to construct the target function for the multi objective optimization? Either 'additive' (default) or 'multiplicative'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: the stress-1 (sqrt(stress.m))
</p>
</li>
<li><p>stress.m: default normalized stress (used for STOPS)
</p>
</li>
<li><p>stoploss: the weighted loss value
</p>
</li>
<li><p>indices: the values of the structuredness indices
</p>
</li>
<li><p>parameters: the parameters used for fitting 
</p>
</li>
<li><p>fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object
</p>
</li></ul>


<hr>
<h2 id='stop_smacofSphere'>STOPS versions of smacofSphere models</h2><span id='topic+stop_smacofSphere'></span>

<h3>Description</h3>

<p>The free parameter is lambda for power transformations the observed proximities. The fitted distances power is internally fixed to 1 and the power for the weights is 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_smacofSphere(
  dis,
  theta = 1,
  ndim = 2,
  weightmat = NULL,
  init = NULL,
  itmax = 1000,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  type = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_smacofSphere_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_smacofSphere_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; this must be a scalar of the lambda transformation for the observed proximities. Defaults to 1.</p>
</td></tr>
<tr><td><code id="stop_smacofSphere_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_smacofSphere_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_smacofSphere_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_smacofSphere_+3A_itmax">itmax</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_smacofSphere_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_smacofSphere_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_smacofSphere_+3A_structures">structures</code></td>
<td>
<p>which structuredness indices to be included in the loss</p>
</td></tr>
<tr><td><code id="stop_smacofSphere_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structuredness indices; ; defaults to 1/#number of structures</p>
</td></tr>
<tr><td><code id="stop_smacofSphere_+3A_strucpars">strucpars</code></td>
<td>
<p>the parameters for the structuredness indices</p>
</td></tr>
<tr><td><code id="stop_smacofSphere_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_smacofSphere_+3A_type">type</code></td>
<td>
<p>How to construct the target function for the multi objective optimization? Either 'additive' (default) or 'multiplicative'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: the stress
</p>
</li>
<li><p>stress.m: default normalized stress
</p>
</li>
<li><p>stoploss: the weighted loss value
</p>
</li>
<li><p>indices: the values of the structuredness indices
</p>
</li>
<li><p>parameters: the parameters used for fitting 
</p>
</li>
<li><p>fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object
</p>
</li></ul>


<hr>
<h2 id='stop_smacofSym'>STOPS version of smacofSym models</h2><span id='topic+stop_smacofSym'></span>

<h3>Description</h3>

<p>The free parameter is lambda for power transformations the observed proximities. The fitted distances power is internally fixed to 1 and the power for the weights is 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_smacofSym(
  dis,
  theta = 1,
  ndim = 2,
  weightmat = NULL,
  init = NULL,
  itmax = 1000,
  ...,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "chierarchy", "cconvexity", "cstriatedness", "coutlying", "cskinniness", "csparsity",
    "cstringiness", "cclumpiness", "cinequality"),
  stressweight = 1,
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  type = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_smacofSym_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_smacofSym_+3A_theta">theta</code></td>
<td>
<p>the theta vector; must be a scalar for the lambda (proximity) transformation. Defaults to 1.</p>
</td></tr>
<tr><td><code id="stop_smacofSym_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_smacofSym_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_smacofSym_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_smacofSym_+3A_itmax">itmax</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_smacofSym_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting</p>
</td></tr>
<tr><td><code id="stop_smacofSym_+3A_structures">structures</code></td>
<td>
<p>which structuredness indices to be included in the loss</p>
</td></tr>
<tr><td><code id="stop_smacofSym_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_smacofSym_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structuredness indices; ; defaults to 1/#number of structures</p>
</td></tr>
<tr><td><code id="stop_smacofSym_+3A_strucpars">strucpars</code></td>
<td>
<p>the parameters for the structuredness indices</p>
</td></tr>
<tr><td><code id="stop_smacofSym_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_smacofSym_+3A_type">type</code></td>
<td>
<p>How to construct the target function for the multi objective optimization? Either 'additive' (default) or 'multiplicative'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: the stress-1 (sqrt(stress.m))
</p>
</li>
<li><p>stress.m: default normalized stress (used for STOPS)
</p>
</li>
<li><p>stoploss: the weighted loss value
</p>
</li>
<li><p>indices: the values of the structuredness indices
</p>
</li>
<li><p>parameters: the parameters used for fitting 
</p>
</li>
<li><p>fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stops object
</p>
</li></ul>


<hr>
<h2 id='stop_sstress'>STOPS version of sstress</h2><span id='topic+stop_sstress'></span>

<h3>Description</h3>

<p>Free parameter is lambda for the observed proximities. Fitted distances are transformed with power 2, weights have exponent of 1. Note that the lambda here works as a multiplicator of 2 (as sstress has f(delta^2)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_sstress(
  dis,
  theta = 1,
  weightmat = NULL,
  init = NULL,
  ndim = 2,
  itmax = 1e+05,
  ...,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(1/length(structures), length(structures)),
  strucpars,
  verbose = 0,
  type = c("additive", "multiplicative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_sstress_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stop_sstress_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; this must be a scalar of the lambda transformation for the observed proximities. Defaults to 1. Note that the lambda here works as a multiplicator of 2 (as sstress has f(delta^2)).</p>
</td></tr>
<tr><td><code id="stop_sstress_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="stop_sstress_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stop_sstress_+3A_ndim">ndim</code></td>
<td>
<p>the number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stop_sstress_+3A_itmax">itmax</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stop_sstress_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="stop_sstress_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stop_sstress_+3A_structures">structures</code></td>
<td>
<p>which structuredness indices to be included in the loss</p>
</td></tr>
<tr><td><code id="stop_sstress_+3A_strucweight">strucweight</code></td>
<td>
<p>weight to be used for the structuredness indices; ; defaults to 1/#number of structures</p>
</td></tr>
<tr><td><code id="stop_sstress_+3A_strucpars">strucpars</code></td>
<td>
<p>the parameters for the structuredness indices</p>
</td></tr>
<tr><td><code id="stop_sstress_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="stop_sstress_+3A_type">type</code></td>
<td>
<p>How to construct the target function for the multi objective optimization? Either 'additive' (default) or 'multiplicative'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: the stress
</p>
</li>
<li><p>stress.m: default normalized stress
</p>
</li>
<li><p>stoploss: the weighted loss value
</p>
</li>
<li><p>indices: the values of the structuredness indices
</p>
</li>
<li><p>parameters: the parameters used for fitting 
</p>
</li>
<li><p>fit: the returned object of the fitting procedure
</p>
</li>
<li><p>stopobj: the stopobj object
</p>
</li></ul>


<hr>
<h2 id='stoploss'>Calculate the weighted multiobjective loss function used in STOPS</h2><span id='topic+stoploss'></span>

<h3>Description</h3>

<p>Calculate the weighted multiobjective loss function used in STOPS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stoploss(
  obj,
  stressweight = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  strucweight = rep(-1/length(structures), length(structures)),
  strucpars,
  type = c("additive", "multiplicative"),
  verbose = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stoploss_+3A_obj">obj</code></td>
<td>
<p>object returned inside a stop_* function. Uses the stress.m slot for getting the stress.</p>
</td></tr>
<tr><td><code id="stoploss_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stoploss_+3A_structures">structures</code></td>
<td>
<p>which c-structuredness indices to be included in the loss</p>
</td></tr>
<tr><td><code id="stoploss_+3A_strucweight">strucweight</code></td>
<td>
<p>the weights of the structuredness indices; defaults to -1/#number of structures</p>
</td></tr>
<tr><td><code id="stoploss_+3A_strucpars">strucpars</code></td>
<td>
<p>a list of parameters to be passed to the c-structuredness indices in the same order as the values in structures. If the index has no parameters or you want to use the defaults, supply NULL. (alternatively a named list that has the structure name as the element name).</p>
</td></tr>
<tr><td><code id="stoploss_+3A_type">type</code></td>
<td>
<p>what type of weighted combination should be used? Can be 'additive' or 'multiplicative'.</p>
</td></tr>
<tr><td><code id="stoploss_+3A_verbose">verbose</code></td>
<td>
<p>verbose output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with calculated stoploss ($stoploss), structuredness indices ($strucinidices) and hyperparameters ($parameters and $theta)
</p>

<hr>
<h2 id='stops'>stops: structure optimized proximity scaling</h2><span id='topic+stops'></span>

<h3>Description</h3>

<p>A package for &quot;structure optimized proximity scaling&quot; (STOPS), a collection of methods that fit nonlinear distance transformations in multidimensional scaling (MDS) and trade-off the fit with structure considerations to find optimal parameters or optimal configurations. The package contains various functions, wrappers, methods and classes for fitting, plotting and displaying different MDS models in a STOPS framework like Torgerson scaling, SMACOF, Sammon mapping, elastic scaling, symmetric SMACOF, spherical SMACOF, sstress, rstress, powermds, power elastic scaling, power sammon mapping, power stress, Isomap, approximate power stress, restricted power stress. All of these models can also be fit as MDS variants (i.e., no structuredness). The package further contains functions for optimization (Adaptive Luus-Jaakola and for Bayesian optimization with treed Gaussian process with jump to linear models) and functions for various structuredness indices
</p>
<p>This allows to fit STOPS models as described in Rusch, Mair, Hornik (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stops(
  dis,
  loss = c("strain", "stress", "smacofSym", "powerstress", "powermds", "powerelastic",
    "powerstrain", "elastic", "sammon", "sammon2", "smacofSphere", "powersammon",
    "rstress", "sstress", "isomap", "isomapeps", "bcstress", "lmds", "apstress",
    "rpowerstress"),
  theta = 1,
  structures = c("cclusteredness", "clinearity", "cdependence", "cmanifoldness",
    "cassociation", "cnonmonotonicity", "cfunctionality", "ccomplexity", "cfaithfulness",
    "cregularity", "chierarchy", "cconvexity", "cstriatedness", "coutlying",
    "cskinniness", "csparsity", "cstringiness", "cclumpiness", "cinequality"),
  ndim = 2,
  weightmat = NULL,
  init = NULL,
  stressweight = 1,
  strucweight,
  strucpars,
  optimmethod = c("SANN", "ALJ", "pso", "Kriging", "tgp", "DIRECT", "stogo", "cobyla",
    "crs2lm", "isres", "mlsl", "neldermead", "sbplx", "hjk", "cmaes"),
  lower,
  upper,
  verbose = 0,
  type = c("additive", "multiplicative"),
  initpoints = 10,
  itmax = 50,
  itmaxps = 10000,
  model,
  control,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stops_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="stops_+3A_loss">loss</code></td>
<td>
<p>which loss function to be used for fitting, defaults to stress.</p>
</td></tr>
<tr><td><code id="stops_+3A_theta">theta</code></td>
<td>
<p>hyperparameter vector starting values for the transformation functions. If the length is smaller than the number of hyperparameters for the MDS version the vector gets recycled (see the corresponding stop_XXX function or the vignette for how theta must look like exactly for each loss). If larger than the number of hyperparameters for the MDS method, an error is thrown. If completely missing theta is set to 1 and recycled.</p>
</td></tr>
<tr><td><code id="stops_+3A_structures">structures</code></td>
<td>
<p>character vector of which c-structuredness indices should be considered; if missing no structure is considered.</p>
</td></tr>
<tr><td><code id="stops_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="stops_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights; defaults to 1 for all off diagonals</p>
</td></tr>
<tr><td><code id="stops_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="stops_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="stops_+3A_strucweight">strucweight</code></td>
<td>
<p>vector of weights to be used for the c-structuredness indices (in the same order as in structures); defaults to -1/length(structures) for each index</p>
</td></tr>
<tr><td><code id="stops_+3A_strucpars">strucpars</code></td>
<td>
<p>(possibly named with the structure). Metaparameters for the structuredness indices (gamma in the article). It's safest for it be a list of lists with the named arguments for the structuredness indices and the order of the lists must be like the order of structures. So something like this <code>list(list(par1Struc1=par1Struc1,par2Struc1=par2Struc1),list(par1Struc2=par1Struc2,par2Struc2=par2Struc2),...)</code> where parYStrucX are the named arguments for the metaparameter Y of the structure X the list elements corresponds to. For a structure without parameters, set NULL. Parameters in different list elements parYStrucX can have the same name. For example, say we want to use cclusteredness with metaparameters epsilon=10 and k=4 (and the default for the other parameters), cdependence with no metaparameters and cfaithfulness with metaparameter k=7 one would <code>list(list(epsilon=10,k=4),list(NULL),list(dis=obdiss,k=6))</code>  for structures vector (&quot;cclusteredness&quot;,&quot;cdependence&quot;,&quot;cfaithfulness&quot;). The parameter lists must be in the same ordering as the indices in structures. If missing it is set to NULL and defaults are used. It is also possible to supply a structure's metaparameters as a list of vectors with named elements if the metaparameters are scalars, so like <code>list(c(par1Struc1=parStruc1,par2Struc1=par1Struc1,...),c(par1Struc2=par1Struc2,par2Struc2=par2Struc2,...))</code>. That can have unintended consequences if the metaparameter is a vector or matrix.</p>
</td></tr>
<tr><td><code id="stops_+3A_optimmethod">optimmethod</code></td>
<td>
<p>What solver to use. Currently supported are Bayesian optimization with Gaussian Process priors and Kriging (&quot;Kriging&quot;), Bayesian optimization with treed Gaussian processes with jump to linear models (&quot;tgp&quot;), Adaptive LJ Search (&quot;ALJ&quot;), Particle Swarm optimization (&quot;pso&quot;), simulated annealing (&quot;SANN&quot;), &quot;DIRECT&quot;, Stochastic Global Optimization (&quot;stogo&quot;), COBYLA (&quot;cobyla&quot;), Controlled Random Search 2 with local mutation (&quot;crs2lm&quot;), Improved Stochastic Ranking Evolution Strategy (&quot;isres&quot;), Multi-Level Single-Linkage (&quot;mlsl&quot;), Nelder-Mead (&quot;neldermead&quot;), Subplex (&quot;sbplx&quot;), Hooke-Jeeves Pattern Search (&quot;hjk&quot;), CMA-ES (&quot;cmaes&quot;). Defaults to &quot;ALJ&quot; version. tgp, ALJ, Kriging and pso usually work well for relatively low values of itmax.</p>
</td></tr>
<tr><td><code id="stops_+3A_lower">lower</code></td>
<td>
<p>The lower contraints of the search region. Needs to be a numeric vector of the same length as the parameter vector theta.</p>
</td></tr>
<tr><td><code id="stops_+3A_upper">upper</code></td>
<td>
<p>The upper contraints of the search region. Needs to be a numeric vector of the same length as the parameter vector theta.</p>
</td></tr>
<tr><td><code id="stops_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is very verbose.</p>
</td></tr>
<tr><td><code id="stops_+3A_type">type</code></td>
<td>
<p>which aggregation for the multi objective target function? Either 'additive' (default) or 'multiplicative'</p>
</td></tr>
<tr><td><code id="stops_+3A_initpoints">initpoints</code></td>
<td>
<p>number of initial points to fit the surrogate model for Bayesian optimization; default is 10.</p>
</td></tr>
<tr><td><code id="stops_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations of the outer optimization (for theta) or number of steps of Bayesian optimization; default is 50. We recommend a higher number for ALJ (around 150). Note that due to the inner workings of some solvers, this may or may not correspond to the actual number of function evaluations performed (or PS models fitted). E.g., with tgp the actual number of function evaluation of the PS method is between itmax and 6*itmax as tgp samples 1-6 candidates from the posterior and uses the best candidate. For pso it is the number of particles s times itmax. For cmaes it is usually a bit higher than itmax. This currently may get overruled by a control argument if it is used (and then set to either ewhat is supplie dby control or to the default of the method).</p>
</td></tr>
<tr><td><code id="stops_+3A_itmaxps">itmaxps</code></td>
<td>
<p>maximum number of iterations of the inner optimization (to obtain the PS configuration)</p>
</td></tr>
<tr><td><code id="stops_+3A_model">model</code></td>
<td>
<p>a character specifying the surrogate model to use. For Kriging it specifies the covariance kernel for the GP prior; see <code>covTensorProduct-class</code> defaults to &quot;powerexp&quot;. For tgp it specifies the non stationary process used see <code>bgp</code>, defaults to &quot;btgpllm&quot;</p>
</td></tr>
<tr><td><code id="stops_+3A_control">control</code></td>
<td>
<p>a control argument passed to the outer optimization procedure. Will override any other control arguents passed, especially verbose and itmax. For the efect of control, see the functions pomp::sannbox for SANN and pso::psoptim for pso, cmaes::cma_es for cmaes, dfoptim::hjkb for hjk and the nloptr docs for the algorithms DIRECT, stogo, cobyla, crs2lm, isres, mlsl, neldermead, sbplx.</p>
</td></tr>
<tr><td><code id="stops_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the outer optimization procedures (not fully tested).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The stops package provides five categories of important functions:
</p>
<p>Models &amp; Algorithms:
</p>

<ul>
<li><p> stops() ... which fits STOPS models as described in Rusch et al. (2023). By setting cordweight or strucweight to zero they can also be used to fit metric MDS for many different models, see below.  
</p>
</li>
<li><p> powerStressMin()... a workhorse for fitting many stresses, including s-stress, r-stress (De Leeuw, 2014), Sammon mapping with power transformations (powersammon), elastic scaling with power transformation (powerelastic), power stress. They can most conveniently be accessed via the stops functions and setting stressweight=1 and cordweight or strucweight=0 or by the dedicated functions starting with stop_foo where foo is the method and setting stressweight=1 and strucweight=0. It uses the nested majorization algorithm for r-stress of De Leeuw(2014).
</p>
</li>
<li><p> bcStressMin()... a workhorse for fitting Box-Cox stress (Chen &amp; Buja, 2013).
</p>
</li>
<li><p> lmds()... a workhorse for the local MDS of Chen &amp; Buja (2008).
</p>
</li></ul>

<p>Structuredness Indices:
Various c-structuredness as c_foo(), where foo is the name of the structuredness.  See Rusch et al. (2023). 
</p>
<p>Optimization functions:
</p>

<ul>
<li><p> ljoptim() ... An (adaptive) version of the Luus-Jakola random search
</p>
</li></ul>

<p>Wrappers and convenience functions:
</p>

<ul>
<li><p> conf_adjust(): procrustes adjustment of configurations 
</p>
</li>
<li><p> cmdscale(), sammon(): wrappers that return S3 objects
</p>
</li>
<li><p> stop_smacofSym(), stop_sammon(), stop_cmdscale(), stop_rstress(), stop_powerstress(),stop_smacofSphere(), stop_sammon2(), stop_elastic(), stop_sstress(), stop_powerelastic(), stop_powersammon(),  stop_powermds(), stop_isomap(), stop_isomapeps(), stop_bcstress(), stop_lmds(), stop_apstress(),stops_rpowerstress(): stop versions of these MDS models.
</p>
</li>
<li><p> stoploss() ... a function to calculate stoploss (Rusch et al., 2023)
</p>
</li></ul>

<p>Methods: 
For most of the objects returned by the high-level functions S3 classes and methods for standard generics were implemented, including print, summary, plot, plot3d, plot3dstatic.   
</p>
<p>References:
</p>

<ul>
<li><p> Rusch, T., Mair, P., &amp; Hornik, K. (2023). Structure-based hyperparameter selection with Bayesian optimization in multidimensional scaling. Statistics &amp; Computing, 33, [28]. https://doi.org/10.1007/s11222-022-10197-w
</p>
</li></ul>

<p>Authors: Thomas Rusch, Lisha Chen, Jan de Leeuw, Patrick Mair, Kurt Hornik
</p>
<p>Maintainer: Thomas Rusch
</p>
<p>The combination of c-structurednes indices and stress uses the stress.m values, which are the explictly normalized stresses. Reported however is the stress-1 value which is sqrt(stress.m).
</p>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stoploss: the stoploss value
</p>
</li>
<li><p> optim: the object returned from the optimization procedure
</p>
</li>
<li><p> stressweight: the stressweight
</p>
</li>
<li><p> strucweight: the vector of structure weights
</p>
</li>
<li><p> call: the call
</p>
</li>
<li><p> optimmethod: The solver selected
</p>
</li>
<li><p> losstype: The PS badness-of-fit function
</p>
</li>
<li><p> nobj: the number of objects in the configuration
</p>
</li>
<li><p> type: The type of stoploss scalacrisation (additive or multiplicative)
</p>
</li>
<li><p> fit: The fitted PS object (most importantly $fit$conf the fitted configuration) 
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(kinshipdelta,package="smacof")

strucpars&lt;-list(list(epsilon=10,minpts=2,scale=3),list(NULL))
dissm&lt;-as.matrix(kinshipdelta)

#STOPS with strain
resstrain&lt;-stops(dissm,loss="strain",theta=1,structures=c("cclusteredness","cdependence"),
strucpars=strucpars,optimmethod="ALJ",lower=0,upper=10,itmax=10)
resstrain
summary(resstrain)
plot(resstrain)


#STOPS with stress
strucpars&lt;-list(list(epsilon=10,minpts=2,scale=3),NULL) 
resstress&lt;-stops(dissm,loss="stress",
structures=c("cclusteredness","cdependence"),
strucpars=strucpars,optimmethod="ALJ",lower=0,upper=10)
resstress
summary(resstress)
plot(resstress)
plot(resstress,"Shepard")

#STOPS with powerstress
respstress&lt;-stops(dissm,loss="powerstress",
structures=c("cclusteredness","cdependence"),
strucpars=strucpars,weightmat=dissm,
itmaxps=1000,optimmethod="ALJ",lower=c(0,0,1),upper=c(10,10,10))
respstress
summary(respstress)
plot(respstress)

#STOPS with bcstress
resbcstress&lt;-stops(dissm,loss="bcstress",
structures=c("cclusteredness","cdependence"),
strucpars=strucpars,optimmethod="ALJ",lower=c(0,1,0),upper=c(10,10,10))
resbcstress
summary(resbcstress)
plot(resbcstress)

#STOPS with lmds
reslmds&lt;-stops(dissm,loss="lmds",
structures=c("cclusteredness","clinearity"),
strucpars=strucpars,optimmethod="ALJ",lower=c(2,0),upper=c(10,2))
reslmds
summary(reslmds)
plot(reslmds)

#STOPS with Isomap (the epsilon version)
resiso&lt;-stops(dissm,loss="isomapeps",
structures=c("cclusteredness","clinearity"),
strucpars=strucpars,optimmethod="ALJ",lower=70,upper=120)
resiso
summary(resiso)
plot(resiso)


data(kinshipdelta,package="smacof")
strucpar&lt;-list(NULL,NULL) #parameters for indices
res1&lt;-stops(kinshipdelta,loss="stress",
structures=c("cclumpiness","cassociation"),strucpars=strucpar,
lower=0,upper=10,itmax=10)
res1


data(BankingCrisesDistances)
strucpar&lt;-list(c(epsilon=10,minpts=2),NULL) #parameters for indices
res1&lt;-stops(BankingCrisesDistances[,1:69],loss="stress",verbose=0,
structures=c("cclusteredness","clinearity"),strucpars=strucpar,
lower=0,upper=10)
res1

strucpar&lt;-list(list(alpha=0.6,C=15,var.thr=1e-5,zeta=NULL),
list(alpha=0.6,C=15,var.thr=1e-5,zeta=NULL))
res1&lt;-stops(BankingCrisesDistances[,1:69],loss="stress",verbose=0,
structures=c("cfunctionality","ccomplexity"),strucpars=strucpar,
lower=0,upper=10)
res1


</code></pre>

<hr>
<h2 id='summary.cmdscale'>S3 summary method for cmdscale</h2><span id='topic+summary.cmdscale'></span>

<h3>Description</h3>

<p>S3 summary method for cmdscale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cmdscale'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cmdscale_+3A_object">object</code></td>
<td>
<p>object of class cmdscale</p>
</td></tr>
<tr><td><code id="summary.cmdscale_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, just prints.
</p>

<hr>
<h2 id='summary.sammon'>S3 summary method for sammon</h2><span id='topic+summary.sammon'></span>

<h3>Description</h3>

<p>S3 summary method for sammon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sammon'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.sammon_+3A_object">object</code></td>
<td>
<p>object of class sammon</p>
</td></tr>
<tr><td><code id="summary.sammon_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, just prints.
</p>

<hr>
<h2 id='summary.smacofP'>S3 summary method for smacofP</h2><span id='topic+summary.smacofP'></span>

<h3>Description</h3>

<p>S3 summary method for smacofP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smacofP'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.smacofP_+3A_object">object</code></td>
<td>
<p>object of class smacofP</p>
</td></tr>
<tr><td><code id="summary.smacofP_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class summary.smacofP
</p>

<hr>
<h2 id='summary.stops'>S3 summary method for stops</h2><span id='topic+summary.stops'></span>

<h3>Description</h3>

<p>S3 summary method for stops
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stops'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.stops_+3A_object">object</code></td>
<td>
<p>object of class stops</p>
</td></tr>
<tr><td><code id="summary.stops_+3A_...">...</code></td>
<td>
<p>addditional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class 'summary.stops'
</p>

<hr>
<h2 id='Swissroll'>Swiss roll</h2><span id='topic+Swissroll'></span>

<h3>Description</h3>

<p>A swiss roll data example where 150 data points are arranged on a swiss roll embedded in a 3D space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Swissroll)
</code></pre>


<h3>Format</h3>

<p>A data frame with 150 rows and 4 columns
</p>


<h3>Details</h3>

<p>A data frame with the variables (columns)
</p>

<ul>
<li><p> x The x axis coordinate for each point
</p>
</li>
<li><p> y The y axis coordinate for each point
</p>
</li>
<li><p> z The z axis coordinate for each point
</p>
</li>
<li><p> col a color code for each point with points along the y axis having the same color (based on the viridis palette) 
</p>
</li></ul>


<hr>
<h2 id='tgpoptim'>Bayesian Optimization by a (treed) Bayesian Gaussian Process Prior (with jumps to linear models) surrogate model
Essentially a wrapper for the functionality in tgp that has the same slots as optim with defaults for STOPS models.</h2><span id='topic+tgpoptim'></span>

<h3>Description</h3>

<p>Bayesian Optimization by a (treed) Bayesian Gaussian Process Prior (with jumps to linear models) surrogate model
Essentially a wrapper for the functionality in tgp that has the same slots as optim with defaults for STOPS models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tgpoptim(
  x,
  fun,
  ...,
  initpoints = 10,
  lower,
  upper,
  acc = 1e-08,
  itmax = 10,
  verbose = 0,
  model = "bgp"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tgpoptim_+3A_x">x</code></td>
<td>
<p>optional starting values</p>
</td></tr>
<tr><td><code id="tgpoptim_+3A_fun">fun</code></td>
<td>
<p>function to minimize</p>
</td></tr>
<tr><td><code id="tgpoptim_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the function to be optimized</p>
</td></tr>
<tr><td><code id="tgpoptim_+3A_initpoints">initpoints</code></td>
<td>
<p>the number of points to sample initially to fit the surrogate model</p>
</td></tr>
<tr><td><code id="tgpoptim_+3A_lower">lower</code></td>
<td>
<p>The lower contraints of the search region</p>
</td></tr>
<tr><td><code id="tgpoptim_+3A_upper">upper</code></td>
<td>
<p>The upper contraints of the search region</p>
</td></tr>
<tr><td><code id="tgpoptim_+3A_acc">acc</code></td>
<td>
<p>if the numerical accuracy of two successive target function values is below this, stop the optimization; defaults to 1e-8</p>
</td></tr>
<tr><td><code id="tgpoptim_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="tgpoptim_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="tgpoptim_+3A_model">model</code></td>
<td>
<p>which surrogate model class to use (currently uses defaults only, will extend this to tweak the model)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components (for compatiility with <code><a href="stats.html#topic+optim">optim</a></code>)
</p>

<ul>
<li><p> par The position of the optimum in the search space (parameters that minimize the function; argmin fun). 
</p>
</li>
<li><p> value The value of the objective function at the optimum (min fun). Note we do not use the last value in the candidate list but the best candidate (which can but need not coincide). 
</p>
</li>
<li><p> svalue The value of the surrogate objective function at the optimal parameters
</p>
</li>
<li><p> counts The number of iterations performed at convergence with entries fnction for the number of iterations and gradient which is always NA at the moment
</p>
</li>
<li><p> convergence 0 successful completion by the accd or acc criterion, 1 indicate iteration limit was reached, 99 is a problem 
</p>
</li>
<li><p> message is NULL (only for compatibility or future use)
</p>
</li>
<li><p> history the improvement history
</p>
</li>
<li><p> tgpout the output of the tgp model    
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
fbana &lt;- function(x) {
x1 &lt;- x[1]
x2 &lt;- x[2]
100 * (x2 - x1 * x1)^2 + (1 - x1)^2
}
res1&lt;-tgpoptim(c(-1.2,1),fbana,lower=c(-5,-5),upper=c(5,5),acc=1e-16,itmax=20)
res1

fwild &lt;- function (x) 10*sin(0.3*x)*sin(1.3*x^2) + 0.00001*x^4 + 0.2*x+80
plot(fwild, -50, 50, n = 1000, main = "Bayesian GP Optimization minimizing 'wild function'")
set.seed(210485)
res2&lt;-tgpoptim(50, fwild,lower=-50,upper=50,acc=1e-16,itmax=20,model="btgpllm")
points(res2$par,res2$value,col="red",pch=19)
res2

</code></pre>

<hr>
<h2 id='torgerson'>Torgerson scaling</h2><span id='topic+torgerson'></span>

<h3>Description</h3>

<p>Torgerson scaling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>torgerson(delta, p = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="torgerson_+3A_delta">delta</code></td>
<td>
<p>symmetric, numeric matrix of distances</p>
</td></tr>
<tr><td><code id="torgerson_+3A_p">p</code></td>
<td>
<p>target space dimensions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix (a Torgerson scaling configuration)
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
