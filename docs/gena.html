<!DOCTYPE html><html><head><title>Help for package gena</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gena}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gena'><p>Genetic Algorithm</p></a></li>
<li><a href='#gena.constr'><p>Constraints</p></a></li>
<li><a href='#gena.crossover'><p>Crossover</p></a></li>
<li><a href='#gena.hybrid'><p>Hybridization</p></a></li>
<li><a href='#gena.mating'><p>Mating</p></a></li>
<li><a href='#gena.mutation'><p>Mutation</p></a></li>
<li><a href='#gena.population'><p>Population</p></a></li>
<li><a href='#genaDiff'><p>Numeric Differentiation</p></a></li>
<li><a href='#plot.gena'><p>Plot best found fitnesses during genetic algorithm</p></a></li>
<li><a href='#plot.pso'><p>Plot best found fitnesses during genetic algorithm</p></a></li>
<li><a href='#print.gena'><p>Print method for &quot;gena&quot; object</p></a></li>
<li><a href='#print.pso'><p>Print method for &quot;pso&quot; object</p></a></li>
<li><a href='#print.summary.gena'><p>Summary for &quot;gena&quot; object</p></a></li>
<li><a href='#print.summary.pso'><p>Summary for &quot;pso&quot; object</p></a></li>
<li><a href='#pso'><p>Particle Swarm Optimization</p></a></li>
<li><a href='#pso.nh'><p>Neighbourhood</p></a></li>
<li><a href='#pso.velocity'><p>Velocity</p></a></li>
<li><a href='#rhypersphere'><p>Hypersphere</p></a></li>
<li><a href='#summary.gena'><p>Summarizing gena Fits</p></a></li>
<li><a href='#summary.pso'><p>Summarizing pso Fits</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Genetic Algorithm and Particle Swarm Optimization</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-08</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements genetic algorithm and particle swarm algorithm for real-valued functions. Various modifications (including hybridization and elitism) of these algorithms are provided. Implemented functions are based on ideas described in S. Katoch, S. Chauhan, V. Kumar (2020) &lt;<a href="https://doi.org/10.1007%2Fs11042-020-10139-6">doi:10.1007/s11042-020-10139-6</a>&gt; and M. Clerc (2012) <a href="https://hal.archives-ouvertes.fr/hal-00764996">https://hal.archives-ouvertes.fr/hal-00764996</a>.</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.6)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-12 14:38:07 UTC; bogda</td>
</tr>
<tr>
<td>Author:</td>
<td>Bogdan Potanin [aut, cre, ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bogdan Potanin &lt;bogdanpotanin@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-15 08:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='gena'>Genetic Algorithm</h2><span id='topic+gena'></span>

<h3>Description</h3>

<p>This function allows to use genetic algorithm for
numeric global optimization of real-valued functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gena(
  fn,
  gr = NULL,
  lower,
  upper,
  pop.n = 100,
  pop.initial = NULL,
  pop.method = "uniform",
  mating.method = "rank",
  mating.par = NULL,
  mating.self = FALSE,
  crossover.method = "local",
  crossover.par = NULL,
  crossover.prob = 0.8,
  mutation.method = "constant",
  mutation.par = NULL,
  mutation.prob = 0.2,
  mutation.genes.prob = 1/length(lower),
  elite.n = min(10, 2 * round(pop.n/20)),
  elite.duplicates = FALSE,
  hybrid.method = "rank",
  hybrid.par = 2,
  hybrid.prob = 0,
  hybrid.opt.par = NULL,
  hybrid.n = 1,
  constr.method = NULL,
  constr.par = NULL,
  maxiter = 100,
  is.max = TRUE,
  info = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gena_+3A_fn">fn</code></td>
<td>
<p>function to be maximized i.e. fitness function.</p>
</td></tr>
<tr><td><code id="gena_+3A_gr">gr</code></td>
<td>
<p>gradient of the <code>fn</code>.</p>
</td></tr>
<tr><td><code id="gena_+3A_lower">lower</code></td>
<td>
<p>lower bound of the search space.</p>
</td></tr>
<tr><td><code id="gena_+3A_upper">upper</code></td>
<td>
<p>upper bound of the search space.</p>
</td></tr>
<tr><td><code id="gena_+3A_pop.n">pop.n</code></td>
<td>
<p>integer representing the size of the population.</p>
</td></tr>
<tr><td><code id="gena_+3A_pop.initial">pop.initial</code></td>
<td>
<p>numeric matrix which rows are chromosomes to be
included into the initial population. Numeric vector will be coerced to
single row matrix.</p>
</td></tr>
<tr><td><code id="gena_+3A_pop.method">pop.method</code></td>
<td>
<p>the algorithm to be applied for a creation of 
the initial population. See 'Details' for additional information.</p>
</td></tr>
<tr><td><code id="gena_+3A_mating.method">mating.method</code></td>
<td>
<p>the algorithm to be applied for a mating i.e. selection
of parents. See 'Details' for additional information.</p>
</td></tr>
<tr><td><code id="gena_+3A_mating.par">mating.par</code></td>
<td>
<p>parameters of the mating (selection) algorithm.</p>
</td></tr>
<tr><td><code id="gena_+3A_mating.self">mating.self</code></td>
<td>
<p>logical; if <code>TRUE</code> then the chromosome may
mate with itself i.e. both parents may be the same chromosome.</p>
</td></tr>
<tr><td><code id="gena_+3A_crossover.method">crossover.method</code></td>
<td>
<p>an algorithm to be applied for crossover i.e.
creation of the children. See 'Details' for additional information.</p>
</td></tr>
<tr><td><code id="gena_+3A_crossover.par">crossover.par</code></td>
<td>
<p>parameters of the crossover algorithm.</p>
</td></tr>
<tr><td><code id="gena_+3A_crossover.prob">crossover.prob</code></td>
<td>
<p>probability of the crossover for each pair of parents.</p>
</td></tr>
<tr><td><code id="gena_+3A_mutation.method">mutation.method</code></td>
<td>
<p>algorithm to be applied for mutation i.e. random
change in some genes of the children. 
See 'Details' for additional information.</p>
</td></tr>
<tr><td><code id="gena_+3A_mutation.par">mutation.par</code></td>
<td>
<p>parameters of the mutation algorithm.</p>
</td></tr>
<tr><td><code id="gena_+3A_mutation.prob">mutation.prob</code></td>
<td>
<p>mutation probability for the chromosomes.</p>
</td></tr>
<tr><td><code id="gena_+3A_mutation.genes.prob">mutation.genes.prob</code></td>
<td>
<p>mutation probability for the genes.</p>
</td></tr>
<tr><td><code id="gena_+3A_elite.n">elite.n</code></td>
<td>
<p>number of the elite children i.e. those which have the
highest function value and will be preserved for the next population.</p>
</td></tr>
<tr><td><code id="gena_+3A_elite.duplicates">elite.duplicates</code></td>
<td>
<p>logical; if <code>TRUE</code> then some elite children
may have the same genes.</p>
</td></tr>
<tr><td><code id="gena_+3A_hybrid.method">hybrid.method</code></td>
<td>
<p>hybrids selection algorithm i.e. mechanism 
determining which chromosomes should be subject to local optimization.
See 'Details' for additional information.</p>
</td></tr>
<tr><td><code id="gena_+3A_hybrid.par">hybrid.par</code></td>
<td>
<p>parameters of the hybridization algorithm.</p>
</td></tr>
<tr><td><code id="gena_+3A_hybrid.prob">hybrid.prob</code></td>
<td>
<p>probability of generating the hybrids each iteration.</p>
</td></tr>
<tr><td><code id="gena_+3A_hybrid.opt.par">hybrid.opt.par</code></td>
<td>
<p>parameters of the local optimization function
to be used for hybridization algorithm (including <code>fn</code> and <code>gr</code>).</p>
</td></tr>
<tr><td><code id="gena_+3A_hybrid.n">hybrid.n</code></td>
<td>
<p>number of hybrids that appear if hybridization
should take place during the iteration.</p>
</td></tr>
<tr><td><code id="gena_+3A_constr.method">constr.method</code></td>
<td>
<p>the algorithm to be applied for imposing constraints
on the chromosomes. See 'Details' for additional information.</p>
</td></tr>
<tr><td><code id="gena_+3A_constr.par">constr.par</code></td>
<td>
<p>parameters of the constraint algorithm.</p>
</td></tr>
<tr><td><code id="gena_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations of the algorithm.</p>
</td></tr>
<tr><td><code id="gena_+3A_is.max">is.max</code></td>
<td>
<p>logical; if <code>TRUE</code> (default) then fitness function
will be maximized. Otherwise it will be minimized.</p>
</td></tr>
<tr><td><code id="gena_+3A_info">info</code></td>
<td>
<p>logical; if <code>TRUE</code> (default) then some optimization related 
information will be printed each iteration.</p>
</td></tr>
<tr><td><code id="gena_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to 
<code>fn</code> and <code>gr</code> functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To find information on particular methods available via
<code>pop.method</code>,
<code>mating.method</code>, <code>crossover.method</code>, <code>mutation.method</code>,
<code>hybrid.method</code> and <code>constr.method</code>
arguments please see 'Details' section of 
<code><a href="#topic+gena.population">gena.population</a></code>, <code><a href="#topic+gena.crossover">gena.crossover</a></code>,
<code><a href="#topic+gena.mutation">gena.mutation</a></code>, <code><a href="#topic+gena.hybrid">gena.hybrid</a></code> 
and <code><a href="#topic+gena.constr">gena.constr</a></code> correspondingly. For example to
find information on possible values of <code>mutation.method</code> and
<code>mutation.par</code> arguments see description of <code>method</code> and
<code>par</code> arguments of <code><a href="#topic+gena.mutation">gena.mutation</a></code> function.
</p>
<p>It is possible to provide manually implemented functions for 
population initialization, mating, crossover, mutation and hybridization. 
For example manual mutation function may be provided through
<code>mutation.method</code> argument. It should have the same signature 
(arguments) as <code><a href="#topic+gena.mutation">gena.mutation</a></code> function and return 
the same object i.e. the matrix of chromosomes of the appropriate size.
Manually implemented functions for other operators (crossover, mating
and so on) may be provided in a similar way.
</p>
<p>By default function does not impose any constraints upon the parameters.
If <code>constr.method = "bounds"</code> then <code>lower</code> and <code>upper</code> 
constraints will be imposed. Lower bounds should be strictly smaller
then upper bounds.
</p>
<p>Currently the only available termination condition is <code>maxiter</code>. We
are going to provide some additional termination conditions during
future updates.
</p>
<p>Infinite values in <code>lower</code> and <code>upper</code> are substituted with
<code>-(.Machine$double.xmax * 0.9)</code> and <code>.Machine$double.xmax * 0.9</code>
correspondingly.
</p>
<p>By default if <code>gr</code> is provided then BFGS algorithm will be used inside
<code><a href="stats.html#topic+optim">optim</a></code> during hybridization.
Otherwise <code>Nelder-Mead</code> will be used. 
Manual values for <code><a href="stats.html#topic+optim">optim</a></code> arguments may be provided 
(as a list) through <code>hybrid.opt.par</code> argument.
</p>
<p>Arguments <code>pop.n</code> and <code>elite.n</code> should be even integers and
<code>elite.n</code> should be greater then 2. If these arguments are odd integers 
then they will be coerced to even integers by adding 1. 
Also <code>pop.n</code> should be greater then <code>elite.n</code> at least by 2.
</p>
<p>For more information on the genetic algorithm
please see Katoch et. al. (2020).
</p>


<h3>Value</h3>

<p>This function returns an object of class <code>gena</code> that is a list
containing the following elements:
</p>

<ul>
<li> <p><code>par</code> - chromosome (solution) with the highest fitness
(objective function) value.
</p>
</li>
<li> <p><code>value</code> - value of <code>fn</code> at <code>par</code>.
</p>
</li>
<li> <p><code>population</code> - matrix of chromosomes (solutions) of the 
last iteration of the algorithm.
</p>
</li>
<li> <p><code>counts</code> - a two-element integer vector giving the number of
calls to <code>fn</code> and <code>gr</code> respectively.
</p>
</li>
<li> <p><code>is.max</code> - identical to <code>is.max</code> input argument.
</p>
</li>
<li> <p><code>fitness.history</code> - vector which i-th element is fitness
of the best chromosome in i-th iteration.
</p>
</li>
<li> <p><code>iter</code> - last iteration number.
</p>
</li></ul>



<h3>References</h3>

<p>S. Katoch, S. Chauhan, V. Kumar (2020). 
A review on genetic algorithm: past, present, and future.
<em>Multimedia Tools and Applications</em>, 80, 8091-8126.
&lt;doi:10.1007/s11042-020-10139-6&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Consider Ackley function

fn &lt;- function(par, a = 20, b = 0.2)
{
  val &lt;- a * exp(-b * sqrt(0.5 * (par[1] ^ 2 + par[2] ^ 2))) +
         exp(0.5 * (cos(2 * pi * par[1]) + cos(2 * pi * par[2]))) -
         exp(1) - a
  return(val)
}

# Maximize this function using classical
# genetic algorithm setup
set.seed(123)
lower &lt;- c(-5, -100)
upper &lt;- c(100, 5)
opt &lt;- gena(fn = fn, 
            lower = lower, upper = upper,
            hybrid.prob = 0,
            a = 20, b = 0.2)
print(opt$par)

# Replicate optimization using hybridization
opt &lt;- gena(fn = fn, 
            lower = lower, upper = upper,
            hybrid.prob = 0.2,
            a = 20, b = 0.2)
print(opt$par)


## Consider Rosenbrock function
fn &lt;- function(par, a = 100)
{
  val &lt;- -(a * (par[2] - par[1] ^ 2) ^ 2 + (1 - par[1]) ^ 2 +
           a * (par[3] - par[2] ^ 2) ^ 2 + (1 - par[2]) ^ 2)
  return(val)
}

# Apply genetic algorithm
lower &lt;- rep(-10, 3)
upper &lt;- rep(10, 3)
set.seed(123)
opt &lt;- gena(fn = fn,
            lower = lower, upper = upper,
            a = 100)
print(opt$par)


# Improve the results by hybridization
opt &lt;- gena(fn = fn,
            lower = lower, upper = upper,
            hybrid.prob = 0.2,
            a = 100)
print(opt$par)


# Provide manually implemented mutation function
# which simply randomly sorts genes. 
# Note that this function should have the same 
# arguments as gena.mutation.
mutation.my &lt;- function(children, lower, upper, 
                        prob, prob.genes, 
                        method, par, iter)
{
  # Get dimensional data
  children.n &lt;- nrow(children)
  genes.n &lt;- ncol(children)
  
  # Select chromosomes that should mutate
  random_values &lt;- runif(children.n, 0, 1)
  mutation_ind &lt;- which(random_values &lt;= prob)
   
  # Mutate chromosomes by randomly sorting
  # their genes
  for (i in mutation_ind)
  {
    children[i, ] &lt;- children[i, sample(1:genes.n)]
  }
  
  # Return mutated chromosomes
  return(children)
}

opt &lt;- gena(fn = fn,
            lower = lower, upper = upper,
            mutation.method = mutation.my,
            a = 100)
print(opt$par)

</code></pre>

<hr>
<h2 id='gena.constr'>Constraints</h2><span id='topic+gena.constr'></span>

<h3>Description</h3>

<p>Impose constraints on chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gena.constr(population, method = "bounds", par, iter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gena.constr_+3A_population">population</code></td>
<td>
<p>numeric matrix which rows are chromosomes i.e. vectors of 
parameters values.</p>
</td></tr>
<tr><td><code id="gena.constr_+3A_method">method</code></td>
<td>
<p>method used to impose constraints.</p>
</td></tr>
<tr><td><code id="gena.constr_+3A_par">par</code></td>
<td>
<p>additional parameters to be passed depending on the <code>method</code>.</p>
</td></tr>
<tr><td><code id="gena.constr_+3A_iter">iter</code></td>
<td>
<p>iteration number of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>method = "bounds"</code> then chromosomes will be bounded
between <code>par$lower</code> and <code>par$upper</code>.
</p>


<h3>Value</h3>

<p>The function returns a list with the following elements:
</p>

<ul>
<li> <p><code>population</code> - matrix which rows are chromosomes after
constraints have been imposed.
</p>
</li>
<li> <p><code>constr.ind</code> - matrix of logical values which (i, j)-th
elements equals <code>TRUE</code> (<code>FALSE</code> otherwise) if j-th jene of
i-th chromosome is a subject to constraint.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Randomly initialize population
set.seed(123)
population &lt;- gena.population(pop.n = 10,
                              lower = c(-5, -5), 
                              upper = c(5, 5))
                           
# Impose lower and upper bounds constraints
pop.constr &lt;- gena.constr(population, 
                          method = "bounds",
                          par = list(lower = c(-1, 2),
                                     upper = c(1, 5)))
print(pop.constr)

</code></pre>

<hr>
<h2 id='gena.crossover'>Crossover</h2><span id='topic+gena.crossover'></span>

<h3>Description</h3>

<p>Crossover method (algorithm) to be used in the
genetic algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gena.crossover(
  parents,
  fitness = NULL,
  prob = 0.8,
  method = "local",
  par = NULL,
  iter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gena.crossover_+3A_parents">parents</code></td>
<td>
<p>numeric matrix which rows are parents i.e. vectors of 
parameters values.</p>
</td></tr>
<tr><td><code id="gena.crossover_+3A_fitness">fitness</code></td>
<td>
<p>numeric vector which <code>i</code>-th element is the value of 
<code>fn</code> at point <code>population[i, ]</code>.</p>
</td></tr>
<tr><td><code id="gena.crossover_+3A_prob">prob</code></td>
<td>
<p>probability of crossover.</p>
</td></tr>
<tr><td><code id="gena.crossover_+3A_method">method</code></td>
<td>
<p>crossover method to be used for making children.</p>
</td></tr>
<tr><td><code id="gena.crossover_+3A_par">par</code></td>
<td>
<p>additional parameters to be passed depending on the <code>method</code>.</p>
</td></tr>
<tr><td><code id="gena.crossover_+3A_iter">iter</code></td>
<td>
<p>iteration number of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Denote <code>parents</code> by <code class="reqn">C^{parent}</code> which <code>i</code>-th row 
<code>parents[i, ]</code> is a chromosome <code class="reqn">c_{i}^{parent}</code> i.e. the vector of 
parameter values of the function being optimized <code class="reqn">f(.)</code> that is
provided via <code>fn</code> argument of <code><a href="#topic+gena">gena</a></code>.
The elements of chromosome <code class="reqn">c_{ij}^{parent}</code> are genes 
representing parameters values.
</p>
<p>Crossover algorithm determines the way parents produce children. 
During crossover each of randomly selected pairs of parents 
<code class="reqn">c_{i}^{parent}</code>, <code class="reqn">c_{i + 1}^{parent}</code>
produce two children 
<code class="reqn">c_{i}^{child}</code>, <code class="reqn">c_{i + 1}^{child}</code>, 
where <code class="reqn">i</code> is odd. Each pair of parents is selected with 
probability <code>prob</code>. If pair of parents have not been selected
for crossover then corresponding children and parents are coincide i.e. 
<code class="reqn">c_{i}^{child}=c_{i}^{parent}</code> and
<code class="reqn">c_{i+1}^{child}=c_{i+1}^{parent}</code>.
</p>
<p>Argument <code>method</code> determines particular crossover algorithm to 
be applied. Denote by <code class="reqn">\tau</code> the vector of parameters used by the 
algorithm. Note that <code class="reqn">\tau</code> corresponds to <code>par</code>.
</p>
<p>If <code>method = "split"</code> then each gene of the first child will
be equiprobably picked from the first or from the second parent. So 
<code class="reqn">c_{ij}^{child}</code> may be equal to <code class="reqn">c_{ij}^{parent}</code>
or <code class="reqn">c_{(i+1)j}^{parent}</code> with equal probability. The second
child is the reversal of the first one in a sense that if the first child 
gets particular gene of the first (second) parent then the second child gets
this gene from the first (second) parent i.e. if
<code class="reqn">c_{ij}^{child}=c_{ij}^{parent}</code> then 
<code class="reqn">c_{(i+1)j}^{child}=c_{(i+1)j}^{parent}</code>; if 
<code class="reqn">c_{ij}^{child}=c_{(i+1)j}^{parent}</code> then 
<code class="reqn">c_{(i+1)j}^{child}=c_{ij}^{parent}</code>.
</p>
<p>If <code>method = "arithmetic"</code> then:
</p>
<p style="text-align: center;"><code class="reqn">c_{i}^{child}=\tau_{1}c_{i}^{parent}+
\left(1-\tau_{1}\right)c_{i+1}^{parent}</code>
</p>

<p style="text-align: center;"><code class="reqn">c_{i+1}^{child}=\left(1-\tau_{1}\right)c_{i}^{parent}+
\tau_{1}c_{i+1}^{parent}</code>
</p>

<p>where <code class="reqn">\tau_{1}</code> is <code>par[1]</code>. By default <code>par[1] = 0.5</code>.
</p>
<p>If <code>method = "local"</code> then the procedure is the same as 
for &quot;arithmetic&quot; method but <code class="reqn">\tau_{1}</code> is a uniform random
value between 0 and 1.
</p>
<p>If <code>method = "flat"</code> then <code class="reqn">c_{ij}^{child}</code> is a uniform
random number between <code class="reqn">c_{ij}^{parent}</code> and 
<code class="reqn">c_{(i+1)j}^{parent}</code>. 
Similarly for the second child <code class="reqn">c_{(i+1)j}^{child}</code>.
</p>
<p>For more information on crossover algorithms
please see Kora, Yadlapalli (2017).
</p>


<h3>Value</h3>

<p>The function returns a matrix which rows are children.
</p>


<h3>References</h3>

<p>P. Kora, P. Yadlapalli. (2017). 
Crossover Operators in Genetic Algorithms: A Review.
<em>International Journal of Computer Applications</em>, 162 (10), 34-36,
&lt;doi:10.5120/ijca2017913370&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Randomly initialize the parents
set.seed(123)
parents.n &lt;- 10
parents &lt;- gena.population(pop.n = parents.n,
                           lower = c(-5, -5), 
                           upper = c(5, 5))
                           
# Perform the crossover
children &lt;- gena.crossover(parents = parents,
                           prob = 0.6,
                           method = "local")
print(children)
</code></pre>

<hr>
<h2 id='gena.hybrid'>Hybridization</h2><span id='topic+gena.hybrid'></span>

<h3>Description</h3>

<p>Hybridization method (algorithm) to be used in the
genetic algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gena.hybrid(
  population,
  fitness,
  hybrid.n = 1,
  method,
  par,
  opt.par,
  info = FALSE,
  iter = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gena.hybrid_+3A_population">population</code></td>
<td>
<p>numeric matrix which rows are chromosomes i.e. vectors of 
parameters values.</p>
</td></tr>
<tr><td><code id="gena.hybrid_+3A_fitness">fitness</code></td>
<td>
<p>numeric vector which <code>i</code>-th element is the value of 
<code>fn</code> at point <code>population[i, ]</code>.</p>
</td></tr>
<tr><td><code id="gena.hybrid_+3A_hybrid.n">hybrid.n</code></td>
<td>
<p>positive integer representing the number of hybrids.</p>
</td></tr>
<tr><td><code id="gena.hybrid_+3A_method">method</code></td>
<td>
<p>hybridization method to improve chromosomes via local search.</p>
</td></tr>
<tr><td><code id="gena.hybrid_+3A_par">par</code></td>
<td>
<p>additional parameters to be passed depending on the <code>method</code>.</p>
</td></tr>
<tr><td><code id="gena.hybrid_+3A_opt.par">opt.par</code></td>
<td>
<p>parameters of the local optimization function
to be used for hybridization algorithm (including <code>fn</code> and <code>gr</code>).</p>
</td></tr>
<tr><td><code id="gena.hybrid_+3A_info">info</code></td>
<td>
<p>logical; if <code>TRUE</code> then some optimization related 
information will be printed each iteration.</p>
</td></tr>
<tr><td><code id="gena.hybrid_+3A_iter">iter</code></td>
<td>
<p>iteration number of the genetic algorithm.</p>
</td></tr>
<tr><td><code id="gena.hybrid_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to 
<code>fn</code> and <code>gr</code> functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses <code><a href="#topic+gena.mating">gena.mating</a></code> function to 
select hybrids. Therefore <code>method</code> and <code>par</code> arguments will
be passed to this function. If some chromosomes selected to become hybrids
are duplicated then these duplicates will not be subject to local
optimization i.e. the number of hybrids will be decreased by the number
of duplicates (actual number of hybrids during some iterations may be 
lower than <code>hybrid.n</code>).
</p>
<p>Currently <code><a href="stats.html#topic+optim">optim</a></code> is the only available local
optimizer. Therefore <code>opt.par</code> is a list containing parameters
that should be passed to <code><a href="stats.html#topic+optim">optim</a></code>.
</p>
<p>For more information on hybridization
please see El-mihoub et. al. (2006).
</p>


<h3>Value</h3>

<p>The function returns a list with the following elements:
</p>

<ul>
<li> <p><code>population</code> - matrix which rows are chromosomes including hybrids.
</p>
</li>
<li> <p><code>fitness</code> - vector which i-th element is the fitness of the
i-th chromosome.
</p>
</li>
<li> <p><code>hybrids.ind</code> - vector of indexes of chromosomes selected for
hybridization.
</p>
</li>
<li> <p><code>counts</code> a two-element integer vector giving the number of
calls to <code>fn</code> and <code>gr</code> respectively.
</p>
</li></ul>



<h3>References</h3>

<p>T. El-mihoub, A. Hopgood, L. Nolle, B. Alan (2006). 
Hybrid Genetic Algorithms: A Review.
<em>Engineering Letters</em>, 13 (3), 124-137.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Consider the following fitness function
fn &lt;- function(x)
{
  val &lt;- x[1] * x[2] - x[1] ^ 2 - x[2] ^ 2
}

# Also let's provide it's gradient (optional)
gr &lt;- function(x)
{
  val &lt;- c(x[2] - 2 * x[1],
           x[1] - 2 * x[2])
}

# Randomly initialize the population
set.seed(123)
n_population &lt;- 10
population &lt;- gena.population(pop.n = n_population,
                              lower = c(-5, -5), 
                              upper = c(5, 5))

# Calculate fitness of each chromosome
fitness &lt;- rep(NA, n_population)
for(i in 1:n_population)
{
  fitness[i] &lt;- fn(population[i, ])
}

# Perform hybridization
hybrids &lt;- gena.hybrid(population = population,
                       fitness = fitness,
                       opt.par = list(fn = fn,
                                      gr = gr,
                                      method = "BFGS",
                                      control = list(fnscale = -1,
                                                     abstol = 1e-10,
                                                     reltol = 1e-10,
                                                     maxit = 1000)),
                       hybrid.n = 2,
                       method = "rank",
                       par = 0.8)
print(hybrids)

</code></pre>

<hr>
<h2 id='gena.mating'>Mating</h2><span id='topic+gena.mating'></span>

<h3>Description</h3>

<p>Mating (selection) method (algorithm) to be used in the
genetic algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gena.mating(
  population,
  fitness,
  parents.n,
  method = "rank",
  par = NULL,
  self = FALSE,
  iter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gena.mating_+3A_population">population</code></td>
<td>
<p>numeric matrix which rows are chromosomes i.e. vectors of 
parameters values.</p>
</td></tr>
<tr><td><code id="gena.mating_+3A_fitness">fitness</code></td>
<td>
<p>numeric vector which <code>i</code>-th element is the value of 
<code>fn</code> at point <code>population[i, ]</code>.</p>
</td></tr>
<tr><td><code id="gena.mating_+3A_parents.n">parents.n</code></td>
<td>
<p>even positive integer representing the number of parents.</p>
</td></tr>
<tr><td><code id="gena.mating_+3A_method">method</code></td>
<td>
<p>mating method to be used for selection of parents.</p>
</td></tr>
<tr><td><code id="gena.mating_+3A_par">par</code></td>
<td>
<p>additional parameters to be passed depending on the <code>method</code>.</p>
</td></tr>
<tr><td><code id="gena.mating_+3A_self">self</code></td>
<td>
<p>logical; if <code>TRUE</code> then chromosome may mate itself. 
Otherwise mating is allowed only between different chromosomes.</p>
</td></tr>
<tr><td><code id="gena.mating_+3A_iter">iter</code></td>
<td>
<p>iteration number of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Denote <code>population</code> by <code class="reqn">C</code> which <code>i</code>-th row 
<code>population[i, ]</code> is a chromosome <code class="reqn">c_{i}</code> i.e. the vector of 
parameter values of the function being optimized <code class="reqn">f(.)</code> that is
provided via <code>fn</code> argument of <code><a href="#topic+gena">gena</a></code>.
The elements of chromosome <code class="reqn">c_{ij}</code> are genes representing parameters 
values. Argument <code>fitness</code> is a vector of function values at
corresponding chromosomes i.e. <code>fitness[i]</code> corresponds to
<code class="reqn">f_{i}=f(c_{i})</code>. Total number of chromosomes in population
<code class="reqn">n_{population}</code> equals to <code>nrow(population)</code>.
</p>
<p>Mating algorithm determines selection of chromosomes that will become parents. 
During mating each iteration one of chromosomes become a parent until
there are <code class="reqn">n_{parents}</code> (i.e. <code>parents.n</code>) parents selected.
Each chromosome may become a parent multiple times or not become a 
parent at all.
</p>
<p>Denote by <code class="reqn">c^{s}_{i}</code> the <code class="reqn">i</code>-th of selected parents. Parents
<code class="reqn">c^{s}_{i}</code> and <code class="reqn">c^{s}_{i + 1}</code> form a pair that will further
produce a child (offspring), where <code class="reqn">i</code> is odd.
If <code>self = FALSE</code> then for each pair of parents 
<code class="reqn">(c_{i}^s, c_{i+1}^s)</code> it is insured that 
<code class="reqn">c^{s}_{i} \ne c^{s}_{i + 1}</code> except the case when there are several 
identical chromosomes in population. However <code>self</code> is ignored 
if <code>method</code> is <code>"tournament"</code>, so in this case self-mating
is always possible.
</p>
<p>Denote by <code class="reqn">p_{i}</code> the probability of a chromosome to become a parent.
Remind that each chromosome may become a parent multiple times.
Probability <code class="reqn">p_{i}\left(f_{i}\right)</code> is a function 
of fitness <code class="reqn">f_{i}</code>. Usually this function is non-decreasing so 
more fitted chromosomes have higher probability of becoming a parent. 
There is also an intermediate value <code class="reqn">w_{i}</code> called weight such that:
</p>
<p style="text-align: center;"><code class="reqn">p_{i}=\frac{w_{i}}{\sum\limits_{j=1}^{n_{population}}w_{j}}</code>
</p>

<p>Therefore all weights <code class="reqn">w_{i}</code> are proportional to corresponding 
probabilities <code class="reqn">p_{i}</code> by the same factor (sum of weights).
</p>
<p>Argument <code>method</code> determines particular mating algorithm to be applied.
Denote by <code class="reqn">\tau</code> the vector of parameters used by the algorithm.
Note that <code class="reqn">\tau</code> corresponds to <code>par</code>. The algorithm determines
a particular form of the <code class="reqn">w_{i}\left(f_{i}\right)</code> function which 
in turn determines <code class="reqn">p_{i}\left(f_{i}\right)</code>.
</p>
<p>If <code>method = "constant"</code> then all weights and probabilities are equal:
</p>
<p style="text-align: center;"><code class="reqn">w_{i}=1 =&gt; p_{i}=\frac{1}{n_{population}}</code>
</p>

<p>If <code>method = "rank"</code> then each chromosome receives a rank <code class="reqn">r_{i}</code> 
based on the fitness <code class="reqn">f_{i}</code> value. So if <code>j</code>-th chromosome is the
fittest one and <code>k</code>-th chromosome has the lowest fitness value then
<code class="reqn">r_{j}=n_{population}</code> and  <code class="reqn">r_{k}=1</code>. The relationship
between weight <code class="reqn">w_{i}</code> and rank <code class="reqn">r_{i}</code> is as follows:
</p>
<p style="text-align: center;"><code class="reqn">w_{i}=\left(\frac{r_{i}}{n_{population}}\right)^{\tau_{1}}</code>
</p>

<p>The greater value of <code class="reqn">\tau_{1}</code> the greater portion of probability will
be delivered to more fitted chromosomes. 
Default value is <code class="reqn">\tau_{1} = 0.5</code> so <code>par = 0.5</code>.
</p>
<p>If <code>method = "fitness"</code> then weights are calculated as follows:
</p>
<p style="text-align: center;"><code class="reqn">w_{i}=\left(f_{i} - 
                  \min\left(f_{1},...,f_{n_{population}}\right) + 
                  \tau_{1}\right)^{\tau_{2}}</code>
</p>

<p>By default <code class="reqn">\tau_{1}=10</code> and <code class="reqn">\tau_{2}=0.5</code> i.e. 
<code>par = c(10, 0.5)</code>. There is a restriction <code class="reqn">\tau_{1}\geq0</code>
insuring that expression in brackets is non-negative.
</p>
<p>If <code>method = "tournament"</code> then  <code class="reqn">\tau_{1}</code> (i.e. <code>par</code>) 
chromosomes will be randomly selected with equal probabilities and without 
replacement. Then the chromosome with the highest fitness 
(among these selected chromosomes) value will become a parent.
It is possible to provide representation of this algorithm via 
probabilities <code class="reqn">p_{i}</code> but the formulas are numerically unstable.
By default <code>par = min(5, ceiling(parents.n * 0.1))</code>.
</p>
<p>Validation and default values assignment for <code>par</code> is performed inside
<code><a href="#topic+gena">gena</a></code> function not in <code><a href="#topic+gena.mating">gena.mating</a></code>.
It allows to perform validation a single time instead of repeating it
each iteration of genetic algorithm.
</p>
<p>For more information on mating (selection) algorithms
please see Shukla et. al. (2015).
</p>


<h3>Value</h3>

<p>The function returns a list with the following elements:
</p>

<ul>
<li> <p><code>parents</code> - matrix which rows are parents. The number of
rows of this matrix equals to <code>parents.n</code> while the number of columns
is <code>ncol(population)</code>.
</p>
</li>
<li> <p><code>fitness</code> - vector which i-th element is the fitness of the
i-th parent.
</p>
</li>
<li> <p><code>ind</code> - vector which i-th element is the index of i-th
parent in population so <code>$parents[i, ]</code> equals to 
<code>population[ind[i], ]</code>.
</p>
</li></ul>



<h3>References</h3>

<p>A. Shukla, H. Pandey, D. Mehrotra (2015). 
Comparative review of selection techniques in genetic algorithm.
<em>2015 International Conference on Futuristic Trends on Computational 
Analysis and Knowledge Management (ABLAZE)</em>, 515-519,
&lt;doi:10.1109/ABLAZE.2015.7154916&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Consider the following fitness function
fn &lt;- function(x)
{
  val &lt;- x[1] * x[2] - x[1] ^ 2 - x[2] ^ 2
}

# Randomly initialize the population
set.seed(123)
pop.nulation &lt;- 10
population &lt;- gena.population(pop.n = pop.nulation,
                              lower = c(-5, -5), 
                              upper = c(5, 5))

# Calculate fitness of each chromosome
fitness &lt;- rep(NA, pop.nulation)
for(i in 1:pop.nulation)
{
  fitness[i] &lt;- fn(population[i, ])
}

# Perform mating to select parents
parents &lt;- gena.mating(population = population,
                       fitness = fitness,
                       parents.n = pop.nulation,
                       method = "rank",
                       par = 0.8)
print(parents)

</code></pre>

<hr>
<h2 id='gena.mutation'>Mutation</h2><span id='topic+gena.mutation'></span>

<h3>Description</h3>

<p>Mutation method (algorithm) to be used in the
genetic algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gena.mutation(
  children,
  lower,
  upper,
  prob = 0.2,
  prob.genes = 1/nrow(children),
  method = "constant",
  par = 1,
  iter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gena.mutation_+3A_children">children</code></td>
<td>
<p>numeric matrix which rows are children i.e. vectors of 
parameters values.</p>
</td></tr>
<tr><td><code id="gena.mutation_+3A_lower">lower</code></td>
<td>
<p>lower bound of the search space.</p>
</td></tr>
<tr><td><code id="gena.mutation_+3A_upper">upper</code></td>
<td>
<p>upper bound of the search space.</p>
</td></tr>
<tr><td><code id="gena.mutation_+3A_prob">prob</code></td>
<td>
<p>probability of mutation for a child.</p>
</td></tr>
<tr><td><code id="gena.mutation_+3A_prob.genes">prob.genes</code></td>
<td>
<p>numeric vector or numeric value representing the
probability of mutation of a child's gene. See 'Details'.</p>
</td></tr>
<tr><td><code id="gena.mutation_+3A_method">method</code></td>
<td>
<p>mutation method to be used for transforming genes of children.</p>
</td></tr>
<tr><td><code id="gena.mutation_+3A_par">par</code></td>
<td>
<p>additional parameters to be passed depending on the <code>method</code>.</p>
</td></tr>
<tr><td><code id="gena.mutation_+3A_iter">iter</code></td>
<td>
<p>iteration number of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Denote <code>children</code> by <code class="reqn">C^{child}</code> which <code>i</code>-th row 
<code>children[i, ]</code> is a chromosome <code class="reqn">c_{i}^{child}</code> i.e. the vector of 
parameter values of the function being optimized <code class="reqn">f(.)</code> that is
provided via <code>fn</code> argument of <code><a href="#topic+gena">gena</a></code>.
The elements of chromosome <code class="reqn">c_{ij}^{child}</code> are genes 
representing parameters values.
</p>
<p>Mutation algorithm determines random transformation of children's genes. 
Each child may be selected for mutation with probability <code>prob</code>.
If <code class="reqn">i</code>-th child is selected for mutation and <code>prob.genes</code> is a 
vector then <code class="reqn">j</code>-th gene of this child
is transformed with probability <code>prob.genes[j]</code>. If <code>prob.genes</code>
is a constant then this probability is the same for all genes.
</p>
<p>Argument <code>method</code> determines particular mutation algorithm to 
be applied. Denote by <code class="reqn">\tau</code> the vector of parameters used by the 
algorithm. Note that <code class="reqn">\tau</code> corresponds to <code>par</code>.
Also let's denote by <code class="reqn">c_{ij}^{mutant}</code> the value of 
gene <code class="reqn">c_{ij}^{child}</code> after mutation.
</p>
<p>If <code>method = "constant"</code> then <code class="reqn">c_{ij}^{mutant}</code>
is a uniform random variable between <code>lower[j]</code> and <code>upper[j]</code>.
</p>
<p>If <code>method = "normal"</code> then <code class="reqn">c_{ij}^{mutant}</code>
equals to the sum of <code class="reqn">c_{ij}^{child}</code> and normal random variable
with zero mean and standard deviation <code>par[j]</code>. 
By default <code>par</code> is identity vector of length <code>ncol(children)</code>
so <code>par[j] = 1</code> for all <code>j</code>.
</p>
<p>If <code>method = "percent"</code> then <code class="reqn">c_{ij}^{mutant}</code> is generated 
from <code class="reqn">c_{ij}^{child}</code>  by equiprobably increasing or decreasing it 
by <code class="reqn">q</code> percent,
where <code class="reqn">q</code> is a uniform random variable between <code class="reqn">0</code> and <code>par[j]</code>. 
Note that <code>par</code> may also be a constant then all
genes have the same maximum possible percentage change.
By default <code>par = 20</code>.
</p>
<p>For more information on mutation algorithms
please see Patil, Bhende (2014).
</p>


<h3>Value</h3>

<p>The function returns a matrix which rows are children
(after mutation has been applied to some of them).
</p>


<h3>References</h3>

<p>S. Patil, M. Bhende. (2014). 
Comparison and Analysis of Different Mutation Strategies to improve the 
Performance of Genetic Algorithm.
<em>International Journal of Computer Science and 
Information Technologies</em>, 5 (3), 4669-4673.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Randomly initialize some children
set.seed(123)
children.n &lt;- 10
children &lt;- gena.population(pop.n = children.n,
                            lower = c(-5, -5), 
                            upper = c(5, 5))
                           
# Perform the mutation
mutants &lt;- gena.mutation(children = children,
                         prob = 0.6,
                         prob.genes = c(0.7, 0.8),
                         par = 30,
                         method = "percent")
print(mutants)
</code></pre>

<hr>
<h2 id='gena.population'>Population</h2><span id='topic+gena.population'></span>

<h3>Description</h3>

<p>Initialize the population of chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gena.population(pop.n, lower, upper, pop.initial = NULL, method = "uniform")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gena.population_+3A_pop.n">pop.n</code></td>
<td>
<p>positive integer representing the number of chromosomes 
in population.</p>
</td></tr>
<tr><td><code id="gena.population_+3A_lower">lower</code></td>
<td>
<p>numeric vector which i-th element determines the minimum
possible value for i-th gene.</p>
</td></tr>
<tr><td><code id="gena.population_+3A_upper">upper</code></td>
<td>
<p>numeric vector which i-th element determines the maximum
possible value for i-th gene.</p>
</td></tr>
<tr><td><code id="gena.population_+3A_pop.initial">pop.initial</code></td>
<td>
<p>numeric matrix which rows are initial chromosomes
suggested by user.</p>
</td></tr>
<tr><td><code id="gena.population_+3A_method">method</code></td>
<td>
<p>string representing the initialization method to be used.
For a list of possible values see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>"method = uniform"</code> then i-th gene of each chromosome is randomly 
(uniformly) chosen between <code>lower[i]</code> and <code>upper[i]</code> bounds. If
<code>"method = normal"</code> then i-th gene is generated from a truncated
normal distribution with mean <code>(upper[i] + lower[i]) / 2</code> and
standard deviation <code>(upper[i] - lower[i]) / 6</code> where <code>lower[i]</code>
and <code>upper[i]</code> are lower and upper truncation bounds correspondingly.
If <code>"method = hypersphere"</code> then population is simulated uniformly
from the hypersphere with center <code>upper - lower</code> and radius
<code>sqrt(sum((upper - lower) ^ 2))</code> via <code><a href="#topic+rhypersphere">rhypersphere</a></code>
function setting <code>type = "inside"</code>.
</p>


<h3>Value</h3>

<p>This function returns a matrix which rows are chromosomes.
</p>


<h3>References</h3>

<p>B. Kazimipour, X. Li, A. Qin (2014). 
A review of population initialization techniques for evolutionary algorithms.
<em>2014 IEEE Congress on Evolutionary Computation</em>, 2585-2592,
&lt;doi:10.1109/CEC.2014.6900618&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
gena.population(pop.n = 10,
                lower = c(-1, -2, -3),
                upper = c(1, 0, -1),
                pop.initial = rbind(c(0, -1, -2),
                                    c(0.1, -1.2, -2.3)),
                method = "normal")
</code></pre>

<hr>
<h2 id='genaDiff'>Numeric Differentiation</h2><span id='topic+genaDiff'></span><span id='topic+gena.grad'></span><span id='topic+gena.hessian'></span>

<h3>Description</h3>

<p>Numeric estimation of the gradient and Hessian.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gena.grad(
  fn,
  par,
  eps = sqrt(.Machine$double.eps) * abs(par),
  method = "central-difference",
  fn.args = NULL
)

gena.hessian(
  fn = NULL,
  gr = NULL,
  par,
  eps = sqrt(.Machine$double.eps) * abs(par),
  fn.args = NULL,
  gr.args = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genaDiff_+3A_fn">fn</code></td>
<td>
<p>function for which gradient or Hessian should be calculated.</p>
</td></tr>
<tr><td><code id="genaDiff_+3A_par">par</code></td>
<td>
<p>point (parameters' value) at which <code>fn</code> should be 
differentiated.</p>
</td></tr>
<tr><td><code id="genaDiff_+3A_eps">eps</code></td>
<td>
<p>numeric vector representing increment of the <code>par</code>. 
So <code>eps[i]</code> represents increment of <code>par[i]</code>. If <code>eps</code> is
a constant then all increments are the same.</p>
</td></tr>
<tr><td><code id="genaDiff_+3A_method">method</code></td>
<td>
<p>numeric differentiation method: &quot;central-difference&quot; or
&quot;forward-difference&quot;.</p>
</td></tr>
<tr><td><code id="genaDiff_+3A_fn.args">fn.args</code></td>
<td>
<p>list containing arguments of <code>fn</code> except <code>par</code>.</p>
</td></tr>
<tr><td><code id="genaDiff_+3A_gr">gr</code></td>
<td>
<p>gradient function of <code>fn</code>.</p>
</td></tr>
<tr><td><code id="genaDiff_+3A_gr.args">gr.args</code></td>
<td>
<p>list containing arguments of <code>gr</code> except <code>par</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is possible to substantially improve numeric Hessian accuracy 
by using analytical gradient <code>gr</code>. If both <code>fn</code> and <code>gr</code>
are provided then only <code>gr</code> will be used. If only <code>fn</code> is provided 
for <code>gena.hessian</code> then <code>eps</code> will be transformed to 
<code>sqrt(eps)</code> for numeric stability purposes.
</p>


<h3>Value</h3>

<p>Function <code>gena.grad</code> returns a vector that is a gradient of 
<code>fn</code> at point <code>par</code> calculated via <code>method</code> numeric 
differentiation approach using increment <code>eps</code>.
</p>
<p>Function <code>gena.hessian</code> returns a matrix that is a Hessian of 
<code>fn</code> at point <code>par</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Consider the following function
fn &lt;- function(par, a = 1, b = 2)
{
  val &lt;- par[1] * par[2] - a * par[1] ^ 2 - b * par[2] ^ 2
}

# Calculate the gradient at point (2, 5) respect to 'par' 
# when 'a = 1' and 'b = 1'
par &lt;- c(2, 5)
fn.args = list(a = 1, b = 1)
gena.grad(fn = fn, par = par, fn.args = fn.args)

# Calculate Hessian at the same point
gena.hessian(fn = fn, par = par, fn.args = fn.args)

# Repeat calculation of the Hessian using analytical gradient
gr &lt;- function(par, a = 1, b = 2)
{
  val &lt;- c(par[2] - 2 * a * par[1],
           par[1] - 2 * b * par[2])
}
gena.hessian(gr = gr, par = par, gr.args = fn.args)

</code></pre>

<hr>
<h2 id='plot.gena'>Plot best found fitnesses during genetic algorithm</h2><span id='topic+plot.gena'></span>

<h3>Description</h3>

<p>Plot best found fitnesses during genetic algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gena'
plot(x, y = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gena_+3A_x">x</code></td>
<td>
<p>Object of class &quot;gena&quot;</p>
</td></tr>
<tr><td><code id="plot.gena_+3A_y">y</code></td>
<td>
<p>this parameter currently ignored</p>
</td></tr>
<tr><td><code id="plot.gena_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function does not return anything.
</p>

<hr>
<h2 id='plot.pso'>Plot best found fitnesses during genetic algorithm</h2><span id='topic+plot.pso'></span>

<h3>Description</h3>

<p>Plot best found fitnesses during genetic algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pso'
plot(x, y = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pso_+3A_x">x</code></td>
<td>
<p>Object of class &quot;pso&quot;</p>
</td></tr>
<tr><td><code id="plot.pso_+3A_y">y</code></td>
<td>
<p>this parameter currently ignored</p>
</td></tr>
<tr><td><code id="plot.pso_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function does not return anything.
</p>

<hr>
<h2 id='print.gena'>Print method for &quot;gena&quot; object</h2><span id='topic+print.gena'></span>

<h3>Description</h3>

<p>Print method for &quot;gena&quot; object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gena'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gena_+3A_x">x</code></td>
<td>
<p>Object of class &quot;gena&quot;</p>
</td></tr>
<tr><td><code id="print.gena_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function does not return anything.
</p>

<hr>
<h2 id='print.pso'>Print method for &quot;pso&quot; object</h2><span id='topic+print.pso'></span>

<h3>Description</h3>

<p>Print method for &quot;pso&quot; object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pso'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.pso_+3A_x">x</code></td>
<td>
<p>Object of class &quot;pso&quot;</p>
</td></tr>
<tr><td><code id="print.pso_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function does not return anything.
</p>

<hr>
<h2 id='print.summary.gena'>Summary for &quot;gena&quot; object</h2><span id='topic+print.summary.gena'></span>

<h3>Description</h3>

<p>Summary for &quot;gena&quot; object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.gena'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.gena_+3A_x">x</code></td>
<td>
<p>Object of class &quot;gena&quot;</p>
</td></tr>
<tr><td><code id="print.summary.gena_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns <code>x</code> input argument.
</p>

<hr>
<h2 id='print.summary.pso'>Summary for &quot;pso&quot; object</h2><span id='topic+print.summary.pso'></span>

<h3>Description</h3>

<p>Summary for &quot;pso&quot; object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.pso'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.pso_+3A_x">x</code></td>
<td>
<p>Object of class &quot;pso&quot;</p>
</td></tr>
<tr><td><code id="print.summary.pso_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns <code>x</code> input argument.
</p>

<hr>
<h2 id='pso'>Particle Swarm Optimization</h2><span id='topic+pso'></span>

<h3>Description</h3>

<p>This function allows to use particle swarm algorithm for
numeric global optimization of real-valued functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pso(
  fn,
  gr = NULL,
  lower,
  upper,
  pop.n = 40,
  pop.initial = NULL,
  pop.method = "uniform",
  nh.method = "random",
  nh.par = 3,
  nh.adaptive = TRUE,
  velocity.method = "hypersphere",
  velocity.par = list(w = 1/(2 * log(2)), c1 = 0.5 + log(2), c2 = 0.5 + log(2)),
  hybrid.method = "rank",
  hybrid.par = 2,
  hybrid.prob = 0,
  hybrid.opt.par = NULL,
  hybrid.n = 1,
  constr.method = NULL,
  constr.par = NULL,
  random.order = TRUE,
  maxiter = 100,
  is.max = TRUE,
  info = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pso_+3A_fn">fn</code></td>
<td>
<p>function to be maximized i.e. fitness function.</p>
</td></tr>
<tr><td><code id="pso_+3A_gr">gr</code></td>
<td>
<p>gradient of the <code>fn</code>.</p>
</td></tr>
<tr><td><code id="pso_+3A_lower">lower</code></td>
<td>
<p>lower bound of the search space.</p>
</td></tr>
<tr><td><code id="pso_+3A_upper">upper</code></td>
<td>
<p>upper bound of the search space.</p>
</td></tr>
<tr><td><code id="pso_+3A_pop.n">pop.n</code></td>
<td>
<p>integer representing the size of the population.</p>
</td></tr>
<tr><td><code id="pso_+3A_pop.initial">pop.initial</code></td>
<td>
<p>numeric matrix which rows are particles to be
included into the initial population. Numeric vector will be coerced to
single row matrix.</p>
</td></tr>
<tr><td><code id="pso_+3A_pop.method">pop.method</code></td>
<td>
<p>the algorithm to be applied for a creation of 
the initial population. See 'Details' for additional information.</p>
</td></tr>
<tr><td><code id="pso_+3A_nh.method">nh.method</code></td>
<td>
<p>string representing the method (topology) to be used for
the creation of neighbourhoods. See 'Details' for additional information.</p>
</td></tr>
<tr><td><code id="pso_+3A_nh.par">nh.par</code></td>
<td>
<p>parameters of the topology algorithm.</p>
</td></tr>
<tr><td><code id="pso_+3A_nh.adaptive">nh.adaptive</code></td>
<td>
<p>logical; if <code>TRUE</code> (default) then neighbourhoods
change every time when the best known (to the swarm) fitnesses value have
not increased. Neighbourhoods are updated according to the topology
defined via <code>nh.method</code> argument.</p>
</td></tr>
<tr><td><code id="pso_+3A_velocity.method">velocity.method</code></td>
<td>
<p>string representing the method to be used for
the update of velocities.</p>
</td></tr>
<tr><td><code id="pso_+3A_velocity.par">velocity.par</code></td>
<td>
<p>parameters of the velocity formula.</p>
</td></tr>
<tr><td><code id="pso_+3A_hybrid.method">hybrid.method</code></td>
<td>
<p>hybrids selection algorithm i.e. mechanism 
determining which particles should be subject to local optimization.
See 'Details' for additional information.</p>
</td></tr>
<tr><td><code id="pso_+3A_hybrid.par">hybrid.par</code></td>
<td>
<p>parameters of the hybridization algorithm.</p>
</td></tr>
<tr><td><code id="pso_+3A_hybrid.prob">hybrid.prob</code></td>
<td>
<p>probability of generating the hybrids each iteration.</p>
</td></tr>
<tr><td><code id="pso_+3A_hybrid.opt.par">hybrid.opt.par</code></td>
<td>
<p>parameters of the local optimization function
to be used for hybridization algorithm (including <code>fn</code> and <code>gr</code>).</p>
</td></tr>
<tr><td><code id="pso_+3A_hybrid.n">hybrid.n</code></td>
<td>
<p>number of hybrids that appear if hybridization
should take place during the iteration.</p>
</td></tr>
<tr><td><code id="pso_+3A_constr.method">constr.method</code></td>
<td>
<p>the algorithm to be applied for imposing constraints
on the particles. See 'Details' for additional information.</p>
</td></tr>
<tr><td><code id="pso_+3A_constr.par">constr.par</code></td>
<td>
<p>parameters of the constraint algorithm.</p>
</td></tr>
<tr><td><code id="pso_+3A_random.order">random.order</code></td>
<td>
<p>logical; if <code>TRUE</code> (default) then particles
related routine will be implemented in a random order.</p>
</td></tr>
<tr><td><code id="pso_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations of the algorithm.</p>
</td></tr>
<tr><td><code id="pso_+3A_is.max">is.max</code></td>
<td>
<p>logical; if <code>TRUE</code> (default) then fitness function
will be maximized. Otherwise it will be minimized.</p>
</td></tr>
<tr><td><code id="pso_+3A_info">info</code></td>
<td>
<p>logical; if <code>TRUE</code> (default) then some optimization related 
information will be printed each iteration.</p>
</td></tr>
<tr><td><code id="pso_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to 
<code>fn</code> and <code>gr</code> functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Default arguments have been set in accordance with SPSO 2011
algorithm proposed by M. Clerc (2012).
</p>
<p>To find information on particular methods available via
<code>pop.method</code>, <code>nh.method</code>, <code>velocity.method</code>,
<code>hybrid.method</code> and <code>constr.method</code>
arguments please see 'Details' section of 
<code><a href="#topic+gena.population">gena.population</a></code>, <code><a href="#topic+pso.nh">pso.nh</a></code>,
<code><a href="#topic+pso.velocity">pso.velocity</a></code>, <code><a href="#topic+gena.hybrid">gena.hybrid</a></code> 
and <code><a href="#topic+gena.constr">gena.constr</a></code> correspondingly.
</p>
<p>It is possible to provide manually implemented functions for population
initialization, neighbourhoods creation, velocity updated, hybridization
and constraints in a similar way as for <code><a href="#topic+gena">gena</a></code>.
</p>
<p>By default function does not impose any constraints upon the parameters.
If <code>constr.method = "bounds"</code> then <code>lower</code> and <code>upper</code> 
constraints will be imposed. Lower bounds should be strictly smaller
then upper bounds.
</p>
<p>Currently the only available termination condition is <code>maxiter</code>. We
are going to provide some additional termination conditions during
future updates.
</p>
<p>Infinite values in <code>lower</code> and <code>upper</code> are substituted with
<code>-(.Machine$double.xmax * 0.9)</code> and <code>.Machine$double.xmax * 0.9</code>
correspondingly.
</p>
<p>By default if <code>gr</code> is provided then BFGS algorithm will be used inside
<code><a href="stats.html#topic+optim">optim</a></code> during hybridization.
Otherwise <code>Nelder-Mead</code> will be used. 
Manual values for <code><a href="stats.html#topic+optim">optim</a></code> arguments may be provided 
(as a list) through <code>hybrid.opt.par</code> argument.
</p>
<p>For more information on particle swarm optimization 
please see M. Clerc (2012).
</p>


<h3>Value</h3>

<p>This function returns an object of class <code>pso</code> that is a list
containing the following elements:
</p>

<ul>
<li> <p><code>par</code> - particle (solution) with the highest fitness
(objective function) value.
</p>
</li>
<li> <p><code>value</code> - value of <code>fn</code> at <code>par</code>.
</p>
</li>
<li> <p><code>population</code> - matrix of particles (solutions) of the 
last iteration of the algorithm.
</p>
</li>
<li> <p><code>counts</code> - a two-element integer vector giving the number of
calls to <code>fn</code> and <code>gr</code> respectively.
</p>
</li>
<li> <p><code>is.max</code> - identical to <code>is.max</code> input argument.
</p>
</li>
<li> <p><code>fitness.history</code> - vector which i-th element is fitness
of the best particle in i-th iteration.
</p>
</li>
<li> <p><code>iter</code> - last iteration number.
</p>
</li></ul>



<h3>References</h3>

<p>M. Clerc (2012). 
Standard Particle Swarm Optimisation.
<em>HAL archieve</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Consider Ackley function

fn &lt;- function(par, a = 20, b = 0.2)
{
  val &lt;- a * exp(-b * sqrt(0.5 * (par[1] ^ 2 + par[2] ^ 2))) +
         exp(0.5 * (cos(2 * pi * par[1]) + cos(2 * pi * par[2]))) -
         exp(1) - a
  return(val)
}

# Maximize this function using particle swarm algorithm

set.seed(123)
lower &lt;- c(-5, -100)
upper &lt;- c(100, 5)
opt &lt;- pso(fn = fn, 
           lower = lower, upper = upper,
           a = 20, b = 0.2)
print(opt$par)


## Consider Bukin function number 6

fn &lt;- function(x, a = 20, b = 0.2)
{
  val &lt;- 100 * sqrt(abs(x[2] - 0.01 * x[1] ^ 2)) + 0.01 * abs(x[1] + 10)
  return(val)
}

# Minimize this function using initially provided
# position for one of the particles
set.seed(777)
lower &lt;- c(-15, -3)
upper &lt;- c(-5, 3)
opt &lt;- pso(fn = fn, 
           pop.init = c(8, 2),
           lower = lower, upper = upper,
           is.max = FALSE)
print(opt$par)

</code></pre>

<hr>
<h2 id='pso.nh'>Neighbourhood</h2><span id='topic+pso.nh'></span>

<h3>Description</h3>

<p>Constructs a neighbourhood of each particle using 
particular topology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pso.nh(pop.n = 40, method = "ring", par = 3, iter = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pso.nh_+3A_pop.n">pop.n</code></td>
<td>
<p>integer representing the size of the population.</p>
</td></tr>
<tr><td><code id="pso.nh_+3A_method">method</code></td>
<td>
<p>string representing the topology to be used for construction
of the neighbourhood. See 'Details' for additional information.</p>
</td></tr>
<tr><td><code id="pso.nh_+3A_par">par</code></td>
<td>
<p>additional parameters to be passed depending on the <code>method</code>.</p>
</td></tr>
<tr><td><code id="pso.nh_+3A_iter">iter</code></td>
<td>
<p>iteration number of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>method = "ring"</code> then each particle will have 
<code>par[1]</code> neighbours. By default <code>par[1] = 3</code>.
See section 3.2.1 of M. Clerc (2012) for 
additional details.
If <code>method = "wheel"</code> then there is a single (randomly selected) 
particle which informs (and informed by) other particles while there is 
no direct communication between other particles. 
If <code>method = "random"</code> then each particle randomly informs other
<code>par[1]</code> particles and itself. Note that duplicates are possible so 
sometimes each particle may inform less then <code>par[1]</code> particles. 
By default <code>par[1] = 3</code>.
See section 3.2.2 of M. Clerc (2012) for more details.
If <code>method = "star"</code> then all particles are fully informed
by each other.
If <code>method = "random2"</code> then each particle will be self-informed
and informed by the j-th particle with probability <code>par[1]</code>
(value between 0 and 1). By default <code>par[1] = 0.1</code>.
</p>


<h3>Value</h3>

<p>This function returns a list which i-th element is a vector of
particles' indexes which inform i-th particle i.e. neighbourhood of the
i-th particle.
</p>


<h3>References</h3>

<p>Maurice Clerc (2012). 
Standard Particle Swarm Optimisation.
<em>HAL archieve</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Prepare random number generator
set.seed(123)

# Ring topology with 5 neighbours
pso.nh(pop.n = 10, method = "ring", par = 5)

# Wheel topology
pso.nh(pop.n = 10, method = "wheel")

# Star topology
pso.nh(pop.n = 10, method = "star")

# Random topology where each particle 
# randomly informs 3 other particles
pso.nh(pop.n = 10, method = "random", par = 3)

# Random2 topology wehere each particle could
# be informed by the other with probability 0.2
pso.nh(pop.n = 10, method = "random2", par = 0.2)

</code></pre>

<hr>
<h2 id='pso.velocity'>Velocity</h2><span id='topic+pso.velocity'></span>

<h3>Description</h3>

<p>Calculates (updates) velocities of the particles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pso.velocity(
  population,
  method = "hypersphere",
  par = list(w = 1/(2 * log(2)), c1 = 0.5 + log(2), c2 = 0.5 + log(2)),
  velocity,
  best.pn,
  best.nh,
  best.pn.fitness,
  best.nh.fitness,
  iter = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pso.velocity_+3A_population">population</code></td>
<td>
<p>numeric matrix which rows are particles i.e. vectors of 
parameters values.</p>
</td></tr>
<tr><td><code id="pso.velocity_+3A_method">method</code></td>
<td>
<p>string representing method to be used for velocities 
calculation. See 'Details' for additional information.</p>
</td></tr>
<tr><td><code id="pso.velocity_+3A_par">par</code></td>
<td>
<p>additional parameters to be passed depending on the <code>method</code>.</p>
</td></tr>
<tr><td><code id="pso.velocity_+3A_velocity">velocity</code></td>
<td>
<p>matrix which i-th row is a velocity of the i-th particle.</p>
</td></tr>
<tr><td><code id="pso.velocity_+3A_best.pn">best.pn</code></td>
<td>
<p>numeric matrix which i-th row is a best personal position 
known by the i-th particle.</p>
</td></tr>
<tr><td><code id="pso.velocity_+3A_best.nh">best.nh</code></td>
<td>
<p>numeric matrix which i-th row is a best personal position 
in a neighbourhood of the i-th particle.</p>
</td></tr>
<tr><td><code id="pso.velocity_+3A_best.pn.fitness">best.pn.fitness</code></td>
<td>
<p>numeric vector which i-th row is the value of
a fitness function at point <code>best.pn[i, ]</code>.</p>
</td></tr>
<tr><td><code id="pso.velocity_+3A_best.nh.fitness">best.nh.fitness</code></td>
<td>
<p>numeric vector which i-th row is the value of
a fitness function at point <code>best.nh[i, ]</code>.</p>
</td></tr>
<tr><td><code id="pso.velocity_+3A_iter">iter</code></td>
<td>
<p>iteration number of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>method = "classic"</code> then classical velocity formula
is used:
</p>
<p style="text-align: center;"><code class="reqn">v_{i,j,(t+1)}=w\times v_{i,j,t} + 
                     c_{1}\times u_{1,i,j} \times b^{pn}_{i,j,t} + 
                     c_{2}\times u_{2,i,j} \times b^{nh}_{i,j,t}</code>
</p>

<p>where <code class="reqn">v_{i, j, t}</code> is a velocity of the <code class="reqn">i</code>-th particle 
respect to the <code class="reqn">j</code>-th component at time <code class="reqn">t</code>. Random variables
<code class="reqn">u_{1,i,j}</code> and <code class="reqn">u_{2,i,j}</code> are i.i.d. respect to all indexes and
follow standard uniform distribution <code class="reqn">U(0, 1)</code>. 
Variable <code class="reqn">b^{pn}_{i,j,t}</code> is <code class="reqn">j</code>-th component of the best known
particle's (personal) position up to time period <code class="reqn">t</code>. 
Similarly <code class="reqn">b^{nh}_{i,j,t}</code> is <code class="reqn">j</code>-th component of the best of best 
known particle's position in a neighbourhood of the <code class="reqn">i</code>-th particle.
Hyperparameters <code class="reqn">w</code>, <code class="reqn">c_{1}</code> and <code class="reqn">c_{2}</code> may be provided
via <code>par</code> argument as a list with elements <code>par$w</code>, <code>par$c1</code>
and <code>par$c2</code> correspondingly. 
</p>
<p>If <code>method = "hypersphere"</code> then rotation invariant formula from
sections 3.4.2 and 3.4.3 of M. Clerc (2012) is used with arguments
identical to the classical method. To simulate a random variate from
the hypersphere function <code><a href="#topic+rhypersphere">rhypersphere</a></code> is used
setting <code>type = "non-uniform"</code>.
</p>
<p>In accordance with M. Clerc (2012) 
default values are <code>par$w = 1/(2 * log(2))</code>,
<code>par$c1 = 0.5 + log(2)</code> and <code>par$c2 = 0.5 + log(2)</code>.
</p>


<h3>Value</h3>

<p>This function returns a matrix which i-th row represents
updated velocity of the i-th particle.
</p>


<h3>References</h3>

<p>Maurice Clerc (2012). 
Standard Particle Swarm Optimisation.
<em>HAL archieve</em>.
</p>

<hr>
<h2 id='rhypersphere'>Hypersphere</h2><span id='topic+rhypersphere'></span>

<h3>Description</h3>

<p>Simulates uniform random variates from the hypersphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhypersphere(n, dim = 2, radius = 1, center = rep(0, dim), type = "boundary")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rhypersphere_+3A_n">n</code></td>
<td>
<p>number of observations to simulate.</p>
</td></tr>
<tr><td><code id="rhypersphere_+3A_dim">dim</code></td>
<td>
<p>dimensions of hypersphere.</p>
</td></tr>
<tr><td><code id="rhypersphere_+3A_radius">radius</code></td>
<td>
<p>radius of hypersphere.</p>
</td></tr>
<tr><td><code id="rhypersphere_+3A_center">center</code></td>
<td>
<p>center of hypersphere.</p>
</td></tr>
<tr><td><code id="rhypersphere_+3A_type">type</code></td>
<td>
<p>character; if <code>"boundary"</code> (default) then random variates 
are simulated from the hypersphere. If <code>"inside"</code> random
variates are points lying inside the hypersphere. If <code>"non-uniform"</code> 
then random variates are non-uniform and simulated from the inner part
of the hypersphere simply by making radius a uniform random variable
between <code>0</code> and <code>radius</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a vector of random variates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# Get 5 random uniform variates from 3D hypersphere
# of radius 10 centered at (2, 3, 1)
rhypersphere(n = 5, dim = 3, radius = 10, center = c(2, 3, 1))

</code></pre>

<hr>
<h2 id='summary.gena'>Summarizing gena Fits</h2><span id='topic+summary.gena'></span>

<h3>Description</h3>

<p>Summarizing gena Fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gena'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gena_+3A_object">object</code></td>
<td>
<p>Object of class &quot;gena&quot;</p>
</td></tr>
<tr><td><code id="summary.gena_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the same list as <code><a href="#topic+gena">gena</a></code> 
function changing its class to &quot;summary.gena&quot;.
</p>

<hr>
<h2 id='summary.pso'>Summarizing pso Fits</h2><span id='topic+summary.pso'></span>

<h3>Description</h3>

<p>Summarizing pso Fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pso'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.pso_+3A_object">object</code></td>
<td>
<p>Object of class &quot;pso&quot;</p>
</td></tr>
<tr><td><code id="summary.pso_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the same list as <code><a href="#topic+pso">pso</a></code> 
function changing its class to &quot;summary.pso&quot;.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
