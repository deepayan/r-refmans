<!DOCTYPE html><html lang="en"><head><title>Help for package uniReg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {uniReg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#equiknots'><p>Determine the knot sequence.</p></a></li>
<li><a href='#plot.unireg'><p>Plot method for <code>unireg</code> objects.</p></a></li>
<li><a href='#points.unireg'><p>Points method for <code>unireg</code> objects.</p></a></li>
<li><a href='#predict.unireg'><p>Predict method for <code>unireg</code> objects.</p></a></li>
<li><a href='#print.unireg'><p>Print method for <code>unireg</code> objects.</p></a></li>
<li><a href='#unimat'><p>Create the matrix of unimodality constraints.</p></a></li>
<li><a href='#unireg'><p>Fitting a unimodal penalized spline regression.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Unimodal Penalized Spline Regression using B-Splines</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-06-05</td>
</tr>
<tr>
<td>Author:</td>
<td>Claudia Koellmann</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Claudia Koellmann &lt;koellmann@statistik.tu-dortmund.de&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>DoseFinding, graphics, MASS, parallel, stats, mvtnorm,
quadprog, SEL, splines</td>
</tr>
<tr>
<td>Description:</td>
<td>Univariate spline regression. It is possible to add the shape constraint of unimodality and predefined or
	self-defined penalties on the B-spline coefficients.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-06-05 21:03:32 UTC; koellman</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-06-06 06:39:59</td>
</tr>
</table>
<hr>
<h2 id='equiknots'>Determine the knot sequence.
</h2><span id='topic+equiknots'></span>

<h3>Description</h3>

<p>Determines <em>g+2k+2</em> knots for the spline basis of degree <em>k</em> on the interval <code class="reqn">[a,b]</code>. The <em>g</em> inner knots lie equidistant in <code class="reqn">[a,b]</code>. If <code>coinc=TRUE</code>, the outer knots (<em>k</em> on each side of the interval) are placed coincident with <em>a</em> and <em>b</em>, otherwise the outer knots are also equidistant beyond <code class="reqn">[a,b]</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equiknots(a, b, g, k, coinc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="equiknots_+3A_a">a</code></td>
<td>
<p>Left numeric boundary of the spline interval.
</p>
</td></tr>
<tr><td><code id="equiknots_+3A_b">b</code></td>
<td>
<p>Right numeric boundary of the spline interval.
</p>
</td></tr>
<tr><td><code id="equiknots_+3A_g">g</code></td>
<td>
<p>A non-negative integer giving the number of inner knots.
</p>
</td></tr>
<tr><td><code id="equiknots_+3A_k">k</code></td>
<td>
<p>A non-negative integer specifying the degree of the spline basis.
</p>
</td></tr>
<tr><td><code id="equiknots_+3A_coinc">coinc</code></td>
<td>
<p>Logical indicating, if the outer knots should be coincident with the boundary knots or not. If <code>coinc=TRUE</code>, there are <em>k</em> coincident outer knots at <em>a</em> as well as at <em>b</em>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length <em>g+2k+2</em> with knot locations.
</p>


<h3>Author(s)</h3>

<p>Claudia Koellmann
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unimat">unimat</a></code>, <code><a href="#topic+unireg">unireg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>equiknots(0,5,3,3,TRUE)
equiknots(0,5,3,3,FALSE)
</code></pre>

<hr>
<h2 id='plot.unireg'>Plot method for <code>unireg</code> objects.
</h2><span id='topic+plot.unireg'></span>

<h3>Description</h3>

<p>Plotting a unimodal regression object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'unireg'
plot(x, onlySpline=FALSE, type="l", xlab="x", ylab=NULL, col="black", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.unireg_+3A_x">x</code></td>
<td>
<p>Object of class <code>"unireg"</code>, a result of <code><a href="#topic+unireg">unireg</a></code>.</p>
</td></tr>
<tr><td><code id="plot.unireg_+3A_onlyspline">onlySpline</code></td>
<td>
<p>Logical indicating whether only the fitted spline or also the original data points should be plotted. Defaults to FALSE (plotting both).</p>
</td></tr>
<tr><td><code id="plot.unireg_+3A_type">type</code></td>
<td>
<p>Per default plotting type  <code>"l"</code> is used for the fitted spline.</p>
</td></tr>
<tr><td><code id="plot.unireg_+3A_xlab">xlab</code></td>
<td>
<p>Per default the x-axis is labelled with &quot;x&quot;.</p>
</td></tr>
<tr><td><code id="plot.unireg_+3A_ylab">ylab</code></td>
<td>
<p>If the user does not specify a label for the y-axis, that is when <code>ylab=NULL</code>(default), prespecified labels like &quot;Fitted unimodal spline function&quot; (depending on the constraint) are used.</p>
</td></tr>
<tr><td><code id="plot.unireg_+3A_col">col</code></td>
<td>
<p>Colour of the spline function to be plotted (default: black).</p>
</td></tr>
<tr><td><code id="plot.unireg_+3A_...">...</code></td>
<td>
<p>other parameters to be passed through to the generic <code>plot</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a plot method for unimodal regression objects. The spline function is plotted using a grid of x-values equally spaced across the interval on which the spline is defined. The distance between the grid values is given by the minimal distance of the observed x-values (used for fitting) divided by 10.</p>


<h3>Author(s)</h3>

<p>Claudia Koellmann</p>


<h3>See Also</h3>

<p><code><a href="#topic+unireg">unireg</a></code>,<code><a href="#topic+predict.unireg">predict.unireg</a></code>,<code><a href="#topic+points.unireg">points.unireg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sort(rep(0:5,20))         
n &lt;- length(x)               
set.seed(41333)
func &lt;- function(mu){rnorm(1,mu,0.05)}
y &lt;- sapply(dchisq(x,3),func)

# fit with default settings
fit &lt;- unireg(x, y, g=5)
# short overview of the fitted spline
fit

# plot of fitted spline with and without data
plot(fit, col="orange")
plot(fit, onlySpline=TRUE)
</code></pre>

<hr>
<h2 id='points.unireg'>Points method for <code>unireg</code> objects.
</h2><span id='topic+points.unireg'></span>

<h3>Description</h3>

<p>Plotting a unimodal regression object into an existing plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'unireg'
points(x, type="l", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="points.unireg_+3A_x">x</code></td>
<td>
<p>Object of class <code>"unireg"</code>, a result of <code><a href="#topic+unireg">unireg</a></code>.</p>
</td></tr>
<tr><td><code id="points.unireg_+3A_type">type</code></td>
<td>
<p>Per default plotting type <code>"l"</code> is used for the fitted spline.</p>
</td></tr>
<tr><td><code id="points.unireg_+3A_...">...</code></td>
<td>
<p>other parameters to be passed through to the generic <code>points</code> functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a points method for unimodal regression objects. The spline function is plotted using a grid of x-values equally spaced across the interval on which the spline is defined. The distance between the grid values is given by the minimal distance of the observed x-values (used for fitting) divided by 10.
</p>


<h3>Author(s)</h3>

<p>Claudia Koellmann</p>


<h3>See Also</h3>

<p><code><a href="#topic+unireg">unireg</a></code>,<code><a href="#topic+predict.unireg">predict.unireg</a></code>,<code><a href="#topic+plot.unireg">plot.unireg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sort(rep(0:5,20))         
n &lt;- length(x)               
set.seed(41333)
func &lt;- function(mu){rnorm(1,mu,0.05)}
y &lt;- sapply(dchisq(x,3),func)

# plot of data
plot(jitter(x), y, xlab="x (jittered)")

# fit with default settings
fit &lt;- unireg(x, y, g=5)
# short overview of the fitted spline
fit

# plot of true and fitted functions
plot(jitter(x), y, xlab="x (jittered)")
curve(dchisq(x,3), 0, 5, type="l", col="grey", lwd=2, add=TRUE)
points(fit, lwd=2, col="orange")
legend("bottomright", legend = c("true mean function", 
        "difference penalized unimodal fit"),
    col=c("grey","orange"),lwd=c(2,2))
</code></pre>

<hr>
<h2 id='predict.unireg'>Predict method for <code>unireg</code> objects.
</h2><span id='topic+predict.unireg'></span>

<h3>Description</h3>

<p>Predicted values based on a unimodal regression object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'unireg'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.unireg_+3A_object">object</code></td>
<td>
<p>Object of class <code>'unireg'</code>, a result of <code><a href="#topic+unireg">unireg</a></code>.</p>
</td></tr>
<tr><td><code id="predict.unireg_+3A_newdata">newdata</code></td>
<td>
<p>A numeric vector of values at which to evaluate the fitted spline function.</p>
</td></tr>
<tr><td><code id="predict.unireg_+3A_...">...</code></td>
<td>
<p>Further arguments (currently not used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>predict.unireg</code> produces predicted values by evaluating the fitted regression spline function at the values in <code>newdata</code>.
</p>


<h3>Value</h3>

<p>Returns a numeric vector of predicted function values.
</p>


<h3>Author(s)</h3>

<p>Claudia Koellmann</p>


<h3>See Also</h3>

<p><code><a href="#topic+unireg">unireg</a></code>,<code><a href="#topic+plot.unireg">plot.unireg</a></code>,<code><a href="#topic+points.unireg">points.unireg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sort(rep(0:5,20))         
n &lt;- length(x)               
set.seed(41333)
func &lt;- function(mu){rnorm(1,mu,0.05)}
y &lt;- sapply(dchisq(x,3),func)

# plot of data
plot(jitter(x), y, xlab="x (jittered)")

# fit with default settings
fit &lt;- unireg(x, y, g=5)
# short overview of the fitted spline
fit

# prediction at interim values
predict(fit, c(1.5,2.5,3.5,4.5))
</code></pre>

<hr>
<h2 id='print.unireg'>Print method for <code>unireg</code> objects.
</h2><span id='topic+print.unireg'></span>

<h3>Description</h3>

<p>Prints unimodal regression objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'unireg'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.unireg_+3A_x">x</code></td>
<td>
<p>Object of class <code>'unireg'</code>, a result of function <code><a href="#topic+unireg">unireg</a></code>.</p>
</td></tr>
<tr><td><code id="print.unireg_+3A_...">...</code></td>
<td>
<p>Further arguments (currently not used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints a short overview of a fitted unimodal regression object to the console, namely, the type of the fitted model (including degree of the spline and type of constraint and penalty), the coefficients and their mode location, the tuning parameter and the variance estimate.
</p>


<h3>Value</h3>

<p>Invisibly returns the input <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Claudia Koellmann</p>


<h3>See Also</h3>

<p><code><a href="#topic+unireg">unireg</a></code>,<code><a href="#topic+plot.unireg">plot.unireg</a></code>,<code><a href="#topic+points.unireg">points.unireg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sort(rep(0:5,20))         
n &lt;- length(x)               
set.seed(41333)
func &lt;- function(mu){rnorm(1,mu,0.05)}
y &lt;- sapply(dchisq(x,3),func)

# plot of data
plot(jitter(x), y, xlab="x (jittered)")

# fit with default settings
fit &lt;- unireg(x, y, g=5)
# short overview of the fitted spline
fit
</code></pre>

<hr>
<h2 id='unimat'>Create the matrix of unimodality constraints.
</h2><span id='topic+unimat'></span>

<h3>Description</h3>

<p>Returns a matrix <em>C</em> that can be used to specify linear constraints <code class="reqn">C b \ge 0</code> to impose unimodality with mode at the <em>m</em>-th element on a numeric vector <em>b</em> of length <em>p</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unimat(p, m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unimat_+3A_p">p</code></td>
<td>
<p>Integer (&gt;=2) giving the length of the vector <em>b</em>.
</p>
</td></tr>
<tr><td><code id="unimat_+3A_m">m</code></td>
<td>
<p>Location of the mode within the vector <em>b</em>. Should be in integer between 1 and p.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix <em>C</em> with coefficients for the linear constraints.
</p>


<h3>Author(s)</h3>

<p>Claudia Koellmann
</p>


<h3>See Also</h3>

<p><code><a href="#topic+equiknots">equiknots</a></code>, <code><a href="#topic+unireg">unireg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>unimat(4,2)
unimat(5,3)
</code></pre>

<hr>
<h2 id='unireg'>Fitting a unimodal penalized spline regression.
</h2><span id='topic+unireg'></span>

<h3>Description</h3>

<p>Function for fitting spline regressions to data. The fit can be constrained to be unimodal, inverse-unimodal, isotonic or antitonic and an arbitrary penalty on the B-spline coefficients can be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unireg(x, y, w=NULL, sigmasq=NULL, a=min(x), b=max(x), g=10, k=3,
	constr=c("unimodal","none","invuni","isotonic","antitonic"),
	penalty=c("diff", "none", "sigEmax", "self", "diag"), Om=NULL,
	beta0=NULL, coinc=NULL, tuning=TRUE, abstol=0.01,vari=5,ordpen=2,
	m=1:(g+k+1), allfits=FALSE, nCores=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unireg_+3A_x">x</code></td>
<td>
<p>A numeric vector of <em>x</em>-values, length <em>n</em>. Contains at least <code class="reqn">d=g+k+1 \le n</code> distinct values.</p>
</td></tr>
<tr><td><code id="unireg_+3A_y">y</code></td>
<td>
<p>A numeric vector of observed <em>y</em>-values of length <em>n</em>.</p>
</td></tr>
<tr><td><code id="unireg_+3A_w">w</code></td>
<td>
<p>A positive numeric weight vector of length <em>n</em>. The weights do not have to sum to <em>n</em>, but will be transformed to do so internally. If <code>sigmasq</code> is given, <code>w</code> should be <code>NULL</code> (default).</p>
</td></tr>
<tr><td><code id="unireg_+3A_sigmasq">sigmasq</code></td>
<td>
<p>Estimate(s) of the residual (co-)variance(s). Can be a positive numeric vector of length <em>n</em>, giving estimates for the variance at each of the <em>x</em>-values. If it is a vector of length 1, equal varainces across all <em>x</em>-values are assumed.<br />
If <code>sigmasq=NULL</code>, each <em>x</em>-value has to be appear at least twice and a global variance (same for all <em>x</em>-values) is estimated internally.<br />
If <code>sigmasq</code> is given, <code>w</code> should be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="unireg_+3A_a">a</code></td>
<td>
<p>The left numeric boundary of the interval, on which the spline is defined. If <code>coinc=TRUE</code>, the spline is zero to the left of this value. By default <code>a</code> is equal to the minimal <em>x</em>-value.</p>
</td></tr>
<tr><td><code id="unireg_+3A_b">b</code></td>
<td>
<p>The right numieric boundary of the interval, on which the spline is defined. If <code>coinc=TRUE</code>, the spline is zero to the right of this value. By default <code>b</code> is equal to the maximal <em>x</em>-value.</p>
</td></tr>
<tr><td><code id="unireg_+3A_g">g</code></td>
<td>
<p>A non-negative integer giving the number of inner knots of the spline (default: 10).</p>
</td></tr>
<tr><td><code id="unireg_+3A_k">k</code></td>
<td>
<p>A non-negative integer specifying the degree of the spline. By default a cubic spline (k = 3) is fitted.</p>
</td></tr>
<tr><td><code id="unireg_+3A_constr">constr</code></td>
<td>
<p>A character string specifying the shape constraint for the fit. Can be one of &quot;unimodal&quot; (default), &quot;none&quot;, &quot;invuni&quot; (inverse-unimodal), &quot;isotonic&quot; or &quot;antitonic&quot;.</p>
</td></tr>
<tr><td><code id="unireg_+3A_penalty">penalty</code></td>
<td>
<p>A character string specifying, which penalty on the B-spline coefficients should be used. Possible choices are <code>"diff"</code> (default) for the differences penalty of order <code>ordpen</code>, <code>"none"</code> for no penalty, <code>"sigEmax"</code> for the sigmoid Emax penalty, <code>"self"</code> for a self-defined penalty and <code>"diag"</code> for a ridge penalty.  For a self-defined penalty, <code>Om</code> and <code>beta0</code> have to be provided.</p>
</td></tr>
<tr><td><code id="unireg_+3A_om">Om</code></td>
<td>
<p>If a self-defined penalty on the B-spline coefficients should be used, <code>Om</code> is the penalty matrix of dimension <code class="reqn">d \times d</code> and full rank $d$. Otherwise, <code>Om</code> should be <code>NULL</code> (default).</p>
</td></tr>
<tr><td><code id="unireg_+3A_beta0">beta0</code></td>
<td>
<p>If a self-defined penalty on the B-spline coefficients should be used, <code>beta0</code> is the penalty vector of length <em>d</em>. Otherwise, <code>beta0</code> should be <code>NULL</code> (default).</p>
</td></tr>
<tr><td><code id="unireg_+3A_coinc">coinc</code></td>
<td>
<p>Logical indicating, if the outer knots of the knot sequence should be coincident with the boundary knots or not? Default is <code>NULL</code> and altering has no effect, if a pre-defined penalty is used. If <code>penalty="self"</code>, it has to be specified.</p>
</td></tr>
<tr><td><code id="unireg_+3A_tuning">tuning</code></td>
<td>
<p>Logical indicating, if the tuning parameter lambda should be optimized with (<code>tuning=TRUE</code>, default, computationally expensive) or without (<code>tuning=FALSE</code>) consideration of the shape constraint. Changing <code>tuning</code> has no effect, when <code>constr="none"</code> or <code>penalty="none"</code>.</p>
</td></tr>
<tr><td><code id="unireg_+3A_abstol">abstol</code></td>
<td>
<p>The iterative estimation of the residual variance <code class="reqn">\sigma^2</code> and the coefficient vector stops after iteration <code class="reqn">\varsigma</code>, when <code class="reqn">|\hat{\sigma}^{(\varsigma)} - \hat{\sigma}^{(\varsigma-1)}|</code> is less than a positive numeric value <code>abstol</code> (default: 0.01) or when <code class="reqn">\varsigma=10</code>. If <code>sigmasq</code> is not <code>NULL</code>, the supplied value is used as starting value in this iteration scheme. There is no iterative estimation, if <code>abstol</code> is set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="unireg_+3A_vari">vari</code></td>
<td>
<p>Variance parameter <code class="reqn">sigma_v^2 &gt; 0</code> in the full-rank precision matrix of the prior for beta. By default 5.</p>
</td></tr>
<tr><td><code id="unireg_+3A_ordpen">ordpen</code></td>
<td>
<p>Order of the difference penalty (integer <code class="reqn">\ge 0</code>, default 2). Only effective, if <code>penalty="diff"</code>.</p>
</td></tr>
<tr><td><code id="unireg_+3A_m">m</code></td>
<td>
<p>An integer vector specifying the modes of the coefficient vector which should be used for fitting, in explicit, a subset of <em>{1,...,d}</em>. This argument only has an effect if <code>constr="unimodal"</code> or <code>"invuni"</code>.</p>
</td></tr>
<tr><td><code id="unireg_+3A_allfits">allfits</code></td>
<td>
<p> Logical indicating if the estimated coefficient vectors for all modes in <code>m</code> should be returned (<code>TRUE</code>) or only the one with minimal residual sum of squares (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="unireg_+3A_ncores">nCores</code></td>
<td>
<p>The integer number of cores used for parallelization. If <code>nCores=1</code>, there is no parallelization (default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function combines implementations of the spline methods described in Koellmann et al. Given paired data <code class="reqn">(x_1,y_1),...,(x_n,y_n)</code> it is possible to fit regression splines using the B-spline basis and the maximum likelihood approach. If the spline is unrestricted, the problem reduces to a simple linear regression problem. If the spline is restricted to be unimodal, inverse unimodal, isotonic or antitonic, this leads to a quadratic programming problem. If a penalty is used on the spline coefficients, the tuning parameter is chosen via restricted maximum likelihood (REML).
</p>
<p>The data should contain repeated measurements at certain points on the <em>x</em>-axis (at least 2 for each point), so that a start estimate of the residual variance can be calculated. Then the function iterates between estimation of the spline coefficients and of the variance. Both estimates will be weighted, if weights are given.
If there is only one measurement per <em>x</em>-value, the function expects an input in <code>sigmasq</code>, an estimate of the variance(s) used for weighted estimation (no further weights can be used).
</p>
<p>If no penalty is used, the number of estimable B-spline coefficients, which is <em>d=g+k+1</em>, equals the number of distinct <em>x</em>-values. <em>g</em> and <em>k</em> have to be chosen accordingly.</p>


<h3>Value</h3>

<p>Returns an object of class &quot;unireg&quot;, that is, a list containing the following components: 
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>The (sorted) vector of <em>x</em>-values.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The input vector of <em>y</em>-values (sorted according to <em>x</em>).</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>The vector of weights used for fitting (sorted according to <em>x</em>).</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>The left boundary of the domain [a,b].</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>The right boundary of the domain [a,b].</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>The number <code>g</code> of inner knots.</p>
</td></tr>
<tr><td><code>degree</code></td>
<td>
<p>The degree <code>k</code> of the spline.</p>
</td></tr>
<tr><td><code>knotsequence</code></td>
<td>
<p>The sequence of knots (length <em>g+2k+2</em>) used for spline fitting.</p>
</td></tr>
<tr><td><code>constr</code></td>
<td>
<p>The constraint on the coefficients.</p>
</td></tr>
<tr><td><code>penalty</code></td>
<td>
<p>The type of penalty used.</p>
</td></tr>
<tr><td><code>Om</code></td>
<td>
<p>The penalty matrix.</p>
</td></tr>
<tr><td><code>beta0</code></td>
<td>
<p>The penalty vector.</p>
</td></tr>
<tr><td><code>coinc</code></td>
<td>
<p>The input parameter <code>coinc</code>.</p>
</td></tr>
<tr><td><code>tuning</code></td>
<td>
<p>The input parameter <code>tuning</code>.</p>
</td></tr>
<tr><td><code>abstol</code></td>
<td>
<p>The input value of <code>abstol</code>.</p>
</td></tr>
<tr><td><code>vari</code></td>
<td>
<p>The input variance parameter <code>vari</code>.</p>
</td></tr>
<tr><td><code>ordpen</code></td>
<td>
<p>The order of the difference penalty.</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>The vector of estimated B-spline coefficients (corresponding to the mode with minimal RSS).</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>The fitted values at each <em>x</em>-value (corresponding to the mode with minimal RSS).</p>
</td></tr>
<tr><td><code>lambdaopt</code></td>
<td>
<p>The optimal tuning parameter found via REML (corresponding to the mode with minimal RSS).</p>
</td></tr>
<tr><td><code>sigmasq</code></td>
<td>
<p>The estimated residual variance. If the input for <code>abstol</code> was <code>NULL</code>, <code>sigmasq</code> equals its input value.</p>
</td></tr>
<tr><td><code>variter</code></td>
<td>
<p>The number <code class="reqn">\varsigma</code> of iterations used to estimate the spline coefficients and the variance.</p>
</td></tr>
<tr><td><code>ed</code></td>
<td>
<p>The effective degrees of freedom (corresponding to the mode with minimal RSS).</p>
</td></tr>
<tr><td><code>modes</code></td>
<td>
<p>The input vector <code>m</code> of modes.</p>
</td></tr>
<tr><td><code>allcoefs</code></td>
<td>
<p>A matrix of coefficient vectors (corresponding to the modes specified in <code>m</code>) or <code>NULL</code> (if <code>allfits=FALSE</code>)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Claudia Koellmann</p>


<h3>References</h3>

<p>Koellmann, C., Bornkamp, B., and Ickstadt, K. (2104), <em>Unimodal regression using Bernstein-Schoenberg splines and penalties</em>, Biometrics 70 (4), 783-793.</p>


<h3>See Also</h3>

<p><code><a href="#topic+unimat">unimat</a></code>, <code><a href="#topic+equiknots">equiknots</a></code>, <code><a href="#topic+plot.unireg">plot.unireg</a></code>, <code><a href="#topic+points.unireg">points.unireg</a></code>, <code><a href="#topic+print.unireg">print.unireg</a></code>, <code><a href="#topic+predict.unireg">predict.unireg</a></code>,</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sort(rep(0:5,20))         
n &lt;- length(x)               
set.seed(41333)
func &lt;- function(mu){rnorm(1,mu,0.05)}
y &lt;- sapply(dchisq(x,3),func)

# plot of data
plot(jitter(x), y, xlab="x (jittered)")

# fit with default settings
fit &lt;- unireg(x, y, g=5)
# short overview of the fitted spline
fit

# prediction at interim values
predict(fit, c(1.5,2.5,3.5,4.5))

# fit without penalty (we can use at most g=2 inner knots if k=3)
fit2 &lt;- unireg(x, y, penalty="none", g=2)

# plot of fitted spline with or without data
plot(fit2)
plot(fit2, onlySpline=TRUE)

# fit without penalty and without constraint 
# (does not differ from fit2 with constraint in this case)
fit3 &lt;- unireg(x, y, penalty="none", g=2, constr="none")

# plot of true and fitted functions
plot(jitter(x), y, xlab="x (jittered)")
curve(dchisq(x,3), 0, 5, type="l", col="grey", lwd=2, add=TRUE)
points(fit, lwd=2)
points(fit2, col="blue", lwd=2)
points(fit3, col="red", lwd=2)
legend("bottomright", legend = c("true mean function", 
        "difference penalized unimodal fit", 
        "unpenalized fit (with and without constraint)"),
    col=c("grey","black","red"),lwd=c(2,2,2))

# estimated variance
fit$sigmasq
fit2$sigmasq

## Not run: 
# fit with isotonic, antitonic and inverse-unimodal constraint (just for completeness)
fit4 &lt;- unireg(x,y,constr="antitonic",g=5)
fit5 &lt;- unireg(x,y,constr="isotonic",g=5)
fit6 &lt;- unireg(x,y,constr="invuni",g=5)

points(fit4,col="orange",lwd=2)
points(fit5,col="brown",lwd=2)
points(fit6,col="yellow",lwd=2)

# suppose only aggregated data had been given
means &lt;- c(mean(y[1:20]), mean(y[21:40]), mean(y[41:60]), mean(y[61:80]), 
           mean(y[81:100]), mean(y[101:120]))
sigmasq &lt;- c(sd(y[1:20]),sd(y[21:40]),sd(y[41:60]),sd(y[61:80]),sd(y[81:100]),sd(y[101:120]))^2

# unimodal fit with differences penalty
fit7 &lt;- unireg(x=unique(x), y=means, g=5, w=NULL, sigmasq=sigmasq, abstol=NULL)
plot(unique(x), means, pch=19, ylim=range(y))
curve(dchisq(x,3), 0, 5, type="l", col="grey", lwd=2, add=TRUE)
points(fit7, type="l", col="green", lwd=2)
legend("bottomright", legend = c("true mean function", "observed mean values", 
    "diff. penalized unimodal fit for means"),
  col=c("grey","black","green"), lty=c(1,NA,1), lwd=c(2,0,2), pch=c(NA,19,NA))

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
