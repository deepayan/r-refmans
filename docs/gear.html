<!DOCTYPE html><html><head><title>Help for package gear</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gear}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#angle2d'><p>Determine angle</p></a></li>
<li><a href='#autoplot.evgram'><p>Plot <code>evgram</code> object</p></a></li>
<li><a href='#cmod_man'><p>Manual covariance models for geostatistical data.</p></a></li>
<li><a href='#cmod_std'><p>Standard covariance models for geostatistical data.</p></a></li>
<li><a href='#cmod.man'><p>Standard covariance models for geostatistical data.</p></a></li>
<li><a href='#cmod.std'><p>Standard covariance models for geostatistical data.</p></a></li>
<li><a href='#co'><p>Geochemical measurements for 960 sites in</p>
Colorado.</a></li>
<li><a href='#decomp_cov'><p>Decompose covariance matrix</p></a></li>
<li><a href='#estimate'><p>Estimate model parameters</p></a></li>
<li><a href='#estimate.geolm_cmodStd'><p>Determine MLEs of model parameters for a geostatistical</p>
model</a></li>
<li><a href='#eval.cmod'><p>Evaluate covariance or semivariance model.</p></a></li>
<li><a href='#evaluate.cmodStd'><p>Evaluate spatial dependence model</p></a></li>
<li><a href='#evgram'><p>Empirical (semi-)variogram</p></a></li>
<li><a href='#fitted.geolm'><p>Extract fitted values from a <code>geolm</code> object</p></a></li>
<li><a href='#ganiso_d'><p>Anisotropic distance-related characteristics</p></a></li>
<li><a href='#gear'><p>gear</p></a></li>
<li><a href='#geardf'><p>Construct a <code>geardf</code></p></a></li>
<li><a href='#geodist'><p>Compute distance for geographic coordinates</p></a></li>
<li><a href='#geolm'><p>Linear model for geostatistical data.</p></a></li>
<li><a href='#geolm_fit'><p>Fit a <code>geolm</code></p></a></li>
<li><a href='#mle'><p>Finds maximum likelihood estimates of model parameters</p>
for a geostatistical model</a></li>
<li><a href='#omni_semivariogram'><p>Compute an omnidirectional empirical semivariogram</p></a></li>
<li><a href='#ploglik_xycholv'><p>Compute the log-likelihood of a model</p></a></li>
<li><a href='#plot.evgram'><p>Plot <code>evgram</code> object</p></a></li>
<li><a href='#plot.geardf'><p>Plot <code>geardf</code> object</p></a></li>
<li><a href='#predict.geolm_cmodMan'><p>Predict method for geostatistical models</p></a></li>
<li><a href='#predict.geolm_cmodStd'><p>Predict method for geostatistical models</p></a></li>
<li><a href='#print.evgram'><p>Print <code>evgram</code> object</p></a></li>
<li><a href='#residuals.geolm'><p>Extract residuals from a <code>geolm</code> object</p></a></li>
<li><a href='#solve_chol'><p>Solve using cholesky decomposition</p></a></li>
<li><a href='#toydata'><p>A toy data set for examples</p></a></li>
<li><a href='#update.geolm'><p>Update linear model for geostatistical data</p></a></li>
<li><a href='#vgram'><p>Empirical variogram</p></a></li>
<li><a href='#xyplot.evgram'><p>Plot <code>evgram</code> object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Geostatistical Analysis in R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-04-06</td>
</tr>
<tr>
<td>Author:</td>
<td>Joshua French</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joshua French &lt;joshua.french@ucdenver.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements common geostatistical methods in a clean, straightforward, efficient manner. The methods are discussed in Schabenberger and Gotway (2004, &lt;ISBN:9781584883227&gt;) and Waller and Gotway (2004, &lt;ISBN:9780471387718&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>autoimage, stats, optimx, Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sp, sf, testthat, Matrix, geoR, gstat, spam, ggplot2, lattice</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-04-06 17:36:50 UTC; joshu</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-04-10 21:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='angle2d'>Determine angle</h2><span id='topic+angle2d'></span>

<h3>Description</h3>

<p><code>angle2d</code> determines the angle between pairs of
coordinates in degrees or radians.  The coordinates are
assumed to be in two-dimensional space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angle2d(coords1, coords2, radians = FALSE, invert = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angle2d_+3A_coords1">coords1</code></td>
<td>
<p>An <code class="reqn">N \times 2</code> matrix of spatial
coordinates.</p>
</td></tr>
<tr><td><code id="angle2d_+3A_coords2">coords2</code></td>
<td>
<p>An <code class="reqn">N \times 2</code> matrix of spatial
coordinates.</p>
</td></tr>
<tr><td><code id="angle2d_+3A_radians">radians</code></td>
<td>
<p>A logical value indicating whether the
angles returned should be in degrees or radians.  The
default is <code>FALSE</code>, indicating that the returned
angles are in degrees.</p>
</td></tr>
<tr><td><code id="angle2d_+3A_invert">invert</code></td>
<td>
<p>A logical value indicating whether the axes
of the coordinates should be inverted (i.e., the x- and
y-axis are switched). The default is <code>TRUE</code> to
mimic results from other geostatistical R packages like
<code>gstat</code>, <code>geoR</code>, and other software like
<code>GSLIB</code> and <code>GeoEAS</code>. Set to <code>FALSE</code> to
use the typical x- and y-axes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the angle is between the actual pairs of
points, not the angle between the vectors extending from
the origin to the points.  e.g., the angle between (0, 1)
and (1, 1) is 90 degrees, not 45. The sign of the
direction not accounted for, e.g., a -135 degree angle is
rotated by 180 degrees to become a 45 degree angle.  All
angles returned are in the interval [0, 180].
</p>


<h3>Value</h3>

<p>Returns a vector of angles.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coords1 = matrix(0, nrow = 8, ncol = 2)
coords2 = cbind(c(2, 2, 0, -2, -2, -2, 0, 2), c(0, 2, 2, 2, 0, -2, -2, -2))
angle2d(coords1, coords2)
angle2d(coords1, coords2, radians = TRUE)
</code></pre>

<hr>
<h2 id='autoplot.evgram'>Plot <code>evgram</code> object</h2><span id='topic+autoplot.evgram'></span>

<h3>Description</h3>

<p>Plot an <code>evgram</code> object produced by the
<code><a href="#topic+evgram">evgram</a></code> function. The plotting
function internally calls the
<code><a href="ggplot2.html#topic+autoplot">autoplot</a></code> function. Note: the
<code>ggplot2</code> package must be loaded (i.e.,
<code>library(autplot)</code> or <code>ggplot2::autoplot</code>
must be specifically called for this function to work.
See Examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoplot.evgram(object, ..., split = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.evgram_+3A_object">object</code></td>
<td>
<p>An <code>evgram</code> object produced by the
<code><a href="#topic+evgram">evgram</a></code> function.</p>
</td></tr>
<tr><td><code id="autoplot.evgram_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="autoplot.evgram_+3A_split">split</code></td>
<td>
<p>A logical value indicating whether, for a
directional semivariogram, the directional
semivariograms should be displayed in a single or split
panels.  Default is <code>FALSE</code>, for a single panel.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(co)
v = evgram(Al ~ 1, co, ~ easting + northing)
if (requireNamespace("ggplot2")) {
   ggplot2::autoplot(v)
}
v2 = evgram(Al ~ 1, co, ~ easting + northing, angle = 22.5, ndir = 4)
# ggplot2 must manually be loaded for this to work
if (requireNamespace("ggplot2")) {
   ggplot2::autoplot(v2)
   ggplot2::autoplot(v2, split = TRUE)
}
</code></pre>

<hr>
<h2 id='cmod_man'>Manual covariance models for geostatistical data.</h2><span id='topic+cmod_man'></span>

<h3>Description</h3>

<p><code>cmod_man</code> manually creates a covariance model
object (<code>cmodMan</code>) for geostatistical data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmod_man(v, evar = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmod_man_+3A_v">v</code></td>
<td>
<p>The covariance matrix of the observed data,
including any errors.  The matrix should be square,
symmetric, and positive definite, though that latter
two conditions are not checked.</p>
</td></tr>
<tr><td><code id="cmod_man_+3A_evar">evar</code></td>
<td>
<p>The variance of the errors.  Must be
non-negative number.  The default is 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>v</code> includes the error variance, i.e.,
<code>v = vz + ve</code>, where <code>vz</code> is the covariance
matrix of the filtered process and the variance matrix
of the errors is <code>ve = diag(evar/weights)</code>, where
the <code>weights</code> come from the <code>geolm</code> object the
<code>cmodMan</code> object is associated with.
</p>


<h3>Value</h3>

<p>Returns a <code>cmodMan</code> object.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coords = matrix(runif(6), ncol = 2)
d = as.matrix(dist(coords))
cmod_man(v = exp(-d), evar = 1)
</code></pre>

<hr>
<h2 id='cmod_std'>Standard covariance models for geostatistical data.</h2><span id='topic+cmod_std'></span>

<h3>Description</h3>

<p>Creates a standard covariance model (<code>cmodStd</code>)
object for geostatistical data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmod_std(
  model,
  psill,
  r,
  evar = 0,
  fvar = 0,
  par3 = 0.5,
  longlat = FALSE,
  angle = 0,
  ratio = 1,
  radians = FALSE,
  invert = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmod_std_+3A_model">model</code></td>
<td>
<p>A covariance model (e.g.,
<code>"exponential"</code>). See Details for the complete
list of choices.</p>
</td></tr>
<tr><td><code id="cmod_std_+3A_psill">psill</code></td>
<td>
<p>The partial sill of the model.  Must be a
positive number.</p>
</td></tr>
<tr><td><code id="cmod_std_+3A_r">r</code></td>
<td>
<p>The range parameter <code>r</code>.  Must be a
positive number.</p>
</td></tr>
<tr><td><code id="cmod_std_+3A_evar">evar</code></td>
<td>
<p>The variance of the errors.  Must be
non-negative number.  The default is 0.</p>
</td></tr>
<tr><td><code id="cmod_std_+3A_fvar">fvar</code></td>
<td>
<p>The finescale variance (microscale error).
Must be a non-negative number.  The default is 0.</p>
</td></tr>
<tr><td><code id="cmod_std_+3A_par3">par3</code></td>
<td>
<p>The value of the third parameter for 3
parameter models.  Must be a positive number.  The
default is 0.5.</p>
</td></tr>
<tr><td><code id="cmod_std_+3A_longlat">longlat</code></td>
<td>
<p>A logical value indicating whether great
circle distance should be used. The default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cmod_std_+3A_angle">angle</code></td>
<td>
<p>The major axis of geometric anisotropy (the
direction of strongest spatial dependence). Must be
between [0, 180) if <code>radians = FALSE</code>, otherwise
it must be between [0, <code class="reqn">\pi</code>).</p>
</td></tr>
<tr><td><code id="cmod_std_+3A_ratio">ratio</code></td>
<td>
<p>The ratio of the minor axis range over the
major axis range. The value must be between (0, 1].</p>
</td></tr>
<tr><td><code id="cmod_std_+3A_radians">radians</code></td>
<td>
<p>A logical value indicating whether the
angles returned should be in degrees or radians.  The
default is <code>FALSE</code>, indicating that the returned
angles are in degrees.</p>
</td></tr>
<tr><td><code id="cmod_std_+3A_invert">invert</code></td>
<td>
<p>A logical value indicating whether the axes
of the coordinates should be inverted (i.e., the x- and
y-axis are switched). The default is <code>TRUE</code> to
mimic results from other geostatistical R packages like
<code>gstat</code>, <code>geoR</code>, and other software like
<code>GSLIB</code> and <code>GeoEAS</code>. Set to <code>FALSE</code> to
use the typical x- and y-axes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The general, isotropic form of the specified covariance function is
<code>psill</code> * <code class="reqn">\rho</code>(<code>d</code>; <code>r</code>) +
(<code>evar</code> + <code>fvar</code>) * (<code>d == 0</code>), where
<code class="reqn">\rho</code> is the correlation function of the parametric
models and <code>d</code> is the distance between the
relevant coordinates.
</p>
<p>For the <code>exponential</code> model, <code class="reqn">\rho</code>(<code>d</code>;
<code>r</code>) is exp(-<code>d</code>/<code>r</code>).
</p>
<p>For the <code>gaussian</code> model, <code class="reqn">\rho</code>(<code>d</code>;
<code>r</code>) is exp(-<code>d^2</code>/<code>r^2</code>).
</p>
<p>For the <code>matern</code> model, <code class="reqn">\rho</code>(<code>d</code>;
<code>r</code>) is
2^(1-<code>par3</code>)/<code>gamma</code>(<code>par3</code>)*<code>sd</code>^<code>par3</code>*<code>besselK(sd,
nu = par3)</code>, where <code>sd = d/r</code>.
</p>
<p>For the <code>amatern</code> (alternative Matern) model,
<code class="reqn">\rho</code>(<code>d</code>; <code>r</code>) is
<code>2^(1-par3)/gamma(par3)*sd^par3*besselK(sd, nu =
par3)</code>, where <code>sd = 2 * sqrt(par3) * d/r</code>.
</p>
<p>For the <code>spherical</code> model, <code class="reqn">\rho</code>(<code>d</code>;
<code>r</code>) is <code>1 - 1.5*sd + 0.5*(sd)^3</code> if <code>d &lt;
r</code>, and 0 otherwise, with <code>sd = d/r</code>.
</p>
<p>For the <code>wendland1</code> model, <code class="reqn">\rho</code>(<code>d</code>;
<code>r</code>) is <code>(1 - sd)^4 * (4*sd + 1)</code> if <code>d &lt;
r</code>, and 0 otherwise, with <code>sd = d/r</code>.
</p>
<p>For the <code>wendland2</code> model, <code class="reqn">\rho</code>(<code>d</code>;
<code>r</code>) is <code>(1 - sd)^6 * (35*sd^2 + 18*sd + 3))/3</code>
if <code>d &lt; r</code>, and 0 otherwise, with <code>sd = d/r</code>.
</p>
<p>For the <code>wu1</code> model, <code class="reqn">\rho</code>(<code>d</code>; <code>r</code>)
is <code>(1 - sd)^3 * (1 + 3*sd + sd^2)</code> if <code>d &lt; r</code>,
and 0 otherwise, with <code>sd = d/r</code>.
</p>
<p>For the <code>wu2</code> model, <code class="reqn">\rho</code>(<code>d</code>; <code>r</code>)
is <code>(1 - sd)^4*(4 + 16*sd + 12*sd^2 + 3*sd^3))/4</code> if
<code>d &lt; r</code>, and 0 otherwise, with <code>sd = d/r</code>.
</p>
<p>For the <code>wu3</code> model, <code class="reqn">\rho</code>(<code>d</code>; <code>r</code>)
is <code>(1 - sd)^6 * (1 + 6*sd + 41/3*sd^2 + 12*sd^3 +
5*sd^4 + 5/6*sd^5)</code> if <code>d &lt; r</code>, and 0 otherwise,
with <code>sd = d/r</code>.
</p>


<h3>Value</h3>

<p>Returns a <code>cmodStd</code> object.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Waller, L. A., &amp; Gotway, C. A. (2004).
Applied Spatial Statistics for Public Health Data. John
Wiley &amp; Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cmod_std(model = "exponential", psill = 1, r = 1)
</code></pre>

<hr>
<h2 id='cmod.man'>Standard covariance models for geostatistical data.</h2><span id='topic+cmod.man'></span>

<h3>Description</h3>

<p><code>cmod.man</code> manually creates a covariance matrix
object (<code>cmodMan</code>) for geostatistical data. This
function will be deprecated in the future. Please update
your code to use the <code><a href="#topic+cmod_man">cmod_man</a></code>
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmod.man(v, evar = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmod.man_+3A_v">v</code></td>
<td>
<p>The covariance matrix of the observed data,
including any errors.  The matrix should be square,
symmetric, and positive definite, though that latter
two conditions are not checked.</p>
</td></tr>
<tr><td><code id="cmod.man_+3A_evar">evar</code></td>
<td>
<p>The variance of the errors.  Must be
non-negative number.  The default is 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>v</code> includes the error variance, i.e.,
<code>v = vz + ve</code>, where <code>vz</code> is the covariance
matrix of the filtered process and the variance matrix
of the errors is <code>ve = diag(evar/weights)</code>, where
the <code>weights</code> come from the <code>geolm</code> object the
<code>cmodMan</code> object is associated with.
</p>


<h3>Value</h3>

<p>Returns a <code>cmodMan</code> object.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coords = matrix(runif(20), ncol = 2)
d = as.matrix(dist(coords))
cmod.man(v = exp(-d), evar = 1)
</code></pre>

<hr>
<h2 id='cmod.std'>Standard covariance models for geostatistical data.</h2><span id='topic+cmod.std'></span>

<h3>Description</h3>

<p>Creates a standard covariance model (<code>cmodStd</code>)
object for geostatistical data. This function will be
deprecated in the future. Please update your code to use
the <code><a href="#topic+cmod_std">cmod_std</a></code> function, which also
allows the user to specify geometric anisotropy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmod.std(model, psill, r, evar = 0, fvar = 0, par3 = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmod.std_+3A_model">model</code></td>
<td>
<p>A covariance model (e.g.,
<code>"exponential"</code>). See Details for the complete
list of choices.</p>
</td></tr>
<tr><td><code id="cmod.std_+3A_psill">psill</code></td>
<td>
<p>The partial sill of the model.  Must be a
positive number.</p>
</td></tr>
<tr><td><code id="cmod.std_+3A_r">r</code></td>
<td>
<p>The range parameter <code>r</code>.  Must be a
positive number.</p>
</td></tr>
<tr><td><code id="cmod.std_+3A_evar">evar</code></td>
<td>
<p>The variance of the errors.  Must be
non-negative number.  The default is 0.</p>
</td></tr>
<tr><td><code id="cmod.std_+3A_fvar">fvar</code></td>
<td>
<p>The finescale variance (microscale error).
Must be a non-negative number.  The default is 0.</p>
</td></tr>
<tr><td><code id="cmod.std_+3A_par3">par3</code></td>
<td>
<p>The value of the third parameter for 3
parameter models.  Must be a positive number.  The
default is 0.5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The general form of the specified covariance function is
<code>psill</code> * <code class="reqn">\rho</code>(<code>d</code>; <code>r</code>) +
(<code>evar</code> + <code>fvar</code>)*(<code>d==0</code>), where
<code class="reqn">\rho</code> is the covariance function of the parametric
models.
</p>
<p>For the <code>exponential</code> model, <code class="reqn">\rho</code>(<code>d</code>;
<code>r</code>) is exp(-<code>d</code>/<code>r</code>).
</p>
<p>For the <code>gaussian</code> model, <code class="reqn">\rho</code>(<code>d</code>;
<code>r</code>) is exp(-<code>d^2</code>/<code>r^2</code>).
</p>
<p>For the <code>matern</code> model, <code class="reqn">\rho</code>(<code>d</code>;
<code>r</code>) is
2^(1-<code>par3</code>)/<code>gamma</code>(<code>par3</code>)*<code>sd</code>^<code>par3</code>*<code>besselK(sd,
nu = par3)</code>, where <code>sd = d/r</code>.
</p>
<p>For the <code>amatern</code> (alternative Matern) model,
<code class="reqn">\rho</code>(<code>d</code>; <code>r</code>) is
<code>2^(1-par3)/gamma(par3)*sd^par3*besselK(sd, nu =
par3)</code>, where <code>sd = 2 * sqrt(par3) * d/r</code>.
</p>
<p>For the <code>spherical</code> model, <code class="reqn">\rho</code>(<code>d</code>;
<code>r</code>) is <code>1 - 1.5*sd + 0.5*(sd)^3</code> if <code>d &lt;
r</code>, and 0 otherwise, with <code>sd = d/r</code>.
</p>
<p>For the <code>wendland1</code> model, <code class="reqn">\rho</code>(<code>d</code>;
<code>r</code>) is <code>(1 - sd)^4 * (4*sd + 1)</code> if <code>d &lt;
r</code>, and 0 otherwise, with <code>sd = d/r</code>.
</p>
<p>For the <code>wendland2</code> model, <code class="reqn">\rho</code>(<code>d</code>;
<code>r</code>) is <code>(1 - sd)^6 * (35*sd^2 + 18*sd + 3))/3</code>
if <code>d &lt; r</code>, and 0 otherwise, with <code>sd = d/r</code>.
</p>
<p>For the <code>wu1</code> model, <code class="reqn">\rho</code>(<code>d</code>; <code>r</code>)
is <code>(1 - sd)^3 * (1 + 3*sd + sd^2)</code> if <code>d &lt; r</code>,
and 0 otherwise, with <code>sd = d/r</code>.
</p>
<p>For the <code>wu2</code> model, <code class="reqn">\rho</code>(<code>d</code>; <code>r</code>)
is <code>(1 - sd)^4*(4 + 16*sd + 12*sd^2 + 3*sd^3))/4</code> if
<code>d &lt; r</code>, and 0 otherwise, with <code>sd = d/r</code>.
</p>
<p>For the <code>wu3</code> model, <code class="reqn">\rho</code>(<code>d</code>; <code>r</code>)
is <code>(1 - sd)^6 * (1 + 6*sd + 41/3*sd^2 + 12*sd^3 +
5*sd^4 + 5/6*sd^5)</code> if <code>d &lt; r</code>, and 0 otherwise,
with <code>sd = d/r</code>.
</p>


<h3>Value</h3>

<p>Returns a <code>cmodStd</code> object.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Waller, L. A., &amp; Gotway, C. A. (2004).
Applied Spatial Statistics for Public Health Data. John
Wiley &amp; Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cmod.std(model = "exponential", psill = 1, r = 1)
</code></pre>

<hr>
<h2 id='co'>Geochemical measurements for 960 sites in
Colorado.</h2><span id='topic+co'></span>

<h3>Description</h3>

<p>These data were collected by the United
States Geological Survey (USGS).  Their description is
as follows:  In 2006, soil samples were collected at
960 sites (1 site per 280 square kilometers) throughout
the state of Colorado. These samples were collected
from a depth of 0 to 15 centimeters and, following a
near-total multi-acid digestion, were analyzed for a
suite of more than 40 major and trace elements. The
resulting data set provides a baseline for the natural
variation in soil geochemistry for Colorado and forms
the basis for detecting changes in soil composition
that might result from natural processes or
anthropogenic activities.
</p>
<p>Latitude and Longitude determined by hand-held GPS
instrument using WGS84 datum.  The longitude and latitude
coordinates were converted to UTM coordinates using the
following commands:
</p>
<p><code>library(sp)</code>
</p>
<p><code>lonlat = co[, c("longitude", "latitude")]</code>
</p>
<p><code>coordinates(lonlat) = c("longitude", "latitude")</code>
</p>
<p><code>proj4string(lonlat) = CRS("+proj=longlat +datum=WGS84")</code>
</p>
<p><code>xy = spTransform(lonlat, CRS("+proj=utm +zone=13 ellps=WGS84"))</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(co)
</code></pre>


<h3>Format</h3>

<p>A data frame with 960 rows and 31 columns:
</p>

<dl>
<dt>easting</dt><dd><p>Easting (m)</p>
</dd>
<dt>northing</dt><dd><p>Northing (m)</p>
</dd>
<dt>latitude</dt><dd><p>The latitude of the site.</p>
</dd>
<dt>longitude</dt><dd><p>The longitude of the site.</p>
</dd>
<dt>Al</dt><dd><p>aluminum (percent)</p>
</dd>
<dt>Ca</dt><dd><p>calcium (percent)</p>
</dd>
<dt>Fe</dt><dd><p>iron (percent)</p>
</dd>
<dt>K</dt><dd><p>potassium (percent)</p>
</dd>
<dt>Mg</dt><dd><p>magnesium (percent)</p>
</dd>
<dt>Na</dt><dd><p>sodium (percent)</p>
</dd>
<dt>Ti</dt><dd><p>titanium (percent)</p>
</dd>
<dt>Be</dt><dd><p>beryllium (mg/kg)</p>
</dd>
<dt>Ce</dt><dd><p>cerium (mg/kg)</p>
</dd>
<dt>Co</dt><dd><p>cobalt (mg/kg)</p>
</dd>
<dt>Cr</dt><dd><p>chromium (mg/kg)</p>
</dd>
<dt>Cu</dt><dd><p>copper (mg/kg)</p>
</dd>
<dt>Ga</dt><dd><p>gallium (mg/kg)</p>
</dd>
<dt>La</dt><dd><p>lanthanum (mg/kg)</p>
</dd>
<dt>Li</dt><dd><p>lithium (mg/kg)</p>
</dd>
<dt>Mo</dt><dd><p>manganese (mg/kg)</p>
</dd>
<dt>Nb</dt><dd><p>molybdenum (mg/kg)</p>
</dd>
<dt>Ni</dt><dd><p>niobium (mg/kg)</p>
</dd>
<dt>Rb</dt><dd><p>rubidium (mg/kg)</p>
</dd>
<dt>Sc</dt><dd><p>scandium (mg/kg)</p>
</dd>
<dt>Sn</dt><dd><p>tin (mg/kg)</p>
</dd>
<dt>Th</dt><dd><p>thorium (mg/kg)</p>
</dd>
<dt>Tl</dt><dd><p>thallium (mg/kg)</p>
</dd>
<dt>U</dt><dd><p>uranium (mg/kg)</p>
</dd>
<dt>V</dt><dd><p>vanadium (mg/kg)</p>
</dd>
<dt>W</dt><dd><p>tungsten (mg/kg)</p>
</dd>
<dt>Y</dt><dd><p>yttrium (mg/kg)</p>
</dd>
</dl>



<h3>Source</h3>

<p>U.S. Geological Survey, Data Series 520, 9 p.  <a href="http://pubs.usgs.gov/ds/520/">http://pubs.usgs.gov/ds/520/</a>.
</p>


<h3>References</h3>

<p>Smith, D.B., Ellefsen, K.J., and Kilburn, J.E., 2010, Geochemical data for Colorado soils &ndash; Results from the 2006 state-scale geochemical survey: U.S. Geological Survey, Data Series 520, 9p.
</p>

<hr>
<h2 id='decomp_cov'>Decompose covariance matrix</h2><span id='topic+decomp_cov'></span><span id='topic+decomp.cov'></span>

<h3>Description</h3>

<p><code>decomp_cov</code> decomposes a covariance matrix
<code>v</code>.  If <code>A = decomp_cov(v)</code>, then
<code>tcrossprod(A, A) == v</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decomp_cov(v, method = "eigen")

decomp.cov(v, method = "eigen")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decomp_cov_+3A_v">v</code></td>
<td>
<p>An <code class="reqn">N \times N</code> covariance matrix.</p>
</td></tr>
<tr><td><code id="decomp_cov_+3A_method">method</code></td>
<td>
<p>The method used to decompose <code>v</code>.
Valid options are <code>"chol"</code>, <code>"eigen"</code>, or
<code>"svd"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>"chol"</code> method is the fastest but least
stable method.  The <code>"eigen"</code> method is slower, but more
stable.  The <code>"svd"</code> method is the slowest method,
but should be the most stable.
</p>


<h3>Value</h3>

<p>Returns an <code class="reqn">N \times N</code> matrix.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate data
n = 100
coords = matrix(runif(n*2), nrow = n, ncol = 2)
d = as.matrix(dist(coords))
# create covariance matrix
v = 3 * exp(-d/2) + 0.1 * diag(n)

# decompose v using the three methods
d1 = decomp_cov(v, "chol")
d2 = decomp_cov(v, "eigen")
d3 = decomp_cov(v, "svd")

# verify accuracy of decompositions
all.equal(v, tcrossprod(d1))
all.equal(v, tcrossprod(d2), check.attributes = FALSE)
all.equal(v, tcrossprod(d3), check.attributes = FALSE)
</code></pre>

<hr>
<h2 id='estimate'>Estimate model parameters</h2><span id='topic+estimate'></span>

<h3>Description</h3>

<p><code>estimate</code> estimates the parameters of the specified
model. The function is written to automatically adapt
based on the class of <code>object</code>.  Currently, the
<code>estimate</code> function performs maximum likelihood
estimation for objects produced by the
<code><a href="#topic+geolm">geolm</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_+3A_object">object</code></td>
<td>
<p>A model object produced by the
<code><a href="#topic+geolm">geolm</a></code> function.</p>
</td></tr>
<tr><td><code id="estimate_+3A_...">...</code></td>
<td>
<p>Currently unimplemented</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate.geolm_cmodStd">estimate.geolm_cmodStd</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
n = 100
</code></pre>

<hr>
<h2 id='estimate.geolm_cmodStd'>Determine MLEs of model parameters for a geostatistical
model</h2><span id='topic+estimate.geolm_cmodStd'></span>

<h3>Description</h3>

<p><code>estimate</code> estimates the parameters of a
geostatistical linear model of class <code>geolm_cmodStd</code>
using maximum likelihood estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geolm_cmodStd'
estimate(
  object,
  reml = FALSE,
  noise_type = "e",
  lower = NULL,
  upper = NULL,
  method = "nlminb",
  itnmax = NULL,
  control = list(),
  est_nugget = TRUE,
  est_par3 = TRUE,
  est_angle = FALSE,
  est_ratio = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate.geolm_cmodStd_+3A_object">object</code></td>
<td>
<p>A geostatistical linear model object
produced by the <code>geolm</code> function.</p>
</td></tr>
<tr><td><code id="estimate.geolm_cmodStd_+3A_reml">reml</code></td>
<td>
<p>A logical value indicating whether standard
maximum likelihood estimation should be performed
(<code>reml = FALSE</code>).  If <code>reml = TRUE</code>, then
restricted maximum likelihood estimation is performed.  The
default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="estimate.geolm_cmodStd_+3A_noise_type">noise_type</code></td>
<td>
<p>A character vector indicating the type
of noise (nugget) variance to estimate. The default is
<code>est = "e"</code>, indicating the error variance should
be estimated. Alternatively, the user can specify
<code>est = "f"</code>, indicating that the finescale (microscale)
variance should be estimated. The other type of noise
variance is set to 0, otherwise the model is not
identifiable. See Details.</p>
</td></tr>
<tr><td><code id="estimate.geolm_cmodStd_+3A_lower">lower</code></td>
<td>
<p>A named list with the names of the
parameters you wish to set lower bounds for and the
associated value. See Details.</p>
</td></tr>
<tr><td><code id="estimate.geolm_cmodStd_+3A_upper">upper</code></td>
<td>
<p>A named list with the names of the
parameters you wish to set upper bounds for and the
associated value.</p>
</td></tr>
<tr><td><code id="estimate.geolm_cmodStd_+3A_method">method</code></td>
<td>
<p>The optimization method.  The default is
<code>"nlminb"</code>. <code>"L-BFGS-B"</code> is another
acceptable choice.  See <code><a href="optimx.html#topic+optimx">optimx</a></code>
for further choices.</p>
</td></tr>
<tr><td><code id="estimate.geolm_cmodStd_+3A_itnmax">itnmax</code></td>
<td>
<p>An integer indicating the maximum number of
iterations to allow for the optimization procedure.</p>
</td></tr>
<tr><td><code id="estimate.geolm_cmodStd_+3A_control">control</code></td>
<td>
<p>A list of control parameters passed
internally to <code><a href="optimx.html#topic+optimx">optimx</a></code>.</p>
</td></tr>
<tr><td><code id="estimate.geolm_cmodStd_+3A_est_nugget">est_nugget</code></td>
<td>
<p>A logical value indicating whether the
nugget variance (<code>evar</code> or <code>fvar</code>) should be
estimated. The default is <code>TRUE</code>, indicating that
the nugget should be estimated.</p>
</td></tr>
<tr><td><code id="estimate.geolm_cmodStd_+3A_est_par3">est_par3</code></td>
<td>
<p>A logical value indicating whether
<code>par3</code> should be estimated (for an appropriate
covariance model such as <code>"matern"</code> or
<code>"amatern"</code>). The default is <code>TRUE</code>,
indicating that this parameter should be estimated.</p>
</td></tr>
<tr><td><code id="estimate.geolm_cmodStd_+3A_est_angle">est_angle</code></td>
<td>
<p>A logical value indicating whether the
geometric anisotropy angle should be estimated. The
default is <code>FALSE</code>, indicating that this parameter
should not be estimated.</p>
</td></tr>
<tr><td><code id="estimate.geolm_cmodStd_+3A_est_ratio">est_ratio</code></td>
<td>
<p>A logical value indicating whether the
geometric anisotropy ratio of minor axis length to
major axis length should be estimated. The default is
<code>FALSE</code>, indicating that this parameter should not
be estimated.</p>
</td></tr>
<tr><td><code id="estimate.geolm_cmodStd_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether
potentially informative messages should be printed. The
default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="estimate.geolm_cmodStd_+3A_...">...</code></td>
<td>
<p>Currently unimplemented</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="optimx.html#topic+optimx">optimx</a></code> function is used to find
the MLEs.  The <code>control</code> argument of
<code><a href="optimx.html#topic+optimx">optimx</a></code> has a parameter <code>kkt</code>
related to checking optimality conditions. This is
internally set to <code>FALSE</code>.  See
<code><a href="optimx.html#topic+optimx">optimx</a></code> for Details.
</p>
<p>Only the sum of <code>evar</code> and <code>fvar</code> is
identifiable. Depending on the choice of
<code>noise_type</code>, the covariance model is internally
updated to estimate only one type of noise. e.g., if
<code>noise_type = "e"</code>, then internally we update
<code>evar</code> so that <code>evar = evar + fvar</code> and
<code>fvar = 0</code>. Estimation is then performed on
<code>evar</code> alone. Alternatively, the analagous estimated
would be made for <code>fvar</code> if <code>noise_type =
"fvar"</code>.
</p>
<p>When <code>est_nugget</code> is true, the likelihood is
profiled to simplify the optimization problem. In that
case a parameter <code>lambda = (evar + fvar)/psill</code> is
optimized. The optimal <code>psill</code> and noise variance
are then determined.
</p>
<p>The <code>lower</code> argument should be a named list with the
names of the parameters you wish to set lower bounds for.
If not specified, an attempt is made to specify
reasonable lower bounds. The current choices are <code>r
= 0.001</code>, <code>psill = 0.001</code>, <code>lambda = 0</code>,
<code>angle = 0</code>, <code>ratio = 0.001</code>, <code>par3 =
0.001</code>.
</p>
<p>The <code>upper</code> argument should be a named list with the
names of the parameters you wish to set upper bounds for.
If not specified, an attempt is made to specify
reasonable upper bounds. The current choices are <code>r
= 5 * </code> maximum intercentroid distance, <code>psill = 5 *
var(object$y)</code>, <code>lambda = 5</code>, <code>angle = 179.99</code>,
<code>ratio = 1</code>, <code>par3 = 3</code>.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cmod_std">cmod_std</a></code>,
<code><a href="optimx.html#topic+optimx">optimx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toydata, package = "gear")
# setup standard covariance model
mod_std = cmod_std("exponential", psill = 1, r = 1, evar = 0.1)
# setup  dataframe with data
# fit Std geolm
object = geolm(y ~ x1 + x2, data = toydata, mod = mod_std,
                  coordnames = c("x1", "x2"))
est_object = estimate(object, control = list(trace = 1),
                      verbose = TRUE,
                      lower = list(r = 0.05, lambda = 0.05))
</code></pre>

<hr>
<h2 id='eval.cmod'>Evaluate covariance or semivariance model.</h2><span id='topic+eval.cmod'></span>

<h3>Description</h3>

<p><code>eval.cmod</code> evaluates the covariance 
of a model based on the provided arguments.  This
function will be deprecated in the future. Please use
the <code><a href="#topic+evaluate">evaluate</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.cmod(mod, d, coords = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.cmod_+3A_mod">mod</code></td>
<td>
<p>A covariance or semivariance model.</p>
</td></tr>
<tr><td><code id="eval.cmod_+3A_d">d</code></td>
<td>
<p>An <code class="reqn">n \times m</code> matrix of distances.</p>
</td></tr>
<tr><td><code id="eval.cmod_+3A_coords">coords</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the evaluated model with necessary
components needed for <code><a href="#topic+estimate">estimate</a></code> and
<code><a href="stats.html#topic+predict">predict</a></code>.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 10
coords = matrix(runif(2*n), nrow = n, ncol = 2)
d = as.matrix(dist(coords))
cmod = cmod_std(model = "exponential", psill = 1, r = 1)
eval.cmod(cmod, d)
</code></pre>

<hr>
<h2 id='evaluate.cmodStd'>Evaluate spatial dependence model</h2><span id='topic+evaluate.cmodStd'></span><span id='topic+evaluate'></span>

<h3>Description</h3>

<p><code>evaluate</code> evaluates the spatial dependence model
based on the provided arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cmodStd'
evaluate(mod, d, e = TRUE, f = TRUE)

evaluate(mod, d, e = TRUE, f = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate.cmodStd_+3A_mod">mod</code></td>
<td>
<p>A covariance or semivariogram model.</p>
</td></tr>
<tr><td><code id="evaluate.cmodStd_+3A_d">d</code></td>
<td>
<p>An <code class="reqn">n \times m</code> matrix of distances.
If <code>mod$ratio != 1</code>, i.e., if geometric anisotropy
has been specified, then <code>d</code> must be produced by the
<code><a href="#topic+ganiso_d">ganiso_d</a></code> function.</p>
</td></tr>
<tr><td><code id="evaluate.cmodStd_+3A_e">e</code></td>
<td>
<p>A single logical value indicating whether the
error variance should be added to the returned
covariance matrix.  Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="evaluate.cmodStd_+3A_f">f</code></td>
<td>
<p>A single logical value indicating whether the
finescale/microscale variance should be added to the
returned covariance matrix.  Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>mod</code> is of class <code>cmodStd</code> (from the
<code>cmod_std</code> function), then the function returns an
<code class="reqn">n \times m</code> matrix with the evaluated standard
covariance function.
</p>


<h3>Value</h3>

<p>Returns the evaluated model with necessary
components needed for <code><a href="#topic+estimate">estimate</a></code> and
<code><a href="stats.html#topic+predict">predict</a></code>.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 10
coords = matrix(runif(2*n), nrow = n, ncol = 2)
d = as.matrix(dist(coords))
cmod = cmod_std(model = "exponential", psill = 1, r = 1)
evaluate(cmod, d)
</code></pre>

<hr>
<h2 id='evgram'>Empirical (semi-)variogram</h2><span id='topic+evgram'></span>

<h3>Description</h3>

<p><code>evgram</code> computes the empirical semivariogram of
<code>data</code> based on the specified <code>formula</code>
indicating the response and trend. See Details. The
variogram is twice the semivariogram. If a trend is
specified, then the semivariogram is constructed using
the residuals of <code>lm(formula, data)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evgram(
  formula,
  data,
  coordnames = NULL,
  nbins = 10,
  maxd = NULL,
  angle = 0,
  ndir = 1,
  type = "standard",
  npmin = 2,
  longlat = FALSE,
  verbose = TRUE,
  invert = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evgram_+3A_formula">formula</code></td>
<td>
<p>A formula describing the relationship
between the response and any covariates of interest,
e.g., response ~ 1.  The variogram is computed for the
residuals of the linear model <code>lm(formula, data)</code>.</p>
</td></tr>
<tr><td><code id="evgram_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code>,
<code>SpatialPointsDataFrame</code>,
<code>SpatialPixelsDataFrame</code>, or
<code>SpatialGridDataFrame</code> object.</p>
</td></tr>
<tr><td><code id="evgram_+3A_coordnames">coordnames</code></td>
<td>
<p>The columns of <code>data</code> containing
the spatial coordinates, provided as a formula (e.g.,
<code>~ x + y</code>), column numbers (e.g., <code>c(1, 2)</code>),
or column names (e.g., <code>c("x", "y")</code>). The default
is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="evgram_+3A_nbins">nbins</code></td>
<td>
<p>The number of bins (tolerance regions) to
use when estimating the empirical semivariogram.</p>
</td></tr>
<tr><td><code id="evgram_+3A_maxd">maxd</code></td>
<td>
<p>The maximum distance used when calculating
the semivariogram.  Default is NULL, in which case half
the maximum distance between coordinates is used.</p>
</td></tr>
<tr><td><code id="evgram_+3A_angle">angle</code></td>
<td>
<p>A single value (in degrees) indicating the
starting direction for a directional variogram.  The
default is 0.</p>
</td></tr>
<tr><td><code id="evgram_+3A_ndir">ndir</code></td>
<td>
<p>The number of directions for which to
calculate a empirical semivariogram.  The default is 1,
meaning calculate an omnidirectional semivariogram.</p>
</td></tr>
<tr><td><code id="evgram_+3A_type">type</code></td>
<td>
<p>The name of the estimator to use in the
estimation process.  The default is <code>"standard"</code>, the
typical method-of-moments estimator.  Other options
include <code>"cressie"</code> for the robust Cressie-Hawkins
estimator, and <code>"cloud"</code> for a semivariogram cloud
based on the standard estimator.  If <code>"cloud"</code> is specified,
the <code>nbins</code> argument is ignored.</p>
</td></tr>
<tr><td><code id="evgram_+3A_npmin">npmin</code></td>
<td>
<p>The minimum number of pairs of points to use
in the semivariogram estimator.  For any bins with
fewer points, the estimate for that bin is dropped.</p>
</td></tr>
<tr><td><code id="evgram_+3A_longlat">longlat</code></td>
<td>
<p>A logical indicating whether Euclidean
(<code>FALSE</code>) or Great Circle distance (WGS84
ellipsoid) (<code>longlat = TRUE</code>) should be used.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="evgram_+3A_verbose">verbose</code></td>
<td>
<p>Logical value indicating whether
computation information should be printed. Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="evgram_+3A_invert">invert</code></td>
<td>
<p>A logical value indicating whether the axes
of the coordinates should be inverted (i.e., the x- and
y-axis are switched). The default is <code>TRUE</code> to
mimic results from other geostatistical R packages like
<code>gstat</code>, <code>geoR</code>, and other software like
<code>GSLIB</code> and <code>GeoEAS</code>. Set to <code>FALSE</code> to
use the typical x- and y-axes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the directions may be different from other
packages (e.g., <code>gstat</code> or <code>geoR</code> packages)
because those packages calculate angles clockwise from
the y-axis, which is a convention frequently seen in
geostatistics (e.g., the GSLIB software library). If
<code>invert = TRUE</code>, the directions should be the same.
</p>
<p>Computing the empirical semivariogram for the residuals
of <code>lm(response ~ 1)</code> will produce identical results
to simply computing the empirical semivariogram from the
original response. However, if a trend is specified (the
righthand side of ~ has non-trival covariates), then the
empirical semivariogram of the residuals will differ
from that of the original response.  A trend should be
specified when the mean is non-stationary over the
spatial domain.
</p>


<h3>Value</h3>

<p>Returns an <code>evgram</code>.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(co)
v = evgram(Al ~ 1, co, ~ easting + northing)
plot(v)
v2 = evgram(Al ~ 1, co, c("easting", "northing"), angle = 22.5, ndir = 4)
plot(v2)
</code></pre>

<hr>
<h2 id='fitted.geolm'>Extract fitted values from a <code>geolm</code> object</h2><span id='topic+fitted.geolm'></span>

<h3>Description</h3>

<p>Extract the fitted values, i.e., the estimated mean
values, for an <code>object</code> produced by the
<code><a href="#topic+geolm">geolm</a></code> function for a specified set of
covariates, <code>x</code>. If <code>x</code> is <code>NULL</code>, then
then <code>x</code> is taken from <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geolm'
fitted(object, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.geolm_+3A_object">object</code></td>
<td>
<p>An object produced by the
<code><a href="#topic+geolm">geolm</a></code> function.</p>
</td></tr>
<tr><td><code id="fitted.geolm_+3A_x">x</code></td>
<td>
<p>A <code class="reqn">m \times p</code> matrix of covariates for the
locations where fitted values are desired. If
<code>NULL</code>, <code>object$x</code> is used.</p>
</td></tr>
<tr><td><code id="fitted.geolm_+3A_...">...</code></td>
<td>
<p>Not currently implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>object</code> has a known mean, i.e.,
<code>object$mu</code> is not <code>NULL</code>, then the function
returns the vector <code>rep(object$mu, m)</code>. If
<code>object</code> has estimated coefficients, then <code>x
%*% object$coeff</code> is returned.
</p>
<p>If <code>x</code> is missing, then <code>object$x</code> is used for
<code>x</code>. Naturally, <code>ncol(x)</code> must equal
<code>length(object$coeff)</code>. If <code>x</code> is <code>NULL</code>
and <code>object$mu</code> is not <code>NULL</code>, then <code>m</code> is
taken to be 1.
</p>


<h3>Value</h3>

<p>The vector of fitted values.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+fitted">fitted</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = data.frame(y = rnorm(10), x1 = runif(10),
                 x2 = runif(10))
d = as.matrix(dist(data[,c("x1", "x2")]))
mod = cmod_man(v = exp(-d), evar = 1)
gearmod = geolm(y ~ x1, data = data,
                coordnames = ~ x1 + x2, mod = mod)
# fitted values for original observations
fitted(gearmod)
# fitted values for new observations
fitted(gearmod, x = cbind(1, rnorm(20)))
</code></pre>

<hr>
<h2 id='ganiso_d'>Anisotropic distance-related characteristics</h2><span id='topic+ganiso_d'></span>

<h3>Description</h3>

<p>Computes necessary distance-related characteristics when
there is geometric anisotropy. This is essentially an
internal function to <code><a href="#topic+evaluate">evaluate</a></code> a
<code>cmodStd</code> object produced by <code><a href="#topic+cmod_std">cmod_std</a></code>
when the anisotropy ratio differs from 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ganiso_d(coords1, coords2, radians = TRUE, invert = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ganiso_d_+3A_coords1">coords1</code></td>
<td>
<p>An <code class="reqn">N \times 2</code> matrix of spatial
coordinates.</p>
</td></tr>
<tr><td><code id="ganiso_d_+3A_coords2">coords2</code></td>
<td>
<p>An <code class="reqn">M \times 2</code> matrix of spatial
coordinates. Is missing, then <code>coords2 = coords1</code>.</p>
</td></tr>
<tr><td><code id="ganiso_d_+3A_radians">radians</code></td>
<td>
<p>A logical value indicating whether the
angles returned should be in degrees or radians.  The
default is <code>FALSE</code>, indicating that the returned
angles are in degrees.</p>
</td></tr>
<tr><td><code id="ganiso_d_+3A_invert">invert</code></td>
<td>
<p>A logical value indicating whether the axes
of the coordinates should be inverted (i.e., the x- and
y-axis are switched). The default is <code>TRUE</code> to
mimic results from other geostatistical R packages like
<code>gstat</code>, <code>geoR</code>, and other software like
<code>GSLIB</code> and <code>GeoEAS</code>. Set to <code>FALSE</code> to
use the typical x- and y-axes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ganisoD</code> object with components <code>d</code>
and <code>angles</code>, which is the distance matrix between
the coordinates and the angles between the coordinates.
The angles are returned in radians.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ganiso_d(cbind(0, 0), cbind(1, 1))
</code></pre>

<hr>
<h2 id='gear'>gear</h2><span id='topic+gear'></span>

<h3>Description</h3>

<p>*Ge*ostatistical *A*nalysis in *R*.
</p>

<hr>
<h2 id='geardf'>Construct a <code>geardf</code></h2><span id='topic+geardf'></span>

<h3>Description</h3>

<p><code>geardf</code> constructs a <code>geardf</code>, which is simply
a <code>data.frame</code> with an attribute indicating which
columns refer to the coordinates. The function either
combines <code>x</code> and <code>coords</code> if <code>coordnames</code>
isn't provided, or identifies the columns of <code>x</code> to
which <code>coordnames</code> refers. The <code>geardf</code> class
is only provided to make plotting results of the
<code>predict.geolm*</code> functions simple without depending
on the <code>sp</code> or <code>sf</code> packages. See
<code><a href="#topic+plot.geardf">plot.geardf</a></code> for easy plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geardf(data, coords, coordnames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geardf_+3A_data">data</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="geardf_+3A_coords">coords</code></td>
<td>
<p>A data.frame or matrix with column names</p>
</td></tr>
<tr><td><code id="geardf_+3A_coordnames">coordnames</code></td>
<td>
<p>The columns of <code>data</code> containing
the spatial coordinates, provided as a formula (e.g.,
<code>~ x + y</code>), column numbers (e.g., <code>c(1, 2)</code>),
or column names (e.g., <code>c("x", "y")</code>). The default
is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>geardf</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.geardf">plot.geardf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dtf = data.frame(a = 1:2, b = 3:4)

# create geardf with matrix coords (note column names)
coords = matrix(rnorm(4), ncol = 2)
colnames(coords) = c("u", "v")
geardf(dtf, coords)

# create geardf with data.frame coords
coords = as.data.frame(coords)
geardf(dtf, coords)

# create geardf using coordnames
dtf2 = cbind(dtf, u = rnorm(2), v = rnorm(2))
# vector form of coordnames
geardf(dtf2, coordnames = c("u", "v"))
# formula form of coordnames
geardf(dtf2, coordnames = ~ u + v)
# column index forum of coordnames
geardf(dtf2, coordnames = 3:4)

gdf = geardf(dtf2, coordnames = 3:4)
# looks like a data.frame
gdf
# but slightly more complicated
class(gdf)
attr(gdf, "coordnames")
</code></pre>

<hr>
<h2 id='geodist'>Compute distance for geographic coordinates</h2><span id='topic+geodist'></span>

<h3>Description</h3>

<p><code>geodist</code> computes the distance between the
coordinates in <code>coords1</code> and <code>coords2</code>. If
<code>coords2</code> isn't supplied, then the distances are
computed between the coordinates in <code>coords1</code> alone.
Otherwise, the pairwise distances between then points in
<code>coords1</code> and <code>coords2</code> is computed. If
<code>longlat = TRUE</code>, then the great circle distance is
computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geodist(coords1, coords2, longlat = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geodist_+3A_coords1">coords1</code></td>
<td>
<p>A two-dimensional matrix of coordinates.</p>
</td></tr>
<tr><td><code id="geodist_+3A_coords2">coords2</code></td>
<td>
<p>A two-dimensional matrix of coordinates.</p>
</td></tr>
<tr><td><code id="geodist_+3A_longlat">longlat</code></td>
<td>
<p>A logical value indicating whether
Euclidean distance (<code>longlat = FALSE</code>) or great
circle distance (<code>longlat = FALSE</code>) should be
computed. The default is <code>longlat = FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm used when <code>longlat = TRUE</code> is a C++
port of the C code written by Roger Bivand for
<code><a href="sp.html#topic+spDists">spDists</a></code>, which appears to be based on a
special case of the Vincenty formula with a slight
correction based on the WGS84 flattening constant. See
<a href="https://en.wikipedia.org/wiki/Great-circle_distance">https://en.wikipedia.org/wiki/Great-circle_distance</a>.
</p>


<h3>Value</h3>

<p>A matrix of distances
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coords = matrix(runif(10), ncol = 2)
d = geodist(coords)
all.equal(d, as.matrix(dist(coords)), check.attributes = FALSE)
</code></pre>

<hr>
<h2 id='geolm'>Linear model for geostatistical data.</h2><span id='topic+geolm'></span>

<h3>Description</h3>

<p><code>geolm</code> creates a geostatistical linear model object
of the appropriate class based on the arguments,
especially the <code>cmod</code> arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geolm(
  formula,
  data,
  coordnames,
  mod,
  weights = NULL,
  mu = NULL,
  longlat = NULL,
  cmod = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geolm_+3A_formula">formula</code></td>
<td>
<p>An object of class
<code><a href="stats.html#topic+formula">formula</a></code> providing a symbolic
description of the model to be fitted.  See Details of
this function and <code><a href="stats.html#topic+lm">lm</a></code>.</p>
</td></tr>
<tr><td><code id="geolm_+3A_data">data</code></td>
<td>
<p>A data frame containing the response,
covariates, and location coordinates.</p>
</td></tr>
<tr><td><code id="geolm_+3A_coordnames">coordnames</code></td>
<td>
<p>The columns of <code>data</code> containing
the spatial coordinates, provided as a formula (e.g.,
<code>~ x + y</code>), column numbers (e.g., <code>c(1, 2)</code>),
or column names (e.g., <code>c("x", "y")</code>)</p>
</td></tr>
<tr><td><code id="geolm_+3A_mod">mod</code></td>
<td>
<p>A model object produced by one
of the <code>cmod_*</code> functions, e.g.,
<code><a href="#topic+cmod_std">cmod_std</a></code>.</p>
</td></tr>
<tr><td><code id="geolm_+3A_weights">weights</code></td>
<td>
<p>An optional vector of weights for the
errors to be used in the fitting process.  A vector
that is proportional to the reciprocal variances of the
errors, i.e., errors are assumed to be uncorrelated
with variances <code>evar/weights</code>.  Default is
<code>NULL</code>, meaning that the weights are uniformly 1.</p>
</td></tr>
<tr><td><code id="geolm_+3A_mu">mu</code></td>
<td>
<p>A single numeric value indicating the consant
mean of the spatial process if simple kriging is
desired.  Default is <code>NULL</code>, meaning that ordinary
or universal kriging should be used.</p>
</td></tr>
<tr><td><code id="geolm_+3A_longlat">longlat</code></td>
<td>
<p>A logical indicating whether Euclidean
(<code>FALSE</code>) or Great Circle distance (WGS84
ellipsoid) (<code>longlat = TRUE</code>) should be used.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="geolm_+3A_cmod">cmod</code></td>
<td>
<p>Retained for backwards compatibility. A model object produced by one
of the <code>cmod_*</code> functions, e.g.,
<code><a href="#topic+cmod_std">cmod_std</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: for the multiresolution Gaussian process model, if
<code>cmod$est == "f"</code> (i.e., if the nugget is finescale
instead of measurement error), then the <code>weights</code>
argument is internally set to <code>rep(1, n)</code>, where
<code>n</code> is the number of observations.
</p>
<p><code>formula</code> should be specified after the form <code>y
~ x1 + x2</code>, where <code>y</code> is the response variable and
<code>x1</code> and <code>x2</code> are the covariates of interest.
If <code>mu</code> is provided, the variables to the right of
<code>~</code> are ignored.
</p>


<h3>Value</h3>

<p>Returns a <code>geolm_*</code> object, where <code>*</code>
depends on <code>mod</code>.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = data.frame(y = rnorm(10), x1 = runif(10),
                 x2 = runif(10))
d = geodist(data[,c("x1", "x2")])
mod = cmod_man(v = exp(-d), evar = 1)
gearmod = geolm(y ~ x1, data = data,
                coordnames = ~ x1 + x2, mod = mod)
</code></pre>

<hr>
<h2 id='geolm_fit'>Fit a <code>geolm</code></h2><span id='topic+geolm_fit'></span>

<h3>Description</h3>

<p><code>geolm_fit</code> fits a <code>geolm</code> based on the
specified <code>mod</code>. This is effectively an internal
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geolm_fit(
  mod,
  x,
  y,
  coords,
  mu,
  weights,
  formula,
  coordnames,
  n,
  call,
  coeff_names
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geolm_fit_+3A_mod">mod</code></td>
<td>
<p>A model object produced by one
of the <code>cmod_*</code> functions, e.g.,
<code><a href="#topic+cmod_std">cmod_std</a></code>.</p>
</td></tr>
<tr><td><code id="geolm_fit_+3A_x">x</code></td>
<td>
<p>The matrix of covariates.</p>
</td></tr>
<tr><td><code id="geolm_fit_+3A_y">y</code></td>
<td>
<p>The vector of observed responses.</p>
</td></tr>
<tr><td><code id="geolm_fit_+3A_coords">coords</code></td>
<td>
<p>The coordinates of the observed data set.</p>
</td></tr>
<tr><td><code id="geolm_fit_+3A_mu">mu</code></td>
<td>
<p>A single numeric value indicating the consant
mean of the spatial process if simple kriging is
desired.  Default is <code>NULL</code>, meaning that ordinary
or universal kriging should be used.</p>
</td></tr>
<tr><td><code id="geolm_fit_+3A_weights">weights</code></td>
<td>
<p>A vector that is proportional to the reciprocal variances of the errors.</p>
</td></tr>
<tr><td><code id="geolm_fit_+3A_formula">formula</code></td>
<td>
<p>An object of class
<code><a href="stats.html#topic+formula">formula</a></code> providing a symbolic
description of the model to be fitted.  See Details of
this function and <code><a href="stats.html#topic+lm">lm</a></code>.</p>
</td></tr>
<tr><td><code id="geolm_fit_+3A_coordnames">coordnames</code></td>
<td>
<p>A vector of length 2 with the names of the columns in <code>data</code> containing the coordinates, e.g., <code>c("long", "lat")</code>.</p>
</td></tr>
<tr><td><code id="geolm_fit_+3A_n">n</code></td>
<td>
<p>The number of observations.</p>
</td></tr>
<tr><td><code id="geolm_fit_+3A_call">call</code></td>
<td>
<p>The <code><a href="base.html#topic+match.call">match.call</a></code> for the <code>geolm</code>.</p>
</td></tr>
<tr><td><code id="geolm_fit_+3A_coeff_names">coeff_names</code></td>
<td>
<p>A character string with the variable names associated with the coefficents.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>geolm</code> with necessary
components needed for <code><a href="#topic+estimate">estimate</a></code> and
<code><a href="stats.html#topic+predict">predict</a></code>.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'># no examples since you shouldn't be using this function!
</code></pre>

<hr>
<h2 id='mle'>Finds maximum likelihood estimates of model parameters
for a geostatistical model</h2><span id='topic+mle'></span>

<h3>Description</h3>

<p><code>mle</code> estimates the parameters of a geostatistical
linear model.
</p>
<p><code>mle</code> estimates the parameters of a geostatistical
linear model. The <code>mle</code> function will be deprecated
in the future. Please update your code to use the
estimate function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mle(
  object,
  reml = FALSE,
  est = "e",
  lower = NULL,
  upper = NULL,
  method = "nlminb",
  itnmax = NULL,
  control = list(),
  ...
)

mle(
  object,
  reml = FALSE,
  est = "e",
  lower = NULL,
  upper = NULL,
  method = "nlminb",
  itnmax = NULL,
  control = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mle_+3A_object">object</code></td>
<td>
<p>A geostatistical linear model object
producted by the <code>geolm</code> function.</p>
</td></tr>
<tr><td><code id="mle_+3A_reml">reml</code></td>
<td>
<p>A logical value indicating whether standard
maximum likelihood estimation should be performed
(<code>reml = FALSE</code>).  If <code>reml = TRUE</code>, then
restricted maximum likelihood is performed.  Defaul is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mle_+3A_est">est</code></td>
<td>
<p>A character vector indicator whether the error
variance (<code>est="e"</code>) or finescale variance
(<code>est = "f"</code>) should be estimated.  The other
component of the nugget variance is held constant, and
in the case of a <code>geolmStd</code> object, is set to 0.</p>
</td></tr>
<tr><td><code id="mle_+3A_lower">lower</code></td>
<td>
<p>A vector of 2 or 3 specifying the lowerbound
of parameter values.  See Details.</p>
</td></tr>
<tr><td><code id="mle_+3A_upper">upper</code></td>
<td>
<p>lower A vector of 2 or 3 specifying the
lowerbound of parameter values.  See Details.</p>
</td></tr>
<tr><td><code id="mle_+3A_method">method</code></td>
<td>
<p>The optimization method.  Default is
<code>"nlminb"</code>, with <code>"L-BFGS-B"</code> being another
acceptable choice.  See <code><a href="optimx.html#topic+optimx">optimx</a></code>
for details.</p>
</td></tr>
<tr><td><code id="mle_+3A_itnmax">itnmax</code></td>
<td>
<p>An integer indicating the maximum number of
iterations to allow for the optimization prodedure.</p>
</td></tr>
<tr><td><code id="mle_+3A_control">control</code></td>
<td>
<p>A list of control parameters passed
internally to <code><a href="optimx.html#topic+optimx">optimx</a></code>.  See
<code><a href="optimx.html#topic+optimx">optimx</a></code> for details.</p>
</td></tr>
<tr><td><code id="mle_+3A_...">...</code></td>
<td>
<p>Currently unimplemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the case of a <code>geolmStd</code> <code>object</code>, the
likelihood has been concentrated so that only the range
parameter <code>r</code> and a scale parameter <code>lambda =
nugget/psill</code> need to be estimated.
</p>
<p>If <code>object</code> is a <code>geolmStd</code>, then <code>lower</code>
is of length 2 if the covariance model of <code>cmod</code> is
not <code>matern</code> or <code>amatern</code>.  Otherwise, it
should be of length 3.  The first parameter is related to
the range parameter <code>r</code>, the second to the scale
parameter <code>lambda</code>, and the third to <code>par3</code>, if
applicable.  If <code>lower = NULL</code>, then the lower
bounds are 0.001, 0, and 0.1, respectively.  A similar
pattern holds for <code>upper</code>, with the default being
<code>3 * max(d)</code>, where <code>d</code> is the matrix of
distances between coordinates, <code>5</code>, and <code>2.5</code>.
</p>
<p>The <code>kkt</code> argument in the <code>control</code> list is set
to be <code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>
<p>Joshua French
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
n = 100
set.seed(10)
n = 100
</code></pre>

<hr>
<h2 id='omni_semivariogram'>Compute an omnidirectional empirical semivariogram</h2><span id='topic+omni_semivariogram'></span>

<h3>Description</h3>

<p>Compute an omnidirectional empirical semivariogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omni_semivariogram(d, diff, cuts, npmin, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omni_semivariogram_+3A_d">d</code></td>
<td>
<p>Vector of pairwise distances</p>
</td></tr>
<tr><td><code id="omni_semivariogram_+3A_diff">diff</code></td>
<td>
<p>Vector of pairwise response differences</p>
</td></tr>
<tr><td><code id="omni_semivariogram_+3A_cuts">cuts</code></td>
<td>
<p>Cut points for bins</p>
</td></tr>
<tr><td><code id="omni_semivariogram_+3A_npmin">npmin</code></td>
<td>
<p>Minimum pairs of differences</p>
</td></tr>
<tr><td><code id="omni_semivariogram_+3A_type">type</code></td>
<td>
<p>Type of empirical semivariogram</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the computed omnidirectional semivariogram
</p>

<hr>
<h2 id='ploglik_xycholv'>Compute the log-likelihood of a model</h2><span id='topic+ploglik_xycholv'></span><span id='topic+ll_xycholv'></span>

<h3>Description</h3>

<p><code>ll_xycholv</code> computes the log-likelihood of
multivariate normal data using components typically found
in a <code>geolm</code>. For <code>ploglik_xycholv</code>, 
<code>cholv</code> is the cholesky decomposition of the 
covariance matrix for the observed data after dividing
the matrix by the (estimated) <code>psill</code>. See the
examples below.
Depending on parameter choices, the
function can return the log-likelihood, the restricted
log-likelihood, -2 times the log-likelihood or restricted
log-likelihood, or the estimated partial sill for both a
maximum likelihood and restricted maximum likelihood
setting. This is intended to be an internal function, so
minimal error checking is done.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ploglik_xycholv(
  x,
  y,
  cholv,
  mu = NULL,
  reml = FALSE,
  minus2 = TRUE,
  return_ll = TRUE
)

ll_xycholv(
  x,
  y,
  cholv,
  mu = NULL,
  reml = FALSE,
  minus2 = TRUE,
  return_ll = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ploglik_xycholv_+3A_x">x</code></td>
<td>
<p>The matrix of covariates.</p>
</td></tr>
<tr><td><code id="ploglik_xycholv_+3A_y">y</code></td>
<td>
<p>The vector of observed responses.</p>
</td></tr>
<tr><td><code id="ploglik_xycholv_+3A_cholv">cholv</code></td>
<td>
<p>The cholesky decomposition of the covariance
matrix of <code>y</code> (or of that matrix divided by <code>psill</code> for
<code>loglik_xycholv</code>.</p>
</td></tr>
<tr><td><code id="ploglik_xycholv_+3A_mu">mu</code></td>
<td>
<p>A single numeric value indicating the assumed
mean of the underlying process.</p>
</td></tr>
<tr><td><code id="ploglik_xycholv_+3A_reml">reml</code></td>
<td>
<p>A logical value. Should the Restricted
Maximum Likelihood be returned. The default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ploglik_xycholv_+3A_minus2">minus2</code></td>
<td>
<p>A logical value. Should -2 times the
log-likelihood be returned. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ploglik_xycholv_+3A_return_ll">return_ll</code></td>
<td>
<p>A logical value. Should the
log-liklihood be returned? Default is <code>TRUE</code>. If
<code>FALSE</code>, the estimated partial sill is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A likelihood value, -2 times the likelihood
value, or the estimated partial sill, depending on the
user's argument choices.
</p>


<h3>References</h3>

<p>Statistical Methods for Spatial Data
Analysis. Oliver Schabenberger and Carol A. Gotway
(Chapman &amp; Hall/CRC Press) 2005. pp. 259-263
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y = rnorm(10)
x = matrix(rep(1, length(y)))
coords = matrix(runif(length(y) * 2), ncol = 2)
d = as.matrix(dist(coords))
pv = exp(-d/3) + 0.1 * diag(length(y))
est_psill = ploglik_xycholv(x, y, chol(pv), return_ll = FALSE)
v = pv * est_psill
# same result
ploglik_xycholv(x, y, chol(pv), minus2 = FALSE)
ll_xycholv(x, y, chol(v), minus2 = FALSE)
</code></pre>

<hr>
<h2 id='plot.evgram'>Plot <code>evgram</code> object</h2><span id='topic+plot.evgram'></span>

<h3>Description</h3>

<p>Plots <code>evgram</code> object produced by  
<code><a href="#topic+evgram">evgram</a></code> using the 
<code><a href="graphics.html#topic+plot">plot</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evgram'
plot(x, ..., split = FALSE, add_legend = TRUE, args_legend = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.evgram_+3A_x">x</code></td>
<td>
<p>An <code>evgram</code> object produced by the <code><a href="#topic+evgram">evgram</a></code> function.</p>
</td></tr>
<tr><td><code id="plot.evgram_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass the <code><a href="graphics.html#topic+plot">plot</a></code> function to change aspects of the plot.</p>
</td></tr>
<tr><td><code id="plot.evgram_+3A_split">split</code></td>
<td>
<p>A logical value indicating whether, for a directional 
semivariogram, the directional semivariograms should be displayed 
in a single or split panels.  Default is FALSE, for a single panel.</p>
</td></tr>
<tr><td><code id="plot.evgram_+3A_add_legend">add_legend</code></td>
<td>
<p>A logical value indicating whether a 
legend should be included for a plot of directional
semivariograms when <code>split = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.evgram_+3A_args_legend">args_legend</code></td>
<td>
<p>A list with arguments for 
<code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments after <code>...</code> are only considered
if a directional semivariogram is provided, i.e., 
when <code>x$ndir != 1</code>. 
</p>
<p><code>split</code> will split directional semivariograms into
different plots automatically using 
<code><a href="autoimage.html#topic+autosize">autosize</a></code>.
</p>
<p><code>add_legend</code> and <code>args_legend</code> are only used
for a directional semivariogram when <code>split = FALSE</code>
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+xyplot">xyplot</a></code>, <code><a href="#topic+evgram">evgram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(co)
# omnidirectional example
v = evgram(Al ~ 1, co, ~ easting + northing)
plot(v)
plot(v, main = "semivariogram of Al")

# directional semivariograms overlaid
v2 = evgram(Al ~ 1, co, ~ easting + northing,
            angle = 22.5, ndir = 4)
plot(v2)
plot(v2, ylab = "semi-variance", pch = 2:5, type = "p")
plot(v2, lty = 2:5, type = "l", 
     args_legend = list(x = "bottomright",
                        legend = c("22.5", "67.5", "112.5", "157.5")))
# directional semivariograms split
plot(v2, split = TRUE)
plot(v2, split = TRUE, col = 2, pch = 3, type = "b",
     main = c("(a)", "(b)", "(c)", "(d)"))
</code></pre>

<hr>
<h2 id='plot.geardf'>Plot <code>geardf</code> object</h2><span id='topic+plot.geardf'></span>

<h3>Description</h3>

<p>Plot a <code>geardf</code> object produced by the
<code><a href="#topic+geardf">geardf</a></code> or <code>predict.geolm*</code>
functions. See the <code><a href="autoimage.html#topic+autopoints">autopoints</a></code>
and <code><a href="autoimage.html#topic+autoimage">autoimage</a></code> functions for
advanced options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geardf'
plot(x, zcol = names(x), interp = FALSE, common.legend = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.geardf_+3A_x">x</code></td>
<td>
<p>A <code>geardf</code> object produced by the
<code><a href="#topic+geardf">geardf</a></code> or <code>predict.geolm*</code>
functions.</p>
</td></tr>
<tr><td><code id="plot.geardf_+3A_zcol">zcol</code></td>
<td>
<p>The names of the columns of <code>x</code> to plot.
The coordinate columns are automatically stripped from
<code>zcol</code>.</p>
</td></tr>
<tr><td><code id="plot.geardf_+3A_interp">interp</code></td>
<td>
<p>A logical value indicating whether the
values should be interpolated onto a grid. If
<code>FALSE</code>, then the
<code><a href="autoimage.html#topic+autopoints">autopoints</a></code> function is used to
construct a heated scatterplot. If <code>TRUE</code>, then
the <code><a href="autoimage.html#topic+autoimage">autoimage</a></code> function is used
to create a heat map. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.geardf_+3A_common.legend">common.legend</code></td>
<td>
<p>A logical value indicating whether a
common legend should be used for the
scatterplots/images. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.geardf_+3A_...">...</code></td>
<td>
<p>Additional arguments to passed to the
<code><a href="autoimage.html#topic+autopoints">autopoints</a></code> or
<code><a href="autoimage.html#topic+autoimage">autoimage</a></code> functions.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>See Also</h3>

<p><code><a href="autoimage.html#topic+autopoints">autopoints</a></code>,
<code><a href="autoimage.html#topic+autoimage">autoimage</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toydata)
# newdata must have columns with prediction coordinates
newdata = data.frame(x1 = runif(10), x2 = runif(10))

# specify a standard covariance model
mod = cmod_std(model = "exponential", psill = 1, r = 1)

# geolm for universal kriging
geolm_uk = geolm(y ~ x1 + x2, data = toydata, mod = mod,
             coordnames = c("x1", "x2"))

# prediction for universal kriging
pred_uk = predict(geolm_uk, newdata, return_type = "geardf")
# heated scatterplot
plot(pred_uk)
# interpolated image of results
plot(pred_uk, interp = TRUE)
# plot only predictions and rmspe with different colors
plot(pred_uk, c("pred", "rmspe"), col = cm.colors(5))
#'plot only predictions with coarser interpolation grid
plot(pred_uk, "pred", interp = TRUE,
     interp.args = list(no.X = 10, no.Y = 10))
</code></pre>

<hr>
<h2 id='predict.geolm_cmodMan'>Predict method for geostatistical models</h2><span id='topic+predict.geolm_cmodMan'></span>

<h3>Description</h3>

<p><code>predict</code> calculates the predicted values at
specified locations.  The method can additionally provide
the mean square prediction error (mspe) and perform
conditional simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geolm_cmodMan'
predict(
  object,
  newdata,
  nsim = 0,
  vop,
  vp,
  return_type = "SpatialPointsDataFrame",
  dmethod = "chol",
  compute_mspe = TRUE,
  sp = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.geolm_cmodMan_+3A_object">object</code></td>
<td>
<p>An object produced by the <code>geolm</code>
function.</p>
</td></tr>
<tr><td><code id="predict.geolm_cmodMan_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame in which to look
for the coordinates at which to predict. If omitted,
the observed data locations are used.</p>
</td></tr>
<tr><td><code id="predict.geolm_cmodMan_+3A_nsim">nsim</code></td>
<td>
<p>A non-negative integer indicating the number
of realizations to sample at the specified coordinates
using conditional simulation.</p>
</td></tr>
<tr><td><code id="predict.geolm_cmodMan_+3A_vop">vop</code></td>
<td>
<p>The cross-covariance matrix between the
observed responses and the responses to predict.</p>
</td></tr>
<tr><td><code id="predict.geolm_cmodMan_+3A_vp">vp</code></td>
<td>
<p>The covariance matrix of the responses to
predict.</p>
</td></tr>
<tr><td><code id="predict.geolm_cmodMan_+3A_return_type">return_type</code></td>
<td>
<p>A character string indicating the type
of object that should be returned. The default is
<code>"<a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a>"</code> for easy
plotting of results (see Examples). Other options
include <code>"<a href="base.html#topic+data.frame">data.frame</a>"</code>,
<code>"<a href="#topic+geardf">geardf</a>"</code>, and <code>"<a href="sf.html#topic+sf">sf</a>"</code>.</p>
</td></tr>
<tr><td><code id="predict.geolm_cmodMan_+3A_dmethod">dmethod</code></td>
<td>
<p>The method used to decompose the
covariance matrix for conditional simulation.  Valid
options are <code>"chol"</code>, <code>"eigen"</code>, and
<code>"svd"</code>.  The default is <code>"chol"</code>.</p>
</td></tr>
<tr><td><code id="predict.geolm_cmodMan_+3A_compute_mspe">compute_mspe</code></td>
<td>
<p>A logical value indicating whether
the mean square prediction error should be calculated.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.geolm_cmodMan_+3A_sp">sp</code></td>
<td>
<p>This argument will be deprecated in the future.
Please use the <code>return_type</code> argument. A logical
value indicating whether to object returned should be
of class <code><a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a></code> for
easier plotting with the <code>sp</code> package.  Default is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="predict.geolm_cmodMan_+3A_...">...</code></td>
<td>
<p>Currently unimplemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>newdata</code> data frame must include the relevant
covariates for the prediction locations, where the
covariates are specified on the right side of the
<code>~</code> in <code>object$formula</code>.  <code>newdata</code> must
also include the coordinates of the prediction locations,
with these columns having the names provided in
<code>object$coordnames</code>.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code>,
<code><a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a></code>,
<code><a href="#topic+geardf">geardf</a></code>, or <code><a href="sf.html#topic+sf">sf</a></code>
object with the kriging predictions
<code>pred</code>, kriging variance/mean-square prediction
error (<code>mspe</code>), the root mean-square prediction
error <code>mspe</code> (<code>rmspe</code>), and the conditional
simulations <code>sim.1</code>, <code>sim.2</code>, etc.
<code>sim.1</code>, <code>sim.2</code>, etc.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate response
y = rnorm(10)
# generate coordinates
x1 = runif(10); x2 = runif(10)

# data frame for observed data
data = data.frame(y, x1, x2)
coords = cbind(x1, x2)
d = as.matrix(dist(coords))
psill = 2 # partial sill
r = 4 # range parameter
evar = .1 # error variance
fvar = .1 # add finescale variance
# one can't generally distinguish between evar and fvar, but
# this is done for illustration purposes

# manually specify an exponential covariance model
v = psill * exp(-d/r) + (evar + fvar) * diag(10)
mod_man = cmod_man(v = v, evar = evar)

# coordinate names
cnames = c("x1", "x2")

# geolm for universal kriging
gearmod_uk = geolm(y ~ x1 + x2, data = data, mod = mod_man,
                 coordnames = cnames)

# newdata must have columns with prediction coordinates
# add 5 unsampled sites to sampled sites
newdata = data.frame(x1 = c(x1, runif(5)), x2 = c(x2, runif(5)))
newcoords = newdata[, cnames]
# create vop and vp using distances
dop = geodist(as.matrix(coords), as.matrix(newcoords))
dp = geodist(newcoords)

# manually create cross-covariance and covariance for
# prediction locations
vop = psill * exp(-dop/r) + fvar * (dop == 0)
vp = psill * exp(-dp/r) + fvar * diag(nrow(newcoords))

# prediction for universal kriging, with conditional simulation,
# using manual covariance matrices
pred_uk_man = predict(gearmod_uk, newdata, nsim = 2,
                      vop = vop, vp = vp, dmethod = "svd")

# do the same thing, but using cmod_std

# prediction for universal kriging, with conditional simulation
mod_std = cmod_std("exponential", psill = psill, r = r,
                   evar = evar, fvar = fvar)
gearmod_uk2 = geolm(y ~ x1 + x2, data = data, mod = mod_std,
                    coordnames = c("x1", "x2"))
pred_uk_std = predict(gearmod_uk2, newdata, nsim = 2, dmethod = "svd")

# compare results
all.equal(pred_uk_man$pred, pred_uk_std$pred)
all.equal(pred_uk_man$mspe, pred_uk_std$mspe)
</code></pre>

<hr>
<h2 id='predict.geolm_cmodStd'>Predict method for geostatistical models</h2><span id='topic+predict.geolm_cmodStd'></span>

<h3>Description</h3>

<p><code>predict</code> calculates the predicted values at
specified locations.  The method can additionally provide
the mean square prediction error (mspe) and perform
conditional simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geolm_cmodStd'
predict(
  object,
  newdata,
  nsim = 0,
  return_type = "SpatialPointsDataFrame",
  dmethod = "chol",
  compute_mspe = TRUE,
  sp = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.geolm_cmodStd_+3A_object">object</code></td>
<td>
<p>An object produced by the <code>geolm</code>
function.</p>
</td></tr>
<tr><td><code id="predict.geolm_cmodStd_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame in which to look
for the coordinates at which to predict. If omitted,
the observed data locations are used.</p>
</td></tr>
<tr><td><code id="predict.geolm_cmodStd_+3A_nsim">nsim</code></td>
<td>
<p>A non-negative integer indicating the number
of realizations to sample at the specified coordinates
using conditional simulation.</p>
</td></tr>
<tr><td><code id="predict.geolm_cmodStd_+3A_return_type">return_type</code></td>
<td>
<p>A character string indicating the type
of object that should be returned. The default is
<code>"<a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a>"</code> for easy
plotting of results (see Examples). Other options
include <code>"<a href="base.html#topic+data.frame">data.frame</a>"</code>,
<code>"<a href="#topic+geardf">geardf</a>"</code>, and <code>"<a href="sf.html#topic+sf">sf</a>"</code>.</p>
</td></tr>
<tr><td><code id="predict.geolm_cmodStd_+3A_dmethod">dmethod</code></td>
<td>
<p>The method used to decompose the
covariance matrix for conditional simulation.  Valid
options are <code>"chol"</code>, <code>"eigen"</code>, and
<code>"svd"</code>.  The default is <code>"chol"</code>.</p>
</td></tr>
<tr><td><code id="predict.geolm_cmodStd_+3A_compute_mspe">compute_mspe</code></td>
<td>
<p>A logical value indicating whether
the mean square prediction error should be calculated.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.geolm_cmodStd_+3A_sp">sp</code></td>
<td>
<p>This argument will be deprecated in the future.
Please use the <code>return_type</code> argument. A logical
value indicating whether to object returned should be
of class <code><a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a></code> for
easier plotting with the <code>sp</code> package.  Default is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="predict.geolm_cmodStd_+3A_...">...</code></td>
<td>
<p>Currently unimplemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>newdata</code> data frame must include the relevant
covariates for the prediction locations, where the
covariates are specified on the right side of the
<code>~</code> in <code>object$formula</code>.  <code>newdata</code> must
also include the coordinates of the prediction locations,
with these columns having the names provided in
<code>object$coordnames</code>.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code>,
<code><a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a></code>,
<code><a href="#topic+geardf">geardf</a></code>, or <code><a href="sf.html#topic+sf">sf</a></code>
object with the kriging predictions
<code>pred</code>, kriging variance/mean-square prediction
error (<code>mspe</code>), the root mean-square prediction
error <code>mspe</code> (<code>rmspe</code>), and the conditional
simulations <code>sim.1</code>, <code>sim.2</code>, etc.
<code>sim.1</code>, <code>sim.2</code>, etc.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate response
y = rnorm(10)
# generate coordinates
x1 = runif(10); x2 = runif(10)

# data frame for observed data
data = data.frame(y, x1, x2)
# newdata must have columns with prediction coordinates
newdata = data.frame(x1 = runif(5), x2 = runif(5))

# specify a standard covariance model
mod = cmod_std(model = "exponential", psill = 1, r = 1)

# geolm for universal kriging
gearmod_uk = geolm(y ~ x1 + x2, data = data, mod = mod,
                   coordnames = c("x1", "x2"))
# prediction for universal kriging, with conditional simulation
pred_uk = predict(gearmod_uk, newdata, nsim = 2)

# demonstrate plotting abilities if return_type == "geardf"
 pred_geardf = predict(gearmod_uk, newdata,
               return_type = "geardf")
 plot(pred_geardf, "pred")
 plot(pred_geardf, interp = TRUE)

# demonstrate plotting abilities if sp package installed
if (requireNamespace("sp", quietly = TRUE)) {
 pred_spdf = predict(gearmod_uk, newdata,
             return_type = "SpatialPointsDataFrame")
 sp::spplot(pred_spdf, "pred")
 sp::spplot(pred_spdf)
}
# demonstrate plotting abilities if sf package installed
if (requireNamespace("sf", quietly = TRUE)) {
 pred_sfdf = predict(gearmod_uk, newdata,
             return_type = "sf")
 plot(pred_sfdf["pred"])
 plot(pred_sfdf)
}

# geolm for ordinary kriging
gearmod_ok = geolm(y ~ 1, data = data, mod = mod,
                   coordnames = c("x1", "x2"))
# prediction for ordinary kriging
pred_ok = predict(gearmod_ok, newdata)

# geolm for simple kriging
gearmod_sk = geolm(y ~ 1, data = data, mod = mod,
                 coordnames = c("x1", "x2"), mu = 1)
# prediction for simple kriging
pred_sk = predict(gearmod_sk, newdata)
</code></pre>

<hr>
<h2 id='print.evgram'>Print <code>evgram</code> object</h2><span id='topic+print.evgram'></span>

<h3>Description</h3>

<p>Print an object of class <code>evgram</code> produced by the 
<code><a href="#topic+evgram">evgram</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evgram'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.evgram_+3A_x">x</code></td>
<td>
<p>An <code>evgram</code> object produced by the <code><a href="#topic+evgram">evgram</a></code> function.</p>
</td></tr>
<tr><td><code id="print.evgram_+3A_...">...</code></td>
<td>
<p>Not currently implemented.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(co)
evgram(Al ~ 1, co, ~ easting + northing)
</code></pre>

<hr>
<h2 id='residuals.geolm'>Extract residuals from a <code>geolm</code> object</h2><span id='topic+residuals.geolm'></span>

<h3>Description</h3>

<p>Extract the residuals for an <code>object</code> produced by
the <code><a href="#topic+geolm">geolm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geolm'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.geolm_+3A_object">object</code></td>
<td>
<p>An object produced by the
<code><a href="#topic+geolm">geolm</a></code> function.</p>
</td></tr>
<tr><td><code id="residuals.geolm_+3A_...">...</code></td>
<td>
<p>Not currently implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector of residuals.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+residuals">residuals</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = data.frame(y = rnorm(10), x1 = runif(10),
                 x2 = runif(10))
d = as.matrix(dist(data[,c("x1", "x2")]))
mod = cmod_man(v = exp(-d), evar = 1)
gearmod = geolm(y ~ x1, data = data,
                coordnames = ~ x1 + x2, mod = mod)
# fitted values for original observations
residuals(gearmod)
</code></pre>

<hr>
<h2 id='solve_chol'>Solve using cholesky decomposition</h2><span id='topic+solve_chol'></span><span id='topic+solve.chol'></span>

<h3>Description</h3>

<p><code>solve_chol</code> solves a system of equations using the
cholesky decomposition of a positive definite matrix
<code>A</code>, i.e., using <code>a = chol(A)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solve_chol(a, b, ...)

## S3 method for class 'chol'
solve(a, b, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solve_chol_+3A_a">a</code></td>
<td>
<p>The cholesky decomposition of a positive
definite matrix.</p>
</td></tr>
<tr><td><code id="solve_chol_+3A_b">b</code></td>
<td>
<p>A numeric or complex vector or matrix giving the
right-hand side(s) of the linear system. If missing,
<code>b</code> is taken to be an identity matrix and solve
will return the inverse of <code>a</code>.</p>
</td></tr>
<tr><td><code id="solve_chol_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: Unless you have good reason to suspect that the
cholesky decomposition of your matrix will be stable, it
is recommended that you use <code><a href="base.html#topic+solve">solve</a></code> or
perform the solve using the <code><a href="base.html#topic+qr">qr</a></code>
decomposition.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+solve">solve</a></code>,
<code><a href="base.html#topic+chol">chol</a></code>, <code><a href="base.html#topic+qr">qr</a></code>,
<code><a href="base.html#topic+solve.qr">solve.qr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
# create positive definite matrix a
a = crossprod(matrix(rnorm(25^2), nrow = 25))
# create vector x and matrix b
# x can be used to check the stability of the solution
x = matrix(rnorm(25))
b = a %*% x

# standard solve
x1 = solve(a, b)
all.equal(x, x1)

# solve using cholesky decomposition
chola = chol(a)
x2 = solve_chol(chola, b)
all.equal(x, x2)

# solve using qr decomposition
qra = qr(a)
x3 = solve.qr(qra, b)
all.equal(x, x3)

# compare direct inversion
ai1 = solve(a)
ai2 = solve_chol(chola) #using cholesky decomposition
all.equal(ai1, ai2) # should be TRUE
</code></pre>

<hr>
<h2 id='toydata'>A toy data set for examples</h2><span id='topic+toydata'></span>

<h3>Description</h3>

<p>This is a toy data set of 25 observations 
generated on a [0, 1] x [0, 1] domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(toydata)
</code></pre>


<h3>Format</h3>

<p>A data frame with 25 rows and 3 columns:
</p>

<dl>
<dt>y</dt><dd><p>response</p>
</dd>
<dt>x1</dt><dd><p>coordinate dimension 1 values</p>
</dd>
<dt>x2</dt><dd><p>coordinate dimension 2 values</p>
</dd>
</dl>


<hr>
<h2 id='update.geolm'>Update linear model for geostatistical data</h2><span id='topic+update.geolm'></span><span id='topic+update.geolm_cmodMan'></span><span id='topic+update.geolm_cmodStd'></span>

<h3>Description</h3>

<p><code>update</code> updates a geostatistical linear model based
on the given model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geolm'
update(object, mod, ...)

## S3 method for class 'geolm_cmodMan'
update(object, mod, ...)

## S3 method for class 'geolm_cmodStd'
update(object, mod, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.geolm_+3A_object">object</code></td>
<td>
<p>An object produced by the <code>geolm</code>
function.</p>
</td></tr>
<tr><td><code id="update.geolm_+3A_mod">mod</code></td>
<td>
<p>A spatial dependence model object obtained
from one of the <code>cmod_*</code> functions or the
<code>estimate</code> function.</p>
</td></tr>
<tr><td><code id="update.geolm_+3A_...">...</code></td>
<td>
<p>Not implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of the same class as
<code>object</code>.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+update">update</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate response
y = rnorm(10)
# generate coordinates
x1 = runif(10); x2 = runif(10)

# data frame for observed data
data = data.frame(y, x1, x2)
coords = cbind(x1, x2)
psill = 2 # partial sill
r = 4 # range parameter
evar = .1 # error variance
fvar = .1 # add finescale variance
# one can't generally distinguish between evar and fvar, but
# this is done for illustration purposes

cmod_std = cmod_std("exponential", psill = psill, r = r,
                    evar = evar, fvar = fvar)

cmod_std2 = cmod_std("exponential", psill = psill + 1,
                     r = r + .5, evar = evar + .01,
                     fvar = fvar)

# check geolm update for universal kriging
gear1 = geolm(y ~ x1 + x2, data = data, mod = cmod_std,
              coordnames = c("x1", "x2"))

gear2 = geolm(y ~ x1 + x2, data = data, mod = cmod_std2,
              coordnames = c("x1", "x2"))
gear2b = update(gear1, cmod_std2)
gear2$call = NULL
gear2b$call = NULL
identical(gear2, gear2b)
</code></pre>

<hr>
<h2 id='vgram'>Empirical variogram</h2><span id='topic+vgram'></span>

<h3>Description</h3>

<p><code>vgram</code> calculates an empirical variogram.  Note that, by convention,
the empirical variogram actually estimates the semivariogram, not the
theoretical variogram (which is twice the semivariogram).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vgram(
  formula,
  data,
  coordnames = NULL,
  nbins = 10,
  maxd = NULL,
  angle = 0,
  ndir = 1,
  type = "standard",
  npmin = 2,
  longlat = FALSE,
  verbose = TRUE,
  coords = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vgram_+3A_formula">formula</code></td>
<td>
<p>A formula describing the relationship between the response and any covariates of interest, e.g., response ~ 1.  The variogram is computed for the residuals of the linear model <code>lm(formula, data)</code>.</p>
</td></tr>
<tr><td><code id="vgram_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code>, <code>SpatialPointsDataFrame</code>, <code>SpatialPixelsDataFrame</code>, or <code>SpatialGridDataFrame</code> object.</p>
</td></tr>
<tr><td><code id="vgram_+3A_coordnames">coordnames</code></td>
<td>
<p>The columns of <code>data</code> containing the spatial coordinates,
provided as a formula (e.g., ~ x + y),
column numbers (e.g., c(1, 2)), or column names (e.g., c(&quot;x&quot;, &quot;y&quot;)).
The default is NULL, but this must be specified if <code>data</code> is of class <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="vgram_+3A_nbins">nbins</code></td>
<td>
<p>The number of bins (tolerance regions) to use when estimating the sample semivariogram.</p>
</td></tr>
<tr><td><code id="vgram_+3A_maxd">maxd</code></td>
<td>
<p>The maximum distance used when calculating the semivariogram.  Default is NULL, in which case half the maximum distance between coordinates is used.</p>
</td></tr>
<tr><td><code id="vgram_+3A_angle">angle</code></td>
<td>
<p>A single value (in degrees) indicating the starting direction for a directional variogram.  The default is 0.</p>
</td></tr>
<tr><td><code id="vgram_+3A_ndir">ndir</code></td>
<td>
<p>The number of directions for which to calculate a sample semivariogram.  The default is 1, meaning calculate an omnidirection semivariogram.</p>
</td></tr>
<tr><td><code id="vgram_+3A_type">type</code></td>
<td>
<p>The name of the estimator to use in the estimation process.  The default is &quot;standard&quot;, the typical method-of-moments estimator.  Other options include &quot;cressie&quot; for the robust Cressie-Hawkins estimator, and &quot;cloud&quot; for a semivariogram cloud based on the standard estimator.  If &quot;cloud&quot; is specified, the <code>nbins</code> argument is ignored.</p>
</td></tr>
<tr><td><code id="vgram_+3A_npmin">npmin</code></td>
<td>
<p>The minimum number of pairs of points to use in the semivariogram estimator.  For any bins with fewer points, the estimate for that bin is dropped.</p>
</td></tr>
<tr><td><code id="vgram_+3A_longlat">longlat</code></td>
<td>
<p>A logical indicating whether Euclidean (<code>FALSE</code>) or Great Circle distance (WGS84 ellipsoid) (<code>longlat = TRUE</code>) should be used.  Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="vgram_+3A_verbose">verbose</code></td>
<td>
<p>Print computation information.  Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="vgram_+3A_coords">coords</code></td>
<td>
<p>A deprecated argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the directions may be different from other packages
(e.g., <code>gstat</code> or <code>geoR</code> packages) because those
packages calculate angles clockwise from the y-axis, which is
a convention frequently seen in geostatistics
(e.g., the GSLIB software library).
</p>
<p>Additionally, note that calculating the empirical variogram for
the residuals of lm(response ~ 1) will produce identical results
to simply computing the sample semivariogram from the original response.
However, if a trend is specified (the righthand side of ~ has non-trival
covariates), then the empirical variogram of the residuals will differ
from that of the original response.  A trend should be specified when
the mean is non-stationary over the spatial domain.
</p>


<h3>Value</h3>

<p>Returns an <code>evgram</code> object with components:
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(co)
v = vgram(Al ~ 1, co, ~ easting + northing)
plot(v)
v2 = vgram(Al ~ 1, co, c("easting", "northing"), angle = 22.5, ndir = 4)
plot(v2)
</code></pre>

<hr>
<h2 id='xyplot.evgram'>Plot <code>evgram</code> object</h2><span id='topic+xyplot.evgram'></span>

<h3>Description</h3>

<p>Plots <code>evgram</code> object produced by the
<code><a href="#topic+evgram">evgram</a></code> function using the
<code><a href="lattice.html#topic+xyplot">xyplot</a></code> function. Note: the
<code>lattice</code> package must be loaded (i.e.,
<code>library(lattice)</code> or <code>lattice::xyplot</code>
must be specifically called for this function to work.
See Examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xyplot.evgram(x, ..., split = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xyplot.evgram_+3A_x">x</code></td>
<td>
<p>An <code>evgram</code> object produced by the <code><a href="#topic+evgram">evgram</a></code> function.</p>
</td></tr>
<tr><td><code id="xyplot.evgram_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass the <code><a href="lattice.html#topic+xyplot">xyplot</a></code> function to change aspects of the plot.</p>
</td></tr>
<tr><td><code id="xyplot.evgram_+3A_split">split</code></td>
<td>
<p>A logical value indicating whether, for a directional
semivariogram, the directional semivariograms should be displayed
in a single or split panels.  Default is FALSE, for a single panel.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+xyplot">xyplot</a></code>, <code><a href="#topic+evgram">evgram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(co)
v = evgram(Al ~ 1, co, ~ easting + northing)
if (requireNamespace("lattice")) {
   lattice::xyplot(v)
}
v2 = evgram(Al ~ 1, co, ~ easting + northing, angle = 22.5, ndir = 4)
if (requireNamespace("lattice")) {
   lattice::xyplot(v2)
   # show how attributes can be changed using different
   # arguments available in lattice::xyplot.
   lattice::xyplot(v2, col = 2:5)
   lattice::xyplot(v2, col = 2:5, pch = 1:4)
   lattice::xyplot(v2, col = 2:5, pch = 1:4, lty = 2:5, type = "b")
   lattice::xyplot(v2, col = 2:5, pch = 1:4, lty = 2:5, type = "b",
    key=list(text=list(levels(as.factor(v2$semi$angle))),
    space='right', points=list(pch=1:4, col=2:5),
    lines=list(col=2:5, lty = 2:5)))
   lattice::xyplot(v2, split = TRUE)
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
