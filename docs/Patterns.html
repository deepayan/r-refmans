<!DOCTYPE html><html><head><title>Help for package Patterns</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Patterns}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Patterns-package'><p>The Patterns Package</p></a></li>
<li><a href='#analyze_network+2Comics_network-method'><p>Analysing the network</p></a></li>
<li><a href='#as.omics_array'><p>Coerce a matrix into a omics_array object.</p></a></li>
<li><a href='#CascadeFinit'><p>Create initial F matrices for cascade networks inference.</p></a></li>
<li><a href='#CascadeFshape'><p>Create F matrices shaped for cascade networks inference.</p></a></li>
<li><a href='#CLL'><p>Expression data from healthy and malignant (chronic lymphocytic leukemia,</p>
CLL) human B-lymphocytes after B-cell receptor stimulation (GSE 39411
dataset)</a></li>
<li><a href='#clustExploration+2Comics_array-method'><p>A function to explore a dataset and cluster its rows.</p></a></li>
<li><a href='#clustInference+2Comics_array+2Cnumeric-method'><p>A function to explore a dataset and cluster its rows.</p></a></li>
<li><a href='#compare-methods'><p>Some basic criteria of comparison between actual and inferred network.</p></a></li>
<li><a href='#cutoff+2Comics_network-method'><p>Choose the best cutoff</p></a></li>
<li><a href='#dim'><p>Dimension of the data</p></a></li>
<li><a href='#evolution+2Comics_network-method'><p>See the evolution of the network with change of cutoff</p></a></li>
<li><a href='#gene_expr_simulation+2Comics_network-method'><p>Simulates omicsarray data based on a given network.</p></a></li>
<li><a href='#geneNeighborhood+2Comics_network-method'><p>Find the neighborhood of a set of nodes.</p></a></li>
<li><a href='#geneSelection'><p>Methods for selecting genes</p></a></li>
<li><a href='#head+2Comics_array-method'><p>Overview of a omics_array object</p></a></li>
<li><a href='#IndicFinit'><p>Create initial F matrices using specific intergroup actions for network</p>
inference.</a></li>
<li><a href='#IndicFshape'><p>Create F matrices using specific intergroup actions for network inference.</p></a></li>
<li><a href='#inference'><p>Reverse-engineer the network</p></a></li>
<li><a href='#infos'><p>Details on some probesets of the affy_hg_u133_plus_2 platform.</p></a></li>
<li><a href='#M'><p>Simulated microarray.</p></a></li>
<li><a href='#Net'><p>Simulated network for examples.</p></a></li>
<li><a href='#Net_inf_PL'><p>Reverse-engineered network of the M and Net simulated data.</p></a></li>
<li><a href='#network'><p>A example of an inferred network (4 groups case).</p></a></li>
<li><a href='#network_random'><p>Generates a network.</p></a></li>
<li><a href='#network2gp'><p>A example of an inferred cascade network (2 groups case).</p></a></li>
<li><a href='#networkCascade'><p>A example of an inferred cascade network (4 groups case).</p></a></li>
<li><a href='#omics_array-class'><p>Class <code>"omics_array"</code></p></a></li>
<li><a href='#omics_network-class'><p>Class <code>"omics_network"</code></p></a></li>
<li><a href='#omics_predict-class'><p>Class <code>"omics_predict"</code></p></a></li>
<li><a href='#plot-methods'><p>Plot</p></a></li>
<li><a href='#plotF'><p>Plot functions for the F matrices.</p></a></li>
<li><a href='#position-methods'><p>Returns the position of edges in the network</p></a></li>
<li><a href='#predict+2Comics_array-method'><p>Methods for Function <code>predict</code></p></a></li>
<li><a href='#probeMerge+2Comics_array-method'><p>Function to merge probesets</p></a></li>
<li><a href='#replaceBand'><p>Replace matrix values by band.</p></a></li>
<li><a href='#replaceDown'><p>Replace matrix values triangular lower part and by band for the upper part.</p></a></li>
<li><a href='#replaceUp'><p>Replace matrix values triangular upper part and by band for the lower part.</p></a></li>
<li><a href='#Selection'><p>Selection of genes.</p></a></li>
<li><a href='#show-methods'><p><code>Show</code> methods</p></a></li>
<li><a href='#summary-methods'><p><code>Summary</code> methods</p></a></li>
<li><a href='#unionOmics-methods'><p>Makes the union between two omics_array objects.</p></a></li>
<li><a href='#unsupervised_clustering_auto_m_c+2Comics_array-method'><p>Cluster a omics_array object: determine optimal fuzzification parameter and</p>
number of clusters.</a></li>
<li><a href='#unsupervised_clustering+2Comics_array+2Cnumeric+2Cnumeric-method'><p>Cluster a omics_array object: performs the clustering.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Deciphering Biological Networks with Patterned Heterogeneous
Measurements</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-29</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, gplots, graphics, grDevices, igraph, jetset, lars,
lattice, limma, methods, Mfuzz, movMF, nnls, plotrix, repmis,
SelectBoost, tnet, VGAM, WGCNA</td>
</tr>
<tr>
<td>Suggests:</td>
<td>animation, Biobase, c060, cluster, elasticnet, glmnet,
pixmap, biomaRt, CascadeData, knitr, R.rsp, spls, rmarkdown</td>
</tr>
<tr>
<td>Author:</td>
<td>Frederic Bertrand <a href="https://orcid.org/0000-0002-0837-8281"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Myriam Maumy-Bertrand
    <a href="https://orcid.org/0000-0002-4615-1512"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Frederic Bertrand &lt;frederic.bertrand@utt.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A modeling tool dedicated to biological network modeling (Bertrand and others 2020, &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtaa855">doi:10.1093/bioinformatics/btaa855</a>&gt;). It allows for single or joint modeling of, for instance, genes and proteins. It starts with the selection of the actors that will be the used in the reverse engineering upcoming step. An actor can be included in that selection based on its differential measurement (for instance gene expression or protein abundance) or on its time course profile. Wrappers for actors clustering functions and cluster analysis are provided. It also allows reverse engineering of biological networks taking into account the observed time course patterns of the actors. Many inference functions are provided and dedicated to get specific features for the inferred network such as sparsity, robust links, high confidence links or stable through resampling links. Some simulation and prediction tools are also available for cascade networks (Jung and others 2014, &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtt705">doi:10.1093/bioinformatics/btt705</a>&gt;). Example of use with microarray or RNA-Seq data are provided.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Collate:</td>
<td>Patterns-package.R global.R datasets.R omics_array.R
omics_network.R omics_array-omics_network.R omics_predict.R</td>
</tr>
<tr>
<td>Classification/MSC:</td>
<td>62J05, 62J07, 62J99, 92C42</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://fbertran.github.io/Patterns/">https://fbertran.github.io/Patterns/</a>,
<a href="https://github.com/fbertran/Patterns/">https://github.com/fbertran/Patterns/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/fbertran/Patterns/issues/">https://github.com/fbertran/Patterns/issues/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-29 23:00:08 UTC; fbertran</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-01 13:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='Patterns-package'>The Patterns Package</h2><span id='topic+Patterns-package'></span><span id='topic+Patterns'></span>

<h3>Description</h3>

<p>A modeling tool dedicated to biological network modeling. It allows for
single or joint modeling of, for instance, genes and proteins. It starts
with the selection of the actors that will be the used in the reverse
engineering upcoming step. An actor can be included in that selection based
on its differential measurement (for instance gene expression or protein
abundance) or on its time course profile. Wrappers for actors clustering
functions and cluster analysis are provided. It also allows reverse
engineering of biological networks taking into account the observed time
course patterns of the actors. Many inference functions are provided and
dedicated to get specific features for the inferred network such as
sparsity, robust links, high confidence links or stable through resampling
links. Some simulation and prediction tools are also available for cascade
networks. Example of use with microarray or RNA-Seq data are provided.
</p>


<h3>Author(s)</h3>

<p>This package has been written by Frederic Bertrand in collaboration
with Myriam Maumy-Bertrand. Maintainer: &lt;frederic.bertrand@utt.fr&gt;
</p>


<h3>References</h3>

<p>F. Bertrand, I. Aouadi, N. Jung, R. Carapito, L. Vallat, S. Bahram, M. Maumy-Bertrand (2020). SelectBoost: a general algorithm to enhance the performance of variable selection methods, <em>Bioinformatics</em>, <a href="https://doi.org/10.1093/bioinformatics/btaa855">doi:10.1093/bioinformatics/btaa855</a>.
</p>
<p>C. Schleiss, [...], M. Maumy-Bertrand, S. Bahram, F. Bertrand, and L. Vallat. (2021). Temporal multiomic modelling reveals a B-cell receptor proliferative program in chronic lymphocytic leukemia. <em>Leukemia</em>.
</p>

<hr>
<h2 id='analyze_network+2Comics_network-method'>Analysing the network</h2><span id='topic+analyze_network+2Comics_network-method'></span><span id='topic+analyze_network'></span><span id='topic+analyze_network-methods'></span>

<h3>Description</h3>

<p>Calculates some indicators for each node in the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'omics_network'
analyze_network(Omega, nv, label_v = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze_network+2B2Comics_network-method_+3A_omega">Omega</code></td>
<td>
<p>a omics_network object</p>
</td></tr>
<tr><td><code id="analyze_network+2B2Comics_network-method_+3A_nv">nv</code></td>
<td>
<p>the level of cutoff at which the analysis should be done</p>
</td></tr>
<tr><td><code id="analyze_network+2B2Comics_network-method_+3A_label_v">label_v</code></td>
<td>
<p>(optionnal) the name of the genes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing, for each node, its betweenness,its degree, its
output, its closeness.
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(network)
analyze_network(network,nv=0)

</code></pre>

<hr>
<h2 id='as.omics_array'>Coerce a matrix into a omics_array object.</h2><span id='topic+as.omics_array'></span>

<h3>Description</h3>

<p>Coerce a matrix into a omics_array object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.omics_array(
  M,
  time,
  subject,
  name_probe = NULL,
  gene_ID = NULL,
  group = 0,
  start_time = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.omics_array_+3A_m">M</code></td>
<td>
<p>A matrix. Contains the omicsarray measurements. Should be of size N
* K, with N the number of genes and K=T*P with T the number of time points,
and P the number of subjects. This matrix should be created using
cbind(M1,M2,...) with M1 a N*T matrix with the measurements for patient 1,
M2 a N*T matrix with the measurements for patient 2.</p>
</td></tr>
<tr><td><code id="as.omics_array_+3A_time">time</code></td>
<td>
<p>A vector. The time points measurements</p>
</td></tr>
<tr><td><code id="as.omics_array_+3A_subject">subject</code></td>
<td>
<p>The number of subjects.</p>
</td></tr>
<tr><td><code id="as.omics_array_+3A_name_probe">name_probe</code></td>
<td>
<p>Vector with the row names of the omics array.</p>
</td></tr>
<tr><td><code id="as.omics_array_+3A_gene_id">gene_ID</code></td>
<td>
<p>Vector with the actors' IDs of the row names of the omics
array.</p>
</td></tr>
<tr><td><code id="as.omics_array_+3A_group">group</code></td>
<td>
<p>Vector with the actors' groups of the row names of the omics
array.</p>
</td></tr>
<tr><td><code id="as.omics_array_+3A_start_time">start_time</code></td>
<td>
<p>Vector with the actors' starting time (i.e. the time it is
thought to begin to have an effect on another actor in the network).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A omics_array object.
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require(CascadeData)){
	data(micro_US, package="CascadeData")
	micro_US&lt;-as.omics_array(micro_US[1:100,],time=c(60,90,210,390),subject=6)
	plot(micro_US)
	}

</code></pre>

<hr>
<h2 id='CascadeFinit'>Create initial F matrices for cascade networks inference.</h2><span id='topic+CascadeFinit'></span>

<h3>Description</h3>

<p>This is an helper function to create initial values F matrices for cascade
networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CascadeFinit(sqF, ngrp, low.trig = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CascadeFinit_+3A_sqf">sqF</code></td>
<td>
<p>Size of an F cell</p>
</td></tr>
<tr><td><code id="CascadeFinit_+3A_ngrp">ngrp</code></td>
<td>
<p>Number of groups</p>
</td></tr>
<tr><td><code id="CascadeFinit_+3A_low.trig">low.trig</code></td>
<td>
<p>Fill the lower trigonal matrices with ones</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of sizes c(sqF, sqF, ngrp).
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
CascadeFinit(3,2)
CascadeFinit(4,3)
plotF(CascadeFinit(4,3),choice = "F")
CascadeFinit(3,2,low.trig=FALSE)
CascadeFinit(4,3,low.trig=FALSE)
plotF(CascadeFinit(4,3,low.trig=FALSE),choice = "F")

</code></pre>

<hr>
<h2 id='CascadeFshape'>Create F matrices shaped for cascade networks inference.</h2><span id='topic+CascadeFshape'></span>

<h3>Description</h3>

<p>This is an helper function to create F matrices with special shape used for
cascade networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CascadeFshape(sqF, ngrp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CascadeFshape_+3A_sqf">sqF</code></td>
<td>
<p>Size of an F cell</p>
</td></tr>
<tr><td><code id="CascadeFshape_+3A_ngrp">ngrp</code></td>
<td>
<p>Number of groups</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of sizes c(sqF, sqF, ngrp).
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
CascadeFshape(3,2)
plotF(CascadeFshape(3,2),choice = "Fshape")
CascadeFshape(4,3)
plotF(CascadeFshape(4,3),choice = "Fshape")

</code></pre>

<hr>
<h2 id='CLL'>Expression data from healthy and malignant (chronic lymphocytic leukemia,
CLL) human B-lymphocytes after B-cell receptor stimulation (GSE 39411
dataset)</h2><span id='topic+CLL'></span>

<h3>Description</h3>

<p>B-cells were negatively selected from healthy donors and previously
untreated CLL patients. BCR stimulated and unstimulated control B-cells were
treated at four time points after stimulation for total RNA extraction and
hybridization on Affymetrix microarrays.
</p>


<h3>Format</h3>

<p>The format is: chr &quot;CLL&quot;
</p>


<h3>Details</h3>

<p>The dataset provided with package is the first five lines of the full
dataset. The full dataset can be downloaded from the github repository of
the package
(https://raw.githubusercontent.com/fbertran/Patterns/master/add_data/CLL.RData).
</p>
<p>Three different cell populations (6 healthy B-lymphocytes, 6 leukemic CLL
B-lymphocyte of indolent form and 5 leukemic CLL B-lymphocyte of aggressive
form) were stimulated in vitro with an anti-IgM antibody, activating the
B-cell receptor (BCR). We analyzed the gene expression at 4 time points (60,
90, 210 and 390 minutes). Each gene expression measurement is performed both
in stimulated cells and in control unstimulated cells. For one aggressive
CLL case, we silenced expression of DUSP1 by transfecting DUSP1-specific
RNAi and, as a control, transfected cells with a non-targeting RNAi. We then
stimulated the BCR of these cells and analyzed the gene expression at the
same time points in stimulated cells and in control unstimulated cells.
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Source</h3>

<p>https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE39411
</p>


<h3>References</h3>

<p>Vallat, L., Kemper, C. A., Jung, N., Maumy-Bertrand, M.,
Bertrand, F., Meyer, N., … Bahram, S. (2013). Reverse-engineering the
genetic circuitry of a cancer cell with predicted intervention in chronic
lymphocytic leukemia. Proceedings of the National Academy of Sciences of the
United States of America, 110(2), 459–464.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(CLL)
str(CLL)


CLLfile &lt;- "https://github.com/fbertran/Patterns/raw/master/add_data/CLL.RData"
repmis::source_data(CLLfile)
str(CLL)


</code></pre>

<hr>
<h2 id='clustExploration+2Comics_array-method'>A function to explore a dataset and cluster its rows.</h2><span id='topic+clustExploration+2Comics_array-method'></span><span id='topic+clustExploration'></span><span id='topic+clustExploration-methods'></span>

<h3>Description</h3>

<p>Based on soft clustering performed by the Mfuzz package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'omics_array'
clustExploration(omicsarray, new.window = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustExploration+2B2Comics_array-method_+3A_omicsarray">omicsarray</code></td>
<td>
<p>A omicsarray to cluster</p>
</td></tr>
<tr><td><code id="clustExploration+2B2Comics_array-method_+3A_new.window">new.window</code></td>
<td>
<p>Boolean. New X11 window for plots. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame of nrows(omicsarray) observations of 3 variables (name,
cluster, maj.vote.index).
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(Patterns)
if(require(CascadeData)){
data(micro_S, package="CascadeData")
D&lt;-Patterns::as.omics_array(micro_S[1:100,],1:4,6)
a&lt;-clustExploration(D)
a
}

</code></pre>

<hr>
<h2 id='clustInference+2Comics_array+2Cnumeric-method'>A function to explore a dataset and cluster its rows.</h2><span id='topic+clustInference+2Comics_array+2Cnumeric-method'></span><span id='topic+clustInference'></span><span id='topic+clustInference-methods'></span>

<h3>Description</h3>

<p>Based on soft clustering performed by the Mfuzz package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'omics_array,numeric'
clustInference(omicsarray, vote.index, new.window = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustInference+2B2Comics_array+2B2Cnumeric-method_+3A_omicsarray">omicsarray</code></td>
<td>
<p>A omicsarray to cluster</p>
</td></tr>
<tr><td><code id="clustInference+2B2Comics_array+2B2Cnumeric-method_+3A_vote.index">vote.index</code></td>
<td>
<p>Option for cluster attribution</p>
</td></tr>
<tr><td><code id="clustInference+2B2Comics_array+2B2Cnumeric-method_+3A_new.window">new.window</code></td>
<td>
<p>Boolean. New X11 window for plots. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two elements: </p>
<table>
<tr><td><code>res.matrix</code></td>
<td>
<p>A data.frame of
nrows(omicsarray) observations of 3 variables (name, cluster,
maj.vote.index).</p>
</td></tr> <tr><td><code>prop.matrix</code></td>
<td>
<p>Additionnal info.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(Patterns)
if(require(CascadeData)){
data(micro_S, package="CascadeData")
D&lt;-Patterns::as.omics_array(micro_S[1:20,],1:4,6)
b&lt;-Patterns::clustInference(D,0.5)
b
}

</code></pre>

<hr>
<h2 id='compare-methods'>Some basic criteria of comparison between actual and inferred network.</h2><span id='topic+compare-methods'></span><span id='topic+compare'></span><span id='topic+compare+2Comics_network+2Comics_network+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Allows comparison between actual and inferred network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'omics_network,omics_network,numeric'
compare(Net, Net_inf, nv = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare-methods_+3A_net">Net</code></td>
<td>
<p>A omics_network object containing the
actual network.</p>
</td></tr>
<tr><td><code id="compare-methods_+3A_net_inf">Net_inf</code></td>
<td>
<p>A omics_network object containing the inferred
network.</p>
</td></tr>
<tr><td><code id="compare-methods_+3A_nv">nv</code></td>
<td>
<p>A number that indicates at which level of cutoff the
comparison should be done.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing : sensitivity, predictive positive value, the
usual F-score (2*ppv*sens/(sppvpe+sens)), the 1/2 ponderated Fscore
((1+0.5^2)*ppv*sens/(ppv/4+sens)) and the 2 ponderated Fscore
((1+2^2)*ppv*sens/(ppv*4+sens)).
</p>


<h3>Methods</h3>


<dl>
<dt>list(&quot;signature(Net = \&quot;omics_network\&quot;, Net_inf = \&quot;omics_network\&quot;, nv =
\&quot;numeric\&quot;)&quot;)</dt><dd>  <dl>
<dt>Net</dt><dd><p> A omics_network object containing the
actual network.  </p>
</dd> <dt>Net_inf</dt><dd><p> A omics_network object containing the inferred
network.  </p>
</dd> <dt>nv</dt><dd><p> A number that indicates at which level of cutoff the
comparison should be done.  </p>
</dd> </dl>
 </dd>
</dl>



<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Net)
data(Net_inf_PL)

#Comparing true and inferred networks
Crit_values=NULL

#Here are the cutoff level tested
test.seq&lt;-seq(0,max(abs(Net_inf_PL@omics_network*0.9)),length.out=200)
for(u in test.seq){
	Crit_values&lt;-rbind(Crit_values,Patterns::compare(Net,Net_inf_PL,u))
}
matplot(test.seq,Crit_values,type="l",ylab="Criterion value",xlab="Cutoff level",lwd=2)
legend(x="topleft", legend=colnames(Crit_values), lty=1:5,col=1:5,ncol=2,cex=.9)

</code></pre>

<hr>
<h2 id='cutoff+2Comics_network-method'>Choose the best cutoff</h2><span id='topic+cutoff+2Comics_network-method'></span><span id='topic+cutoff'></span><span id='topic+cutoff-methods'></span>

<h3>Description</h3>

<p>Allows estimating the best cutoff. For a sequence of cutoff, the p value
corresponding to each cutoff value of the sequence. Mainly recommended for
single time cascade networks. To achieve more sparsity in other settings,
please use a fiiting function based on the stability selection or
selectboost algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'omics_network'
cutoff(Omega, sequence = NULL, x_min = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutoff+2B2Comics_network-method_+3A_omega">Omega</code></td>
<td>
<p>a omics_network object</p>
</td></tr>
<tr><td><code id="cutoff+2B2Comics_network-method_+3A_sequence">sequence</code></td>
<td>
<p>a vector corresponding to the sequence of cutoffs that will be tested.</p>
</td></tr>
<tr><td><code id="cutoff+2B2Comics_network-method_+3A_x_min">x_min</code></td>
<td>
<p>an integer ; only values over x_min are further retained for performing the test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two objects : </p>
<table>
<tr><td><code>p.value</code></td>
<td>
<p>the p values
corresponding to the sequence of cutoff</p>
</td></tr> <tr><td><code>p.value.inter</code></td>
<td>
<p>the smoothed p
value vector, using the loess function</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

		data(network)
		cutoff(network)
		#See vignette for more details


</code></pre>

<hr>
<h2 id='dim'>Dimension of the data</h2><span id='topic+dim'></span><span id='topic+dim-methods'></span><span id='topic+dim+2Comics_array-method'></span>

<h3>Description</h3>

<p>Dimension of the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'omics_array'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dim_+3A_x">x</code></td>
<td>
<p>an object of class 'omics_array'.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>list(&quot;signature(x = \&quot;omics_array\&quot;)&quot;)</dt><dd><p> Gives the dimension of the
matrix of measurements. </p>
</dd> </dl>



<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>

<hr>
<h2 id='evolution+2Comics_network-method'>See the evolution of the network with change of cutoff</h2><span id='topic+evolution+2Comics_network-method'></span><span id='topic+evolution'></span><span id='topic+evolution-methods'></span>

<h3>Description</h3>

<p>See the evolution of the network with change of cutoff
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'omics_network'
evolution(
  net,
  list_nv,
  gr = NULL,
  color.vertex = NULL,
  color.edge = NULL,
  fix = TRUE,
  size = c(2000, 1000),
  label_v = 1:dim(net@omics_network)[1],
  legend.position = "topleft",
  frame.color = "black",
  label.hub = FALSE,
  outdir,
  type.ani = "html"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evolution+2B2Comics_network-method_+3A_net">net</code></td>
<td>
<p>a omics_network object</p>
</td></tr>
<tr><td><code id="evolution+2B2Comics_network-method_+3A_list_nv">list_nv</code></td>
<td>
<p>a vector of cutoff at which the network should be shown</p>
</td></tr>
<tr><td><code id="evolution+2B2Comics_network-method_+3A_gr">gr</code></td>
<td>
<p>a vector giving the group of each genee. Defaults to NULL</p>
</td></tr>
<tr><td><code id="evolution+2B2Comics_network-method_+3A_color.vertex">color.vertex</code></td>
<td>
<p>a vector giving the color of each nodee. Defaults to NULL</p>
</td></tr>
<tr><td><code id="evolution+2B2Comics_network-method_+3A_color.edge">color.edge</code></td>
<td>
<p>a vector giving the color of each edge. Defaults to NULL</p>
</td></tr>
<tr><td><code id="evolution+2B2Comics_network-method_+3A_fix">fix</code></td>
<td>
<p>logical, should the position of the node in the network be calculated once at the beginning ? Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="evolution+2B2Comics_network-method_+3A_size">size</code></td>
<td>
<p>vector giving the size of the plot. Defaults to c(2000,1000)</p>
</td></tr>
<tr><td><code id="evolution+2B2Comics_network-method_+3A_label_v">label_v</code></td>
<td>
<p>vector giving the labels of each vertex. Defaults to 1:dim(net@omics_network)[1]</p>
</td></tr>
<tr><td><code id="evolution+2B2Comics_network-method_+3A_legend.position">legend.position</code></td>
<td>
<p>string giving the position of the legend. Defaults to &quot;topleft&quot;</p>
</td></tr>
<tr><td><code id="evolution+2B2Comics_network-method_+3A_frame.color">frame.color</code></td>
<td>
<p>string giving the color of the frame of the plot. Defaults to &quot;black&quot;</p>
</td></tr>
<tr><td><code id="evolution+2B2Comics_network-method_+3A_label.hub">label.hub</code></td>
<td>
<p>label hubs. Defaults to FALSE</p>
</td></tr>
<tr><td><code id="evolution+2B2Comics_network-method_+3A_outdir">outdir</code></td>
<td>
<p>Directory to save the animation. No default value since it must be specified by the user.</p>
</td></tr>
<tr><td><code id="evolution+2B2Comics_network-method_+3A_type.ani">type.ani</code></td>
<td>
<p>Type of animation. Defaults to &quot;html&quot;</p>
</td></tr>
<tr><td><code id="evolution+2B2Comics_network-method_+3A_legend">legend</code></td>
<td>
<p>string giving the position of the legend. Defaults to &quot;topleft&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Several types of outputs are available using the type.ani option. </p>

<ul>
<li><p> html </p>
</li>
<li><p> latex (requires latex) </p>
</li>
<li><p> swf (requires swftools)
</p>
</li>
<li><p> video (requires ffmpeg) </p>
</li>
<li><p> gif </p>
</li>
<li><p> manual_gif </p>
</li></ul>



<h3>Value</h3>

<p>A HTML page with the evolution of the network.
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(network)
sequence&lt;-seq(0,0.2,length.out=20)

#Change the destdir to have the animation created where you want. 
destdir = tempdir()

#Example of use of the evolution method with an html output.
evolution(network,sequence,type.ani = "html", outdir=destdir)


## Not run: 
#Example of use of the evolution method with an animated gif output.
evolution(network,sequence,type.ani = "gif", outdir=destdir)

## End(Not run)

</code></pre>

<hr>
<h2 id='gene_expr_simulation+2Comics_network-method'>Simulates omicsarray data based on a given network.</h2><span id='topic+gene_expr_simulation+2Comics_network-method'></span><span id='topic+gene_expr_simulation'></span><span id='topic+gene_expr_simulation-methods'></span>

<h3>Description</h3>

<p>Simulates omicsarray data based on a given network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'omics_network'
gene_expr_simulation(
  omics_network,
  time_label = 1:4,
  subject = 5,
  peak_level = 100,
  act_time_group = 1:4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gene_expr_simulation+2B2Comics_network-method_+3A_omics_network">omics_network</code></td>
<td>
<p>A omics_network object.</p>
</td></tr>
<tr><td><code id="gene_expr_simulation+2B2Comics_network-method_+3A_time_label">time_label</code></td>
<td>
<p>a vector containing the time labels.</p>
</td></tr>
<tr><td><code id="gene_expr_simulation+2B2Comics_network-method_+3A_subject">subject</code></td>
<td>
<p>the number of subjects</p>
</td></tr>
<tr><td><code id="gene_expr_simulation+2B2Comics_network-method_+3A_peak_level">peak_level</code></td>
<td>
<p>the mean level of peaks.</p>
</td></tr>
<tr><td><code id="gene_expr_simulation+2B2Comics_network-method_+3A_act_time_group">act_time_group</code></td>
<td>
<p>[NULL] vector ; at which time the groups (defined by sort(unique(group))) are activated ?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A omics_array object.
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Net)
set.seed(1)

#We simulate gene expressions according to the network Net
Msim&lt;-Patterns::gene_expr_simulation(
	omics_network=Net,
	time_label=rep(1:4,each=25),
	subject=5,
	peak_level=200)
head(Msim)

</code></pre>

<hr>
<h2 id='geneNeighborhood+2Comics_network-method'>Find the neighborhood of a set of nodes.</h2><span id='topic+geneNeighborhood+2Comics_network-method'></span><span id='topic+geneNeighborhood'></span><span id='topic+geneNeighborhood-methods'></span>

<h3>Description</h3>

<p>Find the neighborhood of a set of nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'omics_network'
geneNeighborhood(
  net,
  targets,
  nv = 0,
  order = length(net@time_pt) - 1,
  label_v = NULL,
  ini = NULL,
  frame.color = "white",
  label.hub = FALSE,
  graph = TRUE,
  names = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geneNeighborhood+2B2Comics_network-method_+3A_net">net</code></td>
<td>
<p>a omics_network object</p>
</td></tr>
<tr><td><code id="geneNeighborhood+2B2Comics_network-method_+3A_targets">targets</code></td>
<td>
<p>a vector containing the set of nodes</p>
</td></tr>
<tr><td><code id="geneNeighborhood+2B2Comics_network-method_+3A_nv">nv</code></td>
<td>
<p>the level of cutoff. Defaut to 0.</p>
</td></tr>
<tr><td><code id="geneNeighborhood+2B2Comics_network-method_+3A_order">order</code></td>
<td>
<p>of the neighborhood. Defaut to 'length(net@time_pt)-1'.</p>
</td></tr>
<tr><td><code id="geneNeighborhood+2B2Comics_network-method_+3A_label_v">label_v</code></td>
<td>
<p>vector defining the vertex labels.</p>
</td></tr>
<tr><td><code id="geneNeighborhood+2B2Comics_network-method_+3A_ini">ini</code></td>
<td>
<p>using the &ldquo;position&rdquo; function, you can
fix the position of the nodes.</p>
</td></tr>
<tr><td><code id="geneNeighborhood+2B2Comics_network-method_+3A_frame.color">frame.color</code></td>
<td>
<p>color of the frames.</p>
</td></tr>
<tr><td><code id="geneNeighborhood+2B2Comics_network-method_+3A_label.hub">label.hub</code></td>
<td>
<p>logical ; if TRUE only the hubs are labeled.</p>
</td></tr>
<tr><td><code id="geneNeighborhood+2B2Comics_network-method_+3A_graph">graph</code></td>
<td>
<p>plot graph of the network. Defaults to 'TRUE'.</p>
</td></tr>
<tr><td><code id="geneNeighborhood+2B2Comics_network-method_+3A_names">names</code></td>
<td>
<p>return names of the neighbors. Defaults to 'FALSE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The neighborhood of the targeted genes.
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Selection)
data(infos)
#Find probesets for EGR1
pbst_EGR1 = infos[infos$hgnc_symbol=="EGR1", "affy_hg_u133_plus_2"]

gene_IDs = infos[match(Selection@name, infos$affy_hg_u133_plus_), "hgnc_symbol"]

data(network)
#A nv value can chosen using the cutoff function
nv=.11 
EGR1&lt;-which(is.element(Selection@name,pbst_EGR1))
P&lt;-position(network,nv=nv)

geneNeighborhood(network,targets=EGR1,nv=nv,ini=P,
label_v=gene_IDs)
          
</code></pre>

<hr>
<h2 id='geneSelection'>Methods for selecting genes</h2><span id='topic+geneSelection'></span><span id='topic+genePeakSelection'></span><span id='topic+genePeakSelection-methods'></span><span id='topic+geneSelection-methods'></span><span id='topic+geneSelection+2Comics_array+2Cnumeric-method'></span><span id='topic+geneSelection+2Comics_array+2Comics_array+2Cnumeric-method'></span><span id='topic+geneSelection+2Clist+2Clist+2Cnumeric-method'></span><span id='topic+genePeakSelection+2Comics_array+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Selection of differentially expressed genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'omics_array,omics_array,numeric'
geneSelection(
  x,
  y,
  tot.number,
  data_log = TRUE,
  wanted.patterns = NULL,
  forbidden.patterns = NULL,
  peak = NULL,
  alpha = 0.05,
  Design = NULL,
  lfc = 0
)

## S4 method for signature 'list,list,numeric'
geneSelection(
  x,
  y,
  tot.number,
  data_log = TRUE,
  alpha = 0.05,
  cont = FALSE,
  lfc = 0,
  f.asso = NULL,
  return.diff = FALSE
)

## S4 method for signature 'omics_array,numeric'
genePeakSelection(
  x,
  peak,
  y = NULL,
  data_log = TRUE,
  durPeak = c(1, 1),
  abs_val = TRUE,
  alpha_diff = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geneSelection_+3A_x">x</code></td>
<td>
<p>either a omics_array object or a list of omics_array objects. In
the first case, the omics_array object represents the stimulated
measurements. In the second case, the control unstimulated data (if present)
should be the first element of the list.</p>
</td></tr>
<tr><td><code id="geneSelection_+3A_y">y</code></td>
<td>
<p>either a omics_array object or a list of strings. In the first
case, the omics_array object represents the stimulated measurements. In the
second case, the list is the way to specify the contrast: </p>

<dl>
<dt>First element:</dt><dd><p> condition, condition&amp;time or pattern. The condition
specification is used when the overall is to compare two conditions.  The
condition&amp;time specification is used when comparing two conditions at two
precise time points. The pattern specification allows to decide which time
point should be differentially expressed.</p>
</dd> <dt>Second element:</dt><dd><p>a vector
of length 2. The two conditions which should be compared. If a condition is
used as control, it should be the first element of the vector. However, if
this control is not measured throught time, the option cont=TRUE should be
used.</p>
</dd> <dt>Third element:</dt><dd><p>depends on the first element.  It is no needed
if condition has been specified.  If condition&amp;time has been specified, then
this is a vector containing the time point at which the comparison should be
done. If pattern has been specified, then this is a vector of 0 and 1 of
length T, where T is the number of time points. The time points with desired
differential expression are provided with 1.  </p>
</dd></dl>
</td></tr>
<tr><td><code id="geneSelection_+3A_tot.number">tot.number</code></td>
<td>
<p>an integer. The number of selected genes. If tot.number &lt;0
all differentially genes are selected. If tot.number &gt; 1, tot.number is the
maximum of diffenrtially genes that will be selected.  If 0&lt;tot.number&lt;1,
tot.number represents the proportion of diffenrentially genes that are
selected.</p>
</td></tr>
<tr><td><code id="geneSelection_+3A_data_log">data_log</code></td>
<td>
<p>logical (default to TRUE); should data be logged ?</p>
</td></tr>
<tr><td><code id="geneSelection_+3A_wanted.patterns">wanted.patterns</code></td>
<td>
<p>a matrix with wanted patterns [only for geneSelection].</p>
</td></tr>
<tr><td><code id="geneSelection_+3A_forbidden.patterns">forbidden.patterns</code></td>
<td>
<p>a matrix with forbidden patterns [only for geneSelection].</p>
</td></tr>
<tr><td><code id="geneSelection_+3A_peak">peak</code></td>
<td>
<p>interger. At which time points measurements should the genes be
selected [optionnal for geneSelection].</p>
</td></tr>
<tr><td><code id="geneSelection_+3A_alpha">alpha</code></td>
<td>
<p>float; the risk level. Default to 'alpha=0.05'</p>
</td></tr>
<tr><td><code id="geneSelection_+3A_design">Design</code></td>
<td>
<p>the design matrix of the experiment. Defaults to 'NULL'.</p>
</td></tr>
<tr><td><code id="geneSelection_+3A_lfc">lfc</code></td>
<td>
<p>log fold change value used in limma's 'topTable'. Defaults to 0.</p>
</td></tr>
<tr><td><code id="geneSelection_+3A_cont">cont</code></td>
<td>
<p>use contrasts. Defaults to 'FALSE'.</p>
</td></tr>
<tr><td><code id="geneSelection_+3A_f.asso">f.asso</code></td>
<td>
<p>function used to assess the association between the genes. 
The default value 'NULL' implies the use of the usual 'mean' function.</p>
</td></tr>
<tr><td><code id="geneSelection_+3A_return.diff">return.diff</code></td>
<td>
<p>[FALSE] if TRUE then the function returns the stimulated expression of the differentially expressed genes</p>
</td></tr>
<tr><td><code id="geneSelection_+3A_durpeak">durPeak</code></td>
<td>
<p>vector of size 2 (default to c(1,1)) ; the first elements gives the length of the peak at
the left, the second at the right. [only for genePeakSelection]</p>
</td></tr>
<tr><td><code id="geneSelection_+3A_abs_val">abs_val</code></td>
<td>
<p>logical (default to TRUE) ; should genes be selected on the
basis of their absolute value expression ? [only for genePeakSelection]</p>
</td></tr>
<tr><td><code id="geneSelection_+3A_alpha_diff">alpha_diff</code></td>
<td>
<p>float; the risk level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A omics_array object.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand , Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  if(require(CascadeData)){
	data(micro_US)
	micro_US&lt;-as.omics_array(micro_US,time=c(60,90,210,390),subject=6)
	data(micro_S)
	micro_S&lt;-as.omics_array(micro_S,time=c(60,90,210,390),subject=6)

  #Basically, to find the 50 more significant expressed genes you will use:
  Selection_1&lt;-geneSelection(x=micro_S,y=micro_US,
  tot.number=50,data_log=TRUE)
  summary(Selection_1)
  
  #If we want to select genes that are differentially 
  #at time t60 or t90 :
  Selection_2&lt;-geneSelection(x=micro_S,y=micro_US,tot.number=30,
  wanted.patterns=
  rbind(c(0,1,0,0),c(1,0,0,0),c(1,1,0,0)))
  summary(Selection_2)

  #To select genes that have a differential maximum of expression at a specific time point.
  
  Selection_3&lt;-genePeakSelection(x=micro_S,y=micro_US,peak=1,
  abs_val=FALSE,alpha_diff=0.01)
  summary(Selection_3)
  }

  if(require(CascadeData)){
data(micro_US)
micro_US&lt;-as.omics_array(micro_US,time=c(60,90,210,390),subject=6)
data(micro_S)
micro_S&lt;-as.omics_array(micro_S,time=c(60,90,210,390),subject=6)
#Genes with differential expression at t1
Selection1&lt;-geneSelection(x=micro_S,y=micro_US,20,wanted.patterns= rbind(c(1,0,0,0)))
#Genes with differential expression at t2
Selection2&lt;-geneSelection(x=micro_S,y=micro_US,20,wanted.patterns= rbind(c(0,1,0,0)))
#Genes with differential expression at t3
Selection3&lt;-geneSelection(x=micro_S,y=micro_US,20,wanted.patterns= rbind(c(0,0,1,0)))
#Genes with differential expression at t4
Selection4&lt;-geneSelection(x=micro_S,y=micro_US,20,wanted.patterns= rbind(c(0,0,0,1)))
#Genes with global differential expression 
Selection5&lt;-geneSelection(x=micro_S,y=micro_US,20)

#We then merge these selections:
Selection&lt;-unionOmics(list(Selection1,Selection2,Selection3,Selection4,Selection5))
print(Selection)

#Prints the correlation graphics Figure 4:
summary(Selection,3)

##Uncomment this code to retrieve geneids.
#library(org.Hs.eg.db)
#
#ff&lt;-function(x){substr(x, 1, nchar(x)-3)}
#ff&lt;-Vectorize(ff)
#
##Here is the function to transform the probeset names to gene ID.
#
#library("hgu133plus2.db")
#
#probe_to_id&lt;-function(n){  
#x &lt;- hgu133plus2SYMBOL
#mp&lt;-mappedkeys(x)
#xx &lt;- unlist(as.list(x[mp]))
#genes_all = xx[(n)]
#genes_all[is.na(genes_all)]&lt;-"unknown"
#return(genes_all)
#}
#Selection@name&lt;-probe_to_id(Selection@name)
  }
	

</code></pre>

<hr>
<h2 id='head+2Comics_array-method'>Overview of a omics_array object</h2><span id='topic+head+2Comics_array-method'></span><span id='topic+methods'></span><span id='topic+head-methods'></span><span id='topic+head+2CANY-method'></span>

<h3>Description</h3>

<p>Overview of a omics_array object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'omics_array'
head(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head+2B2Comics_array-method_+3A_x">x</code></td>
<td>
<p>an object of class 'omics_array'.</p>
</td></tr>
<tr><td><code id="head+2B2Comics_array-method_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>list(&quot;signature(x = \&quot;ANY\&quot;)&quot;)</dt><dd><p> Gives an overview. </p>
</dd>
<dt>list(&quot;signature(x = \&quot;omics_array\&quot;)&quot;)</dt><dd><p> Gives an overview. </p>
</dd> </dl>



<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 if(require(CascadeData)){
	data(micro_US)
	micro_US&lt;-as.omics_array(micro_US,time=c(60,90,210,390),subject=6)
	head(micro_US)
	}

</code></pre>

<hr>
<h2 id='IndicFinit'>Create initial F matrices using specific intergroup actions for network
inference.</h2><span id='topic+IndicFinit'></span>

<h3>Description</h3>

<p>This is an helper function to create initial values F matrices for networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IndicFinit(sqF, ngrp, Indic, low.trig = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IndicFinit_+3A_sqf">sqF</code></td>
<td>
<p>Size of an F cell</p>
</td></tr>
<tr><td><code id="IndicFinit_+3A_ngrp">ngrp</code></td>
<td>
<p>Number of groups</p>
</td></tr>
<tr><td><code id="IndicFinit_+3A_indic">Indic</code></td>
<td>
<p>Matrix to specify where there is an interaction from one group
to another</p>
</td></tr>
<tr><td><code id="IndicFinit_+3A_low.trig">low.trig</code></td>
<td>
<p>Fill the lower trigonal matrices with ones</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of size (sqF, sqF, ngrp).
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
IndicFinit(3, 2, matrix(1,2,2)-diag(2))

</code></pre>

<hr>
<h2 id='IndicFshape'>Create F matrices using specific intergroup actions for network inference.</h2><span id='topic+IndicFshape'></span>

<h3>Description</h3>

<p>This is an helper function to create values F matrices using specific
intergroup actions for network inference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IndicFshape(sqF, ngrp, Indic)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IndicFshape_+3A_sqf">sqF</code></td>
<td>
<p>Size of an F cell</p>
</td></tr>
<tr><td><code id="IndicFshape_+3A_ngrp">ngrp</code></td>
<td>
<p>Number of groups</p>
</td></tr>
<tr><td><code id="IndicFshape_+3A_indic">Indic</code></td>
<td>
<p>Matrix to specify where there is an interaction from one group
to another</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of size (sqF, sqF, ngrp).
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
IndicFshape(3, 2, matrix(1,2,2)-diag(2))

</code></pre>

<hr>
<h2 id='inference'>Reverse-engineer the network</h2><span id='topic+inference'></span><span id='topic+inference-methods'></span><span id='topic+inference+2Comics_array-method'></span>

<h3>Description</h3>

<p>Reverse-engineer the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'omics_array'
inference(
  M,
  tour.max = 30,
  g = function(x) {
     1/x
 },
  conv = 0.001,
  cv.subjects = TRUE,
  nb.folds = NULL,
  eps = 10^-5,
  type.inf = "iterative",
  Fshape = NULL,
  Finit = NULL,
  Omega = NULL,
  fitfun = "LASSO",
  use.Gram = TRUE,
  error.stabsel = 0.05,
  pi_thr.stabsel = 0.6,
  priors = NULL,
  mc.cores = getOption("mc.cores", 2L),
  intercept.stabpath = TRUE,
  steps.seq = 0.95,
  limselect = 0.95,
  use.parallel = TRUE,
  verbose = TRUE,
  show.error.messages = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inference_+3A_m">M</code></td>
<td>
<p>a omics_array object.</p>
</td></tr>
<tr><td><code id="inference_+3A_tour.max">tour.max</code></td>
<td>
<p>[30] tour.max + 1 = maximal number of steps.</p>
</td></tr>
<tr><td><code id="inference_+3A_g">g</code></td>
<td>
<p>After each step, the new solution is choosen as (the
old solution + g(x) * the new solution)/(1+g(x)) where x is the number of
steps. Defaults to 'g=function(x) 1/x'</p>
</td></tr>
<tr><td><code id="inference_+3A_conv">conv</code></td>
<td>
<p>[0.001] Convergence criterion.</p>
</td></tr>
<tr><td><code id="inference_+3A_cv.subjects">cv.subjects</code></td>
<td>
<p>[TRUE] Subjectwise cross validation: should the cross validation be done by removing the subject one by one?</p>
</td></tr>
<tr><td><code id="inference_+3A_nb.folds">nb.folds</code></td>
<td>
<p>[NULL] Relevant only if no subjectwise cross validation (i.e. cv.subjects=FALSE). The number of folds in cross validation.</p>
</td></tr>
<tr><td><code id="inference_+3A_eps">eps</code></td>
<td>
<p>[10^-5] Threshold for rounding coefficients to 0 (i.e. machine zero).</p>
</td></tr>
<tr><td><code id="inference_+3A_type.inf">type.inf</code></td>
<td>
<p>[&quot;iterative&quot;] &quot;iterative&quot; or &quot;noniterative&quot; : should the algorithm be computed iteratively or only for one step? For highly homogeneous clusters, the &quot;noniterative&quot; option is suffisant.</p>
</td></tr>
<tr><td><code id="inference_+3A_fshape">Fshape</code></td>
<td>
<p>[NULL] Shape of the F matrix.</p>
</td></tr>
<tr><td><code id="inference_+3A_finit">Finit</code></td>
<td>
<p>[NULL] Init values of the F matrix.</p>
</td></tr>
<tr><td><code id="inference_+3A_omega">Omega</code></td>
<td>
<p>[NULL] Init values for the Omega matrix.</p>
</td></tr>
<tr><td><code id="inference_+3A_fitfun">fitfun</code></td>
<td>
<p>[&quot;LASSO&quot;] Function to infer the Omega matrix at each step.</p>
</td></tr>
<tr><td><code id="inference_+3A_use.gram">use.Gram</code></td>
<td>
<p>[TRUE] Optional parameter for the lasso in the 'lars' package.</p>
</td></tr>
<tr><td><code id="inference_+3A_error.stabsel">error.stabsel</code></td>
<td>
<p>[0.05] Optional parameter for the stability selection algorithm in the 'c060' package.</p>
</td></tr>
<tr><td><code id="inference_+3A_pi_thr.stabsel">pi_thr.stabsel</code></td>
<td>
<p>[0.6] Optional parameter for the stability selection algorithm in the 'c060' package.</p>
</td></tr>
<tr><td><code id="inference_+3A_priors">priors</code></td>
<td>
<p>[NULL] A priori weights for
the links between the actors. 0 means that an actor is always included in
the predictive model, 1 is a neutral weighting and +infinity that the actor
is never used in the model. For a given predictive model, the weighting
vector is normalized so that its sum is equal to the number of predictors in
the model.</p>
</td></tr>
<tr><td><code id="inference_+3A_mc.cores">mc.cores</code></td>
<td>
<p>[getOption(&quot;mc.cores&quot;, 2L)] Number of cores.</p>
</td></tr>
<tr><td><code id="inference_+3A_intercept.stabpath">intercept.stabpath</code></td>
<td>
<p>[TRUE] Use intercept in stability selection models?</p>
</td></tr>
<tr><td><code id="inference_+3A_steps.seq">steps.seq</code></td>
<td>
<p>[.95] Optional parameter for the SelectBoost algorithm in the 'SelectBoost' package.</p>
</td></tr>
<tr><td><code id="inference_+3A_limselect">limselect</code></td>
<td>
<p>[.95] Optional parameter for the SelectBoost algorithm in the 'SelectBoost' package.</p>
</td></tr>
<tr><td><code id="inference_+3A_use.parallel">use.parallel</code></td>
<td>
<p>[TRUE] Use parallel computing?</p>
</td></tr>
<tr><td><code id="inference_+3A_verbose">verbose</code></td>
<td>
<p>[TRUE] Info on the completion of the fitting process</p>
</td></tr>
<tr><td><code id="inference_+3A_show.error.messages">show.error.messages</code></td>
<td>
<p>[FALSE] Should the error messages of the Omega estimating function be returned?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fitting built-in fitting functions ('fitfun') provided with the
'Patterns' package are : </p>
 <dl>
<dt>LASSO</dt><dd><p>from the 'lars' package
(default value)</p>
</dd> <dt>LASSO2</dt><dd><p>from the 'glmnet' package</p>
</dd> <dt>SPLS</dt><dd><p>from
the 'spls' package</p>
</dd> <dt>ELASTICNET</dt><dd><p>from the 'elasticnet' package</p>
</dd>
<dt>stability.c060</dt><dd><p>from the 'c060' package implementation of stability
selection</p>
</dd> <dt>stability.c060.weighted</dt><dd><p>a new weighted version of the
'c060' package implementation of stability selection</p>
</dd> <dt>robust</dt><dd><p>lasso
from the 'lars' package with light random Gaussian noise added to the
explanatory variables</p>
</dd> <dt>selectboost.weighted</dt><dd><p>a new weighted version of
the 'selectboost' package implementation of the selectboost algorithm to
look for the more stable links against resampling that takes into account
the correlated structure of the predictors. If no weights are provided,
equal weigths are for all the variables (=non weighted case).</p>
</dd> </dl>

<p>The weights are viewed as a penalty factors in the penalized regression
model: it is a number that multiplies the lambda value in the minimization
problem to allow differential shrinkage, [Friedman et al.
2010](https://web.stanford.edu/~hastie/Papers/glmnet.pdf), equation 1 page
3. If equal to 0, it implies no shrinkage, and that variable is always
included in the model. Default is 1 for all variables. Infinity means that
the variable is excluded from the model. Note that the weights are rescaled
to sum to the number of variables.
</p>


<h3>Value</h3>

<p>A omics_network object.
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#With simulated data, default shaped F matrix and default LASSO from the lars package
#as fitting function
data(M)
infM &lt;- inference(M)
str(infM)
plot(infM, choice="F", nround=0)
plot(infM, choice="F", nround=1)

#With simulated data, cascade network shaped F matrix (1 group per time measurement case) 
#and default LASSO from the lars package as fitting function
infMcasc &lt;- inference(M, Finit=CascadeFinit(4,4), Fshape=CascadeFshape(4,4))
str(infMcasc)
plot(infMcasc, choice="F", nround=0)
plot(infMcasc, choice="F", nround=1)

#With selection of genes from GSE39411
data(Selection)
infSel &lt;- inference(Selection, Finit=CascadeFinit(4,4), Fshape=CascadeFshape(4,4))
str(infSel)
str(infSel)
plot(infSel, choice="F", nround=0)
plot(infSel, choice="F", nround=1)


</code></pre>

<hr>
<h2 id='infos'>Details on some probesets of the affy_hg_u133_plus_2 platform.</h2><span id='topic+infos'></span>

<h3>Description</h3>

<p>Dataset with information on the affy_hg_u133_plus_2 platform such as
probeset name (affy_hg_u133_plus_2), ensembl_gene_id, entrezgene,
hgnc_symbol, chromosome_name, start_position, end_position and band.
</p>


<h3>Format</h3>

<p>The format is: chr &quot;infos&quot;
</p>


<h3>Details</h3>

<p>Data.frame with 8859 rows and 8 variables.
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(infos)

</code></pre>

<hr>
<h2 id='M'>Simulated microarray.</h2><span id='topic+M'></span>

<h3>Description</h3>

<p>Simulated M, microarray.
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(M)
head(M)
str(M)

</code></pre>

<hr>
<h2 id='Net'>Simulated network for examples.</h2><span id='topic+Net'></span>

<h3>Description</h3>

<p>Simulated network.
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Net)
str(Net)

</code></pre>

<hr>
<h2 id='Net_inf_PL'>Reverse-engineered network of the M and Net simulated data.</h2><span id='topic+Net_inf_PL'></span>

<h3>Description</h3>

<p>The reverse-engineered network with the 'Patterns' package using the
fitfun=&quot;LASSO&quot; default function and a cascade network setting.
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Net_inf_PL)
str(Net_inf_PL)

</code></pre>

<hr>
<h2 id='network'>A example of an inferred network (4 groups case).</h2><span id='topic+network'></span>

<h3>Description</h3>

<p>This dataset is a network example with 102 nodes, 4 times and 4 groups.
</p>


<h3>Format</h3>

<p>The format is: chr &quot;network&quot;
</p>


<h3>Details</h3>

<p>A network class object [package &quot;Patterns&quot;] with 6 slots.
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(network)
str(network)
plot(network)

</code></pre>

<hr>
<h2 id='network_random'>Generates a network.</h2><span id='topic+network_random'></span>

<h3>Description</h3>

<p>Generates a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_random(
  nb,
  time_label,
  exp,
  init,
  regul,
  min_expr,
  max_expr,
  casc.level
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_random_+3A_nb">nb</code></td>
<td>
<p>Integer. The number of genes.</p>
</td></tr>
<tr><td><code id="network_random_+3A_time_label">time_label</code></td>
<td>
<p>Vector. The time points measurements.</p>
</td></tr>
<tr><td><code id="network_random_+3A_exp">exp</code></td>
<td>
<p>The exponential parameter, as in the barabasi.game function in
igraph package.</p>
</td></tr>
<tr><td><code id="network_random_+3A_init">init</code></td>
<td>
<p>The attractiveness of the vertices with no adjacent edges. See
barabasi.game function.</p>
</td></tr>
<tr><td><code id="network_random_+3A_regul">regul</code></td>
<td>
<p>A vector mapping each gene with its number of regulators.</p>
</td></tr>
<tr><td><code id="network_random_+3A_min_expr">min_expr</code></td>
<td>
<p>Minimum of strength of a non-zero link</p>
</td></tr>
<tr><td><code id="network_random_+3A_max_expr">max_expr</code></td>
<td>
<p>Maximum of strength of a non-zero link</p>
</td></tr>
<tr><td><code id="network_random_+3A_casc.level">casc.level</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A omics_network object.
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
Net&lt;-network_random(
	nb=100,
	time_label=rep(1:4,each=25),
	exp=1,
	init=1,
	regul=round(rexp(100,1))+1,
	min_expr=0.1,
	max_expr=2,
	casc.level=0.4
	)
plot(Net)

</code></pre>

<hr>
<h2 id='network2gp'>A example of an inferred cascade network (2 groups case).</h2><span id='topic+network2gp'></span>

<h3>Description</h3>

<p>This dataset is a cascade network example with 53 nodes, 4 times and 2
groups.
</p>


<h3>Format</h3>

<p>The format is: chr &quot;network2gp&quot;
</p>


<h3>Details</h3>

<p>A network class object [package &quot;Patterns&quot;] with 6 slots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(network2gp)
str(network2gp)
plot(network2gp)

</code></pre>

<hr>
<h2 id='networkCascade'>A example of an inferred cascade network (4 groups case).</h2><span id='topic+networkCascade'></span>

<h3>Description</h3>

<p>This dataset is a cascade network example with 102 nodes, 4 times and 4
groups.
</p>


<h3>Format</h3>

<p>The format is: chr &quot;networkCascade&quot;
</p>


<h3>Details</h3>

<p>A network class object [package &quot;Patterns&quot;] with 6 slots.
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(networkCascade)
str(networkCascade)
plot(networkCascade)

</code></pre>

<hr>
<h2 id='omics_array-class'>Class <code>"omics_array"</code></h2><span id='topic+omics_array-class'></span>

<h3>Description</h3>

<p>The <code>"omics_array"</code> class
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form
<code>new("omics_array", ...)</code>.
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("omics_array")

</code></pre>

<hr>
<h2 id='omics_network-class'>Class <code>"omics_network"</code></h2><span id='topic+omics_network-class'></span>

<h3>Description</h3>

<p>The <code>"omics_network"</code> class
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form
<code>new("omics_network", ...)</code>.
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("omics_network")

</code></pre>

<hr>
<h2 id='omics_predict-class'>Class <code>"omics_predict"</code></h2><span id='topic+omics_predict-class'></span>

<h3>Description</h3>

<p>The <code>"omics_predict"</code> class
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form
<code>new("omics_predict", ...)</code>.
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("omics_predict")

</code></pre>

<hr>
<h2 id='plot-methods'>Plot</h2><span id='topic+plot-methods'></span><span id='topic+plot+2Comics_array+2CANY-method'></span><span id='topic+plot+2Comics_predict+2CANY-method'></span><span id='topic+plot+2Comics_network+2CANY-method'></span>

<h3>Description</h3>

<p>Considering the class of the argument which is passed to plot, the graphical
output differs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'omics_array,ANY'
plot(x, y, ...)

## S4 method for signature 'omics_network,ANY'
plot(
  x,
  y,
  choice = "omics_network",
  nv = 0,
  gr = NULL,
  ini = NULL,
  color.vertex = NULL,
  color.edge = NULL,
  video = TRUE,
  weight.node = NULL,
  ani = FALSE,
  size = c(2000, 1000),
  label_v = 1:dim(x@omics_network)[1],
  horiz = TRUE,
  legend.position = "topleft",
  frame.color = "black",
  label.hub = FALSE,
  nround = 2,
  ani.img.name = "Rplot",
  ani.imgdir = "images",
  ani.htmlfile = "index.html",
  outdir,
  ani.group.legend = "Cluster",
  layout = ini,
  alpha = 1,
  pixmap.color = terrain.colors(20),
  ...
)

## S4 method for signature 'omics_predict,ANY'
plot(
  x,
  time = NULL,
  label_v = NULL,
  frame.color = "white",
  ini = NULL,
  label.hub = FALSE,
  edge.arrow.size = 0.7,
  edge.thickness = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-methods_+3A_x">x</code></td>
<td>
<p>a omics_array object, a omics_network object or a omics_predict object</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_y">y</code></td>
<td>
<p>optional and not used if x is an appropriate structure</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_choice">choice</code></td>
<td>
<p>what graphic should be plotted: either &quot;F&quot;
(for a representation of the matrices F) or &quot;network&quot;.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_nv">nv</code></td>
<td>
<p>the level of cutoff. Defaut to '0'.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_gr">gr</code></td>
<td>
<p>a vector giving the group of each gene</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_ini">ini</code></td>
<td>
<p>using the &ldquo;position&rdquo; function, you can
fix the position of the nodes.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_color.vertex">color.vertex</code></td>
<td>
<p>a vector defining the color of the vertex.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_color.edge">color.edge</code></td>
<td>
<p>color of the edges</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_video">video</code></td>
<td>
<p>if ani is TRUE and video is TRUE, the result of the animation is saved as an animated GIF.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_weight.node">weight.node</code></td>
<td>
<p>nodes weighting. Defaults to 'NULL'.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_ani">ani</code></td>
<td>
<p>animated plot?</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_size">size</code></td>
<td>
<p>vector giving the size of the plot. Default to 'c(2000,1000)'.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_label_v">label_v</code></td>
<td>
<p>vector defining the vertex labels.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_horiz">horiz</code></td>
<td>
<p>landscape? Defaults to 'TRUE'.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_legend.position">legend.position</code></td>
<td>
<p>position of the legend.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_frame.color">frame.color</code></td>
<td>
<p>color of the frames.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_label.hub">label.hub</code></td>
<td>
<p>logical ; if TRUE only the hubs are labeled.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_nround">nround</code></td>
<td>
<p>number of digits to display</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_ani.img.name">ani.img.name</code></td>
<td>
<p>name of image file  for animations</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_ani.imgdir">ani.imgdir</code></td>
<td>
<p>name of the image directory for animations</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_ani.htmlfile">ani.htmlfile</code></td>
<td>
<p>name of the html file for animations</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_outdir">outdir</code></td>
<td>
<p>name of the outdir for animations</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_ani.group.legend">ani.group.legend</code></td>
<td>
<p>legend for animations</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_layout">layout</code></td>
<td>
<p>layout of the graphs</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_alpha">alpha</code></td>
<td>
<p>transparency of the graphs</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_pixmap.color">pixmap.color</code></td>
<td>
<p>color for pixmap graphs</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_time">time</code></td>
<td>
<p>sets the time for plot of the prediction. Defaults to 'NULL'</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_edge.arrow.size">edge.arrow.size</code></td>
<td>
<p>size of the arrows ; default to 0.7.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_edge.thickness">edge.thickness</code></td>
<td>
<p>edge thickness ; default to 1.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>list(&quot;signature(x = \&quot;omics_array\&quot;, y = \&quot;ANY\&quot;,...)&quot;)</dt><dd> 
<dl>
<dt>x</dt><dd><p>a omics_array object</p>
</dd> <dt>list_nv</dt><dd><p>a vector of cutoff at which
the network should be shown</p>
</dd> </dl>
 </dd> <dt>list(&quot;signature(x = \&quot;omics_network\&quot;, y =
\&quot;ANY\&quot;,...)&quot;)</dt><dd>  <dl>
<dt>x</dt><dd><p>a omics_network object</p>
</dd>
<dt>list()</dt><dd><p>Optionnal arguments: </p>
 <dl>
<dt>gr</dt><dd><p>a vector giving the
group of each gene</p>
</dd> <dt>choice</dt><dd><p>what graphic should be plotted: either &quot;F&quot;
(for a representation of the matrices F) or &quot;network&quot;.</p>
</dd> <dt>nv</dt><dd><p>the level
of cutoff. Defaut to 0.</p>
</dd> <dt>ini</dt><dd><p>using the &ldquo;position&rdquo; function, you can
fix the position of the nodes</p>
</dd> <dt>color.vertex</dt><dd><p>a vector defining the
color of the vertex</p>
</dd> <dt>ani</dt><dd><p>vector giving the size of the plot. Default
to c(2000,1000). The animation can only be created in the working directory.
See the help page of the animation method.</p>
</dd> <dt>video</dt><dd><p>if ani is TRUE and
video is TRUE, the animation result is a GIF video</p>
</dd> <dt>label_v</dt><dd><p>vector
defining the vertex labels</p>
</dd> <dt>legend.position</dt><dd><p>position of the legend</p>
</dd>
<dt>frame.color</dt><dd><p>color of the frames</p>
</dd> <dt>label.hub</dt><dd><p>logical ; if TRUE
only the hubs are labeled</p>
</dd> <dt>edge.arrow.size</dt><dd><p>size of the arrows ;
default to 0.7</p>
</dd> <dt>edge.thickness</dt><dd><p>edge thickness ; default to 1.</p>
</dd> </dl>
 </dd></dl>
</dd>
<dt>list(&quot;signature(x = \&quot;omics_predict\&quot;, y = \&quot;ANY\&quot;,...)&quot;)</dt><dd> 
<dl>
<dt>x</dt><dd><p>a omics_predict object</p>
</dd> <dt>list()</dt><dd><p>Optional arguments: see plot
for omics_network</p>
</dd> </dl>
</dd> </dl>



<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require(CascadeData)){
data(micro_US, package="CascadeData")
micro_US&lt;-as.omics_array(micro_US[1:100,],time=c(60,90,210,390),subject=6)
plot(micro_US)
}

</code></pre>

<hr>
<h2 id='plotF'>Plot functions for the F matrices.</h2><span id='topic+plotF'></span>

<h3>Description</h3>

<p>The graphical output will differ according to the option used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotF(x, choice = "Fshape", nround = 2, pixmap.color = terrain.colors(20))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotF_+3A_x">x</code></td>
<td>
<p>The F matrix.</p>
</td></tr>
<tr><td><code id="plotF_+3A_choice">choice</code></td>
<td>
<p>A string: either &quot;F&quot;, &quot;Fpixmap&quot;, &quot;Fshape&quot;, or &quot;Fshapepixmap&quot;</p>
</td></tr>
<tr><td><code id="plotF_+3A_nround">nround</code></td>
<td>
<p>An integer. For numerical F matrices only. The number of
decimal numbers to display.</p>
</td></tr>
<tr><td><code id="plotF_+3A_pixmap.color">pixmap.color</code></td>
<td>
<p>For pixmap plots.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#For numerical/inferred F matrices
plotF(CascadeFinit(4,4),choice="F", nround=1)
plotF(CascadeFinit(4,4),choice="Fpixmap")

#For theoritical F matrices
plotF(CascadeFshape(4,4),choice="Fshape")
plotF(CascadeFshape(4,4),choice="Fshapepixmap")

</code></pre>

<hr>
<h2 id='position-methods'>Returns the position of edges in the network</h2><span id='topic+position-methods'></span><span id='topic+position'></span><span id='topic+position+2Comics_network-method'></span>

<h3>Description</h3>

<p>Returns the position of edges in the network
Retrieve network position for consistent plotting.
Utility function to plot networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'omics_network'
position(net, nv = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="position-methods_+3A_net">net</code></td>
<td>
<p>a omics_network object</p>
</td></tr>
<tr><td><code id="position-methods_+3A_nv">nv</code></td>
<td>
<p>the level of cutoff at which the analysis should be done</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with as many rows as the number of edges of the network and three
columns (name, xcoord, ycoord).
</p>


<h3>Methods</h3>


<dl>
<dt>list(&quot;signature(net = \&quot;omics_network\&quot;)&quot;)</dt><dd><p> Returns a matrix with the
position of the node. This matrix can then be used as an argument in the
plot function. </p>
</dd> </dl>



<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(network)
position(network)

</code></pre>

<hr>
<h2 id='predict+2Comics_array-method'>Methods for Function <code>predict</code></h2><span id='topic+predict+2Comics_array-method'></span><span id='topic+predict'></span><span id='topic+predict-methods'></span><span id='topic+predict+2CANY-method'></span>

<h3>Description</h3>

<p>Prediction of the gene expressions after a knock-out experience for cascade
networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'omics_array'
predict(
  object,
  Omega,
  act_time_group = NULL,
  nv = 0,
  targets = NULL,
  adapt = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict+2B2Comics_array-method_+3A_object">object</code></td>
<td>
<p>a omics_array object.</p>
</td></tr>
<tr><td><code id="predict+2B2Comics_array-method_+3A_omega">Omega</code></td>
<td>
<p>a omics_network object.</p>
</td></tr>
<tr><td><code id="predict+2B2Comics_array-method_+3A_act_time_group">act_time_group</code></td>
<td>
<p>[NULL] vector; at which time the groups (defined by sort(unique(group))) are activated ?</p>
</td></tr>
<tr><td><code id="predict+2B2Comics_array-method_+3A_nv">nv</code></td>
<td>
<p>[=0] numeric ; the level of the cutoff</p>
</td></tr>
<tr><td><code id="predict+2B2Comics_array-method_+3A_targets">targets</code></td>
<td>
<p>[NULL] vector ; which genes are knocked out ?</p>
</td></tr>
<tr><td><code id="predict+2B2Comics_array-method_+3A_adapt">adapt</code></td>
<td>
<p>[TRUE] boolean; do not raise an error if used with vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot of prediction of knock down experiments (i.e. targets&lt;&gt;NULL) is
still in beta testing for the moment.
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(Selection)
data(infos)
pbst_NR4A1 = infos[infos$hgnc_symbol=="NR4A1", "affy_hg_u133_plus_2"]
pbst_EGR1 = infos[infos$hgnc_symbol=="EGR1", "affy_hg_u133_plus_2"]
gene_IDs = infos[match(Selection@name, infos$affy_hg_u133_plus_), "hgnc_symbol"]

data(networkCascade)
#A nv value can chosen using the cutoff function
nv = .02
NR4A1&lt;-which(is.element(Selection@name,pbst_NR4A1))
EGR1&lt;-which(is.element(Selection@name,pbst_EGR1))
P&lt;-position(networkCascade,nv=nv)

#We predict gene expression modulations within the network if NR4A1 is experimentaly knocked-out. 
prediction_ko5_NR4A1&lt;-predict(Selection,networkCascade,nv=nv,targets=NR4A1,act_time_group=1:4)

#Then we plot the results. Here for example we see changes at time points t2, t3 ans t4:
plot(prediction_ko5_NR4A1,time=2:4,ini=P,label_v=gene_IDs)

#We predict gene expression modulations within the network if EGR1 is experimentaly knocked-out. 
prediction_ko5_EGR1&lt;-predict(Selection,networkCascade,nv=nv,targets=EGR1,act_time_group=1:4)

#Then we plot the results. Here for example we see changes at time point t2, t3 ans t4:
plot(prediction_ko5_EGR1,time=2:4,ini=P,label_v=gene_IDs)


</code></pre>

<hr>
<h2 id='probeMerge+2Comics_array-method'>Function to merge probesets</h2><span id='topic+probeMerge+2Comics_array-method'></span><span id='topic+probeMerge'></span>

<h3>Description</h3>

<p>Used to collapse probesets using the collapseRows function of the WGCNA
package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'omics_array'
probeMerge(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probeMerge+2B2Comics_array-method_+3A_x">x</code></td>
<td>
<p>omicsarray</p>
</td></tr>
<tr><td><code id="probeMerge+2B2Comics_array-method_+3A_...">...</code></td>
<td>
<p>Additionnal parameters to the collapseRows function of the
WGCNA package</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Formal class 'omics_array' [package &quot;Patterns&quot;] with 7 slots
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require(CascadeData)){
data(micro_S)
D&lt;-as.omics_array(micro_S[1:2000,],1:4,6)
D@gene_ID&lt;-jetset::scores.hgu133plus2[D@name,"EntrezID"]
PM &lt;- probeMerge(D)
}

</code></pre>

<hr>
<h2 id='replaceBand'>Replace matrix values by band.</h2><span id='topic+replaceBand'></span>

<h3>Description</h3>

<p>F matrices utility function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replaceBand(a, b, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replaceBand_+3A_a">a</code></td>
<td>
<p>The matrix to be replaced</p>
</td></tr>
<tr><td><code id="replaceBand_+3A_b">b</code></td>
<td>
<p>The matrix with the replacement values</p>
</td></tr>
<tr><td><code id="replaceBand_+3A_k">k</code></td>
<td>
<p>The extend of the replacement: 0 (diagonal only), 1 (diagonal and
first extra diagonal), in general an entry is replaced if abs(row(a) -
col(a)) &lt;= k</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (same size as a)
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a=matrix(1:9,3,3)
b=matrix(0,3,3)
replaceBand(a,b,0)
replaceBand(a,b,1)
replaceBand(a,b,2)

</code></pre>

<hr>
<h2 id='replaceDown'>Replace matrix values triangular lower part and by band for the upper part.</h2><span id='topic+replaceDown'></span>

<h3>Description</h3>

<p>F matrices utility function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replaceDown(a, b, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replaceDown_+3A_a">a</code></td>
<td>
<p>The matrix to be replaced</p>
</td></tr>
<tr><td><code id="replaceDown_+3A_b">b</code></td>
<td>
<p>The matrix with the replacement values</p>
</td></tr>
<tr><td><code id="replaceDown_+3A_k">k</code></td>
<td>
<p>The extend of the replacement: 0 (lower part and diagonal only), 1
(lower part and first extra diagonal), in general an entry is replaced if
-(row(a) - col(a)) &lt;= k</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (same size as a)
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a=matrix(1:9,3,3)
b=matrix(1,3,3)
replaceDown(a,b,0)
replaceDown(a,b,1)
replaceDown(a,b,2)

</code></pre>

<hr>
<h2 id='replaceUp'>Replace matrix values triangular upper part and by band for the lower part.</h2><span id='topic+replaceUp'></span>

<h3>Description</h3>

<p>F matrices utility function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replaceUp(a, b, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replaceUp_+3A_a">a</code></td>
<td>
<p>The matrix to be replaced</p>
</td></tr>
<tr><td><code id="replaceUp_+3A_b">b</code></td>
<td>
<p>The matrix with the replacement values</p>
</td></tr>
<tr><td><code id="replaceUp_+3A_k">k</code></td>
<td>
<p>The extend of the replacement: 0 (upper part only), 1 (upper part
and first extra diagonal), in general an entry is replaced if (row(a) -
col(a)) &lt;= k</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (same size as a)
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a=matrix(1:9,3,3)
b=matrix(1,3,3)
replaceUp(a,b,0)
replaceUp(a,b,1)
replaceUp(a,b,2)

</code></pre>

<hr>
<h2 id='Selection'>Selection of genes.</h2><span id='topic+Selection'></span>

<h3>Description</h3>

<p>20 (at most) genes with differential expression at t1, 20 (at most) genes
with differential expression at t2, 20 (at most) genes with differential
expression at t3, 20 (at most) genes with differential expression at t4 et
20 (at most) genes with global differential expression were selected.
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Selection)
head(Selection)
summary(Selection,3)

</code></pre>

<hr>
<h2 id='show-methods'><code>Show</code> methods</h2><span id='topic+show-methods'></span><span id='topic+show+2CANY-method'></span><span id='topic+show+2Comics_array-method'></span><span id='topic+show+2Comics_network-method'></span>

<h3>Description</h3>

<p>Methods for generic function <code>show</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'omics_array'
show(object)

## S4 method for signature 'omics_network'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show-methods_+3A_object">object</code></td>
<td>
<p>an object of class omics-array or omics_network</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>list(&quot;signature(object = \&quot;ANY\&quot;)&quot;)</dt><dd> </dd>
<dt>list(&quot;signature(object = \&quot;omics_array\&quot;)&quot;)</dt><dd><p> Print an object of class omics_array </p>
</dd>
<dt>list(&quot;signature(object = \&quot;omics_network\&quot;)&quot;)</dt><dd><p> Print an object of class omics_network </p>
</dd> 
</dl>



<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>

<hr>
<h2 id='summary-methods'><code>Summary</code> methods</h2><span id='topic+summary-methods'></span><span id='topic+summary+2CANY-method'></span><span id='topic+summary+2Comics_array-method'></span>

<h3>Description</h3>

<p>Methods for function <code>summary</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'omics_array'
summary(object, nb.graph = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary-methods_+3A_object">object</code></td>
<td>
<p>an object of class omics-array</p>
</td></tr>
<tr><td><code id="summary-methods_+3A_nb.graph">nb.graph</code></td>
<td>
<p>(optionnal) choose the graph to plot. Displays all graphs by default.</p>
</td></tr>
<tr><td><code id="summary-methods_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>list(&quot;signature(object = \&quot;ANY\&quot;)&quot;)</dt><dd> 
</dd>
<dt>list(&quot;signature(object = \&quot;omics_array\&quot;)&quot;)</dt><dd> 
<p>method here~~ </p>
</dd> </dl>



<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>

<hr>
<h2 id='unionOmics-methods'>Makes the union between two omics_array objects.</h2><span id='topic+unionOmics-methods'></span><span id='topic+unionOmics'></span><span id='topic+unionOmics+2Comics_array+2Comics_array-method'></span><span id='topic+unionOmics+2Clist+2CANY-method'></span>

<h3>Description</h3>

<p>Makes the union between two omics_array objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'omics_array,omics_array'
unionOmics(M1, M2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unionOmics-methods_+3A_m1">M1</code></td>
<td>
<p>a omics-array or a list of omics-arrays</p>
</td></tr>
<tr><td><code id="unionOmics-methods_+3A_m2">M2</code></td>
<td>
<p>a omics-array or nothing if M1 is a list of omics-arrays</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>list(&quot;signature(M1 = \&quot;omics_array\&quot;, M2 = \&quot;omics_array\&quot;)&quot;)</dt><dd>
<p>Returns a omics_array object which is the union of M1 and M2.  </p>
</dd>
<dt>list(&quot;signature(M1 = \&quot;list\&quot;, M2 = \&quot;ANY\&quot;)&quot;)</dt><dd><p> Returns a omics_array
object which is the union of the elements of M1.  </p>
</dd> </dl>



<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require(CascadeData)){
data(micro_S, package="CascadeData")
#Create another omicsarray object with 100 genes
Mbis&lt;-M&lt;-as.omics_array(micro_S[1:100,],1:4,6)
#Rename the 100 genes
Mbis@name&lt;-paste(M@name,"bis")
rownames(Mbis@omicsarray) &lt;- Mbis@name
#Union (merge without duplicated names) of the two omicsarrays. 
str(unionOmics(M,Mbis))
}

</code></pre>

<hr>
<h2 id='unsupervised_clustering_auto_m_c+2Comics_array-method'>Cluster a omics_array object: determine optimal fuzzification parameter and
number of clusters.</h2><span id='topic+unsupervised_clustering_auto_m_c+2Comics_array-method'></span><span id='topic+unsupervised_clustering_auto_m_c'></span>

<h3>Description</h3>

<p>Based on soft clustering performed by the Mfuzz package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'omics_array'
unsupervised_clustering_auto_m_c(
  M1,
  clust = NULL,
  mestim = NULL,
  M2 = NULL,
  data_log = TRUE,
  screen = NULL,
  crange = NULL,
  repeats = NULL,
  cselect = TRUE,
  dminimum = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unsupervised_clustering_auto_m_c+2B2Comics_array-method_+3A_m1">M1</code></td>
<td>
<p>Object of omics_array class.</p>
</td></tr>
<tr><td><code id="unsupervised_clustering_auto_m_c+2B2Comics_array-method_+3A_clust">clust</code></td>
<td>
<p>[NULL] Number of clusters.</p>
</td></tr>
<tr><td><code id="unsupervised_clustering_auto_m_c+2B2Comics_array-method_+3A_mestim">mestim</code></td>
<td>
<p>[NULL] Fuzzification parameter.</p>
</td></tr>
<tr><td><code id="unsupervised_clustering_auto_m_c+2B2Comics_array-method_+3A_m2">M2</code></td>
<td>
<p>[NULL] Object of omics_array class,</p>
</td></tr>
<tr><td><code id="unsupervised_clustering_auto_m_c+2B2Comics_array-method_+3A_data_log">data_log</code></td>
<td>
<p>[TRUE] Should data be logged?</p>
</td></tr>
<tr><td><code id="unsupervised_clustering_auto_m_c+2B2Comics_array-method_+3A_screen">screen</code></td>
<td>
<p>[NULL] Specify 'screen' parameter.</p>
</td></tr>
<tr><td><code id="unsupervised_clustering_auto_m_c+2B2Comics_array-method_+3A_crange">crange</code></td>
<td>
<p>[NULL] Specify 'crange' parameter.</p>
</td></tr>
<tr><td><code id="unsupervised_clustering_auto_m_c+2B2Comics_array-method_+3A_repeats">repeats</code></td>
<td>
<p>[NULL] Specify 'repeats' parameter.</p>
</td></tr>
<tr><td><code id="unsupervised_clustering_auto_m_c+2B2Comics_array-method_+3A_cselect">cselect</code></td>
<td>
<p>[TRUE] Estimate 'cselect' parameter.</p>
</td></tr>
<tr><td><code id="unsupervised_clustering_auto_m_c+2B2Comics_array-method_+3A_dminimum">dminimum</code></td>
<td>
<p>[FALSE] Estimate 'dminimum' parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>m</code></td>
<td>
<p>Estimate of the optimal fuzzification parameter.</p>
</td></tr>
<tr><td><code>c</code></td>
<td>
<p>Estimate of the optimal number of clusters.</p>
</td></tr> <tr><td><code>csearch</code></td>
<td>
<p>More
result from the cselection function of the Mfuzz package</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require(CascadeData)){
data(micro_S, package="CascadeData")
M&lt;-as.omics_array(micro_S[1:100,],1:4,6)
mc&lt;-unsupervised_clustering_auto_m_c(M)
}

</code></pre>

<hr>
<h2 id='unsupervised_clustering+2Comics_array+2Cnumeric+2Cnumeric-method'>Cluster a omics_array object: performs the clustering.</h2><span id='topic+unsupervised_clustering+2Comics_array+2Cnumeric+2Cnumeric-method'></span><span id='topic+unsupervised_clustering'></span>

<h3>Description</h3>

<p>Based on soft clustering performed by the Mfuzz package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'omics_array,numeric,numeric'
unsupervised_clustering(
  M1,
  clust,
  mestim,
  M2 = NULL,
  data_log = TRUE,
  screen = NULL,
  heatmap = TRUE,
  new.window = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unsupervised_clustering+2B2Comics_array+2B2Cnumeric+2B2Cnumeric-method_+3A_m1">M1</code></td>
<td>
<p>Object of omics_array class.</p>
</td></tr>
<tr><td><code id="unsupervised_clustering+2B2Comics_array+2B2Cnumeric+2B2Cnumeric-method_+3A_clust">clust</code></td>
<td>
<p>Number of clusters.</p>
</td></tr>
<tr><td><code id="unsupervised_clustering+2B2Comics_array+2B2Cnumeric+2B2Cnumeric-method_+3A_mestim">mestim</code></td>
<td>
<p>Fuzzification parameter.</p>
</td></tr>
<tr><td><code id="unsupervised_clustering+2B2Comics_array+2B2Cnumeric+2B2Cnumeric-method_+3A_m2">M2</code></td>
<td>
<p>[NULL] Object of omics_array class,</p>
</td></tr>
<tr><td><code id="unsupervised_clustering+2B2Comics_array+2B2Cnumeric+2B2Cnumeric-method_+3A_data_log">data_log</code></td>
<td>
<p>[TRUE] Should data be logged?</p>
</td></tr>
<tr><td><code id="unsupervised_clustering+2B2Comics_array+2B2Cnumeric+2B2Cnumeric-method_+3A_screen">screen</code></td>
<td>
<p>[NULL] Specify 'mfrow' parameter.</p>
</td></tr>
<tr><td><code id="unsupervised_clustering+2B2Comics_array+2B2Cnumeric+2B2Cnumeric-method_+3A_heatmap">heatmap</code></td>
<td>
<p>[TRUE] Plot heatmaps?</p>
</td></tr>
<tr><td><code id="unsupervised_clustering+2B2Comics_array+2B2Cnumeric+2B2Cnumeric-method_+3A_new.window">new.window</code></td>
<td>
<p>[TRUE] Use new window?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class omics_array with the group slot updated by groups
deduced from the soft clustering result.
</p>


<h3>Author(s)</h3>

<p>Bertrand Frederic, Myriam Maumy-Bertrand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require(CascadeData)){
data(micro_S, package="CascadeData")
M&lt;-as.omics_array(micro_S[51:100,],1:4,6)
mc&lt;-unsupervised_clustering_auto_m_c(M)
MwithGrp=unsupervised_clustering(M, 4, mc$m, screen=NULL, heatmap=FALSE, new.window = FALSE)
# Other options
unsupervised_clustering(M, 4, mc$m, screen=c(2,2), heatmap=TRUE, new.window = FALSE)
# Plot the clusters
plot(MwithGrp)
}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
