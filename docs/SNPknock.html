<!DOCTYPE html><html lang="en-US"><head><title>Help for package SNPknock</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SNPknock}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#assemble_pEmit'><p>Compute the genotype emission distributions based on the fastPHASE HMM</p></a></li>
<li><a href='#assemble_pEmit_phased'><p>Compute the haplotype emission distributions based on the fastPHASE HMM</p></a></li>
<li><a href='#assemble_pInit'><p>Compute the genotype initial distributions based on the fastPHASE HMM</p></a></li>
<li><a href='#assemble_pInit_phased'><p>Compute the haplotype initial distributions based on the fastPHASE HMM</p></a></li>
<li><a href='#assemble_Q'><p>Compute the genotype transition matrices based on the fastPHASE HMM</p></a></li>
<li><a href='#compute_Q1'><p>Compute the haplotype transition matrices based on the fastPHASE HMM</p></a></li>
<li><a href='#GroupGenotypes_wrapper'><p>Wrapper for GroupGenotypes</p></a></li>
<li><a href='#GroupHaplotypes_wrapper'><p>Wrapper for GroupHaplotypes</p></a></li>
<li><a href='#knockoffDMC'><p>Group knockoffs of discrete Markov chains</p></a></li>
<li><a href='#knockoffDMC_wrapper'><p>Wrapper for DMC group knockoffs</p></a></li>
<li><a href='#knockoffGenotypes'><p>Group-knockoffs of unphased genotypes</p></a></li>
<li><a href='#knockoffHaplotypes'><p>Group-knockoffs of phased haplotypes</p></a></li>
<li><a href='#knockoffHMM'><p>Group knockoffs of hidden Markov models</p></a></li>
<li><a href='#knockoffHMM_wrapper'><p>Wrapper for HMM group knockoffs</p></a></li>
<li><a href='#loadEMParameters'><p>Read the files produced by fastPHASE</p></a></li>
<li><a href='#loadHMM'><p>Load HMM parameters fitted by fastPHASE</p></a></li>
<li><a href='#rand_weighted'><p>Random sampling from discrete distribution</p></a></li>
<li><a href='#runFastPhase'><p>Fit an HMM to genetic data using fastPHASE</p></a></li>
<li><a href='#sampleDMC'><p>Sample discrete Markov chains</p></a></li>
<li><a href='#sampleHMM'><p>Sample hidden Markov models</p></a></li>
<li><a href='#writeXtoInp'><p>Convert genotypes X into the fastPHASE input format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Knockoffs for Hidden Markov Models and Genetic Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-04-30</td>
</tr>
<tr>
<td>Description:</td>
<td>Generate knockoffs for genetic data and hidden Markov models.
  For more information, see the website below and the accompanying papers: 
  "Gene hunting with hidden Markov model knockoffs", Sesia et al., Biometrika, 2019, (&lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasy033">doi:10.1093/biomet/asy033</a>&gt;).
  "Multi-resolution localization of causal variants across the genome", Sesia et al., bioRxiv, 2019, (&lt;<a href="https://doi.org/10.1101%2F631390">doi:10.1101/631390</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.13), Rdpack</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat, parallel, doParallel</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppProgress</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://msesia.github.io/snpknock">https://msesia.github.io/snpknock</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/msesia/snpknock/issues">https://github.com/msesia/snpknock/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-05-16 23:35:28 UTC; msesia</td>
</tr>
<tr>
<td>Author:</td>
<td>Matteo Sesia [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matteo Sesia &lt;msesia@stanford.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-05-17 20:50:14 UTC</td>
</tr>
</table>
<hr>
<h2 id='assemble_pEmit'>Compute the genotype emission distributions based on the fastPHASE HMM</h2><span id='topic+assemble_pEmit'></span>

<h3>Description</h3>

<p>Compute the genotype emission distributions based on the fastPHASE HMM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assemble_pEmit(theta)
</code></pre>

<hr>
<h2 id='assemble_pEmit_phased'>Compute the haplotype emission distributions based on the fastPHASE HMM</h2><span id='topic+assemble_pEmit_phased'></span>

<h3>Description</h3>

<p>Compute the haplotype emission distributions based on the fastPHASE HMM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assemble_pEmit_phased(theta)
</code></pre>

<hr>
<h2 id='assemble_pInit'>Compute the genotype initial distributions based on the fastPHASE HMM</h2><span id='topic+assemble_pInit'></span>

<h3>Description</h3>

<p>Compute the genotype initial distributions based on the fastPHASE HMM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assemble_pInit(alpha)
</code></pre>

<hr>
<h2 id='assemble_pInit_phased'>Compute the haplotype initial distributions based on the fastPHASE HMM</h2><span id='topic+assemble_pInit_phased'></span>

<h3>Description</h3>

<p>Compute the haplotype initial distributions based on the fastPHASE HMM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assemble_pInit_phased(alpha)
</code></pre>

<hr>
<h2 id='assemble_Q'>Compute the genotype transition matrices based on the fastPHASE HMM</h2><span id='topic+assemble_Q'></span>

<h3>Description</h3>

<p>Compute the genotype transition matrices based on the fastPHASE HMM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assemble_Q(Q1)
</code></pre>

<hr>
<h2 id='compute_Q1'>Compute the haplotype transition matrices based on the fastPHASE HMM</h2><span id='topic+compute_Q1'></span>

<h3>Description</h3>

<p>Compute the haplotype transition matrices based on the fastPHASE HMM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_Q1(r, alpha)
</code></pre>

<hr>
<h2 id='GroupGenotypes_wrapper'>Wrapper for GroupGenotypes</h2><span id='topic+GroupGenotypes_wrapper'></span>

<h3>Description</h3>

<p>Wrapper for GroupGenotypes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GroupGenotypes_wrapper(X_, r_, alpha_, theta_, groups_, n_, p_, seed_,
  display_progress_)
</code></pre>

<hr>
<h2 id='GroupHaplotypes_wrapper'>Wrapper for GroupHaplotypes</h2><span id='topic+GroupHaplotypes_wrapper'></span>

<h3>Description</h3>

<p>Wrapper for GroupHaplotypes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GroupHaplotypes_wrapper(X_, r_, alpha_, theta_, groups_, n_, p_, seed_,
  display_progress_)
</code></pre>

<hr>
<h2 id='knockoffDMC'>Group knockoffs of discrete Markov chains</h2><span id='topic+knockoffDMC'></span>

<h3>Description</h3>

<p>This function constructs knockoffs of variables distributed as a discrete Markov chain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knockoffDMC(X, pInit, Q, groups = NULL, seed = 123, cluster = NULL,
  display_progress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="knockoffDMC_+3A_x">X</code></td>
<td>
<p>an integer matrix of size n-by-p containing the original variables.</p>
</td></tr>
<tr><td><code id="knockoffDMC_+3A_pinit">pInit</code></td>
<td>
<p>an array of length K, containing the marginal distribution of the states for the first variable.</p>
</td></tr>
<tr><td><code id="knockoffDMC_+3A_q">Q</code></td>
<td>
<p>an array of size (p-1,K,K), containing a list of p-1 transition matrices between the K states of the Markov chain.</p>
</td></tr>
<tr><td><code id="knockoffDMC_+3A_groups">groups</code></td>
<td>
<p>an array of length p, describing the group membership of each variable (default: NULL).</p>
</td></tr>
<tr><td><code id="knockoffDMC_+3A_seed">seed</code></td>
<td>
<p>an integer random seed (default: 123).</p>
</td></tr>
<tr><td><code id="knockoffDMC_+3A_cluster">cluster</code></td>
<td>
<p>a computing cluster object created by <a href="parallel.html#topic+makeCluster">makeCluster</a> (default: NULL).</p>
</td></tr>
<tr><td><code id="knockoffDMC_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to show progress bar (default: FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each element of the matrix X should be an integer value between 0 and K-1.
The transition matrices contained in Q are defined such that <code class="reqn">P[X_{j+1}=k|X_{j}=l]=Q[j,l,k]</code>.
</p>


<h3>Value</h3>

<p>An integer matrix of size n-by-p containing the knockoff variables.
</p>


<h3>References</h3>

<p>Sesia M, Sabatti C, Candès EJ (2019).
&ldquo;Gene hunting with hidden Markov model knockoffs.&rdquo;
<em>Biometrika</em>, <b>106</b>, 1&ndash;18.
doi: <a href="http://doi.org/10.1093/biomet/asy033">10.1093/biomet/asy033</a>.
Sesia M, Katsevich E, Bates S, Candès E, Sabatti C (2019).
&ldquo;Multi-resolution localization of causal variants across the genome.&rdquo;
<em>bioRxiv</em>.
doi: <a href="http://doi.org/10.1101/631390">10.1101/631390</a>.
</p>


<h3>See Also</h3>

<p>Other knockoffs: <code><a href="#topic+knockoffGenotypes">knockoffGenotypes</a></code>,
<code><a href="#topic+knockoffHMM">knockoffHMM</a></code>,
<code><a href="#topic+knockoffHaplotypes">knockoffHaplotypes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data
p = 10; K = 5;
pInit = rep(1/K,K)
Q = array(stats::runif((p-1)*K*K),c(p-1,K,K))
for(j in 1:(p-1)) { Q[j,,] = Q[j,,] / rowSums(Q[j,,]) }
X = sampleDMC(pInit, Q, n=20)
# Generate knockoffs
Xk = knockoffDMC(X, pInit, Q)
# Generate group-knockoffs for groups of size 3
groups = rep(seq(p), each=3, length.out=p)
Xk = knockoffDMC(X, pInit, Q, groups=groups)

</code></pre>

<hr>
<h2 id='knockoffDMC_wrapper'>Wrapper for DMC group knockoffs</h2><span id='topic+knockoffDMC_wrapper'></span>

<h3>Description</h3>

<p>Wrapper for DMC group knockoffs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knockoffDMC_wrapper(X_, pInit_, Q_, n_, p_, K_, seed_, G_,
  display_progress_)
</code></pre>

<hr>
<h2 id='knockoffGenotypes'>Group-knockoffs of unphased genotypes</h2><span id='topic+knockoffGenotypes'></span>

<h3>Description</h3>

<p>This function efficiently constructs group-knockoffs of 0,1,2 variables distributed
according to the Li and Stephens model for unphased genotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knockoffGenotypes(X, r, alpha, theta, groups = NULL, seed = 123,
  cluster = NULL, display_progress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="knockoffGenotypes_+3A_x">X</code></td>
<td>
<p>a 0,1,2 matrix of size n-by-p containing the original variables.</p>
</td></tr>
<tr><td><code id="knockoffGenotypes_+3A_r">r</code></td>
<td>
<p>a vector of length p containing the &quot;r&quot; parameters estimated by fastPHASE.</p>
</td></tr>
<tr><td><code id="knockoffGenotypes_+3A_alpha">alpha</code></td>
<td>
<p>a matrix of size p-by-K containing the &quot;alpha&quot; parameters estimated by fastPHASE.</p>
</td></tr>
<tr><td><code id="knockoffGenotypes_+3A_theta">theta</code></td>
<td>
<p>a matrix of size p-by-K containing the &quot;theta&quot; parameters estimated by fastPHASE.</p>
</td></tr>
<tr><td><code id="knockoffGenotypes_+3A_groups">groups</code></td>
<td>
<p>a vector of length p containing group memberships for each variable. Indices
are assumed to be monotone increasing, starting from 1 (default: NULL).</p>
</td></tr>
<tr><td><code id="knockoffGenotypes_+3A_seed">seed</code></td>
<td>
<p>an integer random seed (default: 123).</p>
</td></tr>
<tr><td><code id="knockoffGenotypes_+3A_cluster">cluster</code></td>
<td>
<p>a computing cluster object created by <a href="parallel.html#topic+makeCluster">makeCluster</a> (default: NULL).</p>
</td></tr>
<tr><td><code id="knockoffGenotypes_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to show progress bar (default: FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generate group-knockoffs of unphased genotypes according to the Li and Stephens HMM.
The required model parameters can be obtained through fastPHASE and loaded with <a href="#topic+loadHMM">loadHMM</a>.
This function is more efficient than <a href="#topic+knockoffHMM">knockoffHMM</a> for haplotype data.
</p>


<h3>Value</h3>

<p>A 0,1,2 matrix of size n-by-p containing the knockoff variables.
</p>


<h3>References</h3>

<p>Sesia M, Katsevich E, Bates S, Candès E, Sabatti C (2019).
&ldquo;Multi-resolution localization of causal variants across the genome.&rdquo;
<em>bioRxiv</em>.
doi: <a href="http://doi.org/10.1101/631390">10.1101/631390</a>.
</p>


<h3>See Also</h3>

<p>Other knockoffs: <code><a href="#topic+knockoffDMC">knockoffDMC</a></code>,
<code><a href="#topic+knockoffHMM">knockoffHMM</a></code>,
<code><a href="#topic+knockoffHaplotypes">knockoffHaplotypes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Problem size
p = 10
n = 100
# Load HMM to generate data
r_file = system.file("extdata", "haplotypes_rhat.txt", package = "SNPknock")
alpha_file = system.file("extdata", "haplotypes_alphahat.txt", package = "SNPknock")
theta_file = system.file("extdata", "haplotypes_thetahat.txt", package = "SNPknock")
char_file = system.file("extdata", "haplotypes_origchars", package = "SNPknock")
hmm.data = loadHMM(r_file, alpha_file, theta_file, char_file, compact=FALSE, phased=FALSE)
hmm.data$Q = hmm.data$Q[1:(p-1),,]
hmm.data$pEmit = hmm.data$pEmit[1:p,,]
# Sample X from this HMM
X = sampleHMM(hmm.data$pInit, hmm.data$Q, hmm.data$pEmit, n=n)
# Load HMM to generate knockoffs
hmm = loadHMM(r_file, alpha_file, theta_file, char_file)
hmm$r = hmm$r[1:p]
hmm$alpha = hmm$alpha[1:p,]
hmm$theta = hmm$theta[1:p,]
# Generate knockoffs
Xk = knockoffGenotypes(X, hmm$r, hmm$alpha, hmm$theta)
# Generate group-knockoffs for groups of size 3
groups = rep(seq(p), each=3, length.out=p)
Xk = knockoffGenotypes(X, hmm$r, hmm$alpha, hmm$theta, groups=groups)
</code></pre>

<hr>
<h2 id='knockoffHaplotypes'>Group-knockoffs of phased haplotypes</h2><span id='topic+knockoffHaplotypes'></span>

<h3>Description</h3>

<p>This function efficiently constructs group-knockoffs of binary variables distributed
according to the Li and Stephens model for phased haplotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knockoffHaplotypes(X, r, alpha, theta, groups = NULL, seed = 123,
  cluster = NULL, display_progress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="knockoffHaplotypes_+3A_x">X</code></td>
<td>
<p>a binary matrix of size n-by-p containing the original variables.</p>
</td></tr>
<tr><td><code id="knockoffHaplotypes_+3A_r">r</code></td>
<td>
<p>a vector of length p containing the &quot;r&quot; parameters estimated by fastPHASE.</p>
</td></tr>
<tr><td><code id="knockoffHaplotypes_+3A_alpha">alpha</code></td>
<td>
<p>a matrix of size p-by-K containing the &quot;alpha&quot; parameters estimated by fastPHASE.</p>
</td></tr>
<tr><td><code id="knockoffHaplotypes_+3A_theta">theta</code></td>
<td>
<p>a matrix of size p-by-K containing the &quot;theta&quot; parameters estimated by fastPHASE.</p>
</td></tr>
<tr><td><code id="knockoffHaplotypes_+3A_groups">groups</code></td>
<td>
<p>a vector of length p containing group memberships for each variable. Indices
are assumed to be monotone increasing, starting from 1 (default: NULL).</p>
</td></tr>
<tr><td><code id="knockoffHaplotypes_+3A_seed">seed</code></td>
<td>
<p>an integer random seed (default: 123).</p>
</td></tr>
<tr><td><code id="knockoffHaplotypes_+3A_cluster">cluster</code></td>
<td>
<p>a computing cluster object created by <a href="parallel.html#topic+makeCluster">makeCluster</a> (default: NULL).</p>
</td></tr>
<tr><td><code id="knockoffHaplotypes_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to show progress bar (default: FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generate group-knockoffs of phased haplotypes according to the Li and Stephens HMM.
The required model parameters can be obtained through fastPHASE and loaded with <a href="#topic+loadHMM">loadHMM</a>.
This function is more efficient than <a href="#topic+knockoffHMM">knockoffHMM</a> for haplotype data.
</p>


<h3>Value</h3>

<p>A binary matrix of size n-by-p containing the knockoff variables.
</p>


<h3>References</h3>

<p>Sesia M, Katsevich E, Bates S, Candès E, Sabatti C (2019).
&ldquo;Multi-resolution localization of causal variants across the genome.&rdquo;
<em>bioRxiv</em>.
doi: <a href="http://doi.org/10.1101/631390">10.1101/631390</a>.
</p>


<h3>See Also</h3>

<p>Other knockoffs: <code><a href="#topic+knockoffDMC">knockoffDMC</a></code>,
<code><a href="#topic+knockoffGenotypes">knockoffGenotypes</a></code>,
<code><a href="#topic+knockoffHMM">knockoffHMM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Problem size
p = 10
n = 100
# Load HMM to generate data
r_file = system.file("extdata", "haplotypes_rhat.txt", package = "SNPknock")
alpha_file = system.file("extdata", "haplotypes_alphahat.txt", package = "SNPknock")
theta_file = system.file("extdata", "haplotypes_thetahat.txt", package = "SNPknock")
char_file = system.file("extdata", "haplotypes_origchars", package = "SNPknock")
hmm.data = loadHMM(r_file, alpha_file, theta_file, char_file, compact=FALSE, phased=TRUE)
hmm.data$Q = hmm.data$Q[1:(p-1),,]
hmm.data$pEmit = hmm.data$pEmit[1:p,,]
# Sample X from this HMM
X = sampleHMM(hmm.data$pInit, hmm.data$Q, hmm.data$pEmit, n=n)
# Load HMM to generate knockoffs
hmm = loadHMM(r_file, alpha_file, theta_file, char_file)
hmm$r = hmm$r[1:p]
hmm$alpha = hmm$alpha[1:p,]
hmm$theta = hmm$theta[1:p,]
# Generate knockoffs
Xk = knockoffHaplotypes(X, hmm$r, hmm$alpha, hmm$theta)
# Generate group-knockoffs for groups of size 3
groups = rep(seq(p), each=3, length.out=p)
Xk = knockoffHaplotypes(X, hmm$r, hmm$alpha, hmm$theta, groups=groups)

</code></pre>

<hr>
<h2 id='knockoffHMM'>Group knockoffs of hidden Markov models</h2><span id='topic+knockoffHMM'></span>

<h3>Description</h3>

<p>This function constructs knockoffs of variables distributed as a hidden Markov model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knockoffHMM(X, pInit, Q, pEmit, groups = NULL, seed = 123,
  cluster = NULL, display_progress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="knockoffHMM_+3A_x">X</code></td>
<td>
<p>an integer matrix of size n-by-p containing the original variables.</p>
</td></tr>
<tr><td><code id="knockoffHMM_+3A_pinit">pInit</code></td>
<td>
<p>an array of length K, containing the marginal distribution of the states for the first variable.</p>
</td></tr>
<tr><td><code id="knockoffHMM_+3A_q">Q</code></td>
<td>
<p>an array of size (p-1,K,K), containing a list of p-1 transition matrices between the K states of the Markov chain.</p>
</td></tr>
<tr><td><code id="knockoffHMM_+3A_pemit">pEmit</code></td>
<td>
<p>an array of size (p,M,K), containing the emission probabilities for each of the M possible emission states,
from each of the K hidden states and the p variables.</p>
</td></tr>
<tr><td><code id="knockoffHMM_+3A_groups">groups</code></td>
<td>
<p>an array of length p, describing the group membership of each variable (default: NULL).</p>
</td></tr>
<tr><td><code id="knockoffHMM_+3A_seed">seed</code></td>
<td>
<p>an integer random seed (default: 123).</p>
</td></tr>
<tr><td><code id="knockoffHMM_+3A_cluster">cluster</code></td>
<td>
<p>a computing cluster object created by <a href="parallel.html#topic+makeCluster">makeCluster</a> (default: NULL).</p>
</td></tr>
<tr><td><code id="knockoffHMM_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to show progress bar (default: FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each element of the matrix X should be an integer value between 0 and M-1.
The transition matrices contained in Q are defined with the same convention as in <a href="#topic+knockoffDMC">knockoffDMC</a>.
The emission propability matrices contained in pEmit are defined such that <code class="reqn">P[X_{j}=k|H_{j}=l]=\mathrm{pEmit}[j,k,l]</code>,
where <code class="reqn">H_j</code> is the latent variable associated to <code class="reqn">X_j</code>.
</p>


<h3>Value</h3>

<p>An integer matrix of size n-by-p containing the knockoff variables.
</p>


<h3>References</h3>

<p>Sesia M, Sabatti C, Candès EJ (2019).
&ldquo;Gene hunting with hidden Markov model knockoffs.&rdquo;
<em>Biometrika</em>, <b>106</b>, 1&ndash;18.
doi: <a href="http://doi.org/10.1093/biomet/asy033">10.1093/biomet/asy033</a>.
Sesia M, Katsevich E, Bates S, Candès E, Sabatti C (2019).
&ldquo;Multi-resolution localization of causal variants across the genome.&rdquo;
<em>bioRxiv</em>.
doi: <a href="http://doi.org/10.1101/631390">10.1101/631390</a>.
</p>


<h3>See Also</h3>

<p>Other knockoffs: <code><a href="#topic+knockoffDMC">knockoffDMC</a></code>,
<code><a href="#topic+knockoffGenotypes">knockoffGenotypes</a></code>,
<code><a href="#topic+knockoffHaplotypes">knockoffHaplotypes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data
p=10; K=5; M=3;
pInit = rep(1/K,K)
Q = array(stats::runif((p-1)*K*K),c(p-1,K,K))
for(j in 1:(p-1)) { Q[j,,] = Q[j,,] / rowSums(Q[j,,]) }
pEmit = array(stats::runif(p*M*K),c(p,M,K))
for(j in 1:p) { pEmit[j,,] = pEmit[j,,] / rowSums(pEmit[j,,]) }
X = sampleHMM(pInit, Q, pEmit, n=20)
# Generate knockoffs
Xk = knockoffHMM(X, pInit, Q, pEmit)
# Generate group-knockoffs for groups of size 3
groups = rep(seq(p), each=3, length.out=p)
Xk = knockoffHMM(X, pInit, Q, pEmit, groups=groups)

</code></pre>

<hr>
<h2 id='knockoffHMM_wrapper'>Wrapper for HMM group knockoffs</h2><span id='topic+knockoffHMM_wrapper'></span>

<h3>Description</h3>

<p>Wrapper for HMM group knockoffs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knockoffHMM_wrapper(X_, pInit_, Q_, pEmit_, n_, p_, K_, M_, seed_, G_,
  display_progress_)
</code></pre>

<hr>
<h2 id='loadEMParameters'>Read the files produced by fastPHASE</h2><span id='topic+loadEMParameters'></span>

<h3>Description</h3>

<p>Read the files produced by fastPHASE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadEMParameters(data_path)
</code></pre>

<hr>
<h2 id='loadHMM'>Load HMM parameters fitted by fastPHASE</h2><span id='topic+loadHMM'></span>

<h3>Description</h3>

<p>This function loads the parameter estimates obtained by fastPHASE (see <a href="#topic+runFastPhase">runFastPhase</a>)
and assembles the Li and Stephens HMM, in the format required by the knockoff generation functions
<a href="#topic+knockoffHaplotypes">knockoffHaplotypes</a> and <a href="#topic+knockoffGenotypes">knockoffGenotypes</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadHMM(r_file, alpha_file, theta_file, char_file, compact = TRUE,
  phased = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadHMM_+3A_r_file">r_file</code></td>
<td>
<p>a string with the path of the &quot;_rhat.txt&quot; file produced by fastPHASE.</p>
</td></tr>
<tr><td><code id="loadHMM_+3A_alpha_file">alpha_file</code></td>
<td>
<p>a string with the path of the &quot;_alphahat.txt&quot; file produced by fastPHASE.</p>
</td></tr>
<tr><td><code id="loadHMM_+3A_theta_file">theta_file</code></td>
<td>
<p>a string with the path of the &quot;_thetahat.txt&quot; file produced by fastPHASE.</p>
</td></tr>
<tr><td><code id="loadHMM_+3A_char_file">char_file</code></td>
<td>
<p>a string with the path of the &quot;_origchars&quot; file produced by fastPHASE.</p>
</td></tr>
<tr><td><code id="loadHMM_+3A_compact">compact</code></td>
<td>
<p>whether to assemble the explicit transition and emission matrices for the HMM (default: FALSE).</p>
</td></tr>
<tr><td><code id="loadHMM_+3A_phased">phased</code></td>
<td>
<p>whether to assemble a model for phased haplotypes, if compact==FALSE (default: FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function by default returns a structure with three fields:
</p>

<ul>
<li><p>&quot;r&quot;: a numerical array of length p.
</p>
</li>
<li><p>&quot;alpha&quot;: a numerical array of size (p,K).
</p>
</li>
<li><p>&quot;theta&quot;: a numerical array of size (p,K).
</p>
</li></ul>

<p>If the parameter compact is FALSE, this function assembles the HMM model for the genotype data
(either unphased or phased), in the format required by the knockoff generation function <a href="#topic+knockoffHMM">knockoffHMM</a>.
</p>


<h3>Value</h3>

<p>A structure containing the parameters from the Li and Stephens HMM for phased haplotypes.
</p>


<h3>References</h3>

<p>Scheet P, Stephens M (2006).
&ldquo;A fast and flexible statistical model for large-scale population genotype data: applications to inferring missing genotypes and haplotypic phase.&rdquo;
<em>Am. J. Hum. Genet.</em>, <b>78</b>, 629&ndash;644.
doi: <a href="http://doi.org/10.1086/502802">10.1086/502802</a>.
</p>


<h3>See Also</h3>

<p>Other fastPHASE: <code><a href="#topic+runFastPhase">runFastPhase</a></code>,
<code><a href="#topic+writeXtoInp">writeXtoInp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Specify the location of the fastPHASE output files containing the parameter estimates.
# Example files can be found in the package installation directory.
r_file = system.file("extdata", "genotypes_rhat.txt", package = "SNPknock")
alpha_file = system.file("extdata", "genotypes_alphahat.txt", package = "SNPknock")
theta_file = system.file("extdata", "genotypes_thetahat.txt", package = "SNPknock")
char_file = system.file("extdata", "genotypes_origchars", package = "SNPknock")

# Read the parameter files and load the HMM
hmm = loadHMM(r_file, alpha_file, theta_file, char_file)

# Read the parameter files and load the HMM
hmm.large = loadHMM(r_file, alpha_file, theta_file, char_file, compact=FALSE)

</code></pre>

<hr>
<h2 id='rand_weighted'>Random sampling from discrete distribution</h2><span id='topic+rand_weighted'></span>

<h3>Description</h3>

<p>Random sampling from discrete distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rand_weighted(W)
</code></pre>

<hr>
<h2 id='runFastPhase'>Fit an HMM to genetic data using fastPHASE</h2><span id='topic+runFastPhase'></span>

<h3>Description</h3>

<p>This function provides a wrapper for the fastPHASE executable in order to fit an HMM to either
unphased genotype data or phased haplotype data.
The software fastPHASE will fit the HMM  to the genotype data and write the
corresponding parameter estimates in four separate files.
Since fastPHASE is not an R package, this executable must be downloaded separately by the
user. Visit <a href="http://scheet.org/software.html">http://scheet.org/software.html</a> for more information on how to obtain fastPHASE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runFastPhase(fp_path, X_file, out_path = NULL, K = 12, numit = 25,
  phased = FALSE, seed = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runFastPhase_+3A_fp_path">fp_path</code></td>
<td>
<p>a string with the path to the directory with the fastPHASE executable.</p>
</td></tr>
<tr><td><code id="runFastPhase_+3A_x_file">X_file</code></td>
<td>
<p>a string with the path of the genotype input file containing X in fastPHASE
format (as created by <a href="#topic+writeXtoInp">writeXtoInp</a>).</p>
</td></tr>
<tr><td><code id="runFastPhase_+3A_out_path">out_path</code></td>
<td>
<p>a string with the path of the directory in which the parameter estimates
will be saved (default: NULL). If this is equal to NULL, a temporary file
in the R temporary directory will be used.</p>
</td></tr>
<tr><td><code id="runFastPhase_+3A_k">K</code></td>
<td>
<p>the number of hidden states for each haplotype sequence (default: 12).</p>
</td></tr>
<tr><td><code id="runFastPhase_+3A_numit">numit</code></td>
<td>
<p>the number of EM iterations (default: 25).</p>
</td></tr>
<tr><td><code id="runFastPhase_+3A_phased">phased</code></td>
<td>
<p>whether the data are already phased (default: FALSE).</p>
</td></tr>
<tr><td><code id="runFastPhase_+3A_seed">seed</code></td>
<td>
<p>the random seed for the EM algorithm (default: 1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The software fastPHASE saves the parameter estimates in four separate files whose names
begin with the string contained in 'out_path' and end with:
</p>

<ul>
<li><p>&quot;_rhat.txt&quot;
</p>
</li>
<li><p>&quot;_alphahat.txt&quot;
</p>
</li>
<li><p>&quot;_thetahat.txt&quot;
</p>
</li>
<li><p>&quot;_origchars&quot;
</p>
</li></ul>

<p>The HMM for the genotype data can then be loaded from these files by calling
<a href="#topic+loadHMM">loadHMM</a>.
</p>


<h3>Value</h3>

<p>A string containing the path of the directory in which the parameter estimates
were saved. This is useful to find the data when the default option for 'out_path'
is used and the output is written in an R temporary directory.
</p>


<h3>References</h3>

<p>Scheet P, Stephens M (2006).
&ldquo;A fast and flexible statistical model for large-scale population genotype data: applications to inferring missing genotypes and haplotypic phase.&rdquo;
<em>Am. J. Hum. Genet.</em>, <b>78</b>, 629&ndash;644.
doi: <a href="http://doi.org/10.1086/502802">10.1086/502802</a>.
</p>


<h3>See Also</h3>

<p>Other fastPHASE: <code><a href="#topic+loadHMM">loadHMM</a></code>,
<code><a href="#topic+writeXtoInp">writeXtoInp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fp_path  = "~/bin/fastPHASE" # Path to the fastPHASE executable

# Run fastPHASE on unphased genotypes
# Specify the path to the genotype input file in ".inp" format.
# An example file containing unphased genotypes can be found in the package installation folder.
X_file = system.file("extdata", "genotypes.inp", package = "SNPknock")
fp_outPath = runFastPhase(fp_path, X_file)

# Run fastPHASE on phased haplotypes
# An example file containing phased haplotypes can be found in the package installation folder.
H_file = system.file("extdata", "haplotypes.inp", package = "SNPknock")
fp_outPath = runFastPhase(fp_path, H_file, phased=TRUE)

</code></pre>

<hr>
<h2 id='sampleDMC'>Sample discrete Markov chains</h2><span id='topic+sampleDMC'></span>

<h3>Description</h3>

<p>This function draws independent random samples of a discrete Markov chain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleDMC(pInit, Q, n = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleDMC_+3A_pinit">pInit</code></td>
<td>
<p>an array of length K, containing the marginal distribution of the states for the first variable.</p>
</td></tr>
<tr><td><code id="sampleDMC_+3A_q">Q</code></td>
<td>
<p>an array of size (p-1,K,K), containing a list of p-1 transition matrices between the K states of the Markov chain.</p>
</td></tr>
<tr><td><code id="sampleDMC_+3A_n">n</code></td>
<td>
<p>the number of independent samples to be drawn (default: 1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each element of the output matrix is an integer value between 0 and K-1.
The transition matrices contained in Q are defined such that <code class="reqn">P[X_{j+1}=k|X_{j}=l]=Q[j,l,k]</code>.
</p>


<h3>Value</h3>

<p>A matrix of size n-by-p containing the n observed Markov chains of length p.
</p>


<h3>References</h3>

<p>Sesia M, Sabatti C, Candès EJ (2019).
&ldquo;Gene hunting with hidden Markov model knockoffs.&rdquo;
<em>Biometrika</em>, <b>106</b>, 1&ndash;18.
doi: <a href="http://doi.org/10.1093/biomet/asy033">10.1093/biomet/asy033</a>.
</p>


<h3>See Also</h3>

<p>Other models: <code><a href="#topic+sampleHMM">sampleHMM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p=10; K=5;
pInit = rep(1/K,K)
Q = array(stats::runif((p-1)*K*K),c(p-1,K,K))
for(j in 1:(p-1)) { Q[j,,] = Q[j,,] / rowSums(Q[j,,]) }
X = sampleDMC(pInit, Q, n=20)

</code></pre>

<hr>
<h2 id='sampleHMM'>Sample hidden Markov models</h2><span id='topic+sampleHMM'></span>

<h3>Description</h3>

<p>This function draws independent random samples of an hidden Markov model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleHMM(pInit, Q, pEmit, n = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleHMM_+3A_pinit">pInit</code></td>
<td>
<p>an array of length K, containing the marginal distribution of the states for the first variable.</p>
</td></tr>
<tr><td><code id="sampleHMM_+3A_q">Q</code></td>
<td>
<p>an array of size (p-1,K,K), containing a list of p-1 transition matrices between the K states of the Markov chain.</p>
</td></tr>
<tr><td><code id="sampleHMM_+3A_pemit">pEmit</code></td>
<td>
<p>an array of size (p,M,K), containing the emission probabilities for each of the M possible emission states,
from each of the K hidden states and the p variables.</p>
</td></tr>
<tr><td><code id="sampleHMM_+3A_n">n</code></td>
<td>
<p>the number of independent samples to be drawn (default: 1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each element of the output matrix is an integer value between 0 and K-1.
The transition matrices contained in Q are defined with the same convention as in <a href="#topic+sampleDMC">sampleDMC</a>.
The emission propability matrices contained in pEmit are defined such that <code class="reqn">P[X_{j}=k|H_{j}=l]=\mathrm{pEmit}[j,k,l]</code>,
where <code class="reqn">H_j</code> is the latent variable associated to <code class="reqn">X_j</code>.
</p>


<h3>Value</h3>

<p>A matrix of size n-by-p containing the n observed Markov chains of length p.
</p>


<h3>References</h3>

<p>Sesia M, Sabatti C, Candès EJ (2019).
&ldquo;Gene hunting with hidden Markov model knockoffs.&rdquo;
<em>Biometrika</em>, <b>106</b>, 1&ndash;18.
doi: <a href="http://doi.org/10.1093/biomet/asy033">10.1093/biomet/asy033</a>.
</p>


<h3>See Also</h3>

<p>Other models: <code><a href="#topic+sampleDMC">sampleDMC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p=10; K=5; M=3;
pInit = rep(1/K,K)
Q = array(stats::runif((p-1)*K*K),c(p-1,K,K))
for(j in 1:(p-1)) { Q[j,,] = Q[j,,] / rowSums(Q[j,,]) }
pEmit = array(stats::runif(p*M*K),c(p,M,K))
for(j in 1:p) { pEmit[j,,] = pEmit[j,,] / rowSums(pEmit[j,,]) }
X = sampleHMM(pInit, Q, pEmit, n=20)

</code></pre>

<hr>
<h2 id='writeXtoInp'>Convert genotypes X into the fastPHASE input format</h2><span id='topic+writeXtoInp'></span>

<h3>Description</h3>

<p>This function converts a genetic matrix X into the fastPHASE input format and saves
it to a user-specified file. Then, an HMM can be fitted by calling fastPHASE with
<a href="#topic+runFastPhase">runFastPhase</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeXtoInp(X, phased = FALSE, out_file = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="writeXtoInp_+3A_x">X</code></td>
<td>
<p>either a matrix of size n-by-p containing unphased genotypes for n individuals,
or a matrix of size 2n-by-p containing phased haplotypes for n individuals.</p>
</td></tr>
<tr><td><code id="writeXtoInp_+3A_phased">phased</code></td>
<td>
<p>whether the data are phased (default: FALSE).
If this is equal to TRUE, each pair of consecutive rows will be assumed to correspond to phased haplotypes from the
same individual.</p>
</td></tr>
<tr><td><code id="writeXtoInp_+3A_out_file">out_file</code></td>
<td>
<p>a string containing the path of the output file onto which X will be written (default: NULL).
If this is equal to NULL, a temporary file in the R temporary directory will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string containing the path of the output file onto which X was written. This is useful to find the data
when the default option for 'out_file' is used and X is written onto a temporary file in the R temporary directory.
</p>


<h3>References</h3>

<p>Scheet P, Stephens M (2006).
&ldquo;A fast and flexible statistical model for large-scale population genotype data: applications to inferring missing genotypes and haplotypic phase.&rdquo;
<em>Am. J. Hum. Genet.</em>, <b>78</b>, 629&ndash;644.
doi: <a href="http://doi.org/10.1086/502802">10.1086/502802</a>.
</p>


<h3>See Also</h3>

<p>Other fastPHASE: <code><a href="#topic+loadHMM">loadHMM</a></code>,
<code><a href="#topic+runFastPhase">runFastPhase</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert unphased genotypes
# Load an example data matrix X from the package installation directory.
X_file = system.file("extdata", "genotypes.RData", package = "SNPknock")
load(X_file)
# Write X in a temporary file
Xinp_file = writeXtoInp(X)

# Convert phased haplotypes
# Load an example data matrix H from the package installation directory.
H_file = system.file("extdata", "haplotypes.RData", package = "SNPknock")
load(H_file)
# Write H in a temporary file
Hinp_file = writeXtoInp(H, phased=TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
