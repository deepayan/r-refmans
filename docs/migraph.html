<!DOCTYPE html><html><head><title>Help for package migraph</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {migraph}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#between_centrality'><p>Measures of betweenness-like centrality and centralisation</p></a></li>
<li><a href='#brokerage_census'><p>Censuses of brokerage motifs</p></a></li>
<li><a href='#cliques'><p>Clique partitioning algorithms</p></a></li>
<li><a href='#close_centrality'><p>Measures of closeness-like centrality and centralisation</p></a></li>
<li><a href='#closure'><p>Measures of network closure</p></a></li>
<li><a href='#cluster'><p>Methods for equivalence clustering</p></a></li>
<li><a href='#cohesion'><p>Measures of network cohesion or connectedness</p></a></li>
<li><a href='#community'><p>Community partitioning algorithms</p></a></li>
<li><a href='#components'><p>Component partitioning algorithms</p></a></li>
<li><a href='#core'><p>Core-periphery clustering algorithms</p></a></li>
<li><a href='#defunct'><p>Functions that have been renamed, superseded, or are no longer working</p></a></li>
<li><a href='#degree_centrality'><p>Measures of degree-like centrality and centralisation</p></a></li>
<li><a href='#eigenv_centrality'><p>Measures of eigenvector-like centrality and centralisation</p></a></li>
<li><a href='#equivalence'><p>Equivalence clustering algorithms</p></a></li>
<li><a href='#features'><p>Measures of network topological features</p></a></li>
<li><a href='#heterogeneity'><p>Measures of network diversity</p></a></li>
<li><a href='#hierarchy'><p>Graph theoretic dimensions of hierarchy</p></a></li>
<li><a href='#holes'><p>Measures of structural holes</p></a></li>
<li><a href='#kselect'><p>Methods for selecting clusters</p></a></li>
<li><a href='#migraph-package'><p>migraph: Many Network Measures, Motifs, Members, and Models</p></a></li>
<li><a href='#mpn_bristol'><p>Multimodal (3) Bristol protest events, 1990-2002 (Diani and Bison 2004)</p></a></li>
<li><a href='#mpn_cow'><p>One-mode interstate trade relations and two-mode state membership in IGOs (COW)</p></a></li>
<li><a href='#mpn_elite_mex'><p>One-mode Mexican power elite database (Knoke 1990)</p></a></li>
<li><a href='#mpn_elite_usa'><p>Two-mode and three-mode American power elite database (Domhoff 2016)</p></a></li>
<li><a href='#mpn_evs'><p>Two-mode European Values Survey, 1990 and 2008 (EVS 2020)</p></a></li>
<li><a href='#mpn_ryanair'><p>One-mode EU policy influence network, June 2004 (Christopoulos 2006)</p></a></li>
<li><a href='#mpn_senate112'><p>Two-mode 112th Congress Senate Voting (Knoke et al. 2021)</p></a></li>
<li><a href='#net_diffusion'><p>Measures of network diffusion</p></a></li>
<li><a href='#network_census'><p>Censuses of motifs at the network level</p></a></li>
<li><a href='#node_census'><p>Censuses of nodes' motifs</p></a></li>
<li><a href='#node_diffusion'><p>Measures of nodes in a diffusion</p></a></li>
<li><a href='#over'><p>Helper functions for measuring over splits of networks</p></a></li>
<li><a href='#periods'><p>Measures of network change</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#regression'><p>Linear and logistic regression for network data</p></a></li>
<li><a href='#tests'><p>Conditional uniform graph and permutation tests</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Many Network Measures, Motifs, Members, and Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-07</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of tools for analysing multimodal networks.
   It includes functions for measuring 
   centrality, centralization, cohesion, closure, constraint and diversity,
   as well as for network block-modelling, regression, and diffusion models.
   The package is released as a complement to 
   'Multimodal Political Networks' (2021, ISBN:9781108985000),
   and includes various datasets used in the book.
   Built on the 'manynet' package, all functions operate with matrices, edge lists, 
   and 'igraph', 'network', and 'tidygraph' objects,
   and on one-mode, two-mode (bipartite), and sometimes three-mode networks.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://stocnet.github.io/migraph/">https://stocnet.github.io/migraph/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stocnet/migraph/issues">https://github.com/stocnet/migraph/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), manynet</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 1.1.0), generics, ggplot2, igraph (&ge; 1.5.0),
network, future, furrr, pillar, purrr, rlang, sna, tidygraph,
tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>concaveman, covr, ggdendro, minMSE, oaqc, roxygen2,
rsconnect, testthat, xml2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-07 11:31:34 UTC; hollway</td>
</tr>
<tr>
<td>Author:</td>
<td>James Hollway <a href="https://orcid.org/0000-0002-8361-9647"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut, ctb] (IHEID),
  Henrique Sposito <a href="https://orcid.org/0000-0003-3420-6085"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] (IHEID),
  Jael Tan <a href="https://orcid.org/0000-0002-6234-9764"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]
    (IHEID),
  Bernhard Bieri <a href="https://orcid.org/0000-0001-5943-9059"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James Hollway &lt;james.hollway@graduateinstitute.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-07 11:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='between_centrality'>Measures of betweenness-like centrality and centralisation</h2><span id='topic+between_centrality'></span><span id='topic+node_betweenness'></span><span id='topic+node_induced'></span><span id='topic+node_flow'></span><span id='topic+tie_betweenness'></span><span id='topic+network_betweenness'></span>

<h3>Description</h3>

<p>These functions calculate common betweenness-related centrality measures for one- and two-mode networks:
</p>

<ul>
<li> <p><code>node_betweenness()</code> measures the betweenness centralities of nodes in a network.
</p>
</li>
<li> <p><code>node_induced()</code> measures the induced betweenness centralities of nodes in a network.
</p>
</li>
<li> <p><code>node_flow()</code> measures the flow betweenness centralities of nodes in a network,
which uses an electrical current model for information spreading
in contrast to the shortest paths model used by normal betweenness centrality.
</p>
</li>
<li> <p><code>tie_betweenness()</code> measures the number of shortest paths going through a tie.
</p>
</li>
<li> <p><code>network_betweenness()</code> measures the betweenness centralization for a network.
</p>
</li></ul>

<p>All measures attempt to use as much information as they are offered,
including whether the networks are directed, weighted, or multimodal.
If this would produce unintended results,
first transform the salient properties using e.g. <code><a href="manynet.html#topic+to_undirected">to_undirected()</a></code> functions.
All centrality and centralization measures return normalized measures by default,
including for two-mode networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_betweenness(.data, normalized = TRUE, cutoff = NULL)

node_induced(.data, normalized = TRUE, cutoff = NULL)

node_flow(.data, normalized = TRUE)

tie_betweenness(.data, normalized = TRUE)

network_betweenness(
  .data,
  normalized = TRUE,
  direction = c("all", "out", "in")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="between_centrality_+3A_.data">.data</code></td>
<td>
<p>An object of a <code>{manynet}</code>-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="between_centrality_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar, whether the centrality scores are normalized.
Different denominators are used depending on whether the object is one-mode or two-mode,
the type of centrality, and other arguments.</p>
</td></tr>
<tr><td><code id="between_centrality_+3A_cutoff">cutoff</code></td>
<td>
<p>The maximum path length to consider when calculating betweenness.
If negative or NULL (the default), there's no limit to the path lengths considered.</p>
</td></tr>
<tr><td><code id="between_centrality_+3A_direction">direction</code></td>
<td>
<p>Character string, “out” bases the measure on outgoing ties,
“in” on incoming ties, and &quot;all&quot; on either/the sum of the two.
For two-mode networks, &quot;all&quot; uses as numerator the sum of differences
between the maximum centrality score for the mode
against all other centrality scores in the network,
whereas &quot;in&quot; uses as numerator the sum of differences
between the maximum centrality score for the mode
against only the centrality scores of the other nodes in that mode.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector giving the betweenness centrality measure of each node.
</p>


<h3>References</h3>

<p>Everett, Martin and Steve Borgatti. 2010.
&quot;Induced, endogenous and exogenous centrality&quot;
<em>Social Networks</em>, 32: 339-344.
<a href="https://doi.org/10.1016/j.socnet.2010.06.004">doi:10.1016/j.socnet.2010.06.004</a>
</p>


<h3>See Also</h3>

<p>Other centrality: 
<code><a href="#topic+close_centrality">close_centrality</a></code>,
<code><a href="#topic+degree_centrality">degree_centrality</a></code>,
<code><a href="#topic+eigenv_centrality">eigenv_centrality</a></code>
</p>
<p>Other measures: 
<code><a href="#topic+close_centrality">close_centrality</a></code>,
<code><a href="#topic+closure">closure</a></code>,
<code><a href="#topic+cohesion">cohesion</a>()</code>,
<code><a href="#topic+degree_centrality">degree_centrality</a></code>,
<code><a href="#topic+eigenv_centrality">eigenv_centrality</a></code>,
<code><a href="#topic+features">features</a></code>,
<code><a href="#topic+heterogeneity">heterogeneity</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+holes">holes</a></code>,
<code><a href="#topic+net_diffusion">net_diffusion</a></code>,
<code><a href="#topic+node_diffusion">node_diffusion</a></code>,
<code><a href="#topic+periods">periods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>node_betweenness(mpn_elite_mex)
node_betweenness(ison_southern_women)
node_induced(mpn_elite_mex)
(tb &lt;- tie_betweenness(ison_adolescents))
plot(tb)
#ison_adolescents %&gt;% mutate_ties(weight = tb) %&gt;% 
#   autographr()
network_betweenness(ison_southern_women, direction = "in")
</code></pre>

<hr>
<h2 id='brokerage_census'>Censuses of brokerage motifs</h2><span id='topic+brokerage_census'></span><span id='topic+node_brokerage_census'></span><span id='topic+network_brokerage_census'></span><span id='topic+node_brokering_activity'></span><span id='topic+node_brokering_exclusivity'></span><span id='topic+node_brokering'></span>

<h3>Description</h3>

<p>These functions include ways to take a census of the brokerage positions of nodes
in a network:
</p>

<ul>
<li> <p><code>node_brokerage_census()</code> returns the Gould-Fernandez brokerage
roles played by nodes in a network.
</p>
</li>
<li> <p><code>network_brokerage_census()</code> returns the Gould-Fernandez brokerage
roles in a network.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>node_brokerage_census(.data, membership, standardized = FALSE)

network_brokerage_census(.data, membership, standardized = FALSE)

node_brokering_activity(.data, membership)

node_brokering_exclusivity(.data, membership)

node_brokering(.data, membership)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brokerage_census_+3A_.data">.data</code></td>
<td>
<p>An object of a <code>{manynet}</code>-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="brokerage_census_+3A_membership">membership</code></td>
<td>
<p>A vector of partition membership as integers.</p>
</td></tr>
<tr><td><code id="brokerage_census_+3A_standardized">standardized</code></td>
<td>
<p>Whether the score should be standardized
into a <em>z</em>-score indicating how many standard deviations above
or below the average the score lies.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gould, R.V. and Fernandez, R.M. 1989.
“Structures of Mediation: A Formal Approach to Brokerage in Transaction Networks.”
<em>Sociological Methodology</em>, 19: 89-126.
</p>
<p>Jasny, Lorien, and Mark Lubell. 2015.
“Two-Mode Brokerage in Policy Networks.”
<em>Social Networks</em> 41:36–47.
<a href="https://doi.org/10.1016/j.socnet.2014.11.005">doi:10.1016/j.socnet.2014.11.005</a>.
</p>
<p>Hamilton, Matthew, Jacob Hileman, and Orjan Bodin. 2020.
&quot;Evaluating heterogeneous brokerage: New conceptual and methodological approaches
and their application to multi-level environmental governance networks&quot;
<em>Social Networks</em> 61: 1-10.
<a href="https://doi.org/10.1016/j.socnet.2019.08.002">doi:10.1016/j.socnet.2019.08.002</a>
</p>


<h3>See Also</h3>

<p>Other motifs: 
<code><a href="#topic+network_census">network_census</a></code>,
<code><a href="#topic+node_census">node_census</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>node_brokerage_census(manynet::ison_networkers, "Discipline")
network_brokerage_census(manynet::ison_networkers, "Discipline")
node_brokering_exclusivity(ison_networkers, "Discipline")
</code></pre>

<hr>
<h2 id='cliques'>Clique partitioning algorithms</h2><span id='topic+cliques'></span><span id='topic+node_roulette'></span>

<h3>Description</h3>

<p>These functions create a vector of nodes' memberships in
cliques:
</p>

<ul>
<li> <p><code>node_roulette()</code> assigns nodes to maximally diverse groups.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>node_roulette(.data, num_groups, group_size, times = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cliques_+3A_.data">.data</code></td>
<td>
<p>An object of a <code>{manynet}</code>-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="cliques_+3A_num_groups">num_groups</code></td>
<td>
<p>An integer indicating the number of groups desired.</p>
</td></tr>
<tr><td><code id="cliques_+3A_group_size">group_size</code></td>
<td>
<p>An integer indicating the desired size of most of the groups.
Note that if the number of nodes is not divisible into groups of equal size,
there may be some larger or smaller groups.</p>
</td></tr>
<tr><td><code id="cliques_+3A_times">times</code></td>
<td>
<p>An integer of the number of search iterations the algorithm should complete.
By default this is the number of nodes in the network multiplied by the number of groups.
This heuristic may be insufficient for small networks and numbers of groups,
and burdensome for large networks and numbers of groups, but can be overwritten.
At every 10th iteration, a stronger perturbation of a number of successive changes,
approximately the number of nodes divided by the number of groups,
will take place irrespective of whether it improves the objective function.</p>
</td></tr>
</table>


<h3>Maximally diverse grouping problem</h3>

<p>This well known computational problem is a NP-hard problem
with a number of relevant applications,
including the formation of groups of students that have encountered
each other least or least recently.
Essentially, the aim is to return a membership of nodes in cliques
that minimises the sum of their previous (weighted) ties:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{g=1}^{m} \sum_{i=1}^{n-1} \sum_{j=i+1}^{n} x_{ij} y_{ig} y_{jg}</code>
</p>

<p>where <code class="reqn">y_{ig} = 1</code> if node <code class="reqn">i</code> is in group <code class="reqn">g</code>, and 0 otherwise.
</p>
<p><code class="reqn">x_{ij}</code> is the existing network data.
If this is an empty network, the function will just return cliques.
To run this repeatedly, one can join a clique network of the membership result
with the original network, using this as the network data for the next round.
</p>
<p>A form of the Lai and Hao (2016) iterated maxima search (IMS) is used here.
This performs well for small and moderately sized networks.
It includes both weak and strong perturbations to an initial solution
to ensure that a robust solution from the broader state space is identified.
The user is referred to Lai and Hao (2016) and Lai et al (2021) for more details.
</p>


<h3>References</h3>

<p>Lai, Xiangjing, and Jin-Kao Hao. 2016.
“Iterated Maxima Search for the Maximally Diverse Grouping Problem.”
<em>European Journal of Operational Research</em> 254(3):780–800.
<a href="https://doi.org/10.1016/j.ejor.2016.05.018">doi:10.1016/j.ejor.2016.05.018</a>.
</p>
<p>Lai, Xiangjing, Jin-Kao Hao, Zhang-Hua Fu, and Dong Yue. 2021.
“Neighborhood Decomposition Based Variable Neighborhood Search and Tabu Search for Maximally Diverse Grouping.”
<em>European Journal of Operational Research</em> 289(3):1067–86.
<a href="https://doi.org/10.1016/j.ejor.2020.07.048">doi:10.1016/j.ejor.2020.07.048</a>.
</p>


<h3>See Also</h3>

<p>Other memberships: 
<code><a href="#topic+community">community</a></code>,
<code><a href="#topic+components">components</a>()</code>,
<code><a href="#topic+core">core</a></code>,
<code><a href="#topic+equivalence">equivalence</a></code>
</p>

<hr>
<h2 id='close_centrality'>Measures of closeness-like centrality and centralisation</h2><span id='topic+close_centrality'></span><span id='topic+node_closeness'></span><span id='topic+node_reach'></span><span id='topic+node_harmonic'></span><span id='topic+node_information'></span><span id='topic+tie_closeness'></span><span id='topic+network_closeness'></span><span id='topic+network_reach'></span><span id='topic+network_harmonic'></span>

<h3>Description</h3>

<p>These functions calculate common closeness-related centrality measures for one- and two-mode networks:
</p>

<ul>
<li> <p><code>node_closeness()</code> measures the closeness centrality of nodes in a network.
</p>
</li>
<li> <p><code>node_reach()</code> measures nodes' reach centrality,
or how many nodes they can reach within <em>k</em> steps.
</p>
</li>
<li> <p><code>node_harmonic()</code> measures nodes' harmonic centrality or valued centrality,
which is thought to behave better than reach centrality for disconnected networks.
</p>
</li>
<li> <p><code>node_information()</code> measures nodes' information centrality or
current-flow closeness centrality.
</p>
</li>
<li> <p><code>tie_closeness()</code> measures the closeness of each tie to other ties in the network.
</p>
</li>
<li> <p><code>network_closeness()</code> measures a network's closeness centralization.
</p>
</li>
<li> <p><code>network_reach()</code> measures a network's reach centralization.
</p>
</li>
<li> <p><code>network_harmonic()</code> measures a network's harmonic centralization.
</p>
</li></ul>

<p>All measures attempt to use as much information as they are offered,
including whether the networks are directed, weighted, or multimodal.
If this would produce unintended results,
first transform the salient properties using e.g. <code><a href="manynet.html#topic+to_undirected">to_undirected()</a></code> functions.
All centrality and centralization measures return normalized measures by default,
including for two-mode networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_closeness(.data, normalized = TRUE, direction = "out", cutoff = NULL)

node_reach(.data, normalized = TRUE, k = 2)

node_harmonic(.data, normalized = TRUE, k = -1)

node_information(.data, normalized = TRUE)

tie_closeness(.data, normalized = TRUE)

network_closeness(.data, normalized = TRUE, direction = c("all", "out", "in"))

network_reach(.data, normalized = TRUE, k = 2)

network_harmonic(.data, normalized = TRUE, k = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="close_centrality_+3A_.data">.data</code></td>
<td>
<p>An object of a <code>{manynet}</code>-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="close_centrality_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar, whether the centrality scores are normalized.
Different denominators are used depending on whether the object is one-mode or two-mode,
the type of centrality, and other arguments.</p>
</td></tr>
<tr><td><code id="close_centrality_+3A_direction">direction</code></td>
<td>
<p>Character string, “out” bases the measure on outgoing ties,
“in” on incoming ties, and &quot;all&quot; on either/the sum of the two.
For two-mode networks, &quot;all&quot; uses as numerator the sum of differences
between the maximum centrality score for the mode
against all other centrality scores in the network,
whereas &quot;in&quot; uses as numerator the sum of differences
between the maximum centrality score for the mode
against only the centrality scores of the other nodes in that mode.</p>
</td></tr>
<tr><td><code id="close_centrality_+3A_cutoff">cutoff</code></td>
<td>
<p>Maximum path length to use during calculations.</p>
</td></tr>
<tr><td><code id="close_centrality_+3A_k">k</code></td>
<td>
<p>Integer of steps out to calculate reach</p>
</td></tr>
</table>


<h3>References</h3>

<p>Marchiori, M, and V Latora. 2000.
&quot;Harmony in the small-world&quot;.
<em>Physica A</em> 285: 539-546.
</p>
<p>Dekker, Anthony. 2005.
&quot;Conceptual distance in social network analysis&quot;.
<em>Journal of Social Structure</em> 6(3).
</p>


<h3>See Also</h3>

<p>Other centrality: 
<code><a href="#topic+between_centrality">between_centrality</a></code>,
<code><a href="#topic+degree_centrality">degree_centrality</a></code>,
<code><a href="#topic+eigenv_centrality">eigenv_centrality</a></code>
</p>
<p>Other measures: 
<code><a href="#topic+between_centrality">between_centrality</a></code>,
<code><a href="#topic+closure">closure</a></code>,
<code><a href="#topic+cohesion">cohesion</a>()</code>,
<code><a href="#topic+degree_centrality">degree_centrality</a></code>,
<code><a href="#topic+eigenv_centrality">eigenv_centrality</a></code>,
<code><a href="#topic+features">features</a></code>,
<code><a href="#topic+heterogeneity">heterogeneity</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+holes">holes</a></code>,
<code><a href="#topic+net_diffusion">net_diffusion</a></code>,
<code><a href="#topic+node_diffusion">node_diffusion</a></code>,
<code><a href="#topic+periods">periods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>node_closeness(mpn_elite_mex)
node_closeness(ison_southern_women)
node_reach(ison_adolescents)
(ec &lt;- tie_closeness(ison_adolescents))
plot(ec)
#ison_adolescents %&gt;% 
#   activate(edges) %&gt;% mutate(weight = ec) %&gt;% 
#   autographr()
network_closeness(ison_southern_women, direction = "in")
</code></pre>

<hr>
<h2 id='closure'>Measures of network closure</h2><span id='topic+closure'></span><span id='topic+network_reciprocity'></span><span id='topic+node_reciprocity'></span><span id='topic+network_transitivity'></span><span id='topic+node_transitivity'></span><span id='topic+network_equivalency'></span><span id='topic+network_congruency'></span>

<h3>Description</h3>

<p>These functions offer methods for summarising the closure in configurations
in one-, two-, and three-mode networks:
</p>

<ul>
<li> <p><code>network_reciprocity()</code> measures reciprocity in a (usually directed) network.
</p>
</li>
<li> <p><code>node_reciprocity()</code> measures nodes' reciprocity.
</p>
</li>
<li> <p><code>network_transitivity()</code> measures transitivity in a network.
</p>
</li>
<li> <p><code>node_transitivity()</code> measures nodes' transitivity.
</p>
</li>
<li> <p><code>network_equivalency()</code> measures equivalence or reinforcement
in a (usually two-mode) network.
</p>
</li>
<li> <p><code>network_congruency()</code> measures congruency across two two-mode networks.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>network_reciprocity(.data, method = "default")

node_reciprocity(.data)

network_transitivity(.data)

node_transitivity(.data)

network_equivalency(.data)

network_congruency(.data, object2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closure_+3A_.data">.data</code></td>
<td>
<p>An object of a <code>{manynet}</code>-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="closure_+3A_method">method</code></td>
<td>
<p>For reciprocity, either <code>default</code> or <code>ratio</code>.
See <code>?igraph::reciprocity</code></p>
</td></tr>
<tr><td><code id="closure_+3A_object2">object2</code></td>
<td>
<p>Optionally, a second (two-mode) matrix, igraph, or tidygraph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For one-mode networks, shallow wrappers of igraph versions exist via
<code>network_reciprocity</code> and <code>network_transitivity</code>.
</p>
<p>For two-mode networks, <code>network_equivalency</code> calculates the proportion of three-paths in the network
that are closed by fourth tie to establish a &quot;shared four-cycle&quot; structure.
</p>
<p>For three-mode networks, <code>network_congruency</code> calculates the proportion of three-paths
spanning two two-mode networks that are closed by a fourth tie to establish a
&quot;congruent four-cycle&quot; structure.
</p>


<h3>Equivalency</h3>

<p>The <code>network_equivalency()</code> function calculates the Robins and Alexander (2004)
clustering coefficient for two-mode networks.
Note that for weighted two-mode networks, the result is divided by the average tie weight.
</p>


<h3>References</h3>

<p>Robins, Garry L, and Malcolm Alexander. 2004.
Small worlds among interlocking directors: Network structure and distance in bipartite graphs.
<em>Computational &amp; Mathematical Organization Theory</em> 10(1): 69–94.
<a href="https://doi.org/10.1023/B%3ACMOT.0000032580.12184.c0">doi:10.1023/B:CMOT.0000032580.12184.c0</a>.
</p>
<p>Knoke, David, Mario Diani, James Hollway, and Dimitris C Christopoulos. 2021.
<em>Multimodal Political Networks</em>.
Cambridge University Press. Cambridge University Press.
<a href="https://doi.org/10.1017/9781108985000">doi:10.1017/9781108985000</a>
</p>


<h3>See Also</h3>

<p>Other measures: 
<code><a href="#topic+between_centrality">between_centrality</a></code>,
<code><a href="#topic+close_centrality">close_centrality</a></code>,
<code><a href="#topic+cohesion">cohesion</a>()</code>,
<code><a href="#topic+degree_centrality">degree_centrality</a></code>,
<code><a href="#topic+eigenv_centrality">eigenv_centrality</a></code>,
<code><a href="#topic+features">features</a></code>,
<code><a href="#topic+heterogeneity">heterogeneity</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+holes">holes</a></code>,
<code><a href="#topic+net_diffusion">net_diffusion</a></code>,
<code><a href="#topic+node_diffusion">node_diffusion</a></code>,
<code><a href="#topic+periods">periods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>network_reciprocity(ison_southern_women)
node_reciprocity(to_unweighted(ison_networkers))
network_transitivity(ison_adolescents)
node_transitivity(ison_adolescents)
network_equivalency(ison_southern_women)
</code></pre>

<hr>
<h2 id='cluster'>Methods for equivalence clustering</h2><span id='topic+cluster'></span><span id='topic+cluster_hierarchical'></span><span id='topic+cluster_concor'></span>

<h3>Description</h3>

<p>These functions are used to cluster some census object:
</p>

<ul>
<li> <p><code>cluster_hierarchical()</code> returns a hierarchical clustering object
created by <code>stats::hclust()</code>.
</p>
</li>
<li> <p><code>cluster_concor()</code> returns a hierarchical clustering object
created from a convergence of correlations procedure (CONCOR).
</p>
</li></ul>

<p>These functions are not intended to be called directly,
but are called within <code>node_equivalence()</code> and related functions.
They are exported and listed here to provide more detailed documentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_hierarchical(census, distance)

cluster_concor(.data, census)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_+3A_census">census</code></td>
<td>
<p>A matrix returned by a <code style="white-space: pre;">&#8288;node_*_census()&#8288;</code> function.</p>
</td></tr>
<tr><td><code id="cluster_+3A_distance">distance</code></td>
<td>
<p>Character string indicating which distance metric
to pass on to <code>stats::dist</code>.
By default <code>"euclidean"</code>, but other options include
<code>"maximum"</code>, <code>"manhattan"</code>, <code>"canberra"</code>, <code>"binary"</code>, and <code>"minkowski"</code>.
Fewer, identifiable letters, e.g. <code>"e"</code> for Euclidean, is sufficient.</p>
</td></tr>
<tr><td><code id="cluster_+3A_.data">.data</code></td>
<td>
<p>An object of a <code>{manynet}</code>-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
</table>


<h3>CONCOR</h3>

<p>First a matrix of Pearson correlation coefficients between each pair of nodes
profiles in the given census is created.
Then, again, we find the correlations of this square, symmetric matrix,
and continue to do this iteratively until each entry is either <code>1</code> or <code>-1</code>.
These values are used to split the data into two partitions,
with members either holding the values <code>1</code> or <code>-1</code>.
This procedure from census to convergence is then repeated within each block,
allowing further partitions to be found.
Unlike UCINET, partitions are continued until there are single members in
each partition.
Then a distance matrix is constructed from records of in which partition phase
nodes were separated,
and this is given to <code>stats::hclust()</code> so that dendrograms etc can be returned.
</p>


<h3>References</h3>

<p>Breiger, Ronald L., Scott A. Boorman, and Phipps Arabie. 1975.
&quot;An Algorithm for Clustering Relational Data with Applications to
Social Network Analysis and Comparison with Multidimensional Scaling&quot;.
<em>Journal of Mathematical Psychology</em>, 12: 328-83.
<a href="https://doi.org/10.1016/0022-2496%2875%2990028-0">doi:10.1016/0022-2496(75)90028-0</a>.
</p>

<hr>
<h2 id='cohesion'>Measures of network cohesion or connectedness</h2><span id='topic+cohesion'></span><span id='topic+network_density'></span><span id='topic+network_components'></span><span id='topic+network_cohesion'></span><span id='topic+network_adhesion'></span><span id='topic+network_diameter'></span><span id='topic+network_length'></span>

<h3>Description</h3>

<p>These functions return values or vectors relating to how connected a network is
and the number of nodes or edges to remove that would increase fragmentation.
</p>

<ul>
<li> <p><code>network_density()</code> measures the ratio of ties to the number
of possible ties.
</p>
</li>
<li> <p><code>network_components()</code> measures the number of (strong) components
in the network.
</p>
</li>
<li> <p><code>network_cohesion()</code> measures the minimum number of nodes to remove
from the network needed to increase the number of components.
</p>
</li>
<li> <p><code>network_adhesion()</code> measures the minimum number of ties to remove
from the network needed to increase the number of components.
</p>
</li>
<li> <p><code>network_diameter()</code> measures the maximum path length in the network.
</p>
</li>
<li> <p><code>network_length()</code> measures the average path length in the network.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>network_density(.data)

network_components(.data)

network_cohesion(.data)

network_adhesion(.data)

network_diameter(.data)

network_length(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cohesion_+3A_.data">.data</code></td>
<td>
<p>An object of a <code>{manynet}</code>-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
</table>


<h3>Cohesion</h3>

<p>To get the 'weak' components of a directed graph,
please use <code>manynet::to_undirected()</code> first.
</p>


<h3>References</h3>

<p>White, Douglas R and Frank Harary. 2001.
&quot;The Cohesiveness of Blocks In Social Networks: Node Connectivity and Conditional Density.&quot;
<em>Sociological Methodology</em> 31(1): 305-59.
</p>


<h3>See Also</h3>

<p>Other measures: 
<code><a href="#topic+between_centrality">between_centrality</a></code>,
<code><a href="#topic+close_centrality">close_centrality</a></code>,
<code><a href="#topic+closure">closure</a></code>,
<code><a href="#topic+degree_centrality">degree_centrality</a></code>,
<code><a href="#topic+eigenv_centrality">eigenv_centrality</a></code>,
<code><a href="#topic+features">features</a></code>,
<code><a href="#topic+heterogeneity">heterogeneity</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+holes">holes</a></code>,
<code><a href="#topic+net_diffusion">net_diffusion</a></code>,
<code><a href="#topic+node_diffusion">node_diffusion</a></code>,
<code><a href="#topic+periods">periods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>network_density(mpn_elite_mex)
network_density(mpn_elite_usa_advice)
  network_components(mpn_ryanair)
  network_components(manynet::to_undirected(mpn_ryanair))
network_cohesion(manynet::ison_marvel_relationships)
network_cohesion(manynet::to_giant(manynet::ison_marvel_relationships))
network_adhesion(manynet::ison_marvel_relationships)
network_adhesion(manynet::to_giant(manynet::ison_marvel_relationships))
network_diameter(manynet::ison_marvel_relationships)
network_diameter(manynet::to_giant(manynet::ison_marvel_relationships))
network_length(manynet::ison_marvel_relationships)
network_length(manynet::to_giant(manynet::ison_marvel_relationships))
</code></pre>

<hr>
<h2 id='community'>Community partitioning algorithms</h2><span id='topic+community'></span><span id='topic+node_optimal'></span><span id='topic+node_kernighanlin'></span><span id='topic+node_edge_betweenness'></span><span id='topic+node_fast_greedy'></span><span id='topic+node_leading_eigen'></span><span id='topic+node_walktrap'></span><span id='topic+node_infomap'></span><span id='topic+node_spinglass'></span><span id='topic+node_fluid'></span><span id='topic+node_louvain'></span><span id='topic+node_leiden'></span>

<h3>Description</h3>

<p>These functions offer different algorithms useful for partitioning
networks into sets of communities:
</p>

<ul>
<li> <p><code>node_optimal()</code> is a problem-solving algorithm that seeks to maximise
modularity over all possible partitions.
</p>
</li>
<li> <p><code>node_kernaghinlin()</code> is a greedy, iterative, deterministic
partitioning algorithm that results in two equally-sized communities.
</p>
</li>
<li> <p><code>node_edge_betweenness()</code> is a hierarchical, decomposition algorithm
where edges are removed in decreasing order of the number of
shortest paths passing through the edge.
</p>
</li>
<li> <p><code>node_fast_greedy()</code> is a hierarchical, agglomerative algorithm,
that tries to optimize modularity in a greedy manner.
</p>
</li>
<li> <p><code>node_leading_eigen()</code> is a top-down, hierarchical algorithm.
</p>
</li>
<li> <p><code>node_walktrap()</code> is a hierarchical, agglomerative algorithm based on random walks.
</p>
</li>
<li> <p><code>node_infomap()</code> is a hierarchical algorithm based on the information in random walks.
</p>
</li>
<li> <p><code>node_spinglass()</code> is a greedy, iterative, probabilistic algorithm,
based on analogy to model from statistical physics.
</p>
</li>
<li> <p><code>node_fluid()</code> is a propogation-based partitioning algorithm,
based on analogy to model from fluid dynamics.
</p>
</li>
<li> <p><code>node_louvain()</code> is an agglomerative multilevel algorithm that seeks to maximise
modularity over all possible partitions.
</p>
</li>
<li> <p><code>node_leiden()</code> is an agglomerative multilevel algorithm that seeks to maximise
the Constant Potts Model over all possible partitions.
</p>
</li></ul>

<p>The different algorithms offer various advantages in terms of computation time,
availability on different types of networks, ability to maximise modularity,
and their logic or domain of inspiration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_optimal(.data)

node_kernighanlin(.data)

node_edge_betweenness(.data)

node_fast_greedy(.data)

node_leading_eigen(.data)

node_walktrap(.data, times = 50)

node_infomap(.data, times = 50)

node_spinglass(.data, max_k = 200, resolution = 1)

node_fluid(.data)

node_louvain(.data, resolution = 1)

node_leiden(.data, resolution = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="community_+3A_.data">.data</code></td>
<td>
<p>An object of a <code>{manynet}</code>-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="community_+3A_times">times</code></td>
<td>
<p>Integer indicating number of simulations/walks used.
By default, <code>times=50</code>.</p>
</td></tr>
<tr><td><code id="community_+3A_max_k">max_k</code></td>
<td>
<p>Integer constant, the number of spins to use as an upper limit
of communities to be found. Some sets can be empty at the end.</p>
</td></tr>
<tr><td><code id="community_+3A_resolution">resolution</code></td>
<td>
<p>The Reichardt-Bornholdt “gamma” resolution parameter for modularity.
By default 1, making existing and non-existing ties equally important.
Smaller values make existing ties more important,
and larger values make missing ties more important.</p>
</td></tr>
</table>


<h3>Optimal</h3>

<p>The general idea is to calculate the modularity of all possible partitions,
and choose the community structure that maximises this modularity measure.
Note that this is an NP-complete problem with exponential time complexity.
The guidance in the igraph package is networks of &lt;50-200 nodes is probably fine.
</p>


<h3>Edge-betweenness</h3>

<p>This is motivated by the idea that edges connecting different groups
are more likely to lie on multiple shortest paths when they are the
only option to go from one group to another.
This method yields good results but is very slow because of
the computational complexity of edge-betweenness calculations and
the betweenness scores have to be re-calculated after every edge removal.
Networks of ~700 nodes and ~3500 ties are around the upper size limit
that are feasible with this approach.
</p>


<h3>Fast-greedy</h3>

<p>Initially, each node is assigned a separate community.
Communities are then merged iteratively such that each merge
yields the largest increase in the current value of modularity,
until no further increases to the modularity are possible.
The method is fast and recommended as a first approximation
because it has no parameters to tune.
However, it is known to suffer from a resolution limit.
</p>


<h3>Leading eigenvector</h3>

<p>In each step, the network is bifurcated such that modularity increases most.
The splits are determined according to the leading eigenvector of the modularity matrix.
A stopping condition prevents tightly connected groups from being split further.
Note that due to the eigenvector calculations involved,
this algorithm will perform poorly on degenerate networks,
but will likely obtain a higher modularity than fast-greedy (at some cost of speed).
</p>


<h3>Walktrap</h3>

<p>The general idea is that random walks on a network are more likely to stay
within the same community because few edges lead outside a community.
By repeating random walks of 4 steps many times,
information about the hierarchical merging of communities is collected.
</p>


<h3>Infomap</h3>

<p>Motivated by information theoretic principles, this algorithm tries to build
a grouping that provides the shortest description length for a random walk,
where the description length is measured by the expected number of bits per node required to encode the path.
</p>


<h3>Spin-glass</h3>

<p>This is motivated by analogy to the Potts model in statistical physics.
Each node can be in one of <em>k</em> &quot;spin states&quot;,
and ties (particle interactions) provide information about which pairs of nodes
want similar or different spin states.
The final community definitions are represented by the nodes' spin states
after a number of updates.
A different implementation than the default is used in the case of signed networks,
such that nodes connected by negative ties will be more likely found in separate communities.
</p>


<h3>Fluid</h3>

<p>The general idea is to observe how a discrete number of fluids interact, expand and contract,
in a non-homogenous environment, i.e. the network structure.
Unlike the <code>{igraph}</code> implementation that this function wraps,
this function iterates over all possible numbers of communities and returns the membership
associated with the highest modularity.
</p>


<h3>Louvain</h3>

<p>The general idea is to take a hierarchical approach to optimising the modularity criterion.
Nodes begin in their own communities and are re-assigned in a local, greedy way:
each node is moved to the community where it achieves the highest contribution to modularity.
When no further modularity-increasing reassignments are possible,
the resulting communities are considered nodes (like a reduced graph),
and the process continues.
</p>


<h3>Leiden</h3>

<p>The general idea is to optimise the Constant Potts Model,
which does not suffer from the resolution limit, instead of modularity.
As outlined in the <code>{igraph}</code> package,
the Constant Potts Model object function is:
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{2m} \sum_{ij}(A_{ij}-\gamma n_i n_j)\delta(\sigma_i, \sigma_j)</code>
</p>

<p>where <em>m</em> is the total tie weight,
<code class="reqn">A_{ij}</code> is the tie weight between <em>i</em> and <em>j</em>,
<code class="reqn">\gamma</code> is the so-called resolution parameter,
<code class="reqn">n_i</code> is the node weight of node <em>i</em>,
and <code class="reqn">\delta(\sigma_i, \sigma_j) = 1</code> if and only if
<em>i</em> and <em>j</em> are in the same communities and 0 otherwise.
</p>


<h3>References</h3>

<p>Brandes, Ulrik, Daniel Delling, Marco Gaertler, Robert Gorke, Martin Hoefer, Zoran Nikoloski, Dorothea Wagner. 2008.
&quot;On Modularity Clustering&quot;,
<em>IEEE Transactions on Knowledge and Data Engineering</em> 20(2):172-188.
</p>
<p>Kernighan, Brian W., and Shen Lin. 1970.
&quot;An efficient heuristic procedure for partitioning graphs.&quot;
<em>The Bell System Technical Journal</em> 49(2): 291-307.
<a href="https://doi.org/10.1002/j.1538-7305.1970.tb01770.x">doi:10.1002/j.1538-7305.1970.tb01770.x</a>
</p>
<p>Newman, M, and M Girvan. 2004.
&quot;Finding and evaluating community structure in networks.&quot;
<em>Physical Review E</em> 69: 026113.
</p>
<p>Clauset, A, MEJ Newman, MEJ and C Moore.
&quot;Finding community structure in very large networks.&quot;
</p>
<p>Newman, MEJ. 2006.
&quot;Finding community structure using the eigenvectors of matrices&quot;
<em>Physical Review E</em> 74:036104.
</p>
<p>Pons, Pascal, and Matthieu Latapy
&quot;Computing communities in large networks using random walks&quot;.
</p>
<p>Rosvall, M, and C. T. Bergstrom. 2008.
&quot;Maps of information flow reveal community structure in complex networks&quot;,
<em>PNAS</em> 105:1118.
<a href="https://doi.org/10.1073/pnas.0706851105">doi:10.1073/pnas.0706851105</a>
</p>
<p>Rosvall, M., D. Axelsson, and C. T. Bergstrom. 2009.
&quot;The map equation&quot;,
<em>Eur. Phys. J. Special Topics</em> 178: 13.
<a href="https://doi.org/10.1140/epjst/e2010-01179-1">doi:10.1140/epjst/e2010-01179-1</a>
</p>
<p>Reichardt, Jorg, and Stefan Bornholdt. 2006.
&quot;Statistical Mechanics of Community Detection&quot;
<em>Physical Review E</em>, 74(1): 016110–14.
<a href="https://doi.org/10.1073/pnas.0605965104">doi:10.1073/pnas.0605965104</a>
</p>
<p>Traag, VA, and Jeroen Bruggeman. 2008.
&quot;Community detection in networks with positive and negative links&quot;.
</p>
<p>Parés F, Gasulla DG, et. al. 2018.
&quot;Fluid Communities: A Competitive, Scalable and Diverse Community Detection Algorithm&quot;.
In: <em>Complex Networks &amp; Their Applications VI</em>
Springer, 689: 229.
<a href="https://doi.org/10.1007/978-3-319-72150-7_19">doi:10.1007/978-3-319-72150-7_19</a>
</p>
<p>Blondel, Vincent, Jean-Loup Guillaume, Renaud Lambiotte, Etienne Lefebvre. 2008.
&quot;Fast unfolding of communities in large networks&quot;,
<em>J. Stat. Mech.</em> P10008.
</p>
<p>Traag, V. A., L Waltman, and NJ van Eck. 2019.
&quot;From Louvain to Leiden: guaranteeing well-connected communities&quot;,
<em>Scientific Reports</em>, 9(1):5233.
<a href="https://doi.org/10.1038/s41598-019-41695-z">doi:10.1038/s41598-019-41695-z</a>
</p>


<h3>See Also</h3>

<p>Other memberships: 
<code><a href="#topic+cliques">cliques</a></code>,
<code><a href="#topic+components">components</a>()</code>,
<code><a href="#topic+core">core</a></code>,
<code><a href="#topic+equivalence">equivalence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>node_optimal(ison_adolescents)
node_kernighanlin(ison_adolescents)
node_kernighanlin(ison_southern_women)
node_edge_betweenness(ison_adolescents)
node_fast_greedy(ison_adolescents)
node_leading_eigen(ison_adolescents)
node_walktrap(ison_adolescents)
node_infomap(ison_adolescents)
node_spinglass(ison_adolescents)
node_fluid(ison_adolescents)
node_louvain(ison_adolescents)
node_leiden(ison_adolescents)
</code></pre>

<hr>
<h2 id='components'>Component partitioning algorithms</h2><span id='topic+components'></span><span id='topic+node_components'></span><span id='topic+node_weak_components'></span><span id='topic+node_strong_components'></span>

<h3>Description</h3>

<p>These functions create a vector of nodes' memberships in
components or degrees of coreness:
</p>

<ul>
<li> <p><code>node_components()</code> assigns nodes' component membership
using edge direction where available.
</p>
</li>
<li> <p><code>node_weak_components()</code> assigns nodes' component membership
ignoring edge direction.
</p>
</li>
<li> <p><code>node_strong_components()</code> assigns nodes' component membership
based on edge direction.
</p>
</li>
<li> <p><code>node_roulette()</code>
</p>
</li></ul>

<p>In graph theory, components, sometimes called connected components,
are induced subgraphs from partitioning the nodes into disjoint sets.
All nodes that are members of the same partition as <em>i</em> are reachable
from <em>i</em>.
</p>
<p>For directed networks,
strongly connected components consist of subgraphs where there are paths
in each direction between member nodes.
Weakly connected components consist of subgraphs where there is a path
in either direction between member nodes.
</p>
<p>Coreness captures the maximal subgraphs in which each vertex has at least
degree <em>k</em>, where <em>k</em> is also the order of the subgraph.
As described in <code>igraph::coreness</code>,
a node's coreness is <em>k</em> if it belongs to the <em>k</em>-core
but not to the (<em>k</em>+1)-core.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_components(.data)

node_weak_components(.data)

node_strong_components(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="components_+3A_.data">.data</code></td>
<td>
<p>An object of a <code>{manynet}</code>-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other memberships: 
<code><a href="#topic+cliques">cliques</a></code>,
<code><a href="#topic+community">community</a></code>,
<code><a href="#topic+core">core</a></code>,
<code><a href="#topic+equivalence">equivalence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>node_components(mpn_bristol)
</code></pre>

<hr>
<h2 id='core'>Core-periphery clustering algorithms</h2><span id='topic+core'></span><span id='topic+node_core'></span><span id='topic+node_coreness'></span>

<h3>Description</h3>

<p>These functions identify nodes belonging to (some level of) the core of a network:
</p>

<ul>
<li> <p><code>node_core()</code> assigns nodes to either the core or periphery.
</p>
</li>
<li> <p><code>node_coreness()</code> assigns nodes to their level of k-coreness.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>node_core(.data, method = c("degree", "eigenvector"))

node_coreness(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="core_+3A_.data">.data</code></td>
<td>
<p>An object of a <code>{manynet}</code>-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="core_+3A_method">method</code></td>
<td>
<p>Which method to use to identify cores and periphery.
By default this is &quot;degree&quot;,
which relies on the heuristic that high degree nodes are more likely to be in the core.
An alternative is &quot;eigenvector&quot;, which instead begins with high eigenvector nodes.
Other methods, such as a genetic algorithm, CONCOR, and Rombach-Porter,
can be added if there is interest.</p>
</td></tr>
</table>


<h3>Core-periphery</h3>

<p>This function is used to identify which nodes should belong to the core,
and which to the periphery.
It seeks to minimize the following quantity:
</p>
<p style="text-align: center;"><code class="reqn">Z(S_1) = \sum_{(i&lt;j)\in S_1} \textbf{I}_{\{A_{ij}=0\}} + \sum_{(i&lt;j)\notin S_1} \textbf{I}_{\{A_{ij}=1\}}</code>
</p>

<p>where nodes <code class="reqn">\{i,j,...,n\}</code> are ordered in descending degree,
<code class="reqn">A</code> is the adjacency matrix,
and the indicator function is 1 if the predicate is true or 0 otherwise.
Note that minimising this quantity maximises density in the core block
and minimises density in the periphery block;
it ignores ties between these blocks.
</p>


<h3>References</h3>

<p>Borgatti, Stephen P., &amp; Everett, Martin G. 1999.
Models of core /periphery structures.
<em>Social Networks</em>, 21, 375–395.
<a href="https://doi.org/10.1016/S0378-8733%2899%2900019-2">doi:10.1016/S0378-8733(99)00019-2</a>
</p>
<p>Lip, Sean Z. W. 2011.
“A Fast Algorithm for the Discrete Core/Periphery Bipartitioning Problem.”
<a href="https://doi.org/10.48550/arXiv.1102.5511">doi:10.48550/arXiv.1102.5511</a>
</p>


<h3>See Also</h3>

<p>Other memberships: 
<code><a href="#topic+cliques">cliques</a></code>,
<code><a href="#topic+community">community</a></code>,
<code><a href="#topic+components">components</a>()</code>,
<code><a href="#topic+equivalence">equivalence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#mpn_elite_usa_advice %&gt;% as_tidygraph %&gt;% 
#   mutate(corep = node_core(mpn_elite_usa_advice)) %&gt;% 
#   autographr(node_color = "corep")
network_core(mpn_elite_usa_advice)
node_coreness(ison_adolescents)
</code></pre>

<hr>
<h2 id='defunct'>Functions that have been renamed, superseded, or are no longer working</h2><span id='topic+defunct'></span><span id='topic+edge_betweenness'></span><span id='topic+edge_closeness'></span><span id='topic+edge_degree'></span><span id='topic+edge_eigenvector'></span><span id='topic+edge_loop'></span><span id='topic+edge_multiple'></span><span id='topic+edge_bridges'></span><span id='topic+edge_reciprocal'></span><span id='topic+node_cuts'></span><span id='topic+graph_blau_index'></span><span id='topic+graph_diversity'></span><span id='topic+graph_ei_index'></span><span id='topic+graph_homophily'></span><span id='topic+plot.graph_test'></span><span id='topic+print.graph_test'></span><span id='topic+print.graph_measure'></span><span id='topic+print.graph_motif'></span><span id='topic+graph_adhesion'></span><span id='topic+graph_cohesion'></span><span id='topic+graph_assortativity'></span><span id='topic+graph_balance'></span><span id='topic+graph_betweenness'></span><span id='topic+graph_closeness'></span><span id='topic+graph_degree'></span><span id='topic+graph_eigenvector'></span><span id='topic+graph_components'></span><span id='topic+graph_factions'></span><span id='topic+graph_congruency'></span><span id='topic+graph_equivalency'></span><span id='topic+graph_core'></span><span id='topic+graph_density'></span><span id='topic+graph_reciprocity'></span><span id='topic+graph_transitivity'></span><span id='topic+graph_diameter'></span><span id='topic+graph_length'></span><span id='topic+graph_dyad_census'></span><span id='topic+graph_triad_census'></span><span id='topic+graph_mixed_census'></span><span id='topic+graph_modularity'></span><span id='topic+graph_smallworld'></span><span id='topic+network_homophily'></span><span id='topic+node_homophily'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Generally these functions have been superseded or renamed.
Upon using them, a message is provided directing the user to the new function.
However, at this stage of package development,
we generally clear older defunct functions at each minor release,
and so you are strongly encouraged to use the new functions/names/syntax
wherever possible and update your scripts accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge_betweenness(object, normalized = TRUE)

edge_closeness(object, normalized = TRUE)

edge_degree(object, normalized = TRUE)

edge_eigenvector(object, normalized = TRUE)

edge_loop(object)

edge_multiple(object)

edge_bridges(object)

edge_reciprocal(object)

node_cuts(object)

graph_blau_index(object, attribute, clusters = NULL)

graph_diversity(object, attribute, clusters = NULL)

graph_ei_index(object, attribute)

graph_homophily(object, attribute)

## S3 method for class 'graph_test'
plot(x, ..., threshold = 0.95, tails = c("two", "one"))

## S3 method for class 'graph_test'
print(x, ..., max.length = 6, digits = 3)

## S3 method for class 'graph_measure'
print(x, ..., digits = 3)

## S3 method for class 'graph_motif'
print(x, ...)

graph_adhesion(object)

graph_cohesion(object)

graph_assortativity(object)

graph_balance(object)

graph_betweenness(object, normalized = TRUE, direction = c("all", "out", "in"))

graph_closeness(object, normalized = TRUE, direction = c("all", "out", "in"))

graph_degree(object, normalized = TRUE, direction = c("all", "out", "in"))

graph_eigenvector(object, normalized = TRUE)

graph_components(object)

graph_factions(object, membership = NULL)

graph_congruency(object, object2)

graph_equivalency(object)

graph_core(object, membership = NULL)

graph_density(object)

graph_reciprocity(object, method = "default")

graph_transitivity(object)

graph_diameter(object)

graph_length(object)

graph_dyad_census(object)

graph_triad_census(object)

graph_mixed_census(object, object2)

graph_modularity(object, membership = NULL, resolution = 1)

graph_smallworld(object, times = 100)

network_homophily(object, attribute)

node_homophily(object, attribute)
</code></pre>


<h3>Functions</h3>


<ul>
<li> <p><code>edge_betweenness()</code>: Deprecated on 2022-06-28.
</p>
</li>
<li> <p><code>edge_closeness()</code>: Deprecated on 2022-06-28.
</p>
</li>
<li> <p><code>edge_degree()</code>: Deprecated on 2022-06-28.
</p>
</li>
<li> <p><code>edge_eigenvector()</code>: Deprecated on 2022-06-28.
</p>
</li>
<li> <p><code>edge_loop()</code>: Deprecated on 2022-06-28.
</p>
</li>
<li> <p><code>edge_multiple()</code>: Deprecated on 2022-06-28.
</p>
</li>
<li> <p><code>edge_bridges()</code>: Deprecated on 2022-06-28.
</p>
</li>
<li> <p><code>edge_reciprocal()</code>: Deprecated on 2022-06-28.
</p>
</li>
<li> <p><code>node_cuts()</code>: Deprecated on 2022-06-30.
</p>
</li>
<li> <p><code>graph_blau_index()</code>: Deprecated on 2022-09-10.
</p>
</li>
<li> <p><code>graph_diversity()</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>graph_ei_index()</code>: Deprecated on 2022-09-10.
</p>
</li>
<li> <p><code>graph_homophily()</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>plot(graph_test)</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>print(graph_test)</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>print(graph_measure)</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>print(graph_motif)</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>graph_adhesion()</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>graph_cohesion()</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>graph_assortativity()</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>graph_balance()</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>graph_betweenness()</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>graph_closeness()</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>graph_degree()</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>graph_eigenvector()</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>graph_components()</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>graph_factions()</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>graph_congruency()</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>graph_equivalency()</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>graph_core()</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>graph_density()</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>graph_reciprocity()</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>graph_transitivity()</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>graph_diameter()</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>graph_length()</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>graph_dyad_census()</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>graph_triad_census()</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>graph_mixed_census()</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>graph_modularity()</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>graph_smallworld()</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>network_homophily()</code>: Deprecated on 2022-09-25.
</p>
</li>
<li> <p><code>node_homophily()</code>: Deprecated on 2022-09-25.
</p>
</li></ul>

<hr>
<h2 id='degree_centrality'>Measures of degree-like centrality and centralisation</h2><span id='topic+degree_centrality'></span><span id='topic+node_degree'></span><span id='topic+node_deg'></span><span id='topic+node_outdegree'></span><span id='topic+node_indegree'></span><span id='topic+node_multidegree'></span><span id='topic+node_posneg'></span><span id='topic+tie_degree'></span><span id='topic+network_degree'></span><span id='topic+network_outdegree'></span><span id='topic+network_indegree'></span>

<h3>Description</h3>

<p>These functions calculate common degree-related centrality measures for one- and two-mode networks:
</p>

<ul>
<li> <p><code>node_degree()</code> measures the degree centrality of nodes in an unweighted network,
or weighted degree/strength of nodes in a weighted network;
there are several related shortcut functions:
</p>

<ul>
<li> <p><code>node_deg()</code> returns the unnormalised results.
</p>
</li>
<li> <p><code>node_indegree()</code> returns the <code>direction = 'in'</code> results.
</p>
</li>
<li> <p><code>node_outdegree()</code> returns the <code>direction = 'out'</code> results.
</p>
</li></ul>

</li>
<li> <p><code>node_multidegree()</code> measures the ratio between types of ties in a multiplex network.
</p>
</li>
<li> <p><code>node_posneg()</code> measures the PN (positive-negative) centrality of a signed network.
</p>
</li>
<li> <p><code>tie_degree()</code> measures the degree centrality of ties in a network
</p>
</li>
<li> <p><code>network_degree()</code> measures a network's degree centralization;
there are several related shortcut functions:
</p>

<ul>
<li> <p><code>network_indegree()</code> returns the <code>direction = 'out'</code> results.
</p>
</li>
<li> <p><code>network_outdegree()</code> returns the <code>direction = 'out'</code> results.
</p>
</li></ul>

</li></ul>

<p>All measures attempt to use as much information as they are offered,
including whether the networks are directed, weighted, or multimodal.
If this would produce unintended results,
first transform the salient properties using e.g. <code><a href="manynet.html#topic+to_undirected">to_undirected()</a></code> functions.
All centrality and centralization measures return normalized measures by default,
including for two-mode networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_degree(
  .data,
  normalized = TRUE,
  alpha = 1,
  direction = c("all", "out", "in")
)

node_deg(.data, alpha = 0, direction = c("all", "out", "in"))

node_outdegree(.data, normalized = TRUE, alpha = 0)

node_indegree(.data, normalized = TRUE, alpha = 0)

node_multidegree(.data, tie1, tie2)

node_posneg(.data)

tie_degree(.data, normalized = TRUE)

network_degree(.data, normalized = TRUE, direction = c("all", "out", "in"))

network_outdegree(.data, normalized = TRUE)

network_indegree(.data, normalized = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degree_centrality_+3A_.data">.data</code></td>
<td>
<p>An object of a <code>{manynet}</code>-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="degree_centrality_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar, whether the centrality scores are normalized.
Different denominators are used depending on whether the object is one-mode or two-mode,
the type of centrality, and other arguments.</p>
</td></tr>
<tr><td><code id="degree_centrality_+3A_alpha">alpha</code></td>
<td>
<p>Numeric scalar, the positive tuning parameter introduced in
Opsahl et al (2010) for trading off between degree and strength centrality measures.
By default, <code>alpha = 0</code>, which ignores tie weights and the measure is solely based
upon degree (the number of ties).
<code>alpha = 1</code> ignores the number of ties and provides the sum of the tie weights
as strength centrality.
Values between 0 and 1 reflect different trade-offs in the relative contributions of
degree and strength to the final outcome, with 0.5 as the middle ground.
Values above 1 penalise for the number of ties.
Of two nodes with the same sum of tie weights, the node with fewer ties will obtain
the higher score.
This argument is ignored except in the case of a weighted network.</p>
</td></tr>
<tr><td><code id="degree_centrality_+3A_direction">direction</code></td>
<td>
<p>Character string, “out” bases the measure on outgoing ties,
“in” on incoming ties, and &quot;all&quot; on either/the sum of the two.
For two-mode networks, &quot;all&quot; uses as numerator the sum of differences
between the maximum centrality score for the mode
against all other centrality scores in the network,
whereas &quot;in&quot; uses as numerator the sum of differences
between the maximum centrality score for the mode
against only the centrality scores of the other nodes in that mode.</p>
</td></tr>
<tr><td><code id="degree_centrality_+3A_tie1">tie1</code></td>
<td>
<p>Character string indicating the first uniplex network.</p>
</td></tr>
<tr><td><code id="degree_centrality_+3A_tie2">tie2</code></td>
<td>
<p>Character string indicating the second uniplex network.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single centralization score if the object was one-mode,
and two centralization scores if the object was two-mode.
</p>
<p>Depending on how and what kind of an object is passed to the function,
the function will return a <code>tidygraph</code> object where the nodes have been updated
</p>


<h3>References</h3>

<p>Faust, Katherine. 1997.
&quot;Centrality in affiliation networks.&quot;
<em>Social Networks</em> 19(2): 157-191.
<a href="https://doi.org/10.1016/S0378-8733%2896%2900300-0">doi:10.1016/S0378-8733(96)00300-0</a>.
</p>
<p>Borgatti, Stephen P., and Martin G. Everett. 1997.
&quot;Network analysis of 2-mode data.&quot;
<em>Social Networks</em> 19(3): 243-270.
<a href="https://doi.org/10.1016/S0378-8733%2896%2900301-2">doi:10.1016/S0378-8733(96)00301-2</a>.
</p>
<p>Borgatti, Stephen P., and Daniel S. Halgin. 2011.
&quot;Analyzing affiliation networks.&quot;
In <em>The SAGE Handbook of Social Network Analysis</em>,
edited by John Scott and Peter J. Carrington, 417–33.
London, UK: Sage.
<a href="https://doi.org/10.4135/9781446294413.n28">doi:10.4135/9781446294413.n28</a>.
</p>
<p>Opsahl, Tore, Filip Agneessens, and John Skvoretz. 2010.
&quot;Node centrality in weighted networks: Generalizing degree and shortest paths.&quot;
<em>Social Networks</em> 32, 245-251.
<a href="https://doi.org/10.1016/j.socnet.2010.03.006">doi:10.1016/j.socnet.2010.03.006</a>
</p>
<p>Everett, Martin G., and Stephen P. Borgatti. 2014.
“Networks Containing Negative Ties.”
<em>Social Networks</em> 38:111–20.
<a href="https://doi.org/10.1016/j.socnet.2014.03.005">doi:10.1016/j.socnet.2014.03.005</a>.
</p>


<h3>See Also</h3>

<p><code><a href="manynet.html#topic+to_undirected">to_undirected()</a></code> for removing edge directions
and <code><a href="manynet.html#topic+to_unweighted">to_unweighted()</a></code> for removing weights from a graph.
</p>
<p>Other centrality: 
<code><a href="#topic+between_centrality">between_centrality</a></code>,
<code><a href="#topic+close_centrality">close_centrality</a></code>,
<code><a href="#topic+eigenv_centrality">eigenv_centrality</a></code>
</p>
<p>Other measures: 
<code><a href="#topic+between_centrality">between_centrality</a></code>,
<code><a href="#topic+close_centrality">close_centrality</a></code>,
<code><a href="#topic+closure">closure</a></code>,
<code><a href="#topic+cohesion">cohesion</a>()</code>,
<code><a href="#topic+eigenv_centrality">eigenv_centrality</a></code>,
<code><a href="#topic+features">features</a></code>,
<code><a href="#topic+heterogeneity">heterogeneity</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+holes">holes</a></code>,
<code><a href="#topic+net_diffusion">net_diffusion</a></code>,
<code><a href="#topic+node_diffusion">node_diffusion</a></code>,
<code><a href="#topic+periods">periods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>node_degree(mpn_elite_mex)
node_degree(ison_southern_women)
tie_degree(ison_adolescents)
network_degree(ison_southern_women, direction = "in")
</code></pre>

<hr>
<h2 id='eigenv_centrality'>Measures of eigenvector-like centrality and centralisation</h2><span id='topic+eigenv_centrality'></span><span id='topic+node_eigenvector'></span><span id='topic+node_power'></span><span id='topic+node_alpha'></span><span id='topic+node_pagerank'></span><span id='topic+tie_eigenvector'></span><span id='topic+network_eigenvector'></span>

<h3>Description</h3>

<p>These functions calculate common eigenvector-related centrality measures for one- and two-mode networks:
</p>

<ul>
<li> <p><code>node_eigenvector()</code> measures the eigenvector centrality of nodes in a network.
</p>
</li>
<li> <p><code>node_power()</code> measures the Bonacich, beta, or power centrality of nodes in a network.
</p>
</li>
<li> <p><code>node_alpha()</code> measures the alpha or Katz centrality of nodes in a network.
</p>
</li>
<li> <p><code>node_pagerank()</code> measures the pagerank centrality of nodes in a network.
</p>
</li>
<li> <p><code>tie_eigenvector()</code> measures the eigenvector centrality of ties in a network.
</p>
</li>
<li> <p><code>network_eigenvector()</code> measures the eigenvector centralization for a network.
</p>
</li></ul>

<p>All measures attempt to use as much information as they are offered,
including whether the networks are directed, weighted, or multimodal.
If this would produce unintended results,
first transform the salient properties using e.g. <code><a href="manynet.html#topic+to_undirected">to_undirected()</a></code> functions.
All centrality and centralization measures return normalized measures by default,
including for two-mode networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_eigenvector(.data, normalized = TRUE, scale = FALSE)

node_power(.data, normalized = TRUE, scale = FALSE, exponent = 1)

node_alpha(.data, alpha = 0.85)

node_pagerank(.data)

tie_eigenvector(.data, normalized = TRUE)

network_eigenvector(.data, normalized = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigenv_centrality_+3A_.data">.data</code></td>
<td>
<p>An object of a <code>{manynet}</code>-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="eigenv_centrality_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar, whether the centrality scores are normalized.
Different denominators are used depending on whether the object is one-mode or two-mode,
the type of centrality, and other arguments.</p>
</td></tr>
<tr><td><code id="eigenv_centrality_+3A_scale">scale</code></td>
<td>
<p>Logical scalar, whether to rescale the vector so the maximum score is 1.</p>
</td></tr>
<tr><td><code id="eigenv_centrality_+3A_exponent">exponent</code></td>
<td>
<p>Decay rate for the Bonacich power centrality score.</p>
</td></tr>
<tr><td><code id="eigenv_centrality_+3A_alpha">alpha</code></td>
<td>
<p>A constant that trades off the importance of external influence against the importance of connection.
When <code class="reqn">\alpha = 0</code>, only the external influence matters.
As <code class="reqn">\alpha</code> gets larger, only the connectivity matters and we reduce to eigenvector centrality.
By default <code class="reqn">\alpha = 0.85</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We use <code>{igraph}</code> routines behind the scenes here for consistency and because they are often faster.
For example, <code>igraph::eigencentrality()</code> is approximately 25% faster than <code>sna::evcent()</code>.
</p>


<h3>Value</h3>

<p>A numeric vector giving the eigenvector centrality measure of each node.
</p>
<p>A numeric vector giving each node's power centrality measure.
</p>


<h3>Eigenvector centrality</h3>

<p>Eigenvector centrality operates as a measure of a node's influence in a network.
The idea is that being connected to well-connected others results in a higher score.
Each node's eigenvector centrality can be defined as:
</p>
<p style="text-align: center;"><code class="reqn">x_i = \frac{1}{\lambda} \sum_{j \in N} a_{i,j} x_j</code>
</p>

<p>where <code class="reqn">a_{i,j} = 1</code> if <code class="reqn">i</code> is linked to <code class="reqn">j</code> and 0 otherwise,
and <code class="reqn">\lambda</code> is a constant representing the principal eigenvalue.
Rather than performing this iteration,
most routines solve the eigenvector equation <code class="reqn">Ax = \lambda x</code>.
</p>


<h3>Power centrality</h3>

<p>Power or beta (or Bonacich) centrality
</p>


<h3>Alpha centrality</h3>

<p>Alpha or Katz (or Katz-Bonacich) centrality operates better than eigenvector centrality
for directed networks.
Eigenvector centrality will return 0s for all nodes not in the main strongly-connected component.
Each node's alpha centrality can be defined as:
</p>
<p style="text-align: center;"><code class="reqn">x_i = \frac{1}{\lambda} \sum_{j \in N} a_{i,j} x_j + e_i</code>
</p>

<p>where <code class="reqn">a_{i,j} = 1</code> if <code class="reqn">i</code> is linked to <code class="reqn">j</code> and 0 otherwise,
<code class="reqn">\lambda</code> is a constant representing the principal eigenvalue,
and <code class="reqn">e_i</code> is some external influence used to ensure that even nodes beyond the main
strongly connected component begin with some basic influence.
Note that many equations replace <code class="reqn">\frac{1}{\lambda}</code> with <code class="reqn">\alpha</code>,
hence the name.
</p>
<p>For example, if <code class="reqn">\alpha = 0.5</code>, then each direct connection (or alter) would be worth <code class="reqn">(0.5)^1 = 0.5</code>,
each secondary connection (or tertius) would be worth <code class="reqn">(0.5)^2 = 0.25</code>,
each tertiary connection would be worth <code class="reqn">(0.5)^3 = 0.125</code>, and so on.
</p>
<p>Rather than performing this iteration though,
most routines solve the equation <code class="reqn">x = (I - \frac{1}{\lambda} A^T)^{-1} e</code>.
</p>


<h3>References</h3>

<p>Bonacich, Phillip. 1991.
“Simultaneous Group and Individual Centralities.”
<em>Social Networks</em> 13(2):155–68.
<a href="https://doi.org/10.1016/0378-8733%2891%2990018-O">doi:10.1016/0378-8733(91)90018-O</a>.
</p>
<p>Bonacich, Phillip. 1987.
“Power and Centrality: A Family of Measures.”
<em>The American Journal of Sociology</em>, 92(5): 1170–82.
<a href="https://doi.org/10.1086/228631">doi:10.1086/228631</a>.
</p>
<p>Katz, Leo 1953.
&quot;A new status index derived from sociometric analysis&quot;.
<em>Psychometrika</em>. 18(1): 39–43.
</p>
<p>Bonacich, P. and Lloyd, P. 2001.
“Eigenvector-like measures of centrality for asymmetric relations”
<em>Social Networks</em>. 23(3):191-201.
</p>
<p>Brin, Sergey and Page, Larry. 1998.
&quot;The anatomy of a large-scale hypertextual web search engine&quot;.
<em>Proceedings of the 7th World-Wide Web Conference</em>. Brisbane, Australia.
</p>


<h3>See Also</h3>

<p>Other centrality: 
<code><a href="#topic+between_centrality">between_centrality</a></code>,
<code><a href="#topic+close_centrality">close_centrality</a></code>,
<code><a href="#topic+degree_centrality">degree_centrality</a></code>
</p>
<p>Other measures: 
<code><a href="#topic+between_centrality">between_centrality</a></code>,
<code><a href="#topic+close_centrality">close_centrality</a></code>,
<code><a href="#topic+closure">closure</a></code>,
<code><a href="#topic+cohesion">cohesion</a>()</code>,
<code><a href="#topic+degree_centrality">degree_centrality</a></code>,
<code><a href="#topic+features">features</a></code>,
<code><a href="#topic+heterogeneity">heterogeneity</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+holes">holes</a></code>,
<code><a href="#topic+net_diffusion">net_diffusion</a></code>,
<code><a href="#topic+node_diffusion">node_diffusion</a></code>,
<code><a href="#topic+periods">periods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>node_eigenvector(mpn_elite_mex)
node_eigenvector(ison_southern_women)
node_power(ison_southern_women, exponent = 0.5)
tie_eigenvector(ison_adolescents)
network_eigenvector(mpn_elite_mex)
network_eigenvector(ison_southern_women)
</code></pre>

<hr>
<h2 id='equivalence'>Equivalence clustering algorithms</h2><span id='topic+equivalence'></span><span id='topic+node_equivalence'></span><span id='topic+node_structural_equivalence'></span><span id='topic+node_regular_equivalence'></span><span id='topic+node_automorphic_equivalence'></span>

<h3>Description</h3>

<p>These functions combine an appropriate <code style="white-space: pre;">&#8288;_census()&#8288;</code> function
together with methods for calculating the hierarchical clusters
provided by a certain distance calculation.
</p>

<ul>
<li> <p><code>node_equivalence()</code> assigns nodes membership based on their equivalence
with respective to some census/class.
The following functions call this function, together with an appropriate census.
</p>

<ul>
<li> <p><code>node_structural_equivalence()</code> assigns nodes membership based on their
having equivalent ties to the same other nodes.
</p>
</li>
<li> <p><code>node_regular_equivalence()</code> assigns nodes membership based on their
having equivalent patterns of ties.
</p>
</li>
<li> <p><code>node_automorphic_equivalence()</code> assigns nodes membership based on their
having equivalent distances to other nodes.
</p>
</li></ul>

</li></ul>

<p>A <code>plot()</code> method exists for investigating the dendrogram
of the hierarchical cluster and showing the returned cluster
assignment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_equivalence(
  .data,
  census,
  k = c("silhouette", "elbow", "strict"),
  cluster = c("hierarchical", "concor"),
  distance = c("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski"),
  range = 8L
)

node_structural_equivalence(
  .data,
  k = c("silhouette", "elbow", "strict"),
  cluster = c("hierarchical", "concor"),
  distance = c("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski"),
  range = 8L
)

node_regular_equivalence(
  .data,
  k = c("silhouette", "elbow", "strict"),
  cluster = c("hierarchical", "concor"),
  distance = c("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski"),
  range = 8L
)

node_automorphic_equivalence(
  .data,
  k = c("silhouette", "elbow", "strict"),
  cluster = c("hierarchical", "concor"),
  distance = c("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski"),
  range = 8L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equivalence_+3A_.data">.data</code></td>
<td>
<p>An object of a <code>{manynet}</code>-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="equivalence_+3A_census">census</code></td>
<td>
<p>A matrix returned by a <code style="white-space: pre;">&#8288;node_*_census()&#8288;</code> function.</p>
</td></tr>
<tr><td><code id="equivalence_+3A_k">k</code></td>
<td>
<p>Typically a character string indicating which method
should be used to select the number of clusters to return.
By default <code>"silhouette"</code>, other options include <code>"elbow"</code> and <code>"strict"</code>.
<code>"strict"</code> returns classes with members only when strictly equivalent.
<code>"silhouette"</code> and <code>"elbow"</code> select classes based on the distance between
clusters or between nodes within a cluster.
Fewer, identifiable letters, e.g. <code>"e"</code> for elbow, is sufficient.
Alternatively, if <code>k</code> is passed an integer, e.g. <code>k = 3</code>,
then all selection routines are skipped in favour of this number of clusters.</p>
</td></tr>
<tr><td><code id="equivalence_+3A_cluster">cluster</code></td>
<td>
<p>Character string indicating whether clusters should be
clustered hierarchically (<code>"hierarchical"</code>) or
through convergence of correlations (<code>"concor"</code>).
Fewer, identifiable letters, e.g. <code>"c"</code> for CONCOR, is sufficient.</p>
</td></tr>
<tr><td><code id="equivalence_+3A_distance">distance</code></td>
<td>
<p>Character string indicating which distance metric
to pass on to <code>stats::dist</code>.
By default <code>"euclidean"</code>, but other options include
<code>"maximum"</code>, <code>"manhattan"</code>, <code>"canberra"</code>, <code>"binary"</code>, and <code>"minkowski"</code>.
Fewer, identifiable letters, e.g. <code>"e"</code> for Euclidean, is sufficient.</p>
</td></tr>
<tr><td><code id="equivalence_+3A_range">range</code></td>
<td>
<p>Integer indicating the maximum number of (k) clusters
to evaluate.
Ignored when <code>k = "strict"</code> or a discrete number is given for <code>k</code>.</p>
</td></tr>
</table>


<h3>Source</h3>

<p><a href="https://github.com/aslez/concoR">https://github.com/aslez/concoR</a>
</p>


<h3>See Also</h3>

<p>Other memberships: 
<code><a href="#topic+cliques">cliques</a></code>,
<code><a href="#topic+community">community</a></code>,
<code><a href="#topic+components">components</a>()</code>,
<code><a href="#topic+core">core</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(nse &lt;- node_structural_equivalence(mpn_elite_usa_advice))
plot(nse)


(nre &lt;- node_regular_equivalence(mpn_elite_usa_advice,
  cluster = "concor"))
plot(nre)


(nae &lt;- node_automorphic_equivalence(mpn_elite_usa_advice,
  k = "elbow"))
plot(nae)

</code></pre>

<hr>
<h2 id='features'>Measures of network topological features</h2><span id='topic+features'></span><span id='topic+network_core'></span><span id='topic+network_richclub'></span><span id='topic+network_factions'></span><span id='topic+network_modularity'></span><span id='topic+network_smallworld'></span><span id='topic+network_scalefree'></span><span id='topic+network_balance'></span>

<h3>Description</h3>

<p>These functions measure certain topological features of networks:
</p>

<ul>
<li> <p><code>network_core()</code> measures the correlation between a network
and a core-periphery model with the same dimensions.
</p>
</li>
<li> <p><code>network_richclub()</code> measures the rich-club coefficient of a network.
</p>
</li>
<li> <p><code>network_factions()</code> measures the correlation between a network
and a component model with the same dimensions.
If no 'membership' vector is given for the data,
<code>node_kernighanlin()</code> is used to partition nodes into two groups.
</p>
</li>
<li> <p><code>network_modularity()</code> measures the modularity of a network
based on nodes' membership in defined clusters.
</p>
</li>
<li> <p><code>network_smallworld()</code> measures the small-world coefficient for one- or
two-mode networks. Small-world networks can be highly clustered and yet
have short path lengths.
</p>
</li>
<li> <p><code>network_scalefree()</code> measures the exponent of a fitted
power-law distribution. An exponent between 2 and 3 usually indicates
a power-law distribution.
</p>
</li>
<li> <p><code>network_balance()</code> measures the structural balance index on
the proportion of balanced triangles,
ranging between <code>0</code> if all triangles are imbalanced and
<code>1</code> if all triangles are balanced.
</p>
</li>
<li> <p><code>network_change()</code> measures the Hamming distance between two or more networks.
</p>
</li>
<li> <p><code>network_stability()</code> measures the Jaccard index of stability between two or more networks.
</p>
</li></ul>

<p>These <code style="white-space: pre;">&#8288;network_*()&#8288;</code> functions return a single numeric scalar or value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_core(.data, membership = NULL)

network_richclub(.data)

network_factions(.data, membership = NULL)

network_modularity(.data, membership = NULL, resolution = 1)

network_smallworld(.data, method = c("omega", "sigma", "SWI"), times = 100)

network_scalefree(.data)

network_balance(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="features_+3A_.data">.data</code></td>
<td>
<p>An object of a <code>{manynet}</code>-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="features_+3A_membership">membership</code></td>
<td>
<p>A vector of partition membership.</p>
</td></tr>
<tr><td><code id="features_+3A_resolution">resolution</code></td>
<td>
<p>A proportion indicating the resolution scale.
By default 1.</p>
</td></tr>
<tr><td><code id="features_+3A_method">method</code></td>
<td>
<p>There are three small-world measures implemented:
</p>

<ul>
<li><p> &quot;sigma&quot; is the original equation from Watts and Strogatz (1998),
</p>
<p style="text-align: center;"><code class="reqn">\frac{\frac{C}{C_r}}{\frac{L}{L_r}}</code>
</p>
<p>,
where <code class="reqn">C</code> and <code class="reqn">L</code> are the observed
clustering coefficient and path length, respectively,
and <code class="reqn">C_r</code> and <code class="reqn">L_r</code> are the averages obtained from
random networks of the same dimensions and density.
A <code class="reqn">\sigma &gt; 1</code> is considered to be small-world,
but this measure is highly sensitive to network size.
</p>
</li>
<li><p> &quot;omega&quot; (the default) is an update from Telesford et al. (2011),
</p>
<p style="text-align: center;"><code class="reqn">\frac{L_r}{L} - \frac{C}{C_l}</code>
</p>
<p>,
where <code class="reqn">C_l</code> is the clustering coefficient for a lattice graph
with the same dimensions.
<code class="reqn">\omega</code> ranges between 0 and 1,
where 1 is as close to a small-world as possible.
</p>
</li>
<li><p> &quot;SWI&quot; is an alternative proposed by Neal (2017),
</p>
<p style="text-align: center;"><code class="reqn">\frac{L - L_l}{L_r - L_l} \times \frac{C - C_r}{C_l - C_r}</code>
</p>
<p>,
where <code class="reqn">L_l</code> is the average path length for a lattice graph
with the same dimensions.
<code class="reqn">SWI</code> also ranges between 0 and 1 with the same interpretation,
but where there may not be a network for which <code class="reqn">SWI = 1</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="features_+3A_times">times</code></td>
<td>
<p>Integer of number of simulations.</p>
</td></tr>
</table>


<h3>Modularity</h3>

<p>Modularity measures the difference between the number of ties within each community
from the number of ties expected within each community in a random graph
with the same degrees, and ranges between -1 and +1.
Modularity scores of +1 mean that ties only appear within communities,
while -1 would mean that ties only appear between communities.
A score of 0 would mean that ties are half within and half between communities,
as one would expect in a random graph.
</p>
<p>Modularity faces a difficult problem known as the resolution limit
(Fortunato and Barthélemy 2007).
This problem appears when optimising modularity,
particularly with large networks or depending on the degree of interconnectedness,
can miss small clusters that 'hide' inside larger clusters.
In the extreme case, this can be where they are only connected
to the rest of the network through a single tie.
</p>


<h3>Source</h3>

<p><code>{signnet}</code> by David Schoch
</p>


<h3>References</h3>

<p>Borgatti, Stephen P., and Martin G. Everett. 2000.
“Models of Core/Periphery Structures.”
<em>Social Networks</em> 21(4):375–95.
<a href="https://doi.org/10.1016/S0378-8733%2899%2900019-2">doi:10.1016/S0378-8733(99)00019-2</a>
</p>
<p>Murata, Tsuyoshi. 2010. Modularity for Bipartite Networks.
In: Memon, N., Xu, J., Hicks, D., Chen, H. (eds)
<em>Data Mining for Social Network Data. Annals of Information Systems</em>, Vol 12.
Springer, Boston, MA.
<a href="https://doi.org/10.1007/978-1-4419-6287-4_7">doi:10.1007/978-1-4419-6287-4_7</a>
</p>
<p>Watts, Duncan J., and Steven H. Strogatz. 1998.
“Collective Dynamics of ‘Small-World’ Networks.”
<em>Nature</em> 393(6684):440–42.
<a href="https://doi.org/10.1038/30918">doi:10.1038/30918</a>.
</p>
<p>Telesford QK, Joyce KE, Hayasaka S, Burdette JH, Laurienti PJ. 2011.
&quot;The ubiquity of small-world networks&quot;.
<em>Brain Connectivity</em> 1(5): 367–75.
<a href="https://doi.org/10.1089/brain.2011.0038">doi:10.1089/brain.2011.0038</a>.
</p>
<p>Neal Zachary P. 2017.
&quot;How small is it? Comparing indices of small worldliness&quot;.
<em>Network Science</em>. 5 (1): 30–44.
<a href="https://doi.org/10.1017/nws.2017.5">doi:10.1017/nws.2017.5</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+network_transitivity">network_transitivity()</a></code> and <code><a href="#topic+network_equivalency">network_equivalency()</a></code>
for how clustering is calculated
</p>
<p>Other measures: 
<code><a href="#topic+between_centrality">between_centrality</a></code>,
<code><a href="#topic+close_centrality">close_centrality</a></code>,
<code><a href="#topic+closure">closure</a></code>,
<code><a href="#topic+cohesion">cohesion</a>()</code>,
<code><a href="#topic+degree_centrality">degree_centrality</a></code>,
<code><a href="#topic+eigenv_centrality">eigenv_centrality</a></code>,
<code><a href="#topic+heterogeneity">heterogeneity</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+holes">holes</a></code>,
<code><a href="#topic+net_diffusion">net_diffusion</a></code>,
<code><a href="#topic+node_diffusion">node_diffusion</a></code>,
<code><a href="#topic+periods">periods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>network_core(ison_adolescents)
network_core(ison_southern_women)
network_richclub(ison_adolescents)
  network_factions(mpn_elite_mex)
  network_factions(ison_southern_women)
network_modularity(ison_adolescents, 
  node_kernighanlin(ison_adolescents))
network_modularity(ison_southern_women, 
  node_kernighanlin(ison_southern_women))
network_smallworld(ison_brandes)
network_smallworld(ison_southern_women)
network_scalefree(ison_adolescents)
network_scalefree(generate_scalefree(50, 1.5))
network_scalefree(create_lattice(100))
network_balance(ison_marvel_relationships)
</code></pre>

<hr>
<h2 id='heterogeneity'>Measures of network diversity</h2><span id='topic+heterogeneity'></span><span id='topic+network_richness'></span><span id='topic+node_richness'></span><span id='topic+network_diversity'></span><span id='topic+node_diversity'></span><span id='topic+network_heterophily'></span><span id='topic+node_heterophily'></span><span id='topic+network_assortativity'></span><span id='topic+network_spatial'></span>

<h3>Description</h3>

<p>These functions offer ways to summarise the heterogeneity of an attribute
across a network, within groups of a network, or the distribution of ties
across this attribute:
</p>

<ul>
<li> <p><code>network_richness()</code> measures the number of unique categories
in a network attribute.
</p>
</li>
<li> <p><code>node_richness()</code> measures the number of unique categories
of an attribute to which each node is connected.
</p>
</li>
<li> <p><code>network_diversity()</code> measures the heterogeneity of ties across a network
or within clusters by node attributes.
</p>
</li>
<li> <p><code>node_diversity()</code> measures the heterogeneity of each node's
local neighbourhood.
</p>
</li>
<li> <p><code>network_heterophily()</code> measures how embedded nodes in the network
are within groups of nodes with the same attribute.
</p>
</li>
<li> <p><code>node_heterophily()</code> measures each node's embeddedness within groups
of nodes with the same attribute.
</p>
</li>
<li> <p><code>network_assortativity()</code> measures the degree assortativity in a network.
</p>
</li>
<li> <p><code>network_spatial()</code> measures the spatial association/autocorrelation (
global Moran's I) in a network.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>network_richness(.data, attribute)

node_richness(.data, attribute)

network_diversity(.data, attribute, clusters = NULL)

node_diversity(.data, attribute)

network_heterophily(.data, attribute)

node_heterophily(.data, attribute)

network_assortativity(.data)

network_spatial(.data, attribute)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heterogeneity_+3A_.data">.data</code></td>
<td>
<p>An object of a <code>{manynet}</code>-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="heterogeneity_+3A_attribute">attribute</code></td>
<td>
<p>Name of a nodal attribute or membership vector
to use as categories for the diversity measure.</p>
</td></tr>
<tr><td><code id="heterogeneity_+3A_clusters">clusters</code></td>
<td>
<p>A nodal cluster membership vector or name of a vertex attribute.</p>
</td></tr>
</table>


<h3>network_diversity</h3>

<p>Blau's index (1977) uses a formula known also in other disciplines
by other names
(Gini-Simpson Index, Gini impurity, Gini's diversity index,
Gibbs-Martin index, and probability of interspecific encounter (PIE)):
</p>
<p style="text-align: center;"><code class="reqn">1 - \sum\limits_{i = 1}^k {p_i^2 }</code>
</p>
<p>,
where <code class="reqn">p_i</code> is the proportion of group members in <code class="reqn">i</code>th category
and <code class="reqn">k</code> is the number of categories for an attribute of interest.
This index can be interpreted as the probability that two members
randomly selected from a group would be from different categories.
This index finds its minimum value (0) when there is no variety,
i.e. when all individuals are classified in the same category.
The maximum value depends on the number of categories and
whether nodes can be evenly distributed across categories.
</p>


<h3>network_homophily</h3>

<p>Given a partition of a network into a number of mutually exclusive groups then
The E-I index is the number of ties between (or <em>external</em>) nodes
grouped in some mutually exclusive categories
minus the number of ties within (or <em>internal</em>) these groups
divided by the total number of ties.
This value can range from 1 to -1,
where 1 indicates ties only between categories/groups and -1 ties only within categories/groups.
</p>


<h3>References</h3>

<p>Blau, Peter M. (1977).
<em>Inequality and heterogeneity</em>.
New York: Free Press.
</p>
<p>Krackhardt, David and Robert N. Stern (1988).
Informal networks and organizational crises: an experimental simulation.
<em>Social Psychology Quarterly</em> 51(2), 123-140.
</p>
<p>Moran, Patrick Alfred Pierce. 1950.
&quot;Notes on Continuous Stochastic Phenomena&quot;.
<em>Biometrika</em> 37(1): 17-23.
<a href="https://doi.org/10.2307/2332142">doi:10.2307/2332142</a>
</p>


<h3>See Also</h3>

<p>Other measures: 
<code><a href="#topic+between_centrality">between_centrality</a></code>,
<code><a href="#topic+close_centrality">close_centrality</a></code>,
<code><a href="#topic+closure">closure</a></code>,
<code><a href="#topic+cohesion">cohesion</a>()</code>,
<code><a href="#topic+degree_centrality">degree_centrality</a></code>,
<code><a href="#topic+eigenv_centrality">eigenv_centrality</a></code>,
<code><a href="#topic+features">features</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+holes">holes</a></code>,
<code><a href="#topic+net_diffusion">net_diffusion</a></code>,
<code><a href="#topic+node_diffusion">node_diffusion</a></code>,
<code><a href="#topic+periods">periods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>network_richness(mpn_bristol)
node_richness(mpn_bristol, "type")
marvel_friends &lt;- manynet::to_unsigned(manynet::ison_marvel_relationships, "positive")
network_diversity(marvel_friends, "Gender")
network_diversity(marvel_friends, "Attractive")
network_diversity(marvel_friends, "Gender", "Rich")
node_diversity(marvel_friends, "Gender")
node_diversity(marvel_friends, "Attractive")
network_heterophily(marvel_friends, "Gender")
network_heterophily(marvel_friends, "Attractive")
node_heterophily(marvel_friends, "Gender")
node_heterophily(marvel_friends, "Attractive")
network_assortativity(mpn_elite_mex)
network_spatial(ison_lawfirm, "age")
</code></pre>

<hr>
<h2 id='hierarchy'>Graph theoretic dimensions of hierarchy</h2><span id='topic+hierarchy'></span><span id='topic+network_connectedness'></span><span id='topic+network_efficiency'></span><span id='topic+network_upperbound'></span>

<h3>Description</h3>

<p>These functions, together with <code>network_reciprocity()</code>, are used jointly to
measure how hierarchical a network is:
</p>

<ul>
<li> <p><code>network_connectedness()</code> measures the proportion of dyads in the network
that are reachable to one another,
or the degree to which network is a single component.
</p>
</li>
<li> <p><code>network_efficiency()</code> measures the Krackhardt efficiency score.
</p>
</li>
<li> <p><code>network_upperbound()</code> measures the Krackhardt (least) upper bound score.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>network_connectedness(.data)

network_efficiency(.data)

network_upperbound(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hierarchy_+3A_.data">.data</code></td>
<td>
<p>An object of a <code>{manynet}</code>-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
</table>


<h3>References</h3>

<p>Krackhardt, David. 1994.
Graph theoretical dimensions of informal organizations.
In Carley and Prietula (eds) <em>Computational Organizational Theory</em>,
Hillsdale, NJ: Lawrence Erlbaum Associates. Pp. 89-111.
</p>
<p>Everett, Martin, and David Krackhardt. 2012.
“A second look at Krackhardt's graph theoretical dimensions of informal organizations.”
<em>Social Networks</em>, 34: 159-163.
<a href="https://doi.org/10.1016/j.socnet.2011.10.006">doi:10.1016/j.socnet.2011.10.006</a>
</p>


<h3>See Also</h3>

<p>Other measures: 
<code><a href="#topic+between_centrality">between_centrality</a></code>,
<code><a href="#topic+close_centrality">close_centrality</a></code>,
<code><a href="#topic+closure">closure</a></code>,
<code><a href="#topic+cohesion">cohesion</a>()</code>,
<code><a href="#topic+degree_centrality">degree_centrality</a></code>,
<code><a href="#topic+eigenv_centrality">eigenv_centrality</a></code>,
<code><a href="#topic+features">features</a></code>,
<code><a href="#topic+heterogeneity">heterogeneity</a></code>,
<code><a href="#topic+holes">holes</a></code>,
<code><a href="#topic+net_diffusion">net_diffusion</a></code>,
<code><a href="#topic+node_diffusion">node_diffusion</a></code>,
<code><a href="#topic+periods">periods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>network_connectedness(ison_networkers)
1 - network_reciprocity(ison_networkers)
network_efficiency(ison_networkers)
network_upperbound(ison_networkers)
</code></pre>

<hr>
<h2 id='holes'>Measures of structural holes</h2><span id='topic+holes'></span><span id='topic+node_bridges'></span><span id='topic+node_redundancy'></span><span id='topic+node_effsize'></span><span id='topic+node_efficiency'></span><span id='topic+node_constraint'></span><span id='topic+node_hierarchy'></span><span id='topic+node_eccentricity'></span><span id='topic+node_neighbours_degree'></span><span id='topic+tie_cohesion'></span>

<h3>Description</h3>

<p>These function provide different measures of the degree to which nodes
fill structural holes, as outlined in Burt (1992):
</p>

<ul>
<li> <p><code>node_bridges()</code> measures the sum of bridges to which each node
is adjacent.
</p>
</li>
<li> <p><code>node_redundancy()</code> measures the redundancy of each nodes' contacts.
</p>
</li>
<li> <p><code>node_effsize()</code> measures nodes' effective size.
</p>
</li>
<li> <p><code>node_efficiency()</code> measures nodes' efficiency.
</p>
</li>
<li> <p><code>node_constraint()</code> measures nodes' constraint scores for one-mode networks
according to Burt (1992) and for two-mode networks according to Hollway et al (2020).
</p>
</li>
<li> <p><code>node_hierarchy()</code> measures nodes' exposure to hierarchy,
where only one or two contacts are the source of closure.
</p>
</li>
<li> <p><code>node_eccentricity()</code> measures nodes' eccentricity or Koenig number,
a measure of farness based on number of links needed to reach
most distant node in the network.
</p>
</li>
<li> <p><code>node_neighbours_degree()</code> measures nodes' average nearest neighbors degree,
or <code class="reqn">knn</code>, a measure of the type of local environment a node finds itself in
</p>
</li>
<li> <p><code>tie_cohesion()</code> measures the ratio between common neighbors to ties'
adjacent nodes and the total number of adjacent nodes,
where high values indicate ties' embeddedness in dense local environments
</p>
</li></ul>

<p>Burt's theory holds that while those nodes embedded in dense clusters
of close connections are likely exposed to the same or similar ideas and information,
those who fill structural holes between two otherwise disconnected groups
can gain some comparative advantage from that position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_bridges(.data)

node_redundancy(.data)

node_effsize(.data)

node_efficiency(.data)

node_constraint(.data)

node_hierarchy(.data)

node_eccentricity(.data)

node_neighbours_degree(.data)

tie_cohesion(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="holes_+3A_.data">.data</code></td>
<td>
<p>An object of a <code>{manynet}</code>-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>A number of different ways of measuring these structural holes are available.
Note that we use Borgatti's reformulation for unweighted networks in
<code>node_redundancy()</code> and <code>node_effsize()</code>.
Redundancy is thus <code class="reqn">\frac{2t}{n}</code>,
where <code class="reqn">t</code> is the sum of ties and <code class="reqn">n</code> the sum of nodes in each node's neighbourhood,
and effective size is calculated as <code class="reqn">n - \frac{2t}{n}</code>.
Node efficiency is the node's effective size divided by its degree.
</p>


<h3>References</h3>

<p>Burt, Ronald S. 1992.
<em>Structural Holes: The Social Structure of Competition</em>.
Cambridge, MA: Harvard University Press.
</p>
<p>Borgatti, Steven. 1997.
“<a href="http://www.analytictech.com/connections/v20(1)/holes.htm">Structural Holes: Unpacking Burt’s Redundancy Measures</a>”
<em>Connections</em> 20(1):35-38.
</p>
<p>Burchard, Jake, and Benjamin Cornwell. 2018.
“Structural Holes and Bridging in Two-Mode Networks.”
<em>Social Networks</em> 55:11–20.
<a href="https://doi.org/10.1016/j.socnet.2018.04.001">doi:10.1016/j.socnet.2018.04.001</a>
</p>
<p>Hollway, James, Jean-Frédéric Morin, and Joost Pauwelyn. 2020.
&quot;Structural conditions for novelty: the introduction of new environmental clauses to the trade regime complex.&quot;
<em>International Environmental Agreements: Politics, Law and Economics</em> 20 (1): 61–83.
<a href="https://doi.org/10.1007/s10784-019-09464-5">doi:10.1007/s10784-019-09464-5</a>.
</p>
<p>Barrat, Alain, Marc Barthelemy, Romualdo Pastor-Satorras, and Alessandro Vespignani. 2004.
&quot;The architecture of complex weighted networks&quot;,
<em>Proc. Natl. Acad. Sci.</em> 101: 3747.
</p>


<h3>See Also</h3>

<p>Other measures: 
<code><a href="#topic+between_centrality">between_centrality</a></code>,
<code><a href="#topic+close_centrality">close_centrality</a></code>,
<code><a href="#topic+closure">closure</a></code>,
<code><a href="#topic+cohesion">cohesion</a>()</code>,
<code><a href="#topic+degree_centrality">degree_centrality</a></code>,
<code><a href="#topic+eigenv_centrality">eigenv_centrality</a></code>,
<code><a href="#topic+features">features</a></code>,
<code><a href="#topic+heterogeneity">heterogeneity</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+net_diffusion">net_diffusion</a></code>,
<code><a href="#topic+node_diffusion">node_diffusion</a></code>,
<code><a href="#topic+periods">periods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>node_bridges(ison_adolescents)
node_bridges(ison_southern_women)
node_redundancy(ison_adolescents)
node_redundancy(ison_southern_women)
node_effsize(ison_adolescents)
node_effsize(ison_southern_women)
node_efficiency(ison_adolescents)
node_efficiency(ison_southern_women)
node_constraint(ison_southern_women)
node_hierarchy(ison_adolescents)
node_hierarchy(ison_southern_women)
</code></pre>

<hr>
<h2 id='kselect'>Methods for selecting clusters</h2><span id='topic+kselect'></span><span id='topic+k_strict'></span><span id='topic+k_elbow'></span><span id='topic+k_silhouette'></span>

<h3>Description</h3>

<p>These functions help select the number of clusters to return from <code>hc</code>,
some hierarchical clustering object:
</p>

<ul>
<li> <p><code>k_strict()</code> selects a number of clusters in which there is no
distance between cluster members.
</p>
</li>
<li> <p><code>k_elbow()</code> selects a number of clusters in which there is
a fair trade-off between parsimony and fit according to the elbow method.
</p>
</li>
<li> <p><code>k_silhouette()</code> selects a number of clusters that
optimises the silhouette score.
</p>
</li></ul>

<p>These functions are generally not user-facing but used internally
in e.g. the <code style="white-space: pre;">&#8288;*_equivalence()&#8288;</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k_strict(hc, .data)

k_elbow(hc, .data, census, range)

k_silhouette(hc, .data, range)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kselect_+3A_hc">hc</code></td>
<td>
<p>A hierarchical clustering object.</p>
</td></tr>
<tr><td><code id="kselect_+3A_.data">.data</code></td>
<td>
<p>An object of a <code>{manynet}</code>-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="kselect_+3A_census">census</code></td>
<td>
<p>A motif census object.</p>
</td></tr>
<tr><td><code id="kselect_+3A_range">range</code></td>
<td>
<p>An integer indicating the maximum number of options to consider.
The minimum of this and the number of nodes in the network is used.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Thorndike, Robert L. 1953.
&quot;Who Belongs in the Family?&quot;.
<em>Psychometrika</em>, 18(4): 267–76.
<a href="https://doi.org/10.1007/BF02289263">doi:10.1007/BF02289263</a>.
</p>
<p>Rousseeuw, Peter J. 1987.
“Silhouettes: A Graphical Aid to the Interpretation and Validation of Cluster Analysis.”
<em>Journal of Computational and Applied Mathematics</em>, 20: 53–65.
<a href="https://doi.org/10.1016/0377-0427%2887%2990125-7">doi:10.1016/0377-0427(87)90125-7</a>.
</p>

<hr>
<h2 id='migraph-package'>migraph: Many Network Measures, Motifs, Members, and Models</h2><span id='topic+migraph'></span><span id='topic+migraph-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A set of tools for analysing multimodal networks. It includes functions for measuring centrality, centralization, cohesion, closure, constraint and diversity, as well as for network block-modelling, regression, and diffusion models. The package is released as a complement to 'Multimodal Political Networks' (2021, ISBN:9781108985000), and includes various datasets used in the book. Built on the 'manynet' package, all functions operate with matrices, edge lists, and 'igraph', 'network', and 'tidygraph' objects, and on one-mode, two-mode (bipartite), and sometimes three-mode networks.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: James Hollway <a href="mailto:james.hollway@graduateinstitute.ch">james.hollway@graduateinstitute.ch</a> (<a href="https://orcid.org/0000-0002-8361-9647">ORCID</a>) (IHEID) [contributor]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Henrique Sposito (<a href="https://orcid.org/0000-0003-3420-6085">ORCID</a>) (IHEID) [contributor]
</p>
</li>
<li><p> Jael Tan <a href="mailto:jael.tan@graduateinstitute.ch">jael.tan@graduateinstitute.ch</a> (<a href="https://orcid.org/0000-0002-6234-9764">ORCID</a>) (IHEID) [contributor]
</p>
</li>
<li><p> Bernhard Bieri <a href="mailto:bernhard.bieri@graduateinstitute.ch">bernhard.bieri@graduateinstitute.ch</a> (<a href="https://orcid.org/0000-0001-5943-9059">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://stocnet.github.io/migraph/">https://stocnet.github.io/migraph/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/stocnet/migraph/issues">https://github.com/stocnet/migraph/issues</a>
</p>
</li></ul>


<hr>
<h2 id='mpn_bristol'>Multimodal (3) Bristol protest events, 1990-2002 (Diani and Bison 2004)</h2><span id='topic+mpn_bristol'></span>

<h3>Description</h3>

<p>A multimodal network with three levels representing ties between individuals,
civic organisations in Bristol, and major protest and civic events that occurred
between 1990 and 2000. The data contains individuals' affiliations to civic organizations
in Bristol, the participation of these individuals in major protest and civic events between 1990-2002,
and the involvement of the civic organizations in these events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mpn_bristol)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A labelled, two-mode network with 264 nodes and 1496 ties
#&gt; # A tibble: 264 x 3
#&gt;   name  type    lvl
#&gt;   &lt;chr&gt; &lt;lgl&gt; &lt;dbl&gt;
#&gt; 1 101   FALSE     1
#&gt; 2 102   FALSE     1
#&gt; 3 103   FALSE     1
#&gt; 4 104   FALSE     1
#&gt; 5 105   FALSE     1
#&gt; 6 106   FALSE     1
#&gt; # i 258 more rows
#&gt; # A tibble: 1,496 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1    36   151
#&gt; 2    40   151
#&gt; 3    73   151
#&gt; 4    94   151
#&gt; 5   138   151
#&gt; 6   145   151
#&gt; # i 1,490 more rows
</pre></div>


<h3>Details</h3>

<p>Although represented as a two-mode network, it contains three levels:
</p>

<dl>
<dt>1.</dt><dd><p>150 Individuals, anonymised with numeric ID</p>
</dd>
<dt>2.</dt><dd><p>97 Bristol civic organizations</p>
</dd>
<dt>3.</dt><dd><p>17 Major protest and civic events in Bristol, 1990-2002</p>
</dd>
</dl>

<p>The network represents ties between level 1 (individuals) and level 2 (organisations),
level 1 (individuals) and level 3 (events), as well as level 2 (organisations)
and level 3 (events). The network is simple, undirected, and named. For a complete list of
civic organisations and protest/civic events included in the data, please see Appendix 6.1
in <a href="https://www.cambridge.org/core/books/multimodal-political-networks/43EE8C192A1B0DCD65B4D9B9A7842128"><em>Multimodal Political Networks</em></a>
(Knoke et al., 2021).
</p>


<h3>Source</h3>

<p>Knoke, David, Mario Diani, James Hollway, and Dimitris C Christopoulos. 2021.
<a href="https://www.cambridge.org/core/books/multimodal-political-networks/43EE8C192A1B0DCD65B4D9B9A7842128"><em>Multimodal Political Networks</em></a>.
Cambridge University Press. Cambridge University Press.
</p>


<h3>References</h3>

<p>Diani, Mario, and Ivano Bison. 2004.
“Organizations, Coalitions, and Movements.”
<em>Theory and Society</em> 33(3–4):281–309.
<a href="https://doi.org/10.1023/B%3ARYSO.0000038610.00045.07">doi:10.1023/B:RYSO.0000038610.00045.07</a>.
</p>

<hr>
<h2 id='mpn_cow'>One-mode interstate trade relations and two-mode state membership in IGOs (COW)</h2><span id='topic+mpn_cow'></span><span id='topic+mpn_cow_trade'></span><span id='topic+mpn_cow_igo'></span>

<h3>Description</h3>

<p>One-mode interstate trade relations and two-mode state membership in IGOs (COW)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mpn_cow_trade)

data(mpn_cow_igo)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A labelled, weighted, directed network with 116 nodes and 11489 arcs
#&gt; # A tibble: 116 x 1
#&gt;   name                    
#&gt;   &lt;chr&gt;                   
#&gt; 1 United States of America
#&gt; 2 Canada                  
#&gt; 3 Cuba                    
#&gt; 4 Dominican Republic      
#&gt; 5 Jamaica                 
#&gt; 6 Trinidad and Tobago     
#&gt; # i 110 more rows
#&gt; # A tibble: 11,489 x 3
#&gt;    from    to  weight
#&gt;   &lt;int&gt; &lt;int&gt;   &lt;dbl&gt;
#&gt; 1     1     2 180387 
#&gt; 2     1     3    587.
#&gt; 3     1     4   5511.
#&gt; 4     1     5   1896.
#&gt; 5     1     6   2188.
#&gt; 6     1     7 123677 
#&gt; # i 11,483 more rows
</pre></div>
<div class="sourceCode"><pre>#&gt; # A labelled, weighted, two-mode network with 152 nodes and 839 ties
#&gt; # A tibble: 152 x 3
#&gt;   name        type  polity2
#&gt;   &lt;chr&gt;       &lt;lgl&gt;   &lt;dbl&gt;
#&gt; 1 Afghanistan FALSE      -7
#&gt; 2 Albania     FALSE       5
#&gt; 3 Algeria     FALSE      -3
#&gt; 4 Angola      FALSE      -6
#&gt; 5 Argentina   FALSE       8
#&gt; 6 Australia   FALSE      10
#&gt; # i 146 more rows
#&gt; # A tibble: 839 x 3
#&gt;    from    to weight
#&gt;   &lt;int&gt; &lt;int&gt;  &lt;dbl&gt;
#&gt; 1     1   113      1
#&gt; 2     1   114      1
#&gt; 3     1   115      0
#&gt; 4     1   116      0
#&gt; 5     1   117      1
#&gt; 6     1   118      0
#&gt; # i 833 more rows
</pre></div>


<h3>Details</h3>

<p><code>mpn_cow_trade</code> is a one-mode matrix representing the trade relations between 116 states.
The data is derived from the Correlates of War Project (COW) Trade Dataset (v3.0),
which contains the annual dyadic and national trade figures for states (listed in COW)
between 1870 to 2009.
This network is based only on the dyadic trade figures in 2009 for the 116 states
listed in Appendix 7.1 in
<a href="https://www.cambridge.org/core/books/multimodal-political-networks/43EE8C192A1B0DCD65B4D9B9A7842128"><em>Multimodal Political Networks</em></a>
(Knoke et al., 2021).
The value in each cell of the matrix represents the value of exports
from the 116 row states to the 116 column states.
</p>
<p><code>mpn_cow_igo</code> is a two-mode graph representing the membership of 116 states
in 40 intergovernmental organizations (IGOs).
The data is derived from the Correlates of War Project (COW)
Intergovernmental Organizations Dataset (v3.0),
which contains information about intergovernmental organizations from 1815-2014,
such as founding year and membership.
This network contains only a subset of the states and IGOs listed in COW,
with 116 states listed in Appendix 7.1 in <a href="https://www.cambridge.org/core/books/multimodal-political-networks/43EE8C192A1B0DCD65B4D9B9A7842128"><em>Multimodal Political Networks</em></a>
and 40 IGOs from Table 7.1 in <a href="https://www.cambridge.org/core/books/multimodal-political-networks/43EE8C192A1B0DCD65B4D9B9A7842128"><em>Multimodal Political Networks</em></a>
that also overlap with the COW dataset (Knoke et al., 2021).
</p>


<h3>Source</h3>

<p>The Correlates of War Project. 2012. <em>Trade</em>.
</p>
<p>Barbieri, Katherine and Omar Keshk. 2012.
Correlates of War Project Trade Data Set Codebook, Version 3.0.
</p>
<p>The Correlates of War Project. 2019. <em>Intergovernmental Organization v3</em>.
</p>


<h3>References</h3>

<p>Barbieri, Katherine, Omar M. G. Keshk, and Brian Pollins. 2009.
“TRADING DATA: Evaluating our Assumptions and Coding Rules.”
<em>Conflict Management and Peace Science</em> 26(5): 471-491.
<a href="https://doi.org/10.1177/0738894209343887">doi:10.1177/0738894209343887</a>.
</p>
<p>Knoke, David, Mario Diani, James Hollway, and Dimitris C Christopoulos. 2021.
<a href="https://www.cambridge.org/core/books/multimodal-political-networks/43EE8C192A1B0DCD65B4D9B9A7842128"><em>Multimodal Political Networks</em></a>.
Cambridge University Press. Cambridge University Press.
</p>
<p>Pevehouse, Jon C.W., Timothy Nordstron, Roseanne W McManus, Anne Spencer Jamison. 2020.
“Tracking Organizations in the World: The Correlates of War IGO Version 3.0 datasets”.
<em>Journal of Peace Research</em> 57(3): 492-503.
<a href="https://doi.org/10.1177/0022343319881175">doi:10.1177/0022343319881175</a>.
</p>

<hr>
<h2 id='mpn_elite_mex'>One-mode Mexican power elite database (Knoke 1990)</h2><span id='topic+mpn_elite_mex'></span>

<h3>Description</h3>

<p>This data contains the full network of 35 members of the Mexican power elite.
The undirected lines connecting pairs of men represent any formal, informal,
or organizational relation between a dyad;
for example, “common belonging (school, sports, business, political participation),
or a common interest (political power)” (Mendieta et al. 1997: 37).
Additional nodal attributes include their full name, place of birth, state,
and region (1=North, 2=Centre, 3=South, original coding added by
<a href="https://jameshollway.com/courses/ison/heber_post">Frank Heber</a>),
as well as their year of entry into politics
and whether they are civilian (0) or affiliated with the military (1).
An additional variable &quot;in_mpn&quot; can be used to subset this network
to a network of 11 core members of the 1990s Mexican power elite (Knoke 2017),
three of which were successively elected presidents of Mexico:
José López Portillo (1976-82), Miguel de la Madrid (1982-88), and Carlos Salinas de Gortari (1988-94,
who was also the son of another core member, Raúl Salinas Lozano).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mpn_elite_mex)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A labelled, undirected network with 35 nodes and 117 ties
#&gt; # A tibble: 35 x 8
#&gt;   name     full_name        entry_year military in_mpn PlaceOfBirth state region
#&gt;   &lt;chr&gt;    &lt;chr&gt;                 &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;        &lt;chr&gt;  &lt;dbl&gt;
#&gt; 1 Trevino  Trevino, Jacint~       1910        1      0 Guerrero     Coah~      1
#&gt; 2 Madero   Madero, Francis~       1911        0      0 Parras de l~ Coah~      1
#&gt; 3 Carranza Carranza, Venus~       1913        1      0 Cuatro Cien~ Coah~      1
#&gt; 4 Aguilar  Aguilar, Candido       1918        1      0 Cordoba      Vera~      3
#&gt; 5 Obregon  Obregon, Alvaro        1920        1      0 Siquisiva, ~ Sono~      1
#&gt; 6 Calles   Calles, Plutarc~       1924        1      0 Guaymas      Sono~      1
#&gt; # i 29 more rows
#&gt; # A tibble: 117 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     2     3
#&gt; 2     2     5
#&gt; 3     2     6
#&gt; 4     2     4
#&gt; 5     1     2
#&gt; 6     2     8
#&gt; # i 111 more rows
</pre></div>


<h3>Details</h3>

<p><img src="../help/figures/mpnelitemex.png" width="100%" alt="Figure: mpn\_elite\_mex" />

</p>


<h3>Source</h3>

<p>Knoke, David. 1990. <em>Political Networks</em>.
</p>
<p>Knoke, David, Mario Diani, James Hollway, and Dimitris C Christopoulos. 2021.
<a href="https://www.cambridge.org/core/books/multimodal-political-networks/43EE8C192A1B0DCD65B4D9B9A7842128"><em>Multimodal Political Networks</em></a>.
Cambridge University Press. Cambridge University Press.
</p>

<hr>
<h2 id='mpn_elite_usa'>Two-mode and three-mode American power elite database (Domhoff 2016)</h2><span id='topic+mpn_elite_usa'></span><span id='topic+mpn_elite_usa_advice'></span><span id='topic+mpn_elite_usa_money'></span>

<h3>Description</h3>

<p><code>mpn_elite_usa_advice</code> is a 2-mode network of persons serving as directors or trustees of think tanks.
Think tanks are “public-policy research analysis and engagement organizations
that generate policy-oriented research, analysis, and advice on domestic and international issues,
thereby enabling policymakers and the public to make informed decisions about public policy” (McGann 2016: 6).
The Power Elite Database (Domhoff 2016) includes information on the directors of 33 prominent think tanks in 2012.
Here we include only 14 directors who held three or more seats among 20 think tanks.
</p>
<p><code>mpn_elite_usa_money</code> is based on 26 elites who sat on the boards of directors
for at least two of six economic policy making organizations (Domhoff 2016),
and also made campaign contributions to one or more of six candidates
running in the primary election contests for the 2008 Presidential nominations
of the Republican Party (Rudy Giuliani, John McCain, Mitt Romney)
or the Democratic Party (Hillary Clinton, Christopher Dodd, Barack Obama).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mpn_elite_usa_advice)

data(mpn_elite_usa_money)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A labelled, two-mode network with 34 nodes and 46 ties
#&gt; # A tibble: 34 x 2
#&gt;   type  name    
#&gt;   &lt;lgl&gt; &lt;chr&gt;   
#&gt; 1 FALSE Albright
#&gt; 2 FALSE Argyros 
#&gt; 3 FALSE Armitage
#&gt; 4 FALSE Curry   
#&gt; 5 FALSE Fukuyama
#&gt; 6 FALSE Gray    
#&gt; # i 28 more rows
#&gt; # A tibble: 46 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     1    17
#&gt; 2     1    19
#&gt; 3     1    21
#&gt; 4     2    22
#&gt; 5     2    23
#&gt; 6     2    27
#&gt; # i 40 more rows
</pre></div>
<div class="sourceCode"><pre>#&gt; # A labelled, two-mode network with 38 nodes and 103 ties
#&gt; # A tibble: 38 x 2
#&gt;   type  name    
#&gt;   &lt;lgl&gt; &lt;chr&gt;   
#&gt; 1 FALSE Adkerson
#&gt; 2 FALSE Akins   
#&gt; 3 FALSE Banga   
#&gt; 4 FALSE Boyce   
#&gt; 5 FALSE Britt   
#&gt; 6 FALSE Cannon  
#&gt; # i 32 more rows
#&gt; # A tibble: 103 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     1    27
#&gt; 2     1    28
#&gt; 3     1    34
#&gt; 4     1    36
#&gt; 5     2    28
#&gt; 6     2    32
#&gt; # i 97 more rows
</pre></div>


<h3>Details</h3>

<p><img src="../help/figures/mpneliteusa.png" width="100%" alt="Figure: mpn\_elite\_usa" />

</p>


<h3>References</h3>

<p>Domhoff, G William. 2016. <a href="https://whorulesamerica.ucsc.edu/power_elite/">“Who Rules America? Power Elite Database.”</a>
</p>
<p>The Center for Responsive Politics. 2019. <a href="https://www.opensecrets.org">“OpenSecrets.”</a>
</p>
<p>Knoke, David, Mario Diani, James Hollway, and Dimitris C Christopoulos. 2021.
<a href="https://www.cambridge.org/core/books/multimodal-political-networks/43EE8C192A1B0DCD65B4D9B9A7842128"><em>Multimodal Political Networks</em></a>.
Cambridge University Press. Cambridge University Press.
</p>

<hr>
<h2 id='mpn_evs'>Two-mode European Values Survey, 1990 and 2008 (EVS 2020)</h2><span id='topic+mpn_evs'></span><span id='topic+mpn_IT_1990'></span><span id='topic+mpn_IT_2008'></span><span id='topic+mpn_DE_1990'></span><span id='topic+mpn_DE_2008'></span><span id='topic+mpn_UK_1990'></span><span id='topic+mpn_UK_2008'></span>

<h3>Description</h3>

<p>6 two-mode matrices containing individuals' memberships to 14 different types
of associations in three countries (Italy, Germany, and the UK) in 1990
and 2008. The Italy data has 658 respondents in 1990 and 540 in 2008.
The Germany data has 1369 respondents in 1990 and 503 in 2008.
The UK data has 738 respondents in 1990 and 664 in 2008.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mpn_IT_1990)

data(mpn_IT_1990)

data(mpn_IT_2008)

data(mpn_DE_1990)

data(mpn_DE_2008)

data(mpn_UK_1990)

data(mpn_UK_2008)
</code></pre>


<h3>Format</h3>

<p><code>tbl_graph</code> object based on an association matrix with 14 columns:
</p>

<dl>
<dt>Welfare</dt><dd><p>1 if individual associated</p>
</dd>
<dt>Religious</dt><dd><p>1 if individual associated</p>
</dd>
<dt>Education.culture</dt><dd><p>1 if individual associated</p>
</dd>
<dt>Unions</dt><dd><p>1 if individual associated</p>
</dd>
<dt>Parties</dt><dd><p>1 if individual associated</p>
</dd>
<dt>Local.political.groups</dt><dd><p>1 if individual associated</p>
</dd>
<dt>Human.rights</dt><dd><p>1 if individual associated</p>
</dd>
<dt>Environmental.animal</dt><dd><p>1 if individual associated</p>
</dd>
<dt>Professional</dt><dd><p>1 if individual associated</p>
</dd>
<dt>Youth</dt><dd><p>1 if individual associated</p>
</dd>
<dt>Sports</dt><dd><p>1 if individual associated</p>
</dd>
<dt>Women</dt><dd><p>1 if individual associated</p>
</dd>
<dt>Peace</dt><dd><p>1 if individual associated</p>
</dd>
<dt>Health</dt><dd><p>1 if individual associated</p>
</dd>
</dl>

<p>An object of class <code>tbl_graph</code> (inherits from <code>igraph</code>) of length 672.
</p>
<p>An object of class <code>tbl_graph</code> (inherits from <code>igraph</code>) of length 554.
</p>
<p>An object of class <code>tbl_graph</code> (inherits from <code>igraph</code>) of length 1383.
</p>
<p>An object of class <code>tbl_graph</code> (inherits from <code>igraph</code>) of length 517.
</p>
<p>An object of class <code>tbl_graph</code> (inherits from <code>igraph</code>) of length 752.
</p>
<p>An object of class <code>tbl_graph</code> (inherits from <code>igraph</code>) of length 678.
</p>


<h3>Source</h3>

<p>Knoke, David, Mario Diani, James Hollway, and Dimitris C Christopoulos. 2021.
<a href="https://www.cambridge.org/core/books/multimodal-political-networks/43EE8C192A1B0DCD65B4D9B9A7842128"><em>Multimodal Political Networks</em></a>.
Cambridge University Press. Cambridge University Press.
</p>


<h3>References</h3>

<p>EVS (2020). European Values Study Longitudinal Data File 1981-2008 (EVS 1981-2008).
GESIS Data Archive, Cologne. ZA4804 Data file Version 3.1.0,
<a href="https://doi.org/10.4232/1.13486">doi:10.4232/1.13486</a>.
</p>

<hr>
<h2 id='mpn_ryanair'>One-mode EU policy influence network, June 2004 (Christopoulos 2006)</h2><span id='topic+mpn_ryanair'></span>

<h3>Description</h3>

<p>Network of anonymised actors reacting to the Ryanair/Charleroi decision of
the EU Commission in February 2004.
The relationships mapped comprise an account of public records of interaction
supplemented with the cognitive network of key informants.
Examination of relevant communiques, public statements and a number of
off-the-record interviews provides confidence
that the network mapped closely approximated interactions between 29 January
and 12 February 2004. The time point mapped is at the height of influence and
interest intermediation played by actors in the AER,
a comparatively obscure body representing the interests of a number of
European regional bodies at the EU institutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mpn_ryanair)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A labelled, weighted, directed network with 20 nodes and 177 arcs
#&gt; # A tibble: 20 x 1
#&gt;   name          
#&gt;   &lt;chr&gt;         
#&gt; 1 1 AER         
#&gt; 2 2 AER         
#&gt; 3 5 AER/COR     
#&gt; 4 7 RYANAIR     
#&gt; 5 8 DG TRANSPORT
#&gt; 6 9 COR         
#&gt; # i 14 more rows
#&gt; # A tibble: 177 x 3
#&gt;    from    to weight
#&gt;   &lt;int&gt; &lt;int&gt;  &lt;dbl&gt;
#&gt; 1     1     2      1
#&gt; 2     1     3      1
#&gt; 3     1     4      1
#&gt; 4     1     5      1
#&gt; 5     1     6      1
#&gt; 6     1     7      1
#&gt; # i 171 more rows
</pre></div>


<h3>Source</h3>

<p>Christopoulos, Dimitrios C. 2006.
“Relational Attributes of Political Entrepreneurs: a Network Perspective.”
<em>Journal of European Public Policy</em> 13(5): 757–78.
<a href="https://doi.org/10.1080/13501760600808964">doi:10.1080/13501760600808964</a>.
</p>
<p>Knoke, David, Mario Diani, James Hollway, and Dimitris C Christopoulos. 2021.
<a href="https://www.cambridge.org/core/books/multimodal-political-networks/43EE8C192A1B0DCD65B4D9B9A7842128"><em>Multimodal Political Networks</em></a>.
Cambridge University Press. Cambridge University Press.
</p>

<hr>
<h2 id='mpn_senate112'>Two-mode 112th Congress Senate Voting (Knoke et al. 2021)</h2><span id='topic+mpn_senate112'></span><span id='topic+mpn_DemSxP'></span><span id='topic+mpn_RepSxP'></span><span id='topic+mpn_OverSxP'></span>

<h3>Description</h3>

<p>These datasets list the U.S. Senators who served in the 112th Congress,
which met from January 3, 2011 to January 3, 2013.
Although the Senate has 100 seats, 103 persons served during this period due
to two resignations and a death. However, the third replacement occurred
only two days before the end and cast no votes on the bills investigated
here. Hence, the number of Senators analyzed is 102.
</p>
<p>CQ Almanac identified 25 key bills on which the Senate voted during the
112th Congress, and which Democratic and Republican Senators voting “yea”
and “nay” on each proposal.
</p>
<p>Lastly, we obtained data on campaign contributions made by 92 PACs from the
Open Secrets Website. We recorded all contributions made during the 2008,
2010, and 2012 election campaigns to the 102 persons who were Senators in
the 112th Congress. The vast majority of PAC contributions to a candidate
during a campaign was for $10,000 (the legal maximum is $5,000 each for a
primary and the general election). We aggregated the contributions across
all three electoral cycles, then dichotomized the sums into no contribution
(0) and any contribution (1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mpn_DemSxP)

data(mpn_RepSxP)

data(mpn_OverSxP)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A labelled, weighted, two-mode network with 114 nodes and 2791 ties
#&gt; # A tibble: 114 x 2
#&gt;   type  name      
#&gt;   &lt;lgl&gt; &lt;chr&gt;     
#&gt; 1 FALSE Baucus    
#&gt; 2 FALSE Begich    
#&gt; 3 FALSE Bennet    
#&gt; 4 FALSE Blumenthal
#&gt; 5 FALSE Boxer     
#&gt; 6 FALSE BrownSh   
#&gt; # i 108 more rows
#&gt; # A tibble: 2,791 x 3
#&gt;    from    to weight
#&gt;   &lt;int&gt; &lt;int&gt;  &lt;dbl&gt;
#&gt; 1     1    52      1
#&gt; 2     1    53      1
#&gt; 3     1    54      1
#&gt; 4     1    55      1
#&gt; 5     1    56      1
#&gt; 6     1    57      1
#&gt; # i 2,785 more rows
</pre></div>
<div class="sourceCode"><pre>#&gt; # A labelled, weighted, two-mode network with 134 nodes and 3675 ties
#&gt; # A tibble: 134 x 2
#&gt;   type  name     
#&gt;   &lt;lgl&gt; &lt;chr&gt;    
#&gt; 1 FALSE Alexander
#&gt; 2 FALSE Ayotte   
#&gt; 3 FALSE Barrasso 
#&gt; 4 FALSE Baucus   
#&gt; 5 FALSE Blunt    
#&gt; 6 FALSE Boozman  
#&gt; # i 128 more rows
#&gt; # A tibble: 3,675 x 3
#&gt;    from    to weight
#&gt;   &lt;int&gt; &lt;int&gt;  &lt;dbl&gt;
#&gt; 1     1    64      1
#&gt; 2     1    66      1
#&gt; 3     1    67      1
#&gt; 4     1    70      1
#&gt; 5     1    71      1
#&gt; 6     1    72      1
#&gt; # i 3,669 more rows
</pre></div>
<div class="sourceCode"><pre>#&gt; # A labelled, weighted, two-mode network with 52 nodes and 614 ties
#&gt; # A tibble: 52 x 2
#&gt;   type  name     
#&gt;   &lt;lgl&gt; &lt;chr&gt;    
#&gt; 1 FALSE Baucus   
#&gt; 2 FALSE Cardin   
#&gt; 3 FALSE Carper   
#&gt; 4 FALSE Casey    
#&gt; 5 FALSE Collins  
#&gt; 6 FALSE Feinstein
#&gt; # i 46 more rows
#&gt; # A tibble: 614 x 3
#&gt;    from    to weight
#&gt;   &lt;int&gt; &lt;int&gt;  &lt;dbl&gt;
#&gt; 1     1    21      1
#&gt; 2     1    22      1
#&gt; 3     1    23      1
#&gt; 4     1    24      1
#&gt; 5     1    25      1
#&gt; 6     1    26      1
#&gt; # i 608 more rows
</pre></div>


<h3>References</h3>

<p>Knoke, David, Mario Diani, James Hollway, and Dimitris C Christopoulos. 2021.
<a href="https://www.cambridge.org/core/books/multimodal-political-networks/43EE8C192A1B0DCD65B4D9B9A7842128"><em>Multimodal Political Networks</em></a>.
Cambridge University Press. Cambridge University Press.
</p>

<hr>
<h2 id='net_diffusion'>Measures of network diffusion</h2><span id='topic+net_diffusion'></span><span id='topic+network_transmissibility'></span><span id='topic+network_infection_length'></span><span id='topic+network_reproduction'></span><span id='topic+network_immunity'></span><span id='topic+network_hazard'></span>

<h3>Description</h3>

<p>These functions allow measurement of various features of
a diffusion process:
</p>

<ul>
<li> <p><code>network_transmissibility()</code> measures the average transmissibility observed
in a diffusion simulation, or the number of new infections over
the number of susceptible nodes.
</p>
</li>
<li> <p><code>network_infection_length()</code> measures the average number of time steps
nodes remain infected once they become infected.
</p>
</li>
<li> <p><code>network_reproduction()</code> measures the observed reproductive number
in a diffusion simulation as the network's transmissibility over
the network's average infection length.
</p>
</li>
<li> <p><code>network_immunity()</code> measures the proportion of nodes that would need
to be protected through vaccination, isolation, or recovery for herd immunity to be reached.
</p>
</li>
<li> <p><code>network_hazard()</code> measures the hazard rate or instantaneous probability that
nodes will adopt/become infected at that time
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>network_transmissibility(diff_model)

network_infection_length(diff_model)

network_reproduction(diff_model)

network_immunity(diff_model)

network_hazard(diff_model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net_diffusion_+3A_diff_model">diff_model</code></td>
<td>
<p>A valid network diffusion model,
as created by <code>as_diffusion()</code> or <code>play_diffusion()</code>.</p>
</td></tr>
</table>


<h3>Transmissibility</h3>

<p><code>network_transmissibility()</code> measures how many directly susceptible nodes
each infected node will infect in each time period, on average.
That is:
</p>
<p style="text-align: center;"><code class="reqn">T = \frac{1}{n}\sum_{j=1}^n \frac{i_{j}}{s_{j}}</code>
</p>

<p>where <code class="reqn">i</code> is the number of new infections in each time period, <code class="reqn">j \in n</code>,
and <code class="reqn">s</code> is the number of nodes that could have been infected in that time period
(note that <code class="reqn">s \neq S</code>, or
the number of nodes that are susceptible in the population).
<code class="reqn">T</code> can be interpreted as the proportion of susceptible nodes that are
infected at each time period.
</p>


<h3>Infection length</h3>

<p><code>network_infection_length()</code> measures the average number of time steps that
nodes in a network remain infected.
Note that in a diffusion model without recovery, average infection length
will be infinite.
This will also be the case where there is right censoring.
The longer nodes remain infected, the longer they can infect others.
</p>


<h3>Reproduction number</h3>

<p><code>network_reproduction()</code> measures a given diffusion's reproductive number.
Here it is calculated as:
</p>
<p style="text-align: center;"><code class="reqn">R = \min\left(\frac{T}{1/IL}, \bar{k}\right)</code>
</p>

<p>where <code class="reqn">T</code> is the observed transmissibility in a diffusion
and <code class="reqn">IL</code> is the observed infection length in a diffusion.
Since <code class="reqn">IL</code> can be infinite where there is no recovery
or there is right censoring,
and since network structure places an upper limit on how many
nodes each node may further infect (their degree),
this function returns the minimum of <code class="reqn">R_0</code>
and the network's average degree.
</p>
<p>Interpretation of the reproduction number is oriented around R = 1.
Where <code class="reqn">R &gt; 1</code>, the 'disease' will 'infect' more and more
nodes in the network.
Where <code class="reqn">R &lt; 1</code>, the 'disease' will not sustain itself and eventually
die out.
Where <code class="reqn">R = 1</code>, the 'disease' will continue as endemic,
if conditions allow.
</p>


<h3>Herd immunity</h3>

<p><code>network_immunity()</code> estimates the proportion of a network
that need to be protected from infection for herd immunity
to be achieved.
This is known as the Herd Immunity Threshold or HIT:
</p>
<p style="text-align: center;"><code class="reqn">1 - \frac{1}{R}</code>
</p>

<p>where <code class="reqn">R</code> is the reproduction number from <code>network_reproduction()</code>.
The HIT indicates the threshold at which
the reduction of susceptible members of the network means
that infections will no longer keep increasing.
Note that there may still be more infections after this threshold has been reached,
but there should be fewer and fewer.
These excess infections are called the <em>overshoot</em>.
This function does <em>not</em> take into account the structure
of the network, instead using the average degree.
</p>
<p>Interpretation is quite straightforward.
A HIT or immunity score of 0.75 would mean that 75% of the nodes in the network
would need to be vaccinated or otherwise protected to achieve herd immunity.
To identify how many nodes this would be, multiply this proportion with the number
of nodes in the network.
</p>


<h3>Hazard rate</h3>

<p>The hazard rate is the instantaneous probability of adoption/infection at each time point (Allison 1984).
In survival analysis, hazard rate is formally defined as:
</p>
<p style="text-align: center;"><code class="reqn">%
\lambda(t)=\lim_{h\to +0}\frac{F(t+h)-F(t)}{h}\frac{1}{1-F(t)} %
</code>
</p>

<p>By approximating <code class="reqn">h=1</code>, we can rewrite the equation as
</p>
<p style="text-align: center;"><code class="reqn">%
\lambda(t)=\frac{F(t+1)-F(t)}{1-F(t)} %
</code>
</p>

<p>If we estimate <code class="reqn">F(t)</code>,
the probability of not having adopted the innovation in time <code class="reqn">t</code>,
from the proportion of adopters in that time,
such that <code class="reqn">F(t) \sim q_t/n</code>, we now have (ultimately for <code class="reqn">t&gt;1</code>):
</p>
<p style="text-align: center;"><code class="reqn">%
\lambda(t)=\frac{q_{t+1}/n-q_t/n}{1-q_t/n} = \frac{q_{t+1} - q_t}{n - q_t} = \frac{q_t - q_{t-1}}{n - q_{t-1}} %
</code>
</p>

<p>where <code class="reqn">q_i</code> is the number of adopters in time <code class="reqn">t</code>,
and <code class="reqn">n</code> is the number of vertices in the graph.
</p>
<p>The shape of the hazard rate indicates the pattern of new adopters over time.
Rapid diffusion with convex cumulative adoption curves will have
hazard functions that peak early and decay over time.
Slow concave cumulative adoption curves will have
hazard functions that are low early and rise over time.
Smooth hazard curves indicate constant adoption whereas
those that oscillate indicate variability in adoption behavior over time.
</p>


<h3>Source</h3>

<p><code>{netdiffuseR}</code>
</p>


<h3>References</h3>

<p>Kermack, W. and McKendrick, A., 1927. &quot;A contribution to the mathematical theory of epidemics&quot;.
<em>Proc. R. Soc. London A</em> 115: 700-721.
</p>
<p>Allison, P. 1984. <em>Event history analysis regression for longitudinal event data</em>.
London: Sage Publications.
</p>
<p>Wooldridge, J. M. 2010. <em>Econometric Analysis of Cross Section and Panel Data</em> (2nd ed.).
Cambridge: MIT Press.
</p>


<h3>See Also</h3>

<p>Other measures: 
<code><a href="#topic+between_centrality">between_centrality</a></code>,
<code><a href="#topic+close_centrality">close_centrality</a></code>,
<code><a href="#topic+closure">closure</a></code>,
<code><a href="#topic+cohesion">cohesion</a>()</code>,
<code><a href="#topic+degree_centrality">degree_centrality</a></code>,
<code><a href="#topic+eigenv_centrality">eigenv_centrality</a></code>,
<code><a href="#topic+features">features</a></code>,
<code><a href="#topic+heterogeneity">heterogeneity</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+holes">holes</a></code>,
<code><a href="#topic+node_diffusion">node_diffusion</a></code>,
<code><a href="#topic+periods">periods</a></code>
</p>
<p>Other diffusion: 
<code><a href="#topic+node_diffusion">node_diffusion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  smeg &lt;- manynet::generate_smallworld(15, 0.025)
  smeg_diff &lt;- play_diffusion(smeg, recovery = 0.2)
  plot(smeg_diff)
  # To calculate the average transmissibility for a given diffusion model
  network_transmissibility(smeg_diff)
  # To calculate the average infection length for a given diffusion model
  network_infection_length(smeg_diff)
  # To calculate the reproduction number for a given diffusion model
  network_reproduction(smeg_diff)
  # Calculating the proportion required to achieve herd immunity
  network_immunity(smeg_diff)
  # To find the number of nodes to be vaccinated
  ceiling(network_immunity(smeg_diff) * manynet::network_nodes(smeg))
# To calculate the hazard rates at each time point
network_hazard(play_diffusion(smeg, transmissibility = 0.3))
</code></pre>

<hr>
<h2 id='network_census'>Censuses of motifs at the network level</h2><span id='topic+network_census'></span><span id='topic+network_dyad_census'></span><span id='topic+network_triad_census'></span><span id='topic+network_mixed_census'></span>

<h3>Description</h3>

<p>These functions include ways to take a census of the positions of nodes
in a network:
</p>

<ul>
<li> <p><code>network_dyad_census()</code> returns a census of dyad motifs in a network.
</p>
</li>
<li> <p><code>network_triad_census()</code> returns a census of triad motifs in a network.
</p>
</li>
<li> <p><code>network_mixed_census()</code> returns a census of triad motifs that span
a one-mode and a two-mode network.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>network_dyad_census(.data)

network_triad_census(.data)

network_mixed_census(.data, object2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_census_+3A_.data">.data</code></td>
<td>
<p>An object of a <code>{manynet}</code>-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="network_census_+3A_object2">object2</code></td>
<td>
<p>A second, two-mode migraph-consistent object.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Alejandro Espinosa 'netmem'
</p>


<h3>References</h3>

<p>Davis, James A., and Samuel Leinhardt. 1967.
“<a href="https://files.eric.ed.gov/fulltext/ED024086.pdf">The Structure of Positive Interpersonal Relations in Small Groups</a>.” 55.
</p>
<p>Hollway, James, Alessandro Lomi, Francesca Pallotti, and Christoph Stadtfeld. 2017.
“Multilevel Social Spaces: The Network Dynamics of Organizational Fields.”
<em>Network Science</em> 5(2): 187–212.
<a href="https://doi.org/10.1017/nws.2017.8">doi:10.1017/nws.2017.8</a>
</p>


<h3>See Also</h3>

<p>Other motifs: 
<code><a href="#topic+brokerage_census">brokerage_census</a></code>,
<code><a href="#topic+node_census">node_census</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>network_dyad_census(manynet::ison_algebra)
network_triad_census(manynet::ison_adolescents)
marvel_friends &lt;- manynet::to_unsigned(manynet::ison_marvel_relationships, "positive")
(mixed_cen &lt;- network_mixed_census(marvel_friends, manynet::ison_marvel_teams))
</code></pre>

<hr>
<h2 id='node_census'>Censuses of nodes' motifs</h2><span id='topic+node_census'></span><span id='topic+node_tie_census'></span><span id='topic+node_triad_census'></span><span id='topic+node_quad_census'></span><span id='topic+node_path_census'></span>

<h3>Description</h3>

<p>These functions include ways to take a census of the positions of nodes
in a network:
</p>

<ul>
<li> <p><code>node_tie_census()</code> returns a census of the ties in a network.
For directed networks, out-ties and in-ties are bound together.
for multiplex networks, the various types of ties are bound together.
</p>
</li>
<li> <p><code>node_triad_census()</code> returns a census of the triad configurations
nodes are embedded in.
</p>
</li>
<li> <p><code>node_quad_census()</code> returns a census of nodes' positions
in motifs of four nodes.
</p>
</li>
<li> <p><code>node_path_census()</code> returns the shortest path lengths
of each node to every other node in the network.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>node_tie_census(.data)

node_triad_census(.data)

node_quad_census(.data)

node_path_census(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_census_+3A_.data">.data</code></td>
<td>
<p>An object of a <code>{manynet}</code>-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
</table>


<h3>Quad census</h3>

<p>The quad census uses the <code>{oaqc}</code> package to do
the heavy lifting of counting the number of each orbits.
See <code>vignette('oaqc')</code>.
However, our function relabels some of the motifs
to avoid conflicts and improve some consistency with
other census-labelling practices.
The letter-number pairing of these labels indicate
the number and configuration of ties.
For now, we offer a rough translation:</p>

<table>
<tr>
 <td style="text-align: left;">
   migraph </td><td style="text-align: left;"> Ortmann and Brandes </td>
</tr>
<tr>
 <td style="text-align: left;">
   E4 </td><td style="text-align: left;"> co-K4 </td>
</tr>
<tr>
 <td style="text-align: left;">
   I40, I41 </td><td style="text-align: left;"> co-diamond </td>
</tr>
<tr>
 <td style="text-align: left;">
   H4 </td><td style="text-align: left;"> co-C4 </td>
</tr>
<tr>
 <td style="text-align: left;">
   L42, L41, L40 </td><td style="text-align: left;"> co-paw </td>
</tr>
<tr>
 <td style="text-align: left;">
   D42, D40 </td><td style="text-align: left;"> co-claw </td>
</tr>
<tr>
 <td style="text-align: left;">
   U42, U41 </td><td style="text-align: left;"> P4 </td>
</tr>
<tr>
 <td style="text-align: left;">
   Y43, Y41 </td><td style="text-align: left;"> claw </td>
</tr>
<tr>
 <td style="text-align: left;">
   P43, P42, P41 </td><td style="text-align: left;"> paw </td>
</tr>
<tr>
 <td style="text-align: left;">
   04 </td><td style="text-align: left;"> C4 </td>
</tr>
<tr>
 <td style="text-align: left;">
   Z42, Z43 </td><td style="text-align: left;"> diamond </td>
</tr>
<tr>
 <td style="text-align: left;">
   X4 </td><td style="text-align: left;"> K4 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>See also <a href="https://www.graphclasses.org/smallgraphs.html#nodes4">this list of graph classes</a>.
</p>


<h3>References</h3>

<p>Davis, James A., and Samuel Leinhardt. 1967.
“<a href="https://files.eric.ed.gov/fulltext/ED024086.pdf">The Structure of Positive Interpersonal Relations in Small Groups</a>.” 55.
</p>
<p>Ortmann, Mark, and Ulrik Brandes. 2017.
“Efficient Orbit-Aware Triad and Quad Census in Directed and Undirected Graphs.”
<em>Applied Network Science</em> 2(1):13.
<a href="https://doi.org/10.1007/s41109-017-0027-2">doi:10.1007/s41109-017-0027-2</a>.
</p>
<p>Dijkstra, Edsger W. 1959.
&quot;A note on two problems in connexion with graphs&quot;.
<em>Numerische Mathematik</em> 1, 269-71.
<a href="https://doi.org/10.1007/BF01386390">doi:10.1007/BF01386390</a>.
</p>
<p>Opsahl, Tore, Filip Agneessens, and John Skvoretz. 2010.
&quot;Node centrality in weighted networks: Generalizing degree and shortest paths&quot;.
<em>Social Networks</em> 32(3): 245-51.
<a href="https://doi.org/10.1016/j.socnet.2010.03.006">doi:10.1016/j.socnet.2010.03.006</a>.
</p>


<h3>See Also</h3>

<p>Other motifs: 
<code><a href="#topic+brokerage_census">brokerage_census</a></code>,
<code><a href="#topic+network_census">network_census</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>task_eg &lt;- manynet::to_named(manynet::to_uniplex(manynet::ison_algebra, "tasks"))
(tie_cen &lt;- node_tie_census(task_eg))
(triad_cen &lt;- node_triad_census(task_eg))
node_quad_census(manynet::ison_southern_women)
node_path_census(manynet::ison_adolescents)
node_path_census(manynet::ison_southern_women)
</code></pre>

<hr>
<h2 id='node_diffusion'>Measures of nodes in a diffusion</h2><span id='topic+node_diffusion'></span><span id='topic+node_adoption_time'></span><span id='topic+node_adopter'></span><span id='topic+node_thresholds'></span><span id='topic+node_infection_length'></span><span id='topic+node_exposure'></span>

<h3>Description</h3>

<p>These functions allow measurement of various features of
a diffusion process:
</p>

<ul>
<li> <p><code>node_adoption_time()</code>: Measures the number of time steps until
nodes adopt/become infected
</p>
</li>
<li> <p><code>node_adopter()</code>: Classifies membership of nodes into diffusion categories
</p>
</li>
<li> <p><code>node_thresholds()</code>: Measures nodes' thresholds from the amount
of exposure they had when they became infected
</p>
</li>
<li> <p><code>node_infection_length()</code>: Measures the average length nodes that become
infected remain infected in a compartmental model with recovery
</p>
</li>
<li> <p><code>node_exposure()</code>: Measures how many exposures nodes have to
a given mark
</p>
</li>
<li> <p><code>node_is_exposed()</code>: Marks the nodes that are susceptible,
i.e. are in the immediate neighbourhood of given mark vector
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>node_adoption_time(diff_model)

node_adopter(diff_model)

node_thresholds(diff_model)

node_infection_length(diff_model)

node_exposure(.data, mark, time = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_diffusion_+3A_diff_model">diff_model</code></td>
<td>
<p>A valid network diffusion model,
as created by <code>as_diffusion()</code> or <code>play_diffusion()</code>.</p>
</td></tr>
<tr><td><code id="node_diffusion_+3A_.data">.data</code></td>
<td>
<p>An object of a <code>{manynet}</code>-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="node_diffusion_+3A_mark">mark</code></td>
<td>
<p>A valid 'node_mark' object or
logical vector (TRUE/FALSE) of length equal to
the number of nodes in the network.</p>
</td></tr>
<tr><td><code id="node_diffusion_+3A_time">time</code></td>
<td>
<p>A time point until which infections/adoptions should be
identified. By default <code>time = 0</code>.</p>
</td></tr>
</table>


<h3>Adoption time</h3>

<p><code>node_adoption_time()</code> measures the time units it took
until each node became infected.
Note that an adoption time of 0 indicates that this was a seed node.
</p>


<h3>Adopter class</h3>

<p><code>node_adopter()</code> classifies the nodes involved in a diffusion
by where on the distribution of adopters they fell.
Valente (1995) defines five memberships:
</p>

<ul>
<li> <p><em>Early adopter</em>: those with an adoption time less than
the average adoption time minus one standard deviation of adoptions times
</p>
</li>
<li> <p><em>Early majority</em>: those with an adoption time between
the average adoption time and
the average adoption time minus one standard deviation of adoptions times
</p>
</li>
<li> <p><em>Late majority</em>: those with an adoption time between
the average adoption time and
the average adoption time plus one standard deviation of adoptions times
</p>
</li>
<li> <p><em>Laggard</em>: those with an adoption time greater than
the average adoption time plus one standard deviation of adoptions times
</p>
</li>
<li> <p><em>Non-adopter</em>: those without an adoption time,
i.e. never adopted
</p>
</li></ul>



<h3>Thresholds</h3>

<p><code>node_thresholds()</code> infers nodes' thresholds based on how much
exposure they had when they were infected.
This inference is of course imperfect,
especially where there is a sudden increase in exposure,
but it can be used heuristically.
</p>


<h3>Infection length</h3>

<p><code>node_infection_length()</code> measures the average length of time that nodes
that become infected remain infected in a compartmental model with recovery.
Infections that are not concluded by the end of the study period are
calculated as infinite.
</p>


<h3>Exposure</h3>

<p><code>node_exposure()</code> calculates the number of infected/adopting nodes
to which each susceptible node is exposed.
It usually expects network data and
an index or mark (TRUE/FALSE) vector of those nodes which are currently infected,
but if a diff_model is supplied instead it will return
nodes exposure at <code class="reqn">t = 0</code>.
</p>


<h3>References</h3>

<p>Valente, Tom W. 1995. <em>Network models of the diffusion of innovations</em>
(2nd ed.). Cresskill N.J.: Hampton Press.
</p>


<h3>See Also</h3>

<p>Other measures: 
<code><a href="#topic+between_centrality">between_centrality</a></code>,
<code><a href="#topic+close_centrality">close_centrality</a></code>,
<code><a href="#topic+closure">closure</a></code>,
<code><a href="#topic+cohesion">cohesion</a>()</code>,
<code><a href="#topic+degree_centrality">degree_centrality</a></code>,
<code><a href="#topic+eigenv_centrality">eigenv_centrality</a></code>,
<code><a href="#topic+features">features</a></code>,
<code><a href="#topic+heterogeneity">heterogeneity</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+holes">holes</a></code>,
<code><a href="#topic+net_diffusion">net_diffusion</a></code>,
<code><a href="#topic+periods">periods</a></code>
</p>
<p>Other diffusion: 
<code><a href="#topic+net_diffusion">net_diffusion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  smeg &lt;- manynet::generate_smallworld(15, 0.025)
  smeg_diff &lt;- play_diffusion(smeg, recovery = 0.2)
  plot(smeg_diff)
  # To measure when nodes adopted a diffusion/were infected
  (times &lt;- node_adoption_time(smeg_diff))
  # To classify nodes by their position in the adoption curve
  (adopts &lt;- node_adopter(smeg_diff))
  summary(adopts)
  summary(times, membership = adopts)
  # To infer nodes' thresholds
  node_thresholds(smeg_diff)
  # To measure how long each node remains infected for
  node_infection_length(smeg_diff)
  # To measure how much exposure nodes have to a given mark
  node_exposure(smeg, mark = c(1,3))
  node_exposure(smeg_diff)
</code></pre>

<hr>
<h2 id='over'>Helper functions for measuring over splits of networks</h2><span id='topic+over'></span><span id='topic+over_waves'></span><span id='topic+over_time'></span>

<h3>Description</h3>

<p>Helper functions for measuring over splits of networks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>over_waves(
  .data,
  FUN,
  ...,
  attribute = "wave",
  strategy = "sequential",
  verbose = FALSE
)

over_time(
  .data,
  FUN,
  ...,
  attribute = "time",
  slice = NULL,
  strategy = "sequential",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="over_+3A_.data">.data</code></td>
<td>
<p>An object of a <code>{manynet}</code>-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="over_+3A_fun">FUN</code></td>
<td>
<p>A function to run over all splits.</p>
</td></tr>
<tr><td><code id="over_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed on to FUN.</p>
</td></tr>
<tr><td><code id="over_+3A_attribute">attribute</code></td>
<td>
<p>A string naming the attribute to be split upon.</p>
</td></tr>
<tr><td><code id="over_+3A_strategy">strategy</code></td>
<td>
<p>If <code>{furrr}</code> is installed,
then multiple cores can be used to accelerate the function.
By default <code>"sequential"</code>,
but if multiple cores available,
then <code>"multisession"</code> or <code>"multicore"</code> may be useful.
Generally this is useful only when <code>times</code> &gt; 1000.
See <a href="https://furrr.futureverse.org"><code>{furrr}</code></a> for more.</p>
</td></tr>
<tr><td><code id="over_+3A_verbose">verbose</code></td>
<td>
<p>Whether the function should report on its progress.
By default FALSE.
See <a href="https://progressr.futureverse.org"><code>{progressr}</code></a> for more.</p>
</td></tr>
<tr><td><code id="over_+3A_slice">slice</code></td>
<td>
<p>Optionally, a vector of specific slices.
Otherwise all observed slices will be returned.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>over_waves()</code>: Runs a function, e.g. a measure,
over waves of a panel network
</p>
</li>
<li> <p><code>over_time()</code>: Runs a function, e.g. a measure,
over time slices of a dynamic network
</p>
</li></ul>

<hr>
<h2 id='periods'>Measures of network change</h2><span id='topic+periods'></span><span id='topic+network_change'></span><span id='topic+network_stability'></span>

<h3>Description</h3>

<p>These functions measure certain topological features of networks:
</p>

<ul>
<li> <p><code>network_change()</code> measures the Hamming distance between two or more networks.
</p>
</li>
<li> <p><code>network_stability()</code> measures the Jaccard index of stability between two or more networks.
</p>
</li></ul>

<p>These <code style="white-space: pre;">&#8288;network_*()&#8288;</code> functions return a numeric vector the length of the number
of networks minus one. E.g., the periods between waves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_change(.data, object2)

network_stability(.data, object2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="periods_+3A_.data">.data</code></td>
<td>
<p>An object of a <code>{manynet}</code>-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="periods_+3A_object2">object2</code></td>
<td>
<p>A network object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other measures: 
<code><a href="#topic+between_centrality">between_centrality</a></code>,
<code><a href="#topic+close_centrality">close_centrality</a></code>,
<code><a href="#topic+closure">closure</a></code>,
<code><a href="#topic+cohesion">cohesion</a>()</code>,
<code><a href="#topic+degree_centrality">degree_centrality</a></code>,
<code><a href="#topic+eigenv_centrality">eigenv_centrality</a></code>,
<code><a href="#topic+features">features</a></code>,
<code><a href="#topic+heterogeneity">heterogeneity</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+holes">holes</a></code>,
<code><a href="#topic+net_diffusion">net_diffusion</a></code>,
<code><a href="#topic+node_diffusion">node_diffusion</a></code>
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+tidy'></span><span id='topic+glance'></span><span id='topic+is_igraph'></span><span id='topic+is.network'></span><span id='topic+as.network'></span><span id='topic++25+3E+25'></span><span id='topic+with_graph'></span><span id='topic+is.tbl_graph'></span><span id='topic+.G'></span><span id='topic+.N'></span><span id='topic+.E'></span><span id='topic+mutate'></span><span id='topic+rename'></span><span id='topic+bind_edges'></span><span id='topic+ggplot'></span><span id='topic+ggtitle'></span><span id='topic+guides'></span><span id='topic+labs'></span><span id='topic+xlab'></span><span id='topic+ylab'></span><span id='topic+aes'></span><span id='topic+ggsave'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+reexports">%&gt;%</a></code></p>
</dd>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+glance">glance</a></code>, <code><a href="generics.html#topic+tidy">tidy</a></code></p>
</dd>
<dt>ggplot2</dt><dd><p><code><a href="ggplot2.html#topic+aes">aes</a></code>, <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>, <code><a href="ggplot2.html#topic+ggsave">ggsave</a></code>, <code><a href="ggplot2.html#topic+labs">ggtitle</a></code>, <code><a href="ggplot2.html#topic+guides">guides</a></code>, <code><a href="ggplot2.html#topic+labs">labs</a></code>, <code><a href="ggplot2.html#topic+labs">xlab</a></code>, <code><a href="ggplot2.html#topic+labs">ylab</a></code></p>
</dd>
<dt>igraph</dt><dd><p><code><a href="igraph.html#topic+is_igraph">is_igraph</a></code></p>
</dd>
<dt>network</dt><dd><p><code><a href="network.html#topic+network">as.network</a></code>, <code><a href="network.html#topic+network">is.network</a></code></p>
</dd>
<dt>tidygraph</dt><dd><p><code><a href="tidygraph.html#topic+context_accessors">.E</a></code>, <code><a href="tidygraph.html#topic+context_accessors">.G</a></code>, <code><a href="tidygraph.html#topic+context_accessors">.N</a></code>, <code><a href="tidygraph.html#topic+bind_graphs">bind_edges</a></code>, <code><a href="tidygraph.html#topic+tbl_graph">is.tbl_graph</a></code>, <code><a href="tidygraph.html#topic+reexports">mutate</a></code>, <code><a href="tidygraph.html#topic+reexports">rename</a></code>, <code><a href="tidygraph.html#topic+with_graph">with_graph</a></code></p>
</dd>
</dl>

<hr>
<h2 id='regression'>Linear and logistic regression for network data</h2><span id='topic+regression'></span><span id='topic+network_reg'></span>

<h3>Description</h3>

<p>This function provides an implementation of
the multiple regression quadratic assignment procedure (MRQAP)
for both one-mode and two-mode network linear models.
It offers several advantages:
</p>

<ul>
<li><p> it works with combined graph/network objects such as igraph and network objects
by constructing the various dependent and independent matrices for the user.
</p>
</li>
<li><p> it uses a more intuitive formula-based system for specifying the model,
with several ways to specify how nodal attributes should be handled.
</p>
</li>
<li><p> it can handle categorical variables (factors/characters) and
interactions intuitively, naming the reference variable where appropriate.
</p>
</li>
<li><p> it relies on <a href="https://furrr.futureverse.org"><code>{furrr}</code></a> for parallelising
and <a href="https://progressr.futureverse.org"><code>{progressr}</code></a>
for reporting progress to the user,
which can be useful when many simulations are required.
</p>
</li>
<li><p> results are <a href="https://broom.tidymodels.org"><code>{broom}</code></a>-compatible,
with <code>tidy()</code> and <code>glance()</code> reports to facilitate comparison
with results from different models.
Note that a <em>t</em>- or <em>z</em>-value is always used as the test statistic,
and properties of the dependent network
&ndash; modes, directedness, loops, etc &ndash;
will always be respected in permutations and analysis.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>network_reg(
  formula,
  .data,
  method = c("qap", "qapy"),
  times = 1000,
  strategy = "sequential",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regression_+3A_formula">formula</code></td>
<td>
<p>A formula describing the relationship being tested.
Several additional terms are available to assist users investigate
the effects they are interested in. These include:
</p>

<ul>
<li> <p><code>ego()</code> constructs a matrix where the cells reflect the value of
a named nodal attribute for an edge's sending node
</p>
</li>
<li> <p><code>alter()</code> constructs a matrix where the cells reflect the value of
a named nodal attribute for an edge's receiving node
</p>
</li>
<li> <p><code>same()</code> constructs a matrix where a 1 reflects
if two nodes' attribute values are the same
</p>
</li>
<li> <p><code>dist()</code> constructs a matrix where the cells reflect the
absolute difference between the attribute's values
for the sending and receiving nodes
</p>
</li>
<li> <p><code>sim()</code> constructs a matrix where the cells reflect the
proportional similarity between the attribute's values
for the sending and receiving nodes
</p>
</li>
<li> <p><code>tertius()</code> constructs a matrix where the cells reflect some
aggregate of an attribute associated with a node's other ties.
Currently &quot;mean&quot; and &quot;sum&quot; are available aggregating functions.
'ego' is excluded from these calculations.
See Haunss and Hollway (2023) for more on this effect.
</p>
</li>
<li><p> dyadic covariates (other networks) can just be named
</p>
</li></ul>
</td></tr>
<tr><td><code id="regression_+3A_.data">.data</code></td>
<td>
<p>An object of a <code>{manynet}</code>-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="regression_+3A_method">method</code></td>
<td>
<p>A method for establishing the null hypothesis.
Note that &quot;qap&quot; uses Dekker et al's (2007) double semi-partialling technique,
whereas &quot;qapy&quot; permutes only the $y$ variable.
&quot;qap&quot; is the default.</p>
</td></tr>
<tr><td><code id="regression_+3A_times">times</code></td>
<td>
<p>Integer indicating number of simulations used for quantile estimation.
(Relevant to the null hypothesis test only -
the analysis itself is unaffected by this parameter.)
Note that, as for all Monte Carlo procedures, convergence is slower for more
extreme quantiles.
By default, <code>times=1000</code>.
1,000 - 10,000 repetitions recommended for publication-ready results.</p>
</td></tr>
<tr><td><code id="regression_+3A_strategy">strategy</code></td>
<td>
<p>If <code>{furrr}</code> is installed,
then multiple cores can be used to accelerate the function.
By default <code>"sequential"</code>,
but if multiple cores available,
then <code>"multisession"</code> or <code>"multicore"</code> may be useful.
Generally this is useful only when <code>times</code> &gt; 1000.
See <a href="https://furrr.futureverse.org"><code>{furrr}</code></a> for more.</p>
</td></tr>
<tr><td><code id="regression_+3A_verbose">verbose</code></td>
<td>
<p>Whether the function should report on its progress.
By default FALSE.
See <a href="https://progressr.futureverse.org"><code>{progressr}</code></a> for more.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Krackhardt, David. 1988.
“Predicting with Networks: Nonparametric Multiple Regression Analysis of Dyadic Data.”
<em>Social Networks</em> 10(4):359–81.
<a href="https://doi.org/10.1016/0378-8733%2888%2990004-4">doi:10.1016/0378-8733(88)90004-4</a>.
</p>
<p>Dekker, David, David Krackhard, and Tom A. B. Snijders. 2007.
“Sensitivity of MRQAP tests to collinearity and autocorrelation conditions.”
<em>Psychometrika</em> 72(4): 563-581.
<a href="https://doi.org/10.1007/s11336-007-9016-1">doi:10.1007/s11336-007-9016-1</a>.
</p>


<h3>See Also</h3>

<p><code>vignette("p7linearmodel")</code>
</p>
<p>Other models: 
<code><a href="#topic+tests">tests</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>networkers &lt;- ison_networkers %&gt;% to_subgraph(Discipline == "Sociology")
model1 &lt;- network_reg(weight ~ alter(Citations) + sim(Citations), 
                      networkers, times = 20)
# Should be run many more `times` for publication-ready results
tidy(model1)
glance(model1)
plot(model1)
</code></pre>

<hr>
<h2 id='tests'>Conditional uniform graph and permutation tests</h2><span id='topic+tests'></span><span id='topic+test_random'></span><span id='topic+test_permutation'></span><span id='topic+test_gof'></span>

<h3>Description</h3>

<p>These functions conduct tests of any network-level statistic:
</p>

<ul>
<li> <p><code>test_random()</code> performs a conditional uniform graph (CUG) test
of a measure against a distribution of measures on random networks
of the same dimensions.
</p>
</li>
<li> <p><code>test_permutation()</code> performs a quadratic assignment procedure (QAP) test
of a measure against a distribution of measures on permutations
of the original network.
</p>
</li>
<li> <p><code>test_gof()</code> performs a chi-squared test on the squared Mahalanobis distance
between a diff_model and diff_models objects.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>test_random(
  .data,
  FUN,
  ...,
  times = 1000,
  strategy = "sequential",
  verbose = FALSE
)

test_permutation(
  .data,
  FUN,
  ...,
  times = 1000,
  strategy = "sequential",
  verbose = FALSE
)

test_gof(diff_model, diff_models)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tests_+3A_.data">.data</code></td>
<td>
<p>An object of a <code>{manynet}</code>-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="tests_+3A_fun">FUN</code></td>
<td>
<p>A graph-level statistic function to test.</p>
</td></tr>
<tr><td><code id="tests_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed on to FUN,
e.g. the name of the attribute.</p>
</td></tr>
<tr><td><code id="tests_+3A_times">times</code></td>
<td>
<p>Integer indicating number of simulations used for quantile estimation.
(Relevant to the null hypothesis test only -
the analysis itself is unaffected by this parameter.)
Note that, as for all Monte Carlo procedures, convergence is slower for more
extreme quantiles.
By default, <code>times=1000</code>.
1,000 - 10,000 repetitions recommended for publication-ready results.</p>
</td></tr>
<tr><td><code id="tests_+3A_strategy">strategy</code></td>
<td>
<p>If <code>{furrr}</code> is installed,
then multiple cores can be used to accelerate the function.
By default <code>"sequential"</code>,
but if multiple cores available,
then <code>"multisession"</code> or <code>"multicore"</code> may be useful.
Generally this is useful only when <code>times</code> &gt; 1000.
See <a href="https://furrr.futureverse.org"><code>{furrr}</code></a> for more.</p>
</td></tr>
<tr><td><code id="tests_+3A_verbose">verbose</code></td>
<td>
<p>Whether the function should report on its progress.
By default FALSE.
See <a href="https://progressr.futureverse.org"><code>{progressr}</code></a> for more.</p>
</td></tr>
<tr><td><code id="tests_+3A_diff_model">diff_model</code></td>
<td>
<p>A diff_model object is returned by
<code>play_diffusion()</code> or <code>as_diffusion()</code> and contains
a single empirical or simulated diffusion.</p>
</td></tr>
<tr><td><code id="tests_+3A_diff_models">diff_models</code></td>
<td>
<p>A diff_models object is returned by
<code>play_diffusions()</code> and contains a series of diffusion simulations.</p>
</td></tr>
</table>


<h3>Mahalanobis distance</h3>

<p><code>test_gof()</code> takes a single diff_model object,
which may be a single empirical or simulated diffusion,
and a diff_models object containing many simulations.
Note that currently only the goodness of fit of the
</p>
<p>It returns a tibble (compatible with <code>broom::glance()</code>) that includes
the Mahalanobis distance statistic
between the observed and simulated distributions.
It also includes a p-value summarising a chi-squared test on this statistic,
listing also the degrees of freedom and number of observations.
If the p-value is less than the convention 0.05,
then one can argue that the first diffusion is not well captured by
</p>


<h3>See Also</h3>

<p>Other models: 
<code><a href="#topic+regression">regression</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>marvel_friends &lt;- to_unsigned(ison_marvel_relationships)
marvel_friends &lt;- to_giant(marvel_friends) %&gt;% 
  to_subgraph(PowerOrigin == "Human")
(cugtest &lt;- test_random(marvel_friends, network_heterophily, attribute = "Attractive",
  times = 200))
plot(cugtest)
(qaptest &lt;- test_permutation(marvel_friends, 
                network_heterophily, attribute = "Attractive",
                times = 200))
plot(qaptest)
  # Playing a reasonably quick diffusion
  x &lt;- play_diffusion(generate_random(15), transmissibility = 0.7)
  # Playing a slower diffusion
  y &lt;- play_diffusions(generate_random(15), transmissibility = 0.1, times = 40)
  plot(x)
  plot(y)
  test_gof(x, y)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
