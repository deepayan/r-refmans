<!DOCTYPE html><html><head><title>Help for package wrMisc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {wrMisc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.addLetterWoLast'><p>Add letter to all elements but not last</p></a></li>
<li><a href='#.allRatioMatr1to2'><p>Calculate ratios for each column to each column of reference-matrix</p></a></li>
<li><a href='#.allRatios'><p>Search character-string and cut either before or after</p></a></li>
<li><a href='#.arrLstMean'><p>Summarize along columns of multiple arrays in list</p></a></li>
<li><a href='#.arrLstSEM'><p>Summarize along columns of mult arrays in list</p></a></li>
<li><a href='#.asDF2'><p>Convert anything to data.frame</p></a></li>
<li><a href='#.breakInSer'><p>Get series of values after last discontinuity</p></a></li>
<li><a href='#.bringToCtr'><p>Bring most extreme to center</p></a></li>
<li><a href='#.checkArgNa'><p>Check argument names</p></a></li>
<li><a href='#.checkConsistentArrList'><p>Check list of arrays for consistent dimensions of all arrays</p></a></li>
<li><a href='#.checkConvt2Vect'><p>Convert to simple vector (similar to unlist)</p></a></li>
<li><a href='#.checkFactor'><p>Check Factor</p></a></li>
<li><a href='#.checkFileNameExtensions'><p>checkFileNameExtensions</p>
Function for checking file-names.</a></li>
<li><a href='#.checkLegendLoc'><p>Check argument for Location of legend</p></a></li>
<li><a href='#.checkLmConfInt'><p>Compare 'dat' to confindence interval of linare model 'lMod' (eg from lm())</p></a></li>
<li><a href='#.checkRegrArguments'><p>Check regression arguments</p></a></li>
<li><a href='#.chooseGrpCol'><p>Automatic choice of colors</p></a></li>
<li><a href='#.combineListAnnot'><p>Combine annotation information from list of matrixes</p></a></li>
<li><a href='#.compareByDiff'><p>Compare by distance/difference</p></a></li>
<li><a href='#.compareByLogRatio'><p>Compare by log-ratio</p></a></li>
<li><a href='#.compareByPPM'><p>Compare by PPM</p></a></li>
<li><a href='#.complCols'><p>Search (complementing) columns for best coverage of non-NA data for rowNormalization (main)</p></a></li>
<li><a href='#.composeCallName'><p>Compose sequence of (function-)calls</p></a></li>
<li><a href='#.convertMatrToNum'><p>Convert numeric matrix to numeric</p></a></li>
<li><a href='#.convertNa'><p>Convert/standardize names of 'query' to standard names from 'ref'</p></a></li>
<li><a href='#.corDuplItemsByIncrem'><p>Avoid duplicating items between 'curNa' and 'newNa' by incrementing digits after 'extPref' (in newNa)</p></a></li>
<li><a href='#.cutAtSearch'><p>Search character-string and cut either before or after</p></a></li>
<li><a href='#.cutStr'><p>Cut string to get all variants from given start with min and max length</p></a></li>
<li><a href='#.datSlope'><p>Model linear regression and optional plot</p></a></li>
<li><a href='#.extrNAneighb'><p>Extract NA-neighbour values</p></a></li>
<li><a href='#.extrNumHeadingCap'><p>Extract number(s) before capital character</p></a></li>
<li><a href='#.extrNumHeadingSepChar'><p>Extract numbers before separator followed by alphabetic character</p></a></li>
<li><a href='#.filterNetw'><p>Filter nodes &amp; edges for extracting networks (main)</p>
</p>
<p>This function allows extracting and filtering network-data based on fixed threshold (<code>limInt</code>) and add sandwich-nodes (nodes inter-connecting initial nodes) out of node-based queries.</p></a></li>
<li><a href='#.filterSw'><p>Filter 3-dim array of numeric data (main)</p></a></li>
<li><a href='#.filtSize'><p>Filter for size</p></a></li>
<li><a href='#.findBorderOverlaps'><p>Find overlap instances among range of values in lines</p></a></li>
<li><a href='#.firstMin'><p>Get first minimum</p></a></li>
<li><a href='#.fuse2ArrBy2ndDim'><p>fuse 2 instances of 3dim arr as mult cols in 3dim array</p></a></li>
<li><a href='#.getAmean'><p>Get A value for each group of replicates</p></a></li>
<li><a href='#.getAmean2'><p>Get A value for each group of replicates based on comp</p></a></li>
<li><a href='#.getMvalue2'><p>Get M value for each group of replicates based on comp</p></a></li>
<li><a href='#.growTree'><p>Grow tree</p></a></li>
<li><a href='#.insp1dimByClustering'><p>Segment (1-dim vector) 'dat' into clusters</p></a></li>
<li><a href='#.inspectHeader'><p>Inspect 'matr' and check if 1st line can be used/converted as header</p></a></li>
<li><a href='#.keepCenter1d'><p>Refine/filter 'dat1' (1dim dataset, eg cluster) with aim of keeping center of data</p></a></li>
<li><a href='#.keepFiniteCol'><p>Remove all columns where all data are not finite</p></a></li>
<li><a href='#.mayBeNum'><p>Check if vector may be numeric content</p></a></li>
<li><a href='#.medianSpecGrp'><p>Rescale respective to specific group</p></a></li>
<li><a href='#.mergeMatrices'><p>Merge Multiple Matrices (main)</p></a></li>
<li><a href='#.minDif'><p>find closest neighbour to numeric vector</p></a></li>
<li><a href='#.neigbDis'><p>Distances beteenw sorted points of 2-columns</p></a></li>
<li><a href='#.normalize'><p>Main Normalization function</p></a></li>
<li><a href='#.normConstSlope'><p>Normalize columns of 2dim matrix to common linear regression fit</p></a></li>
<li><a href='#.offCenter'><p>Return position of 'di' (numeric vector) which is most excentric (distant to 0), starts with NAs as most excentric</p></a></li>
<li><a href='#.pasteCols'><p>Paste-concatenate all columns of matrix</p></a></li>
<li><a href='#.plotCountPie'><p>Pie plot for counting results</p></a></li>
<li><a href='#.plusLowerCaps'><p>Add lower caps to character vector</p></a></li>
<li><a href='#.predRes'><p>Calculate residues of (2-dim) linear model 'lMod'-prediction of/for 'dat'</p></a></li>
<li><a href='#.raiseColLowest'><p>Raise all values close to lowest value</p></a></li>
<li><a href='#.removeCol'><p>Remove columns indicated by col-number</p></a></li>
<li><a href='#.removeEmptyCol'><p>Search for (empty) columns conaining only entries defined in 'searchFields' and remove such columns</p></a></li>
<li><a href='#.replSpecChar'><p>Replace Special Characters</p></a></li>
<li><a href='#.retain1stPart'><p>Trim character string: keep only text before 'sep'</p></a></li>
<li><a href='#.rowGrpCV'><p>row group CV (main)</p></a></li>
<li><a href='#.rowGrpMeans'><p>row group mean (main)</p></a></li>
<li><a href='#.rowGrpSds'><p>row group sd (main)</p></a></li>
<li><a href='#.rowGrpSums'><p>row group rowSums per group (main)</p></a></li>
<li><a href='#.rowNorm'><p>Row-normalization procedure on matrix or data.frame 'dat'</p></a></li>
<li><a href='#.rowNormFact'><p>Obtain normalization factor (main)</p></a></li>
<li><a href='#.scale01'><p>Scale between 0 and 1 (main)</p></a></li>
<li><a href='#.scaleSpecGrp'><p>Rescale respective to specific group</p></a></li>
<li><a href='#.scaleXY'><p>Scale between min and max value (main)</p></a></li>
<li><a href='#.seqCutStr'><p>Cut string to get all variants from given start with min length, depreciated</p></a></li>
<li><a href='#.setLowestTo'><p>Set lowest value to given value</p></a></li>
<li><a href='#.sortMid'><p>Choose most frequent or middle of sorted vector</p></a></li>
<li><a href='#.stackArray'><p>Reorganize array by reducing dimension 'byDim'  (similar to stack() for data-frames)</p></a></li>
<li><a href='#.summarizeCols'><p>Summarize columns of matrix (or data.frame) 'x' using apply (main)</p></a></li>
<li><a href='#.trimFromEnd'><p>Trim from end</p></a></li>
<li><a href='#.trimFromStart'><p>Trim from start</p></a></li>
<li><a href='#.trimLeft'><p>Trim from Left</p></a></li>
<li><a href='#.trimRight'><p>Trim from right</p></a></li>
<li><a href='#.uniqueWName'><p>Check regression arguments</p></a></li>
<li><a href='#.vector2Matr'><p>Convert numeric vector to matrix</p></a></li>
<li><a href='#addBeforFileExtension'><p>Add text before file-extension</p></a></li>
<li><a href='#adjBy2ptReg'><p>Linear rescaling of numeric vertor or matrix</p></a></li>
<li><a href='#adjustUnitPrefix'><p>Adjust Value With Different Decimal Prefixes To Single Prefix Plus Unit</p></a></li>
<li><a href='#appendNR'><p>Append vectors or lists, without duplcating common elements</p></a></li>
<li><a href='#arrayCV'><p>CV of array</p></a></li>
<li><a href='#asSepList'><p>Organize Data as Separate List-Entries</p></a></li>
<li><a href='#buildTree'><p>Connect edges to from tree and extract all possible branches</p></a></li>
<li><a href='#cbindNR'><p>cbind to non-redundant</p></a></li>
<li><a href='#checkAvSd'><p>Check how multiple groups of data separate or overlap based on mean +/- sd</p></a></li>
<li><a href='#checkFilePath'><p>Check If File Is Available For Reading</p></a></li>
<li><a href='#checkGrpOrder'><p>checkGrpOrder</p></a></li>
<li><a href='#checkGrpOrderSEM'><p>Check order of multiple groups including non-overlapping SEM-margins</p></a></li>
<li><a href='#checkSimValueInSer'><p>Check for similar values in series</p></a></li>
<li><a href='#checkStrictOrder'><p>Check for strict (ascencing or descending) order</p></a></li>
<li><a href='#checkVectLength'><p>Check length of vector</p></a></li>
<li><a href='#cleanReplicates'><p>Replace Most Distant Values by NA</p></a></li>
<li><a href='#closeMatchMatrix'><p>Reorganize results of search for close (similar) values in matrix-view</p></a></li>
<li><a href='#coinPermTest'><p>Compare means of two vectors by permutation test</p></a></li>
<li><a href='#colMedSds'><p>Standard error of median for each column by bootstrap</p></a></li>
<li><a href='#colorAccording2'><p>Transform numeric values to color-gradient</p></a></li>
<li><a href='#colSds'><p>sd for each column</p></a></li>
<li><a href='#combinatIntTable'><p>Planing for making all multiplicative combinations</p></a></li>
<li><a href='#combineAsN'><p>Combine Vectors From List And Return Basic Count Statistics</p></a></li>
<li><a href='#combineByEitherFactor'><p>Create factor-like column regrouping data regrouping simultaneaously by two factors</p></a></li>
<li><a href='#combineOverlapInfo'><p>Find and combine points located very close in x/y space</p></a></li>
<li><a href='#combineRedBasedOnCol'><p>Combine/reduce redundant lines based on specified column</p></a></li>
<li><a href='#combineRedundLinesInList'><p>Combine Redundant Lines In List</p></a></li>
<li><a href='#combineRedundLinesInListAcRef'><p>Combine Redundant Lines In List, Deprecated</p></a></li>
<li><a href='#combineReplFromListToMatr'><p>Combine replicates from list to matrix</p></a></li>
<li><a href='#combineSingleT'><p>Get all combinations with TRUE from each column</p></a></li>
<li><a href='#completeArrLst'><p>Complete list of arrays for same dimensions</p></a></li>
<li><a href='#concatMatch'><p>Value Matching With Option For Concatenated Terms</p></a></li>
<li><a href='#confInt'><p>Confidence Interval To Given Alpha</p></a></li>
<li><a href='#contribToContigPerFrag'><p>Characterize individual contribution of single edges in tree-structures</p></a></li>
<li><a href='#conv01toColNa'><p>Convert matrix of integer to matrix of x-times repeated column-names</p></a></li>
<li><a href='#convColorToTransp'><p>Assign new transparency to given colors</p></a></li>
<li><a href='#convMatr2df'><p>Convert matrix (eg with redundant) row-names to data.frame</p></a></li>
<li><a href='#convToNum'><p>Convert vector to numeric</p></a></li>
<li><a href='#coordOfFilt'><p>get coordinates of values/points in matrix according to filtering condition</p></a></li>
<li><a href='#correctToUnique'><p>Correct vector to unique</p></a></li>
<li><a href='#correctWinPath'><p>Correct mixed slash and backslash in file path</p></a></li>
<li><a href='#countCloseToLimits'><p>Count from two vectors number of values close within given limits</p></a></li>
<li><a href='#countSameStartEnd'><p>Count same start- and end- sites of edges (or fragments)</p></a></li>
<li><a href='#cutArrayInCluLike'><p>Cut 3-dim array in list of matrixes (or arrays) similar to organizing into clusters</p></a></li>
<li><a href='#cutAtMultSites'><p>Cut character-vector at multiple sites</p></a></li>
<li><a href='#cutToNgrp'><p>Cut numeric vector to n groups (ie convert to factor)</p></a></li>
<li><a href='#diffCombin'><p>Compute matrix of differences for all pairwise combinations of numeric vector</p></a></li>
<li><a href='#diffPPM'><p>Difference in ppm between numeric values</p></a></li>
<li><a href='#elimCloseCoord'><p>Eliminate close (overlapping) points (in x &amp; y space)</p></a></li>
<li><a href='#equLenNumber'><p>Equal character-length number</p></a></li>
<li><a href='#exclExtrValues'><p>Exclude extreme values (based on distance to mean)</p></a></li>
<li><a href='#exponNormalize'><p>Normalize by adjusting exponent</p></a></li>
<li><a href='#extr1chan'><p>Extract just one series, ie channel, of list of arrays</p></a></li>
<li><a href='#extractLast2numericParts'><p>Extract last two numeric parts from character vector</p></a></li>
<li><a href='#extrColsDeX'><p>Flexible extraction of columns</p></a></li>
<li><a href='#extrNumericFromMatr'><p>Extract numeric part of matrix or data.frame</p></a></li>
<li><a href='#extrSpcText'><p>Extract specific text</p></a></li>
<li><a href='#filt3dimArr'><p>Filter three-dimensional array of numeric data</p></a></li>
<li><a href='#filterLiColDeList'><p>Filter lines(rows) and/or columns from all suitable elements of list</p></a></li>
<li><a href='#filterList'><p>Filter for unique elements</p></a></li>
<li><a href='#filterNetw'><p>Filter nodes &amp; edges for extracting networks</p>
</p>
<p>This function allows extracting and filtering network-data based on fixed threshold (<code>limInt</code>) and add sandwich-nodes (nodes inter-connecting initial nodes) out of node-based queries.</p></a></li>
<li><a href='#filtSizeUniq'><p>Filter for unique elements</p></a></li>
<li><a href='#findCloseMatch'><p>Find close numeric values between two vectors</p></a></li>
<li><a href='#findRepeated'><p>Find repeated elements</p></a></li>
<li><a href='#findSimilFrom2sets'><p>Find similar numeric values from two vectors/matrixes</p></a></li>
<li><a href='#findUsableGroupRange'><p>Select groups within given range</p></a></li>
<li><a href='#firstLineOfDat'><p>Filter matrix to keep only first of repeated lines</p></a></li>
<li><a href='#firstOfRepeated'><p>Find first of repeated elements</p></a></li>
<li><a href='#firstOfRepLines'><p>Reduce to first occurance of repeated lines</p></a></li>
<li><a href='#fuseAnnotMatr'><p>Fuse annotation matrix to initial matrix</p></a></li>
<li><a href='#fuseCommonListElem'><p>Fuse content of list-elements with redundant (duplicated) names</p></a></li>
<li><a href='#fusePairs'><p>Fuse pairs to generate cluster-names</p></a></li>
<li><a href='#get1stOfRepeatedByCol'><p>Get first of repeated by column</p></a></li>
<li><a href='#getValuesByUnique'><p>Print matrix-content as plot</p></a></li>
<li><a href='#gitDataUrl'><p>Convert ulr-name for reading in raw-mode</p></a></li>
<li><a href='#htmlSpecCharConv'><p>Html special character conversion</p></a></li>
<li><a href='#keepCommonText'><p>Extract Longest Common Text Out Of Character Vector</p></a></li>
<li><a href='#levIndex'><p>Transform (factor) levels into index</p></a></li>
<li><a href='#linModelSelect'><p>Test multiple starting levels for linear regression model, select best and plot</p></a></li>
<li><a href='#linRegrParamAndPVal'><p>Fit linear regression, return parameters and p-values</p></a></li>
<li><a href='#listBatchReplace'><p>Replacements in list</p></a></li>
<li><a href='#listGroupsByNames'><p>Organize values into list and sort by names</p></a></li>
<li><a href='#lmSelClu'><p>Run lm on segmented data (from clustering)</p></a></li>
<li><a href='#lrbind'><p>rbind on lists</p></a></li>
<li><a href='#makeMAList'><p>Make MA-List object</p></a></li>
<li><a href='#makeNRedMatr'><p>Make non-redundant matrix</p></a></li>
<li><a href='#matchMatrixLinesToRef'><p>Match All Lines of Matrix To Reference Note</p></a></li>
<li><a href='#matchNamesWithReverseParts'><p>Value Matching with optional reversing of sub-parts of non-matching elements</p></a></li>
<li><a href='#matchSampToPairw'><p>Match names to concatenated pairs of names</p></a></li>
<li><a href='#matr2list'><p>Transform columns of matrix to list of vectors</p></a></li>
<li><a href='#mergeMatrices'><p>Merge Multiple Matrices</p></a></li>
<li><a href='#mergeMatrixList'><p>Merge Multiple Matrices from List</p></a></li>
<li><a href='#mergeSelCol'><p>Merge selected columns out of 2 matrix or data.frames</p></a></li>
<li><a href='#mergeSelCol3'><p>mergeSelCol3</p></a></li>
<li><a href='#mergeVectors'><p>Merge Named Vectors</p></a></li>
<li><a href='#mergeW2'><p>Extended version of merge for multiple objects (even without rownames)</p></a></li>
<li><a href='#minDiff'><p>Minimum distance/difference between values</p></a></li>
<li><a href='#moderTest2grp'><p>Moderated pair-wise t-test from limma</p></a></li>
<li><a href='#moderTestXgrp'><p>Multiple moderated pair-wise t-tests from limma</p></a></li>
<li><a href='#multiCharReplace'><p>Multiple replacement of entire character elements in simple vector, matrix or data.frame</p></a></li>
<li><a href='#multiMatch'><p>Simple Multi-to-Multi Matching of (Concatenated) Terms</p></a></li>
<li><a href='#naOmit'><p>Fast na.omit</p></a></li>
<li><a href='#nFragments'><p>Number of fragments after cut at specific character(s) within size-range</p></a></li>
<li><a href='#nFragments0'><p>Number of fragments after cut at specific character(s)</p></a></li>
<li><a href='#nNonNumChar'><p>Count number of non-numeric characters</p></a></li>
<li><a href='#nonAmbiguousMat'><p>Transform matrix to non-ambiguous matrix (in respect to given column)</p></a></li>
<li><a href='#nonAmbiguousNum'><p>make numeric vector non-ambiguous (ie unique)</p></a></li>
<li><a href='#nonredDataFrame'><p>Filter for unique elements</p></a></li>
<li><a href='#nonRedundLines'><p>Non-redundant lines of matrix</p></a></li>
<li><a href='#normalizeThis'><p>Normalize data in various modes</p></a></li>
<li><a href='#numPairDeColNames'><p>Extract pair of numeric values from vector or column-names</p></a></li>
<li><a href='#orderMatrToRef'><p>Order Lines of Matrix According to Reference (Character) Vector</p></a></li>
<li><a href='#organizeAsListOfRepl'><p>(re)organize data of (3-dim) array as list of replicates</p></a></li>
<li><a href='#packageDownloadStat'><p>Simple Package Download Statistics from CRAN</p></a></li>
<li><a href='#pairsAsPropensMatr'><p>Convert Pairs of Node-Names to Non-Oriented Propensity Matrix</p></a></li>
<li><a href='#partialDist'><p>Partial distance matrix (focus on closest)</p></a></li>
<li><a href='#partUnlist'><p>Partial unlist of lists of lists</p></a></li>
<li><a href='#pasteC'><p>Advanced paste-collapse</p></a></li>
<li><a href='#presenceFilt'><p>Filter lines of matrix for max number of NAs</p></a></li>
<li><a href='#presenceGrpFilt'><p>Filter for each group of columns for sufficient data as non-NA</p></a></li>
<li><a href='#protectSpecChar'><p>Protect Special Characters</p></a></li>
<li><a href='#pVal2lfdr'><p>Convert p-values to lfdr</p></a></li>
<li><a href='#randIndFx'><p>Distance of categorical data (Jaccard, Rand and adjusted Rand index)</p></a></li>
<li><a href='#rankToContigTab'><p>Contingenty tables for fit of ranking</p></a></li>
<li><a href='#ratioAllComb'><p>Calculate all ratios between x and y</p></a></li>
<li><a href='#ratioToPpm'><p>Convert ratio to ppm</p></a></li>
<li><a href='#readCsvBatch'><p>Read batch of csv-files</p></a></li>
<li><a href='#readTabulatedBatch'><p>Batch reading of Tabulated Text-Files</p></a></li>
<li><a href='#readVarColumns'><p>Read tabular content of files with variable number of columns</p></a></li>
<li><a href='#readXlsxBatch'><p>Read Batch of Excel xlsx-Files</p></a></li>
<li><a href='#reduceTable'><p>Reduce table by aggregating smaller groups</p></a></li>
<li><a href='#regrBy1or2point'><p>Rescaling according to reference data using linear regression.</p></a></li>
<li><a href='#regrMultBy1or2point'><p>Rescaling of multiple data-sets according to reference data using regression</p></a></li>
<li><a href='#renameColumns'><p>Rename columns</p></a></li>
<li><a href='#reorgByCluNo'><p>Reorganize matrix according to clustering-output</p></a></li>
<li><a href='#replicateStructure'><p>Search and Select Groups of Replicates</p></a></li>
<li><a href='#replNAbyLow'><p>Replace NAs by low values</p></a></li>
<li><a href='#replPlateCV'><p>CV of replicate plates (list of matrixes)</p></a></li>
<li><a href='#rmDupl2colMatr'><p>Remove lines of matrix redundant /duplicated for 1st and 2nd column</p></a></li>
<li><a href='#rmEnumeratorName'><p>Remove or rename enumerator tag/name (or remove entire enumerator) from tailing enumerators</p></a></li>
<li><a href='#rnormW'><p>Normal random number generation with close fit to expected mean and sd</p></a></li>
<li><a href='#rowCVs'><p>rowCVs</p></a></li>
<li><a href='#rowGrpCV'><p>Row group CV</p></a></li>
<li><a href='#rowGrpMeans'><p>rowMeans with destinction of groups (of columns, eg groups of replicates)</p></a></li>
<li><a href='#rowGrpNA'><p>Count number of NAs per row and group of columns</p></a></li>
<li><a href='#rowGrpSds'><p>Per line and per group sd-values</p></a></li>
<li><a href='#rowGrpSums'><p>rowSums with destinction of groups (of columns, eg groups of replicates)</p></a></li>
<li><a href='#rowMedSds'><p>sd of median for each row by bootstrap</p></a></li>
<li><a href='#rowNormalize'><p>Row Normalize</p></a></li>
<li><a href='#rowSds'><p>sd for each row (fast execution)</p></a></li>
<li><a href='#rowSEMs'><p>SEM for each row</p></a></li>
<li><a href='#sampNoDeMArrayLM'><p>Locate Sample Index From Index or Name Of Pair-Wise Comparisons in list or MArrayLM-Object</p></a></li>
<li><a href='#scaleXY'><p>Scale data to given minimum and maxiumum</p></a></li>
<li><a href='#searchDataPairs'><p>Search duplicated data over multiple columns, ie pairs of data</p></a></li>
<li><a href='#searchLinesAtGivenSlope'><p>Search points forming lines at given slope</p></a></li>
<li><a href='#simpleFragFig'><p>Simple figure showing line from start- to end-sites of edges (or fragments) defined by their start- and end-sites</p>
</p>
<p><code>simpleFragFig</code> draws figure showing start- and end-sites of edges (or fragments)</p></a></li>
<li><a href='#singleLineAnova'><p>2-factorial Anova on single line of data</p></a></li>
<li><a href='#sortBy2CategorAnd1IntCol'><p>Sort matrix by two categorical and one integer columns</p></a></li>
<li><a href='#sortByNRepeated'><p>Make a list of common occurances sorted by number of repeats</p></a></li>
<li><a href='#stableMode'><p>Estimate mode (most frequent value)</p></a></li>
<li><a href='#standardW'><p>Standardize (scale) data</p></a></li>
<li><a href='#stdErrMedBoot'><p>Standard eror of median by boot-strap</p></a></li>
<li><a href='#summarizeCols'><p>Summarize columns (as median,mean,min,last or other methods)</p></a></li>
<li><a href='#sumNAperGroup'><p>Count number of NAs per sub-set of columns</p></a></li>
<li><a href='#sysDate'><p>System-date (compressed format)</p></a></li>
<li><a href='#tableToPlot'><p>Print matrix-content as plot</p></a></li>
<li><a href='#test2factLimma'><p>2-factorial limma-style t-test</p></a></li>
<li><a href='#transpGraySca'><p>Make single vector gray-gradient</p></a></li>
<li><a href='#treatTxtDuplicates'><p>Locate duplicates in text and make non-redundant</p></a></li>
<li><a href='#triCoord'><p>Pairwise x,y combinations</p></a></li>
<li><a href='#trimRedundText'><p>Trim redundant text</p></a></li>
<li><a href='#tTestAllVal'><p>t.test on all individual values against all other values</p></a></li>
<li><a href='#unifyEnumerator'><p>Unify Enumerators</p></a></li>
<li><a href='#uniqCountReport'><p>Report number of unique and redundant elements (optional figure)</p></a></li>
<li><a href='#upperMaCoord'><p>(upper) pairwise x,y combinations</p></a></li>
<li><a href='#withinRefRange'><p>Check for values within range of reference</p></a></li>
<li><a href='#writeCsv'><p>Write (and convert) csv files</p></a></li>
<li><a href='#XYToDiffPpm'><p>Express difference as ppm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.14.2</td>
</tr>
<tr>
<td>Title:</td>
<td>Analyze Experimental High-Throughput (Omics) Data</td>
</tr>
<tr>
<td>Author:</td>
<td>Wolfgang Raffelsberger [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wolfgang Raffelsberger &lt;w.raffelsberger@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The efficient treatment and convenient analysis of experimental high-throughput (omics) data gets facilitated through this collection of diverse functions. 
  Several functions address advanced object-conversions, like manipulating lists of lists or lists of arrays, reorganizing lists to arrays or into separate vectors, merging of multiple entries, etc.  
  Another set of functions provides speed-optimized calculation of standard deviation (sd), coefficient of variance (CV) or standard error of the mean (SEM)  
  for data in matrixes or means per line with respect to additional grouping (eg n groups of replicates). 
  Other functions facilitate dealing with non-redundant information, by indexing unique, adding counters to redundant or eliminating lines with respect redundancy in a given reference-column, etc. 
  Help is provided to identify very closely matching numeric values to generate (partial) distance matrixes for very big data in a memory efficient manner or to reduce the complexity of large data-sets by combining very close values. 
  Many times large experimental datasets need some additional filtering, adequate functions are provided. 
  Batch reading (or writing) of sets of files and combining data to arrays is supported, too. 
  Convenient data normalization is supported in various different modes, parameter estimation via permutations or boot-strap as well as flexible testing of multiple pair-wise combinations using the framework of 'limma' is provided, too.</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, MASS, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BBmisc, boot, coin, data.table, data.tree, fdrtool,
flexclust, knitr, limma, markdown, mixdist, NbClust,
preprocessCore, qvalue, Rcpp, RColorBrewer, readxl, rmarkdown,
som, stringi, VGAM, vsn, wrGraph</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-28 12:29:32 UTC; wraff</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-28 13:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.addLetterWoLast'>Add letter to all elements but not last</h2><span id='topic+.addLetterWoLast'></span>

<h3>Description</h3>

<p>This function allows to add 'addChr' to all entries, without the last entry
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.addLetterWoLast(x, addChr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".addLetterWoLast_+3A_x">x</code></td>
<td>
<p>(character) main input</p>
</td></tr>
<tr><td><code id=".addLetterWoLast_+3A_addchr">addChr</code></td>
<td>
<p>(character)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a modified character vector
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+paste">paste</a></code>; used in <code><a href="#topic+cutAtMultSites">cutAtMultSites</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.addLetterWoLast(c("abc","efgh"),"Z")
</code></pre>

<hr>
<h2 id='.allRatioMatr1to2'>Calculate ratios for each column to each column of reference-matrix</h2><span id='topic+.allRatioMatr1to2'></span>

<h3>Description</h3>

<p>This function calculates ratio(s) for each column of matrix 'x' versus all/each column(s) of matrix 'y' (reference)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.allRatioMatr1to2(x, y, asLog2 = TRUE, sumMeth = "mean", callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".allRatioMatr1to2_+3A_x">x</code></td>
<td>
<p>(matrix or data.frame) main input1</p>
</td></tr>
<tr><td><code id=".allRatioMatr1to2_+3A_y">y</code></td>
<td>
<p>(matrix or data.frame) main input2</p>
</td></tr>
<tr><td><code id=".allRatioMatr1to2_+3A_aslog2">asLog2</code></td>
<td>
<p>(logical)</p>
</td></tr>
<tr><td><code id=".allRatioMatr1to2_+3A_summeth">sumMeth</code></td>
<td>
<p>(character) method</p>
</td></tr>
<tr><td><code id=".allRatioMatr1to2_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a numeric vector or matrix in dimension of 'x' (so far summarize all ratios from mult division from mult ref cols as mean or median )
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeMAList">makeMAList</a></code>, <code><a href="base.html#topic+grep">grep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.allRatioMatr1to2(matrix(11:14, ncol=2), matrix(21:24, ncol=2))
</code></pre>

<hr>
<h2 id='.allRatios'>Search character-string and cut either before or after</h2><span id='topic+.allRatios'></span>

<h3>Description</h3>

<p>This function extracts/cuts text-fragments out of <code>txt</code> following specific anchors defined by arguments <code>cutFrom</code> and <code>cutTo</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.allRatios(dat, ty = "log2", colNaSep = "_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".allRatios_+3A_dat">dat</code></td>
<td>
<p>(matrix or data.frame) main input</p>
</td></tr>
<tr><td><code id=".allRatios_+3A_ty">ty</code></td>
<td>
<p>(character) type of ratio (eg 'log2')</p>
</td></tr>
<tr><td><code id=".allRatios_+3A_colnasep">colNaSep</code></td>
<td>
<p>(character) separator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a numeric vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeMAList">makeMAList</a></code>, <code><a href="base.html#topic+grep">grep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.allRatios(matrix(11:14, ncol=2))
</code></pre>

<hr>
<h2 id='.arrLstMean'>Summarize along columns of multiple arrays in list</h2><span id='topic+.arrLstMean'></span>

<h3>Description</h3>

<p>This function allows summarizing along columns of multiple arrays in list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.arrLstMean(
  arrLst,
  sumType = "mean",
  arrOutp = FALSE,
  signifDig = 3,
  formatCheck = FALSE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".arrLstMean_+3A_arrlst">arrLst</code></td>
<td>
<p>(list) main input</p>
</td></tr>
<tr><td><code id=".arrLstMean_+3A_sumtype">sumType</code></td>
<td>
<p>(character)</p>
</td></tr>
<tr><td><code id=".arrLstMean_+3A_arroutp">arrOutp</code></td>
<td>
<p>(logical)</p>
</td></tr>
<tr><td><code id=".arrLstMean_+3A_signifdig">signifDig</code></td>
<td>
<p>(integer)</p>
</td></tr>
<tr><td><code id=".arrLstMean_+3A_formatcheck">formatCheck</code></td>
<td>
<p>(logical)</p>
</td></tr>
<tr><td><code id=".arrLstMean_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id=".arrLstMean_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id=".arrLstMean_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array (1st dim will be summary along cols, rows will be layers of 3rd array-dim
</p>


<h3>See Also</h3>

<p>used in <code><a href="#topic+cutArrayInCluLike">cutArrayInCluLike</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.datSlope(c(3:6))
</code></pre>

<hr>
<h2 id='.arrLstSEM'>Summarize along columns of mult arrays in list</h2><span id='topic+.arrLstSEM'></span>

<h3>Description</h3>

<p>This function allows summarizing along columns of mult arrays in list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.arrLstSEM(
  arrLst,
  arrOutp = FALSE,
  signifDig = 3,
  formatCheck = FALSE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".arrLstSEM_+3A_arrlst">arrLst</code></td>
<td>
<p>(list) main input</p>
</td></tr>
<tr><td><code id=".arrLstSEM_+3A_arroutp">arrOutp</code></td>
<td>
<p>(logical)</p>
</td></tr>
<tr><td><code id=".arrLstSEM_+3A_signifdig">signifDig</code></td>
<td>
<p>(integer)</p>
</td></tr>
<tr><td><code id=".arrLstSEM_+3A_formatcheck">formatCheck</code></td>
<td>
<p>(logical)</p>
</td></tr>
<tr><td><code id=".arrLstSEM_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id=".arrLstSEM_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id=".arrLstSEM_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array (1st dim will be summary along cols, rows will be layers of 3rd array-dim ie dim(arrLst[[1]])[3])
</p>


<h3>See Also</h3>

<p>used in <code><a href="#topic+cutArrayInCluLike">cutArrayInCluLike</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.datSlope(c(3:6))
</code></pre>

<hr>
<h2 id='.asDF2'>Convert anything to data.frame</h2><span id='topic+.asDF2'></span>

<h3>Description</h3>

<p>This function allows converting anything to data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.asDF2(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".asDF2_+3A_z">z</code></td>
<td>
<p>(numeric vector, factor, matrix or list) main input</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.asDF2(c(3:6))
</code></pre>

<hr>
<h2 id='.breakInSer'>Get series of values after last discontinuity</h2><span id='topic+.breakInSer'></span>

<h3>Description</h3>

<p>This function aims to get series of values after last discontinuity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.breakInSer(x, getFrom = "last")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".breakInSer_+3A_x">x</code></td>
<td>
<p>(numeric) main input</p>
</td></tr>
<tr><td><code id=".breakInSer_+3A_getfrom">getFrom</code></td>
<td>
<p>(character)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a numeric vector of reduced length
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.breakInSer(c(11:14,16:18))
</code></pre>

<hr>
<h2 id='.bringToCtr'>Bring most extreme to center</h2><span id='topic+.bringToCtr'></span>

<h3>Description</h3>

<p>This function aims to bring most extreme value to center
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.bringToCtr(aa, ctr, ctrFa = 0.75)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".bringToCtr_+3A_aa">aa</code></td>
<td>
<p>(numeric) main input</p>
</td></tr>
<tr><td><code id=".bringToCtr_+3A_ctr">ctr</code></td>
<td>
<p>(numeric) 'control'</p>
</td></tr>
<tr><td><code id=".bringToCtr_+3A_ctrfa">ctrFa</code></td>
<td>
<p>(numeric &lt;1) modulate amplitude of effect</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an adjusted numeric vector
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.bringToCtr(11:14, 9)
</code></pre>

<hr>
<h2 id='.checkArgNa'>Check argument names</h2><span id='topic+.checkArgNa'></span>

<h3>Description</h3>

<p>This function allows checking of argument names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.checkArgNa(x, argNa, lazyEval = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".checkArgNa_+3A_x">x</code></td>
<td>
<p>(character) main input</p>
</td></tr>
<tr><td><code id=".checkArgNa_+3A_argna">argNa</code></td>
<td>
<p>(character) argument name</p>
</td></tr>
<tr><td><code id=".checkArgNa_+3A_lazyeval">lazyEval</code></td>
<td>
<p>(logical) decide if argument should be avaluated with abbreviated names, too</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a elongated character vector
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+chartr">chartr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.checkArgNa("Abc",c("ab","Ab","BCD"))
</code></pre>

<hr>
<h2 id='.checkConsistentArrList'>Check list of arrays for consistent dimensions of all arrays</h2><span id='topic+.checkConsistentArrList'></span>

<h3>Description</h3>

<p>This function allows to check list of arrays for consistent dimensions of all arrays
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.checkConsistentArrList(
  arrLst,
  arrNDim = 3,
  fxName = NULL,
  varName = NULL,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".checkConsistentArrList_+3A_arrlst">arrLst</code></td>
<td>
<p>(list) main input</p>
</td></tr>
<tr><td><code id=".checkConsistentArrList_+3A_arrndim">arrNDim</code></td>
<td>
<p>(integer) number of dimensions for arrays</p>
</td></tr>
<tr><td><code id=".checkConsistentArrList_+3A_fxname">fxName</code></td>
<td>
<p>(character) this name will be given in message</p>
</td></tr>
<tr><td><code id=".checkConsistentArrList_+3A_varname">varName</code></td>
<td>
<p>(character)</p>
</td></tr>
<tr><td><code id=".checkConsistentArrList_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id=".checkConsistentArrList_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id=".checkConsistentArrList_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>See Also</h3>

<p>used in <code><a href="#topic+cutArrayInCluLike">cutArrayInCluLike</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.datSlope(c(3:6))
</code></pre>

<hr>
<h2 id='.checkConvt2Vect'>Convert to simple vector (similar to unlist)</h2><span id='topic+.checkConvt2Vect'></span>

<h3>Description</h3>

<p>This function allows converting 'dat' (may be list, data.frame etc) to simple vector, more elaborate than unlist()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.checkConvt2Vect(dat, toNumeric = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".checkConvt2Vect_+3A_dat">dat</code></td>
<td>
<p>(list, data.frame) main input</p>
</td></tr>
<tr><td><code id=".checkConvt2Vect_+3A_tonumeric">toNumeric</code></td>
<td>
<p>(logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character (or numeric) vector
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+unlist">unlist</a></code>; used in  <code><a href="#topic+equLenNumber">equLenNumber</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aa &lt;- matrix(11:14, ncol=2)
.checkConvt2Vect(aa)
</code></pre>

<hr>
<h2 id='.checkFactor'>Check Factor</h2><span id='topic+.checkFactor'></span>

<h3>Description</h3>

<p>This function was designed to check a factor object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.checkFactor(
  fac,
  facNa = NULL,
  minLev = 2,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".checkFactor_+3A_fac">fac</code></td>
<td>
<p>(factor) main input</p>
</td></tr>
<tr><td><code id=".checkFactor_+3A_facna">facNa</code></td>
<td>
<p>(character) level-names</p>
</td></tr>
<tr><td><code id=".checkFactor_+3A_minlev">minLev</code></td>
<td>
<p>(integer) minium number of levels</p>
</td></tr>
<tr><td><code id=".checkFactor_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id=".checkFactor_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id=".checkFactor_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a corrceted/adjusted factor
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+factor">factor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.checkFactor(gl(3,2))
</code></pre>

<hr>
<h2 id='.checkFileNameExtensions'>checkFileNameExtensions 
Function for checking file-names.</h2><span id='topic+.checkFileNameExtensions'></span>

<h3>Description</h3>

<p>checkFileNameExtensions 
Function for checking file-names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.checkFileNameExtensions(fileNa, ext)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".checkFileNameExtensions_+3A_filena">fileNa</code></td>
<td>
<p>(character) file name to be checked</p>
</td></tr>
<tr><td><code id=".checkFileNameExtensions_+3A_ext">ext</code></td>
<td>
<p>(character) file extension</p>
</td></tr>
</table>


<h3>Value</h3>

<p>modified character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.checkFileNameExtensions("testFile.txt","txt")
</code></pre>

<hr>
<h2 id='.checkLegendLoc'>Check argument for Location of legend</h2><span id='topic+.checkLegendLoc'></span>

<h3>Description</h3>

<p>This function allows checking an argument for Location of legend,
if value provided not found as valid, it returns 'defLoc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.checkLegendLoc(
  legLoc,
  defLoc = "topright",
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".checkLegendLoc_+3A_legloc">legLoc</code></td>
<td>
<p>(character) main input</p>
</td></tr>
<tr><td><code id=".checkLegendLoc_+3A_defloc">defLoc</code></td>
<td>
<p>(character)</p>
</td></tr>
<tr><td><code id=".checkLegendLoc_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id=".checkLegendLoc_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id=".checkLegendLoc_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a character vector designing the potential location of legend
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+legend">legend</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.checkLegendLoc("abc")
</code></pre>

<hr>
<h2 id='.checkLmConfInt'>Compare 'dat' to confindence interval of linare model 'lMod' (eg from lm())</h2><span id='topic+.checkLmConfInt'></span>

<h3>Description</h3>

<p>This function allows to compare 'dat' to confindence interval of linare model 'lMod' (eg from lm())
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.checkLmConfInt(dat, lMod, level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".checkLmConfInt_+3A_dat">dat</code></td>
<td>
<p>matrix or data.frame, main input</p>
</td></tr>
<tr><td><code id=".checkLmConfInt_+3A_lmod">lMod</code></td>
<td>
<p>linear model, only used to extract coefficients offset &amp; slope</p>
</td></tr>
<tr><td><code id=".checkLmConfInt_+3A_level">level</code></td>
<td>
<p>(numeric) alpha threshold for linear model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a logical vector for each value in 2nd col of 'dat' if INSIDE confid interval
</p>


<h3>See Also</h3>

<p><code><a href="#topic+searchLinesAtGivenSlope">searchLinesAtGivenSlope</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016); dat1 &lt;- matrix(c(runif(200)+rep(1:10,20)),ncol=10)
</code></pre>

<hr>
<h2 id='.checkRegrArguments'>Check regression arguments</h2><span id='topic+.checkRegrArguments'></span>

<h3>Description</h3>

<p>This function allows to check arguments for linear regression. Used as argument checking for <code>regrBy1or2point</code> and <code>regrMultBy1or2point</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.checkRegrArguments(inData, refList, regreTo, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".checkRegrArguments_+3A_indata">inData</code></td>
<td>
<p>(numeric vector) main input</p>
</td></tr>
<tr><td><code id=".checkRegrArguments_+3A_reflist">refList</code></td>
<td>
<p>(list)</p>
</td></tr>
<tr><td><code id=".checkRegrArguments_+3A_regreto">regreTo</code></td>
<td>
<p>(numeric vector)</p>
</td></tr>
<tr><td><code id=".checkRegrArguments_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+append">append</a></code>; <code><a href="#topic+lrbind">lrbind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.datSlope(c(3:6))
</code></pre>

<hr>
<h2 id='.chooseGrpCol'>Automatic choice of colors</h2><span id='topic+.chooseGrpCol'></span>

<h3>Description</h3>

<p>This function allows to do automatic choice of colors: if single-&gt; grey, if few -&gt; RColorBrewer, if many : gradient green -&gt; grey/red
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.chooseGrpCol(nGrp, paired = FALSE, alph = 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".chooseGrpCol_+3A_ngrp">nGrp</code></td>
<td>
<p>(numeric vector) main input</p>
</td></tr>
<tr><td><code id=".chooseGrpCol_+3A_paired">paired</code></td>
<td>
<p>(logical)</p>
</td></tr>
<tr><td><code id=".chooseGrpCol_+3A_alph">alph</code></td>
<td>
<p>(numeric vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector with color codes
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+rgb">rgb</a></code>; <code><a href="#topic+colorAccording2">colorAccording2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.chooseGrpCol(4)	
</code></pre>

<hr>
<h2 id='.combineListAnnot'>Combine annotation information from list of matrixes</h2><span id='topic+.combineListAnnot'></span>

<h3>Description</h3>

<p>This function allows to combine information (annotation) from list of matrixes (ie replace when NA), using always the columns specified in 'useCol' (numeric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.combineListAnnot(
  lst,
  useCol = 1:2,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".combineListAnnot_+3A_lst">lst</code></td>
<td>
<p>(list) main input</p>
</td></tr>
<tr><td><code id=".combineListAnnot_+3A_usecol">useCol</code></td>
<td>
<p>(numeric vector) which columns should be used</p>
</td></tr>
<tr><td><code id=".combineListAnnot_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id=".combineListAnnot_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id=".combineListAnnot_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a single matrix of combined (non-redundant) info
</p>


<h3>See Also</h3>

<p>used in <code><a href="#topic+cutArrayInCluLike">cutArrayInCluLike</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.datSlope(c(3:6))
</code></pre>

<hr>
<h2 id='.compareByDiff'>Compare by distance/difference</h2><span id='topic+.compareByDiff'></span>

<h3>Description</h3>

<p>This function allows to compare by distance/difference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.compareByDiff(dat, limit, distVal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".compareByDiff_+3A_dat">dat</code></td>
<td>
<p>list of 2 numerical vectors</p>
</td></tr>
<tr><td><code id=".compareByDiff_+3A_limit">limit</code></td>
<td>
<p>(numeric, length=1) threshold value for retaining values, used with distace-type specified in argument 'compTy'</p>
</td></tr>
<tr><td><code id=".compareByDiff_+3A_distval">distVal</code></td>
<td>
<p>(logical) to toggle outpout as matrix of numeric (distance values above 'limit', others NA) or matrix of logical</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with close matches of 'x' to given 'y', the numeric value dependes on 'sortMatch' (if FASLE then always value of 'y' otherwise of longest of x&amp;y)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findCloseMatch">findCloseMatch</a></code>,  <code><a href="#topic+checkSimValueInSer">checkSimValueInSer</a></code>, and also <code>.compareByLogRatio</code>, for convient output <code><a href="#topic+countCloseToLimits">countCloseToLimits</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cc &lt;- list(aa=11:14, bb=c(13.1,11.5,14.3,20:21))
</code></pre>

<hr>
<h2 id='.compareByLogRatio'>Compare by log-ratio</h2><span id='topic+.compareByLogRatio'></span>

<h3>Description</h3>

<p>This function allows to compare by log-ratio
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.compareByLogRatio(dat, limit, distVal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".compareByLogRatio_+3A_dat">dat</code></td>
<td>
<p>list of 2 numerical vectors</p>
</td></tr>
<tr><td><code id=".compareByLogRatio_+3A_limit">limit</code></td>
<td>
<p>(numeric, length=1) threshold value for retaining values, used with distace-type specified in argument 'compTy'</p>
</td></tr>
<tr><td><code id=".compareByLogRatio_+3A_distval">distVal</code></td>
<td>
<p>(logical) to toggle outpout as matrix of numeric (distance values above 'limit', others NA) or matrix of logical</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with close matches of 'x' to given 'y', the numeric value dependes on 'sortMatch' (if FASLE then always value of 'y' otherwise of longest of x&amp;y)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findCloseMatch">findCloseMatch</a></code>,  <code><a href="#topic+checkSimValueInSer">checkSimValueInSer</a></code>, and also <code>.compareByDiff</code>, for convient output <code><a href="#topic+countCloseToLimits">countCloseToLimits</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cc &lt;- list(aa=11:14, bb=c(13.1,11.5,14.3,20:21))
.compareByLogRatio(cc, 1) 
</code></pre>

<hr>
<h2 id='.compareByPPM'>Compare by PPM</h2><span id='topic+.compareByPPM'></span>

<h3>Description</h3>

<p>This function allows to compare by ppm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.compareByPPM(dat, limit, distVal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".compareByPPM_+3A_dat">dat</code></td>
<td>
<p>list of 2 numerical vectors</p>
</td></tr>
<tr><td><code id=".compareByPPM_+3A_limit">limit</code></td>
<td>
<p>(numeric, length=1) threshold value for retaining values, used with distace-type specified in argument 'compTy'</p>
</td></tr>
<tr><td><code id=".compareByPPM_+3A_distval">distVal</code></td>
<td>
<p>(logical) to toggle outpout as matrix of numeric (distance values above 'limit', others NA) or matrix of logical</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with close matches of 'x' to given 'y', the numeric value dependes on 'sortMatch' (if FASLE then always value of 'y' otherwise of longest of x&amp;y)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findCloseMatch">findCloseMatch</a></code>,  <code><a href="#topic+checkSimValueInSer">checkSimValueInSer</a></code>, and also <code>.compareByDiff</code>, for convient output <code><a href="#topic+countCloseToLimits">countCloseToLimits</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cc &lt;- list(aa=11:14, bb=c(13.1,11.5,14.3,20:21))
.compareByPPM(cc, 1) 
</code></pre>

<hr>
<h2 id='.complCols'>Search (complementing) columns for best coverage of non-NA data for rowNormalization (main)</h2><span id='topic+.complCols'></span>

<h3>Description</h3>

<p>This function was designed to complete the selection of columns of sparse matrix 'dat' with sets of 'nCombin' columns at complete 'coverage'
Context : In sparse matrix 'dat' search subsets of columns with some rows as complete (no NA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.complCols(x, dat, nCombin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".complCols_+3A_x">x</code></td>
<td>
<p>(integer, length=1) column number for with other columns to combine &amp; give (some) complete non-NA lines are seeked</p>
</td></tr>
<tr><td><code id=".complCols_+3A_dat">dat</code></td>
<td>
<p>(matrix) .. init data, smay be parse matrix with numerous NA</p>
</td></tr>
<tr><td><code id=".complCols_+3A_ncombin">nCombin</code></td>
<td>
<p>(integer) .. number of columns used to make complete subset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix of column-indexes complementing (nCombin rows)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowNormalize">rowNormalize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.complCols(3, dat=matrix(c(NA,12:17,NA,19),ncol=3), nCombin=3)
</code></pre>

<hr>
<h2 id='.composeCallName'>Compose sequence of (function-)calls</h2><span id='topic+.composeCallName'></span>

<h3>Description</h3>

<p>This function was designed for tracing the hierarchy of function-calls.
It allows to remove any tailing space or ': ' from 'callFrom' (character vector) and return with added 'newNa' (+ 'add2Tail')
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.composeCallName(newNa, add2Head = "", add2Tail = " : ", callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".composeCallName_+3A_newna">newNa</code></td>
<td>
<p>(character vector) main input</p>
</td></tr>
<tr><td><code id=".composeCallName_+3A_add2head">add2Head</code></td>
<td>
<p>(character)</p>
</td></tr>
<tr><td><code id=".composeCallName_+3A_add2tail">add2Tail</code></td>
<td>
<p>(character)</p>
</td></tr>
<tr><td><code id=".composeCallName_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) may also contain multiple separate names (ie length &gt;1), will be concatenated using ' -&gt; '</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector (history of who called whom)
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+paste">paste</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.composeCallName("newFunction", callFrom="initFunction")
</code></pre>

<hr>
<h2 id='.convertMatrToNum'>Convert numeric matrix to numeric</h2><span id='topic+.convertMatrToNum'></span>

<h3>Description</h3>

<p>Take matrix and return vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.convertMatrToNum(matr, useCol = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".convertMatrToNum_+3A_matr">matr</code></td>
<td>
<p>(matrix) main input</p>
</td></tr>
<tr><td><code id=".convertMatrToNum_+3A_usecol">useCol</code></td>
<td>
<p>(integer) design the comumns to be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+matrix">matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.convertMatrToNum(matrix(1:6, ncol=2))
</code></pre>

<hr>
<h2 id='.convertNa'>Convert/standardize names of 'query' to standard names from 'ref'</h2><span id='topic+.convertNa'></span>

<h3>Description</h3>

<p>This function converts/standardizes names of 'query' to standard names from 'ref' (list of possible names (char vect) where names define standardized name).
It takes 'query' as character vector and return character vecor (same length as 'query') with 'converted/corrected' names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.convertNa(query, ref, partMatch = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".convertNa_+3A_query">query</code></td>
<td>
<p>(matrix or data.frame, min 2 columns) main input</p>
</td></tr>
<tr><td><code id=".convertNa_+3A_ref">ref</code></td>
<td>
<p>(list) list of multiple possible names associated to given group, reference name for each group is name of list</p>
</td></tr>
<tr><td><code id=".convertNa_+3A_partmatch">partMatch</code></td>
<td>
<p>(logical) allows partial matching (ie name of 'ref' must be in head of 'query')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>daPa &lt;- matrix(c(1:5,8,2:6,9), ncol=2)
</code></pre>

<hr>
<h2 id='.corDuplItemsByIncrem'>Avoid duplicating items between 'curNa' and 'newNa' by incrementing digits after 'extPref' (in newNa)</h2><span id='topic+.corDuplItemsByIncrem'></span>

<h3>Description</h3>

<p>This function aims to avoid duplicating items between 'curNa' and 'newNa' by incrementing digits after 'extPref' (in newNa)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.corDuplItemsByIncrem(newNa, curNa, extPref = "_s")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".corDuplItemsByIncrem_+3A_newna">newNa</code></td>
<td>
<p>(character) main input 1</p>
</td></tr>
<tr><td><code id=".corDuplItemsByIncrem_+3A_curna">curNa</code></td>
<td>
<p>(character) main input 2</p>
</td></tr>
<tr><td><code id=".corDuplItemsByIncrem_+3A_extpref">extPref</code></td>
<td>
<p>(character) extension</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the corrected input vector <code>newNa</code>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+duplicated">duplicated</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.corDuplItemsByIncrem(letters[1:6], letters[8:4])
</code></pre>

<hr>
<h2 id='.cutAtSearch'>Search character-string and cut either before or after</h2><span id='topic+.cutAtSearch'></span>

<h3>Description</h3>

<p>This function extracts/cuts text-fragments out of <code>txt</code> following specific anchors defined by arguments <code>cutFrom</code> and <code>cutTo</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cutAtSearch(
  x,
  searchChar,
  after = TRUE,
  silent = TRUE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".cutAtSearch_+3A_x">x</code></td>
<td>
<p>character vector to be treated</p>
</td></tr>
<tr><td><code id=".cutAtSearch_+3A_searchchar">searchChar</code></td>
<td>
<p>(character) text to look for</p>
</td></tr>
<tr><td><code id=".cutAtSearch_+3A_after">after</code></td>
<td>
<p>(logical)</p>
</td></tr>
<tr><td><code id=".cutAtSearch_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id=".cutAtSearch_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id=".cutAtSearch_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a modified character vector
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grep">grep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.cutAtSearch("abcdefg","de")
</code></pre>

<hr>
<h2 id='.cutStr'>Cut string to get all variants from given start with min and max length</h2><span id='topic+.cutStr'></span>

<h3>Description</h3>

<p>This function allows truncating character vector to all variants from given start, with min and optonal max length
Used to evaluate argument calls without giving full length of argument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cutStr(txt, startFr = 1, minLe = 1, maxLe = NULL, reverse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".cutStr_+3A_txt">txt</code></td>
<td>
<p>(character) main input, may be length &gt;1</p>
</td></tr>
<tr><td><code id=".cutStr_+3A_startfr">startFr</code></td>
<td>
<p>(interger) where to start</p>
</td></tr>
<tr><td><code id=".cutStr_+3A_minle">minLe</code></td>
<td>
<p>(interger) minimum length of output</p>
</td></tr>
<tr><td><code id=".cutStr_+3A_maxle">maxLe</code></td>
<td>
<p>(interger) maximum length of output</p>
</td></tr>
<tr><td><code id=".cutStr_+3A_reverse">reverse</code></td>
<td>
<p>(logical) return longest text-fragments at beginning of vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a character vector
</p>


<h3>See Also</h3>

<p>used in <code><a href="#topic+pasteC">pasteC</a></code>; <code><a href="base.html#topic+substr">substr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.cutStr("abcdefg", minLe=2)
</code></pre>

<hr>
<h2 id='.datSlope'>Model linear regression and optional plot</h2><span id='topic+.datSlope'></span>

<h3>Description</h3>

<p>This function allows to model a linear regression and optionally to plot the results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.datSlope(
  dat,
  typeOfPlot = "sort",
  toNinX = FALSE,
  plotData = FALSE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".datSlope_+3A_dat">dat</code></td>
<td>
<p>(vector or matrix) main input</p>
</td></tr>
<tr><td><code id=".datSlope_+3A_typeofplot">typeOfPlot</code></td>
<td>
<p>(character)</p>
</td></tr>
<tr><td><code id=".datSlope_+3A_toninx">toNinX</code></td>
<td>
<p>(logical)</p>
</td></tr>
<tr><td><code id=".datSlope_+3A_plotdata">plotData</code></td>
<td>
<p>(logical)</p>
</td></tr>
<tr><td><code id=".datSlope_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id=".datSlope_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id=".datSlope_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector with intercept and slope, optional plot
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+append">append</a></code>; <code><a href="#topic+lrbind">lrbind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.datSlope(c(3:6))
</code></pre>

<hr>
<h2 id='.extrNAneighb'>Extract NA-neighbour values</h2><span id='topic+.extrNAneighb'></span>

<h3>Description</h3>

<p>This function allows extracting NA-neighbour value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.extrNAneighb(x, grp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".extrNAneighb_+3A_x">x</code></td>
<td>
<p>initial matrix to treat</p>
</td></tr>
<tr><td><code id=".extrNAneighb_+3A_grp">grp</code></td>
<td>
<p>(factor) grouing of replicates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>snumeric vector
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+unique">unique</a></code>, <code><a href="#topic+nonAmbiguousNum">nonAmbiguousNum</a></code>, faster than <code><a href="#topic+firstOfRepeated">firstOfRepeated</a></code> which gives more detail in output (lines/elements/indexes of omitted)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.extrNAneighb(c(11:14,NA), rep(1,5))
</code></pre>

<hr>
<h2 id='.extrNumHeadingCap'>Extract number(s) before capital character</h2><span id='topic+.extrNumHeadingCap'></span>

<h3>Description</h3>

<p>This function aims to extract number(s) before capital character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.extrNumHeadingCap(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".extrNumHeadingCap_+3A_x">x</code></td>
<td>
<p>character vector to be treated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a numeric vector
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grep">grep</a></code>, <code><a href="base.html#topic+nchar">nchar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.extrNumHeadingCap(" 1B ")
</code></pre>

<hr>
<h2 id='.extrNumHeadingSepChar'>Extract numbers before separator followed by alphabetic character</h2><span id='topic+.extrNumHeadingSepChar'></span>

<h3>Description</h3>

<p>This function aims to extract number(s) before separator followed by alphabetic character (return named numeric vector, NAs when no numeric part found)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.extrNumHeadingSepChar(x, sep = "_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".extrNumHeadingSepChar_+3A_x">x</code></td>
<td>
<p>character vector to be treated</p>
</td></tr>
<tr><td><code id=".extrNumHeadingSepChar_+3A_sep">sep</code></td>
<td>
<p>(character) separator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a numeric vector
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+nchar">nchar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.extrNumHeadingSepChar(" 1B ")
</code></pre>

<hr>
<h2 id='.filterNetw'>Filter nodes &amp; edges for extracting networks (main)
This function allows extracting and filtering network-data based on fixed threshold (<code>limInt</code>) and add sandwich-nodes (nodes inter-connecting initial nodes) out of node-based queries.</h2><span id='topic+.filterNetw'></span>

<h3>Description</h3>

<p>Filter nodes &amp; edges for extracting networks (main)
</p>
<p>This function allows extracting and filtering network-data based on fixed threshold (<code>limInt</code>) and add sandwich-nodes (nodes inter-connecting initial nodes) out of node-based queries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.filterNetw(
  lst,
  remOrphans = TRUE,
  reverseCheck = TRUE,
  filtCol = 2,
  callFrom = NULL,
  silent = FALSE,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".filterNetw_+3A_lst">lst</code></td>
<td>
<p>(list, composed of multiple matrix or data.frames ) main input (each list-element should have same number of columns)</p>
</td></tr>
<tr><td><code id=".filterNetw_+3A_remorphans">remOrphans</code></td>
<td>
<p>(logical) remove networks consisting only of 2 connected edges</p>
</td></tr>
<tr><td><code id=".filterNetw_+3A_reversecheck">reverseCheck</code></td>
<td>
<p>(logical)</p>
</td></tr>
<tr><td><code id=".filterNetw_+3A_filtcol">filtCol</code></td>
<td>
<p>(integer, length=1) which column of <code>lst</code> should be usd to filter using thresholds <code>limInt</code> and <code>sandwLim</code></p>
</td></tr>
<tr><td><code id=".filterNetw_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
<tr><td><code id=".filterNetw_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id=".filterNetw_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix or data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterNetw">filterNetw</a></code> and other CRAN package dedeicated to networks
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ab &lt;- 1:10  
</code></pre>

<hr>
<h2 id='.filterSw'>Filter 3-dim array of numeric data (main)</h2><span id='topic+.filterSw'></span>

<h3>Description</h3>

<p>Filtering of matrix or array <code>x</code> (may be 3-dim array) according to <code>fiTy</code> and <code>checkVa</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.filterSw(x, fiTy, checkVa, indexRet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".filterSw_+3A_x">x</code></td>
<td>
<p>array (3-dim) of numeric data</p>
</td></tr>
<tr><td><code id=".filterSw_+3A_fity">fiTy</code></td>
<td>
<p>(character) which type of testing to perform ('eq','inf','infeq','sup','supeq', '&gt;', '&lt;', '&gt;=', '&lt;=', '==')</p>
</td></tr>
<tr><td><code id=".filterSw_+3A_checkva">checkVa</code></td>
<td>
<p>(logical) s</p>
</td></tr>
<tr><td><code id=".filterSw_+3A_indexret">indexRet</code></td>
<td>
<p>(logical) if <code>TRUE</code> (default) rather return index numbers than filtered values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns either index (position within 'x') or concrete (filtered) result
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filt3dimArr">filt3dimArr</a></code>; <code><a href="#topic+filterList">filterList</a></code>; <code><a href="#topic+filterLiColDeList">filterLiColDeList</a></code>;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>arr1 &lt;- array(11:34, dim=c(4,3,2), dimnames=list(c(LETTERS[1:4]),
  paste("col",1:3,sep=""),c("ch1","ch2")))
filt3dimArr(arr1,displCrit=c("col1","col2"),filtCrit="col2",filtVal=7)
.filterSw(arr1, fiTy="inf", checkVa=7)
</code></pre>

<hr>
<h2 id='.filtSize'>Filter for size</h2><span id='topic+.filtSize'></span>

<h3>Description</h3>

<p>This function aims to filter for size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.filtSize(x, minSize = 5, maxSize = 36)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".filtSize_+3A_x">x</code></td>
<td>
<p>main inpuy</p>
</td></tr>
<tr><td><code id=".filtSize_+3A_minsize">minSize</code></td>
<td>
<p>(integer) minimum number of characters, if <code>NULL</code> set to 0</p>
</td></tr>
<tr><td><code id=".filtSize_+3A_maxsize">maxSize</code></td>
<td>
<p>(integer) maximum number of characters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of filtered input
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filtSizeUniq">filtSizeUniq</a></code>; <code><a href="#topic+correctToUnique">correctToUnique</a></code>, <code><a href="base.html#topic+unique">unique</a></code>, <code><a href="base.html#topic+duplicated">duplicated</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aa &lt;- 1:10
</code></pre>

<hr>
<h2 id='.findBorderOverlaps'>Find overlap instances among range of values in lines</h2><span id='topic+.findBorderOverlaps'></span>

<h3>Description</h3>

<p>This function aims to find overlap instances among range of values in lines of 'x' (typically give just min &amp; max)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.findBorderOverlaps(x, rmRedund = FALSE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".findBorderOverlaps_+3A_x">x</code></td>
<td>
<p>(matrix of numeric values or all-numeric data.frame) main input</p>
</td></tr>
<tr><td><code id=".findBorderOverlaps_+3A_rmredund">rmRedund</code></td>
<td>
<p>(logical) report overlaps only in 1st instance (will show up twice otherwise)</p>
</td></tr>
<tr><td><code id=".findBorderOverlaps_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix with line for each overlap found, cols 'refLi' (line no), 'targLi' (line no), 'targCol' (col no)
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+nchar">nchar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aa &lt;- 11:15
</code></pre>

<hr>
<h2 id='.firstMin'>Get first minimum</h2><span id='topic+.firstMin'></span>

<h3>Description</h3>

<p>This function allows to find the first minimum of a numeric vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.firstMin(x, positionOnly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".firstMin_+3A_x">x</code></td>
<td>
<p>(numeric vector) main input</p>
</td></tr>
<tr><td><code id=".firstMin_+3A_positiononly">positionOnly</code></td>
<td>
<p>(logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+which.min">which.min</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.firstMin(c(4,3:6))
</code></pre>

<hr>
<h2 id='.fuse2ArrBy2ndDim'>fuse 2 instances of 3dim arr as mult cols in 3dim array</h2><span id='topic+.fuse2ArrBy2ndDim'></span>

<h3>Description</h3>

<p>This function allows fusing 2 instances of 3dim arr as mult cols in 3dim array (ie fuse along 2nd dim, increase cols)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.fuse2ArrBy2ndDim(arr1, arr2, silent = FALSE, debug = FALSE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fuse2ArrBy2ndDim_+3A_arr1">arr1</code></td>
<td>
<p>(array)</p>
</td></tr>
<tr><td><code id=".fuse2ArrBy2ndDim_+3A_arr2">arr2</code></td>
<td>
<p>(array)</p>
</td></tr>
<tr><td><code id=".fuse2ArrBy2ndDim_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id=".fuse2ArrBy2ndDim_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id=".fuse2ArrBy2ndDim_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This functuin returns a numeric vector with  numer of non-numeric characters (ie not '.' or 0-9))
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+array">array</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aa &lt;- 11:15
</code></pre>

<hr>
<h2 id='.getAmean'>Get A value for each group of replicates</h2><span id='topic+.getAmean'></span>

<h3>Description</h3>

<p>This function calculates the 'A' value (ie group mean) for each group of replicates (eg for MA-plot)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getAmean(dat, grp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getAmean_+3A_dat">dat</code></td>
<td>
<p>(matrix or data.frame) main input</p>
</td></tr>
<tr><td><code id=".getAmean_+3A_grp">grp</code></td>
<td>
<p>(factor) grouping of replicates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a numeric vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeMAList">makeMAList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.getAmean(matrix(11:18, ncol=4), gl(2,2))
</code></pre>

<hr>
<h2 id='.getAmean2'>Get A value for each group of replicates based on comp</h2><span id='topic+.getAmean2'></span>

<h3>Description</h3>

<p>This function calculates the 'A' value (ie group mean) for each group of replicates (eg for MA-plot)
<code>comp</code> is matrix telling which groups to use/compare, assuming that dat are already group-means)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getAmean2(dat, comp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getAmean2_+3A_dat">dat</code></td>
<td>
<p>(matrix or data.frame) main input</p>
</td></tr>
<tr><td><code id=".getAmean2_+3A_comp">comp</code></td>
<td>
<p>(matrix) tells which groups to use/compare, assuming that dat are already group-means)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a numeric vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeMAList">makeMAList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.getAmean(matrix(11:18, ncol=4), gl(2,2))
</code></pre>

<hr>
<h2 id='.getMvalue2'>Get M value for each group of replicates based on comp</h2><span id='topic+.getMvalue2'></span>

<h3>Description</h3>

<p>This function calculates the 'M' value (ie log-ratio) for each group of replicates based on comp (eg for MA-plot)
<code>comp</code> is matrix telling which groups to use/compare, assuming that dat are already group-means)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getMvalue2(dat, comp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getMvalue2_+3A_dat">dat</code></td>
<td>
<p>(matrix or data.frame) main input</p>
</td></tr>
<tr><td><code id=".getMvalue2_+3A_comp">comp</code></td>
<td>
<p>(matrix) tells which groups to use/compare, assuming that dat are already group-means)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a numeric vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeMAList">makeMAList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.getAmean(matrix(11:18, ncol=4), gl(2,2))
</code></pre>

<hr>
<h2 id='.growTree'>Grow tree</h2><span id='topic+.growTree'></span>

<h3>Description</h3>

<p>This function allows growing tree-like structures (data.tree objects)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.growTree(tm, setX, addToObj = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".growTree_+3A_tm">tm</code></td>
<td>
<p>(list) main input, $disDat .. matrix with integer start &amp; end sites for fragments; $lo (logical) which fragments may be grown; $start (integer) index for which line of $disDat to start; $it numeric version of $lo; $preN for previous tree objects towards root; $iter for iterator (starting at 1))</p>
</td></tr>
<tr><td><code id=".growTree_+3A_setx">setX</code></td>
<td>
<p>.. data.tree object (main obj from root)</p>
</td></tr>
<tr><td><code id=".growTree_+3A_addtoobj">addToObj</code></td>
<td>
<p>.. data.tree object (branch on which to add new branches/nodes)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildTree">buildTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.datSlope(c(3:6))
</code></pre>

<hr>
<h2 id='.insp1dimByClustering'>Segment (1-dim vector) 'dat' into clusters</h2><span id='topic+.insp1dimByClustering'></span>

<h3>Description</h3>

<p>This function allows aegmenting (1-dim vector) 'dat' into clusters.
If 'automClu=TRUE ..' first try automatic clustering, if too few clusters, run km with length(dat)^0.3 clusters
This function requires the package NbClust to be installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.insp1dimByClustering(
  dat,
  automClu = TRUE,
  cluChar = TRUE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".insp1dimByClustering_+3A_dat">dat</code></td>
<td>
<p>matrix or data.frame, main input</p>
</td></tr>
<tr><td><code id=".insp1dimByClustering_+3A_automclu">automClu</code></td>
<td>
<p>(logical) run atomatic clustering</p>
</td></tr>
<tr><td><code id=".insp1dimByClustering_+3A_cluchar">cluChar</code></td>
<td>
<p>(logical) to display cluster characteristics</p>
</td></tr>
<tr><td><code id=".insp1dimByClustering_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id=".insp1dimByClustering_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id=".insp1dimByClustering_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns clustering (class index) or (if 'cluChar'=TRUE) list with clustering and cluster-characteristics
</p>


<h3>See Also</h3>

<p><code><a href="#topic+searchLinesAtGivenSlope">searchLinesAtGivenSlope</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016); dat1 &lt;- matrix(c(runif(200)+rep(1:10,20)),ncol=10)
</code></pre>

<hr>
<h2 id='.inspectHeader'>Inspect 'matr' and check if 1st line can be used/converted as header</h2><span id='topic+.inspectHeader'></span>

<h3>Description</h3>

<p>This function inspects 'matr' and check if 1st line can be used/converted as header.
If colnames of 'matr' are either NULL or 'V1',etc the 1st row will be tested if it contains any of the elements (if not, 1st line won't be used as new colnames)
If 'numericCheck'=TRUE, all columns will be tested if they can be converted to numeric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.inspectHeader(
  matr,
  headNames = c("Plate", "Well", "StainA"),
  numericCheck = TRUE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".inspectHeader_+3A_matr">matr</code></td>
<td>
<p>(matrix or data.frame) main input to be instected</p>
</td></tr>
<tr><td><code id=".inspectHeader_+3A_headnames">headNames</code></td>
<td>
<p>(character) column-names t look for</p>
</td></tr>
<tr><td><code id=".inspectHeader_+3A_numericcheck">numericCheck</code></td>
<td>
<p>(logical) allows reducing complexity by drawing for very long x or y</p>
</td></tr>
<tr><td><code id=".inspectHeader_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id=".inspectHeader_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id=".inspectHeader_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix vector or data.frame similar to input
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+head">head</a></code> for looking at first few lines
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ma1 &lt;- matrix(letters[1:6], ncol=3, dimnames=list(NULL,c("ab","Plate","Well")))
.inspectHeader(ma1) 

</code></pre>

<hr>
<h2 id='.keepCenter1d'>Refine/filter 'dat1' (1dim dataset, eg cluster) with aim of keeping center of data</h2><span id='topic+.keepCenter1d'></span>

<h3>Description</h3>

<p>This function allows to refine/filter 'dat1' (1dim dataset, eg cluster) with aim of keeping center of data.
It is done based on most freq class of histogramm keep/filter data if 'core' (
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.keepCenter1d(
  dat1,
  core = NULL,
  keepOnly = TRUE,
  displPlot = FALSE,
  silent = TRUE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".keepCenter1d_+3A_dat1">dat1</code></td>
<td>
<p>simple numeric vector</p>
</td></tr>
<tr><td><code id=".keepCenter1d_+3A_core">core</code></td>
<td>
<p>numeric vactor (betw 0 and 1) for fraction of data to keep; if null trimmedMean/max hist occurance will be used, limited within 30-70 perent; may also be 'high' or 'low' for forcing low (20-60percent) or high (75-99) percent of data to retain</p>
</td></tr>
<tr><td><code id=".keepCenter1d_+3A_keeponly">keepOnly</code></td>
<td>
<p>(logical)</p>
</td></tr>
<tr><td><code id=".keepCenter1d_+3A_displplot">displPlot</code></td>
<td>
<p>(logical) show plot of hist &amp; boundaries</p>
</td></tr>
<tr><td><code id=".keepCenter1d_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id=".keepCenter1d_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id=".keepCenter1d_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the index of values retained or if 'keepOnly' return list with 'keep' index and 'drop' index
</p>


<h3>See Also</h3>

<p><code><a href="#topic+searchLinesAtGivenSlope">searchLinesAtGivenSlope</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016); dat1 &lt;- matrix(c(runif(200)+rep(1:10,20)),ncol=10)
</code></pre>

<hr>
<h2 id='.keepFiniteCol'>Remove all columns where all data are not finite</h2><span id='topic+.keepFiniteCol'></span>

<h3>Description</h3>

<p>This function aims to remove all columns where all data are not finite
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.keepFiniteCol(
  dat,
  msgStart = NULL,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".keepFiniteCol_+3A_dat">dat</code></td>
<td>
<p>(matrix or data.frame) main input</p>
</td></tr>
<tr><td><code id=".keepFiniteCol_+3A_msgstart">msgStart</code></td>
<td>
<p>(character)</p>
</td></tr>
<tr><td><code id=".keepFiniteCol_+3A_silent">silent</code></td>
<td>
<p>(logical) suppres messages</p>
</td></tr>
<tr><td><code id=".keepFiniteCol_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id=".keepFiniteCol_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a corrected matrix or data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+renameColumns">renameColumns</a></code>; <code><a href="base.html#topic+is.finite">is.finite</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ma1 &lt;- matrix(c(1:5, Inf), ncol=2)
.keepFiniteCol(ma1)

</code></pre>

<hr>
<h2 id='.mayBeNum'>Check if vector may be numeric content</h2><span id='topic+.mayBeNum'></span>

<h3>Description</h3>

<p>This function allows to checking if a given vector may be numeric content
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.mayBeNum(x, pattern = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".mayBeNum_+3A_x">x</code></td>
<td>
<p>(numeric vector) main input</p>
</td></tr>
<tr><td><code id=".mayBeNum_+3A_pattern">pattern</code></td>
<td>
<p>(character)  custom pattern to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This functions returns a logical/boolean vector for each of the elements of 'x'
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+numeric">numeric</a></code>; <code><a href="#topic+convMatr2df">convMatr2df</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.mayBeNum(c(3:6))
</code></pre>

<hr>
<h2 id='.medianSpecGrp'>Rescale respective to specific group</h2><span id='topic+.medianSpecGrp'></span>

<h3>Description</h3>

<p>This function allows to rescale data 'x' so that specific group 'grpNum' gets normalized to predefined value 'grpVal'.
In normal case x will be multiplied by 'grpVal' and devided by value obtained from 'grpNum'.
If summary of 'grpNum-positions' or 'grpVal' is 0, then grpVal will be attained by subtraction of summary &amp; adding grpVal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.medianSpecGrp(x, grpNum, grpVal, sumMeth = "median", callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".medianSpecGrp_+3A_x">x</code></td>
<td>
<p>(numeric vector) main input</p>
</td></tr>
<tr><td><code id=".medianSpecGrp_+3A_grpnum">grpNum</code></td>
<td>
<p>(numeric)</p>
</td></tr>
<tr><td><code id=".medianSpecGrp_+3A_grpval">grpVal</code></td>
<td>
<p>(numeric)</p>
</td></tr>
<tr><td><code id=".medianSpecGrp_+3A_summeth">sumMeth</code></td>
<td>
<p>(character) method for summarizing</p>
</td></tr>
<tr><td><code id=".medianSpecGrp_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+which.min">which.min</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.firstMin(c(4,3:6))
</code></pre>

<hr>
<h2 id='.mergeMatrices'>Merge Multiple Matrices (main)</h2><span id='topic+.mergeMatrices'></span>

<h3>Description</h3>

<p>This function allows merging of multiple matrix-like objects from an initial list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.mergeMatrices(
  inpL,
  mode = "intersect",
  useColumn = 1,
  extrRowNames = FALSE,
  na.rm = TRUE,
  argL = NULL,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".mergeMatrices_+3A_inpl">inpL</code></td>
<td>
<p>(list containing matrices or data.frames) main input (multiple matrix or data.frame objects)</p>
</td></tr>
<tr><td><code id=".mergeMatrices_+3A_mode">mode</code></td>
<td>
<p>(character) allows choosing restricting to all common elements (<code>mode='intersect'</code>) or union  (<code>mode='union'</code>)</p>
</td></tr>
<tr><td><code id=".mergeMatrices_+3A_usecolumn">useColumn</code></td>
<td>
<p>(integer, character or list) the column(s) to consider, may be <code>'all'</code> to use all, integer to select specific indexes or list of indexes or colnames for cutom-selection per matrix</p>
</td></tr>
<tr><td><code id=".mergeMatrices_+3A_extrrownames">extrRowNames</code></td>
<td>
<p>(logical) decide whether columns with all values different (ie no replicates or max divergency) should be excluded</p>
</td></tr>
<tr><td><code id=".mergeMatrices_+3A_na.rm">na.rm</code></td>
<td>
<p>(logical) suppress <code>NA</code>s</p>
</td></tr>
<tr><td><code id=".mergeMatrices_+3A_argl">argL</code></td>
<td>
<p>(list of arguments)</p>
</td></tr>
<tr><td><code id=".mergeMatrices_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id=".mergeMatrices_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id=".mergeMatrices_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix containing all selected columns of the input matrices to fuse
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mergeMatrixList">mergeMatrixList</a></code>,  <code><a href="base.html#topic+merge">merge</a></code>,  <code><a href="#topic+mergeMatrices">mergeMatrices</a></code> for separate entries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat1 &lt;- matrix(11:18, ncol=2, dimnames=list(letters[3:6],LETTERS[1:2]))
</code></pre>

<hr>
<h2 id='.minDif'>find closest neighbour to numeric vector</h2><span id='topic+.minDif'></span>

<h3>Description</h3>

<p>This function aims to find closest neighbour to numeric vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.minDif(z, initOrder = TRUE, rat = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".minDif_+3A_z">z</code></td>
<td>
<p>(numeric) vector to search minimum difference</p>
</td></tr>
<tr><td><code id=".minDif_+3A_initorder">initOrder</code></td>
<td>
<p>(logical) return matrix so that 'x' matches exactely 2nd col of output</p>
</td></tr>
<tr><td><code id=".minDif_+3A_rat">rat</code></td>
<td>
<p>(logical) express result as ratio</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix with index,value,dif,best
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.minDif(c(11:15,17))
</code></pre>

<hr>
<h2 id='.neigbDis'>Distances beteenw sorted points of 2-columns</h2><span id='topic+.neigbDis'></span>

<h3>Description</h3>

<p>This function returns distances beteenw sorted points of 2-column matrix 'x'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.neigbDis(x, asSum = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".neigbDis_+3A_x">x</code></td>
<td>
<p>(matrix or data.frame, min 2 columns) main input</p>
</td></tr>
<tr><td><code id=".neigbDis_+3A_assum">asSum</code></td>
<td>
<p>(logical) if <code>TRUE</code> (default) the sum of all distances will be returned, otherwise the individual distances</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a numeric vector with distances
</p>


<h3>Examples</h3>

<pre><code class='language-R'>daPa &lt;- matrix(c(1:5,8,2:6,9), ncol=2)
.neigbDis(daPa)
</code></pre>

<hr>
<h2 id='.normalize'>Main Normalization function</h2><span id='topic+.normalize'></span>

<h3>Description</h3>

<p>This function aims to normalize a matrix or data.frame by columns. 
It assumes all checks have been done before calling this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.normalize(
  dat,
  meth,
  mode,
  param,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".normalize_+3A_dat">dat</code></td>
<td>
<p>matrix or data.frame of data to get normalized</p>
</td></tr>
<tr><td><code id=".normalize_+3A_meth">meth</code></td>
<td>
<p>(character) may be &quot;mean&quot;,&quot;median&quot;,&quot;NULL&quot;,&quot;none&quot;, &quot;trimMean&quot;, &quot;rowNormalize&quot;, &quot;slope&quot;, &quot;exponent&quot;, &quot;slope2Sections&quot;, &quot;vsn&quot;; When <code>NULL</code> or 'none' is chosen the input will be returned</p>
</td></tr>
<tr><td><code id=".normalize_+3A_mode">mode</code></td>
<td>
<p>(character) may be &quot;proportional&quot;, &quot;additive&quot;;
decide if normalizatio factors will be applies as multiplicative (proportional) or additive; for log2-omics data <code>mode="aditive"</code> is suggested</p>
</td></tr>
<tr><td><code id=".normalize_+3A_param">param</code></td>
<td>
<p>(list) additional parameters</p>
</td></tr>
<tr><td><code id=".normalize_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id=".normalize_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id=".normalize_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a numeric vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normalizeThis">normalizeThis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aa &lt;- matrix(1:12, ncol=3)
.normalize(aa,"median",mode="proportional",param=NULL)
</code></pre>

<hr>
<h2 id='.normConstSlope'>Normalize columns of 2dim matrix to common linear regression fit</h2><span id='topic+.normConstSlope'></span>

<h3>Description</h3>

<p>This function aims to normalize columns of 2dim matrix to common linear regression fit within range of 'useQuant'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.normConstSlope(
  mat,
  useQuant = c(0.2, 0.8),
  refLines = NULL,
  diagPlot = TRUE,
  plotLog = "",
  datName = NULL,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".normConstSlope_+3A_mat">mat</code></td>
<td>
<p>matrix or data.frame of data to get normalized</p>
</td></tr>
<tr><td><code id=".normConstSlope_+3A_usequant">useQuant</code></td>
<td>
<p>(numeric) quantiles to use</p>
</td></tr>
<tr><td><code id=".normConstSlope_+3A_reflines">refLines</code></td>
<td>
<p>(NULL or numeric) allows to consider only specific lines of 'dat' when determining normalization factors (all data will be normalized)</p>
</td></tr>
<tr><td><code id=".normConstSlope_+3A_diagplot">diagPlot</code></td>
<td>
<p>(logical) draw diagnistic plot</p>
</td></tr>
<tr><td><code id=".normConstSlope_+3A_plotlog">plotLog</code></td>
<td>
<p>(character) indicate which axis shousl be diplayed on log-scale, may be 'x', 'xy' or 'y'</p>
</td></tr>
<tr><td><code id=".normConstSlope_+3A_datname">datName</code></td>
<td>
<p>(character) use as title in diag plot</p>
</td></tr>
<tr><td><code id=".normConstSlope_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id=".normConstSlope_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id=".normConstSlope_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a numeric vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normalizeThis">normalizeThis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aa &lt;- matrix(1:12, ncol=3)
</code></pre>

<hr>
<h2 id='.offCenter'>Return position of 'di' (numeric vector) which is most excentric (distant to 0), starts with NAs as most excentric</h2><span id='topic+.offCenter'></span>

<h3>Description</h3>

<p>This function aims to return position of 'di' (numeric vector) which is most excentric (distant to 0), starts with NAs as most excentric
It is used for identifying/removing (potential) outliers. 
Note : this fx doesn't consider reference distrubutions, even with &quot;perfect data&quot; 'nMost' points will ba tagged !
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.offCenter(di, nMost = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".offCenter_+3A_di">di</code></td>
<td>
<p>(numeric) main input</p>
</td></tr>
<tr><td><code id=".offCenter_+3A_nmost">nMost</code></td>
<td>
<p>(integer)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a integer/numeric vector (indicating index)
</p>


<h3>See Also</h3>

<p>use in <code><a href="#topic+presenceFilt">presenceFilt</a></code>;  <code><a href="base.html#topic+diff">diff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.offCenter(11:14)
</code></pre>

<hr>
<h2 id='.pasteCols'>Paste-concatenate all columns of matrix</h2><span id='topic+.pasteCols'></span>

<h3>Description</h3>

<p>This function allows paste columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.pasteCols(mat, sep = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".pasteCols_+3A_mat">mat</code></td>
<td>
<p>inital matrix</p>
</td></tr>
<tr><td><code id=".pasteCols_+3A_sep">sep</code></td>
<td>
<p>(character) separator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>simplified/non-redundant vector/matrix (ie fewer lines for matrix), or respective index
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+unique">unique</a></code>, <code><a href="#topic+nonAmbiguousNum">nonAmbiguousNum</a></code>, faster than <code><a href="#topic+firstOfRepeated">firstOfRepeated</a></code> which gives more detail in output (lines/elements/indexes of omitted)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.pasteCols(matrix(11:16,ncol=2), sep="_")
</code></pre>

<hr>
<h2 id='.plotCountPie'>Pie plot for counting results</h2><span id='topic+.plotCountPie'></span>

<h3>Description</h3>

<p>This function allows to inspect results of <code>table</code> or <code>uniqCountReport</code> on a pie-plot
Note : fairly slow for long vectors !!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.plotCountPie(
  count,
  tit = NULL,
  col = NULL,
  radius = 0.9,
  sizeTo = NULL,
  clockwise = FALSE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".plotCountPie_+3A_count">count</code></td>
<td>
<p>(integer vector) counting result</p>
</td></tr>
<tr><td><code id=".plotCountPie_+3A_tit">tit</code></td>
<td>
<p>(character) optional title in plot</p>
</td></tr>
<tr><td><code id=".plotCountPie_+3A_col">col</code></td>
<td>
<p>(character) custom colors in pie</p>
</td></tr>
<tr><td><code id=".plotCountPie_+3A_radius">radius</code></td>
<td>
<p>(numeric) radius passed to  <code>pie</code></p>
</td></tr>
<tr><td><code id=".plotCountPie_+3A_sizeto">sizeTo</code></td>
<td>
<p>(numeric or charcter) optional reference group for size-population relative adjusting overall surface of pie</p>
</td></tr>
<tr><td><code id=".plotCountPie_+3A_clockwise">clockwise</code></td>
<td>
<p>(logical) argument passed to pie</p>
</td></tr>
<tr><td><code id=".plotCountPie_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id=".plotCountPie_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id=".plotCountPie_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with counts of n (total), nUnique (wo any repeated), nHasRepeated (first of repeated), nRedundant), optional figure
</p>


<h3>See Also</h3>

<p><code><a href="#topic+uniqCountReport">uniqCountReport</a></code>, <code><a href="#topic+correctToUnique">correctToUnique</a></code>, <code><a href="base.html#topic+unique">unique</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.plotCountPie(table(c(1:5,4:2)))
</code></pre>

<hr>
<h2 id='.plusLowerCaps'>Add lower caps to character vector</h2><span id='topic+.plusLowerCaps'></span>

<h3>Description</h3>

<p>This function allows adding all content as lower caps to/of character vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.plusLowerCaps(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".plusLowerCaps_+3A_x">x</code></td>
<td>
<p>(character) main input</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a elongated character vector
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+chartr">chartr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.plusLowerCaps(c("Abc","BCD"))
</code></pre>

<hr>
<h2 id='.predRes'>Calculate residues of (2-dim) linear model 'lMod'-prediction of/for 'dat'</h2><span id='topic+.predRes'></span>

<h3>Description</h3>

<p>This function calculates residues of (2-dim) linear model 'lMod'-prediction of/for 'dat' (using 2nd col of 'useCol' )
(indexing in 'dat', matrix or data.frame with min 2 cols), using 1st col of 'useCol' as 'x'.
It may be used for comparing/identifying data close to regression  (eg re-finding data on autoregression line in FT-ICR)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.predRes(dat, lMod, regTy = "lin", useCol = 1:2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".predRes_+3A_dat">dat</code></td>
<td>
<p>matrix or data.frame, main input</p>
</td></tr>
<tr><td><code id=".predRes_+3A_lmod">lMod</code></td>
<td>
<p>linear model, only used to extract coefficients offset &amp; slope</p>
</td></tr>
<tr><td><code id=".predRes_+3A_regty">regTy</code></td>
<td>
<p>(character) type of regression model</p>
</td></tr>
<tr><td><code id=".predRes_+3A_usecol">useCol</code></td>
<td>
<p>(integer) columns to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a numeric vector of residues (for each line of dat)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+searchLinesAtGivenSlope">searchLinesAtGivenSlope</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016); dat1 &lt;- matrix(c(runif(200)+rep(1:10,20)),ncol=10)
</code></pre>

<hr>
<h2 id='.raiseColLowest'>Raise all values close to lowest value</h2><span id='topic+.raiseColLowest'></span>

<h3>Description</h3>

<p>This function aims to raise all values close to lowest value to end up as at value of 'raiseTo'.
This is done independently for each col of mat.
This function sets all data to common raiseTo (which is min among all cols)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.raiseColLowest(
  mat,
  raiseTo = NULL,
  minFa = 0.1,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".raiseColLowest_+3A_mat">mat</code></td>
<td>
<p>(matrix of numeric values) main input</p>
</td></tr>
<tr><td><code id=".raiseColLowest_+3A_raiseto">raiseTo</code></td>
<td>
<p>(numeric)</p>
</td></tr>
<tr><td><code id=".raiseColLowest_+3A_minfa">minFa</code></td>
<td>
<p>(numeric) minimum factor</p>
</td></tr>
<tr><td><code id=".raiseColLowest_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id=".raiseColLowest_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id=".raiseColLowest_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a numeric vector with  numer of non-numeric characters (ie not '.' or 0-9))
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+nchar">nchar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aa &lt;- 11:15
</code></pre>

<hr>
<h2 id='.removeCol'>Remove columns indicated by col-number</h2><span id='topic+.removeCol'></span>

<h3>Description</h3>

<p>This function aims to remove columns indicated by col-number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.removeCol(matr, rmCol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".removeCol_+3A_matr">matr</code></td>
<td>
<p>(matrix or data.frame) main input</p>
</td></tr>
<tr><td><code id=".removeCol_+3A_rmcol">rmCol</code></td>
<td>
<p>(integer) column index for removing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an matrix or data.frame
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aa &lt;- matrix(1:6, ncol=3)
.removeCol(aa, 2)
</code></pre>

<hr>
<h2 id='.removeEmptyCol'>Search for (empty) columns conaining only entries defined in 'searchFields' and remove such columns</h2><span id='topic+.removeEmptyCol'></span>

<h3>Description</h3>

<p>This function aims to search for (empty) columns conaining only entries defined in 'searchFields' and remove such columns.
If 'fromBackOnly' =TRUE .. only tailing empty columns will be removed (other columns with &quot;empty&quot; entries in middle will be kept).
If &rdquo;=TRUE columns containing all NAs will be excluded as well 
This function will also remove columns containing (exculsively) mixtures of the various 'searchFields'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.removeEmptyCol(
  dat,
  fromBackOnly = TRUE,
  searchFields = c("", " ", "NA.", NA),
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".removeEmptyCol_+3A_dat">dat</code></td>
<td>
<p>(matrix or data.frame) main input</p>
</td></tr>
<tr><td><code id=".removeEmptyCol_+3A_frombackonly">fromBackOnly</code></td>
<td>
<p>(logical)</p>
</td></tr>
<tr><td><code id=".removeEmptyCol_+3A_searchfields">searchFields</code></td>
<td>
<p>(character)</p>
</td></tr>
<tr><td><code id=".removeEmptyCol_+3A_silent">silent</code></td>
<td>
<p>(logical) suppres messages</p>
</td></tr>
<tr><td><code id=".removeEmptyCol_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id=".removeEmptyCol_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a corrected matrix or data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+renameColumns">renameColumns</a></code>;  <code><a href="base.html#topic+is.finite">is.finite</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ma1 &lt;- matrix(c(1:5, NA), ncol=2)
.removeEmptyCol(ma1)
</code></pre>

<hr>
<h2 id='.replSpecChar'>Replace Special Characters</h2><span id='topic+.replSpecChar'></span>

<h3>Description</h3>

<p>This function allows replacing special characters
Note that (most) special characters must be presented with protection for <code>grep</code> and <code>sub</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.replSpecChar(x, findSp = c("\\(", "\\)", "\\$"), replBy = "_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".replSpecChar_+3A_x">x</code></td>
<td>
<p>(character) main input</p>
</td></tr>
<tr><td><code id=".replSpecChar_+3A_findsp">findSp</code></td>
<td>
<p>(character) special characters to replace (may have to be given as protected)</p>
</td></tr>
<tr><td><code id=".replSpecChar_+3A_replby">replBy</code></td>
<td>
<p>(character) replace by</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a corrceted/adjusted factor
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+factor">factor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.replSpecChar(c("jhjh(ab)","abc"))
</code></pre>

<hr>
<h2 id='.retain1stPart'>Trim character string: keep only text before 'sep'</h2><span id='topic+.retain1stPart'></span>

<h3>Description</h3>

<p>Trim character string: keep only text before 'sep' (length=1 !)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.retain1stPart(chr, sep = " = ", offSet = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".retain1stPart_+3A_chr">chr</code></td>
<td>
<p>character vector to be treated</p>
</td></tr>
<tr><td><code id=".retain1stPart_+3A_sep">sep</code></td>
<td>
<p>(character) saparator</p>
</td></tr>
<tr><td><code id=".retain1stPart_+3A_offset">offSet</code></td>
<td>
<p>(integer) off-set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a modified character vector
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+substr">substr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.retain1stPart("abc = def")
</code></pre>

<hr>
<h2 id='.rowGrpCV'>row group CV (main)</h2><span id='topic+.rowGrpCV'></span>

<h3>Description</h3>

<p>This function calculates CVs for matrix with multiple groups of data, ie one CV for each group of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rowGrpCV(x, grp, means)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".rowGrpCV_+3A_x">x</code></td>
<td>
<p>numeric matrix where relplicates are organized into separate columns</p>
</td></tr>
<tr><td><code id=".rowGrpCV_+3A_grp">grp</code></td>
<td>
<p>(factor) defining which columns should be grouped (considered as replicates)</p>
</td></tr>
<tr><td><code id=".rowGrpCV_+3A_means">means</code></td>
<td>
<p>(numeric) alternative values instead of means by .rowGrpMeans()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix of CV values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowGrpCV">rowGrpCV</a></code>, <code><a href="#topic+rowCVs">rowCVs</a></code>, <code><a href="#topic+arrayCV">arrayCV</a></code>, <code><a href="#topic+replPlateCV">replPlateCV</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016); dat1 &lt;- matrix(c(runif(200)+rep(1:10,20)),ncol=10)
grp1 &lt;- gl(4,3,labels=LETTERS[1:4])[2:11]
head(.rowGrpCV(dat1, grp1,  .rowGrpMeans(dat1, grp1)))
</code></pre>

<hr>
<h2 id='.rowGrpMeans'>row group mean (main)</h2><span id='topic+.rowGrpMeans'></span>

<h3>Description</h3>

<p>This function calculates CVs for matrix with multiple groups of data, ie one CV for each group of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rowGrpMeans(x, grp, na.replVa = NULL, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".rowGrpMeans_+3A_x">x</code></td>
<td>
<p>numeric matrix where relplicates are organized into separate columns</p>
</td></tr>
<tr><td><code id=".rowGrpMeans_+3A_grp">grp</code></td>
<td>
<p>(factor) defining which columns should be grouped (considered as replicates)</p>
</td></tr>
<tr><td><code id=".rowGrpMeans_+3A_na.replva">na.replVa</code></td>
<td>
<p>(numeric) value to replace <code>NA</code> values</p>
</td></tr>
<tr><td><code id=".rowGrpMeans_+3A_na.rm">na.rm</code></td>
<td>
<p>(logical) remove all <code>NA</code> values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix of mean values per row and group of replicates
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowGrpCV">rowGrpCV</a></code>, <code><a href="#topic+rowCVs">rowCVs</a></code>, <code><a href="#topic+arrayCV">arrayCV</a></code>, <code><a href="#topic+replPlateCV">replPlateCV</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016); dat1 &lt;- matrix(c(runif(200)+rep(1:10,20)),ncol=10)
grp1 &lt;- gl(4,3,labels=LETTERS[1:4])[2:11]
head(.rowGrpMeans(dat1, grp1))
</code></pre>

<hr>
<h2 id='.rowGrpSds'>row group sd (main)</h2><span id='topic+.rowGrpSds'></span>

<h3>Description</h3>

<p>This function calculates sd for matrix with multiple groups of data, ie one sd for each group of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rowGrpSds(x, grp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".rowGrpSds_+3A_x">x</code></td>
<td>
<p>numeric matrix where relplicates are organized into separate columns</p>
</td></tr>
<tr><td><code id=".rowGrpSds_+3A_grp">grp</code></td>
<td>
<p>(factor) defining which columns should be grouped (considered as replicates)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix of sd values per row and group of replicates
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowGrpCV">rowGrpCV</a></code>, <code><a href="#topic+rowCVs">rowCVs</a></code>, <code><a href="#topic+arrayCV">arrayCV</a></code>, <code><a href="#topic+replPlateCV">replPlateCV</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016); dat1 &lt;- matrix(c(runif(200)+rep(1:10,20)),ncol=10)
grp1 &lt;- gl(4,3,labels=LETTERS[1:4])[2:11]
head(.rowGrpSds(dat1, grp1))
</code></pre>

<hr>
<h2 id='.rowGrpSums'>row group rowSums per group (main)</h2><span id='topic+.rowGrpSums'></span>

<h3>Description</h3>

<p>This function calculates row-sums for matrix with multiple groups of data, with multiple groups of data, ie one sd for each group of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rowGrpSums(x, grp, na.replVa = NULL, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".rowGrpSums_+3A_x">x</code></td>
<td>
<p>numeric matrix where relplicates are organized into separate columns</p>
</td></tr>
<tr><td><code id=".rowGrpSums_+3A_grp">grp</code></td>
<td>
<p>(factor) defining which columns should be grouped (considered as replicates)</p>
</td></tr>
<tr><td><code id=".rowGrpSums_+3A_na.replva">na.replVa</code></td>
<td>
<p>(numeric) value to replace <code>NA</code> values</p>
</td></tr>
<tr><td><code id=".rowGrpSums_+3A_na.rm">na.rm</code></td>
<td>
<p>(logical) remove all <code>NA</code> values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix of row-sums for matrix with multiple groups of data
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowGrpCV">rowGrpCV</a></code>, <code><a href="#topic+rowCVs">rowCVs</a></code>, <code><a href="#topic+arrayCV">arrayCV</a></code>, <code><a href="#topic+replPlateCV">replPlateCV</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016); dat1 &lt;- matrix(c(runif(200)+rep(1:10,20)),ncol=10)
grp1 &lt;- gl(4,3,labels=LETTERS[1:4])[2:11]
head(.rowGrpSums(dat1, grp1)) 
</code></pre>

<hr>
<h2 id='.rowNorm'>Row-normalization procedure on matrix or data.frame 'dat'</h2><span id='topic+.rowNorm'></span>

<h3>Description</h3>

<p>This function was performs a row-normalization procedure on matrix or data.frame 'dat'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rowNorm(
  dat,
  refLi,
  method,
  proportMode,
  maxFact = 10,
  fact0val = 10,
  retFact = FALSE,
  callFrom = NULL,
  debug = FALSE,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".rowNorm_+3A_dat">dat</code></td>
<td>
<p>(matrix) .. init data, smay be parse matrix with numerous NA</p>
</td></tr>
<tr><td><code id=".rowNorm_+3A_refli">refLi</code></td>
<td>
<p>(NULL or numeric) allows to consider only specific lines of 'dat' when determining normalization factors (all data will be normalized)</p>
</td></tr>
<tr><td><code id=".rowNorm_+3A_method">method</code></td>
<td>
<p>(character) may be &quot;mean&quot;,&quot;median&quot; (plus &quot;NULL&quot;,&quot;none&quot;); When NULL or 'none' is chosen the input will be returned as is</p>
</td></tr>
<tr><td><code id=".rowNorm_+3A_proportmode">proportMode</code></td>
<td>
<p>(logical) decide if normalization should be done by multiplicative or additive factor</p>
</td></tr>
<tr><td><code id=".rowNorm_+3A_maxfact">maxFact</code></td>
<td>
<p>(numeric, length=2) max normalization factor</p>
</td></tr>
<tr><td><code id=".rowNorm_+3A_fact0val">fact0val</code></td>
<td>
<p>(integer)</p>
</td></tr>
<tr><td><code id=".rowNorm_+3A_retfact">retFact</code></td>
<td>
<p>(logical)</p>
</td></tr>
<tr><td><code id=".rowNorm_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) This function allows easier tracking of messages produced</p>
</td></tr>
<tr><td><code id=".rowNorm_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id=".rowNorm_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix of normalized data same dimensions as 'dat'
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowNormalize">rowNormalize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.rowNorm(matrix(11:31, ncol=3), refLi=1, method="mean", proportMode=TRUE)
</code></pre>

<hr>
<h2 id='.rowNormFact'>Obtain normalization factor (main)</h2><span id='topic+.rowNormFact'></span>

<h3>Description</h3>

<p>This function was designed to obtain normalization factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rowNormFact(
  dat,
  combOfN,
  comUse,
  method = "median",
  refLi = NULL,
  refGrp = NULL,
  proportMode = TRUE,
  minQuant = NULL,
  maxFact = 10,
  omitNonAlignable = FALSE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".rowNormFact_+3A_dat">dat</code></td>
<td>
<p>(matrix) .. init data, smay be parse matrix with numerous NA</p>
</td></tr>
<tr><td><code id=".rowNormFact_+3A_combofn">combOfN</code></td>
<td>
<p>(matrix) ..  # matrix of index for all sub-groups (assumed as sorted)</p>
</td></tr>
<tr><td><code id=".rowNormFact_+3A_comuse">comUse</code></td>
<td>
<p>(list) .. index of complete lines for each col of combOfN</p>
</td></tr>
<tr><td><code id=".rowNormFact_+3A_method">method</code></td>
<td>
<p>(character) may be &quot;mean&quot;,&quot;median&quot; (plus &quot;NULL&quot;,&quot;none&quot;); When NULL or 'none' is chosen the input will be returned as is</p>
</td></tr>
<tr><td><code id=".rowNormFact_+3A_refli">refLi</code></td>
<td>
<p>(NULL or numeric) allows to consider only specific lines of 'dat' when determining normalization factors (all data will be normalized)</p>
</td></tr>
<tr><td><code id=".rowNormFact_+3A_refgrp">refGrp</code></td>
<td>
<p>(integer) Only the columns indicated will be used as reference, default all columns (integer or colnames)</p>
</td></tr>
<tr><td><code id=".rowNormFact_+3A_proportmode">proportMode</code></td>
<td>
<p>(logical) decide if normalization should be done by multiplicative or additive factor</p>
</td></tr>
<tr><td><code id=".rowNormFact_+3A_minquant">minQuant</code></td>
<td>
<p>(numeric) optional filter to set all values below given value as <code>NA</code></p>
</td></tr>
<tr><td><code id=".rowNormFact_+3A_maxfact">maxFact</code></td>
<td>
<p>(numeric, length=2) max normalization factor</p>
</td></tr>
<tr><td><code id=".rowNormFact_+3A_omitnonalignable">omitNonAlignable</code></td>
<td>
<p>(logical) allow omitting all columns which can't get aligned due to sparseness</p>
</td></tr>
<tr><td><code id=".rowNormFact_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id=".rowNormFact_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id=".rowNormFact_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) This function allows easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix of column-indexes complementing (nCombin rows)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowNormalize">rowNormalize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ma1 &lt;- matrix(11:41, ncol=3)
</code></pre>

<hr>
<h2 id='.scale01'>Scale between 0 and 1 (main)</h2><span id='topic+.scale01'></span>

<h3>Description</h3>

<p>This function rescales between 0 and 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.scale01(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".scale01_+3A_x">x</code></td>
<td>
<p>numeric vector to be re-scalded</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a numeric vector of same length with re-scaled values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scaleXY">scaleXY</a></code> , <code><a href="base.html#topic+scale">scale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.scale01(11:15)
</code></pre>

<hr>
<h2 id='.scaleSpecGrp'>Rescale respective to specific group</h2><span id='topic+.scaleSpecGrp'></span>

<h3>Description</h3>

<p>This function allows to rescale data 'x' so that 2 specific groups get normalized to predefined values (and all other values follow proportionally)
'grp1Num' and 'grp2Num' should be either numeric for positions in 'x' or character for names of 'x';
if 'grp1Num' and/or 'grp2Num' design mulitple locations: perform median or mean summarization, according to 'sumMeth'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.scaleSpecGrp(
  x,
  grp1Num,
  grp1Val,
  grp2Num = NULL,
  grp2Val = NULL,
  sumMeth = "mean",
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".scaleSpecGrp_+3A_x">x</code></td>
<td>
<p>(numeric vector) main input</p>
</td></tr>
<tr><td><code id=".scaleSpecGrp_+3A_grp1num">grp1Num</code></td>
<td>
<p>(numeric)</p>
</td></tr>
<tr><td><code id=".scaleSpecGrp_+3A_grp1val">grp1Val</code></td>
<td>
<p>(numeric)</p>
</td></tr>
<tr><td><code id=".scaleSpecGrp_+3A_grp2num">grp2Num</code></td>
<td>
<p>(numeric)</p>
</td></tr>
<tr><td><code id=".scaleSpecGrp_+3A_grp2val">grp2Val</code></td>
<td>
<p>(numeric)</p>
</td></tr>
<tr><td><code id=".scaleSpecGrp_+3A_summeth">sumMeth</code></td>
<td>
<p>(character) method for summarizing</p>
</td></tr>
<tr><td><code id=".scaleSpecGrp_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+which.min">which.min</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.firstMin(c(4,3:6))
</code></pre>

<hr>
<h2 id='.scaleXY'>Scale between min and max value (main)</h2><span id='topic+.scaleXY'></span>

<h3>Description</h3>

<p>This function rescales between user-defined min and max values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.scaleXY(x, minim = 2, maxim = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".scaleXY_+3A_x">x</code></td>
<td>
<p>numeric vector to be re-scalded</p>
</td></tr>
<tr><td><code id=".scaleXY_+3A_minim">minim</code></td>
<td>
<p>(numeric) minimum value for resultant vactor</p>
</td></tr>
<tr><td><code id=".scaleXY_+3A_maxim">maxim</code></td>
<td>
<p>(numeric) minimum value for resultant vactor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix of CV values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scaleXY">scaleXY</a></code> , <code><a href="base.html#topic+scale">scale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.scaleXY(11:15, min=1, max=100)
</code></pre>

<hr>
<h2 id='.seqCutStr'>Cut string to get all variants from given start with min length, depreciated</h2><span id='topic+.seqCutStr'></span>

<h3>Description</h3>

<p>This function is depreciated, please use <code>/cutStr</code> instead !
This function allows truncating character vector to all variants from given start, with min and optonal max length
Used to evaluate argument calls without giving full length of argument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.seqCutStr(txt, startFr = 1, minLe = 1, reverse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".seqCutStr_+3A_txt">txt</code></td>
<td>
<p>(character) main input, may be length &gt;1</p>
</td></tr>
<tr><td><code id=".seqCutStr_+3A_startfr">startFr</code></td>
<td>
<p>(interger) where to start</p>
</td></tr>
<tr><td><code id=".seqCutStr_+3A_minle">minLe</code></td>
<td>
<p>(interger) minimum length of output</p>
</td></tr>
<tr><td><code id=".seqCutStr_+3A_reverse">reverse</code></td>
<td>
<p>(logical) return longest text-fragments at beginning of vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a character vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pasteC">pasteC</a></code>; <code><a href="base.html#topic+substr">substr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.seqCutStr("abcdefg", minLe=2)
</code></pre>

<hr>
<h2 id='.setLowestTo'>Set lowest value to given value</h2><span id='topic+.setLowestTo'></span>

<h3>Description</h3>

<p>This function aims to set lowest value of x to value 'setTo'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.setLowestTo(x, setTo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".setLowestTo_+3A_x">x</code></td>
<td>
<p>(numeric) main vector to be treated</p>
</td></tr>
<tr><td><code id=".setLowestTo_+3A_setto">setTo</code></td>
<td>
<p>(numeric) replacement value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a numeric vector
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+nchar">nchar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.setLowestTo(9:4, 6)
</code></pre>

<hr>
<h2 id='.sortMid'>Choose most frequent or middle of sorted vector</h2><span id='topic+.sortMid'></span>

<h3>Description</h3>

<p>This function chooses the (first) most frequent or  middle of sorted vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.sortMid(x, retVal = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".sortMid_+3A_x">x</code></td>
<td>
<p>(numeric) main input</p>
</td></tr>
<tr><td><code id=".sortMid_+3A_retval">retVal</code></td>
<td>
<p>(logical) return value of most frequent, if <code>FALSE</code> return index of (1st) 'x' for most frequent</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a numeric verctor
</p>


<h3>See Also</h3>

<p>simple/partial functionality in <code><a href="#topic+summarizeCols">summarizeCols</a></code>,  <code><a href="#topic+checkSimValueInSer">checkSimValueInSer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.sortMid(11:14)
</code></pre>

<hr>
<h2 id='.stackArray'>Reorganize array by reducing dimension 'byDim'  (similar to stack() for data-frames)</h2><span id='topic+.stackArray'></span>

<h3>Description</h3>

<p>This function aims to reorganize an array by reducing dimension 'byDim'  (similar to stack() for data-frames)
It returns an array/matrix of 1 dimension less than 'arr', 1st dim has more lines (names as paste with '_')
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.stackArray(arr, byDim = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".stackArray_+3A_arr">arr</code></td>
<td>
<p>(array) main input</p>
</td></tr>
<tr><td><code id=".stackArray_+3A_bydim">byDim</code></td>
<td>
<p>(integer)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an array/matrix of 1 dimension less than 'arr', 1st dim has more lines (names as paste with '_')
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(arr1 &lt;- array(11:37, dim=c(3,3,3)))
.stackArray(arr1, 3)
</code></pre>

<hr>
<h2 id='.summarizeCols'>Summarize columns of matrix (or data.frame) 'x' using apply (main)</h2><span id='topic+.summarizeCols'></span>

<h3>Description</h3>

<p>This function summarizes columns of matrix (or data.frame) 'x' using apply
Note, it cannot handle character entries !  (all results will be NA)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.summarizeCols(
  x,
  me = c("median", "medianComplete", "mean", "meanComplete", "aver", "average", "min",
    "max", "maxOfRef", "minOfRef", "maxAbsOfRef", "lastLi", "last", "firstComplete",
    "first", "firstLi", "summary"),
  vectAs1row = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".summarizeCols_+3A_x">x</code></td>
<td>
<p>data.frame matrix of data to be summarized by comlumn</p>
</td></tr>
<tr><td><code id=".summarizeCols_+3A_me">me</code></td>
<td>
<p>(character, length=1) summarization method (eg 'maxLast','minLast','maxLast','maxAbsLast', 'minLast', 'medianComplete' or 'meanComplete')</p>
</td></tr>
<tr><td><code id=".summarizeCols_+3A_vectas1row">vectAs1row</code></td>
<td>
<p>(logical) if TRUE will interprete non-matrix 'x' as matrix with 1 row (correct effect of automatic conversion when extracting 1 line)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with summary for each column
</p>


<h3>See Also</h3>

<p><code>summarizeCols</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t1 &lt;- matrix(round(runif(30,1,9)), nc=3); rownames(t1) &lt;- letters[c(1:5,3:4,6:4)]  
</code></pre>

<hr>
<h2 id='.trimFromEnd'>Trim from end</h2><span id='topic+.trimFromEnd'></span>

<h3>Description</h3>

<p>This function allows trimming/removing redundant text-fragments from end
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.trimFromEnd(x, ..., callFrom = NULL, debug = FALSE, silent = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".trimFromEnd_+3A_x">x</code></td>
<td>
<p>character vector to be treated</p>
</td></tr>
<tr><td><code id=".trimFromEnd_+3A_...">...</code></td>
<td>
<p>more vectors to be treated</p>
</td></tr>
<tr><td><code id=".trimFromEnd_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
<tr><td><code id=".trimFromEnd_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id=".trimFromEnd_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a modified character vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trimRedundText">trimRedundText</a></code>; Inverse : Find/keep common text <code><a href="#topic+keepCommonText">keepCommonText</a></code>;  you may also look for related functions in package <a href="https://CRAN.R-project.org/package=stringr">stringr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>txt1 &lt;- c("abcd_ccc","bcd_ccc","cde_ccc")
.trimFromEnd(txt1)
</code></pre>

<hr>
<h2 id='.trimFromStart'>Trim from start</h2><span id='topic+.trimFromStart'></span>

<h3>Description</h3>

<p>This function allows trimming/removing redundant text-fragments from start
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.trimFromStart(
  x,
  ...,
  minNchar = 1,
  silent = TRUE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".trimFromStart_+3A_x">x</code></td>
<td>
<p>character vector to be treated</p>
</td></tr>
<tr><td><code id=".trimFromStart_+3A_...">...</code></td>
<td>
<p>more vectors to be treated</p>
</td></tr>
<tr><td><code id=".trimFromStart_+3A_minnchar">minNchar</code></td>
<td>
<p>(integer) minumin number of characters that must remain</p>
</td></tr>
<tr><td><code id=".trimFromStart_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id=".trimFromStart_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id=".trimFromStart_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a modified character vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trimRedundText">trimRedundText</a></code>; Inverse : Find/keep common text <code><a href="#topic+keepCommonText">keepCommonText</a></code>;  you may also look for related functions in package <a href="https://CRAN.R-project.org/package=stringr">stringr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>txt1 &lt;- c("abcd_ccc","bcd_ccc","cde_ccc")
.trimFromStart(txt1)
</code></pre>

<hr>
<h2 id='.trimLeft'>Trim from Left</h2><span id='topic+.trimLeft'></span>

<h3>Description</h3>

<p>This function allows trimming/removing redundant text-fragments from left side
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.trimLeft(x, minNchar = 1, silent = TRUE, debug = FALSE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".trimLeft_+3A_x">x</code></td>
<td>
<p>character vector to be treated</p>
</td></tr>
<tr><td><code id=".trimLeft_+3A_minnchar">minNchar</code></td>
<td>
<p>(integer) minumin number of characters that must remain</p>
</td></tr>
<tr><td><code id=".trimLeft_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id=".trimLeft_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id=".trimLeft_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a modified character vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trimRedundText">trimRedundText</a></code>; Inverse : Find/keep common text <code><a href="#topic+keepCommonText">keepCommonText</a></code>;  you may also look for related functions in package <a href="https://CRAN.R-project.org/package=stringr">stringr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>txt1 &lt;- c("abcd_ccc","bcd_ccc","cde_ccc")
.trimLeft(txt1)
</code></pre>

<hr>
<h2 id='.trimRight'>Trim from right</h2><span id='topic+.trimRight'></span>

<h3>Description</h3>

<p>This function allows trimming/removing redundant text-fragments from right side
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.trimRight(x, minNchar = 1, silent = TRUE, debug = FALSE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".trimRight_+3A_x">x</code></td>
<td>
<p>character vector to be treated</p>
</td></tr>
<tr><td><code id=".trimRight_+3A_minnchar">minNchar</code></td>
<td>
<p>(integer) minumin number of characters that must remain</p>
</td></tr>
<tr><td><code id=".trimRight_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id=".trimRight_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id=".trimRight_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a modified character vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trimRedundText">trimRedundText</a></code>; Inverse : Find/keep common text <code><a href="#topic+keepCommonText">keepCommonText</a></code>;  you may also look for related functions in package <a href="https://CRAN.R-project.org/package=stringr">stringr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>txt1 &lt;- c("abcd_ccc","bcd_ccc","cde_ccc")
.trimRight(txt1)
</code></pre>

<hr>
<h2 id='.uniqueWName'>Check regression arguments</h2><span id='topic+.uniqueWName'></span>

<h3>Description</h3>

<p>This function is an enhanced version of <code>unique</code>, names of elements are maintained
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.uniqueWName(
  x,
  splitSameName = TRUE,
  silent = TRUE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".uniqueWName_+3A_x">x</code></td>
<td>
<p>(numeric or character vector) main input</p>
</td></tr>
<tr><td><code id=".uniqueWName_+3A_splitsamename">splitSameName</code></td>
<td>
<p>(logical)</p>
</td></tr>
<tr><td><code id=".uniqueWName_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id=".uniqueWName_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id=".uniqueWName_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector like input
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+unique">unique</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aa &lt;- c(a=11, b=12,a=11,d=14, c=11)
.uniqueWName(aa)
.uniqueWName(aa[-1]) # value repeated but different name
</code></pre>

<hr>
<h2 id='.vector2Matr'>Convert numeric vector to matrix</h2><span id='topic+.vector2Matr'></span>

<h3>Description</h3>

<p>Take (numeric) vector and return matrix, if 'colNa' given will be used as colname
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.vector2Matr(x, colNa = NULL, rowsKeep = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".vector2Matr_+3A_x">x</code></td>
<td>
<p>(numeric or character) main input</p>
</td></tr>
<tr><td><code id=".vector2Matr_+3A_colna">colNa</code></td>
<td>
<p>(integer) design the comumn-name to be given</p>
</td></tr>
<tr><td><code id=".vector2Matr_+3A_rowskeep">rowsKeep</code></td>
<td>
<p>(logical) is <code>TRUE</code> make matrix of 1 column, otherwise of 1 row</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+matrix">matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.vector2Matr(c(3:6))
</code></pre>

<hr>
<h2 id='addBeforFileExtension'>Add text before file-extension</h2><span id='topic+addBeforFileExtension'></span>

<h3>Description</h3>

<p>This function helps changing charater srings like file-names and allows adding the character vector 'add'
(length 1) before the extension (defined by last '.') of the input string 'x'. 
Used for easily creating variants/additional filenames but keeping current extension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addBeforFileExtension(
  x,
  add,
  sep = "_",
  silent = FALSE,
  callFrom = NULL,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addBeforFileExtension_+3A_x">x</code></td>
<td>
<p>main character vector</p>
</td></tr>
<tr><td><code id="addBeforFileExtension_+3A_add">add</code></td>
<td>
<p>character vector to be added</p>
</td></tr>
<tr><td><code id="addBeforFileExtension_+3A_sep">sep</code></td>
<td>
<p>(character) separator between 'x' &amp; 'add' (character, length 1)</p>
</td></tr>
<tr><td><code id="addBeforFileExtension_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="addBeforFileExtension_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
<tr><td><code id="addBeforFileExtension_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
</table>


<h3>Value</h3>

<p>modified character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>addBeforFileExtension(c("abd.txt","ghg.ijij.txt","kjh"),"new")
</code></pre>

<hr>
<h2 id='adjBy2ptReg'>Linear rescaling of numeric vertor or matrix</h2><span id='topic+adjBy2ptReg'></span>

<h3>Description</h3>

<p><code>adjBy2ptReg</code> takes data within window defined by 'lims' and determines linear transformation so that these points get the regression characteristics 'regrTo', 
all other points (ie beyond the limits) will follow the same transformation.
In other words, this function performs 'linear rescaling', by adjusting (normalizing) the vector 'dat' by linear regression so that points falling in 'lims'
(list with upper &amp; lower boundaries) will end up as 'regrTo'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjBy2ptReg(
  dat,
  lims,
  regrTo = c(0.1, 0.9),
  refLines = NULL,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjBy2ptReg_+3A_dat">dat</code></td>
<td>
<p>numeric vector, matrix or data.frame</p>
</td></tr>
<tr><td><code id="adjBy2ptReg_+3A_lims">lims</code></td>
<td>
<p>(list, length=2) should be list giving limits (list(lo=c(min,max),hi=c(min,max)) in data allowing identifying which points will be used for determining slope &amp; offset</p>
</td></tr>
<tr><td><code id="adjBy2ptReg_+3A_regrto">regrTo</code></td>
<td>
<p>(numeric, length=2) to which characteristics data should be regressed</p>
</td></tr>
<tr><td><code id="adjBy2ptReg_+3A_reflines">refLines</code></td>
<td>
<p>(NULL or integer) optional subselection of lines of dat (will be used internal as refDat)</p>
</td></tr>
<tr><td><code id="adjBy2ptReg_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="adjBy2ptReg_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="adjBy2ptReg_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix (of same dimensions as inlut matrix) with normalized values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normalizeThis">normalizeThis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016); dat1 &lt;- round(runif(50,0,100),1)
## extreme values will be further away :
adjBy2ptReg(dat1,lims=list(c(5,9), c(60,90)))
plot(dat1, adjBy2ptReg(dat1, lims=list(c(5,9),c(60,90))))
</code></pre>

<hr>
<h2 id='adjustUnitPrefix'>Adjust Value With Different Decimal Prefixes To Single Prefix Plus Unit</h2><span id='topic+adjustUnitPrefix'></span>

<h3>Description</h3>

<p>This function provides help converting values with with different unit-prefixes to a single prefix-unit type.
This can be used to convert a vector of mixed prefixes like 'p' and 'n'.
Any text to the right of the unit will be ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjustUnitPrefix(
  x,
  pref = c("z", "a", "f", "p", "n", "u", "m"),
  unit = "sec",
  sep = c(".", " ", ""),
  headingTxt = "",
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjustUnitPrefix_+3A_x">x</code></td>
<td>
<p>(character) vector containing digit uunit-prefix and unit terms</p>
</td></tr>
<tr><td><code id="adjustUnitPrefix_+3A_pref">pref</code></td>
<td>
<p>(character) multiplicative unit-prefixes, assumes as increasing factors of 1000</p>
</td></tr>
<tr><td><code id="adjustUnitPrefix_+3A_unit">unit</code></td>
<td>
<p>(character) unit name, the numeric part may be sepatated by one space-character</p>
</td></tr>
<tr><td><code id="adjustUnitPrefix_+3A_sep">sep</code></td>
<td>
<p>(character) separator characters that may appear between integer numeric value and unit description</p>
</td></tr>
<tr><td><code id="adjustUnitPrefix_+3A_headingtxt">headingTxt</code></td>
<td>
<p>(character) additional text preceeding the numeric part of 'x' to be ingnored/removed</p>
</td></tr>
<tr><td><code id="adjustUnitPrefix_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="adjustUnitPrefix_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="adjustUnitPrefix_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please note that the current version recognizes and converts only interger values, decimals or scientific writing won't work.
The resultant numeric vector expresses all values as lowest prefix unit level.
In case of invalid entries <code>NA</code>s will be returned.
</p>
<p>Please note the 'u' is used for 'micro'.
</p>


<h3>Value</h3>

<p>This function returns a numeric vector with quantities extracted and adjusted to a single type of unit (without the unit description)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+convToNum">convToNum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adjustUnitPrefix(c("10.psec abc","2 fsec etc"), unit="sec")
</code></pre>

<hr>
<h2 id='appendNR'>Append vectors or lists, without duplcating common elements</h2><span id='topic+appendNR'></span>

<h3>Description</h3>

<p>This function allows combining two vectors or lists without duplicating common content (definded by name of list-elements).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>appendNR(x, y, rmDuplicate = TRUE, silent = FALSE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="appendNR_+3A_x">x</code></td>
<td>
<p>(vector or list) must have names to allow checking for duplicate names in y</p>
</td></tr>
<tr><td><code id="appendNR_+3A_y">y</code></td>
<td>
<p>(vector or list) must have names to allow checking for duplicate names in x</p>
</td></tr>
<tr><td><code id="appendNR_+3A_rmduplicate">rmDuplicate</code></td>
<td>
<p>(logical) avoid duplicating liste-elements present in both x and y (based on names of list-elements)</p>
</td></tr>
<tr><td><code id="appendNR_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="appendNR_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When setting the argument <code>rmDuplicate=FALSE</code> the function will behave like <code>append</code>.
</p>


<h3>Value</h3>

<p>If both <code>x</code> and <code>y</code> are vectors, the output will be a vector, otherwise it will be a list
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+append">append</a></code>; <code><a href="#topic+lrbind">lrbind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>li1 &lt;- list(a=1, b=2, c=3)
li2 &lt;- list(A=11, B=12, c=3)
appendNR(li1, li2)
append(li1, li2) 
</code></pre>

<hr>
<h2 id='arrayCV'>CV of array</h2><span id='topic+arrayCV'></span>

<h3>Description</h3>

<p><code>arrayCV</code> gets CVs for replicates in 2 or 3 dim array and returns CVs as matrix.
This function may be used to calculate CVs from replicate microtiter plates (eg 8x12) where replicates are typically done as multiple plates,
ie initial matrixes that are the organized into arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrayCV(arr, byDim = 3, silent = TRUE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrayCV_+3A_arr">arr</code></td>
<td>
<p>(3-dim) array of numeric data like where replicates are along one dimesion of the array</p>
</td></tr>
<tr><td><code id="arrayCV_+3A_bydim">byDim</code></td>
<td>
<p>(integer) over which dimension repliates are found</p>
</td></tr>
<tr><td><code id="arrayCV_+3A_silent">silent</code></td>
<td>
<p>(logical) suppres messages</p>
</td></tr>
<tr><td><code id="arrayCV_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of CV values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowCVs">rowCVs</a></code>, <code><a href="#topic+rowGrpCV">rowGrpCV</a></code>, <code><a href="#topic+replPlateCV">replPlateCV</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016); dat1 &lt;- matrix(c(runif(200)+rep(1:10,20)),ncol=10)
head(arrayCV(dat1,byDim=2))
</code></pre>

<hr>
<h2 id='asSepList'>Organize Data as Separate List-Entries</h2><span id='topic+asSepList'></span>

<h3>Description</h3>

<p><code>asSepList</code> allows reorganizing most types of input into a list with separate numeric vectors. For example, matrixes or data.frames will be split into separate columns
(differnt to <code><a href="#topic+partUnlist">partUnlist</a></code> which maintains the original structure). This function also works with lists of lists.
This function may be helpful for reorganizing data for plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asSepList(
  y,
  minLen = 4,
  asNumeric = TRUE,
  exclElem = NULL,
  sep = "_",
  fillNames = TRUE,
  silent = FALSE,
  callFrom = NULL,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asSepList_+3A_y">y</code></td>
<td>
<p>list to be separated/split in vectors</p>
</td></tr>
<tr><td><code id="asSepList_+3A_minlen">minLen</code></td>
<td>
<p>(integer) min length (or number of rows), as add'l element to eliminate arguments given without names when asSepList is called in vioplot2</p>
</td></tr>
<tr><td><code id="asSepList_+3A_asnumeric">asNumeric</code></td>
<td>
<p>(logical) to transform all list-elements in simple numeric vectors (won't work if some entries are character)</p>
</td></tr>
<tr><td><code id="asSepList_+3A_exclelem">exclElem</code></td>
<td>
<p>(character) optinal names to exclude if any (lazy matching) matches (to exclude other arguments be misinterpreted as data)</p>
</td></tr>
<tr><td><code id="asSepList_+3A_sep">sep</code></td>
<td>
<p>(character) separator when combining name of list-element to colames</p>
</td></tr>
<tr><td><code id="asSepList_+3A_fillnames">fillNames</code></td>
<td>
<p>(logical) add names for list-elements/ series when not given</p>
</td></tr>
<tr><td><code id="asSepList_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="asSepList_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
<tr><td><code id="asSepList_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list, partially unlisted to vectors
</p>


<h3>See Also</h3>

<p><code><a href="#topic+partUnlist">partUnlist</a></code>, <code><a href="base.html#topic+unlist">unlist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bb &lt;- list(fa=gl(2,2), c=31:33, L2=matrix(21:28,nc=2),
  li=list(li1=11:14, li2=data.frame(41:44)))
asSepList(bb)
## multi data-frame examples
ca &lt;- data.frame(a=11:15, b=21:25, c=31:35)
cb &lt;- data.frame(a=51:53, b=61:63)
cc &lt;- list(gl(3,2), ca, cb, 91:94, short=81:82, letters[1:5])
asSepList(cc)
cd &lt;- list(e1=gl(3,2), e2=ca, e3=cb, e4=91:94, short=81:82, e6=letters[1:5])
asSepList(cd)
</code></pre>

<hr>
<h2 id='buildTree'>Connect edges to from tree and extract all possible branches</h2><span id='topic+buildTree'></span>

<h3>Description</h3>

<p>It is assumed that multiple fragments from a common ancestor bay be charcterized by the their start- and end-sites by integer values.  
For example, If 'abcdefg' is the ancestor, the fragments 'bcd' (from position 2 to 4) to  and 'efg' may then be assembled. 
To do so, all fragments must be presented as matix specifying all start- and end-sites (and fragment-names).  
<code>buildTree</code> searchs contiguous fragments from columns 'posCo' (start/end) from 'disDat' to build tree &amp; extract path information starting with line 'startFr'.
Made for telling if dissociated fragments contribute to long assemblies.
This function uses various functions of package <a href="https://CRAN.R-project.org/package=data.tree">data.tree</a> which must be installed, too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildTree(
  disDat,
  startFr = NULL,
  posCo = c("beg", "end"),
  silent = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildTree_+3A_disdat">disDat</code></td>
<td>
<p>(matrix or data.frame) integer values with 1st column, ie start site of fragment, 2nd column as end of fragments, rownames as unique IDs (node-names)</p>
</td></tr>
<tr><td><code id="buildTree_+3A_startfr">startFr</code></td>
<td>
<p>(integer) index for 1st node (typically =1 if 'disDat' sorted by &quot;beg&quot;), should point to a terminal node for consective growing of branches</p>
</td></tr>
<tr><td><code id="buildTree_+3A_posco">posCo</code></td>
<td>
<p>(character) colnames specifying the begin &amp; start sites in 'disDat', if NULL 1st &amp; 2nd col will be used</p>
</td></tr>
<tr><td><code id="buildTree_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="buildTree_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with $paths (branches as matrix with columns 'sumLen' &amp; 'n'), $usedNodes (character vector of all names used to build tree) and $tree (object from data.tree)
</p>


<h3>See Also</h3>

<p>package <a href="https://CRAN.R-project.org/package=data.tree">data.tree</a> original function used <code><a href="data.tree.html#topic+Node">Node</a></code>; in this package : for exploiting edge/tree related issues <code><a href="#topic+simpleFragFig">simpleFragFig</a></code>, <code><a href="#topic+countSameStartEnd">countSameStartEnd</a></code> and <code><a href="#topic+contribToContigPerFrag">contribToContigPerFrag</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>frag2 &lt;- cbind(beg=c(2,3,7,13,13,15,7,9,7,3,7,5,7,3),end=c(6,12,8,18,20,20,19,12,12,4,12,7,12,4)) 
rownames(frag2) &lt;- c("A","E","B","C","D","F","H","G","I", "J","K","L","M","N")
buildTree(frag2)
countSameStartEnd(frag2)
</code></pre>

<hr>
<h2 id='cbindNR'>cbind to non-redundant</h2><span id='topic+cbindNR'></span>

<h3>Description</h3>

<p><code>cbindNR</code> combines all matrixes given as arguments to non-redundant column names (by ADDING the number of 'duplicated' columns !). 
Thus, this function works similar to <code>cbind</code>, but allows combining multiple matrix-objects containing redundant column-names.
Of course, all input-matrixes must have the same number of rows !
By default, the output gets sorted by column-names.
Note, due to the use of '...' arguments must be given by their full argument-names, lazy evaluation might not recognize properly argument names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cbindNR(
  ...,
  convertDFtoMatr = TRUE,
  sortOutput = TRUE,
  summarizeAs = "sum",
  silent = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cbindNR_+3A_...">...</code></td>
<td>
<p>all matrixes to get combined in cbind way</p>
</td></tr>
<tr><td><code id="cbindNR_+3A_convertdftomatr">convertDFtoMatr</code></td>
<td>
<p>(logical) decide if output should be converted to matrix</p>
</td></tr>
<tr><td><code id="cbindNR_+3A_sortoutput">sortOutput</code></td>
<td>
<p>(logical) optional sorting by column-names</p>
</td></tr>
<tr><td><code id="cbindNR_+3A_summarizeas">summarizeAs</code></td>
<td>
<p>(character) decide of combined values should get summed (default, 'sum') or averaged ('mean')</p>
</td></tr>
<tr><td><code id="cbindNR_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="cbindNR_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix or data.frame (as cbind would return)
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+cbind">cbind</a></code>, <code><a href="#topic+nonAmbiguousNum">nonAmbiguousNum</a></code>, <code><a href="#topic+firstOfRepLines">firstOfRepLines</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ma1 &lt;- matrix(1:6, ncol=3, dimnames=list(1:2,LETTERS[3:1]))
ma2 &lt;- matrix(11:16, ncol=3, dimnames=list(1:2,LETTERS[3:5]))
cbindNR(ma1, ma2)
cbindNR(ma1, ma2, summarizeAs="mean")
</code></pre>

<hr>
<h2 id='checkAvSd'>Check how multiple groups of data separate or overlap based on mean +/- sd</h2><span id='topic+checkAvSd'></span>

<h3>Description</h3>

<p><code>checkAvSd</code> compares if/how neighbour groups separate/overlap via the 'engineering approach' (+/- 2 standard-deviations is similar to a=0.05 <code>t.test</code>).
This approach may be used as less elegant alternative to (multi-group) logistic regression.
The function uses 'daAv' as matrix of means (rows are tested for up/down character/progression) which get compared with boundaries taken from daSd (for Sd values of each mean in 'daAv').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkAvSd(
  daAv,
  daSd,
  nByGr = NULL,
  multSd = 2,
  codeConst = "const",
  extSearch = FALSE,
  outAsLogical = TRUE,
  silent = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkAvSd_+3A_daav">daAv</code></td>
<td>
<p>matrix or data.frame</p>
</td></tr>
<tr><td><code id="checkAvSd_+3A_dasd">daSd</code></td>
<td>
<p>matrix or data.frame</p>
</td></tr>
<tr><td><code id="checkAvSd_+3A_nbygr">nByGr</code></td>
<td>
<p>optinal specifying number of Elements per group, allows rather using SEM (adopt to variable n of different groups)</p>
</td></tr>
<tr><td><code id="checkAvSd_+3A_multsd">multSd</code></td>
<td>
<p>(numeric) the factor specifyin how many sd values should be used as margin</p>
</td></tr>
<tr><td><code id="checkAvSd_+3A_codeconst">codeConst</code></td>
<td>
<p>(character) which term/word to use when specifying 'constant'</p>
</td></tr>
<tr><td><code id="checkAvSd_+3A_extsearch">extSearch</code></td>
<td>
<p>(logical) if TRUE, extend search to one group further (will call result 'nearUp' or 'nearDw')</p>
</td></tr>
<tr><td><code id="checkAvSd_+3A_outaslogical">outAsLogical</code></td>
<td>
<p>to switch between 2col-output (separate col for 'up' and 'down') or simple categorical vector ('const','okDw','okUp')</p>
</td></tr>
<tr><td><code id="checkAvSd_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="checkAvSd_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector describing character as 'const' or 'okUp','okDw' (or if extSearch=TRUE 'nearUp','nearDw')
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowGrpMeans">rowGrpMeans</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat1 &lt;- matrix(rep(11:24,3)[1:40],byrow=TRUE,ncol=8)
checkGrpOrderSEM(mat1,grp=gl(3,3)[-1])
checkAvSd(rowGrpMeans(mat1,gl(3,3)[-1]),rowGrpSds(mat1,gl(3,3)[-1]) )
# consider variable n :
checkAvSd(rowGrpMeans(mat1,gl(3,3)[-1]),rowGrpSds(mat1,gl(3,3)[-1]),nByGr=c(2,3,3)) 
</code></pre>

<hr>
<h2 id='checkFilePath'>Check If File Is Available For Reading</h2><span id='topic+checkFilePath'></span>

<h3>Description</h3>

<p>This function allows tesing if a given file-name corresponds to an existing file (eg for reading lateron).
Indications to the path and file-extensions may be given separately. If no files do match .gz compressed versions may be searced, too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkFilePath(
  fileName,
  path,
  expectExt = "",
  compressedOption = TRUE,
  strictExtension = FALSE,
  stopIfNothing = FALSE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkFilePath_+3A_filename">fileName</code></td>
<td>
<p>(character) name of file to be tested; may also include an absolute or relative path</p>
</td></tr>
<tr><td><code id="checkFilePath_+3A_path">path</code></td>
<td>
<p>(character, length=1) optional separate entry for path of <code>fileName</code></p>
</td></tr>
<tr><td><code id="checkFilePath_+3A_expectext">expectExt</code></td>
<td>
<p>(character) file extension (will not be considerd if <code>""</code>)</p>
</td></tr>
<tr><td><code id="checkFilePath_+3A_compressedoption">compressedOption</code></td>
<td>
<p>(logical) also look for .gz compressed files</p>
</td></tr>
<tr><td><code id="checkFilePath_+3A_strictextension">strictExtension</code></td>
<td>
<p>(logical) decide if extesion (<code>expectExt</code>) - if given - should be considered obligatory</p>
</td></tr>
<tr><td><code id="checkFilePath_+3A_stopifnothing">stopIfNothing</code></td>
<td>
<p>(logical) decide if function should give error or warning if no files found</p>
</td></tr>
<tr><td><code id="checkFilePath_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="checkFilePath_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="checkFilePath_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the filename given by the user exists but it's file-extension is not matching <code>expectExt</code> 
the argument <code>strictExtension</code> allows to decide if the filename will still be returned or not.
</p>
<p>When <code>expectExt</code> is given, initial search will look for perfect matches. 
However, if nothing is found and <code>strictExtension=FALSE</code>, a more relaxed and non-case-sensitive search will be performed.
</p>


<h3>Value</h3>

<p>This function returns a character vector with verified path and file-name(s), returns <code>NULL</code> if nothing
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+file.exists">file.exists</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(RhomeFi &lt;- list.files(R.home()))
file.exists(file.path(R.home(), "bin"))
checkFilePath(c("xxx","unins000"), R.home(), expectExt="dat")
</code></pre>

<hr>
<h2 id='checkGrpOrder'>checkGrpOrder</h2><span id='topic+checkGrpOrder'></span>

<h3>Description</h3>

<p><code>checkGrpOrder</code> tests each line of 'x' if expected order appears. 
Used for comparing groups of measures with expected profile (simply by mataching expected order)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkGrpOrder(
  x,
  rankExp = NULL,
  revRank = TRUE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkGrpOrder_+3A_x">x</code></td>
<td>
<p>matrix or data.frame</p>
</td></tr>
<tr><td><code id="checkGrpOrder_+3A_rankexp">rankExp</code></td>
<td>
<p>(numeric) expected order for values in columns, default 'rankExp' =1:ncol(x)</p>
</td></tr>
<tr><td><code id="checkGrpOrder_+3A_revrank">revRank</code></td>
<td>
<p>(logical) if 'revRank'=TRUE, the initial ranks &amp; reversed ranks will be tested</p>
</td></tr>
<tr><td><code id="checkGrpOrder_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="checkGrpOrder_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="checkGrpOrder_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of logical values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+checkGrpOrderSEM">checkGrpOrderSEM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2005); mat1 &lt;- rbind(matrix(round(runif(40),1),nc=4), rep(1,4))
checkGrpOrder(mat1)
checkGrpOrder(mat1,c(1,4,3,2))
</code></pre>

<hr>
<h2 id='checkGrpOrderSEM'>Check order of multiple groups including non-overlapping SEM-margins</h2><span id='topic+checkGrpOrderSEM'></span>

<h3>Description</h3>

<p><code>checkGrpOrderSEM</code> tests each line of 'x' if expected order of (replicate-) groups (defined in 'grp') appears intact,
while inluding SEM of groups (replicates) via a proportional weight 'sdFact' as (avGr1-gr1SEM) &lt; (avGr1+gr1SEM) &lt; (avGr2-gr2SEM) &lt; (avGr2+gr2SEM).  
Used for comparing groups of measures with expected profile (by matching expected order)
to check if data in 'x' represting groups ('grp') as lines follow.  
Groups of size=1: The sd (and SEM) can't be estimated directly without any replicates, however, an estimate can be given by shrinking if 'shrink1sampSd'=TRUE 
under the hypothesis that the overall mechanisms determining the variances is constant across all samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkGrpOrderSEM(
  x,
  grp,
  sdFact = 1,
  revRank = TRUE,
  shrink1sampSd = TRUE,
  silent = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkGrpOrderSEM_+3A_x">x</code></td>
<td>
<p>matrix or data.frame</p>
</td></tr>
<tr><td><code id="checkGrpOrderSEM_+3A_grp">grp</code></td>
<td>
<p>(factor) to organize replicate columns of (x)</p>
</td></tr>
<tr><td><code id="checkGrpOrderSEM_+3A_sdfact">sdFact</code></td>
<td>
<p>(numeric) is proportional factor how many units of SEM will be used for defining lower &amp; upper bounds of each group</p>
</td></tr>
<tr><td><code id="checkGrpOrderSEM_+3A_revrank">revRank</code></td>
<td>
<p>(logical) optionally revert ranks</p>
</td></tr>
<tr><td><code id="checkGrpOrderSEM_+3A_shrink1sampsd">shrink1sampSd</code></td>
<td>
<p>(logical)</p>
</td></tr>
<tr><td><code id="checkGrpOrderSEM_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="checkGrpOrderSEM_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector if order correct (as expected based on ranks)
</p>


<h3>See Also</h3>

<p>takes only 10
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat1 &lt;- matrix(rep(11:24,3)[1:40],byrow=TRUE,ncol=8)
checkGrpOrderSEM(mat1,grp=gl(3,3)[-1])
</code></pre>

<hr>
<h2 id='checkSimValueInSer'>Check for similar values in series</h2><span id='topic+checkSimValueInSer'></span>

<h3>Description</h3>

<p>This function checks all values of 'x' for similar neighbour values within (relative) range of 'ppm' (ie parts per milion as measure of distance).
By default values will be sorted internally, so if a given value of <code>x</code> has anywhere in  <code>x</code>  another value close enough, this will be detected.
However, if <code>sortX=FALSE</code> only the values next to left and right will be considered.
Return logical vector : FALSE for each entry of 'x' if value inside of ppm range to neighbour (of sorted values)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkSimValueInSer(
  x,
  ppm = 5,
  sortX = TRUE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkSimValueInSer_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="checkSimValueInSer_+3A_ppm">ppm</code></td>
<td>
<p>(numeric, length=1) ppm-range for considering as similar</p>
</td></tr>
<tr><td><code id="checkSimValueInSer_+3A_sortx">sortX</code></td>
<td>
<p>(logical) allows speeding up function when set to FALSE, for large data that are already sorted</p>
</td></tr>
<tr><td><code id="checkSimValueInSer_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="checkSimValueInSer_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="checkSimValueInSer_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a logical vector : <code>TRUE</code> for each entry of <code>x</code> where at least one neighbour is inside of ppm distance/range
</p>


<h3>See Also</h3>

<p>similar with more options <code><a href="#topic+withinRefRange">withinRefRange</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>va1 &lt;- c(4:7,7,7,7,7,8:10)+(1:11)/28600; checkSimValueInSer(va1)
data.frame(va=sort(va1),simil=checkSimValueInSer(va1))
</code></pre>

<hr>
<h2 id='checkStrictOrder'>Check for strict (ascencing or descending) order</h2><span id='topic+checkStrictOrder'></span>

<h3>Description</h3>

<p><code>checkStrictOrder</code> tests lines of 'dat' (matrix of data.frame) for strict order (ascending, descending or constant), 
each col of data is tested relative to the col on its left.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkStrictOrder(
  dat,
  invertCount = FALSE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkStrictOrder_+3A_dat">dat</code></td>
<td>
<p>matrix or data.frame</p>
</td></tr>
<tr><td><code id="checkStrictOrder_+3A_invertcount">invertCount</code></td>
<td>
<p>(logical) inverse counting (ie return 0 for all elememts in order)</p>
</td></tr>
<tr><td><code id="checkStrictOrder_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="checkStrictOrder_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="checkStrictOrder_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with counts of up pairs, down pairs, equal-pairs, if 'invertCount'=TRUE all non-events are counted, ie a resulting 0 means that all columns are following the described characteristics (with variabale col-numbers easier to count)
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+order">order</a></code>, <code><a href="#topic+checkGrpOrder">checkGrpOrder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2005); mat1 &lt;- rbind(matrix(round(runif(40),1),nc=4), rep(1,4))
checkStrictOrder(mat1); mat1[which(checkStrictOrder(mat1)[,2]==0),]
</code></pre>

<hr>
<h2 id='checkVectLength'>Check length of vector</h2><span id='topic+checkVectLength'></span>

<h3>Description</h3>

<p><code>checkVectLength</code> checks argument 'x' for expected length 'expeL' and return either message or error when expectation not met. 
May be used for parameter ('sanity') checking in other user front-end functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkVectLength(
  x,
  expeL = 1,
  stopOnProblem = FALSE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkVectLength_+3A_x">x</code></td>
<td>
<p>(numeric or charcter vector) input to check length</p>
</td></tr>
<tr><td><code id="checkVectLength_+3A_expel">expeL</code></td>
<td>
<p>(numeric) expected length</p>
</td></tr>
<tr><td><code id="checkVectLength_+3A_stoponproblem">stopOnProblem</code></td>
<td>
<p>(logical) continue on problems with message or stop (as error message)</p>
</td></tr>
<tr><td><code id="checkVectLength_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="checkVectLength_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="checkVectLength_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns <code>NULL</code>; it produces either error-message if length is not OK or optional message if length is OK
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aa &lt;- 1:5; checkVectLength(aa,exp=3)
</code></pre>

<hr>
<h2 id='cleanReplicates'>Replace Most Distant Values by NA</h2><span id='topic+cleanReplicates'></span>

<h3>Description</h3>

<p>This procedures aims to streighten (clean) the most extreme values of noisy replicates by identifying the most distant points 
(among a set of replicates). The input 'x' (matrix or data.frame) is supposed to come from multiple different measures taken 
in replicates (eg weight of different individuals as rows taken as multiple replicate measures in subsequent columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cleanReplicates(
  x,
  centrMeth = "median",
  nOutl = 2,
  retOffPos = FALSE,
  silent = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cleanReplicates_+3A_x">x</code></td>
<td>
<p>matrix (or data.frame)</p>
</td></tr>
<tr><td><code id="cleanReplicates_+3A_centrmeth">centrMeth</code></td>
<td>
<p>(character) method to summarize (mean or median)</p>
</td></tr>
<tr><td><code id="cleanReplicates_+3A_noutl">nOutl</code></td>
<td>
<p>(integer) determines how many points per line will be set to <code>NA</code> (with n=1 the worst row of replicates will be 'cleaned')</p>
</td></tr>
<tr><td><code id="cleanReplicates_+3A_retoffpos">retOffPos</code></td>
<td>
<p>(logical) if <code>TRUE</code>, replace the most extreme outlyer only</p>
</td></tr>
<tr><td><code id="cleanReplicates_+3A_silent">silent</code></td>
<td>
<p>(logical) suppres messages</p>
</td></tr>
<tr><td><code id="cleanReplicates_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With the argument <code>nOutl</code> the user chooses the total number of most extreme values to replace by <code>NA</code>.
how many of the most extreme replicates of the whole dataset will replaced by <code>NA</code>, ie with <code>nOutl=1</code> 
only the single most extreme outlyer will be replaced by <code>NA</code>. 
Outlier points are determined as point(s) with highest distance to (row) center (median and mean choice via argument 'centrMeth').
Thus function returns input data with &quot;removed&quot; points set to <code>NA</code>, or if <code>retOffPos=TRUE</code> the most extreme/outlier positions.
</p>


<h3>Value</h3>

<p>This function returns a matrix of same dimensions as input <code>x</code>,  data-points which were tagged/removed are set to <code>NA</code>, or if <code>retOffPos=TRUE</code> the most extreme/outlier positions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat3 &lt;- matrix(c(19,20,30, 18,19,28, 16,14,35),ncol=3)
cleanReplicates(mat3, nOutl=1)
</code></pre>

<hr>
<h2 id='closeMatchMatrix'>Reorganize results of search for close (similar) values in matrix-view</h2><span id='topic+closeMatchMatrix'></span>

<h3>Description</h3>

<p><code>closeMatchMatrix</code> reorganizes/refines results from simple search of similar values of 2 sets of data by <code><a href="#topic+findCloseMatch">findCloseMatch</a></code> (as list for one-to many relations) to more human friendly/readable matrix.
This function returns results combining two sets of data which were initially compared (eg measured and threoretical values) as matrix-view using output of <code><a href="#topic+findCloseMatch">findCloseMatch</a></code> and both original datastes
Additional information (covariables, annotation, ...) may be included as optional columns for either 'predMatr' or 'measMatr'.
Note : It is important to run <code><a href="#topic+findCloseMatch">findCloseMatch</a></code> with <code>sortMatch=FALSE</code> !
Note : Results presented based on view of 'predMatr', so if multiple 'measMatr' are at within tolared distance, lines of 'measMatr' will be repeated;
Note : Distances  'disToMeas' and 'ppmToPred' are oriented : neg value if measured is lower than predicted (and pos values if higher than predicted);
Note : Returns <code>NULL</code> when nothing within given limits of comparison;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>closeMatchMatrix(
  closeMatch,
  predMatr,
  measMatr,
  prefMatch = c("^x", "^y"),
  colPred = 1,
  colMeas = 1,
  limitToBest = TRUE,
  asDataFrame = FALSE,
  origNa = TRUE,
  silent = FALSE,
  callFrom = NULL,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closeMatchMatrix_+3A_closematch">closeMatch</code></td>
<td>
<p>(list) output from <code><a href="#topic+findCloseMatch">findCloseMatch</a></code>, ie list with hits for each 'x' (1st argument) : named vectors of value &amp; x index in name; run with 'sortMatch'=F</p>
</td></tr>
<tr><td><code id="closeMatchMatrix_+3A_predmatr">predMatr</code></td>
<td>
<p>(vector or matrix) predicted values, the column 'colPred' indicates which column is used for matching from <code><a href="#topic+findCloseMatch">findCloseMatch</a></code>; if column 'id' present this column will be used as identifier for matching</p>
</td></tr>
<tr><td><code id="closeMatchMatrix_+3A_measmatr">measMatr</code></td>
<td>
<p>(vector or matrix) measured values, the column 'colMeas' indicates which column is used for matching from <code><a href="#topic+findCloseMatch">findCloseMatch</a></code>; if column 'id' present this column will be used as identifier for matching</p>
</td></tr>
<tr><td><code id="closeMatchMatrix_+3A_prefmatch">prefMatch</code></td>
<td>
<p>(character, length=2) prefixes ('^x' and/or '^y') thay may have been added by <code>findCloseMatch</code></p>
</td></tr>
<tr><td><code id="closeMatchMatrix_+3A_colpred">colPred</code></td>
<td>
<p>(integer or text, length=1) column of 'predMatr' with main values of comparison</p>
</td></tr>
<tr><td><code id="closeMatchMatrix_+3A_colmeas">colMeas</code></td>
<td>
<p>(integer or text, length=1) column of 'measMatr' with main measures of comparison</p>
</td></tr>
<tr><td><code id="closeMatchMatrix_+3A_limittobest">limitToBest</code></td>
<td>
<p>(integer) column of 'measMatr' with main measures of comparison</p>
</td></tr>
<tr><td><code id="closeMatchMatrix_+3A_asdataframe">asDataFrame</code></td>
<td>
<p>(logical) convert results to data.frame if non-numeric matrix produced (may slightly slow down big results)</p>
</td></tr>
<tr><td><code id="closeMatchMatrix_+3A_origna">origNa</code></td>
<td>
<p>(logical) will try to use original names of objects 'predMatr','measMatr', if they are not multi-column and not conflicting other output-names (otherwise 'predMatr','measMatr' will appear)</p>
</td></tr>
<tr><td><code id="closeMatchMatrix_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="closeMatchMatrix_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of message(s) produced</p>
</td></tr>
<tr><td><code id="closeMatchMatrix_+3A_debug">debug</code></td>
<td>
<p>(logical) for bug-tracking: more/enhanced messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>results as matrix-view based on initial results from <code><a href="#topic+findCloseMatch">findCloseMatch</a></code>, including optional columns of suppelemental data for both sets of data for comparison. Returns <code>NULL</code> when nothing within limits
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findCloseMatch">findCloseMatch</a></code>, <code><a href="#topic+checkSimValueInSer">checkSimValueInSer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aA &lt;- c(11:17); bB &lt;- c(12.001,13.999); cC &lt;- c(16.2,8,9,12.5,15.9,13.5,15.7,14.1,5)
(cloMa &lt;- findCloseMatch(aA,cC,com="diff",lim=0.5,sor=FALSE))       
# all matches (of 2d arg) to/within limit for each of 1st arg ('x'); 'y' ..to 2nd arg = cC
(maAa &lt;- closeMatchMatrix(cloMa,aA,cC,lim=TRUE))  #
(maAa &lt;- closeMatchMatrix(cloMa,aA,cC,lim=FALSE,origN=TRUE))  #
(maAa &lt;- closeMatchMatrix(cloMa,cbind(valA=81:87,aA),cbind(valC=91:99,cC),colM=2,
  colP=2,lim=FALSE))
(maAa &lt;- closeMatchMatrix(cloMa,cbind(aA,valA=81:87),cC,lim=FALSE,deb=TRUE))  #
a2 &lt;- aA; names(a2) &lt;- letters[1:length(a2)];  c2 &lt;- cC; names(c2) &lt;- letters[10+1:length(c2)]
(cloM2 &lt;- findCloseMatch(x=a2,y=c2,com="diff",lim=0.5,sor=FALSE)) 
(maA2 &lt;- closeMatchMatrix(cloM2,predM=cbind(valA=81:87,a2),measM=cbind(valC=91:99,c2),
  colM=2,colP=2,lim=FALSE,asData=TRUE)) 
(maA2 &lt;- closeMatchMatrix(cloM2,cbind(id=names(a2),valA=81:87,a2),cbind(id=names(c2),
  valC=91:99,c2),colM=3,colP=3,lim=FALSE,deb=FALSE)) 
</code></pre>

<hr>
<h2 id='coinPermTest'>Compare means of two vectors by permutation test</h2><span id='topic+coinPermTest'></span>

<h3>Description</h3>

<p>Run coin-flipping like permutation tests (to compare difference of 2 means: 'x1' and 'x2') without any distribution-assumptions.
This function uses the package <a href="https://CRAN.R-project.org/package=coin">coin</a>, if not installed, the function will return NULL and give a warning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coinPermTest(
  x1,
  x2,
  orient = "two.sided",
  nPerm = 5000,
  silent = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coinPermTest_+3A_x1">x1</code></td>
<td>
<p>numeric vector (to be compared with vector 'x2')</p>
</td></tr>
<tr><td><code id="coinPermTest_+3A_x2">x2</code></td>
<td>
<p>numeric vector (to be compared with vector 'x1')</p>
</td></tr>
<tr><td><code id="coinPermTest_+3A_orient">orient</code></td>
<td>
<p>(character) may be &quot;two.sided&quot;,&quot;greater&quot; or &quot;less&quot;</p>
</td></tr>
<tr><td><code id="coinPermTest_+3A_nperm">nPerm</code></td>
<td>
<p>(integer) number of permutations</p>
</td></tr>
<tr><td><code id="coinPermTest_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="coinPermTest_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This  function returns an object of &quot;MCp&quot; class numeric output with p-values
</p>


<h3>See Also</h3>

<p><code>oneway_test</code> in <code><a href="coin.html#topic+LocationTests">LocationTests</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coinPermTest(2, 3, nPerm=200)
</code></pre>

<hr>
<h2 id='colMedSds'>Standard error of median for each column by bootstrap</h2><span id='topic+colMedSds'></span>

<h3>Description</h3>

<p>Determine standard error (sd) of median by bootstraping for multiple sets of data (rows in input matrix 'dat').
Note: The package <a href="https://CRAN.R-project.org/package=boot">boot</a> must be installed from CRAN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colMedSds(dat, nBoot = 99, silent = FALSE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colMedSds_+3A_dat">dat</code></td>
<td>
<p>(numeric) matix</p>
</td></tr>
<tr><td><code id="colMedSds_+3A_nboot">nBoot</code></td>
<td>
<p>(integer) number if iterations</p>
</td></tr>
<tr><td><code id="colMedSds_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="colMedSds_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a (numeric) vector with estimated standard errors
</p>


<h3>See Also</h3>

<p><code><a href="boot.html#topic+boot">boot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016); dat1 &lt;- matrix(c(runif(200) +rep(1:10,20)), ncol=10)
colMedSds(dat1) 
</code></pre>

<hr>
<h2 id='colorAccording2'>Transform numeric values to color-gradient</h2><span id='topic+colorAccording2'></span>

<h3>Description</h3>

<p>This function helps making color-gradients for plotting a numerical variable.
It requires the package 'RColorBrewer' being installed from CRAN. 
Note : RColorBrewer palettes were not integrated here, since they are not continuous.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorAccording2(
  x,
  gradTy = "rainbow",
  nStartOmit = NULL,
  nEndOmit = NULL,
  revCol = FALSE,
  alpha = 1,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colorAccording2_+3A_x">x</code></td>
<td>
<p>(character) color input</p>
</td></tr>
<tr><td><code id="colorAccording2_+3A_gradty">gradTy</code></td>
<td>
<p>(character) type of gradeint may be 'rainbow', 'heat.colors', 'terrain.colors', 'topo.colors', 'cm.colors', 'hcl.colors', 'grey.colors', 'gray.colorsW' or 'logGray'</p>
</td></tr>
<tr><td><code id="colorAccording2_+3A_nstartomit">nStartOmit</code></td>
<td>
<p>(integer) omit n steps from begining of gradient range</p>
</td></tr>
<tr><td><code id="colorAccording2_+3A_nendomit">nEndOmit</code></td>
<td>
<p>(integer or &quot;sep&quot;) omit n steps from end of gradient range, if <code>nEndOmit="sep"</code> 20 percent of initial grades will be removed to obtain 'separate' ie non-closing color-circles/gradients eg with <code>rainbow</code></p>
</td></tr>
<tr><td><code id="colorAccording2_+3A_revcol">revCol</code></td>
<td>
<p>(logical) reverse order</p>
</td></tr>
<tr><td><code id="colorAccording2_+3A_alpha">alpha</code></td>
<td>
<p>(numeric) optional transparency value (1 for no transparency, 0 for complete opaqueness)</p>
</td></tr>
<tr><td><code id="colorAccording2_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a character vector (of same length as x) with color encoding
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+cut">cut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2015); dat1 &lt;- round(runif(15),2)
plot(1:15,dat1,pch=16,cex=2,col=colorAccording2(dat1))
plot(1:15,dat1,pch=16,cex=2,col=colorAccording2(dat1,nStartO=0,nEndO=4,revCol=TRUE))
plot(1:9,pch=3)
points(1:9,1:9,col=transpGraySca(st=0,en=0.8,nSt=9,trans=0.3),cex=42,pch=16)
</code></pre>

<hr>
<h2 id='colSds'>sd for each column</h2><span id='topic+colSds'></span>

<h3>Description</h3>

<p><code>colSds</code> is a speed optimized <code>sd</code> for matrix or data.frames. 
It and treats each line as an independent set of data for calculating the sd (equiv to <code>apply(dat,1,sd)</code>).
NAs are ignored from data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colSds(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colSds_+3A_dat">dat</code></td>
<td>
<p>matrix (or data.frame) with numeric values (may contain NAs)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector of sd values
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+sd">sd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016); dat1 &lt;- matrix(c(runif(200)+rep(1:10,20)),nc=10)
colSds(dat1)
</code></pre>

<hr>
<h2 id='combinatIntTable'>Planing for making all multiplicative combinations</h2><span id='topic+combinatIntTable'></span>

<h3>Description</h3>

<p>Provide all combinations for each of n elements of vector 'nMax' (positive integer, eg number of max multiplicative value). 
For example, imagine, we have 3 cities and the (maximum) voting participants per city.
Results must be read vertically and allow to see all total possible compositons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combinatIntTable(
  nMax,
  include0 = TRUE,
  asList = FALSE,
  callFrom = NULL,
  silent = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combinatIntTable_+3A_nmax">nMax</code></td>
<td>
<p>(positive integer) could be max number of voting participants form different cities, eg Paris max 2 persons, Lyon max 1 person ...</p>
</td></tr>
<tr><td><code id="combinatIntTable_+3A_include0">include0</code></td>
<td>
<p>(logical) include 0 occurances, ie provide al combinations starting from 0 or from 1 up to nMax</p>
</td></tr>
<tr><td><code id="combinatIntTable_+3A_aslist">asList</code></td>
<td>
<p>(logical) return result as list or as array</p>
</td></tr>
<tr><td><code id="combinatIntTable_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
<tr><td><code id="combinatIntTable_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list or array (as 2- or 3 dim) with possible number of occurances for each of the 3 elements in nMax. Read results vertical : out[[1]] or out[,,1] .. (multiplicative) table for 1st element of nMax; out[,,2] .. for 2nd
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+combn">combn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>combinatIntTable(c(1,1,1,2), include0=TRUE, asList=FALSE, silent=TRUE)
## Imagine we have 3 cities and the (maximum) voting participants per city :
nMa &lt;- c(Paris=2, Lyon=1, Strasbourg=1)
combinatIntTable(nMa, include0=TRUE, asList=TRUE, silent=TRUE) 
</code></pre>

<hr>
<h2 id='combineAsN'>Combine Vectors From List And Return Basic Count Statistics</h2><span id='topic+combineAsN'></span>

<h3>Description</h3>

<p>The aim of this function is to choose a fixed number (<code>nCombin</code>) of list-elments from <code>lst</code> and count the number of common values/words.
Furthermore, one can define levels to fine-tune the types of combinations to examine.
In case multiple combinations for a given level are possible, some basic summary statistics are provided, too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineAsN(
  lst,
  lev = NULL,
  nCombin = 3,
  remDouble = TRUE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineAsN_+3A_lst">lst</code></td>
<td>
<p>(list of character or integer vectors) main input</p>
</td></tr>
<tr><td><code id="combineAsN_+3A_lev">lev</code></td>
<td>
<p>(character) define groups of <code>lst</code></p>
</td></tr>
<tr><td><code id="combineAsN_+3A_ncombin">nCombin</code></td>
<td>
<p>(integer) number of list-elements to combine from <code>lst</code></p>
</td></tr>
<tr><td><code id="combineAsN_+3A_remdouble">remDouble</code></td>
<td>
<p>(logical) remove intra-duplicates (defaults to <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="combineAsN_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="combineAsN_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="combineAsN_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note of caution :
With very long lists and/or high numbers of repeats of given levels, however, the computational effort incerases very much (like it does when using <code>table</code>).
Thus, when exploring all different combinations of large data-sets may easily result in queries consuming many ressources (RAM and processing time) !
It is recommended to start testing with test smaller sub-groups.
</p>
<p>The main idea of this function is to count frequency of terms when combining different drawings.
For example, you ask students from different cities which are their preferred hobbies, they may have different preference depending on the city ( defined by <code>lev</code>).
Now, if you want to make groups of 3 students, possibly with one from each city (A ,B and C), you want to count (/estimate) the frequency of different combinations possible.
Thus, using this function all combinations of the students from city A with the students from city B and C will be made when counting the number of common hobbies (by <code>nCombin</code> students).
Then, all counting results will be summarized to the average count for the various categories (which hobbies were seen once, twice or 3 times...),
sem (standard error of the mean) and CI (95
</p>
<p>Of course, the number of potential combinations may quickly get very large. Using the argument <code>remDouble=TRUE</code> you can limit the search to
either finding all students giving the same answer plus all student giving different answers.
In this case, when a given level appears multiple times, all possible combinations using one of the respective entries will be be made with the other levels.
</p>


<h3>Value</h3>

<p>This function returns an array with 3 dimensions : i)  ii) the combinations of <code>nCombin</code> list-elements,
iii) the number of counts (n), sem (standard error of the mean), CI (confidence interval) and sd
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+table">table</a></code>,  <code><a href="#topic+replicateStructure">replicateStructure</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## all list-elements are considered equal
tm1 &lt;- list(a1=LETTERS[1:17], a2=LETTERS[3:19], a3=LETTERS[6:20], a4=LETTERS[8:22])
combineAsN(tm1, lev=gl(1,4))[,1,]

## different levels/groups in list-elements
tm4 &lt;- list(a1=LETTERS[1:15], a2=LETTERS[3:16], a3=LETTERS[6:17], a4=LETTERS[8:19],
  b1=LETTERS[5:19], b2=LETTERS[7:20], b3=LETTERS[11:24], b4=LETTERS[13:25], c1=LETTERS[17:26],
  d1=LETTERS[4:12], d2=LETTERS[5:11], d3=LETTERS[6:12], e1=LETTERS[7:10])
te4 &lt;- combineAsN(tm4, nCombin=4, lev=substr(names(tm4),1,1))
str(te4)
te4[,,1]

</code></pre>

<hr>
<h2 id='combineByEitherFactor'>Create factor-like column regrouping data regrouping simultaneaously by two factors</h2><span id='topic+combineByEitherFactor'></span>

<h3>Description</h3>

<p>This function aims to address the situation when two somehow different groupins (of the same data) exist and need to be joined.
It is not necessary that both alternative groupings use the same labels, neither.
<code>combineByEitherFactor</code> adds new (last) column named 'grp' to input matrix representing the combined factor 
relative to 2 specified columns from input matrix  <code>mat</code> (via 'refC1','refC2'). Optionally, the output may be 
sorted and a column giving n per factor-level may be added. 
The function treats selected columns of  <code>mat</code> 
as pairwise combination of 2 elements (that may occur multiple times over all lines of  <code>mat</code>)
and sorts/organizes all instances of such combined elements (ie from both selected columns) as repeats of a given group,
who's class number is given in output column 'grp', the (total) number of repeats may be displayed in column 'nGrp' ( <code>nByGrp=TRUE</code>).
If groups are overlapping (after re-ordering), an iterative process of max 3x2 passes will be launched after initial matching.
Works on numeric as well as character input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineByEitherFactor(
  mat,
  refC1,
  refC2,
  nByGrp = FALSE,
  convergeMax = TRUE,
  callFrom = NULL,
  debug = FALSE,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineByEitherFactor_+3A_mat">mat</code></td>
<td>
<p>main input matrix</p>
</td></tr>
<tr><td><code id="combineByEitherFactor_+3A_refc1">refC1</code></td>
<td>
<p>(integer) column-number of 'mat' to use as 1st set</p>
</td></tr>
<tr><td><code id="combineByEitherFactor_+3A_refc2">refC2</code></td>
<td>
<p>(integer) column-number of 'mat' to use as 2nd set</p>
</td></tr>
<tr><td><code id="combineByEitherFactor_+3A_nbygrp">nByGrp</code></td>
<td>
<p>(logical) add last col with n by group</p>
</td></tr>
<tr><td><code id="combineByEitherFactor_+3A_convergemax">convergeMax</code></td>
<td>
<p>(logical) if <code>TRUE</code>, run 2 add'l iteartive steps to search convergence to stable result</p>
</td></tr>
<tr><td><code id="combineByEitherFactor_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
<tr><td><code id="combineByEitherFactor_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="combineByEitherFactor_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix containing both selected columns plus additional column(s) indicating group-number of the pair-wise combination 
(and optional the total n by group)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nn &lt;- rep(c("a","e","b","c","d","g","f"),c(3,1,2,2,1,2,1))
qq &lt;- rep(c("m","n","p","o","q"),c(2,1,1,4,4))
nq &lt;- cbind(nn,qq)[c(4,2,9,11,6,10,7,3,5,1,12,8),]
combineByEitherFactor(nq,1,2,nBy=TRUE); combineByEitherFactor(nq,1,2,nBy=FALSE)
combineByEitherFactor(nq,1,2,conv=FALSE); combineByEitherFactor(nq,1,2,conv=TRUE)
##
mm &lt;- rep(c("a","b","c","d","e"),c(3,4,2,3,1)); pp &lt;- rep(c("m","n","o","p","q"),c(2,2,2,2,5))
combineByEitherFactor(cbind(mm,pp), 1, 2, con=FALSE, nBy=TRUE)
combineByEitherFactor(cbind(mm,pp), 1, 2, con=TRUE, nBy=TRUE) 
</code></pre>

<hr>
<h2 id='combineOverlapInfo'>Find and combine points located very close in x/y space</h2><span id='topic+combineOverlapInfo'></span>

<h3>Description</h3>

<p>Search points in x,y space that are located very close and thus likely to overlap.
In case of points close enough, various options for joining names (and shortening longer descriptions) are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineOverlapInfo(
  dat,
  suplInfo = NULL,
  disThr = 0.01,
  addNsimil = TRUE,
  txtSepChar = ",",
  combSym = "+",
  maxOverl = 50,
  callFrom = NULL,
  debug = FALSE,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineOverlapInfo_+3A_dat">dat</code></td>
<td>
<p>(matrix) matrix or data.frame with 2 cols (used ONLY 1st &amp; 2nd column !), used as x &amp; y coordinates</p>
</td></tr>
<tr><td><code id="combineOverlapInfo_+3A_suplinfo">suplInfo</code></td>
<td>
<p>(NULL or character) when points are considered overlapping the text from 'suplInfo' will be reduced to fragment before 'txtSepChar' and combined (with others from overlapping text) using 'combSym', if NULL $combInf will appear with row-numbers</p>
</td></tr>
<tr><td><code id="combineOverlapInfo_+3A_disthr">disThr</code></td>
<td>
<p>(numeric) distance-thrshold for considering as similar via searchDataPairs()</p>
</td></tr>
<tr><td><code id="combineOverlapInfo_+3A_addnsimil">addNsimil</code></td>
<td>
<p>(logical) include number of fused points</p>
</td></tr>
<tr><td><code id="combineOverlapInfo_+3A_txtsepchar">txtSepChar</code></td>
<td>
<p>(character) for use with .retain1stPart(): where to cut (&amp; keep 1st part) text from 'suplInfo' to return in out$CombInf; only 1st element used !</p>
</td></tr>
<tr><td><code id="combineOverlapInfo_+3A_combsym">combSym</code></td>
<td>
<p>(character) concatenation symbol (character, length=1) for points considered overlaying, see also 'suplInfo'</p>
</td></tr>
<tr><td><code id="combineOverlapInfo_+3A_maxoverl">maxOverl</code></td>
<td>
<p>(integer) if NULL no limit or max limit of group/clu size (avoid condensing too many neighbour points to single cloud)</p>
</td></tr>
<tr><td><code id="combineOverlapInfo_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
<tr><td><code id="combineOverlapInfo_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="combineOverlapInfo_+3A_silent">silent</code></td>
<td>
<p>(logical) suppres messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with fused (condensed) information for cluster of overapping points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2013)
datT2 &lt;- matrix(round(rnorm(200)+3,1),ncol=2,dimnames=list(paste("li",1:100,sep=""),
  letters[23:24]))
# (mimick) some short and longer names for each line
inf2 &lt;- cbind(sh=paste(rep(letters[1:4],each=26),rep(letters,4),1:(26*4),sep=""),
 lo=paste(rep(LETTERS[1:4],each=26),rep(LETTERS,4),1:(26*4),",",rep(letters[sample.int(26)],4),
  rep(letters[sample.int(26)],4),sep=""))[1:100,] 
head(datT2,n=10)
head(combineOverlapInfo(datT2,disThr=0.03),n=10)
head(combineOverlapInfo(datT2,suplI=inf2[,2],disThr=0.03),n=10)
</code></pre>

<hr>
<h2 id='combineRedBasedOnCol'>Combine/reduce redundant lines based on specified column</h2><span id='topic+combineRedBasedOnCol'></span>

<h3>Description</h3>

<p>This function works similar to <code>unique</code>, but it takes a matrix as input and considers one specified column to find unique instances.
It identifies 'repeated' lines of the input-matrix (or data.frame) 'mat' based on (repeated) elements in/of column with name 'colNa' (or column-number).
Redundant lines (ie repeated lines) will disappear in output.
Eg used with extracted annotation where 1 gene has many lines for different GO annotation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineRedBasedOnCol(mat, colNa, sep = ",", silent = FALSE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineRedBasedOnCol_+3A_mat">mat</code></td>
<td>
<p>input matrix or data.frame</p>
</td></tr>
<tr><td><code id="combineRedBasedOnCol_+3A_colna">colNa</code></td>
<td>
<p>character vector (length 1) macting 1 column name (if mult only 1st will be used), in case of mult matches only 1st used</p>
</td></tr>
<tr><td><code id="combineRedBasedOnCol_+3A_sep">sep</code></td>
<td>
<p>(character) separator (default=&quot;,&quot;)</p>
</td></tr>
<tr><td><code id="combineRedBasedOnCol_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="combineRedBasedOnCol_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix containing the input matrix without lines considered repeated (unique-like)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findRepeated">findRepeated</a></code>, <code><a href="#topic+firstOfRepLines">firstOfRepLines</a></code>, <code><a href="#topic+organizeAsListOfRepl">organizeAsListOfRepl</a></code>, <code><a href="#topic+combineRedundLinesInList">combineRedundLinesInList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>matr &lt;- matrix(c(letters[1:6],"h","h","f","e",LETTERS[1:5]),ncol=3,
  dimnames=list(letters[11:15],c("xA","xB","xC")))
combineRedBasedOnCol(matr,colN="xB")
combineRedBasedOnCol(rbind(matr[1,],matr),colN="xB")
</code></pre>

<hr>
<h2 id='combineRedundLinesInList'>Combine Redundant Lines In List</h2><span id='topic+combineRedundLinesInList'></span>

<h3>Description</h3>

<p>This function provides help for combining/summarizing lines of numeric data which may be summaried according to reference vector or matrix of annotation (part of the same input-list).
The data and reference will be aligned and data corresponding to redundant information be combined/summarized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineRedundLinesInList(
  lst,
  refNa = "ref",
  datNa = "quant",
  refColNa = "GeneName",
  supRefColNa = NULL,
  summarizeType = "av",
  NA.rm = TRUE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineRedundLinesInList_+3A_lst">lst</code></td>
<td>
<p>(list) main input, containing matrix or data.frame of numeric data (see <code>datNa</code> and annotation (see <code>refNa</code>) and possibly unrelated stuff</p>
</td></tr>
<tr><td><code id="combineRedundLinesInList_+3A_refna">refNa</code></td>
<td>
<p>(character) name of list-element containing annotation</p>
</td></tr>
<tr><td><code id="combineRedundLinesInList_+3A_datna">datNa</code></td>
<td>
<p>(character) name(s) of list-element(s) containing numeric/quantitation data</p>
</td></tr>
<tr><td><code id="combineRedundLinesInList_+3A_refcolna">refColNa</code></td>
<td>
<p>(character) in case the list-element to be used as reference is <code>matrix</code> or <code>data.frame</code>, the column to be used must be specified here</p>
</td></tr>
<tr><td><code id="combineRedundLinesInList_+3A_suprefcolna">supRefColNa</code></td>
<td>
<p>(character) in case the <code>lst$refNa</code> has no rownames, the content of column <code>lst$supRefColNa</code> will be used instead</p>
</td></tr>
<tr><td><code id="combineRedundLinesInList_+3A_summarizetype">summarizeType</code></td>
<td>
<p>(character) the summarization method gets specified here; so far 'sum','av','med','first' and 'last' are implemented</p>
</td></tr>
<tr><td><code id="combineRedundLinesInList_+3A_na.rm">NA.rm</code></td>
<td>
<p>(logical) pass to summarizing functions order to omit <code>NA</code>s, defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="combineRedundLinesInList_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="combineRedundLinesInList_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="combineRedundLinesInList_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All input data should be in a list, ie one or multipl matrix or data.frame for numeric data (see argument <code>datNa</code>), as well as the reference (see argument <code>refNa</code>). 
The refgerence may be a named character vecor or a matrix for which the column to be used should be specified using the argument <code>refColNa</code>.
In case the annotation is a matrix, the rownames will be used as unique/independent identifyers to adjust potentially different order of numeric data and annotation.
In absence of rownames, an additional column  <code>supRefColNa</code> of the annotation may be designed for adjusting the order of annotation and numeric data.
</p>
<p>The numeric list may contain multiple matrixes or data.frames which will all be summarized by the same procedure as long as they have the same initial dimensions and are specified by <code>refNa</code>. 
</p>
<p>Please note that all other list elements from input not specified by <code>refNa</code> (or <code>datNa</code>) will be maintained in the output just as they are.
</p>


<h3>Value</h3>

<p>This function returns a list of same length as input
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findRepeated">findRepeated</a></code>, <code><a href="#topic+firstOfRepLines">firstOfRepLines</a></code>, <code><a href="#topic+organizeAsListOfRepl">organizeAsListOfRepl</a></code>, <code><a href="#topic+combineRedBasedOnCol">combineRedBasedOnCol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- list(quant=matrix(11:34, ncol=3, dimnames=list(letters[8:1], LETTERS[11:13])), 
  annot=matrix(paste0(LETTERS[c(1:4,6,3:5)],LETTERS[c(1:4,6,3:5)]), ncol=1, 
  dimnames=list(paste(letters[1:8]),"xx")) )
combineRedundLinesInList(lst=x1, refNa="annot", datNa="quant", refColNa="xx")
</code></pre>

<hr>
<h2 id='combineRedundLinesInListAcRef'>Combine Redundant Lines In List, Deprecated</h2><span id='topic+combineRedundLinesInListAcRef'></span>

<h3>Description</h3>

<p>The function combineRedundLinesInListAcRef() has been deprecated and replaced by combineRedundLinesInList() from the same package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineRedundLinesInListAcRef(
  lst,
  listNa = c("ref", "quant"),
  refColNa = "xx",
  summarizeType = "av",
  NA.rm = TRUE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineRedundLinesInListAcRef_+3A_lst">lst</code></td>
<td>
<p>(list) main input</p>
</td></tr>
<tr><td><code id="combineRedundLinesInListAcRef_+3A_listna">listNa</code></td>
<td>
<p>(character)   names of list-elements containing quantitation data (1st position) and protein/line annotation (2nd position)</p>
</td></tr>
<tr><td><code id="combineRedundLinesInListAcRef_+3A_refcolna">refColNa</code></td>
<td>
<p>(character) in case the list-element to be used as reference is <code>matrix</code> or <code>data.frame</code>, the column to be used must be specified here</p>
</td></tr>
<tr><td><code id="combineRedundLinesInListAcRef_+3A_summarizetype">summarizeType</code></td>
<td>
<p>(character) the summarization method gets specified here; so far 'sum','av','med','first' and 'last' are implemented</p>
</td></tr>
<tr><td><code id="combineRedundLinesInListAcRef_+3A_na.rm">NA.rm</code></td>
<td>
<p>(logical) pass to summarizing functions order to omit <code>NA</code>s, defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="combineRedundLinesInListAcRef_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="combineRedundLinesInListAcRef_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="combineRedundLinesInListAcRef_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list of same length as input
</p>


<h3>See Also</h3>

<p><code><a href="#topic+combineRedundLinesInList">combineRedundLinesInList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- list(quant=matrix(11:34, ncol=3, dimnames=list(letters[8:1], LETTERS[11:13])), 
  annot=matrix(paste0(LETTERS[c(1:4,6,3:5)],LETTERS[c(1:4,6,3:5)]), ncol=1, 
  dimnames=list(paste(letters[1:8]),"xx")) )
## please use combineRedundLinesInList()
combineRedundLinesInList(lst=x1, refNa="annot", datNa="quant", refColNa="xx")
</code></pre>

<hr>
<h2 id='combineReplFromListToMatr'>Combine replicates from list to matrix</h2><span id='topic+combineReplFromListToMatr'></span>

<h3>Description</h3>

<p>Suppose multiple measures (like multiple chanels) are taken for subjects and these measures are organized as groups in a list, 
like muliple parameters (= channels) or types of measurements (typically many paramters are recorded when screeinig compounds in microtiter plates).
Within one parameter/channel all replicate-data from separate list-entries ('lst') will get combined according to names of list-elements.
The function will trim any redundant text in names of list-elements, try to isolate separator (may vary among replicate-groups, but should be 1 character long).
eg names &quot;hct116 1.1.xlsx&quot; &amp; &quot;hct116 1.2.xlsx&quot; will be combined as replicates, &quot;hct116 2.1.xlsx&quot; will be considered as new group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineReplFromListToMatr(lst, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineReplFromListToMatr_+3A_lst">lst</code></td>
<td>
<p>(list)  list of arrays (typically multi-parameter measures of micortiterplate data)</p>
</td></tr>
<tr><td><code id="combineReplFromListToMatr_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of arrays now with same dimension of arrays (but shorter, since replicate-arrays were combined)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extr1chan">extr1chan</a></code>, <code><a href="#topic+organizeAsListOfRepl">organizeAsListOfRepl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lst2 &lt;- list(aa_1x=matrix(1:12,nrow=4,byrow=TRUE),ab_2x=matrix(24:13,nrow=4,byrow=TRUE))
combineReplFromListToMatr(lst2)
</code></pre>

<hr>
<h2 id='combineSingleT'>Get all combinations with TRUE from each column</h2><span id='topic+combineSingleT'></span>

<h3>Description</h3>

<p>This function addresses the case when multiple alternatove ways exit to combine two elements. 
<code>combineSingleT</code> makes combinatory choices : if multiple <code>TRUE</code> in given column of 'mat' make all multiple selections with always one <code>TRUE</code> from each column
The resultant output contains index for first and second input columns elements to be combined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineSingleT(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineSingleT_+3A_mat">mat</code></td>
<td>
<p>2-column matrix of logical values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with indexes of conbinations of <code>TRUE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example: Fist column indicates which boys want to dance and second column  
## which girls want to dance. So if several boys want to dance each of the girls 
## will have the chance to dance with each of them.  
matr &lt;- matrix(c(TRUE,FALSE,TRUE,FALSE,TRUE,FALSE),ncol=2)
combineSingleT(matr)
</code></pre>

<hr>
<h2 id='completeArrLst'>Complete list of arrays for same dimensions</h2><span id='topic+completeArrLst'></span>

<h3>Description</h3>

<p>This functions aims to inspect repeating structues of data given as list of arrays and will try to complete 
arrays with fewer lines or columns (as this may appear eg with the very last set of high-thourput sceening data 
if fewer measures remain in the last set). Thus, the dimensions of the arrays are compared and 
cases with fewer (lost) columns (eg fewer experimental replicates) will be adjust/complete  by adding column(s) of NA.
Used eg when at reading mircotiterplate data the last set is not complete.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>completeArrLst(arrLst, silent = FALSE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="completeArrLst_+3A_arrlst">arrLst</code></td>
<td>
<p>(list) list of arrays (typically 1st and 2nd dim for specific genes/objects, 3rd for different measures associated with)</p>
</td></tr>
<tr><td><code id="completeArrLst_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="completeArrLst_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of arrays, now with same dimension of arrays
</p>


<h3>See Also</h3>

<p><code><a href="#topic+organizeAsListOfRepl">organizeAsListOfRepl</a></code>, <code><a href="#topic+extr1chan">extr1chan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>arr1 &lt;- array(1:24,dim=c(4,3,2),dimnames=list(c(LETTERS[1:4]),
  paste("col",1:3,sep=""),c("ch1","ch2")))
arr3 &lt;- array(81:96,dim=c(4,2,2),dimnames=list(c(LETTERS[1:4]),
  paste("col",1:2,sep=""),c("ch1","ch2")))
arrL3 &lt;- list(pl1=arr1,pl3=arr3)
completeArrLst(arrL3)
</code></pre>

<hr>
<h2 id='concatMatch'>Value Matching With Option For Concatenated Terms</h2><span id='topic+concatMatch'></span>

<h3>Description</h3>

<p>This is a _match()_-like function allowing to serach among concatenated terms/IDs, additional options to remove text pattern like terminal lowercase extesion are available.
The function returns a named vector indicating the positions of (first) matches similar to <code><a href="base.html#topic+match">match</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concatMatch(
  x,
  table,
  sep = ",",
  sepPattern = NULL,
  globalPat = "digitExtension",
  nomatch = NA_integer_,
  incomparables = NULL,
  extensPat = TRUE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concatMatch_+3A_x">x</code></td>
<td>
<p>(vector) the values to be matched</p>
</td></tr>
<tr><td><code id="concatMatch_+3A_table">table</code></td>
<td>
<p>(vector) the values to be matched against (ie reference)</p>
</td></tr>
<tr><td><code id="concatMatch_+3A_sep">sep</code></td>
<td>
<p>(character) separator character in case concatenation of entries is tested</p>
</td></tr>
<tr><td><code id="concatMatch_+3A_seppattern">sepPattern</code></td>
<td>
<p>(character or <code>NULL</code>) optional custom  pattern for splitting concatenations of <code>x</code>) and <code>table</code>) (in case <code>NULL</code>) is not sufficient)</p>
</td></tr>
<tr><td><code id="concatMatch_+3A_globalpat">globalPat</code></td>
<td>
<p>(character) pattern for additional trimming of serach-terms. If <code>globalPat="digitExtension"</code> all terminal digits will not be considered when matching</p>
</td></tr>
<tr><td><code id="concatMatch_+3A_nomatch">nomatch</code></td>
<td>
<p>(vector) similar to <code><a href="base.html#topic+match">match</a></code> the value to be returned in the case when no match is found</p>
</td></tr>
<tr><td><code id="concatMatch_+3A_incomparables">incomparables</code></td>
<td>
<p>(vector) similar to <code><a href="base.html#topic+match">match</a></code>, a vector of values that cannot be matched. Any value in x matching a value in this vector is assigned the nomatch value.</p>
</td></tr>
<tr><td><code id="concatMatch_+3A_extenspat">extensPat</code></td>
<td>
<p>(logical) similar to <code><a href="base.html#topic+match">match</a></code> the value to be returned in the case when no match is found</p>
</td></tr>
<tr><td><code id="concatMatch_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="concatMatch_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="concatMatch_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main motivation to create this function was to be able to treat concatenated entries and to look if <code>any</code> of the concatenated values match to 'x'.
This function offers additional options for trimming values before running the main comparison.
</p>
<p>Of course, the concatenation strategy must be known and only a single concatenation separator (which may be multiple characters long) may be used for both <code>x</code> and <code>match</code>.
Thus result will only indicate that at least one of the concatenated terms had a match, but not which one.
Finally, both vectors <code>x</code> and <code>table</code> may contain concatenated terms.
In this case this function will require much more computational ressources due to the increased combinatorics when comparing larger vectors.
</p>
<p>Please note, that in case of multiple to multiple matches, only the first hit gets reported.
</p>
<p>The argument <code>globalPat="digitExtension"</code> allows eg reducing 'A1234-4' to 'A1234'.
</p>


<h3>Value</h3>

<p>This function returns a character vector with verified path and file-name(s), returns <code>NULL</code> if nothing
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+match">match</a></code> (for two simple vectors without concatenated terms), <code><a href="base.html#topic+grep">grep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tab1 &lt;- c("AA","BB-5","CCab","FF")
tab2 &lt;- c("AA","WW,Vde,BB-5,E","CCab","FF,Uef")
x1 &lt;- c("ZZ","YY","AA","BB-2","DD","CCdef","Dxy")            # modif of single ID (no concat)
concatMatch(x1, tab2)
x2 &lt;- c("ZZ,Z","YY,Y","AA,Z,Y","BB-2","DD","X,CCdef","Dxy")  # conatenated in 'x'
concatMatch(x2, tab2)
tab1 &lt;- c("AA","BB-5","CCab","FF")              # no conatenated in 'table'
concatMatch(x2, tab1)                          # simple case of no concat anywhere
concatMatch(x1, tab1)
</code></pre>

<hr>
<h2 id='confInt'>Confidence Interval To Given Alpha</h2><span id='topic+confInt'></span>

<h3>Description</h3>

<p>This little function returns the confidence interval associated to a given significance level <code>alpha</code> under the hypothesis of the Normal distribution is valid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confInt(x, alpha = 0.05, distrib = "Normal", silent = FALSE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confInt_+3A_x">x</code></td>
<td>
<p>(numeric) main input</p>
</td></tr>
<tr><td><code id="confInt_+3A_alpha">alpha</code></td>
<td>
<p>(numeric) significance level, accepted type I error</p>
</td></tr>
<tr><td><code id="confInt_+3A_distrib">distrib</code></td>
<td>
<p>(character) distribution, so far only <code>Normal</code> is implemented</p>
</td></tr>
<tr><td><code id="confInt_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="confInt_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the confidence interval to a given <code>alpha</code> under the hypothesis of the Normal distribution.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+TDist">TDist</a></code>; <code><a href="stats.html#topic+confint">confint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
confInt(c(5,2:6))

</code></pre>

<hr>
<h2 id='contribToContigPerFrag'>Characterize individual contribution of single edges in tree-structures</h2><span id='topic+contribToContigPerFrag'></span>

<h3>Description</h3>

<p>This function helps investigating tree-like structures with the aim of indicating how much individual tree components contribute 
to compose long stretches.
<code>contribToContigPerFrag</code> characterizes individual (isolated) contribution of single edges in tree-structures. 
Typically used to process/exploit summarized trees (as matrix) made by <code><a href="#topic+buildTree">buildTree</a></code> which makes use of the package <a href="https://CRAN.R-project.org/package=data.tree">data.tree</a>.
For example if A,B and C can be joined aa well and B +D, this function will check if A+B+C is longer and if A contributes to the longest tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contribToContigPerFrag(joinMat, fullLength = NULL, nDig = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contribToContigPerFrag_+3A_joinmat">joinMat</code></td>
<td>
<p>(matrix) matrix with concatenated edges as rownames (separated by slashes), column <code>sumLen</code> for total length and column <code>n</code> for number of edges</p>
</td></tr>
<tr><td><code id="contribToContigPerFrag_+3A_fulllength">fullLength</code></td>
<td>
<p>(integer) custom total length (useful if the concatenated edges do not cover 100 percent of the original precursor whose fragments are studied)</p>
</td></tr>
<tr><td><code id="contribToContigPerFrag_+3A_ndig">nDig</code></td>
<td>
<p>(integer) rounding: number of digits for 3rd column <code>len.rat</code> in output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of 3 columns: with length of longest tree-branches where given edge participates (column <code>sumLen</code>), the (total) number of edges therein (col <code>n.frag</code>) and a relative value (<code>len.rat</code>)
</p>


<h3>See Also</h3>

<p>to build tree <code><a href="#topic+buildTree">buildTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path1 &lt;- matrix(c(17,19,18,17, 4,4,2,3),ncol=2,
  dimnames=list(c("A/B/C/D","A/B/G/D","A/H","A/H/I"),c("sumLen","n")))
contribToContigPerFrag(path1)
</code></pre>

<hr>
<h2 id='conv01toColNa'>Convert matrix of integer to matrix of x-times repeated column-names</h2><span id='topic+conv01toColNa'></span>

<h3>Description</h3>

<p><code>conv01toColNa</code> transforms matrix of integers (eg 0 and 1) to repeated &amp; concatenated text from argument <code>colNa</code>, 
the character string for 0 occurances of argument <code>zeroTex</code> may be customized.
Used eg when specifying (and concatenating) various counted elements (eg properties) along a vector like variable peptide modifications in proteomics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conv01toColNa(mat, colNa = NULL, zeroTex = "", pasteCol = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conv01toColNa_+3A_mat">mat</code></td>
<td>
<p>input matrix (with integer values)</p>
</td></tr>
<tr><td><code id="conv01toColNa_+3A_colna">colNa</code></td>
<td>
<p>alternative (column-)names to the ones from 'mat' (default colnames of 'mat')</p>
</td></tr>
<tr><td><code id="conv01toColNa_+3A_zerotex">zeroTex</code></td>
<td>
<p>text to display if 0 (default &quot;&quot;)</p>
</td></tr>
<tr><td><code id="conv01toColNa_+3A_pastecol">pasteCol</code></td>
<td>
<p>(logical) allows to collapse all columns to single chain of characters in output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(ma1 &lt;- matrix(sample(0:3,40,repl=TRUE), ncol=4, dimnames=list(NULL, letters[11:14])))
conv01toColNa(ma1)
conv01toColNa(ma1, colNa=LETTERS[1:4], ze=".")
conv01toColNa(ma1, colNa=LETTERS[1:4], pasteCol=TRUE)
</code></pre>

<hr>
<h2 id='convColorToTransp'>Assign new transparency to given colors</h2><span id='topic+convColorToTransp'></span>

<h3>Description</h3>

<p>This function alows (re-)defining a new transparency. A color encoding vector will be transformed to the same color(s) but with new transparency (alpha).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convColorToTransp(color, alph = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convColorToTransp_+3A_color">color</code></td>
<td>
<p>(character) color input</p>
</td></tr>
<tr><td><code id="convColorToTransp_+3A_alph">alph</code></td>
<td>
<p>(numeric) transparency value (1 for no transparency, 0 for complete opaqueness), values &lt;1 will be treated as percent-values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector (of same length as input) with color encoding for new transparency
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+rgb">rgb</a></code>, <code><a href="graphics.html#topic+par">par</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>col0 &lt;- c("#998FCC","#5AC3BA","#CBD34E","#FF7D73")
col1 &lt;- convColorToTransp(col0,alph=0.7)
layout(1:2)
pie(rep(1,length(col0)),col=col0)
pie(rep(1,length(col1)),col=col1,main="new transparency")
</code></pre>

<hr>
<h2 id='convMatr2df'>Convert matrix (eg with redundant) row-names to data.frame</h2><span id='topic+convMatr2df'></span>

<h3>Description</h3>

<p>This function provides flexible converting of matrix to data.frame. 
For example repeated/redundant rownames are not allowed in data.frame(), thus the corresponding column-names have to be renamed using a counter-suffix.
In case of non-redundant rownames, a new column 'addIniNa' will be introduced at beginning to document the initial (redundant) rownames, 
non-redundant rownames will be created.
Finally, this functions converts the corrected matrix to data.frame and checks/converts columns for transforming character to numeric if possible. 
If the input is a data.frame containing factors, they will be converted to character before potential conversion.
Note: for simpler version (only text to numeric) see from this package <code>.convertMatrToNum</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convMatr2df(
  mat,
  addIniNa = TRUE,
  duplTxtSep = "_",
  silent = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convMatr2df_+3A_mat">mat</code></td>
<td>
<p>matrix (or data.frame) to be converted</p>
</td></tr>
<tr><td><code id="convMatr2df_+3A_addinina">addIniNa</code></td>
<td>
<p>(logical) if <code>TRUE</code> an additional column ('ID') with rownames will be added at beginning</p>
</td></tr>
<tr><td><code id="convMatr2df_+3A_dupltxtsep">duplTxtSep</code></td>
<td>
<p>(character) separator for enumerating replicated names</p>
</td></tr>
<tr><td><code id="convMatr2df_+3A_silent">silent</code></td>
<td>
<p>(logical) suppres messages</p>
</td></tr>
<tr><td><code id="convMatr2df_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This functions returns a data.frame equivalent to the input matrix, an additional column named 'ID' will be added for initial rownames
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+numeric">numeric</a></code>, for simpler version (only text to numeric) see from this package <code>.convertMatrToNum</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat1 &lt;- matrix(1:10, ncol=2)
rownames(dat1) &lt;- letters[c(1:3,2,5)]
## as.data.frame(dat1)  ...  would result in an error
convMatr2df(dat1)

df1 &lt;- data.frame(a=as.character((1:3)/2), b=LETTERS[1:3], c=1:3)
str(convMatr2df(df1))

df2 &lt;- df1; df2$b &lt;- as.factor(df2$b)
str(convMatr2df(df2))
</code></pre>

<hr>
<h2 id='convToNum'>Convert vector to numeric</h2><span id='topic+convToNum'></span>

<h3>Description</h3>

<p>This function checks if input vector/character string contains numbers (with or without comma) and attempts converting to numeric.
This functions was designed for extracting the numeric part of character-vectors (or matrix) containing both numbers and character-elements.
Depending on the parameters <code>convert</code> and <code>remove</code> text-entries can be converted to NA (in resulting numeric objects) or removed (the number of elements/lines gets reduced, in consequece). 
Note: if 'x' is a matrix, its matrix-dimensions &amp; -names will be preserved.
Note: so far Inf  and -Inf do not get recognized as numeric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convToNum(
  x,
  autoConv = TRUE,
  spaceRemove = TRUE,
  convert = c(NA, "sparseChar"),
  remove = NULL,
  euroStyle = TRUE,
  sciIncl = TRUE,
  callFrom = NULL,
  silent = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convToNum_+3A_x">x</code></td>
<td>
<p>vector to be converted</p>
</td></tr>
<tr><td><code id="convToNum_+3A_autoconv">autoConv</code></td>
<td>
<p>(logical) simple automatic conversion based on <code>as.numeric</code>; if <code>TRUE</code> all other arguments exept  <code>spaceRemove</code> will not be considered</p>
</td></tr>
<tr><td><code id="convToNum_+3A_spaceremove">spaceRemove</code></td>
<td>
<p>(logical) to remove all heading and trailing (white) space (until first non-space character)</p>
</td></tr>
<tr><td><code id="convToNum_+3A_convert">convert</code></td>
<td>
<p>(character) define which type of non-conform entries to convert to NAs. Note, if <code>remove</code> is selected to eliminate character-entries they cannot be converted any more. Use 'allChar' for all character-entries; 'sparseChar' sparse (ie rare) character entries; <code>NA</code> for converting 'Na' or 'na' to <code>NA</code>; if 'none' or <code>NULL</code> no conversions at all.</p>
</td></tr>
<tr><td><code id="convToNum_+3A_remove">remove</code></td>
<td>
<p>(character) define which type of non-conform entries to remove, removed items cannot be converted to <code>NA</code> any more. Use 'allChar' for removing all character entries; <code>NA</code> for removing all instances of <code>NA</code> (execept thise created by converting text); all elements will be kept if 'none' or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="convToNum_+3A_eurostyle">euroStyle</code></td>
<td>
<p>(logical) if <code>TRUE</code> will convert all ',' (eg used as European decimal-separator) to '.' (as internally used by R as decimal-separator), thus allowing converting the European decimal format.</p>
</td></tr>
<tr><td><code id="convToNum_+3A_sciincl">sciIncl</code></td>
<td>
<p>(logical) include recognizing scientific notation (eg 2e-4)</p>
</td></tr>
<tr><td><code id="convToNum_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
<tr><td><code id="convToNum_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function may be used in two modes, depening if argument <code>autoConv</code> is <code>TRUE</code> or <code>FALSE</code>.
The first options allows accessing an automatic mode based on <code>as.numeric</code>, 
while the second options investigates all characters if they may belong to numeric expressions and allows removing specific text-elements.
</p>


<h3>Value</h3>

<p>This function returns a numeric vector (or matrix (if 'x' is matrix))
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+numeric">numeric</a></code> and <code>as.numeric</code> (on same help-page)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- c("+4"," + 5","6","bb","Na","-7") 
convToNum(x1) 
convToNum(x1, autoConv=FALSE, convert=c("allChar"))
convToNum(x1, autoConv=FALSE)      # too many non-numeric instances for 'sparseChar'

x2 &lt;- c("+4"," + 5","6","-7"," - 8","1e6","+ 2.3e4","-3E4","- 4E5") 
convToNum(x2) 
convToNum(x2, autoConv=FALSE, convert=NA,remove=c("allChar",NA))
convToNum(x2, autoConv=FALSE, convert=NA,remove=c("allChar",NA),sciIncl=FALSE)
</code></pre>

<hr>
<h2 id='coordOfFilt'>get coordinates of values/points in matrix according to filtering condition</h2><span id='topic+coordOfFilt'></span>

<h3>Description</h3>

<p>Get coordinates of values/points in matrix according to filtering condition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coordOfFilt(mat, cond, sortByRows = FALSE, silent = FALSE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coordOfFilt_+3A_mat">mat</code></td>
<td>
<p>(matrix or data.frame) matrix or data.frame</p>
</td></tr>
<tr><td><code id="coordOfFilt_+3A_cond">cond</code></td>
<td>
<p>(logical or integer) condition/test to see which values of <code>mat</code> fulfull test, or integer of index passing</p>
</td></tr>
<tr><td><code id="coordOfFilt_+3A_sortbyrows">sortByRows</code></td>
<td>
<p>(logical) optional sorting of results by row-index</p>
</td></tr>
<tr><td><code id="coordOfFilt_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="coordOfFilt_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix columns 'row' and 'col'
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+which">which</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2021); ma1 &lt;- matrix(sample.int(n=40,size=27,replace=TRUE), ncol=9)
## let's test which values are &gt;37
which(ma1 &gt;37)      # doesn't tell which row &amp; col
coordOfFilt(ma1, ma1 &gt;37)

</code></pre>

<hr>
<h2 id='correctToUnique'>Correct vector to unique</h2><span id='topic+correctToUnique'></span>

<h3>Description</h3>

<p><code>correctToUnique</code> checks 'x' for unique entries, while maintaining the original length. If necessary a counter will added to non-unique entries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correctToUnique(
  x,
  sep = "_",
  atEnd = TRUE,
  maxIter = 4,
  NAenum = TRUE,
  silent = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correctToUnique_+3A_x">x</code></td>
<td>
<p>input character vector</p>
</td></tr>
<tr><td><code id="correctToUnique_+3A_sep">sep</code></td>
<td>
<p>(character) separator used when adding counter</p>
</td></tr>
<tr><td><code id="correctToUnique_+3A_atend">atEnd</code></td>
<td>
<p>(logical) decide location of placing the counter (at end or at beginning of initial text)</p>
</td></tr>
<tr><td><code id="correctToUnique_+3A_maxiter">maxIter</code></td>
<td>
<p>(numeric) max number of iterations</p>
</td></tr>
<tr><td><code id="correctToUnique_+3A_naenum">NAenum</code></td>
<td>
<p>(logical) if <code>TRUE</code> all <code>NA</code>s will be enumerated (NA_1,NA_2,...)</p>
</td></tr>
<tr><td><code id="correctToUnique_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="correctToUnique_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) for better tracking of use of functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a character vector
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+unique">unique</a></code> will simply remove repeated elements, ie length of 'x' won't remain constant, <code><a href="#topic+filtSizeUniq">filtSizeUniq</a></code> is more complex and slower, <code><a href="#topic+treatTxtDuplicates">treatTxtDuplicates</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>correctToUnique(c("li0","n",NA,NA,rep(c("li2","li3"),2),rep("n",4))) 
</code></pre>

<hr>
<h2 id='correctWinPath'>Correct mixed slash and backslash in file path</h2><span id='topic+correctWinPath'></span>

<h3>Description</h3>

<p>This function corrects paths character strings for mixed slash and backslash in file path.
In Windows the function <code>tempdir()</code> will use double backslashes as separator while <code>file.path()</code> uses regular slashes.
So when combining these two one might encounter a mix of slashes and double backslashes which may cause trouble, unless this is streightened out to a single separator used.
When pointig to given files inside html-files, paths need to have a prefix, this can be added using the argument <code>asHtml</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correctWinPath(
  x,
  asHtml = FALSE,
  anyPlatf = FALSE,
  silent = TRUE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correctWinPath_+3A_x">x</code></td>
<td>
<p>(character) input path to test and correct</p>
</td></tr>
<tr><td><code id="correctWinPath_+3A_ashtml">asHtml</code></td>
<td>
<p>(logical) option for use in html : add prefix &quot;file:/&quot;</p>
</td></tr>
<tr><td><code id="correctWinPath_+3A_anyplatf">anyPlatf</code></td>
<td>
<p>(logical) if <code>TRUE</code>, checking will only be performed in Windows environement</p>
</td></tr>
<tr><td><code id="correctWinPath_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="correctWinPath_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector with corrected path
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+tempfile">tempfile</a></code>, <code><a href="base.html#topic+file.path">file.path</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path1 &lt;- 'D:\\temp\\Rtmp6X8/working_dir\\RtmpKC/example.txt'
(path1b &lt;- correctWinPath(path1, anyPlatf=TRUE)) 
(path1h &lt;- correctWinPath(path1, anyPlatf=TRUE, asHtml=TRUE)) 
</code></pre>

<hr>
<h2 id='countCloseToLimits'>Count from two vectors number of values close within given limits</h2><span id='topic+countCloseToLimits'></span>

<h3>Description</h3>

<p>This functions summarizes the serach of similar (or identical) numeric values from 2 initial vectors, it 
evaluates the result from initial search run by findCloseMatch(), whose output is a less convenient list.
<code>countCloseToLimits</code> checks furthermore how many results within additional (more stringent)
distance-limits may be found and returns the number of distance values within the limits tested.
Designed for checking if threshold used with findCloseMatch() may be set more stringent, eg  when searching reasonable FDR limits ...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countCloseToLimits(closeMatch, limitIdent = 5, prefix = "lim_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="countCloseToLimits_+3A_closematch">closeMatch</code></td>
<td>
<p>(list) output from findCloseMatch(), ie list indicating which instances of 2 series of data have close matches</p>
</td></tr>
<tr><td><code id="countCloseToLimits_+3A_limitident">limitIdent</code></td>
<td>
<p>(numeric) max limit or panel of threshold values to test (if single value, in addtion a panel with values below will be tested)</p>
</td></tr>
<tr><td><code id="countCloseToLimits_+3A_prefix">prefix</code></td>
<td>
<p>(character)  prefix for names of output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector with counts for number of list-elements with at least one absolue value below threshold, names
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findCloseMatch">findCloseMatch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2019); aa &lt;- sample(12:15,20,repl=TRUE) +round(runif(20),2)-0.5
bb &lt;- 11:18
match1 &lt;- findCloseMatch(aa,bb,com="diff",lim=0.65)
head(match1)
(tmp3 &lt;- countCloseToLimits(match1,lim=c(0.5,0.35,0.2)))
(tmp4 &lt;- countCloseToLimits(match1,lim=0.7))
</code></pre>

<hr>
<h2 id='countSameStartEnd'>Count same start- and end- sites of edges (or fragments)</h2><span id='topic+countSameStartEnd'></span>

<h3>Description</h3>

<p>Suppose a parent sequence/string 'ABCDE' gets cut in various fragments (eg 'ABC','AB' ...).   
<code>countSameStartEnd</code> counts how many (ie re-occuring) start- and end- sites of edges do occur in the input-data. 
The input is presented as matrix of/indicating start- and end-sites of edges.
The function is used to characterize partially redundant edges and accumulation of cutting/breakage sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countSameStartEnd(frag, minFreq = 2, nDig = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="countSameStartEnd_+3A_frag">frag</code></td>
<td>
<p>(matrix) 1st column <code>beg</code> start-sites, 2nd column <code>end</code> end-sites of edges, rownames to precise fragment identities are recommended</p>
</td></tr>
<tr><td><code id="countSameStartEnd_+3A_minfreq">minFreq</code></td>
<td>
<p>(integer) min number of accumulated sites for taking into account (allows filtering with large datasets)</p>
</td></tr>
<tr><td><code id="countSameStartEnd_+3A_ndig">nDig</code></td>
<td>
<p>(integer) rounding: number of digits for columns <code>beg.rat</code> and <code>end.rat</code> in output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of 6 columns: input (beg and end), beg.n, beg.rat, end.n, end.rat
</p>


<h3>See Also</h3>

<p>to build initial tree <code><a href="#topic+buildTree">buildTree</a></code>, <code><a href="#topic+contribToContigPerFrag">contribToContigPerFrag</a></code>, <code><a href="#topic+simpleFragFig">simpleFragFig</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>frag1 &lt;- cbind(beg=c(2,3,7,13,13,15,7,9,7, 3,3,5), end=c(6,12,8,18,20,20,19,12,12, 4,5,7))
rownames(frag1) &lt;- letters[1:nrow(frag1)]
countSameStartEnd(frag1)
simpleFragFig(frag1)
</code></pre>

<hr>
<h2 id='cutArrayInCluLike'>Cut 3-dim array in list of matrixes (or arrays) similar to organizing into clusters</h2><span id='topic+cutArrayInCluLike'></span>

<h3>Description</h3>

<p><code>cutArrayInCluLike</code> cuts 'dat' (matrix,data.frame or 3-dim array) in list (of appended lines) according to 'cluOrg', 
which serves as instruction which line of 'dat' should be placed in which list-element (like sorting according to cluster-numbers).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutArrayInCluLike(dat, cluOrg, silent = FALSE, debug = FALSE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutArrayInCluLike_+3A_dat">dat</code></td>
<td>
<p>array (3 dim)</p>
</td></tr>
<tr><td><code id="cutArrayInCluLike_+3A_cluorg">cluOrg</code></td>
<td>
<p>(factor) organization of lines to clusters</p>
</td></tr>
<tr><td><code id="cutArrayInCluLike_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="cutArrayInCluLike_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="cutArrayInCluLike_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function retruns a list of matrixes (or arrays)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat1 &lt;- matrix(1:30,nc=3,dimnames=list(letters[1:10],1:3))
cutArrayInCluLike(mat1,cluOrg=factor(c(2,rep(1:4,2),5)))
</code></pre>

<hr>
<h2 id='cutAtMultSites'>Cut character-vector at multiple sites</h2><span id='topic+cutAtMultSites'></span>

<h3>Description</h3>

<p>This function cuts character vector after 'cutAt' (ie keep the search subtsting 'cutAt', different to <code>strsplit</code>). 
Used for theoretical enzymatic digestion (eg in proteomics)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutAtMultSites(y, cutAt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutAtMultSites_+3A_y">y</code></td>
<td>
<p>character vector (better if of length=1, otherwise one won't know which fragment stems from which input)</p>
</td></tr>
<tr><td><code id="cutAtMultSites_+3A_cutat">cutAt</code></td>
<td>
<p>(character) search subtsting, ie 'cutting rule'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>modified (ie cut) character vector
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+strsplit">strsplit</a></code>, <code><a href="#topic+nFragments0">nFragments0</a></code>, <code><a href="#topic+nFragments">nFragments</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- "MSVSRTMEDSCELDLVYVTERIIAVSFPSTANEENFRSNLREVAQMLKSKHGGNYLLFNLSERRPDITKLHAKVLEFGWPDLHTPALEKI"
cutAtMultSites(c(tmp,"ojioRij"),c("R","K"))
</code></pre>

<hr>
<h2 id='cutToNgrp'>Cut numeric vector to n groups (ie convert to factor)</h2><span id='topic+cutToNgrp'></span>

<h3>Description</h3>

<p><code>cutToNgrp</code> is a more elaborate version of <code><a href="base.html#topic+cut">cut</a></code> for cutting a the content of a 
numeric vector '<code>x</code>' into a given number of groups, taken from the length of '<code>lev</code>'.
Besides, this function provides the group borders/limits for convention use with legends.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutToNgrp(x, lev, NAuse = FALSE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutToNgrp_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="cutToNgrp_+3A_lev">lev</code></td>
<td>
<p>(character or numeric), the length of this argument tells the number of groups to be used for cutting</p>
</td></tr>
<tr><td><code id="cutToNgrp_+3A_nause">NAuse</code></td>
<td>
<p>(logical) include NAs as separate group</p>
</td></tr>
<tr><td><code id="cutToNgrp_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) for better tracking of use of functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with <code>$grouped</code> telling which element of '<code>x</code>' goes in which group and <code>$legTxt</code> with gourp-borders for convenient use with legends
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+cut">cut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2019); dat &lt;- runif(30) +(1:30)/2
cutToNgrp(dat,1:5)
plot(dat,col=(1:5)[as.numeric(cutToNgrp(dat,1:5)$grouped)])
</code></pre>

<hr>
<h2 id='diffCombin'>Compute matrix of differences for all pairwise combinations of numeric vector</h2><span id='topic+diffCombin'></span>

<h3>Description</h3>

<p><code>diffCombin</code> returns matrix of differences (eg resulting from subsititution) for all pairwise combinations of numeric vector 'x'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffCombin(x, diagAsNA = FALSE, prefix = TRUE, silent = FALSE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffCombin_+3A_x">x</code></td>
<td>
<p>numeric vector to compute differences for all combinations</p>
</td></tr>
<tr><td><code id="diffCombin_+3A_diagasna">diagAsNA</code></td>
<td>
<p>(logical) return all self-self combinations as NA (otherwise 0)</p>
</td></tr>
<tr><td><code id="diffCombin_+3A_prefix">prefix</code></td>
<td>
<p>(logical) if TRUE, dimnames of output will specify orientation (prefix='from.' and 'to.')</p>
</td></tr>
<tr><td><code id="diffCombin_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="diffCombin_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix of all pairwise differences
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+diff">diff</a></code> for simple differences
</p>


<h3>Examples</h3>

<pre><code class='language-R'>diffCombin(c(10,11.1,13.3,16.6))
</code></pre>

<hr>
<h2 id='diffPPM'>Difference in ppm between numeric values</h2><span id='topic+diffPPM'></span>

<h3>Description</h3>

<p>This is a <code>diff()</code>-like function to return difference in ppm between subsequent values. 
Result is oriented, ie neg ppm value means decrease (from higher to lower value). Note that if the absolute difference remains the same the difference in ppm will not remain same.
Any difference to NA is returned as NA, thus a single NA will result in two NAs in output (unless NA is 1st or last).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffPPM(dat, toPrev = FALSE, silent = FALSE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffPPM_+3A_dat">dat</code></td>
<td>
<p>(numeric) vector for calculating difference to preceeding/following value in ppm</p>
</td></tr>
<tr><td><code id="diffPPM_+3A_toprev">toPrev</code></td>
<td>
<p>(logical) determine oriention</p>
</td></tr>
<tr><td><code id="diffPPM_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="diffPPM_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with close matches of 'x' to given 'y', the numeric value dependes on 'sortMatch' (if FALSE then always value of 'y' otherwise of longest of x&amp;y)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+checkSimValueInSer">checkSimValueInSer</a></code> and (from this package) <code>.compareByDiff</code>,  <code><a href="base.html#topic+diff">diff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aa &lt;- c(1000.01, 1000.02, 1000.05, 1000.08, 1000.09, 1000.08)
.compareByPPM(list(aa,aa), 30, TRUE)                    # tabular 'long' version
diffPPM(aa)
</code></pre>

<hr>
<h2 id='elimCloseCoord'>Eliminate close (overlapping) points (in x &amp; y space)</h2><span id='topic+elimCloseCoord'></span>

<h3>Description</h3>

<p><code>elimCloseCoord</code> reduces number of rows in 'dat' by eliminating lines where x &amp; y coordinates (columns of matrix '<code>dat</code>' defined by '<code>useCol</code>') are identical (overlay points) or very close.
The stringency for 'close' values may be fine-tuned using <code>nDig</code>), this function uses internally <code><a href="#topic+firstOfRepeated">firstOfRepeated</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elimCloseCoord(
  dat,
  useCol = 1:2,
  elimIdentOnly = FALSE,
  refine = 2,
  nDig = 3,
  callFrom = NULL,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elimCloseCoord_+3A_dat">dat</code></td>
<td>
<p>matrix (or data.frame) with main numeric input</p>
</td></tr>
<tr><td><code id="elimCloseCoord_+3A_usecol">useCol</code></td>
<td>
<p>(numeric) index for numeric columns of 'dat' to use/consider</p>
</td></tr>
<tr><td><code id="elimCloseCoord_+3A_elimidentonly">elimIdentOnly</code></td>
<td>
<p>(logical) if TRUE, eliminate real duplicated points only (ie identical values only)</p>
</td></tr>
<tr><td><code id="elimCloseCoord_+3A_refine">refine</code></td>
<td>
<p>(numeric) allows increasing stringency even further  (higher 'refine' .. more lines considered equal)</p>
</td></tr>
<tr><td><code id="elimCloseCoord_+3A_ndig">nDig</code></td>
<td>
<p>(integer) number of significant digits used for rounding, if two 'similar' values are identical after this rounding the second will be eliminated.</p>
</td></tr>
<tr><td><code id="elimCloseCoord_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of message(s) produced</p>
</td></tr>
<tr><td><code id="elimCloseCoord_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>resultant matrix/data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findCloseMatch">findCloseMatch</a></code>, <code><a href="#topic+firstOfRepeated">firstOfRepeated</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>da1 &lt;- matrix(c(rep(0:4,5),0.01,1.1,2.04,3.07,4.5),nc=2); da1[,1] &lt;- da1[,1]*99; head(da1)
elimCloseCoord(da1)
</code></pre>

<hr>
<h2 id='equLenNumber'>Equal character-length number</h2><span id='topic+equLenNumber'></span>

<h3>Description</h3>

<p><code>equLenNumber</code> convert numeric entry 'x' to text, with all elements getting the same number of characters (ie  by adding preceeding or tailing 0s, if needed).
So far, the function cannot handle scientific annotations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equLenNumber(x, silent = FALSE, callFrom = NULL, debug = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equLenNumber_+3A_x">x</code></td>
<td>
<p>(caracter) input vector</p>
</td></tr>
<tr><td><code id="equLenNumber_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="equLenNumber_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
<tr><td><code id="equLenNumber_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector formated as equal number of characters per value
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sprintf">sprintf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>equLenNumber(c(12,-3,321))
equLenNumber(c(12,-3.3,321))
</code></pre>

<hr>
<h2 id='exclExtrValues'>Exclude extreme values (based on distance to mean)</h2><span id='topic+exclExtrValues'></span>

<h3>Description</h3>

<p>This function aims to identify extreme values (values most distant to mean, thus potential outlyers), mark them as NA or directely exclude them (depending on '<code>showNAs</code>').
Note that every set of non-identical values will have at least one most extreme value. Extreme values are part of many distributions, they are not necessarily true outliers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exclExtrValues(
  dat,
  result = "val",
  CVlim = NULL,
  maxExcl = 1,
  showNA = FALSE,
  goodValues = TRUE,
  silent = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exclExtrValues_+3A_dat">dat</code></td>
<td>
<p>numeric vector, main input</p>
</td></tr>
<tr><td><code id="exclExtrValues_+3A_result">result</code></td>
<td>
<p>(character) may be 'val' for returning data without extreme values or 'pos' for returning position/index of extreme values</p>
</td></tr>
<tr><td><code id="exclExtrValues_+3A_cvlim">CVlim</code></td>
<td>
<p>(NULL or numeric) allows to retain extreme values only if a certain CV (for all 'dat') is exceeded (to avoid calling extreme values form homogenous data-sets)</p>
</td></tr>
<tr><td><code id="exclExtrValues_+3A_maxexcl">maxExcl</code></td>
<td>
<p>(integer) max number of elments to explude</p>
</td></tr>
<tr><td><code id="exclExtrValues_+3A_showna">showNA</code></td>
<td>
<p>(logical) will display extrelme values as NA</p>
</td></tr>
<tr><td><code id="exclExtrValues_+3A_goodvalues">goodValues</code></td>
<td>
<p>(logical) allows to display rather the good values instead of the extreme values</p>
</td></tr>
<tr><td><code id="exclExtrValues_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="exclExtrValues_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector wo extremle values or index-position of extreme values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+firstOfRepLines">firstOfRepLines</a></code>,  <code><a href="#topic+get1stOfRepeatedByCol">get1stOfRepeatedByCol</a></code> for treatment of matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(rnorm(30),-6,20)
exclExtrValues(x)
</code></pre>

<hr>
<h2 id='exponNormalize'>Normalize by adjusting exponent</h2><span id='topic+exponNormalize'></span>

<h3>Description</h3>

<p>This function normalizes 'dat' by optimizing exponent function (ie dat ^exp) to fit best to 'ref' (default: average of each line of 'dat').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exponNormalize(
  dat,
  useExpon,
  dynExp = TRUE,
  nStep = 20,
  startExp = 1,
  simMeas = "cor",
  refDat = NULL,
  refGrp = NULL,
  refLines = NULL,
  rSquare = FALSE,
  silent = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exponNormalize_+3A_dat">dat</code></td>
<td>
<p>matrix or data.frame of numeric data to be normalized</p>
</td></tr>
<tr><td><code id="exponNormalize_+3A_useexpon">useExpon</code></td>
<td>
<p>(numeric vector or matrix) exponent values to be tested</p>
</td></tr>
<tr><td><code id="exponNormalize_+3A_dynexp">dynExp</code></td>
<td>
<p>(logical) require 'useExpon' as 2 values (matrix), will gradually increase exponent from 1st to 2nd; may be matrix or data.frame for dynamic, 
in this case 1st line for exp for lowest data, 2nd line for highest</p>
</td></tr>
<tr><td><code id="exponNormalize_+3A_nstep">nStep</code></td>
<td>
<p>(integer) number of exponent variations (steps) when testing range from-to</p>
</td></tr>
<tr><td><code id="exponNormalize_+3A_startexp">startExp</code></td>
<td>
<p>(numeric)</p>
</td></tr>
<tr><td><code id="exponNormalize_+3A_simmeas">simMeas</code></td>
<td>
<p>(character) similarity metric to be used (so far only &quot;cor&quot;), if rSquare=TRRUE, the r-squared will be returned</p>
</td></tr>
<tr><td><code id="exponNormalize_+3A_refdat">refDat</code></td>
<td>
<p>(matrix or data.frame) if null average of each line from 'dat' will be used as reference in similarity measure</p>
</td></tr>
<tr><td><code id="exponNormalize_+3A_refgrp">refGrp</code></td>
<td>
<p>(factor) designing which col of 'ref' should be used with which col of 'dat' (length equal to number of cols in 'dat').
Note: 'refGrp' not yet coded optimally to extract numeric part of character vector, protential problems when all lines or cols of dat are NA</p>
</td></tr>
<tr><td><code id="exponNormalize_+3A_reflines">refLines</code></td>
<td>
<p>(NULL or integer) optional subset of lines to be considered (only) when determining normalization factors</p>
</td></tr>
<tr><td><code id="exponNormalize_+3A_rsquare">rSquare</code></td>
<td>
<p>(logical) if <code>TRUE</code>, add r-squared</p>
</td></tr>
<tr><td><code id="exponNormalize_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="exponNormalize_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This functuion returns a matrix of normalized data
</p>


<h3>See Also</h3>

<p>more eveolved than <code><a href="#topic+normalizeThis">normalizeThis</a></code> with arugment set to 'exponent'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016); dat1 &lt;- matrix(c(runif(200)+rep(1:10,20)),nc=10)
head(rowGrpCV(dat1,gr=gl(4,3,labels=LETTERS[1:4])[2:11]))
set.seed(2016); dat1 &lt;- c(0.1,0.2,0.3,0.5)*rep(c(1,10),each=4)
dat1 &lt;- matrix(round(c(sqrt(dat1),dat1^1.5,3*dat1+runif(length(dat1))),2),nc=3)
dat2a &lt;- exponNormalize(dat1[,1],useExpon=2,nSte=1,refD=dat1[,3])
layout(matrix(1:2,nc=2))
plot(dat1[,1],dat1[,3],type="b",main="init",ylab="ref") 
plot(dat2a$datNor[,1],dat1[,3],type="b",main="norm",ylab="ref")
dat2b &lt;- exponNormalize(dat1[,1],useExpon=c(1.7,2.3),nSte=5,refD=dat1[,3])
plot(dat1[,1],dat1[,3],type="b",main="init",ylab="ref")
plot(dat2b$datNor[,1],dat1[,3],type="b",main="norm",ylab="ref")

dat2c &lt;- exponNormalize(dat1[,-3],useExpon=matrix(c(1.7,2.3,0.6,0.8),nc=2),nSte=5,refD=dat1[,3]);
plot(dat1[,1],dat1[,3],type="b",main="init",ylab="ref ")
plot(dat2c$datNor[,1],dat1[,3],type="b",main="norm 1",ylab="ref")
plot(dat1[,2],dat1[,3],type="b",main="init",ylab="ref")
plot(dat2c$datNor[,2],dat1[,3],type="b",main="norm 2",ylab="ref"); 
</code></pre>

<hr>
<h2 id='extr1chan'>Extract just one series, ie channel, of list of arrays</h2><span id='topic+extr1chan'></span>

<h3>Description</h3>

<p>This function was designed for handeling measurements stored as list of multiple arrays, like eg compound-screens using microtiter-plates where multiple parameters ('channels') 
were recorded for each well (element).
The elements (eg compounds screened) are typcally stored in the 1st dimension of the arrays, the replicated in the secon dimension and different measure types/parameters in the 3rd chanel. 
In order to keep the structure of of individual microtiter-plates, typically each plate forms a separate array (of same dimensions) in a list.  
The this function allows extracting a single channel of the list of arrays (3rd dim of each array) and return row-appended matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extr1chan(arrLst, cha, na.rm = TRUE, rowSep = "__")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extr1chan_+3A_arrlst">arrLst</code></td>
<td>
<p>(list) list of arrays (typically 1st and 2nd dim for specific genes/objects, 3rd for different measures associated with)</p>
</td></tr>
<tr><td><code id="extr1chan_+3A_cha">cha</code></td>
<td>
<p>(integer) channel number</p>
</td></tr>
<tr><td><code id="extr1chan_+3A_na.rm">na.rm</code></td>
<td>
<p>(logical) default =TRUE to remove NAs</p>
</td></tr>
<tr><td><code id="extr1chan_+3A_rowsep">rowSep</code></td>
<td>
<p>(character) separator for rows</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with just single channel extracted
</p>


<h3>See Also</h3>

<p><code><a href="#topic+organizeAsListOfRepl">organizeAsListOfRepl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>arr1 &lt;- array(1:24,dim=c(4,3,2),dimnames=list(c(LETTERS[1:4]),
  paste("col",1:3,sep=""),c("ch1","ch2")))
arr2 &lt;- array(74:51,dim=c(4,3,2),dimnames=list(c(LETTERS[1:4]),
  paste("col",1:3,sep=""),c("ch1","ch2")))
arrL1 &lt;- list(pl1=arr1,pl2=arr2)
extr1chan(arrL1,ch=2)
</code></pre>

<hr>
<h2 id='extractLast2numericParts'>Extract last two numeric parts from character vector</h2><span id='topic+extractLast2numericParts'></span>

<h3>Description</h3>

<p><code>extractLast2numericParts</code> extracts last 2 (integer) numeric parts between punctuations out of character vector 'x'.
Runs faster than <code>gregexpr</code> .
Note: won't work correctly with decimals or exponential signs !! (such characters will be considered as punctuation, ie as separator)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractLast2numericParts(x, silent = FALSE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractLast2numericParts_+3A_x">x</code></td>
<td>
<p>main character input</p>
</td></tr>
<tr><td><code id="extractLast2numericParts_+3A_silent">silent</code></td>
<td>
<p>(logical) suppres messages</p>
</td></tr>
<tr><td><code id="extractLast2numericParts_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(numeric) matrix with 2 columns (eg from initial concatenated coordinates)
</p>


<h3>See Also</h3>

<p><code>gregexpr</code> from <code><a href="base.html#topic+grep">grep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>extractLast2numericParts(c("M01.1-4","M001/2.5","M_0001_03-16","zyx","012","a1.b2.3-7,2"))
</code></pre>

<hr>
<h2 id='extrColsDeX'>Flexible extraction of columns</h2><span id='topic+extrColsDeX'></span>

<h3>Description</h3>

<p>This function provides flexible checking if a set of columns may be extracted from a matrix or data.frame 'x'.
If argument <code>extrCol</code> is list of character vectors, this allows to search among given options, the first matching name for each vector will be identified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extrColsDeX(x, extrCol, doExtractCols = FALSE, callFrom = NULL, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extrColsDeX_+3A_x">x</code></td>
<td>
<p>(matrix or data.frame) main input (where data should be extracted from)</p>
</td></tr>
<tr><td><code id="extrColsDeX_+3A_extrcol">extrCol</code></td>
<td>
<p>(character, integer or list) columns to be extracted, may be column-names or column index; if is <code>list</code> each first-level element will be considered as options for one choice</p>
</td></tr>
<tr><td><code id="extrColsDeX_+3A_doextractcols">doExtractCols</code></td>
<td>
<p>(logical) if default <code>FALSE</code> only the column indexes will be returned</p>
</td></tr>
<tr><td><code id="extrColsDeX_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of message(s) produced</p>
</td></tr>
<tr><td><code id="extrColsDeX_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer-vector (if<code>doExtractCols=FALSE</code> return depending on input <code>matrix</code> or <code>data.frame</code>)
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.table</a></code>, <code><a href="#topic+filterList">filterList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dFr &lt;- data.frame(a=11:14, b=24:21, cc=LETTERS[1:4], dd=rep(c(TRUE,FALSE),2)) 
extrColsDeX(dFr,c("b","cc","notThere")) 
extrColsDeX(dFr,c("b","cc","notThere"), doExtractCols=TRUE) 
extrColsDeX(dFr, list(c("nn","b","a"), c("cc","a"),"notThere")) 
</code></pre>

<hr>
<h2 id='extrNumericFromMatr'>Extract numeric part of matrix or data.frame</h2><span id='topic+extrNumericFromMatr'></span>

<h3>Description</h3>

<p><code>extrNumericFromMatr</code> extracts numeric part of matrix or data.frame, removing remaining non-numeric elements if <code>trimToData</code> is set to <code>TRUE</code>.
Note, that cropping entire lines where a (single) text element appeared may quickly reduce the overal content of the input data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extrNumericFromMatr(dat, trimToData = TRUE, silent = FALSE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extrNumericFromMatr_+3A_dat">dat</code></td>
<td>
<p>matrix (or data.frame) for extracting numeric parts</p>
</td></tr>
<tr><td><code id="extrNumericFromMatr_+3A_trimtodata">trimToData</code></td>
<td>
<p>(logical) default to remove (crop) lines and cols contributing to NA, non-numeric data is transfomed to NA</p>
</td></tr>
<tr><td><code id="extrNumericFromMatr_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="extrNumericFromMatr_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of numeric data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(c(letters[1:7],14:16,LETTERS[1:6]),nrow=4,dimnames=list(1:4,letters[1:4]))
mat; extrNumericFromMatr(mat)
mat &lt;- matrix(c(letters[1:4],1,"e",12:19,LETTERS[1:6]),nr=5,dimnames=list(11:15,letters[1:4]))
mat; extrNumericFromMatr(mat)
</code></pre>

<hr>
<h2 id='extrSpcText'>Extract specific text</h2><span id='topic+extrSpcText'></span>

<h3>Description</h3>

<p>This function extracts/cuts text-fragments out of <code>txt</code> following specific anchors defined by arguments <code>cutFrom</code> and <code>cutTo</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extrSpcText(
  txt,
  cutFrom = " GN=",
  cutTo = " PE=",
  missingAs = NA,
  exclFromTag = TRUE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extrSpcText_+3A_txt">txt</code></td>
<td>
<p>character vector to be treated</p>
</td></tr>
<tr><td><code id="extrSpcText_+3A_cutfrom">cutFrom</code></td>
<td>
<p>(character) text where to start cutting</p>
</td></tr>
<tr><td><code id="extrSpcText_+3A_cutto">cutTo</code></td>
<td>
<p>(character) text where to stop cutting</p>
</td></tr>
<tr><td><code id="extrSpcText_+3A_missingas">missingAs</code></td>
<td>
<p>(character) specific content of output at line/location of 'exclLi'</p>
</td></tr>
<tr><td><code id="extrSpcText_+3A_exclfromtag">exclFromTag</code></td>
<td>
<p>(logical) to exclude text given in 'cutFrom' from result</p>
</td></tr>
<tr><td><code id="extrSpcText_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="extrSpcText_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="extrSpcText_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case <code>cutFrom</code> is not found <code>missingAs</code> will be returned.
In case <code>cutTo</code> is not found, text gets extracted with <code>chaMaxEl</code> characters.
</p>


<h3>Value</h3>

<p>This function returns a modified character vector
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+substr">substr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>extrSpcText(c(" ghjg GN=thisText PE=001"," GN=_ PE=", NA, "abcd"))
extrSpcText(c("ABCDEF.3-6","05g","bc.4-5"), cutFr="\\.", cutT="-")
</code></pre>

<hr>
<h2 id='filt3dimArr'>Filter three-dimensional array of numeric data</h2><span id='topic+filt3dimArr'></span>

<h3>Description</h3>

<p>Filtering of matrix or (3-dim) array <code>x</code> : filter column according to <code>filtCrit</code> (eg 'inf') and threshold <code>filtVal</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filt3dimArr(
  x,
  filtVal,
  filtTy = "&gt;",
  filtCrit = NULL,
  displCrit = NULL,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filt3dimArr_+3A_x">x</code></td>
<td>
<p>array (3-dim) of numeric data</p>
</td></tr>
<tr><td><code id="filt3dimArr_+3A_filtval">filtVal</code></td>
<td>
<p>(numeric, length=1) for testing inferior/superor/equal condition</p>
</td></tr>
<tr><td><code id="filt3dimArr_+3A_filtty">filtTy</code></td>
<td>
<p>(character, length=1) which type of testing to perform (may be 'eq','inf','infeq','sup','supeq', '&gt;', '&lt;', '&gt;=', '&lt;=', '==')</p>
</td></tr>
<tr><td><code id="filt3dimArr_+3A_filtcrit">filtCrit</code></td>
<td>
<p>(character, length=1) which column-name consider when filtering filter with 'filtVal' and 'filtTy'</p>
</td></tr>
<tr><td><code id="filt3dimArr_+3A_displcrit">displCrit</code></td>
<td>
<p>(character) column-name(s) to display</p>
</td></tr>
<tr><td><code id="filt3dimArr_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="filt3dimArr_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="filt3dimArr_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>and extract/display all col matching 'displCrit'.
</p>


<h3>Value</h3>

<p>This function returns a list of filtered matrixes (by 3rd dim)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterList">filterList</a></code>; <code><a href="#topic+filterLiColDeList">filterLiColDeList</a></code>;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>arr1 &lt;- array(11:34, dim=c(4,3,2), dimnames=list(c(LETTERS[1:4]),
  paste("col",1:3,sep=""), c("ch1","ch2")))
filt3dimArr(arr1,displCrit=c("col1","col2"),filtCrit="col2",filtVal=7)
</code></pre>

<hr>
<h2 id='filterLiColDeList'>Filter lines(rows) and/or columns from all suitable elements of list</h2><span id='topic+filterLiColDeList'></span>

<h3>Description</h3>

<p>Filter all elements of list (or S3-object) according to criteria designed to one selected reference-element of the list.
All simple vectors, matrix, data.frames and 3-dimensional arrays will be checked if matching number of rows and/or columns to decide if they should be filtered the same way.
If the reference element has same number of rows and columns simple (1-dimensional) vectors won't be filtered since it not clear if this should be done to lines or columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterLiColDeList(
  lst,
  useLines,
  useCols = NULL,
  ref = 1,
  silent = FALSE,
  callFrom = NULL,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filterLiColDeList_+3A_lst">lst</code></td>
<td>
<p>(list or S3 object) main input</p>
</td></tr>
<tr><td><code id="filterLiColDeList_+3A_uselines">useLines</code></td>
<td>
<p>(integer, logcial or character) vector to assign lines to keep when filtering along lines;
set to <code>NULL</code> for no filtering; if '<code>allNA</code>' all lines composed uniquely of <code>NA</code> values will be removed.</p>
</td></tr>
<tr><td><code id="filterLiColDeList_+3A_usecols">useCols</code></td>
<td>
<p>(integer, logcial or character) vector for filtering columns; set to <code>NULL</code> for no filtering; if '<code>allNA</code>' all columns uniquely <code>NA</code> values will be removed</p>
</td></tr>
<tr><td><code id="filterLiColDeList_+3A_ref">ref</code></td>
<td>
<p>(integer) index for designing the elment of 'lst' to take as reference for checking which other list-elements have suitable number of rows or columns</p>
</td></tr>
<tr><td><code id="filterLiColDeList_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="filterLiColDeList_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
<tr><td><code id="filterLiColDeList_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used eg in package wrProteo to simultaneaously filter raw and transformed data.
</p>


<h3>Value</h3>

<p>This function returns the correct(ed) input (object of same class, of same length)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+moderTest2grp">moderTest2grp</a></code> for single comparisons, <code><a href="limma.html#topic+lmFit">lmFit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lst1 &lt;- list(m1=matrix(11:18,ncol=2), m2=matrix(21:30,ncol=2), indR=31:34,
  m3=matrix(c(21:23,NA,25:27,NA),ncol=2))
## here $m2 has more lines than $m1, and thus will be ignored when ref=1
filterLiColDeList(lst1, useLines=2:3)
filterLiColDeList(lst1, useLines="allNA", ref=4)

</code></pre>

<hr>
<h2 id='filterList'>Filter for unique elements</h2><span id='topic+filterList'></span>

<h3>Description</h3>

<p>This function aims to apply a given filter-citerium, a matrix or vector of <code>FALSE/TRUE</code> which is typically combined with a second layer   
which filters for a min content of filer-passing values per line for the first/main criterium.
Then all lines concerned will be removed. This will be done for all list-elements (of appropriate size) of the input-list  
(while maintaining the list-structure in the output) not matching the filtering criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterList(lst, filt, minLineRatio = 0.5, silent = FALSE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filterList_+3A_lst">lst</code></td>
<td>
<p>(list) main input, each vector, matrix or data.frame in this list will be filtered if its length or number of lines fits to <code>filt</code></p>
</td></tr>
<tr><td><code id="filterList_+3A_filt">filt</code></td>
<td>
<p>(logical) vector of <code>FALSE/TRUE</code> to use for filtering. If this a matrix is given, the value of <code>minLineRatio</code> will be applied as threshod of min content of <code>TRUE</code> for each line of <code>filt</code></p>
</td></tr>
<tr><td><code id="filterList_+3A_minlineratio">minLineRatio</code></td>
<td>
<p>(numeric) in case <code>filt</code> is a matrix of <code>FALSE/TRUE</code>, this value will be used as threshold of min content of <code>TRUE</code> for each line of <code>filt</code></p>
</td></tr>
<tr><td><code id="filterList_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="filterList_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>filtered list
</p>


<h3>See Also</h3>

<p><code><a href="#topic+correctToUnique">correctToUnique</a></code>, <code><a href="base.html#topic+unique">unique</a></code>, <code><a href="base.html#topic+duplicated">duplicated</a></code>, <code><a href="#topic+extrColsDeX">extrColsDeX</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2020); dat1 &lt;- round(runif(80),2)
list1 &lt;- list(m1=matrix(dat1[1:40],ncol=8), m2=matrix(dat1[41:80],ncol=8), other=letters[1:8])
rownames(list1$m1) &lt;- rownames(list1$m2) &lt;- paste0("line",1:5)
filterList(list1, list1$m1[,1] &gt;0.4) 
filterList(list1, list1$m1 &gt;0.4) 
</code></pre>

<hr>
<h2 id='filterNetw'>Filter nodes &amp; edges for extracting networks
This function allows extracting and filtering network-data based on fixed threshold (<code>limInt</code>) and add sandwich-nodes (nodes inter-connecting initial nodes) out of node-based queries.</h2><span id='topic+filterNetw'></span>

<h3>Description</h3>

<p>Filter nodes &amp; edges for extracting networks
</p>
<p>This function allows extracting and filtering network-data based on fixed threshold (<code>limInt</code>) and add sandwich-nodes (nodes inter-connecting initial nodes) out of node-based queries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterNetw(
  lst,
  filtCol = 3,
  limInt = 5000,
  sandwLim = 5000,
  filterAsInf = TRUE,
  outFormat = "matrix",
  remOrphans = TRUE,
  remRevPairs = TRUE,
  elemNa = "genes",
  silent = FALSE,
  callFrom = NULL,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filterNetw_+3A_lst">lst</code></td>
<td>
<p>(list, composed of multiple matrix or data.frames ) main input (each list-element should have same number of columns)</p>
</td></tr>
<tr><td><code id="filterNetw_+3A_filtcol">filtCol</code></td>
<td>
<p>(integer, length=1) which column of <code>lst</code> should be usd to filter using thresholds <code>limInt</code> and <code>sandwLim</code></p>
</td></tr>
<tr><td><code id="filterNetw_+3A_limint">limInt</code></td>
<td>
<p>(numeric, length=1) filter main edge-scores according to <code>filterAsInf</code></p>
</td></tr>
<tr><td><code id="filterNetw_+3A_sandwlim">sandwLim</code></td>
<td>
<p>(numeric, length=1) filter sandwich connection edge-scores accodring to <code>filterAsInf</code></p>
</td></tr>
<tr><td><code id="filterNetw_+3A_filterasinf">filterAsInf</code></td>
<td>
<p>(logical) filter as 'inferior or equal' or 'superior or equal'</p>
</td></tr>
<tr><td><code id="filterNetw_+3A_outformat">outFormat</code></td>
<td>
<p>(character) may be 'matrix' for tabular output, 'all' as list with matrix and list of node-names</p>
</td></tr>
<tr><td><code id="filterNetw_+3A_remorphans">remOrphans</code></td>
<td>
<p>(logical) remove networks consisting only of 2 connected edges</p>
</td></tr>
<tr><td><code id="filterNetw_+3A_remrevpairs">remRevPairs</code></td>
<td>
<p>(logical) remove duplicate edges due to reverse massping (eg A - B and B - A); NOTE : use only when edges don't have orientation !</p>
</td></tr>
<tr><td><code id="filterNetw_+3A_elemna">elemNa</code></td>
<td>
<p>(character) used only for messages</p>
</td></tr>
<tr><td><code id="filterNetw_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="filterNetw_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
<tr><td><code id="filterNetw_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix or data.frame
</p>


<h3>See Also</h3>

<p>in <code><a href="base.html#topic+cbind">cbind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lst2 &lt;- list('121'=data.frame(ID=as.character(c(141,221,228,229,449)),11:15), 
	 '131'=data.frame(ID=as.character(c(228,331,332,333,339)),11:15), 
  '141'=data.frame(ID=as.character(c(121,151,229,339,441,442,449)),c(11:17)), 
  '151'=data.frame(ID=as.character(c(449,141,551,552)),11:14),
  '161'=data.frame(ID=as.character(171),11), '171'=data.frame(ID=as.character(161),11),
  '181'=data.frame(ID=as.character(881:882),11:12) )

lst2 &lt;- list('121'=data.frame(ID=as.character(c(141,221,228,229,449)),11:15, 21:25), 
	 '131'=data.frame(ID=as.character(c(228,331,332,333,339)),11:15, 21:25), 
  '141'=data.frame(ID=as.character(c(121,151,229,339,441,442,449)), c(11:17), 21:27), 
  '151'=data.frame(ID=as.character(c(449,141,551,552)), 11:14, 21:24),
  '161'=data.frame(ID=as.character(171), 11,21), '171'=data.frame(ID=as.character(161), 11,21),
  '181'=data.frame(ID=as.character(881:882), 11:12,21:22) )

(te1 &lt;- filterNetw(lst2, limInt=90, remOrphans=FALSE))
(te2 &lt;- filterNetw(lst2, limInt=90, remOrphans=TRUE))

(te3 &lt;- filterNetw(lst2, limInt=13, remOrphans=FALSE))
(te4 &lt;- filterNetw(lst2, limInt=13, remOrphans=TRUE))


</code></pre>

<hr>
<h2 id='filtSizeUniq'>Filter for unique elements</h2><span id='topic+filtSizeUniq'></span>

<h3>Description</h3>

<p>This function aims to identify and remove duplicated elements in a list and maintain the list-structure in the output. 
<code>filtSizeUniq</code>  filters 'lst' (list of character-vectors or character-vector) for elements being unique (to 'ref' or if NULL to all 'lst') and of character length. 
In addition, the min- and max- character length may be filtered, too. Eg, in proteomics this helps removing peptide sequences which would not be measured/detected any way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filtSizeUniq(
  lst,
  ref = NULL,
  minSize = 6,
  maxSize = 36,
  filtUnique = TRUE,
  byProt = TRUE,
  inclEmpty = TRUE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filtSizeUniq_+3A_lst">lst</code></td>
<td>
<p>list of character-vectors or character-vector</p>
</td></tr>
<tr><td><code id="filtSizeUniq_+3A_ref">ref</code></td>
<td>
<p>(character) optional alternative 'reference', if not <code>NULL</code> used in addition to 'lst' for considering elements of 'lst' as unique</p>
</td></tr>
<tr><td><code id="filtSizeUniq_+3A_minsize">minSize</code></td>
<td>
<p>(integer) minimum number of characters, if <code>NULL</code> set to 0</p>
</td></tr>
<tr><td><code id="filtSizeUniq_+3A_maxsize">maxSize</code></td>
<td>
<p>(integer) maximum number of characters</p>
</td></tr>
<tr><td><code id="filtSizeUniq_+3A_filtunique">filtUnique</code></td>
<td>
<p>(logical) if <code>TRUE</code> return unique-only character-strings</p>
</td></tr>
<tr><td><code id="filtSizeUniq_+3A_byprot">byProt</code></td>
<td>
<p>(logical) if <code>TRUE</code> organize output as list (by names of input, eg protein-names) - if 'lst' was named list</p>
</td></tr>
<tr><td><code id="filtSizeUniq_+3A_inclempty">inclEmpty</code></td>
<td>
<p>(logical) optional including empty list-elements when all elements have been filtered away - if 'lst' was named list</p>
</td></tr>
<tr><td><code id="filtSizeUniq_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="filtSizeUniq_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="filtSizeUniq_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of filtered input
</p>


<h3>See Also</h3>

<p><code><a href="#topic+correctToUnique">correctToUnique</a></code>, <code><a href="base.html#topic+unique">unique</a></code>, <code><a href="base.html#topic+duplicated">duplicated</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filtSizeUniq(list(A="a",B=c("b","bb","c"),D=c("dd","d","ddd","c")),filtUn=TRUE,minSi=NULL)
# input: c and dd are repeated
filtSizeUniq(list(A="a",B=c("b","bb","c"),D=c("dd","d","ddd","c")),ref=c(letters[c(1:26,1:3)],
  "dd","dd","bb","ddd"),filtUn=TRUE,minSi=NULL)  # a,b,c,dd repeated 
</code></pre>

<hr>
<h2 id='findCloseMatch'>Find close numeric values between two vectors</h2><span id='topic+findCloseMatch'></span>

<h3>Description</h3>

<p><code>findCloseMatch</code> finds close matches (similar values) between two numeric vectors ('x','y') based on method 'compTy' and threshold 'limit'. 
Return list with close matches of 'x' to given 'y', the numeric value dependes on 'sortMatch' (if FALSE then always value of 'y' otherwise of longest of x&amp;y).  
Note: Speed &amp; memory improvement if 'sortMatch'=TRUE (but result might be inversed!): adopt search of x-&gt;y or y-&gt;x to searching matches of each longest to each shorter  (ie flip x &amp;y).
Otherwise, if length of 'x' &amp; 'y' are very different, it may be advantagous to use a long(er) 'x'  and short(er) 'y' (with 'sortMatch'=FALSE).  
Note: Names of 'x' &amp; 'y' or (if no names) prefix letters 'x' &amp; 'y' are always added as names to results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findCloseMatch(
  x,
  y,
  compTy = "ppm",
  limit = 5,
  asIndex = FALSE,
  maxFitShort = 100,
  sortMatch = FALSE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findCloseMatch_+3A_x">x</code></td>
<td>
<p>numeric vector for comparison</p>
</td></tr>
<tr><td><code id="findCloseMatch_+3A_y">y</code></td>
<td>
<p>numeric vector for comparison</p>
</td></tr>
<tr><td><code id="findCloseMatch_+3A_compty">compTy</code></td>
<td>
<p>(character) may be 'diff' or 'ppm', will be used with threshold from argument 'limit'</p>
</td></tr>
<tr><td><code id="findCloseMatch_+3A_limit">limit</code></td>
<td>
<p>(numeric) threshold value for retaining values, used with distace-type specified in argument 'compTy'</p>
</td></tr>
<tr><td><code id="findCloseMatch_+3A_asindex">asIndex</code></td>
<td>
<p>(logical) optionally rather report index of retained values</p>
</td></tr>
<tr><td><code id="findCloseMatch_+3A_maxfitshort">maxFitShort</code></td>
<td>
<p>(numeric) limit output to max number of elements (avoid returning high number of results if filtering was not enough stringent)</p>
</td></tr>
<tr><td><code id="findCloseMatch_+3A_sortmatch">sortMatch</code></td>
<td>
<p>(logical) if TRUE than matching will be preformed as 'match longer (of x &amp; y) to closer', this may process slightly faster (eg 'x' longer: list for each 'y' all 'x' that are close, otherwise list of each 'x'),</p>
</td></tr>
<tr><td><code id="findCloseMatch_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="findCloseMatch_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="findCloseMatch_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with close matches of 'x' to given 'y', the numeric value dependes on 'sortMatch' (if FASLE then always value of 'y' otherwise of longest of x&amp;y)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+checkSimValueInSer">checkSimValueInSer</a></code> and (from this package) <code>.compareByDiff</code>, for convient output <code><a href="#topic+countCloseToLimits">countCloseToLimits</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aa &lt;- 11:14 ; bb &lt;- c(13.1,11.5,14.3,20:21)
findCloseMatch(aa,bb,com="diff",lim=0.6)
findCloseMatch(c(a=5,b=11,c=12,d=18),c(G=2,H=11,I=12,J=13)+0.5, comp="diff", lim=2)
findCloseMatch(c(4,5,11,12,18),c(2,11,12,13,33)+0.5, comp="diff", lim=2)
findCloseMatch(c(4,5,11,12,18),c(2,11,12,13,33)+0.5, comp="diff", lim=2, sort=FALSE)
.compareByDiff(list(c(a=10,b=11,c=12,d=13),c(H=11,I=12,J=13,K=33)+0.5),limit=1) #' return matrix

a2 &lt;- c(11:20); names(a2) &lt;- letters[11:20]
b2 &lt;- c(25:5)+c(rep(0,5),(1:10)/50000,rep(0,6)); names(b2) &lt;- LETTERS[25:5]
which(abs(b2-a2[8]) &lt; a2[8]*1e-6*5)                                     #'  find R=18 : no10
findCloseMatch(a2, b2, com="ppm", lim=5)                                #'  find Q,R,S,T
findCloseMatch(a2, b2, com="ppm", lim=5,asI=TRUE)                       #'  find Q,R,S,T
findCloseMatch(b2, a2, com="ppm", lim=5,asI=TRUE,sort=FALSE)
findCloseMatch(a2, b2, com="ratio", lim=1.000005)                       #'  find Q,R,S,T
findCloseMatch(a2, b2, com="diff", lim=0.00005)                         #'  find S,T
</code></pre>

<hr>
<h2 id='findRepeated'>Find repeated elements</h2><span id='topic+findRepeated'></span>

<h3>Description</h3>

<p><code>findRepeated</code> gets index of repeated items/values in vector 'x' (will be treated as character). 
Return (named) list of indexes for each of the repeated values, or <code>NULL</code> if all values are unique.
This approach is similar but more basic compared to <code><a href="#topic+get1stOfRepeatedByCol">get1stOfRepeatedByCol</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findRepeated(x, nonRepeated = FALSE, silent = FALSE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findRepeated_+3A_x">x</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="findRepeated_+3A_nonrepeated">nonRepeated</code></td>
<td>
<p>(logical) if <code>=TRUE</code>, return list with elements <code>$rep</code> and <code>$nonrep</code></p>
</td></tr>
<tr><td><code id="findRepeated_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="findRepeated_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(named) list of indexes for each of the repeated values, or NULL if all values unique
</p>


<h3>See Also</h3>

<p>similar approach but more basic than <code><a href="#topic+get1stOfRepeatedByCol">get1stOfRepeatedByCol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aa &lt;- c(11:16,14:12,14); findRepeated(aa) 
</code></pre>

<hr>
<h2 id='findSimilFrom2sets'>Find similar numeric values from two vectors/matrixes</h2><span id='topic+findSimilFrom2sets'></span>

<h3>Description</h3>

<p><code>findSimilFrom2sets</code> compares to vectors or matrixes and returns combined view including only all close (by <code><a href="#topic+findCloseMatch">findCloseMatch</a></code>).
Return matrix (predMatr) with add'l columns for index to and 'grp' (group of similar values (1-to-many)), 'nGrp' (n of grp), 'isBest' or 'nBest', 'disToMeas' 
(distance/difference between pair) &amp;  'ppmToPred' (distance in ppm).
Note: too wide 'limitComp' will result in large window and many 'good' hits will compete (and be mutually exlcuded) if selection 'bestOnly' is selected
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findSimilFrom2sets(
  predMatr,
  measMatr,
  colMeas = 1,
  colPre = 1,
  compareTy = "diff",
  limitComp = 0.5,
  bestOnly = FALSE,
  silent = FALSE,
  callFrom = NULL,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findSimilFrom2sets_+3A_predmatr">predMatr</code></td>
<td>
<p>(matrix or numeric vector) dataset number 1, referred to as 'predicted', the colum speified in argument <code>colPre</code> points to the data to be used</p>
</td></tr>
<tr><td><code id="findSimilFrom2sets_+3A_measmatr">measMatr</code></td>
<td>
<p>(matrix or numeric vector) dataset number 2, referred to as 'measured', the colum speified in argument <code>colMeas</code> points to the data to be used</p>
</td></tr>
<tr><td><code id="findSimilFrom2sets_+3A_colmeas">colMeas</code></td>
<td>
<p>(integer) which column number of 'measMatr' to consider</p>
</td></tr>
<tr><td><code id="findSimilFrom2sets_+3A_colpre">colPre</code></td>
<td>
<p>(integer) which column number of 'predMatr' to consider</p>
</td></tr>
<tr><td><code id="findSimilFrom2sets_+3A_comparety">compareTy</code></td>
<td>
<p>(character) 'diff' (difference) 'ppm' (relative difference)</p>
</td></tr>
<tr><td><code id="findSimilFrom2sets_+3A_limitcomp">limitComp</code></td>
<td>
<p>(numeric) limit used by 'compareTy'</p>
</td></tr>
<tr><td><code id="findSimilFrom2sets_+3A_bestonly">bestOnly</code></td>
<td>
<p>(logical) allows to filter only hits with min distance (defined by 'compareTy'), 3rd last col will be 'nBest' - otherwise 3rd last col 'isBest'</p>
</td></tr>
<tr><td><code id="findSimilFrom2sets_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="findSimilFrom2sets_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
<tr><td><code id="findSimilFrom2sets_+3A_debug">debug</code></td>
<td>
<p>(logical) for bug-tracking: more/enhanced messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix (predMatr) with add'l columns for index to and 'grp' (group of similar values (1-to-many)), 'nGrp' (n of grp), 'isBest' or 'nBest', 'disToMeas' (distance/difference between pair) &amp;  'ppmToPred' (distance in ppm)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+checkSimValueInSer">checkSimValueInSer</a></code> <code><a href="#topic+findCloseMatch">findCloseMatch</a></code> <code><a href="#topic+closeMatchMatrix">closeMatchMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aA &lt;- c(11:17); bB &lt;- c(12.001,13.999); cC &lt;- c(16.2,8,9,12.5,12.6,15.9,14.1)
aZ &lt;-  matrix(c(aA,aA+20),ncol=2,dimnames=list(letters[1:length(aA)],c("aaA","aZ")))
cZ &lt;-  matrix(c(cC,cC+20),ncol=2,dimnames=list(letters[1:length(cC)],c("ccC","cZ")))
findCloseMatch(cC,aA,com="diff",lim=0.5,sor=FALSE)
findSimilFrom2sets(aA,cC)
findSimilFrom2sets(cC,aA)
findSimilFrom2sets(aA,cC,best=FALSE)
findSimilFrom2sets(aA,cC,comp="ppm",lim=5e4,deb=TRUE)
findSimilFrom2sets(aA,cC,comp="ppm",lim=9e4,bestO=FALSE)
# below: find fewer 'best matches' since search window larger (ie more good hits compete !)
findSimilFrom2sets(aA,cC,comp="ppm",lim=9e4,bestO=TRUE)      
</code></pre>

<hr>
<h2 id='findUsableGroupRange'>Select groups within given range</h2><span id='topic+findUsableGroupRange'></span>

<h3>Description</h3>

<p>This function aims to help finding streches/segments of data with a given maximum number of NA-instances.
This function is used to inspect/filter each lines of 'dat' for a subset with sufficient presence/absence of NA values (ie limit number of NAs per level of 'grp').
Note :  optimal perfomance with n.lines &gt;&gt; n.groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findUsableGroupRange(dat, grp, maxNA = 1, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findUsableGroupRange_+3A_dat">dat</code></td>
<td>
<p>(matrix or data.frame) main input</p>
</td></tr>
<tr><td><code id="findUsableGroupRange_+3A_grp">grp</code></td>
<td>
<p>(factor) information which column of 'dat' is replicate of whom</p>
</td></tr>
<tr><td><code id="findUsableGroupRange_+3A_maxna">maxNA</code></td>
<td>
<p>(interger) max number of tolerated NAs</p>
</td></tr>
<tr><td><code id="findUsableGroupRange_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with boundaries of 1st and last usable column (NA if there were no suitable groups found)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat1 &lt;- matrix(1:56,nc=7)
dat1[c(2,3,4,5,6,10,12,18,19,20,22,23,26,27,28,30,31,34,38,39,50,54)] &lt;- NA
rownames(dat1) &lt;- letters[1:nrow(dat1)]
findUsableGroupRange(dat1,gl(3,3)[-(3:4)])
</code></pre>

<hr>
<h2 id='firstLineOfDat'>Filter matrix to keep only first of repeated lines</h2><span id='topic+firstLineOfDat'></span>

<h3>Description</h3>

<p>This function aims to reduce the complexity of a matrix (or data.frame) in case column 'refCol' has multiple lines with same value. 
In this case, it reduces the input-data to 1st line of redundant entries and returns a matrix (or data.frame) without lines identified as redundant entries for 'refCol').
in sum, this functions works lile useng <code>unique</code> on a given column, and propagates the same treatment to all other columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>firstLineOfDat(dat, refCol = 2, silent = FALSE, debug = FALSE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="firstLineOfDat_+3A_dat">dat</code></td>
<td>
<p>(matrix or data.frame) main input</p>
</td></tr>
<tr><td><code id="firstLineOfDat_+3A_refcol">refCol</code></td>
<td>
<p>(integer) column number of reference-column</p>
</td></tr>
<tr><td><code id="firstLineOfDat_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="firstLineOfDat_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="firstLineOfDat_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix (same number of columns as input)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+firstOfRepeated">firstOfRepeated</a></code>, <code><a href="base.html#topic+unique">unique</a></code>, <code><a href="base.html#topic+duplicated">duplicated</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(mat1 &lt;- matrix(c(1:6,rep(1:3,1:3)),ncol=2,dimnames=list(letters[1:6],LETTERS[1:2])))
firstLineOfDat(mat1)
</code></pre>

<hr>
<h2 id='firstOfRepeated'>Find first of repeated elements</h2><span id='topic+firstOfRepeated'></span>

<h3>Description</h3>

<p>This function works similar to <code>unique</code>, but provides additional information about which elements of original input <code>'x'</code> are repeatd by providing indexes realtoe to the input.
<code>firstOfRepeated</code> makes list with 3 elements : $indRepeated.. index for first of repeated 'x', $indUniq.. index of all unique + first of repeated, $indRedund.. index of all redundant entries, ie non-unique (wo 1st).
Used for reducing data to non-redundant status, however, for large numeric input the function nonAmbiguousNum() may perform better/faster.
NAs won't be considered (NAs do not appear in reported  index of results), see also firstOfRepLines() .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>firstOfRepeated(x, silent = FALSE, debug = FALSE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="firstOfRepeated_+3A_x">x</code></td>
<td>
<p>(charcter or numeric) main input</p>
</td></tr>
<tr><td><code id="firstOfRepeated_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="firstOfRepeated_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="firstOfRepeated_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with indices: $indRepeated,  $indUniq, $indRedund
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+duplicated">duplicated</a></code>, <code><a href="#topic+nonAmbiguousNum">nonAmbiguousNum</a></code>, <code><a href="#topic+firstOfRepLines">firstOfRepLines</a></code> gives less detail in output (lines/elements/indexes of omitted not directly accessible) and works fsster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(letters[c(3,2:4,8,NA,3:1,NA,5:4)]); names(x) &lt;- 100+(1:length(x))
firstOfRepeated(x)
x[firstOfRepeated(x)$indUniq]          # only unique with names
</code></pre>

<hr>
<h2 id='firstOfRepLines'>Reduce to first occurance of repeated lines</h2><span id='topic+firstOfRepLines'></span>

<h3>Description</h3>

<p>This function concatenattes all columns of input-matrix and then searches like <code>unique</code> for unique elements, optionally the indexes of unique elements may get returned.
Note: This function reats input as character (thus won't understand <code>10==10.0</code> ).
Returns simplified/non-redundant vector/matrix (ie fewer lines), or respective index.
faster than  <code><a href="#topic+firstOfRepeated">firstOfRepeated</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>firstOfRepLines(
  mat,
  outTy = "ind",
  useCol = NULL,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="firstOfRepLines_+3A_mat">mat</code></td>
<td>
<p>initial matrix to treat</p>
</td></tr>
<tr><td><code id="firstOfRepLines_+3A_outty">outTy</code></td>
<td>
<p>for output type: 'ind'.. index to 1st occurance (non-red),'orig'..non-red lines of mat, 'conc'.. non-red concateneted values, 'num'.. index to which group/category the lines belong</p>
</td></tr>
<tr><td><code id="firstOfRepLines_+3A_usecol">useCol</code></td>
<td>
<p>(integer) custom choice of which columns to paste/concatenate</p>
</td></tr>
<tr><td><code id="firstOfRepLines_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="firstOfRepLines_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="firstOfRepLines_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>simplified/non-redundant vector/matrix (ie fewer lines for matrix), or respective index
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+unique">unique</a></code>, <code><a href="#topic+nonAmbiguousNum">nonAmbiguousNum</a></code>, faster than <code><a href="#topic+firstOfRepeated">firstOfRepeated</a></code> which gives more detail in output (lines/elements/indexes of omitted)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(c("e","n","a","n","z","z","n","z","z","b", 
  "","n","c","n","","","n","","","z"),ncol=2)
firstOfRepLines(mat,out="conc")
</code></pre>

<hr>
<h2 id='fuseAnnotMatr'>Fuse annotation matrix to initial matrix</h2><span id='topic+fuseAnnotMatr'></span>

<h3>Description</h3>

<p>In a number of instances experimental measurements and additional information (annotation) are provided by separate objects (matrixes) as they may not be generated the same time.
The aim of this function is provide help when matching approprate lines for 2 sets of data (experimental measures in <code>iniTab</code> and annotation from <code>annotTab</code>) for fusing.  
<code>fuseAnnotMatr</code> adds suppelmental columns/annotation to an initial matrix <code>iniTab</code> : using column 'refIniT' as key (in <code>iniTab</code>) to compare with key 'refAnnotT' (from 'annotTab'). 
The columns to be added from <code>annotTab</code> must be chosen explicitely. 
Note: if  non-unique IDs in iniTab : runs slow (but save) due to use of loop for each unique ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fuseAnnotMatr(
  iniTab,
  annotTab,
  refIniT = "Uniprot",
  refAnnotT = "combName",
  addCol = c("ensembl_gene_id", "description", "geneName", "combName"),
  debug = TRUE,
  silent = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fuseAnnotMatr_+3A_initab">iniTab</code></td>
<td>
<p>(matrix), that may have lines with multiple (=repeated) key entries</p>
</td></tr>
<tr><td><code id="fuseAnnotMatr_+3A_annottab">annotTab</code></td>
<td>
<p>(matrix) containing reference annotation</p>
</td></tr>
<tr><td><code id="fuseAnnotMatr_+3A_refinit">refIniT</code></td>
<td>
<p>(character) type of reference (eg 'Uniprot')</p>
</td></tr>
<tr><td><code id="fuseAnnotMatr_+3A_refannott">refAnnotT</code></td>
<td>
<p>(character) column name to use for reference-annotation</p>
</td></tr>
<tr><td><code id="fuseAnnotMatr_+3A_addcol">addCol</code></td>
<td>
<p>(character) column-namess of 'annotTab' to use/extract (if no matches found, use all)</p>
</td></tr>
<tr><td><code id="fuseAnnotMatr_+3A_debug">debug</code></td>
<td>
<p>(logical) for bug-tracking: more/enhanced messages</p>
</td></tr>
<tr><td><code id="fuseAnnotMatr_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="fuseAnnotMatr_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>combined matrix (elements not found in 'annotTab' are displayed as NA)
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+merge">merge</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tab0 &lt;- matrix(rep(letters[1:25],8),ncol=10)
tab1 &lt;- cbind(Uniprot=paste(tab0[,1],tab0[,2]),col1=paste(tab0[,3],
  tab0[,4],tab0[,5]," ",tab0[,7],tab0[,6]))
tab2 &lt;- cbind(combName=paste(tab0[,1],tab0[,2]),col2=paste(tab0[,8],tab0[,9],tab0[,10]))
fuseAnnotMatr(tab1,tab2[c(20:11,2:5),],refIni="Uniprot",refAnnotT="combName",addCol="col2")
fuseAnnotMatr(tab2[c(20:11,2:5),],tab1,refAnnotT="Uniprot",refIni="combName",addCol="col1")
</code></pre>

<hr>
<h2 id='fuseCommonListElem'>Fuse content of list-elements with redundant (duplicated) names</h2><span id='topic+fuseCommonListElem'></span>

<h3>Description</h3>

<p><code>fuseCommonListElem</code> fuses (character or numeric) elements of list re-occuring under same name, so that resultant list has unique names.
Note : will not work with list of matrixes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fuseCommonListElem(
  lst,
  initOrd = TRUE,
  removeDuplicates = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fuseCommonListElem_+3A_lst">lst</code></td>
<td>
<p>(list) main input, list of numeric vectors</p>
</td></tr>
<tr><td><code id="fuseCommonListElem_+3A_initord">initOrd</code></td>
<td>
<p>(logical) preserve initial order in output (if TRUE) or otherwise sort alphabetically</p>
</td></tr>
<tr><td><code id="fuseCommonListElem_+3A_removeduplicates">removeDuplicates</code></td>
<td>
<p>(logical) allow to remove duplicate entries (if vector contains names, both the name and the value need to be identical to be removed; note: all names must have names with more than 0 characters to be considered as names)</p>
</td></tr>
<tr><td><code id="fuseCommonListElem_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fused list (same names as elements of input)
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+unlist">unlist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>val1 &lt;- 10 +1:26
names(val1) &lt;- letters
lst1 &lt;- list(c=val1[3:6],a=val1[1:3],b=val1[2:3],a=val1[12],c=val1[13])
fuseCommonListElem(lst1)
</code></pre>

<hr>
<h2 id='fusePairs'>Fuse pairs to generate cluster-names</h2><span id='topic+fusePairs'></span>

<h3>Description</h3>

<p>Fuse previously identified pairs to 'clusters', return vector with cluster-numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fusePairs(
  datPair,
  refDatNames = NULL,
  inclRepLst = FALSE,
  maxFuse = NULL,
  debug = FALSE,
  silent = TRUE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fusePairs_+3A_datpair">datPair</code></td>
<td>
<p>2-column matrix where each line represents 1 pair</p>
</td></tr>
<tr><td><code id="fusePairs_+3A_refdatnames">refDatNames</code></td>
<td>
<p>(NULL or character) allows placing selected pairs in context of larger data-set (names to match those of 'datPair')</p>
</td></tr>
<tr><td><code id="fusePairs_+3A_inclreplst">inclRepLst</code></td>
<td>
<p>(logical) if TRUE, return list with 'clu' (clu-numbers, default output) and 'refLst' (list of clustered elements, only n&gt;1)</p>
</td></tr>
<tr><td><code id="fusePairs_+3A_maxfuse">maxFuse</code></td>
<td>
<p>(integer, default NULL) maximal number of groups/clusters</p>
</td></tr>
<tr><td><code id="fusePairs_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="fusePairs_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="fusePairs_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a vector with cluster-numbers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>daPa &lt;- matrix(c(1:5,8,2:6,9), ncol=2)
fusePairs(daPa, maxFuse=4)
</code></pre>

<hr>
<h2 id='get1stOfRepeatedByCol'>Get first of repeated by column</h2><span id='topic+get1stOfRepeatedByCol'></span>

<h3>Description</h3>

<p><code>get1stOfRepeatedByCol</code> sorts matrix 'mat' and extracts only 1st occurance of values in column 'sortBy'.
Returns then non-redundant matrix (ie for column 'sortBy', if 'markIfAmbig' specifies existing col, mark ambig there).
Note : problem when sortSupl or sortBy not present (or not intended for use)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get1stOfRepeatedByCol(
  mat,
  sortBy = "seq",
  sortSupl = "ty",
  asFirstLast = c("full", "inter"),
  markIfAmbig = c("ambig", "seqNa"),
  asList = FALSE,
  abmiPref = "_"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get1stOfRepeatedByCol_+3A_mat">mat</code></td>
<td>
<p>(matrix or data.frame) numeric vector to be tested</p>
</td></tr>
<tr><td><code id="get1stOfRepeatedByCol_+3A_sortby">sortBy</code></td>
<td>
<p>column name for which elements should be made unique, numeric or character column; 'sortSupl' .. add'l colname to always select specific 1st)</p>
</td></tr>
<tr><td><code id="get1stOfRepeatedByCol_+3A_sortsupl">sortSupl</code></td>
<td>
<p>default=&quot;ty&quot;</p>
</td></tr>
<tr><td><code id="get1stOfRepeatedByCol_+3A_asfirstlast">asFirstLast</code></td>
<td>
<p>(character,length=2) to force specific strings from coluln 'sortSupl' as first and last when selecting 1st of repeated terms, default=c(&quot;full&quot;,&quot;inter&quot;)</p>
</td></tr>
<tr><td><code id="get1stOfRepeatedByCol_+3A_markifambig">markIfAmbig</code></td>
<td>
<p>(character,length=2) 1st will be set to 'TRUE' if ambiguous/repeated, 2nd will get (heading) prefix, default=c(&quot;ambig&quot;,&quot;seqNa&quot;)</p>
</td></tr>
<tr><td><code id="get1stOfRepeatedByCol_+3A_aslist">asList</code></td>
<td>
<p>(logical) to return list with non-redundant ('unique') and removed lines ('repeats')</p>
</td></tr>
<tr><td><code id="get1stOfRepeatedByCol_+3A_abmipref">abmiPref</code></td>
<td>
<p>(character) prefix to note ambiguous entries/terms, default=&quot;_&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>depending on 'asList' either list with non-redundant ('unique') and removed lines ('repeats')
</p>


<h3>See Also</h3>

<p><code><a href="#topic+firstOfRepeated">firstOfRepeated</a></code> for (more basic) treatment of simple vector, <code><a href="#topic+nonAmbiguousNum">nonAmbiguousNum</a></code> for numeric use (much faster !!!)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aa &lt;- cbind(no=as.character(1:20),seq=sample(LETTERS[1:15],20,repl=TRUE),
  ty=sample(c("full","Nter","inter"),20,repl=TRUE),ambig=rep(NA,20),seqNa=1:20)
get1stOfRepeatedByCol(aa)
</code></pre>

<hr>
<h2 id='getValuesByUnique'>Print matrix-content as plot</h2><span id='topic+getValuesByUnique'></span>

<h3>Description</h3>

<p>When data have repeated elements (defined by names inside the vector), it may be advantageous to run some operations 
only on a unique set of the initial data, or somtimes all repeated occurances need to be replaced by a common (summarizing) value.
This function allows to re-introduce new values from on second vector with unique names, to return a final vector of initial input-length and order of names (elements) like initial, too.
Normally the user would provide 'datUniq' (without repeated names) containing new values which will be expanded to structure of 'dat', 
if 'datUniq' is not provided a vector with unique names will be made using the first occurance of repeated value(s).
For more complex cases the indexing relative to 'datUniq' can be returned (setting <code>asIndex=TRUE</code>).
Note: If not all names of 'dat' are found in 'datUniq' the missing spots will be returned as <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getValuesByUnique(
  dat,
  datUniq = NULL,
  asIndex = FALSE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getValuesByUnique_+3A_dat">dat</code></td>
<td>
<p>(numeric or character) main long input, must have names</p>
</td></tr>
<tr><td><code id="getValuesByUnique_+3A_datuniq">datUniq</code></td>
<td>
<p>(numeric or character) will be used to impose values on <code>dat</code>, must have names that should match names (at least partially) from <code>dat</code></p>
</td></tr>
<tr><td><code id="getValuesByUnique_+3A_asindex">asIndex</code></td>
<td>
<p>(logical) if <code>TRUE</code> index values will be returned instead of replacing values</p>
</td></tr>
<tr><td><code id="getValuesByUnique_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="getValuesByUnique_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="getValuesByUnique_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of length <code>dat</code> with imposed values, or index values if <code>asIndex=TRUE</code>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+unique">unique</a></code>, <code><a href="#topic+findRepeated">findRepeated</a></code>, <code><a href="#topic+correctToUnique">correctToUnique</a></code>, <code><a href="#topic+treatTxtDuplicates">treatTxtDuplicates</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- 11:19
names(dat) &lt;- letters[c(6:3,2:4,8,3)]
## let's make a 'datUniq' with the mean of repeated values :
datUniq &lt;- round(tapply(dat,names(dat),mean),1)
## now propagate the mean values to the full vector
getValuesByUnique(dat,datUniq)
cbind(ini=dat,firstOfRep=getValuesByUnique(dat,datUniq),
  indexUniq=getValuesByUnique(dat,datUniq,asIn=TRUE))
</code></pre>

<hr>
<h2 id='gitDataUrl'>Convert ulr-name for reading in raw-mode</h2><span id='topic+gitDataUrl'></span>

<h3>Description</h3>

<p>This functions converts a given urlName so that from data from git-hub can be read correctly that tabular data.
Thus, this will remove '/blob/' and change starting characters to 'raw.githubusercontent.com'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gitDataUrl(
  urlName,
  replTxt = NULL,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gitDataUrl_+3A_urlname">urlName</code></td>
<td>
<p>(charachter) main url-address</p>
</td></tr>
<tr><td><code id="gitDataUrl_+3A_repltxt">replTxt</code></td>
<td>
<p>(NULL or matrix) adjust/ custom-modify search- and replacement items; should be matrix with 2 columns, 
the 1st colimn entries will be used as 'search-for' and the 2nd as 'replace by' fro each row.</p>
</td></tr>
<tr><td><code id="gitDataUrl_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="gitDataUrl_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="gitDataUrl_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>corrected urlName
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sub">sub</a></code>;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>url1 &lt;- paste0("https://github.com/bigbio/proteomics-metadata-standard/blob/",
  "master/annotated-projects/PXD001819/PXD001819.sdrf.tsv") 
gitDataUrl(url1)



</code></pre>

<hr>
<h2 id='htmlSpecCharConv'>Html special character conversion</h2><span id='topic+htmlSpecCharConv'></span>

<h3>Description</h3>

<p>Converts 'txt' so that (the most common) special characters (like 'beta','micro','square' etc) will be displayed correctly whe used for display in html (eg at mouse-over).
Note : The package <a href="https://CRAN.R-project.org/package=stringi">stringi</a> is required for the conversions (the input will get returned if <code>stringi</code> is not available).
Currently only the 16 most common special characters are implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>htmlSpecCharConv(txt, silent = FALSE, callFrom = NULL, debug = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="htmlSpecCharConv_+3A_txt">txt</code></td>
<td>
<p>character vector, including special characters</p>
</td></tr>
<tr><td><code id="htmlSpecCharConv_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="htmlSpecCharConv_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
<tr><td><code id="htmlSpecCharConv_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a corrected character vector adopted for html display
</p>


<h3>See Also</h3>

<p>tables on <a href="https://www.htmlhelp.com/reference/html40/entities/latin1.html">https://www.htmlhelp.com/reference/html40/entities/latin1.html</a>,  
<a href="https://www.degraeve.com/reference/specialcharacters.php">https://www.degraeve.com/reference/specialcharacters.php</a>, or <code>https://ascii.cl/htmlcodes.htm</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## we'll use the package stringi to generate text including the 'micro'-symbol as input
x &lt;- if(requireNamespace("stringi", quietly=TRUE)) {
  stringi::stri_unescape_unicode("\\u00b5\\u003d\\u0061\\u0062")} else "\"x=axb\""
htmlSpecCharConv(x)
</code></pre>

<hr>
<h2 id='keepCommonText'>Extract Longest Common Text Out Of Character Vector</h2><span id='topic+keepCommonText'></span>

<h3>Description</h3>

<p>This function allows recovering the single longest common text-fragments (from center, head or tail) out of character vector <code>txt</code>.
Only the first of all of the longest solutions will be returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keepCommonText(
  txt,
  minNchar = 1,
  side = "center",
  hiResol = TRUE,
  silent = TRUE,
  callFrom = NULL,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keepCommonText_+3A_txt">txt</code></td>
<td>
<p>character vector to be treated</p>
</td></tr>
<tr><td><code id="keepCommonText_+3A_minnchar">minNchar</code></td>
<td>
<p>(integer) minumin number of characters that must remain</p>
</td></tr>
<tr><td><code id="keepCommonText_+3A_side">side</code></td>
<td>
<p>(character) may be be either 'center', 'any', 'terminal', 'left' or 'right'; only with <code>side='center'</code> or <code>'any'</code> internal text-segments may be found</p>
</td></tr>
<tr><td><code id="keepCommonText_+3A_hiresol">hiResol</code></td>
<td>
<p>(logical) find best solution, but at much higher comptational cost (eg 3x slower, however <code>hiResol=FALSE</code> rather finds anchor which may need to get extended)</p>
</td></tr>
<tr><td><code id="keepCommonText_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="keepCommonText_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
<tr><td><code id="keepCommonText_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please note, that finding common parts between chains of characters is not a completely trivial task. 
This topic still has ongoing research for the application of sequence-alignments, where chains of characters to be compared get very long.
This function uses a k-mer inspirated approach.
The initial aim with this function was allowing to treat smaller chains of characters (and finding shorter strteches of common text), like eg with column-names.
</p>
<p>Important : This function identifies only the first best hit, ie other shared/common character-chains of the same length will not be found !
</p>
<p>Using the argument <code>hiResol=FALSE</code> it is possible to accelerate the search aprox 3x (with larger character-vectors), however, frequently the very best solution may not be found. 
This means, that in this case the result should rather be considered a 'seed', allowing check if further extension may improve the result, 
ie for identifying a (slightly) longer chain of common characters.
</p>
<p>With longer vectors and longer character chains this may get demanding on computational reesources, the argument <code>hiResol=FALSE</code> allows reducing this at the price of missing the best solution.
With this argument single common/matching characters will not be searched if all text-elements are longer than 500 characters, an empty character vector will be returned. 
</p>
<p>When argument <code>side</code> is either <code>left</code>, <code>right</code> or <code>terminal</code> only terminal common text may be found (a potentially even longer internal text will be lost).
Of course, choosing this option makes searches much faster.  
</p>
<p>This function does not return the position of the shared/common characters within the text, you may use <code>gregexpr</code> or <code>regexec</code> to locate them.
</p>


<h3>Value</h3>

<p>This function returns a character vector of length=1, ie only one (normally the longest) common sequence of characters is identified.
If nothing is found common/shared an empty character-vector is returned
</p>


<h3>See Also</h3>

<p>Use <code>gregexpr</code> or <code>regexec</code> in <code><a href="base.html#topic+grep">grep</a></code> for locating the identified common characters in the initial query.
</p>
<p>Inverse : Trim redundant text (from either side) to keep only varaible part using <code><a href="#topic+trimRedundText">trimRedundText</a></code>; 
you may also look for related functions in package <a href="https://CRAN.R-project.org/package=stringr">stringr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>txt1 &lt;- c("abcd_abc_kjh", "bcd_abc123", "cd_abc_po")
keepCommonText(txt1, side="center")       # trim from right

txt2 &lt;- c("ddd_ab","ddd_bcd","ddd_cde")
trimRedundText(txt2, side="left")          #  
keepCommonText(txt2, side="center")        # 
</code></pre>

<hr>
<h2 id='levIndex'>Transform (factor) levels into index</h2><span id='topic+levIndex'></span>

<h3>Description</h3>

<p>This function helps transforming a numeric or character vector into indexes of levels (of its original values).
By default indexes are assigned by order of occurance, ie, the first value of <code>x</code> will be get the index of 1.
Using the argument <code>byOccurance=FALSE</code> the resultant indexes will follow the sorted values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>levIndex(
  dat,
  byOccurance = TRUE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="levIndex_+3A_dat">dat</code></td>
<td>
<p>(numeric or character vector or factor) main input</p>
</td></tr>
<tr><td><code id="levIndex_+3A_byoccurance">byOccurance</code></td>
<td>
<p>(logical) toogle if lowest index should be based on alphabetical order or on order of input</p>
</td></tr>
<tr><td><code id="levIndex_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="levIndex_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="levIndex_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with mean values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowSds">rowSds</a></code>, <code><a href="base.html#topic+colSums">colSums</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- letters[rep(c(5,2:3),1:3)]
levIndex(x1)
levIndex(x1, byOccurance=FALSE)
## with factor 
fa1 &lt;- factor(letters[rep(c(5,2:3),1:3)], levels=letters[1:6])
levIndex(fa1)
levIndex(fa1, byOccurance=FALSE)
</code></pre>

<hr>
<h2 id='linModelSelect'>Test multiple starting levels for linear regression model, select best and plot</h2><span id='topic+linModelSelect'></span>

<h3>Description</h3>

<p>The aim of this function is to select the data suiting set of levels of the main input data to construct a linear regression model. 
In real world measurements one may be confronted to the case of very low level analytes below the detection limit (LOD) and resulting read-outs fluctuate around around a common baseline (instead of <code>NA</code>). 
With such data it may be preferable to omit the read-outs for the lowest concentrations/levels of analytes if they are spread around a base-line value.
This function allows trying to omit all starting levels designed in <code>startLev</code>, then the resulting p-values for the linear regression slopes will be checked and the best p-value chosen. 
The input may also be a MArrayLM-type object from package <a href="https://bioconductor.org/packages/release/bioc/html/limma.html">limma</a> or from <code><a href="#topic+moderTestXgrp">moderTestXgrp</a></code> or <code><a href="#topic+moderTest2grp">moderTest2grp</a></code>.
In the graphical representation all points assocoated to levels omitted are shown in light green.
For the graphical display additional information can be used : If the  <code>dat</code> is list or MArrayLM-type object, 
the list-elements $raw (according to argument <code>lisNa</code> will be used to display points initially given as NA ad imputed lateron in grey.
Logarithmic (ie log-linear) data can be treated by settting argument <code>logExpect=TRUE</code>. Then the levels will be taken as exponent of 2 for the regression, while the original values will be displayed in the figure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linModelSelect(
  rowNa,
  dat,
  expect,
  logExpect = FALSE,
  startLev = NULL,
  lisNa = c(raw = "raw", annot = "annot", datImp = "datImp"),
  plotGraph = TRUE,
  tit = NULL,
  pch = c(1, 3),
  cexLeg = 0.95,
  cexSub = 0.85,
  xLab = NULL,
  yLab = NULL,
  cexXAxis = 0.85,
  cexYAxis = 0.9,
  xLabLas = 1,
  cexLab = 1.1,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linModelSelect_+3A_rowna">rowNa</code></td>
<td>
<p>(character, length=1) rowname for line to be extracted from <code>dat</code></p>
</td></tr>
<tr><td><code id="linModelSelect_+3A_dat">dat</code></td>
<td>
<p>(matrix, list or MArrayLM-object from limma) main input of which columns should get re-ordered, may be output from <code><a href="#topic+moderTestXgrp">moderTestXgrp</a></code> or <code><a href="#topic+moderTest2grp">moderTest2grp</a></code>.</p>
</td></tr>
<tr><td><code id="linModelSelect_+3A_expect">expect</code></td>
<td>
<p>(numeric of character) the expected levels; if character, constant unit-characters will be stripped away to extact the numeric content</p>
</td></tr>
<tr><td><code id="linModelSelect_+3A_logexpect">logExpect</code></td>
<td>
<p>(logical) toggle to <code>TRUE</code> if the main data are logarithmic but <code>expect</code> is linear</p>
</td></tr>
<tr><td><code id="linModelSelect_+3A_startlev">startLev</code></td>
<td>
<p>(integer) specify all starting levels to test for omitting here (multiple start sites for modelling linear regression may be specified to finally pick the best model)</p>
</td></tr>
<tr><td><code id="linModelSelect_+3A_lisna">lisNa</code></td>
<td>
<p>(character) in case <code>dat</code> is list or MArrayLM-type object, the list-elements with these names will be used as $raw (for indicating initial <code>NA</code>-values,
$datImp (the main quantitation data to use) and $annot for displaying the corresponding value from the &quot;Accession&quot;-column.</p>
</td></tr>
<tr><td><code id="linModelSelect_+3A_plotgraph">plotGraph</code></td>
<td>
<p>(logical) display figure</p>
</td></tr>
<tr><td><code id="linModelSelect_+3A_tit">tit</code></td>
<td>
<p>(character) optional custom title</p>
</td></tr>
<tr><td><code id="linModelSelect_+3A_pch">pch</code></td>
<td>
<p>(integer) symbols to use n optional plot; 1st for regular values, 2nd for values not used in regression</p>
</td></tr>
<tr><td><code id="linModelSelect_+3A_cexleg">cexLeg</code></td>
<td>
<p>(numeric) size of text in legend</p>
</td></tr>
<tr><td><code id="linModelSelect_+3A_cexsub">cexSub</code></td>
<td>
<p>(numeric) text-size for line (as subtitle) giving regression details of best linear model)</p>
</td></tr>
<tr><td><code id="linModelSelect_+3A_xlab">xLab</code></td>
<td>
<p>(character) custom x-axis label</p>
</td></tr>
<tr><td><code id="linModelSelect_+3A_ylab">yLab</code></td>
<td>
<p>(character) custom y-axis label</p>
</td></tr>
<tr><td><code id="linModelSelect_+3A_cexxaxis">cexXAxis</code></td>
<td>
<p>(character) <code>cex</code>-type for size of text for x-axis labels</p>
</td></tr>
<tr><td><code id="linModelSelect_+3A_cexyaxis">cexYAxis</code></td>
<td>
<p>(character) <code>cex</code>-type for size of text for y-axis labels</p>
</td></tr>
<tr><td><code id="linModelSelect_+3A_xlablas">xLabLas</code></td>
<td>
<p>(integer) <code>las</code>-type orientation of x-axis labels (set to 2 for vertical axix-labels)</p>
</td></tr>
<tr><td><code id="linModelSelect_+3A_cexlab">cexLab</code></td>
<td>
<p>(numeric) <code>cex</code>-type for size of text in x &amp; y axis labels (will be passed to <code>cex.lab</code> in <code>plot()</code>)</p>
</td></tr>
<tr><td><code id="linModelSelect_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="linModelSelect_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="linModelSelect_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with $coef (coefficients), $name (as/from input <code>rowNa</code>), $startLev the best starting level)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+moderTestXgrp">moderTestXgrp</a></code> for single comparisons, <code><a href="base.html#topic+order">order</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Construct data
li1 &lt;- rep(c(4,3,3:6),each=3) + round(runif(18)/5,2)
names(li1) &lt;- paste0(rep(letters[1:5], each=3), rep(1:3,6))
li2 &lt;- rep(c(6,3:7), each=3) + round(runif(18)/5, 2)
dat2 &lt;- rbind(P1=li1, P2=li2)
exp2 &lt;- rep(c(11:16), each=3)

## Check &amp; plot for linear model 
linModelSelect("P2", dat2, expect=exp2)

## Log-Linear data
## Suppose dat2 is result of measures in log2, but exp4 is not
exp4 &lt;- rep(c(3,10,30,100,300,1000), each=3)
linModelSelect("P2", dat2, expect=exp4, logE=FALSE)    # bad
linModelSelect("P2", dat2, expect=exp4, logE=TRUE)

</code></pre>

<hr>
<h2 id='linRegrParamAndPVal'>Fit linear regression, return parameters and p-values</h2><span id='topic+linRegrParamAndPVal'></span>

<h3>Description</h3>

<p>This function fits a linear regression and returns the parameters, including p-values from Anova.
Here the vector 'y' (scalar response or dependent variable, ie the value that should get estimated) will be estimated according to 'dep' (explanatory or independent variable).
Alternatively, 'dep' may me a <code>matrix</code> where 1st column will be used as 'dep and the 2nd column as 'y'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linRegrParamAndPVal(
  dep,
  y = NULL,
  asVect = TRUE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linRegrParamAndPVal_+3A_dep">dep</code></td>
<td>
<p>(numeric vector, matrix or data.frame) explanatory or dependent variable, if matrix or data.frame the 1st column will be used, if 'y'=<code>NULL</code> the 2nd column will be used as 'y'</p>
</td></tr>
<tr><td><code id="linRegrParamAndPVal_+3A_y">y</code></td>
<td>
<p>(numeric vector) independent variable (the value that should get estimated based on 'dep')</p>
</td></tr>
<tr><td><code id="linRegrParamAndPVal_+3A_asvect">asVect</code></td>
<td>
<p>(logical) return numeric vector (Intercept, slope, p.intercept, p.slope) or matrix or results</p>
</td></tr>
<tr><td><code id="linRegrParamAndPVal_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="linRegrParamAndPVal_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="linRegrParamAndPVal_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector (Intercept, slope, p.intercept, p.slope), or if <code>asVect</code>==<code>TRUE</code> as matrix (p.values in 2nd column)
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lm">lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>linRegrParamAndPVal(c(5,5.1,8,8.2),gl(2,2))
</code></pre>

<hr>
<h2 id='listBatchReplace'>Replacements in list</h2><span id='topic+listBatchReplace'></span>

<h3>Description</h3>

<p><code>listBatchReplace</code> replaces in list <code>lst</code> all entries with value <code>searchValue</code> by <code>replaceBy</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listBatchReplace(
  lst,
  searchValue,
  replaceBy,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="listBatchReplace_+3A_lst">lst</code></td>
<td>
<p>input-list to be used for replacing</p>
</td></tr>
<tr><td><code id="listBatchReplace_+3A_searchvalue">searchValue</code></td>
<td>
<p>(character, length=1)</p>
</td></tr>
<tr><td><code id="listBatchReplace_+3A_replaceby">replaceBy</code></td>
<td>
<p>(character, length=1)</p>
</td></tr>
<tr><td><code id="listBatchReplace_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="listBatchReplace_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="listBatchReplace_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a corrected list
</p>


<h3>See Also</h3>

<p>basic replacement <code>sub</code> in <code><a href="base.html#topic+grep">grep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lst1 &lt;- list(aa=1:4, bb=c("abc","efg","abhh","effge"), cc=c("abdc","efg"))
listBatchReplace(lst1, search="efg", repl="EFG", sil=FALSE)
</code></pre>

<hr>
<h2 id='listGroupsByNames'>Organize values into list and sort by names</h2><span id='topic+listGroupsByNames'></span>

<h3>Description</h3>

<p>Sort values of <code>'x'</code> by its names and organize as list by common names, the names until <code>'sep'</code> are used for (re)grouping. 
Note that typical spearators occuring the initial names may need protection by '\' (this is automatically taken care of for the case of the dot ('.') separator).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listGroupsByNames(x, sep = ".", silent = FALSE, debug = FALSE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="listGroupsByNames_+3A_x">x</code></td>
<td>
<p>(list) main input</p>
</td></tr>
<tr><td><code id="listGroupsByNames_+3A_sep">sep</code></td>
<td>
<p>(character) separator (note that typcal separators may need to be protected, only automatically added for '.')</p>
</td></tr>
<tr><td><code id="listGroupsByNames_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="listGroupsByNames_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="listGroupsByNames_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix or data.frame
</p>


<h3>See Also</h3>

<p><code>rbind</code> in <code><a href="base.html#topic+cbind">cbind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>listGroupsByNames((1:10)/5)
ser1 &lt;- 1:6; names(ser1) &lt;- c("AA","BB","AA.1","CC","AA.b","BB.e")
listGroupsByNames(ser1)
</code></pre>

<hr>
<h2 id='lmSelClu'>Run lm on segmented data (from clustering)</h2><span id='topic+lmSelClu'></span>

<h3>Description</h3>

<p><code>lmSelClu</code> runs linear regression on data segmented previously (eg by clustering).  
This functio offers various types of (2-coefficient) linear regression on 2 columns of 'dat' (matrix with 3rd col named 'clu' or 'cluID', numeric elements for cluster-number).
If argument <code>'clu'</code> is (default) 'max', the column 'clu' will be inspected to take most frequent value of 'clu', otherwise a numeric entry specifying the cluster to extract is expected.
Note: this function was initially made for use with results from diagCheck()
Note: this function lacks means of judging godness of fit of the regression preformed &amp; means for plotting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmSelClu(
  dat,
  useCol = 1:2,
  clu = "max",
  regTy = "lin",
  filt1 = NULL,
  filt2 = NULL,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmSelClu_+3A_dat">dat</code></td>
<td>
<p>matrix or data.frame</p>
</td></tr>
<tr><td><code id="lmSelClu_+3A_usecol">useCol</code></td>
<td>
<p>(integer or charcter) specify which 2 columns of 'dat' to use for linear regression</p>
</td></tr>
<tr><td><code id="lmSelClu_+3A_clu">clu</code></td>
<td>
<p>(character) name of cluster to be extracted and treatad</p>
</td></tr>
<tr><td><code id="lmSelClu_+3A_regty">regTy</code></td>
<td>
<p>(character) change type used for linear regression :  'lin' for 1st col ~ 2nd col, 'res' for residue ~ 2nd col, 'norRes' for residue/2nd col ~2nd col or 'sqNorRes','inv' for 1st col ~ 1/(2nd col), 'invRes' for residue ~ 1/(2nd col)</p>
</td></tr>
<tr><td><code id="lmSelClu_+3A_filt1">filt1</code></td>
<td>
<p>(logical or numerical) filter criteria for 1st of 'useCol' , if numeric then select all lines of dat less than max of filt1</p>
</td></tr>
<tr><td><code id="lmSelClu_+3A_filt2">filt2</code></td>
<td>
<p>(logical or numerical) filter criteria for 2nd of 'useCol' , if numeric then select all lines of dat less than max of filt2</p>
</td></tr>
<tr><td><code id="lmSelClu_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="lmSelClu_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="lmSelClu_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>lm object (or NULL if no data left)
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lm">lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016); ran1 &lt;- runif(220)
mat1 &lt;- round(rbind(matrix(c(1:100+ran1[1:100],rep(1,50)),ncol=3), 
  matrix(c(1:60,68:9+ran1[101:160],rep(2,60)),nc=3)),1)
colnames(mat1) &lt;- c("a","BB","clu")
lmSelClu(mat1)
plot(mat1[which(mat1[,3]=="2"),1:2],col=grey(0.6))
abline(lmSelClu(mat1),lty=2,lwd=2)
# 
mat2 &lt;- round(rbind(matrix(c(1:100+ran1[1:100],rep(1,50)),ncol=3), 
  matrix(c(1:60,(2:61+ran1[101:160])^2,rep(2,60)),nc=3)),1)
colnames(mat2) &lt;- c("a","BB","clu")
(reg2 &lt;- lmSelClu(mat2,regTy="sqNor"))
plot(function(x) coef(reg2)[2]+ (coef(reg2)[2]*x^2),xlim=c(1,70))
points(mat2[which(mat2[,3]=="2"),1:2],col=2)
</code></pre>

<hr>
<h2 id='lrbind'>rbind on lists</h2><span id='topic+lrbind'></span>

<h3>Description</h3>

<p>rbind-like function to append list-elements containing matrixes (or data.frames) and return one long table. 
All list-elements must have same number of columns (and same types of classes in case of data.frames.
Simple vectors (as list-elements) will be considered as sigle lines for attaching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lrbind(lst, silent = FALSE, debug = FALSE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lrbind_+3A_lst">lst</code></td>
<td>
<p>(list, composed of multiple matrix or data.frames or simple vectors) main input (each list-element should have same number of columns, numeric vectors will be converted to number of columns of other columns/elements)</p>
</td></tr>
<tr><td><code id="lrbind_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="lrbind_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="lrbind_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns (depending on input) a matrix or data.frame
</p>


<h3>See Also</h3>

<p><code>rbind</code> in <code><a href="base.html#topic+cbind">cbind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lst1 &lt;- list(matrix(1:9, ncol=3, dimnames=list(letters[1:3],c("AA","BB","CC"))),
  11:13, matrix(51:56, ncol=3))
lrbind(lst1)
</code></pre>

<hr>
<h2 id='makeMAList'>Make MA-List object</h2><span id='topic+makeMAList'></span>

<h3>Description</h3>

<p><code>makeMAList</code> extracts sets of data-pairs (like R &amp; G series) and makes MA objects as <code>MA-List object</code> (eg for ratio oriented analysis).
The grouping of columns as sets of replicate-measurements is done according to argumnet <code>'MAfac'</code>.
The output is fully compatible to functions of package <a href="https://bioconductor.org/packages/release/bioc/html/limma.html">limma</a> (Bioconductor).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMAList(
  mat,
  MAfac,
  useF = c("R", "G"),
  isLog = TRUE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeMAList_+3A_mat">mat</code></td>
<td>
<p>main input matrix</p>
</td></tr>
<tr><td><code id="makeMAList_+3A_mafac">MAfac</code></td>
<td>
<p>(factor) factor orgnaizing columns of 'mat' (if <code>useF</code> contains the default 'R' and 'G', they should also be part of <code>MAfac</code>)</p>
</td></tr>
<tr><td><code id="makeMAList_+3A_usef">useF</code></td>
<td>
<p>(character) two specific factor-leves of <code>MAfac</code> that will be used/extracted</p>
</td></tr>
<tr><td><code id="makeMAList_+3A_islog">isLog</code></td>
<td>
<p>(logical) tell if data is already log2 (will be considered when computing M and A values)</p>
</td></tr>
<tr><td><code id="makeMAList_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="makeMAList_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="makeMAList_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires Bioconductor package <a href="https://bioconductor.org/packages/release/bioc/html/limma.html">limma</a> being installed.
</p>


<h3>Value</h3>

<p>limma-type &quot;MAList&quot; containing M and A values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+test2factLimma">test2factLimma</a></code>, for creating RG-lists within limma: <code>MA.RG</code> in <code><a href="limma.html#topic+normalizeWithinArrays">normalizeWithinArrays</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2017); t4 &lt;- matrix(round(runif(40,1,9),2), ncol=4,
  dimnames=list(letters[c(1:5,3:4,6:4)], c("AA1","BB1","AA2","BB2")))
makeMAList(t4, gl(2,2,labels=c("R","G")))
</code></pre>

<hr>
<h2 id='makeNRedMatr'>Make non-redundant matrix</h2><span id='topic+makeNRedMatr'></span>

<h3>Description</h3>

<p><code>makeNRedMatr</code> takes matrix or data.frame 'dat' to summarize redundant lines (column argument <code>iniID</code>) along method specified in <code>summarizeRedAs</code> 
to treat all lines with redundant <code>iniID</code> by same approach (ie for all columns the line where specified column is at eg max = 'maxOfRef' ).
If no name given, the function will take the last numeric (factors may be used - they will be read as levels).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeNRedMatr(
  dat,
  summarizeRedAs,
  iniID = "iniID",
  retDataFrame = TRUE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeNRedMatr_+3A_dat">dat</code></td>
<td>
<p>(matrix or data.frame) main input for making non-redundant</p>
</td></tr>
<tr><td><code id="makeNRedMatr_+3A_summarizeredas">summarizeRedAs</code></td>
<td>
<p>(character) summarization method(s), typical choices 'median','mean','min' or 'maxOfRef','maxAbsOfRef' for summarizing according to 1 specified column, may be single method for all or different method for each column (besides col 'iniID') or special method looking at column (if found, first of special methods used, everything else not considered).</p>
</td></tr>
<tr><td><code id="makeNRedMatr_+3A_iniid">iniID</code></td>
<td>
<p>(character) column-name used as initial ID (default=&quot;iniID&quot;)</p>
</td></tr>
<tr><td><code id="makeNRedMatr_+3A_retdataframe">retDataFrame</code></td>
<td>
<p>(logical) if TRUE, check if text-columns may be converted to data.frame with numeric</p>
</td></tr>
<tr><td><code id="makeNRedMatr_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="makeNRedMatr_+3A_debug">debug</code></td>
<td>
<p>(logical) for bug-tracking: more/enhanced messages</p>
</td></tr>
<tr><td><code id="makeNRedMatr_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a (numeric) matrix or data.frame with summarized data and add'l col with number of initial redundant lines
</p>


<h3>See Also</h3>

<p>simple/partial functionality in <code><a href="#topic+summarizeCols">summarizeCols</a></code>,  <code><a href="#topic+checkSimValueInSer">checkSimValueInSer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t3 &lt;- data.frame(ref=rep(11:15,3),tx=letters[1:15],
  matrix(round(runif(30,-3,2),1),nc=2),stringsAsFactors=FALSE)
by(t3,t3[,1],function(x) x)
t(sapply(by(t3,t3[,1],function(x) x), summarizeCols, me="maxAbsOfRef"))
(xt3 &lt;- makeNRedMatr(t3, summ="mean", iniID="ref"))
(xt3 &lt;- makeNRedMatr(t3, summ=unlist(list(X1="maxAbsOfRef")), iniID="ref"))
</code></pre>

<hr>
<h2 id='matchMatrixLinesToRef'>Match All Lines of Matrix To Reference Note</h2><span id='topic+matchMatrixLinesToRef'></span>

<h3>Description</h3>

<p>This function allows adjusting the order of lines of a matrix <code>mat</code> to a reference character-vector <code>ref</code>,
even when initial direct matching of character-strings using <code>match</code> is not possible/successful.
In this case, various variants of using <code>grep</code> will be used to see if unambiguous matching is possible of characteristic parts of the text.
All columns of <code>mat</code> will be tested an the column giving the bes resuts will be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchMatrixLinesToRef(
  mat,
  ref,
  addRef = TRUE,
  inclInfo = FALSE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchMatrixLinesToRef_+3A_mat">mat</code></td>
<td>
<p>(matrix or data.frame) main input, all columns of <code>mat</code> will be tested for (partial) matching of <code>ref</code></p>
</td></tr>
<tr><td><code id="matchMatrixLinesToRef_+3A_ref">ref</code></td>
<td>
<p>(character, length must match ) reference for trying to match each of the columns of  <code>mat</code></p>
</td></tr>
<tr><td><code id="matchMatrixLinesToRef_+3A_addref">addRef</code></td>
<td>
<p>(logical), if <code>TRUE</code> the content of <code>ref</code> will be added to  <code>mat</code> as additional column</p>
</td></tr>
<tr><td><code id="matchMatrixLinesToRef_+3A_inclinfo">inclInfo</code></td>
<td>
<p>(logical) allows returning list with new matrix and additional information</p>
</td></tr>
<tr><td><code id="matchMatrixLinesToRef_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="matchMatrixLinesToRef_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="matchMatrixLinesToRef_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests all columns of <code>mat</code> to find perfect matching results to the reference <code>ref</code>.
In case of multiple results the
In case no direct matching is possible, <code>grep</code> will be used to find the best partial matching.
The orderof the rows of input <code>mat</code> will be adjusted according to the matching results.
</p>
<p>If <code>addRef=TRUE</code>, the reference will be included as additional column to the results, too.
</p>


<h3>Value</h3>

<p>This function returns the input matrix in an adjusted order (plus an optional additional column showing the reference)
or if <code>inclInfo=TRUE</code> a list with $mat (adjusted matrix), $byColumn, $newOrder and $method;
the reference can bee added as additional last column if <code>addRef=TRUE</code>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+match">match</a></code>,  <code><a href="base.html#topic+grep">grep</a></code>, <code><a href="#topic+trimRedundText">trimRedundText</a></code>, <code><a href="#topic+replicateStructure">replicateStructure</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Note : columns b and e allow non-ambigous match, not all elements of e are present in a
mat0 &lt;- cbind(a=c("mvvk","axxd","bxxd","vv"),b=c("iwwy","iyyu","kvvh","gxx"), c=rep(9,4),
  d=c("hgf","hgf","vxc","nvnn"), e=c("_vv_","_ww_","_xx_","_yy_"))
matchMatrixLinesToRef(mat0[,1:4], ref=mat0[,5])
matchMatrixLinesToRef(mat0[,1:4], ref=mat0[1:3,5], inclInfo=TRUE)

matchMatrixLinesToRef(mat0[,-2], ref=mat0[,2], inclInfo=TRUE)   # needs 'reverse grep'
</code></pre>

<hr>
<h2 id='matchNamesWithReverseParts'>Value Matching with optional reversing of sub-parts of non-matching elements</h2><span id='topic+matchNamesWithReverseParts'></span>

<h3>Description</h3>

<p>This function provides a variant to <code><a href="base.html#topic+match">match</a></code>, where initially non-matching elements of <code>x</code>  
will be tested by decomposing non-matching elements, reversing the parts in front and after the separator <code>sep</code> and re-matching.
If separator <code>sep</code> does not occur, a warning will be issued, if it occurs more than once, 
the parts before and after the first separartor will be used and a warning issued.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchNamesWithReverseParts(
  x,
  y,
  sep = "-",
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchNamesWithReverseParts_+3A_x">x</code></td>
<td>
<p>(character) first vector for match</p>
</td></tr>
<tr><td><code id="matchNamesWithReverseParts_+3A_y">y</code></td>
<td>
<p>(character) second vector for match</p>
</td></tr>
<tr><td><code id="matchNamesWithReverseParts_+3A_sep">sep</code></td>
<td>
<p>(character) separator between elements</p>
</td></tr>
<tr><td><code id="matchNamesWithReverseParts_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="matchNamesWithReverseParts_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="matchNamesWithReverseParts_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>index for matching (integer) x to y
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+match">match</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tx1 &lt;- c("a-b","a-c","d-a","d-b","b-c","d-c")
tmp &lt;- triCoord(4)
tx2 &lt;- paste(letters[tmp[,1]],letters[tmp[,2]],sep="-")
## Some matches won't be found, since 'a-d' got reversed to 'd-a', etc... 
match(tx1,tx1)  
matchNamesWithReverseParts(tx1,tx2)
</code></pre>

<hr>
<h2 id='matchSampToPairw'>Match names to concatenated pairs of names</h2><span id='topic+matchSampToPairw'></span>

<h3>Description</h3>

<p>The column-names of multiple pairwise testing contain the names of the initial groups/conditions tested, plus there is a separator (eg '-' in <code>moderTestXgrp</code>).  
Thus function allows to map back which groups/conditions were used by returning the index of the respective groups used in pair-wise sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchSampToPairw(
  grpNa,
  pairwNa,
  sep = NULL,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchSampToPairw_+3A_grpna">grpNa</code></td>
<td>
<p>(character) the names of the groups of replicates (ie conditions) used to test</p>
</td></tr>
<tr><td><code id="matchSampToPairw_+3A_pairwna">pairwNa</code></td>
<td>
<p>(character) the names of pairwise-testing (ie 'concatenated' <code>sampNa</code></p>
</td></tr>
<tr><td><code id="matchSampToPairw_+3A_sep">sep</code></td>
<td>
<p>(character) if not <code>NULL</code> the characters given will be used via <code>stringsplit</code></p>
</td></tr>
<tr><td><code id="matchSampToPairw_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="matchSampToPairw_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="matchSampToPairw_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two modes of operation : 1) Argument <code>sep</code> is set to <code>NULL</code> :  The names of initial groups/conditions (<code>grpNa</code>) 
will be tested for exact pattern matching either at beginning or at end of pair-wise names (<code>pairwNa</code>).
This approach has the advantage that it does not need to be known what character(s) were used as separator (or they may change), 
but the disadvantage that in case the perfect <code>grpNa</code> was not given, the longest best match of <code>grpNa</code> will be returned.
</p>
<p>2) The separator <code>sep</code> is given and exact matches at both sides will be searched.
However, if the character(s) from <code>sep</code> do appear inside <code>grpNa</code> no matches will be found.
</p>
<p>If some <code>grpNa</code> are not found in <code>pairwNa</code> this will be marked as NA.
</p>


<h3>Value</h3>

<p>matrix of 2 columns with inidices of <code>sampNa</code> with <code>pairwNa</code> as rows
</p>


<h3>See Also</h3>

<p>(for running multiple pair-wise test) <code><a href="#topic+moderTestXgrp">moderTestXgrp</a></code>, <code><a href="base.html#topic+grep">grep</a></code>, <code><a href="base.html#topic+strsplit">strsplit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pairwNa1 &lt;- c("abc-efg","abc-hij","efg-hij")
grpNa1 &lt;- c("hij","abc","abcc","efg","klm")
matchSampToPairw(grpNa1, pairwNa1) 

pairwNa2 &lt;- c("abc-efg","abcc-hij","abc-hij","abc-hijj","zz-zz","efg-hij")
matchSampToPairw(grpNa1, pairwNa2) 
</code></pre>

<hr>
<h2 id='matr2list'>Transform columns of matrix to list of vectors</h2><span id='topic+matr2list'></span>

<h3>Description</h3>

<p>convert matrix to list of vectors: each column of 'mat' as vector of list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matr2list(mat, concSym = ".", silent = FALSE, debug = TRUE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matr2list_+3A_mat">mat</code></td>
<td>
<p>(matrix) main input</p>
</td></tr>
<tr><td><code id="matr2list_+3A_concsym">concSym</code></td>
<td>
<p>(character) symbol for concatenating: concatenation of named vectors in list names as colname(s)+'concSym'+rowname</p>
</td></tr>
<tr><td><code id="matr2list_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="matr2list_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="matr2list_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix or array (1st dim is intraplate-position, 2nd .. plate-group/type, 3rd .. channels)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+convToNum">convToNum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat1 &lt;- matrix(1:12,ncol=3,dimnames=list(letters[1:4],LETTERS[1:3]))
mat2 &lt;- matrix(LETTERS[11:22],ncol=3,dimnames=list(letters[1:4],LETTERS[1:3]))
matr2list(mat1);  matr2list(mat2)
</code></pre>

<hr>
<h2 id='mergeMatrices'>Merge Multiple Matrices</h2><span id='topic+mergeMatrices'></span>

<h3>Description</h3>

<p>This function allows merging of multiple matrix-like objects.
The matix-rownames will be used to align common elements, either be returning all common elements <code>mode='intersect'</code> or containg all elements <code>mode='union'</code> (the result may contains additional <code>NA</code>s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeMatrices(
  ...,
  mode = "intersect",
  useColumn = 1,
  na.rm = TRUE,
  extrRowNames = FALSE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeMatrices_+3A_...">...</code></td>
<td>
<p>(matrix or data.frame) multiple matrix or data.frame objects may be entered</p>
</td></tr>
<tr><td><code id="mergeMatrices_+3A_mode">mode</code></td>
<td>
<p>(character) allows choosing restricting to all common elements (<code>mode='intersect'</code>) or union  (<code>mode='union'</code>)</p>
</td></tr>
<tr><td><code id="mergeMatrices_+3A_usecolumn">useColumn</code></td>
<td>
<p>(integer, character or list) the column(s) to consider, may be <code>'all'</code> to use all, integer to select specific indexes or list of indexes or colnames for cutom-selection per matrix</p>
</td></tr>
<tr><td><code id="mergeMatrices_+3A_na.rm">na.rm</code></td>
<td>
<p>(logical) suppress <code>NA</code>s</p>
</td></tr>
<tr><td><code id="mergeMatrices_+3A_extrrownames">extrRowNames</code></td>
<td>
<p>(logical) decide whether columns with all values different (ie no replicates or max divergency) should be excluded</p>
</td></tr>
<tr><td><code id="mergeMatrices_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="mergeMatrices_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="mergeMatrices_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Custom column-names can be given by entering matrices like named arguments (see examples below).
The choice of columns tu use may be adopted to each matrix entered, in this case the argument <code>useColumn</code> may be a list with matrix-names to use or a list of indexes (see examples below).
</p>
<p>Note, that matrices may contain repeated rownames (see examples, <code>mat3</code>). In this case only the first of repeated rownames will be considered (and lines of repeated names ignored).
</p>


<h3>Value</h3>

<p>This function returns a matrix containing all selected columns of the input matrices to fuse
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+merge">merge</a></code>,  <code><a href="#topic+mergeMatrixList">mergeMatrixList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat1 &lt;- matrix(11:18, ncol=2, dimnames=list(letters[3:6],LETTERS[1:2]))
mat2 &lt;- matrix(21:28, ncol=2, dimnames=list(letters[2:5],LETTERS[3:4]))
mat3 &lt;- matrix(31:38, ncol=2, dimnames=list(letters[c(1,3:4,3)],LETTERS[4:5]))

mergeMatrices(mat1, mat2)
mergeMatrices(mat1, mat2, mat3, mode="union", useCol=2)
## custom names for matrix-origin
mergeMatrices(m1=mat1, m2=mat2, mat3, mode="union", useCol=2)
## flexible/custom selection of columns
mergeMatrices(m1=mat1, m2=mat2, mat3, mode="union", useCol=list(1,1:2,2))
</code></pre>

<hr>
<h2 id='mergeMatrixList'>Merge Multiple Matrices from List</h2><span id='topic+mergeMatrixList'></span>

<h3>Description</h3>

<p>This function allows merging of multiple matrix-like objects from an initial list.
The matix-rownames will be used to align common elements, either be returning all common elements <code>mode='intersect'</code> or containg all elements <code>mode='union'</code> (the result may contains additional <code>NA</code>s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeMatrixList(
  matLst,
  mode = "intersect",
  useColumn = 1,
  na.rm = TRUE,
  extrRowNames = FALSE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeMatrixList_+3A_matlst">matLst</code></td>
<td>
<p>(list containing matrices or data.frames) main input (multiple matrix or data.frame objects)</p>
</td></tr>
<tr><td><code id="mergeMatrixList_+3A_mode">mode</code></td>
<td>
<p>(character) allows choosing restricting to all common elements (<code>mode='intersect'</code>) or union  (<code>mode='union'</code>)</p>
</td></tr>
<tr><td><code id="mergeMatrixList_+3A_usecolumn">useColumn</code></td>
<td>
<p>(integer, character or list) the column(s) to consider, may be <code>'all'</code> to use all, integer to select specific indexes or list of indexes or colnames for cutom-selection per matrix</p>
</td></tr>
<tr><td><code id="mergeMatrixList_+3A_na.rm">na.rm</code></td>
<td>
<p>(logical) suppress <code>NA</code>s</p>
</td></tr>
<tr><td><code id="mergeMatrixList_+3A_extrrownames">extrRowNames</code></td>
<td>
<p>(logical) decide whether columns with all values different (ie no replicates or max divergency) should be excluded</p>
</td></tr>
<tr><td><code id="mergeMatrixList_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="mergeMatrixList_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="mergeMatrixList_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Custom column-names can be given by entering matrices like named arguments (see examples below).
The choice of columns tu use may be adopted to each matrix entered, in this case the argument <code>useColumn</code> may be a list with matrix-names to use or a list of indexes (see examples below).
</p>
<p>Note, that matrices may contain repeated rownames (see examples, <code>mat3</code>). In this case only the first of repeated rownames will be considered (and lines of repeated names ignored).
</p>


<h3>Value</h3>

<p>This function returns a matrix containing all selected columns of the input matrices to fuse
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+merge">merge</a></code>,  <code><a href="#topic+mergeMatrices">mergeMatrices</a></code> for separate entries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat1 &lt;- matrix(11:18, ncol=2, dimnames=list(letters[3:6],LETTERS[1:2]))
mat2 &lt;- matrix(21:28, ncol=2, dimnames=list(letters[2:5],LETTERS[3:4]))
mat3 &lt;- matrix(31:38, ncol=2, dimnames=list(letters[c(1,3:4,3)],LETTERS[4:5]))

mergeMatrixList(list(mat1, mat2))

mergeMatrixList(list(m1=mat1, m2=mat2, mat3), mode="union", useCol=2)
</code></pre>

<hr>
<h2 id='mergeSelCol'>Merge selected columns out of 2 matrix or data.frames</h2><span id='topic+mergeSelCol'></span>

<h3>Description</h3>

<p>This function merges selected columns out of 2 matrix or data.frames.
'selCols' will be used to define columns to be used; optionally may be different for 'dat2' : define in 'supCols2'. 
Output-cols will get additions specified in newSuff (default '.x' and '.y')
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeSelCol(
  dat1,
  dat2,
  selCols,
  supCols2 = NULL,
  byC = NULL,
  useAll = FALSE,
  setRownames = TRUE,
  newSuff = c(".x", ".y"),
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeSelCol_+3A_dat1">dat1</code></td>
<td>
<p>matrix or data.frame for fusing</p>
</td></tr>
<tr><td><code id="mergeSelCol_+3A_dat2">dat2</code></td>
<td>
<p>matrix or data.frame for fusing</p>
</td></tr>
<tr><td><code id="mergeSelCol_+3A_selcols">selCols</code></td>
<td>
<p>will be used to define columns to be used; optionally may be different for 'dat2' : define in 'supCols2'</p>
</td></tr>
<tr><td><code id="mergeSelCol_+3A_supcols2">supCols2</code></td>
<td>
<p>if additional column-names should be extracted form dat2</p>
</td></tr>
<tr><td><code id="mergeSelCol_+3A_byc">byC</code></td>
<td>
<p>(character) 'by' value used in <code><a href="base.html#topic+merge">merge</a></code></p>
</td></tr>
<tr><td><code id="mergeSelCol_+3A_useall">useAll</code></td>
<td>
<p>(logical) use all lines (will produce NAs when given identifyer not found un 2nd group of data)</p>
</td></tr>
<tr><td><code id="mergeSelCol_+3A_setrownames">setRownames</code></td>
<td>
<p>(logical) if <code>TRUE</code>, will use values of col used as 'by' as rownames instead of showing as add'l col in output</p>
</td></tr>
<tr><td><code id="mergeSelCol_+3A_newsuff">newSuff</code></td>
<td>
<p>(character) prefix (argument 'suffixes' in <code>merge</code>)</p>
</td></tr>
<tr><td><code id="mergeSelCol_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="mergeSelCol_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="mergeSelCol_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a data.frame containing the merged columns
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+merge">merge</a></code>, merge 3 data.frames using <code><a href="#topic+mergeSelCol3">mergeSelCol3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat1 &lt;- matrix(c(1:7,letters[1:7],11:17), ncol=3, dimnames=list(LETTERS[1:7],c("x1","x2","x3")))
mat2 &lt;- matrix(c(1:6,c("b","a","e","f","g","k"), 31:36),
  ncol=3, dimnames=list(LETTERS[11:16],c("y1","x2","x3")))
mergeSelCol(mat1, mat2, selC=c("x2","x3"))
</code></pre>

<hr>
<h2 id='mergeSelCol3'>mergeSelCol3</h2><span id='topic+mergeSelCol3'></span>

<h3>Description</h3>

<p>successive merge of selected columns out of 3 matrix or data.frames.
'selCols' will be used to define columns to be used; optionally may be different for 'dat2' : define in 'supCols2'. 
Output-cols will get additions specified in newSuff (default '.x' and '.y')
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeSelCol3(
  dat1,
  dat2,
  dat3,
  selCols,
  supCols2 = NULL,
  supCols3 = NULL,
  byC = NULL,
  useAll = FALSE,
  setRownames = TRUE,
  newSuff = c(".x", ".y", ".z"),
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeSelCol3_+3A_dat1">dat1</code></td>
<td>
<p>matrix or data.frame for fusing</p>
</td></tr>
<tr><td><code id="mergeSelCol3_+3A_dat2">dat2</code></td>
<td>
<p>matrix or data.frame for fusing</p>
</td></tr>
<tr><td><code id="mergeSelCol3_+3A_dat3">dat3</code></td>
<td>
<p>matrix or data.frame for fusing</p>
</td></tr>
<tr><td><code id="mergeSelCol3_+3A_selcols">selCols</code></td>
<td>
<p>will be used to define columns to be used; optionally may be different for 'dat2' : define in 'supCols2'</p>
</td></tr>
<tr><td><code id="mergeSelCol3_+3A_supcols2">supCols2</code></td>
<td>
<p>if additional column-names should be extracted form dat2</p>
</td></tr>
<tr><td><code id="mergeSelCol3_+3A_supcols3">supCols3</code></td>
<td>
<p>if additional column-names should be extracted form dat3</p>
</td></tr>
<tr><td><code id="mergeSelCol3_+3A_byc">byC</code></td>
<td>
<p>(character) 'by' value used in <code><a href="base.html#topic+merge">merge</a></code></p>
</td></tr>
<tr><td><code id="mergeSelCol3_+3A_useall">useAll</code></td>
<td>
<p>(logical) use all lines (will produce NAs when given identifyer not found un 2nd group of data)</p>
</td></tr>
<tr><td><code id="mergeSelCol3_+3A_setrownames">setRownames</code></td>
<td>
<p>if <code>TRUE</code>, will use values of col used as 'by' as rownames instead of showing as add'l col in output</p>
</td></tr>
<tr><td><code id="mergeSelCol3_+3A_newsuff">newSuff</code></td>
<td>
<p>(character) prefix (argument 'suffixes' in <code>merge</code>)</p>
</td></tr>
<tr><td><code id="mergeSelCol3_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="mergeSelCol3_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="mergeSelCol3_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a data.frame containing the merged columns
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+merge">merge</a></code>, <code><a href="#topic+mergeSelCol">mergeSelCol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat1 &lt;- matrix(c(1:7,letters[1:7],11:17),ncol=3,dimnames=list(LETTERS[1:7],c("x1","x2","x3")))
mat2 &lt;- matrix(c(1:6,c("b","a","e","f","g","k"),31:36), ncol=3,
  dimnames=list(LETTERS[11:16],c("y1","x2","x3")))
mat3 &lt;- matrix(c(1:6,c("c","a","e","b","g","k"),51:56), ncol=3,
  dimnames=list(LETTERS[11:16],c("z1","x2","x3")))
mergeSelCol3(mat1, mat2, mat3, selC=c("x2","x3"))
</code></pre>

<hr>
<h2 id='mergeVectors'>Merge Named Vectors</h2><span id='topic+mergeVectors'></span>

<h3>Description</h3>

<p>This function allows merging for multiple named vectors (each element needs to be named).
Basically, all elements carrying the same name across different input-vectors will be aligned in the same column of the output (input-vectors appear as lines).
If vectors are not given using a name (see first example below), they will be names 'x.1' etc (see argument <code>namePrefix</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeVectors(
  ...,
  namePrefix = "x.",
  NAto0 = FALSE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeVectors_+3A_...">...</code></td>
<td>
<p>all vectors that need to be merged</p>
</td></tr>
<tr><td><code id="mergeVectors_+3A_nameprefix">namePrefix</code></td>
<td>
<p>(character) prefix to numers used when vectors are not given with explicit names (second exammple)</p>
</td></tr>
<tr><td><code id="mergeVectors_+3A_nato0">NAto0</code></td>
<td>
<p>(logical) optional replacemet of <code>NA</code>s by 0</p>
</td></tr>
<tr><td><code id="mergeVectors_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="mergeVectors_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="mergeVectors_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note : The arguments '<code>namePrefix</code>', '<code>NAto0</code>', '<code>callFrom</code>' and '<code>silent</code>' must be given with full name to be recognized as such (and not get considered as vector for merging).
</p>


<h3>Value</h3>

<p>This function returns a matrix of merged values
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+merge">merge</a></code> (for two data.frames)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- c(a=1, b=11, c=21)
x2 &lt;- c(b=12, c=22, a=2)
x3 &lt;- c(a=3, d=43)
mergeVectors(vect1=x1, vect2=x2, vect3=x3)
x4 &lt;- 41:44     # no names - not conform for merging
mergeVectors(x1, x2, x3, x4)
</code></pre>

<hr>
<h2 id='mergeW2'>Extended version of merge for multiple objects (even without rownames)</h2><span id='topic+mergeW2'></span>

<h3>Description</h3>

<p><code>mergeW2</code> povides flexible merging out of 'MArrayLM'-object (if found, won't consider any other input-data) or of separate vectors or matrixes.
The main idea was to have somthing not adding add'l lines as merge might do, but to stay within the frame of the 1st argument given, even when IDs are repeated, 
so the output follows the order of the 1st argument, non-redundant IDs are created (orig IDs as new column).
If no 'MArrayLM'-object found: try to combine all elements of input '...', input-names must match predefined variants 'chInp'.
IDs given in 1st argument and not found in later arguments will be displayed as NA in the output matrix of data.frame.  
Note : (non-data) arguments must be given with full name (so far no lazy evaluation, may conflict with names in 'inputNamesLst'). 
Note : special characters in colnames bound to give trouble. 
Note : when no names given, <code>mergeW2</code> will presume order of elements (names) from 'inputNamesLst'. 
PROBLEM : error after xxMerg3 when several entries have matching (row)names but some entries match only partially  (what to do : replace with NAs ??)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeW2(
  ...,
  nonRedundID = TRUE,
  convertDF = TRUE,
  selMerg = TRUE,
  inputNamesLst = NULL,
  noMatchPursue = TRUE,
  standColNa = FALSE,
  lastOfMultCols = c("p.value", "Lfdr"),
  duplTxtSep = "_",
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeW2_+3A_...">...</code></td>
<td>
<p>all data (vectors, matrixes or data.frames) intendes for merge</p>
</td></tr>
<tr><td><code id="mergeW2_+3A_nonredundid">nonRedundID</code></td>
<td>
<p>(logical) if TRUE, allways add 1st column with non-redundant IDs (add anyway if non-redundant IDs found )</p>
</td></tr>
<tr><td><code id="mergeW2_+3A_convertdf">convertDF</code></td>
<td>
<p>(logical) allows converting output in data.frame, add new heading col with non-red rownames &amp; check which cols should be numeric</p>
</td></tr>
<tr><td><code id="mergeW2_+3A_selmerg">selMerg</code></td>
<td>
<p>(logical) if FALSE toggle to classic merge() (will give more rows in output in case of redundant names</p>
</td></tr>
<tr><td><code id="mergeW2_+3A_inputnameslst">inputNamesLst</code></td>
<td>
<p>(list) named list with character vectors (should be unique), search these names in input for extracting/merging elements use for 'lazy matching' when checking names of input, default : 7 groups ('Mvalue', 'Avalue','p.value','mouseInfo','Lfdr','link','filt') with common short versions</p>
</td></tr>
<tr><td><code id="mergeW2_+3A_nomatchpursue">noMatchPursue</code></td>
<td>
<p>(logical) allows using entries where 0 names match (just as if no names given)</p>
</td></tr>
<tr><td><code id="mergeW2_+3A_standcolna">standColNa</code></td>
<td>
<p>(logical) if TRUE return standard colnames as defined in 'inputNamesLst' (ie 'chInp'), otherwise colnames as initially provided</p>
</td></tr>
<tr><td><code id="mergeW2_+3A_lastofmultcols">lastOfMultCols</code></td>
<td>
<p>may specify input groups where only last col will be used/extracted</p>
</td></tr>
<tr><td><code id="mergeW2_+3A_dupltxtsep">duplTxtSep</code></td>
<td>
<p>(character)  separator for counting/denomiating multiple occurances of same name</p>
</td></tr>
<tr><td><code id="mergeW2_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="mergeW2_+3A_debug">debug</code></td>
<td>
<p>(logical) for bug-tracking: more/enhanced messages and intermediate objects written in global name-space</p>
</td></tr>
<tr><td><code id="mergeW2_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix or data.frame of fused data
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+merge">merge</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t1 &lt;- 1:10; names(t1) &lt;- letters[c(1:7,3:4,8)]
t2 &lt;- 20:11;  names(t2) &lt;- letters[c(1:7,3:4,8)]
t3 &lt;- 101:110; names(t3) &lt;- letters[c(11:20)]
t4 &lt;- matrix(100:81,ncol=2,dimnames=list(letters[1:10],c("co1","co2")))
t5 &lt;- cbind(t1=t1,t52=t1+20,t53=t1+30)
  t1; t2; t3;  cbind(t1,t2)
mergeW2(Mval=t1,p.value=t2,debug=FALSE)
</code></pre>

<hr>
<h2 id='minDiff'>Minimum distance/difference between values</h2><span id='topic+minDiff'></span>

<h3>Description</h3>

<p>This function aims to find the min distance (ie closest point) to any other x (numeric value), ie intra 'x' and
returns matrix with 'index','value','dif','ppm','ncur','nbest','best'.
At equal distance to lower &amp; upper neighbour point, the upper (following) point is chosen (as single best).
In case of multiple ex-aequo distance returns 1st of multiple, may be different at various repeats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minDiff(
  x,
  digSig = 3,
  ppm = TRUE,
  initOrder = TRUE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minDiff_+3A_x">x</code></td>
<td>
<p>(numeric) vector to search minimum difference</p>
</td></tr>
<tr><td><code id="minDiff_+3A_digsig">digSig</code></td>
<td>
<p>number of significant digits, used for ratio or ppm column</p>
</td></tr>
<tr><td><code id="minDiff_+3A_ppm">ppm</code></td>
<td>
<p>(logical) display distance as ppm (1e6*diff/refValue, ie normalized difference eg as used in mass spectrometry), otherwise the ratio is given as : value(from 'x') / closestValue (from 'x')</p>
</td></tr>
<tr><td><code id="minDiff_+3A_initorder">initOrder</code></td>
<td>
<p>(logical) return matrix so that 'x' matches exactely 2nd col of output</p>
</td></tr>
<tr><td><code id="minDiff_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="minDiff_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="minDiff_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+diff">diff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2017); aa &lt;- 100*c(0.1 +round(runif(20),2),0.53,0.53)
minDiff(aa); 
minDiff(aa,initO=TRUE,ppm=FALSE); .minDif(unique(aa))
</code></pre>

<hr>
<h2 id='moderTest2grp'>Moderated pair-wise t-test from limma</h2><span id='topic+moderTest2grp'></span>

<h3>Description</h3>

<p>Runs moderated t-test from package 'limma' on each line of data.
Note: This function requires the package <a href="https://bioconductor.org/packages/release/bioc/html/limma.html">limma</a> from bioconductor. 
The limma contrast-matrix has to be read by column, the lines in the contrast-matrix containing '+1' will be compared to the '-1' lines, eg grpA-grpB .
Local false discovery rates (lfdr) estimations will be made using the CRAN-package <a href="https://CRAN.R-project.org/package=fdrtool">fdrtool</a> (if available).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moderTest2grp(
  dat,
  grp,
  limmaOutput = TRUE,
  addResults = c("lfdr", "FDR", "Mval", "means"),
  testOrientation = "=",
  silent = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moderTest2grp_+3A_dat">dat</code></td>
<td>
<p>matrix or data.frame with rows for multiple (independent) tests, use ONLY with 2 groups; assumed as log2-data</p>
</td></tr>
<tr><td><code id="moderTest2grp_+3A_grp">grp</code></td>
<td>
<p>(factor) describes column-relationship of 'dat'   (1st factor is considered as reference -&gt; orientation of M-values !!)</p>
</td></tr>
<tr><td><code id="moderTest2grp_+3A_limmaoutput">limmaOutput</code></td>
<td>
<p>(logical) return full (or extended) MArrayLM-object from limma or 'FALSE' for only the (uncorrected) p.values</p>
</td></tr>
<tr><td><code id="moderTest2grp_+3A_addresults">addResults</code></td>
<td>
<p>(character) types of results to add besides basic limma-output, data are assumed to be log2 ! (eg &quot;lfdr&quot; using fdrtool-package, &quot;FDR&quot; or &quot;BH&quot; for BH-FDR, &quot;BY&quot; for BY-FDR, 
&quot;bonferroni&quot; for Bonferroni-correction, &quot;qValue&quot; for lfdr by qvalue, &quot;Mval&quot;, &quot;means&quot; or &quot;nonMod&quot; for non-moderated test and he equivaent all (other) multiple testing corrections chosen here)</p>
</td></tr>
<tr><td><code id="moderTest2grp_+3A_testorientation">testOrientation</code></td>
<td>
<p>(character) for one-sided test (&quot;&gt;&quot;,&quot;greater&quot; or &quot;&lt;&quot;,&quot;less&quot;), NOTE : 2nd grp is considered control/reference, '&lt;' will identify grp1 &lt; grp2</p>
</td></tr>
<tr><td><code id="moderTest2grp_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="moderTest2grp_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a limma-type object of class <code>MArrayLM</code>
</p>


<h3>See Also</h3>

<p><code><a href="limma.html#topic+lmFit">lmFit</a></code> and the <code>eBayes</code>-family of functions in package <a href="https://bioconductor.org/packages/release/bioc/html/limma.html">limma</a>, <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2017); t8 &lt;- matrix(round(rnorm(1600,10,0.4),2), ncol=8,
  dimnames=list(paste("l",1:200),c("AA1","BB1","CC1","DD1","AA2","BB2","CC2","DD2")))
t8[3:6,1:2] &lt;- t8[3:6,1:2]+3     # augment lines 3:6 for AA1&amp;BB1
t8[5:8,5:6] &lt;- t8[5:8,5:6]+3     # augment lines 5:8 for AA2&amp;BB2 (c,d,g,h should be found)
t4 &lt;- log2(t8[,1:4]/t8[,5:8])
## Two-sided testing 
fit4 &lt;- moderTest2grp(t4,gl(2,2))
# If you have limma installed we can now see further
if("list" %in% mode(fit4)) limma::topTable(fit4, coef=1, n=5)    # effect for 3,4,7,8

## One-sided testing
fit4in &lt;- moderTest2grp(t4,gl(2,2),testO="&lt;")
# If you have limma installed we can now see further
if("list" %in% mode(fit4)) limma::topTable(fit4in, coef=1, n=5)
</code></pre>

<hr>
<h2 id='moderTestXgrp'>Multiple moderated pair-wise t-tests from limma</h2><span id='topic+moderTestXgrp'></span>

<h3>Description</h3>

<p>Runs all pair-wise combinations of moderated t-tests from package 'limma' on each line of data against 1st group from 'grp'.
Note: This function requires the package <a href="https://bioconductor.org/packages/release/bioc/html/limma.html">limma</a> from bioconductor. 
The limma contrast-matrix has to be read by column, the lines in the contrast-matrix containing '+1' will be compared to the '-1' lines, eg grpA-grpB .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moderTestXgrp(
  dat,
  grp,
  limmaOutput = TRUE,
  addResults = c("lfdr", "FDR", "Mval", "means"),
  testOrientation = "=",
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moderTestXgrp_+3A_dat">dat</code></td>
<td>
<p>matrix or data.frame with rows for multiple (independent) tests, use ONLY with 2 groups; assumed as log2-data !!!</p>
</td></tr>
<tr><td><code id="moderTestXgrp_+3A_grp">grp</code></td>
<td>
<p>(factor) describes column-relationship of 'dat'   (1st factor is considered as reference -&gt; orientation of M-values !!)</p>
</td></tr>
<tr><td><code id="moderTestXgrp_+3A_limmaoutput">limmaOutput</code></td>
<td>
<p>(logical) return full (or extended) MArrayLM-object from limma or 'FAlSE' for only the (uncorrected) p.values</p>
</td></tr>
<tr><td><code id="moderTestXgrp_+3A_addresults">addResults</code></td>
<td>
<p>(character) types of results to add besides basic limma-output, data are assumed to be log2 ! (eg &quot;lfdr&quot; using fdrtool-package, &quot;FDR&quot; or &quot;BH&quot; for BH-FDR, &quot;BY&quot; for BY-FDR, 
&quot;bonferroni&quot; for Bonferroni-correction, &quot;qValue&quot; for lfdr by qvalue, &quot;Mval&quot;, &quot;means&quot; or &quot;nonMod&quot; for non-moderated test and he equivaent all (other) multiple testing corrections chosen here)</p>
</td></tr>
<tr><td><code id="moderTestXgrp_+3A_testorientation">testOrientation</code></td>
<td>
<p>(character) for one-sided test (&quot;&gt;&quot;,&quot;greater&quot; or &quot;&lt;&quot;,&quot;less&quot;), NOTE : 2nd grp is considered control/reference, '&lt;' will identify grp1 &lt; grp2</p>
</td></tr>
<tr><td><code id="moderTestXgrp_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="moderTestXgrp_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="moderTestXgrp_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a limma-type MA-object (list)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+moderTest2grp">moderTest2grp</a></code> for single comparisons, <code><a href="limma.html#topic+lmFit">lmFit</a></code> and the <code>eBayes</code>-family of functions in package <a href="https://bioconductor.org/packages/release/bioc/html/limma.html">limma</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grp &lt;- factor(rep(LETTERS[c(3,1,4)],c(2,3,3)))
set.seed(2017); t8 &lt;- matrix(round(rnorm(208*8,10,0.4),2), ncol=8,
  dimnames=list(paste(letters[],rep(1:8,each=26),sep=""), paste(grp,c(1:2,1:3,1:3),sep="")))
t8[3:6,1:2] &lt;- t8[3:6,1:2] +3                    # augment lines 3:6 (c-f) 
t8[5:8,c(1:2,6:8)] &lt;- t8[5:8,c(1:2,6:8)] -1.5    # lower lines 
t8[6:7,3:5] &lt;- t8[6:7,3:5] +2.2                  # augment lines 
## expect to find C/A in c,d,g, (h)
## expect to find C/D in c,d,e,f
## expect to find A/D in f,g,(h) 
test8 &lt;- moderTestXgrp(t8, grp) 
# If you have limma installed we can now see further
if("list" %in% mode(test8)) head(test8$p.value, n=8)
</code></pre>

<hr>
<h2 id='multiCharReplace'>Multiple replacement of entire character elements in simple vector, matrix or data.frame</h2><span id='topic+multiCharReplace'></span>

<h3>Description</h3>

<p>This functions allows multiple types of replacements of entire character elements in simple vector, matrix or data.frame.
In addtion, the result may be optionally directly transformed to logical or numeric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiCharReplace(
  mat,
  repl,
  convTo = NULL,
  silent = FALSE,
  debug = TRUE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiCharReplace_+3A_mat">mat</code></td>
<td>
<p>(character vector, matrix or data.frame) main data</p>
</td></tr>
<tr><td><code id="multiCharReplace_+3A_repl">repl</code></td>
<td>
<p>(matrix or list) tells what to replace by what: If matrix the 1st oolumn will be considered as 'old' and the 2nd as 'replaceBy'; if named list, the names of the list-elements will be consdered as 'replaceBy'</p>
</td></tr>
<tr><td><code id="multiCharReplace_+3A_convto">convTo</code></td>
<td>
<p>(character) optional conversion of content to 'numeric' or 'logical'</p>
</td></tr>
<tr><td><code id="multiCharReplace_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="multiCharReplace_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="multiCharReplace_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an object of same dimension as input (with replaced content)
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grep">grep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- c("ab","bc","cd","efg","ghj")
multiCharReplace(x1, cbind(old=c("bc","efg"), new=c("BBCC","EF")))

x2 &lt;- c("High","n/a","High","High","Low")
multiCharReplace(x2, cbind(old=c("n/a","Low","High"), new=c(NA,FALSE,TRUE)),convTo="logical")

# works also to replace numeric content :
x3 &lt;- matrix(11:16, ncol=2)
multiCharReplace(x3, cbind(12:13,112:113))
</code></pre>

<hr>
<h2 id='multiMatch'>Simple Multi-to-Multi Matching of (Concatenated) Terms</h2><span id='topic+multiMatch'></span>

<h3>Description</h3>

<p>This function allows convenient matching of multi-to-multi relationships between two objects/vectors. 
It was designed for finding common elements in multiple to multiple matching situations (eg when comparing <code>c("aa; bb", "cc")</code>  to <code>c("bb; ab","dd")</code>, 
ie to find 'bb' as matching between both objects).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiMatch(
  x,
  y,
  sep = "; ",
  sep2 = NULL,
  method = "byX",
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiMatch_+3A_x">x</code></td>
<td>
<p>(vector or list) first object to compare; if vector, the (partially) concatenated identifyers (will be split using separator <code>sep</code>), or list of items to be matched (ie already split)</p>
</td></tr>
<tr><td><code id="multiMatch_+3A_y">y</code></td>
<td>
<p>(vector or list) second object to compare; if vector, the (partially) concatenated identifyers (will be split using separator <code>sep</code>), or list of items to be matched (ie already split)</p>
</td></tr>
<tr><td><code id="multiMatch_+3A_sep">sep</code></td>
<td>
<p>(character, length=1) separator used to split concatenated identifyers (if <code>x</code> or  <code>y</code> is vector)</p>
</td></tr>
<tr><td><code id="multiMatch_+3A_sep2">sep2</code></td>
<td>
<p>(character, length=1) optional separator used when <code>method="matched"</code> to concatenate all indexes of <code>y</code> for column <code>y.allInd</code></p>
</td></tr>
<tr><td><code id="multiMatch_+3A_method">method</code></td>
<td>
<p>(character) mode of operation: 'asIndex' to return index of y (those hwo have matches) with names of x (which x are the correpsonding match)</p>
</td></tr>
<tr><td><code id="multiMatch_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="multiMatch_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="multiMatch_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>method='byX'</code> .. returns data.frame with view oriented towards entries of <code>x</code>: character column <code>x</code> for entire content of <code>x</code>; integer column <code>x.Ind</code> for index of <code>x</code>; 
character column <code>TagBest</code> for most frequent matching isolated tag/ID; integer column <code>y.IndBest</code> index of most frequent matching <code>y</code>;
character column <code>y.IndAll</code> index for all <code>y</code> matching any of the tags;
character column <code>y.Match</code> for entire content of best matching <code>y</code>; 
character column <code>y.Adj</code> for <code>y</code> adjusted to best matching <code>y</code> for easier subsequent perfect matching.
</p>
<p><code>method=c("byX","filter")</code> .. combinded argument to keep only lines with any matches 
</p>
<p><code>method='byTag'</code> .. returns matrix (of integers) from view of isolated tags from <code>x</code> (a separate line for each tag from  <code>x</code> matching to <code>y</code>);
</p>
<p><code>method=c("byTag","filter")</code> ..if combined as arguments, this will return a data.frame for all unique tags with any matches between <code>x</code> and <code>y</code>, with 
additional colunms <code>x.AllInd</code> for all matching <code>x</code>-indexes,  <code>y.IndBest</code> best matching <code>y</code> index; <code>x.n</code> for number of different <code>x</code> conatining this tag;
<code>y.AllInd</code> for all matching <code>y</code>-indexes 
</p>
<p><code>method='adjustXtoY'</code> .. returns vector with <code>x</code> adjusted to <code>y</code>, ie those elements of <code>x</code> matching are replace by the exact corresponding term of <code>y</code>.
</p>
<p><code>method=NULL</code> .. If no term matching the options shown above is given, another version of 'asIndex' is returned, but indexes to <code>y</code> _after_ spliting by <code>sep</code>. 
Again, this method can be filtered by using <code>method="filter"</code> to focus on the best matches to <code>x</code>.
</p>


<h3>Value</h3>

<p>matrix, data.frame or list with matching results depending on <code>method</code> chosen
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+match">match</a></code>; <code><a href="base.html#topic+strsplit">strsplit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aa &lt;- c("m","k", "j; aa", "m; aa; bb; o; ee", "n; dd; cc", "aa", "cc")
bb &lt;- c("dd; r", "aa", "ee; bb; q; cc", "p; cc")
(match1 &lt;- multiMatch(aa, bb, method=NULL))      # match bb to aa
(match2 &lt;- multiMatch(aa, bb, method="byX"))     # match bb to aa
(match3 &lt;- multiMatch(aa, bb, method="byTag"))   # match bb to aa
(match4 &lt;- multiMatch(aa, bb, method=c("byTag","filter")))   # match bb to aa

</code></pre>

<hr>
<h2 id='naOmit'>Fast na.omit</h2><span id='topic+naOmit'></span>

<h3>Description</h3>

<p><code>naOmit</code> removes NAs from input vector. This function has no slot for removed elements while <code>na.omit</code> does so. 
Resulting objects from <code>naOmit</code> are smaller in size and subsequent execution (on large vectors) is faster (in particular if many NAs get encountered).
Note : Behaves differently to <code>na.omit</code> with input other than plain vectors. Will not work with data.frames !
</p>


<h3>Usage</h3>

<pre><code class='language-R'>naOmit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="naOmit_+3A_x">x</code></td>
<td>
<p>(vector or matrix) input</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector without NAs (matrix input will be transformed to vector). Returns NULL if input consists only of NAs.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+na.fail">na.fail</a></code>, <code>na.omit</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aA &lt;- c(11:13,NA,10,NA); 
naOmit(aA) 
</code></pre>

<hr>
<h2 id='nFragments'>Number of fragments after cut at specific character(s) within size-range</h2><span id='topic+nFragments'></span>

<h3>Description</h3>

<p><code>nFragments</code> determines number of fragments /entry within range of 'sizeRa' (numeric,length=2) when cutting after 'cutAt'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nFragments(protSeq, cutAt, sizeRa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nFragments_+3A_protseq">protSeq</code></td>
<td>
<p>(character)  text to be cut</p>
</td></tr>
<tr><td><code id="nFragments_+3A_cutat">cutAt</code></td>
<td>
<p>(character) position to cut</p>
</td></tr>
<tr><td><code id="nFragments_+3A_sizera">sizeRa</code></td>
<td>
<p>(numeric,length=2) min and max size to consider</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector with number of fragments for each entry 'protSeq' (names are 'protSeq')
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cutAtMultSites">cutAtMultSites</a></code>, simple version <code>{nFragments0}</code> (no size-range)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- "MSVSREDSCELDLVYVTERIIAVSFPSTANEENFRSNLREVAQMLKSKHGGNYLLFNLSERRPDITKLHAKVLEFGWPDLHTPALEKI"
nFragments(c(tmp,"ojioRij"),c("R","K"),c(4,31))

</code></pre>

<hr>
<h2 id='nFragments0'>Number of fragments after cut at specific character(s)</h2><span id='topic+nFragments0'></span>

<h3>Description</h3>

<p><code>nFragments0</code> tells the number of fragments/entry when cutting after 'cutAt'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nFragments0(protSeq, cutAt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nFragments0_+3A_protseq">protSeq</code></td>
<td>
<p>(character) text to be cut</p>
</td></tr>
<tr><td><code id="nFragments0_+3A_cutat">cutAt</code></td>
<td>
<p>(integer) position to cut</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector with number of fragments for each entry 'protSeq' (names are 'protSeq')
</p>


<h3>See Also</h3>

<p>more elaborate <code>{nFragments}</code>; <code><a href="#topic+cutAtMultSites">cutAtMultSites</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- "MSVSRTMEDSCELDLVYVTERIIAVSFPSTANEENFRSNLREVAQMLKSKHGGNYLLFNLSERRPDITKLHAKVLEFGWPDLHTPALEKI" 
nFragments0(c(tmp,"ojioRij"),c("R","K"))
</code></pre>

<hr>
<h2 id='nNonNumChar'>Count number of non-numeric characters</h2><span id='topic+nNonNumChar'></span>

<h3>Description</h3>

<p><code>nNonNumChar</code> counts number of non-numeric characters.
Made for positive non-scientific values (eg won't count neg-sign, neither Euro comma ',')
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nNonNumChar(txt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nNonNumChar_+3A_txt">txt</code></td>
<td>
<p>character vector to be treated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a numeric vector with  numer of non-numeric characters (ie not '.' or 0-9))
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+nchar">nchar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nNonNumChar("a1b "); sapply(c("aa","12ab","a1b2","12","0.5"), nNonNumChar)
</code></pre>

<hr>
<h2 id='nonAmbiguousMat'>Transform matrix to non-ambiguous matrix (in respect to given column)</h2><span id='topic+nonAmbiguousMat'></span>

<h3>Description</h3>

<p><code>nonAmbiguousMat</code> makes values of matrix 'mat' in col 'byCol' unique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonAmbiguousMat(
  mat,
  byCol,
  uniqOnly = FALSE,
  asList = FALSE,
  nameMod = "amb_",
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nonAmbiguousMat_+3A_mat">mat</code></td>
<td>
<p>numeric or character matrix (or data.frame), column specified by 'byCol' must be/will be used as.numeric, 1st column of 'mat' will be considered like index &amp; used for adding prefix 'nameMod' (unless byCol=1, then 2nd col will be used)</p>
</td></tr>
<tr><td><code id="nonAmbiguousMat_+3A_bycol">byCol</code></td>
<td>
<p>(character or integer-index) column by which ambiguousity will be tested</p>
</td></tr>
<tr><td><code id="nonAmbiguousMat_+3A_uniqonly">uniqOnly</code></td>
<td>
<p>(logical) if =TRUE return unique only, if =FALSE return unique and single representative of non-unique values (with &rdquo; added to name), selection of representative of repeated: first (of sorted) or middle if &gt;2 instances</p>
</td></tr>
<tr><td><code id="nonAmbiguousMat_+3A_aslist">asList</code></td>
<td>
<p>(logical) return result as list</p>
</td></tr>
<tr><td><code id="nonAmbiguousMat_+3A_namemod">nameMod</code></td>
<td>
<p>(character) prefix added to 1st column of 'mat' (expect 'by') for indicating non-unique/ambiguous values</p>
</td></tr>
<tr><td><code id="nonAmbiguousMat_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sorted non-ambigous numeric vector (or list if 'asList'=TRUE and 'uniqOnly'=FALSE)
</p>


<h3>See Also</h3>

<p>for non-numeric use <code><a href="#topic+firstOfRepeated">firstOfRepeated</a></code> - but 1000x much slower !; <code><a href="#topic+get1stOfRepeatedByCol">get1stOfRepeatedByCol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2017); mat2 &lt;- matrix(c(1:100,round(rnorm(200),2)),ncol=3,
  dimnames=list(1:100,LETTERS[1:3]));
head(mat2U &lt;- nonAmbiguousMat(mat2,by="B",na="_",uniqO=FALSE),n=15)
head(get1stOfRepeatedByCol(mat2,sortB="B",sortS="B"))
</code></pre>

<hr>
<h2 id='nonAmbiguousNum'>make numeric vector non-ambiguous (ie unique)</h2><span id='topic+nonAmbiguousNum'></span>

<h3>Description</h3>

<p><code>nonAmbiguousNum</code> makes (named) values of numeric vector 'x' unique. 
Note: for non-numeric use  <code><a href="#topic+firstOfRepeated">firstOfRepeated</a></code> - but 1000x slower !
Return sorted non-ambigous numeric vector (or list if 'asList'=TRUE and 'uniqOnly'=FASLSE)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonAmbiguousNum(
  x,
  uniqOnly = FALSE,
  asList = FALSE,
  nameMod = "amb_",
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nonAmbiguousNum_+3A_x">x</code></td>
<td>
<p>(numeric) main input</p>
</td></tr>
<tr><td><code id="nonAmbiguousNum_+3A_uniqonly">uniqOnly</code></td>
<td>
<p>(logical) if=TRUE return unique only, if =FALSE return unique and single representative of non-unique values (with &rdquo; added to name), selection of representative of repeated: first (of sorted) or middle if &gt;2 instances</p>
</td></tr>
<tr><td><code id="nonAmbiguousNum_+3A_aslist">asList</code></td>
<td>
<p>(logical) return list</p>
</td></tr>
<tr><td><code id="nonAmbiguousNum_+3A_namemod">nameMod</code></td>
<td>
<p>(character) text to add in case on ambiguous values, default=&quot;amb_&quot;</p>
</td></tr>
<tr><td><code id="nonAmbiguousNum_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sorted non-ambigous numeric vector (or list if 'asList'=TRUE and 'uniqOnly'=FALSE)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+firstOfRepeated">firstOfRepeated</a></code> for non-numeric use (much slower !!!), <code><a href="base.html#topic+duplicated">duplicated</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2017); aa &lt;- round(rnorm(100),2); names(aa) &lt;- 1:length(aa)
str(nonAmbiguousNum(aa))
str(nonAmbiguousNum(aa,uniq=FALSE,asLi=TRUE))
</code></pre>

<hr>
<h2 id='nonredDataFrame'>Filter for unique elements</h2><span id='topic+nonredDataFrame'></span>

<h3>Description</h3>

<p><code>nonredDataFrame</code>  filters 'x' (list of char-vectors or char-vector) for elements unique (to 'ref' or if NULL to all 'x') and of character length. 
May be used for different 'accession' for same pep sequence (same 'peptide_id').
Note : made for treating data.frames, may be slightly slower than matrix equivalent
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonredDataFrame(
  dataFr,
  useCol = c(pepID = "peptide_id", protID = "accession", seq = "sequence", mod =
    "modifications"),
  sepCollapse = "//",
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nonredDataFrame_+3A_datafr">dataFr</code></td>
<td>
<p>(data.frame) main inpput</p>
</td></tr>
<tr><td><code id="nonredDataFrame_+3A_usecol">useCol</code></td>
<td>
<p>(character,length=2) comlumn names of 'dataFr' to use : 1st value designates where redundant values should be gathered; 2nd value designes column of which information should be concatenated</p>
</td></tr>
<tr><td><code id="nonredDataFrame_+3A_sepcollapse">sepCollapse</code></td>
<td>
<p>(character) conatenation symbol</p>
</td></tr>
<tr><td><code id="nonredDataFrame_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a data.frame of filtered (fewer lines) with additional 2 columns 'nSamePep' (number of redundant entries) and 'concID' (concatenated content)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+combineRedBasedOnCol">combineRedBasedOnCol</a></code>, <code><a href="#topic+correctToUnique">correctToUnique</a></code>, <code><a href="base.html#topic+unique">unique</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- data.frame(cbind(xA=letters[1:5], xB=c("h","h","f","e","f"), xC=LETTERS[1:5])) 
nonredDataFrame(df1, useCol=c("xB","xC")) 
</code></pre>

<hr>
<h2 id='nonRedundLines'>Non-redundant lines of matrix</h2><span id='topic+nonRedundLines'></span>

<h3>Description</h3>

<p><code>nonRedundLines</code> reduces complexity of matrix (or data.frame) if multiple consectuive (!) lines with same values.
Return matrix (or data.frame) without repeated lines (keep 1st occurance)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonRedundLines(dat, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nonRedundLines_+3A_dat">dat</code></td>
<td>
<p>(matrix or data.frame) main input</p>
</td></tr>
<tr><td><code id="nonRedundLines_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix (or data.frame) without repeated lines (keep 1st occurance)..
</p>


<h3>See Also</h3>

<p><code><a href="#topic+firstLineOfDat">firstLineOfDat</a></code>, <code><a href="#topic+firstOfRepLines">firstOfRepLines</a></code>, <code><a href="#topic+findRepeated">findRepeated</a></code>, <code><a href="#topic+firstOfRepeated">firstOfRepeated</a></code>, <code><a href="#topic+get1stOfRepeatedByCol">get1stOfRepeatedByCol</a></code>, <code><a href="#topic+combineRedBasedOnCol">combineRedBasedOnCol</a></code>, <code><a href="#topic+correctToUnique">correctToUnique</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat2 &lt;- matrix(rep(c(1,1:3,3,1),2),ncol=2,dimnames=list(letters[1:6],LETTERS[1:2]))
nonRedundLines(mat2)
</code></pre>

<hr>
<h2 id='normalizeThis'>Normalize data in various modes</h2><span id='topic+normalizeThis'></span>

<h3>Description</h3>

<p>Generic normalization of 'dat' (by columns), multiple methods may be applied.
The choice of normalization procedures must be done with care, plotting the data before and after normalization
may be critical to understandig the initial data structure and the effect of the procedure applied.
Inappropriate methods chosen may render interpretation of (further) results incorrect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalizeThis(
  dat,
  method = "mean",
  refLines = NULL,
  refGrp = NULL,
  mode = "proportional",
  trimFa = NULL,
  minQuant = NULL,
  sparseLim = 0.4,
  nCombin = 3,
  omitNonAlignable = FALSE,
  maxFact = 10,
  quantFa = NULL,
  expFa = NULL,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalizeThis_+3A_dat">dat</code></td>
<td>
<p>matrix or data.frame of data to get normalized</p>
</td></tr>
<tr><td><code id="normalizeThis_+3A_method">method</code></td>
<td>
<p>(character) may be &quot;mean&quot;,&quot;median&quot;,&quot;NULL&quot;,&quot;none&quot;, &quot;trimMean&quot;, &quot;rowNormalize&quot;, &quot;slope&quot;, &quot;exponent&quot;, &quot;slope2Sections&quot;, &quot;vsn&quot;; When <code>NULL</code> or 'none' is chosen the input will be returned</p>
</td></tr>
<tr><td><code id="normalizeThis_+3A_reflines">refLines</code></td>
<td>
<p>(NULL or numeric) allows to consider only specific lines of 'dat' when determining normalization factors (all data will be normalized)</p>
</td></tr>
<tr><td><code id="normalizeThis_+3A_refgrp">refGrp</code></td>
<td>
<p>Only the columns indicated will be used as reference, default all columns (integer or colnames)</p>
</td></tr>
<tr><td><code id="normalizeThis_+3A_mode">mode</code></td>
<td>
<p>(character) may be &quot;proportional&quot;, &quot;additive&quot;;
decide if normalizatio factors will be applies as multiplicative (proportional) or additive; for log2-omics data <code>mode="aditive"</code> is suggested</p>
</td></tr>
<tr><td><code id="normalizeThis_+3A_trimfa">trimFa</code></td>
<td>
<p>(numeric, length=1) additional parameters for trimmed mean</p>
</td></tr>
<tr><td><code id="normalizeThis_+3A_minquant">minQuant</code></td>
<td>
<p>(numeric) only used with <code>method='rowNormalize'</code>: optional filter to set all values below given value as <code>NA</code>; see also <code><a href="#topic+rowNormalize">rowNormalize</a></code></p>
</td></tr>
<tr><td><code id="normalizeThis_+3A_sparselim">sparseLim</code></td>
<td>
<p>(integer) only used with <code>method='rowNormalize'</code>: decide at which min content of  <code>NA</code> values the function should go in sparse-mode; see also <code><a href="#topic+rowNormalize">rowNormalize</a></code></p>
</td></tr>
<tr><td><code id="normalizeThis_+3A_ncombin">nCombin</code></td>
<td>
<p>(NULL or integer) only used with <code>method='rowNormalize'</code>: used only in sparse-mode (ie if content of <code>NA</code>s higher than content of <code>sparseLim</code>):
Number of groups of smller matrixes with this number of columns to be inspected initially;
low values (small groups have higher chances of more common elements); see also <code><a href="#topic+rowNormalize">rowNormalize</a></code></p>
</td></tr>
<tr><td><code id="normalizeThis_+3A_omitnonalignable">omitNonAlignable</code></td>
<td>
<p>(logical) only used with <code>method='rowNormalize'</code>: allow omitting all columns which can't get aligned due to sparseness; see also <code><a href="#topic+rowNormalize">rowNormalize</a></code></p>
</td></tr>
<tr><td><code id="normalizeThis_+3A_maxfact">maxFact</code></td>
<td>
<p>(numeric, length=2) only used with <code>method='rowNormalize'</code>:  max normalization factor; see also <code><a href="#topic+rowNormalize">rowNormalize</a></code></p>
</td></tr>
<tr><td><code id="normalizeThis_+3A_quantfa">quantFa</code></td>
<td>
<p>(numeric, length=2) additional parameters for quantiles to use with method='slope'</p>
</td></tr>
<tr><td><code id="normalizeThis_+3A_expfa">expFa</code></td>
<td>
<p>(numeric, length=1) additional parameters for method='exponent'</p>
</td></tr>
<tr><td><code id="normalizeThis_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="normalizeThis_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="normalizeThis_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In most cases of treating 'Omics'-data one works with the hypothesis that there are no global changes in the structure of all data/columns
Under this htpothesis it is very common to assume the the median (via the argument <code>method</code>) of all samples (ie columns) should remain constant.
For examples samples/columns with less signal will be considered as having received 'accidentally' less material (eg due to the imprecision when transfering very small amounts of liquid samples).
In consequence, a sample having received only 95
Thus, all measures will be multiplied by 1/0.95 (apr 1.053) to compensate for supposed lack of staring material.
</p>
<p>With the analysis of 'Omics'-data it is very common to work with data on log-scale.
In this case the argument <code>mode</code> should be set to <code>additive</code>, since adding a constant factor to log-data corresponds to a multiplicative factor on regular scale
Please note that (at this point) the methods 'slope', 'exponent', 'slope2Sections' and 'vsn' don't distinguish between additive and proportional modes, but take take the data 'as is'
(you may look at the original documenation for more details, see <code><a href="#topic+exponNormalize">exponNormalize</a></code>, <code><a href="#topic+adjBy2ptReg">adjBy2ptReg</a></code>, <code><a href="vsn.html#topic+justvsn">justvsn</a></code>).
</p>
<p>Normalization using <code>method="rowNormalize"</code> runs <code><a href="#topic+rowNormalize">rowNormalize</a></code> from this package.
In this case, the working hypothesis is, that all values in each row are expected to be the same.
This method could be applied when all series of values (ie columns) are replicate measurements of the same sample.
THere is also an option for treating sparse data (see argument <code>sparseLim</code>), which may, hovere, consume much more comptational ressources,
in particular, when the value <code>nCombin</code> is low (compared to the number of samples/columns).
</p>
<p>Normalization using  <code>method="vsn"</code> runs <code><a href="vsn.html#topic+justvsn">justvsn</a></code> from <a href="https://bioconductor.org/packages/release/bioc/html/vsn.html">vsn</a>
(this requires a minimum of 42 rows of input-data and having the Bioconductor package vsn installed).
Note : Depending on the procedure chosen, the normalized data may appear on a different scale.
</p>


<h3>Value</h3>

<p>This function returns a matrix of normalized data (same dimensions as input)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowNormalize">rowNormalize</a></code>, <code><a href="#topic+exponNormalize">exponNormalize</a></code>, <code><a href="#topic+adjBy2ptReg">adjBy2ptReg</a></code>, <code><a href="vsn.html#topic+justvsn">justvsn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2015); rand1 &lt;- round(runif(300)+rnorm(300,0,2),3)
dat1 &lt;- cbind(ser1=round(100:1+rand1[1:100]), ser2=round(1.2*(100:1+rand1[101:200])-2),
  ser3=round((100:1 +rand1[201:300])^1.2-3))
dat1 &lt;- cbind(dat1, ser4=round(dat1[,1]^seq(2,5,length.out=100)+rand1[11:110],1))
dat1[dat1 &lt;1] &lt;- NA
  summary(dat1)
  dat1[c(1:5,50:54,95:100),]
no1 &lt;- normalizeThis(dat1, refGrp=1:3, meth="mean")
no2 &lt;- normalizeThis(dat1, refGrp=1:3, meth="trimMean", trim=0.4)
no3 &lt;- normalizeThis(dat1, refGrp=1:3, meth="median")
no4 &lt;- normalizeThis(dat1, refGrp=1:3, meth="slope", quantFa=c(0.2,0.8))
dat1[c(1:10,91:100),]
cor(dat1[,3],rowMeans(dat1[,1:2],na.rm=TRUE), use="complete.obs")             # high
cor(dat1[,4],rowMeans(dat1[,1:2],na.rm=TRUE), use="complete.obs")             # bad
cor(dat1[c(1:10,91:100),4],rowMeans(dat1[c(1:10,91:100),1:2],na.rm=TRUE),use="complete.obs")
cor(dat1[,3],rowMeans(dat1[,1:2],na.rm=TRUE)^ (1/seq(2,5,length.out=100)),use="complete.obs")
</code></pre>

<hr>
<h2 id='numPairDeColNames'>Extract pair of numeric values from vector or column-names</h2><span id='topic+numPairDeColNames'></span>

<h3>Description</h3>

<p>This function extracts a pair of numeric values out of a vector or colnames (from a matrix). 
This is useful when pairwise comparisons are concatenated like '10c-100c', return matrix with 'index'=selComp, log2rat and both numeric.
Additional white space or character text can be removed via the argument <code>stripTxt</code>.
Of course, the separator <code>sep</code> needs to be specified and should not be included to 'stripTxt'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numPairDeColNames(
  dat,
  selComp = NULL,
  stripTxt = NULL,
  sep = "-",
  columLabel = "conc",
  sortByAbsRatio = FALSE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numPairDeColNames_+3A_dat">dat</code></td>
<td>
<p>(matrix or data.frame) main input</p>
</td></tr>
<tr><td><code id="numPairDeColNames_+3A_selcomp">selComp</code></td>
<td>
<p>(character) the column index selected</p>
</td></tr>
<tr><td><code id="numPairDeColNames_+3A_striptxt">stripTxt</code></td>
<td>
<p>(character, max length=2) text to ignore, if NULL heading letter and punctuation characters will be removed; default will remove all letters (and following spaces)</p>
</td></tr>
<tr><td><code id="numPairDeColNames_+3A_sep">sep</code></td>
<td>
<p>(character, length=1) separator between pair of numeric values to extract</p>
</td></tr>
<tr><td><code id="numPairDeColNames_+3A_columlabel">columLabel</code></td>
<td>
<p>(character) column labels in output</p>
</td></tr>
<tr><td><code id="numPairDeColNames_+3A_sortbyabsratio">sortByAbsRatio</code></td>
<td>
<p>(logical) optional sorting of output by (absolute) log-ratios (most extreme ratios on top)</p>
</td></tr>
<tr><td><code id="numPairDeColNames_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="numPairDeColNames_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="numPairDeColNames_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+strsplit">strsplit</a></code> and help on regex
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##  composed column names
mat1 &lt;- matrix(1:8, nrow=2, dimnames=list(NULL, paste0(1:4,"-",6:9)))
numPairDeColNames(mat1)
numPairDeColNames(colnames(mat1))
##  works also with simple numeric column names
mat2 &lt;- matrix(1:8, nrow=2, dimnames=list(NULL, paste0("a",6:9)))
numPairDeColNames(mat2)
</code></pre>

<hr>
<h2 id='orderMatrToRef'>Order Lines of Matrix According to Reference (Character) Vector</h2><span id='topic+orderMatrToRef'></span>

<h3>Description</h3>

<p>This function orders lines of matrix <code>mat</code> according to a (character) reference vector <code>ref</code>.
To do so, all columns of <code>mat</code> will be considered to use the first column from left with the best (partial) matching results.
This function first looks for unambiguous perfect matches, and if not found successive rounds of more elaborte partial matching will be engaged: 
In case of no perfect matches found, grep of <code>ref</code> on all columns of <code>mat</code> and/or grep of all columns of <code>mat</code> on <code>ref</code> (ie 'reverse grep') will be applied (finally a 'two way grep' approach).
Until a perfect match is found each element of <code>ref</code> will be tested on <code>mat</code> and inversely (for each column) each element of <code>mat</code> will be tested on <code>ref</code>.
The approach with the best number of (unique) matches will be chosen. In case of one-to-many matches, it will be tried to use most complete lines (see also last example).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderMatrToRef(
  mat,
  ref,
  addRef = TRUE,
  listReturn = TRUE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orderMatrToRef_+3A_mat">mat</code></td>
<td>
<p>(matrix, data.frame) main input of which rows should get re-ordered according to a (character) reference vector <code>ref</code></p>
</td></tr>
<tr><td><code id="orderMatrToRef_+3A_ref">ref</code></td>
<td>
<p>(character) reference imposing new order</p>
</td></tr>
<tr><td><code id="orderMatrToRef_+3A_addref">addRef</code></td>
<td>
<p>(logical) add <code>ref</code> to output as new column</p>
</td></tr>
<tr><td><code id="orderMatrToRef_+3A_listreturn">listReturn</code></td>
<td>
<p>(logical) allows retrieving more information in form of list</p>
</td></tr>
<tr><td><code id="orderMatrToRef_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="orderMatrToRef_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="orderMatrToRef_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns, depending on <code>listReturn</code>, either the input-matrix in new order or a list with $mat (the input matrix in new order), $grep (matched matrix) and $col indicating the colum of <code>mat</code> finally used
</p>


<h3>See Also</h3>

<p>for basic ordering see <code><a href="base.html#topic+match">match</a></code>; <code><a href="#topic+checkGrpOrder">checkGrpOrder</a></code> for testing each line for expected order, <code><a href="#topic+checkStrictOrder">checkStrictOrder</a></code> to check for strict (ascending or descending) order
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat1 &lt;- matrix(paste0("__",letters[rep(c(1,1,2,2,3),3) +rep(0:2,each=5)], rep(1:5)), ncol=3)
orderMatrToRef(mat1, paste0(letters[c(3,4,5,3,4)],c(1,3,5,2,4)))

mat2 &lt;- matrix(paste0("__",letters[rep(c(1,1,2,2,3),3) +rep(0:2,each=5)], 
  c(rep(1:5,2),1,1,3:5 )), ncol=3)
orderMatrToRef(mat2, paste0(letters[c(3,4,5,3,4)],c(1,3,5,1,4)))

mat3 &lt;- matrix(paste0(letters[rep(c(1,1,2,2,3),3) +rep(0:2,each=5)], 
  c(rep(1:5,2),1,1,3,3,5 )), ncol=3)
orderMatrToRef(mat3, paste0("__",letters[c(3,4,5,3,4)],c(1,3,5,1,3)))

</code></pre>

<hr>
<h2 id='organizeAsListOfRepl'>(re)organize data of (3-dim) array as list of replicates</h2><span id='topic+organizeAsListOfRepl'></span>

<h3>Description</h3>

<p>Organize array of all data ('arrIn', long table) into list of (replicate-)arrays (of similar type/layout) based on dimension number 'byDim' of 'arrIn' (eg 2nd or 3rd dim).
Argument <code>inspNChar</code> defines the number of characters to consider, so if the beginning of names is the same they will be separated as list of multiple arrays.
Default will search for '_' separator or trim from end if not found in the relevant dimnames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>organizeAsListOfRepl(
  arrIn,
  inspNChar = 0,
  byDim = 3,
  silent = TRUE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="organizeAsListOfRepl_+3A_arrin">arrIn</code></td>
<td>
<p>(array) main input</p>
</td></tr>
<tr><td><code id="organizeAsListOfRepl_+3A_inspnchar">inspNChar</code></td>
<td>
<p>(interger) if inspNChar=0 the array-names (2nd dim of 'arrIn') will be cut before last '_'</p>
</td></tr>
<tr><td><code id="organizeAsListOfRepl_+3A_bydim">byDim</code></td>
<td>
<p>(integer, length=1) dimension number along which data will be split in separate elements (considering the first inspNChar characters)</p>
</td></tr>
<tr><td><code id="organizeAsListOfRepl_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="organizeAsListOfRepl_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="organizeAsListOfRepl_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list of arrays (typically 1st and 2nd dim for specific genes/objects, 3rd for different measures associated with)
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+array">array</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>arr1 &lt;- array(1:24,dim=c(4,3,2),dimnames=list(c(LETTERS[1:4]),
  paste("col",1:3,sep=""), c("ch1","ch2")))
organizeAsListOfRepl(arr1)
</code></pre>

<hr>
<h2 id='packageDownloadStat'>Simple Package Download Statistics from CRAN</h2><span id='topic+packageDownloadStat'></span>

<h3>Description</h3>

<p>This function allows accessing the most recent counts of package downloads availabale on http://www.datasciencemeta.com/rpackages,
obtaining rank quantiles and to compare (multiple) given packages to the bulk data, optionally a plot can be drawn.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>packageDownloadStat(
  queryPackages = c("wrMisc", "wrProteo", "cif", "bcv", "FinCovRegularization"),
  countUrl = "http://www.datasciencemeta.com/rpackages",
  refQuant = (1:10)/10,
  figure = TRUE,
  log = "",
  silent = FALSE,
  callFrom = NULL,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="packageDownloadStat_+3A_querypackages">queryPackages</code></td>
<td>
<p>(character or integer) package names of interest, if <code>integer</code>, n random packages will be picked by random</p>
</td></tr>
<tr><td><code id="packageDownloadStat_+3A_counturl">countUrl</code></td>
<td>
<p>(character) the url where the dayly counts ara available</p>
</td></tr>
<tr><td><code id="packageDownloadStat_+3A_refquant">refQuant</code></td>
<td>
<p>(numeric) add reference quantile values to output matrix</p>
</td></tr>
<tr><td><code id="packageDownloadStat_+3A_figure">figure</code></td>
<td>
<p>(logical) decide of figure should be printed</p>
</td></tr>
<tr><td><code id="packageDownloadStat_+3A_log">log</code></td>
<td>
<p>(character) set count-axis of figure to linear or log-scale (by setting <code>log="y"</code>)</p>
</td></tr>
<tr><td><code id="packageDownloadStat_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="packageDownloadStat_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
<tr><td><code id="packageDownloadStat_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Detailed articles on this subject have been published on R-Hub (https://blog.r-hub.io/2020/05/11/packagerank-intro/) and on
R-bloggers (https://www.r-bloggers.com/2020/10/a-cran-downloads-experiment/).
The task of checking the number of downloads for a given package has also been addressed by several other packages (eg dlstats, cranlogs, adjustedcranlogs).
</p>
<p>This function only allows accessing counts as listed on the website of <code>www.datasciencemeta.com</code> which get updated dayly.
Please note, that reading all lines from the website may take a few seconds !!
To get a better understanding of the counts read, reference quantiles for download-counts get added by default  (see argument <code>refQuant</code>).
The (optional) figure can be drawn in linear scale (default, with minor zoom to lower number of counts) or in log (necessary for proper display of the entire range of counts), by setting the argument <code>log="y"</code>.
</p>
<p>The number of downloads counted by RStudio may not be a perfect measure for the actual usage/popularity of a given package,
the articles cited above discuss this in more detail.
For example, multiple downloads from the same IP or subsequent downloads of multiple (older) versions of the same package seem to get counted, too.
</p>


<h3>Value</h3>

<p>This function retuns a matrix with download counts (or <code>NULL</code> if the web-site can't be accessed or the query-packages are not found there)
</p>


<h3>See Also</h3>

<p>packages <a href="https://CRAN.R-project.org/package=cranlogs">cranlogs</a> and <a href="https://CRAN.R-project.org/package=packageRank">packageRank</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Let's try a microscopic test-file (NOT representative for true up to date counts !!)
pack1 &lt;- c("cif", "bcv", "FinCovRegularization", "wrMisc", "wrProteo")
testFi &lt;- file.path(system.file("extdata", package="wrMisc"), "rpackagesMicro.html")
packageDownloadStat(pack1, countUrl=testFi, log="y", figure=FALSE)
## For real online counting simply drop the argument countUrl

</code></pre>

<hr>
<h2 id='pairsAsPropensMatr'>Convert Pairs of Node-Names to Non-Oriented Propensity Matrix</h2><span id='topic+pairsAsPropensMatr'></span>

<h3>Description</h3>

<p>Numerous network query tools produce a listing of pairs of nodes (with one pair of nodes per line). 
Using this function such a <code>matrix</code> (or <code>data.frame</code>) can be combined to this more comprehensive view as propensity-matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairsAsPropensMatr(mat, silent = FALSE, debug = FALSE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairsAsPropensMatr_+3A_mat">mat</code></td>
<td>
<p>(matrix) main input, matrix of interaction partners with each line as a separate pair of nodes; 
the first two columns should contain identifiers of the nodes</p>
</td></tr>
<tr><td><code id="pairsAsPropensMatr_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="pairsAsPropensMatr_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="pairsAsPropensMatr_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note, this has been primarily developed for undirected interaction networks, the resulting propensity-matrix does not show any orientation any more.   
In a number of applications (eg in protein-protein interaction networks, PPI) the resulting matrix may be rather sparse.
</p>


<h3>Value</h3>

<p>This function returns matrix or data.frame
</p>


<h3>See Also</h3>

<p>uses typically input from <code><a href="#topic+filterNetw">filterNetw</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pairs3L &lt;- matrix(LETTERS[c(1,3,3, 2,2,1)], ncol=2)    # loop of 3
(netw13pr &lt;- pairsAsPropensMatr(pairs3L))              # as prop matr

</code></pre>

<hr>
<h2 id='partialDist'>Partial distance matrix (focus on closest)</h2><span id='topic+partialDist'></span>

<h3>Description</h3>

<p><code>partialDist</code> calculates distance matrix like <code>dist</code> for 1- or 2-dim data, but only partially, ie only cases of small distances.
This function was made for treating very large data-sets where only very close distances to a given point need to be found,
it allows to overcome memory-problems with larger data (and faster execution with &gt; 50 rows of 'dat').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partialDist(
  dat,
  groups,
  overLap = TRUE,
  method = "euclidean",
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partialDist_+3A_dat">dat</code></td>
<td>
<p>(matrix of numeric values) main input</p>
</td></tr>
<tr><td><code id="partialDist_+3A_groups">groups</code></td>
<td>
<p>(factor) to split using <code>cut</code> or specific custom grouping (length of dat)</p>
</td></tr>
<tr><td><code id="partialDist_+3A_overlap">overLap</code></td>
<td>
<p>(logical) if TRUE make groups overlapping by 1 value (ie maintain some context-information)</p>
</td></tr>
<tr><td><code id="partialDist_+3A_method">method</code></td>
<td>
<p>'character' name of method passed to <code>dist</code></p>
</td></tr>
<tr><td><code id="partialDist_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="partialDist_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="partialDist_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix with partial distances (not of class 'dist' object)
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016); mat3 &lt;- matrix(runif(300),nr=30)
round(dist(mat3), 1)
round(partialDist(mat3, gr=3), 1)
</code></pre>

<hr>
<h2 id='partUnlist'>Partial unlist of lists of lists</h2><span id='topic+partUnlist'></span>

<h3>Description</h3>

<p><code>partUnlist</code> does partial unlist for treating list of lists : New (returned) list has one level less of hierarchy 
(Highest level list will be appended). In case of conflicting (non-null) listnames a prefix will be added. 
Behaviour different to <code><a href="base.html#topic+unlist">unlist</a></code> when unlisting list of matrixes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partUnlist(lst, sep = "_", silent = FALSE, debug = FALSE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partUnlist_+3A_lst">lst</code></td>
<td>
<p>(list) main input, list to be partially unlisted</p>
</td></tr>
<tr><td><code id="partUnlist_+3A_sep">sep</code></td>
<td>
<p>(character, length=1) separator for names</p>
</td></tr>
<tr><td><code id="partUnlist_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="partUnlist_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="partUnlist_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with partially reduced nested structure
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+unlist">unlist</a></code>, <code><a href="#topic+asSepList">asSepList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>partUnlist(list(list(a=11:12,b=21:24), list(c=101:101,d=201:204)))
li4 &lt;- list(c=1:3, M2=matrix(1:4,ncol=2), L3=list(L1=11:12, M3=matrix(21:26,ncol=2)))
partUnlist(li4)
unlist(li4, rec=FALSE)
</code></pre>

<hr>
<h2 id='pasteC'>Advanced paste-collapse</h2><span id='topic+pasteC'></span>

<h3>Description</h3>

<p>This function is a variant of <code><a href="base.html#topic+paste">paste</a></code> for convenient use of paste-collapse and separation of last element to paste (via 'lastCol').
This function was mode for more human like enumeriating in output and messages.
If multiple arguments are given without names they will all be concatenated, if they contain names lazy evaluation for names will be tried
(with preference to longest match to argument names).
Note that some special characters (like backslash) may need to be protetected when used with 'collapse' or 'quoteC'.
Returns character vector of length 1 (everything pasted together)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pasteC(..., collapse = ", ", lastCol = " and ", quoteC = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pasteC_+3A_...">...</code></td>
<td>
<p>(character) main input to be collapsed</p>
</td></tr>
<tr><td><code id="pasteC_+3A_collapse">collapse</code></td>
<td>
<p>(character,length=1) element to use for collapsing</p>
</td></tr>
<tr><td><code id="pasteC_+3A_lastcol">lastCol</code></td>
<td>
<p>(character) text to use before last item enumerated element</p>
</td></tr>
<tr><td><code id="pasteC_+3A_quotec">quoteC</code></td>
<td>
<p>character to use for citing with quotations (default &quot;&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a character vector of truncated versions of intpup <code>txt</code>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+paste">paste</a></code> for basic paste
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pasteC(1:4)
</code></pre>

<hr>
<h2 id='presenceFilt'>Filter lines of matrix for max number of NAs</h2><span id='topic+presenceFilt'></span>

<h3>Description</h3>

<p>This function produces a logical matrix to be used as filter for lines of 'dat' for sufficient presence of non-<code>NA</code> values (ie limit number of NAs per line). 
Filter abundance/expression data for min number and/or ratio of non-<code>NA</code> values in at east 1 of multiple groups.
This type of procedure is common in proteomics and tanscriptomics, where a <code>NA</code> can many times be assocoaued with quantitation below detetction limit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>presenceFilt(
  dat,
  grp,
  maxGrpMiss = 1,
  ratMaxNA = 0.8,
  minVal = NULL,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="presenceFilt_+3A_dat">dat</code></td>
<td>
<p>matrix or data.frame (abundance or expression-values which may contain some <code>NA</code>s).</p>
</td></tr>
<tr><td><code id="presenceFilt_+3A_grp">grp</code></td>
<td>
<p>factor of min 2 levels describing which column of 'dat' belongs to which group (levels 1 &amp; 2 will be used)</p>
</td></tr>
<tr><td><code id="presenceFilt_+3A_maxgrpmiss">maxGrpMiss</code></td>
<td>
<p>(numeric) at least 1 group has not more than this number of NAs (otherwise marke line as bad)</p>
</td></tr>
<tr><td><code id="presenceFilt_+3A_ratmaxna">ratMaxNA</code></td>
<td>
<p>(numeric) at least 1 group reaches this content of non-<code>NA</code> values</p>
</td></tr>
<tr><td><code id="presenceFilt_+3A_minval">minVal</code></td>
<td>
<p>(default NULL or numeric), any value below will be treated like <code>NA</code></p>
</td></tr>
<tr><td><code id="presenceFilt_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="presenceFilt_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="presenceFilt_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical matrix (with separate col for each pairwise combination of 'grp' levels) indicating if line of 'dat' acceptable based on <code>NA</code>s (and values minVal)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+presenceGrpFilt">presenceGrpFilt</a></code>,  there are also other packages totaly dedicated to filtering on CRAN and Bioconductor
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(rep(8,150), ncol=15, dimnames=list(NULL,
  paste0(rep(LETTERS[4:2],each=6),1:6)[c(1:5,7:16)]))
mat[lower.tri(mat)] &lt;- NA
mat[,15] &lt;- NA
mat[c(2:3,9),14:15] &lt;- NA
mat[c(1,10),13:15] &lt;- NA
mat
presenceFilt(mat ,rep(LETTERS[4:2], c(5,6,4)))
presenceFilt(mat, rep(1:2,c(9,6)))

# one more example 
dat1 &lt;- matrix(1:56, ncol=7)
dat1[c(2,3,4,5,6,10,12,18,19,20,22,23,26,27,28,30,31,34,38,39,50,54)] &lt;- NA
dat1; presenceFilt(dat1,gr=gl(3,3)[-(3:4)], maxGr=0)
presenceFilt(dat1, gr=gl(2,4)[-1], maxGr=1, ratM=0.1)
presenceFilt(dat1, gr=gl(2,4)[-1], maxGr=2, rat=0.5)
</code></pre>

<hr>
<h2 id='presenceGrpFilt'>Filter for each group of columns for sufficient data as non-NA</h2><span id='topic+presenceGrpFilt'></span>

<h3>Description</h3>

<p>The aim of this function is to filter for each group of columns for sufficient data as non-NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>presenceGrpFilt(dat, grp, presThr = 0.75, silent = FALSE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="presenceGrpFilt_+3A_dat">dat</code></td>
<td>
<p>matrix or data.frame (abundance or expression-values which may contain some <code>NA</code>s).</p>
</td></tr>
<tr><td><code id="presenceGrpFilt_+3A_grp">grp</code></td>
<td>
<p>factor of min 2 levels describing which column of 'dat' belongs to which group (levels 1 &amp; 2 will be used)</p>
</td></tr>
<tr><td><code id="presenceGrpFilt_+3A_presthr">presThr</code></td>
<td>
<p>(numeric) min ratio of non- <code>NA</code> values (per group) for returning a given line &amp; group as  <code>TRUE</code></p>
</td></tr>
<tr><td><code id="presenceGrpFilt_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="presenceGrpFilt_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows to identify lines with an <code>NA</code>-content above the threshold <code>presThr</code> per group as defined by the levels of factor <code>grp</code>.  
With different types of projects/questions different threshold  <code>presThr</code> levels may be useful.
For example, if one would like to keep the degree of threshold  <code>presThr</code>s per group rather low, one could use a value of 0.75 (ie &gt;= 75
</p>


<h3>Value</h3>

<p>logical matrix (with on column for each level of <code>grp</code>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+presenceFilt">presenceFilt</a></code>, there are also other packages totaly dedicated to filtering on CRAN and Bioconductor
</p>


<h3>Examples</h3>

<pre><code class='language-R'> mat &lt;- matrix(NA, nrow=11, ncol=6)
 mat[lower.tri(mat)] &lt;- 1
 mat &lt;- cbind(mat, mat[,1:4])
 colnames(mat) &lt;- c(paste0("re",1:6), paste0("x",1:4))
 mat[6:8,7:10] &lt;- mat[1:3,7:10]  # ref
 mat[9:11,1:6] &lt;- mat[2:4,1:6]

##  accept 1 NA out of 4, 2 NA out of 6   (ie certainly present)
 (filt0a &lt;- presenceGrpFilt(mat, rep(1:2, c(6,4)), pres=0.66))
##  accept 2 NA out of 4, 2 NA out of 6   (ie min 50% present)
 (filt0b &lt;- presenceGrpFilt(mat, rep(1:2, c(6,4)), pres=0.5))
##  accept 3 NA out of 4, 4 NA out of 6   (ie possibly present)
 (filt0c &lt;- presenceGrpFilt(mat, rep(1:2, c(6,4)), pres=0.19))

</code></pre>

<hr>
<h2 id='protectSpecChar'>Protect Special Characters</h2><span id='topic+protectSpecChar'></span>

<h3>Description</h3>

<p>Some characters do have a special meaning when used with regular expressions.
This concerns characters like a point, parinthesis, backslash etc.
Thus, when using <code>grep</code> or any related command, shuch special characters must get protected in order to get considered as they are.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>protectSpecChar(
  x,
  prot = c(".", "\\", "|", "(", ")", "[", "{", "^", "$", "*", "+", "?"),
  silent = TRUE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="protectSpecChar_+3A_x">x</code></td>
<td>
<p>character vector to be prepared for use in regular expressions</p>
</td></tr>
<tr><td><code id="protectSpecChar_+3A_prot">prot</code></td>
<td>
<p>(character) collection of characters that need to be protected</p>
</td></tr>
<tr><td><code id="protectSpecChar_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="protectSpecChar_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a modified character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aa &lt;- c("abc","abcde","ab.c","ab.c.e","ab*c","ab\\d")
grepl("b.", aa)             # all TRUE
grepl("b\\.", aa)           # manual prootection
grepl(protectSpecChar("b."), aa)
</code></pre>

<hr>
<h2 id='pVal2lfdr'>Convert p-values to lfdr</h2><span id='topic+pVal2lfdr'></span>

<h3>Description</h3>

<p>This function takes a numeric vector of p-values and returns a vector of lfdr-values (local false discovery) using 
the package <a href="https://CRAN.R-project.org/package=fdrtool">fdrtool</a>.
Multiple testing correction should be performed with caution, short series of p-values typically pose problems for transforming to lfdr. 
The transformation to lfdr values may give warning messages, in this case the resultant lfdr values may be invalid !
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pVal2lfdr(x, silent = TRUE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pVal2lfdr_+3A_x">x</code></td>
<td>
<p>(numeric) vector of p.values</p>
</td></tr>
<tr><td><code id="pVal2lfdr_+3A_silent">silent</code></td>
<td>
<p>(logical) suppres messages</p>
</td></tr>
<tr><td><code id="pVal2lfdr_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a (numeric) vector of lfdr values (or <code>NULL</code> if data insufficient to run the function 'fdrtool')
</p>


<h3>See Also</h3>

<p>lfdr from <code><a href="fdrtool.html#topic+fdrtool">fdrtool</a></code>, other p-adjustments (multiple test correction, eg FDR) in <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Note that this example is too small for estimating really meaningful fdr values
## In consequence, a warning will be issued.
set.seed(2017); t8 &lt;- matrix(round(rnorm(160,10,0.4),2), ncol=8,
  dimnames=list(letters[1:20], c("AA1","BB1","CC1","DD1","AA2","BB2","CC2","DD2")))
t8[3:6,1:2] &lt;- t8[3:6,1:2]+3   # augment lines 3:6 (c-f) for AA1&amp;BB1
t8[5:8,5:6] &lt;- t8[5:8,5:6]+3   # augment lines 5:8 (e-h) for AA2&amp;BB2 (c,d,g,h should be found)
head(pVal2lfdr(apply(t8, 1, function(x) t.test(x[1:4], x[5:8])$p.value)))
</code></pre>

<hr>
<h2 id='randIndFx'>Distance of categorical data (Jaccard, Rand and adjusted Rand index)</h2><span id='topic+randIndFx'></span>

<h3>Description</h3>

<p><code>randIndFx</code> calculates distance of categorical data (as Rand Index, Adjusted Rand Index or Jaccard Index). 
Note: uses/requires package <a href="https://CRAN.R-project.org/package=flexclust">flexclust</a>
Methods so far available (via flexclust): &quot;ARI&quot; .. adjusted Rand Index, &quot;RI&quot; .. Rand index, &quot;J&quot; .. Jaccard, &quot;FM&quot; .. Fowlkes-Mallows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randIndFx(ma, method = "ARI", adjSense = TRUE, silent = FALSE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randIndFx_+3A_ma">ma</code></td>
<td>
<p>(matrix) main input for distance calulation</p>
</td></tr>
<tr><td><code id="randIndFx_+3A_method">method</code></td>
<td>
<p>(character) name of distance method (eg &quot;ARI&quot;,&quot;RI&quot;,&quot;J&quot;,&quot;FM&quot;)</p>
</td></tr>
<tr><td><code id="randIndFx_+3A_adjsense">adjSense</code></td>
<td>
<p>(logical) allows introducing correlation/anticorrelation (interprete neg distance results as anti)</p>
</td></tr>
<tr><td><code id="randIndFx_+3A_silent">silent</code></td>
<td>
<p>(logical) suppres messages</p>
</td></tr>
<tr><td><code id="randIndFx_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a distance matrix
</p>


<h3>See Also</h3>

<p><code>comPart</code> in <code><a href="flexclust.html#topic+randIndex">randIndex</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016); tab2 &lt;- matrix(sample(1:2, size=42, replace=TRUE), ncol=7)
if(requireNamespace("flexclust")) { flexclust::comPart(tab2[1,], tab2[2,])
  flexclust::comPart(tab2[1,], tab2[3,])
  flexclust::comPart(tab2[1,], tab2[4,]) }
## via randIndFx():
  randIndFx(tab2, adjSense=FALSE)
  cor(t(tab2))
  randIndFx(tab2, adjSense=TRUE)
</code></pre>

<hr>
<h2 id='rankToContigTab'>Contingenty tables for fit of ranking</h2><span id='topic+rankToContigTab'></span>

<h3>Description</h3>

<p>Count the number of instances where the corresponding columns of 'dat' have a value matching the group number as specified by 'grp'.
Counting will be performed/repeated independently for each line of 'dat'.
Returns array  (1st dim is rows of dat, 2nd is unique(grp), 3rd dim is ok/bad), these results may be tested using eg <code><a href="stats.html#topic+fisher.test">fisher.test</a></code>.
This function was made for prearing to test the ranking of multiple features (lines in 'mat') including replicates (levels of 'grp').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rankToContigTab(dat, grp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rankToContigTab_+3A_dat">dat</code></td>
<td>
<p>(matrix or data.frame of integer values) ranking of multiple features (lines), equal ranks may occur</p>
</td></tr>
<tr><td><code id="rankToContigTab_+3A_grp">grp</code></td>
<td>
<p>(integer) expected ranking</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array (1st dim is rows of dat, 2nd is unique(grp), 3rd dim is ok/bad)
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lm">lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Let's create a matrix with ranks (equal ranks do occur)
ma0 &lt;- matrix(rep(1:3,each=6), ncol=6, dimnames=list(
  c("li1","li2","ref"), letters[1:6]))
ma0[1,6] &lt;- 1                       # create item not matching correctly
ma0[2,] &lt;- c(3:1,2,1,3)             # create items not matching correctly
gr0 &lt;- gl(3,2)                      # the expected ranking (as duplicates)
(count0 &lt;- rankToContigTab(ma0,gr0))
cTab &lt;- t(apply(count0, c(1,3) ,sum))
# Now we can compare the ranking of line1 to ref ...
fisher.test(cTab[,c(3,1)])          # test li1 against ref
fisher.test(cTab[,c(3,2)])          # test li2 against ref
</code></pre>

<hr>
<h2 id='ratioAllComb'>Calculate all ratios between x and y</h2><span id='topic+ratioAllComb'></span>

<h3>Description</h3>

<p>This function calculates all possible pairwise ratios between all individual calues of x and y, or samples up to a maximum number of combinations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ratioAllComb(
  x,
  y,
  maxLim = 10000,
  isLog = FALSE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ratioAllComb_+3A_x">x</code></td>
<td>
<p>(numeric) vector, numerator for constructing rations</p>
</td></tr>
<tr><td><code id="ratioAllComb_+3A_y">y</code></td>
<td>
<p>(numeric) vector, denominator for constructing rations</p>
</td></tr>
<tr><td><code id="ratioAllComb_+3A_maxlim">maxLim</code></td>
<td>
<p>(integer) allows reducing complexity by drawing for very long x or y</p>
</td></tr>
<tr><td><code id="ratioAllComb_+3A_islog">isLog</code></td>
<td>
<p>(logical) adjust ratio calculation to log-data</p>
</td></tr>
<tr><td><code id="ratioAllComb_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="ratioAllComb_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="ratioAllComb_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2014); ra1 &lt;- c(rnorm(9,2,1),runif(8,1,2))
ratioAllComb(ra1[1:9],ra1[10:17])
boxplot(list(norm=ra1[1:9], unif=ra1[10:17], rat=ratioAllComb(ra1[1:9],ra1[10:17])))
</code></pre>

<hr>
<h2 id='ratioToPpm'>Convert ratio to ppm</h2><span id='topic+ratioToPpm'></span>

<h3>Description</h3>

<p>This function transforms ratio 'x' to ppm (parts per million). 
If 'y' not given (or different length as 'x'), then 'x' is assumed as ratio otherise rations are constructed as x/y is used lateron.
Does additional checking : negative values not expected - will be made absolute !
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ratioToPpm(
  x,
  y = NULL,
  nSign = NULL,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ratioToPpm_+3A_x">x</code></td>
<td>
<p>(numeric) main input</p>
</td></tr>
<tr><td><code id="ratioToPpm_+3A_y">y</code></td>
<td>
<p>(numeric) optional value to construct ratios (x/y). If NULL (or different length as 'x'), then 'x' will be considered as ratio.</p>
</td></tr>
<tr><td><code id="ratioToPpm_+3A_nsign">nSign</code></td>
<td>
<p>(numeric) number of significan digits</p>
</td></tr>
<tr><td><code id="ratioToPpm_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="ratioToPpm_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="ratioToPpm_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a numeric vector of ppm values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+XYToDiffPpm">XYToDiffPpm</a></code> for ppm of difference as used in mass spectrometrie
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2017); aa &lt;- c(1.000001,0.999999,1+rnorm(10,0,0.001))
cbind(x=aa,ppm=ratioToPpm(aa,nSign=4))
</code></pre>

<hr>
<h2 id='readCsvBatch'>Read batch of csv-files</h2><span id='topic+readCsvBatch'></span>

<h3>Description</h3>

<p>This function was designed to read screening data split in parts (with common structure) and saved to multiple files,  
to extract the numeric columns and to compile all (numeric) data to a single array (or list).  Some screening platforms save results while progressing 
through a pile of microtiter-plates separately. The organization of the resultant files is structured through file-names and all files have exactely the same organization of lines and columns/ 
European or US-formatted csv files can be read, if argument <code>fileFormat</code> is <code>NULL</code> both types will be tested, otherwise it allows to specify a given format.
The presence of headers (to be used as column-names) may be tested using <code>checkFormat</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readCsvBatch(
  fileNames = NULL,
  path = ".",
  fileFormat = "Eur",
  checkFormat = TRUE,
  returnArray = TRUE,
  columns = c("Plate", "Well", "StainA"),
  excludeFiles = "All infected plates",
  simpleNames = TRUE,
  minNamesLe = 4,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readCsvBatch_+3A_filenames">fileNames</code></td>
<td>
<p>(character) names of files to be read, if <code>NULL</code> all files fitting 'fileFormat'</p>
</td></tr>
<tr><td><code id="readCsvBatch_+3A_path">path</code></td>
<td>
<p>(character) where files should be read (folders should be written in R-style)</p>
</td></tr>
<tr><td><code id="readCsvBatch_+3A_fileformat">fileFormat</code></td>
<td>
<p>(character) may be <code>NULL</code> (both US and European formats will be tried), 'Eur' or 'US'</p>
</td></tr>
<tr><td><code id="readCsvBatch_+3A_checkformat">checkFormat</code></td>
<td>
<p>(logical) if <code>TRUE</code>: check header, remove empty columns, 1st line if all empmty, set output format for each file to matrix, if rownames are increasing integeres try to use 2nd of 'columns' as rownames</p>
</td></tr>
<tr><td><code id="readCsvBatch_+3A_returnarray">returnArray</code></td>
<td>
<p>(logical) allows switching from array to list-output</p>
</td></tr>
<tr><td><code id="readCsvBatch_+3A_columns">columns</code></td>
<td>
<p>(NULL or character) column-headers to be extracted (if specified), 2nd value may be comlumn with rownames (if rownames are encountered as increasing rownames)</p>
</td></tr>
<tr><td><code id="readCsvBatch_+3A_excludefiles">excludeFiles</code></td>
<td>
<p>(character) names of files to exclude (only used when reading all files of given directory)</p>
</td></tr>
<tr><td><code id="readCsvBatch_+3A_simplenames">simpleNames</code></td>
<td>
<p>(logical) allows truncating names (from beginning) to get to variable part (using .trimFromStart()), but keeping 'minNamesLe'</p>
</td></tr>
<tr><td><code id="readCsvBatch_+3A_minnamesle">minNamesLe</code></td>
<td>
<p>(interger) min length of column-names if simpleNames=TRUE</p>
</td></tr>
<tr><td><code id="readCsvBatch_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="readCsvBatch_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="readCsvBatch_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an array (or list if <code>returnArray=FALSE</code>) of all numeric data read (numerical columns only) from individual files
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.table</a></code>, <code><a href="#topic+writeCsv">writeCsv</a></code>, <code><a href="#topic+readXlsxBatch">readXlsxBatch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path1 &lt;- system.file("extdata", package="wrMisc")
fiNa &lt;-  c("pl01_1.csv","pl01_2.csv","pl02_1.csv","pl02_2.csv")
datAll &lt;- readCsvBatch(fiNa, path1)
str(datAll)
## batch reading of all csv files in specified path :
datAll2 &lt;- readCsvBatch(fileNames=NULL, path=path1, silent=TRUE)
</code></pre>

<hr>
<h2 id='readTabulatedBatch'>Batch reading of Tabulated Text-Files</h2><span id='topic+readTabulatedBatch'></span>

<h3>Description</h3>

<p>This function allows batch reading of multiple tabulated text files n batch. 
The files can be designed specifically, or, alternatively all files from a given directory can be read.
If package <a href="https://CRAN.R-project.org/package=data.table">data.table</a> is available, faster reading of files will be performed using the function <code><a href="data.table.html#topic+fread">fread</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readTabulatedBatch(
  query,
  path = NULL,
  dec = ".",
  header = "auto",
  strip.white = FALSE,
  blank.lines.skip = TRUE,
  fill = FALSE,
  filtCol = 2,
  filterAsInf = TRUE,
  filtVal = 5000,
  silent = FALSE,
  callFrom = NULL,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readTabulatedBatch_+3A_query">query</code></td>
<td>
<p>(character) vector of file-names to be read, if <code>"."</code> all files will be read (no matter what their extension might be)</p>
</td></tr>
<tr><td><code id="readTabulatedBatch_+3A_path">path</code></td>
<td>
<p>(character) path for reading files, if <code>NULL</code> or <code>NA</code> the current directory will be used</p>
</td></tr>
<tr><td><code id="readTabulatedBatch_+3A_dec">dec</code></td>
<td>
<p>(character, length=1) decimals to use, will be passed to <code><a href="data.table.html#topic+fread">fread</a></code> or <code><a href="utils.html#topic+read.delim">read.delim</a></code></p>
</td></tr>
<tr><td><code id="readTabulatedBatch_+3A_header">header</code></td>
<td>
<p>(character, length=1) path for reading files, if <code>NULL</code> or <code>NA</code> the current directory will be used, will be passed to <code><a href="data.table.html#topic+fread">fread</a></code> or <code><a href="utils.html#topic+read.delim">read.delim</a></code></p>
</td></tr>
<tr><td><code id="readTabulatedBatch_+3A_strip.white">strip.white</code></td>
<td>
<p>(logical, length=1) Strips leading and trailing whitespaces of unquoted fields, will be passed to <code><a href="data.table.html#topic+fread">fread</a></code> or <code><a href="utils.html#topic+read.delim">read.delim</a></code></p>
</td></tr>
<tr><td><code id="readTabulatedBatch_+3A_blank.lines.skip">blank.lines.skip</code></td>
<td>
<p>(logical, length=1)  If <code>TRUE</code> blank lines in the input are ignored. will be passed to <code><a href="data.table.html#topic+fread">fread</a></code> or <code><a href="utils.html#topic+read.delim">read.delim</a></code></p>
</td></tr>
<tr><td><code id="readTabulatedBatch_+3A_fill">fill</code></td>
<td>
<p>(logical, length=1) If <code>TRUE</code> then in case the rows have unequal length, blank fields are implicitly filled, will be passed to <code><a href="data.table.html#topic+fread">fread</a></code> or <code><a href="utils.html#topic+read.delim">read.delim</a></code></p>
</td></tr>
<tr><td><code id="readTabulatedBatch_+3A_filtcol">filtCol</code></td>
<td>
<p>(integer, length=1) which columns should be used for filtering, if <code>NULL</code> or <code>NA</code> all data will be returned</p>
</td></tr>
<tr><td><code id="readTabulatedBatch_+3A_filterasinf">filterAsInf</code></td>
<td>
<p>(logical, length=1) filter as inferior or equal (<code>TRUE</code>) or superior or equal threshold <code>filtVal</code></p>
</td></tr>
<tr><td><code id="readTabulatedBatch_+3A_filtval">filtVal</code></td>
<td>
<p>(numeric, length=1) which numeric threshold should be used for filtering, if <code>NULL</code> or <code>NA</code> all data will be returned</p>
</td></tr>
<tr><td><code id="readTabulatedBatch_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="readTabulatedBatch_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
<tr><td><code id="readTabulatedBatch_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you want to provide a flexible pattern of ffile-names, this has to be done before calling this usntion, eg using <code>grep</code> to provide an explicit collection of flles.
However, it is possible to read different files from different locations/directories, the length of <code>path</code> must match the length of <code>query</code>
</p>


<h3>Value</h3>

<p>This function returns a list of data.frames
</p>


<h3>See Also</h3>

<p><code><a href="data.table.html#topic+fread">fread</a></code>, <code><a href="utils.html#topic+read.delim">read.delim</a></code>, for reading batch of csv files : <code><a href="#topic+readCsvBatch">readCsvBatch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path1 &lt;- system.file("extdata", package="wrMisc")
fiNa &lt;-  c("a1.txt","a2.txt")
allTxt &lt;- readTabulatedBatch(fiNa, path1)
str(allTxt)

</code></pre>

<hr>
<h2 id='readVarColumns'>Read tabular content of files with variable number of columns</h2><span id='topic+readVarColumns'></span>

<h3>Description</h3>

<p>Reading the content of files where the number of separators (eg tabulation) is variable poses problems with traditional methods for reding files, like  <code><a href="utils.html#topic+read.table">read.table</a></code>.
This function reads each line independently and then parses all separators therein. The first line is assumed to be column-headers.
Finally, all data will be returned in a matrix adopted to the line with most separators and if the number of column-headers is insufficient, new (unique) column-headers will be generated.
Thus, the lines may contain different number of elements, empty elements (ie tabular fields) will always get added to right of data read 
and their content will be as defined by argument <code>emptyFields</code> (default <code>NA</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readVarColumns(
  fiName,
  path = NULL,
  sep = "\t",
  header = TRUE,
  emptyFields = NA,
  refCo = NULL,
  supNa = NULL,
  silent = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readVarColumns_+3A_finame">fiName</code></td>
<td>
<p>(character) file-name</p>
</td></tr>
<tr><td><code id="readVarColumns_+3A_path">path</code></td>
<td>
<p>(character) optional path</p>
</td></tr>
<tr><td><code id="readVarColumns_+3A_sep">sep</code></td>
<td>
<p>(character) separator (between columns)</p>
</td></tr>
<tr><td><code id="readVarColumns_+3A_header">header</code></td>
<td>
<p>(logical) indicating whether the file contains the names of the variables as its first line.</p>
</td></tr>
<tr><td><code id="readVarColumns_+3A_emptyfields">emptyFields</code></td>
<td>
<p>(<code>NA</code> or character) missing headers will be replaced by the content of 'emptyFields', if <code>NA</code> the last column-name will be re-used and a counter added</p>
</td></tr>
<tr><td><code id="readVarColumns_+3A_refco">refCo</code></td>
<td>
<p>(integer) for custom choice of column to be used as row-names (default will use 1st text-column)</p>
</td></tr>
<tr><td><code id="readVarColumns_+3A_supna">supNa</code></td>
<td>
<p>(character) base for constructing name for columns wo names (+counter starting at 2), default column-name to left of 1st col wo colname</p>
</td></tr>
<tr><td><code id="readVarColumns_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="readVarColumns_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note, this functions assumes one line of header and at least one line of data !
Note, for numeric data the comma is assumed to be US-Style (as '.').
Note, that it is assumed, that any missing fields for the complete tabular view are missing on the right (ie at the end of line) !
</p>


<h3>Value</h3>

<p>This function returns a matrix (character or numeric)
</p>


<h3>See Also</h3>

<p>for regular 'complete' data <code><a href="utils.html#topic+read.table">read.table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path1 &lt;- system.file("extdata",package="wrMisc")
fiNa &lt;- "Names1.tsv"
datAll &lt;- readVarColumns(fiName=file.path(path1,fiNa))
str(datAll)
</code></pre>

<hr>
<h2 id='readXlsxBatch'>Read Batch of Excel xlsx-Files</h2><span id='topic+readXlsxBatch'></span>

<h3>Description</h3>

<p><code>readXlsxBatch</code> reads data out of multiple xlsx files, the sheet indicated by 'sheetInd' will be considered. 
All files must have the same organization of data, as this is typically the case when high-throughput measurements are automatically saved while experiments progress.
In particular, the first file read is used to structure the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readXlsxBatch(
  fileNames = NULL,
  path = ".",
  fileExtension = "xlsx",
  excludeFiles = NULL,
  sheetInd = 1,
  checkFormat = TRUE,
  returnArray = TRUE,
  columns = c("Plate", "Well", "StainA"),
  simpleNames = 3,
  silent = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readXlsxBatch_+3A_filenames">fileNames</code></td>
<td>
<p>(character) provide either explicit list of file-names to be read or leave <code>NULL</code> for reading all files ending with 'xlsx' in path specified with argument <code>path</code></p>
</td></tr>
<tr><td><code id="readXlsxBatch_+3A_path">path</code></td>
<td>
<p>(character) there may be a different path for each file</p>
</td></tr>
<tr><td><code id="readXlsxBatch_+3A_fileextension">fileExtension</code></td>
<td>
<p>(character) extension of files (default='<code>xlsx</code>')</p>
</td></tr>
<tr><td><code id="readXlsxBatch_+3A_excludefiles">excludeFiles</code></td>
<td>
<p>(character) names of files to exclude (only used when reading all files of given directory)</p>
</td></tr>
<tr><td><code id="readXlsxBatch_+3A_sheetind">sheetInd</code></td>
<td>
<p>(character or integer) specify which sheet to extract (as exact name of sheed or sheet-number, eg <code>sheetInd=2</code> will extract always the 2nd sheet (no matter the name); if given as sheet-name but nor present in file an empty list-elements wil be returned</p>
</td></tr>
<tr><td><code id="readXlsxBatch_+3A_checkformat">checkFormat</code></td>
<td>
<p>(logical) if <code>TRUE</code>: check header, remove empty columns, if rownames are increasing integeres it will searh for fisrt column with different entries to use as rownames</p>
</td></tr>
<tr><td><code id="readXlsxBatch_+3A_returnarray">returnArray</code></td>
<td>
<p>(logical) allows switching from array to list-output</p>
</td></tr>
<tr><td><code id="readXlsxBatch_+3A_columns">columns</code></td>
<td>
<p>(NULL or character) column-headers to be extracted (if specified, otherwise all columns will be extracted)</p>
</td></tr>
<tr><td><code id="readXlsxBatch_+3A_simplenames">simpleNames</code></td>
<td>
<p>(integer), if <code>NULL</code> all characters of fileNames will be maintained, otherwise allows truncating names (from beginning) to get to variable part (using .trimFromStart()), but keeping at least the number of charcters indicated by this argument</p>
</td></tr>
<tr><td><code id="readXlsxBatch_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="readXlsxBatch_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default all columns with text-content may be eliminated to keep the numeric part only, which may then get organized to a 3-dim numeric array 
(where the additional files will be used as 2nd dimension and multiple columns per file shown as 3rd dimension). 
</p>
<p>NOTE : (starting from version wrMisc-1.5.5) requires packages <a href="https://CRAN.R-project.org/package=readxl">readxl</a> and 
<a href="https://CRAN.R-project.org/package=Rcpp">Rcpp</a> being installed ! 
(This allows much faster and memory efficient processing than previous use of package '<code>xlsx</code>')
</p>


<h3>Value</h3>

<p>This function returns a list of data.frames
</p>


<h3>See Also</h3>

<p><code><a href="readxl.html#topic+read_excel">read_excel</a></code>; for simple reading of (older) xls-files under 32-bit R one may also see the package <a href="https://CRAN.R-project.org/package=RODBC">RODBC</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path1 &lt;- system.file("extdata", package="wrMisc")
fiNa &lt;- c("pl01_1.xlsx","pl01_2.xlsx","pl02_1.xlsx","pl02_2.xlsx")
datAll &lt;- readXlsxBatch(fiNa, path1)
str(datAll)
## Now let's read all xlsx files of directory
datAll2 &lt;- readXlsxBatch(path=path1, silent=TRUE)
identical(datAll, datAll2)
</code></pre>

<hr>
<h2 id='reduceTable'>Reduce table by aggregating smaller groups</h2><span id='topic+reduceTable'></span>

<h3>Description</h3>

<p><code>reduceTable</code> treats/reduces results from <code><a href="base.html#topic+table">table</a></code> to 'nGrp' groups, 
optional indiv resolution of 'separFirst' (numeric or NULL). 
Mainly made for reducing the number of classes for betters plots with <code><a href="graphics.html#topic+pie">pie</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduceTable(tab, separFirst = 4, nGrp = 15)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduceTable_+3A_tab">tab</code></td>
<td>
<p>output of <code><a href="base.html#topic+table">table</a></code></p>
</td></tr>
<tr><td><code id="reduceTable_+3A_separfirst">separFirst</code></td>
<td>
<p>(integer or NULL) optinal separartion of n 'separFirst' groups (value &lt;2 or NULL 
will priviledge more uniform size of groups, higher values will cause small inital and larger tailing groups)</p>
</td></tr>
<tr><td><code id="reduceTable_+3A_ngrp">nGrp</code></td>
<td>
<p>(integer) number of groups expected</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a numeric vector with number of counts and class-borders as names (like table).
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+table">table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2018); dat &lt;- sample(11:60,200,repl=TRUE)
pie(table(dat))
pie(reduceTable(table(dat), sep=NULL))
pie(reduceTable(table(dat), sep=NULL), init.angle=90,
  clockwise=TRUE, col=rainbow(20)[1:15], cex=0.8)
</code></pre>

<hr>
<h2 id='regrBy1or2point'>Rescaling according to reference data using linear regression.</h2><span id='topic+regrBy1or2point'></span>

<h3>Description</h3>

<p><code>regrBy1or2point</code> does rescaling: linear transform simple vector 'inDat' that (mean of) elements of names cited in 'refLst' will end up as values 'regrTo'. 
Regress single vector according to 'refLst' (describing names of inDat).
If 'refLst' contains 2 groups, the 1st group will be set to the 1st value of 'regrTo' (and the 2nd group of 'refLst' to the 2nd 'regtTo')
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regrBy1or2point(
  inDat,
  refLst,
  regrTo = c(1, 0.5),
  silent = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regrBy1or2point_+3A_indat">inDat</code></td>
<td>
<p>matrix or data.frame</p>
</td></tr>
<tr><td><code id="regrBy1or2point_+3A_reflst">refLst</code></td>
<td>
<p>list of names existing in inDat (one group of names for each value in 'regrTo'), to be transformed in values precised in 'regTo'; if no matches to names of 'inDat' found, the 2 lowest and/or highest highest values will be chosen</p>
</td></tr>
<tr><td><code id="regrBy1or2point_+3A_regrto">regrTo</code></td>
<td>
<p>(numeric,length=2) range (at scale 0-1) of target-values for mean of elements cited in 'refLst'</p>
</td></tr>
<tr><td><code id="regrBy1or2point_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="regrBy1or2point_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>normalized matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adjBy2ptReg">adjBy2ptReg</a></code>, <code><a href="#topic+regrMultBy1or2point">regrMultBy1or2point</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016); dat1 &lt;- 1:50 +(1:50)*round(runif(50),1)
names(dat1) &lt;- 1:length(dat1)
reg1 &lt;- regrBy1or2point(dat1,refLst=c("2","49"))
plot(reg1,dat1) 
</code></pre>

<hr>
<h2 id='regrMultBy1or2point'>Rescaling of multiple data-sets according to reference data using regression</h2><span id='topic+regrMultBy1or2point'></span>

<h3>Description</h3>

<p><code>regrMultBy1or2point</code> regresses each col of matrix according to 'refLst'(describing rownames of inDat). 
If 'refLst' conatins 2 groups, the 1st group will be set to the 1st value of 'regrTo' (and the 2nd group of 'refLst' to the 2nd 'regtTo')
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regrMultBy1or2point(
  inDat,
  refLst,
  regrTo = c(1, 0.5),
  silent = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regrMultBy1or2point_+3A_indat">inDat</code></td>
<td>
<p>matrix or data.frame</p>
</td></tr>
<tr><td><code id="regrMultBy1or2point_+3A_reflst">refLst</code></td>
<td>
<p>list of names existing in inDat (one group of names for each value in 'regrTo'), to be transformed in values precised in 'regTo'; if no matches to names of 'inDat' found, the 2 lowest and/or highest highest values will be chosen</p>
</td></tr>
<tr><td><code id="regrMultBy1or2point_+3A_regrto">regrTo</code></td>
<td>
<p>(numeric,length=2) range (at scale 0-1) of target-values for mean of elements cited in 'refLst'</p>
</td></tr>
<tr><td><code id="regrMultBy1or2point_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="regrMultBy1or2point_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>normalized matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adjBy2ptReg">adjBy2ptReg</a></code>, <code><a href="#topic+regrBy1or2point">regrBy1or2point</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016); dat2 &lt;- round(cbind(1:50 +(1:50)*runif(50),2.2*(1:50) +rnorm(50,0,3)),1)
rownames(dat2) &lt;- 1:nrow(dat2)
reg1 &lt;- regrBy1or2point(dat2[,1],refLst=list(as.character(5:7),as.character(44:45)))
reg2 &lt;- regrMultBy1or2point(dat2,refLst=list(as.character(5:7),as.character(44:45)))
plot(dat2[,1],reg2[,1])
identical(reg1,reg2[,1])
identical(dat2[,1],reg2[,1])
</code></pre>

<hr>
<h2 id='renameColumns'>Rename columns</h2><span id='topic+renameColumns'></span>

<h3>Description</h3>

<p>This function renames columns of 'refMatr' using 2-column matrix (or data.frame) indicating old and new names (for replacement).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renameColumns(refMatr, newName, silent = FALSE, debug = FALSE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renameColumns_+3A_refmatr">refMatr</code></td>
<td>
<p>matrix (or data.frame) where column-names should be changed</p>
</td></tr>
<tr><td><code id="renameColumns_+3A_newname">newName</code></td>
<td>
<p>(matrix of character) giving correspondence of old to new names (number of lines must match number of columns of 'refMatr')</p>
</td></tr>
<tr><td><code id="renameColumns_+3A_silent">silent</code></td>
<td>
<p>(logical) suppres messages</p>
</td></tr>
<tr><td><code id="renameColumns_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="renameColumns_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix (or data.frame) with renamed columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ma &lt;- matrix(1:8,ncol=4,dimnames=list(1:2,LETTERS[1:4]))
replBy1 &lt;- cbind(new=c("dd","bb","z_"),old=c("D","B","zz"))
replBy2 &lt;- matrix(c("D","B","zz","dd","bb","z_"),ncol=2)
replBy3 &lt;- matrix(c("X","Y","zz","xx","yy","z_"),ncol=2)
renameColumns(ma,replBy1)
renameColumns(ma,replBy2)
renameColumns(ma,replBy3)
</code></pre>

<hr>
<h2 id='reorgByCluNo'>Reorganize matrix according to clustering-output</h2><span id='topic+reorgByCluNo'></span>

<h3>Description</h3>

<p>Reorganize input matrix as sorted by cluster numbers (and geometric mean) according to vector with cluster names, and index for sorting per cluster and per geometric mean.
In case <code>mat</code> is an array, the 3rd dimension will be considered as 'column' with arguments <code>useColumn</code> ( and <code>cluNo</code>, if it designs a 'column' of mat).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reorgByCluNo(
  mat,
  cluNo,
  useColumn = NULL,
  meanCol = NULL,
  addInfo = TRUE,
  retList = FALSE,
  silent = FALSE,
  callFrom = NULL,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reorgByCluNo_+3A_mat">mat</code></td>
<td>
<p>(matrix or data.frame) main input</p>
</td></tr>
<tr><td><code id="reorgByCluNo_+3A_cluno">cluNo</code></td>
<td>
<p>(positive integer, length to match nrow(dat) initial cluster numbers for each line of 'mat' (obtained by separate clustering or other segmentation) or may desinn column of <code>mat</code> to use as cluster-numbers</p>
</td></tr>
<tr><td><code id="reorgByCluNo_+3A_usecolumn">useColumn</code></td>
<td>
<p>(character or integer) the columns to use from <code>mat</code> as main data (default will use all, exept <code>cluCol</code> and/or <code>meanCol</code> if they design columns))</p>
</td></tr>
<tr><td><code id="reorgByCluNo_+3A_meancol">meanCol</code></td>
<td>
<p>(character or integer) alternative summarizing data for intra-cluster sorting (instead of geometric mean)</p>
</td></tr>
<tr><td><code id="reorgByCluNo_+3A_addinfo">addInfo</code></td>
<td>
<p>(logical) allows adding of columns 'index', 'geoMean' and 'cluNo'  (or array if <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="reorgByCluNo_+3A_retlist">retList</code></td>
<td>
<p>(logical) return as list of matrixes (or array if <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="reorgByCluNo_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="reorgByCluNo_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
<tr><td><code id="reorgByCluNo_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list or array (as 2- or 3 dim) with possible number of occurances for each of the 3 elements in nMax. Read results vertical : out[[1]] or out[,,1] .. (multiplicative) table for 1st element of nMax; out[,,2] .. for 2nd
</p>


<h3>See Also</h3>

<p>pairwise combinations <code><a href="utils.html#topic+combn">combn</a></code>, clustering <code><a href="stats.html#topic+kmeans">kmeans</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat1 &lt;- matrix(round(runif(24),2), ncol=3, dimnames=list(NULL,letters[1:3]))
clu &lt;- stats::kmeans(dat1, 5)$cluster
reorgByCluNo(dat1, clu) 

dat2 &lt;- cbind(dat1, clu=clu) 
reorgByCluNo(dat2, "clu") 
</code></pre>

<hr>
<h2 id='replicateStructure'>Search and Select Groups of Replicates</h2><span id='topic+replicateStructure'></span>

<h3>Description</h3>

<p>This function was designed for mining annotation information organized in multiple columns to identify the (potential) grouping of multiple samples, ie to determine factor levels.
The argument <code>method</code> allows further finetuning if high or low number of groups should be preferred, if multiple columns may be combined, or to choose a particular custom column for desiganting factor levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replicateStructure(
  x,
  method = "median",
  sep = "__",
  exclNoRepl = TRUE,
  trimNames = FALSE,
  includeOther = FALSE,
  silent = FALSE,
  callFrom = NULL,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replicateStructure_+3A_x">x</code></td>
<td>
<p>(matrix or data.frame) the annotation to inspect; each column is supposed to describe another set of annoation/metadata for the rows of <code>x</code> (min 1 row and 1 column),</p>
</td></tr>
<tr><td><code id="replicateStructure_+3A_method">method</code></td>
<td>
<p>(character, length=1) the procedure to choose column(s) with properties of information, may be <code>highest</code> or <code>max</code> (max number of levels)
<code>lowest</code> or <code>min</code> (min number of levels), <code>median</code> (median of all options for number of levels),
<code>combAll</code> (combine all columns of <code>x</code>) or <code>combNonOrth</code> (combine only non-orthogonal columns of <code>x</code>, to avoid avoid n lines with n levels);
lazy evluation of the argument is possible</p>
</td></tr>
<tr><td><code id="replicateStructure_+3A_sep">sep</code></td>
<td>
<p>(character) separator used when a method combining multiple columns (eg combAll, combNonOrth)  is chosen (should not appear anywhere in <code>x</code>)</p>
</td></tr>
<tr><td><code id="replicateStructure_+3A_exclnorepl">exclNoRepl</code></td>
<td>
<p>(logical) decide whether columns with all values different (ie no replicates or max divergency) should be excluded</p>
</td></tr>
<tr><td><code id="replicateStructure_+3A_trimnames">trimNames</code></td>
<td>
<p>(logical) optional trimming of names in <code>x</code> by removing redundant heading and tailing text</p>
</td></tr>
<tr><td><code id="replicateStructure_+3A_includeother">includeOther</code></td>
<td>
<p>(logical) include $allCols with pattern of (all) other columns</p>
</td></tr>
<tr><td><code id="replicateStructure_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="replicateStructure_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
<tr><td><code id="replicateStructure_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Statistical tests require specifying which samples should be considered as replicates of whom.
In some cases, like the Sdrf-format, automatic mining of such annotation to indentify an experiment's underlying structure of replicates
may be challanging, since the key information may not always be found in the same column.
For this reason this function allows inspecting all columns of a matrix of data.frame to identify which colmns may serve describing groups of replicates.
</p>
<p>The argument <code>exclNoRepl=TRUE</code> allows excluding all columns with different content for each line (like line-numbers), ie information without any replicates.
It is set by default to <code>TRUE</code> to exclude such columns, since statistical tests usually do require some replicates.
</p>
<p>When using as <code>method="combAll"</code>, there is risk all lines (samples) will be be considered different and no replicates remain.
To avoid this situation the argument can be set to <code>method="combNonOrth"</code>.
Using this mode it will be checked if adding more columns will lead to complete loss of replicates, and -if so- concerned columns omitted.
</p>


<h3>Value</h3>

<p>This function returns a list with $col (column index relativ to <code>x</code>), $lev (abstract labels of level),
$meth (note of method finally used) and $allCols with general replicate structure of all columns of  <code>x</code>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+duplicated">duplicated</a></code>, uses <code><a href="#topic+trimRedundText">trimRedundText</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a is all different, b is groups of 2,
## c &amp; d  are groups of 2 nut NOT 'same general' pattern as b
strX &lt;- data.frame(a=letters[18:11], b=letters[rep(c(3:1,4), each=2)],
 c=letters[rep(c(5,8:6), each=2)], d=letters[c(1:2,1:3,3:4,4)],
 e=letters[rep(c(4,8,4,7),each=2)], f=rep("z",8) )
strX
replicateStructure(strX[,1:2])
replicateStructure(strX[,1:4], method="combAll")
replicateStructure(strX[,1:4], method="combAll", exclNoRepl=FALSE)
replicateStructure(strX[,1:4], method="combNonOrth", exclNoRepl=TRUE)
replicateStructure(strX, method="lowest")
replicateStructure(strX, method=3, includeOther=TRUE)   # custom choice of 3rd column



</code></pre>

<hr>
<h2 id='replNAbyLow'>Replace NAs by low values</h2><span id='topic+replNAbyLow'></span>

<h3>Description</h3>

<p>With several screening techniques used in hight-throughput biology values at/below detection limit are returned as <code>NA</code>.
However, the resultant <code>NA</code>-values may be difficult to analyse properly, simply ignoring <code>NA</code>-values mat not be a good choice.
When (technical) replicate measurements are available, one can look for cases where one gave an <code>NA</code> while the other did not 
with the aim of investigating such 'NA-neighbours'.  
<code>replNAbyLow</code> locates and replaces <code>NA</code> values by (random) values from same line &amp; same group 'grp'. 
The origin of NAs should be predominantly absence of measure (quantitation) due to signal below limit of detection
and not saturation at upper detection limit or other technical problems.  
Note, this approach may be not optimal if the number of NA-neighbours is very low.
Replacamet is done -depending on agrument 'unif'- by Gaussian random model based on neighbour values (within same group),
using their means and sd, or a uniform random model (min and max of neighbour values) .
Then numeric matrix (same dim as 'x') with <code>NA</code> replaced is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replNAbyLow(
  x,
  grp,
  quant = 0.8,
  signific = 3,
  unif = TRUE,
  absOnly = FALSE,
  seed = NULL,
  silent = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replNAbyLow_+3A_x">x</code></td>
<td>
<p>(numeric matrix or data.frame) main input</p>
</td></tr>
<tr><td><code id="replNAbyLow_+3A_grp">grp</code></td>
<td>
<p>(factor) to organize replicate columns of (x)</p>
</td></tr>
<tr><td><code id="replNAbyLow_+3A_quant">quant</code></td>
<td>
<p>(numeric) quantile form 'neighbour' values to use as upper limit for random values</p>
</td></tr>
<tr><td><code id="replNAbyLow_+3A_signific">signific</code></td>
<td>
<p>number of signif digits for random values</p>
</td></tr>
<tr><td><code id="replNAbyLow_+3A_unif">unif</code></td>
<td>
<p>(logical) toggle between uniform and Gaussian random values</p>
</td></tr>
<tr><td><code id="replNAbyLow_+3A_absonly">absOnly</code></td>
<td>
<p>(logical) if TRUE, make negative NA-replacment values positive as absolute values</p>
</td></tr>
<tr><td><code id="replNAbyLow_+3A_seed">seed</code></td>
<td>
<p>(integer) for use with set.seed for reproducible output</p>
</td></tr>
<tr><td><code id="replNAbyLow_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="replNAbyLow_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix (same dim as 'x') with <code>NA</code> replaced
</p>


<h3>See Also</h3>

<p><code><a href="#topic+naOmit">naOmit</a></code>, <code><a href="stats.html#topic+na.fail">na.fail</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- matrix(round(rnorm(30),2),ncol=6); grD &lt;- gl(2,3)
dat[sort(sample(1:30,9,repl=FALSE))] &lt;- NA
dat; replNAbyLow(dat,gr=grD)
</code></pre>

<hr>
<h2 id='replPlateCV'>CV of replicate plates (list of matrixes)</h2><span id='topic+replPlateCV'></span>

<h3>Description</h3>

<p><code>replPlateCV</code> gets CVs of replicates from list of 2 or 3-dim arrays (where 2nd dim is replicates, 3rd dim may be channel). 
Note : all list-elements of must MUST have SAME dimensions !
When treating data from microtiter plates (eg 8x12) data are typically spread over multiple plates, ie initial matrixes that are the organized into arrays.
Returns matrix or array (1st dim is intraplate-position, 2nd .. plate-group/type, 3rd .. channels)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replPlateCV(lst, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replPlateCV_+3A_lst">lst</code></td>
<td>
<p>list of matrixes : suppose lines are independent elements, colums are replicates of the 1st column. All matrixes must have same dimensions</p>
</td></tr>
<tr><td><code id="replPlateCV_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix or array (1st dim is intraplate-position, 2nd .. plate-group/type, 3rd .. channels)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowCVs">rowCVs</a></code>, @seealso <code><a href="#topic+arrayCV">arrayCV</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016); ra1 &lt;- matrix(rnorm(3*96),nrow=8)
pla1 &lt;- list(ra1[,1:12],ra1[,13:24],ra1[,25:36])
replPlateCV(pla1)
arrL1 &lt;- list(a=array(as.numeric(ra1)[1:192],dim=c(8,12,2)),
  b=array(as.numeric(ra1)[97:288],dim=c(8,12,2)))
replPlateCV(arrL1)
</code></pre>

<hr>
<h2 id='rmDupl2colMatr'>Remove lines of matrix redundant /duplicated for 1st and 2nd column</h2><span id='topic+rmDupl2colMatr'></span>

<h3>Description</h3>

<p><code>rmDupl2colMatr</code> removes lines of matrix that are redundant /duplicated for 1st and 2nd column (irrespective of content of their columns).
The first occurance of redundant /duplicated elements is kept.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmDupl2colMatr(mat, useCol = c(1, 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmDupl2colMatr_+3A_mat">mat</code></td>
<td>
<p>(matrix or data.frame) main input</p>
</td></tr>
<tr><td><code id="rmDupl2colMatr_+3A_usecol">useCol</code></td>
<td>
<p>(integer, length=2) columns to consider/use when looking for duplicated entries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with duplictaed lines removed
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+unlist">unlist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(1:12,ncol=3)
mat[3,1:2] &lt;- mat[1,1:2]
rmDupl2colMatr(mat)
</code></pre>

<hr>
<h2 id='rmEnumeratorName'>Remove or rename enumerator tag/name (or remove entire enumerator) from tailing enumerators</h2><span id='topic+rmEnumeratorName'></span>

<h3>Description</h3>

<p>This function allows indentifying, removing or renaming enumerator tag/name (or remove entire enumerator) from tailing enumerators (eg 'abc_No1' to 'abc_1').
A panel of potential candidates as combination of separator-symbols and separtor text/words will be tested to find if one matches all data.
In case the main input is a matrix, all columns will be tested independently to find the first column where one specific combination of separator-symbols and separtor text/words is found.
Several options exist for the output, the combination of separator-symbols and separtor text/words may be included, too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmEnumeratorName(
  dat,
  nameEnum = c("Number", "No", "#", "Replicate", "Sample"),
  sepEnum = c(" ", "-", "_"),
  newSep = "",
  incl = c("anyCase", "trim2"),
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmEnumeratorName_+3A_dat">dat</code></td>
<td>
<p>(character vecor or matrix) main input</p>
</td></tr>
<tr><td><code id="rmEnumeratorName_+3A_nameenum">nameEnum</code></td>
<td>
<p>(character) potential enumerator-names</p>
</td></tr>
<tr><td><code id="rmEnumeratorName_+3A_sepenum">sepEnum</code></td>
<td>
<p>(character)  potential separators for enumerator-names</p>
</td></tr>
<tr><td><code id="rmEnumeratorName_+3A_newsep">newSep</code></td>
<td>
<p>(character) potential enumerator-names</p>
</td></tr>
<tr><td><code id="rmEnumeratorName_+3A_incl">incl</code></td>
<td>
<p>(character) options to include further variants of the enumerator-names, use <code>"rmEnum"</code> for completely removing enumerator tag/name and digits
for differentr options of trimming names/tags from <code>nameEnum</code> one may use <code>anyCase</code>, <code>trim3</code> (trimming down to max 3 letters),
<code>trim2</code> (trimming to max 2 letters) or  <code>trim1</code> (trimming down to single letter); 
<code>trim0</code> works like <code>trim1</code> but also includes ' ', ie no enumerator tag/name in front of the digit(s)</p>
</td></tr>
<tr><td><code id="rmEnumeratorName_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="rmEnumeratorName_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="rmEnumeratorName_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please note, that checking a variety of different separator text-word and separator-symbols may give an important number of combinations to check.
In particular, when automatic trimming of separator text-words is added (eg <code>incl="trim2"</code>), the complexity of associated searches increases quickly.
Thus, with large data-sets restricting the content of the arguments <code>nameEnum</code>, <code>sepEnum</code> and (in particular) <code>newSep</code> to the most probable terms/options
is suggested to help reducing demands on memory and CPU.
</p>
<p>In case the input <code>dat</code> is a matrix and multiple different numerator-types are found, only the first colum (from the left) will be treated.
If you which to remove/subsitute mutiple types of enumerators the function <code>rmEnumeratorName</code> must be run independently, see last example below.
</p>


<h3>Value</h3>

<p>This function returns a corrected vector (or matrix), or a list if <code>incl="rmEnumL"</code> containing $dat (corrected data),
$pattern (the combination of separator-symbols and separtor text/words found), and if input is matrix $column (which column of the input was identified and treated)
</p>


<h3>See Also</h3>

<p>when the exact pattern is known <code><a href="base.html#topic+grep">grep</a></code> and <code>sub</code> may allow direct manipulations much faster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xx &lt;- c("hg_Re1","hjRe2_Re2","hk-Re3_Re33")
rmEnumeratorName(xx)
rmEnumeratorName(xx, newSep="--")
rmEnumeratorName(xx, incl="anyCase")

xy &lt;- cbind(a=11:13, b=c("11#11","2_No2","333_samp333"), c=xx)
rmEnumeratorName(xy)
rmEnumeratorName(xy,incl=c("anyCase","trim2","rmEnumL"))

xz &lt;- cbind(a=11:13, b=c("23#11","4#2","567#333"), c=xx)
apply(xz, 2, rmEnumeratorName, sepEnum=c("","_"), newSep="_", silent=TRUE)

</code></pre>

<hr>
<h2 id='rnormW'>Normal random number generation with close fit to expected mean and sd</h2><span id='topic+rnormW'></span>

<h3>Description</h3>

<p>This function allows creating a vector of random values similar to <code>rnorm</code>, but resulting value get recorrected to fit to expected mean and sd.
When the number of random values to generate is low, the mean and sd of the resultant values may deviate from the expected mean and sd when using the standard <code>rnorm</code> function.
In such cases the function <code>rnormW</code> helps getting much closer to the expected mean and sd.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnormW(
  n,
  mean = 0,
  sd = 1,
  seed = NULL,
  digits = 8,
  silent = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnormW_+3A_n">n</code></td>
<td>
<p>(integer, length=1)  number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rnormW_+3A_mean">mean</code></td>
<td>
<p>(numeric, length=1) expected mean</p>
</td></tr>
<tr><td><code id="rnormW_+3A_sd">sd</code></td>
<td>
<p>(numeric, length=1) expected sd</p>
</td></tr>
<tr><td><code id="rnormW_+3A_seed">seed</code></td>
<td>
<p>(integer, length=1) seed for generating random numbers</p>
</td></tr>
<tr><td><code id="rnormW_+3A_digits">digits</code></td>
<td>
<p>(integer, length=1 or <code>NULL</code>) number of significant digits for output, set to <code>NULL</code> to get all digits</p>
</td></tr>
<tr><td><code id="rnormW_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="rnormW_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For making result reproducible, a seed for generating random numbers can be set via the argument <code>seed</code>.
However, with <code>n=2</code> the resulting values are 'fixed' since no random component is possible at n &lt;3.
</p>


<h3>Value</h3>

<p>This function returns a numeric vector of random values
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Normal">Normal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- (11:16)[-5]
mean(x1); sd(x1)
## the standard way
ra1 &lt;- rnorm(n=length(x1), mean=mean(x1), sd=sd(x1))
## typically the random values deviate (slightly) from expected mean and sd
mean(ra1) -mean(x1) 
sd(ra1) -sd(x1)
## random numbers with close fit to expected mean and sd :
ra2 &lt;- rnormW(length(x1), mean(x1), sd(x1))
mean(ra2) -mean(x1) 
sd(ra2) -sd(x1)          # much closer to expected value
</code></pre>

<hr>
<h2 id='rowCVs'>rowCVs</h2><span id='topic+rowCVs'></span>

<h3>Description</h3>

<p>This function returns CV for values in each row (using speed optimized standard deviation).
Note : NaN values get replaced by NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowCVs(dat, autoconvert = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowCVs_+3A_dat">dat</code></td>
<td>
<p>(numeric) matix</p>
</td></tr>
<tr><td><code id="rowCVs_+3A_autoconvert">autoconvert</code></td>
<td>
<p>(NULL or character) allows converting simple vectors in matrix of 1 row (autoconvert=&quot;row&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a (numeric) vector with CVs for each row of 'dat'
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+colSums">colSums</a></code>, <code><a href="#topic+rowGrpCV">rowGrpCV</a></code>, <code><a href="#topic+rowSds">rowSds</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016); dat1 &lt;- matrix(c(runif(200) +rep(1:10,20)),ncol=10)
head(rowCVs(dat1))
</code></pre>

<hr>
<h2 id='rowGrpCV'>Row group CV</h2><span id='topic+rowGrpCV'></span>

<h3>Description</h3>

<p>This function calculates CVs for matrix with multiple groups of data, ie one CV for each group of data. 
Groups are specified as columns of 'x' in 'grp' (so length of grp should match number of columns of 'x', NAs are allowed)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowGrpCV(x, grp, means = NULL, listOutp = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowGrpCV_+3A_x">x</code></td>
<td>
<p>numeric matrix where relplicates are organized into separate columns</p>
</td></tr>
<tr><td><code id="rowGrpCV_+3A_grp">grp</code></td>
<td>
<p>(factor) defining which columns should be grouped (considered as replicates)</p>
</td></tr>
<tr><td><code id="rowGrpCV_+3A_means">means</code></td>
<td>
<p>(numeric) alternative values instead of means by .rowGrpMeans()</p>
</td></tr>
<tr><td><code id="rowGrpCV_+3A_listoutp">listOutp</code></td>
<td>
<p>(logical) if TRUE, provide output as list with $CV, $mean and $n</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix of CV values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowCVs">rowCVs</a></code>, <code><a href="#topic+arrayCV">arrayCV</a></code>,  <code><a href="#topic+replPlateCV">replPlateCV</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016); dat1 &lt;- matrix(c(runif(200)+rep(1:10,20)),ncol=10)
head(rowGrpCV(dat1, gr=gl(4,3,labels=LETTERS[1:4])[2:11]))
</code></pre>

<hr>
<h2 id='rowGrpMeans'>rowMeans with destinction of groups (of columns, eg groups of replicates)</h2><span id='topic+rowGrpMeans'></span>

<h3>Description</h3>

<p><code>rowGrpMeans</code> calculates column-means for matrix with multiple groups of data, ie similar to rowMeans but one mean for each group of data.
Groups are specified as columns of 'x' in 'grp' (so length of grp should match number of columns of 'x', NAs are allowed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowGrpMeans(x, grp, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowGrpMeans_+3A_x">x</code></td>
<td>
<p>matrix or data.frame</p>
</td></tr>
<tr><td><code id="rowGrpMeans_+3A_grp">grp</code></td>
<td>
<p>(character or factor) defining which columns should be grouped (considered as replicates)</p>
</td></tr>
<tr><td><code id="rowGrpMeans_+3A_na.rm">na.rm</code></td>
<td>
<p>(logical) a logical value indicating whether <code>NA</code>-values should be stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with mean values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowSds">rowSds</a></code>, <code><a href="base.html#topic+colSums">colSums</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016); dat1 &lt;- matrix(c(runif(200) +rep(1:10,20)), ncol=10)
head(rowGrpMeans(dat1, gr=gl(4, 3, labels=LETTERS[1:4])[2:11]))
</code></pre>

<hr>
<h2 id='rowGrpNA'>Count number of NAs per row and group of columns</h2><span id='topic+rowGrpNA'></span>

<h3>Description</h3>

<p>This functions allows easy counting the number of NAs per row in data organized in multiple sub-groups as columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowGrpNA(mat, grp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowGrpNA_+3A_mat">mat</code></td>
<td>
<p>(matrix of data.frame) data to count the number of <code>NA</code>s</p>
</td></tr>
<tr><td><code id="rowGrpNA_+3A_grp">grp</code></td>
<td>
<p>(character or factor) defining which columns should be grouped (considered as replicates)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with number of <code>NA</code>s per group
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowGrpMeans">rowGrpMeans</a></code>, <code><a href="#topic+rowSds">rowSds</a></code>, <code><a href="base.html#topic+colSums">colSums</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat2 &lt;- c(22.2, 22.5, 22.2, 22.2, 21.5, 22.0, 22.1, 21.7, 21.5, 22, 22.2, 22.7,
   NA, NA, NA, NA, NA, NA, NA, 21.2,   NA, NA, NA, NA,
   NA, 22.6, 23.2, 23.2,  22.4, 22.8, 22.8, NA,  23.3, 23.2, NA, 23.7,
   NA, 23.0, 23.1, 23.0,  23.2, 23.2, NA, 23.3,  NA, NA, 23.3, 23.8)
mat2 &lt;- matrix(mat2, ncol=12, byrow=TRUE)
gr4 &lt;- gl(3, 4, labels=LETTERS[1:3])
# overal number of NAs per row
rowSums(is.na(mat2)) 
# number of NAs per row and group
rowGrpNA(mat2, gr4)
</code></pre>

<hr>
<h2 id='rowGrpSds'>Per line and per group sd-values</h2><span id='topic+rowGrpSds'></span>

<h3>Description</h3>

<p><code>rowGrpSds</code> calculate Sd (standard-deviation) for matrix with multiple groups of data, ie one sd for each group of data. 
Groups are specified as columns of 'x' in 'grp' (so length of grp should match number of columns of 'x', NAs are allowed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowGrpSds(x, grp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowGrpSds_+3A_x">x</code></td>
<td>
<p>matrix where relplicates are organized into seprate columns</p>
</td></tr>
<tr><td><code id="rowGrpSds_+3A_grp">grp</code></td>
<td>
<p>(character or factor) defining which columns should be grouped (considered as replicates)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix of sd values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowGrpMeans">rowGrpMeans</a></code>, <code><a href="#topic+rowCVs">rowCVs</a></code>, <code><a href="#topic+rowSEMs">rowSEMs</a></code>,<code><a href="stats.html#topic+sd">sd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016); dat1 &lt;- matrix(c(runif(200) +rep(1:10,20)), ncol=10)
head(rowGrpSds(dat1, gr=gl(4,3,labels=LETTERS[1:4])[2:11]))
</code></pre>

<hr>
<h2 id='rowGrpSums'>rowSums with destinction of groups (of columns, eg groups of replicates)</h2><span id='topic+rowGrpSums'></span>

<h3>Description</h3>

<p>This function calculates row-sums for matrix with multiple groups of data, ie similar to <code>rowSums</code> but one summed value for each line and group of data.
Groups are specified as columns of 'x' in 'grp' (so length of grp should match number of columns of 'x', NAs are allowed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowGrpSums(x, grp, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowGrpSums_+3A_x">x</code></td>
<td>
<p>matrix or data.frame</p>
</td></tr>
<tr><td><code id="rowGrpSums_+3A_grp">grp</code></td>
<td>
<p>(character or factor) defining which columns should be grouped (considered as replicates)</p>
</td></tr>
<tr><td><code id="rowGrpSums_+3A_na.rm">na.rm</code></td>
<td>
<p>(logical) a logical value indicating whether <code>NA</code>-values should be stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function a matrix with row/group sum values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowGrpMeans">rowGrpMeans</a></code>, <code><a href="#topic+rowGrpSds">rowGrpSds</a></code>, <code><a href="#topic+rowSds">rowSds</a></code>, <code><a href="base.html#topic+colSums">colSums</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016); dat1 &lt;- matrix(c(runif(200) +rep(1:10,20)), ncol=10)
head(rowGrpMeans(dat1, gr=gl(4, 3, labels=LETTERS[1:4])[2:11]))
</code></pre>

<hr>
<h2 id='rowMedSds'>sd of median for each row by bootstrap</h2><span id='topic+rowMedSds'></span>

<h3>Description</h3>

<p><code>rowMedSds</code> determines the stand error (sd) of the median for each row by bootstraping each row of 'dat'.
Note: requires package <a href="https://CRAN.R-project.org/package=boot">boot</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowMedSds(dat, nBoot = 99)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowMedSds_+3A_dat">dat</code></td>
<td>
<p>(numeric) matix, main input</p>
</td></tr>
<tr><td><code id="rowMedSds_+3A_nboot">nBoot</code></td>
<td>
<p>(integer) number if iterations for bootstrap</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This functions returns a (numeric) vector with estimated standard errors
</p>


<h3>See Also</h3>

<p><code><a href="boot.html#topic+boot">boot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016); dat1 &lt;- matrix(c(runif(200)+rep(1:10,20)), ncol=10)
rowMedSds(dat1) ; plot(rowSds(dat1), rowMedSds(dat1))
</code></pre>

<hr>
<h2 id='rowNormalize'>Row Normalize</h2><span id='topic+rowNormalize'></span>

<h3>Description</h3>

<p>This function was designed for normalizing data that is supposed to be particularly similar, like a collection of technical replicates.
Thus, initially for each row an independent normalization factor is calculated and the median or mean across all factors will be finally applied to the data.
This function has a special mode of operation with higher content of <code>NA</code> values (which may pose problems with other normalization approaches). 
If the <code>NA</code>-content is higher than the threshold set in <code>sparseLim</code>,
a special procedure for sparse data will be applied (iteratively trating subsets of <code>nCombin</code> columns that will be combined in a later step).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowNormalize(
  dat,
  method = "median",
  refLines = NULL,
  refGrp = NULL,
  proportMode = TRUE,
  minQuant = NULL,
  sparseLim = 0.4,
  nCombin = 3,
  omitNonAlignable = FALSE,
  maxFact = 10,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowNormalize_+3A_dat">dat</code></td>
<td>
<p>matrix or data.frame of data to get normalized</p>
</td></tr>
<tr><td><code id="rowNormalize_+3A_method">method</code></td>
<td>
<p>(character) may be &quot;mean&quot;,&quot;median&quot; (plus &quot;NULL&quot;,&quot;none&quot;); When NULL or 'none' is chosen the input will be returned as is</p>
</td></tr>
<tr><td><code id="rowNormalize_+3A_reflines">refLines</code></td>
<td>
<p>(NULL or numeric) allows to consider only specific lines of 'dat' when determining normalization factors (all data will be normalized)</p>
</td></tr>
<tr><td><code id="rowNormalize_+3A_refgrp">refGrp</code></td>
<td>
<p>(integer) Only the columns indicated will be used as reference, default all columns (integer or colnames)</p>
</td></tr>
<tr><td><code id="rowNormalize_+3A_proportmode">proportMode</code></td>
<td>
<p>(logical) decide if normalization should be done by multiplicative or additive factor</p>
</td></tr>
<tr><td><code id="rowNormalize_+3A_minquant">minQuant</code></td>
<td>
<p>(numeric) optional filter to set all values below given value as <code>NA</code></p>
</td></tr>
<tr><td><code id="rowNormalize_+3A_sparselim">sparseLim</code></td>
<td>
<p>(integer) decide at which min content of  <code>NA</code> values the function should go in sparse-mode</p>
</td></tr>
<tr><td><code id="rowNormalize_+3A_ncombin">nCombin</code></td>
<td>
<p>(NULL or integer) used only in sparse-mode (ie if content of <code>NA</code>s higher than content of <code>sparseLim</code>): Number of groups of smller matrixes with this number of columns to be inspected initailly;
low values (small groups have higher chances of more common elements)</p>
</td></tr>
<tr><td><code id="rowNormalize_+3A_omitnonalignable">omitNonAlignable</code></td>
<td>
<p>(logical) allow omitting all columns which can't get aligned due to sparseness</p>
</td></tr>
<tr><td><code id="rowNormalize_+3A_maxfact">maxFact</code></td>
<td>
<p>(numeric, length=2) max normalization factor</p>
</td></tr>
<tr><td><code id="rowNormalize_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="rowNormalize_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="rowNormalize_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) This function allows easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arguments were kept similar with function <code>normalizeThis</code> as much as possible.
In most cases data get normalized by proportional factors. In case of log2-data (very common in omics-data) normalizing by an additive factor is equivalent to a proportional factor.
</p>
<p>This function has a special mode of operation for sparse data (ie containing a high content of <code>NA</code> values).
0-values by themselves will be primarily considered as true measurment outcomes and not as missing.
However, by using the argument <code>minQuant</code> all values below a given threshold will be set as <code>NA</code> and this may possibly trigger the sparse mode of normalizing.
</p>
<p>Note : Using a small value of <code>nCombin</code> will give the highest chances of finding sufficient complete combination of columns with sparse data.
However, this will also increase (very much) the computational efforts and time required to produce an output.
</p>
<p>When using default proportional mode a potential division by 0 could occur, when the initial normalization factor turns out as 0.
In this case a small value (default the maximum value of <code>dat</code> / 10 will be added to all data before normalizing.
If this also creates 0-vales in the data this factor will be multiplied by 0.03.
</p>


<h3>Value</h3>

<p>This function returns a matrix of normalized data
</p>


<h3>See Also</h3>

<p><code><a href="#topic+exponNormalize">exponNormalize</a></code>, <code><a href="#topic+adjBy2ptReg">adjBy2ptReg</a></code>, <code><a href="vsn.html#topic+justvsn">justvsn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## sparse matrix  normalization
set.seed(2); AA &lt;- matrix(rbinom(110,10,0.05), nrow=10)
AA[,4:5] &lt;- AA[,4:5] *rep(4:3, each=nrow(AA))
AA[2,c(2,6,7)] &lt;- 1; AA[3,8] &lt;- 1;

(AA1 &lt;- rowNormalize(AA))
(AA2 &lt;- rowNormalize(AA, minQuant=1))   # set all 0 as NAs
(AA3 &lt;- rowNormalize(AA, refLines=1:6, omitNonAlignable=FALSE, minQuant=1))


</code></pre>

<hr>
<h2 id='rowSds'>sd for each row (fast execution)</h2><span id='topic+rowSds'></span>

<h3>Description</h3>

<p>This function is speed optimized sd per line (takes matrix or data.frame and treats each line as set of data for sd, )equiv to using <code>apply</code>.
NAs are ignored from data unless entire line NA). Speed improvements may be seen at more than 100 lines.
Note: NaN instances will be transformed to NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowSds(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowSds_+3A_dat">dat</code></td>
<td>
<p>matrix (or data.frame) with numeric values (may contain NAs)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector of sd values
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+sd">sd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016); dat1 &lt;- matrix(c(runif(200)+rep(1:10,20)),ncol=10)
rowSds(dat1)
</code></pre>

<hr>
<h2 id='rowSEMs'>SEM for each row</h2><span id='topic+rowSEMs'></span>

<h3>Description</h3>

<p>This function speed optimized SEM (standard error of the mean) for each row.
The function takes a matrix or data.frame and treats each row as set of data for SEM; NAs are ignored from data.
Note: NaN instances will be transformed to NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowSEMs(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowSEMs_+3A_dat">dat</code></td>
<td>
<p>matrix or data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a numeric vector with SEM values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowSds">rowSds</a></code>,  <code><a href="#topic+colSds">colSds</a></code>, <code><a href="base.html#topic+colSums">colSums</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016); dat1 &lt;- matrix(c(runif(200)+rep(1:10,20)),ncol=10)
head(rowSEMs(dat1))
</code></pre>

<hr>
<h2 id='sampNoDeMArrayLM'>Locate Sample Index From Index or Name Of Pair-Wise Comparisons in list or MArrayLM-Object</h2><span id='topic+sampNoDeMArrayLM'></span>

<h3>Description</h3>

<p>When multiple series of data are tested simultaneaously (eg using <code>moderTestXgrp</code>), multiple pairwise comparisons get performed. 
This function helps locating the samples, ie mean-columns, corresponding to a specific pairwise comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampNoDeMArrayLM(
  MArrayObj,
  useComp,
  groupSep = "-",
  lstMeans = "means",
  lstP = c("BH", "FDR", "p.value"),
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampNoDeMArrayLM_+3A_marrayobj">MArrayObj</code></td>
<td>
<p>(list or MArray-object) main input</p>
</td></tr>
<tr><td><code id="sampNoDeMArrayLM_+3A_usecomp">useComp</code></td>
<td>
<p>(character or integer) index or name of pairwise-comparison to be addressed</p>
</td></tr>
<tr><td><code id="sampNoDeMArrayLM_+3A_groupsep">groupSep</code></td>
<td>
<p>(character, length=1) separator for paitr of names</p>
</td></tr>
<tr><td><code id="sampNoDeMArrayLM_+3A_lstmeans">lstMeans</code></td>
<td>
<p>(character, length=1) the list element containing the individual sample names, typically the matrix containing the replicate-mean values for each type of sample, the column-names get used</p>
</td></tr>
<tr><td><code id="sampNoDeMArrayLM_+3A_lstp">lstP</code></td>
<td>
<p>(character, length=1) the list element containing all pairwise comparisons performed, the column-names get used</p>
</td></tr>
<tr><td><code id="sampNoDeMArrayLM_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="sampNoDeMArrayLM_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="sampNoDeMArrayLM_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As main input one gives a list or MArrayLM-object containing testing results contain the pairwise comparisons
and a specific comparison indicated by <code>useComp</code> to get located in the element of mean-columns (<code>lstMeans</code>) among all pairwise comparisons.
</p>


<h3>Value</h3>

<p>This fuction returns a numeric vector (length=2) with index indicating the columns of (replicate) mean-values corresponding to the comparison specified in <code>useComp</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+moderTestXgrp">moderTestXgrp</a></code>, this function gets used eg in <code><a href="wrGraph.html#topic+MAplotW">MAplotW</a></code> or <code><a href="wrGraph.html#topic+VolcanoPlotW">VolcanoPlotW</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grp &lt;- factor(rep(LETTERS[c(3,1,4)],c(2,3,3)))
set.seed(2017); t8 &lt;- matrix(round(rnorm(208*8,10,0.4),2), ncol=8,
  dimnames=list(paste(letters[],rep(1:8,each=26),sep=""), paste(grp,c(1:2,1:3,1:3),sep="")))
test8 &lt;- moderTestXgrp(t8, grp) 
head(test8$p.value)         # all pairwise comparisons available
if(requireNamespace("limma", quietly=TRUE)) {  # need limma installed...
  sampNoDeMArrayLM(test8,1)
  head(test8$means[,sampNoDeMArrayLM(test8,1)])
  head(test8$means[,sampNoDeMArrayLM(test8,"C-D")]) }

</code></pre>

<hr>
<h2 id='scaleXY'>Scale data to given minimum and maxiumum</h2><span id='topic+scaleXY'></span>

<h3>Description</h3>

<p>This is a convenient way to scale data to given minimum and maxiumum without full standarization, ie without deviding by the sd.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleXY(x, min = 0, max = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaleXY_+3A_x">x</code></td>
<td>
<p>(numeric) vector to rescacle</p>
</td></tr>
<tr><td><code id="scaleXY_+3A_min">min</code></td>
<td>
<p>(numeric) minimum value in output</p>
</td></tr>
<tr><td><code id="scaleXY_+3A_max">max</code></td>
<td>
<p>(numeric) maximum value in output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of rescaled data (in dimensions as input)
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+scale">scale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- matrix(2*round(runif(100),2), ncol=4)
range(dat)
dat1 &lt;- scaleXY(dat, 1,100)
range(dat1)
summary(dat1)

## scale for each column individually
dat2 &lt;- apply(dat, 2, scaleXY, 1, 100)
range(dat2)
summary(dat2)
</code></pre>

<hr>
<h2 id='searchDataPairs'>Search duplicated data over multiple columns, ie pairs of data</h2><span id='topic+searchDataPairs'></span>

<h3>Description</h3>

<p><code>searchDataPairs</code> searches matrix for columns of similar data, ie 'duplicate' values in separate columns or very similar columns if <code>realDupsOnly=FALSE</code>.
Initial distance measures will be normalized either to diagonale (<code>normRange=TRUE)</code> of 'window' or to the real max distance observed (equal or less than diagonale).
Return data.frame with names for sample-pair, percent of identical values (100 for complete identical pair) and relative (Euclidean) distance (ie max dist observed =1.0).
Note, that low distance values do not necessarily imply correlating data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>searchDataPairs(
  dat,
  disThr = 0.01,
  byColumn = TRUE,
  normRange = TRUE,
  altNa = NULL,
  realDupsOnly = TRUE,
  silent = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="searchDataPairs_+3A_dat">dat</code></td>
<td>
<p>matrix or data.frame (main input)</p>
</td></tr>
<tr><td><code id="searchDataPairs_+3A_disthr">disThr</code></td>
<td>
<p>(numeric) threshold to decide when to report similar data (applied on normalized distances, low val fewer reported), applied on normalized distances (norm to diagonale of all data for best relative 'unbiased' view)</p>
</td></tr>
<tr><td><code id="searchDataPairs_+3A_bycolumn">byColumn</code></td>
<td>
<p>(logical) rotates main input by 90 degrees (using <code><a href="base.html#topic+t">t</a></code>), thus allows to read by rows instead of by columns</p>
</td></tr>
<tr><td><code id="searchDataPairs_+3A_normrange">normRange</code></td>
<td>
<p>(logical) normize each columns separately if <code>TRUE</code></p>
</td></tr>
<tr><td><code id="searchDataPairs_+3A_altna">altNa</code></td>
<td>
<p>(character, default <code>NULL</code>) vector with alternative names (for display)</p>
</td></tr>
<tr><td><code id="searchDataPairs_+3A_realdupsonly">realDupsOnly</code></td>
<td>
<p>(logical) if <code>TRUE</code> will consider equal values only, otherwise will also consider very close values (based on argument <code>disThr</code>)</p>
</td></tr>
<tr><td><code id="searchDataPairs_+3A_silent">silent</code></td>
<td>
<p>(logical) suppres messages</p>
</td></tr>
<tr><td><code id="searchDataPairs_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a data.frame with names of sample-pairs, percent of identical values (100 for complete identical pair) and rel (Euclidean) distance (ie max dist observed =1.0)
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+duplicated">duplicated</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- round(matrix(c(11:40,runif(20)+12,11:19,17,runif(20)+18,11:20), nrow=10), 1)
colnames(mat) &lt;- 1:9
searchDataPairs(mat,disThr=0.05)
</code></pre>

<hr>
<h2 id='searchLinesAtGivenSlope'>Search points forming lines at given slope</h2><span id='topic+searchLinesAtGivenSlope'></span>

<h3>Description</h3>

<p><code>searchLinesAtGivenSlope</code> searchs among set of points (2-dim) those forming line(s) with user-defined slope ('coeff'),
ie search optimal (slope-) offset parameter(s) for (regression) line(s) with given slope ('coef').
Note: larger data-sets : segment residuals to 'coeff' &amp; select most homogenous
</p>


<h3>Usage</h3>

<pre><code class='language-R'>searchLinesAtGivenSlope(
  dat,
  coeff = 1.5,
  filtExtr = c(0, 1),
  minMaxDistThr = NULL,
  lmCompare = TRUE,
  indexPoints = TRUE,
  displHist = FALSE,
  displScat = FALSE,
  bestCluByDistRat = TRUE,
  neighbDiLim = NULL,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="searchLinesAtGivenSlope_+3A_dat">dat</code></td>
<td>
<p>matrix or data.frame, main input</p>
</td></tr>
<tr><td><code id="searchLinesAtGivenSlope_+3A_coeff">coeff</code></td>
<td>
<p>(numeric) slope to consider</p>
</td></tr>
<tr><td><code id="searchLinesAtGivenSlope_+3A_filtextr">filtExtr</code></td>
<td>
<p>(integer) lower &amp; upper quantile values, remove points with extreme deviation to offset=0, (if single value: everything up to or after will be used)</p>
</td></tr>
<tr><td><code id="searchLinesAtGivenSlope_+3A_minmaxdistthr">minMaxDistThr</code></td>
<td>
<p>(logical) optional minumum and maximum distance threshold</p>
</td></tr>
<tr><td><code id="searchLinesAtGivenSlope_+3A_lmcompare">lmCompare</code></td>
<td>
<p>(logical) add'l fitting of linear regression to best results, return offset AND slope based on lm fit</p>
</td></tr>
<tr><td><code id="searchLinesAtGivenSlope_+3A_indexpoints">indexPoints</code></td>
<td>
<p>(logical) return results as list with element 'index' specifying retained points</p>
</td></tr>
<tr><td><code id="searchLinesAtGivenSlope_+3A_displhist">displHist</code></td>
<td>
<p>(logical) display histogram of residues</p>
</td></tr>
<tr><td><code id="searchLinesAtGivenSlope_+3A_displscat">displScat</code></td>
<td>
<p>(logical) display (simple) scatter plot</p>
</td></tr>
<tr><td><code id="searchLinesAtGivenSlope_+3A_bestclubydistrat">bestCluByDistRat</code></td>
<td>
<p>(logical) initial selection of decent clusters based on ratio overallDist/averNeighbDist (or by CV &amp; cor)</p>
</td></tr>
<tr><td><code id="searchLinesAtGivenSlope_+3A_neighbdilim">neighbDiLim</code></td>
<td>
<p>(numeric) additional threshold for (trimmed mean) neighbour-distance</p>
</td></tr>
<tr><td><code id="searchLinesAtGivenSlope_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="searchLinesAtGivenSlope_+3A_debug">debug</code></td>
<td>
<p>(logical) for bug-tracking: more/enhanced messages</p>
</td></tr>
<tr><td><code id="searchLinesAtGivenSlope_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This functions returns a matrix of line-characteristics  (or if indexPoints is <code>TRUE</code> then list (line-characteristics &amp; index &amp; lm-results)
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lm">lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016); ra1 &lt;- runif(300)
 dat1 &lt;- cbind(x=round(c(1:100+ra1[1:100]/5,4*ra1[1:50]),1),
  y=round(c(1:100+ra1[101:200]/5, 4*ra1[101:150]), 1))
(li1 &lt;- searchLinesAtGivenSlope(dat1, coeff=1))
</code></pre>

<hr>
<h2 id='simpleFragFig'>Simple figure showing line from start- to end-sites of edges (or fragments) defined by their start- and end-sites
<code>simpleFragFig</code> draws figure showing start- and end-sites of edges (or fragments)</h2><span id='topic+simpleFragFig'></span>

<h3>Description</h3>

<p>Simple figure showing line from start- to end-sites of edges (or fragments) defined by their start- and end-sites
</p>
<p><code>simpleFragFig</code> draws figure showing start- and end-sites of edges (or fragments)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpleFragFig(
  frag,
  fullSize = NULL,
  sortByHead = TRUE,
  useTit = NULL,
  useCol = NULL,
  displNa = TRUE,
  useCex = 0.7
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simpleFragFig_+3A_frag">frag</code></td>
<td>
<p>(matrix) 2 columns defining begin- and end-sites (as interger values)</p>
</td></tr>
<tr><td><code id="simpleFragFig_+3A_fullsize">fullSize</code></td>
<td>
<p>(integer) optional max size used for figure (x-axis)</p>
</td></tr>
<tr><td><code id="simpleFragFig_+3A_sortbyhead">sortByHead</code></td>
<td>
<p>(logical) sort by begin-sites (if <code>TRUE</code>) or sort by end-sites</p>
</td></tr>
<tr><td><code id="simpleFragFig_+3A_usetit">useTit</code></td>
<td>
<p>(character) custom title</p>
</td></tr>
<tr><td><code id="simpleFragFig_+3A_usecol">useCol</code></td>
<td>
<p>(character) specify colors, if numeric vector will be onsidered as score values</p>
</td></tr>
<tr><td><code id="simpleFragFig_+3A_displna">displNa</code></td>
<td>
<p>(character) display names of edges (figure may get crowded)</p>
</td></tr>
<tr><td><code id="simpleFragFig_+3A_usecex">useCex</code></td>
<td>
<p>(numeric) expansion factor, see also <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with mean values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildTree">buildTree</a></code>, <code><a href="#topic+countSameStartEnd">countSameStartEnd</a></code>, <code><a href="#topic+contribToContigPerFrag">contribToContigPerFrag</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>frag2 &lt;- cbind(beg=c(2,3,7,13,13,15,7,9,7, 3,7,5,7,3),end=c(6,12,8,18,20,20,19,12,12, 4,12,7,12,4)) 
rownames(frag2) &lt;- c("A","E","B","C","D","F","H","G","I", "J","K","L","M","N")
simpleFragFig(frag2,fullSize=21,sortByHead=TRUE) 
buildTree(frag2)
</code></pre>

<hr>
<h2 id='singleLineAnova'>2-factorial Anova on single line of data</h2><span id='topic+singleLineAnova'></span>

<h3>Description</h3>

<p>This function runs 2-factorial Anova on a single line of data (using <code><a href="stats.html#topic+aov">aov</a></code> from package <code>stats</code>) 
using a model with two factors (without factor-interaction) and extracts the correpsonding p-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>singleLineAnova(
  dat,
  fac1,
  fac2,
  inclInteraction = TRUE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="singleLineAnova_+3A_dat">dat</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="singleLineAnova_+3A_fac1">fac1</code></td>
<td>
<p>(character or factor) vector describing grouping elements of dat for first factor, must be of same langth as fac2</p>
</td></tr>
<tr><td><code id="singleLineAnova_+3A_fac2">fac2</code></td>
<td>
<p>(character or factor) vector describing grouping elements of dat for second factor, must be of same langth as fac1</p>
</td></tr>
<tr><td><code id="singleLineAnova_+3A_inclinteraction">inclInteraction</code></td>
<td>
<p>(logical) decide if factor-interactions (eg synergy) should be included to model</p>
</td></tr>
<tr><td><code id="singleLineAnova_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="singleLineAnova_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="singleLineAnova_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the (uncorrected) p for factor 'Pr(&gt;F)' (see <code><a href="stats.html#topic+aov">aov</a></code>)
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+aov">aov</a></code>, <code><a href="stats.html#topic+anova">anova</a></code>; for repeated tests using the  package <a href="https://bioconductor.org/packages/release/bioc/html/limma.html">limma</a> including <code><a href="limma.html#topic+lmFit">lmFit</a></code> and <code>eBayes</code> see <code><a href="#topic+test2factLimma">test2factLimma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2012); dat &lt;- round(runif(8),1)
singleLineAnova(dat, gl(2,4),rep(1:2,4))
</code></pre>

<hr>
<h2 id='sortBy2CategorAnd1IntCol'>Sort matrix by two categorical and one integer columns</h2><span id='topic+sortBy2CategorAnd1IntCol'></span>

<h3>Description</h3>

<p>This function sorts matrix 'mat' subsequently by categorical and numerical columns of 'mat',
ie lines with identical values for categor are sorted by numeric value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortBy2CategorAnd1IntCol(
  mat,
  categCol,
  numCol,
  findNeighb = TRUE,
  decreasing = FALSE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sortBy2CategorAnd1IntCol_+3A_mat">mat</code></td>
<td>
<p>matrix (or data.frame) from which by 2 columns will be selected for sorting</p>
</td></tr>
<tr><td><code id="sortBy2CategorAnd1IntCol_+3A_categcol">categCol</code></td>
<td>
<p>(integer or character) which columns of 'mat' to be used as categorical columns</p>
</td></tr>
<tr><td><code id="sortBy2CategorAnd1IntCol_+3A_numcol">numCol</code></td>
<td>
<p>(integer or character) which column of 'mat' to be used as integer columns</p>
</td></tr>
<tr><td><code id="sortBy2CategorAnd1IntCol_+3A_findneighb">findNeighb</code></td>
<td>
<p>(logical) if 'findNeighb' neighbour cols according to 'numCol' will be identified as groups &amp; marked in new col 'neiGr', orphans marked as NA</p>
</td></tr>
<tr><td><code id="sortBy2CategorAnd1IntCol_+3A_decreasing">decreasing</code></td>
<td>
<p>(logical) order of sort</p>
</td></tr>
<tr><td><code id="sortBy2CategorAnd1IntCol_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="sortBy2CategorAnd1IntCol_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="sortBy2CategorAnd1IntCol_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a sorted matrix (same dimensions as 'mat')
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- cbind(aa=letters[c(3,rep(7:8,3:4),4,4:6,7)],bb=LETTERS[rep(1:5,c(1,3,4,4,1))],
  nu=c(23:21,23,21,22,18:12))
mat[c(3:5,1:2,6:9,13:10),]
sortBy2CategorAnd1IntCol(mat,cate=c("bb","aa"),num="nu",findN=FALSE,decr=TRUE)
sortBy2CategorAnd1IntCol(mat,cate=c("bb","aa"),num="nu",findN=TRUE,decr=FALSE)
</code></pre>

<hr>
<h2 id='sortByNRepeated'>Make a list of common occurances sorted by number of repeats</h2><span id='topic+sortByNRepeated'></span>

<h3>Description</h3>

<p>The aim of this function is to count the number of occurances of words when comaring separate vectors (<code>x</code>, <code>y</code> and <code>z</code>) or from a list (given as <code>x</code>)
and to give an output sorted by their frequency.
The output lists the various values/words by their frequency, the names of the resulting list-elements indicate number of times the values/words were found repeated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortByNRepeated(
  x,
  y = NULL,
  z = NULL,
  filterIntraRep = TRUE,
  silent = TRUE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sortByNRepeated_+3A_x">x</code></td>
<td>
<p>(list, character or integer) main input, if list, arguments <code>y</code> and <code>z</code> will not be used</p>
</td></tr>
<tr><td><code id="sortByNRepeated_+3A_y">y</code></td>
<td>
<p>(character or integer) supplemental vector to comare with <code>x</code></p>
</td></tr>
<tr><td><code id="sortByNRepeated_+3A_z">z</code></td>
<td>
<p>(character or integer) supplemental vector to comare with <code>x</code></p>
</td></tr>
<tr><td><code id="sortByNRepeated_+3A_filterintrarep">filterIntraRep</code></td>
<td>
<p>(logical) allow making vectors <code>x</code>, <code>y</code> and <code>z</code> unique before comparing (defaults to <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="sortByNRepeated_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="sortByNRepeated_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="sortByNRepeated_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to compare the frquency of values/words between separate vectors or vectors within a list, it is necessary that these have been made unique before calling this function or using <code>filterIntraRep=TRUE</code>. 
</p>
<p>In case the input is given as list (in <code>x</code>), there is no restriction to the number of vectors to be compared. 
With very long lists, however, the computational effort incerases (like it does when using <code>table</code>)
</p>


<h3>Value</h3>

<p>This function returns a list sorted by number of occurances. The names of the list indicate the number of repeats.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+table">table</a></code>,  <code><a href="#topic+replicateStructure">replicateStructure</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sortByNRepeated(x=LETTERS[1:11], y=LETTERS[3:13], z=LETTERS[6:12])
sortByNRepeated(x=LETTERS[1:11], y=LETTERS[c(3:13,5:4)], z=LETTERS[6:12])

</code></pre>

<hr>
<h2 id='stableMode'>Estimate mode (most frequent value)</h2><span id='topic+stableMode'></span>

<h3>Description</h3>

<p>Estimate mode, ie most frequent value. In case of continuous numeric data, the most frequent values may not be the most frequently repeated exact term.
This function offers various approches to estimate the mode of a numeric vector. 
Besides, it can also be used to identify the most frequentexact term (in this case also from character vectors).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stableMode(
  x,
  method = "density",
  finiteOnly = TRUE,
  bandw = NULL,
  rangeSign = 1:6,
  silent = FALSE,
  callFrom = NULL,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stableMode_+3A_x">x</code></td>
<td>
<p>(numeric, or character if 'method='mode') data to find/estimate most frequent value</p>
</td></tr>
<tr><td><code id="stableMode_+3A_method">method</code></td>
<td>
<p>(character) There are 3 options : BBmisc, binning and density (default). If &quot;binning&quot; the function will search context dependent, ie like most frequent class of histogram.
Using &quot;binning&quot; mode the search will be refined if either 80 percent of values in single class or &gt;50 percent in single class.</p>
</td></tr>
<tr><td><code id="stableMode_+3A_finiteonly">finiteOnly</code></td>
<td>
<p>(logical) suppress non-finite values; allows avoiding <code>NULL</code> as result in presence of some <code>Inf</code> values; <code>NA</code> will be ignored in any case</p>
</td></tr>
<tr><td><code id="stableMode_+3A_bandw">bandw</code></td>
<td>
<p>(integer) only used when <code>method="binning"</code> or  <code>method="density"</code> : defines the number of points to look for density or number of classes used; 
very &quot;critical&quot; parameter, may change results in strong way. Note: with <code>method="binning"</code>: At higher values for &quot;bandw&quot; you will finally loose advantage of histLike-type search of mode !</p>
</td></tr>
<tr><td><code id="stableMode_+3A_rangesign">rangeSign</code></td>
<td>
<p>(integer) only used when <code>method="binning"</code>: range of numbers used as number of significant values</p>
</td></tr>
<tr><td><code id="stableMode_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="stableMode_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of messages produced</p>
</td></tr>
<tr><td><code id="stableMode_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>method</code> allows to choose among (so far) 4 different methods available.
If &quot;density&quot; is chosen, the most dense region of sqrt(n) values will be chosen; 
if &quot;binning&quot;, the data will be binned (like in histograms) via rounding to a user-defined number of significant values (&quot;rangeSign&quot;).
If <code>method</code> is set to &quot;BBmisc&quot;, the function <code>computeMode()</code> from package <a href="https://CRAN.R-project.org/package=BBmisc">BBmisc</a> will be used.
If &quot;mode&quot; is chosen, the first most frequently occuring (exact) value will be returned, if &quot;allModes&quot;, all ties will be returned. This last mode also works with character input.
</p>


<h3>Value</h3>

<p>This function returns a numeric vector with value of mode, the name of the value indicates it's position
</p>


<h3>See Also</h3>

<p><code>computeMode()</code> in package <a href="https://CRAN.R-project.org/package=BBmisc">BBmisc</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2012); dat &lt;- round(c(rnorm(50), runif(100)),3)
stableMode(dat)
</code></pre>

<hr>
<h2 id='standardW'>Standardize (scale) data</h2><span id='topic+standardW'></span>

<h3>Description</h3>

<p>This functions work similar to <code><a href="base.html#topic+scale">scale</a></code>, however, it evaluates the entire input and not column-wise (and independeltly as <code>scale</code> does). 
With Standarizing we speak of transforming the data to end up with mean=O and sd=1.
Furthermore, in case of 3-dim arrays, this function returns also an object with the same dimensions as the input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardW(
  mat,
  byColumn = FALSE,
  na.rm = TRUE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardW_+3A_mat">mat</code></td>
<td>
<p>(matrix, data.frame or array) data that need to get standardized.</p>
</td></tr>
<tr><td><code id="standardW_+3A_bycolumn">byColumn</code></td>
<td>
<p>(logical) if <code>TRUE</code> the function will be run independently over all columns such as as <code>apply(mat,2,standardW)</code></p>
</td></tr>
<tr><td><code id="standardW_+3A_na.rm">na.rm</code></td>
<td>
<p>(logical) if <code>NA</code>s in the data don't get ignored via this argument, the output will be all <code>NA</code></p>
</td></tr>
<tr><td><code id="standardW_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="standardW_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="standardW_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This functions retruns a vector of rescaled data (in dimensions as input)
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+scale">scale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- matrix(2*round(runif(100),2), ncol=4)
mean(dat); sd(dat)

dat2 &lt;- standardW(dat)
apply(dat2, 2, sd)
summary(dat2)

dat3 &lt;- standardW(dat, byColumn=TRUE)
apply(dat2, 2, sd)
summary(dat2)
mean(dat2); sd(dat2)

</code></pre>

<hr>
<h2 id='stdErrMedBoot'>Standard eror of median by boot-strap</h2><span id='topic+stdErrMedBoot'></span>

<h3>Description</h3>

<p><code>stdErrMedBoot</code> estimate standard eror of median by boot-strap approach. 
Note: requires package <a href="https://CRAN.R-project.org/package=boot">boot</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stdErrMedBoot(x, nBoot = 99)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stdErrMedBoot_+3A_x">x</code></td>
<td>
<p>(numeric) vector to estimate median and it's standard error</p>
</td></tr>
<tr><td><code id="stdErrMedBoot_+3A_nboot">nBoot</code></td>
<td>
<p>(integer) number for iterations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a (numeric) vector with estimated standard error
</p>


<h3>See Also</h3>

<p><code><a href="boot.html#topic+boot">boot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2014); ra1 &lt;- c(rnorm(9,2,1),runif(8,1,2))
rat1 &lt;- ratioAllComb(ra1[1:9],ra1[10:17])
median(rat1); stdErrMedBoot(rat1)
</code></pre>

<hr>
<h2 id='summarizeCols'>Summarize columns (as median,mean,min,last or other methods)</h2><span id='topic+summarizeCols'></span>

<h3>Description</h3>

<p><code>summarizeCols</code> summarizes all columns of matrix (or data.frame).
In case of text-columns the sorted middle (~median) will be given, unless 'maxLast', 'minLast',
'maxLast','maxAbsLast' or 'minLast' .. consider only last column of 'matr' : choose from all columns the line where (max of) last col is at min;
'medianComplete' or 'meanComplete' consideres only lines/rows where no NA occur (NA have influence other columns !)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarizeCols(
  matr,
  meth = "median",
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarizeCols_+3A_matr">matr</code></td>
<td>
<p>data.frame matrix of data to be summarized by comlumn (may do different method for text and numeric comlumns)</p>
</td></tr>
<tr><td><code id="summarizeCols_+3A_meth">meth</code></td>
<td>
<p>(character) summarization method (eg 'maxLast','minLast','maxLast','maxAbsLast', 'minLast', 'medianComplete' or 'meanComplete')</p>
</td></tr>
<tr><td><code id="summarizeCols_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="summarizeCols_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="summarizeCols_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with summary for each column
</p>


<h3>See Also</h3>

<p><code>rowMeans</code> in <code><a href="base.html#topic+colSums">colSums</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t1 &lt;- matrix(round(runif(30,1,9)), nc=3); rownames(t1) &lt;- letters[c(1:5,3:4,6:4)]
summarizeCols(t1, me="median")
t(sapply(by(t1,rownames(t1), function(x) x), summarizeCols,me="maxLast"))
t3 &lt;- data.frame(ref=rep(11:15,3), tx=letters[1:15],
  matrix(round(runif(30,-3,2),1), ncol=2), stringsAsFactors=FALSE)
by(t3,t3[,1], function(x) x)
t(sapply(by(t3,t3[,1], function(x) x), summarizeCols,me="maxAbsLast"))
</code></pre>

<hr>
<h2 id='sumNAperGroup'>Count number of NAs per sub-set of columns</h2><span id='topic+sumNAperGroup'></span>

<h3>Description</h3>

<p>This function will count the number of <code>NA</code>s per group (defined by argument <code>grp</code>) while summing over all lines of a matrix or data.frame.
The row-position has no influence on the counting.
Using the argument <code>asRelative=TRUE</code> the result will be given as (average) number of <code>NA</code>s per row and group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumNAperGroup(
  x,
  grp,
  asRelative = FALSE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumNAperGroup_+3A_x">x</code></td>
<td>
<p>matrix or data.frame which may contain <code>NA</code>s</p>
</td></tr>
<tr><td><code id="sumNAperGroup_+3A_grp">grp</code></td>
<td>
<p>factor describing which column of 'dat' belongs to which group</p>
</td></tr>
<tr><td><code id="sumNAperGroup_+3A_asrelative">asRelative</code></td>
<td>
<p>(logical) return as count of <code>NA</code>s per row and group</p>
</td></tr>
<tr><td><code id="sumNAperGroup_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="sumNAperGroup_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="sumNAperGroup_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an integer vector with count of <code>NA</code>s per group
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+NA">NA</a></code>, filter <code>NA</code>s by line <code><a href="#topic+presenceFilt">presenceFilt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(1:25, ncol=5) 
mat[lower.tri(mat)] &lt;- NA
sumNAperGroup(mat, rep(1:2,c(3,2)))
sumNAperGroup(mat, rep(1:2,c(3,2)), asRelative=TRUE)

</code></pre>

<hr>
<h2 id='sysDate'>System-date (compressed format)</h2><span id='topic+sysDate'></span>

<h3>Description</h3>

<p>This function returns current date (based on Sys.Date) in different format options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sysDate(style = "univ1")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sysDate_+3A_style">style</code></td>
<td>
<p>(character) choose style (default 'univ1' for very compact style)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multiple options for formatting exist :
'univ1' or 'wr' ... (default) compact sytle using day, first 3 letters of English name of month (lowercaps) and last 2 letters of year as ddmmmyy, eg 14jun21 
</p>
<p>'univ2' ... as ddMmmyy, eg 14Jun21
</p>
<p>'univ3' ... as ddMonthyyyy, eg 14June2021
</p>
<p>'univ4' ... as ddmonthyyyy, eg 14june2021
</p>
<p>'univ5' ... as yyyy-mm-dd (output of <code>Sys.Date()</code>), eg 2021-06-14
</p>
<p>'univ6' ... as yyyy-number of day (in year), eg 2021-165
</p>
<p>'local1' ... compact sytle using day, first 3 letters of current locale name of month (not necessarily unique !) and last 2 letters of year as ddmmmyy, eg 14jui21 
</p>
<p>'local2' ... as ddMmmyy, month based on current locale (not necessarily unique !), eg 14Jui21
</p>
<p>'local3' ... as ddMonthyyyy, month based on current locale , eg 14Juin2021
</p>
<p>'local4' ... as ddmonthyyyy, month based on current locale , eg 14juin2021
</p>
<p>'local5' ... as dd-month-yyyy, month based on current locale , eg 14-juin-2021
</p>
<p>'local6' ... as yyyymonthddd, month based on current locale , eg 2021juin14
</p>


<h3>Value</h3>

<p>character vector with formatted date
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+date">date</a></code>, <code>Sys.Date</code> and <code><a href="base.html#topic+Sys.time">Sys.time</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sysDate() 

</code></pre>

<hr>
<h2 id='tableToPlot'>Print matrix-content as plot</h2><span id='topic+tableToPlot'></span>

<h3>Description</h3>

<p>This function prints all columns of matrix in plotting region for easier inclusion to reports (default values are set to work for output as A4-sized pdf).
It was made for integrating listings of text to graphical output to devices like <code>png</code>, <code>jpeg</code> or <code>pdf</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tableToPlot(
  matr,
  colPos = c(0.05, 0.35, 0.41, 0.56),
  useCex = 0.7,
  useAdj = c(0, 1, 1, 0),
  titOffS = 0,
  useCol = 1,
  silent = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tableToPlot_+3A_matr">matr</code></td>
<td>
<p>(matrix) main (character) matrix to display</p>
</td></tr>
<tr><td><code id="tableToPlot_+3A_colpos">colPos</code></td>
<td>
<p>(numeric) postion of columns on x-scale (from 0 to 1)</p>
</td></tr>
<tr><td><code id="tableToPlot_+3A_usecex">useCex</code></td>
<td>
<p>(numeric) cex expension factor forsiez of text (may be different for each column)</p>
</td></tr>
<tr><td><code id="tableToPlot_+3A_useadj">useAdj</code></td>
<td>
<p>(numeric) left/cneter/right alignment for text (may be different for each column)</p>
</td></tr>
<tr><td><code id="tableToPlot_+3A_titoffs">titOffS</code></td>
<td>
<p>(numeric) offset for title line (ralive to 'colPos')</p>
</td></tr>
<tr><td><code id="tableToPlot_+3A_usecol">useCol</code></td>
<td>
<p>color specification for text (may be different for each column)</p>
</td></tr>
<tr><td><code id="tableToPlot_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="tableToPlot_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was initially designed for listings with small/medium 1st col (eg couner or index), 2nd &amp; 3rd col small and long 3rd col (like file paths).
Obviously, the final number of lines one can pack and still read correctly into the graphical output depends on the size of the device 
(on a pdf of size A4 one can pack up to apr. 11O lines). 
Of ourse, <code><a href="utils.html#topic+Sweave">Sweave</a></code>, combined with LaTeX, provides a powerful alternative for wrapping text to pdf-output (and further combining text and graphics).
Note: The final result on pdf devices may vary depending on screen-size (ie with of current device), the parameters 'colPos' and 'titOffS' may need some refinements.
Note: In view of typical page/figure layouts like A4, the plotting region will be split to avoid too wide spacing between rows with less than 30 rows.
</p>


<h3>Value</h3>

<p>This function returns NULL (no R-object returned), print 'plot' in current device only
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+Sweave">Sweave</a></code> for more flexible framework
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## as example let's make a listing of file-names and associated parameters in current directory
mat &lt;- dir()
mat &lt;- cbind(no=1:length(mat),fileName=mat,mode=file.mode(mat),
  si=round(file.size(mat)/1024),path=getwd())
## Now, we wrap all text into a figure (which could be saved as jpg, pdf etc)
tableToPlot(mat[,-1],colPos=c(0.01,0.4,0.46,0.6),titOffS=c(0.05,-0.03,-0.01,0.06))
tableToPlot(mat,colPos=c(0,0.16,0.36,0.42,0.75),useAdj=0.5,titOffS=c(-0.01,0,-0.01,0,-0.1)) 
</code></pre>

<hr>
<h2 id='test2factLimma'>2-factorial limma-style t-test</h2><span id='topic+test2factLimma'></span>

<h3>Description</h3>

<p>The aim of this function is to provide convenient acces to two-factorial (linear) testing withing the framework of <code><a href="#topic+makeMAList">makeMAList</a></code> including the emprical Bayes shrinkage. 
The input data 'datMatr' which should already be organized as limma-type MAList, eg using using <code><a href="#topic+makeMAList">makeMAList</a></code>. 
Note: This function uses the Bioconductor package <a href="https://bioconductor.org/packages/release/bioc/html/limma.html">limma</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test2factLimma(
  datMatr,
  fac1,
  fac2,
  testSynerg = TRUE,
  testOrientation = "=",
  addResults = c("lfdr", "FDR", "Mval", "means"),
  addGenes = NULL,
  silent = FALSE,
  callFrom = NULL,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test2factLimma_+3A_datmatr">datMatr</code></td>
<td>
<p>matrix or data.frame with lines as indenpendent series of measures (eg different genes)</p>
</td></tr>
<tr><td><code id="test2factLimma_+3A_fac1">fac1</code></td>
<td>
<p>(character or factor) vector describing grouping elements of each line of 'datMatr' for first factor, must be of same langth as fac2</p>
</td></tr>
<tr><td><code id="test2factLimma_+3A_fac2">fac2</code></td>
<td>
<p>(character or factor) vector describing grouping elements of each line of 'datMatr' for second factor, must be of same langth as fac1</p>
</td></tr>
<tr><td><code id="test2factLimma_+3A_testsynerg">testSynerg</code></td>
<td>
<p>(logical) decide if factor-interactions (eg synergy) should be included to model</p>
</td></tr>
<tr><td><code id="test2factLimma_+3A_testorientation">testOrientation</code></td>
<td>
<p>(character) default (or any non-recignized input) '=', otherwise either '&gt;','gerater','sup','upper' or '&lt;','inf','lower'</p>
</td></tr>
<tr><td><code id="test2factLimma_+3A_addresults">addResults</code></td>
<td>
<p>(character) vector defining which types of information should be included to output, may be 'lfdr','FDR' (for BY correction), 'Mval' (M values), 'means' (matrix with mean values for each group of replicates)</p>
</td></tr>
<tr><td><code id="test2factLimma_+3A_addgenes">addGenes</code></td>
<td>
<p>(matrix or data.frame) additional information to add to output</p>
</td></tr>
<tr><td><code id="test2factLimma_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="test2factLimma_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
<tr><td><code id="test2factLimma_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an object of class &quot;MArrayLM&quot; (from limma) containing/enriched by the testing results
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeMAList">makeMAList</a></code>, single line testing <code><a href="limma.html#topic+lmFit">lmFit</a></code> and the <code>eBayes</code>-family of functions in package <a href="https://bioconductor.org/packages/release/bioc/html/limma.html">limma</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2014)
dat0 &lt;- rnorm(30) + rep(c(10,15,19,20),c(9,8,7,6))
fa &lt;- factor(rep(letters[1:4],c(9,8,7,6)))
dat2 &lt;- data.frame(facA=rep(c("-","A","-","A"), c(9,8,7,6)),
  facB= rep(c("-","-","B","B"), c(9,8,7,6)), dat1=dat0, dat2=runif(30))
grpNa &lt;- sub("-","",sub("\\.","", apply(dat2[,1:2], 1, paste, collapse="")))    
test2f &lt;- test2factLimma(t(dat2[,3:4]), dat2$facA, dat2$facB, testS=FALSE)  
test2f 
# Now you can easily summarize results using topTable from limma
if(requireNamespace("limma", quietly=TRUE)) {
  library(limma)
  topTable(test2f, coef=1, n=5) 
  topTable(test2f, coef=2, n=5) } 
</code></pre>

<hr>
<h2 id='transpGraySca'>Make single vector gray-gradient</h2><span id='topic+transpGraySca'></span>

<h3>Description</h3>

<p>This function helps making gray-gradients.
Note : The resulting color gradient does not seem linear to the human eye, you may try <code><a href="grDevices.html#topic+gray.colors">gray.colors</a></code> instead
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transpGraySca(startGray = 0.2, endGrey = 0.8, nSteps = 5, transp = 0.3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transpGraySca_+3A_startgray">startGray</code></td>
<td>
<p>(numeric) gray shade at start</p>
</td></tr>
<tr><td><code id="transpGraySca_+3A_endgrey">endGrey</code></td>
<td>
<p>(numeric)  gray shade at end</p>
</td></tr>
<tr><td><code id="transpGraySca_+3A_nsteps">nSteps</code></td>
<td>
<p>(integer) number of levels</p>
</td></tr>
<tr><td><code id="transpGraySca_+3A_transp">transp</code></td>
<td>
<p>(numeric) transparency alpha</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector (of same length as x) with color encoding
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+gray.colors">gray.colors</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>layout(1:2)
col1 &lt;- transpGraySca(0.8,0.3,7,0.9) 
pie(rep(1,length(col1)), col=col1, main="from transpGraySca")
col2 &lt;- gray.colors(7,0.9,0.3,alph=0.9)
pie(rep(1,length(col2)), col=col2, main="from gray.colors")
</code></pre>

<hr>
<h2 id='treatTxtDuplicates'>Locate duplicates in text and make non-redundant</h2><span id='topic+treatTxtDuplicates'></span>

<h3>Description</h3>

<p><code>treatTxtDuplicates</code> locates duplictes in character-vector 'x' and return list (length=3) : with $init (initial),
$nRed .. non-redundant text by adding number at end or beginning, and $nrLst .. list-version with indexes per unique entry. 
Note : NAs (if multiple) will be renamed to NA_1, NA_2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treatTxtDuplicates(
  x,
  atEnd = TRUE,
  sep = "_",
  onlyCorrectToUnique = FALSE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treatTxtDuplicates_+3A_x">x</code></td>
<td>
<p>(character) vector with character-entries to identify (and remove) duplicates</p>
</td></tr>
<tr><td><code id="treatTxtDuplicates_+3A_atend">atEnd</code></td>
<td>
<p>(logical) decide location of placing the counter (at end or at beginning of ID) (see <code><a href="#topic+correctToUnique">correctToUnique</a></code>)</p>
</td></tr>
<tr><td><code id="treatTxtDuplicates_+3A_sep">sep</code></td>
<td>
<p>(character) separator to add before counter when making non-redundant version</p>
</td></tr>
<tr><td><code id="treatTxtDuplicates_+3A_onlycorrecttounique">onlyCorrectToUnique</code></td>
<td>
<p>(logical) if TRUE, return only vector of non-redundant</p>
</td></tr>
<tr><td><code id="treatTxtDuplicates_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="treatTxtDuplicates_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="treatTxtDuplicates_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with $init, $nRed, $nrLst
</p>


<h3>See Also</h3>

<p>For simple correction use <code><a href="#topic+correctToUnique">correctToUnique</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>treatTxtDuplicates(c("li0",NA,rep(c("li2","li3"),2)))
correctToUnique(c("li0",NA,rep(c("li2","li3"),2)))
</code></pre>

<hr>
<h2 id='triCoord'>Pairwise x,y combinations</h2><span id='topic+triCoord'></span>

<h3>Description</h3>

<p><code>triCoord</code> gets pairwise combinations for 'n' elements; returns matrix with x &amp; y coordinates to form all pairwise groups for 1:n elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triCoord(n, side = "upper")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triCoord_+3A_n">n</code></td>
<td>
<p>(integer) number of elements for making all pair-wise combinations</p>
</td></tr>
<tr><td><code id="triCoord_+3A_side">side</code></td>
<td>
<p>(character) &quot;upper&quot; or &quot;lower&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>2-column matrix wiyh indexes for all pairwise combnations of 1:n
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+lower.tri">lower.tri</a></code> or <code>upper.tri</code>, simpler version <code><a href="#topic+upperMaCoord">upperMaCoord</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>triCoord(4)
</code></pre>

<hr>
<h2 id='trimRedundText'>Trim redundant text</h2><span id='topic+trimRedundText'></span>

<h3>Description</h3>

<p>This function allows trimming/removing redundant text-fragments (redundant from head or tail) out of character vector 'txt'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimRedundText(
  txt,
  minNchar = 1,
  side = "both",
  spaceElim = FALSE,
  silent = TRUE,
  callFrom = NULL,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trimRedundText_+3A_txt">txt</code></td>
<td>
<p>character vector to be treated</p>
</td></tr>
<tr><td><code id="trimRedundText_+3A_minnchar">minNchar</code></td>
<td>
<p>(integer) minumin number of characters that must remain</p>
</td></tr>
<tr><td><code id="trimRedundText_+3A_side">side</code></td>
<td>
<p>(character) may be be either 'both', 'left' or 'right'</p>
</td></tr>
<tr><td><code id="trimRedundText_+3A_spaceelim">spaceElim</code></td>
<td>
<p>(logical) optional removal of any heading or tailing white space</p>
</td></tr>
<tr><td><code id="trimRedundText_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="trimRedundText_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
<tr><td><code id="trimRedundText_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a modified character vector
</p>


<h3>See Also</h3>

<p>Inverse : Find/keep common text <code><a href="#topic+keepCommonText">keepCommonText</a></code>;  you may also look for related functions in package <a href="https://CRAN.R-project.org/package=stringr">stringr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>txt1 &lt;- c("abcd_ccc","bcd_ccc","cde_ccc")
trimRedundText(txt1, side="right")       # trim from right

txt2 &lt;- c("ddd_ab","ddd_bcd","ddd_cde")
trimRedundText(txt2, side="left")        # trim from left 
</code></pre>

<hr>
<h2 id='tTestAllVal'>t.test on all individual values against all other values</h2><span id='topic+tTestAllVal'></span>

<h3>Description</h3>

<p>Run t.test on each indiv value of x against all its neighbours (=remaining values of same vector) in order to test if tis value is likely to belong to vector x. 
This represents a repeated leave-one-out testing. Mutiple choices for multiple testing correction are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tTestAllVal(
  x,
  alph = 0.05,
  alternative = "two.sided",
  p.adj = NULL,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tTestAllVal_+3A_x">x</code></td>
<td>
<p>matrix or data.frame</p>
</td></tr>
<tr><td><code id="tTestAllVal_+3A_alph">alph</code></td>
<td>
<p>(numeric) threshold alpha (passed to <code>t.test</code>)</p>
</td></tr>
<tr><td><code id="tTestAllVal_+3A_alternative">alternative</code></td>
<td>
<p>(character) will be passed to <code>t.test</code> as argument 'alternative', may be &quot;two.sided&quot;,..</p>
</td></tr>
<tr><td><code id="tTestAllVal_+3A_p.adj">p.adj</code></td>
<td>
<p>(character) multiple test correction : may be NULL (no correction), &quot;BH&quot;,&quot;BY&quot;,&quot;holm&quot;,&quot;hochberg&quot; or &quot;bonferroni&quot;  (but not 'fdr' since this may be confounded with local false discovery rate), see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code></p>
</td></tr>
<tr><td><code id="tTestAllVal_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="tTestAllVal_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="tTestAllVal_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a numeric vector with p-values or FDR (depending on argument <code>p.adj</code>)
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+t.test">t.test</a></code>, <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016); x1 &lt;- rnorm(100)
allTests1 &lt;- tTestAllVal(x1)
hist(allTests1,breaks="FD")
</code></pre>

<hr>
<h2 id='unifyEnumerator'>Unify Enumerators</h2><span id='topic+unifyEnumerator'></span>

<h3>Description</h3>

<p>The aim of this function is to provide help in automatically harmonizing enumerators at the end of sample-names.
When data have same grouped setup/design, many times this is reflected in their names, eg 'A_sample1', 'A_sample2' and 'B_sample1'.
However, human operators may use multiple similar (but not identical) ways of expressing the same meanin, eg writng 'A_Samp_1'.
This function allows testing a panel of different extensions of enumerators and (if recognized) to replace them by a user-defined standard text/enumerator.
Please note that the more recent function <code><a href="#topic+rmEnumeratorName">rmEnumeratorName</a></code> offers better/more flexible options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unifyEnumerator(
  x,
  refSep = "_",
  baseSep = c("\\-", "\\ ", "\\."),
  suplEnu = c("Repl", "Rep", "R", "Number", "No", "Sample", "Samp"),
  stringentMatch = TRUE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unifyEnumerator_+3A_x">x</code></td>
<td>
<p>(character) main input</p>
</td></tr>
<tr><td><code id="unifyEnumerator_+3A_refsep">refSep</code></td>
<td>
<p>(character) separator for output</p>
</td></tr>
<tr><td><code id="unifyEnumerator_+3A_basesep">baseSep</code></td>
<td>
<p>(character) basic seprators to test (you have to protect special characters)</p>
</td></tr>
<tr><td><code id="unifyEnumerator_+3A_suplenu">suplEnu</code></td>
<td>
<p>(character) additional text</p>
</td></tr>
<tr><td><code id="unifyEnumerator_+3A_stringentmatch">stringentMatch</code></td>
<td>
<p>(logical) decide if enumerator text has to be found in all instances or only once</p>
</td></tr>
<tr><td><code id="unifyEnumerator_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="unifyEnumerator_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="unifyEnumerator_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has been developed for matching series of the same samples passing in parallel through different evaluation software (see R package wrProteo).
The way human operators may name things may easily leave room for surprises and this function allows testing only a limited number of common ways of writing.
Thus, in any case, the user is advised to inspect the results by eye and - if needed- to adjust the parameters.
</p>
<p>Basically enumerator separators can be constructed by combing a base-separator <code>baseSep</code> (like '-', '_' etc) and an enumerator-abbreviation <code>suplEnu</code>.
Then, all possible combinations will be tested if they occur in the text <code>x</code>.
Furthermore, the text searched has to be followd by on or multiple digts at the end of text-entry (decimal comma-separators etc are not allowed).
Thus, if there is other 'free text' following to the right after the enumerator-text this function will not find any enumerators to replace.
</p>
<p>The argument <code>stringentMatch</code> allows defining if this text has to be found in all text-entries of <code>x</code> or just one of them.
Whe using <code>stringentMatch=FALSE</code> there is risk that other text not meant to design enumerators may be picked up and modified.
</p>
<p>Please note, that with large data-sets (ie many columns) testing/checking a larger panel of enumerator-abreviations may result in slower performance.
In cases of larger data-sets it may be more effective to first study the data and then run simple subsitions using sub targeted for this very case.
</p>


<h3>Value</h3>

<p>This function returns a character vector of same length as input <code>x</code>, with it's content as adjusted enumerators
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmEnumeratorName">rmEnumeratorName</a></code> for better/more flexible options; <code><a href="base.html#topic+grep">grep</a></code> or <code>sub()</code>, etc if exact and consistent patterns are known
</p>


<h3>Examples</h3>

<pre><code class='language-R'>unifyEnumerator(c("ab-1","ab-2","c-3"))
unifyEnumerator(c("ab-R1","ab-R2","c-R3"))
unifyEnumerator(c("ab-1","c3-2","dR3"), strin=FALSE);

</code></pre>

<hr>
<h2 id='uniqCountReport'>Report number of unique and redundant elements (optional figure)</h2><span id='topic+uniqCountReport'></span>

<h3>Description</h3>

<p>Make report about number of unique and redundant elements of vector 'dat'.
Note : fairly slow for long vectors !!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniqCountReport(
  dat,
  frL = NULL,
  plotDispl = FALSE,
  tit = NULL,
  col = NULL,
  radius = 0.9,
  sizeTo = NULL,
  clockwise = FALSE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniqCountReport_+3A_dat">dat</code></td>
<td>
<p>(charcter or numeric vector) main input where number of unique (and redunant) should be determined</p>
</td></tr>
<tr><td><code id="uniqCountReport_+3A_frl">frL</code></td>
<td>
<p>(logical) optional (re-)introducing results from <code>duplicated</code> to shorten time of execution</p>
</td></tr>
<tr><td><code id="uniqCountReport_+3A_plotdispl">plotDispl</code></td>
<td>
<p>(logical) decide if pie-type plot should be produced</p>
</td></tr>
<tr><td><code id="uniqCountReport_+3A_tit">tit</code></td>
<td>
<p>(character) optional title in plot</p>
</td></tr>
<tr><td><code id="uniqCountReport_+3A_col">col</code></td>
<td>
<p>(character) custom colors in pie</p>
</td></tr>
<tr><td><code id="uniqCountReport_+3A_radius">radius</code></td>
<td>
<p>(numeric) radius passed to  <code>pie</code></p>
</td></tr>
<tr><td><code id="uniqCountReport_+3A_sizeto">sizeTo</code></td>
<td>
<p>(numeric or charcter) optional reference group for size-population relative adjusting overall surface of pie</p>
</td></tr>
<tr><td><code id="uniqCountReport_+3A_clockwise">clockwise</code></td>
<td>
<p>(logical) argument passed to pie</p>
</td></tr>
<tr><td><code id="uniqCountReport_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="uniqCountReport_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="uniqCountReport_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with counts of n (total), nUnique (wo any repeated), nHasRepeated (first of repeated), nRedundant), optional figure
</p>


<h3>See Also</h3>

<p><code><a href="#topic+correctToUnique">correctToUnique</a></code>, <code><a href="base.html#topic+unique">unique</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>layout(1:2)
uniqCountReport(rep(1:7,1:7),plot=TRUE)
uniqCountReport(rep(1:3,1:3),plot=TRUE,sizeTo=rep(1:7,1:7))      
</code></pre>

<hr>
<h2 id='upperMaCoord'>(upper) pairwise x,y combinations</h2><span id='topic+upperMaCoord'></span>

<h3>Description</h3>

<p><code>upperMaCoord</code> gets pairwise combinations for 'n' elements; return matrix with x &amp; y coordinates to form all pairwise groups for n elements.
But no distinction of 'upper' or 'lower' possible like in <code><a href="#topic+triCoord">triCoord</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upperMaCoord(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upperMaCoord_+3A_n">n</code></td>
<td>
<p>(integer) number of elements for making all pair-wise combinations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>2-column matrix wiyh indexes for all pairwise combnations of 1:n
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+lower.tri">lower.tri</a></code>, more evolved version <code><a href="#topic+triCoord">triCoord</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>upperMaCoord(4)
</code></pre>

<hr>
<h2 id='withinRefRange'>Check for values within range of reference</h2><span id='topic+withinRefRange'></span>

<h3>Description</h3>

<p><code>withinRefRange</code> checks which values of numeric vector 'x' are within range +/- 'fa' x 'ref' (ie within range of reference).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>withinRefRange(x, fa, ref = NULL, absRef = TRUE, asInd = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="withinRefRange_+3A_x">x</code></td>
<td>
<p>matrix or data.frame</p>
</td></tr>
<tr><td><code id="withinRefRange_+3A_fa">fa</code></td>
<td>
<p>(numeric) absolute or relative tolerance value (numeric, length=1), interpreted according to 'absRef' as absolute or relative to 'x'(ie fa*ref)</p>
</td></tr>
<tr><td><code id="withinRefRange_+3A_ref">ref</code></td>
<td>
<p>(numeric) (center) reference value for comparison (numeric, length=1), if not given mean of 'x' (excluding NA or non-finite values) will be used</p>
</td></tr>
<tr><td><code id="withinRefRange_+3A_absref">absRef</code></td>
<td>
<p>(logical) return result as absolute or relative to 'x'(ie fa*ref)</p>
</td></tr>
<tr><td><code id="withinRefRange_+3A_asind">asInd</code></td>
<td>
<p>(logical) if TRUE return index of which values of 'x' are within range, otherwise return values if 'x' within range</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector (containing only the values within range of reference)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## within 2.5 +/- 0.7
withinRefRange(-5:6,fa=0.7,ref=2.5)                
## within 2.5 +/- (0.7*2.5)
withinRefRange(-5:6,fa=0.7,ref=2.5,absRef=FALSE)
</code></pre>

<hr>
<h2 id='writeCsv'>Write (and convert) csv files</h2><span id='topic+writeCsv'></span>

<h3>Description</h3>

<p>This functions is absed on <code>write.csv</code> allows for more options when writing data into csv-files.
The main input may be gven as R-object or read from file 'input'. Then, one can (re-)write using specified conversions. 
An optional filter to select columns (column-name specified via 'filterCol') is available. 
The output may be simultaneaously written to multiple formats, as specified in 'expTy', 
tabulation characters may be converted to avoid accidentally split/shift text to multiple columns. 
Note: Mixing '.' and ',' as comma separators via text-columns or fused text&amp;data may cause problems lateron, though.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeCsv(
  input,
  inPutFi = NULL,
  expTy = c("Eur", "US"),
  imporTy = "Eur",
  filename = NULL,
  quote = FALSE,
  filterCol = NULL,
  replMatr = NULL,
  returnOut = FALSE,
  SYLKprevent = TRUE,
  digits = 22,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeCsv_+3A_input">input</code></td>
<td>
<p>either matrix or data.frame</p>
</td></tr>
<tr><td><code id="writeCsv_+3A_inputfi">inPutFi</code></td>
<td>
<p>(character or <code>NULL</code>) file-name to be read (format as US or Euro-type may specified via argument <code>imporTy</code>)</p>
</td></tr>
<tr><td><code id="writeCsv_+3A_expty">expTy</code></td>
<td>
<p>(character) 'US' and/or 'Eur' for sparator and decimal type in output</p>
</td></tr>
<tr><td><code id="writeCsv_+3A_importy">imporTy</code></td>
<td>
<p>(character) default 'Eur' (otherwise set to 'US')</p>
</td></tr>
<tr><td><code id="writeCsv_+3A_filename">filename</code></td>
<td>
<p>(character) optional new file name(s)</p>
</td></tr>
<tr><td><code id="writeCsv_+3A_quote">quote</code></td>
<td>
<p>(logical) will be passed to function <code>write.csv</code></p>
</td></tr>
<tr><td><code id="writeCsv_+3A_filtercol">filterCol</code></td>
<td>
<p>(integer or character) optionally, to export only the columns specified here</p>
</td></tr>
<tr><td><code id="writeCsv_+3A_replmatr">replMatr</code></td>
<td>
<p>optional, matrix (1st line:search, 2nd li:use for replacing) indicating which characters need to be replaced )</p>
</td></tr>
<tr><td><code id="writeCsv_+3A_returnout">returnOut</code></td>
<td>
<p>(logical) return output as object</p>
</td></tr>
<tr><td><code id="writeCsv_+3A_sylkprevent">SYLKprevent</code></td>
<td>
<p>(logical) prevent difficulty when opening file via Excel. In some cases Excel presumes (by error) the SYLK format and produces an error when trying to open files : 
To prevent this, if necessary, the 1st column-name will be changed from 'ID' to 'Id'.</p>
</td></tr>
<tr><td><code id="writeCsv_+3A_digits">digits</code></td>
<td>
<p>(interger) limit number of signif digits in output (ie file)</p>
</td></tr>
<tr><td><code id="writeCsv_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="writeCsv_+3A_debug">debug</code></td>
<td>
<p>(logical) for bug-tracking: more/enhanced messages</p>
</td></tr>
<tr><td><code id="writeCsv_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function writes a file to disk and returns <code>NULL</code> unless <code>returnOut=TRUE</code>
</p>


<h3>See Also</h3>

<p><code>write.csv</code> in <code><a href="utils.html#topic+write.table">write.table</a></code>, batch reading using this package <code><a href="#topic+readCsvBatch">readCsvBatch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat1 &lt;- data.frame(ini=letters[1:5],x1=1:5,x2=11:15,t1=c("10,10","20.20","11,11","21,21","33.33"),
  t2=c("10,11","20.21","kl;kl","az,az","ze.ze"))
fiNa &lt;- file.path(tempdir(), paste("test",1:2,".csv",sep=""))
writeCsv(dat1, filename=fiNa[1])
dir(path=tempdir(), pattern="cs")

(writeCsv(dat1, replM=rbind(bad=c(";",","), replBy="__"), expTy=c("Eur"),
  returnOut=TRUE, filename=fiNa[2]))

</code></pre>

<hr>
<h2 id='XYToDiffPpm'>Express difference as ppm</h2><span id='topic+XYToDiffPpm'></span>

<h3>Description</h3>

<p>This function transforms offset (pariwise-difference) between 'x' &amp; 'y' to ppm (as normalized difference ppm, parts per million, ie (x-y)/y ).
This type of expressiong differences is used eg in mass-spectrometry.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>XYToDiffPpm(x, y, nSign = NULL, silent = FALSE, debug = FALSE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="XYToDiffPpm_+3A_x">x</code></td>
<td>
<p>(numeric) typically for measured variable</p>
</td></tr>
<tr><td><code id="XYToDiffPpm_+3A_y">y</code></td>
<td>
<p>(numeric) typically for theoretical/expected value (vector must be of same length as 'x')</p>
</td></tr>
<tr><td><code id="XYToDiffPpm_+3A_nsign">nSign</code></td>
<td>
<p>(integer) number of significant digits in output</p>
</td></tr>
<tr><td><code id="XYToDiffPpm_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="XYToDiffPpm_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="XYToDiffPpm_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a numeric vector of (ratio-) ppm values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ratioToPpm">ratioToPpm</a></code> for classical ppm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2017); aa &lt;- runif(10,50,900)
cbind(x=aa,y=aa+1e-3,ppm=XYToDiffPpm(aa,aa+1e-3,nSign=4)) 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
