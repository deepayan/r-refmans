<!DOCTYPE html><html lang="en"><head><title>Help for package SurfRough</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SurfRough}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anisoDir'><p>Calculate the direction of maximum continuity considering 4 directions</p></a></li>
<li><a href='#anisoDirL'><p>Calculate the direction of maximum continuity considering 4 directions</p></a></li>
<li><a href='#anisoR'><p>Calculate the index of anisotropy considering the spatial variability along 4 directions</p></a></li>
<li><a href='#anisoRL'><p>Calculate the index of anisotropy considering the spatial variability along 4 directions</p></a></li>
<li><a href='#CalcMeans'><p>Calculate the mean of absolute values raised to an exponent found in a search window</p></a></li>
<li><a href='#CalcMedians'><p>Calculate the median of absolute values found in a search window for each raster in a list</p></a></li>
<li><a href='#circularDispersionGV'><p>Compute circular variance of aspect (i.e. of the gradient vector)</p></a></li>
<li><a href='#circularDispersionNV'><p>Compute circular variance of normal vectors to surface</p></a></li>
<li><a href='#circularEigenNV'><p>Compute circular variance of normal vectors to surface</p></a></li>
<li><a href='#k05ck2'><p>basic kernels</p></a></li>
<li><a href='#k1c'><p>basic kernels</p></a></li>
<li><a href='#k1ck2'><p>basic kernels</p></a></li>
<li><a href='#k2c'><p>basic kernels</p></a></li>
<li><a href='#k2ck2'><p>basic kernels</p></a></li>
<li><a href='#k4c'><p>basic kernels</p></a></li>
<li><a href='#k6c'><p>basic kernels</p></a></li>
<li><a href='#k8c'><p>basic kernels</p></a></li>
<li><a href='#KernelCircular'><p>Build a circular moving window</p></a></li>
<li><a href='#KernelRectangular'><p>Build a rectangular kernel of size X x Y</p></a></li>
<li><a href='#Madscan'><p>Calculate MAD basic indexes</p></a></li>
<li><a href='#Meanscan'><p>Calculate less robust geostatistical indexes (mean of absolute differences raised to an exponent)</p></a></li>
<li><a href='#RRI'><p>RRI: Radial Roughness index</p></a></li>
<li><a href='#RRIK3'><p>RRIK3: Radial Roughness index with differences of order 3</p></a></li>
<li><a href='#RRIMax'><p>RRIMax: Maximum Radial Roughness index</p></a></li>
<li><a href='#RRIMin'><p>RRIMin: Minimum Radial Roughness index</p></a></li>
<li><a href='#Trik2'><p>Improved TRI (with differences of order 2), reducing/removing slope dependence.</p></a></li>
<li><a href='#Trik2.numeric'><p>Improved TRI (with differences of order 2), reducing/removing slope dependence.</p></a></li>
<li><a href='#Trik2.SpatRaster'><p>Improved TRI (with differences of order 2), reducing/removing slope dependence.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Calculate Surface/Image Texture Indexes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for the computation of surface/image texture indices using a geostatistical based approach (Trevisani et al. (2023) &lt;<a href="https://doi.org/10.1016%2Fj.geomorph.2023.108838">doi:10.1016/j.geomorph.2023.108838</a>&gt;). It provides various functions for the computation of surface texture indices (e.g., omnidirectional roughness and roughness anisotropy), including the ones based on the robust MAD estimator. The kernels included in the software permit also to calculate the surface/image texture indices directly from the input surface  (i.e., without de-trending) using increments of order 2. It also provides the new radial roughness index (RRI), representing the improvement of the popular topographic roughness index (TRI). The framework can be easily extended with ad-hoc surface/image texture indices.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/strevisani/SurfRough/issues">https://github.com/strevisani/SurfRough/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), terra</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tinytest</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/strevisani/SurfRough">https://github.com/strevisani/SurfRough</a>,
<a href="https://doi.org/10.5281/zenodo.7132160">https://doi.org/10.5281/zenodo.7132160</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-19 06:48:55 UTC; x</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sebastiano Trevisani &lt;strevisani@iuav.it&gt;</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastiano Trevisani
    <a href="https://orcid.org/0000-0001-8436-7798"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Ilich Alexander <a href="https://orcid.org/0000-0003-1758-8499"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Zakharko Taras <a href="https://orcid.org/0000-0001-7601-8424"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-19 07:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='anisoDir'>Calculate the direction of maximum continuity considering 4 directions</h2><span id='topic+anisoDir'></span>

<h3>Description</h3>

<p>The input is represented by four rasters with the spatial variability index (e.g., MAD, variogram, etc.) computed
in four directions (N-S, NE-SW, E-W, SE-NW)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anisoDir(N, NE, E, SE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anisoDir_+3A_n">N</code></td>
<td>
<p>Spatial variability along N-S direction</p>
</td></tr>
<tr><td><code id="anisoDir_+3A_ne">NE</code></td>
<td>
<p>Spatial variability along NE-SW direction</p>
</td></tr>
<tr><td><code id="anisoDir_+3A_e">E</code></td>
<td>
<p>Spatial variability along E-W direction</p>
</td></tr>
<tr><td><code id="anisoDir_+3A_se">SE</code></td>
<td>
<p>Spatial variability along SE-NW direction</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A raster with the direction (in degrees, geographical) of maximum continuity
</p>

<hr>
<h2 id='anisoDirL'>Calculate the direction of maximum continuity considering 4 directions</h2><span id='topic+anisoDirL'></span>

<h3>Description</h3>

<p>The input is represented by a list of rasters with the spatial variability index (e.g., MAD, variogram, etc.) computed
in four directions (N-S, NE-SW, E-W, SE-NW)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anisoDirL(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anisoDirL_+3A_x">x</code></td>
<td>
<p>A list of rasters with the spatial variability along 4 directions (see function anisoDir())</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A raster with the direction (in degrees, geographical) of maximum continuity
</p>

<hr>
<h2 id='anisoR'>Calculate the index of anisotropy considering the spatial variability along 4 directions</h2><span id='topic+anisoR'></span>

<h3>Description</h3>

<p>The input is represented by four rasters with the spatial variability index (e.g., MAD, variogram, etc.) computed
in four directions (N-S, NE-SW, E-W, SE-NW)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anisoR(N, NE, E, SE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anisoR_+3A_n">N</code></td>
<td>
<p>Spatial vairability along N-S direction</p>
</td></tr>
<tr><td><code id="anisoR_+3A_ne">NE</code></td>
<td>
<p>Spatial vairability along NE-SW direction</p>
</td></tr>
<tr><td><code id="anisoR_+3A_e">E</code></td>
<td>
<p>Spatial vairability along E-W direction</p>
</td></tr>
<tr><td><code id="anisoR_+3A_se">SE</code></td>
<td>
<p>Spatial vairability along SE-NW direction</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A raster with the index of anisotropy (min=0 max=1)
</p>

<hr>
<h2 id='anisoRL'>Calculate the index of anisotropy considering the spatial variability along 4 directions</h2><span id='topic+anisoRL'></span>

<h3>Description</h3>

<p>The input is represented by a list of rasters with the spatial variability index (e.g., MAD, variogram, etc.) computed
in four directions (N-S, NE-SW, E-W, SE-NW)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anisoRL(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anisoRL_+3A_x">x</code></td>
<td>
<p>A list of rasters with the spatial variability along 4 directions (see function anisoR())</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A raster with the index of anisotropy (min=0 max=1)
</p>

<hr>
<h2 id='CalcMeans'>Calculate the mean of absolute values raised to an exponent found in a search window</h2><span id='topic+CalcMeans'></span>

<h3>Description</h3>

<p>With this you can compute variogram and madogram (but remember that for
classical geostatistical indexes you need to divide the derived isotropic index by 2!)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcMeans(deltas, w, exponent)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalcMeans_+3A_deltas">deltas</code></td>
<td>
<p>The values from which calculate the median of absolute values (i.e., directional differences of order K)</p>
</td></tr>
<tr><td><code id="CalcMeans_+3A_w">w</code></td>
<td>
<p>The moving window used (e.g. w=KernelCircular(3))</p>
</td></tr>
<tr><td><code id="CalcMeans_+3A_exponent">exponent</code></td>
<td>
<p>The exponent: increasing the exponent increase the sensitivity to outliers. Set 2 for Variogram and 1 for Madogram.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A raster with the mean of absolute values in the search window
</p>

<hr>
<h2 id='CalcMedians'>Calculate the median of absolute values found in a search window for each raster in a list</h2><span id='topic+CalcMedians'></span>

<h3>Description</h3>

<p>Calculate the median of absolute values found in a search window for each raster in a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcMedians(deltas, w)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalcMedians_+3A_deltas">deltas</code></td>
<td>
<p>A list of rasters with the values from which calculate the median of absolute values (e.g., directional differences of order K)</p>
</td></tr>
<tr><td><code id="CalcMedians_+3A_w">w</code></td>
<td>
<p>The moving window used (e.g. w=KernelCircular(3))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of rasters with the median of absolute values in the search window
</p>

<hr>
<h2 id='circularDispersionGV'>Compute circular variance of aspect (i.e. of the gradient vector)</h2><span id='topic+circularDispersionGV'></span>

<h3>Description</h3>

<p>Compute circular variance of aspect (i.e. of the gradient vector)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circularDispersionGV(inraster, window)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circularDispersionGV_+3A_inraster">inraster</code></td>
<td>
<p>The DEM from which compute the index</p>
</td></tr>
<tr><td><code id="circularDispersionGV_+3A_window">window</code></td>
<td>
<p>The moving window adopted for computing the index</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The raster with the computed index
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Gradient vector dispersion using a circular search window of radius 3.
library(terra)
dem=rast(paste(system.file("extdata", package = "SurfRough"), "/trento1.tif",sep=""))
w=KernelCircular(3)
roughGrad=circularDispersionGV(dem,w)
plot(roughGrad)
</code></pre>

<hr>
<h2 id='circularDispersionNV'>Compute circular variance of normal vectors to surface</h2><span id='topic+circularDispersionNV'></span>

<h3>Description</h3>

<p>Compute circular variance of normal vectors to surface, using the resultant vector length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circularDispersionNV(inraster, window)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circularDispersionNV_+3A_inraster">inraster</code></td>
<td>
<p>The DEM from which compute the index</p>
</td></tr>
<tr><td><code id="circularDispersionNV_+3A_window">window</code></td>
<td>
<p>The moving window adopted for computing the index</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The raster with the computed index
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
#Normal vector dispersion using a circular search window of radius 3.
library(terra)
dem=rast(paste(system.file("extdata", package = "SurfRough"), "/trento1.tif",sep=""))
w=KernelCircular(3)
roughVDR=circularDispersionNV(dem,w)
plot(roughVDR)
</code></pre>

<hr>
<h2 id='circularEigenNV'>Compute circular variance of normal vectors to surface</h2><span id='topic+circularEigenNV'></span>

<h3>Description</h3>

<p>Compute circular variance of normal vectors to surface, using the eigen values (only for testing, very slow)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circularEigenNV(inraster, window)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circularEigenNV_+3A_inraster">inraster</code></td>
<td>
<p>The DEM from which compute the index</p>
</td></tr>
<tr><td><code id="circularEigenNV_+3A_window">window</code></td>
<td>
<p>The moving window adopted for computing the index</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The raster with the computed index
</p>

<hr>
<h2 id='k05ck2'>basic kernels</h2><span id='topic+k05ck2'></span>

<h3>Description</h3>

<p>Kernels for computing directional differences for specific directions and lag distances.
These have been constructed using bilinear interpolation for directions out of main axes.
The kernels are intended to be used with &quot;Terra&quot; focal functions (i.e., convolution).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k05ck2
</code></pre>


<h3>Format</h3>

<p>just matrices.
</p>


<h3>Source</h3>

<p>Sebastiano Trevisani
</p>


<h3>References</h3>


<ol>
<li><p> Trevisani, S. &amp; Rocca, M. 2015. MAD: Robust image texture analysis for applications in high resolution geomorphometry.
Computers and Geosciences, vol. 81, pp. 78-92.
</p>
</li>
<li><p> Trevisani, S. Teza, G., Guth, P., 2023. A simplified geostatistical approach for characterizing key aspects of short-range roughness.
CATENA,Volume 223, ISSN 0341-8162,https://doi.org/10.1016/j.catena.2023.106927
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>#to see kernels (each one is a list with 4 kernels) of order 1
#These should be used with a detrended "surface"
#lag 1 pixel
k1c
#lag 2 pixels
k2c
#lag 4 pixels
k4c
#lag 6 pixels
k6c
#lag 8 pixels
k8c
#kernels of order 2 (differences of differences)
#these can be applied directly without detrending
#lag 05 pixel
k05ck2
#lag 1 pixel
k1ck2
#lag 2 pixels
k2ck2
</code></pre>

<hr>
<h2 id='k1c'>basic kernels</h2><span id='topic+k1c'></span>

<h3>Description</h3>

<p>Kernels for computing directional differences for specific directions and lag distances.
These have been constructed using bilinear interpolation for directions out of main axes.
The kernels are intended to be used with &quot;Terra&quot; focal functions (i.e., convolution).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k1c
</code></pre>


<h3>Format</h3>

<p>just matrices.
</p>


<h3>Source</h3>

<p>Sebastiano Trevisani
</p>


<h3>References</h3>


<ol>
<li><p> Trevisani, S. &amp; Rocca, M. 2015. MAD: Robust image texture analysis for applications in high resolution geomorphometry.
Computers and Geosciences, vol. 81, pp. 78-92.
</p>
</li>
<li><p> Trevisani, S. Teza, G., Guth, P., 2023. A simplified geostatistical approach for characterizing key aspects of short-range roughness.
CATENA,Volume 223, ISSN 0341-8162,https://doi.org/10.1016/j.catena.2023.106927
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>#to see kernels (each one is a list with 4 kernels) of order 1
#These should be used with a detrended "surface"
#lag 1 pixel
k1c
#lag 2 pixels
k2c
#lag 4 pixels
k4c
#lag 6 pixels
k6c
#lag 8 pixels
k8c
#kernels of order 2 (differences of differences)
#these can be applied directly without detrending
#lag 05 pixel
k05ck2
#lag 1 pixel
k1ck2
#lag 2 pixels
k2ck2
</code></pre>

<hr>
<h2 id='k1ck2'>basic kernels</h2><span id='topic+k1ck2'></span>

<h3>Description</h3>

<p>Kernels for computing directional differences for specific directions and lag distances.
These have been constructed using bilinear interpolation for directions out of main axes.
The kernels are intended to be used with &quot;Terra&quot; focal functions (i.e., convolution).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k1ck2
</code></pre>


<h3>Format</h3>

<p>just matrices.
</p>


<h3>Source</h3>

<p>Sebastiano Trevisani
</p>


<h3>References</h3>


<ol>
<li><p> Trevisani, S. &amp; Rocca, M. 2015. MAD: Robust image texture analysis for applications in high resolution geomorphometry.
Computers and Geosciences, vol. 81, pp. 78-92.
</p>
</li>
<li><p> Trevisani, S. Teza, G., Guth, P., 2023. A simplified geostatistical approach for characterizing key aspects of short-range roughness.
CATENA,Volume 223, ISSN 0341-8162,https://doi.org/10.1016/j.catena.2023.106927
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>#to see kernels (each one is a list with 4 kernels) of order 1
#These should be used with a detrended "surface"
#lag 1 pixel
k1c
#lag 2 pixels
k2c
#lag 4 pixels
k4c
#lag 6 pixels
k6c
#lag 8 pixels
k8c
#kernels of order 2 (differences of differences)
#these can be applied directly without detrending
#lag 05 pixel
k05ck2
#lag 1 pixel
k1ck2
#lag 2 pixels
k2ck2
</code></pre>

<hr>
<h2 id='k2c'>basic kernels</h2><span id='topic+k2c'></span>

<h3>Description</h3>

<p>Kernels for computing directional differences for specific directions and lag distances.
These have been constructed using bilinear interpolation for directions out of main axes.
The kernels are intended to be used with &quot;Terra&quot; focal functions (i.e., convolution).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k2c
</code></pre>


<h3>Format</h3>

<p>just matrices.
</p>


<h3>Source</h3>

<p>Sebastiano Trevisani
</p>


<h3>References</h3>


<ol>
<li><p> Trevisani, S. &amp; Rocca, M. 2015. MAD: Robust image texture analysis for applications in high resolution geomorphometry.
Computers and Geosciences, vol. 81, pp. 78-92.
</p>
</li>
<li><p> Trevisani, S. Teza, G., Guth, P., 2023. A simplified geostatistical approach for characterizing key aspects of short-range roughness.
CATENA,Volume 223, ISSN 0341-8162,https://doi.org/10.1016/j.catena.2023.106927
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>#to see kernels (each one is a list with 4 kernels) of order 1
#These should be used with a detrended "surface"
#lag 1 pixel
k1c
#lag 2 pixels
k2c
#lag 4 pixels
k4c
#lag 6 pixels
k6c
#lag 8 pixels
k8c
#kernels of order 2 (differences of differences)
#these can be applied directly without detrending
#lag 05 pixel
k05ck2
#lag 1 pixel
k1ck2
#lag 2 pixels
k2ck2
</code></pre>

<hr>
<h2 id='k2ck2'>basic kernels</h2><span id='topic+k2ck2'></span>

<h3>Description</h3>

<p>Kernels for computing directional differences for specific directions and lag distances.
These have been constructed using bilinear interpolation for directions out of main axes.
The kernels are intended to be used with &quot;Terra&quot; focal functions (i.e., convolution).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k2ck2
</code></pre>


<h3>Format</h3>

<p>just matrices.
</p>


<h3>Source</h3>

<p>Sebastiano Trevisani
</p>


<h3>References</h3>


<ol>
<li><p> Trevisani, S. &amp; Rocca, M. 2015. MAD: Robust image texture analysis for applications in high resolution geomorphometry.
Computers and Geosciences, vol. 81, pp. 78-92.
</p>
</li>
<li><p> Trevisani, S. Teza, G., Guth, P., 2023. A simplified geostatistical approach for characterizing key aspects of short-range roughness.
CATENA,Volume 223, ISSN 0341-8162,https://doi.org/10.1016/j.catena.2023.106927
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>#to see kernels (each one is a list with 4 kernels) of order 1
#These should be used with a detrended "surface"
#lag 1 pixel
k1c
#lag 2 pixels
k2c
#lag 4 pixels
k4c
#lag 6 pixels
k6c
#lag 8 pixels
k8c
#kernels of order 2 (differences of differences)
#these can be applied directly without detrending
#lag 05 pixel
k05ck2
#lag 1 pixel
k1ck2
#lag 2 pixels
k2ck2
</code></pre>

<hr>
<h2 id='k4c'>basic kernels</h2><span id='topic+k4c'></span>

<h3>Description</h3>

<p>Kernels for computing directional differences for specific directions and lag distances.
These have been constructed using bilinear interpolation for directions out of main axes.
The kernels are intended to be used with &quot;Terra&quot; focal functions (i.e., convolution).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k4c
</code></pre>


<h3>Format</h3>

<p>just matrices.
</p>


<h3>Source</h3>

<p>Sebastiano Trevisani
</p>


<h3>References</h3>


<ol>
<li><p> Trevisani, S. &amp; Rocca, M. 2015. MAD: Robust image texture analysis for applications in high resolution geomorphometry.
Computers and Geosciences, vol. 81, pp. 78-92.
</p>
</li>
<li><p> Trevisani, S. Teza, G., Guth, P., 2023. A simplified geostatistical approach for characterizing key aspects of short-range roughness.
CATENA,Volume 223, ISSN 0341-8162,https://doi.org/10.1016/j.catena.2023.106927
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>#to see kernels (each one is a list with 4 kernels) of order 1
#These should be used with a detrended "surface"
#lag 1 pixel
k1c
#lag 2 pixels
k2c
#lag 4 pixels
k4c
#lag 6 pixels
k6c
#lag 8 pixels
k8c
#kernels of order 2 (differences of differences)
#these can be applied directly without detrending
#lag 05 pixel
k05ck2
#lag 1 pixel
k1ck2
#lag 2 pixels
k2ck2
</code></pre>

<hr>
<h2 id='k6c'>basic kernels</h2><span id='topic+k6c'></span>

<h3>Description</h3>

<p>Kernels for computing directional differences for specific directions and lag distances.
These have been constructed using bilinear interpolation for directions out of main axes.
The kernels are intended to be used with &quot;Terra&quot; focal functions (i.e., convolution).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k6c
</code></pre>


<h3>Format</h3>

<p>just matrices.
</p>


<h3>Source</h3>

<p>Sebastiano Trevisani
</p>


<h3>References</h3>


<ol>
<li><p> Trevisani, S. &amp; Rocca, M. 2015. MAD: Robust image texture analysis for applications in high resolution geomorphometry.
Computers and Geosciences, vol. 81, pp. 78-92.
</p>
</li>
<li><p> Trevisani, S. Teza, G., Guth, P., 2023. A simplified geostatistical approach for characterizing key aspects of short-range roughness.
CATENA,Volume 223, ISSN 0341-8162,https://doi.org/10.1016/j.catena.2023.106927
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>#to see kernels (each one is a list with 4 kernels) of order 1
#These should be used with a detrended "surface"
#lag 1 pixel
k1c
#lag 2 pixels
k2c
#lag 4 pixels
k4c
#lag 6 pixels
k6c
#lag 8 pixels
k8c
#kernels of order 2 (differences of differences)
#these can be applied directly without detrending
#lag 05 pixel
k05ck2
#lag 1 pixel
k1ck2
#lag 2 pixels
k2ck2
</code></pre>

<hr>
<h2 id='k8c'>basic kernels</h2><span id='topic+k8c'></span>

<h3>Description</h3>

<p>Kernels for computing directional differences for specific directions and lag distances.
These have been constructed using bilinear interpolation for directions out of main axes.
The kernels are intended to be used with &quot;Terra&quot; focal functions (i.e., convolution).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k8c
</code></pre>


<h3>Format</h3>

<p>just matrices.
</p>


<h3>Source</h3>

<p>Sebastiano Trevisani
</p>


<h3>References</h3>


<ol>
<li><p> Trevisani, S. &amp; Rocca, M. 2015. MAD: Robust image texture analysis for applications in high resolution geomorphometry.
Computers and Geosciences, vol. 81, pp. 78-92.
</p>
</li>
<li><p> Trevisani, S. Teza, G., Guth, P., 2023. A simplified geostatistical approach for characterizing key aspects of short-range roughness.
CATENA,Volume 223, ISSN 0341-8162,https://doi.org/10.1016/j.catena.2023.106927
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>#to see kernels (each one is a list with 4 kernels) of order 1
#These should be used with a detrended "surface"
#lag 1 pixel
k1c
#lag 2 pixels
k2c
#lag 4 pixels
k4c
#lag 6 pixels
k6c
#lag 8 pixels
k8c
#kernels of order 2 (differences of differences)
#these can be applied directly without detrending
#lag 05 pixel
k05ck2
#lag 1 pixel
k1ck2
#lag 2 pixels
k2ck2
</code></pre>

<hr>
<h2 id='KernelCircular'>Build a circular moving window</h2><span id='topic+KernelCircular'></span>

<h3>Description</h3>

<p>Build a circular moving window
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KernelCircular(radius)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KernelCircular_+3A_radius">radius</code></td>
<td>
<p>The radius of the moving window</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with selected pixels
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#A circular moving window with a radius of 3 pixels
w=KernelCircular(3)
w
</code></pre>

<hr>
<h2 id='KernelRectangular'>Build a rectangular kernel of size X x Y</h2><span id='topic+KernelRectangular'></span>

<h3>Description</h3>

<p>Build a rectangular kernel of size X x Y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KernelRectangular(lenx, leny)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KernelRectangular_+3A_lenx">lenx</code></td>
<td>
<p>The size in pixels along x</p>
</td></tr>
<tr><td><code id="KernelRectangular_+3A_leny">leny</code></td>
<td>
<p>The size in pixels along y</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix (square/rectangular) with the selected pixels
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#A rectangular moving window 5x5 pixels
w=KernelRectangular(5,5)
w
</code></pre>

<hr>
<h2 id='Madscan'>Calculate MAD basic indexes</h2><span id='topic+Madscan'></span>

<h3>Description</h3>

<p>Calculate MAD basic indexes considering a specif lag and difference of order K.
It computes 3 indexes of roughness/image texture: isotropic/omnidirectional; direction of maximum continuity; anisotropy index.
The anisotropy index is based on vector dispersion approach: 0 minimum anisotropy; 1 maximum anisotropy.
The direction of anisotropy is in degrees according to geographical convention.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Madscan(inRaster, kernels, w)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Madscan_+3A_inraster">inRaster</code></td>
<td>
<p>The DEM/residual-dem from which to compute the indexes</p>
</td></tr>
<tr><td><code id="Madscan_+3A_kernels">kernels</code></td>
<td>
<p>The kernels to be used for computing the directional differences (e.g. order 1 or 2 for various lags)</p>
</td></tr>
<tr><td><code id="Madscan_+3A_w">w</code></td>
<td>
<p>The moving window adopted for computing the geostatistical index (i.e., MAD)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 3 rasters: 1)isotropic roughness; 2) direction of anisotropy;3)index of anisotropy.
</p>


<h3>References</h3>


<ol>
<li><p> Trevisani, S. &amp; Rocca, M. 2015. MAD: Robust image texture analysis for applications in high resolution geomorphometry.
Computers and Geosciences, vol. 81, pp. 78-92.
</p>
</li>
<li><p> Trevisani, S. Teza, G., Guth, P., 2023. A simplified geostatistical approach for characterizing key aspects of short-range roughness.
CATENA,Volume 223, ISSN 0341-8162,https://doi.org/10.1016/j.catena.2023.106927
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'># MAD for lag 2 with differences of order 2 using a circular search window of radius 3.
# Using differences of order 1, you should
# apply these on a detrended surface/image.
library(terra)
dem=rast(paste(system.file("extdata", package = "SurfRough"), "/trento1.tif",sep=""))
w=KernelCircular(3)
rough2c=Madscan(dem,k2ck2, w)
#Plot isotropic roughness
plot(rough2c$IsoRough)
#Plot anisotropy index/strenght
plot(rough2c$AnisoR)

</code></pre>

<hr>
<h2 id='Meanscan'>Calculate less robust geostatistical indexes (mean of absolute differences raised to an exponent)</h2><span id='topic+Meanscan'></span>

<h3>Description</h3>

<p>With this you can compute variogram and madogram (but remember that for
classical geostatistical indexes you need to divide the derived isotropic index by 2!).
Moreover you can calibrate the exponent in order to filter or enhance hotspots and discontinuities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Meanscan(inRaster, kernels, w, exponent)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Meanscan_+3A_inraster">inRaster</code></td>
<td>
<p>The DEM/residual-dem from which to compute the indexes</p>
</td></tr>
<tr><td><code id="Meanscan_+3A_kernels">kernels</code></td>
<td>
<p>The kernels to be used for computing the directional differences (e.g. order 1 or 2 for various lags)</p>
</td></tr>
<tr><td><code id="Meanscan_+3A_w">w</code></td>
<td>
<p>The moving window adopted for computing the geostatistical index (i.e., MAD)</p>
</td></tr>
<tr><td><code id="Meanscan_+3A_exponent">exponent</code></td>
<td>
<p>The exponent: increasing the exponent increase the sensitivity to outliers. Set 2 for Variogram and 1 for Madogram.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatRaster with 3 layers: 1)isotropic roughness; 2) direction of anisotropy; 3)index of anisotropy.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' Variogram-like for lag 2 with differences of order 2 using a circular search window of radius 3.
# Using differences of order 1, you should
# apply these on a detrended surface/image.
library(terra)
dem=rast(paste(system.file("extdata", package = "SurfRough"), "/trento1.tif",sep=""))
w=KernelCircular(3)
rough2c=Meanscan(dem,k2ck2, w,2)
#(divide by two if you need classical estimator)
plot(rough2c$IsoRough)

</code></pre>

<hr>
<h2 id='RRI'>RRI: Radial Roughness index</h2><span id='topic+RRI'></span><span id='topic+RRI.numeric'></span><span id='topic+RRI.SpatRaster'></span>

<h3>Description</h3>

<p>Modified TRI, based on increments of order 2  (reducing/removing slope dependence) and correcting for diagonal distance.
RRI modifies TRI (topographic ruggedness index) using increments of order 2, symmetrical to the central pixel,
so as to reduce/remove the effect of local slope.
This version corrects for the diagonal distance using bilinear interpolation.
It uses a 5x5 kernel, consequently 12 directional differences of order k (2)
are used in the estimation.
One could also use a 3x3 kernel using only the 4 differences centered on the central pixel
but the metric would be very noisy.
The input is the DEM (no need to detrend).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RRI(x, ...)

## S3 method for class 'numeric'
RRI(x, ...)

## S3 method for class 'SpatRaster'
RRI(x, ..., .method = c("rcpp", "r"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RRI_+3A_x">x</code></td>
<td>
<p>A DEM as a SpatRaster or a vector of numeric values from a focal window in a DEM from which to compute the index</p>
</td></tr>
<tr><td><code id="RRI_+3A_...">...</code></td>
<td>
<p>reserved for future use</p>
</td></tr>
<tr><td><code id="RRI_+3A_.method">.method</code></td>
<td>
<p>Either <code>r</code> or <code>rcpp</code> (fast batch processing using C++)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>isotropic roughness (in the same units of input)
</p>


<h3>References</h3>


<ol>
<li><p> Riley, S. J., S. D. DeGloria, and R. Elliott. 1999.
A terrain ruggedness index that quantifies topographic heterogeneity.
Intermountain Journal of Science 5:23.
</p>
</li>
<li><p> Wilson, M.F.J., O'Connell, B., Brown, C., Guinan, J.C. &amp; Grehan, A.J. 2007.
Multiscale terrain analysis of multibeam bathymetry data for habitat mapping on the continental slope&quot;.
Marine Geodesy, vol. 30, no. 1-2, pp. 3-35.
</p>
</li>
<li><p> Trevisani S., Teza G., Guth P.L., 2023. Hacking the topographic ruggedness index. Geomorphology
https://doi.org/10.1016/j.geomorph.2023.108838
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
dem= rast(paste(system.file("extdata", package = "SurfRough"), "/trento1.tif",sep=""))
w &lt;- matrix(1, nrow=5, ncol=5)
roughRRI_v1=focal(dem, w=w, fun=RRI)
roughRRI_v2=RRI(dem)
plot(c(roughRRI_v1, roughRRI_v2))
</code></pre>

<hr>
<h2 id='RRIK3'>RRIK3: Radial Roughness index with differences of order 3</h2><span id='topic+RRIK3'></span><span id='topic+RRIK3.numeric'></span><span id='topic+RRIK3.SpatRaster'></span>

<h3>Description</h3>

<p>Extension of RRI using differences of order 3
Accordingly, this version filters out a trend of order 2, so it reduces still more the dependence
on slope and partially on curvature.
The input is the DEM (no need to detrend).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RRIK3(x, ...)

## S3 method for class 'numeric'
RRIK3(x, ...)

## S3 method for class 'SpatRaster'
RRIK3(x, ..., .method = c("rcpp", "r"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RRIK3_+3A_x">x</code></td>
<td>
<p>A DEM as a SpatRaster or a vector of numeric values from a focal window in a DEM from which to compute the index</p>
</td></tr>
<tr><td><code id="RRIK3_+3A_...">...</code></td>
<td>
<p>reserved for future use</p>
</td></tr>
<tr><td><code id="RRIK3_+3A_.method">.method</code></td>
<td>
<p>Either <code>r</code> or <code>rcpp</code> (fast batch processing using C++, still to implement)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>isotropic roughness (in the same units of input)
</p>


<h3>References</h3>

<p>Trevisani S., Teza G., Guth P.L., 2023. Hacking the topographic ruggedness index. Geomorphology
https://doi.org/10.1016/j.geomorph.2023.108838
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
dem= rast(paste(system.file("extdata", package = "SurfRough"), "/trento1.tif",sep=""))
roughRRIK3=RRIK3(dem)
plot(roughRRIK3)
</code></pre>

<hr>
<h2 id='RRIMax'>RRIMax: Maximum Radial Roughness index</h2><span id='topic+RRIMax'></span><span id='topic+RRIMax.numeric'></span><span id='topic+RRIMax.SpatRaster'></span>

<h3>Description</h3>

<p>Same as RRI but instead of computing the mean of the absolute differences of order 2,
the maximum is computed.
The input is the DEM (no need to detrend).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RRIMax(x, ...)

## S3 method for class 'numeric'
RRIMax(x, ...)

## S3 method for class 'SpatRaster'
RRIMax(x, ..., .method = c("rcpp", "r"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RRIMax_+3A_x">x</code></td>
<td>
<p>A DEM as a SpatRaster or a vector of numeric values from a focal window in a DEM from which to compute the index</p>
</td></tr>
<tr><td><code id="RRIMax_+3A_...">...</code></td>
<td>
<p>reserved for future use</p>
</td></tr>
<tr><td><code id="RRIMax_+3A_.method">.method</code></td>
<td>
<p>Either <code>r</code> or <code>rcpp</code> (fast batch processing using C++, still to implement)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>isotropic roughness (in the same units of input)
</p>


<h3>References</h3>

<p>Trevisani S., Teza G., Guth P.L., 2023. Hacking the topographic ruggedness index. Geomorphology
https://doi.org/10.1016/j.geomorph.2023.108838
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
dem= rast(paste(system.file("extdata", package = "SurfRough"), "/trento1.tif",sep=""))
roughRRIMax=RRIMax(dem)
plot(roughRRIMax)
</code></pre>

<hr>
<h2 id='RRIMin'>RRIMin: Minimum Radial Roughness index</h2><span id='topic+RRIMin'></span><span id='topic+RRIMin.numeric'></span><span id='topic+RRIMin.SpatRaster'></span>

<h3>Description</h3>

<p>Same as RRI but instead of computing the mean of the absolute differences of order 2,
the minimum is computed.
The input is the DEM (no need to detrend).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RRIMin(x, ...)

## S3 method for class 'numeric'
RRIMin(x, ...)

## S3 method for class 'SpatRaster'
RRIMin(x, ..., .method = c("rcpp", "r"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RRIMin_+3A_x">x</code></td>
<td>
<p>A DEM as a SpatRaster or a vector of numeric values from a focal window in a DEM from which to compute the index</p>
</td></tr>
<tr><td><code id="RRIMin_+3A_...">...</code></td>
<td>
<p>reserved for future use</p>
</td></tr>
<tr><td><code id="RRIMin_+3A_.method">.method</code></td>
<td>
<p>Either <code>r</code> or <code>rcpp</code> (fast batch processing using C++, still to implement)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>isotropic roughness (in the same units of input)
</p>


<h3>References</h3>

<p>Trevisani S., Teza G., Guth P.L., 2023. Hacking the topographic ruggedness index. Geomorphology
https://doi.org/10.1016/j.geomorph.2023.108838
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
dem= rast(paste(system.file("extdata", package = "SurfRough"), "/trento1.tif",sep=""))
roughRRImin=RRIMin(dem)
plot(roughRRImin)
</code></pre>

<hr>
<h2 id='Trik2'>Improved TRI (with differences of order 2), reducing/removing slope dependence.</h2><span id='topic+Trik2'></span>

<h3>Description</h3>

<p>It is essentially a radial roughness index.
TRIk2 modifies TRI (topographic ruggedness index) using increments of order 2, symmetrical to central pixel,
so as to remove/reduce the effect of local slope.
This version does not correct for diagonal distance and therefore is mainly for testing/simulation purposes,
so in practice the Radial Roughness Index calculated by the RRI function should be used instead.
It uses a 5x5 kernel, consequently 12 directional differences of order k (2)
are used in the estimation.
One could also use a 3x3 kernel using only the 4 differences centered on the central pixel
but the metric would be very noisy.
The input is the DEM (no need to detrend).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Trik2(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Trik2_+3A_x">x</code></td>
<td>
<p>A DEM as a SpatRaster or a vector of numeric values from a focal window in a DEM from which to compute the index</p>
</td></tr>
</table>


<h3>Value</h3>

<p>isotropic roughness (in the same units of input)
</p>


<h3>References</h3>


<ol>
<li><p> Riley, S. J., S. D. DeGloria, and R. Elliott. 1999.
A terrain ruggedness index that quantifies topographic heterogeneity.
Intermountain Journal of Science 5:23.
</p>
</li>
<li><p> Wilson, M.F.J., O'Connell, B., Brown, C., Guinan, J.C. &amp; Grehan, A.J. 2007.
Multiscale terrain analysis of multibeam bathymetry data for habitat mapping on the continental slope&quot;.
Marine Geodesy, vol. 30, no. 1-2, pp. 3-35.
</p>
</li>
<li><p> Trevisani S., Teza G., Guth P.L., 2023. Hacking the topographic ruggedness index. Geomorphology
https://doi.org/10.1016/j.geomorph.2023.108838
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
dem=rast(paste(system.file("extdata", package = "SurfRough"), "/trento1.tif",sep=""))
w &lt;- matrix(1, nrow=5, ncol=5)
roughTrik5x5_v1=focal(dem, w=w, fun=Trik2)
roughTrik5x5_v2=Trik2(dem)
plot(c(roughTrik5x5_v1,roughTrik5x5_v2))

</code></pre>

<hr>
<h2 id='Trik2.numeric'>Improved TRI (with differences of order 2), reducing/removing slope dependence.</h2><span id='topic+Trik2.numeric'></span>

<h3>Description</h3>

<p>It is essentially a radial roughness index.
TRIk2 modifies TRI (topographic ruggedness index) using increments of order 2, symmetrical to central pixel,
so as to remove the effect of local slope.
This version does not correct for diagonal distance and therefore is mainly for testing/simulation purposes,
so in practice the Radial Roughness Index calculated by the RRI function should be used instead.
It uses a 5x5 kernel, consequently 12 directional differences of order k (2)
are used in the estimation.
One could also use a 3x3 kernel using only the 4 differences centered on the central pixel
but the metric would be very noisy.
The input is the DEM (no need to detrend).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'numeric'
Trik2(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Trik2.numeric_+3A_x">x</code></td>
<td>
<p>A vector of numeric values from a focal window in a DEM from which to compute the index</p>
</td></tr>
</table>


<h3>Value</h3>

<p>isotropic roughness (in the same units of input)
</p>


<h3>References</h3>


<ol>
<li><p> Riley, S. J., S. D. DeGloria, and R. Elliott. 1999.
A terrain ruggedness index that quantifies topographic heterogeneity.
Intermountain Journal of Science 5:23.
</p>
</li>
<li><p> Wilson, M.F.J., O'Connell, B., Brown, C., Guinan, J.C. &amp; Grehan, A.J. 2007.
Multiscale terrain analysis of multibeam bathymetry data for habitat mapping on the continental slope&quot;.
Marine Geodesy, vol. 30, no. 1-2, pp. 3-35.
</p>
</li>
<li><p> Trevisani S., Teza G., Guth P.L., 2023. Hacking the topographic ruggedness index. Geomorphology
https://doi.org/10.1016/j.geomorph.2023.108838
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
dem=rast(paste(system.file("extdata", package = "SurfRough"), "/trento1.tif",sep=""))
w &lt;- matrix(1, nrow=5, ncol=5)
roughTrik5x5=focal(dem, w=w, fun=Trik2)
plot(roughTrik5x5)

</code></pre>

<hr>
<h2 id='Trik2.SpatRaster'>Improved TRI (with differences of order 2), reducing/removing slope dependence.</h2><span id='topic+Trik2.SpatRaster'></span>

<h3>Description</h3>

<p>It is essentially a radial roughness index.
TRIk2 modifies TRI (topographic ruggedness index) using increments of order 2, symmetrical to central pixel,
so as to reduce/remove the effect of local slope.
This version does not correct for diagonal distance and therefore is mainly for testing/simulation purposes,
so in practice the Radial Roughness Index calculated by the RRI function should be used instead.
It uses a 5x5 kernel, consequently 12 directional differences of order k (2)
are used in the estimation.
One could also use a 3x3 kernel using only the 4 differences centered on the central pixel
but the metric would be very noisy.
The input is the DEM (no need to detrend).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatRaster'
Trik2(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Trik2.SpatRaster_+3A_x">x</code></td>
<td>
<p>A DEM as a SpatRaster or a vector of numeric values from a focal window in a DEM from which to compute the index</p>
</td></tr>
</table>


<h3>Value</h3>

<p>isotropic roughness (in the same units of input)
</p>


<h3>References</h3>


<ol>
<li><p> Riley, S. J., S. D. DeGloria, and R. Elliott. 1999.
A terrain ruggedness index that quantifies topographic heterogeneity.
Intermountain Journal of Science 5:23.
</p>
</li>
<li><p> Wilson, M.F.J., O'Connell, B., Brown, C., Guinan, J.C. &amp; Grehan, A.J. 2007.
Multiscale terrain analysis of multibeam bathymetry data for habitat mapping on the continental slope&quot;.
Marine Geodesy, vol. 30, no. 1-2, pp. 3-35.
</p>
</li>
<li><p> Trevisani S., Teza G., Guth P.L., 2023. Hacking the topographic ruggedness index. Geomorphology
https://doi.org/10.1016/j.geomorph.2023.108838
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
dem=rast(paste(system.file("extdata", package = "SurfRough"), "/trento1.tif",sep=""))
roughTrik5x5=Trik2(dem)
plot(roughTrik5x5)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
