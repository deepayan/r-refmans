<!DOCTYPE html><html><head><title>Help for package gslnls</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gslnls}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anova.gsl_nls'><p>Anova tables</p></a></li>
<li><a href='#coef.gsl_nls'><p>Extract model coefficients</p></a></li>
<li><a href='#confint.gsl_nls'><p>Confidence interval for model parameters</p></a></li>
<li><a href='#confintd'><p>Confidence intervals for derived parameters</p></a></li>
<li><a href='#confintd.gsl_nls'><p>Confidence intervals for derived parameters</p></a></li>
<li><a href='#deviance.gsl_nls'><p>Model deviance</p></a></li>
<li><a href='#df.residual.gsl_nls'><p>Residual degrees-of-freedom</p></a></li>
<li><a href='#fitted.gsl_nls'><p>Extract model fitted values</p></a></li>
<li><a href='#formula.gsl_nls'><p>Extract model formula</p></a></li>
<li><a href='#gsl_nls'><p>GSL Nonlinear Least Squares fitting</p></a></li>
<li><a href='#gsl_nls_control'><p>Tunable Nonlinear Least Squares iteration parameters</p></a></li>
<li><a href='#gsl_nls_large'><p>GSL Large-scale Nonlinear Least Squares fitting</p></a></li>
<li><a href='#logLik.gsl_nls'><p>Extract model log-likelihood</p></a></li>
<li><a href='#nls_test_list'><p>Available NLS test problems</p></a></li>
<li><a href='#nls_test_problem'><p>Retrieve an NLS test problem</p></a></li>
<li><a href='#nobs.gsl_nls'><p>Extract the number of observations</p></a></li>
<li><a href='#predict.gsl_nls'><p>Calculate model predicted values</p></a></li>
<li><a href='#residuals.gsl_nls'><p>Extract model residuals</p></a></li>
<li><a href='#sigma.gsl_nls'><p>Residual standard deviation</p></a></li>
<li><a href='#summary.gsl_nls'><p>Model summary</p></a></li>
<li><a href='#vcov.gsl_nls'><p>Calculate variance-covariance matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>GSL Nonlinear Least-Squares Fitting</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-09</td>
</tr>
<tr>
<td>Description:</td>
<td>An R interface to nonlinear least-squares optimization with the GNU Scientific Library (GSL), see M. Galassi et al. (2009, ISBN:0954612078). The available trust region methods include the Levenberg-Marquardt algorithm with and without geodesic acceleration, the Steihaug-Toint conjugate gradient algorithm for large systems and several variants of Powell's dogleg algorithm. The interface includes multi-start optimization using quasi-random samples based on a modified version of algorithm in Hickernell and Yuan (1997, OR Transactions). Bindings are provided to tune a number of parameters affecting the low-level aspects of the trust region algorithms. The interface mimics R's nls() function and returns model objects inheriting from the same class.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/JorisChau/gslnls/issues">https://github.com/JorisChau/gslnls/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/JorisChau/gslnls">https://github.com/JorisChau/gslnls</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, Matrix</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GSL (&gt;= 2.2)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-10 20:46:53 UTC; jchau</td>
</tr>
<tr>
<td>Author:</td>
<td>Joris Chau [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joris Chau &lt;joris.chau@openanalytics.eu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-11 07:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='anova.gsl_nls'>Anova tables</h2><span id='topic+anova.gsl_nls'></span>

<h3>Description</h3>

<p>Returns the analysis of variance (or deviance) tables for two or
more fitted <code>"gsl_nls"</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gsl_nls'
anova(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.gsl_nls_+3A_object">object</code></td>
<td>
<p>An object inheriting from class <code>"gsl_nls"</code>.</p>
</td></tr>
<tr><td><code id="anova.gsl_nls_+3A_...">...</code></td>
<td>
<p>Additional objects inheriting from class <code>"gsl_nls"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame object of class <code>"anova"</code> similar to <code><a href="stats.html#topic+anova">anova</a></code> representing the
analysis-of-variance table of the fitted model objects when printed.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+anova">anova</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data
set.seed(1)
n &lt;- 50
xy &lt;- data.frame(
  x = (1:n) / n,
  y = 2.5 * exp(-1.5 * (1:n) / n) + 1 + rnorm(n, sd = 0.1)
)
## model
obj1 &lt;- gsl_nls(fn = y ~ A * exp(-lam * x), data = xy, start = c(A = 1, lam = 1))
obj2 &lt;- gsl_nls(fn = y ~ A * exp(-lam * x) + b, data = xy,
    start = c(A = 1, lam = 1, b = 0))

anova(obj1, obj2)
</code></pre>

<hr>
<h2 id='coef.gsl_nls'>Extract model coefficients</h2><span id='topic+coef.gsl_nls'></span>

<h3>Description</h3>

<p>Returns the fitted model coefficients from a <code>"gsl_nls"</code> object.
<code>coefficients</code> can also be used as an alias.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gsl_nls'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.gsl_nls_+3A_object">object</code></td>
<td>
<p>An object inheriting from class <code>"gsl_nls"</code>.</p>
</td></tr>
<tr><td><code id="coef.gsl_nls_+3A_...">...</code></td>
<td>
<p>At present no optional arguments are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named numeric vector of fitted coefficients similar to <code><a href="stats.html#topic+coef">coef</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+coef">coef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data
set.seed(1)
n &lt;- 50
xy &lt;- data.frame(
  x = (1:n) / n,
  y = 2.5 * exp(-1.5 * (1:n) / n) + rnorm(n, sd = 0.1)
)
## model
obj &lt;- gsl_nls(fn = y ~ A * exp(-lam * x), data = xy, start = c(A = 1, lam = 1))

coef(obj)
</code></pre>

<hr>
<h2 id='confint.gsl_nls'>Confidence interval for model parameters</h2><span id='topic+confint.gsl_nls'></span>

<h3>Description</h3>

<p>Returns asymptotic or profile likelihood confidence intervals for the parameters in a
fitted <code>"gsl_nls"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gsl_nls'
confint(object, parm, level = 0.95, method = c("asymptotic", "profile"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.gsl_nls_+3A_object">object</code></td>
<td>
<p>An object inheriting from class <code>"gsl_nls"</code>.</p>
</td></tr>
<tr><td><code id="confint.gsl_nls_+3A_parm">parm</code></td>
<td>
<p>A character vector of parameter names for which to evaluate confidence intervals, defaults
to all parameters.</p>
</td></tr>
<tr><td><code id="confint.gsl_nls_+3A_level">level</code></td>
<td>
<p>A numeric scalar between 0 and 1 giving the level of the parameter confidence intervals.</p>
</td></tr>
<tr><td><code id="confint.gsl_nls_+3A_method">method</code></td>
<td>
<p>Method to be used, either <code>"asymptotic"</code> for asymptotic confidence intervals or
<code>"profile"</code> for profile likelihood confidence intervals. The latter is only available for
<code>"gsl_nls"</code> objects that are also of class <code>"nls"</code>.</p>
</td></tr>
<tr><td><code id="confint.gsl_nls_+3A_...">...</code></td>
<td>
<p>At present no optional arguments are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method <code>"asymptotic"</code> assumes (approximate) normality of the errors in the model and calculates
standard asymptotic confidence intervals based on the quantiles of a t-distritbution. Method <code>"profile"</code>
calculates profile likelihood confidence intervals using the <code><a href="MASS.html#topic+confint">confint.nls</a></code> method
in the <a href="https://CRAN.R-project.org/package=MASS"><span class="pkg">MASS</span></a> package and for this reason is only available for <code>"gsl_nls"</code> objects that
are <em>also</em> of class <code>"nls"</code>.
</p>


<h3>Value</h3>

<p>A matrix with columns giving the lower and upper confidence limits for each parameter.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+confint">confint</a></code>, <code><a href="MASS.html#topic+confint">confint.nls</a></code> in package <a href="https://CRAN.R-project.org/package=MASS"><span class="pkg">MASS</span></a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data
set.seed(1)
n &lt;- 50
xy &lt;- data.frame(
  x = (1:n) / n,
  y = 2.5 * exp(-1.5 * (1:n) / n) + rnorm(n, sd = 0.1)
)
## model
obj &lt;- gsl_nls(fn = y ~ A * exp(-lam * x), data = xy, start = c(A = 1, lam = 1))

## asymptotic ci's
confint(obj)
## Not run: 
## profile ci's (requires MASS)
confint(obj, method = "profile")

## End(Not run)
</code></pre>

<hr>
<h2 id='confintd'>Confidence intervals for derived parameters</h2><span id='topic+confintd'></span>

<h3>Description</h3>

<p><code>confintd</code> is a generic function to compute confidence intervals for continuous functions
of the parameters in a fitted model. The function invokes particular <em>methods</em> which depend on the
<code><a href="base.html#topic+class">class</a></code> of the first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confintd(object, expr, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confintd_+3A_object">object</code></td>
<td>
<p>A fitted model object.</p>
</td></tr>
<tr><td><code id="confintd_+3A_expr">expr</code></td>
<td>
<p>An expression or character vector that can be transformed to an <code><a href="base.html#topic+expression">expression</a></code>
giving the function(s) of the parameters to be evaluated. Each expression should evaluate to a numeric scalar.</p>
</td></tr>
<tr><td><code id="confintd_+3A_level">level</code></td>
<td>
<p>A numeric scalar between 0 and 1 giving the level of the derived parameter confidence intervals.</p>
</td></tr>
<tr><td><code id="confintd_+3A_...">...</code></td>
<td>
<p>Additional argument(s) for methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with columns giving the fitted values and lower and upper confidence limits for
each derived parameter. The row names list the individual derived parameter expressions.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+confint">confint</a></code>
</p>

<hr>
<h2 id='confintd.gsl_nls'>Confidence intervals for derived parameters</h2><span id='topic+confintd.gsl_nls'></span>

<h3>Description</h3>

<p>Returns fitted values and confidence intervals for continuous functions of parameters
from a fitted <code>"gsl_nls"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gsl_nls'
confintd(object, expr, level = 0.95, dtype = "symbolic", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confintd.gsl_nls_+3A_object">object</code></td>
<td>
<p>A fitted model object.</p>
</td></tr>
<tr><td><code id="confintd.gsl_nls_+3A_expr">expr</code></td>
<td>
<p>An expression or character vector that can be transformed to an <code><a href="base.html#topic+expression">expression</a></code>
giving the function(s) of the parameters to be evaluated. Each expression should evaluate to a numeric scalar.</p>
</td></tr>
<tr><td><code id="confintd.gsl_nls_+3A_level">level</code></td>
<td>
<p>A numeric scalar between 0 and 1 giving the level of the derived parameter confidence intervals.</p>
</td></tr>
<tr><td><code id="confintd.gsl_nls_+3A_dtype">dtype</code></td>
<td>
<p>A character string equal to <code>"symbolic"</code> for <em>symbolic</em> differentiation of
<code>expr</code> with <code><a href="stats.html#topic+deriv">deriv</a></code>, or <code>"numeric"</code> for <em>numeric</em> differentiation
of <code>expr</code> with <code><a href="stats.html#topic+numericDeriv">numericDeriv</a></code> using forward finite differencing.</p>
</td></tr>
<tr><td><code id="confintd.gsl_nls_+3A_...">...</code></td>
<td>
<p>Additional argument(s) for methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method assumes (approximate) normality of the errors in the model and confidence intervals are
calculated using the <em>delta method</em>, i.e. a first-order Taylor approximation of the (continuous)
function of the parameters. If <code>dtype = "symbolic"</code> (the default), <code>expr</code> is differentiated
with respect to the parameters using symbolic differentiation with <code><a href="stats.html#topic+deriv">deriv</a></code>. As such,
each expression in <code>expr</code> must contain only operators that are known to <code><a href="stats.html#topic+deriv">deriv</a></code>.
If <code>dtype = "numeric"</code>, <code>expr</code> is differentiated using numeric differentiation with
<code><a href="stats.html#topic+numericDeriv">numericDeriv</a></code>, which should be used if <code>expr</code> cannot be derived symbolically
with <code><a href="stats.html#topic+deriv">deriv</a></code>.
</p>


<h3>Value</h3>

<p>A matrix with columns giving the fitted values and lower and upper confidence limits for
each derived parameter. The row names list the individual derived parameter expressions.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+confint">confint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data
set.seed(1)
n &lt;- 50
xy &lt;- data.frame(
  x = (1:n) / n,
  y = 2.5 * exp(-1.5 * (1:n) / n) + rnorm(n, sd = 0.1)
)
## model
obj &lt;- gsl_nls(fn = y ~ A * exp(-lam * x), data = xy, start = c(A = 1, lam = 1))

## delta method ci's
confintd(obj, expr = c("log(lam)", "A / lam"))
</code></pre>

<hr>
<h2 id='deviance.gsl_nls'>Model deviance</h2><span id='topic+deviance.gsl_nls'></span>

<h3>Description</h3>

<p>Returns the deviance of a fitted <code>"gsl_nls"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gsl_nls'
deviance(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deviance.gsl_nls_+3A_object">object</code></td>
<td>
<p>An object inheriting from class <code>"gsl_nls"</code>.</p>
</td></tr>
<tr><td><code id="deviance.gsl_nls_+3A_...">...</code></td>
<td>
<p>At present no optional arguments are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric deviance value similar to <code><a href="stats.html#topic+deviance">deviance</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+deviance">deviance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data
set.seed(1)
n &lt;- 50
xy &lt;- data.frame(
  x = (1:n) / n,
  y = 2.5 * exp(-1.5 * (1:n) / n) + rnorm(n, sd = 0.1)
)
## model
obj &lt;- gsl_nls(fn = y ~ A * exp(-lam * x), data = xy, start = c(A = 1, lam = 1))

deviance(obj)
</code></pre>

<hr>
<h2 id='df.residual.gsl_nls'>Residual degrees-of-freedom</h2><span id='topic+df.residual.gsl_nls'></span>

<h3>Description</h3>

<p>Returns the residual degrees-of-freedom from a fitted <code>"gsl_nls"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gsl_nls'
df.residual(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df.residual.gsl_nls_+3A_object">object</code></td>
<td>
<p>An object inheriting from class <code>"gsl_nls"</code>.</p>
</td></tr>
<tr><td><code id="df.residual.gsl_nls_+3A_...">...</code></td>
<td>
<p>At present no optional arguments are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer residual degrees-of-freedom similar to <code><a href="stats.html#topic+df.residual">df.residual</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+df.residual">df.residual</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data
set.seed(1)
n &lt;- 50
xy &lt;- data.frame(
  x = (1:n) / n,
  y = 2.5 * exp(-1.5 * (1:n) / n) + rnorm(n, sd = 0.1)
)
## model
obj &lt;- gsl_nls(fn = y ~ A * exp(-lam * x), data = xy, start = c(A = 1, lam = 1))

df.residual(obj)
</code></pre>

<hr>
<h2 id='fitted.gsl_nls'>Extract model fitted values</h2><span id='topic+fitted.gsl_nls'></span>

<h3>Description</h3>

<p>Returns the fitted responses from a <code>"gsl_nls"</code> object. <code>fitted.values</code>
can also be used as an alias.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gsl_nls'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.gsl_nls_+3A_object">object</code></td>
<td>
<p>An object inheriting from class <code>"gsl_nls"</code>.</p>
</td></tr>
<tr><td><code id="fitted.gsl_nls_+3A_...">...</code></td>
<td>
<p>At present no optional arguments are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of fitted responses similar to <code><a href="stats.html#topic+fitted">fitted</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+fitted">fitted</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data
set.seed(1)
n &lt;- 50
xy &lt;- data.frame(
  x = (1:n) / n,
  y = 2.5 * exp(-1.5 * (1:n) / n) + rnorm(n, sd = 0.1)
)
## model
obj &lt;- gsl_nls(fn = y ~ A * exp(-lam * x), data = xy, start = c(A = 1, lam = 1))

fitted(obj)
</code></pre>

<hr>
<h2 id='formula.gsl_nls'>Extract model formula</h2><span id='topic+formula.gsl_nls'></span>

<h3>Description</h3>

<p>Returns the model formula from a fitted <code>"gsl_nls"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gsl_nls'
formula(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.gsl_nls_+3A_x">x</code></td>
<td>
<p>An object inheriting from class <code>"gsl_nls"</code>.</p>
</td></tr>
<tr><td><code id="formula.gsl_nls_+3A_...">...</code></td>
<td>
<p>At present no optional arguments are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the object inherits from class <code>"nls"</code> returns the fitted model as a <a href="stats.html#topic+formula">formula</a> similar
to <code><a href="stats.html#topic+formula">formula</a></code>. Otherwise returns the fitted model as a <a href="base.html#topic+function">function</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+formula">formula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data
set.seed(1)
n &lt;- 50
xy &lt;- data.frame(
  x = (1:n) / n,
  y = 2.5 * exp(-1.5 * (1:n) / n) + rnorm(n, sd = 0.1)
)
## model
obj &lt;- gsl_nls(fn = y ~ A * exp(-lam * x), data = xy, start = c(A = 1, lam = 1))

formula(obj)
</code></pre>

<hr>
<h2 id='gsl_nls'>GSL Nonlinear Least Squares fitting</h2><span id='topic+gsl_nls'></span><span id='topic+gsl_nls.formula'></span><span id='topic+gsl_nls.function'></span>

<h3>Description</h3>

<p>Determine the nonlinear least-squares estimates of the parameters of a
nonlinear model using the <code>gsl_multifit_nlinear</code> module present in
the GNU Scientific Library (GSL).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsl_nls(fn, ...)

## S3 method for class 'formula'
gsl_nls(
  fn,
  data = parent.frame(),
  start,
  algorithm = c("lm", "lmaccel", "dogleg", "ddogleg", "subspace2D"),
  control = gsl_nls_control(),
  jac = NULL,
  fvv = NULL,
  trace = FALSE,
  subset,
  weights,
  na.action,
  model = FALSE,
  ...
)

## S3 method for class 'function'
gsl_nls(
  fn,
  y,
  start,
  algorithm = c("lm", "lmaccel", "dogleg", "ddogleg", "subspace2D"),
  control = gsl_nls_control(),
  jac = NULL,
  fvv = NULL,
  trace = FALSE,
  weights,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsl_nls_+3A_fn">fn</code></td>
<td>
<p>a nonlinear model defined either as a two-sided <a href="stats.html#topic+formula">formula</a> including variables and parameters,
or as a <a href="base.html#topic+function">function</a> returning a numeric vector, with first argument the vector of parameters to be estimated.
See the individual method descriptions below.</p>
</td></tr>
<tr><td><code id="gsl_nls_+3A_data">data</code></td>
<td>
<p>an optional data frame in which to evaluate the variables in <code>fn</code> if
defined as a <a href="stats.html#topic+formula">formula</a>. Can also be a list or an environment, but not a matrix.</p>
</td></tr>
<tr><td><code id="gsl_nls_+3A_y">y</code></td>
<td>
<p>numeric response vector if <code>fn</code> is defined as a <a href="base.html#topic+function">function</a>, equal in
length to the vector returned by evaluation of the function <code>fn</code>.</p>
</td></tr>
<tr><td><code id="gsl_nls_+3A_start">start</code></td>
<td>
<p>initial parameter values (single-start) or parameter ranges (multi-start). The following choices are supported:
</p>

<ul>
<li> <p><em>single-start</em>: a named list or named vector of numeric starting values. <code>start</code> is only allowed to
be missing if <code>fn</code> is a <code><a href="stats.html#topic+selfStart">selfStart</a></code> model.
</p>
</li>
<li> <p><em>multi-start</em>: a named list with the (multi-start) parameter starting ranges in the form of length-2
numeric vectors. Can also be a (<code>2</code> by <code>p</code>) named matrix with as columns the numeric starting ranges for the parameters.
Ill-defined parameter ranges such as <code>c(0, Inf)</code> or <code>c(NA, 0)</code> are not allowed.
</p>
</li></ul>
</td></tr>
<tr><td><code id="gsl_nls_+3A_algorithm">algorithm</code></td>
<td>
<p>character string specifying the algorithm to use. The following choices are supported:
</p>

<ul>
<li> <p><code>"lm"</code> Levenberg-Marquardt algorithm (default)
</p>
</li>
<li> <p><code>"lmaccel"</code> Levenberg-Marquardt algorithm with geodesic acceleration.
Can be faster than <code>"lm"</code> but less stable. Stability is controlled by the
<code>avmax</code> parameter in <code>control</code>, setting <code>avmax</code> to zero is analogous
to not using geodesic acceleration.
</p>
</li>
<li> <p><code>"dogleg"</code> Powell's dogleg algorithm
</p>
</li>
<li> <p><code>"ddogleg"</code> Double dogleg algorithm, an improvement over <code>"dogleg"</code>
by including information about the Gauss-Newton step while the iteration is still
far from the minimum.
</p>
</li>
<li> <p><code>"subspace2D"</code> 2D generalization of the dogleg algorithm. This method
searches a larger subspace for a solution, it can converge more quickly than <code>"dogleg"</code>
on some problems.
</p>
</li></ul>
</td></tr>
<tr><td><code id="gsl_nls_+3A_control">control</code></td>
<td>
<p>an optional list of control parameters to tune the least squares iterations and multistart algorithm.
See <code><a href="#topic+gsl_nls_control">gsl_nls_control</a></code> for the available control parameters and their default values.</p>
</td></tr>
<tr><td><code id="gsl_nls_+3A_jac">jac</code></td>
<td>
<p>either <code>NULL</code> (default) or a <a href="base.html#topic+function">function</a> returning the <code>n</code> by <code>p</code> dimensional Jacobian matrix of
the nonlinear model <code>fn</code>, where <code>n</code> is the number of observations and <code>p</code> the
number of parameters. If a function, the first argument must be the vector of parameters of length <code>p</code>.
If <code>NULL</code>, the Jacobian is computed internally using a finite difference approximations.
Can also be <code>TRUE</code>, in which case <code>jac</code> is derived symbolically with <code><a href="stats.html#topic+deriv">deriv</a></code>,
this only works if <code>fn</code> is defined as a (non-selfstarting) formula. If <code>fn</code> is a <code><a href="stats.html#topic+selfStart">selfStart</a></code> model,
the Jacobian specified in the <code>"gradient"</code> attribute of the self-start model is used instead.</p>
</td></tr>
<tr><td><code id="gsl_nls_+3A_fvv">fvv</code></td>
<td>
<p>either <code>NULL</code> (default) or a <a href="base.html#topic+function">function</a> returning an <code>n</code> dimensional vector containing
the second directional derivatives of the nonlinear model <code>fn</code>, with <code>n</code> the number of observations.
This argument is only used if geodesic acceleration is enabled (<code>algorithm = "lmaccel"</code>).
If a function, the first argument must be the vector of parameters of length <code>p</code> and the second argument must be the velocity vector
also of length <code>p</code>. If <code>NULL</code>, the second directional derivative vector is computed internal
using a finite difference approximation. Can also be <code>TRUE</code>, in which case <code>fvv</code> is derived
symbolically with <code><a href="stats.html#topic+deriv">deriv</a></code>, this only works if <code>fn</code> is defined as a (non-selfstarting) formula.
If the model <a href="base.html#topic+function">function</a> in <code>fn</code> also returns a <code>"hessian"</code> attribute (similar to the <code>"gradient"</code> attribute
in a <code>selfStart</code> model), this Hessian matrix is used to evaluate the second directional derivatives instead.</p>
</td></tr>
<tr><td><code id="gsl_nls_+3A_trace">trace</code></td>
<td>
<p>logical value indicating if a trace of the iteration progress should be printed.
Default is <code>FALSE</code>. If <code>TRUE</code>, the residual (weighted) sum-of-squares and the current parameter estimates
are printed after each iteration.</p>
</td></tr>
<tr><td><code id="gsl_nls_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.
This argument is only used if <code>fn</code> is defined as a <a href="stats.html#topic+formula">formula</a>.</p>
</td></tr>
<tr><td><code id="gsl_nls_+3A_weights">weights</code></td>
<td>
<p>an optional numeric vector of (fixed) weights. When present, the objective function is
weighted least squares.</p>
</td></tr>
<tr><td><code id="gsl_nls_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data contain <code>NA</code>s. The
default is set by the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, and is <code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset.
The 'factory-fresh' default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>. Value <code><a href="stats.html#topic+na.exclude">na.exclude</a></code> can be useful.
This argument is only used if <code>fn</code> is defined as a <a href="stats.html#topic+formula">formula</a>.</p>
</td></tr>
<tr><td><code id="gsl_nls_+3A_model">model</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the model frame is returned as part of the object. Defaults to <code>FALSE</code>.
This argument is only used if <code>fn</code> is defined as a <a href="stats.html#topic+formula">formula</a>.</p>
</td></tr>
<tr><td><code id="gsl_nls_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the calls of <code>fn</code>, <code>jac</code> and <code>fvv</code> if
defined as functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>fn</code> is a <code>formula</code> returns a list object of class <code>nls</code>.
If <code>fn</code> is a <code>function</code> returns a list object of class <code>gsl_nls</code>.
See the individual method descriptions for the structures of the returned lists and the generic functions
applicable to objects of both classes.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>gsl_nls(formula)</code>: If <code>fn</code> is a <code>formula</code>, the returned list object is of classes <code>gsl_nls</code> and <code>nls</code>.
Therefore, all generic functions applicable to objects of class <code>nls</code>, such as <code>anova</code>, <code>coef</code>, <code>confint</code>,
<code>deviance</code>, <code>df.residual</code>, <code>fitted</code>, <code>formula</code>, <code>logLik</code>, <code>nobs</code>, <code>predict</code>, <code>print</code>, <code>profile</code>,
<code>residuals</code>, <code>summary</code>, <code>vcov</code> and <code>weights</code> are also applicable to the returned list object.
In addition, a method <code>confintd</code> is available for inference of derived parameters.
</p>
</li>
<li> <p><code>gsl_nls(`function`)</code>: If <code>fn</code> is a <code>function</code>, the first argument must be the vector of parameters and
the function should return a numeric vector containing the nonlinear model evaluations at
the provided parameter and predictor or covariate vectors. In addition, the argument <code>y</code>
needs to contain the numeric vector of observed responses, equal in length to the numeric
vector returned by <code>fn</code>. The returned list object is (only) of class <code>gsl_nls</code>.
Although the returned object is not of class <code>nls</code>, the following generic functions remain
applicable for an object of class <code>gsl_nls</code>: <code>anova</code>, <code>coef</code>, <code>confint</code>, <code>deviance</code>,
<code>df.residual</code>, <code>fitted</code>, <code>formula</code>, <code>logLik</code>, <code>nobs</code>, <code>predict</code>, <code>print</code>,
<code>residuals</code>, <code>summary</code>, <code>vcov</code> and <code>weights</code>. In addition, a method <code>confintd</code>
is available for inference of derived parameters.
</p>
</li></ul>


<h3>Multi-start algorithm</h3>

<p>If <code>start</code> is a list or matrix of parameter ranges, a modified version of the multi-start algorithm described in
Hickernell and Yuan (1997) is applied. Note that the <code>start</code> parameter ranges are only used to bound the domain for the
starting values, i.e. the resulting parameter estimates are not constrained to lie within these bounds. Quasi-random starting values
are sampled in the unit hypercube from a Sobol sequence if <code>p &lt; 41</code> and from a Halton sequence otherwise. The initial starting values
are scaled to the specified parameter ranges using an inverse (scaled) logistic function favoring starting values near the center of the
(scaled) domain. The trust region algorithm as specified by <code>algorithm</code> used for the inexpensive and expensive local search (see Algorithm 2.1 of Hickernell
and Yuan (1997)) are the same, only differing in the number of search iterations <code>mstart_p</code> versus <code>mstart_maxiter</code>, where
<code>mstart_p</code> is typically very small, e.g. 2 or 3. When a new stationary point is detected, the scaling step from the unit hypercube to
the starting value domain is updated using the diagonal of the estimated scaling matrix <code>D</code> in the trust region algorithm, which is
especially useful in sampling starting values when the parameters are living on very different scales. The multi-start algorithm terminates when NSP (number of stationary points)
is larger than or equal to <code>mstart_minsp</code> and NWSP (number of worse stationary points) is larger than or equal to <code>mstart_r</code> times NSP,
or when the maximum number of major iterations <code>mstart_maxstart</code> is reached. After termination of the multi-start algorithm, a full
single-start optimization is executed starting from the optimal parameter values observed during the multi-start procedure.
</p>


<h3>References</h3>

<p>M. Galassi et al., <em>GNU Scientific Library Reference Manual (3rd Ed.)</em>, ISBN 0954612078.
</p>
<p>Hickernell, F.J. and Yuan, Y. (1997) <em>“A simple multistart algorithm for global optimization”</em>, OR Transactions, Vol. 1 (2).
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+nls">nls</a></code>
</p>
<p><a href="https://www.gnu.org/software/gsl/doc/html/nls.html">https://www.gnu.org/software/gsl/doc/html/nls.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1: exponential model
# (https://www.gnu.org/software/gsl/doc/html/nls.html#exponential-fitting-example)

## data
set.seed(1)
n &lt;- 50
x &lt;- (seq_len(n) - 1) * 3 / (n - 1)
f &lt;- function(A, lam, b, x) A * exp(-lam * x) + b
y &lt;- f(A = 5, lam = 1.5, b = 1, x) + rnorm(n, sd = 0.25)

## model fit
ex1_fit &lt;- gsl_nls(
  fn = y ~ A * exp(-lam * x) + b,                        ## model formula
  data = data.frame(x = x, y = y),                       ## model fit data
  start = c(A = 0, lam = 0, b = 0)                       ## starting values
)
summary(ex1_fit)                                         ## model summary
predict(ex1_fit, interval = "prediction")                ## prediction intervals

## multi-start
gsl_nls(
  fn = y ~ A * exp(-lam * x) + b,                             ## model formula
  data = data.frame(x = x, y = y),                            ## model fit data
  start = list(A = c(0, 100), lam = c(0, 10), b = c(-10, 10)) ## starting ranges
)

## analytic Jacobian 1
gsl_nls(
  fn = y ~ A * exp(-lam * x) + b,                        ## model formula
  data = data.frame(x = x, y = y),                       ## model fit data
  start = c(A = 0, lam = 0, b = 0),                      ## starting values
  jac = function(par) with(as.list(par),                 ## jacobian
    cbind(A = exp(-lam * x), lam = -A * x * exp(-lam * x), b = 1)
  )
)

## analytic Jacobian 2
gsl_nls(
  fn = y ~ A * exp(-lam * x) + b,                        ## model formula
  data = data.frame(x = x, y = y),                       ## model fit data
  start = c(A = 0, lam = 0, b = 0),                      ## starting values
  jac = TRUE                                             ## automatic derivation
)

## self-starting model
gsl_nls(
  fn =  y ~ SSasymp(x, Asym, R0, lrc),                   ## model formula
  data = data.frame(x = x, y = y)                        ## model fit data
)

# Example 2: Gaussian function
# (https://www.gnu.org/software/gsl/doc/html/nls.html#geodesic-acceleration-example-2)

## data
set.seed(1)
n &lt;- 300
x &lt;- seq_len(n) / n
f &lt;- function(a, b, c, x) a * exp(-(x - b)^2 / (2 * c^2))
y &lt;- f(a = 5, b = 0.4, c = 0.15, x) * rnorm(n, mean = 1, sd = 0.1)

## Levenberg-Marquardt (default)
gsl_nls(
  fn = y ~ a * exp(-(x - b)^2 / (2 * c^2)),             ## model formula
  data = data.frame(x = x, y = y),                      ## model fit data
  start = c(a = 1, b = 0, c = 1),                       ## starting values
  trace = TRUE                                          ## verbose output
)

## Levenberg-Marquardt w/ geodesic acceleration 1
gsl_nls(
  fn = y ~ a * exp(-(x - b)^2 / (2 * c^2)),             ## model formula
  data = data.frame(x = x, y = y),                      ## model fit data
  start = c(a = 1, b = 0, c = 1),                       ## starting values
  algorithm = "lmaccel",                                ## algorithm
  trace = TRUE                                          ## verbose output
)

## Levenberg-Marquardt w/ geodesic acceleration 2
## second directional derivative
fvv &lt;- function(par, v, x) {
  with(as.list(par), {
    zi &lt;- (x - b) / c
    ei &lt;- exp(-zi^2 / 2)
    2 * v[["a"]] * v[["b"]] * zi / c * ei + 2 * v[["a"]] * v[["c"]] * zi^2 / c * ei -
      v[["b"]]^2 * a / c^2 * (1 - zi^2) * ei -
      2 * v[["b"]] * v[["c"]] * a / c^2 * zi * (2 - zi^2) * ei -
      v[["c"]]^2 * a / c^2 * zi^2 * (3 - zi^2) * ei
  })
}

## analytic fvv 1
gsl_nls(
  fn = y ~ a * exp(-(x - b)^2 / (2 * c^2)),             ## model formula
  data = data.frame(x = x, y = y),                      ## model fit data
  start = c(a = 1, b = 0, c = 1),                       ## starting values
  algorithm = "lmaccel",                                ## algorithm
  trace = TRUE,                                         ## verbose output
  fvv = fvv,                                            ## analytic fvv
  x = x                                                 ## argument passed to fvv
)

## analytic fvv 2
gsl_nls(
  fn = y ~ a * exp(-(x - b)^2 / (2 * c^2)),             ## model formula
  data = data.frame(x = x, y = y),                      ## model fit data
  start = c(a = 1, b = 0, c = 1),                       ## starting values
  algorithm = "lmaccel",                                ## algorithm
  trace = TRUE,                                         ## verbose output
  fvv = TRUE                                            ## automatic derivation
)

# Example 3: Branin function
# (https://www.gnu.org/software/gsl/doc/html/nls.html#comparing-trs-methods-example)

## Branin model function
branin &lt;- function(x) {
  a &lt;- c(-5.1 / (4 * pi^2), 5 / pi, -6, 10, 1 / (8 * pi))
  f1 &lt;- x[2] + a[1] * x[1]^2 + a[2] * x[1] + a[3]
  f2 &lt;- sqrt(a[4] * (1 + (1 - a[5]) * cos(x[1])))
  c(f1, f2)
}

## Dogleg minimization w/ model as function
gsl_nls(
  fn = branin,                   ## model function
  y = c(0, 0),                   ## response vector
  start = c(x1 = 6, x2 = 14.5),  ## starting values
  algorithm = "dogleg"           ## algorithm
)

# Other example problems

nls_test_list()

misra1a &lt;- nls_test_problem(name = "Misra1a")

misra1a_fit &lt;- with(misra1a,
  gsl_nls(
    fn = fn,
    data = data,
    start = start
  )
)

all.equal(coef(misra1a_fit), misra1a$target)

</code></pre>

<hr>
<h2 id='gsl_nls_control'>Tunable Nonlinear Least Squares iteration parameters</h2><span id='topic+gsl_nls_control'></span>

<h3>Description</h3>

<p>Allow the user to tune the characteristics of the <code><a href="#topic+gsl_nls">gsl_nls</a></code> and <code><a href="#topic+gsl_nls_large">gsl_nls_large</a></code>
nonlinear least squares algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsl_nls_control(
  maxiter = 50,
  scale = "more",
  solver = "qr",
  fdtype = "forward",
  factor_up = 2,
  factor_down = 3,
  avmax = 0.75,
  h_df = sqrt(.Machine$double.eps),
  h_fvv = 0.02,
  xtol = sqrt(.Machine$double.eps),
  ftol = sqrt(.Machine$double.eps),
  gtol = .Machine$double.eps^(1/3),
  mstart_n = 25,
  mstart_p = 2,
  mstart_q = 5,
  mstart_r = 3,
  mstart_s = 2,
  mstart_tol = 0.1,
  mstart_maxiter = maxiter%/%3,
  mstart_maxstart = 100,
  mstart_minsp = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsl_nls_control_+3A_maxiter">maxiter</code></td>
<td>
<p>positive integer, termination occurs when the number of iterations reaches <code>maxiter</code>.</p>
</td></tr>
<tr><td><code id="gsl_nls_control_+3A_scale">scale</code></td>
<td>
<p>character, scaling method or damping strategy determining the diagonal scaling matrix D. The following options
are supported:
</p>

<ul>
<li> <p><code>"more"</code> Moré rescaling (default). This method makes the problem scale-invariant and has
been proven effective on a large class of problems.
</p>
</li>
<li> <p><code>"levenberg"</code> Levenberg rescaling. This method has also proven effective on a large class of problems,
but is not scale-invariant. It may perform better for problems susceptible to <em>parameter evaporation</em> (parameters going to infinity).
</p>
</li>
<li> <p><code>"marquardt"</code> Marquardt rescaling. This method is scale-invariant, but it is generally
considered inferior to both the Levenberg and Moré strategies.
</p>
</li></ul>
</td></tr>
<tr><td><code id="gsl_nls_control_+3A_solver">solver</code></td>
<td>
<p>character, method used to solve the linear least squares system resulting as a subproblem in each iteration.
For large-scale problems fitted with <code><a href="#topic+gsl_nls_large">gsl_nls_large</a></code>, the Cholesky solver (<code>"cholesky"</code>) is always selected
and this parameter is not used. For least squares problems fitted with <code><a href="#topic+gsl_nls">gsl_nls</a></code> the following choices are supported:
</p>

<ul>
<li> <p><code>"qr"</code> QR decomposition of the Jacobian (default). This method will produce reliable solutions in cases
where the Jacobian is rank deficient or near-singular but does require more operations than the Cholesky method.
</p>
</li>
<li> <p><code>"cholesky"</code> Cholesky decomposition of the Jacobian. This method is faster than the QR approach, however
it is susceptible to numerical instabilities if the Jacobian matrix is rank deficient or near-singular.
</p>
</li>
<li> <p><code>"svd"</code> SVD decomposition of the Jacobian. This method will produce the most reliable solutions for
ill-conditioned Jacobians but is also the slowest.
</p>
</li></ul>
</td></tr>
<tr><td><code id="gsl_nls_control_+3A_fdtype">fdtype</code></td>
<td>
<p>character, method used to numerically approximate the Jacobian and/or second-order derivatives
when geodesic acceleration is used. Either <code>"forward"</code> for forward finite differencing or <code>"center"</code>
for centered finite differencing. For least squares problems solved with <code><a href="#topic+gsl_nls_large">gsl_nls_large</a></code>, numerical
approximation of the Jacobian matrix is not available and this parameter is only used to numerically approximate
the second-order derivatives (if geodesic acceleration is used).</p>
</td></tr>
<tr><td><code id="gsl_nls_control_+3A_factor_up">factor_up</code></td>
<td>
<p>numeric factor by which to increase the trust region radius when a search step is accepted.
Too large values may destabilize the search, too small values slow down the search, defaults to 2.</p>
</td></tr>
<tr><td><code id="gsl_nls_control_+3A_factor_down">factor_down</code></td>
<td>
<p>numeric factor by which to decrease the trust region radius when a search step is rejected.
Too large values may destabilize the search, too small values slow down the search, defaults to 3.</p>
</td></tr>
<tr><td><code id="gsl_nls_control_+3A_avmax">avmax</code></td>
<td>
<p>numeric value, the ratio of the acceleration term to the velocity term when using geodesic acceleration to
solve the nonlinear least squares problem. Any steps with a ratio larger than <code>avmax</code> are rejected, defaults to 0.75.
For problems which experience difficulty converging, this threshold could be lowered.</p>
</td></tr>
<tr><td><code id="gsl_nls_control_+3A_h_df">h_df</code></td>
<td>
<p>numeric value, the step size for approximating the Jacobian matrix with finite differences, defaults to <code>sqrt(.Machine$double.eps)</code>.</p>
</td></tr>
<tr><td><code id="gsl_nls_control_+3A_h_fvv">h_fvv</code></td>
<td>
<p>numeric value, the step size for approximating the second directional derivative when geodesic acceleration
is used to solve the nonlinear least squares problem, defaults to 0.02. This is only used if no analytic second
directional derivative (<code>fvv</code>) is specified in <code><a href="#topic+gsl_nls">gsl_nls</a></code> or <code><a href="#topic+gsl_nls_large">gsl_nls_large</a></code>.</p>
</td></tr>
<tr><td><code id="gsl_nls_control_+3A_xtol">xtol</code></td>
<td>
<p>numeric value, termination occurs when the relative change in parameters between iterations is <code>&lt;= xtol</code>.
A general guideline for selecting the step tolerance is to choose <code>xtol = 10^(-d)</code> where <code>d</code> is the number of accurate
decimal digits desired in the parameters, defaults to <code>sqrt(.Machine$double.eps)</code>.</p>
</td></tr>
<tr><td><code id="gsl_nls_control_+3A_ftol">ftol</code></td>
<td>
<p>numeric value, termination occurs when the relative change in sum of squared residuals between iterations is <code>&lt;= ftol</code>,
defaults to <code>sqrt(.Machine$double.eps)</code>.</p>
</td></tr>
<tr><td><code id="gsl_nls_control_+3A_gtol">gtol</code></td>
<td>
<p>numeric value, termination occurs when the relative size of the gradient of the sum of squared residuals is <code>&lt;= gtol</code>,
indicating a local minimum, defaults to <code>.Machine$double.eps^(1/3)</code></p>
</td></tr>
<tr><td><code id="gsl_nls_control_+3A_mstart_n">mstart_n</code></td>
<td>
<p>positive integer, number of quasirandom points drawn in each major iteration, parameter <code>N</code> in Hickernell and Yuan (1997). Default is 25.</p>
</td></tr>
<tr><td><code id="gsl_nls_control_+3A_mstart_p">mstart_p</code></td>
<td>
<p>positive integer, number of iterations of inexpensive local search to concentrate the sample, parameter <code>p</code> in Hickernell and Yuan (1997). Default is 2.</p>
</td></tr>
<tr><td><code id="gsl_nls_control_+3A_mstart_q">mstart_q</code></td>
<td>
<p>positiver integer, number of points retained in the concentrated sample, parameter <code>q</code> in Hickernell and Yuan (1997). Default is 5.</p>
</td></tr>
<tr><td><code id="gsl_nls_control_+3A_mstart_r">mstart_r</code></td>
<td>
<p>positive integer, scaling factor of number of stationary points determining when the multi-start algorithm terminates, parameter <code>r</code> in Hickernell and Yuan (1997). Default is 3.</p>
</td></tr>
<tr><td><code id="gsl_nls_control_+3A_mstart_s">mstart_s</code></td>
<td>
<p>positive integer, minimum number of iterations a point needs to be retained before starting an efficient local search, parameter <code>s</code> in Hickernell and Yuan (1997). Default is 2.</p>
</td></tr>
<tr><td><code id="gsl_nls_control_+3A_mstart_tol">mstart_tol</code></td>
<td>
<p>numeric value, tolerance used as criterion to start an efficient local search (epsilon in Algorithm 2.1, Hickernell and Yuan (1997)).</p>
</td></tr>
<tr><td><code id="gsl_nls_control_+3A_mstart_maxiter">mstart_maxiter</code></td>
<td>
<p>positive integer, maximum number of iterations in the efficient local search algorithm (Algorithm B, Hickernell and Yuan (1997)), defaults to <code>maxiter %/% 3</code>.</p>
</td></tr>
<tr><td><code id="gsl_nls_control_+3A_mstart_maxstart">mstart_maxstart</code></td>
<td>
<p>positive integer, minimum number of major iterations (Algorithm 2.1, Hickernell and Yuan (1997)) before the multi-start algorithm terminates, defaults to 100.</p>
</td></tr>
<tr><td><code id="gsl_nls_control_+3A_mstart_minsp">mstart_minsp</code></td>
<td>
<p>positive integer, minimum number of detected stationary points before the multi-start algorithm terminates, defaults to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with exactly twenty-one components:
</p>

<ul>
<li><p> maxiter
</p>
</li>
<li><p> scale
</p>
</li>
<li><p> solver
</p>
</li>
<li><p> fdtype
</p>
</li>
<li><p> factor_up
</p>
</li>
<li><p> factor_down
</p>
</li>
<li><p> avmax
</p>
</li>
<li><p> h_df
</p>
</li>
<li><p> h_fvv
</p>
</li>
<li><p> xtol
</p>
</li>
<li><p> ftol
</p>
</li>
<li><p> gtol
</p>
</li>
<li><p> mstart_n
</p>
</li>
<li><p> mstart_p
</p>
</li>
<li><p> mstart_q
</p>
</li>
<li><p> mstart_r
</p>
</li>
<li><p> mstart_s
</p>
</li>
<li><p> mstart_tol
</p>
</li>
<li><p> mstart_maxiter
</p>
</li>
<li><p> mstart_maxstart
</p>
</li>
<li><p> mstart_minsp
</p>
</li></ul>

<p>with meanings as explained under 'Arguments'.
</p>


<h3>Note</h3>

<p><code>ftol</code> is disabled in some versions of the GSL library.
</p>


<h3>References</h3>

<p>M. Galassi et al., <em>GNU Scientific Library Reference Manual (3rd Ed.)</em>, ISBN 0954612078.
</p>
<p>Hickernell, F.J. and Yuan, Y. (1997) <em>“A simple multistart algorithm for global optimization”</em>, OR Transactions, Vol. 1 (2).
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+nls.control">nls.control</a></code>
</p>
<p><a href="https://www.gnu.org/software/gsl/doc/html/nls.html#tunable-parameters">https://www.gnu.org/software/gsl/doc/html/nls.html#tunable-parameters</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## default tuning parameters
gsl_nls_control()
</code></pre>

<hr>
<h2 id='gsl_nls_large'>GSL Large-scale Nonlinear Least Squares fitting</h2><span id='topic+gsl_nls_large'></span><span id='topic+gsl_nls_large.formula'></span><span id='topic+gsl_nls_large.function'></span>

<h3>Description</h3>

<p>Determine the nonlinear least-squares estimates of the parameters of a large
nonlinear model system using the <code>gsl_multilarge_nlinear</code> module present in
the GNU Scientific Library (GSL).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsl_nls_large(fn, ...)

## S3 method for class 'formula'
gsl_nls_large(
  fn,
  data = parent.frame(),
  start,
  algorithm = c("lm", "lmaccel", "dogleg", "ddogleg", "subspace2D", "cgst"),
  control = gsl_nls_control(),
  jac,
  fvv,
  trace = FALSE,
  subset,
  weights,
  na.action,
  model = FALSE,
  ...
)

## S3 method for class ''function''
gsl_nls_large(
  fn,
  y,
  start,
  algorithm = c("lm", "lmaccel", "dogleg", "ddogleg", "subspace2D", "cgst"),
  control = gsl_nls_control(),
  jac,
  fvv,
  trace = FALSE,
  weights,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsl_nls_large_+3A_fn">fn</code></td>
<td>
<p>a nonlinear model defined either as a two-sided <a href="stats.html#topic+formula">formula</a> including variables and parameters,
or as a <a href="base.html#topic+function">function</a> returning a numeric vector, with first argument the vector of parameters to be estimated.
See the individual method descriptions below.</p>
</td></tr>
<tr><td><code id="gsl_nls_large_+3A_data">data</code></td>
<td>
<p>an optional data frame in which to evaluate the variables in <code>fn</code> if
defined as a <a href="stats.html#topic+formula">formula</a>. Can also be a list or an environment, but not a matrix.</p>
</td></tr>
<tr><td><code id="gsl_nls_large_+3A_y">y</code></td>
<td>
<p>numeric response vector if <code>fn</code> is defined as a <a href="base.html#topic+function">function</a>, equal in
length to the vector returned by evaluation of the function <code>fn</code>.</p>
</td></tr>
<tr><td><code id="gsl_nls_large_+3A_start">start</code></td>
<td>
<p>a named list or named numeric vector of starting estimates. <code>start</code> is
only allowed to be missing if <code>fn</code> is a <code><a href="stats.html#topic+selfStart">selfStart</a></code> model. If <code>fn</code>
is a <code>formula</code>, a naive guess for <code>start</code> is tried, but this should not be relied on.</p>
</td></tr>
<tr><td><code id="gsl_nls_large_+3A_algorithm">algorithm</code></td>
<td>
<p>character string specifying the algorithm to use. The following choices are supported:
</p>

<ul>
<li> <p><code>"lm"</code> Levenberg-Marquardt algorithm (default)
</p>
</li>
<li> <p><code>"lmaccel"</code> Levenberg-Marquardt algorithm with geodesic acceleration.
Can be faster than <code>"lm"</code> but less stable. Stability is controlled by the
<code>avmax</code> parameter in <code>control</code>, setting <code>avmax</code> to zero is analogous
to not using geodesic acceleration.
</p>
</li>
<li> <p><code>"dogleg"</code> Powell's dogleg algorithm
</p>
</li>
<li> <p><code>"ddogleg"</code> Double dogleg algorithm, an improvement over <code>"dogleg"</code>
by including information about the Gauss-Newton step while the iteration is still
far from the minimum.
</p>
</li>
<li> <p><code>"subspace2D"</code> 2D generalization of the dogleg algorithm. This method
searches a larger subspace for a solution, it can converge more quickly than <code>"dogleg"</code>
on some problems.
</p>
</li>
<li> <p><code>"cgst"</code> Steihaug-Toint Conjugate Gradient algorithm, a generalization of the dogleg algorithm
that avoids solving for the Gauss-Newton step directly, instead using an iterative conjugate gradient algorithm.
The method performs well at points where the Jacobian is singular, and is also suitable for large-scale problems
where factoring the Jacobian matrix is prohibitively expensive.
</p>
</li></ul>
</td></tr>
<tr><td><code id="gsl_nls_large_+3A_control">control</code></td>
<td>
<p>an optional list of control parameters to tune the least squares iterations and multistart algorithm.
See <code><a href="#topic+gsl_nls_control">gsl_nls_control</a></code> for the available control parameters and their default values.</p>
</td></tr>
<tr><td><code id="gsl_nls_large_+3A_jac">jac</code></td>
<td>
<p>a <a href="base.html#topic+function">function</a> returning the <code>n</code> by <code>p</code> dimensional Jacobian matrix of
the nonlinear model <code>fn</code>, where <code>n</code> is the number of observations and <code>p</code> the
number of parameters. The first argument must be the vector of parameters of length <code>p</code>.
Can also be <code>TRUE</code>, in which case <code>jac</code> is derived symbolically with <code><a href="stats.html#topic+deriv">deriv</a></code>,
this only works if <code>fn</code> is defined as a (non-selfstarting) formula. If <code>fn</code> is a <code><a href="stats.html#topic+selfStart">selfStart</a></code> model,
the Jacobian specified in the <code>"gradient"</code> attribute of the self-start model is used instead.</p>
</td></tr>
<tr><td><code id="gsl_nls_large_+3A_fvv">fvv</code></td>
<td>
<p>a <a href="base.html#topic+function">function</a> returning an <code>n</code> dimensional vector containing
the second directional derivatives of the nonlinear model <code>fn</code>, with <code>n</code> the number of observations.
This argument is only used if geodesic acceleration is enabled (<code>algorithm = "lmaccel"</code>).
The first argument must be the vector of parameters of length <code>p</code> and the second argument must be the velocity vector
also of length <code>p</code>. Can also be <code>TRUE</code>, in which case <code>fvv</code> is derived
symbolically with <code><a href="stats.html#topic+deriv">deriv</a></code>, this only works if <code>fn</code> is defined as a (non-selfstarting) formula.
If the model <a href="base.html#topic+function">function</a> in <code>fn</code> also returns a <code>"hessian"</code> attribute (similar to the <code>"gradient"</code> attribute
in a <code>selfStart</code> model), this Hessian matrix is used to evaluate the second directional derivatives instead.</p>
</td></tr>
<tr><td><code id="gsl_nls_large_+3A_trace">trace</code></td>
<td>
<p>logical value indicating if a trace of the iteration progress should be printed.
Default is <code>FALSE</code>. If <code>TRUE</code>, the residual (weighted) sum-of-squares,
the squared (Euclidean) norm of the current parameter estimates and the condition number of the Jacobian
are printed after each iteration.</p>
</td></tr>
<tr><td><code id="gsl_nls_large_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.
This argument is only used if <code>fn</code> is defined as a <a href="stats.html#topic+formula">formula</a>.</p>
</td></tr>
<tr><td><code id="gsl_nls_large_+3A_weights">weights</code></td>
<td>
<p>an optional numeric vector of (fixed) weights. When present, the objective function is
weighted least squares.</p>
</td></tr>
<tr><td><code id="gsl_nls_large_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data contain <code>NA</code>s. The
default is set by the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, and is <code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset.
The 'factory-fresh' default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>. Value <code><a href="stats.html#topic+na.exclude">na.exclude</a></code> can be useful.
This argument is only used if <code>fn</code> is defined as a <a href="stats.html#topic+formula">formula</a>.</p>
</td></tr>
<tr><td><code id="gsl_nls_large_+3A_model">model</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the model frame is returned as part of the object. Defaults to <code>FALSE</code>.
This argument is only used if <code>fn</code> is defined as a <a href="stats.html#topic+formula">formula</a>.</p>
</td></tr>
<tr><td><code id="gsl_nls_large_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the calls of <code>fn</code>, <code>jac</code> and <code>fvv</code> if
defined as functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>fn</code> is a <code>formula</code> returns a list object of class <code>nls</code>.
If <code>fn</code> is a <code>function</code> returns a list object of class <code>gsl_nls</code>.
See the individual method descriptions for the structures of the returned lists and the generic functions
applicable to objects of both classes.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>gsl_nls_large(formula)</code>: If <code>fn</code> is a <code>formula</code>, the returned list object is of classes <code>gsl_nls</code> and <code>nls</code>.
Therefore, all generic functions applicable to objects of class <code>nls</code>, such as <code>anova</code>, <code>coef</code>, <code>confint</code>,
<code>deviance</code>, <code>df.residual</code>, <code>fitted</code>, <code>formula</code>, <code>logLik</code>, <code>nobs</code>, <code>predict</code>, <code>print</code>, <code>profile</code>,
<code>residuals</code>, <code>summary</code>, <code>vcov</code> and <code>weights</code> are also applicable to the returned list object.
In addition, a method <code>confintd</code> is available for inference of derived parameters.
</p>
</li>
<li> <p><code>gsl_nls_large(`function`)</code>: If <code>fn</code> is a <code>function</code>, the first argument must be the vector of parameters and
the function should return a numeric vector containing the nonlinear model evaluations at
the provided parameter and predictor or covariate vectors. In addition, the argument <code>y</code>
needs to contain the numeric vector of observed responses, equal in length to the numeric
vector returned by <code>fn</code>. The returned list object is (only) of class <code>gsl_nls</code>.
Although the returned object is not of class <code>nls</code>, the following generic functions remain
applicable for an object of class <code>gsl_nls</code>: <code>anova</code>, <code>coef</code>, <code>confint</code>, <code>deviance</code>,
<code>df.residual</code>, <code>fitted</code>, <code>formula</code>, <code>logLik</code>, <code>nobs</code>, <code>predict</code>, <code>print</code>,
<code>residuals</code>, <code>summary</code>, <code>vcov</code> and <code>weights</code>. In addition, a method <code>confintd</code>
is available for inference of derived parameters.
</p>
</li></ul>


<h3>References</h3>

<p>M. Galassi et al., <em>GNU Scientific Library Reference Manual (3rd Ed.)</em>, ISBN 0954612078.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsl_nls">gsl_nls</a></code>
</p>
<p><a href="https://www.gnu.org/software/gsl/doc/html/nls.html">https://www.gnu.org/software/gsl/doc/html/nls.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Large NLS example
# (https://www.gnu.org/software/gsl/doc/html/nls.html#large-nonlinear-least-squares-example)

## number of parameters
p &lt;- 250

## model function
f &lt;- function(theta) {
  c(sqrt(1e-5) * (theta - 1), sum(theta^2) - 0.25)
}

## jacobian function
jac &lt;- function(theta) {
  rbind(diag(sqrt(1e-5), nrow = length(theta)), 2 * t(theta))
}

## dense Levenberg-Marquardt
gsl_nls_large(
  fn = f,                       ## model
  y = rep(0, p + 1),            ## (dummy) responses
  start = 1:p,                  ## start values
  algorithm = "lm",             ## algorithm
  jac = jac,                    ## jacobian
  control = list(maxiter = 250)
)

## dense Steihaug-Toint conjugate gradient
gsl_nls_large(
  fn = f,                       ## model
  y = rep(0, p + 1),            ## (dummy) responses
  start = 1:p,                  ## start values
  jac = jac,                    ## jacobian
  algorithm = "cgst"            ## algorithm
)

## sparse Jacobian function
jacsp &lt;- function(theta) {
  rbind(Matrix::Diagonal(x = sqrt(1e-5), n = length(theta)), 2 * t(theta))
}

## sparse Levenberg-Marquardt
gsl_nls_large(
  fn = f,                       ## model
  y = rep(0, p + 1),            ## (dummy) responses
  start = 1:p,                  ## start values
  algorithm = "lm",             ## algorithm
  jac = jacsp,                  ## sparse jacobian
  control = list(maxiter = 250)
)

## sparse Steihaug-Toint conjugate gradient
gsl_nls_large(
  fn = f,                       ## model
  y = rep(0, p + 1),            ## (dummy) responses
  start = 1:p,                  ## start values
  jac = jacsp,                  ## sparse jacobian
  algorithm = "cgst"            ## algorithm
)

</code></pre>

<hr>
<h2 id='logLik.gsl_nls'>Extract model log-likelihood</h2><span id='topic+logLik.gsl_nls'></span>

<h3>Description</h3>

<p>Returns the model log-likelihood of a fitted <code>"gsl_nls"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gsl_nls'
logLik(object, REML = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.gsl_nls_+3A_object">object</code></td>
<td>
<p>An object inheriting from class <code>"gsl_nls"</code>.</p>
</td></tr>
<tr><td><code id="logLik.gsl_nls_+3A_reml">REML</code></td>
<td>
<p>logical value; included for compatibility reasons only, should not be used.</p>
</td></tr>
<tr><td><code id="logLik.gsl_nls_+3A_...">...</code></td>
<td>
<p>At present no optional arguments are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric object of class <code>"logLik"</code> identical to <code><a href="stats.html#topic+logLik">logLik</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+logLik">logLik</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data
set.seed(1)
n &lt;- 50
xy &lt;- data.frame(
  x = (1:n) / n,
  y = 2.5 * exp(-1.5 * (1:n) / n) + rnorm(n, sd = 0.1)
)
## model
obj &lt;- gsl_nls(fn = y ~ A * exp(-lam * x), data = xy, start = c(A = 1, lam = 1))

logLik(obj)
</code></pre>

<hr>
<h2 id='nls_test_list'>Available NLS test problems</h2><span id='topic+nls_test_list'></span>

<h3>Description</h3>

<p>Returns an overview of 56 NLS test problems originating primarily from the NIST Statistical Reference Datasets (StRD)
archive and More, Garbow and Hillstrom (1981).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nls_test_list(fields = c("name", "class", "p", "n", "check"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nls_test_list_+3A_fields">fields</code></td>
<td>
<p>optional character vector to return a subset of columns in the <a href="base.html#topic+data.frame">data.frame</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="base.html#topic+data.frame">data.frame</a> with high-level information about the available test problems. The following columns are returned by default:
</p>

<ul>
<li> <p><code>"name"</code> Name of the test problem for use in <code><a href="#topic+nls_test_problem">nls_test_problem</a></code>.
</p>
</li>
<li> <p><code>"class"</code> Either <code>"formula"</code> if the model is defined as a <a href="stats.html#topic+formula">formula</a> or <code>"function"</code> if defined as a <a href="base.html#topic+function">function</a>.
</p>
</li>
<li> <p><code>"p"</code> Default number of parameters in the test problem.
</p>
</li>
<li> <p><code>"n"</code> Default number of residuals in the test problem.
</p>
</li>
<li> <p><code>"check"</code> One of the following three options: (1) <code>"p, n fixed"</code> if the listed values for <code>p</code> and <code>n</code> are the only ones possible;
(2) <code>"p &lt;= n free"</code> if the values for <code>p</code> and <code>n</code> are not fixed, but <code>p</code> must be smaller or equal to <code>n</code>;
(3) <code>"p == n free"</code> if the values for <code>p</code> and <code>n</code> are not fixed, but <code>p</code> must be equal to <code>n</code>.
</p>
</li></ul>



<h3>References</h3>

<p>J.J. Moré, Garbow, B.S. and Hillstrom, K.E. (1981). <em>Testing unconstrained optimization software</em>, ACM Transactions on Mathematical Software, 7(1), 17-41.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nls_test_problem">nls_test_problem</a></code>
</p>
<p><a href="https://www.itl.nist.gov/div898/strd/nls/nls_main.shtml">https://www.itl.nist.gov/div898/strd/nls/nls_main.shtml</a>
</p>
<p><a href="https://people.math.sc.edu/Burkardt/f_src/test_nls/test_nls.html">https://people.math.sc.edu/Burkardt/f_src/test_nls/test_nls.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## available test problems
nls_test_list()
</code></pre>

<hr>
<h2 id='nls_test_problem'>Retrieve an NLS test problem</h2><span id='topic+nls_test_problem'></span>

<h3>Description</h3>

<p>Fetches the model definition and model data required to solve a single NLS test problem with <code><a href="#topic+gsl_nls">gsl_nls</a></code>
(or <code><a href="stats.html#topic+nls">nls</a></code> if the model is defined as a <a href="stats.html#topic+formula">formula</a>). Use <code><a href="#topic+nls_test_list">nls_test_list</a></code> to
list the names of the available NLS test problems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nls_test_problem(name, p = NA, n = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nls_test_problem_+3A_name">name</code></td>
<td>
<p>Name of the NLS test problem, as returned in the <code>"name"</code> column of <code><a href="#topic+nls_test_list">nls_test_list</a></code>.</p>
</td></tr>
<tr><td><code id="nls_test_problem_+3A_p">p</code></td>
<td>
<p>The number of parameters in the NLS test problem constrained by the <code>check</code> condition returned by <code><a href="#topic+nls_test_list">nls_test_list</a></code>.
If <code>NA</code> (default), the default number of parameters as listed by <code><a href="#topic+nls_test_list">nls_test_list</a></code> is used.</p>
</td></tr>
<tr><td><code id="nls_test_problem_+3A_n">n</code></td>
<td>
<p>The number of residuals in the NLS test problem constrained by the <code>check</code> condition returned by <code><a href="#topic+nls_test_list">nls_test_list</a></code>.
If <code>NA</code> (default), the default number of residuals as listed by <code><a href="#topic+nls_test_list">nls_test_list</a></code> is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the model is defined as a <a href="stats.html#topic+formula">formula</a>, a <a href="base.html#topic+list">list</a> of class <code>"nls_test_formula"</code> with elements:
</p>

<ul>
<li> <p><code>data</code> a data.frame with <code>n</code> rows containing the data (predictor and response values) used in the regression problem.
</p>
</li>
<li> <p><code>fn</code> a <a href="stats.html#topic+formula">formula</a> defining the test problem model.
</p>
</li>
<li> <p><code>start</code> a named vector of length <code>p</code> with suggested starting values for the parameters.
</p>
</li>
<li> <p><code>target</code> a named vector of length <code>p</code> with the certified target values for the parameters corresponding to the
<em>best-available</em> solutions.
</p>
</li></ul>

<p>If the model is defined as a <a href="base.html#topic+function">function</a>, a <a href="base.html#topic+list">list</a> of class <code>"nls_test_function"</code> with elements:
</p>

<ul>
<li> <p><code>fn</code> a <a href="base.html#topic+function">function</a> defining the test problem model. <code>fn</code> takes a vector of parameters
of length <code>p</code> as its first argument and returns a numeric vector of length <code>n</code>.
<code>fn</code>
</p>
</li>
<li> <p><code>y</code> a numeric vector of length <code>n</code> containing the response values.
</p>
</li>
<li> <p><code>start</code> a numeric named vector of length <code>p</code> with suggested starting values for the parameters.
</p>
</li>
<li> <p><code>jac</code> a <a href="base.html#topic+function">function</a> defining the analytic Jacobian matrix of the model <code>fn</code>. <code>jac</code>
takes a vector of parameters of length <code>p</code> as its first argument and returns an <code>n</code> by <code>p</code> dimensional matrix.
</p>
</li>
<li> <p><code>target</code> a numeric named vector of length <code>p</code> with the certified target values for the parameters, or a vector of
<code>NA</code>'s if no target solution is available.
</p>
</li></ul>



<h3>References</h3>

<p>J.J. Moré, Garbow, B.S. and Hillstrom, K.E. (1981). <em>Testing unconstrained optimization software</em>, ACM Transactions on Mathematical Software, 7(1), 17-41.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nls_test_list">nls_test_list</a></code>
</p>
<p><a href="https://www.itl.nist.gov/div898/strd/nls/nls_main.shtml">https://www.itl.nist.gov/div898/strd/nls/nls_main.shtml</a>
</p>
<p><a href="https://people.math.sc.edu/Burkardt/f_src/test_nls/test_nls.html">https://people.math.sc.edu/Burkardt/f_src/test_nls/test_nls.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example regression problem
ratkowsky2 &lt;- nls_test_problem(name = "Ratkowsky2")
with(ratkowsky2,
     gsl_nls(
       fn = fn,
       data = data,
       start = start
     )
)

## example optimization problem
rosenbrock &lt;- nls_test_problem(name = "Rosenbrock")
with(rosenbrock,
     gsl_nls(
       fn = fn,
       y = y,
       start = start,
       jac = jac
     )
)
</code></pre>

<hr>
<h2 id='nobs.gsl_nls'>Extract the number of observations</h2><span id='topic+nobs.gsl_nls'></span>

<h3>Description</h3>

<p>Returns the number of <em>observations</em> from a <code>"gsl_nls"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gsl_nls'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nobs.gsl_nls_+3A_object">object</code></td>
<td>
<p>An object inheriting from class <code>"gsl_nls"</code>.</p>
</td></tr>
<tr><td><code id="nobs.gsl_nls_+3A_...">...</code></td>
<td>
<p>At present no optional arguments are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer number of observations similar to <code><a href="stats.html#topic+nobs">nobs</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+nobs">nobs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data
set.seed(1)
n &lt;- 50
xy &lt;- data.frame(
  x = (1:n) / n,
  y = 2.5 * exp(-1.5 * (1:n) / n) + rnorm(n, sd = 0.1)
)
## model
obj &lt;- gsl_nls(fn = y ~ A * exp(-lam * x), data = xy, start = c(A = 1, lam = 1))

nobs(obj)
</code></pre>

<hr>
<h2 id='predict.gsl_nls'>Calculate model predicted values</h2><span id='topic+predict.gsl_nls'></span>

<h3>Description</h3>

<p>Returns predicted values for the expected response from a fitted <code>"gsl_nls"</code> object.
Asymptotic confidence or prediction (tolerance) intervals at a given <code>level</code> can be evaluated
by specifying the appropriate <code>interval</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gsl_nls'
predict(
  object,
  newdata,
  scale = NULL,
  interval = c("none", "confidence", "prediction"),
  level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.gsl_nls_+3A_object">object</code></td>
<td>
<p>An object inheriting from class <code>"gsl_nls"</code>.</p>
</td></tr>
<tr><td><code id="predict.gsl_nls_+3A_newdata">newdata</code></td>
<td>
<p>A named list or data.frame in which to look for variables with which to predict. If
<code>newdata</code> is missing, the predicted values at the original data points are returned.</p>
</td></tr>
<tr><td><code id="predict.gsl_nls_+3A_scale">scale</code></td>
<td>
<p>A numeric scalar or vector. If it is set, it is used as the residual standard deviation
(or vector of residual standard deviations) in the computation of the standard errors, otherwise
this information is extracted from the model fit.</p>
</td></tr>
<tr><td><code id="predict.gsl_nls_+3A_interval">interval</code></td>
<td>
<p>A character string indicating if confidence or prediction (tolerance) intervals
at the specified level should be returned.</p>
</td></tr>
<tr><td><code id="predict.gsl_nls_+3A_level">level</code></td>
<td>
<p>A numeric scalar between 0 and 1 giving the confidence level for the intervals (if any)
to be calculated.</p>
</td></tr>
<tr><td><code id="predict.gsl_nls_+3A_...">...</code></td>
<td>
<p>At present no optional arguments are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>interval = "none"</code> (default), a vector of predictions for the mean response. Otherwise,
a matrix with columns <code>fit</code>, <code>lwr</code> and <code>upr</code>. The first column (<code>fit</code>) contains
predictions for the mean response. The other two columns contain lower (<code>lwr</code>) and upper (<code>upr</code>)
confidence or prediction bounds at the specified <code>level</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict.nls">predict.nls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data
set.seed(1)
n &lt;- 50
xy &lt;- data.frame(
  x = (1:n) / n,
  y = 2.5 * exp(-1.5 * (1:n) / n) + rnorm(n, sd = 0.1)
)
## model
obj &lt;- gsl_nls(fn = y ~ A * exp(-lam * x), data = xy, start = c(A = 1, lam = 1))

predict(obj)
predict(obj, newdata = data.frame(x = 1:(2 * n) / n))
predict(obj, interval = "confidence")
predict(obj, interval = "prediction", level = 0.99)
</code></pre>

<hr>
<h2 id='residuals.gsl_nls'>Extract model residuals</h2><span id='topic+residuals.gsl_nls'></span>

<h3>Description</h3>

<p>Returns the model residuals from a fitted <code>"gsl_nls"</code> object.
<code>resid</code> can also be used as an alias.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gsl_nls'
residuals(object, type = c("response", "pearson"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.gsl_nls_+3A_object">object</code></td>
<td>
<p>An object inheriting from class <code>"gsl_nls"</code>.</p>
</td></tr>
<tr><td><code id="residuals.gsl_nls_+3A_type">type</code></td>
<td>
<p>character; if <code>"response"</code> the raw residuals are returned, if <code>"pearson"</code>
the Pearson are returned, i.e. the raw residuals divided by their standard error.</p>
</td></tr>
<tr><td><code id="residuals.gsl_nls_+3A_...">...</code></td>
<td>
<p>At present no optional arguments are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of model residuals similar to <code><a href="stats.html#topic+residuals">residuals</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+residuals">residuals</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data
set.seed(1)
n &lt;- 50
xy &lt;- data.frame(
  x = (1:n) / n,
  y = 2.5 * exp(-1.5 * (1:n) / n) + rnorm(n, sd = 0.1)
)
## model
obj &lt;- gsl_nls(fn = y ~ A * exp(-lam * x), data = xy, start = c(A = 1, lam = 1))

residuals(obj)
</code></pre>

<hr>
<h2 id='sigma.gsl_nls'>Residual standard deviation</h2><span id='topic+sigma.gsl_nls'></span>

<h3>Description</h3>

<p>Returns the estimated (unweighted) residual standard deviation of a fitted <code>"gsl_nls"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gsl_nls'
sigma(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigma.gsl_nls_+3A_object">object</code></td>
<td>
<p>An object inheriting from class <code>"gsl_nls"</code>.</p>
</td></tr>
<tr><td><code id="sigma.gsl_nls_+3A_...">...</code></td>
<td>
<p>At present no optional arguments are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric residual standard deviation value similar to <code><a href="stats.html#topic+sigma">sigma</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+sigma">sigma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data
set.seed(1)
n &lt;- 50
xy &lt;- data.frame(
  x = (1:n) / n,
  y = 2.5 * exp(-1.5 * (1:n) / n) + rnorm(n, sd = 0.1)
)
## model
obj &lt;- gsl_nls(fn = y ~ A * exp(-lam * x), data = xy, start = c(A = 1, lam = 1))

sigma(obj)
</code></pre>

<hr>
<h2 id='summary.gsl_nls'>Model summary</h2><span id='topic+summary.gsl_nls'></span>

<h3>Description</h3>

<p>Returns the model summary for a fitted <code>"gsl_nls"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gsl_nls'
summary(object, correlation = FALSE, symbolic.cor = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gsl_nls_+3A_object">object</code></td>
<td>
<p>An object inheriting from class <code>"gsl_nls"</code>.</p>
</td></tr>
<tr><td><code id="summary.gsl_nls_+3A_correlation">correlation</code></td>
<td>
<p>logical; if <code>TRUE</code>, the correlation matrix of the estimated
parameters is returned and printed.</p>
</td></tr>
<tr><td><code id="summary.gsl_nls_+3A_symbolic.cor">symbolic.cor</code></td>
<td>
<p>logical; if <code>TRUE</code>, print the correlations in a symbolic form
(see <code><a href="stats.html#topic+symnum">symnum</a></code>) rather than as numbers.</p>
</td></tr>
<tr><td><code id="summary.gsl_nls_+3A_...">...</code></td>
<td>
<p>At present no optional arguments are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List object of class <code>"summary.nls"</code> identical to <code><a href="stats.html#topic+summary.nls">summary.nls</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+summary.nls">summary.nls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data
set.seed(1)
n &lt;- 50
xy &lt;- data.frame(
  x = (1:n) / n,
  y = 2.5 * exp(-1.5 * (1:n) / n) + rnorm(n, sd = 0.1)
)
## model
obj &lt;- gsl_nls(fn = y ~ A * exp(-lam * x), data = xy, start = c(A = 1, lam = 1))

summary(obj)
</code></pre>

<hr>
<h2 id='vcov.gsl_nls'>Calculate variance-covariance matrix</h2><span id='topic+vcov.gsl_nls'></span>

<h3>Description</h3>

<p>Returns the estimated variance-covariance matrix of the model parameters
from a fitted <code>"gsl_nls"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gsl_nls'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.gsl_nls_+3A_object">object</code></td>
<td>
<p>An object inheriting from class <code>"gsl_nls"</code>.</p>
</td></tr>
<tr><td><code id="vcov.gsl_nls_+3A_...">...</code></td>
<td>
<p>At present no optional arguments are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the estimated covariances between the parameter estimates similar
to <code><a href="stats.html#topic+vcov">vcov</a></code> with row and column names corresponding to the parameter names given by <code><a href="#topic+coef.gsl_nls">coef.gsl_nls</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+vcov">vcov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data
set.seed(1)
n &lt;- 50
xy &lt;- data.frame(
  x = (1:n) / n,
  y = 2.5 * exp(-1.5 * (1:n) / n) + rnorm(n, sd = 0.1)
)
## model
obj &lt;- gsl_nls(fn = y ~ A * exp(-lam * x), data = xy, start = c(A = 1, lam = 1))

vcov(obj)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
