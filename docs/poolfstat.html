<!DOCTYPE html><html><head><title>Help for package poolfstat</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {poolfstat}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#poolfstat'><p>PoolFstat</p></a></li>
<li><a href='#add.leaf'><p>Test all possible connection of a leaf to a graph with non-admixed and or admixed edges</p></a></li>
<li><a href='#bjack_cov'><p>bjack_cov</p></a></li>
<li><a href='#compare.fitted.fstats'><p>Compare fitted f2, f3 and f4 f-statistics of an admixture graph with estimated ones</p></a></li>
<li><a href='#compute_blockDdenom'><p>compute_blockDdenom</p></a></li>
<li><a href='#compute_Ddenom'><p>compute_Ddenom</p></a></li>
<li><a href='#compute_Ddenom_bjmeans'><p>compute_Ddenom_bjmeans</p></a></li>
<li><a href='#compute_F2_bjmeans'><p>compute_F2_bjmeans</p></a></li>
<li><a href='#compute_F3fromF2'><p>compute_F3fromF2</p></a></li>
<li><a href='#compute_F3fromF2samples'><p>compute_F3fromF2samples</p></a></li>
<li><a href='#compute_F4DfromF2samples'><p>compute_F4DfromF2samples</p></a></li>
<li><a href='#compute_F4fromF2'><p>compute_F4fromF2</p></a></li>
<li><a href='#compute_F4fromF2samples'><p>compute_F4fromF2samples</p></a></li>
<li><a href='#compute_H1'><p>compute_H1</p></a></li>
<li><a href='#compute_Q_bjmeans'><p>compute_Q_bjmeans</p></a></li>
<li><a href='#compute_Q2'><p>compute_Q2</p></a></li>
<li><a href='#compute_QmatfromF2samples'><p>compute_QmatfromF2samples</p></a></li>
<li><a href='#compute.f4ratio'><p>Compute F4ratio (estimation of admixture rate) from an fstats object</p></a></li>
<li><a href='#compute.fstats'><p>Estimate the F-statistics (F2, F3, F3star, F4, Dstat) and within and across population diversity</p></a></li>
<li><a href='#compute.pairwiseFST'><p>Compute pairwise population population FST matrix (and possibly all pairwise SNP-specific FST)</p></a></li>
<li><a href='#computeFST'><p>Compute FST from Pool-Seq data or Count data</p></a></li>
<li><a href='#countdata-class'><p>S4 class to represent a Count data set.</p></a></li>
<li><a href='#countdata.subset'><p>Create a subset of a countdata object that contains count data as a function of pop or SNP indexes</p></a></li>
<li><a href='#extract_allele_names'><p>extract_allele_names</p></a></li>
<li><a href='#extract_nonvscan_counts'><p>extract_nonvscan_counts</p></a></li>
<li><a href='#extract_vscan_counts'><p>extract_vscan_counts</p></a></li>
<li><a href='#find_indelneighbor_idx'><p>find_indelneighbor_idx</p></a></li>
<li><a href='#find.tree.popset'><p>Find sets of populations that may used as scaffold tree</p></a></li>
<li><a href='#fit.graph'><p>Estimate parameters of an admixture graph</p></a></li>
<li><a href='#fitted.graph-class'><p>S4 class to represent a population tree or admixture graph and its underlying fitted parameter.</p></a></li>
<li><a href='#fstats-class'><p>S4 class to represent fstats results obtained with computeFstats.</p></a></li>
<li><a href='#generate.graph.params'><p>Generate a graph parameter object to fit admixture graph to observed fstats</p></a></li>
<li><a href='#generate.jackknife.blocks'><p>Generate block coordinates for block-jackknife</p></a></li>
<li><a href='#generateF3names'><p>generateF3names</p></a></li>
<li><a href='#generateF4names'><p>generateF4names</p></a></li>
<li><a href='#genobaypass2countdata'><p>Convert BayPass allele count input files into a coundata object</p></a></li>
<li><a href='#genobaypass2pooldata'><p>Convert BayPass read count and haploid pool size input files into a pooldata object</p></a></li>
<li><a href='#genoselestim2pooldata'><p>Convert SelEstim read count input files into a pooldata object</p></a></li>
<li><a href='#genotreemix2countdata'><p>Convert allele count input files from the Treemix program into a coundata object</p></a></li>
<li><a href='#graph.builder'><p>Implement a graph builder heuristic by successively adding leaves to an initial graph</p></a></li>
<li><a href='#graph.params-class'><p>S4 class to represent a population tree or admixture graph and its underlying parameter.</p></a></li>
<li><a href='#graph.params2qpGraphFiles'><p>Generate files for the qpGraph software from a graph.params object</p></a></li>
<li><a href='#graph.params2symbolic.fstats'><p>Provide a symbolic representation of all the F-statistics and the model system of equations</p></a></li>
<li><a href='#heatmap,pairwisefst-method'><p>Show pairwisefst object</p></a></li>
<li><a href='#is.countdata'><p>Check countdata objects</p></a></li>
<li><a href='#is.fitted.graph'><p>Check fitted.graph objects</p></a></li>
<li><a href='#is.fstats'><p>Check fstats objects</p></a></li>
<li><a href='#is.graph.params'><p>Check graph.params objects</p></a></li>
<li><a href='#is.pairwisefst'><p>Check pairwisefst objects</p></a></li>
<li><a href='#is.pooldata'><p>Check pooldata objects</p></a></li>
<li><a href='#make.example.files'><p>Create example files</p></a></li>
<li><a href='#pairwisefst-class'><p>S4 class to represent a pairwise Fst results obtained with the compute.pairwiseFST</p></a></li>
<li><a href='#plot_fstats'><p>Plot F2, F3, F3star, F4, D or pairwise Fst values with their Confidence Intervals</p></a></li>
<li><a href='#plot,fitted.graph-method'><p>plot pairwisefst object</p></a></li>
<li><a href='#plot,fstats-method'><p>plot fstats object</p></a></li>
<li><a href='#plot,graph.params-method'><p>plot graph in graph.params object</p></a></li>
<li><a href='#plot,pairwisefst-method'><p>plot pairwisefst object</p></a></li>
<li><a href='#pooldata-class'><p>S4 class to represent a Pool-Seq data set.</p></a></li>
<li><a href='#pooldata.subset'><p>Create a subset of the pooldata object that contains Pool-Seq data as a function of pool and/or SNP indexes</p></a></li>
<li><a href='#pooldata2diyabc'><p>Convert a pooldata object into DIYABC input files.</p></a></li>
<li><a href='#pooldata2genobaypass'><p>Convert a pooldata object into BayPass input files.</p></a></li>
<li><a href='#pooldata2genoselestim'><p>Convert a pooldata object into SelEstim input files.</p></a></li>
<li><a href='#poppair_idx'><p>poppair_idx</p></a></li>
<li><a href='#popsync2pooldata'><p>Convert Popoolation Sync files into a pooldata object</p></a></li>
<li><a href='#randomallele.pca'><p>PCA of a pooldata or countdata object using a random allele approach</p></a></li>
<li><a href='#rooted.njtree.builder'><p>Construct and root an Neighbor-Joining tree of presumably nonadmixed leaves</p></a></li>
<li><a href='#scan_allele_info'><p>scan_allele_info</p></a></li>
<li><a href='#show,countdata-method'><p>Show countdata object</p></a></li>
<li><a href='#show,fitted.graph-method'><p>Show fitted.graph object</p></a></li>
<li><a href='#show,fstats-method'><p>Show fstats object</p></a></li>
<li><a href='#show,graph.params-method'><p>Show graph.params object</p></a></li>
<li><a href='#show,pairwisefst-method'><p>Show pairwisefst object</p></a></li>
<li><a href='#show,pooldata-method'><p>Show pooldata object</p></a></li>
<li><a href='#vcf2pooldata'><p>Convert a VCF file into a pooldata object.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Maintainer:</td>
<td>Mathieu Gautier &lt;mathieu.gautier@inrae.fr&gt;</td>
</tr>
<tr>
<td>Author:</td>
<td>Mathieu Gautier</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.0</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Title:</td>
<td>Computing f-Statistics and Building Admixture Graphs Based on
Allele Count or Pool-Seq Read Count Data</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for the computation of f- and D-statistics (estimation of 'Fst', Patterson's 'F2', 'F3', 'F3*', 'F4' and D parameters) in population genomics studies from allele count or Pool-Seq read count data and for the fitting, building and visualization of admixture graphs. The package also includes several utilities to manipulate Pool-Seq data stored in standard format (e.g., such as 'vcf' files or 'rsync' files generated by the the 'PoPoolation' software) and perform conversion to alternative format (as used in the 'BayPass' and 'SelEstim' software). As of version 2.0, the package also includes utilities to manipulate standard allele count data (e.g., stored in 'TreeMix', 'BayPass' or 'SelEstim' format).</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppProgress</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.5), methods, data.table, utils, foreach,
doParallel, parallel, DiagrammeR, ape, stats, zoo, Ryacas,
Matrix,RcppProgress, progress, nnls</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-06 15:12:50 UTC; mathieu</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-06 15:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='poolfstat'>PoolFstat</h2><span id='topic+poolfstat'></span><span id='topic+poolfstat-package'></span>

<h3>Description</h3>

<p>Functions for the computation of f- and D-statistics (estimation of Fst, Patterson's F2, F3, F3*, F4 and D parameters) in population genomics studies from allele count or Pool-Seq read count data and for the fitting, building and visualization of admixture graphs. The package also includes several utilities to manipulate Pool-Seq data stored in standard format (e.g., such as 'vcf' files or 'rsync' files generated by the the 'PoPoolation' software) and perform conversion to alternative format (as used in the 'BayPass' and 'SelEstim' software). As of version 2.0, the package also includes utilities to manipulate standard allele count data (e.g., stored in TreeMix, BayPass and SelEstim format).
</p>


<h3>Details</h3>

<p>Computing f-Statistics and building admixture graphs based on allele count or Pool-Seq read count data
</p>

<hr>
<h2 id='add.leaf'>Test all possible connection of a leaf to a graph with non-admixed and or admixed edges</h2><span id='topic+add.leaf'></span>

<h3>Description</h3>

<p>Test all possible connection of a leaf to a graph with non-admixed and or admixed edges
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.leaf(
  x,
  leaf.to.add,
  fstats,
  only.test.non.admixed.edges = FALSE,
  only.test.admixed.edges = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.leaf_+3A_x">x</code></td>
<td>
<p>An object of class graph.params or fitted.graph (see details)</p>
</td></tr>
<tr><td><code id="add.leaf_+3A_leaf.to.add">leaf.to.add</code></td>
<td>
<p>Name of the leaf to add</p>
</td></tr>
<tr><td><code id="add.leaf_+3A_fstats">fstats</code></td>
<td>
<p>Object of class fstats that contains estimates of the fstats (see compute.fstats)</p>
</td></tr>
<tr><td><code id="add.leaf_+3A_only.test.non.admixed.edges">only.test.non.admixed.edges</code></td>
<td>
<p>If TRUE the function only test non.admixed edges (may be far faster)</p>
</td></tr>
<tr><td><code id="add.leaf_+3A_only.test.admixed.edges">only.test.admixed.edges</code></td>
<td>
<p>If TRUE the function only test admixed edges</p>
</td></tr>
<tr><td><code id="add.leaf_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE extra information is printed on the terminal</p>
</td></tr>
<tr><td><code id="add.leaf_+3A_...">...</code></td>
<td>
<p>Some parameters to be passed the function fit.graph called internally</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input object x needs to be of class graph.params (as generated by the function generate.graph.params) or fitted.graph (as generated by the function fit.graph or by the function add.leaf itself in the graphs.fit.res elements of the output list). This is to ensure that the matrix describing the structure of the graph (graph slot of these objects) is valid (note that it can be plotted for checks). Hence graph.params objects may have been generated without fstats information (that should be supplied independently to the add.leaf function to obtain information on the fstats involving the candidate leaf defined with the leaf.to.add argument).
By default the function tests all the possible positions of a newly added edge connecting the candidate leaf to the graph with both non-admixed (including a new rooting with the candidate leaf as an outgroup) and admixed edges. If n_e is the the number of non-admixed edges of the original graph, the number of tested graphs for non-admixed edges equals n_e+1. The newly added node is named &quot;N-&quot;name of the leaf to add (or with more N if the name already exists). For admixed edges, the number of tested graphs equals n_e*(n_e-1)/2 and for a given tested graph, three nodes named &quot;S-&quot;name of the leaf to add, &quot;S1-&quot;name of the leaf to add and &quot;S2-&quot;name of the leaf to add (or with more S if the name already exists) are added and the admixture proportions are named with a letter (A to Z depending on the number of admixed nodes already present in the graph).
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ol>
<li><p> &quot;n.graphs&quot;: The number of tested graphs
</p>
</li>
<li><p> &quot;fitted.graphs.list&quot;: a list of fitted.graph objects (indexed from 1 to n.graphs and in the same order as the list &quot;graphs&quot;) containing the results of fitting of each graph. 
</p>
</li>
<li><p> &quot;best.fitted.graph&quot;: The graph (object of class fitted.graph) with the minimal BIC (see function fit.graph) among all the graphs within fitted.graphs.list 
</p>
</li>
<li><p> &quot;bic&quot;: a vector of the n.graphs BIC (indexed from 1 to n.graphs and in the same order as the &quot;fitted.graphs.list&quot; list) (see fit.graph details for the computation of the scores). 
</p>
</li></ol>



<h3>See Also</h3>

<p>see <code><a href="#topic+fit.graph">fit.graph</a></code> and <code><a href="#topic+generate.graph.params">generate.graph.params</a></code>.
</p>

<hr>
<h2 id='bjack_cov'>bjack_cov</h2><span id='topic+bjack_cov'></span>

<h3>Description</h3>

<p>Compute the block-jackknife covariance between two stats
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="bjack_cov_+3A_stat1">stat1</code></td>
<td>
<p>Vector of block-jackknife values for the first stat</p>
</td></tr>
<tr><td><code id="bjack_cov_+3A_stat2">stat2</code></td>
<td>
<p>Vector of block-jackknife values for the second stat</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute the block-jackknife covariance between two stats with correction
</p>


<h3>Value</h3>

<p>Covariance values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
</code></pre>

<hr>
<h2 id='compare.fitted.fstats'>Compare fitted f2, f3 and f4 f-statistics of an admixture graph with estimated ones</h2><span id='topic+compare.fitted.fstats'></span>

<h3>Description</h3>

<p>Compare fitted f2, f3 and f4 f-statistics of an admixture graph with estimated ones
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare.fitted.fstats(fstats, fitted.graph, n.worst.stats = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare.fitted.fstats_+3A_fstats">fstats</code></td>
<td>
<p>Object of class fstats containing estimates of fstats (as obtained with compute.fstats)</p>
</td></tr>
<tr><td><code id="compare.fitted.fstats_+3A_fitted.graph">fitted.graph</code></td>
<td>
<p>Object of class fitted graph (as obtained with fit.graph function).</p>
</td></tr>
<tr><td><code id="compare.fitted.fstats_+3A_n.worst.stats">n.worst.stats</code></td>
<td>
<p>The number of worst statistics to be displayed in the terminal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compare fitted and estimated f-statistics may allow identifying problematic edges on the graph.
</p>


<h3>Value</h3>

<p>A matrix with 3 columns for each test (row names of the matrix corresponding to the test):
</p>

<ol>
<li><p> The estimated f-statistics (mean across block-Jackknife samples)
</p>
</li>
<li><p> The fitted f-statistics (obtained from the fitted grah parameters
</p>
</li>
<li><p> A Z-score measuring the deviation of the fitted values from the estimated values in units of standard errors (i.e., Z=(fitted.value-target.value)/se(target.value))
</p>
</li></ol>



<h3>See Also</h3>

<p>See <code><a href="#topic+compute.fstats">compute.fstats</a></code> and <code><a href="#topic+fit.graph">fit.graph</a></code>
</p>

<hr>
<h2 id='compute_blockDdenom'>compute_blockDdenom</h2><span id='topic+compute_blockDdenom'></span><span id='topic+.compute_blockDdenom'></span>

<h3>Description</h3>

<p>Compute the denominator of the Dstat for all quadruplet configuration and each block-jackknife block (if any) and overall SNPs (within or outside blocks)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.compute_blockDdenom(refcount, totcount, nblocks, block_id, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_blockDdenom_+3A_refcount">refcount</code></td>
<td>
<p>Matrix of nsnpxnpop with counts (genotype or reads) for the reference allele</p>
</td></tr>
<tr><td><code id="compute_blockDdenom_+3A_totcount">totcount</code></td>
<td>
<p>Matrix of nsnpxnpop with total counts or read coverages</p>
</td></tr>
<tr><td><code id="compute_blockDdenom_+3A_nblocks">nblocks</code></td>
<td>
<p>Integer giving the number of block-jackknife blocs (may be 0 if no block-jackknife)</p>
</td></tr>
<tr><td><code id="compute_blockDdenom_+3A_block_id">block_id</code></td>
<td>
<p>Integer vector of length nsnps with the (0-indexed) id of the block to which each SNP belongs (-1 for SNPs outside blocks)</p>
</td></tr>
<tr><td><code id="compute_blockDdenom_+3A_verbose">verbose</code></td>
<td>
<p>Logical (if TRUE progression bar is printed on the terminal)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute the denominator of the Dstat for all quadruplet configuration and each block-jackknife block (if any) and overall SNPs (within or outside blocks)
</p>


<h3>Value</h3>

<p>Return a matrix with nf4=(npops*(npops-1)/2)*((npops-2)*(npops-3)/2)/2 rows and nblocks+1 columns giving the mean Dstat-denominator (1-Q2ab)(1-Q2cd)
for all quadruplet configuration and within each block-jackknife sample and over all SNPs (last column)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
</code></pre>

<hr>
<h2 id='compute_Ddenom'>compute_Ddenom</h2><span id='topic+compute_Ddenom'></span><span id='topic+.compute_Ddenom'></span>

<h3>Description</h3>

<p>Compute the denominator of Dstats
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.compute_Ddenom(snpQ2, f2idx, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_Ddenom_+3A_snpq2">snpQ2</code></td>
<td>
<p>the nsnp by (npop*(npop-1))/2 matrix of all pairwise Q2 estimates</p>
</td></tr>
<tr><td><code id="compute_Ddenom_+3A_f2idx">f2idx</code></td>
<td>
<p>a matrix of nDstat by 2 giving the index of the Q2 required to compute the denominator of the different F4</p>
</td></tr>
<tr><td><code id="compute_Ddenom_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE progression bar is printed on the terminal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute the denominator of Dstats
</p>


<h3>Value</h3>

<p>Return a vector of the denominator of the nDstat
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
</code></pre>

<hr>
<h2 id='compute_Ddenom_bjmeans'>compute_Ddenom_bjmeans</h2><span id='topic+compute_Ddenom_bjmeans'></span><span id='topic+.compute_Ddenom_bjmeans'></span>

<h3>Description</h3>

<p>Compute the the block-jackknife mean of Dstat denominator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.compute_Ddenom_bjmeans(snpQ2, f2idx, snp_bj_id, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_Ddenom_bjmeans_+3A_snpq2">snpQ2</code></td>
<td>
<p>the nsnp by (npop*(npop-1))/2 matrix of all pairwise Q2 estimates</p>
</td></tr>
<tr><td><code id="compute_Ddenom_bjmeans_+3A_f2idx">f2idx</code></td>
<td>
<p>a matrix of nDstat by 2 giving the index of the Q2 required to compute the Dstat denominator</p>
</td></tr>
<tr><td><code id="compute_Ddenom_bjmeans_+3A_snp_bj_id">snp_bj_id</code></td>
<td>
<p>integer vector of length nsnp giving the block index of each SNP</p>
</td></tr>
<tr><td><code id="compute_Ddenom_bjmeans_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE progression bar is printed on the terminal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute the the block-jackknife mean of Dstat denominator
</p>


<h3>Value</h3>

<p>Return a vector with the block-jackknife mean estimates of the Dstat denominator
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
</code></pre>

<hr>
<h2 id='compute_F2_bjmeans'>compute_F2_bjmeans</h2><span id='topic+compute_F2_bjmeans'></span><span id='topic+.compute_F2_bjmeans'></span>

<h3>Description</h3>

<p>Compute the the block-jackknife mean of F2 values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.compute_F2_bjmeans(snpQ1, snpQ2, q1_idx, snp_bj_id, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_F2_bjmeans_+3A_snpq1">snpQ1</code></td>
<td>
<p>the nsnp by npop matrix of Q1 estimates</p>
</td></tr>
<tr><td><code id="compute_F2_bjmeans_+3A_snpq2">snpQ2</code></td>
<td>
<p>the nsnp by (npop*(npop-1))/2 matrix of all pairwise Q2 estimates</p>
</td></tr>
<tr><td><code id="compute_F2_bjmeans_+3A_q1_idx">q1_idx</code></td>
<td>
<p>the nsnp by 2 matrix with the indexes of the Q1 needed to compute each F2</p>
</td></tr>
<tr><td><code id="compute_F2_bjmeans_+3A_snp_bj_id">snp_bj_id</code></td>
<td>
<p>integer vector of length nsnp giving the block index of each SNP</p>
</td></tr>
<tr><td><code id="compute_F2_bjmeans_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE progression bar is printed on the terminal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute the the block-jackknife mean of F2 values
</p>


<h3>Value</h3>

<p>Return a vector with the block-jackknife mean estimates of the F2 values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
</code></pre>

<hr>
<h2 id='compute_F3fromF2'>compute_F3fromF2</h2><span id='topic+compute_F3fromF2'></span><span id='topic+.compute_F3fromF2'></span>

<h3>Description</h3>

<p>Compute all F3 from overall F2 values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.compute_F3fromF2(F2val, Hval, npops)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_F3fromF2_+3A_f2val">F2val</code></td>
<td>
<p>Numeric vector of length nF2=(npop*(npop-1))/2 with all pairwise F2 estimates</p>
</td></tr>
<tr><td><code id="compute_F3fromF2_+3A_hval">Hval</code></td>
<td>
<p>Numeric vector of length npop with all within pop heterozygosity estimates</p>
</td></tr>
<tr><td><code id="compute_F3fromF2_+3A_npops">npops</code></td>
<td>
<p>Integer giving the number of populations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute F3 and F3star estimates from F2 (and heterozygosities)
</p>


<h3>Value</h3>

<p>Return a matrix of length nF3=npops*(npops-1)*(npops-2)/2 rows and 2 columns corresponding to the F3 and F3star estimates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
</code></pre>

<hr>
<h2 id='compute_F3fromF2samples'>compute_F3fromF2samples</h2><span id='topic+compute_F3fromF2samples'></span><span id='topic+.compute_F3fromF2samples'></span>

<h3>Description</h3>

<p>Compute all F3 from F2 values obtained from each block-jackknife bloc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.compute_F3fromF2samples(blockF2, blockHet, npops, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_F3fromF2samples_+3A_blockf2">blockF2</code></td>
<td>
<p>Numeric Matrix with nF2=(npop*(npop-1))/2 rows and nblocks columns matrix containing pairwise-pop F2 estimates for each block-jackknife sample (l.o.o.)</p>
</td></tr>
<tr><td><code id="compute_F3fromF2samples_+3A_blockhet">blockHet</code></td>
<td>
<p>Numeric Matrix with npop rows and nblocks columns containing all within pop heterozygosity estimates for each block-jackknife sample (l.o.o.)</p>
</td></tr>
<tr><td><code id="compute_F3fromF2samples_+3A_npops">npops</code></td>
<td>
<p>Integer giving the number of populations</p>
</td></tr>
<tr><td><code id="compute_F3fromF2samples_+3A_verbose">verbose</code></td>
<td>
<p>Logical (if TRUE progression bar is printed on the terminal)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute F3 and F3star estimates and their s.e. based on block-jackknife estimates of all F2 (and heterozygosities)
</p>


<h3>Value</h3>

<p>Return a matrix with nF3=npops*(npops-1)*(npops-2)/2 rows and four columns corresponding to the mean and the s.e. of F3 and the mean and s.e. of F3star
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
</code></pre>

<hr>
<h2 id='compute_F4DfromF2samples'>compute_F4DfromF2samples</h2><span id='topic+compute_F4DfromF2samples'></span><span id='topic+.compute_F4DfromF2samples'></span>

<h3>Description</h3>

<p>Compute all F4 and Dstat from F2 values obtained from each block-jackknife bloc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.compute_F4DfromF2samples(blockF2, blockDenom, npops, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_F4DfromF2samples_+3A_blockf2">blockF2</code></td>
<td>
<p>Numeric Matrix with nF2=(npop*(npop-1))/2 rows and nblocks columns matrix containing pairwise-pop F2 estimates for each block-jackknife sample (l.o.o.)</p>
</td></tr>
<tr><td><code id="compute_F4DfromF2samples_+3A_blockdenom">blockDenom</code></td>
<td>
<p>Numeric Matrix with nF4=(npops*(npops-1)/2)*((npops-2)*(npops-3)/2)/2 rows and nblocks containing the estimates of the denominator of Dstat (see compute_blockDdenom) for each block-jackknife sample (l.o.o.)</p>
</td></tr>
<tr><td><code id="compute_F4DfromF2samples_+3A_npops">npops</code></td>
<td>
<p>Integer giving the number of populations</p>
</td></tr>
<tr><td><code id="compute_F4DfromF2samples_+3A_verbose">verbose</code></td>
<td>
<p>Logical (if TRUE progression bar is printed on the terminal)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute F4 and D estimates and their s.e. based on block-jackknife estimates of all F2 (and heterozygosities)
</p>


<h3>Value</h3>

<p>Return a matrix with nF4=(npops*(npops-1)/2)*((npops-2)*(npops-3)/2)/2 rows and four columns corresponding to the mean and the s.e. of F4 and the mean and s.e. of Dstat
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
</code></pre>

<hr>
<h2 id='compute_F4fromF2'>compute_F4fromF2</h2><span id='topic+compute_F4fromF2'></span><span id='topic+.compute_F4fromF2'></span>

<h3>Description</h3>

<p>Compute all F4 from overall F2 and Q2 values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.compute_F4fromF2(F2val, npops)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_F4fromF2_+3A_f2val">F2val</code></td>
<td>
<p>Numeric vector of length nF2=(npop*(npop-1))/2 with all pairwise F2 estimates</p>
</td></tr>
<tr><td><code id="compute_F4fromF2_+3A_npops">npops</code></td>
<td>
<p>Integer giving the number of populations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute F4 from F2 (and heterozygosities)
</p>


<h3>Value</h3>

<p>Return a vector of length nF4=(npops*(npops-1)/2) * ((npops-2)*(npops-3)/2) / 2 rows corresponding to all the F4 estimates for all possible configurations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
</code></pre>

<hr>
<h2 id='compute_F4fromF2samples'>compute_F4fromF2samples</h2><span id='topic+compute_F4fromF2samples'></span><span id='topic+.compute_F4fromF2samples'></span>

<h3>Description</h3>

<p>Compute all F4 from F2 values obtained from each block-jackknife bloc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.compute_F4fromF2samples(blockF2, npops, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_F4fromF2samples_+3A_blockf2">blockF2</code></td>
<td>
<p>Numeric Matrix with nF2=(npop*(npop-1))/2 rows and nblocks columns matrix containing pairwise-pop F2 estimates for each block-jackknife sample (l.o.o.)</p>
</td></tr>
<tr><td><code id="compute_F4fromF2samples_+3A_npops">npops</code></td>
<td>
<p>Integer giving the number of populations</p>
</td></tr>
<tr><td><code id="compute_F4fromF2samples_+3A_verbose">verbose</code></td>
<td>
<p>Logical (if TRUE progression bar is printed on the terminal)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute F4 estimates and their s.e. based on block-jackknife estimates of all F2 (and heterozygosities)
</p>


<h3>Value</h3>

<p>Return a matrix with nF4=(npops*(npops-1)/2) * ((npops-2)*(npops-3)/2) / 2 rows and two columns corresponding to the mean and the s.e. of F4 estimates for all possible configurations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
</code></pre>

<hr>
<h2 id='compute_H1'>compute_H1</h2><span id='topic+compute_H1'></span><span id='topic+.compute_H1'></span>

<h3>Description</h3>

<p>Compute (uncorrected) 1-Q1 for each block-jackknife block (if any) and over all the SNPs (i.e., either within or outside blocks)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.compute_H1(refcount, totcount, nblocks, block_id, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_H1_+3A_refcount">refcount</code></td>
<td>
<p>Matrix of nsnpxnpop with counts (genotype or reads) for the reference allele</p>
</td></tr>
<tr><td><code id="compute_H1_+3A_totcount">totcount</code></td>
<td>
<p>Matrix of nsnpxnpop with total counts or read coverages</p>
</td></tr>
<tr><td><code id="compute_H1_+3A_nblocks">nblocks</code></td>
<td>
<p>Integer giving the number of block-jackknife blocs (may be 0 if no block-jackknife)</p>
</td></tr>
<tr><td><code id="compute_H1_+3A_block_id">block_id</code></td>
<td>
<p>Integer vector of length nsnps with the (0-indexed) id of the block to which each SNP belongs (-1 for SNPs outside blocks)</p>
</td></tr>
<tr><td><code id="compute_H1_+3A_verbose">verbose</code></td>
<td>
<p>Logical (if TRUE progression bar is printed on the terminal)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute all the (uncorrected) H1=1-Q1 for each block-jackknife block (if any) and overall SNPs (within or outside blocks). 
It is indeed more convenient to compute H1 (rather than Q1) to apply corrections afterwards within R function
</p>


<h3>Value</h3>

<p>Return a matrix with npops rows and nblocks+1 column giving the mean H1 of each pop within each block and for all SNPs (last column)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
</code></pre>

<hr>
<h2 id='compute_Q_bjmeans'>compute_Q_bjmeans</h2><span id='topic+compute_Q_bjmeans'></span><span id='topic+.compute_Q_bjmeans'></span>

<h3>Description</h3>

<p>Compute the the block-jackknife mean of Q values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.compute_Q_bjmeans(snpQ, snp_bj_id, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_Q_bjmeans_+3A_snpq">snpQ</code></td>
<td>
<p>matrix of nsnp by nQ estimates of Q (e.g., Q1 or Q2)</p>
</td></tr>
<tr><td><code id="compute_Q_bjmeans_+3A_snp_bj_id">snp_bj_id</code></td>
<td>
<p>integer vector of length nsnp giving the block index of each SNP</p>
</td></tr>
<tr><td><code id="compute_Q_bjmeans_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE progression bar is printed on the terminal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute the the block-jackknife mean of Q values
</p>


<h3>Value</h3>

<p>Return a vector with the block-jackknife mean estimates for the nQ values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
</code></pre>

<hr>
<h2 id='compute_Q2'>compute_Q2</h2><span id='topic+compute_Q2'></span><span id='topic+.compute_Q2'></span>

<h3>Description</h3>

<p>Compute all Q2 for each block-jackknife block (if any) and overall SNPs (within or outside blocks)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.compute_Q2(refcount, totcount, nblocks, block_id, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_Q2_+3A_refcount">refcount</code></td>
<td>
<p>Matrix of nsnpxnpop with counts (genotype or reads) for the reference allele</p>
</td></tr>
<tr><td><code id="compute_Q2_+3A_totcount">totcount</code></td>
<td>
<p>Matrix of nsnpxnpop with total counts or read coverages</p>
</td></tr>
<tr><td><code id="compute_Q2_+3A_nblocks">nblocks</code></td>
<td>
<p>Integer giving the number of block-jackknife blocs (may be 0 if no block-jackknife)</p>
</td></tr>
<tr><td><code id="compute_Q2_+3A_block_id">block_id</code></td>
<td>
<p>Integer vector of length nsnps with the (0-indexed) id of the block to which each SNP belongs (-1 for SNPs outside blocks)</p>
</td></tr>
<tr><td><code id="compute_Q2_+3A_verbose">verbose</code></td>
<td>
<p>Logical (if TRUE progression bar is printed on the terminal)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute all Q2 for each block-jackknife block (if any) and overall SNPs (within or outside blocks).
</p>


<h3>Value</h3>

<p>Return a matrix with npops*(npops-1)/2 and nblocks+1 column giving the mean Q2 of each pairwise pop comp. within each block and for all SNPs (last column)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
</code></pre>

<hr>
<h2 id='compute_QmatfromF2samples'>compute_QmatfromF2samples</h2><span id='topic+compute_QmatfromF2samples'></span><span id='topic+.compute_QmatfromF2samples'></span>

<h3>Description</h3>

<p>Compute the Qmat matrix (error covariance between all F2 and F3 measures) from F2 block-jackknife estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.compute_QmatfromF2samples(blockF2, npops, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_QmatfromF2samples_+3A_blockf2">blockF2</code></td>
<td>
<p>Numeric Matrix with nF2=(npop*(npop-1))/2 rows and nblocks columns matrix containing pairwise-pop F2 estimates for each block-jackknife sample (l.o.o.)</p>
</td></tr>
<tr><td><code id="compute_QmatfromF2samples_+3A_npops">npops</code></td>
<td>
<p>Integer giving the number of populations</p>
</td></tr>
<tr><td><code id="compute_QmatfromF2samples_+3A_verbose">verbose</code></td>
<td>
<p>Logical (if TRUE progression bar is printed on the terminal)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute the error covariance matrix Qmat (between all F2 and F3 measures) from F2 block-jackknife estimates (by recomuting all F3 for all blocks)
</p>


<h3>Value</h3>

<p>Return the (nF2+nF3)*(nF2+nF3) error covariance (symmetric) matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
</code></pre>

<hr>
<h2 id='compute.f4ratio'>Compute F4ratio (estimation of admixture rate) from an fstats object</h2><span id='topic+compute.f4ratio'></span>

<h3>Description</h3>

<p>Compute F4ratio (estimation of admixture rate) from an fstats object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.f4ratio(x, num.quadruplet, den.quadruplet)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.f4ratio_+3A_x">x</code></td>
<td>
<p>A fstats object containing estimates of fstats</p>
</td></tr>
<tr><td><code id="compute.f4ratio_+3A_num.quadruplet">num.quadruplet</code></td>
<td>
<p>A character vector for the F4 quadruplet used in the F4ratio numerator (should be of the form &quot;A,O;C,X&quot; where A, O, C and X are the names of the population as defined in the countdata or pooldata object used to obtain fstats, see details)</p>
</td></tr>
<tr><td><code id="compute.f4ratio_+3A_den.quadruplet">den.quadruplet</code></td>
<td>
<p>A character vector for the F4 quadruplet used in the F4ratio denominator (should be of the form &quot;A,O;C,B&quot; where A, O, C and B are the names of the populations as defined in the countdata or pooldata object used to obtain fstats, see details))</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assuming a 4 population phylogeny rooted with an outgroup O of the form (((A,B);C);O) and an admixed population X with two source populations related to B and C, the admixture rate alpha of the B-related ancestry is obtained using the ratio F4(A,O;C,X)/F4(A,O;C,B) (see Patterson et al., 2012 for more details).
</p>


<h3>Value</h3>

<p>Either a scalar corresponding to the estimated admixture rate or, if F2 block-jackknife samples are available in the input fstats object (i.e., compute.fstats was run with return.F2.blockjackknife.samples = TRUE) a vector with three elements corresponding to the estimate of the admixture rate, the block-jacknife mean (may be slightly different than the previous since not exactly the same set of markers are used) and the standard error of the estimates.
</p>


<h3>See Also</h3>

<p>To generate pooldata object, see <code><a href="#topic+vcf2pooldata">vcf2pooldata</a></code>, <code><a href="#topic+popsync2pooldata">popsync2pooldata</a></code>,<code><a href="#topic+genobaypass2pooldata">genobaypass2pooldata</a></code> or <code><a href="#topic+genoselestim2pooldata">genoselestim2pooldata</a></code>. To generate coundata object, see <code><a href="#topic+genobaypass2countdata">genobaypass2countdata</a></code> or <code><a href="#topic+genotreemix2countdata">genotreemix2countdata</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> make.example.files(writing.dir=tempdir())
 pooldata=popsync2pooldata(sync.file=paste0(tempdir(),"/ex.sync.gz"),poolsizes=rep(50,15))
 res.fstats=compute.fstats(pooldata)
</code></pre>

<hr>
<h2 id='compute.fstats'>Estimate the F-statistics (F2, F3, F3star, F4, Dstat) and within and across population diversity</h2><span id='topic+compute.fstats'></span>

<h3>Description</h3>

<p>Estimate the F-statistics (F2, F3, F3star, F4, Dstat) and within and across population diversity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.fstats(
  x,
  nsnp.per.bjack.block = 0,
  computeDstat = FALSE,
  computeF3 = TRUE,
  computeF4 = TRUE,
  output.pairwise.fst = TRUE,
  output.pairwise.div = TRUE,
  computeQmat = TRUE,
  return.F2.blockjackknife.samples = FALSE,
  return.F4.blockjackknife.samples = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.fstats_+3A_x">x</code></td>
<td>
<p>A pooldata object containing Pool-Seq information or a countdata object containing allele count information</p>
</td></tr>
<tr><td><code id="compute.fstats_+3A_nsnp.per.bjack.block">nsnp.per.bjack.block</code></td>
<td>
<p>Number of consecutive SNPs within a block for block-jackknife (default=0, i.e., no block-jackknife sampling)</p>
</td></tr>
<tr><td><code id="compute.fstats_+3A_computedstat">computeDstat</code></td>
<td>
<p>If TRUE compute Dstatistics (i.e. scaled F4). This may add some non negligible computation time if the number of population is large (n&gt;15)</p>
</td></tr>
<tr><td><code id="compute.fstats_+3A_computef3">computeF3</code></td>
<td>
<p>If TRUE (default) compute all F3 and all F3star (i.e. scaled F3).</p>
</td></tr>
<tr><td><code id="compute.fstats_+3A_computef4">computeF4</code></td>
<td>
<p>If TRUE (default) compute all F4.</p>
</td></tr>
<tr><td><code id="compute.fstats_+3A_output.pairwise.fst">output.pairwise.fst</code></td>
<td>
<p>If TRUE (default), output the npopxnpop matrix of pairwise-population Fst estimates (corresponding to the &quot;Identity&quot; method implemented in <code><a href="#topic+compute.pairwiseFST">compute.pairwiseFST</a></code>) in the pairwise.fst slot of the fstats output object (see help(fstats) for details) that may be visualized with e.g. heatmap function or used with a clustering function (e.g., hclust).</p>
</td></tr>
<tr><td><code id="compute.fstats_+3A_output.pairwise.div">output.pairwise.div</code></td>
<td>
<p>If TRUE (default), output the npopxnpop matrix of pairwise-population divergence (1-Q2) estimates  in the pairwise.div slot of the fstats output object (see help(fstats) for details) that may be visualized with e.g. heatmap function or used with a clustering function (e.g., hclust).</p>
</td></tr>
<tr><td><code id="compute.fstats_+3A_computeqmat">computeQmat</code></td>
<td>
<p>If TRUE, compute the error covariance matrix between all F3 and F2 statistics (needed for admixture graph construction). This matrix may be very large if the number of pops is large. It is recommended to estimate it on a reduced sample of pops.</p>
</td></tr>
<tr><td><code id="compute.fstats_+3A_return.f2.blockjackknife.samples">return.F2.blockjackknife.samples</code></td>
<td>
<p>If TRUE (and nsnp.per.bjack.block&gt;0) return an array of dimension (npopxnpopxnblocks) in an admixtools2 compatible format</p>
</td></tr>
<tr><td><code id="compute.fstats_+3A_return.f4.blockjackknife.samples">return.F4.blockjackknife.samples</code></td>
<td>
<p>Deprecated options (since v. 2.2.0)</p>
</td></tr>
<tr><td><code id="compute.fstats_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE extra information is printed on the terminal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function estimates for the n populations (or pools) represented in the input object x:
</p>

<ol>
<li><p> The F2 statistics for all the <code class="reqn">n(n-1)/2</code> pairs of populations (or pools) and their scaled version (equivalent, but faster, than Fst estimated with <code><a href="#topic+compute.pairwiseFST">compute.pairwiseFST</a></code> when method=&quot;Identity&quot;)
</p>
</li>
<li><p> If n&gt;2, The F3 statistics for all the <code class="reqn">npools(npools-1)(npools-2)/2</code> possible triplets of populations (or pools) and their scaled version (named F3star after Patterson et al., 2012)
</p>
</li>
<li><p> If n&gt;3, The F4 statistics and the D-statistics (a scaled version of the F4) for all the <code class="reqn">npools(npools-1)(npools-2)*(npools-3)/8</code> possible quadruplets of populations
</p>
</li>
<li><p> The estimated within population heterozygosities (=1-Q1)
</p>
</li>
<li><p> The estimated divergence for each pair of populations (=1-Q2) 
</p>
</li></ol>



<h3>Value</h3>

<p>An object of class fstats (see help(fstats) for details)
</p>


<h3>See Also</h3>

<p>To generate pooldata object, see <code><a href="#topic+vcf2pooldata">vcf2pooldata</a></code>, <code><a href="#topic+popsync2pooldata">popsync2pooldata</a></code>,<code><a href="#topic+genobaypass2pooldata">genobaypass2pooldata</a></code> or <code><a href="#topic+genoselestim2pooldata">genoselestim2pooldata</a></code>. To generate coundata object, see <code><a href="#topic+genobaypass2countdata">genobaypass2countdata</a></code> or <code><a href="#topic+genotreemix2countdata">genotreemix2countdata</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> make.example.files(writing.dir=tempdir())
 pooldata=popsync2pooldata(sync.file=paste0(tempdir(),"/ex.sync.gz"),poolsizes=rep(50,15))
 res.fstats=compute.fstats(pooldata)
</code></pre>

<hr>
<h2 id='compute.pairwiseFST'>Compute pairwise population population FST matrix (and possibly all pairwise SNP-specific FST)</h2><span id='topic+compute.pairwiseFST'></span>

<h3>Description</h3>

<p>Compute pairwise population population FST matrix (and possibly all pairwise SNP-specific FST)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.pairwiseFST(
  x,
  method = "Anova",
  min.cov.per.pool = -1,
  max.cov.per.pool = 1e+06,
  min.indgeno.per.pop = -1,
  min.maf = -1,
  output.snp.values = FALSE,
  nsnp.per.bjack.block = 0,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.pairwiseFST_+3A_x">x</code></td>
<td>
<p>A pooldata object containing Pool-Seq information or a countdata object containing allele count information</p>
</td></tr>
<tr><td><code id="compute.pairwiseFST_+3A_method">method</code></td>
<td>
<p>Either &quot;Anova&quot; (default method as described in the manuscript) or &quot;Identity&quot; (relies on an alternative modeling consisting in estimating unbiased Probability of Identity within and across pairs of pools)</p>
</td></tr>
<tr><td><code id="compute.pairwiseFST_+3A_min.cov.per.pool">min.cov.per.pool</code></td>
<td>
<p>For Pool-Seq data (i.e., pooldata objects) only: minimal allowed read count (per pool). If at least one pool is not covered by at least min.cov.perpool reads, the position is discarded in the corresponding pairwise comparisons</p>
</td></tr>
<tr><td><code id="compute.pairwiseFST_+3A_max.cov.per.pool">max.cov.per.pool</code></td>
<td>
<p>For Pool-Seq data (i.e., pooldata objects) only: maximal allowed read count (per pool). If at least one pool is covered by more than min.cov.perpool reads, the position is discarded in the corresponding pairwise comparisons.</p>
</td></tr>
<tr><td><code id="compute.pairwiseFST_+3A_min.indgeno.per.pop">min.indgeno.per.pop</code></td>
<td>
<p>For allele count data (i.e., countdata objects) only: minimal number of overall counts required in each population. If at least one pop is not genotyped for at least min.indgeno.per.pop (haploid) individual, the position is discarded</p>
</td></tr>
<tr><td><code id="compute.pairwiseFST_+3A_min.maf">min.maf</code></td>
<td>
<p>Minimal allowed Minor Allele Frequency (computed from the ratio overal read counts for the reference allele over the read coverage)  in the pairwise comparisons.</p>
</td></tr>
<tr><td><code id="compute.pairwiseFST_+3A_output.snp.values">output.snp.values</code></td>
<td>
<p>If TRUE, provide SNP-specific pairwise FST for each comparisons (may lead to a huge result object if the number of pools and/or SNPs is large)</p>
</td></tr>
<tr><td><code id="compute.pairwiseFST_+3A_nsnp.per.bjack.block">nsnp.per.bjack.block</code></td>
<td>
<p>Number of consecutive SNPs within a block for block-jackknife (default=0, i.e., no block-jackknife sampling)</p>
</td></tr>
<tr><td><code id="compute.pairwiseFST_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE extra information is printed on the terminal</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class pairwisefst (see help(pairwisefst) for details)
</p>


<h3>See Also</h3>

<p>To generate pooldata object, see <code><a href="#topic+vcf2pooldata">vcf2pooldata</a></code>, <code><a href="#topic+popsync2pooldata">popsync2pooldata</a></code>,<code><a href="#topic+genobaypass2pooldata">genobaypass2pooldata</a></code> or <code><a href="#topic+genoselestim2pooldata">genoselestim2pooldata</a></code>. To generate coundata object, see <code><a href="#topic+genobaypass2countdata">genobaypass2countdata</a></code> or <code><a href="#topic+genotreemix2countdata">genotreemix2countdata</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> make.example.files(writing.dir=tempdir())
 pooldata=popsync2pooldata(sync.file=paste0(tempdir(),"/ex.sync.gz"),poolsizes=rep(50,15))
 PairwiseFST=compute.pairwiseFST(pooldata)
</code></pre>

<hr>
<h2 id='computeFST'>Compute FST from Pool-Seq data or Count data</h2><span id='topic+computeFST'></span>

<h3>Description</h3>

<p>Compute FST from Pool-Seq data or Count data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeFST(
  x,
  method = "Anova",
  nsnp.per.bjack.block = 0,
  sliding.window.size = 0,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeFST_+3A_x">x</code></td>
<td>
<p>A pooldata object containing Pool-Seq information or countdata object containing allele counts information</p>
</td></tr>
<tr><td><code id="computeFST_+3A_method">method</code></td>
<td>
<p>Either &quot;Anova&quot; (default method as described in Hivert et al (2018, eq. 9) for pool-seq data and Weir (1996, eq. 5.2) for count data) or &quot;Identity&quot; (relying on unbiased estimators of Probability of Identity within and across pairs of pools/populations)</p>
</td></tr>
<tr><td><code id="computeFST_+3A_nsnp.per.bjack.block">nsnp.per.bjack.block</code></td>
<td>
<p>Number of consecutive SNPs within a block for block-jackknife (default=0, i.e., no block-jackknife sampling)</p>
</td></tr>
<tr><td><code id="computeFST_+3A_sliding.window.size">sliding.window.size</code></td>
<td>
<p>Number of consecutive SNPs within a window for multi-locus computation of Fst over sliding window with half-window size step (default=0, i.e., no sliding-window scan)</p>
</td></tr>
<tr><td><code id="computeFST_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE extra information is printed on the terminal</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the four following elements:
</p>

<ol>
<li><p> &quot;FST&quot;: a scalar corresponding to the estimate of the genome-wide FST over all the populations
</p>
</li>
<li><p> &quot;snp.FST&quot;: a vector containing estimates of SNP-specific FST
</p>
</li>
<li><p> &quot;snp.Q1&quot;: a vector containing estimates of the overall within pop. SNP-specific probability of identity
</p>
</li>
<li><p> &quot;snp.Q2&quot;: a vector containing estimates of the overall between pop. SNP-specific probability of identity
</p>
</li>
<li><p> &quot;mean.fst&quot; (if nsnp.per.bjack.block&gt;0): genome-wide Fst estimate as the mean over block-jackknife samples (may slight differ from &quot;FST&quot; estimate since it is only computed on SNPs eligible for Block-Jackknife)
</p>
</li>
<li><p> &quot;se.fst&quot; (if nsnp.per.bjack.block&gt;0): standard-error of the genome-wide Fst estimate computed block-jackknife samples
</p>
</li>
<li><p> &quot;fst.bjack.samples&quot; (if nsnp.per.bjack.block&gt;0): a vector containing estimates of the overall between pop. SNP-specific probability of identity
</p>
</li>
<li><p> &quot;sliding.windows.fst&quot; (if sliding.window.size&gt;0): a 4-columns data frame containing information on multi-locus Fst computed for sliding windows of SNPs over the whole genome with i) column with the chromosome/contig of origin of each window; ii) the mid-position of each window; iii) the cumulated mid-position of each window (to facilitate further plotting); and iv) the estimated multi-locus Fst
</p>
</li></ol>



<h3>See Also</h3>

<p>To generate pooldata object, see <code><a href="#topic+vcf2pooldata">vcf2pooldata</a></code>, <code><a href="#topic+popsync2pooldata">popsync2pooldata</a></code>,<code><a href="#topic+genobaypass2pooldata">genobaypass2pooldata</a></code> or <code><a href="#topic+genoselestim2pooldata">genoselestim2pooldata</a></code>. To generate coundata object, see <code><a href="#topic+genobaypass2countdata">genobaypass2countdata</a></code> or <code><a href="#topic+genotreemix2countdata">genotreemix2countdata</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> make.example.files(writing.dir=tempdir())
 pooldata=popsync2pooldata(sync.file=paste0(tempdir(),"/ex.sync.gz"),poolsizes=rep(50,15))
 res.fst=computeFST(pooldata)
</code></pre>

<hr>
<h2 id='countdata-class'>S4 class to represent a Count data set.</h2><span id='topic+countdata-class'></span><span id='topic+countdata'></span>

<h3>Description</h3>

<p>S4 class to represent a Count data set.
</p>


<h3>Slots</h3>


<dl>
<dt><code>npops</code></dt><dd><p>The number of populations</p>
</dd>
<dt><code>nsnp</code></dt><dd><p>The number of SNPs</p>
</dd>
<dt><code>refallele.count</code></dt><dd><p>A matrix (nsnp rows and npops columns) with the allele counts for the reference allele</p>
</dd>
<dt><code>total.count</code></dt><dd><p>A matrix (nsnp rows and npops columns) with the total number of counts (i.e., twice the number of genotyped individual for diploid species and autosomal markers)</p>
</dd>
<dt><code>snp.info</code></dt><dd><p>A data frame (nsnp rows and 4 columns) detailing for each SNP, the chromosome (or scaffold), the position, Reference allele name and Alternate allele name (if available)</p>
</dd>
<dt><code>popnames</code></dt><dd><p>A vector of length npops with the corresponding population names</p>
</dd>
</dl>


<h3>See Also</h3>

<p>To generate countdata object, see <code><a href="#topic+genobaypass2countdata">genobaypass2countdata</a></code> and <code><a href="#topic+genotreemix2countdata">genotreemix2countdata</a></code>
</p>

<hr>
<h2 id='countdata.subset'>Create a subset of a countdata object that contains count data as a function of pop or SNP indexes</h2><span id='topic+countdata.subset'></span>

<h3>Description</h3>

<p>Create a subset of a countdata object that contains count data as a function of pop or SNP indexes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countdata.subset(
  countdata,
  pop.index = 1:countdata@npops,
  snp.index = 1:countdata@nsnp,
  min.indgeno.per.pop = -1,
  min.maf = -1,
  return.snp.idx = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="countdata.subset_+3A_countdata">countdata</code></td>
<td>
<p>A countdata object containing Allele count information</p>
</td></tr>
<tr><td><code id="countdata.subset_+3A_pop.index">pop.index</code></td>
<td>
<p>Indexes of the pools (at least two), that should be selected to create the new pooldata object (default=all the pools)</p>
</td></tr>
<tr><td><code id="countdata.subset_+3A_snp.index">snp.index</code></td>
<td>
<p>Indexes of the SNPs (at least two), that should be selected to create the new pooldata object (default=all the SNPs)</p>
</td></tr>
<tr><td><code id="countdata.subset_+3A_min.indgeno.per.pop">min.indgeno.per.pop</code></td>
<td>
<p>Minimal number of overall counts required in each population. If at least one pop is not genotyped for at least min.indgeno.per.pop (haploid) individual, the position is discarded</p>
</td></tr>
<tr><td><code id="countdata.subset_+3A_min.maf">min.maf</code></td>
<td>
<p>Minimal allowed Minor Allele Frequency (computed from the ratio overall counts for the reference allele over the overall number of (haploid) individual genotyped)</p>
</td></tr>
<tr><td><code id="countdata.subset_+3A_return.snp.idx">return.snp.idx</code></td>
<td>
<p>If TRUE, the row.names of the snp.info slot of the returned pooldata object are named as &quot;rsx&quot; where x is the index of SNP in the initial pooldata object (default=FALSE)</p>
</td></tr>
<tr><td><code id="countdata.subset_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE return some information</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows subsetting a pooldata object by selecting only some pools and/or some SNPs (e.g., based on their position on the genome). Additional filtering steps on SNPs can be carried out on the resulting subset to discard SNP with low polymorphism or poorly or too highly covered. In addition, coverage criteria can be applied on a per-pool basis with the cov.qthres.per.pool argument. 'more specific SNP selection based on their positions on the genome or their characteristics. For instance if qmax=0.95, a position is discarded if in a given pool it has a number of reads higher than the 95-th percentile of the empirical coverage distribution in this same pool (defined over the SNPs selected by snp.index). Similarly, if qmax=0.05, a position is discarded if in a given pool it has a number of reads lower than the 5-th percentile of the empirical coverage distribution in this same pool. This mode of selection may be more relevant when considering pools with heterogeneous read coverages.
</p>


<h3>Value</h3>

<p>A countdata object with 6 elements:
</p>

<ol>
<li><p> &quot;refallele.count&quot;: a matrix (nsnp rows and npops columns) with the allele counts for the reference allele
</p>
</li>
<li><p> &quot;total.count&quot;: a matrix (nsnp rows and npops columns) with the total number of counts (i.e., twice the number of genotyped individual for diploid species and autosomal markers)
</p>
</li>
<li><p> &quot;snp.info&quot;: a matrix with nsnp rows and four columns containing respectively the contig (or chromosome) name (1st column) and position (2nd column) of the SNP; the allele taken as reference in the refallele.count matrix (3rd column); and the alternative allele (4th column)
</p>
</li>
<li><p> &quot;popnames&quot;: a vector of length npops containing the names of the pops
</p>
</li>
<li><p> &quot;nsnp&quot;: a scalar corresponding to the number of SNPs
</p>
</li>
<li><p> &quot;npops&quot;: a scalar corresponding to the number of populations
</p>
</li></ol>



<h3>See Also</h3>

<p>To generate countdata object, see <code><a href="#topic+genobaypass2countdata">genobaypass2countdata</a></code>, <code><a href="#topic+genotreemix2countdata">genotreemix2countdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> make.example.files(writing.dir=tempdir())
 pooldata=popsync2pooldata(sync.file=paste0(tempdir(),"/ex.sync.gz"),poolsizes=rep(50,15))
 pooldata2genobaypass(pooldata=pooldata,writing.dir=tempdir())
 ##NOTE: This example is just for the sake of illustration as it amounts to
 ##interpret read count as allele count which must not be done in practice!
 countdata=genobaypass2countdata(genobaypass.file=paste0(tempdir(),"/genobaypass")) 
 subset.by.snps=countdata.subset(countdata,snp.index=10:100)
 subset.by.pops.and.snps=countdata.subset(countdata,pop.index=c(1,2),snp.index=10:100)
</code></pre>

<hr>
<h2 id='extract_allele_names'>extract_allele_names</h2><span id='topic+extract_allele_names'></span><span id='topic+.extract_allele_names'></span>

<h3>Description</h3>

<p>Extract the alleles from the REF and ALT fields
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.extract_allele_names(allele_info, allele_idx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_allele_names_+3A_allele_info">allele_info</code></td>
<td>
<p>a character string vector (concatenated REF and ALT field of the vcf)</p>
</td></tr>
<tr><td><code id="extract_allele_names_+3A_allele_idx">allele_idx</code></td>
<td>
<p>Matrix with indexes of the two alleles of interest for the different markers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extract the alleles from the REF and ALT fields
</p>


<h3>Value</h3>

<p>Return a matrix with the two alleles after parsing the alleles info
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.extract_allele_names(c("A,C","A,C,T"),rbind(c(1,2),c(1,3)))

</code></pre>

<hr>
<h2 id='extract_nonvscan_counts'>extract_nonvscan_counts</h2><span id='topic+extract_nonvscan_counts'></span><span id='topic+.extract_nonvscan_counts'></span>

<h3>Description</h3>

<p>Extract counts from vcf produced by other caller than VarScan (e.g., bcftools, FreeBayes, GATK)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.extract_nonvscan_counts(vcf_data, nb_all, ad_idx, min_rc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_nonvscan_counts_+3A_vcf_data">vcf_data</code></td>
<td>
<p>a matrix of String containing count information</p>
</td></tr>
<tr><td><code id="extract_nonvscan_counts_+3A_nb_all">nb_all</code></td>
<td>
<p>a vector containing the number of alleles for the different markers</p>
</td></tr>
<tr><td><code id="extract_nonvscan_counts_+3A_ad_idx">ad_idx</code></td>
<td>
<p>the index of the FORMAT AD field</p>
</td></tr>
<tr><td><code id="extract_nonvscan_counts_+3A_min_rc">min_rc</code></td>
<td>
<p>Minimal allowed read count per base (same as min.rc option in <code><a href="#topic+vcf2pooldata">vcf2pooldata</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extract VarScan counts and return read counts for the reference and alternate allele
</p>


<h3>Value</h3>

<p>A numeric matrix of read count with nsnp rows and 2*npools+6 columns.
The first npools columns consist of read count for the reference allele,
columns npools+1 to 2*npools consist of read coverage. The last 6 columns correspond to 
the index of the two most frequent alleles (idx_all1 and idx_all2) and their count (cnt_all1 and cnt_all2);
the min_rc filtering criterion and count of variant (cnt_bases) other than two first most frequent. The min_rc crit is
set to -1 for polymorphisms with more than 2 alleles and with the third most frequent alleles having 
more than min_rc count
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.extract_nonvscan_counts(rbind(c("0/0:20,0","1/1:1,18"),c("0/2:12,1,15","1/1:27,1,0")),c(2,3),2,0)
.extract_nonvscan_counts(rbind(c("0/0:20,0","1/1:1,18"),c("0/2:12,1,15","1/1:27,1,0")),c(2,3),2,2)
</code></pre>

<hr>
<h2 id='extract_vscan_counts'>extract_vscan_counts</h2><span id='topic+extract_vscan_counts'></span><span id='topic+.extract_vscan_counts'></span>

<h3>Description</h3>

<p>Extract VarScan counts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.extract_vscan_counts(vcf_data, ad_idx, rd_idx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_vscan_counts_+3A_vcf_data">vcf_data</code></td>
<td>
<p>a matrix of String containing count information in VarScan format</p>
</td></tr>
<tr><td><code id="extract_vscan_counts_+3A_ad_idx">ad_idx</code></td>
<td>
<p>the index of the FORMAT AD field</p>
</td></tr>
<tr><td><code id="extract_vscan_counts_+3A_rd_idx">rd_idx</code></td>
<td>
<p>the index of the FORMAT RD field</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extract VarScan counts and return read counts for the reference and alternate allele.
For VarScan generated vcf, SNPs with more than one alternate allele are discarded 
(because only a single count is then reported in the AD fields) making the min.rc unavailable (of vcf2pooldata).
The VarScan &ndash;min-reads2 option might replace to some extent the min.rc functionality although 
SNP where the two major alleles in the Pool-Seq data are different from the reference allele 
(e.g., expected to be more frequent when using a distantly related reference genome for mapping) 
will be disregarded.
</p>


<h3>Value</h3>

<p>A numeric matrix of read count with nsnp rows and 2*npools columns.
The first npools columns consist of read count for the reference allele (RD),
columns npools+1 to 2*npools consist of read coverage (RD+AD)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.extract_vscan_counts(rbind(c("0/0:0:20","1/1:18:1"),c("0/1:12:15","1/1:27:2")),3,2)

</code></pre>

<hr>
<h2 id='find_indelneighbor_idx'>find_indelneighbor_idx</h2><span id='topic+find_indelneighbor_idx'></span><span id='topic+.find_indelneighbor_idx'></span>

<h3>Description</h3>

<p>Search for the closest indels of the markers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.find_indelneighbor_idx(contig, position, indels_idx, min_dist, indels_size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_indelneighbor_idx_+3A_contig">contig</code></td>
<td>
<p>a character string vector corresponding to the CHR field value of the vcf for the markers</p>
</td></tr>
<tr><td><code id="find_indelneighbor_idx_+3A_position">position</code></td>
<td>
<p>an integer vector corresponding to the POSITION value for the markers</p>
</td></tr>
<tr><td><code id="find_indelneighbor_idx_+3A_indels_idx">indels_idx</code></td>
<td>
<p>vector of (0-indexed) indices of indels</p>
</td></tr>
<tr><td><code id="find_indelneighbor_idx_+3A_min_dist">min_dist</code></td>
<td>
<p>same as min.dist.from.indels option in <code><a href="#topic+vcf2pooldata">vcf2pooldata</a></code></p>
</td></tr>
<tr><td><code id="find_indelneighbor_idx_+3A_indels_size">indels_size</code></td>
<td>
<p>size of the indels (associated to indels_idx)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Identify if the SNPs are close to an indel
</p>


<h3>Value</h3>

<p>Return a vector consisting of 1 (if the marker is close to an indel) or 0 (if not)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.find_indelneighbor_idx(c("chr1","chr1","chr1"),c(1000,1004,1020),1,5,2)

</code></pre>

<hr>
<h2 id='find.tree.popset'>Find sets of populations that may used as scaffold tree</h2><span id='topic+find.tree.popset'></span>

<h3>Description</h3>

<p>Find sets of populations that may used as scaffold tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.tree.popset(
  fstats,
  f3.zcore.threshold = -1.65,
  f4.zscore.absolute.threshold = 1.96,
  excluded.pops = NULL,
  nthreads = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.tree.popset_+3A_fstats">fstats</code></td>
<td>
<p>Object of class fstats containing estimates of fstats (see the function compute.fstats)</p>
</td></tr>
<tr><td><code id="find.tree.popset_+3A_f3.zcore.threshold">f3.zcore.threshold</code></td>
<td>
<p>The significance threshold for Z-score of formal test of admixture based on the F3-statistics (default=-2)</p>
</td></tr>
<tr><td><code id="find.tree.popset_+3A_f4.zscore.absolute.threshold">f4.zscore.absolute.threshold</code></td>
<td>
<p>The significance threshold for |Z-score| of formal test of treeness based on the F4-statistics  (default=2)</p>
</td></tr>
<tr><td><code id="find.tree.popset_+3A_excluded.pops">excluded.pops</code></td>
<td>
<p>Vector of pop names to be exclude from the exploration</p>
</td></tr>
<tr><td><code id="find.tree.popset_+3A_nthreads">nthreads</code></td>
<td>
<p>Number of available threads for parallelization of some part of the parsing (default=1, i.e., no parallelization)</p>
</td></tr>
<tr><td><code id="find.tree.popset_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE extra information is printed on the terminal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure first discards all the populations P that shows a significant signal of admixture with a Z-score for F3 statistics of the form F3(P;Q,R) &lt; f3.zscore.thresholds. It then identifies all the sets of populations that pass the F4-based treeness with themselves. More precisely, for a given set E containing n populations, the procedure ensure that all the n(n-1)(n-2)(n-3)/8 possible F4 quadruplets have a |Z-score|&lt;f4.zscore.absolute.threshold. The function aims at maximizing the size of the sets.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ol>
<li><p> &quot;n.sets&quot;: The number of sets of (scaffold) unadmixed populations identified
</p>
</li>
<li><p> &quot;set.size&quot;: The number of populations included in each set
</p>
</li>
<li><p> &quot;pop.sets&quot;: A character matrix of n.sets rows and set.size columns giving for each set identified the names of the included populations.
</p>
</li>
<li><p> &quot;Z_f4.range&quot;: A matrix of n.sets rows and 2 columns reported for each set the range of variation (min and max value) of the absolute F4 Z-scores for the quadruplets passing the treeness test. More precisely, for a given set consisting of n=set.size populations, a total of n(n-1)(n-2)(n-3)/8 quadruplets can be formed. Yet, any set of four populations A, B, C and D is represented by three quadruplets A,B;C,D (or one of its seven other equivalent combinations formed by permuting each pairs); A,C;B,D (or one of its seven other equivalent combinations) and A,D;B,C (or one of its seven other combinations). Among these three, only a single quadruplet is expected to pass the treeness test (i.e., if the correct unrooted tree topology is (A,C;B,D), then the absoulte value of the Z-scores associated to F4(A,B;C,D) and F4(A,D;B,C) or their equivalent will be high. 
</p>
</li>
<li><p> &quot;passing.quadruplets&quot;: A matrix of n.sets rows and set.size columns reporting for each sets the n(n-1)(n-2)(n-3)/24 quadruplets that pass the treeness test (see Z_f4.range detail). 
</p>
</li></ol>



<h3>See Also</h3>

<p>see <code><a href="#topic+compute.fstats">compute.fstats</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make.example.files(writing.dir=tempdir())
pooldata=popsync2pooldata(sync.file=paste0(tempdir(),"/ex.sync.gz"),poolsizes=rep(50,15))
res.fstats=compute.fstats(pooldata,nsnp.per.bjack.block = 50) 
#NOTE: toy example (in practice nsnp.per.bjack.block should be higher)
popsets=find.tree.popset(res.fstats,f3.zcore.threshold=-3)  
</code></pre>

<hr>
<h2 id='fit.graph'>Estimate parameters of an admixture graph</h2><span id='topic+fit.graph'></span>

<h3>Description</h3>

<p>Estimate parameters of an admixture graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.graph(
  graph.params,
  Q.lambda = 0,
  eps.admix.prop = 1e-06,
  edge.fact = 1000,
  admix.fact = 100,
  compute.ci = F,
  drift.scaling = F,
  outfileprefix = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.graph_+3A_graph.params">graph.params</code></td>
<td>
<p>An object of class graph.params containing graph information and relevant Fstats estimates (see the function generate.graph.params)</p>
</td></tr>
<tr><td><code id="fit.graph_+3A_q.lambda">Q.lambda</code></td>
<td>
<p>A scalar (usually small) to add to the diagonal elements of the error covariance matrix of fstats estimates (may improve numerical stability of its decomposition for large number of populations)</p>
</td></tr>
<tr><td><code id="fit.graph_+3A_eps.admix.prop">eps.admix.prop</code></td>
<td>
<p>A scalar defining admixture proportion domain (eps.admix.prop vary between eps.admix.prop and 1-eps.admix.prop)</p>
</td></tr>
<tr><td><code id="fit.graph_+3A_edge.fact">edge.fact</code></td>
<td>
<p>The multiplying factor of edges length in graph representation</p>
</td></tr>
<tr><td><code id="fit.graph_+3A_admix.fact">admix.fact</code></td>
<td>
<p>The multiplying factor of admixture proportion in graph representation</p>
</td></tr>
<tr><td><code id="fit.graph_+3A_compute.ci">compute.ci</code></td>
<td>
<p>Derive 95% Confidence Intervals for the parameters of the admixture graph (edge lengths and admixture rates)</p>
</td></tr>
<tr><td><code id="fit.graph_+3A_drift.scaling">drift.scaling</code></td>
<td>
<p>If TRUE scale edge lengths in drift units (require estimates of leave heterozygosities)</p>
</td></tr>
<tr><td><code id="fit.graph_+3A_outfileprefix">outfileprefix</code></td>
<td>
<p>The prefix of the dot file that will represent the graph (with extension &quot;.dot&quot;). If NULL, no graph file generated</p>
</td></tr>
<tr><td><code id="fit.graph_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE extra information is printed on the terminal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">f</code> represent the n-length vector of basis target (i.e., observed)  F2 and F3 statistics and <code class="reqn">g(e;a)=X(a)*e</code> the vector of their expected values given the vector of graph edges lengths <code class="reqn">e</code> and the incidence matrix <code class="reqn">X(a)</code> that depends on the structure of the graph and the admixture rates <code class="reqn">a</code> (if there is no admixture in the graph, <code class="reqn">X(a)</code> only contains 0 or 1). The function attempts to find the  <code class="reqn">e</code> and <code class="reqn">a</code> graph parameter values that minimize a cost (score of the model) defined as <code class="reqn">S(e;a)=(f-g(e;a))'Q^{-1}(f-g(e;a))</code>. Assuming <code class="reqn">f~N(g(e;a),Q)</code> (i.e., the observed f-statistics vector is multivariate normal distributed around an expected g vector specified by the admixture graph and a covariance structure empirically estimated), <code class="reqn">S=-2log(L) - K</code> where <code class="reqn">L</code> is the likelihood of the fitted graph and <code class="reqn">K=n*log(2*pi)+log(|Q|)</code>. Also, for model comparison purpose, a standard <code class="reqn">BIC</code> is then derived from <code class="reqn">S</code> as <code class="reqn">BIC= S + p*log(n) - K</code> (p being the number of graph parameters, i.e., edge lengths and admixture rates). 
As mentioned by Patterson et al. (2012), the score <code class="reqn">S(e;a)</code> is quadratic in edge lengths <code class="reqn">e</code> given <code class="reqn">a</code>. The function uses the Lawson-Hanson non-negative linear least squares algorithm implemented in the nnls function (package nnls) to estimate <code class="reqn">e</code> (subject to the constraint of positive edge lengths) by finding the vector <code class="reqn">e</code> that minimize <code class="reqn">S(e;a)=(f-X(a)*e)'Q^{-1}(f-X(a)*e)=||G*f-G*X(a)*e||</code> (where <code class="reqn">G</code> results from the Cholesky decomposition of <code class="reqn">Q^{-1}</code>, i.e., <code class="reqn">Q^{-1}=G'G</code>). Note that the *Q.lambda* argument may be used to add a small constant (e.g., <code class="reqn">1e-4</code>) to the diagonal elements of <code class="reqn">Q</code> to avoid numerical problems (see Patterson et al., 2012). Yet *Q.lambda* is always disregarded when computing the final score <code class="reqn">S</code> and <code class="reqn">BIC</code>. Minimization of <code class="reqn">S(e;a)</code> is thus reduced to the identification of the admixture rates (<code class="reqn">a</code> vector) which is performed using the L-BFGS-B  method (i.e., Limited-memory Broyden-Fletcher-Goldfarb-Shanno algorithm with box constraints) implemented in the optim function (stats package). The *eps.admix.prop* argument allows specifying the lower and upper bound of the admixture rates to *eps.admix.prop* and *1-eps.admix.prop* respectively.
Scaling of the edges lengths in drift units (i.e., in units of <code class="reqn">t/2N</code> where <code class="reqn">t</code> is time in generations and <code class="reqn">N</code> is the effective population size) is performed as described in Lipson et al. (MBE, 2013) by dividing the estimated edges lengths by half the estimated heterozygosity of their parental nodes (using the property <code class="reqn">hp=hc+2e(C,P)</code> where <code class="reqn">hp</code> and <code class="reqn">hc</code> are the heterozygosities of a child C and its parent P node and <code class="reqn">e(C,P)</code> is the estimated length of the branch relating C and P.
Finally, if compute.ci=TRUE, a (rough) <code class="reqn">95\%</code> confidence intervals is computed using a bisection method (with a <code class="reqn">1e-4</code> precision) for each parameters in turn (all others being set to their estimated value). Note that <code class="reqn">95\%</code> CI are here defined as the set of values associated to a score <code class="reqn">S</code> such that <code class="reqn">Sopt&lt;S&lt;Sopt+3.84</code> (where <code class="reqn">Sopt</code> is the optimized score), i.e., with a likelihood-ratio test statistic with respect to the fitted values <code class="reqn">&lt;3.84</code> (the <code class="reqn">95\%</code> threshold of a one ddl Chi-square distribution).
</p>


<h3>Value</h3>

<p>An object of class fitted.graph (see help(fitted.graph) for details)
</p>


<h3>See Also</h3>

<p>To generate a graph.params object, see <code><a href="#topic+generate.graph.params">generate.graph.params</a></code>. The fitted graph may be plotted directly using plot that calls grViz() function and the resulting fitted fstats may be compared to the estimated ones with <code><a href="#topic+compare.fitted.fstats">compare.fitted.fstats</a></code>.
</p>

<hr>
<h2 id='fitted.graph-class'>S4 class to represent a population tree or admixture graph and its underlying fitted parameter.</h2><span id='topic+fitted.graph-class'></span><span id='topic+fitted.graph'></span>

<h3>Description</h3>

<p>S4 class to represent a population tree or admixture graph and its underlying fitted parameter.
</p>


<h3>Details</h3>

<p>The dot.graph element allows to plot the graph using grViz() from the DiagrammeR package or with the dot program after writing the files (e.g., dot -Tpng inputgraph.dot in terminal). Note that the dot file may be customized (e.g., to change leave color, parameter names...).
</p>


<h3>Slots</h3>


<dl>
<dt><code>graph</code></dt><dd><p>The graph in 3 column format originated from the fitted graph.params object</p>
</dd>
<dt><code>dot.graph</code></dt><dd><p>The fitted graph in dot format</p>
</dd>
<dt><code>score</code></dt><dd><p>the score of the model (squared Mahalanobis distance between the observed and fitted basis F-statistics vectors)</p>
</dd>
<dt><code>bic</code></dt><dd><p>The Bayesian Information Criterion associated to the model</p>
</dd>
<dt><code>fitted.outstats</code></dt><dd><p>a matrix containing the target values of the fstats, the fitted values and the Z-score measuring the deviation of the fitted values from the target values in units of standard errors (i.e., Z=(fitted.value-target.value)/se(target.value))</p>
</dd>
<dt><code>edges.length</code></dt><dd><p>a vector containing the estimated edges.length. Note finally, that the (two) edges coming from the roots are assumed of equal length (i.e., unrooted branch) as these are non-identifiable by the method.</p>
</dd>
<dt><code>edges.length.scaled</code></dt><dd><p>If drift.scaling=TRUE, the estimated edges.length in units of t/2N</p>
</dd>
<dt><code>edges.length.ci</code></dt><dd><p>A matrix with two columns (or four columns if drift scaled lengths are computed) containing for each edge length (in a row) the 95% CI lower and higher bounds (columns 3 and 4 containing 95% CI lower and higher bounds of drift scaled lengths, if any)</p>
</dd>
<dt><code>admix.prop</code></dt><dd><p>a vector containing the estimated admixture proportions (if any)</p>
</dd>
<dt><code>admix.prop.ci</code></dt><dd><p>a matrix with two columns containing for each admixture proportion (in a row) the 95% CI lower and higher bounds</p>
</dd>
<dt><code>nodes.het</code></dt><dd><p>The estimated heterozygosities for all nodes (if available; see drift.scaling argument in fit.graph)</p>
</dd>
<dt><code>fitted.f2.mat</code></dt><dd><p>the matrix of all the fitted F2 statistics (obtained from fitted admixture graph parameter values) from which all the fitted fstats can be derived.</p>
</dd>
<dt><code>optim.results</code></dt><dd><p>list containing results of the optim call</p>
</dd>
</dl>


<h3>See Also</h3>

<p>To generate fitted.graph object, see <code><a href="#topic+fit.graph">fit.graph</a></code>.
</p>

<hr>
<h2 id='fstats-class'>S4 class to represent fstats results obtained with computeFstats.</h2><span id='topic+fstats-class'></span><span id='topic+fstats'></span>

<h3>Description</h3>

<p>S4 class to represent fstats results obtained with computeFstats.
</p>


<h3>Slots</h3>


<dl>
<dt><code>f2.values</code></dt><dd><p>A data frame with npop(npop-1)/2 rows and 1 (or 3 if blockjackknife is TRUE) columns containing estimates of the f2-statistics over all the SNPs and if blockjackknife=TRUE, the estimated block-jackknife and standard error (s.e.)</p>
</dd>
<dt><code>fst.values</code></dt><dd><p>A data frame with npop(npop-1)/2 rows and 1 (or 3 if blockjackknife is TRUE) columns containing estimates of the scaled f2.values (same as obtained with compute.pairwiseFST with method=&quot;Identity&quot;) over all the SNPs and if blockjackknife=TRUE, the estimated block-jackknife and standard error (s.e.). The F2 scaling factor is equal to 1-Q2 (where Q2 is the AIS probability between the two populations)</p>
</dd>
<dt><code>f3.values</code></dt><dd><p>A data frame with npops(npops-1)(npops-2)/2 rows and 1 (or 4 if blockjackknife is TRUE) columns containing estimates of the f3-statistics over all the SNPs and if blockjackknife=TRUE, the estimated block-jackknife and standard error (s.e.) and Z-score measuring the deviation of the f3-statistics from 0 in units of s.e.</p>
</dd>
<dt><code>f3star.values</code></dt><dd><p>A data frame with npops(npops-1)(npops-2)/2 rows and 1 (or 4 if blockjackknife is TRUE) columns containing estimates of the scaled f3-statistics over all the SNPs and if blockjackknife=TRUE, the estimated block-jackknife and standard error (s.e.) and Z-score measuring the deviation of the f3-statistics from 0 in units of s.e. The F3 scaling factor is equal to 1-Q1 (where Q1 is the AIS probability within the target population, i.e., population C for F3(C;A,B))</p>
</dd>
<dt><code>f4.values</code></dt><dd><p>A data frame with npops(npops-1)(npops-2)(npops-3)/8 rows and 1 (or 4 if blockjackknife is TRUE) columns containing estimates of the f4-statistics over all the SNPs and if blockjackknife=TRUE, the estimated block-jackknife and standard error (s.e.) and Z-score measuring the deviation of the f4-statistics from 0 in units of s.e.</p>
</dd>
<dt><code>Dstat.values</code></dt><dd><p>A data frame with npops(npops-1)(npops-2)(npops-3)/8 rows and 1 (or 4 if blockjackknife is TRUE) columns containing estimates of the D-statistics (scaled f4-statistics) over all the SNPs and if blockjackknife=TRUE, the estimated block-jackknife and standard error (s.e.) and Z-score measuring the deviation of the f3-statistics from 0 in units of s.e. For a given quadruplet (A,B;C,D), the parameter D corresponds to F4(A,B;C,D) scaled by (1-Q2(A,B))*(1-Q2(C,D)) where Q2(X,Y) is the is the AIS probability between the X and Y populations.</p>
</dd>
<dt><code>F2.bjack.samples</code></dt><dd><p>If blockjackknife=TRUE and options return.F2.blockjackknife.samples is actived in compute.fstats, an array of dimension (npop x npop x nblocks) in an admixtools2 compatible format</p>
</dd>
<dt><code>comparisons</code></dt><dd><p>A list containing matrices with population names associated to the different test comparisons (e.g., the &quot;F2&quot; elements of the list is a npop(npop-1)/2 rows x 2 columns with each row containing the name of the two populations compared)</p>
</dd>
<dt><code>Q.matrix</code></dt><dd><p>The estimated error covariance matrix for all the F2 and F3 estimates (required by graph fitting functions to compute graph scores)</p>
</dd>
<dt><code>heterozygosities</code></dt><dd><p>A data frame with npop rows and 1 (or 3 if blockjackknife is TRUE) columns containing estimates of the within population heterozygosities (1-Q1) over all the SNPs and if blockjackknife=TRUE, the estimated block-jackknife and standard error (s.e.)</p>
</dd>
<dt><code>divergence</code></dt><dd><p>A data frame with npop(npop-1)/2 rows and 1 (or 3 if blockjackknife is TRUE) column(s) containing estimates of each population pairwise (absolute) divergence (1-Q2) over all the SNPs and if blockjackknife=TRUE, the estimated block-jackknife and standard error (s.e.). This statistic is related to dXY (a.k.a. PiXY) but it is computed on the ascertained SNPs that were included in the original pooldata or countdata objects.</p>
</dd>
<dt><code>pairwise.fst</code></dt><dd><p>A npop x npop (symmetric) matrix containing the pairwise-population Fst estimates (same as in the fst.values object) that may directly be visualized with e.g. heatmap function or used with a clustering function (e.g., hclust).</p>
</dd>
<dt><code>pairwise.div</code></dt><dd><p>A npop x npop (symmetric) matrix containing the pairwise-population divergence (1-Q2) estimates (same as in the fst.values object) that may directly be visualized with e.g. heatmap function or used with a clustering function (e.g., hclust).</p>
</dd>
<dt><code>blockjacknife</code></dt><dd><p>A logical indicating whether block-jackknife estimates of standard errors are available (TRUE) or not (FALSE)</p>
</dd>
</dl>


<h3>See Also</h3>

<p>To generate pairwise object, see <code><a href="#topic+compute.pairwiseFST">compute.pairwiseFST</a></code>
</p>

<hr>
<h2 id='generate.graph.params'>Generate a graph parameter object to fit admixture graph to observed fstats</h2><span id='topic+generate.graph.params'></span>

<h3>Description</h3>

<p>Generate a graph parameter object to fit admixture graph to observed fstats
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.graph.params(
  graph,
  fstats = NULL,
  popref = NULL,
  outfileprefix = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.graph.params_+3A_graph">graph</code></td>
<td>
<p>A three columns matrix containing graph information in a simple format (see details)</p>
</td></tr>
<tr><td><code id="generate.graph.params_+3A_fstats">fstats</code></td>
<td>
<p>A fstats object containing estimates of fstats</p>
</td></tr>
<tr><td><code id="generate.graph.params_+3A_popref">popref</code></td>
<td>
<p>Reference population of the fstats basis used to fit the graph.</p>
</td></tr>
<tr><td><code id="generate.graph.params_+3A_outfileprefix">outfileprefix</code></td>
<td>
<p>The prefix of the dot file that will represent the graph (with extension &quot;.dot&quot;). If NULL, no graph file generated</p>
</td></tr>
<tr><td><code id="generate.graph.params_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE some information is printed on the terminal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The graph needs to be specified by a three column (character) matrix corresponding for each edge (wether admixed or not) to i) the child node; ii) the parent node; iii) the admixture proportion. For non-admixed edge, the third column must be blank. An admixed node should be referred two times as a child node with two different parent node and two different admixture proportions coded as alpha and (1-alpha) (Note that the parentheses are mandatory) if alpha is the name of the admixture proportion. The root is automatically identified as a node only present in the parent node column. Several checks are made within the function but it is recommended to check the graph by plotting the resulting dot file named outfileprefix.dot using for instance the grViz() from the DiagrammeR package that may be called directly with plot or with the dot program (e.g., dot -Tpng inputgraph.dot in terminal). Note that the dot file may be easily customized (e.g., to change leave color, parameter names...). The fstats object should be of class fstats (see help(fstats) for details) containing estimates of F2 and F3 statistics and block jackknife as generated with the <code><a href="#topic+compute.fstats">compute.fstats</a></code> function with computeF3 set to TRUE. If no fstats object is provided, only graph parameters will be generated.
</p>


<h3>Value</h3>

<p>An object of class graph.params (see help(graph.params) for details)
</p>


<h3>See Also</h3>

<p>The object may be used to estimate graph parameters with the function <code><a href="#topic+fit.graph">fit.graph</a></code> or to generate files for the qpGraph software with <code><a href="#topic+graph.params2qpGraphFiles">graph.params2qpGraphFiles</a></code>. See also <code><a href="#topic+graph.params2symbolic.fstats">graph.params2symbolic.fstats</a></code> to obtain symbolic representation of Fstats.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph=rbind(c("P1","P7",""),c("P2","s1",""),c("P3","s2",""),c("P6","S",""),
            c("S","s1","a"),c("S","s2","(1-a)"),c("s2","P8",""),c("s1","P7",""),
            c("P4","P9",""),c("P5","P9",""),c("P7","P8",""),
            c("P8","R",""),c("P9","R","")) 
graph.params=generate.graph.params(graph)
plot(graph.params)
##NOTE: this calls grViz from DiagrammeR which cannot easily be plotted 
#within pdf or other device. To that end the easiest is to output 
#the graph in a dot file (using the outfileprefix argument) and 
#then to use the dot program out of R in a terminal: dot -Tpng inputgraph.dot
</code></pre>

<hr>
<h2 id='generate.jackknife.blocks'>Generate block coordinates for block-jackknife</h2><span id='topic+generate.jackknife.blocks'></span>

<h3>Description</h3>

<p>Generate block coordinates for block-jackknife
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.jackknife.blocks(x, nsnp.per.bjack.block, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.jackknife.blocks_+3A_x">x</code></td>
<td>
<p>A pooldata or countdata object containing SNP positions (snp.info slot)</p>
</td></tr>
<tr><td><code id="generate.jackknife.blocks_+3A_nsnp.per.bjack.block">nsnp.per.bjack.block</code></td>
<td>
<p>Number of consecutive SNPs of each block-jackknife block</p>
</td></tr>
<tr><td><code id="generate.jackknife.blocks_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE extra information is printed on the terminal</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the two following elements:
</p>

<ol>
<li><p> &quot;blocks.det&quot;: A matrix with three columns containing for each identified block (in row) the index of the start SNP, the index of the end SNP and the block Size in bp
</p>
</li>
<li><p> &quot;snp.block.id&quot;: A vector containing the blocks assigned to each SNP eligible for block-Jacknife (non eligible SNPs ares assigned NA)
</p>
</li>
<li><p> &quot;nblocks&quot;: A scalar corresponding to the number of blocks
</p>
</li>
<li><p> &quot;nsnps&quot;: Number of SNPs eligible for block-jackknife 'i.e., included in one block
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>make.example.files(writing.dir=tempdir())
pooldata=popsync2pooldata(sync.file=paste0(tempdir(),"/ex.sync.gz"),poolsizes=rep(50,15))
bjack.blocks=generate.jackknife.blocks(pooldata,nsnp.per.bjack.block=50)
</code></pre>

<hr>
<h2 id='generateF3names'>generateF3names</h2><span id='topic+generateF3names'></span><span id='topic+.generateF3names'></span>

<h3>Description</h3>

<p>Generate all names for F3 stats (same order as computation)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.generateF3names(popnames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateF3names_+3A_popnames">popnames</code></td>
<td>
<p>String vector with the names of all the pops</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generate all the npops*(npops-1)*(npops-2)/2 names for F3 stats (same order as computation)
</p>


<h3>Value</h3>

<p>Return a string matrix with 4 columns including the complete F3 configuration names (of the form Px;P1,P2), and the names of each pop involved in the configuration
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
</code></pre>

<hr>
<h2 id='generateF4names'>generateF4names</h2><span id='topic+generateF4names'></span><span id='topic+.generateF4names'></span>

<h3>Description</h3>

<p>Generate all names for F4 stats (same order as computation)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.generateF4names(popnames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateF4names_+3A_popnames">popnames</code></td>
<td>
<p>String vector with the names of all the pops</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generate all the nf4=(npops*(npops-1)/2)*((npops-2)*(npops-3)/2)/2 names for F4 stats (same order as computation)
</p>


<h3>Value</h3>

<p>Return a string matrix with 5 columns including the complete F4 configuration names (of the form P1,P2;P3,P4), and the names of each pop involved in the configuration
</p>
<p>#
</p>

<hr>
<h2 id='genobaypass2countdata'>Convert BayPass allele count input files into a coundata object</h2><span id='topic+genobaypass2countdata'></span>

<h3>Description</h3>

<p>Convert BayPass allele count input files into a coundata object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genobaypass2countdata(
  genobaypass.file = "",
  snp.pos = NA,
  popnames = NA,
  min.indgeno.per.pop = -1,
  min.maf = -1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genobaypass2countdata_+3A_genobaypass.file">genobaypass.file</code></td>
<td>
<p>The name (or a path) of the BayPass allele count file (see the BayPass manual <a href="https://forgemia.inra.fr/mathieu.gautier/baypass_public/">https://forgemia.inra.fr/mathieu.gautier/baypass_public/</a>)</p>
</td></tr>
<tr><td><code id="genobaypass2countdata_+3A_snp.pos">snp.pos</code></td>
<td>
<p>An optional two column matrix with nsnps rows containing the chromosome (or contig/scaffold) of origin and the position of each markers</p>
</td></tr>
<tr><td><code id="genobaypass2countdata_+3A_popnames">popnames</code></td>
<td>
<p>A character vector with the names of pool</p>
</td></tr>
<tr><td><code id="genobaypass2countdata_+3A_min.indgeno.per.pop">min.indgeno.per.pop</code></td>
<td>
<p>Minimal number of overall counts required in each population. If at least one pop is not genotyped for at least min.indgeno.per.pop (haploid) individual, the position is discarded</p>
</td></tr>
<tr><td><code id="genobaypass2countdata_+3A_min.maf">min.maf</code></td>
<td>
<p>Minimal allowed Minor Allele Frequency (computed from the ratio overall counts for the reference allele over the overall number of (haploid) individual genotyped)</p>
</td></tr>
<tr><td><code id="genobaypass2countdata_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE extra information is printed on the terminal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Information on SNP position is only required for some graphical display or to carried out block-jacknife sampling estimation of confidence intervals. If no mapping information is given (default), SNPs will be assumed to be ordered on the same chromosome and separated by 1 bp. As blocks are defined with a number of consecutive SNPs (rather than a length), the latter assumption has actually no effect (except in the reported estimated block sizes in Mb).
</p>


<h3>Value</h3>

<p>A countdata object containing 6 elements:
</p>

<ol>
<li><p> &quot;refallele.count&quot;: a matrix (nsnp rows and npops columns) with the allele counts for the reference allele
</p>
</li>
<li><p> &quot;total.count&quot;: a matrix (nsnp rows and npops columns) with the total number of counts (i.e., twice the number of genotyped individual for diploid species and autosomal markers)
</p>
</li>
<li><p> &quot;snp.info&quot;: a matrix with nsnp rows and four columns containing respectively the contig (or chromosome) name (1st column) and position (2nd column) of the SNP; the allele taken as reference in the refallele.count matrix (3rd column); and the alternative allele (4th column)
</p>
</li>
<li><p> &quot;popnames&quot;: a vector of length npops containing the names of the pops
</p>
</li>
<li><p> &quot;nsnp&quot;: a scalar corresponding to the number of SNPs
</p>
</li>
<li><p> &quot;npops&quot;: a scalar corresponding to the number of populations
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'> make.example.files(writing.dir=tempdir())
 pooldata=popsync2pooldata(sync.file=paste0(tempdir(),"/ex.sync.gz"),poolsizes=rep(50,15))
 pooldata2genobaypass(pooldata=pooldata,writing.dir=tempdir())
 ##NOTE: This example is just for the sake of illustration as it amounts 
 ##to interpret read count as allele count which must not be done in practice!
 countdata=genobaypass2countdata(genobaypass.file=paste0(tempdir(),"/genobaypass")) 
</code></pre>

<hr>
<h2 id='genobaypass2pooldata'>Convert BayPass read count and haploid pool size input files into a pooldata object</h2><span id='topic+genobaypass2pooldata'></span>

<h3>Description</h3>

<p>Convert BayPass read count and haploid pool size input files into a pooldata object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genobaypass2pooldata(
  genobaypass.file = "",
  poolsize.file = "",
  snp.pos = NA,
  poolnames = NA,
  min.cov.per.pool = -1,
  max.cov.per.pool = 1e+06,
  min.maf = -1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genobaypass2pooldata_+3A_genobaypass.file">genobaypass.file</code></td>
<td>
<p>The name (or a path) of the BayPass read count file (see the BayPass manual <a href="https://forgemia.inra.fr/mathieu.gautier/baypass_public/">https://forgemia.inra.fr/mathieu.gautier/baypass_public/</a>)</p>
</td></tr>
<tr><td><code id="genobaypass2pooldata_+3A_poolsize.file">poolsize.file</code></td>
<td>
<p>The name (or a path) of the BayPass (haploid) pool size file (see the BayPass manual <a href="https://forgemia.inra.fr/mathieu.gautier/baypass_public/">https://forgemia.inra.fr/mathieu.gautier/baypass_public/</a>)</p>
</td></tr>
<tr><td><code id="genobaypass2pooldata_+3A_snp.pos">snp.pos</code></td>
<td>
<p>An optional two column matrix with nsnps rows containing the chromosome (or contig/scaffold) of origin and the position of each markers</p>
</td></tr>
<tr><td><code id="genobaypass2pooldata_+3A_poolnames">poolnames</code></td>
<td>
<p>A character vector with the names of pool</p>
</td></tr>
<tr><td><code id="genobaypass2pooldata_+3A_min.cov.per.pool">min.cov.per.pool</code></td>
<td>
<p>Minimal allowed read count (per pool). If at least one pool is not covered by at least min.cov.perpool reads, the position is discarded</p>
</td></tr>
<tr><td><code id="genobaypass2pooldata_+3A_max.cov.per.pool">max.cov.per.pool</code></td>
<td>
<p>Maximal allowed read count (per pool). If at least one pool is covered by more than min.cov.perpool reads, the position is discarded</p>
</td></tr>
<tr><td><code id="genobaypass2pooldata_+3A_min.maf">min.maf</code></td>
<td>
<p>Minimal allowed Minor Allele Frequency (computed from the ratio overall read counts for the reference allele over the read coverage)</p>
</td></tr>
<tr><td><code id="genobaypass2pooldata_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE extra information is printed on the terminal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Information on SNP position is only required for some graphical display or to carried out block-jacknife sampling estimation of confidence intervals. If no mapping information is given (default), SNPs will be assumed to be ordered on the same chromosome and separated by 1 bp. As blocks are defined with a number of consecutive SNPs (rather than a length), the latter assumption has actually no effect (except in the reported estimated block sizes in Mb).
</p>


<h3>Value</h3>

<p>A pooldata object containing 7 elements:
</p>

<ol>
<li><p> &quot;refallele.readcount&quot;: a matrix with nsnp rows and npools columns containing read counts for the reference allele (chosen arbitrarily) in each pool
</p>
</li>
<li><p> &quot;readcoverage&quot;: a matrix with nsnp rows and npools columns containing read coverage in each pool
</p>
</li>
<li><p> &quot;snp.info&quot;: a matrix with nsnp rows and four columns containing respectively the contig (or chromosome) name (1st column) and position (2nd column) of the SNP; the allele taken as reference in the refallele.readcount matrix (3rd column); and the alternative allele (4th column)
</p>
</li>
<li><p> &quot;poolsizes&quot;: a vector of length npools containing the haploid pool sizes
</p>
</li>
<li><p> &quot;poolnames&quot;: a vector of length npools containing the names of the pools
</p>
</li>
<li><p> &quot;nsnp&quot;: a scalar corresponding to the number of SNPs
</p>
</li>
<li><p> &quot;npools&quot;: a scalar corresponding to the number of pools
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'> make.example.files(writing.dir=tempdir())
 pooldata=popsync2pooldata(sync.file=paste0(tempdir(),"/ex.sync.gz"),poolsizes=rep(50,15))
 pooldata2genobaypass(pooldata=pooldata,writing.dir=tempdir())
 pooldata=genobaypass2pooldata(genobaypass.file=paste0(tempdir(),"/genobaypass"),
                               poolsize.file=paste0(tempdir(),"/poolsize"))
</code></pre>

<hr>
<h2 id='genoselestim2pooldata'>Convert SelEstim read count input files into a pooldata object</h2><span id='topic+genoselestim2pooldata'></span>

<h3>Description</h3>

<p>Convert SelEstim read count input files into a pooldata object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genoselestim2pooldata(
  genoselestim.file = "",
  poolnames = NA,
  min.cov.per.pool = -1,
  max.cov.per.pool = 1e+06,
  min.maf = -1,
  nlines.per.readblock = 1e+06,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genoselestim2pooldata_+3A_genoselestim.file">genoselestim.file</code></td>
<td>
<p>The name (or a path) of the SelEstim read count file (see the SelEstim manual <a href="https://www1.montpellier.inrae.fr/CBGP/software/selestim/">https://www1.montpellier.inrae.fr/CBGP/software/selestim/</a>)</p>
</td></tr>
<tr><td><code id="genoselestim2pooldata_+3A_poolnames">poolnames</code></td>
<td>
<p>A character vector with the names of pool</p>
</td></tr>
<tr><td><code id="genoselestim2pooldata_+3A_min.cov.per.pool">min.cov.per.pool</code></td>
<td>
<p>Minimal allowed read count (per pool). If at least one pool is not covered by at least min.cov.perpool reads, the position is discarded</p>
</td></tr>
<tr><td><code id="genoselestim2pooldata_+3A_max.cov.per.pool">max.cov.per.pool</code></td>
<td>
<p>Maximal allowed read count (per pool). If at least one pool is covered by more than min.cov.perpool reads, the position is discarded</p>
</td></tr>
<tr><td><code id="genoselestim2pooldata_+3A_min.maf">min.maf</code></td>
<td>
<p>Minimal allowed Minor Allele Frequency (computed from the ratio overal read counts for the reference allele over the read coverage)</p>
</td></tr>
<tr><td><code id="genoselestim2pooldata_+3A_nlines.per.readblock">nlines.per.readblock</code></td>
<td>
<p>Number of Lines read simultaneously. Should be adapted to the available RAM.</p>
</td></tr>
<tr><td><code id="genoselestim2pooldata_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE extra information is printed on the terminal</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A pooldata object containing 7 elements:
</p>

<ol>
<li><p> &quot;refallele.readcount&quot;: a matrix with nsnp rows and npools columns containing read counts for the reference allele (chosen arbitrarily) in each pool
</p>
</li>
<li><p> &quot;readcoverage&quot;: a matrix with nsnp rows and npools columns containing read coverage in each pool
</p>
</li>
<li><p> &quot;snp.info&quot;: a matrix with nsnp rows and four columns containing respectively the contig (or chromosome) name (1st column) and position (2nd column) of the SNP; the allele taken as reference in the refallele.readcount matrix (3rd column); and the alternative allele (4th column)
</p>
</li>
<li><p> &quot;poolsizes&quot;: a vector of length npools containing the haploid pool sizes
</p>
</li>
<li><p> &quot;poolnames&quot;: a vector of length npools containing the names of the pools
</p>
</li>
<li><p> &quot;nsnp&quot;: a scalar corresponding to the number of SNPs
</p>
</li>
<li><p> &quot;npools&quot;: a scalar corresponding to the number of pools
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'> make.example.files(writing.dir=tempdir())
 pooldata=popsync2pooldata(sync.file=paste0(tempdir(),"/ex.sync.gz"),poolsizes=rep(50,15))
 pooldata2genoselestim(pooldata=pooldata,writing.dir=tempdir())
 pooldata=genoselestim2pooldata(genoselestim.file=paste0(tempdir(),"/genoselestim"))
</code></pre>

<hr>
<h2 id='genotreemix2countdata'>Convert allele count input files from the Treemix program into a coundata object</h2><span id='topic+genotreemix2countdata'></span>

<h3>Description</h3>

<p>Convert allele count input files from the Treemix program into a coundata object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genotreemix2countdata(
  genotreemix.file = "",
  snp.pos = NA,
  min.indgeno.per.pop = -1,
  min.maf = -1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genotreemix2countdata_+3A_genotreemix.file">genotreemix.file</code></td>
<td>
<p>The name (or a path) of the Treemix allele count file (see the Treemix manual <a href="https://bitbucket.org/nygcresearch/treemix/wiki/Home">https://bitbucket.org/nygcresearch/treemix/wiki/Home</a>)</p>
</td></tr>
<tr><td><code id="genotreemix2countdata_+3A_snp.pos">snp.pos</code></td>
<td>
<p>An optional two column matrix with nsnps rows containing the chromosome (or contig/scaffold) of origin and the position of each markers</p>
</td></tr>
<tr><td><code id="genotreemix2countdata_+3A_min.indgeno.per.pop">min.indgeno.per.pop</code></td>
<td>
<p>Minimal number of overall counts required in each population. If at least one pop is not genotyped for at least min.indgeno.per.pop (haploid) individual, the position is discarded</p>
</td></tr>
<tr><td><code id="genotreemix2countdata_+3A_min.maf">min.maf</code></td>
<td>
<p>Minimal allowed Minor Allele Frequency (computed from the ratio overall counts for the reference allele over the overall number of (haploid) individual genotyped)</p>
</td></tr>
<tr><td><code id="genotreemix2countdata_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE extra information is printed on the terminal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Information on SNP position is only required for some graphical display or to carried out block-jacknife sampling estimation of confidence intervals. If no mapping information is given (default), SNPs will be assumed to be ordered on the same chromosome and separated by 1 bp. As blocks are defined with a number of consecutive SNPs (rather than a length), the latter assumption has actually no effect (except in the reported estimated block sizes in Mb).
</p>


<h3>Value</h3>

<p>A countdata object containing 6 elements:
</p>

<ol>
<li><p> &quot;refallele.count&quot;: a matrix (nsnp rows and npops columns) with the allele counts for the reference allele
</p>
</li>
<li><p> &quot;total.count&quot;: a matrix (nsnp rows and npops columns) with the total number of counts (i.e., twice the number of genotyped individual for diploid species and autosomal markers)
</p>
</li>
<li><p> &quot;snp.info&quot;: a matrix with nsnp rows and four columns containing respectively the contig (or chromosome) name (1st column) and position (2nd column) of the SNP; the allele taken as reference in the refallele.count matrix (3rd column); and the alternative allele (4th column)
</p>
</li>
<li><p> &quot;popnames&quot;: a vector of length npops containing the names of the pops
</p>
</li>
<li><p> &quot;nsnp&quot;: a scalar corresponding to the number of SNPs
</p>
</li>
<li><p> &quot;npops&quot;: a scalar corresponding to the number of populations
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'> make.example.files(writing.dir=tempdir())
 pooldata=popsync2pooldata(sync.file=paste0(tempdir(),"/ex.sync.gz"),poolsizes=rep(50,15))
 ##NOTE: This example is just for the sake of illustration as it amounts 
 ##to interpret read count as allele count which must not be done in practice!
 dum=matrix(paste(pooldata@refallele.readcount,
   pooldata@readcoverage-pooldata@refallele.readcount,sep=","),
   ncol=pooldata@npools)
 colnames(dum)=pooldata@poolnames
 write.table(dum,file=paste0(tempdir(),"/genotreemix"),quote=FALSE,row.names=FALSE)
 countdata=genotreemix2countdata(genotreemix.file=paste0(tempdir(),"/genotreemix"))
</code></pre>

<hr>
<h2 id='graph.builder'>Implement a graph builder heuristic by successively adding leaves to an initial graph</h2><span id='topic+graph.builder'></span>

<h3>Description</h3>

<p>Implement a graph builder heuristic by successively adding leaves to an initial graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.builder(
  x,
  leaves.to.add,
  fstats,
  heap.dbic = 6,
  max.heap.size = 25,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.builder_+3A_x">x</code></td>
<td>
<p>An object (or list of objects) of class graph.params or fitted.graph (see details)</p>
</td></tr>
<tr><td><code id="graph.builder_+3A_leaves.to.add">leaves.to.add</code></td>
<td>
<p>Names of the leaves to successively add (in the given order)</p>
</td></tr>
<tr><td><code id="graph.builder_+3A_fstats">fstats</code></td>
<td>
<p>Object of class fstats that contains estimates of the fstats (see compute.fstats)</p>
</td></tr>
<tr><td><code id="graph.builder_+3A_heap.dbic">heap.dbic</code></td>
<td>
<p>Maximal BIC distance from the best graph to be kept in the heap (heap.dbic=6 by default)</p>
</td></tr>
<tr><td><code id="graph.builder_+3A_max.heap.size">max.heap.size</code></td>
<td>
<p>Maximal number of graphs stored in the heap (max.heap.size=25 by default)</p>
</td></tr>
<tr><td><code id="graph.builder_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE extra information is printed on the terminal</p>
</td></tr>
<tr><td><code id="graph.builder_+3A_...">...</code></td>
<td>
<p>Some parameters to be passed the function add.leaf called internally</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input object x needs to be of class graph.params as generated by the function generate.graph.params; or fitted.graph as generated by the functions fit.graph, add.leaf (in the output list element named &quot;fitted.graphs.list&quot;) or rooted.nj.builder (in the output element named &quot;best.rooted.tree&quot;). This is to ensure that the matrix describing the structure of the graph (graph slot of these objects) is valid (note that it can be plotted for checks). Hence graph.params objects may have been generated without fstats information (that should be supplied independently to the add.leaf function to obtain information on the fstats involving the candidate leaf defined with the leaf.to.add argument).
The functions successively add each leaf given in the leaves.to.add vector to the list of fitted graph stored in a heap using the function add.leaf. For the first iteration (i.e., first tested leaf) the heap consists of the input graph or list of graph x. At each iteration, the function add.leaf is used to test the candidate leaf to each graph from the current heap in turn. A new heap of graphs is then built by each time including the fitted graphs with a BIC less than heap.dbic larger than the best resulting graphs (treating each graph independently). If the final number of graphs in the heap is larger than max.heap.size, the max.heap.size graphs with the lowest BIC are kept in the heap. After testing the latest leaf, graphs with a BIC larger than heap.dbic units of the best graph are discarded from the final list of graphs.
In practice, it is recommended to test different orders of inclusion of the leaves (as specified in the vector leaves.to.add)
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ol>
<li><p> &quot;n.graphs&quot;: The final number of fitted graphs
</p>
</li>
<li><p> &quot;fitted.graphs.list&quot;: a list of fitted.graph objects (indexed from 1 to n.graphs and in the same order as the list &quot;graphs&quot;) containing the results of fitting of each graph. 
</p>
</li>
<li><p> &quot;best.fitted.graph&quot;: The graph (object of class fitted.graph) with the minimal BIC (see function fit.graph) among all the graphs within fitted.graphs.list 
</p>
</li>
<li><p> &quot;bic&quot;: a vector of the n.graphs BIC (indexed from 1 to n.graphs and in the same order as the &quot;fitted.graphs.list&quot; list) (see fit.graph details for the computation of the scores). 
</p>
</li></ol>



<h3>See Also</h3>

<p>see <code><a href="#topic+fit.graph">fit.graph</a></code>, <code><a href="#topic+generate.graph.params">generate.graph.params</a></code> and <code><a href="#topic+add.leaf">add.leaf</a></code>.
</p>

<hr>
<h2 id='graph.params-class'>S4 class to represent a population tree or admixture graph and its underlying parameter.</h2><span id='topic+graph.params-class'></span><span id='topic+graph.params'></span>

<h3>Description</h3>

<p>S4 class to represent a population tree or admixture graph and its underlying parameter.
</p>


<h3>Details</h3>

<p>The graph is specified by a three column (character) matrix giving for each edge (whether admixed or not) to i) the child node; ii) the parent node; iii) the admixture proportion. For non-admixed edge, the third column must be blank. An admixed node should be referred two times as a child node with two different parent node and two different admixture proportions coded as alpha and (1-alpha) (parentheses are mandatory) if alpha is the name of the parameter for admixture proportion. The dot.graph element allows to plot the graph using grViz() from the DiagrammeR package or with the dot program after writing the files (e.g., dot -Tpng inputgraph.dot in terminal). Note that the dot file may be customized (e.g., to change leave color, parameter names...).
</p>


<h3>Slots</h3>


<dl>
<dt><code>graph</code></dt><dd><p>The graph in 3 column format (see details)</p>
</dd>
<dt><code>dot.graph</code></dt><dd><p>The graph in dot format</p>
</dd>
<dt><code>is.admgraph</code></dt><dd><p>If FALSE the graph is binary tree (i.e., no admixture events), if TRUE the graph is an admixture graph</p>
</dd>
<dt><code>n.leaves</code></dt><dd><p>Number of leaves of the graph</p>
</dd>
<dt><code>leaves</code></dt><dd><p>Name of the leaves</p>
</dd>
<dt><code>root.name</code></dt><dd><p>Name of the root</p>
</dd>
<dt><code>n.nodes</code></dt><dd><p>Number of nodes (including root)</p>
</dd>
<dt><code>nodes.names</code></dt><dd><p>Name of the nodes</p>
</dd>
<dt><code>n.edges</code></dt><dd><p>Number of edges (including admixture edges)</p>
</dd>
<dt><code>edges.names</code></dt><dd><p>Names of the edges (coded as &quot;Parent node Name&quot;&lt;-&gt;&quot;Child node Name&quot;)</p>
</dd>
<dt><code>n.adm.nodes</code></dt><dd><p>Number of admixed nodes (=0 if is.admgraph=FALSE). This is also the number of admixed parameters since only two-ways admixture are assumed for a given node</p>
</dd>
<dt><code>adm.params.names</code></dt><dd><p>Names of the admixed parameters</p>
</dd>
<dt><code>graph.matrix</code></dt><dd><p>The graph incidence matrix consisting of n.leaves rows and n.edges columns. The elements of the matrix are the weights of each edge (in symbolic representation) for the different possible paths from the leaves to the graph root.</p>
</dd>
<dt><code>root.edges.idx</code></dt><dd><p>Indexes of the graph.matrix columns associated to the (two) edges connected to the root</p>
</dd>
<dt><code>f2.target</code></dt><dd><p>The (n.leaves-1) stats F2 involving popref (i.e., of the form F2(popref;pop))</p>
</dd>
<dt><code>f2.target.pops</code></dt><dd><p>A matrix of (n.leaves-1) rows and 2 columns containing the names of populations of the F2 stats. The first column is by construction always popref. The order is the same as in f2.target</p>
</dd>
<dt><code>f3.target</code></dt><dd><p>The (n.leaves-1)(n.leaves-2)/2 stats F3 involving popref as a target (i.e., of the form F3(popref;popA,popB))</p>
</dd>
<dt><code>f3.target.pops</code></dt><dd><p>A matrix of (n.leaves-1)(n.leaves-2)/2 rows and 3 columns containing the name of popref in the first column and the names of the two populations involved in the F3 stats. The order is the same as in f3.target</p>
</dd>
<dt><code>popref</code></dt><dd><p>The name of the reference population defining the fstats basis</p>
</dd>
<dt><code>f.Qmat</code></dt><dd><p>A square matrix of rank n.leaves(n.leaves-1)/2 corresponding to the error covariance matrix of the F2 and F3 estimates</p>
</dd>
<dt><code>Het</code></dt><dd><p>Estimated leave heterozygosities (if present in the fstats object)</p>
</dd>
</dl>


<h3>See Also</h3>

<p>To generate graph.params object, see <code><a href="#topic+generate.graph.params">generate.graph.params</a></code>. The object may be used to estimate graph parameters with the function <code><a href="#topic+fit.graph">fit.graph</a></code> or to generate files for the qpGraph software with <code><a href="#topic+graph.params2qpGraphFiles">graph.params2qpGraphFiles</a></code>. See also <code><a href="#topic+graph.params2symbolic.fstats">graph.params2symbolic.fstats</a></code> to obtain symbolic representation of Fstats from the matrix &quot;Omega&quot;.
</p>

<hr>
<h2 id='graph.params2qpGraphFiles'>Generate files for the qpGraph software from a graph.params object</h2><span id='topic+graph.params2qpGraphFiles'></span>

<h3>Description</h3>

<p>Generate files for the qpGraph software from a graph.params object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.params2qpGraphFiles(
  graph.params,
  outfileprefix = "out",
  n.printed.dec = 4,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.params2qpGraphFiles_+3A_graph.params">graph.params</code></td>
<td>
<p>An object of class graph.params containing graph information with Fstats information (see the function generate.graph.params)</p>
</td></tr>
<tr><td><code id="graph.params2qpGraphFiles_+3A_outfileprefix">outfileprefix</code></td>
<td>
<p>The prefix of the qpGraph files</p>
</td></tr>
<tr><td><code id="graph.params2qpGraphFiles_+3A_n.printed.dec">n.printed.dec</code></td>
<td>
<p>Number of decimal to be printed (if not enough may lead to fatalx error in qpGraph)</p>
</td></tr>
<tr><td><code id="graph.params2qpGraphFiles_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE extra information is printed on the terminal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates the three files required by qpGraph: i) a file named outfileprefix.graph containing the graph in appropriate format; ii) a file named outfileprefix.fstats file containing the fstats estimates of fstats (and their covariance); iii) a file named outfileprefix.parqpGraph containing essential parameter information to run qpGraph (this may be edited by hand if other options are needed). The qpGraph software may then be run using the following options -p outfileprefix.parqpGraph -g outfileprefix.graph -o out.ggg -d out.dot.
</p>


<h3>Value</h3>

<p>The three files described in the details section
</p>


<h3>See Also</h3>

<p>To generate graph.params object, see <code><a href="#topic+generate.graph.params">generate.graph.params</a></code>
</p>

<hr>
<h2 id='graph.params2symbolic.fstats'>Provide a symbolic representation of all the F-statistics and the model system of equations</h2><span id='topic+graph.params2symbolic.fstats'></span>

<h3>Description</h3>

<p>Provide a symbolic representation of all the F-statistics and the model system of equations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.params2symbolic.fstats(x, outfile = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.params2symbolic.fstats_+3A_x">x</code></td>
<td>
<p>An object of class graph.params containing graph information and relevant Fstats estimates (see the function generate.graph.params)</p>
</td></tr>
<tr><td><code id="graph.params2symbolic.fstats_+3A_outfile">outfile</code></td>
<td>
<p>The file where to print the equations (default=NULL, equations are not printed in a file)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ol>
<li><p> &quot;model.matrix&quot;: A symbolic representation of the matrix M relating the basis F-statistics and graph edge length as F=M*b where F is the vector of the basis Fstats (row names of model.matrix M) and b is the vector of graph edges (column names of model.matrix M).
</p>
</li>
<li><p> &quot;omega&quot;: A symbolic representation of the scaled covariance matrix of allele frequency with edge names and admixture parameter names as specified in the edges.names and adm.params.names slot of the input graph.params object x
</p>
</li>
<li><p> &quot;F2.equations&quot;: A symbolic representation of the nleaves(nleaves-1)/2 different F2 as a function of graph parameters
</p>
</li>
<li><p> &quot;F3.equations&quot;: A symbolic representation  of the nleaves(nleaves-1)(nleaves-2)/2 different F3 as a function of graph parameters 
</p>
</li>
<li><p> &quot;F4.equations&quot;: A symbolic representation of the npops(npops-1)(npops-2)(npops-3)/8 different F4 as a function of graph parameters
</p>
</li></ol>



<h3>See Also</h3>

<p>To generate a graph.params object, see <code><a href="#topic+generate.graph.params">generate.graph.params</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph=rbind(c("P1","P7",""),c("P2","s1",""),c("P3","s2",""),c("P6","S",""),
            c("S","s1","a"),c("S","s2","(1-a)"),c("s2","P8",""),c("s1","P7",""),
            c("P4","P9",""),c("P5","P9",""),c("P7","P8",""),
            c("P8","R",""),c("P9","R","")) 
graph.params=generate.graph.params(graph)
graph.equations=graph.params2symbolic.fstats(graph.params) 
</code></pre>

<hr>
<h2 id='heatmap+2Cpairwisefst-method'>Show pairwisefst object</h2><span id='topic+heatmap+2Cpairwisefst-method'></span>

<h3>Description</h3>

<p>Show pairwisefst object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pairwisefst'
heatmap(
  x,
  Rowv = NULL,
  Colv = if (symm) "Rowv" else NULL,
  distfun = as.dist,
  hclustfun = hclust,
  reorderfun = function(d, w) reorder(d, w),
  add.expr,
  symm = FALSE,
  revC = identical(Colv, "Rowv"),
  scale = c("row", "column", "none"),
  na.rm = TRUE,
  margins = c(5, 5),
  ColSideColors,
  RowSideColors,
  cexRow = 0.2 + 1/log10(nrow(x@PairwiseFSTmatrix)),
  cexCol = 0.2 + 1/log10(ncol(x@PairwiseFSTmatrix)),
  labRow = NULL,
  labCol = NULL,
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  keep.dendro = FALSE,
  verbose = getOption("verbose"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heatmap+2B2Cpairwisefst-method_+3A_x">x</code></td>
<td>
<p>Object of class pairwisefst</p>
</td></tr>
<tr><td><code id="heatmap+2B2Cpairwisefst-method_+3A_rowv">Rowv</code></td>
<td>
<p>determines if and how the row dendrogram should be computed and reordered. Either a dendrogram or a vector of values used to reorder the row dendrogram or NA to suppress any row dendrogram (and reordering) or by default, NULL, see Details below.</p>
</td></tr>
<tr><td><code id="heatmap+2B2Cpairwisefst-method_+3A_colv">Colv</code></td>
<td>
<p>determines if and how the column dendrogram should be reordered. Has the same options as the Rowv argument above and additionally when x is a square matrix, Colv = &quot;Rowv&quot; means that columns should be treated identically to the rows (and so if there is to be no row dendrogram there will not be a column one either).</p>
</td></tr>
<tr><td><code id="heatmap+2B2Cpairwisefst-method_+3A_distfun">distfun</code></td>
<td>
<p>function used to compute the distance (dissimilarity) between both rows and columns. Defaults to as.dist.</p>
</td></tr>
<tr><td><code id="heatmap+2B2Cpairwisefst-method_+3A_hclustfun">hclustfun</code></td>
<td>
<p>function used to compute the hierarchical clustering when Rowv or Colv are not dendrograms. Defaults to hclust. Should take as argument a result of distfun and return an object to which as.dendrogram can be applied.</p>
</td></tr>
<tr><td><code id="heatmap+2B2Cpairwisefst-method_+3A_reorderfun">reorderfun</code></td>
<td>
<p>function(d, w) of dendrogram and weights for reordering the row and column dendrograms. The default uses reorder.dendrogram.</p>
</td></tr>
<tr><td><code id="heatmap+2B2Cpairwisefst-method_+3A_add.expr">add.expr</code></td>
<td>
<p>expression that will be evaluated after the call to image. Can be used to add components to the plot.</p>
</td></tr>
<tr><td><code id="heatmap+2B2Cpairwisefst-method_+3A_symm">symm</code></td>
<td>
<p>logical indicating if x should be treated symmetrically; can only be true when x is a square matrix.</p>
</td></tr>
<tr><td><code id="heatmap+2B2Cpairwisefst-method_+3A_revc">revC</code></td>
<td>
<p>logical indicating if the column order should be reversed for plotting, such that e.g., for the symmetric case, the symmetry axis is as usual.</p>
</td></tr>
<tr><td><code id="heatmap+2B2Cpairwisefst-method_+3A_scale">scale</code></td>
<td>
<p>character indicating if the values should be centered and scaled in either the row direction or the column direction, or none. The default is &quot;row&quot; if symm false, and &quot;none&quot; otherwise.</p>
</td></tr>
<tr><td><code id="heatmap+2B2Cpairwisefst-method_+3A_na.rm">na.rm</code></td>
<td>
<p>logical indicating whether NA's should be removed.</p>
</td></tr>
<tr><td><code id="heatmap+2B2Cpairwisefst-method_+3A_margins">margins</code></td>
<td>
<p>numeric vector of length 2 containing the margins (see par(mar = *)) for column and row names, respectively.</p>
</td></tr>
<tr><td><code id="heatmap+2B2Cpairwisefst-method_+3A_colsidecolors">ColSideColors</code></td>
<td>
<p>(optional) character vector of length ncol(x) containing the color names for a horizontal side bar that may be used to annotate the columns of x.</p>
</td></tr>
<tr><td><code id="heatmap+2B2Cpairwisefst-method_+3A_rowsidecolors">RowSideColors</code></td>
<td>
<p>(optional) character vector of length nrow(x) containing the color names for a vertical side bar that may be used to annotate the rows of x.</p>
</td></tr>
<tr><td><code id="heatmap+2B2Cpairwisefst-method_+3A_cexrow">cexRow</code>, <code id="heatmap+2B2Cpairwisefst-method_+3A_cexcol">cexCol</code></td>
<td>
<p>positive numbers, used as cex.axis in for the row or column axis labeling. The defaults currently only use number of rows or columns, respectively.</p>
</td></tr>
<tr><td><code id="heatmap+2B2Cpairwisefst-method_+3A_labrow">labRow</code>, <code id="heatmap+2B2Cpairwisefst-method_+3A_labcol">labCol</code></td>
<td>
<p>character vectors with row and column labels to use; these default to rownames(x) or colnames(x), respectively.</p>
</td></tr>
<tr><td><code id="heatmap+2B2Cpairwisefst-method_+3A_main">main</code>, <code id="heatmap+2B2Cpairwisefst-method_+3A_xlab">xlab</code>, <code id="heatmap+2B2Cpairwisefst-method_+3A_ylab">ylab</code></td>
<td>
<p>main, x- and y-axis titles; defaults to none.</p>
</td></tr>
<tr><td><code id="heatmap+2B2Cpairwisefst-method_+3A_keep.dendro">keep.dendro</code></td>
<td>
<p>logical indicating if the dendrogram(s) should be kept as part of the result (when Rowv and/or Colv are not NA).</p>
</td></tr>
<tr><td><code id="heatmap+2B2Cpairwisefst-method_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if information should be printed.</p>
</td></tr>
<tr><td><code id="heatmap+2B2Cpairwisefst-method_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to image, e.g., col specifying the colors.</p>
</td></tr>
</table>

<hr>
<h2 id='is.countdata'>Check countdata objects</h2><span id='topic+is.countdata'></span>

<h3>Description</h3>

<p>Check countdata objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.countdata(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.countdata_+3A_x">x</code></td>
<td>
<p>The name of the object to be tested</p>
</td></tr>
</table>

<hr>
<h2 id='is.fitted.graph'>Check fitted.graph objects</h2><span id='topic+is.fitted.graph'></span>

<h3>Description</h3>

<p>Check fitted.graph objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.fitted.graph(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.fitted.graph_+3A_x">x</code></td>
<td>
<p>Object to be tested</p>
</td></tr>
</table>

<hr>
<h2 id='is.fstats'>Check fstats objects</h2><span id='topic+is.fstats'></span>

<h3>Description</h3>

<p>Check fstats objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.fstats(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.fstats_+3A_x">x</code></td>
<td>
<p>The name of the object to be tested</p>
</td></tr>
</table>

<hr>
<h2 id='is.graph.params'>Check graph.params objects</h2><span id='topic+is.graph.params'></span>

<h3>Description</h3>

<p>Check graph.params objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.graph.params(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.graph.params_+3A_x">x</code></td>
<td>
<p>The name (or a path) of the graph.params objet</p>
</td></tr>
</table>

<hr>
<h2 id='is.pairwisefst'>Check pairwisefst objects</h2><span id='topic+is.pairwisefst'></span>

<h3>Description</h3>

<p>Check pairwisefst objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.pairwisefst(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.pairwisefst_+3A_x">x</code></td>
<td>
<p>The name (or a path) of the pairwisefst object</p>
</td></tr>
</table>

<hr>
<h2 id='is.pooldata'>Check pooldata objects</h2><span id='topic+is.pooldata'></span>

<h3>Description</h3>

<p>Check pooldata objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.pooldata(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.pooldata_+3A_x">x</code></td>
<td>
<p>The name of the object to be tested</p>
</td></tr>
</table>

<hr>
<h2 id='make.example.files'>Create example files</h2><span id='topic+make.example.files'></span>

<h3>Description</h3>

<p>Write in the current directory example files corresponding to a sync (as obtained when parsing mpileup files with PoPoolation) and vcf (as obtained when parsing mpileup files with VarScan) gzipped files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.example.files(writing.dir = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.example.files_+3A_writing.dir">writing.dir</code></td>
<td>
<p>Directory where to copy example files (e.g., set writing.dir=getwd() to copy in the current working directory)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> make.example.files(writing.dir=tempdir())
</code></pre>

<hr>
<h2 id='pairwisefst-class'>S4 class to represent a pairwise Fst results obtained with the compute.pairwiseFST</h2><span id='topic+pairwisefst-class'></span><span id='topic+pairwisefst'></span>

<h3>Description</h3>

<p>S4 class to represent a pairwise Fst results obtained with the compute.pairwiseFST
</p>


<h3>Slots</h3>


<dl>
<dt><code>values</code></dt><dd><p>A data frame with npop*(npop-1)/2 rows and 3 (or 7 if blockjackknife is TRUE) columns containing for both the Fst and Q2, estimates over all the SNPs and if blockjackknife=TRUE, the estimated block-jackknife and standard error (s.e.). The seventh (or third if blockjackknife=FALSE) column gives the number of SNPs.</p>
</dd>
<dt><code>PairwiseFSTmatrix</code></dt><dd><p>A npxnp matrix containing the pairwise FST estimates</p>
</dd>
<dt><code>PairwiseSnpFST</code></dt><dd><p>A matrix (nsnp rows and npops columns) with read count data for the reference allele</p>
</dd>
<dt><code>PairwiseSnpQ1</code></dt><dd><p>A matrix (nsnp rows and npops columns) with overall read coverage</p>
</dd>
<dt><code>PairwiseSnpQ2</code></dt><dd><p>A matrix (nsnp rows and 4 columns) detailing for each SNP, the chromosome (or scaffold), the position, allele 1 and allele 2</p>
</dd>
<dt><code>blockjacknife</code></dt><dd><p>A logical indicating whether block-jackknife estimates of standard errors are available (TRUE) or not (FALSE)</p>
</dd>
</dl>


<h3>See Also</h3>

<p>To generate pairwise object, see <code><a href="#topic+compute.pairwiseFST">compute.pairwiseFST</a></code>
</p>

<hr>
<h2 id='plot_fstats'>Plot F2, F3, F3star, F4, D or pairwise Fst values with their Confidence Intervals</h2><span id='topic+plot_fstats'></span>

<h3>Description</h3>

<p>Plot F2, F3, F3star, F4, D or pairwise Fst values with their Confidence Intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_fstats(
  x,
  stat.name = "F2",
  ci.perc = 95,
  value.range = c(NA, NA),
  pop.sel = NA,
  pop.f3.target = NA,
  highlight.signif = TRUE,
  main = stat.name,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_fstats_+3A_x">x</code></td>
<td>
<p>An object of class fstats (to plot heterozygosities, divergence, F2, F3, F3star, F4 or D statistics) or pairwisefst (to plot pairwise fst)</p>
</td></tr>
<tr><td><code id="plot_fstats_+3A_stat.name">stat.name</code></td>
<td>
<p>For fstats object, the name of the stat (either heterozygosities, divergence, F2, F3, F3star, F4 or Dstat)</p>
</td></tr>
<tr><td><code id="plot_fstats_+3A_ci.perc">ci.perc</code></td>
<td>
<p>Percentage of the Confidence Interval in number of standard errors (default=95%)</p>
</td></tr>
<tr><td><code id="plot_fstats_+3A_value.range">value.range</code></td>
<td>
<p>Range of test values (x-axis) to be plotted (default=NA,NA: i.e., all test values are plotted)</p>
</td></tr>
<tr><td><code id="plot_fstats_+3A_pop.sel">pop.sel</code></td>
<td>
<p>Only plot test values involving these populations (default=NA: i.e., all test values are plotted)</p>
</td></tr>
<tr><td><code id="plot_fstats_+3A_pop.f3.target">pop.f3.target</code></td>
<td>
<p>For F3-statistics, only plot F3 involving pop.f3.target as a target</p>
</td></tr>
<tr><td><code id="plot_fstats_+3A_highlight.signif">highlight.signif</code></td>
<td>
<p>If TRUE highlight significant tests in red (see details)</p>
</td></tr>
<tr><td><code id="plot_fstats_+3A_main">main</code></td>
<td>
<p>Main title of the plot (default=stat.name)</p>
</td></tr>
<tr><td><code id="plot_fstats_+3A_...">...</code></td>
<td>
<p>Some other graphical arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data will only be plotted if jackknife estimates of the estimator s.e. have been performed i.e. if the functions compute.fstats or compute.pairwiseFST were run with nsnp.per.block&gt;0
</p>


<h3>Value</h3>

<p>A plot of the Fstats of interest. Significant F3 statistics (i.e., showing formal evidence for admixture of the target population) are highlighted in red. Significant F4 statistics (i.e., showing formal evidence against treeness of the pop. quadruplet) are highlighted in red.
</p>


<h3>See Also</h3>

<p>To generate x object, see <code><a href="#topic+compute.pairwiseFST">compute.pairwiseFST</a></code> (for pairwisefst object) or <code><a href="#topic+compute.fstats">compute.fstats</a></code>  (for fstats object)
</p>


<h3>Examples</h3>

<pre><code class='language-R'> make.example.files(writing.dir=tempdir())
 pooldata=popsync2pooldata(sync.file=paste0(tempdir(),"/ex.sync.gz"),
                   poolsizes=rep(50,15),poolnames=paste0("P",1:15))
 res.fstats=compute.fstats(pooldata,nsnp.per.bjack.block=25)
 plot_fstats(res.fstats,stat.name="F3",cex=0.5)
 plot_fstats(res.fstats,stat.name="F3",value.range=c(NA,0.001),
             pop.f3.target=c("P7","P5"),cex.axis=0.7)
 plot_fstats(res.fstats,stat.name="F4",cex=0.5) 
 #allow to reduce the size of the test name (y-axis)
 plot_fstats(res.fstats,stat.name="F4",cex=0.5,
             pop.sel=c("P1","P2","P3","P4","P5")) 
 plot_fstats(res.fstats,stat.name="F4",cex=0.5,
             pop.sel=c("P1","P2","P3","P4","P5"),highlight.signif=FALSE)  
</code></pre>

<hr>
<h2 id='plot+2Cfitted.graph-method'>plot pairwisefst object</h2><span id='topic+plot+2Cfitted.graph-method'></span>

<h3>Description</h3>

<p>plot pairwisefst object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'fitted.graph'
plot(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2Cfitted.graph-method_+3A_x">x</code></td>
<td>
<p>Object of class fitted.graph</p>
</td></tr>
<tr><td><code id="plot+2B2Cfitted.graph-method_+3A_y">y</code></td>
<td>
<p>dummy argument</p>
</td></tr>
</table>

<hr>
<h2 id='plot+2Cfstats-method'>plot fstats object</h2><span id='topic+plot+2Cfstats-method'></span>

<h3>Description</h3>

<p>plot fstats object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'fstats'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2Cfstats-method_+3A_x">x</code></td>
<td>
<p>Object of class fstats</p>
</td></tr>
<tr><td><code id="plot+2B2Cfstats-method_+3A_y">y</code></td>
<td>
<p>dummy argument</p>
</td></tr>
<tr><td><code id="plot+2B2Cfstats-method_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to plot_fstats</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>see <code><a href="#topic+plot_fstats">plot_fstats</a></code> for details on plot_fstats arguments
</p>

<hr>
<h2 id='plot+2Cgraph.params-method'>plot graph in graph.params object</h2><span id='topic+plot+2Cgraph.params-method'></span>

<h3>Description</h3>

<p>plot graph in graph.params object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'graph.params'
plot(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2Cgraph.params-method_+3A_x">x</code></td>
<td>
<p>Object of class fitted.graph</p>
</td></tr>
<tr><td><code id="plot+2B2Cgraph.params-method_+3A_y">y</code></td>
<td>
<p>dummy argument</p>
</td></tr>
</table>

<hr>
<h2 id='plot+2Cpairwisefst-method'>plot pairwisefst object</h2><span id='topic+plot+2Cpairwisefst-method'></span>

<h3>Description</h3>

<p>plot pairwisefst object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pairwisefst'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2Cpairwisefst-method_+3A_x">x</code></td>
<td>
<p>Object of class pairwisefst</p>
</td></tr>
<tr><td><code id="plot+2B2Cpairwisefst-method_+3A_y">y</code></td>
<td>
<p>dummy argument</p>
</td></tr>
<tr><td><code id="plot+2B2Cpairwisefst-method_+3A_...">...</code></td>
<td>
<p>Some arguments to be passed to plot_fstats</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>see <code><a href="#topic+plot_fstats">plot_fstats</a></code> for details on plot_fstats arguments
</p>

<hr>
<h2 id='pooldata-class'>S4 class to represent a Pool-Seq data set.</h2><span id='topic+pooldata-class'></span><span id='topic+pooldata'></span>

<h3>Description</h3>

<p>S4 class to represent a Pool-Seq data set.
</p>


<h3>Slots</h3>


<dl>
<dt><code>npools</code></dt><dd><p>The number of pools</p>
</dd>
<dt><code>nsnp</code></dt><dd><p>The number of SNPs</p>
</dd>
<dt><code>refallele.readcount</code></dt><dd><p>A matrix (nsnp rows and npools columns) with read count data for the reference allele</p>
</dd>
<dt><code>readcoverage</code></dt><dd><p>A matrix (nsnp rows and npools columns) with overall read coverage</p>
</dd>
<dt><code>snp.info</code></dt><dd><p>A data frame (nsnp rows and 4 columns) detailing for each SNP, the chromosome (or scaffold), the position, Reference allele name and Alternate allele name (if available)</p>
</dd>
<dt><code>poolsizes</code></dt><dd><p>A vector of length npools with the corresponding haploid pool sizes</p>
</dd>
<dt><code>poolnames</code></dt><dd><p>A vector of length npools with the corresponding haploid pool names</p>
</dd>
</dl>


<h3>See Also</h3>

<p>To generate pooldata object, see <code><a href="#topic+vcf2pooldata">vcf2pooldata</a></code>, <code><a href="#topic+popsync2pooldata">popsync2pooldata</a></code>, <code><a href="#topic+genobaypass2pooldata">genobaypass2pooldata</a></code> and <code><a href="#topic+genoselestim2pooldata">genoselestim2pooldata</a></code>
</p>

<hr>
<h2 id='pooldata.subset'>Create a subset of the pooldata object that contains Pool-Seq data as a function of pool and/or SNP indexes</h2><span id='topic+pooldata.subset'></span>

<h3>Description</h3>

<p>Create a subset of the pooldata object that contains Pool-Seq data as a function of pool and/or SNP indexes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pooldata.subset(
  pooldata,
  pool.index = 1:pooldata@npools,
  snp.index = 1:pooldata@nsnp,
  min.cov.per.pool = -1,
  max.cov.per.pool = 1e+06,
  min.maf = -1,
  cov.qthres.per.pool = c(0, 1),
  return.snp.idx = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pooldata.subset_+3A_pooldata">pooldata</code></td>
<td>
<p>A pooldata object containing Pool-Seq information</p>
</td></tr>
<tr><td><code id="pooldata.subset_+3A_pool.index">pool.index</code></td>
<td>
<p>Indexes of the pools (at least two), that should be selected to create the new pooldata object (default=all the pools)</p>
</td></tr>
<tr><td><code id="pooldata.subset_+3A_snp.index">snp.index</code></td>
<td>
<p>Indexes of the SNPs (at least two), that should be selected to create the new pooldata object (default=all the SNPs)</p>
</td></tr>
<tr><td><code id="pooldata.subset_+3A_min.cov.per.pool">min.cov.per.pool</code></td>
<td>
<p>Minimal allowed read count (per pool). If at least one pool is not covered by at least min.cov.perpool reads, the position is discarded</p>
</td></tr>
<tr><td><code id="pooldata.subset_+3A_max.cov.per.pool">max.cov.per.pool</code></td>
<td>
<p>Maximal allowed read count (per pool). If at least one pool is covered by more than min.cov.perpool reads, the position is discarded</p>
</td></tr>
<tr><td><code id="pooldata.subset_+3A_min.maf">min.maf</code></td>
<td>
<p>Minimal allowed Minor Allele Frequency (computed from the ratio over all read counts for the reference allele over the read coverage)</p>
</td></tr>
<tr><td><code id="pooldata.subset_+3A_cov.qthres.per.pool">cov.qthres.per.pool</code></td>
<td>
<p>A two-elements vector containing the minimal (qmin) and maximal (qmax) quantile coverage thresholds applied to each pools (0&lt;=qmin&lt;qmax&lt;=1). See details below</p>
</td></tr>
<tr><td><code id="pooldata.subset_+3A_return.snp.idx">return.snp.idx</code></td>
<td>
<p>If TRUE, the row.names of the snp.info slot of the returned pooldata object are named as &quot;rsx&quot; where x is the index of SNP in the initial pooldata object (default=FALSE)</p>
</td></tr>
<tr><td><code id="pooldata.subset_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE return some information</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows subsetting a pooldata object by selecting only some pools and/or some SNPs (e.g., based on their position on the genome). Additional filtering steps on SNPs can be carried out on the resulting subset to discard SNP with low polymorphism or poorly or too highly covered. In addition, coverage criteria can be applied on a per-pool basis with the cov.qthres.per.pool argument. 'more specific SNP selection based on their positions on the genome or their characteristics. For instance if qmax=0.95, a position is discarded if in a given pool it has a number of reads higher than the 95-th percentile of the empirical coverage distribution in this same pool (defined over the SNPs selected by snp.index). Similarly, if qmax=0.05, a position is discarded if in a given pool it has a number of reads lower than the 5-th percentile of the empirical coverage distribution in this same pool. This mode of selection may be more relevant when considering pools with heterogeneous read coverages.
</p>


<h3>Value</h3>

<p>A pooldata object with 7 elements:
</p>

<ol>
<li><p> &quot;refallele.readcount&quot;: a matrix with nsnp rows and npools columns containing read counts for the reference allele (chosen arbitrarily) in each pool
</p>
</li>
<li><p> &quot;readcoverage&quot;: a matrix with nsnp rows and npools columns containing read coverage in each pool
</p>
</li>
<li><p> &quot;snp.info&quot;: a matrix with nsnp rows and four columns containing respectively the contig (or chromosome) name (1st column) and position (2nd column) of the SNP; the allele in the reference assembly (3rd column); the allele taken as reference in the refallele matrix.readcount matrix (4th column); and the alternative allele (5th column)
</p>
</li>
<li><p> &quot;poolsizes&quot;: a vector of length npools containing the haploid pool sizes
</p>
</li>
<li><p> &quot;poolnames&quot;: a vector of length npools containing the names of the pools
</p>
</li>
<li><p> &quot;nsnp&quot;: a scalar corresponding to the number of SNPs
</p>
</li>
<li><p> &quot;npools&quot;: a scalar corresponding to the number of pools
</p>
</li></ol>



<h3>See Also</h3>

<p>To generate pooldata object, see <code><a href="#topic+vcf2pooldata">vcf2pooldata</a></code>, <code><a href="#topic+popsync2pooldata">popsync2pooldata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> make.example.files(writing.dir=tempdir())
 pooldata=popsync2pooldata(sync.file=paste0(tempdir(),"/ex.sync.gz"),poolsizes=rep(50,15))
 subset.by.pools=pooldata.subset(pooldata,pool.index=c(1,2))
 subset.by.snps=pooldata.subset(pooldata,snp.index=10:100)
 subset.by.pools.and.snps=pooldata.subset(pooldata,pool.index=c(1,2),snp.index=10:100)
 subset.by.pools.qcov.thr=pooldata.subset(pooldata,pool.index=1:8,cov.qthres.per.pool=c(0.05,0.95)) 
</code></pre>

<hr>
<h2 id='pooldata2diyabc'>Convert a pooldata object into DIYABC input files.</h2><span id='topic+pooldata2diyabc'></span>

<h3>Description</h3>

<p>Convert a pooldata object into DIYABC data file for pool-seq data. A file containing SNP details is also printed out. Options to generate sub-samples  (e.g., for large number of SNPs) are also available. Note that DIYABC SNP filtering criterion is based on MRC (minimal read count) which may be more stringent than usual MAF-based filtering criterion. It is recommended to parse vcf files and pooldata objects without any MAF criterion or to prefilter pooldata objects with the desired MRC (using option snp.index <code><a href="#topic+pooldata.subset">pooldata.subset</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pooldata2diyabc(
  pooldata,
  writing.dir = getwd(),
  prefix = "",
  diyabc.mrc = 1,
  subsamplesize = -1,
  subsamplingmethod = "thinning"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pooldata2diyabc_+3A_pooldata">pooldata</code></td>
<td>
<p>A pooldata object containing Pool-Seq information (see <code><a href="#topic+vcf2pooldata">vcf2pooldata</a></code> and <code><a href="#topic+popsync2pooldata">popsync2pooldata</a></code>)</p>
</td></tr>
<tr><td><code id="pooldata2diyabc_+3A_writing.dir">writing.dir</code></td>
<td>
<p>Directory where to create the files  (e.g., set writing.dir=getwd() to copy in the current working directory)</p>
</td></tr>
<tr><td><code id="pooldata2diyabc_+3A_prefix">prefix</code></td>
<td>
<p>Prefix used for output file names</p>
</td></tr>
<tr><td><code id="pooldata2diyabc_+3A_diyabc.mrc">diyabc.mrc</code></td>
<td>
<p>MRC to be applied by DIYABC (note that no filtering based on MRC is done by the function)</p>
</td></tr>
<tr><td><code id="pooldata2diyabc_+3A_subsamplesize">subsamplesize</code></td>
<td>
<p>Size of the sub-samples. If &lt;=1 (default), all the SNPs are considered in the output</p>
</td></tr>
<tr><td><code id="pooldata2diyabc_+3A_subsamplingmethod">subsamplingmethod</code></td>
<td>
<p>If sub-sampling is activated (argument subsamplesize), define the method used for subsampling that might be either i) &quot;random&quot; (A single data set consisting of randmly chosen SNPs is generated) or ii) &quot;thinning&quot;, sub-samples are generated by taking SNPs one every nsub=floor(nsnp/subsamplesize) in the order of the map (a suffix &quot;.subn&quot; is added to each sub-sample files where n varies from 1 to nsub).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>DIYABC data file for pool-seq data
</p>


<h3>See Also</h3>

<p>To generate pooldata object, see <code><a href="#topic+vcf2pooldata">vcf2pooldata</a></code>, <code><a href="#topic+popsync2pooldata">popsync2pooldata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> make.example.files(writing.dir=tempdir())
 pooldata=popsync2pooldata(sync.file=paste0(tempdir(),"/ex.sync.gz"),poolsizes=rep(50,15))
 pooldata2diyabc(pooldata=pooldata,writing.dir=tempdir())
</code></pre>

<hr>
<h2 id='pooldata2genobaypass'>Convert a pooldata object into BayPass input files.</h2><span id='topic+pooldata2genobaypass'></span>

<h3>Description</h3>

<p>Convert a pooldata object into BayPass allele read count and haploid pool size files. A file containing SNP details is also printed out. Options to generate sub-samples  (e.g., for large number of SNPs) are also available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pooldata2genobaypass(
  pooldata,
  writing.dir = getwd(),
  prefix = "",
  subsamplesize = -1,
  subsamplingmethod = "thinning"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pooldata2genobaypass_+3A_pooldata">pooldata</code></td>
<td>
<p>A pooldata object containing Pool-Seq information (see <code><a href="#topic+vcf2pooldata">vcf2pooldata</a></code> and <code><a href="#topic+popsync2pooldata">popsync2pooldata</a></code>)</p>
</td></tr>
<tr><td><code id="pooldata2genobaypass_+3A_writing.dir">writing.dir</code></td>
<td>
<p>Directory where to create the files  (e.g., set writing.dir=getwd() to copy in the current working directory)</p>
</td></tr>
<tr><td><code id="pooldata2genobaypass_+3A_prefix">prefix</code></td>
<td>
<p>Prefix used for output file names</p>
</td></tr>
<tr><td><code id="pooldata2genobaypass_+3A_subsamplesize">subsamplesize</code></td>
<td>
<p>Size of the sub-samples. If &lt;=1 (default), all the SNPs are considered in the output</p>
</td></tr>
<tr><td><code id="pooldata2genobaypass_+3A_subsamplingmethod">subsamplingmethod</code></td>
<td>
<p>If sub-sampling is activated (argument subsamplesize), define the method used for subsampling that might be either i) &quot;random&quot; (A single data set consisting of randmly chosen SNPs is generated) or ii) &quot;thinning&quot;, sub-samples are generated by taking SNPs one every nsub=floor(nsnp/subsamplesize) in the order of the map (a suffix &quot;.subn&quot; is added to each sub-sample files where n varies from 1 to nsub).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Files containing allele count (in BayPass format), haploid pool size (in BayPass format), and SNP details (as in the snp.info matrix from the pooldata object)
</p>


<h3>See Also</h3>

<p>To generate pooldata object, see <code><a href="#topic+vcf2pooldata">vcf2pooldata</a></code>, <code><a href="#topic+popsync2pooldata">popsync2pooldata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> make.example.files(writing.dir=tempdir())
 pooldata=popsync2pooldata(sync.file=paste0(tempdir(),"/ex.sync.gz"),poolsizes=rep(50,15))
 pooldata2genobaypass(pooldata=pooldata,writing.dir=tempdir())
</code></pre>

<hr>
<h2 id='pooldata2genoselestim'>Convert a pooldata object into SelEstim input files.</h2><span id='topic+pooldata2genoselestim'></span>

<h3>Description</h3>

<p>Convert a pooldata object into SelEstim allele read count. A file containing SNP details is also printed out. Options to generate sub-samples  (e.g., for large number of SNPs) are also available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pooldata2genoselestim(
  pooldata,
  writing.dir = getwd(),
  prefix = "",
  subsamplesize = -1,
  subsamplingmethod = "thinning"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pooldata2genoselestim_+3A_pooldata">pooldata</code></td>
<td>
<p>A pooldata object containing Pool-Seq information (see <code><a href="#topic+vcf2pooldata">vcf2pooldata</a></code> and <code><a href="#topic+popsync2pooldata">popsync2pooldata</a></code>)</p>
</td></tr>
<tr><td><code id="pooldata2genoselestim_+3A_writing.dir">writing.dir</code></td>
<td>
<p>Directory where to create the files  (e.g., set writing.dir=getwd() to copy in the current working directory)</p>
</td></tr>
<tr><td><code id="pooldata2genoselestim_+3A_prefix">prefix</code></td>
<td>
<p>Prefix used for output file names</p>
</td></tr>
<tr><td><code id="pooldata2genoselestim_+3A_subsamplesize">subsamplesize</code></td>
<td>
<p>Size of the sub-samples. If &lt;=1 (default), all the SNPs are considered in the output</p>
</td></tr>
<tr><td><code id="pooldata2genoselestim_+3A_subsamplingmethod">subsamplingmethod</code></td>
<td>
<p>If sub-sampling is activated (argument subsamplesize), define the method used for subsampling that might be either i) &quot;random&quot; (A single data set consisting of randmly chosen SNPs is generated) or ii) &quot;thinning&quot;, sub-samples are generated by taking SNPs one every nsub=floor(nsnp/subsamplesize) in the order of the map (a suffix &quot;.subn&quot; is added to each sub-sample files where n varies from 1 to nsub).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Files containing allele count (in SelEstim Pool-Seq format) and SNP details (as in the snp.info matrix from the pooldata object)
</p>


<h3>See Also</h3>

<p>To generate pooldata object, see <code><a href="#topic+vcf2pooldata">vcf2pooldata</a></code>, <code><a href="#topic+popsync2pooldata">popsync2pooldata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> make.example.files(writing.dir=tempdir())
 pooldata=popsync2pooldata(sync.file=paste0(tempdir(),"/ex.sync.gz"),poolsizes=rep(50,15))
 pooldata2genoselestim(pooldata=pooldata,writing.dir=tempdir())
</code></pre>

<hr>
<h2 id='poppair_idx'>poppair_idx</h2><span id='topic+poppair_idx'></span>

<h3>Description</h3>

<p>Compute the index of the pairwise comparison from the idx of each pop
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="poppair_idx_+3A_idx_pop1">idx_pop1</code></td>
<td>
<p>Integer giving the (0-indexed) index of the first pop</p>
</td></tr>
<tr><td><code id="poppair_idx_+3A_idx_pop2">idx_pop2</code></td>
<td>
<p>Integer giving the (0-indexed) index of the second pop</p>
</td></tr>
<tr><td><code id="poppair_idx_+3A_nidx">nidx</code></td>
<td>
<p>Integer giving the total number of indexes (i.e., number of pops)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If idx_pop2 &lt; idx_pop1, indexes are reversed
</p>


<h3>Value</h3>

<p>Return the (0-indexed) index for the row associated to the pairwise comparison in the ordered flat list of all (npop*(npop-1))/2 pairwise stats
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
</code></pre>

<hr>
<h2 id='popsync2pooldata'>Convert Popoolation Sync files into a pooldata object</h2><span id='topic+popsync2pooldata'></span>

<h3>Description</h3>

<p>Convert Popoolation Sync files into a pooldata object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popsync2pooldata(
  sync.file = "",
  poolsizes = NA,
  poolnames = NA,
  min.rc = 1,
  min.cov.per.pool = -1,
  max.cov.per.pool = 1e+06,
  min.maf = 0.01,
  noindel = TRUE,
  nlines.per.readblock = 1e+06,
  nthreads = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="popsync2pooldata_+3A_sync.file">sync.file</code></td>
<td>
<p>The name (or a path) of the Popoolation sync file (might be in compressed format)</p>
</td></tr>
<tr><td><code id="popsync2pooldata_+3A_poolsizes">poolsizes</code></td>
<td>
<p>A numeric vector with haploid pool sizes</p>
</td></tr>
<tr><td><code id="popsync2pooldata_+3A_poolnames">poolnames</code></td>
<td>
<p>A character vector with the names of pool</p>
</td></tr>
<tr><td><code id="popsync2pooldata_+3A_min.rc">min.rc</code></td>
<td>
<p>Minimal allowed read count per base. Bases covered by less than min.rc reads are discarded and considered as sequencing error. For instance, if nucleotides A, C, G and T are covered by respectively 100, 15, 0 and 1 over all the pools, setting min.rc to 0 will lead to discard the position (the polymorphism being considered as tri-allelic), while setting min.rc to 1 (or 2, 3..14) will make the position be considered as a SNP with two alleles A and C (the only read for allele T being disregarded).</p>
</td></tr>
<tr><td><code id="popsync2pooldata_+3A_min.cov.per.pool">min.cov.per.pool</code></td>
<td>
<p>Minimal allowed read count (per pool). If at least one pool is not covered by at least min.cov.perpool reads, the position is discarded</p>
</td></tr>
<tr><td><code id="popsync2pooldata_+3A_max.cov.per.pool">max.cov.per.pool</code></td>
<td>
<p>Maximal allowed read count (per pool). If at least one pool is covered by more than min.cov.perpool reads, the position is discarded</p>
</td></tr>
<tr><td><code id="popsync2pooldata_+3A_min.maf">min.maf</code></td>
<td>
<p>Minimal allowed Minor Allele Frequency (computed from the ratio overal read counts for the reference allele over the read coverage)</p>
</td></tr>
<tr><td><code id="popsync2pooldata_+3A_noindel">noindel</code></td>
<td>
<p>If TRUE, positions with at least one indel count are discarded</p>
</td></tr>
<tr><td><code id="popsync2pooldata_+3A_nlines.per.readblock">nlines.per.readblock</code></td>
<td>
<p>Number of Lines read simultaneously. Should be adapted to the available RAM.</p>
</td></tr>
<tr><td><code id="popsync2pooldata_+3A_nthreads">nthreads</code></td>
<td>
<p>Number of available threads for parallelization of some part of the parsing (default=1, i.e., no parallelization)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A pooldata object containing 7 elements:
</p>

<ol>
<li><p> &quot;refallele.readcount&quot;: a matrix with nsnp rows and npools columns containing read counts for the reference allele (chosen arbitrarily) in each pool
</p>
</li>
<li><p> &quot;readcoverage&quot;: a matrix with nsnp rows and npools columns containing read coverage in each pool
</p>
</li>
<li><p> &quot;snp.info&quot;: a matrix with nsnp rows and four columns containing respectively the contig (or chromosome) name (1st column) and position (2nd column) of the SNP; the allele taken as reference in the refallele.readcount matrix (3rd column); and the alternative allele (4th column)
</p>
</li>
<li><p> &quot;poolsizes&quot;: a vector of length npools containing the haploid pool sizes
</p>
</li>
<li><p> &quot;poolnames&quot;: a vector of length npools containing the names of the pools
</p>
</li>
<li><p> &quot;nsnp&quot;: a scalar corresponding to the number of SNPs
</p>
</li>
<li><p> &quot;npools&quot;: a scalar corresponding to the number of pools
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'> make.example.files(writing.dir=tempdir())
 pooldata=popsync2pooldata(sync.file=paste0(tempdir(),"/ex.sync.gz"),poolsizes=rep(50,15))
</code></pre>

<hr>
<h2 id='randomallele.pca'>PCA of a pooldata or countdata object using a random allele approach</h2><span id='topic+randomallele.pca'></span>

<h3>Description</h3>

<p>PCA of a pooldata or countdata object using a random allele approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomallele.pca(
  x,
  scale = TRUE,
  return.snploadings = FALSE,
  plot.pcs = c(1, 2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomallele.pca_+3A_x">x</code></td>
<td>
<p>A pooldata object containing Pool-Seq information or a countdata object containing allele count information</p>
</td></tr>
<tr><td><code id="randomallele.pca_+3A_scale">scale</code></td>
<td>
<p>If FALSE the random allele data matrix is not scaled (default=TRUE)</p>
</td></tr>
<tr><td><code id="randomallele.pca_+3A_return.snploadings">return.snploadings</code></td>
<td>
<p>If TRUE return the SNP loadings (may be large)</p>
</td></tr>
<tr><td><code id="randomallele.pca_+3A_plot.pcs">plot.pcs</code></td>
<td>
<p>A vector with two-elements giving the two PCs to plot. If NULL, no plotting is done.</p>
</td></tr>
<tr><td><code id="randomallele.pca_+3A_...">...</code></td>
<td>
<p>graphical parameters (see <code><a href="graphics.html#topic+plot">plot</a></code> function)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>PCA is performed by singular-value decomposition (SVD) of a npop (or npools) x nsnp matrix of a single randomly sampled allele (i.e. or read for pooldata object) for each SNP and for each population (inspired by Skoglund and Jakobsson, 2011, https://doi.org/10.1073/pnas.1108181108). Although this approach leads to information loss, it allows to efficiently account for unequal sample size (and read coverages for pool-seq data) and have little impact on the resulting representation when the number of SNPs is large. Note also that the implemented approach is similar to that implemented in the PCA_MDS module of the software ANGSD by Korneliussen et al. (2014) (see http://www.popgen.dk/angsd/index.php/PCA_MDS).
</p>


<h3>Value</h3>

<p>An object of class fstats (see help(fstats) for details)
</p>


<h3>See Also</h3>

<p>To generate pooldata object, see <code><a href="#topic+vcf2pooldata">vcf2pooldata</a></code>, <code><a href="#topic+popsync2pooldata">popsync2pooldata</a></code>,<code><a href="#topic+genobaypass2pooldata">genobaypass2pooldata</a></code> or <code><a href="#topic+genoselestim2pooldata">genoselestim2pooldata</a></code>. To generate coundata object, see <code><a href="#topic+genobaypass2countdata">genobaypass2countdata</a></code> or <code><a href="#topic+genotreemix2countdata">genotreemix2countdata</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> make.example.files(writing.dir=tempdir())
 pooldata&lt;-popsync2pooldata(sync.file=paste0(tempdir(),"/ex.sync.gz"),poolsizes=rep(50,15))
 res.pca&lt;-randomallele.pca(pooldata)
</code></pre>

<hr>
<h2 id='rooted.njtree.builder'>Construct and root an Neighbor-Joining tree of presumably nonadmixed leaves</h2><span id='topic+rooted.njtree.builder'></span>

<h3>Description</h3>

<p>Construct and root an Neighbor-Joining tree of presumably nonadmixed leaves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rooted.njtree.builder(
  fstats,
  pop.sel,
  edge.fact = 1000,
  plot.nj = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rooted.njtree.builder_+3A_fstats">fstats</code></td>
<td>
<p>Object of class fstats that contains estimates of the fstats (see compute.fstats)</p>
</td></tr>
<tr><td><code id="rooted.njtree.builder_+3A_pop.sel">pop.sel</code></td>
<td>
<p>Names of the leaves (pops) used to build the nj tree (at least 3 required)</p>
</td></tr>
<tr><td><code id="rooted.njtree.builder_+3A_edge.fact">edge.fact</code></td>
<td>
<p>The multiplying factor of edges length in graph representation</p>
</td></tr>
<tr><td><code id="rooted.njtree.builder_+3A_plot.nj">plot.nj</code></td>
<td>
<p>If TRUE plot the Neighbor-Joining tree</p>
</td></tr>
<tr><td><code id="rooted.njtree.builder_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE extra information is printed on the terminal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Neighbor-Joining tree is first built (using nj function from the package ape) based on the F2-distance matrix of the leaves in pop.sel which are presumably non-admixed (see the function find.tree.popset to find such groups of scaffold populations using estimated F3 and F4 test statistics). For non-admixed leaves, F2 are indeed expected to be additive along the resulting binary tree (see Lipson et al., 2013). The resulting tree is then rooted using the method described in Lipson et al. (2013) which is based on the property that the estimated heterozygosity of the root h_R equals h_R=1-Q2(A,B) if A and B are two populations sharing R as the only common ancestor in the tree. This estimator should then be consistent across all the possible pairs of populations A and B that are only connected through R in the tree (i.e., that each belong to one of the two partitions of the tree defined by a root position R). Note that 1-Q2(A,B)=(1-Q1(A))/2 + (1-Q1(B))/2 + F2(A,B)=(h_A+h_B)/2+F2(A,B) where h_A, h_B and F2(A,B) are estimated with the function compute.fstats.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ol>
<li><p> &quot;n.rooted.trees&quot;: The number of possible rooted binary trees that were evaluated
</p>
</li>
<li><p> &quot;fitted.rooted.trees.list&quot;: a list of objects of class fitted.graph containing information on all the possible graphs (indexed from 1 to n.rooted.trees). Each tree may be visualized or further used using functions applied to objects of class fitted.graph (e.g., plot, add.leave) 
</p>
</li>
<li><p> best.rooted.tree The tree (object of class fitted.graph) among all the graphs within fitted.rooted.trees.list displaying the minimal the minimal sd over estimates of h_P (see details) 
</p>
</li>
<li><p> &quot;root.het.est.var&quot;: For a matrix of n.tree rows (same order as in the list rooted.tree) and 4 columns with i) the average estimated root heterozygosity h_R across all the pairs of population leave that are relevant for estimation (see details); ii) the size of the range of variation and iii) the s.d. of the estimates of h_R, and iv) the number of population pairs relevant for estimation 
</p>
</li>
<li><p> &quot;nj.tree.eval&quot;: If n.edges&gt;3, gives the five worst configuration fit (by calling the compare.fitted.fstats function) which are the same irrespective of rooting
</p>
</li></ol>



<h3>See Also</h3>

<p>see <code><a href="#topic+fit.graph">fit.graph</a></code>, <code><a href="#topic+generate.graph.params">generate.graph.params</a></code> and <code><a href="#topic+add.leaf">add.leaf</a></code>.
</p>

<hr>
<h2 id='scan_allele_info'>scan_allele_info</h2><span id='topic+scan_allele_info'></span><span id='topic+.scan_allele_info'></span>

<h3>Description</h3>

<p>Scan allele information in ALT field of a vcf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.scan_allele_info(allele_info)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan_allele_info_+3A_allele_info">allele_info</code></td>
<td>
<p>a character string vector (ALT field of the vcf)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Scan allele information in ALT field of a vcf to identify the number of alleles and if there is indels
</p>


<h3>Value</h3>

<p>Return a vector with two elements consisting i) the number of alleles (1+number of comma)
and ii) 0 or 1 if an indel is detected
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.scan_allele_info(c("A,C","T","AAT"))

</code></pre>

<hr>
<h2 id='show+2Ccountdata-method'>Show countdata object</h2><span id='topic+show+2Ccountdata-method'></span>

<h3>Description</h3>

<p>Show countdata object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'countdata'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2Ccountdata-method_+3A_object">object</code></td>
<td>
<p>Object of class countdata</p>
</td></tr>
</table>

<hr>
<h2 id='show+2Cfitted.graph-method'>Show fitted.graph object</h2><span id='topic+show+2Cfitted.graph-method'></span>

<h3>Description</h3>

<p>Show fitted.graph object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'fitted.graph'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2Cfitted.graph-method_+3A_object">object</code></td>
<td>
<p>Object of class fitted.graph</p>
</td></tr>
</table>

<hr>
<h2 id='show+2Cfstats-method'>Show fstats object</h2><span id='topic+show+2Cfstats-method'></span>

<h3>Description</h3>

<p>Show fstats object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'fstats'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2Cfstats-method_+3A_object">object</code></td>
<td>
<p>Object of class fstats</p>
</td></tr>
</table>

<hr>
<h2 id='show+2Cgraph.params-method'>Show graph.params object</h2><span id='topic+show+2Cgraph.params-method'></span>

<h3>Description</h3>

<p>Show graph.params object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'graph.params'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2Cgraph.params-method_+3A_object">object</code></td>
<td>
<p>Object of class graph.params</p>
</td></tr>
</table>

<hr>
<h2 id='show+2Cpairwisefst-method'>Show pairwisefst object</h2><span id='topic+show+2Cpairwisefst-method'></span>

<h3>Description</h3>

<p>Show pairwisefst object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pairwisefst'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2Cpairwisefst-method_+3A_object">object</code></td>
<td>
<p>Object of class pairwisefst</p>
</td></tr>
</table>

<hr>
<h2 id='show+2Cpooldata-method'>Show pooldata object</h2><span id='topic+show+2Cpooldata-method'></span>

<h3>Description</h3>

<p>Show pooldata object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pooldata'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2Cpooldata-method_+3A_object">object</code></td>
<td>
<p>Object of class pooldata</p>
</td></tr>
</table>

<hr>
<h2 id='vcf2pooldata'>Convert a VCF file into a pooldata object.</h2><span id='topic+vcf2pooldata'></span>

<h3>Description</h3>

<p>Convert VCF files into a pooldata object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcf2pooldata(
  vcf.file = "",
  poolsizes = NA,
  poolnames = NA,
  min.cov.per.pool = -1,
  min.rc = 1,
  max.cov.per.pool = 1e+06,
  min.maf = -1,
  remove.indels = FALSE,
  min.dist.from.indels = 0,
  nlines.per.readblock = 1e+06,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcf2pooldata_+3A_vcf.file">vcf.file</code></td>
<td>
<p>The name (or a path) of the Popoolation sync file (might be in compressed format)</p>
</td></tr>
<tr><td><code id="vcf2pooldata_+3A_poolsizes">poolsizes</code></td>
<td>
<p>A numeric vector with haploid pool sizes</p>
</td></tr>
<tr><td><code id="vcf2pooldata_+3A_poolnames">poolnames</code></td>
<td>
<p>A character vector with the names of pool</p>
</td></tr>
<tr><td><code id="vcf2pooldata_+3A_min.cov.per.pool">min.cov.per.pool</code></td>
<td>
<p>Minimal allowed read count (per pool). If at least one pool is not covered by at least min.cov.perpool reads, the position is discarded</p>
</td></tr>
<tr><td><code id="vcf2pooldata_+3A_min.rc">min.rc</code></td>
<td>
<p>Minimal allowed read count per base (options silenced for VarScan vcf). Bases covered by less than min.rc reads are discarded and considered as sequencing error. For instance, if nucleotides A, C, G and T are covered by respectively 100, 15, 0 and 1 over all the pools, setting min.rc to 0 will lead to discard the position (the polymorphism being considered as tri-allelic), while setting min.rc to 1 (or 2, 3..14) will make the position be considered as a SNP with two alleles A and C (the only read for allele T being disregarded). For VarScan vcf, markers with more than one alternative allele are discarded because the VarScan AD field only contains one alternate read count.</p>
</td></tr>
<tr><td><code id="vcf2pooldata_+3A_max.cov.per.pool">max.cov.per.pool</code></td>
<td>
<p>Maximal allowed read count (per pool). If at least one pool is covered by more than min.cov.perpool reads, the position is discarded</p>
</td></tr>
<tr><td><code id="vcf2pooldata_+3A_min.maf">min.maf</code></td>
<td>
<p>Minimal allowed Minor Allele Frequency (computed from the ratio overall read counts for the reference allele over the read coverage)</p>
</td></tr>
<tr><td><code id="vcf2pooldata_+3A_remove.indels">remove.indels</code></td>
<td>
<p>Remove indels identified using the number of characters of the alleles in the REF or ALT fields (i.e., if at least one allele is more than 1 character, the position is discarded)</p>
</td></tr>
<tr><td><code id="vcf2pooldata_+3A_min.dist.from.indels">min.dist.from.indels</code></td>
<td>
<p>Remove SNPs within min.dist.from.indels from an indel i.e. SNP with position p verifying (indel.pos-min.dist)&lt;=p&lt;=(indel.pos+min.dist+l.indels-1) where l.indel=length of the ref. indel allele. If min.dist.from.indels&gt;0, INDELS are also removed (i.e., remove.indels is set to TRUE).</p>
</td></tr>
<tr><td><code id="vcf2pooldata_+3A_nlines.per.readblock">nlines.per.readblock</code></td>
<td>
<p>Number of Lines read simultaneously. Should be adapted to the available RAM.</p>
</td></tr>
<tr><td><code id="vcf2pooldata_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE extra information is printed on the terminal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Genotype format in the vcf file for each pool is assumed to contain either i) an AD field containing allele counts separated by a comma (as produced by popular software such as GATK or samtools/bcftools) or ii) both a RD (reference allele count) and a AD (alternate allele count) as obtained with the VarScan mpileup2snp program (when run with the &ndash;output-vcf option). The underlying format is automatically detected by the function. For VarScan generated vcf, it should be noticed that SNPs with more than one alternate allele are discarded (because only a single count is then reported in the AD fields) making the min.rc unavailable. The VarScan &ndash;min-reads2 option might replace to some extent this functionality although SNP where the two major alleles in the Pool-Seq data are different from the reference allele (e.g., expected to be more frequent when using a distantly related reference genome for mapping) will be disregarded.
</p>


<h3>Value</h3>

<p>A pooldata object containing 7 elements:
</p>

<ol>
<li><p> &quot;refallele.readcount&quot;: a matrix with nsnp rows and npools columns containing read counts for the reference allele (chosen arbitrarily) in each pool
</p>
</li>
<li><p> &quot;readcoverage&quot;: a matrix with nsnp rows and npools columns containing read coverage in each pool
</p>
</li>
<li><p> &quot;snp.info&quot;: a matrix with nsnp rows and four columns containing respectively the contig (or chromosome) name (1st column) and position (2nd column) of the SNP; the allele taken as reference in the refallele.readcount matrix (3rd column); and the alternative allele (4th column)
</p>
</li>
<li><p> &quot;poolsizes&quot;: a vector of length npools containing the haploid pool sizes
</p>
</li>
<li><p> &quot;poolnames&quot;: a vector of length npools containing the names of the pools
</p>
</li>
<li><p> &quot;nsnp&quot;: a scalar corresponding to the number of SNPs
</p>
</li>
<li><p> &quot;npools&quot;: a scalar corresponding to the number of pools
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'> make.example.files(writing.dir=tempdir())
 pooldata=vcf2pooldata(vcf.file=paste0(tempdir(),"/ex.vcf.gz"),poolsizes=rep(50,15))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
