<!DOCTYPE html><html lang="en"><head><title>Help for package MatrixModels</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MatrixModels}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#glm4'><p>Fitting Generalized Linear Models (using S4)</p></a></li>
<li><a href='#glpModel-class'><p>Class &quot;glpModel&quot; of General Linear Prediction Models</p></a></li>
<li><a href='#lm.fit.sparse'><p>Fitter Function for Sparse Linear Models</p></a></li>
<li><a href='#mkRespMod'><p>Create a respModule object</p></a></li>
<li><a href='#Model-class'><p>Mother Class &quot;Model&quot; of all S4 Models</p></a></li>
<li><a href='#model.Matrix'><p>Construct Possibly Sparse Design or Model Matrices</p></a></li>
<li><a href='#modelMatrix-class'><p>Class &quot;modelMatrix&quot; and SubClasses</p></a></li>
<li><a href='#predModule-class'><p>Class &quot;predModule&quot; and SubClasses</p></a></li>
<li><a href='#resid-et-al'><p>Aliases for Model Extractors</p></a></li>
<li><a href='#respModule-class'><p>&quot;respModule&quot; and derived classes</p></a></li>
<li><a href='#reweightPred'><p>Reweight Prediction Module Structure Internals</p></a></li>
<li><a href='#solveCoef'><p>Solve for the Coefficients or Coefficient Increment</p></a></li>
<li><a href='#updateMu'><p>Update 'mu', the Fitted Mean Response</p></a></li>
<li><a href='#updateWts'><p>Update the Residual and X Weights - Generic and Methods</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.5-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-06</td>
</tr>
<tr>
<td>Title:</td>
<td>Modelling with Sparse and Dense Matrices</td>
</tr>
<tr>
<td>Author:</td>
<td>Douglas Bates &lt;bates@stat.wisc.edu&gt; and Martin Maechler &lt;maechler@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Maechler &lt;mmaechler+Matrix@gmail.com&gt;</td>
</tr>
<tr>
<td>Contact:</td>
<td>Matrix-authors@R-project.org</td>
</tr>
<tr>
<td>Description:</td>
<td>Modelling with sparse and dense 'Matrix' matrices, using
  modular prediction and response module classes.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, methods, Matrix (&ge; 1.6-0)</td>
</tr>
<tr>
<td>ImportsNote:</td>
<td>_not_yet_stats4</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://Matrix.R-forge.R-project.org/">https://Matrix.R-forge.R-project.org/</a>,
<a href="https://r-forge.r-project.org/R/?group_id=61">https://r-forge.r-project.org/R/?group_id=61</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://R-forge.R-project.org/tracker/?func=add&amp;atid=294&amp;group_id=61">https://R-forge.R-project.org/tracker/?func=add&amp;atid=294&amp;group_id=61</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-06 13:43:15 UTC; maechler</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-06 14:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='glm4'>Fitting Generalized Linear Models (using S4)</h2><span id='topic+glm4'></span>

<h3>Description</h3>

<p><code>glm4</code>, very similarly as standard <span class="rlang"><b>R</b></span>'s <code><a href="stats.html#topic+glm">glm</a>()</code> is
used to fit generalized linear models, specified by giving a symbolic
description of the linear predictor and a description of the error
distribution.
</p>
<p>It is more general, as it fits linear, generalized linear, non-linear
and generalized nonlinear models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm4(formula, family, data, weights, subset, na.action,
     start = NULL, etastart, mustart, offset,
     sparse = FALSE, drop.unused.levels = FALSE, doFit = TRUE,
     control = list(...),
     model = TRUE, x = FALSE, y = TRUE, contrasts = NULL, ...)
</code></pre>


<h3>Arguments</h3>


<table role = "presentation">
<tr><td><code id="glm4_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>"<a href="stats.html#topic+formula">formula</a>"</code> (or one that
can be coerced to that class): a symbolic description of the
model to be fitted.  The details of model specification are given
under &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="glm4_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link
function to be used in the model. This can be a character string
naming a family function, a family function or the result of a call
to a family function.  (See <code><a href="stats.html#topic+family">family</a></code> for details of
family functions.)</p>
</td></tr>
<tr><td><code id="glm4_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing
the variables in the model.  If not found in <code>data</code>, the
variables are taken from <code>environment(formula)</code>,
typically the environment from which <code>glm</code> is called.</p>
</td></tr>
<tr><td><code id="glm4_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;prior weights&rsquo; to be used
in the fitting process.  Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="glm4_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="glm4_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen
when the data contain <code>NA</code>s.  The default is set by
the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, and is
<code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset.  The &lsquo;factory-fresh&rsquo;
default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>.  Another possible value is
<code>NULL</code>, no action.  Value <code><a href="stats.html#topic+na.exclude">na.exclude</a></code> can be useful.</p>
</td></tr>
<tr><td><code id="glm4_+3A_start">start</code>, <code id="glm4_+3A_etastart">etastart</code>, <code id="glm4_+3A_mustart">mustart</code></td>
<td>

<p>starting values for the parameters in the linear predictor, the
predictor itself and for the vector of means.</p>
</td></tr>
<tr><td><code id="glm4_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during fitting.
This should be <code>NULL</code> or a numeric vector of length equal to
the number of cases.  One or more <code><a href="stats.html#topic+offset">offset</a></code> terms can be
included in the formula instead or as well, and if more than one is
specified their sum is used.  See <code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="glm4_+3A_sparse">sparse</code></td>
<td>
<p>logical indicating if the model matrix should be sparse
or not.</p>
</td></tr>
<tr><td><code id="glm4_+3A_drop.unused.levels">drop.unused.levels</code></td>
<td>
<p>used only when <code>sparse</code> is TRUE: Should
factors have unused levels dropped?
(This used to be true, <em>implicitly</em> in the first versions up to
July 2010; the default has been changed for compatibility with
<span class="rlang"><b>R</b></span>'s standard (dense) <code><a href="stats.html#topic+model.matrix">model.matrix</a>()</code>.
</p>
</td></tr>
<tr><td><code id="glm4_+3A_dofit">doFit</code></td>
<td>
<p>logical indicating if the model should be fitted (or just
returned unfitted).</p>
</td></tr>
<tr><td><code id="glm4_+3A_control">control</code></td>
<td>

<p>a list with options on fitting; currently passed unchanged to
(hidden) function <code>IRLS()</code>.</p>
</td></tr>
<tr><td><code id="glm4_+3A_model">model</code>, <code id="glm4_+3A_x">x</code>, <code id="glm4_+3A_y">y</code></td>
<td>
<p>currently ignored; here for back compatibility with
<code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code id="glm4_+3A_contrasts">contrasts</code></td>
<td>
<p>passed to <code><a href="#topic+model.Matrix">model.Matrix</a>(.., contrasts.arg =
    contrasts)</code>, see <em>its</em> documentation.</p>
</td></tr>
<tr><td><code id="glm4_+3A_...">...</code></td>
<td>
<p>potentially arguments passed on to fitter functions; not
used currently.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+glpModel-class">glpModel</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a>()</code> the standard <span class="rlang"><b>R</b></span> function;<br />
<code><a href="#topic+lm.fit.sparse">lm.fit.sparse</a>()</code> a sparse least squares fitter.
</p>
<p>The resulting class <code><a href="#topic+glpModel-class">glpModel</a></code> documentation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### All the following is very experimental -- and probably will change: -------

data(CO2, package="datasets")
## dense linear model
str(glm4(uptake ~ 0 + Type*Treatment, data=CO2, doFit = FALSE), 4)
## sparse linear model
str(glm4(uptake ~ 0 + Type*Treatment, data=CO2, doFit = FALSE,
                  sparse = TRUE), 4)

## From example(glm): -----------------

## Dobson (1990) Page 93: Randomized Controlled Trial :
str(trial &lt;- data.frame(counts=c(18,17,15,20,10,20,25,13,12),
                        outcome=gl(3,1,9,labels=LETTERS[1:3]),
                        treatment=gl(3,3,labels=letters[1:3])))
glm.D93 &lt;- glm(counts ~ outcome + treatment, family=poisson, data=trial)
summary(glm.D93)
c.glm &lt;- unname(coef(glm.D93))
glmM  &lt;- glm4(counts ~ outcome + treatment, family = poisson, data=trial)
glmM2 &lt;- update(glmM, quick = FALSE) # slightly more accurate
glmM3 &lt;- update(glmM, quick = FALSE, finalUpdate = TRUE)
                 # finalUpdate has no effect on 'coef'
stopifnot( identical(glmM2@pred@coef, glmM3@pred@coef),
           all.equal(glmM @pred@coef, c.glm, tolerance=1e-7),
           all.equal(glmM2@pred@coef, c.glm, tolerance=1e-12))


## Watch the iterations --- and use no intercept --&gt; more sparse X
## 1) dense generalized linear model
glmM &lt;- glm4(counts ~ 0+outcome + treatment, poisson, trial,
                      verbose = TRUE)
## 2) sparse generalized linear model
glmS &lt;- glm4(counts ~ 0+outcome + treatment, poisson, trial,
                      verbose = TRUE, sparse = TRUE)
str(glmS, max.lev = 4)
stopifnot( all.equal(glmM@pred@coef, glmS@pred@coef),
           all.equal(glmM@pred@Vtr,  glmS@pred@Vtr) )


## A Gamma example, from McCullagh &amp; Nelder (1989, pp. 300-2)
clotting &lt;- data.frame(u = c(5,10,15,20,30,40,60,80,100),
                       lot1 = c(118,58,42,35,27,25,21,19,18),
                       lot2 = c(69,35,26,21,18,16,13,12,12))
str(gMN &lt;- glm4(lot1 ~ log(u), data=clotting, family=Gamma, verbose=TRUE))
glm. &lt;- glm(lot1 ~ log(u), data=clotting, family=Gamma)
stopifnot( all.equal(gMN@pred@coef, unname(coef(glm.)), tolerance=1e-7) )
</code></pre>

<hr>
<h2 id='glpModel-class'>Class &quot;glpModel&quot; of General Linear Prediction Models</h2><span id='topic+glpModel-class'></span><span id='topic+coef+2CglpModel-method'></span><span id='topic+fitted+2CglpModel-method'></span><span id='topic+residuals+2CglpModel-method'></span>

<h3>Description</h3>

<p>The class <code>"glpModel"</code> conceptually contains a very large class
of <em>&ldquo;General Linear Prediction Models&rdquo;</em>.
</p>
<p>Its <code>resp</code> slot (of class <code>"<a href="#topic+respModule-class">respModule</a>"</code>) may
model linear, non-linear, generalized linear and non-linear
generalized response models.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("glpModel", ...)</code>,
but typically rather are returned by our modeling functions, e.g., <code>glm4()</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>resp</code>:</dt><dd><p>a <code>"<a href="#topic+respModule-class">respModule</a>"</code> object.</p>
</dd>
<dt><code>pred</code>:</dt><dd><p>a <code>"<a href="#topic+predModule-class">predModule</a>"</code> object.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+Model-class">Model</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>coef</dt><dd><p><code>signature(object = "glpModel")</code>: extract the
coefficient vector <code class="reqn">\beta</code> from the object.</p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "glpModel")</code>: fitted values;
there may be several types, corresponding to the residuals, see there
(below).</p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "glpModel")</code>: residuals,
depending on the type of the model, there are several types of
residuals and correspondingly residuals,
see <code><a href="stats.html#topic+glm.summaries">residuals.glm</a></code> from the
<span class="pkg">stats</span> package.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+glm4">glm4</a>()</code> returns fitted <code>glpModel</code> objects.
</p>
<p>The constituents of this class are
<code><a href="#topic+respModule-class">respModule</a></code> and
<code><a href="#topic+predModule-class">predModule</a></code>, both of which have several sub
classes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("glpModel")

## Use   example(glm4)  or see  help(glm4) for many more examples.
</code></pre>

<hr>
<h2 id='lm.fit.sparse'>Fitter Function for Sparse Linear Models</h2><span id='topic+lm.fit.sparse'></span>

<h3>Description</h3>

<p>A basic computing engine for sparse linear least squares regression.
</p>
<p>Note that the exact interface (arguments, return value) currently is
<b>experimental</b>, and is bound to change.  Use at your own risk!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm.fit.sparse(x, y, w = NULL, offset = NULL,
              method = c("qr", "cholesky"),
              tol = 1e-7, singular.ok = TRUE, order = NULL,
              transpose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lm.fit.sparse_+3A_x">x</code></td>
<td>
<p><em>sparse</em> design matrix of dimension <code>n * p</code>, i.e.,
an <span class="rlang"><b>R</b></span> object of a <code><a href="base.html#topic+class">class</a></code> extending
<code><a href="Matrix.html#topic+dsparseMatrix-class">dsparseMatrix</a></code>; typically the result of
<code><a href="Matrix.html#topic+sparse.model.matrix">sparse.model.matrix</a></code>.</p>
</td></tr>
<tr><td><code id="lm.fit.sparse_+3A_y">y</code></td>
<td>
<p>vector of observations of length <code>n</code>, or a matrix with
<code>n</code> rows.</p>
</td></tr>
<tr><td><code id="lm.fit.sparse_+3A_w">w</code></td>
<td>
<p>vector of weights (length <code>n</code>) to be used in the fitting
process.  Weighted least squares is used with weights <code>w</code>,
i.e., <code>sum(w * e^2)</code> is minimized.
</p>
<p><b>Not yet implemented !</b>
</p>
</td></tr>
<tr><td><code id="lm.fit.sparse_+3A_offset">offset</code></td>
<td>
<p>numeric of length <code>n</code>).  This can be used to
specify an <em>a priori</em> known component to be included in the
linear predictor during fitting.</p>
</td></tr>
<tr><td><code id="lm.fit.sparse_+3A_method">method</code></td>
<td>
<p>a character string specifying the (factorization)
method.  Currently, <code>"qr"</code> or <code>"cholesky"</code>.</p>
</td></tr>
<tr><td><code id="lm.fit.sparse_+3A_tol">tol</code></td>
<td>
<p>[for back-compatibility only; unused:] tolerance for the
<code><a href="base.html#topic+qr">qr</a></code> decomposition.  Default is 1e-7.</p>
</td></tr>
<tr><td><code id="lm.fit.sparse_+3A_singular.ok">singular.ok</code></td>
<td>
<p>[for back-compatibility only; unused:] logical. If
<code>FALSE</code>, a singular model is an error.</p>
</td></tr>
<tr><td><code id="lm.fit.sparse_+3A_order">order</code></td>
<td>
<p>integer or <code>NULL</code>, for <code>method == "qr"</code>, will
determine how the fill-reducing ordering (aka permutation) for the
&ldquo;symbolic&rdquo; part is determined (in <code>cs_amd()</code>), with the
options </p>

<dl>
<dt>0:</dt><dd><p>natural,</p>
</dd>
<dt>1:</dt><dd><p>Chol,</p>
</dd>
<dt>2:</dt><dd><p>LU,   and</p>
</dd>
<dt>3:</dt><dd><p>QR,</p>
</dd>
</dl>

<p>where <code>3</code> is the default.</p>
</td></tr>
<tr><td><code id="lm.fit.sparse_+3A_transpose">transpose</code></td>
<td>

<p>logical; if true, use the transposed matrix <code>t(x)</code> instead of
<code>x</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a single numeric vector or a list of four numeric vectors.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glm4">glm4</a></code> is an alternative (much) more general fitting
function.
</p>
<p><code><a href="Matrix.html#topic+sparse.model.matrix">sparse.model.matrix</a></code> from the <span class="pkg">Matrix</span> package;
the non-sparse function in standard <span class="rlang"><b>R</b></span>'s package <span class="pkg">stats</span>:
<code><a href="stats.html#topic+lm.fit">lm.fit</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dd &lt;- expand.grid(a = as.factor(1:3),
                  b = as.factor(1:4),
                  c = as.factor(1:2),
                  d= as.factor(1:8))
n &lt;- nrow(dd &lt;- dd[rep(seq_len(nrow(dd)), each = 10), ])
set.seed(17)
dM &lt;- cbind(dd, x = round(rnorm(n), 1))
## randomly drop some
n &lt;- nrow(dM &lt;- dM[- sample(n, 50),])
dM &lt;- within(dM, { A &lt;- c(2,5,10)[a]
                   B &lt;- c(-10,-1, 3:4)[b]
                   C &lt;- c(-8,8)[c]
                   D &lt;- c(10*(-5:-2), 20*c(0, 3:5))[d]
   Y &lt;- A + B + A*B + C + D + A*D + C*x + rnorm(n)/10
   wts &lt;- sample(1:10, n, replace=TRUE)
   rm(A,B,C,D)
})
str(dM) # 1870 x 7

X &lt;- Matrix::sparse.model.matrix( ~ (a+b+c+d)^2 + c*x, data = dM)
dim(X) # 1870 x 69
X[1:10, 1:20]

## For now, use  'MatrixModels:::'  --- TODO : export once interface is clear!

Xd &lt;- as(X,"matrix")
system.time(fmDense &lt;- lm.fit(Xd, y = dM[,"Y"])) # {base} functionality
system.time( r1 &lt;- MatrixModels:::lm.fit.sparse(X, y = dM[,"Y"]) ) # *is* faster
stopifnot(all.equal(r1, unname(fmDense$coeff), tolerance = 1e-12))
system.time(
     r2 &lt;- MatrixModels:::lm.fit.sparse(X, y = dM[,"Y"], method = "chol") )
stopifnot(all.equal(r1, r2$coef, tolerance = 1e-12),
          all.equal(fmDense$residuals, r2$residuals, tolerance=1e-9)
         )
## with weights:
system.time(fmD.w &lt;- with(dM, lm.wfit(Xd, Y, w = wts)))
system.time(fm.w1 &lt;- with(dM, MatrixModels:::lm.fit.sparse(X, Y, w = wts)))
system.time(fm.w2 &lt;- with(dM, MatrixModels:::lm.fit.sparse(X, Y, w = wts,
                                                     method = "chol") ))
stopifnot(all.equal(fm.w1, unname(fmD.w$coeff), tolerance = 1e-12),
          all.equal(fm.w2$coef, fm.w1, tolerance = 1e-12),
          all.equal(fmD.w$residuals, fm.w2$residuals, tolerance=1e-9)
          )
</code></pre>

<hr>
<h2 id='mkRespMod'>Create a respModule object</h2><span id='topic+mkRespMod'></span>

<h3>Description</h3>

<p>Create a <code><a href="#topic+respModule-class">respModule</a></code> object, which could be from a
derived class such as <code><a href="#topic+glmRespMod-class">glmRespMod</a></code> or
<code><a href="#topic+nlsRespMod-class">nlsRespMod</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkRespMod(fr, family = NULL, nlenv = NULL, nlmod = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mkRespMod_+3A_fr">fr</code></td>
<td>

<p>a model frame, usually created by a call to <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="mkRespMod_+3A_family">family</code></td>
<td>

<p>an optional glm <code><a href="stats.html#topic+family">family</a></code> object
(<code><a href="#topic+glmRespMod-class">glmRespMod</a></code> objects only).</p>
</td></tr>
<tr><td><code id="mkRespMod_+3A_nlenv">nlenv</code></td>
<td>

<p>an environment for evaluation of the nonlinear model, <code>nlmod</code>.
(<code><a href="#topic+nlsRespMod-class">nlsRespMod</a></code> objects only).</p>
</td></tr>
<tr><td><code id="mkRespMod_+3A_nlmod">nlmod</code></td>
<td>

<p>the nonlinear model function, as a function call
(<code><a href="#topic+nlsRespMod-class">nlsRespMod</a></code> objects only).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The internal representation of a statistical model based on
a linear predictor expression is derived from a <code><a href="stats.html#topic+formula">formula</a></code>
expression and a <code>data</code> argument, possibly supplemented with a
<code><a href="stats.html#topic+family">family</a></code> object and/or a nonlinear model expression.  The
steps to obtain this representation usually involve calls to
<code><a href="stats.html#topic+model.frame">model.frame</a></code> and to <code><a href="stats.html#topic+model.matrix">model.matrix</a></code> or
<code><a href="#topic+model.Matrix">model.Matrix</a></code>, which encapsulate important parts of this
process.   This function encapsulates other operations related to
weights and offsets and to the model family to create a
<code><a href="#topic+respModule-class">respModule</a></code> object.
</p>


<h3>Value</h3>

<p>an object of a class inheriting from <code><a href="#topic+respModule-class">respModule</a></code>.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+respModule-class">respModule</a></code> class description.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## see  help("glpModel-class")
</code></pre>

<hr>
<h2 id='Model-class'>Mother Class &quot;Model&quot; of all S4 Models</h2><span id='topic+Model-class'></span><span id='topic+formula+2CModel-method'></span><span id='topic+update+2CModel-method'></span>

<h3>Description</h3>

<p>Class <code>"Model"</code> is meant to be the mother class of all (S4) model
classes.
As some useful methods are already defined for <code>"Model"</code> objects,
derived classes inherit those &ldquo;for free&rdquo;.
</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>the <code><a href="base.html#topic+call">call</a></code> which generated the model.</p>
</dd>
<dt><code>fitProps</code>:</dt><dd><p>a <code><a href="base.html#topic+list">list</a></code>; must be named,
i.e., have unique <code><a href="base.html#topic+names">names</a></code>, but can be empty.
</p>
<p>When the main object is a <em>fitted</em> model, the list will
typically have components such as <code>iter</code> (non-negative
integer) and <code>convergenece</code> (<code><a href="base.html#topic+logical">logical</a></code> typically).
</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>formula</dt><dd><p><code>signature(x = "Model")</code>: extract the model
formula - if there is one, or <code><a href="base.html#topic+NULL">NULL</a></code>.</p>
</dd>
<dt>update</dt><dd><p><code>signature(object = "Model")</code>: Update the model
with a new formula, new data, ...... etc.  This semantically
equivalent (and as <span class="rlang"><b>R</b></span> function almost identical) to the standard
<code><a href="stats.html#topic+update">update</a></code> (package <span class="pkg">stats</span>).</p>
</dd>
</dl>



<h3>See Also</h3>


<p>the <code><a href="#topic+glpModel-class">glpModel</a></code> class in package
<span class="pkg">MatrixModels</span> which extends this class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("Model")
</code></pre>

<hr>
<h2 id='model.Matrix'>Construct Possibly Sparse Design or Model Matrices</h2><span id='topic+model.Matrix'></span>

<h3>Description</h3>

<p><code>model.Matrix</code> creates design matrix, very much like the
standard <span class="rlang"><b>R</b></span> function <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>, however returning a
dense or sparse object of class <code><a href="#topic+modelMatrix-class">modelMatrix</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.Matrix(object, data = environment(object),
             contrasts.arg = NULL, xlev = NULL,
             sparse = FALSE, drop.unused.levels = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model.Matrix_+3A_object">object</code></td>
<td>
<p>an object of an appropriate class.  For the default
method, a model <a href="stats.html#topic+formula">formula</a> or a <code><a href="stats.html#topic+terms">terms</a></code> object.</p>
</td></tr>
<tr><td><code id="model.Matrix_+3A_data">data</code></td>
<td>
<p>a data frame created with <code><a href="stats.html#topic+model.frame">model.frame</a></code>.  If
another sort of object, <code>model.frame</code> is called first.</p>
</td></tr>
<tr><td><code id="model.Matrix_+3A_contrasts.arg">contrasts.arg</code></td>
<td>
<p>A list, whose entries are values (numeric
matrices or character strings naming functions) to be used
as replacement values for the <code><a href="stats.html#topic+contrasts">contrasts</a></code>
replacement function and whose names are the names of
columns of <code>data</code> containing <code><a href="base.html#topic+factor">factor</a></code>s.</p>
</td></tr>
<tr><td><code id="model.Matrix_+3A_xlev">xlev</code></td>
<td>
<p>to be used as argument of <code><a href="stats.html#topic+model.frame">model.frame</a></code> if
<code>data</code> has no <code>"terms"</code> attribute.</p>
</td></tr>
<tr><td><code id="model.Matrix_+3A_sparse">sparse</code></td>
<td>
<p>logical indicating if the result should be sparse
(of class <code><a href="#topic+sparseModelMatrix-class">sparseModelMatrix</a></code>), using
<code><a href="Matrix.html#topic+sparse.model.matrix">sparse.model.matrix</a>()</code> (package <span class="pkg">Matrix</span>).</p>
</td></tr>
<tr><td><code id="model.Matrix_+3A_drop.unused.levels">drop.unused.levels</code></td>
<td>
<p>used only when <code>sparse</code> is TRUE: Should
factors have unused levels dropped?
(This used to be true, <em>implicitly</em> in the first versions up to
July 2010; the default has been changed for compatibility with
<span class="rlang"><b>R</b></span>'s standard (dense) <code><a href="stats.html#topic+model.matrix">model.matrix</a>()</code>.
</p>
</td></tr>
<tr><td><code id="model.Matrix_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>model.Matrix()</code> is a simple wrapper either (<code>sparse = FALSE</code>)
around the traditional <code><a href="stats.html#topic+model.matrix">model.matrix</a>()</code> returning a
<code>"<a href="#topic+ddenseModelMatrix-class">ddenseModelMatrix</a>"</code>, or (<code>sparse = TRUE</code>)
around <code><a href="Matrix.html#topic+sparse.model.matrix">sparse.model.matrix</a>()</code>, returning a
<code>"<a href="#topic+dsparseModelMatrix-class">dsparseModelMatrix</a>"</code> object.
</p>
<p><code>model.Matrix</code> creates a design matrix from the description given
in <code>terms(object)</code>, using the data in <code>data</code> which must
supply variables with the same names as would be created by a call to
<code>model.frame(object)</code> or, more precisely, by evaluating
<code>attr(terms(object), "variables")</code>.
</p>
<p>For more details, see <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.
</p>


<h3>Value</h3>

<p>an object inheriting from class <code><a href="#topic+modelMatrix-class">modelMatrix</a></code>, by
default, <code><a href="#topic+ddenseModelMatrix-class">ddenseModelMatrix</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+model.matrix">model.matrix</a></code>,
<code><a href="Matrix.html#topic+sparse.model.matrix">sparse.model.matrix</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CO2, package="datasets")
class(sm &lt;- model.Matrix(~ 0+Type*Treatment, data=CO2, sparse=TRUE))
class(dm &lt;- model.Matrix(~ 0+Type*Treatment, data=CO2, sparse=FALSE))
stopifnot(dim(sm) == c(84,4), dim(sm) == dim(dm), all(sm == dm))
</code></pre>

<hr>
<h2 id='modelMatrix-class'>Class &quot;modelMatrix&quot; and SubClasses</h2><span id='topic+modelMatrix-class'></span><span id='topic+denseModelMatrix-class'></span><span id='topic+ddenseModelMatrix-class'></span><span id='topic+sparseModelMatrix-class'></span><span id='topic+dsparseModelMatrix-class'></span><span id='topic+show+2CmodelMatrix-method'></span><span id='topic+print+2CmodelMatrix-method'></span>

<h3>Description</h3>

<p>The class <code>"modelMatrix"</code> and notably its subclass
<code>"dsparseModelMatrix"</code> are used to encode additional information,
analogously to what the standard <span class="rlang"><b>R</b></span> function
<code><a href="stats.html#topic+model.matrix">model.matrix</a>()</code> returns.
</p>


<h3>Objects from the Classes</h3>

<p>Only <code>"dsparseModelMatrix"</code> and <code>"ddenseModelMatrix"</code> are
&ldquo;actual&rdquo; (aka non-virtual) classes. For these,
objects can be created by calls of the form
<code>new("dsparseModelMatrix", x, assign, contrast)</code>, where <code>x</code>
is a <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code> classed object.
</p>


<h3>Slots</h3>

<p>The <code>"modelMatrix"</code> mother class contains
<code><a href="Matrix.html#topic+Matrix-class">Matrix</a></code> plus two extra slots,
</p>

<dl>
<dt><code>assign</code>:</dt><dd><p><code>"integer"</code> vector of length
<code>ncol(.)</code>, coding the variables which make up the
matrix columns, see <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.</p>
</dd>
<dt><code>contrasts</code>:</dt><dd><p>a named <code><a href="base.html#topic+list">list</a></code> of
<code><a href="stats.html#topic+contrasts">contrasts</a></code>, as in <code><a href="stats.html#topic+model.matrix">model.matrix</a>()</code>.</p>
</dd>
<dt><code>Dim</code>:</dt><dd><p>integer vector of length two with the matrix dimensions.</p>
</dd>
<dt><code>Dimnames</code>:</dt><dd><p>list of length two, the
<code><a href="base.html#topic+dimnames">dimnames</a>(.)</code> of the matrix.</p>
</dd>
</dl>

<p>whereas the (current only) actual classes <code>"d*ModelMatrix"</code>,
have an at least an additional (<code><a href="base.html#topic+numeric">numeric</a></code> slot <code>"x"</code>.
E.g., &quot;dsparseModelMatrix&quot; has the additional slots
</p>

<dl>
<dt><code>i</code>,<code>p</code>:</dt><dd><p>row number and &ldquo;pointer&rdquo; integer
vectors, see class <code>"<a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a>"</code>.</p>
</dd>
<dt><code>x</code>:</dt><dd><p><code>"numeric"</code> vector of non-zero entries.</p>
</dd>
<dt><code>factors</code>:</dt><dd><p>a (possibly empty) <code><a href="base.html#topic+list">list</a></code> of
factorizations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p><code>"dsparseModelMatrix"</code> extends class <code>"<a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a>"</code> directly,<br />
<code>"ddenseModelMatrix"</code> extends class <code>"<a href="Matrix.html#topic+dgeMatrix-class">dgeMatrix</a>"</code> directly.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "modelMatrix")</code>:
<code><a href="methods.html#topic+show">show</a>(.)</code> the matrix, but also the <code>assign</code> and
<code>contrasts</code> slots.</p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "modelMatrix")</code>: as <code>show()</code>,
however (via <code>...</code>) allowing to pass further arguments for
printing the matrix.

</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+sparse.model.matrix">sparse.model.matrix</a></code> will return a
<code>"dsparseModelMatrix"</code> object.
<code><a href="#topic+model.Matrix">model.Matrix</a></code> which is a simple wrapper around the traditional
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code> and returns a <code>"ddenseModelMatrix"</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("modelMatrix")
showClass("dsparseModelMatrix")

## see   example(model.Matrix)
</code></pre>

<hr>
<h2 id='predModule-class'>Class &quot;predModule&quot; and SubClasses</h2><span id='topic+predModule-class'></span><span id='topic+dPredModule-class'></span><span id='topic+sPredModule-class'></span><span id='topic+coerce+2CddenseModelMatrix+2CpredModule-method'></span><span id='topic+coerce+2CdsparseModelMatrix+2CpredModule-method'></span>

<h3>Description</h3>

<p>The class <code>"predModule"</code> and notably its subclasses
<code>"dPredModule"</code> and <code>"sPredModule"</code> encapsulate information
about linear predictors in statistical models.  They incorporate a
<code><a href="#topic+modelMatrix-class">modelMatrix</a></code>, the corresponding coefficients and a
representation of a triangular factor from the, possibly weighted or
otherwise modified, model matrix.
</p>


<h3>Objects from the Classes</h3>

<p>Objects are typically created by coercion from objects of class
<code><a href="#topic+ddenseModelMatrix-class">ddenseModelMatrix</a></code> or
<code><a href="#topic+dsparseModelMatrix-class">dsparseModelMatrix</a></code>.
</p>


<h3>Slots</h3>

<p>The virtual class <code>"predModule"</code> and its two subclasses all have slots
</p>

<dl>
<dt><code>X</code>:</dt><dd><p>a <code><a href="#topic+modelMatrix-class">modelMatrix</a></code>.</p>
</dd>
<dt><code>coef</code>:</dt><dd><p><code>"numeric"</code> coefficient vector of length
<code>ncol(.)</code><code class="reqn">:= p</code>.</p>
</dd>
<dt><code>Vtr</code>:</dt><dd><p><code>"numeric"</code> vector of length <code class="reqn">p</code>,
to contain <code class="reqn">V'r</code> (&ldquo;<b>V</b> <b>t</b>ransposed <b>r</b>&rdquo;).</p>
</dd>
<dt><code>fac</code>:</dt><dd><p>a representation of a triangular factor, the
Cholesky decomposition of <code class="reqn">V'V</code>.</p>
</dd>
</dl>

<p>The actual classes <code>"dPredModule"</code> and <code>"sPredModule"</code>
specify specific (sub) classes for the two non-trivial slots,
</p>

<dl>
<dt><code>X</code>:</dt><dd><p>a <code>"<a href="#topic+ddenseModelMatrix-class">ddenseModelMatrix</a>"</code> or
<code>"<a href="#topic+dsparseModelMatrix-class">dsparseModelMatrix</a>"</code>, respectively.</p>
</dd>
<dt><code>fac</code>:</dt><dd><p>For the <code>"dpredModule"</code> class this factor is a
<code><a href="Matrix.html#topic+Cholesky-class">Cholesky</a></code> object.  For the <code>"spredModule"</code> class
it is of class <code><a href="Matrix.html#topic+CHMfactor-class">CHMfactor</a></code>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p><code>signature(from = "ddenseModelMatrix", to = "predModule")</code>:
Creates a <code>"dPredModule"</code> object.</p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "dsparseModelMatrix", to = "predModule")</code>:
Creates an <code>"sPredModule"</code> object.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Douglas Bates</p>


<h3>See Also</h3>

<p><code><a href="#topic+model.Matrix">model.Matrix</a>()</code> which returns a
<code>"<a href="#topic+ddenseModelMatrix-class">ddenseModelMatrix</a>"</code> or
<code>"<a href="#topic+dsparseModelMatrix-class">dsparseModelMatrix</a>"</code> object, depending if its
<code>sparse</code> argument is false or true. In both cases, the resulting
<code>"modelMatrix"</code> can then be coerced to a sparse or dense
<code>"predModule"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("dPredModule")
showClass("sPredModule")

## see   example(model.Matrix)
</code></pre>

<hr>
<h2 id='resid-et-al'>Aliases for Model Extractors</h2><span id='topic+resid+2CANY-method'></span><span id='topic+fitted.values+2CANY-method'></span><span id='topic+coefficients+2CANY-method'></span>

<h3>Description</h3>

<p>Aliases for model extractors; it is an old S and <span class="rlang"><b>R</b></span> tradition to have
aliases for these three model extractor functions:
</p>

<dl>
<dt><code>resid()</code></dt><dd><p>equivalent to <code><a href="stats.html#topic+residuals">residuals</a>()</code>.</p>
</dd>
<dt><code>fitted.values()</code></dt><dd><p>equivalent to <code><a href="stats.html#topic+fitted">fitted</a>()</code>.</p>
</dd>
<dt><code>coefficients()</code></dt><dd><p>equivalent to <code><a href="stats.html#topic+coef">coef</a>()</code>.</p>
</dd>
</dl>

<p>We provide S4 generics and methods for these.
</p>


<h3>Methods</h3>


<dl>
<dt>resid</dt><dd><p><code>signature(object = "ANY")</code>: return the residuals;
this is a rarely used <em>alias</em> for <code><a href="stats.html#topic+residuals">residuals</a>()</code>.</p>
</dd>
<dt>fitted.values</dt><dd><p><code>signature(object = "ANY")</code>: return the
fitted values; this is a rarely used <em>alias</em> for <code><a href="stats.html#topic+fitted">fitted</a>()</code>.</p>
</dd>
<dt>coefficients</dt><dd><p><code>signature(object = "ANY")</code>: return the
coefficients of a model; this is a rarely used <em>alias</em> for
<code><a href="stats.html#topic+coef">coef</a>()</code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="stats.html#topic+residuals">residuals</a></code>;
<code><a href="methods.html#topic+Methods">Methods</a></code> for general information about formal (S4) methods.
</p>

<hr>
<h2 id='respModule-class'>&quot;respModule&quot; and derived classes</h2><span id='topic+respModule-class'></span><span id='topic+glmRespMod-class'></span><span id='topic+nlsRespMod-class'></span><span id='topic+nglmRespMod-class'></span><span id='topic+fitted+2CrespModule-method'></span><span id='topic+residuals+2CrespModule-method'></span><span id='topic+residuals+2CglmRespMod-method'></span>

<h3>Description</h3>

<p>The <code>"respModule"</code> class is the virtual base class of
response modules for <code><a href="#topic+glpModel-class">glpModel</a></code> model objects.
Classes that inherit from <code>"respModule"</code> include
<code><a href="#topic+glmRespMod-class">glmRespMod</a></code>, for
generalized linear models, <code><a href="#topic+nlsRespMod-class">nlsRespMod</a></code>, for
nonlinear models and <code><a href="#topic+nglmRespMod-class">nglmRespMod</a></code> for generalized
nonlinear models.
</p>


<h3>Objects from the Class</h3>

<p>Objects from these classes are usually created with
<code><a href="#topic+mkRespMod">mkRespMod</a></code> as part of an <code><a href="#topic+glpModel-class">glpModel</a></code>
object returned by model-fitting functions such as the hidden function
<code>glm4</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>mu</code>:</dt><dd><p>Fitted mean response.</p>
</dd>
<dt><code>offset</code>:</dt><dd><p>offset in the linear predictor &ndash; always
present even if it is a vector of zeros.  In an
<code><a href="#topic+nlsRespMod-class">nlsRespMod</a></code> object the length of the offset can be
a multiple of the length of the response.</p>
</dd>
<dt><code>sqrtXwt</code>:</dt><dd><p>the matrix of
weights for the model matrices, derived from the <code>sqrtrwt</code> slot.</p>
</dd>
<dt><code>sqrtrwt</code>:</dt><dd><p>Numeric vector of the square roots
of the weights for the residuals.  For
<code>respModule</code> and <code><a href="#topic+nlsRespMod-class">nlsRespMod</a></code>
objects these are constant.  For
<code><a href="#topic+glmRespMod-class">glmRespMod</a></code> and <code><a href="#topic+nglmRespMod-class">nglmRespMod</a></code>
objects these are updated at each iteration of the iteratively
reweighted least squares algorithm.</p>
</dd>
<dt><code>weights</code>:</dt><dd><p>Prior
weights &ndash; always present even when it is a vector of ones.</p>
</dd>
<dt><code>y</code>:</dt><dd><p>Numeric response vector.</p>
</dd>
<dt><code>family</code>:</dt><dd><p>a glm family, see <code><a href="stats.html#topic+family">family</a></code> for
details - <code>glmRespMod</code> objects only.</p>
</dd>
<dt><code>eta</code>:</dt><dd><p>numeric vector, the linear predictor that is
transformed to the conditional mean via the link function -
<code>glmRespMod</code> objects only.</p>
</dd>
<dt><code>n</code>:</dt><dd><p>a numeric vector used for calculation of the aic family
function (it is really only used with the binomial family but
we need to include it everywhere) - <code>glmRespMod</code> objects only.</p>
</dd>
<dt><code>nlenv</code>:</dt><dd><p>an environment in which to evaluate the
nonlinear model function - <code>nlsRespMod</code> objects only.</p>
</dd>
<dt><code>nlmod</code>:</dt><dd><p>an unevaluated call to the
nonlinear model function - <code>nlsRespMod</code> objects only.</p>
</dd>
<dt><code>pnames</code>:</dt><dd><p>a character vector of parameter names -
<code>nlsRespMod</code> objects only.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>fitted</dt><dd><p><code>signature(object = "respModule")</code>: fitted values;
there may be several types, corresponding to the residuals, see there
(below).</p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "respModule")</code>: residuals,
depending on the type of the model, there are several types of
residuals and correspondingly residuals,
see <code><a href="stats.html#topic+glm.summaries">residuals.glm</a></code> from the
<span class="pkg">stats</span> package.  Because many of these types of residuals are
identical except for objects that inherit from &quot;glmRespMod&quot;, a
separate method is defined for this subclass.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+mkRespMod">mkRespMod</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("respModule")
showClass("glmRespMod")
showClass("nlsRespMod")
</code></pre>

<hr>
<h2 id='reweightPred'>Reweight Prediction Module Structure Internals</h2><span id='topic+reweightPred'></span><span id='topic+reweightPred-methods'></span><span id='topic+reweightPred+2CdPredModule+2Cmatrix+2Cnumeric-method'></span><span id='topic+reweightPred+2CsPredModule+2Cmatrix+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Update any internal structures associated with sqrtXwt and the
weighted residuals.  The &quot;V&quot; matrix is evaluated from X using the
sqrtXwt matrix and a Vtr vector is calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reweightPred(predM, sqrtXwt, wtres, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reweightPred_+3A_predm">predM</code></td>
<td>
<p>a predictor module</p>
</td></tr>
<tr><td><code id="reweightPred_+3A_sqrtxwt">sqrtXwt</code></td>
<td>
<p>the sqrtXwt matrix</p>
</td></tr>
<tr><td><code id="reweightPred_+3A_wtres">wtres</code></td>
<td>
<p>the vector of weighted residuals</p>
</td></tr>
<tr><td><code id="reweightPred_+3A_...">...</code></td>
<td>
<p>potentially further arguments used in methods; not used
currently.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated predM</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(predM = "dPredModule", sqrtXwt = "matrix",
	wtres = "numeric")</code></dt><dd><p> .. </p>
</dd>
<dt><code>signature(predM = "sPredModule", sqrtXwt = "matrix",
	wtres = "numeric")</code></dt><dd><p> .. </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## TODO
</code></pre>

<hr>
<h2 id='solveCoef'>Solve for the Coefficients or Coefficient Increment</h2><span id='topic+solveCoef'></span><span id='topic+solveCoef-methods'></span><span id='topic+solveCoef+2CdPredModule-method'></span><span id='topic+solveCoef+2CsPredModule-method'></span>

<h3>Description</h3>

<p>The squared length of the intermediate solution is attached as an
attribute of the returned value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solveCoef(predM, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="solveCoef_+3A_predm">predM</code></td>
<td>
<p>prediction module, i.e. from class
<code><a href="#topic+predModule-class">predModule</a></code>.</p>
</td></tr>
<tr><td><code id="solveCoef_+3A_...">...</code></td>
<td>
<p>potentially further arguments used in methods; not used
currently.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>coefficient vector or increment of coef.~vector.</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(predM = "dPredModule")</code></dt><dd><p> .. </p>
</dd>
<dt><code>signature(predM = "sPredModule")</code></dt><dd><p> .. </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## TODO
</code></pre>

<hr>
<h2 id='updateMu'>Update 'mu', the Fitted Mean Response</h2><span id='topic+updateMu'></span><span id='topic+updateMu-methods'></span><span id='topic+updateMu+2CglmRespMod+2Cnumeric-method'></span><span id='topic+updateMu+2CnglmRespMod+2Cnumeric-method'></span><span id='topic+updateMu+2CnlsRespMod+2Cnumeric-method'></span><span id='topic+updateMu+2CrespModule+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Updates the mean vector <code class="reqn">\mu</code> given the linear predictor
<code class="reqn">\gamma</code>.  Evaluate the residuals and the weighted sum of squared
residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateMu(respM, gamma, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="updateMu_+3A_respm">respM</code></td>
<td>
<p>a response module, see the
<code><a href="#topic+respModule-class">respModule</a></code> class.</p>
</td></tr>
<tr><td><code id="updateMu_+3A_gamma">gamma</code></td>
<td>
<p>the value of the linear predictor before adding the offset</p>
</td></tr>
<tr><td><code id="updateMu_+3A_...">...</code></td>
<td>
<p>potentially further arguments used in methods; not used
currently.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the offset is added to the linear predictor before
calculating mu.
</p>
<p>The sqrtXwt matrix can be updated but the sqrtrwt should not be in
that the weighted sum of squared residuals should be calculated
relative to fixed weights.  Reweighting is done in a separate call.
</p>


<h3>Value</h3>

<p>updated <code>respM</code></p>


<h3>Methods</h3>


<dl>
<dt><code>signature(respM = "glmRespMod", gamma = "numeric")</code></dt><dd><p> .. </p>
</dd>
<dt><code>signature(respM = "nglmRespMod", gamma = "numeric")</code></dt><dd><p> .. </p>
</dd>
<dt><code>signature(respM = "nlsRespMod", gamma = "numeric")</code></dt><dd><p> .. </p>
</dd>
<dt><code>signature(respM = "respModule", gamma = "numeric")</code></dt><dd><p> .. </p>
</dd>
</dl>



<h3>See Also</h3>

<p>The <code><a href="#topic+respModule-class">respModule</a></code> class (and specific subclasses);
<code><a href="#topic+glm4">glm4</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## TODO
</code></pre>

<hr>
<h2 id='updateWts'>Update the Residual and X Weights - Generic and Methods</h2><span id='topic+updateWts'></span><span id='topic+updateWts-methods'></span><span id='topic+updateWts+2CglmRespMod-method'></span><span id='topic+updateWts+2CrespModule-method'></span>

<h3>Description</h3>

<p>Update the residual weights <code>sqrtrwt</code> and
<code class="reqn">X</code> weights <code>sqrtXwt</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateWts(respM, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="updateWts_+3A_respm">respM</code></td>
<td>
<p>a response module, see the
<code><a href="#topic+respModule-class">respModule</a></code> class.</p>
</td></tr>
<tr><td><code id="updateWts_+3A_...">...</code></td>
<td>
<p>potentially further arguments used in methods; not used
currently.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated response module.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(respM = "glmRespMod")</code></dt><dd><p> .. </p>
</dd>
<dt><code>signature(respM = "respModule")</code></dt><dd><p> .. </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## TODO
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
