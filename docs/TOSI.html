<!DOCTYPE html><html lang="en"><head><title>Help for package TOSI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TOSI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#assessBsFun'><p>Assess the performance of group-sparse loading estimate</p></a></li>
<li><a href='#bic.spfac'><p>Modified BIC criteria for selecting penalty parameters</p></a></li>
<li><a href='#ccorFun'><p>Evaluate the smallest canonical correlation for two set of variables</p></a></li>
<li><a href='#cv.spfac'><p>Cross validation for selecting penalty parameters</p></a></li>
<li><a href='#FacRowMaxST'><p>Data splitting-based two-stage maximum testing method for a group of loading vectors in factor models.</p></a></li>
<li><a href='#FacRowMinST'><p>Data splitting-based two-stage minimum testing method for a group of loading vectors in factor models.</p></a></li>
<li><a href='#Factorm'><p>Factor Analysis Model</p></a></li>
<li><a href='#gendata_Fac'><p>Generate simulated data</p></a></li>
<li><a href='#gendata_Mean'><p>Generate simulated data</p></a></li>
<li><a href='#gendata_Reg'><p>Generate simulated data</p></a></li>
<li><a href='#gsspFactorm'><p>High Dimensional Sparse  Factor Model</p></a></li>
<li><a href='#MeanMax'><p>Data splitting-based two-stage maximum mean testing method for the mean vector.</p></a></li>
<li><a href='#MeanMin'><p>Data splitting-based two-stage minimum mean testing method for the mean vector.</p></a></li>
<li><a href='#RegMax'><p>Data splitting-based two-stage maximum testing method for the regression coefficients in linear regression models</p></a></li>
<li><a href='#RegMin'><p>Data splitting-based two-Stage minimum testing method for the regression coefficients in linear regression models.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Two-Directional Simultaneous Inference for High-Dimensional
Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-26</td>
</tr>
<tr>
<td>Author:</td>
<td>Wei Liu [aut, cre],
  Huazhen Lin [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wei Liu &lt;weiliu@smail.swufe.edu.cn&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A general framework of two directional simultaneous inference
    is provided for high-dimensional as well as the fixed dimensional models with manifest
    variable or latent variable structure, such as high-dimensional mean models, high-
    dimensional sparse regression models, and high-dimensional latent factors models.
    It is making the simultaneous inference on a set of parameters from two directions,
    one is testing whether the estimated zero parameters indeed are zero and the other is
    testing whether there exists zero in the parameter set of non-zero. More details can be 
    referred to Wei Liu, et al. (2022) &lt;<a href="https://doi.org/10.48550%2FarXiv.2012.11100">doi:10.48550/arXiv.2012.11100</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, hdi, scalreg, glmnet</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/feiyoung/TOSI">https://github.com/feiyoung/TOSI</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/feiyoung/TOSI/issues">https://github.com/feiyoung/TOSI/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-26 11:43:19 UTC; Liuxianju</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-26 22:00:30 UTC</td>
</tr>
</table>
<hr>
<h2 id='assessBsFun'>Assess the performance of group-sparse loading estimate</h2><span id='topic+assessBsFun'></span>

<h3>Description</h3>

<p>Evaluate the model selection consistency rate (SCR), F-measure and the smallest canonical correlation and the larger values mean better peformance in model selection and parameter estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  assessBsFun(hB, B0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assessBsFun_+3A_hb">hB</code></td>
<td>
<p>a <code>p</code>-by-<code>q</code> matrix, the estimated loading matrix.</p>
</td></tr>
<tr><td><code id="assessBsFun_+3A_b0">B0</code></td>
<td>
<p>a <code>p</code>-by-<code>q</code> matrix, the true loading matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a vecotor with three compoents whose names are scr,fmea, ccorB.
</p>


<h3>Note</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Liu Wei
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ccorFun">ccorFun</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  dat &lt;- gendata_Fac(n = 300, p = 500)
  res &lt;- gsspFactorm(dat$X)
  assessBsFun(res$sphB, dat$B0)
  n &lt;- nrow(dat$X)
  res &lt;- gsspFactorm(dat$X, lambda1=0.05*n^(1/4), lambda2=9*n^(1/4))
  assessBsFun(res$sphB, dat$B0)
</code></pre>

<hr>
<h2 id='bic.spfac'>Modified BIC criteria for selecting penalty parameters</h2><span id='topic+bic.spfac'></span>

<h3>Description</h3>

<p>Evalute the BIC values on a set of grids of penalty parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  bic.spfac(X, c1.max= 10, nlamb1=10, C10=4, c2.max=10, nlamb2=10, C20=4)
  </code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bic.spfac_+3A_x">X</code></td>
<td>
<p>a <code>n</code>-by-<code>p</code> matrix, the observed data</p>
</td></tr>
<tr><td><code id="bic.spfac_+3A_c1.max">c1.max</code></td>
<td>
<p>a positve scalar, the maximum of the grids of c1.</p>
</td></tr>
<tr><td><code id="bic.spfac_+3A_nlamb1">nlamb1</code></td>
<td>
<p>a positive integer, the length of grids of penalty parameter lambda1.</p>
</td></tr>
<tr><td><code id="bic.spfac_+3A_c10">C10</code></td>
<td>
<p>a positve scalar, the penalty factor C1 of modified BIC.</p>
</td></tr>
<tr><td><code id="bic.spfac_+3A_c2.max">c2.max</code></td>
<td>
<p>a positve scalar, the maximum of the grids of c2.</p>
</td></tr>
<tr><td><code id="bic.spfac_+3A_nlamb2">nlamb2</code></td>
<td>
<p>a positive integer, the length of grids of penalty parameter lambda2.</p>
</td></tr>
<tr><td><code id="bic.spfac_+3A_c20">C20</code></td>
<td>
<p>a positve scalar, the penalty factor C2 of modified BIC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a list with class named <code>pena_info</code> and <code>BIC</code>, including following components:
</p>
<table role = "presentation">
<tr><td><code>lambda1.min</code></td>
<td>
<p>a positive number, the penalty value for lambda1 corresponding to the minimum BIC on grids.</p>
</td></tr>
<tr><td><code>lambda2.min</code></td>
<td>
<p>a positive number, the penalty value for lambda2 corresponding to the minimum BIC on grids.</p>
</td></tr>
<tr><td><code>bic1</code></td>
<td>
<p>a numeric matrix with three columns named c1, lambda1 and bic1, where each row is corresponding to each grid.</p>
</td></tr>
<tr><td><code>bic2</code></td>
<td>
<p>a numeric matrix with three columns named c2, lambda2 and bic2, where each row is corresponding to each grid.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Liu Wei
</p>


<h3>References</h3>

<p>Wei Liu, Huazhen Lin, Jin Liu (2020). Estimation and inference on high-dimensional sparse factor models.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsspFactorm">gsspFactorm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  datlist1 &lt;- gendata_Fac(n= 100, p = 500)
  X &lt;- datlist1$X
  spfac &lt;- gsspFactorm(X, q=NULL) # use default values for lambda's.
  assessBsFun(spfac$sphB, datlist1$B0)

  biclist &lt;- bic.spfac(datlist1$X, c2.max=20,nlamb1 = 10) # # select lambda's values using BIC.
</code></pre>

<hr>
<h2 id='ccorFun'>Evaluate the smallest canonical correlation for two set of variables</h2><span id='topic+ccorFun'></span>

<h3>Description</h3>

<p>Evaluate the smallest canonical correlation for two set of variables, each set of variables is represented by a matrix whose columns are variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ccorFun(hH, H)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ccorFun_+3A_hh">hH</code></td>
<td>
<p>a <code>n</code>-by-<code>q</code> matrix, one set of q variables.</p>
</td></tr>
<tr><td><code id="ccorFun_+3A_h">H</code></td>
<td>
<p>a <code>n</code>-by-<code>q</code> matrix, the other set of q variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a scalar value, the smallest canonical correlation.
</p>


<h3>Note</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Liu Wei
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cancor">cancor</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  dat &lt;- gendata_Fac(n = 300, p = 500)
  res &lt;- gsspFactorm(dat$X)
  ccorFun(res$hH, dat$H0)
</code></pre>

<hr>
<h2 id='cv.spfac'>Cross validation for selecting penalty parameters</h2><span id='topic+cv.spfac'></span>

<h3>Description</h3>

<p>Evalute the CV values on a set of grids of penalty parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  cv.spfac(X, lambda1_set, lambda2_set, nfolds=5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.spfac_+3A_x">X</code></td>
<td>
<p>a <code>n</code>-by-<code>p</code> matrix, the observed data</p>
</td></tr>
<tr><td><code id="cv.spfac_+3A_lambda1_set">lambda1_set</code></td>
<td>
<p>a positve vector, the grid for lambda_1.</p>
</td></tr>
<tr><td><code id="cv.spfac_+3A_lambda2_set">lambda2_set</code></td>
<td>
<p>a positve vector, the grid for lambda_2.</p>
</td></tr>
<tr><td><code id="cv.spfac_+3A_nfolds">nfolds</code></td>
<td>
<p>a positve integer, the folds of cross validation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a list including following components:
</p>
<table role = "presentation">
<tr><td><code>lamcv.min</code></td>
<td>
<p>a 3-dimensional vector, the penalty value for lambda_1 and lambda_2 corresponding to the minimum CV on grids.</p>
</td></tr>
<tr><td><code>lamcvMat</code></td>
<td>
<p>a numeric matrix with three columns named lambda_1, lambda_2 and cv, where each row is corresponding to each grid.</p>
</td></tr>
<tr><td><code>lambda1_set</code></td>
<td>
<p>the used grid for lambda_1.</p>
</td></tr>
<tr><td><code>lambda2_set</code></td>
<td>
<p>the used grid for lambda_2.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Liu Wei
</p>


<h3>References</h3>

<p>Wei Liu, Huazhen Lin, (2019). Estimation and inference on high-dimensional sparse factor models.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsspFactorm">gsspFactorm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  datlist1 &lt;- gendata_Fac(n= 100, p = 300, rho=1)
  X &lt;- datlist1$X
  spfac &lt;- gsspFactorm(X, q=NULL)  # use default values for lambda's.
  assessBsFun(spfac$sphB, datlist1$B0)
  lambda1_set &lt;- seq(0.2, 2, by=0.3)
  lambda2_set &lt;- 1:8
  # select lambda's values using CV method.
  lamList &lt;- cv.spfac(X, lambda1_set, lambda2_set, nfolds=5)
  spfac &lt;- gsspFactorm(X, q=NULL,lamList$lamcv.min[1], lamList$lamcv.min[2])
  assessBsFun(spfac$sphB, datlist1$B0)

</code></pre>

<hr>
<h2 id='FacRowMaxST'>Data splitting-based two-stage maximum testing method for a group of loading vectors in factor models.</h2><span id='topic+FacRowMaxST'></span>

<h3>Description</h3>

<p>Conduct the simultaneous inference for a set of loading vectors in the NUll hypothesises H01 that assumes the set of loading vectors are all zeroes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  FacRowMaxST(X, G1, q=NULL, Nsplit= 5, sub.frac=0.5,
              alpha=0.05, standardized=FALSE,seed=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FacRowMaxST_+3A_x">X</code></td>
<td>
<p>a <code>n</code>-by-<code>p</code> matrix, the observed data</p>
</td></tr>
<tr><td><code id="FacRowMaxST_+3A_g1">G1</code></td>
<td>
<p>a index set with values of components between 1 and p, the testing set in H01.</p>
</td></tr>
<tr><td><code id="FacRowMaxST_+3A_q">q</code></td>
<td>
<p>a positive integer, the number of factors. It will automatically selected by a criterion if it is NULL.</p>
</td></tr>
<tr><td><code id="FacRowMaxST_+3A_nsplit">Nsplit</code></td>
<td>
<p>a positive integer, the number of data spliting, default as 5.</p>
</td></tr>
<tr><td><code id="FacRowMaxST_+3A_sub.frac">sub.frac</code></td>
<td>
<p>a positive number between 0 and 1, the proportion of the sample used in stage I.</p>
</td></tr>
<tr><td><code id="FacRowMaxST_+3A_alpha">alpha</code></td>
<td>
<p>a positive real, the significance level.</p>
</td></tr>
<tr><td><code id="FacRowMaxST_+3A_standardized">standardized</code></td>
<td>
<p>a logical value, whether use the standardized test statistic.</p>
</td></tr>
<tr><td><code id="FacRowMaxST_+3A_seed">seed</code></td>
<td>
<p>a non-negative integer, the random seed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a vector with names 'CriticalValue', 'TestStatistic', 'reject_status', 'p-value' if Nsplit=1, and 'reject_status' and 'adjusted_p-value' if Nsplit&gt;1.
</p>


<h3>Note</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Liu Wei
</p>


<h3>References</h3>

<p>Wei Liu, Huazhen Lin, Jin Liu (2020). Estimation and inference on high-dimensional sparse factor models.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Factorm">Factorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ### Example
  dat &lt;- gendata_Fac(n = 300, p = 500)
  res &lt;- Factorm(dat$X)
  X &lt;- dat$X
  # ex1: H01 is false
  G1 &lt;- 1:10; # all are nonzero loading vectors
  FacRowMaxST(X, G1=G1, alpha=0.05, sub.frac=0.5)
  FacRowMaxST(X, q= 6, G1=G1, alpha=0.05, sub.frac=0.5) # specify the true number of factors
  # ex2: H01 is true
  G1 &lt;- 481:500 # all are zero loading vectors
  FacRowMaxST(X, G1=G1, alpha=0.05, sub.frac=0.5)
  FacRowMaxST(X, q= 7, G1=G1, alpha=0.05, sub.frac=0.5) # specify a false number of factors
</code></pre>

<hr>
<h2 id='FacRowMinST'>Data splitting-based two-stage minimum testing method for a group of loading vectors in factor models.</h2><span id='topic+FacRowMinST'></span>

<h3>Description</h3>

<p>Conduct the simultaneous inference for a set of loading vectors inr the NUll hypothesises H02 that assumes there is zero loading vector in the set of loading vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  FacRowMinST(X, G2,  q=NULL, Nsplit= 5, sub.frac=0.5,
              alpha=0.05, standardized=FALSE,seed=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FacRowMinST_+3A_x">X</code></td>
<td>
<p>a <code>n</code>-by-<code>p</code> matrix, the observed data</p>
</td></tr>
<tr><td><code id="FacRowMinST_+3A_g2">G2</code></td>
<td>
<p>a positive vector with values between 1 and p, the set of H02.</p>
</td></tr>
<tr><td><code id="FacRowMinST_+3A_q">q</code></td>
<td>
<p>a positive integer, the number of factors. It will automatically selected by a criterion if it is NULL.</p>
</td></tr>
<tr><td><code id="FacRowMinST_+3A_nsplit">Nsplit</code></td>
<td>
<p>a positive integer, the number of data spliting, default as 5.</p>
</td></tr>
<tr><td><code id="FacRowMinST_+3A_sub.frac">sub.frac</code></td>
<td>
<p>a positive number between 0 and 1, the proportion of the sample used in stage I.</p>
</td></tr>
<tr><td><code id="FacRowMinST_+3A_alpha">alpha</code></td>
<td>
<p>a positive real, the significance level.</p>
</td></tr>
<tr><td><code id="FacRowMinST_+3A_standardized">standardized</code></td>
<td>
<p>a logical value, whether use the standardized test statistic.</p>
</td></tr>
<tr><td><code id="FacRowMinST_+3A_seed">seed</code></td>
<td>
<p>a non-negative integer, the random seed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a vector with names 'CriticalValue', 'TestStatistic', 'reject_status', 'p-value' if Nsplit=1, and 'reject_status' and 'adjusted_p-value' if Nsplit&gt;1.
</p>


<h3>Note</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Liu Wei
</p>


<h3>References</h3>

<p>Wei Liu, Huazhen Lin, Jin Liu (2020). Estimation and inference on high-dimensional sparse factor models.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Factorm">Factorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ### Example
  dat &lt;- gendata_Fac(n = 300, p = 500)
  res &lt;- Factorm(dat$X)
  X &lt;- dat$X
  # ex1: H01 is false
  G2 &lt;- 1:200; # all are nonzero loading vectors
  FacRowMinST(X, G2=G2, alpha=0.05, sub.frac=0.5)
  FacRowMinST(X, q= 6, G2=G2, alpha=0.05, sub.frac=0.5) # specify the true number of factors
  # ex2: H01 is true
  G2 &lt;- 1:500 # all are zero loading vectors
  FacRowMinST(X, G2=G2, alpha=0.05, sub.frac=0.5)
  FacRowMinST(X, q= 7, G2=G2, alpha=0.05, sub.frac=0.5) # specify a false number of factors
</code></pre>

<hr>
<h2 id='Factorm'>Factor Analysis Model</h2><span id='topic+Factorm'></span>

<h3>Description</h3>

<p>Factor analysis to extract latent linear factor and estimate loadings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Factorm(X, q=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Factorm_+3A_x">X</code></td>
<td>
<p>a <code>n</code>-by-<code>p</code> matrix, the observed data</p>
</td></tr>
<tr><td><code id="Factorm_+3A_q">q</code></td>
<td>
<p>an integer between 1 and <code>p</code> or <code>NULL</code>, default as <code>NULL</code> and automatically choose q by the eigenvalue ratio method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a list with class named <code>fac</code>, including following components:
</p>
<table role = "presentation">
<tr><td><code>hH</code></td>
<td>
<p>a <code>n</code>-by-<code>q</code> matrix, the extracted lantent factor matrix.</p>
</td></tr>
<tr><td><code>hB</code></td>
<td>
<p>a <code>p</code>-by-<code>q</code> matrix, the estimated loading matrix.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>an integer between 1 and <code>p</code>, the number of factor extracted.</p>
</td></tr>
<tr><td><code>sigma2vec</code></td>
<td>
<p>a p-dimensional vector, the estimated variance for each error term in model.</p>
</td></tr>
<tr><td><code>propvar</code></td>
<td>
<p>a positive number between 0 and 1, the explained propotion of cummulative variance by the <code>q</code> factors.</p>
</td></tr>
<tr><td><code>egvalues</code></td>
<td>
<p>a n-dimensional(n&lt;=p) or p-dimensional(p&lt;n) vector, the eigenvalues of sample covariance matrix.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Liu Wei
</p>


<h3>References</h3>

<p>Fan, J., Xue, L., and Yao, J. (2017). Sufficient forecasting using factor models. Journal of Econometrics.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+factor">factor</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  dat &lt;- gendata_Fac(n = 300, p = 500)
  res &lt;- Factorm(dat$X)
  ccorFun(res$hH, dat$H0) # the smallest canonical correlation
</code></pre>

<hr>
<h2 id='gendata_Fac'>Generate simulated data</h2><span id='topic+gendata_Fac'></span>

<h3>Description</h3>

<p>Generate simulated data from high dimensional sparse factor model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  gendata_Fac(n, p, seed=1, q=6, pzero= floor(p/4),
              sigma2=0.1, gamma=1, heter=FALSE, rho=1)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gendata_Fac_+3A_n">n</code></td>
<td>
<p>a positive integer, the sample size.</p>
</td></tr>
<tr><td><code id="gendata_Fac_+3A_p">p</code></td>
<td>
<p>an positive integer, the variable dimension.</p>
</td></tr>
<tr><td><code id="gendata_Fac_+3A_seed">seed</code></td>
<td>
<p>a nonnegative integer, the random seed, default as 1.</p>
</td></tr>
<tr><td><code id="gendata_Fac_+3A_q">q</code></td>
<td>
<p>a positive integer, the number of factors.</p>
</td></tr>
<tr><td><code id="gendata_Fac_+3A_pzero">pzero</code></td>
<td>
<p>a positive integer, the number of zero loading vectors, default as p/4.</p>
</td></tr>
<tr><td><code id="gendata_Fac_+3A_sigma2">sigma2</code></td>
<td>
<p>a positive real number, the homogenous variance of error term.</p>
</td></tr>
<tr><td><code id="gendata_Fac_+3A_gamma">gamma</code></td>
<td>
<p>a positive number, the common component of heteroscedasticity of error term.</p>
</td></tr>
<tr><td><code id="gendata_Fac_+3A_heter">heter</code></td>
<td>
<p>a logical value, indicates whether generate heteroscendastic error term.</p>
</td></tr>
<tr><td><code id="gendata_Fac_+3A_rho">rho</code></td>
<td>
<p>a positive number, controlling the magnitude of loading matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a list including two components:
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p>a <code>n</code>-by-<code>p</code> matrix, the observed data matrix.</p>
</td></tr>
<tr><td><code>H0</code></td>
<td>
<p>a <code>n</code>-by-<code>q</code> matrix, the true lantent factor matrix.</p>
</td></tr>
<tr><td><code>B0</code></td>
<td>
<p>a <code>p</code>-by-<code>q</code> matrix, the true loading matrix, the last pzero rows are vectors of zeros.</p>
</td></tr>
<tr><td><code>ind_nz</code></td>
<td>
<p>a integer vector, the index vector for which rows of <code>B0</code> not zeros.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Liu Wei
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Factorm">Factorm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  dat &lt;- gendata_Fac(n=300, p = 500)
  str(dat)
</code></pre>

<hr>
<h2 id='gendata_Mean'>Generate simulated data</h2><span id='topic+gendata_Mean'></span>

<h3>Description</h3>

<p>Generate simulated data from  for high-dimensional mean model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  gendata_Mean(n, p, s0= floor(p/2), seed=1, rho= 1, tau=1)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gendata_Mean_+3A_n">n</code></td>
<td>
<p>a positive integer, the sample size.</p>
</td></tr>
<tr><td><code id="gendata_Mean_+3A_p">p</code></td>
<td>
<p>an positive integer, the variable dimension.</p>
</td></tr>
<tr><td><code id="gendata_Mean_+3A_s0">s0</code></td>
<td>
<p>a positive integer, the number of nonzero components of mean .</p>
</td></tr>
<tr><td><code id="gendata_Mean_+3A_seed">seed</code></td>
<td>
<p>a nonnegative integer, the random seed, default as 1.</p>
</td></tr>
<tr><td><code id="gendata_Mean_+3A_rho">rho</code></td>
<td>
<p>a positive number between 0 and 1, controlling the correlation of data.</p>
</td></tr>
<tr><td><code id="gendata_Mean_+3A_tau">tau</code></td>
<td>
<p>a positive number, controlling the magnitude of covriance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a list including two components:
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p>a <code>n</code>-by-<code>p</code> matrix, the observed data matrix.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>a p-dimensional vector, the mean vector.</p>
</td></tr>
<tr><td><code>p0</code></td>
<td>
<p>a integer vector, the number of nonzero components of mean.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Liu Wei
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  dat &lt;- gendata_Mean(n=100, p = 100, s0=3)
  str(dat)
</code></pre>

<hr>
<h2 id='gendata_Reg'>Generate simulated data</h2><span id='topic+gendata_Reg'></span>

<h3>Description</h3>

<p>Generate simulated data from  high-dimensional sparse regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  gendata_Reg(n=100, p = 20, s0=5, rho=1, seed=1)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gendata_Reg_+3A_n">n</code></td>
<td>
<p>a positive integer, the sample size, default as 100.</p>
</td></tr>
<tr><td><code id="gendata_Reg_+3A_p">p</code></td>
<td>
<p>an positive integer, the dimension of covriates, default as 20.</p>
</td></tr>
<tr><td><code id="gendata_Reg_+3A_s0">s0</code></td>
<td>
<p>a positive integer, the number of nonzero components of regression coefficients, default as 5.</p>
</td></tr>
<tr><td><code id="gendata_Reg_+3A_rho">rho</code></td>
<td>
<p>a positive number, controlling the magnitude of coefficients.</p>
</td></tr>
<tr><td><code id="gendata_Reg_+3A_seed">seed</code></td>
<td>
<p>a nonnegative integer, the random seed, default as 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a list including two components:
</p>
<table role = "presentation">
<tr><td><code>Y</code></td>
<td>
<p>a <code>n</code>-dimensional vector, the observed response vector.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>a <code>n</code>-by-<code>p</code> matrix, the observed covariates matrix.</p>
</td></tr>
<tr><td><code>beta0</code></td>
<td>
<p>a p-dimensional vector, the Reg. coefficients.</p>
</td></tr>
<tr><td><code>index_nz</code></td>
<td>
<p>a integer vector, the index of nonzero components of Reg. coefficients.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Liu Wei
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  dat &lt;- gendata_Reg(n=100, p = 100, s0=3)
  str(dat)
</code></pre>

<hr>
<h2 id='gsspFactorm'>High Dimensional Sparse  Factor Model</h2><span id='topic+gsspFactorm'></span>

<h3>Description</h3>

<p>sparse factor analysis to extract latent linear factor and estimate row-sparse and entry-wise-sparse loading matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  gsspFactorm(X, q=NULL, lambda1=nrow(X)^(1/4), lambda2=nrow(X)^(1/4))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gsspFactorm_+3A_x">X</code></td>
<td>
<p>a <code>n</code>-by-<code>p</code> matrix, the observed data</p>
</td></tr>
<tr><td><code id="gsspFactorm_+3A_q">q</code></td>
<td>
<p>an integer between 1 and <code>p</code> or <code>NULL</code>, default as <code>NULL</code> and automatically choose q by the eigenvalue ratio method.</p>
</td></tr>
<tr><td><code id="gsspFactorm_+3A_lambda1">lambda1</code></td>
<td>
<p>a non-negative number, the row-sparse penalty parameter, default as <code>n</code>^(1/4).</p>
</td></tr>
<tr><td><code id="gsspFactorm_+3A_lambda2">lambda2</code></td>
<td>
<p>a non-negative number, the entry-sparse penalty parameter, default as <code>n</code>^(1/4).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a list with class named <code>fac</code>, including following components:
</p>
<table role = "presentation">
<tr><td><code>hH</code></td>
<td>
<p>a <code>n</code>-by-<code>q</code> matrix, the extracted lantent factor matrix.</p>
</td></tr>
<tr><td><code>sphB</code></td>
<td>
<p>a <code>p</code>-by-<code>q</code> matrix, the estimated row-sparseloading matrix.</p>
</td></tr>
<tr><td><code>hB</code></td>
<td>
<p>a <code>p</code>-by-<code>q</code> matrix, the estimated loading matrix without penalty.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>an integer between 1 and <code>p</code>, the number of factor extracted.</p>
</td></tr>
<tr><td><code>propvar</code></td>
<td>
<p>a positive number between 0 and 1, the explained propotion of cummulative variance by the <code>q</code> factors.</p>
</td></tr>
<tr><td><code>egvalues</code></td>
<td>
<p>a n-dimensional(n&lt;=p) or p-dimensional(p&lt;n) vector, the eigenvalues of sample covariance matrix.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Liu Wei
</p>


<h3>References</h3>

<p>Liu, W., Lin, H., Liu, J., &amp; Zheng, S. (2020). Two-directional simultaneous inference for high-dimensional models. arXiv preprint arXiv:2012.11100.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+factor">factor</a></code>, <code><a href="#topic+Factorm">Factorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  dat &lt;- gendata_Fac(n = 300, p = 500)
  res &lt;- gsspFactorm(dat$X)
  ccorFun(res$hH, dat$H0) # the smallest canonical correlation
  ## comparison of l2 norm
  oldpar &lt;- par(mar = c(5, 5, 2, 2), mfrow = c(1, 2))
  plot(rowSums(dat$B0^2), type='o', ylab='l2B', main='True')
  l2B &lt;- rowSums(res$sphB^2)
  plot(l2B, type='o', main='Est.')

  Bind &lt;- ifelse(dat$B0==0, 0, 1)
  hBind &lt;- ifelse(res$sphB==0, 0, 1)

  ## Select good penalty parameters
  dat &lt;- gendata_Fac(n = 300, p = 200)
  res &lt;- gsspFactorm(dat$X, lambda1=0.04*nrow(dat$X)^(1/4) ,lambda2=1*nrow(dat$X)^(1/4))
  ccorFun(res$hH, dat$H0) # the smallest canonical correlation

  ## comparison of l2 norm
  plot(rowSums(dat$B0^2), type='o', ylab='l2B', main='True')
  l2B &lt;- rowSums(res$sphB^2)
  plot(l2B, type='o', main='Est.')

  ## comparison of structure of loading matrix
  Bind &lt;- ifelse(dat$B0==0, 0, 1)
  hBind &lt;- ifelse(res$sphB==0, 0, 1)
  par(oldpar)


</code></pre>

<hr>
<h2 id='MeanMax'>Data splitting-based two-stage maximum mean testing method for the mean vector.</h2><span id='topic+MeanMax'></span>

<h3>Description</h3>

<p>Conduct the simultaneous inference for a set of mean components in the NUll hypothesises H01 that assumes the set of mean components are all zeroes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  MeanMax(X, test.set, Nsplit = 5,frac.size=0.5, standardized=FALSE,alpha=0.05, seed=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MeanMax_+3A_x">X</code></td>
<td>
<p>a <code>n</code>-by-<code>p</code> matrix, the observed data</p>
</td></tr>
<tr><td><code id="MeanMax_+3A_test.set">test.set</code></td>
<td>
<p>a positive vector with values between 1 and p, the set of H01.</p>
</td></tr>
<tr><td><code id="MeanMax_+3A_nsplit">Nsplit</code></td>
<td>
<p>a positive integer, the random split times used, default as 5.</p>
</td></tr>
<tr><td><code id="MeanMax_+3A_frac.size">frac.size</code></td>
<td>
<p>a positive real between 0 and 1, the proportion of the sample used in stage I.</p>
</td></tr>
<tr><td><code id="MeanMax_+3A_standardized">standardized</code></td>
<td>
<p>a logical value, whether standerdize variables in stage I.</p>
</td></tr>
<tr><td><code id="MeanMax_+3A_alpha">alpha</code></td>
<td>
<p>a positive real, the significant level.</p>
</td></tr>
<tr><td><code id="MeanMax_+3A_seed">seed</code></td>
<td>
<p>a non-negative integer, the random seed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a vector with names 'CriticalValue', 'TestStatistic', 'reject_status', 'p-value' if Nsplit=1, and 'reject_status' and 'adjusted_p-value' if Nsplit&gt;1.
</p>


<h3>Note</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Liu Wei
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gendata_Mean">gendata_Mean</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ### Example
  n &lt;- 100; p &lt;- 100;i &lt;- 1
  s0 &lt;- 5 # First five components are nonzeros
  rho &lt;- 1; tau &lt;- 1;
  dat1 &lt;- gendata_Mean(n, p, s0, seed=i, rho, tau)
  # ex1: H01 is false
  MeanMax(dat1$X, 1:p)
  MeanMax(dat1$X, 1:p, Nsplit=1)
  # ex1: H01 is true
  MeanMax(dat1$X, p)
  MeanMax(dat1$X, p, Nsplit=1)
</code></pre>

<hr>
<h2 id='MeanMin'>Data splitting-based two-stage minimum mean testing method for the mean vector.</h2><span id='topic+MeanMin'></span>

<h3>Description</h3>

<p>Conduct the simultaneous inference for a set of mean components in the the Null hypothesises H02 that assumes the set of mean components exist zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  MeanMin(X, test.set, Nsplit = 5, frac.size=0.5, standardized=FALSE, alpha=0.05, seed=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MeanMin_+3A_x">X</code></td>
<td>
<p>a <code>n</code>-by-<code>p</code> matrix, the observed data</p>
</td></tr>
<tr><td><code id="MeanMin_+3A_test.set">test.set</code></td>
<td>
<p>a positive vector with values between 1 and p, the set of H02.</p>
</td></tr>
<tr><td><code id="MeanMin_+3A_nsplit">Nsplit</code></td>
<td>
<p>a positive integer, the random split times used, default as 5.</p>
</td></tr>
<tr><td><code id="MeanMin_+3A_frac.size">frac.size</code></td>
<td>
<p>a positive number between 0 and 1, the proportion of the sample used in stage I.</p>
</td></tr>
<tr><td><code id="MeanMin_+3A_standardized">standardized</code></td>
<td>
<p>a logical value, whether standerdize in stage I.</p>
</td></tr>
<tr><td><code id="MeanMin_+3A_alpha">alpha</code></td>
<td>
<p>a positive number, the significant level.</p>
</td></tr>
<tr><td><code id="MeanMin_+3A_seed">seed</code></td>
<td>
<p>a non-negative integer, the random seed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a vector with names 'CriticalValue', 'TestStatistic', 'reject_status', 'p-value' if Nsplit=1, and 'reject_status' and 'adjusted_p-value' if Nsplit&gt;1.
</p>


<h3>Note</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Liu Wei
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gendata_Mean">gendata_Mean</a></code>, <code><a href="#topic+MeanMin">MeanMin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ### Example
  n &lt;- 100; p &lt;- 100; i &lt;- 1
  s0 &lt;- 5 # First five components are nonzeros
  rho &lt;- 4; tau &lt;- 1;
  dat1 &lt;- gendata_Mean(n, p, s0, seed=i, rho, tau)
  # ex1: H01 is false
  MeanMin(dat1$X, 1:s0)
  MeanMin(dat1$X, 1:s0, Nsplit=1)
  # ex1: H01 is true
  MeanMin(dat1$X, 1:p)
  MeanMin(dat1$X, 1:p, Nsplit=1)
</code></pre>

<hr>
<h2 id='RegMax'>Data splitting-based two-stage maximum testing method for the regression coefficients in linear regression models</h2><span id='topic+RegMax'></span>

<h3>Description</h3>

<p>Conduct the simultaneous inference for a set of regression coefficients in the null hypothesises H01 that assume the set of regression coefficients components are all zeroes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  RegMax(X, Y,  G1, Nsplit = 5, sub.frac=0.5, alpha=0.05, seed=1,  standardized=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RegMax_+3A_x">X</code></td>
<td>
<p>a <code>n</code>-by-<code>p</code> matrix, the observed covariates matrix.</p>
</td></tr>
<tr><td><code id="RegMax_+3A_y">Y</code></td>
<td>
<p>a <code>n</code>-dimensional vector, the observed response vector.</p>
</td></tr>
<tr><td><code id="RegMax_+3A_g1">G1</code></td>
<td>
<p>a positive vector with values between 1 and p, the set of H01.</p>
</td></tr>
<tr><td><code id="RegMax_+3A_nsplit">Nsplit</code></td>
<td>
<p>a positive integer, the random split times used, default as 5.</p>
</td></tr>
<tr><td><code id="RegMax_+3A_sub.frac">sub.frac</code></td>
<td>
<p>a positive number between 0 and 1, the proportion of the sample used in the stage I.</p>
</td></tr>
<tr><td><code id="RegMax_+3A_alpha">alpha</code></td>
<td>
<p>a positive real, the significance level.</p>
</td></tr>
<tr><td><code id="RegMax_+3A_seed">seed</code></td>
<td>
<p>a non-negative integer, the random seed.</p>
</td></tr>
<tr><td><code id="RegMax_+3A_standardized">standardized</code></td>
<td>
<p>a logical value, whether standerdize the covariates matrix in the stage I.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a vector with names 'CriticalValue', 'TestStatistic', 'reject_status', 'p-value' if Nsplit=1, and 'reject_status' and 'adjusted_p-value' if Nsplit&gt;1.
</p>


<h3>Note</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Liu Wei
</p>


<h3>References</h3>

<p>Liu, W., Lin, H., Liu, J., &amp; Zheng, S. (2020). Two-directional simultaneous inference for high-dimensional models. arXiv preprint arXiv:2012.11100.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gendata_Reg">gendata_Reg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
    ### Example
    n &lt;- 50; p &lt;- 20; i &lt;- 1
    s0 &lt;- 5 # First five components are nonzeros
    rho &lt;- 1;
    dat1 &lt;- gendata_Reg(n, p, s0, seed=i, rho)
    # ex1: H01 is false
    RegMax(dat1$X, dat1$Y, 1:p)
    # ex1: H01 is true
    RegMax(dat1$X, dat1$Y, p)
  
</code></pre>

<hr>
<h2 id='RegMin'>Data splitting-based two-Stage minimum testing method for the regression coefficients in linear regression models.</h2><span id='topic+RegMin'></span>

<h3>Description</h3>

<p>Conduct the simultaneous inference for a set of regression coefficients in a null hypothesises H02 that assumes the set of regression coefficients components exist zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  RegMin(X, Y,  G2, Nsplit = 5, sub.frac=0.5, alpha=0.05, seed=1,  standardized=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RegMin_+3A_x">X</code></td>
<td>
<p>a <code>n</code>-by-<code>p</code> matrix, the observed covariates matrix.</p>
</td></tr>
<tr><td><code id="RegMin_+3A_y">Y</code></td>
<td>
<p>a <code>n</code>-dimensional vector, the observed outcome vector.</p>
</td></tr>
<tr><td><code id="RegMin_+3A_g2">G2</code></td>
<td>
<p>a positive vector with values between 1 and p, the set of regression coefficients in the null hypothesises H02.</p>
</td></tr>
<tr><td><code id="RegMin_+3A_nsplit">Nsplit</code></td>
<td>
<p>a positive integer, the random split times used, default as 5.</p>
</td></tr>
<tr><td><code id="RegMin_+3A_sub.frac">sub.frac</code></td>
<td>
<p>a positive number between 0 and 1, the proportion of the sample used in the stage I.</p>
</td></tr>
<tr><td><code id="RegMin_+3A_alpha">alpha</code></td>
<td>
<p>a positive real, the significance level.</p>
</td></tr>
<tr><td><code id="RegMin_+3A_seed">seed</code></td>
<td>
<p>a non-negative integer, the random seed.</p>
</td></tr>
<tr><td><code id="RegMin_+3A_standardized">standardized</code></td>
<td>
<p>a logical value, whether standerdize the covariates matrix in the stage I.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a vector with names 'CriticalValue', 'TestStatistic', 'reject_status', 'p-value' if Nsplit=1, and 'reject_status' and 'adjusted_p-value' if Nsplit&gt;1.
</p>


<h3>Note</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Liu Wei
</p>


<h3>References</h3>

<p>Liu, W., Lin, H., Liu, J., &amp; Zheng, S. (2020). Two-directional simultaneous inference for high-dimensional models. arXiv preprint arXiv:2012.11100.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gendata_Reg">gendata_Reg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  ### Example
  n &lt;- 100; p &lt;- 20;i &lt;- 1
  s0 &lt;- 5 # First five components are nonzeros
  rho &lt;- 1;
  dat1 &lt;- gendata_Reg(n, p, s0, seed=i, rho)
  # ex1: H01 is false
  RegMin(dat1$X, dat1$Y, 1:s0)
  # ex1: H01 is true
  RegMin(dat1$X, dat1$Y, p)
  
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
