<!DOCTYPE html><html lang="en"><head><title>Help for package goldfish</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {goldfish}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#goldfish-package'><p>goldfish package</p></a></li>
<li><a href='#defineDependentEvents'><p>Define dependent events for a model</p></a></li>
<li><a href='#defineGlobalAttribute'><p>Define a global time-varying attribute</p></a></li>
<li><a href='#defineGroups_interaction'><p>To define the second mode of a DyNAM-i model</p></a></li>
<li><a href='#defineNetwork'><p>Defining a network with dynamic events</p></a></li>
<li><a href='#defineNodes'><p>Defining a node set with (dynamic) node attributes.</p></a></li>
<li><a href='#estimate'><p>Estimate a model</p></a></li>
<li><a href='#examine'><p>Diagnostic functions</p></a></li>
<li><a href='#Fisheries_Treaties_6070'><p>International bilateral fisheries treaties (1960-1970)</p></a></li>
<li><a href='#GatherPreprocessing'><p>Gather preprocess data from a formula</p></a></li>
<li><a href='#linkEvents'><p>Link dynamic events to a nodeset or a network</p></a></li>
<li><a href='#logLik.result.goldfish'><p>Extract log-likelihood from a fitted model object</p></a></li>
<li><a href='#print-method'><p>Methods for <code>goldfish</code> objects.</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#RFID_Validity_Study'><p>RFID Validity dataset</p></a></li>
<li><a href='#Social_Evolution'><p>Social evolution of a university dormitory cohort</p></a></li>
<li><a href='#update-method'><p>Methods to update a nodes or network object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Network Models for Dynamic Network Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.10</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-03</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for fitting statistical network models to dynamic network data.
   Can be used for fitting both dynamic network actor models ('DyNAMs') and
   relational event models ('REMs').
   Stadtfeld, Hollway, and Block (2017a) &lt;<a href="https://doi.org/10.1177%2F0081175017709295">doi:10.1177/0081175017709295</a>&gt;,
   Stadtfeld, Hollway, and Block (2017b) &lt;<a href="https://doi.org/10.1177%2F0081175017733457">doi:10.1177/0081175017733457</a>&gt;,
   Stadtfeld and Block (2017) &lt;<a href="https://doi.org/10.15195%2Fv4.a14">doi:10.15195/v4.a14</a>&gt;,
   Hoffman et al. (2020) &lt;<a href="https://doi.org/10.1017%2Fnws.2020.3">doi:10.1017/nws.2020.3</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://stocnet.github.io/goldfish/">https://stocnet.github.io/goldfish/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stocnet/goldfish/issues/">https://github.com/stocnet/goldfish/issues/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.1), changepoint, methods, utils, stats, generics,
ggplot2, rlang, tibble</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, devtools, covr, rmarkdown, pixiedust,
igraph, ggraph, migraph, manynet, patchwork, broom, lmtest</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-03 09:09:08 UTC; ualvaro</td>
</tr>
<tr>
<td>Author:</td>
<td>James Hollway <a href="https://orcid.org/0000-0002-8361-9647"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, dtc] (IHEID),
  Christoph Stadtfeld [aut, dtc],
  Marion Hoffman [aut],
  Alvaro Uzaheta <a href="https://orcid.org/0000-0003-4367-3670"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Mirko Reul [ctb],
  Timon Elmer [ctb],
  Kieran Mepham [ctb],
  Per Block [ctb],
  Xiaolei Zhang [ctb],
  Weigutian Ou [ctb],
  Emily Garvin [ctb],
  Siwei Zhang [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alvaro Uzaheta &lt;ualvaro@ethz.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-03 10:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='goldfish-package'>goldfish package</h2><span id='topic+goldfish'></span><span id='topic+goldfish-package'></span>

<h3>Description</h3>

<p>The goldfish Project is an R package that allows
to fit statistical network models
(such as DyNAM and REM) to dynamic network data.
</p>


<h3>Details</h3>

<p>The <a href="https://sn.ethz.ch/research/goldfish.html">goldfish</a>
package in R allows the study of time-stamped network data
using a variety of models.
In particular, it implements different types of
Dynamic Network Actor Models (DyNAMs),
a class of models that is tailored to the study of
actor-oriented network processess through time.
Goldfish also implements different versions of
the tie-oriented Relational Event Model by Carter Butts.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Alvaro Uzaheta <a href="mailto:ualvaro@ethz.ch">ualvaro@ethz.ch</a> (<a href="https://orcid.org/0000-0003-4367-3670">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> James Hollway <a href="mailto:james.hollway@graduateinstitute.ch">james.hollway@graduateinstitute.ch</a> (<a href="https://orcid.org/0000-0002-8361-9647">ORCID</a>) (IHEID) [data contributor]
</p>
</li>
<li><p> Christoph Stadtfeld <a href="mailto:c.stadtfeld@ethz.ch">c.stadtfeld@ethz.ch</a> [data contributor]
</p>
</li>
<li><p> Marion Hoffman
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Mirko Reul [contributor]
</p>
</li>
<li><p> Timon Elmer [contributor]
</p>
</li>
<li><p> Kieran Mepham [contributor]
</p>
</li>
<li><p> Per Block [contributor]
</p>
</li>
<li><p> Xiaolei Zhang [contributor]
</p>
</li>
<li><p> Weigutian Ou [contributor]
</p>
</li>
<li><p> Emily Garvin [contributor]
</p>
</li>
<li><p> Siwei Zhang [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Stadtfeld, C. (2012). Events in Social Networks: A Stochastic
Actor-oriented Framework for Dynamic Event Processes in Social Networks.
<em>KIT Scientific Publishing</em>. <a href="https://doi.org/10.5445/KSP/1000025407">doi:10.5445/KSP/1000025407</a>
</p>
<p>Stadtfeld, C., and Block, P. (2017). Interactions, Actors, and Time:
Dynamic Network Actor Models for Relational Events.
<em>Sociological Science 4 (1)</em>, 318-52. <a href="https://doi.org/10.15195/v4.a14">doi:10.15195/v4.a14</a>
</p>
<p>Stadtfeld, C., Hollway, J., and Block, P. (2017).
Dynamic Network Actor Models: Investigating Coordination Ties Through Time.
<em>Sociological Methodology 47 (1)</em>. <a href="https://doi.org/10.1177/0081175017709295">doi:10.1177/0081175017709295</a>
</p>
<p>Hollway, J. (2020).
Network embeddedness and the rate
of international water cooperation and conflict.
In <em>Networks in Water Governance</em>,
edited by Manuel Fischer and Karin Ingold.
London: Palgrave, pp. 87-113.
</p>
<p>Hoffman, M., Block P., Elmer T., and Stadtfeld C. (2020).
A model for the dynamics of face-to-face interactions in social groups.
<em>Network Science</em>, 8(S1), S4-S25. <a href="https://doi.org/10.1017/nws.2020.3">doi:10.1017/nws.2020.3</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate()</a></code>
</p>

<hr>
<h2 id='defineDependentEvents'>Define dependent events for a model</h2><span id='topic+defineDependentEvents'></span>

<h3>Description</h3>

<p>The final step in defining the data objects is to identify
the dependent events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defineDependentEvents(
  events,
  nodes,
  nodes2 = NULL,
  defaultNetwork = NULL,
  envir = environment()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="defineDependentEvents_+3A_events">events</code></td>
<td>
<p>a data frame containing the event list that should be
considered as a dependent variable in models.</p>
</td></tr>
<tr><td><code id="defineDependentEvents_+3A_nodes">nodes</code></td>
<td>
<p>a data frame or a <code>nodes.goldfish</code> object containing the nodes
used in the event list.</p>
</td></tr>
<tr><td><code id="defineDependentEvents_+3A_nodes2">nodes2</code></td>
<td>
<p>a second nodeset in the case that the events occurs in a
two-mode network.</p>
</td></tr>
<tr><td><code id="defineDependentEvents_+3A_defaultnetwork">defaultNetwork</code></td>
<td>
<p>the name of a <code>network.goldfish</code> object.</p>
</td></tr>
<tr><td><code id="defineDependentEvents_+3A_envir">envir</code></td>
<td>
<p>An <a href="methods.html#topic+environment-class">environment</a> object where the nodes-set
and default network objects are defined. The default value is
<code><a href="base.html#topic+environment">environment()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before this step is performed, we have to define:
the nodeset (<code><a href="#topic+defineNodes">defineNodes()</a></code>), the network (<code><a href="#topic+defineNetwork">defineNetwork()</a></code>)
and the link the event list to the network (<code><a href="#topic+linkEvents">linkEvents()</a></code>).
</p>
<p>During the definition as a dependent event, some checks are done to ensure
consistency with the default network and the nodeset.
In particular, consistency of the labels of nodes in the events with the
nodes' labels in the network and the nodeset is done.
</p>
<p>It is possible to define as a dependent event a different set of events to
the ones link to the default network.
This is useful to model different type of events where the event dynamic is
driven by different effects or its weight differs.
<a href="#topic+Fisheries_Treaties_6070">Fisheries_Treaties_6070</a> has an example of it, the relational event modeled
are fisheries treaties between countries. The <code>bilatchanges</code> data frame
contains information of creation and dissolution of treaties.
<code>vignette(teaching2)</code> shows how to model just the creation of treaties
conditional on creation and dissolution.
</p>


<h3>Value</h3>

<p>an object with additional class <code>dependent.goldfish</code> with attributes:
</p>
<table role = "presentation">
<tr><td><code>nodes</code></td>
<td>
<p>a character vector with the names of the nodes set that define
the dimensions of the <code>defaultNetwork</code>. <code>nodes</code> and <code>nodes2</code> arguments.</p>
</td></tr>
<tr><td><code>defaultNetwork</code></td>
<td>
<p>A character value with the name of the network object
when this is present. <code>defaultNetwork</code> argument.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>A character value that can take values monadic or dyadic
depending on the arguments used during the definition.</p>
</td></tr>
</table>
<p>The object can be modified using methods for data frames.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+defineNodes">defineNodes()</a></code>, <code><a href="#topic+defineNetwork">defineNetwork()</a></code>, <code><a href="#topic+linkEvents">linkEvents()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actors &lt;- data.frame(
  actor = 1:5, label = paste("Actor", 1:5),
  present = TRUE, gender = sample.int(2, 5, replace = TRUE)
)
actors &lt;- defineNodes(nodes = actors)
calls &lt;- data.frame(
  time = c(12, 27, 45, 56, 66, 68, 87),
  sender = paste("Actor", c(1, 3, 5, 2, 3, 4, 2)),
  receiver = paste("Actor", c(4, 2, 3, 5, 1, 2, 5)), increment = rep(1, 7)
)
callNetwork &lt;- defineNetwork(nodes = actors)
callNetwork &lt;- linkEvents(
  x = callNetwork, changeEvent = calls, nodes = actors
)

# Defining the dependent events:
callDependent &lt;- defineDependentEvents(
  events = calls, nodes = actors, defaultNetwork = callNetwork
)
</code></pre>

<hr>
<h2 id='defineGlobalAttribute'>Define a global time-varying attribute</h2><span id='topic+defineGlobalAttribute'></span>

<h3>Description</h3>

<p>This function allows to define a global attribute of the nodeset
(i.e a variable that is identical for each node but changes over time).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defineGlobalAttribute(global)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="defineGlobalAttribute_+3A_global">global</code></td>
<td>
<p>a data frame containing all the values this global attribute
takes along time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For instance, seasonal climate changes could be defined as a
changing global attribute.
Then, this global attribute can be linked to the nodeset by using
<code><a href="#topic+linkEvents">linkEvents()</a></code>
</p>


<h3>Value</h3>

<p>an object of class <code>global.goldfish</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seasons &lt;- defineGlobalAttribute(data.frame(time = 1:12, replace = 1:12))
</code></pre>

<hr>
<h2 id='defineGroups_interaction'>To define the second mode of a DyNAM-i model</h2><span id='topic+defineGroups_interaction'></span>

<h3>Description</h3>

<p>This function create all objects necessary to the estimation of a DyNAM-i
model <code>model = "DyNAMi"</code> from dyadic interaction records and an actor set.
It first creates a nodeset for the second mode of the interaction network
that will be modeled, i.e. the interaction groups set,
and an event list that indicates when groups are present or not through time.
It then creates a list of interaction events, between actors and groups,
in which an actor either joins or leaves a group. It is decomposed in
an list of dependent events (that should be modeled) and a list of
exogenous events (that should not be modeled).
For example when an actor leaves a group and joins her own singleton group,
only the leaving event is modeled but not the joining one, and vice versa
when an actor belonging to a singleton group joins another group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defineGroups_interaction(
  records,
  actors,
  seed.randomization,
  progress = getOption("progress")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="defineGroups_interaction_+3A_records">records</code></td>
<td>
<p>an object of class <code>data.frame</code> that is a list of rows of type
node A, nodeB, Start, End, where nodeA and nodeB indicate the actors
involved in a dyadic interaction, and Start and End indicating the starting
and ending time of their interaction.</p>
</td></tr>
<tr><td><code id="defineGroups_interaction_+3A_actors">actors</code></td>
<td>
<p>a object of class <code>nodes.goldfish</code> that defines the actors
interacting (labels in records and actors should be identical).</p>
</td></tr>
<tr><td><code id="defineGroups_interaction_+3A_seed.randomization">seed.randomization</code></td>
<td>
<p>an <code>integer</code> used whenever there should
be some random choice to be made.</p>
</td></tr>
<tr><td><code id="defineGroups_interaction_+3A_progress">progress</code></td>
<td>
<p>logical weather detailed information of intermediate steps
should be printed in the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is important to notice that sometimes some random decisions have to
be made regarding who joined or left a group, for example when two actors
start interacting but we do not know who initiated the interaction.
Tot est for the robustness of such a procedure, one can use different
randomization seeds and run the model several times.
</p>


<h3>Value</h3>

<p>a <code>list</code> with the following data frames
</p>

<dl>
<dt>interaction.updates</dt><dd><p>containing all joining and leaving events</p>
</dd>
<dt>groups</dt><dd><p>containing the nodeset corresponding to interaction groups
(the second mode of the network)</p>
</dd>
<dt>dependent.events</dt><dd><p>for the events that should be modeled</p>
</dd>
<dt>exogenous.events</dt><dd><p>that are not modeled (for example when an actor
leaves a group and joins its own singleton group, only the leaving event
is modeled but not the joining event)</p>
</dd>
<dt>composition.changes</dt><dd><p>that is an events list that should be attached
to the groups nodeset to indicate when a group is present or not</p>
</dd>
</dl>


<hr>
<h2 id='defineNetwork'>Defining a network with dynamic events</h2><span id='topic+defineNetwork'></span>

<h3>Description</h3>

<p>The function defines a network object either from a nodeset or
from a matrix (sociomatrix or adjacency matrix). If a matrix is used as
input, <code>defineNetwork()</code> returns a network filled with the same values
as the ones present in the provided network.
If the nodeset is the only argument, <code>defineNetwork()</code> returns an
empty network with the number of columns and rows corresponding to the
size of the nodeset.
These networks are static, but they can be turned into dynamic networks
by linking dynamic events to the network objectw using <code><a href="#topic+linkEvents">linkEvents()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defineNetwork(
  matrix = NULL,
  nodes,
  nodes2 = NULL,
  directed = TRUE,
  envir = environment()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="defineNetwork_+3A_matrix">matrix</code></td>
<td>
<p>An initial matrix (optional), and object of class <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="defineNetwork_+3A_nodes">nodes</code></td>
<td>
<p>A node-set (see <code><a href="#topic+defineNodes">defineNodes()</a></code>).</p>
</td></tr>
<tr><td><code id="defineNetwork_+3A_nodes2">nodes2</code></td>
<td>
<p>A second optional node-set for the definition of
two-mode networks.</p>
</td></tr>
<tr><td><code id="defineNetwork_+3A_directed">directed</code></td>
<td>
<p>A logical value indicating whether the network is directed.</p>
</td></tr>
<tr><td><code id="defineNetwork_+3A_envir">envir</code></td>
<td>
<p>An <a href="methods.html#topic+environment-class">environment</a> object where the nodes-set objects are
defined. The default value is <code><a href="base.html#topic+environment">environment()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a matrix is used as input, its dimension names must be a subset of the
nodes in the nodeset as defined with the <code><a href="#topic+defineNodes">defineNodes()</a></code> and the order of
the labels in rows and columns must correspond to the order of node labels
in the nodeset.
The matrix can be directed or undirected (as specified with the
<code>directed</code> argument).
</p>
<p>If the network is updated over time (e.g., a new wave of friendship data is
collected), these changes can be added with the <code><a href="#topic+linkEvents">linkEvents()</a></code> - similar to
link changing attribute events to a nodeset.
This time, the user needs to provide the network and the associated nodeset.
If no matrix is provided, goldfish only considers the nodeset and assumes
the initial state to be empty (i.e., a matrix containing only 0s).
</p>


<h3>Value</h3>

<p>an object with additional class <code>network.goldfish</code> with attributes:
</p>
<table role = "presentation">
<tr><td><code>nodes</code></td>
<td>
<p>a character vector with the names of the nodes set objects used
during the definition. <code>nodes</code> and <code>nodes2</code> arguments.</p>
</td></tr>
<tr><td><code>directed</code></td>
<td>
<p>Logical value indicating whether the network is directed.
<code>directed</code> argument</p>
</td></tr>
<tr><td><code>events</code></td>
<td>
<p>An empty character vector. <code><a href="#topic+linkEvents">linkEvents()</a></code> is used to
link event data frames.</p>
</td></tr>
</table>
<p>The object can be modified using methods for matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+defineNodes">defineNodes()</a></code>, <code><a href="#topic+linkEvents">linkEvents()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># If no intial matrix is provided
data("Social_Evolution")
callNetwork &lt;- defineNetwork(nodes = actors)

# If a initial matrix is provided
data("Fisheries_Treaties_6070")
bilatnet &lt;- defineNetwork(bilatnet, nodes = states, directed = FALSE)
</code></pre>

<hr>
<h2 id='defineNodes'>Defining a node set with (dynamic) node attributes.</h2><span id='topic+defineNodes'></span>

<h3>Description</h3>

<p>The <code>defineNodes()</code> function processes and checks the <code>data.frame</code> passed to
the <code>nodes</code> argument.
This is a recommended step before the definition of the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defineNodes(nodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="defineNodes_+3A_nodes">nodes</code></td>
<td>
<p>a <code>data.frame</code> object with the nodes attributes with the
following reserved names
</p>

<dl>
<dt>label</dt><dd><p><code>character</code> variable containing the nodes labels
(mandatory)</p>
</dd>
<dt>present</dt><dd><p><code>logical</code> variable indicating if the respective node
is present at the first time-point (optional)</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>Additional variables in the <code>nodes</code> data frame object are considered as the
initial values of the nodes attributes.
Those variables must be of class <code>numeric</code>, <code>character</code>, <code>logical</code>.
</p>
<p>It is important that the initial definition of the node set contain all the
nodes that could be potential senders or receivers of events.
In case that all the nodes are not available at all times, the <code>present</code>
variable can be used to define compositional changes.
Therefore, the initial node set would contain all the potential senders and
receivers nodes and the variable <code>present</code> will indicate all the nodes
present at the beginning as senders or receivers.
Using <code><a href="#topic+linkEvents">linkEvents()</a></code> is possible to link events where the composition of
available nodes changes over time, see <code>vignette("teaching2")</code>.
</p>
<p>For the attributes in the nodeset to become dynamic, them
can be linked to a dynamic event-list data frames in the initial state
object by using the <code><a href="#topic+linkEvents">linkEvents()</a></code>.
A new call of <code>linkEvents()</code> is required for each attribute that is dynamic.
</p>
<p>Objects of class <a href="tibble.html#topic+tbl_df-class">tibble::tbl_df</a> from the tibble package frequently use in the
tidyverse ecosystem and objects from the <span class="pkg">data.table</span> package will produce
errors in later steps for goldfish.
Current implementation of goldfish relies on the subsetting behavior of
data frames objects. The previous mentioned objects classes change this
behavior producing errors.
</p>


<h3>Value</h3>

<p>an object with an additional class <code>nodes.goldfish</code> with attributes:
</p>
<table role = "presentation">
<tr><td><code>events</code></td>
<td>
<p>An empty character vector. <code><a href="#topic+linkEvents">linkEvents()</a></code> is used to
link event data frames.</p>
</td></tr>
<tr><td><code>dynamicAttributes</code></td>
<td>
<p>An empty character vector. <code><a href="#topic+linkEvents">linkEvents()</a></code> is used to
link event data frames and their related attribute.</p>
</td></tr>
</table>
<p>The object can be modified using methods for data frames.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+defineNetwork">defineNetwork()</a></code>, <code><a href="#topic+linkEvents">linkEvents()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nodesAttr &lt;- data.frame(
  label = paste("Actor", 1:5),
  present = c(TRUE, FALSE, TRUE, TRUE, FALSE),
  gender = c(1, 2, 1, 1, 2)
)
nodesAttr &lt;- defineNodes(nodes = nodesAttr)

# Social evolution nodes definition
data("Social_Evolution")
actors &lt;- defineNodes(actors)

# Fisheries treaties nodes definition
data("Fisheries_Treaties_6070")
states &lt;- defineNodes(states)
</code></pre>

<hr>
<h2 id='estimate'>Estimate a model</h2><span id='topic+estimate'></span>

<h3>Description</h3>

<p>Estimates parameters for a dynamic network model via maximum likelihood
implementing the iterative Newton-Raphson procedure as describe in
Stadtfeld and Block (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate(
  x,
  model = c("DyNAM", "REM", "DyNAMi"),
  subModel = c("choice", "rate", "choice_coordination"),
  estimationInit = NULL,
  preprocessingInit = NULL,
  preprocessingOnly = FALSE,
  envir = new.env(),
  progress = getOption("progress"),
  verbose = getOption("verbose")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_+3A_x">x</code></td>
<td>
<p>a formula that defines at the left-hand side the dependent
network (see <code><a href="#topic+defineDependentEvents">defineDependentEvents()</a></code>) and at the right-hand side the
effects and the variables for which the effects are expected to occur
(see <code>vignette("goldfishEffects")</code>).</p>
</td></tr>
<tr><td><code id="estimate_+3A_model">model</code></td>
<td>
<p>a character string defining the model type.
Current options include <code>"DyNAM"</code>, <code>"DyNAMi"</code> or <code>"REM"</code>
</p>

<dl>
<dt>DyNAM</dt><dd><p>Dynamic Network Actor Models
(Stadtfeld, Hollway and Block, 2017 and Stadtfeld and Block, 2017)</p>
</dd>
<dt>DyNAMi</dt><dd><p>Dynamic Network Actor Models for interactions
(Hoffman et al., 2020)</p>
</dd>
<dt>REM</dt><dd><p>Relational Event Model (Butts, 2008)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="estimate_+3A_submodel">subModel</code></td>
<td>
<p>a character string defining the submodel type.
Current options include <code>"choice"</code>, <code>"rate"</code> or
<code>"choice_coordination"</code>
</p>

<dl>
<dt>choice</dt><dd><p>a multinomial receiver choice model <code>model = "DyNAM"</code>
(Stadtfeld and Block, 2017), or the general Relational event model
<code>model = "REM"</code> (Butts, 2008).
A multinomial group choice model <code>model = "DyNAMi"</code> (Hoffman et al., 2020)</p>
</dd>
<dt>choice_coordination</dt><dd><p>a multinomial-multinomial model for coordination
ties <code>model = "DyNAM"</code> (Stadtfeld, Hollway and Block, 2017)</p>
</dd>
<dt>rate</dt><dd><p>A individual activity rates model <code>model = "DyNAM"</code>
(Stadtfeld and Block, 2017).
Two rate models, one for individuals joining groups and one for individuals
leaving groups, jointly estimated <code>model = "DyNAMi"</code>(Hoffman et al., 2020)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="estimate_+3A_estimationinit">estimationInit</code></td>
<td>
<p>a list containing lower level technical parameters
for estimation. It may contain:
</p>

<dl>
<dt>initialParameters</dt><dd><p>a numeric vector.
It includes initial parameters of the estimation.
Default is set to NULL.</p>
</dd>
<dt>fixedParameters</dt><dd><p>a numeric vector. It specifies which component of
the coefficient parameters (intercept included) is fixed and the value
it takes during estimation, e.g., if the vector is <code>c(2, NA)</code> then
the first component of the parameter is fixed to 2 during the
estimation process. Default is set to <code>NULL</code>, i.e. all parameters are
estimated. Note that it must be consistent with <code>initialParameters</code>.</p>
</dd>
<dt>maxIterations</dt><dd><p>maximum number of iterations of the Gauss/Fisher
scoring method for the estimation. Default is set to 20.</p>
</dd>
<dt>maxScoreStopCriterion</dt><dd><p>maximum absolute score criteria for successful
convergence. Default value is 0.001</p>
</dd>
<dt>initialDamping</dt><dd><p>a numeric vector used to declare the initial damping
factor for each parameter.
It controls the size of the update step during the iterative estimation
process. The default is set to 30 when the formula has windowed effects or
10 in another case, see <code>vignette("goldfishEffects")</code>.</p>
</dd>
<dt>dampingIncreaseFactor</dt><dd><p>a numeric value. It controls the factor that
increases the damping of the parameters when improvements in the estimation
are found.</p>
</dd>
<dt>dampingDecreaseFactor</dt><dd><p>a numeric value. Controls the factor that
decreases the damping of the parameters when no improvements in the
estimation are found.</p>
</dd>
<dt>returnIntervalLogL</dt><dd><p>a logical value. Whether to keep the
log-likelihood of each event from the final iteration of the Gauss/Fisher
estimation method.</p>
</dd>
<dt>engine</dt><dd><p>a string indicating the estimation engine to be used.
Current options include <code>"default"</code>, <code>"default_c"</code>, and <code>"gather_compute"</code>.
The default value is <code>"default"</code>, it is an estimation routine implemented in
pure <code>R</code> code.
<code>"default_c"</code> uses a <code>C</code> implementation of the <code>"default"</code> routine.
<code>"gather_compute"</code> uses a <code>C</code> implementation with a different data
structure that reduces the time but it can increase the memory usage.</p>
</dd>
<dt>startTime</dt><dd><p>a numerical value or a date-time character with the same
time-zone formatting as the times in event that indicates the starting time
to be considered during estimation.
<em>Note:</em> it is only use during preprocessing</p>
</dd>
<dt>endTime</dt><dd><p>a numerical value or a date-time character with the same
time-zone formatting as the times in event that indicates the end time
to be considered during estimation.
<em>Note:</em> it is only use during preprocessing</p>
</dd>
<dt>opportunitiesList</dt><dd><p>a list containing for each dependent event
the list of available nodes for the choice model, this list should be
the same length as the dependent events list (ONLY for choice models).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="estimate_+3A_preprocessinginit">preprocessingInit</code></td>
<td>
<p>a <code>preprocessed.goldfish</code> object computed for
the current formula, allows skipping the preprocessing step.</p>
</td></tr>
<tr><td><code id="estimate_+3A_preprocessingonly">preprocessingOnly</code></td>
<td>
<p>logical indicating whether only preprocessed
statistics should be returned rather than a <code>result.goldfish</code> object
with the estimated coefficients.</p>
</td></tr>
<tr><td><code id="estimate_+3A_envir">envir</code></td>
<td>
<p>an <code>environment</code> where <code>formula</code> objects and their linked
objects are available.</p>
</td></tr>
<tr><td><code id="estimate_+3A_progress">progress</code></td>
<td>
<p>logical indicating whether should print a minimal output
to the console of the progress of the preprocessing and estimation processes.</p>
</td></tr>
<tr><td><code id="estimate_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating whether should print
very detailed intermediate results of the iterative Newton-Raphson procedure;
slows down the routine significantly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing data is imputed during the preprocessing stage.
For network data missing values are replaced by a zero value,
it means that is assuming a not tie/event explicitly.
For attributes missing values are replaced by the mean value,
if missing values are presented during events updates they are replace by
the mean of the attribute in that moment of time.
</p>


<h3>Value</h3>

<p>returns an object of <code><a href="base.html#topic+class">class()</a></code> <code>"result.goldfish"</code>
when <code>preprocessingOnly = FALSE</code> or
a preprocessed statistics object of class <code>"preprocessed.goldfish"</code>
when <code>preprocessingOnly = TRUE</code>.
</p>
<p>An object of class <code>"result.goldfish"</code> is a list including:
</p>
<table role = "presentation">
<tr><td><code>parameters</code></td>
<td>
<p>a numeric vector with the coefficients estimates.</p>
</td></tr>
<tr><td><code>standardErrors</code></td>
<td>

<p>a numeric vector with the standard errors of the coefficients estimates.</p>
</td></tr>
<tr><td><code>logLikelihood</code></td>
<td>
<p>the log-likelihood of the estimated model</p>
</td></tr>
<tr><td><code>finalScore</code></td>
<td>

<p>a vector with the final score reach by the parameters during estimation.</p>
</td></tr>
<tr><td><code>finalInformationMatrix</code></td>
<td>

<p>a matrix with the final values of the negative Fisher information matrix.
The inverse of this matrix gives the variance-covariance matrix for the
parameters estimates.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>a list with two elements.
The first element (<code>isConverged</code>) is a logical value that indicates
the convergence of the model.
The second element (<code>maxAbsScore</code>) reports the final maximum absolute
score in the final iteration.</p>
</td></tr>
<tr><td><code>nIterations</code></td>
<td>

<p>an integer with the total number of iterations performed during the
estimation process.</p>
</td></tr>
<tr><td><code>nEvents</code></td>
<td>

<p>an integer reporting the number of events considered in the model.</p>
</td></tr>
<tr><td><code>names</code></td>
<td>

<p>a matrix with a description of the effects used for model fitting.
It includes the name of the object used to calculate the effects and
additional parameter description.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>a formula with the information of the model fitted.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>a character value of the model type.</p>
</td></tr>
<tr><td><code>subModel</code></td>
<td>
<p>a character value of the subModel type.</p>
</td></tr>
<tr><td><code>rightCensored</code></td>
<td>

<p>a logical value indicating if the estimation process considered
right-censored events.
Only it is considered for DyNAM-rate (<code>model = "DyNAM"</code> and
<code>subModel = "rate"</code>) or REM (<code>model = "REM"</code>) models,
and when the model includes the intercept.</p>
</td></tr>
</table>


<h3>DyNAM</h3>

<p>The actor-oriented models that the goldfish package implements have been
called Dynamic Network Actor Models (DyNAMs).
The model is a two-step process. In the first step, the waiting time until
an actor <code class="reqn">i</code> initiates the next relational event is modeled
(<code>model = "DyNAM"</code> and <code>subModel = "rate"</code>) by an exponential
distribution depending on the actor activity rate.
In the second step, the conditional probability of <code class="reqn">i</code> choosing
<code class="reqn">j</code> as the event receiver is modeled (<code>model = "DyNAM"</code> and
<code>subModel = "choice"</code>) by a multinomial probability distribution
with a linear predictor.
These two-steps are assumed to be conditionally independent given
the process state (Stadtfeld, 2012),
due to this assumption is possible to estimate these components by
different calls of the <code>estimate</code> function.
</p>


<h3>Waiting times</h3>

<p>When DyNAM-rate (<code>model = "DyNAM"</code> and <code>subModel = "rate"</code>) model
is used to estimate the first step component of the process, or the REM
<code>model = "REM"</code> model is used.
It is important to add a time intercept to model the waiting times between
events, in this way the algorithm considers the right-censored intervals
in the estimation process.
</p>
<p>In the case that the intercept is not included in the formula.
The model reflects the likelihood of an event being the next in the sequence.
This specification is useful for scenarios where the researcher doesn't have
access to the exact interevent times.
For this ordinal case the likelihood of an event is merely a
multinomial probability (Butts, 2008).
</p>


<h3>References</h3>

<p>Butts C. (2008). A Relational Event Framework for Social Action.
<em>Sociological Methodology 38 (1)</em>.
<a href="https://doi.org/10.1111/j.1467-9531.2008.00203.x">doi:10.1111/j.1467-9531.2008.00203.x</a>
</p>
<p>Hoffman, M., Block P., Elmer T., and Stadtfeld C. (2020).
A model for the dynamics of face-to-face interactions in social groups.
<em>Network Science</em>, 8(S1), S4-S25. <a href="https://doi.org/10.1017/nws.2020.3">doi:10.1017/nws.2020.3</a>
</p>
<p>Stadtfeld, C. (2012). Events in Social Networks: A Stochastic Actor-oriented
Framework for Dynamic Event Processes in Social Networks.
<em>KIT Scientific Publishing</em>. <a href="https://doi.org/10.5445/KSP/1000025407">doi:10.5445/KSP/1000025407</a>
</p>
<p>Stadtfeld, C., and Block, P. (2017). Interactions, Actors, and Time:
Dynamic Network Actor Models for Relational Events.
<em>Sociological Science 4 (1)</em>, 318-52. <a href="https://doi.org/10.15195/v4.a14">doi:10.15195/v4.a14</a>
</p>
<p>Stadtfeld, C., Hollway, J., and Block, P. (2017).
Dynamic Network Actor Models: Investigating Coordination Ties Through Time.
<em>Sociological Methodology 47 (1)</em>. <a href="https://doi.org/10.1177/0081175017709295">doi:10.1177/0081175017709295</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+defineDependentEvents">defineDependentEvents()</a></code>, <code><a href="#topic+defineGlobalAttribute">defineGlobalAttribute()</a></code>,
<code><a href="#topic+defineNetwork">defineNetwork()</a></code>, <code><a href="#topic+defineNodes">defineNodes()</a></code>, <code><a href="#topic+linkEvents">linkEvents()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A multinomial receiver choice model
data("Social_Evolution")
callNetwork &lt;- defineNetwork(nodes = actors, directed = TRUE)
callNetwork &lt;- linkEvents(
  x = callNetwork, changeEvent = calls,
  nodes = actors
)
callsDependent &lt;- defineDependentEvents(
  events = calls, nodes = actors,
  defaultNetwork = callNetwork
)



mod01 &lt;- estimate(callsDependent ~ inertia + recip + trans,
  model = "DyNAM", subModel = "choice",
  estimationInit = list(engine = "default_c")
)
summary(mod01)

# A individual activity rates model
mod02 &lt;- estimate(callsDependent ~ 1 + nodeTrans + indeg + outdeg,
  model = "DyNAM", subModel = "rate",
  estimationInit = list(engine = "default_c")
)
summary(mod02)


# A multinomial-multinomial choice model for coordination ties
data("Fisheries_Treaties_6070")
states &lt;- defineNodes(states)
states &lt;- linkEvents(states, sovchanges, attribute = "present")
states &lt;- linkEvents(states, regchanges, attribute = "regime")
states &lt;- linkEvents(states, gdpchanges, attribute = "gdp")

bilatnet &lt;- defineNetwork(bilatnet, nodes = states, directed = FALSE)
bilatnet &lt;- linkEvents(bilatnet, bilatchanges, nodes = states)

contignet &lt;- defineNetwork(contignet, nodes = states, directed = FALSE)
contignet &lt;- linkEvents(contignet, contigchanges, nodes = states)

createBilat &lt;- defineDependentEvents(
  events = bilatchanges[bilatchanges$increment == 1, ],
  nodes = states, defaultNetwork = bilatnet
)

partnerModel &lt;- estimate(
  createBilat ~
    inertia(bilatnet) +
    indeg(bilatnet, ignoreRep = TRUE) +
    trans(bilatnet, ignoreRep = TRUE) +
    tie(contignet) +
    alter(states$regime) +
    diff(states$regime) +
    alter(states$gdp) +
    diff(states$gdp),
  model = "DyNAM", subModel = "choice_coordination",
  estimationInit = list(initialDamping = 40, maxIterations = 30)
)
summary(partnerModel)


</code></pre>

<hr>
<h2 id='examine'>Diagnostic functions</h2><span id='topic+examine'></span><span id='topic+examineOutliers'></span><span id='topic+examineChangepoints'></span>

<h3>Description</h3>

<p>Provide diagnostic functions for an object of class <code>result.goldfish</code>.
<code>outliers</code> helps to identify outliers events.
<code>changepoints</code> helps to identify where a change point
in the events sequence is presented using the log-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>examineOutliers(
  x,
  method = c("Hampel", "IQR", "Top"),
  parameter = 3,
  window = NULL
)

examineChangepoints(
  x,
  moment = c("mean", "variance"),
  method = c("PELT", "AMOC", "BinSeg"),
  window = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="examine_+3A_x">x</code></td>
<td>
<p>an object of class <code>result.goldfish</code> output from an
<code><a href="#topic+estimate">estimate</a></code> call.</p>
</td></tr>
<tr><td><code id="examine_+3A_method">method</code></td>
<td>
<p>Choice of <code>"AMOC"</code>, <code>"PELT"</code> or <code>"BinSeg"</code>.
For a detail description see <code><a href="changepoint.html#topic+cpt.mean">cpt.mean</a></code> or
<code><a href="changepoint.html#topic+cpt.var">cpt.var</a></code>. The default value is <code>"PELT"</code>.</p>
</td></tr>
<tr><td><code id="examine_+3A_parameter">parameter</code></td>
<td>
<p>An integer that represents the number of absolute outliers
to identify, the threshold for the Hampel filter, i.e. <code>parameter * MAD</code>,
or the threshold beyond the interquartile range halved, i.e.
<code>parameter/2 * IQR</code>.</p>
</td></tr>
<tr><td><code id="examine_+3A_window">window</code></td>
<td>
<p>The window half-width for the Hampel filter.
By default it is half the width of the event sequence.</p>
</td></tr>
<tr><td><code id="examine_+3A_moment">moment</code></td>
<td>
<p>character argument to choose between &quot;mean&quot; or &quot;variance&quot;.
See section <em>Change point</em> for details.</p>
</td></tr>
<tr><td><code id="examine_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the functions in the
<span class="pkg">changepoint</span> package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> if neither outliers nor change points are identified.
An object of class <code>ggplot</code> object from a call of <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code>.
It can be modified using the <code>ggplot2</code> syntax.
</p>


<h3>Outliers</h3>

<p><code>examineOutliers</code> creates a plot with the log-likelihood of the events
in the y-axis and the event index in the x-axis, identifying observations
with labels indicating the sender and recipient.
</p>


<h3>Change point</h3>

<p>The parameter <code>moment</code> controls which method from the package
<span class="pkg">changepoint</span> is used:
</p>

<dl>
<dt><code>"mean"</code></dt><dd><p>It uses the <code><a href="changepoint.html#topic+cpt.mean">cpt.mean</a></code>
function to investigate optimal positioning and (potentially) number
of change points for the log-likelihood of the events in mean.</p>
</dd>
<dt><code>"variance"</code></dt><dd><p>It uses the
<code><a href="changepoint.html#topic+cpt.var">cpt.var</a></code>
function to investigate optimal positioning and (potentially) number
of change points for the log-likelihood of the events in variance</p>
</dd>
</dl>

<p>The function call creates a plot with the log-likelihood of the events
in the y-axis and the event index in the x-axis, highlighting the change
point sections identified by the method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A multinomial receiver choice model
data("Social_Evolution")
callNetwork &lt;- defineNetwork(nodes = actors, directed = TRUE)
callNetwork &lt;- linkEvents(
  x = callNetwork, changeEvent = calls,
  nodes = actors
)
callsDependent &lt;- defineDependentEvents(
  events = calls, nodes = actors,
  defaultNetwork = callNetwork
)

mod01 &lt;- estimate(callsDependent ~ inertia + recip + trans,
  model = "DyNAM", subModel = "choice",
  estimationInit = list(
    returnIntervalLogL = TRUE,
    engine = "default_c"
  )
)

examineOutliers(mod01)

examineChangepoints(mod01)
</code></pre>

<hr>
<h2 id='Fisheries_Treaties_6070'>International bilateral fisheries treaties (1960-1970)</h2><span id='topic+Fisheries_Treaties_6070'></span><span id='topic+bilatchanges'></span><span id='topic+bilatnet'></span><span id='topic+contigchanges'></span><span id='topic+contignet'></span><span id='topic+gdpchanges'></span><span id='topic+regchanges'></span><span id='topic+sovchanges'></span><span id='topic+states'></span>

<h3>Description</h3>

<p>An abbreviated version of the international fisheries agreements dataset,
including only bilateral agreements, fewer variables,
and ranging only between 1960 and 1970 inclusive.
This data set is only meant for testing, and not for inference.
It provides an example of an undirected, weighted (by integer/increment)
network, with composition change and both monadic and dyadic covariates.
Monadic variables include the dates states gain or lose sovereign status,
their polity score, and their GDP.
Dyadic variables include bilateral fisheries agreements between states,
and states' contiguity with one another over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Fisheries_Treaties_6070)

bilatchanges

bilatnet

contigchanges

contignet

gdpchanges

regchanges

sovchanges

states
</code></pre>


<h3>Format</h3>

<p>The data includes several dataframes:
states (154 rows, 4 columns, monadic),
sovchanges (62 rows, 3 columns, monadic),
regchanges (145 rows, 3 columns, monadic),
gdpchanges (979 rows, 3 columns, monadic),
bilatchanges (77 rows, 4 columns, dyadic),
contigchanges (139 rows, 4 columns, dyadic).
See below for variables and formats.
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>Object</strong> </td><td style="text-align: left;"> <strong>Description</strong> </td><td style="text-align: left;"> <strong>Format</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
states$label </td><td style="text-align: left;"> Node identifier labels </td><td style="text-align: left;"> character </td>
</tr>
<tr>
 <td style="text-align: left;">
states$present </td><td style="text-align: left;"> Node present in dataset </td><td style="text-align: left;"> boolean </td>
</tr>
<tr>
 <td style="text-align: left;">
states$regime </td><td style="text-align: left;"> Placeholder for regime variable </td><td style="text-align: left;"> numeric (NA) </td>
</tr>
<tr>
 <td style="text-align: left;">
states$gdp </td><td style="text-align: left;"> Placeholder for GDP variable </td><td style="text-align: left;"> numeric (NA) </td>
</tr>
<tr>
 <td style="text-align: left;">
sovchanges$time </td><td style="text-align: left;"> Date of state sovereignty update </td><td style="text-align: left;"> POSIXct </td>
</tr>
<tr>
 <td style="text-align: left;">
sovchanges$node </td><td style="text-align: left;"> Node for state sovereignty update </td><td style="text-align: left;"> integer </td>
</tr>
<tr>
 <td style="text-align: left;">
sovchanges$replace </td><td style="text-align: left;"> State sovereignty update </td><td style="text-align: left;"> boolean </td>
</tr>
<tr>
 <td style="text-align: left;">
regchanges$time </td><td style="text-align: left;"> Date of regime update </td><td style="text-align: left;"> POSIXct </td>
</tr>
<tr>
 <td style="text-align: left;">
regchanges$node </td><td style="text-align: left;"> Node for regime update </td><td style="text-align: left;"> integer </td>
</tr>
<tr>
 <td style="text-align: left;">
regchanges$replace </td><td style="text-align: left;"> Regime update </td><td style="text-align: left;"> integer (-10--10) </td>
</tr>
<tr>
 <td style="text-align: left;">
gdpchanges$time </td><td style="text-align: left;"> Date of GDP update </td><td style="text-align: left;"> POSIXct </td>
</tr>
<tr>
 <td style="text-align: left;">
gdpchanges$node </td><td style="text-align: left;"> Node for GDP update </td><td style="text-align: left;"> integer </td>
</tr>
<tr>
 <td style="text-align: left;">
gdpchanges$replace </td><td style="text-align: left;"> GDP update </td><td style="text-align: left;"> numeric </td>
</tr>
<tr>
 <td style="text-align: left;">
bilatchanges$time </td><td style="text-align: left;"> Date of bilateral change </td><td style="text-align: left;"> POSIXct </td>
</tr>
<tr>
 <td style="text-align: left;">
bilatchanges$sender </td><td style="text-align: left;"> First bilateral change node </td><td style="text-align: left;"> integer </td>
</tr>
<tr>
 <td style="text-align: left;">
bilatchanges$receiver </td><td style="text-align: left;"> Second bilateral change node </td><td style="text-align: left;"> integer </td>
</tr>
<tr>
 <td style="text-align: left;">
bilatchanges$increment</td><td style="text-align: left;"> Create or dissolve tie</td><td style="text-align: left;"> numeric (-1 or 1)</td>
</tr>
<tr>
 <td style="text-align: left;">
contigchanges$time </td><td style="text-align: left;"> Date of contiguity change </td><td style="text-align: left;"> POSIXct </td>
</tr>
<tr>
 <td style="text-align: left;">
contigchanges$sender </td><td style="text-align: left;"> First contiguity change node </td><td style="text-align: left;"> integer </td>
</tr>
<tr>
 <td style="text-align: left;">
contigchanges$receiver </td><td style="text-align: left;"> Second contiguity change node </td><td style="text-align: left;"> integer </td>
</tr>
<tr>
 <td style="text-align: left;">
contigchanges$replace </td><td style="text-align: left;"> New contiguity value </td><td style="text-align: left;"> numeric </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>An object of class <code>data.frame</code> with 77 rows and 4 columns.
</p>
<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 154 rows and 154 columns.
</p>
<p>An object of class <code>data.frame</code> with 139 rows and 4 columns.
</p>
<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 154 rows and 154 columns.
</p>
<p>An object of class <code>data.frame</code> with 979 rows and 3 columns.
</p>
<p>An object of class <code>data.frame</code> with 145 rows and 3 columns.
</p>
<p>An object of class <code>data.frame</code> with 62 rows and 3 columns.
</p>
<p>An object of class <code>data.frame</code> with 154 rows and 4 columns.
</p>


<h3>References</h3>

<p>Hollway, James, and Johan Koskinen. 2016.
Multilevel Embeddedness: The Case of the Global Fisheries Governance Complex.
<em>Social Networks</em>, 44: 281-94. <a href="https://doi.org/10.1016/j.socnet.2015.03.001">doi:10.1016/j.socnet.2015.03.001</a>.
</p>
<p>Hollway, James, and Johan H Koskinen. 2016.
Multilevel Bilateralism and Multilateralism: States' Bilateral and
Multilateral Fisheries Treaties and Their Secretariats.
In <em>Multilevel Network Analysis for the Social Sciences</em>,
edited by Emmanuel Lazega and Tom A B Snijders,
315-32. Cham: Springer International Publishing.
<a href="https://doi.org/10.1007/978-3-319-24520-1_13">doi:10.1007/978-3-319-24520-1_13</a>.
</p>

<hr>
<h2 id='GatherPreprocessing'>Gather preprocess data from a formula</h2><span id='topic+GatherPreprocessing'></span>

<h3>Description</h3>

<p>Gather the preprocess data from a formula and a model,
where the output corresponds to the data structure used by the engine
<code>gather_compute</code>; see <code><a href="#topic+estimate">estimate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GatherPreprocessing(
  formula,
  model = c("DyNAM", "REM"),
  subModel = c("choice", "choice_coordination", "rate"),
  preprocessArgs = NULL,
  progress = getOption("progress"),
  envir = new.env()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GatherPreprocessing_+3A_formula">formula</code></td>
<td>
<p>a formula object that defines at the
left-hand side the dependent
network (see <code><a href="#topic+defineDependentEvents">defineDependentEvents()</a></code>) and at the right-hand side the
effects and the variables for which the effects are expected to occur
(see <code>vignette("goldfishEffects")</code>).</p>
</td></tr>
<tr><td><code id="GatherPreprocessing_+3A_model">model</code></td>
<td>
<p>a character string defining the model type.
Current options include <code>"DyNAM"</code>, <code>"DyNAMi"</code> or <code>"REM"</code>
</p>

<dl>
<dt>DyNAM</dt><dd><p>Dynamic Network Actor Models
(Stadtfeld, Hollway and Block, 2017 and Stadtfeld and Block, 2017)</p>
</dd>
<dt>DyNAMi</dt><dd><p>Dynamic Network Actor Models for interactions
(Hoffman et al., 2020)</p>
</dd>
<dt>REM</dt><dd><p>Relational Event Model (Butts, 2008)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="GatherPreprocessing_+3A_submodel">subModel</code></td>
<td>
<p>a character string defining the submodel type.
Current options include <code>"choice"</code>, <code>"rate"</code> or
<code>"choice_coordination"</code>
</p>

<dl>
<dt>choice</dt><dd><p>a multinomial receiver choice model <code>model = "DyNAM"</code>
(Stadtfeld and Block, 2017), or the general Relational event model
<code>model = "REM"</code> (Butts, 2008).
A multinomial group choice model <code>model = "DyNAMi"</code> (Hoffman et al., 2020)</p>
</dd>
<dt>choice_coordination</dt><dd><p>a multinomial-multinomial model for coordination
ties <code>model = "DyNAM"</code> (Stadtfeld, Hollway and Block, 2017)</p>
</dd>
<dt>rate</dt><dd><p>A individual activity rates model <code>model = "DyNAM"</code>
(Stadtfeld and Block, 2017).
Two rate models, one for individuals joining groups and one for individuals
leaving groups, jointly estimated <code>model = "DyNAMi"</code>(Hoffman et al., 2020)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="GatherPreprocessing_+3A_preprocessargs">preprocessArgs</code></td>
<td>
<p>a list containing additional parameters
for preprocessing. It may contain:
</p>

<dl>
<dt>startTime</dt><dd><p>a numerical value or a date-time character with the same
time-zone formatting as the times in event that indicates the starting time
to be considered during estimation.
<em>Note:</em> it is only use during preprocessing</p>
</dd>
<dt>endTime</dt><dd><p>a numerical value or a date-time character with the same
time-zone formatting as the times in event that indicates the end time
to be considered during estimation.
<em>Note:</em> it is only use during preprocessing</p>
</dd>
<dt>opportunitiesList</dt><dd><p>a list containing for each dependent event
the list of available nodes for the choice model, this list should be
the same length as the dependent events list (ONLY for choice models).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="GatherPreprocessing_+3A_progress">progress</code></td>
<td>
<p>logical indicating whether should print a minimal output
to the console of the progress of the preprocessing and estimation processes.</p>
</td></tr>
<tr><td><code id="GatherPreprocessing_+3A_envir">envir</code></td>
<td>
<p>an <code>environment</code> where <code>formula</code> objects and their linked
objects are available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It differs from the <code>estimate()</code> output when the argument <code>preprocessingOnly</code>
is set to <code>TRUE</code> regarding the memory space requirement.
The <code>gatherPreprocessing()</code> produces a list where the first element
is a matrix that could have up to the number of events times
the number of actors rows and the number of effects columns.
For medium to large datasets with thousands of events and
thousands of actors, the memory RAM requirements are large and,
therefore, errors are produced due to a lack of space.
The advantage of the data structure is that it can be adapted
to estimate the models (or extensions of them) using standard packages
for generalized linear models (or any other model)
that use tabular data as input.
</p>


<h3>Value</h3>

<p>a list object including:
</p>

<dl>
<dt>stat_all_events</dt><dd><p>a matrix. The number of rows can be up to the number
of events times the number of actors
(square number of actors for the REM).
Rigth-censored events are included when the model has an intercept.
The number of columns is the number of effects in the model.
Every row is the effect statistics at the time of the event for each actor
in the choice set or the sender set.</p>
</dd>
<dt>n_candidates</dt><dd>
<p>a numeric vector with the number of rows related with an event.
The length correspond to the number of events
plus right censored events if any.</p>
</dd>
<dt>selected</dt><dd><p>a numeric vector with the position of the
selected actor (choice model), sender actor (rate model), or
active dyad (choice-coordination model, REM model).
Indexing start at 1 for each event.</p>
</dd>
<dt>sender, receiver</dt><dd>
<p>a character vector with the label of the sender/receiver actor.
For right-censored events the receiver values is not meaningful.</p>
</dd>
<dt>hasIntercept</dt><dd>
<p>a logical value indicating if the model has an intercept.</p>
</dd>
<dt>namesEffects</dt><dd><p>a character vector with a short name of the effect.
It includes the name of the object used to calculate the effects and
modifiers of the effect, e.g., the type of effect, weighted effect.</p>
</dd>
<dt>effectDescription</dt><dd>
<p>a character matrix with the description of the effects.
It includes the name of the object used to calculate the effects and
additional information of the effect, e.g., the type of effect,
weighted effect, transformation function, window length.</p>
</dd>
</dl>

<p>If the model has an intercept and the subModel is <code>rate</code> or model is <code>REM</code>,
additional elements are included:
</p>

<dl>
<dt>timespan</dt><dd>
<p>a numeric vector with the time span between events,
including right-censored events.</p>
</dd>
<dt>isDependent</dt><dd>
<p>a logical vector indicating if the event is dependent or right-censored.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data("Fisheries_Treaties_6070")
states &lt;- defineNodes(states)
states &lt;- linkEvents(states, sovchanges, attribute = "present")
states &lt;- linkEvents(states, regchanges, attribute = "regime")
states &lt;- linkEvents(states, gdpchanges, attribute = "gdp")

bilatnet &lt;- defineNetwork(bilatnet, nodes = states, directed = FALSE)
bilatnet &lt;- linkEvents(bilatnet, bilatchanges, nodes = states)

createBilat &lt;- defineDependentEvents(
  events = bilatchanges[bilatchanges$increment == 1, ],
  nodes = states, defaultNetwork = bilatnet
)

contignet &lt;- defineNetwork(contignet, nodes = states, directed = FALSE)
contignet &lt;- linkEvents(contignet, contigchanges, nodes = states)

gatheredData &lt;- GatherPreprocessing(
  createBilat ~ inertia(bilatnet) + trans(bilatnet) + tie(contignet)
)

</code></pre>

<hr>
<h2 id='linkEvents'>Link dynamic events to a nodeset or a network</h2><span id='topic+linkEvents'></span><span id='topic+linkEvents.nodes.goldfish'></span><span id='topic+linkEvents.network.goldfish'></span><span id='topic+linkEvents.default'></span>

<h3>Description</h3>

<p>Link events stored in data frames that modify attributes of the nodeset or
modify ties in a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkEvents(x, ...)

## S3 method for class 'nodes.goldfish'
linkEvents(x, changeEvents, attribute, ...)

## S3 method for class 'network.goldfish'
linkEvents(x, changeEvents, nodes = NULL, nodes2 = NULL, ...)

## Default S3 method:
linkEvents(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linkEvents_+3A_x">x</code></td>
<td>
<p>Either a nodeset (<code>nodes.goldfish</code> object) or a network
(<code>network.goldfish</code> object)</p>
</td></tr>
<tr><td><code id="linkEvents_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the method.</p>
</td></tr>
<tr><td><code id="linkEvents_+3A_changeevents">changeEvents</code></td>
<td>
<p>The name of a data frame that represents a
valid events list.</p>
</td></tr>
<tr><td><code id="linkEvents_+3A_attribute">attribute</code></td>
<td>
<p>a character vector indicating the names of the attributes
that should be updated by the specified events (ONLY if the object is a
nodeset).</p>
</td></tr>
<tr><td><code id="linkEvents_+3A_nodes">nodes</code></td>
<td>
<p>a nodeset (<code>data.frame</code> or <code>nodes.goldfish</code> object)
related to the network (ONLY if <code>x</code> is a network)</p>
</td></tr>
<tr><td><code id="linkEvents_+3A_nodes2">nodes2</code></td>
<td>
<p>an optional nodeset (<code>data.frame</code> or <code>nodes.goldfish</code> object)
related to the network (ONLY if <code>x</code> is a network)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data frame that contains the events must contain variables with specific
names depending if they refer to dynamic attributes or dynamic networks.
</p>
<p>For dynamic networks stored in object of class <code>network.goldfish</code> the
<code>changeEvents</code> data frame must contain the following variables:
</p>

<dl>
<dt>time</dt><dd><p><code>numeric</code> or <code>POSIXct</code> (see <code><a href="base.html#topic+as.Date">base::as.Date()</a></code>) variable
containing the time-stamps when the event happen.</p>
</dd>
<dt>sender</dt><dd><p><code>character</code> variable indicating the label of the sender
of the event.</p>
</dd>
<dt>receiver</dt><dd><p><code>character</code> variable indicating the label of the receiver
of the event.</p>
</dd>
</dl>

<p>See the <code>bilatchanges</code> and <code>contigchanges</code> data frames in the
<a href="#topic+Fisheries_Treaties_6070">Fisheries_Treaties_6070</a> datasets for examples of event data frames that
relate with dynamic networks.
</p>
<p>For dynamic attributes stored in object of class <code>nodes.goldfish</code> the
<code>changeEvents</code> data frame must contain the following variables:
</p>

<dl>
<dt>time</dt><dd><p><code>numeric</code> or <code>POSIXct</code> (see <code><a href="base.html#topic+as.Date">base::as.Date()</a></code>) variable
containing the time-stamps when the event happen.</p>
</dd>
<dt>label</dt><dd><p><code>character</code> variable indicating the label of the node
for which the attribute changes.</p>
</dd>
</dl>

<p>See <code>sovchanges</code>, <code>regchanges</code> and <code>gdpchanges</code> data frames in the
<a href="#topic+Fisheries_Treaties_6070">Fisheries_Treaties_6070</a> datasets for examples of event data frames that
relate with dynamic attributes
</p>
<p>For both cases an additional variable indicates the change in value of either
the ties or attributes.
The class of this variable must be the same as the tie value or attribute
value that will be updated, i.e., when the <code>present</code> variable is dynamic the
updating values must be <code>logical</code> (see <code><a href="#topic+defineNodes">defineNodes()</a></code> for a description
of this variable.
There are two possibilities on how to specify those
changes but only one can be used at a time:
</p>

<dl>
<dt>increment</dt><dd><p>with a numerical value that represent the increment
(when it's positive value) or the decrement (when it's a negative value)
of the dynamic element from their past value (with respect to the <code>time</code>
value).
</p>
<p>In the <a href="#topic+Social_Evolution">Social_Evolution</a> dataset the <code>calls</code> data frame contains
the calling events between students where the increment represent a new call.
With every new call the dyad (sender-receiver) increase the count of calls
that had happen in the past.</p>
</dd>
<dt>replace</dt><dd><p>contains the value that would replace at point-time <code>time</code>
the attribute or tie value. It is usually the way to represent changes in
node attributes.
</p>
<p>In the <a href="#topic+Fisheries_Treaties_6070">Fisheries_Treaties_6070</a> dataset the <code>sovchanges</code>,
<code>regchanges</code> and <code>gdpchanges</code>data frames are examples where the <code>replace</code>
variable is used to specify attribute changes and their class match with the
variable in the node set.
</p>
<p>Dynamic network attributes can be also defined using the <code>replace</code> variable.
The <code>contigchanges</code> data frame in the <a href="#topic+Fisheries_Treaties_6070">Fisheries_Treaties_6070</a> dataset, and
<code>friendship</code> data frame in the <a href="#topic+Social_Evolution">Social_Evolution</a> are examples of this.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>an object with the same class as the object <code>x</code>.
For objects of class <code>network.goldfish</code> the attribute <code>events</code> with the name
of the event data frame passed through with the argument <code>changeEvents</code>.
For objects of class <code>nodes.goldfish</code> attibutes <code>events</code> and
<code>dynamicAttribute</code> are modified with name of the objects passed through with
the arguments <code>changeEvents</code> and <code>attribute</code> respectively.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+defineNodes">defineNodes()</a></code>, <code><a href="#topic+defineNetwork">defineNetwork()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>actors &lt;- data.frame(
  actor = 1:5, label = paste("Actor", 1:5),
  present = TRUE, gender = sample.int(2, 5, replace = TRUE)
)
actors &lt;- defineNodes(nodes = actors)
callNetwork &lt;- defineNetwork(nodes = actors)

# Link events to a nodeset
compositionChangeEvents &lt;- data.frame(
  time = c(14, 60),
  node = "Actor 4",
  replace = c(FALSE, TRUE)
)
actorsnew &lt;- linkEvents(
  x = actors, attribute = "present", changeEvents = compositionChangeEvents
)

# Link events to a Network
calls &lt;- data.frame(
  time = c(12, 27, 45, 56, 66, 68, 87),
  sender = paste("Actor", c(1, 3, 5, 2, 3, 4, 2)),
  receiver = paste("Actor", c(4, 2, 3, 5, 1, 2, 5)),
  increment = rep(1, 7)
)
callNetwork &lt;- linkEvents(
  x = callNetwork, changeEvent = calls, nodes = actors
)
</code></pre>

<hr>
<h2 id='logLik.result.goldfish'>Extract log-likelihood from a fitted model object</h2><span id='topic+logLik.result.goldfish'></span>

<h3>Description</h3>

<p>This function extract the log-likelihood from the output of a
<code>estimate</code> call.
The extracted log-likelihood correspond to the value in the last
iteration of the <code>estimate</code> call, users should check convergence of
the Gauss/Fisher scoring method before using the log-likelihood statistic
to compare models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'result.goldfish'
logLik(object, ..., avgPerEvent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.result.goldfish_+3A_object">object</code></td>
<td>
<p>an object of class <code>result.goldfish</code> output from an
<code><a href="#topic+estimate">estimate</a></code> call with a fitted model.</p>
</td></tr>
<tr><td><code id="logLik.result.goldfish_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed.</p>
</td></tr>
<tr><td><code id="logLik.result.goldfish_+3A_avgperevent">avgPerEvent</code></td>
<td>
<p>a logical value indicating whether the average
likelihood per event should be calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Users might use <code><a href="stats.html#topic+AIC">stats::AIC()</a></code> and <code><a href="stats.html#topic+AIC">stats::BIC()</a></code> to compute the Information
Criteria from one or several fitted model objects.
An information criterion could be used to compare models
with respect to their predictive power.
</p>
<p>Alternatively, <code><a href="lmtest.html#topic+lrtest">lmtest::lrtest()</a></code> can be used to compare models via
asymptotic likelihood ratio tests. The test is designed to compare nested
models. i.e., models where the model specification of one contains a subset
of the predictor variables that define the other.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>logLik</code> when <code>avgPerEvent = FALSE</code>.
This is a number with the extracted log-likelihood from the fitted model,
and with the following attributes:
</p>
<table role = "presentation">
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom with the number of estimated parameters in
the model</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>the number of observations used in estimation.
In general, it corresponds to the number of dependent events used in
estimation. For a <code>subModel = "rate"</code> or <code>model = "REM"</code> with intercept,
it corresponds to the number of dependent events plus right-censored
events due to exogenous or endogenous changes.</p>
</td></tr>
</table>
<p>When <code>avgPerEvent = TRUE</code>, the function returns a number with the average
log-likelihood per event. The total number of events depends on the presence
of right-censored events in a similar way that the attribute <code>nobs</code>
is computed when <code>avgPerEvent = FALSE</code>.
</p>

<hr>
<h2 id='print-method'>Methods for <code>goldfish</code> objects.</h2><span id='topic+print-method'></span><span id='topic+print.result.goldfish'></span><span id='topic+print.summary.result.goldfish'></span><span id='topic+print.nodes.goldfish'></span><span id='topic+print.network.goldfish'></span><span id='topic+print.dependent.goldfish'></span><span id='topic+print.preprocessed.goldfish'></span>

<h3>Description</h3>

<p>Printing functions for <code>goldfish</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'result.goldfish'
print(
  x,
  ...,
  digits = max(3, getOption("digits") - 2),
  width = getOption("width"),
  complete = FALSE
)

## S3 method for class 'summary.result.goldfish'
print(
  x,
  ...,
  digits = max(3, getOption("digits") - 2),
  width = getOption("width"),
  complete = FALSE
)

## S3 method for class 'nodes.goldfish'
print(x, ..., full = FALSE, n = 6)

## S3 method for class 'network.goldfish'
print(x, ..., full = FALSE, n = 6L)

## S3 method for class 'dependent.goldfish'
print(x, ..., full = FALSE, n = 6)

## S3 method for class 'preprocessed.goldfish'
print(x, ..., width = getOption("width"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print-method_+3A_x">x</code></td>
<td>
<p>an object of class <code>result.goldfish</code>, <code>summary.result.goldfish</code>,
<code>nodes.goldfish</code>, <code>network.goldfish</code>, <code>dependent.goldfish</code>, or
<code>preprocessed.goldfish</code>.</p>
</td></tr>
<tr><td><code id="print-method_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the respective <code>default</code>
method.</p>
</td></tr>
<tr><td><code id="print-method_+3A_digits">digits</code></td>
<td>
<p>minimal number of significant digits, see <code><a href="base.html#topic+print.default">print.default()</a></code>.</p>
</td></tr>
<tr><td><code id="print-method_+3A_width">width</code></td>
<td>
<p>controls the maximum number of columns on a line used in
printing <code>summary.result.goldfish</code> and <code>preprocessed.goldfish</code>,
see  <code><a href="base.html#topic+print.default">print.default()</a></code>.</p>
</td></tr>
<tr><td><code id="print-method_+3A_complete">complete</code></td>
<td>
<p>logical. Indicates whether the parameter coefficients
of effects fixed during estimation using <code>fixedParameters</code> should be printed.
The default value is <code>FALSE</code>. <em>Note:</em> applies for objects of class
<code>result.goldfish</code> and <code>summary.result.goldfish</code>.</p>
</td></tr>
<tr><td><code id="print-method_+3A_full">full</code></td>
<td>
<p>logical. Indicates whether the complete <code>matrix</code>/<code>data.frame</code>
should be printed. The default value <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="print-method_+3A_n">n</code></td>
<td>
<p>number of rows for <code>data.frame</code>, and rows and columns for
<code>matrix</code> to be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Not value, called for printing side effect.
</p>
<p>For objects of class <code>result.goldfish</code> and <code>summary.result.goldfish</code>
print the estimated coefficients when <code>complete = FALSE</code>, otherwise it
includes also the fixed coefficients.
For <code>summary.result.goldfish</code> print:
</p>
<table role = "presentation">
<tr><td><code>Effect details:</code></td>
<td>
<p>a table with additional information of the effects.
The information corresponds to the  values of the effects arguments when
they are modified and if they where fixed during estimation, see
<code>vignette("goldfishEffects")</code> for the complete list of arguments, and
<code><a href="#topic+estimate">estimate()</a></code> on how to fix coefficients during estimation.</p>
</td></tr>
<tr><td><code>Coefficients:</code></td>
<td>
<p>a table with the estimated coefficients, their
approximate standard error obtain from the inverse of the negative Fisher
information matrix, z-value and the p-value of the univariate two-tailed
Wald test to test the hypothesis that the parameter is 0.</p>
</td></tr>
<tr><td><code>Convergence and Information Criteria:</code></td>
<td>
<p>Information about the
convergence of the iterative Newton-Raphson procedure and the score value
in the last iteration. Information criteria as the AIC, BIC and the AIC
corrected for small sample size AICc are reported.</p>
</td></tr>
<tr><td><code>Model and subModel:</code></td>
<td>
<p>the values set during estimation.</p>
</td></tr>
</table>
<p>For objects of class <code>nodes.goldfish</code> print information of the total
number of nodes in the object, the number of nodes present at the beginning
of preprocessing, a table with the linked attributes with their respective
events data frame and a printing of the first rows in the nodes data frame.
See <code><a href="#topic+defineNodes">defineNodes()</a></code>.
</p>
<p>For objects of class <code>network.goldfish</code> print information of the
dimensions of the network, number of ties presented at the beginning of the
preprocessing, the nodes data frames linked to it, information about their
definition as a one-mode and directed network, linked events data frame to it
and a printing of the first rows and columns in the array.
See <code><a href="#topic+defineNetwork">defineNetwork()</a></code>.
</p>
<p>For objects of class <code>dependent.goldfish</code> print information of the
total number of events in the object, linked nodes set(s),
linked default network
and a printing of the first rows in the events data frame.
See <code><a href="#topic+defineDependentEvents">defineDependentEvents()</a></code>.
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+tidy'></span><span id='topic+glance'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+glance">glance</a></code>, <code><a href="generics.html#topic+tidy">tidy</a></code></p>
</dd>
</dl>

<hr>
<h2 id='RFID_Validity_Study'>RFID Validity dataset</h2><span id='topic+RFID_Validity_Study'></span><span id='topic+rfid'></span><span id='topic+video'></span><span id='topic+known.before'></span><span id='topic+participants'></span>

<h3>Description</h3>

<p>Dataset collected at ETH Zürich by Timon Elmer and colleagues in order to
test the accuracy of Radio Frequency Identification (RFID) badges for
measuring social interactions.
Social interactions of 11 individuals (from the university staff) were
recorded with RFID badges in an informal setting. They were then compared to
the interactions observed by two confederates who watched the video recording
of the event. The RFID data went through the data processing procedure
detailed in the original article. See Elmer et al, 2019 for more details,
and the OSF platform for all details on the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(RFID_Validity_Study)

rfid

video

known.before

participants
</code></pre>


<h3>Format</h3>

<p>3 dataframes: <br />
</p>

<ul>
<li><p> participants (11 rows, 7 columns):
attributes of the experiment's participants<br />
</p>
</li>
<li><p> rfid (1011 rows, 4 columns): dyadic interactions detected
by the RFID badges (after data processing)<br />
</p>
</li>
<li><p> video (219 rows, 4 columns): dyadic interactions detected
by the video rating<br />
and one network:<br />
</p>
</li>
<li><p> known.before (11 rows, 11 columns): network of previous acquaintances<br />
See below for variables and formats.<br />
</p>
</li></ul>


<table>
<tr>
 <td style="text-align: left;">
<strong>Object</strong> </td><td style="text-align: left;"> <strong>Description</strong> </td><td style="text-align: left;"> <strong>Format</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
participants$actor </td><td style="text-align: left;"> Identifier of the actor </td><td style="text-align: left;">  integer </td>
</tr>
<tr>
 <td style="text-align: left;">
participants$label </td><td style="text-align: left;"> (Anonymized) name </td><td style="text-align: left;">  Factor </td>
</tr>
<tr>
 <td style="text-align: left;">
participants$present </td><td style="text-align: left;"> Presence of the actor (all actors are present)
</td><td style="text-align: left;"> logical </td>
</tr>
<tr>
 <td style="text-align: left;">
participants$age </td><td style="text-align: left;"> Actor's age </td><td style="text-align: left;"> integer </td>
</tr>
<tr>
 <td style="text-align: left;">
participants$gender </td><td style="text-align: left;"> Actor's gender (0: male, 1: female)
</td><td style="text-align: left;"> integer </td>
</tr>
<tr>
 <td style="text-align: left;">
participants$group
</td><td style="text-align: left;"> Actor's group affiliation (groups have distinct ids) </td><td style="text-align: left;"> integer </td>
</tr>
<tr>
 <td style="text-align: left;">
participants$level </td><td style="text-align: left;"> Actor's seniority
(1: MSc student, 2: PhD student, 3: PostDoc, 4: Prof) </td><td style="text-align: left;"> integer </td>
</tr>
<tr>
 <td style="text-align: left;">
rfid$NodeA </td><td style="text-align: left;"> Identifier for the first actor </td><td style="text-align: left;">  chr </td>
</tr>
<tr>
 <td style="text-align: left;">
rfid$NodeB </td><td style="text-align: left;"> Identifier for the second actor </td><td style="text-align: left;">  chr </td>
</tr>
<tr>
 <td style="text-align: left;">
rfid$Start </td><td style="text-align: left;"> Time of the beginning of the dyadic interaction
</td><td style="text-align: left;"> integer </td>
</tr>
<tr>
 <td style="text-align: left;">
rfid$End </td><td style="text-align: left;"> Time of the end of the dyadic interaction </td><td style="text-align: left;"> integer </td>
</tr>
<tr>
 <td style="text-align: left;">
video$NodeA </td><td style="text-align: left;"> Identifier for the first actor </td><td style="text-align: left;"> chr </td>
</tr>
<tr>
 <td style="text-align: left;">
video$NodeB </td><td style="text-align: left;"> Identifier for the second actor </td><td style="text-align: left;"> chr </td>
</tr>
<tr>
 <td style="text-align: left;">
video$Start </td><td style="text-align: left;"> Time of the beginning of the dyadic interaction
</td><td style="text-align: left;"> integer </td>
</tr>
<tr>
 <td style="text-align: left;">
video$End </td><td style="text-align: left;"> Time of the end of the dyadic interaction </td><td style="text-align: left;"> integer </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>An object of class <code>data.frame</code> with 1011 rows and 4 columns.
</p>
<p>An object of class <code>data.frame</code> with 219 rows and 4 columns.
</p>
<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 11 rows and 11 columns.
</p>
<p>An object of class <code>data.frame</code> with 11 rows and 7 columns.
</p>


<h3>Source</h3>

<p><a href="https://osf.io/rrhxe/">https://osf.io/rrhxe/</a>
</p>


<h3>References</h3>

<p>Elmer, T., Chaitanya, K., Purwar, P., &amp; Stadtfeld, C. (2019).
The validity of RFID badges measuring face-to-face interactions.
Behavior research methods, 1-19. <a href="https://doi.org/10.3758/s13428-018-1180-y">doi:10.3758/s13428-018-1180-y</a>
</p>

<hr>
<h2 id='Social_Evolution'>Social evolution of a university dormitory cohort</h2><span id='topic+Social_Evolution'></span><span id='topic+actors'></span><span id='topic+calls'></span><span id='topic+friendship'></span>

<h3>Description</h3>

<p>An abbreviated version of the MIT Reality Commons Social Evolution dataset,
spanning a reduced time period and with fewer variables. Dyadic variables
include binary friendships at time of survey, and time-stamped phone call
occurrences. Individual variables include the floor of the dormitory on
which the student resides, and the grade type of each student including
freshmen, sophomore, junior, senior, or graduate tutors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Social_Evolution)

actors

calls

friendship
</code></pre>


<h3>Format</h3>

<p>3 dataframes: actors (84 rows, 4 columns),
calls (439 rows, 4 columns), friendship (766 rows, 4 columns).
See below for variables and formats.
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>Object</strong> </td><td style="text-align: left;"> <strong>Description</strong> </td><td style="text-align: left;"><strong>Format</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
actors$label </td><td style="text-align: left;">  Actor identifier labels </td><td style="text-align: left;"> character </td>
</tr>
<tr>
 <td style="text-align: left;">
actors$present </td><td style="text-align: left;">  Actor present in dataset </td><td style="text-align: left;"> boolean </td>
</tr>
<tr>
 <td style="text-align: left;">
actors$floor </td><td style="text-align: left;">  Floor of residence actor lives on
</td><td style="text-align: left;"> numeric (1-9) </td>
</tr>
<tr>
 <td style="text-align: left;">
actors$gradeType </td><td style="text-align: left;">  Degree level </td><td style="text-align: left;"> numeric (1-5) </td>
</tr>
<tr>
 <td style="text-align: left;">
calls$time </td><td style="text-align: left;">  Time and date of call </td><td style="text-align: left;"> numeric from POSIXct </td>
</tr>
<tr>
 <td style="text-align: left;">
calls$sender </td><td style="text-align: left;">  Initiator of phone call </td><td style="text-align: left;"> character </td>
</tr>
<tr>
 <td style="text-align: left;">
calls$receiver </td><td style="text-align: left;">  Recipient of phone call </td><td style="text-align: left;"> character </td>
</tr>
<tr>
 <td style="text-align: left;">
calls$increment </td><td style="text-align: left;">  Indicates call number increment (all 1s)
</td><td style="text-align: left;"> numeric (1) </td>
</tr>
<tr>
 <td style="text-align: left;">
friendship$time </td><td style="text-align: left;">  Time and date of friend nomination
</td><td style="text-align: left;"> numeric from POSIXct </td>
</tr>
<tr>
 <td style="text-align: left;">
friendship$sender </td><td style="text-align: left;">  Nominator of friendship </td><td style="text-align: left;"> character </td>
</tr>
<tr>
 <td style="text-align: left;">
friendship$receiver </td><td style="text-align: left;">  Nominee of friendship </td><td style="text-align: left;"> character </td>
</tr>
<tr>
 <td style="text-align: left;">
friendship$replace </td><td style="text-align: left;">  Indicates friendship value at $time
</td><td style="text-align: left;"> numeric </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>An object of class <code>data.frame</code> with 84 rows and 4 columns.
</p>
<p>An object of class <code>data.frame</code> with 439 rows and 4 columns.
</p>
<p>An object of class <code>data.frame</code> with 766 rows and 4 columns.
</p>


<h3>References</h3>

<p>A. Madan, M. Cebrian, S. Moturu, K. Farrahi, A. Pentland (2012).
Sensing the 'Health State' of a Community.
<em>Pervasive Computing. 11</em>, 4, pp. 36-45. <a href="https://doi.org/10.1109/MPRV.2011.79">doi:10.1109/MPRV.2011.79</a>.
</p>

<hr>
<h2 id='update-method'>Methods to update a nodes or network object</h2><span id='topic+update-method'></span><span id='topic+as.data.frame.nodes.goldfish'></span><span id='topic+as.matrix.network.goldfish'></span>

<h3>Description</h3>

<p>Methods to create a data frame from an object of class <code>nodes.goldfish</code>
(see <code><a href="#topic+defineNodes">defineNodes()</a></code>) or a matrix from an object of class
<code>network.goldfish</code> (see <code><a href="#topic+defineNetwork">defineNetwork()</a></code>) with the attributes
or the network ties updated according with the events linked to the object
using the <code><a href="#topic+linkEvents">linkEvents()</a></code>) function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nodes.goldfish'
as.data.frame(x, ..., time = -Inf, startTime = -Inf, envir = new.env())

## S3 method for class 'network.goldfish'
as.matrix(x, ..., time = -Inf, startTime = -Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update-method_+3A_x">x</code></td>
<td>
<p>an object of class <code>nodes.goldfish</code> for <code>as.data.frame()</code>
method or <code>network.goldfish</code> for <code>as.matrix()</code> method.</p>
</td></tr>
<tr><td><code id="update-method_+3A_...">...</code></td>
<td>
<p>Not further arguments are required.</p>
</td></tr>
<tr><td><code id="update-method_+3A_time">time</code></td>
<td>
<p>a numeric value or a calendar date value (see <code><a href="base.html#topic+as.Date">as.Date()</a></code>)
to update the state of the object <code>x</code> until this time value
(event time &lt; time).</p>
</td></tr>
<tr><td><code id="update-method_+3A_starttime">startTime</code></td>
<td>
<p>a numeric <code>as.Date</code> format value; prior events are
disregarded.</p>
</td></tr>
<tr><td><code id="update-method_+3A_envir">envir</code></td>
<td>
<p>an <code>environment</code> where the nodes and linked events
objects are available.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The respective object updated accordingly to the events link to it.
For <code>nodes.goldfish</code> object the attributes are updated according to the
events linked to them.
For <code>network.goldfish</code> object the network ties are updated according to the
events linked to it.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+defineNetwork">defineNetwork()</a></code>, <code><a href="#topic+defineNodes">defineNodes()</a></code>, <code><a href="#topic+linkEvents">linkEvents()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Fisheries_Treaties_6070")
states &lt;- defineNodes(states)
states &lt;- linkEvents(states, sovchanges, attribute = "present")
states &lt;- linkEvents(states, regchanges, attribute = "regime")
states &lt;- linkEvents(states, gdpchanges, attribute = "gdp")

bilatnet &lt;- defineNetwork(bilatnet, nodes = states, directed = FALSE)
bilatnet &lt;- linkEvents(bilatnet, bilatchanges, nodes = states)

updateStates &lt;- as.data.frame(
  states,
  time = as.numeric(as.POSIXct("1965-12-31"))
)


updateNet &lt;- as.matrix(bilatnet, time = as.numeric(as.POSIXct("1965-12-31")))


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
