<!DOCTYPE html><html><head><title>Help for package SparseMDC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SparseMDC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cell_type_biase'><p>Biase Data Cell Type</p></a></li>
<li><a href='#condition_biase'><p>Biase Data Conditions</p></a></li>
<li><a href='#data_biase'><p>Biase Data</p></a></li>
<li><a href='#generate_uni_dat'><p>Uniform data generator</p>
For use with the gap statistic. Generates datasets drawn from the reference
distribution where each reference feature is generated uniformly over the
range of observed values for that feature.</a></li>
<li><a href='#lambda1_calculator'><p>Lambda 1 Calcualtor</p></a></li>
<li><a href='#lambda2_calculator'><p>Lambda 2 Calculator</p></a></li>
<li><a href='#mu_calc'><p>mu Calculator</p></a></li>
<li><a href='#mu_solver'><p>Mu Solver</p></a></li>
<li><a href='#pen_calculator'><p>Penalty calculator</p></a></li>
<li><a href='#pre_proc_data'><p>Pre-process data</p></a></li>
<li><a href='#S_func'><p>The soft thresholding operator</p></a></li>
<li><a href='#score_calc'><p>Score calculator</p></a></li>
<li><a href='#sdc_mpar'><p>SparseDC Multi Parallel</p></a></li>
<li><a href='#sparse_mdc'><p>SparseDC Multi</p></a></li>
<li><a href='#sparsemdc_gap'><p>Gap Statistic Calculator</p></a></li>
<li><a href='#update_c'><p>update_c</p></a></li>
<li><a href='#update_mu'><p>update_mu</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Implementation of SparseMDC Algorithm</td>
</tr>
<tr>
<td>Version:</td>
<td>0.99.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the algorithm described in
    Barron, M., and Li, J. (Not yet published). This algorithm clusters
    samples from multiple ordered populations, links the clusters across the
    conditions and identifies marker genes for these changes. The package was
    designed for scRNA-Seq data but is also applicable to many other data
    types, just replace cells with samples and genes with variables. The
    package also contains functions for estimating the parameters for SparseMDC
    as outlined in the paper. We recommend that users further select their
    marker genes using the magnitude of the cluster centers.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, foreach, parallel, doParallel</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0), doRNG</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-08-01 16:44:39 UTC; Martin</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Barron [aut],
  Jun Li [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jun Li &lt;jun.li@nd.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-08-02 12:40:16 UTC</td>
</tr>
</table>
<hr>
<h2 id='cell_type_biase'>Biase Data Cell Type</h2><span id='topic+cell_type_biase'></span>

<h3>Description</h3>

<p>The cell type of each of the cells in the Biase data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell_type_biase
</code></pre>


<h3>Format</h3>

<p>An R.Data object containing a vector with the cell type of each of the
cells in the Biase Data.</p>

<hr>
<h2 id='condition_biase'>Biase Data Conditions</h2><span id='topic+condition_biase'></span>

<h3>Description</h3>

<p>The condition for each sample in the Biase data. To be used when splitting
the data to demonstrate SparseDC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condition_biase
</code></pre>


<h3>Format</h3>

<p>An R.Data object containing a vector with the conditon of the 49 cells
in the Biase data.</p>

<hr>
<h2 id='data_biase'>Biase Data</h2><span id='topic+data_biase'></span>

<h3>Description</h3>

<p>This dataset was created by Biase et al. to study cell fat inclination in
mouse embryos. It contains FPKM gene expression measurements for 49 cells
and 16,514 genes. There are three cell types in the dataset, zygote,
two-cell embryo, and four-cell embryo cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_biase
</code></pre>


<h3>Format</h3>

<p>An R.Data object storing FPKM gene expression
measurements for each of the samples.</p>

<hr>
<h2 id='generate_uni_dat'>Uniform data generator
For use with the gap statistic. Generates datasets drawn from the reference
distribution where each reference feature is generated uniformly over the
range of observed values for that feature.</h2><span id='topic+generate_uni_dat'></span>

<h3>Description</h3>

<p>Uniform data generator
For use with the gap statistic. Generates datasets drawn from the reference
distribution where each reference feature is generated uniformly over the
range of observed values for that feature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_uni_dat(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_uni_dat_+3A_data">data</code></td>
<td>
<p>A dataset with rows as features and columns as samples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataset drawn from the reference distribution for use internally
with the gap statistic.
</p>

<hr>
<h2 id='lambda1_calculator'>Lambda 1 Calcualtor</h2><span id='topic+lambda1_calculator'></span>

<h3>Description</h3>

<p>Calculates the lambda 1 value for the SparseMDC algorithm. The lambda 1
value controls the number of marker genes selected for each
cluster in the output from SparseMDC. It is calculated as the value of
lambda 1 that results in no marker genes being selected when then are no
meaningful clusters present in the data. Please see the original manuscript
for further details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda1_calculator(dat_l, dim, nclust, nboot = 1000, alpha1 = 0.5,
  delta = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambda1_calculator_+3A_dat_l">dat_l</code></td>
<td>
<p>list with D entries, each entry contains data d, p * n matrix.
This data should be centered and log-transformed.</p>
</td></tr>
<tr><td><code id="lambda1_calculator_+3A_dim">dim</code></td>
<td>
<p>Total number of conditions, D.</p>
</td></tr>
<tr><td><code id="lambda1_calculator_+3A_nclust">nclust</code></td>
<td>
<p>Total number of clusters.</p>
</td></tr>
<tr><td><code id="lambda1_calculator_+3A_nboot">nboot</code></td>
<td>
<p>The number of bootstrap repetitions used for estimating
lambda 1, the default value is 1000.</p>
</td></tr>
<tr><td><code id="lambda1_calculator_+3A_alpha1">alpha1</code></td>
<td>
<p>The quantile of the bootstrapped lambda 1 values to use,
range is (0,1). The default value is 0.5, the median of the calculated
lambda 1 values.</p>
</td></tr>
<tr><td><code id="lambda1_calculator_+3A_delta">delta</code></td>
<td>
<p>Small value term added to ensure existance, default value is
0.0000001.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated value of lambda1 for use in main SparseMDC
algorithm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
# Select small dataset for example
data_test &lt;- data_biase[1:100,]
# Split data into condition A and B
data_A &lt;- data_test[ , which(condition_biase == "A")]
data_B &lt;- data_test[ , which(condition_biase == "B")]
data_C &lt;- data_test[ , which(condition_biase == "C")]
# Store data as list
dat_l &lt;- list(data_A, data_B, data_C)
# Pre-process the data
pdat &lt;- pre_proc_data(dat_l, dim=3, norm = FALSE, log = TRUE,
center = TRUE)
lambda1 &lt;- lambda1_calculator(pdat, dim = 3, nclust = 3 )

</code></pre>

<hr>
<h2 id='lambda2_calculator'>Lambda 2 Calculator</h2><span id='topic+lambda2_calculator'></span>

<h3>Description</h3>

<p>Calculates the lambda 2 values for use in the main SparseMDC algorithm, the
lambda 2 value controls the number of genes that show condition-dependent
expression within each cell type. That is it controls the number of
different mean values across the conditions for each cluster. It is
calculated by estimating the value of lambda 2 that would result in no
difference in mean values across conditions when there are no meaningful
differences across between the conditions. For further details please see
the original manuscript.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda2_calculator(dat_l, dim, nclust, nboot = 1000, alpha2 = 0.5,
  delta = 1e-07, lambda1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambda2_calculator_+3A_dat_l">dat_l</code></td>
<td>
<p>list with D entries, each entry contains data d, p * n matrix.
This data should be centered and log-transformed.</p>
</td></tr>
<tr><td><code id="lambda2_calculator_+3A_dim">dim</code></td>
<td>
<p>Total number of conditions, D.</p>
</td></tr>
<tr><td><code id="lambda2_calculator_+3A_nclust">nclust</code></td>
<td>
<p>Total number of clusters.</p>
</td></tr>
<tr><td><code id="lambda2_calculator_+3A_nboot">nboot</code></td>
<td>
<p>The number of bootstrap repetitions for estimating lambda 2,
the default value is 1000.</p>
</td></tr>
<tr><td><code id="lambda2_calculator_+3A_alpha2">alpha2</code></td>
<td>
<p>The quantile of the bootstrapped lambda 2 values to use,
range is (0,1). The default value is 0.5, the median of the calculated
lambda 2 values.</p>
</td></tr>
<tr><td><code id="lambda2_calculator_+3A_delta">delta</code></td>
<td>
<p>Small term to ensure existance of solution, default is
0.0000001.</p>
</td></tr>
<tr><td><code id="lambda2_calculator_+3A_lambda1">lambda1</code></td>
<td>
<p>Calcualted penalty parameter for mean size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated value of lambda2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
# Select small dataset for example
data_test &lt;- data_biase[1:100,]
# Split data into condition A and B
data_A &lt;- data_test[ , which(condition_biase == "A")]
data_B &lt;- data_test[ , which(condition_biase == "B")]
data_C &lt;- data_test[ , which(condition_biase == "C")]
# Store data as list
dat_l &lt;- list(data_A, data_B, data_C)
# Pre-process the data
pdat &lt;- pre_proc_data(dat_l, dim=3, norm = FALSE, log = TRUE,
center = TRUE)
lambda1 &lt;- lambda1_calculator(pdat, dim = 3, nclust = 3)
lambda2 &lt;- lambda2_calculator(pdat, dim = 3, nclust = 3, lambda1 = lambda1)
</code></pre>

<hr>
<h2 id='mu_calc'>mu Calculator</h2><span id='topic+mu_calc'></span>

<h3>Description</h3>

<p>This function handles the calculations of the Mu Solver. This function
runs inside <code>sparse_mdc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mu_calc(d, v, EQ, dim, x, nk, p1, p2, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mu_calc_+3A_d">d</code></td>
<td>
<p>- The current condition.</p>
</td></tr>
<tr><td><code id="mu_calc_+3A_v">v</code></td>
<td>
<p>- Relationship matrix, describing relationship between d-1 and d.</p>
</td></tr>
<tr><td><code id="mu_calc_+3A_eq">EQ</code></td>
<td>
<p>- Equality matrix specifying the number of following terms to
which mu_d is equal.</p>
</td></tr>
<tr><td><code id="mu_calc_+3A_dim">dim</code></td>
<td>
<p>Total number of conditions, D.</p>
</td></tr>
<tr><td><code id="mu_calc_+3A_x">x</code></td>
<td>
<p>- Matrix of mean values.</p>
</td></tr>
<tr><td><code id="mu_calc_+3A_nk">nk</code></td>
<td>
<p>- Vector with the number of samples in each dimension for this
cluster.</p>
</td></tr>
<tr><td><code id="mu_calc_+3A_p1">p1</code></td>
<td>
<p>- Penalties on mean size.</p>
</td></tr>
<tr><td><code id="mu_calc_+3A_p2">p2</code></td>
<td>
<p>- Penalties on mean difference.</p>
</td></tr>
<tr><td><code id="mu_calc_+3A_delta">delta</code></td>
<td>
<p>Small term to ensure existance of solution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two vectors containing the calculated values of
mu_d | mu_d &lt; mu_d-1 and mu_d | mu_d &gt; mu_d-1 respecitively.
</p>

<hr>
<h2 id='mu_solver'>Mu Solver</h2><span id='topic+mu_solver'></span>

<h3>Description</h3>

<p>Calculates the regularized center values for a cluster. This function
runs inside <code>sparse_mdc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mu_solver(d, mu, v, EQ, dim, x, nk, p1, p2, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mu_solver_+3A_d">d</code></td>
<td>
<p>- The current condition.</p>
</td></tr>
<tr><td><code id="mu_solver_+3A_mu">mu</code></td>
<td>
<p>- A matrix of regularized mean values.</p>
</td></tr>
<tr><td><code id="mu_solver_+3A_v">v</code></td>
<td>
<p>- Relationship matrix, describing relationship between d-1 and d.</p>
</td></tr>
<tr><td><code id="mu_solver_+3A_eq">EQ</code></td>
<td>
<p>- Equality matrix specifying the number of following terms to
which mu_d is equal.</p>
</td></tr>
<tr><td><code id="mu_solver_+3A_dim">dim</code></td>
<td>
<p>- Total dimensions.</p>
</td></tr>
<tr><td><code id="mu_solver_+3A_x">x</code></td>
<td>
<p>- Matrix of mean values.</p>
</td></tr>
<tr><td><code id="mu_solver_+3A_nk">nk</code></td>
<td>
<p>- Vector with the number of samples in each condition for this
cluster.</p>
</td></tr>
<tr><td><code id="mu_solver_+3A_p1">p1</code></td>
<td>
<p>- Penalties on mean size.</p>
</td></tr>
<tr><td><code id="mu_solver_+3A_p2">p2</code></td>
<td>
<p>- Penalties on mean difference.</p>
</td></tr>
<tr><td><code id="mu_solver_+3A_delta">delta</code></td>
<td>
<p>Small term to ensure existance of solution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the regularized cluster means for each
dimension.
</p>

<hr>
<h2 id='pen_calculator'>Penalty calculator</h2><span id='topic+pen_calculator'></span>

<h3>Description</h3>

<p>Calcualtes the penalty terms for penalizing mean size and mean difference.
This function runs inside <code>sparse_mdc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pen_calculator(lambda1, lambda2, nk, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pen_calculator_+3A_lambda1">lambda1</code></td>
<td>
<p>Calculated penalty parameter for mean size.</p>
</td></tr>
<tr><td><code id="pen_calculator_+3A_lambda2">lambda2</code></td>
<td>
<p>Calculated penalty parameter for mean difference.</p>
</td></tr>
<tr><td><code id="pen_calculator_+3A_nk">nk</code></td>
<td>
<p>Vector containing the number of samples in each dimension.</p>
</td></tr>
<tr><td><code id="pen_calculator_+3A_delta">delta</code></td>
<td>
<p>Small term to ensure existance of solution, default is
0.0000001.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two vectors containing the penalty terms for mean size
and mean difference respectively.
</p>

<hr>
<h2 id='pre_proc_data'>Pre-process data</h2><span id='topic+pre_proc_data'></span>

<h3>Description</h3>

<p>This function centers on a gene-by-gene basis, normalizes and/or log
transforms the data prior to the application of SparseMDC.For the
sequencing depth normalization we recommend that users use one of the many
methods developed for normalizing scRNA-Seq data prior to using SparseMDC and
so can set <code>norm = FALSE</code>. However, here we normalize the data by
dividing by the total number of reads. This function log transforms the data
by applying <code>log(x + 1)</code> to each of the data sets. By far the most
important pre-processing step for SparseMDC is the centralization of the
data. Having centralized data is a core component of the SparseMDC algorithm
and is necessary for both accurate clustering of the cells and identifying
marker genes. We therefore recommend that all users centralize their data
using this function and that only experienced users set <code>center = FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pre_proc_data(dat_l, dim, norm = FALSE, log = TRUE, center = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pre_proc_data_+3A_dat_l">dat_l</code></td>
<td>
<p>list with D entries, each entry contains data d, p * n matrix.
The entries should be ordered according the condition of each dataset. The
rows of the data matrix should contain samples while the columns contain
features or genes.</p>
</td></tr>
<tr><td><code id="pre_proc_data_+3A_dim">dim</code></td>
<td>
<p>Total number of conditions, D.</p>
</td></tr>
<tr><td><code id="pre_proc_data_+3A_norm">norm</code></td>
<td>
<p>True/False on if the data should be normalized. This parameter
controls whether the data is normalized for sequencing depth by dividing
each column by the total number of reads for that sample. We recommend that
user use one of the many methods for normalizing scRNA-Seq data and so set
this as <code>FALSE</code>. The default value is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="pre_proc_data_+3A_log">log</code></td>
<td>
<p>True/False of if the data should be transformed as log(x + 1).
The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pre_proc_data_+3A_center">center</code></td>
<td>
<p>This parameter controls whether the data is centered on a gene
by gene basis. We recommend all users center their data prior to applying
SparseMDC and only experienced users should set this as <code>FALSE</code>. The
default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with D entries containing the pre-processed data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
# Select small dataset for example
data_test &lt;- data_biase[1:100,]
# Split data into condition A and B
data_A &lt;- data_test[ , which(condition_biase == "A")]
data_B &lt;- data_test[ , which(condition_biase == "B")]
data_C &lt;- data_test[ , which(condition_biase == "C")]
# Store data as list
dat_l &lt;- list(data_A, data_B, data_C)
# Pre-process the data
pdat &lt;- pre_proc_data(dat_l, dim=3, norm = FALSE, log = TRUE,
center = TRUE)
</code></pre>

<hr>
<h2 id='S_func'>The soft thresholding operator</h2><span id='topic+S_func'></span>

<h3>Description</h3>

<p>Function to solve the soft thresholding problem
</p>


<h3>Usage</h3>

<pre><code class='language-R'>S_func(x, a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="S_func_+3A_x">x</code></td>
<td>
<p>The data value</p>
</td></tr>
<tr><td><code id="S_func_+3A_a">a</code></td>
<td>
<p>The lambda value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The solution to the soft thresholding operator.
</p>

<hr>
<h2 id='score_calc'>Score calculator</h2><span id='topic+score_calc'></span>

<h3>Description</h3>

<p>Calculates the score for each combination of cluster assignments
and center values. This function runs inside <code>sparse_mdc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score_calc(pdat, clusters, mu, lambda1, lambda2, nclust, delta, dim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score_calc_+3A_pdat">pdat</code></td>
<td>
<p>list with D entries, each entry contains data d, p * n matrix.
This data should be centered and log-transformed.</p>
</td></tr>
<tr><td><code id="score_calc_+3A_clusters">clusters</code></td>
<td>
<p>List containig cluster assignments for each dimension
as entries.</p>
</td></tr>
<tr><td><code id="score_calc_+3A_mu">mu</code></td>
<td>
<p>list with D entries, each entry contains centers for data d,
p*k matrix.</p>
</td></tr>
<tr><td><code id="score_calc_+3A_lambda1">lambda1</code></td>
<td>
<p>Penalty parameter for mean size.</p>
</td></tr>
<tr><td><code id="score_calc_+3A_lambda2">lambda2</code></td>
<td>
<p>Penalty parameter for mean difference.</p>
</td></tr>
<tr><td><code id="score_calc_+3A_nclust">nclust</code></td>
<td>
<p>Number of clusters in the data.</p>
</td></tr>
<tr><td><code id="score_calc_+3A_delta">delta</code></td>
<td>
<p>Small term to ensure existance of solution, default is
0.0000001.</p>
</td></tr>
<tr><td><code id="score_calc_+3A_dim">dim</code></td>
<td>
<p>Total number of conditions, D.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The caluculated score.
</p>

<hr>
<h2 id='sdc_mpar'>SparseDC Multi Parallel</h2><span id='topic+sdc_mpar'></span>

<h3>Description</h3>

<p>Applies sparse clustering to data from multiple conditions, linking the
clusters across conditions and selecting a set of marker variables for
each cluster and condition. This is a wrapper function to run SparseMDC in
parallel and choose the solution with the mimimum score for each run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdc_mpar(pdat, nclust, dim, lambda1, lambda2, nitter = 20,
  nstarts = 50, init_iter = 5, delta = 1e-07, par_starts, cores)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdc_mpar_+3A_pdat">pdat</code></td>
<td>
<p>list with D entries, each entry contains data d, p * n matrix.
This data should be centered and log-transformed.</p>
</td></tr>
<tr><td><code id="sdc_mpar_+3A_nclust">nclust</code></td>
<td>
<p>Number of clusters in the data.</p>
</td></tr>
<tr><td><code id="sdc_mpar_+3A_dim">dim</code></td>
<td>
<p>Total number of conditions, D.</p>
</td></tr>
<tr><td><code id="sdc_mpar_+3A_lambda1">lambda1</code></td>
<td>
<p>The lambda 1 value to use in the SparseMDC function. This
value controls the number of marker genes detected for each of the clusters
in the final result. This can be calculated using the &quot;lambda1_calculator&quot;
function or supplied by the user.</p>
</td></tr>
<tr><td><code id="sdc_mpar_+3A_lambda2">lambda2</code></td>
<td>
<p>The lambda 2 value to use in the SparseMDC function. This
value controls the number of genes that show condition-dependent
expression within each cell type. This can be calculated using the
&quot;lambda2_calculator&quot; function or supplied by the user.</p>
</td></tr>
<tr><td><code id="sdc_mpar_+3A_nitter">nitter</code></td>
<td>
<p>The max number of iterations for each of the start values, the
default value is 20.</p>
</td></tr>
<tr><td><code id="sdc_mpar_+3A_nstarts">nstarts</code></td>
<td>
<p>The max number of possible starts. The default
value is 50.</p>
</td></tr>
<tr><td><code id="sdc_mpar_+3A_init_iter">init_iter</code></td>
<td>
<p>The number of iterations used to initialize the
algorithm. Higher values result in less starts but more accurate and
vice versa. Default is 5.</p>
</td></tr>
<tr><td><code id="sdc_mpar_+3A_delta">delta</code></td>
<td>
<p>Small term to ensure existance of solution, default is
0.0000001.</p>
</td></tr>
<tr><td><code id="sdc_mpar_+3A_par_starts">par_starts</code></td>
<td>
<p>Number of parallel starts.</p>
</td></tr>
<tr><td><code id="sdc_mpar_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing cluster assignments, center values and the scores
for each start.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
# Select small dataset for example
data_test &lt;- data_biase[1:100,]
# Split data into condition A and B
data_A &lt;- data_test[ , which(condition_biase == "A")]
data_B &lt;- data_test[ , which(condition_biase == "B")]
data_C &lt;- data_test[ , which(condition_biase == "C")]
# Store data as list
dat_l &lt;- list(data_A, data_B, data_C)
# Pre-process the data
pdat &lt;- pre_proc_data(dat_l, dim=3, norm = FALSE, log = TRUE,
center = TRUE)
# Calculate lambda1
lambda1 &lt;- lambda1_calculator(pdat, dim = 3, nclust = 3)
# Calcualte lambda2
lambda2 &lt;- lambda2_calculator(pdat, dim = 3, nclust = 3, lambda1 = lambda1)
# Prepare parallel enviornment
library(doParallel) # Load package
library(foreach)  # Load the package
library(doRNG)
# Apply SparseMDC
smdc_res &lt;- sdc_mpar(pdat, nclust = 3, dim = 3, lambda1 = lambda1,
lambda2 = lambda2, par_starts = 2, cores = 2)
</code></pre>

<hr>
<h2 id='sparse_mdc'>SparseDC Multi</h2><span id='topic+sparse_mdc'></span>

<h3>Description</h3>

<p>Applies sparse clustering to data from multiple conditions, linking the
clusters across conditions and selecting a set of marker variables for
each cluster and condition. See the manuscript for descriptions of the
different categories of marker genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_mdc(pdat, nclust, dim, lambda1, lambda2, nitter = 20,
  nstarts = 50, init_iter = 5, delta = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparse_mdc_+3A_pdat">pdat</code></td>
<td>
<p>list with D entries, each entry contains data d, p * n matrix.
This data should be centered and log-transformed.</p>
</td></tr>
<tr><td><code id="sparse_mdc_+3A_nclust">nclust</code></td>
<td>
<p>Number of clusters in the data.</p>
</td></tr>
<tr><td><code id="sparse_mdc_+3A_dim">dim</code></td>
<td>
<p>Total number of conditions, D.</p>
</td></tr>
<tr><td><code id="sparse_mdc_+3A_lambda1">lambda1</code></td>
<td>
<p>The lambda 1 value to use in the SparseMDC function. This
value controls the number of marker genes detected for each of the clusters
in the final result. This can be calculated using the &quot;lambda1_calculator&quot;
function or supplied by the user.</p>
</td></tr>
<tr><td><code id="sparse_mdc_+3A_lambda2">lambda2</code></td>
<td>
<p>The lambda 2 value to use in the SparseMDC function. This
value controls the number of genes that show condition-dependent
expression within each cell type. This can be calculated using the
&quot;lambda2_calculator&quot; function or supplied by the user.</p>
</td></tr>
<tr><td><code id="sparse_mdc_+3A_nitter">nitter</code></td>
<td>
<p>The max number of iterations for each of the start values, the
default value is 20.</p>
</td></tr>
<tr><td><code id="sparse_mdc_+3A_nstarts">nstarts</code></td>
<td>
<p>The max number of possible starts. The default
value is 50.</p>
</td></tr>
<tr><td><code id="sparse_mdc_+3A_init_iter">init_iter</code></td>
<td>
<p>The number of iterations used to initialize the
algorithm. Higher values result in less starts but more accurate and
vice versa. Default is 5.</p>
</td></tr>
<tr><td><code id="sparse_mdc_+3A_delta">delta</code></td>
<td>
<p>Small term to ensure existance of solution, default is
0.0000001.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing cluster assignments, center values and the scores
for each start.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
# Select small dataset for example
data_test &lt;- data_biase[1:100,]
# Split data into condition A and B
data_A &lt;- data_test[ , which(condition_biase == "A")]
data_B &lt;- data_test[ , which(condition_biase == "B")]
data_C &lt;- data_test[ , which(condition_biase == "C")]
# Store data as list
dat_l &lt;- list(data_A, data_B, data_C)
# Pre-process the data
pdat &lt;- pre_proc_data(dat_l, dim=3, norm = FALSE, log = TRUE,
center = TRUE)
lambda1 &lt;- lambda1_calculator(pdat, dim = 3, nclust = 3)
lambda2 &lt;- lambda2_calculator(pdat, dim = 3, nclust = 3, lambda1 = lambda1)
smdc_res &lt;- sparse_mdc(pdat, nclust = 3, dim = 3, lambda1 = lambda1,
lambda2 = lambda2)
</code></pre>

<hr>
<h2 id='sparsemdc_gap'>Gap Statistic Calculator</h2><span id='topic+sparsemdc_gap'></span>

<h3>Description</h3>

<p>This function calculates the gap statistic for SparseMDC. For use
when the number of clusters in the data is unknown. We recommend
using alternate methods to infer the number of clusters in the
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsemdc_gap(pdat, dim, min_clus, max_clus, nboots = 200, nitter = 20,
  nstarts = 10, l1_boot = 50, l2_boot = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparsemdc_gap_+3A_pdat">pdat</code></td>
<td>
<p>list with D entries, each entry contains data d, p * n matrix.
This data should be centered and log-transformed.</p>
</td></tr>
<tr><td><code id="sparsemdc_gap_+3A_dim">dim</code></td>
<td>
<p>Total number of conditions, D.</p>
</td></tr>
<tr><td><code id="sparsemdc_gap_+3A_min_clus">min_clus</code></td>
<td>
<p>The minimum number of clusters to try, minimum value is 2.</p>
</td></tr>
<tr><td><code id="sparsemdc_gap_+3A_max_clus">max_clus</code></td>
<td>
<p>The maximum number of clusters to try.</p>
</td></tr>
<tr><td><code id="sparsemdc_gap_+3A_nboots">nboots</code></td>
<td>
<p>The number of bootstrap repetitions to use, default = 200.</p>
</td></tr>
<tr><td><code id="sparsemdc_gap_+3A_nitter">nitter</code></td>
<td>
<p>The max number of iterations for each of the start values, the
default value is 20.</p>
</td></tr>
<tr><td><code id="sparsemdc_gap_+3A_nstarts">nstarts</code></td>
<td>
<p>The number of start values to use for SparseDC. The default
value is 10.</p>
</td></tr>
<tr><td><code id="sparsemdc_gap_+3A_l1_boot">l1_boot</code></td>
<td>
<p>The number of bootstrap repetitions used for estimating
lambda 1.</p>
</td></tr>
<tr><td><code id="sparsemdc_gap_+3A_l2_boot">l2_boot</code></td>
<td>
<p>The number of bootstrap repetitions used for estimating
lambda 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the optimal number of clusters, as well as gap
statistics and the calculated standard error for each number of clusters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
# Select small dataset for example
data_test &lt;- data_biase[1:100,]
# Split data into condition A and B
data_A &lt;- data_test[ , which(condition_biase == "A")]
data_B &lt;- data_test[ , which(condition_biase == "B")]
data_C &lt;- data_test[ , which(condition_biase == "C")]
# Store data as list
dat_l &lt;- list(data_A, data_B, data_C)
# Pre-process the data
pdat &lt;- pre_proc_data(dat_l, dim=3, norm = FALSE, log = TRUE,
center = TRUE)
# Run with one bootstrap sample for example
gap_stat &lt;- sparsemdc_gap(pdat, dim=3, min_clus = 2, max_clus =3, nboots =2,
nitter = 2, nstarts = 1, l1_boot = 5, l2_boot = 5)

</code></pre>

<hr>
<h2 id='update_c'>update_c</h2><span id='topic+update_c'></span>

<h3>Description</h3>

<p>Assigns samples to clusters. This function runs inside
<code>sparse_mdc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_c(mu, pdat, nclust, dim, lambda1, lambda2, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_c_+3A_mu">mu</code></td>
<td>
<p>list with D entries, each entry contains centers for data d,
p*k matrix.</p>
</td></tr>
<tr><td><code id="update_c_+3A_pdat">pdat</code></td>
<td>
<p>list with D entries, each entry contains data d, p * n matrix.
This data should be centered and log-transformed.</p>
</td></tr>
<tr><td><code id="update_c_+3A_nclust">nclust</code></td>
<td>
<p>Total number of clusters.</p>
</td></tr>
<tr><td><code id="update_c_+3A_dim">dim</code></td>
<td>
<p>Total number of conditions, D.</p>
</td></tr>
<tr><td><code id="update_c_+3A_lambda1">lambda1</code></td>
<td>
<p>Calculated penalty parameter for mean size.</p>
</td></tr>
<tr><td><code id="update_c_+3A_lambda2">lambda2</code></td>
<td>
<p>Calculated penalty parameter for mean difference.</p>
</td></tr>
<tr><td><code id="update_c_+3A_delta">delta</code></td>
<td>
<p>Small term to ensure existance of solution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with D entries containing cluster assignments for each
sample.
</p>

<hr>
<h2 id='update_mu'>update_mu</h2><span id='topic+update_mu'></span>

<h3>Description</h3>

<p>Update the mean/center values for each cluster and dimension.
This function runs inside <code>sparse_mdc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_mu(clusters, pdat, nclust, dim, lambda1, lambda2, ngenes, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_mu_+3A_clusters">clusters</code></td>
<td>
<p>List containig cluster assignments for each dimension
as entries.</p>
</td></tr>
<tr><td><code id="update_mu_+3A_pdat">pdat</code></td>
<td>
<p>list with D entries, each entry contains data d, p * n matrix.
This data should be centered and log-transformed.</p>
</td></tr>
<tr><td><code id="update_mu_+3A_nclust">nclust</code></td>
<td>
<p>Number of clusters in the data.</p>
</td></tr>
<tr><td><code id="update_mu_+3A_dim">dim</code></td>
<td>
<p>Total number of conditions, D.</p>
</td></tr>
<tr><td><code id="update_mu_+3A_lambda1">lambda1</code></td>
<td>
<p>Calculated penalty parameter for mean size.</p>
</td></tr>
<tr><td><code id="update_mu_+3A_lambda2">lambda2</code></td>
<td>
<p>Calculated penalty parameter for mean difference.</p>
</td></tr>
<tr><td><code id="update_mu_+3A_ngenes">ngenes</code></td>
<td>
<p>The number of genes in the data.</p>
</td></tr>
<tr><td><code id="update_mu_+3A_delta">delta</code></td>
<td>
<p>Small term to ensure existance of solution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the center values for the clusters in each dimensions
as entries.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
