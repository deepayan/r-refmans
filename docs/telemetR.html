<!DOCTYPE html><html><head><title>Help for package telemetR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {telemetR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_org'><p>Add Organism Data to a Detection Dataframe</p></a></li>
<li><a href='#blanked_detects'><p>Example Multi-blanked Detection Data</p></a></li>
<li><a href='#blanking_event'><p>Create Potential Blanking Periods for Identifying Optimal Blanking Period</p></a></li>
<li><a href='#build_residence'><p>Build Continuous Residence Events</p></a></li>
<li><a href='#conv_thresh'><p>Example 95 Percent Convergence Threshold</p></a></li>
<li><a href='#conv_thresholds'><p>Calculate Convergence Thresholds for the rSSR curve</p></a></li>
<li><a href='#dat_filt1'><p>Prefiltered detection data</p></a></li>
<li><a href='#dat_orgfilt'><p>Filtered detection data with Organism Data</p></a></li>
<li><a href='#duration_compare'><p>Compare the duration of Potential Blanking Periods</p></a></li>
<li><a href='#ex_opt'><p>Example Optimum Maximum Blanking Period</p></a></li>
<li><a href='#ex_rSSR'><p>Example Renormalized Sum of Squares</p></a></li>
<li><a href='#filter_2h'><p>Basic Two Hit Filter for Detections</p></a></li>
<li><a href='#filter_4h'><p>Basic Four Hit Filter for Detections</p></a></li>
<li><a href='#filtered_detections'><p>Example Completely Filtered Detection Data</p></a></li>
<li><a href='#fish'><p>Fish Data</p></a></li>
<li><a href='#format_detects'><p>Format Detections for filteRjsats</p></a></li>
<li><a href='#format_org'><p>Format Organism Data for add_org()</p></a></li>
<li><a href='#format_receivers'><p>Format for Receiver data for filteRjsats</p></a></li>
<li><a href='#opt_mbp'><p>Idenitfy the Optimum MBP based on Convergence Threshold</p></a></li>
<li><a href='#prefilter'><p>Apply the &quot;prefilter&quot; to a Detection Dataframe</p></a></li>
<li><a href='#raw_detections'><p>Unfiltered detection data</p></a></li>
<li><a href='#receivers'><p>Receiver Data</p></a></li>
<li><a href='#reftags'><p>Example reference tags</p></a></li>
<li><a href='#renorm_SSR'><p>Calculate the Renormalized Sum of Squared Residuals</p></a></li>
<li><a href='#residence_plot'><p>Residency Survival Plot</p></a></li>
<li><a href='#rSSR_plot'><p>Plot the rSSR Curve and Convergence Thresholds and Optimum MBP</p></a></li>
<li><a href='#Set_GVs'><p>Add in Global Variables</p></a></li>
<li><a href='#setup_blanking'><p>Setup a Detection Dataframe for Identifying the Optimal Blanking Period</p></a></li>
<li><a href='#time_test'><p>Example Time Tests for Multi-blanked Detection Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Filter and Analyze Generalised Telemetry Data from Organisms</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Analyze telemetry datasets generalized to allow
    any technology. The filtering steps check for false positives caused by 
    reflected transmissions from surfaces and false pings from other noise 
    generating equipment. The filters are based on JSATS filtering algorithms
    found in package 'filteRjsats' <a href="https://CRAN.R-project.org/package=filteRjsats">https://CRAN.R-project.org/package=filteRjsats</a>
    but have been generalized to allow the user to define many of the filtering 
    variables. Additionally, this package contains scripts used to help identify 
    an optimal maximum blanking period as defined in Capello et al (2015) 
    &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0134002">doi:10.1371/journal.pone.0134002</a>&gt;. The functions were written according to
    their manuscript description, but have not been reviewed by the authors for 
    accuracy. It is included here as is, without warranty.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, tidyr, lubridate, zoo, ggplot2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rerddap, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-12 19:59:20 UTC; TSpaulding</td>
</tr>
<tr>
<td>Author:</td>
<td>Taylor Spaulding <a href="https://orcid.org/0000-0003-4381-5296"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Taylor Spaulding &lt;tspaulding@esassoc.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-13 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_org'>Add Organism Data to a Detection Dataframe</h2><span id='topic+add_org'></span>

<h3>Description</h3>

<p>This function takes a prefiltered detection dataframe from 'prefilter()' and
joins it to organism data formatted using the 'format_org()' function.
Detections are then filtered further based on the date and time of tag
release and expected battery life. Detections occurring before release of the
tag or after 2x the expected battery life are removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_org(prefilter_file, org, time_before_detection, time_unit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_org_+3A_prefilter_file">prefilter_file</code></td>
<td>
<p>a prefiltered detection dataframe from 'prefilter()'</p>
</td></tr>
<tr><td><code id="add_org_+3A_org">org</code></td>
<td>
<p>a dataframe of organism data retrieved from 'get_org_data()' or
'format_org()'</p>
</td></tr>
<tr><td><code id="add_org_+3A_time_before_detection">time_before_detection</code></td>
<td>
<p>How long before detection could an organism be
released and still detected? Generally 2x the expected tag life.</p>
</td></tr>
<tr><td><code id="add_org_+3A_time_unit">time_unit</code></td>
<td>
<p>The unit of time used for time_before_detection
(seconds, minutes, hours, days, weeks, months)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A filtered dataframe converting the raw detection data into rows
of detections
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Format the organism data
formatted_fish &lt;- format_org(data = fish,
                             var_Id = "TagCode",
                             var_release = "Release_Date",
                             var_tag_life = "TagLife",
                             var_ping_rate = "PRI",
                             local_time_zone = "America/Los_Angeles",
                             time_format = "%Y-%m-%d %H:%M:%S")

# Add organism data to the prefiltered detection data
add_org(prefilter_file = dat_filt1,
        org = formatted_fish,
        time_before_detection = 120,
        time_unit = "days")
</code></pre>

<hr>
<h2 id='blanked_detects'>Example Multi-blanked Detection Data</h2><span id='topic+blanked_detects'></span>

<h3>Description</h3>

<p>An example dataset of real acoustic telemetry detections of fish at several
receivers within the California Central Valley from 2021. These detections
have already been been processed using 'blanking_event()' to create events
using maximum blanking periods from 3 to 1,500 seconds to reprocess the data.
Each row represents a single event which includes &gt;=1 detection(s) per fish
per site which occur within the specified maximum blanking period 'mbp_n'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blanked_detects
</code></pre>


<h3>Format</h3>

<p>## 'blanked_detects'
A data frame with 44,630 rows and 9 columns:
</p>

<dl>
<dt>fish_type</dt><dd><p>Generally a strain, run, and species of fish (e.g.
Nimbus Fall Chinook = Fall-run Chinook Salmon from Nimbus Hatchery)</p>
</dd>
<dt>Tag_Code</dt><dd><p>The hexadecimal acoustic tag ID code</p>
</dd>
<dt>mbp_n</dt><dd><p>the maximum blanking period used to create this event</p>
</dd>
<dt>event_change</dt><dd><p>An increasing number which identifies the event number;
one event per fish per site for all detections which occur within 'mbp_n'
seconds of the next.</p>
</dd>
<dt>receiver_general_location</dt><dd><p>The more general geographic name of the
location of the receiver</p>
</dd>
<dt>start_time</dt><dd><p>The Date and Time of the first detection within the event</p>
</dd>
<dt>end_time</dt><dd><p>The Date and Time of the last detection within the event</p>
</dd>
<dt>n_det</dt><dd><p>The total number of detections contained within the event</p>
</dd>
<dt>duration</dt><dd><p>the total length of time of the event in seconds</p>
</dd>
</dl>


<hr>
<h2 id='blanking_event'>Create Potential Blanking Periods for Identifying Optimal Blanking Period</h2><span id='topic+blanking_event'></span>

<h3>Description</h3>

<p>Takes a dataframe with telemetry detection data and a list of potential
Blanking Period multipliers (n_val) and crosses them, duplicating the entire
dataframe by the length of n_val. Detections are grouped by individual,
site, and any supplied grouping variables. Then events are created by
collecting detections which occur within n_val*ping_rate from the next
detection. This function can be very slow depending on the size of the
dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blanking_event(
  data,
  var_site,
  var_Id,
  var_datetime,
  var_groups = NULL,
  var_ping_rate,
  n_val,
  time_unit
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blanking_event_+3A_data">data</code></td>
<td>
<p>the detection dataframe with columns for sites, tag IDs,
datetime, any grouping variables, and the expected ping rate.</p>
</td></tr>
<tr><td><code id="blanking_event_+3A_var_site">var_site</code></td>
<td>
<p>the column name, in quotes, which identifies unique residency
sites, these sites should be as distinct as possible, such that it is
infrequent that organisms can be detected at two sites at a given time.</p>
</td></tr>
<tr><td><code id="blanking_event_+3A_var_id">var_Id</code></td>
<td>
<p>the column name, in quotes, which identifies the individual
transmitter/tag/organism identifier.</p>
</td></tr>
<tr><td><code id="blanking_event_+3A_var_datetime">var_datetime</code></td>
<td>
<p>the column name, in quotes, which identifies the date and
time of the detection event. This column should already have been converted
to POSIXct format.</p>
</td></tr>
<tr><td><code id="blanking_event_+3A_var_groups">var_groups</code></td>
<td>
<p>a single string or vector of strings of the columns which
should be used to group animals. Common groupings are species and cohorts.</p>
</td></tr>
<tr><td><code id="blanking_event_+3A_var_ping_rate">var_ping_rate</code></td>
<td>
<p>the column name, in quotes, which identifies the
temporal frequency at which the transmitter emits a detectable signal.</p>
</td></tr>
<tr><td><code id="blanking_event_+3A_n_val">n_val</code></td>
<td>
<p>a vector sequence of integers which can be multiplied by the
ping rate to construct multiple potential blanking periods. The range and
step values for n should be selected based on prior knowledge about general
behavior habits of the study organism and the functionality of the equipment.
For more information, please refer to Capello et. al. 2015.</p>
</td></tr>
<tr><td><code id="blanking_event_+3A_time_unit">time_unit</code></td>
<td>
<p>the preferred unit of time to calculate durations, this
should correspond to the ping_rate, (i.e. if the ping rate is 3 seconds, the
preferred time_unit is seconds). If the preferred time_unit is on the same
scale as the ping_rate, the ping rate should be converted to the same scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe which has been crossed with all integers in n_val, and
which has been condensed into events. Please refer to Capello et. al. 2015
for further detail about the creation of these events.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a dataframe of events blanked by a set of n_values from 1:10
blanking_event(data = filtered_detections,
               var_Id = "Tag_Code",
               var_site = "receiver_general_location",
               var_datetime = "DateTime_Local",
               var_groups = "fish_type",
               var_ping_rate = "tag_pulse_rate_interval_nominal",
               n_val = c(1:2),
               time_unit = "secs")
</code></pre>

<hr>
<h2 id='build_residence'>Build Continuous Residence Events</h2><span id='topic+build_residence'></span>

<h3>Description</h3>

<p>Takes a dataframe with telemetry detection data and a single optimum blanking
period chosen from the output of opt_mbp(), and groups detections by
individual, site, and any supplied grouping variables into residence events.
The residence events are created by collecting detections which occur within
the selected optimum maximum blanking period from the next detection. This
function can be very slow depending on the size of the dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_residence(
  data,
  var_groups,
  var_Id,
  var_datetime,
  var_site,
  opt_mbp,
  time_unit
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_residence_+3A_data">data</code></td>
<td>
<p>the detection dataframe with columns for sites, tag IDs,
datetime, any grouping variables, and the expected ping rate.</p>
</td></tr>
<tr><td><code id="build_residence_+3A_var_groups">var_groups</code></td>
<td>
<p>a single string or vector of strings of the columns which
should be used to group animals. Common groupings are species and cohorts.</p>
</td></tr>
<tr><td><code id="build_residence_+3A_var_id">var_Id</code></td>
<td>
<p>the column name, in quotes, which identifies the individual
transmitter/tag/organism identifier.</p>
</td></tr>
<tr><td><code id="build_residence_+3A_var_datetime">var_datetime</code></td>
<td>
<p>the column name, in quotes, which identifies the date and
time of the detection event. This column should already have been converted
to POSIXct format.</p>
</td></tr>
<tr><td><code id="build_residence_+3A_var_site">var_site</code></td>
<td>
<p>the column name, in quotes, which identifies unique residency
sites, these sites should be as distinct as possible, such that it is
infrequent that organisms can be detected at two sites at a given time.</p>
</td></tr>
<tr><td><code id="build_residence_+3A_opt_mbp">opt_mbp</code></td>
<td>
<p>a single optimum blanking period chosen from the output of
opt_mbp()</p>
</td></tr>
<tr><td><code id="build_residence_+3A_time_unit">time_unit</code></td>
<td>
<p>the unit of time used by the optimum maximum blanking
period, often on the same scale as the ping rate for the transmitter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of detections which has been condensed into continuous
residence events based on the optimum maximum blanking period selected.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Build a set of detection events after determining the optimal blanking
# period (e.g. 2500 seconds)
build_residence(data = filtered_detections,
                var_groups = "fish_type",
                var_Id = "Tag_Code",
                var_datetime = "DateTime_Local",
                var_site = "receiver_general_location",
                opt_mbp = 2500,
                time_unit = "secs")

</code></pre>

<hr>
<h2 id='conv_thresh'>Example 95 Percent Convergence Threshold</h2><span id='topic+conv_thresh'></span>

<h3>Description</h3>

<p>Example output from the 'conv_thresholds()' function, calculating the 95
convergence thresholds for the rSSR data found in 'ex_rSSR'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conv_thresh
</code></pre>


<h3>Format</h3>

<p>## 'conv_thresh'
A data frame with 1 rows and 5 columns:
</p>

<dl>
<dt>fish_type</dt><dd><p>Generally a strain, run, and species of fish (e.g.
Nimbus Fall Chinook = Fall-run Chinook Salmon from Nimbus Hatchery)</p>
</dd>
<dt>min_val</dt><dd><p>The minimum rSSR value</p>
</dd>
<dt>max_val</dt><dd><p>The maximum rSSR value</p>
</dd>
<dt>threshold</dt><dd><p>the rSSR value which represents the 'thresh_level' cutoff
for estimating convergence</p>
</dd>
<dt>thresh_level</dt><dd><p>The desired convergence level (100-x)</p>
</dd>
</dl>


<hr>
<h2 id='conv_thresholds'>Calculate Convergence Thresholds for the rSSR curve</h2><span id='topic+conv_thresholds'></span>

<h3>Description</h3>

<p>Takes a dataframe created by renorm_SSR and calculates the range in values
and then calculates thresholds given. Suggested values are
0.5, 0.1, and 0.005. The rSSR calculated for each MBP should decrease
with each increasing blanking period until they reach close to zero, which
We consider convergence. Since the rSSR curve generally bounces around an
assymptote and often does not reach or stay at 0, we set a threshold a priori
for identifying convergence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conv_thresholds(rSSR_df, var_groups, thresh_levels = c(0.05, 0.01, 0.005))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conv_thresholds_+3A_rssr_df">rSSR_df</code></td>
<td>
<p>a dataframe created by created by renorm_SSRduration compare
showing the renormalized sum of squares of the residuals between one
potential blanking period and the next.</p>
</td></tr>
<tr><td><code id="conv_thresholds_+3A_var_groups">var_groups</code></td>
<td>
<p>a single string or vector of strings of the columns which
should be used to group organisms. Common groupings are species and cohorts.</p>
</td></tr>
<tr><td><code id="conv_thresholds_+3A_thresh_levels">thresh_levels</code></td>
<td>
<p>a single value or vector of values used to set
thresholds for identifying convergence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of rSSR values corresponding to the given convergence
threshold
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate the 95% "convergence" threshold for the rSSR data
conv_thresholds(rSSR_df = ex_rSSR,
                var_groups = "fish_type",
                thresh_levels = 0.05)

</code></pre>

<hr>
<h2 id='dat_filt1'>Prefiltered detection data</h2><span id='topic+dat_filt1'></span>

<h3>Description</h3>

<p>An example dataset of real acoustic telemetry detections of fish at several
receivers within the California Central Valley from 2021. These detections
have already been been processed using 'prefilter()' from this package or
companion package 'filteRjsats'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dat_filt1
</code></pre>


<h3>Format</h3>

<p>## 'dat_filt1'
A data frame with 47,931 rows and 4 columns:
</p>

<dl>
<dt>ReceiverSN</dt><dd><p>The serial number of the detecting receiver</p>
</dd>
<dt>DateTime_Local</dt><dd><p>the local time of the detection (tz = America/Los_Angeles)</p>
</dd>
<dt>Tag_Code</dt><dd><p>The hexadecimal acoustic tag ID code</p>
</dd>
<dt>CheckMBP</dt><dd><p>A calculated field from the prefilter checking the
time between acoustic transmissions from the same tag was &gt;0.3secs</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data collected by the California Department of Water Resources 2021
</p>

<hr>
<h2 id='dat_orgfilt'>Filtered detection data with Organism Data</h2><span id='topic+dat_orgfilt'></span>

<h3>Description</h3>

<p>An example dataset of real acoustic telemetry detections of fish at several
receivers within the California Central Valley from 2021. These detections
have already been been processed using 'prefilter()' and 'add_org()'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dat_orgfilt
</code></pre>


<h3>Format</h3>

<p>## 'dat_orgfilt'
A data frame with 47,343 rows and 16 columns:
</p>

<dl>
<dt>ReceiverSN</dt><dd><p>The serial number of the detecting receiver</p>
</dd>
<dt>DateTime_Local</dt><dd><p>the local time of the detection (tz = America/Los_Angeles)</p>
</dd>
<dt>Tag_Code</dt><dd><p>The hexadecimal acoustic tag ID code</p>
</dd>
<dt>CheckMBP</dt><dd><p>A calculated field from the prefilter checking the
time between acoustic transmissions from the same tag was &gt;0.3secs</p>
</dd>
<dt>TagInFile</dt><dd><p>A calculated field from the add_fish filter which
queries whether the tag code of the detection is associated with an
organism.</p>
</dd>
<dt>fish_type</dt><dd><p>Generally a strain, run, and species of fish (e.g.
Nimbus Fall Chinook = Fall-run Chinook Salmon from Nimbus Hatchery)</p>
</dd>
<dt>org_release_Date</dt><dd><p>The release date and time of the fish</p>
</dd>
<dt>release_location</dt><dd><p>The coded name of the release site</p>
</dd>
<dt>length</dt><dd><p>The length of the fish in millimeters</p>
</dd>
<dt>weight</dt><dd><p>The weight of the fish in grams</p>
</dd>
<dt>tag_weight</dt><dd><p>The weight of the implanted acoustic tag</p>
</dd>
<dt>tag_model</dt><dd><p>The model number of the implanted acoustic tag</p>
</dd>
<dt>tag_pulse_rate_interval_nominal</dt><dd><p>The pulse rate interval (time
between transmissions) of the implanted tag, as reported by the
manufacturer</p>
</dd>
<dt>tag_life</dt><dd><p>The expected number of days the tag should continue to
transmit, as reported by the manufacturer</p>
</dd>
<dt>CheckDT</dt><dd><p>A calculated field which checks whether the detection
occurred after the release of the fish</p>
</dd>
<dt>CheckBattLife</dt><dd><p>A calculated field which checks whether the detection
occurred before the tag battery is expected to expire (2x tag life)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data collected by the California Department of Water Resources 2021
</p>

<hr>
<h2 id='duration_compare'>Compare the duration of Potential Blanking Periods</h2><span id='topic+duration_compare'></span>

<h3>Description</h3>

<p>Takes a dataframe of detection data which has been condensed by potential
blanking periods generated by 'blanking_event()' and compares the duration of
each event to a common sequence of increasing times. If the event is longer
than the duration it is flagged as &quot;survived&quot;. The proportion of events which
&quot;survive&quot; for each potential blanking period at each time (t) is then
calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duration_compare(event_dur, var_groups = NULL, time_seq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duration_compare_+3A_event_dur">event_dur</code></td>
<td>
<p>the detection dataframe which has been condensed into
discrete events using each potential blanking period.</p>
</td></tr>
<tr><td><code id="duration_compare_+3A_var_groups">var_groups</code></td>
<td>
<p>a single string or vector of strings of the columns which
should be used to group organisms. Common groupings are species and cohorts.</p>
</td></tr>
<tr><td><code id="duration_compare_+3A_time_seq">time_seq</code></td>
<td>
<p>a vector of times on the same scale as the ping rate. The
largest value of the sequence should be greater that the longest duration
produced using blanking event, and the smallest should be shorter than the
smallest blanking period.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe which contains the proportion of &quot;survived&quot; events
created by each potential blanking period for each time (t).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compare the durations of blanked detection events
duration_compare(event_dur = blanked_detects,
                 var_groups = "fish_type",
                 time_seq = c(1:10))
</code></pre>

<hr>
<h2 id='ex_opt'>Example Optimum Maximum Blanking Period</h2><span id='topic+ex_opt'></span>

<h3>Description</h3>

<p>Example output from the 'opt_mbp()' function, finding the optimal mbp for
each group and desired convergence threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_opt
</code></pre>


<h3>Format</h3>

<p>## 'ex_opt'
A data frame with 1 rows and 5 columns:
</p>

<dl>
<dt>fish_type</dt><dd><p>Generally a strain, run, and species of fish (e.g.
Nimbus Fall Chinook = Fall-run Chinook Salmon from Nimbus Hatchery)</p>
</dd>
<dt>min_val</dt><dd><p>The minimum rSSR value</p>
</dd>
<dt>max_val</dt><dd><p>The maximum rSSR value</p>
</dd>
<dt>threshold</dt><dd><p>the rSSR value which represents the 'thresh_level' cutoff
for estimating convergence</p>
</dd>
<dt>thresh_level</dt><dd><p>The desired convergence level (100-x)</p>
</dd>
<dt>opt_mbp</dt><dd><p>The identified optimum mbp for the given threshold and group</p>
</dd>
</dl>


<hr>
<h2 id='ex_rSSR'>Example Renormalized Sum of Squares</h2><span id='topic+ex_rSSR'></span>

<h3>Description</h3>

<p>Example output from the 'renorm_SSR()' function, calculating the
renormalized sum of squares for the &quot;survival&quot; data found in 'time_test'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_rSSR
</code></pre>


<h3>Format</h3>

<p>## 'ex_rSSR'
A data frame with 100 rows and 5 columns:
</p>

<dl>
<dt>fish_type</dt><dd><p>Generally a strain, run, and species of fish (e.g.
Nimbus Fall Chinook = Fall-run Chinook Salmon from Nimbus Hatchery)</p>
</dd>
<dt>mbp_n</dt><dd><p>The maximum blanking period (in seconds) used to create a
set of events</p>
</dd>
<dt>SSR</dt><dd><p>The sum of squared residuals between this 'mbp_n' and the next</p>
</dd>
<dt>n</dt><dd><p>the total number of events created with this 'mbp_n'</p>
</dd>
<dt>rSSR</dt><dd><p>the renormalized sum of squared residuals between this 'mbp_n'
and the next</p>
</dd>
</dl>


<hr>
<h2 id='filter_2h'>Basic Two Hit Filter for Detections</h2><span id='topic+filter_2h'></span>

<h3>Description</h3>

<p>This function takes a detection dataframe generated from the
add_org() function and filters it a second time to remove any remaining
multipath detections, and then check the remaining detections by comparing
the time between each detection to ensure it is less 4x the stated pulse rate
interval. Called by second_filter_2h4h().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_2h(org_file, time_unit, multipath_time, org_ping_rate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_2h_+3A_org_file">org_file</code></td>
<td>
<p>a dataframe of detections retrieved from add_org()</p>
</td></tr>
<tr><td><code id="filter_2h_+3A_time_unit">time_unit</code></td>
<td>
<p>The unit of time used for analyses (seconds, minutes, hours,
days, weeks, months)</p>
</td></tr>
<tr><td><code id="filter_2h_+3A_multipath_time">multipath_time</code></td>
<td>
<p>A numeric maximum amount of time which must pass
between detections for a detection to be considered a &quot;true&quot;, not a bounced,
signal.</p>
</td></tr>
<tr><td><code id="filter_2h_+3A_org_ping_rate">org_ping_rate</code></td>
<td>
<p>The expected time between transmissions emitted from
tags/transmitters implanted or attached to an organism</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe which has been filtered to remove false positives
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Apply a 2-hit filter to data previously prefiltered and with organism data
filter_2h(org_file = dat_orgfilt,
          time_unit = "secs",
          multipath_time = 0.3,
          org_ping_rate = 3)
</code></pre>

<hr>
<h2 id='filter_4h'>Basic Four Hit Filter for Detections</h2><span id='topic+filter_4h'></span>

<h3>Description</h3>

<p>This function takes a detection dataframe generated from the 'add_org()'
function and filters it a second time to remove any remaining multipath
detections, and then check the remaining detections by comparing the time
between detections, for a rolling window of 4 detections to ensure it is less
16.6x the stated pulse rate interval. Called by 'second_filter()'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_4h(org_file, time_unit, multipath_time, org_ping_rate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_4h_+3A_org_file">org_file</code></td>
<td>
<p>a dataframe of detections retrieved from 'add_org()'</p>
</td></tr>
<tr><td><code id="filter_4h_+3A_time_unit">time_unit</code></td>
<td>
<p>The unit of time used for analyses (secs, mins, hours,
days, weeks)</p>
</td></tr>
<tr><td><code id="filter_4h_+3A_multipath_time">multipath_time</code></td>
<td>
<p>A numeric maximum amount of time which must pass
between detections for a detection to be considered a &quot;true&quot;, not a bounced,
signal.</p>
</td></tr>
<tr><td><code id="filter_4h_+3A_org_ping_rate">org_ping_rate</code></td>
<td>
<p>The expected time between transmissions emitted from
tags/transmitters implanted or attached to an organism</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe which has been filtered to remove false positives
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Apply a 4hit filter to data previously prefiltered and with organism data
filter_4h(org_file = dat_orgfilt,
          time_unit = "secs",
          multipath_time = 0.3,
          org_ping_rate = 3)
</code></pre>

<hr>
<h2 id='filtered_detections'>Example Completely Filtered Detection Data</h2><span id='topic+filtered_detections'></span>

<h3>Description</h3>

<p>An example dataset of real acoustic telemetry detections of fish at several
receivers within the California Central Valley from 2021. These detections
have already been been processed using 'prefilter()' and 'add_org()'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filtered_detections
</code></pre>


<h3>Format</h3>

<p>## 'filtered_detections'
A data frame with 41,000 rows and 26 columns:
</p>

<dl>
<dt>ReceiverSN</dt><dd><p>The serial number of the detecting receiver</p>
</dd>
<dt>DateTime_Local</dt><dd><p>the local time of the detection (tz = America/Los_Angeles)</p>
</dd>
<dt>Tag_Code</dt><dd><p>The hexadecimal acoustic tag ID code</p>
</dd>
<dt>CheckMBP</dt><dd><p>A calculated field from the prefilter checking the
time between acoustic transmissions from the same tag was &gt;0.3secs</p>
</dd>
<dt>TagInFile</dt><dd><p>A calculated field from the add_fish filter which
queries whether the tag code of the detection is associated with an
organism.</p>
</dd>
<dt>fish_type</dt><dd><p>Generally a strain, run, and species of fish (e.g.
Nimbus Fall Chinook = Fall-run Chinook Salmon from Nimbus Hatchery)</p>
</dd>
<dt>org_release_Date</dt><dd><p>The release date and time of the fish</p>
</dd>
<dt>release_location</dt><dd><p>The coded name of the release site</p>
</dd>
<dt>length</dt><dd><p>The length of the fish in millimeters</p>
</dd>
<dt>weight</dt><dd><p>The weight of the fish in grams</p>
</dd>
<dt>tag_weight</dt><dd><p>The weight of the implanted acoustic tag</p>
</dd>
<dt>tag_model</dt><dd><p>The model number of the implanted acoustic tag</p>
</dd>
<dt>tag_pulse_rate_interval_nominal</dt><dd><p>The pulse rate interval (time
between transmissions) of the implanted tag, as reported by the
manufacturer</p>
</dd>
<dt>tag_life</dt><dd><p>The expected number of days the tag should continue to
transmit, as reported by the manufacturer</p>
</dd>
<dt>CheckDT</dt><dd><p>A calculated field which checks whether the detection
occurred after the release of the fish</p>
</dd>
<dt>CheckBattLife</dt><dd><p>A calculated field which checks whether the detection
occurred before the tag battery is expected to expire (2x tag life)</p>
</dd>
<dt>dep_id</dt><dd><p>A unique id is created for each receiver deployment</p>
</dd>
<dt>Make</dt><dd><p>The brand of the acoustic receiver</p>
</dd>
<dt>latitude</dt><dd><p>The decimal degree latitude (WGS1984) of the acoustic
receiver at deployment</p>
</dd>
<dt>longitude</dt><dd><p>The decimal degree longitude (WGS1984) of the acoustic
receiver at deployment</p>
</dd>
<dt>receiver_location</dt><dd><p>The site name of an individual receiver, often
more than one 'receiver_location' is found at a 'receiver_general_location'</p>
</dd>
<dt>receiver_general_location</dt><dd><p>The more general geographic name of the
location of the receiver</p>
</dd>
<dt>receiver_river_km</dt><dd><p>The number of river kilometers the receiver is
from the Golden Gate Bridge</p>
</dd>
<dt>receiver_start</dt><dd><p>The start time of the reciever (generally when it
was deployed)</p>
</dd>
<dt>receiver_end</dt><dd><p>The end time of the receiver (generally when it was
retrieved)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data collected by the California Department of Water Resources 2021
</p>

<hr>
<h2 id='fish'>Fish Data</h2><span id='topic+fish'></span>

<h3>Description</h3>

<p>An example dataset of real fish tagged with acoustic telemetry tags and
released within the California Central Valley in 2021 and 2022.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fish
</code></pre>


<h3>Format</h3>

<p>## 'fish'
A data frame with 7,240 rows and 60 columns:
</p>

<dl>
<dt>fish_type</dt><dd><p>Generally a strain, run, and species of fish (e.g.
Nimbus Fall Chinook = Fall-run Chinook Salmon from Nimbus Hatchery)</p>
</dd>
<dt>TagCode</dt><dd><p>The hexadecimal code of the implanted acoustic tag</p>
</dd>
<dt>Release_Date</dt><dd><p>The release date and time of the fish</p>
</dd>
<dt>release_location</dt><dd><p>The coded name of the release site</p>
</dd>
<dt>length</dt><dd><p>The length of the fish in millimeters</p>
</dd>
<dt>weight</dt><dd><p>The weight of the fish in grams</p>
</dd>
<dt>tag_weight</dt><dd><p>The weight of the implanted acoustic tag</p>
</dd>
<dt>tag_model</dt><dd><p>The model number of the implanted acoustic tag</p>
</dd>
<dt>PRI</dt><dd><p>The pulse rate interval (time between transmissions) of the
implanted tag, as reported by the manufacturer</p>
</dd>
<dt>TagLife</dt><dd><p>The expected number of days the tag should continue to
transmit, as reported by the manufacturer</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://oceanview.pfeg.noaa.gov/CalFishTrack/pageRealtime_download.html&gt;
</p>

<hr>
<h2 id='format_detects'>Format Detections for filteRjsats</h2><span id='topic+format_detects'></span>

<h3>Description</h3>

<p>This function takes a detection dataframe from a single receiver and
reformats specific columns so that they can be read by the filtering
functions in filteRjsats package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_detects(
  data,
  var_Id,
  var_datetime_local,
  var_frequency = NULL,
  var_receiver_serial,
  var_receiver_make = NULL,
  local_time_zone,
  time_format
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_detects_+3A_data">data</code></td>
<td>
<p>the detection dataframe with columns for individual receivers,
tag IDs,datetime, and the expected ping rate.</p>
</td></tr>
<tr><td><code id="format_detects_+3A_var_id">var_Id</code></td>
<td>
<p>the column name, in quotes, which identifies the individual
transmitter/tag/organism identifier.</p>
</td></tr>
<tr><td><code id="format_detects_+3A_var_datetime_local">var_datetime_local</code></td>
<td>
<p>the column name, in quotes, which identifies the
date and time of the detection event. This column should already have been converted
to POSIXct format and should be converted to the local timezone.</p>
</td></tr>
<tr><td><code id="format_detects_+3A_var_frequency">var_frequency</code></td>
<td>
<p>the column name, in quotes, which identifies the maximum
temporal frequency at which transmitters in organisms emit a detectable
signal, only for use before JSATS filtering.</p>
</td></tr>
<tr><td><code id="format_detects_+3A_var_receiver_serial">var_receiver_serial</code></td>
<td>
<p>the column name, in quotes, which identifies the
serial number of the detection receiver</p>
</td></tr>
<tr><td><code id="format_detects_+3A_var_receiver_make">var_receiver_make</code></td>
<td>
<p>the column name, in quotes, which identifies the
make or brand of the detection receiver. Must be one of &quot;ATS&quot;, &quot;Lotek&quot;, or
&quot;Tekno&quot;, only for use before JSATS filtering.</p>
</td></tr>
<tr><td><code id="format_detects_+3A_local_time_zone">local_time_zone</code></td>
<td>
<p>the local timezone used for analyses. Uses tz database
names (e.g. &quot;America/Los_Angeles&quot; for Pacific Time)</p>
</td></tr>
<tr><td><code id="format_detects_+3A_time_format">time_format</code></td>
<td>
<p>a string value indicating the datetime format of all time
fields</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A standardized detection dataframe which can be read by filteRjsats
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#format the detection data
format_detects(data = raw_detections,
               var_Id = "tag_id",
               var_datetime_local = "local_time",
               var_receiver_serial = "serial",
               local_time_zone = "America/Los_Angeles",
               time_format = "%Y-%m-%d %H:%M:%S")
</code></pre>

<hr>
<h2 id='format_org'>Format Organism Data for add_org()</h2><span id='topic+format_org'></span>

<h3>Description</h3>

<p>This function takes a dataframe of org and tag data and renames the
columns to those expected by the add_org() function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_org(
  data,
  var_Id,
  var_release,
  var_tag_life,
  var_ping_rate,
  local_time_zone,
  time_format
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_org_+3A_data">data</code></td>
<td>
<p>a dataframe of org and tag data</p>
</td></tr>
<tr><td><code id="format_org_+3A_var_id">var_Id</code></td>
<td>
<p>the column name, in quotes, which identifies the individual
transmitter/tag/organism identifier.</p>
</td></tr>
<tr><td><code id="format_org_+3A_var_release">var_release</code></td>
<td>
<p>the column name, in quotes, which identifies the release
date and time in POSIX format and appropriate timezone</p>
</td></tr>
<tr><td><code id="format_org_+3A_var_tag_life">var_tag_life</code></td>
<td>
<p>the column name, in quotes, which identified the expected
tag life in days</p>
</td></tr>
<tr><td><code id="format_org_+3A_var_ping_rate">var_ping_rate</code></td>
<td>
<p>the column name, in quotes which identifies the expected
ping rate of the tag/transmitter</p>
</td></tr>
<tr><td><code id="format_org_+3A_local_time_zone">local_time_zone</code></td>
<td>
<p>the local timezone used for analyses. Uses tz database
names (e.g. &quot;America/Los_Angeles&quot; for Pacific Time)</p>
</td></tr>
<tr><td><code id="format_org_+3A_time_format">time_format</code></td>
<td>
<p>a string value indicating the datetime format of all time
fields</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe which contains fields renamed to match those required by
add_org() function
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Rename columns to work with functions
format_org(data = fish,
            var_Id = "TagCode",
            var_release = "Release_Date",
            var_tag_life = "TagLife",
            var_ping_rate = "PRI",
            local_time_zone = "America/Los_Angeles",
            time_format = "%Y-%m-%d %H:%M:%S")

</code></pre>

<hr>
<h2 id='format_receivers'>Format for Receiver data for filteRjsats</h2><span id='topic+format_receivers'></span>

<h3>Description</h3>

<p>This function takes a dataframe of receiver metadata and reformats specific
columns so that they can be read by the filtering functions in filteRjsats
package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_receivers(
  data,
  var_receiver_serial,
  var_receiver_make,
  var_receiver_deploy,
  var_receiver_retrieve,
  local_time_zone,
  time_format
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_receivers_+3A_data">data</code></td>
<td>
<p>the detection dataframe with columns for individual receivers,
tag IDs,datetime, and the expected ping rate.</p>
</td></tr>
<tr><td><code id="format_receivers_+3A_var_receiver_serial">var_receiver_serial</code></td>
<td>
<p>the column name, in quotes, which identifies the
serial number of the detection receiver</p>
</td></tr>
<tr><td><code id="format_receivers_+3A_var_receiver_make">var_receiver_make</code></td>
<td>
<p>the column name, in quotes, which identifies the
make or brand of the detection receiver. Must be one of &quot;ATS&quot;, &quot;Lotek&quot;, or
&quot;Tekno&quot;</p>
</td></tr>
<tr><td><code id="format_receivers_+3A_var_receiver_deploy">var_receiver_deploy</code></td>
<td>
<p>the column name, in quotes, which identifies the
date and time the receiver was deployed</p>
</td></tr>
<tr><td><code id="format_receivers_+3A_var_receiver_retrieve">var_receiver_retrieve</code></td>
<td>
<p>the column name, in quotes, which identifies the
date and time the receiver was retrieved</p>
</td></tr>
<tr><td><code id="format_receivers_+3A_local_time_zone">local_time_zone</code></td>
<td>
<p>the local timezone used for analyses. Uses tz database
names (e.g. &quot;America/Los_Angeles&quot; for Pacific Time)</p>
</td></tr>
<tr><td><code id="format_receivers_+3A_time_format">time_format</code></td>
<td>
<p>a string value indicating the datetime format of all time
fields</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe which contains fields renamed to match those required by
add_receivers() function
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Rename columns to work with functions
format_receivers(data = receivers,
                 var_receiver_serial = "receiver_serial_number",
                 var_receiver_make = "receiver_make",
                 var_receiver_deploy = "receiver_start",
                 var_receiver_retrieve = "receiver_end",
                 local_time_zone = "America/Los_Angeles",
                 time_format = "%m-%d-%Y %H:%M:%S")
</code></pre>

<hr>
<h2 id='opt_mbp'>Idenitfy the Optimum MBP based on Convergence Threshold</h2><span id='topic+opt_mbp'></span>

<h3>Description</h3>

<p>Takes dataframes created by 'renorm_SSR()' and 'conv_thresholds()' and
determines the corresponding &quot;optimum&quot; maximum blanking period (MBP) for each
convergence threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt_mbp(rSSR_df, thresh_values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt_mbp_+3A_rssr_df">rSSR_df</code></td>
<td>
<p>a dataframe created by created by renorm_SSRduration compare
showing the renormalized sum of squares of the residuals between one
potential blanking period and the next.</p>
</td></tr>
<tr><td><code id="opt_mbp_+3A_thresh_values">thresh_values</code></td>
<td>
<p>a dataframe created by conv_thresholds corresponding to
the chosen convergence thresholds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe showing the convergence value and corresponding optimal
maximum blanking period for each grouping.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Determine the optimum mbp
opt_mbp(rSSR_df = ex_rSSR,
        thresh_values = conv_thresh)
</code></pre>

<hr>
<h2 id='prefilter'>Apply the &quot;prefilter&quot; to a Detection Dataframe</h2><span id='topic+prefilter'></span>

<h3>Description</h3>

<p>This function takes a detection dataframe output from format_detects and
filters out multipath signals (signals which are bounced off of surfaces,
usually seen in underwater systems with hard surfaces which reflect sound)
and spurious signals which do not occur within a user defined time frame
of the last detection (12x the ping rate for organisms or 3x the ping rate
for beacons). Following this, the dataframe is standardized so
that all detection dataframes from any technology type are identical and
superfluous fields are removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prefilter(
  data,
  reference_tags,
  time_unit,
  multipath_time,
  org_ping_rate,
  beacon_ping
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prefilter_+3A_data">data</code></td>
<td>
<p>A dataframe which is the output from read_jstats() or
format_detects()</p>
</td></tr>
<tr><td><code id="prefilter_+3A_reference_tags">reference_tags</code></td>
<td>
<p>A vector of potential reference (beacon) tag IDs</p>
</td></tr>
<tr><td><code id="prefilter_+3A_time_unit">time_unit</code></td>
<td>
<p>The unit of time used for analyses (seconds, minutes, hours,
days, weeks, months)</p>
</td></tr>
<tr><td><code id="prefilter_+3A_multipath_time">multipath_time</code></td>
<td>
<p>A numeric maximum amount of time which must pass
between detections for a detection to be considered a &quot;true&quot;, not a bounced,
signal.</p>
</td></tr>
<tr><td><code id="prefilter_+3A_org_ping_rate">org_ping_rate</code></td>
<td>
<p>The expected time between transmissions emitted from
tags/transmitters implanted or attached to an organism</p>
</td></tr>
<tr><td><code id="prefilter_+3A_beacon_ping">beacon_ping</code></td>
<td>
<p>The expected time between transmissions emitted from
tags/transmitters used as beacon or reference tags to check receiver
functionality.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A standardized detection dataframe with multipath detects removed
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Run the prefilter on a set of raw detection data

#format the detection data
detects_formatted &lt;- format_detects(data = raw_detections,
                                    var_Id = "tag_id",
                                    var_datetime_local = "local_time",
                                    var_receiver_serial = "serial",
                                    local_time_zone = "America/Los_Angeles",
                                    time_format = "%Y-%m-%d %H:%M:%S")

#apply the prefilter
prefilter(data = detects_formatted,
          reference_tags = reftags,
          time_unit = "secs",
          multipath_time = 0.3,
          org_ping_rate = 3,
          beacon_ping = 30)
</code></pre>

<hr>
<h2 id='raw_detections'>Unfiltered detection data</h2><span id='topic+raw_detections'></span>

<h3>Description</h3>

<p>An example dataset of real acoustic telemetry detections of fish at several
receivers within the California Central Valley from 2021. These detections
have not been processed to remove false positives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_detections
</code></pre>


<h3>Format</h3>

<p>## 'raw_detections'
A data frame with 55,736 rows and 3 columns:
</p>

<dl>
<dt>serial</dt><dd><p>The serial number of the detecting receiver</p>
</dd>
<dt>local_time</dt><dd><p>the local time of the detection (tz = America/Los_Angeles)</p>
</dd>
<dt>tag_id</dt><dd><p>The hexadecimal acoustic tag ID code</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data collected by the California Department of Water Resources 2021
</p>

<hr>
<h2 id='receivers'>Receiver Data</h2><span id='topic+receivers'></span>

<h3>Description</h3>

<p>An example dataset of real acoustic telemetry receivers within the California
Central Valley in 2021. These receivers are only those which match the
serial numbers in companion dataset 'filtered_detections'. This data is
formatted to match the California Fish Tracking receiver metadata found here:
https://oceanview.pfeg.noaa.gov/CalFishTrack/.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>receivers
</code></pre>


<h3>Format</h3>

<p>## 'receivers'
A data frame with 7,240 rows and 60 columns:
</p>

<dl>
<dt>dep_id</dt><dd><p>A unique id is created for each receiver deployment</p>
</dd>
<dt>receiver_make</dt><dd><p>The brand of the acoustic receiver</p>
</dd>
<dt>receiver_serial_number</dt><dd><p>The serial number of the acoustic receiver</p>
</dd>
<dt>latitude</dt><dd><p>The decimal degree latitude (WGS1984) of the acoustic
receiver at deployment</p>
</dd>
<dt>longitude</dt><dd><p>The decimal degree longitude (WGS1984) of the acoustic
receiver at deployment</p>
</dd>
<dt>receiver_location</dt><dd><p>The site name of an individual receiver, often
more than one 'receiver_location' is found at a 'receiver_general_location'</p>
</dd>
<dt>receiver_general_location</dt><dd><p>The more general geographic name of the
location of the receiver</p>
</dd>
<dt>receiver_river_km</dt><dd><p>The number of river kilometers the receiver is
from the Golden Gate Bridge</p>
</dd>
<dt>receiver_start</dt><dd><p>The start time of the reciever (generally when it
was deployed)</p>
</dd>
<dt>receiver_end</dt><dd><p>The end time of the receiver (generally when it was
retrieved)</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://oceanview.pfeg.noaa.gov/CalFishTrack/pageRealtime_download.html&gt;
</p>

<hr>
<h2 id='reftags'>Example reference tags</h2><span id='topic+reftags'></span>

<h3>Description</h3>

<p>A vector of example reference tag codes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reftags
</code></pre>


<h3>Format</h3>

<p>A vector of example reference tag codes
</p>

<hr>
<h2 id='renorm_SSR'>Calculate the Renormalized Sum of Squared Residuals</h2><span id='topic+renorm_SSR'></span>

<h3>Description</h3>

<p>Takes a dataframe of the proportion of events created by each potential
blanking period which &quot;survived&quot; a certain time (t) created by
'duration_compare()' and calculates the sum of squares of the residuals
between one potential blanking period and the next. This result is then
renormalized by dividing the result by the number of events created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renorm_SSR(time_df, var_groups = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renorm_SSR_+3A_time_df">time_df</code></td>
<td>
<p>a dataframe created by duration compare showing the proportion
of events created by each potential blanking period which &quot;survived&quot; a
certain time (t)</p>
</td></tr>
<tr><td><code id="renorm_SSR_+3A_var_groups">var_groups</code></td>
<td>
<p>a single string or vector of strings of the columns which
should be used to group organisms. Common groupings are species and cohorts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of the renormalized sum of squared residuals between each
potential blanking period and the subsequent one.
</p>

<hr>
<h2 id='residence_plot'>Residency Survival Plot</h2><span id='topic+residence_plot'></span>

<h3>Description</h3>

<p>Takes a dataframe of the proportion of events created by each potential
blanking period which &quot;survived&quot; a certain time (t) and creates a plot.
Used to visually look for convergences between survival lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residence_plot(time_df, var_groups = NULL, time_unit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residence_plot_+3A_time_df">time_df</code></td>
<td>
<p>a dataframe created by duration compare showing the proportion
of events created by each potential blanking period which &quot;survived&quot; a
certain time (t)</p>
</td></tr>
<tr><td><code id="residence_plot_+3A_var_groups">var_groups</code></td>
<td>
<p>a single string or vector of strings of the columns which
should be used to group organisms. Common groupings are species and cohorts.</p>
</td></tr>
<tr><td><code id="residence_plot_+3A_time_unit">time_unit</code></td>
<td>
<p>the unit of time used to calculate durations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the proportion of events created by each potential
blanking period at each time (t).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Plot a comparison of the number of events longer than a given time `t`
residence_plot(time_df = time_test,
               var_groups = "fish_type",
               time_unit = "secs")
# Note: that the large number of lines extending past the largest Time
# indicates that a larger t is needed to ensure convergence
</code></pre>

<hr>
<h2 id='rSSR_plot'>Plot the rSSR Curve and Convergence Thresholds and Optimum MBP</h2><span id='topic+rSSR_plot'></span>

<h3>Description</h3>

<p>Using the dataframes produced by renorm_SSR and opt_mbp, plots the rSSR
curve, and all the convergence thresholds (horizontal lines) and
corresponding optimum mbps (vertical lines).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rSSR_plot(rSSR_df, opt_mbp_df, var_groups = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rSSR_plot_+3A_rssr_df">rSSR_df</code></td>
<td>
<p>a dataframe created by created by renorm_SSRduration compare
showing the renormalized sum of squares of the residuals between one
potential blanking period and the next.</p>
</td></tr>
<tr><td><code id="rSSR_plot_+3A_opt_mbp_df">opt_mbp_df</code></td>
<td>
<p>a dataframe created by opt_mbp showing the values for the
convergence thresholds and optimum mbps</p>
</td></tr>
<tr><td><code id="rSSR_plot_+3A_var_groups">var_groups</code></td>
<td>
<p>a single string or vector of strings of the columns which
should be used to group organisms. Common groupings are species and cohorts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the rSSR curve, convergence thresholds, and optimum mbps
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#plot the rSSR and log(rSSR) curves
rSSR_plot(rSSR_df = ex_rSSR,
          opt_mbp_df = ex_opt,
          var_groups = "fish_type")
</code></pre>

<hr>
<h2 id='Set_GVs'>Add in Global Variables</h2><span id='topic+Set_GVs'></span>

<h3>Description</h3>

<p>Sets all global variables to remove warnings in package build
</p>

<hr>
<h2 id='setup_blanking'>Setup a Detection Dataframe for Identifying the Optimal Blanking Period</h2><span id='topic+setup_blanking'></span>

<h3>Description</h3>

<p>Takes a dataframe with telemetry detection data and a list of potential
Blanking Period multipliers (n_val) and crosses them, duplicating the entire
dataframe by the length of n_val. This function is contained in blanking
event.This function can be slow depending on the size of the dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_blanking(
  data,
  var_site,
  var_Id,
  var_datetime,
  var_groups = NULL,
  var_ping_rate,
  n_val
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setup_blanking_+3A_data">data</code></td>
<td>
<p>the detection dataframe with columns for sites, tag IDs,
datetime, any grouping variables, and the expected ping rate.</p>
</td></tr>
<tr><td><code id="setup_blanking_+3A_var_site">var_site</code></td>
<td>
<p>the column name, in quotes, which identifies unique residency
sites, these sites should be as distinct as possible, such that it is
infrequent that organisms can be detected at two sites at a given time.</p>
</td></tr>
<tr><td><code id="setup_blanking_+3A_var_id">var_Id</code></td>
<td>
<p>the column name, in quotes, which identifies the individual
transmitter/tag/organism identifier.</p>
</td></tr>
<tr><td><code id="setup_blanking_+3A_var_datetime">var_datetime</code></td>
<td>
<p>the column name, in quotes, which identifies the date and
time of the detection event. This column should already have been converted
to POSIXct format.</p>
</td></tr>
<tr><td><code id="setup_blanking_+3A_var_groups">var_groups</code></td>
<td>
<p>a single string or vector of strings of the columns which
should be used to group animals. Common groupings are species and cohorts.</p>
</td></tr>
<tr><td><code id="setup_blanking_+3A_var_ping_rate">var_ping_rate</code></td>
<td>
<p>the column name, in quotes, which identifies the
temporal frequency at which the transmitter emits a detectable signal.</p>
</td></tr>
<tr><td><code id="setup_blanking_+3A_n_val">n_val</code></td>
<td>
<p>a vector sequence of integers which can be multiplied by the
ping rate to construct multiple potential blanking periods. The range and
step values for n should be selected based on prior knowledge about general
behavior habits of the study organism and the functionality of the equipment.
For more information, please refer to Capello et. al. 2015.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe which has been crossed with all integers in n_val
</p>


<h3>Examples</h3>

<pre><code class='language-R'># reduce dataframe for optimal blanking period analysis
setup_blanking(data = filtered_detections,
               var_Id = "Tag_Code",
               var_site = "receiver_general_location",
               var_datetime = "DateTime_Local",
               var_groups = "fish_type",
               var_ping_rate = "tag_pulse_rate_interval_nominal",
               n_val = c(1:3))
</code></pre>

<hr>
<h2 id='time_test'>Example Time Tests for Multi-blanked Detection Data</h2><span id='topic+time_test'></span>

<h3>Description</h3>

<p>Example output from the 'duration_compare()' function, testing the duration
of detection events found in 'blanked_detects'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_test
</code></pre>


<h3>Format</h3>

<p>## 'time_test'
A data frame with 333,400 rows and 4 columns:
</p>

<dl>
<dt>t</dt><dd><p>The time (in seconds) against which the duration was compared</p>
</dd>
<dt>fish_type</dt><dd><p>Generally a strain, run, and species of fish (e.g.
Nimbus Fall Chinook = Fall-run Chinook Salmon from Nimbus Hatchery)</p>
</dd>
<dt>mbp_n</dt><dd><p>The maximum blanking period (in seconds) used to create a
set of events</p>
</dd>
<dt>prop_res</dt><dd><p>The proportion of all events created with 'mbp_n' which have
a duration longer than time 't'.</p>
</dd>
</dl>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
