<!DOCTYPE html><html lang="en"><head><title>Help for package polykde</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {polykde}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#polykde-package'><p><code>polykde</code>: Polyspherical Kernel Density Estimation</p></a></li>
<li><a href='#angles_to_polysph'><p>Conversion between the angular and Cartesian coordinates of the</p>
polysphere</a></li>
<li><a href='#angles_to_sph'><p>Conversion between the angular and Cartesian coordinates of the</p>
hypersphere</a></li>
<li><a href='#angles_to_torus'><p>Conversion between the angular and Cartesian coordinates of the torus</p></a></li>
<li><a href='#bw_cv_kre_polysph'><p>Cross-validation bandwidth selection for polyspherical-on-scalar</p>
regression</a></li>
<li><a href='#bw_cv_polysph'><p>Cross-validation bandwidth selection for polyspherical kernel</p>
density estimator</a></li>
<li><a href='#bw_lcv_min_epa'><p>Minimum bandwidth allowed in likelihood cross-validation for</p>
Epanechnikov kernels</a></li>
<li><a href='#bw_mrot_polysph'><p>Marginal rule-of-thumb bandwidth selection for polyspherical kernel</p>
density estimator</a></li>
<li><a href='#bw_rot_polysph'><p>Rule-of-thumb bandwidth selection for polyspherical kernel</p>
density estimator</a></li>
<li><a href='#clean_euler_ridge'><p>Clean ridge points coming from spurious fits</p></a></li>
<li><a href='#comp_ind_dj'><p>Index of hyperspheres on a polysphere</p></a></li>
<li><a href='#curv_vmf_polysph'><p>Curvature of a polyspherical von Mises&ndash;Fisher density</p></a></li>
<li><a href='#d_unif_polysph'><p>Density of the uniform distribution on the polysphere</p></a></li>
<li><a href='#d_vmf_polysph'><p>Density of the product of von Mises&ndash;Fisher distributions on the</p>
polysphere</a></li>
<li><a href='#dist_polysph'><p>Polyspherical distance</p></a></li>
<li><a href='#eff_kern'><p>Polyspherical kernel moments and efficiencies</p></a></li>
<li><a href='#euler_ridge'><p>Euler algorithms for polyspherical density ridge estimation</p></a></li>
<li><a href='#grad_hess_kde_polysph'><p>Gradient and Hessian of the polyspherical kernel density estimator</p></a></li>
<li><a href='#hom_test_polysph'><p>Homogeneity test for several polyspherical samples</p></a></li>
<li><a href='#index_ridge'><p>Index a ridge curve, creating the Smoothed and Indexed Estimated</p>
Ridge (SIER)</a></li>
<li><a href='#interp_polysph'><p>Interpolation on the polysphere</p></a></li>
<li><a href='#kde_polysph'><p>Polyspherical kernel density estimator</p></a></li>
<li><a href='#kernel'><p>Kernels on the hypersphere and their derivatives</p></a></li>
<li><a href='#kre_polysph'><p>Local polynomial estimator for polyspherical-on-scalar regression</p></a></li>
<li><a href='#log_cv_kde_polysph'><p>Cross-validation for the polyspherical kernel density estimator</p></a></li>
<li><a href='#polylog_minus_exp_mu'><p>Polylogarithm function with negative argument</p></a></li>
<li><a href='#proj_grad_kde_polysph'><p>Projected gradient of the polyspherical kernel density estimator</p></a></li>
<li><a href='#proj_polysph'><p>Projection onto the polysphere</p></a></li>
<li><a href='#r_g_kern'><p>Sample from the angular kernel density</p></a></li>
<li><a href='#r_kde_polysph'><p>Sample from polyspherical kernel density estimator</p></a></li>
<li><a href='#r_kern_polysph'><p>Sample kernel-distributed polyspherical data</p></a></li>
<li><a href='#r_path_s1r'><p>Samplers of one-dimensional modes of variation for polyspherical data</p></a></li>
<li><a href='#r_unif_polysph'><p>Sample uniform polyspherical data</p></a></li>
<li><a href='#r_vmf_polysph'><p>Sample von Mises&ndash;Fisher distributed polyspherical data</p></a></li>
<li><a href='#softplus'><p>Stable computation of the softplus function</p></a></li>
<li><a href='#view_srep'><p>s-rep viewer</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Polyspherical Kernel Density Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-13</td>
</tr>
<tr>
<td>Description:</td>
<td>Kernel density estimation on the polysphere, hypersphere, and
    circle. Includes functions for density estimation, regression estimation,
    ridge estimation, bandwidth selection, kernels, samplers, and homogeneity
    tests. Companion package to García-Portugués and Meilán-Vila (2024)
    &lt;<a href="https://doi.org/10.48550%2FarXiv.2411.04166">doi:10.48550/arXiv.2411.04166</a>&gt; and García-Portugués and Meilán-Vila
    (2023) &lt;<a href="https://doi.org/10.1007%2F978-3-031-32729-2_4">doi:10.1007/978-3-031-32729-2_4</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, doFuture, foreach, future, gsl, movMF, progressr, Rcpp
(&ge; 1.0.8.3), RcppProgress, rotasym, sphunif</td>
</tr>
<tr>
<td>Suggests:</td>
<td>alphashape3d, DirStats, FixedPoint, ks, manipulate, numDeriv,
optimParallel, testthat, viridis, rgl, scatterplot3d, sdetorus,
smacof</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppProgress</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/egarpor/polykde">https://github.com/egarpor/polykde</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/egarpor/polykde/issues">https://github.com/egarpor/polykde/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-13 19:14:03 UTC; Eduardo</td>
</tr>
<tr>
<td>Author:</td>
<td>Eduardo García-Portugués
    <a href="https://orcid.org/0000-0002-9224-4111"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Andrea Meilán-Vila
    <a href="https://orcid.org/0000-0001-8537-9280"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eduardo García-Portugués &lt;edgarcia@est-econ.uc3m.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-17 11:00:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='polykde-package'><code>polykde</code>: Polyspherical Kernel Density Estimation</h2><span id='topic+polykde-package'></span><span id='topic+polykde'></span>

<h3>Description</h3>

<p>Kernel density estimation on the polysphere, hypersphere, and
circle. Includes functions for density estimation, regression estimation,
ridge estimation, bandwidth selection, kernels, samplers, and homogeneity
tests. Companion package to García-Portugués and Meilán-Vila (2024)
&lt;<a href="https://doi.org/10.48550/arXiv.2411.04166">doi:10.48550/arXiv.2411.04166</a>&gt; and García-Portugués and Meilán-Vila
(2023) &lt;<a href="https://doi.org/10.1007/978-3-031-32729-2_4">doi:10.1007/978-3-031-32729-2_4</a>&gt;.
</p>


<h3>Author(s)</h3>

<p>Eduardo García-Portugués.
</p>


<h3>References</h3>

<p>García-Portugués, E. and Meilán-Vila, A. (2024). Kernel density estimation
with polyspherical data and its applications. <em>arXiv:2411.04166</em>.
<a href="https://doi.org/10.48550/arXiv.2411.04166">doi:10.48550/arXiv.2411.04166</a>.
</p>
<p>García-Portugués, E. and Meilán-Vila, A. (2023). Hippocampus shape analysis
via skeletal models and kernel smoothing. In Larriba, Y. (Ed.),
<em>Statistical Methods at the Forefront of Biomedical Advances</em>,
pp. 63&ndash;82. Springer, Cham. <a href="https://doi.org/10.1007/978-3-031-32729-2_4">doi:10.1007/978-3-031-32729-2_4</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/egarpor/polykde">https://github.com/egarpor/polykde</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/egarpor/polykde/issues">https://github.com/egarpor/polykde/issues</a>
</p>
</li></ul>


<hr>
<h2 id='angles_to_polysph'>Conversion between the angular and Cartesian coordinates of the
polysphere</h2><span id='topic+angles_to_polysph'></span><span id='topic+polysph_to_angles'></span>

<h3>Description</h3>

<p>Obtain the angular coordinates of points on a polysphere
<code class="reqn">\mathcal{S}^{d_1}\times\cdots\times\mathcal{S}^{d_r}</code>, and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angles_to_polysph(theta, d)

polysph_to_angles(x, d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="angles_to_polysph_+3A_theta">theta</code></td>
<td>
<p>matrix of size <code>c(n, sum(d))</code> with the angles.</p>
</td></tr>
<tr><td><code id="angles_to_polysph_+3A_d">d</code></td>
<td>
<p>vector with the dimensions of the polysphere.</p>
</td></tr>
<tr><td><code id="angles_to_polysph_+3A_x">x</code></td>
<td>
<p>matrix of size <code>c(n, sum(d + 1))</code> with the Cartesian
coordinates on <code class="reqn">\mathcal{S}^{d_1}\times\cdots\times\mathcal{S}^{d_r}</code>.
Assumed to be of unit norm by blocks of coordinates in the rows.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p><code>angles_to_polysph</code>: the matrix <code>x</code>.
</p>
</li>
<li><p><code>polysph_to_angles</code>: the matrix <code>theta</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Check changes of coordinates
polysph_to_angles(angles_to_polysph(rep(pi / 2, 3), d = 2:1), d = 2:1)
angles_to_polysph(polysph_to_angles(x = c(0, 0, 1, 0, 1), d = 2:1), d = 2:1)
</code></pre>

<hr>
<h2 id='angles_to_sph'>Conversion between the angular and Cartesian coordinates of the
hypersphere</h2><span id='topic+angles_to_sph'></span><span id='topic+sph_to_angles'></span>

<h3>Description</h3>

<p>Transforms the angles <code class="reqn">(\theta_1,\ldots,\theta_d)</code> in
<code class="reqn">[0,\pi)^{d-1}\times[-\pi,\pi)</code> into the Cartesian coordinates
</p>
<p style="text-align: center;"><code class="reqn">(\cos(x_1),\sin(x_1)\cos(x_2),\ldots,
\sin(x_1)\cdots\sin(x_{d-1})\cos(x_d),
\sin(x_1)\cdots\sin(x_{d-1})\sin(x_d))</code>
</p>

<p>of the hypersphere <code class="reqn">\mathcal{S}^{d}</code>, and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angles_to_sph(theta)

sph_to_angles(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="angles_to_sph_+3A_theta">theta</code></td>
<td>
<p>matrix of size <code>c(n, d)</code> with the angles.</p>
</td></tr>
<tr><td><code id="angles_to_sph_+3A_x">x</code></td>
<td>
<p>matrix of size <code>c(n, d + 1)</code> with the Cartesian coordinates
on <code class="reqn">\mathcal{S}^{d}</code>. Assumed to be of unit norm by rows.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p><code>angles_to_sph</code>: the matrix <code>x</code>.
</p>
</li>
<li><p><code>sph_to_angles</code>: the matrix <code>theta</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Check changes of coordinates
sph_to_angles(angles_to_sph(c(pi / 2, 0, pi)))
sph_to_angles(angles_to_sph(rbind(c(pi / 2, 0, pi), c(pi, pi / 2, 0))))
angles_to_sph(sph_to_angles(c(0, sqrt(0.5), sqrt(0.1), sqrt(0.4))))
angles_to_sph(sph_to_angles(rbind(c(0, sqrt(0.5), sqrt(0.1), sqrt(0.4)),
                                  c(0, sqrt(0.5), sqrt(0.5), 0),
                                  c(0, 1, 0, 0),
                                  c(0, 0, 0, -1),
                                  c(0, 0, 1, 0))))
</code></pre>

<hr>
<h2 id='angles_to_torus'>Conversion between the angular and Cartesian coordinates of the torus</h2><span id='topic+angles_to_torus'></span><span id='topic+torus_to_angles'></span>

<h3>Description</h3>

<p>Transforms the angles <code class="reqn">(\theta_1,\ldots,\theta_d)</code> in
<code class="reqn">[-\pi,\pi)^d</code> into the Cartesian coordinates
</p>
<p style="text-align: center;"><code class="reqn">(\cos(x_1), \sin(x_1),\ldots,\cos(x_d), \sin(x_d))</code>
</p>

<p>of the torus <code class="reqn">(\mathcal{S}^1)^d</code>, and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angles_to_torus(theta)

torus_to_angles(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="angles_to_torus_+3A_theta">theta</code></td>
<td>
<p>matrix of size <code>c(n, d)</code> with the angles.</p>
</td></tr>
<tr><td><code id="angles_to_torus_+3A_x">x</code></td>
<td>
<p>matrix of size <code>c(n, 2 * d)</code> with the Cartesian coordinates on
<code class="reqn">(\mathcal{S}^1)^d</code>. Assumed to be of unit norm by pairs of coordinates
in the rows.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p><code>angles_to_torus</code>: the matrix <code>x</code>.
</p>
</li>
<li><p><code>torus_to_angles</code>: the matrix <code>theta</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Check changes of coordinates
torus_to_angles(angles_to_torus(c(0, pi / 3, pi / 2)))
torus_to_angles(angles_to_torus(rbind(c(0, pi / 3, pi / 2), c(0, 1, -2))))
angles_to_torus(torus_to_angles(c(0, 1, 1, 0)))
angles_to_torus(torus_to_angles(rbind(c(0, 1, 1, 0), c(0, 1, 0, 1))))
</code></pre>

<hr>
<h2 id='bw_cv_kre_polysph'>Cross-validation bandwidth selection for polyspherical-on-scalar
regression</h2><span id='topic+bw_cv_kre_polysph'></span>

<h3>Description</h3>

<p>Computes least squares cross-validation bandwidths for kernel
regression estimation with polyspherical response and scalar predictor.
It computes both the bandwidth that minimizes the cross-validation loss and
its &quot;one standard error&quot; variant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_cv_kre_polysph(X, Y, d, p = 0, h_grid = bw.nrd(X) * 10^seq(-2, 2, l =
  100), plot_cv = TRUE, fast = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bw_cv_kre_polysph_+3A_x">X</code></td>
<td>
<p>a vector of size <code>n</code> with the predictor sample.</p>
</td></tr>
<tr><td><code id="bw_cv_kre_polysph_+3A_y">Y</code></td>
<td>
<p>a matrix of size <code>c(n, sum(d) + r)</code> with the response sample
on the polysphere.</p>
</td></tr>
<tr><td><code id="bw_cv_kre_polysph_+3A_d">d</code></td>
<td>
<p>vector of size <code>r</code> with dimensions.</p>
</td></tr>
<tr><td><code id="bw_cv_kre_polysph_+3A_p">p</code></td>
<td>
<p>degree of local fit, either <code>0</code> or <code>1</code>. Defaults to
<code>0</code>.</p>
</td></tr>
<tr><td><code id="bw_cv_kre_polysph_+3A_h_grid">h_grid</code></td>
<td>
<p>bandwidth grid where to optimize the cross-validation loss.
Defaults to <code>bw.nrd(X) * 10^seq(-1, 1, l = 100)</code>.</p>
</td></tr>
<tr><td><code id="bw_cv_kre_polysph_+3A_plot_cv">plot_cv</code></td>
<td>
<p>plot the cross-validation loss curve? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="bw_cv_kre_polysph_+3A_fast">fast</code></td>
<td>
<p>use the faster and equivalent version of the cross-validation
loss? Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A similar output to <code>glmnet</code>'s <code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>
is returned.
</p>


<h3>Value</h3>

<p>A list with the following fields:
</p>
<table role = "presentation">
<tr><td><code>h_min</code></td>
<td>
<p>the bandwidth that minimizes the cross-validation loss.</p>
</td></tr>
<tr><td><code>h_1se</code></td>
<td>
<p>the largest bandwidth within one standard error of the
minimal cross-validation loss.</p>
</td></tr>
<tr><td><code>cvm</code></td>
<td>
<p>the mean of the cross-validation loss curve.</p>
</td></tr>
<tr><td><code>cvse</code></td>
<td>
<p>the standard error of the cross-validation loss curve.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 50
X &lt;- seq(0, 1, l = n)
Y &lt;- r_path_s2r(n = n, r = 1, sigma = 0.1, spiral = TRUE)[, , 1]
bw_cv_kre_polysph(X = X, Y = Y, d = 2, p = 0)
bw_cv_kre_polysph(X = X, Y = Y, d = 2, p = 1, fast = FALSE)
</code></pre>

<hr>
<h2 id='bw_cv_polysph'>Cross-validation bandwidth selection for polyspherical kernel
density estimator</h2><span id='topic+bw_cv_polysph'></span>

<h3>Description</h3>

<p>Likelihood Cross-Validation (LCV) and Least Squares
Cross-Validation (LSCV) bandwidth selection for the polyspherical kernel
density estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_cv_polysph(X, d, kernel = 1, kernel_type = 1, k = 10,
  type = c("LCV", "LSCV")[1], M = 10000, bw0 = NULL, na.rm = FALSE,
  ncores = 1, h_min = 0, upscale = FALSE, deriv = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bw_cv_polysph_+3A_x">X</code></td>
<td>
<p>a matrix of size <code>c(n, sum(d) + r)</code> with the sample.</p>
</td></tr>
<tr><td><code id="bw_cv_polysph_+3A_d">d</code></td>
<td>
<p>vector of size <code>r</code> with dimensions.</p>
</td></tr>
<tr><td><code id="bw_cv_polysph_+3A_kernel">kernel</code></td>
<td>
<p>kernel employed: <code>1</code> for von Mises&ndash;Fisher (default);
<code>2</code> for Epanechnikov; <code>3</code> for softplus.</p>
</td></tr>
<tr><td><code id="bw_cv_polysph_+3A_kernel_type">kernel_type</code></td>
<td>
<p>type of kernel employed: <code>1</code> for product kernel
(default); <code>2</code> for spherically symmetric kernel.</p>
</td></tr>
<tr><td><code id="bw_cv_polysph_+3A_k">k</code></td>
<td>
<p>softplus kernel parameter. Defaults to <code>10.0</code>.</p>
</td></tr>
<tr><td><code id="bw_cv_polysph_+3A_type">type</code></td>
<td>
<p>cross-validation type, either <code>"LCV"</code> (default) or
<code>"LSCV"</code>.</p>
</td></tr>
<tr><td><code id="bw_cv_polysph_+3A_m">M</code></td>
<td>
<p>Monte Carlo samples to use for approximating the integral in
the LSCV loss.</p>
</td></tr>
<tr><td><code id="bw_cv_polysph_+3A_bw0">bw0</code></td>
<td>
<p>initial bandwidth for minimizing the CV loss. If <code>NULL</code>, it
is computed internally by magnifying the <code><a href="#topic+bw_rot_polysph">bw_rot_polysph</a></code>
bandwidths by 50%.</p>
</td></tr>
<tr><td><code id="bw_cv_polysph_+3A_na.rm">na.rm</code></td>
<td>
<p>remove <code>NA</code>s in the objective function? Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bw_cv_polysph_+3A_ncores">ncores</code></td>
<td>
<p>number of cores used during the optimization. Defaults to
<code>1</code>.</p>
</td></tr>
<tr><td><code id="bw_cv_polysph_+3A_h_min">h_min</code></td>
<td>
<p>minimum h enforced (componentwise). Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="bw_cv_polysph_+3A_upscale">upscale</code></td>
<td>
<p>rescale the resulting bandwidths to work for derivative
estimation? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bw_cv_polysph_+3A_deriv">deriv</code></td>
<td>
<p>derivative order to perform the upscaling. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="bw_cv_polysph_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="stats.html#topic+optim">optim</a></code>
(if <code>ncores = 1</code>) or <code><a href="optimParallel.html#topic+optimParallel">optimParallel</a></code>
(if <code>ncores &gt; 1</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list as <code><a href="stats.html#topic+optim">optim</a></code> or
<code><a href="optimParallel.html#topic+optimParallel">optimParallel</a></code> output. In particular, the
optimal bandwidth is stored in <code>par</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 50
d &lt;- 1:2
kappa &lt;- rep(10, 2)
X &lt;- r_vmf_polysph(n = n, d = d, mu = r_unif_polysph(n = 1, d = d),
                   kappa = kappa)
bw_cv_polysph(X = X, d = d, type = "LCV")$par
bw_cv_polysph(X = X, d = d, type = "LSCV")$par
</code></pre>

<hr>
<h2 id='bw_lcv_min_epa'>Minimum bandwidth allowed in likelihood cross-validation for
Epanechnikov kernels</h2><span id='topic+bw_lcv_min_epa'></span>

<h3>Description</h3>

<p>This function computes the minimum bandwidth allowed in
likelihood cross-validation with Epanechnikov kernels, for a given dataset
and dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_lcv_min_epa(X, d, kernel_type = c("prod", "sph")[1])
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bw_lcv_min_epa_+3A_x">X</code></td>
<td>
<p>a matrix of size <code>c(n, sum(d) + r)</code> with the sample.</p>
</td></tr>
<tr><td><code id="bw_lcv_min_epa_+3A_d">d</code></td>
<td>
<p>vector of size <code>r</code> with dimensions.</p>
</td></tr>
<tr><td><code id="bw_lcv_min_epa_+3A_kernel_type">kernel_type</code></td>
<td>
<p>type of kernel employed: <code>1</code> for product kernel
(default); <code>2</code> for spherically symmetric kernel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The minimum bandwidth allowed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 5
d &lt;- 1:3
X &lt;- r_unif_polysph(n = n, d = d)
h_min &lt;- rep(bw_lcv_min_epa(X = X, d = d), length(d))
log_cv_kde_polysph(X = X, d = d, h = h_min - 1e-4, kernel = 2) # Problem
log_cv_kde_polysph(X = X, d = d, h = h_min + 1e-4, kernel = 2) # OK
</code></pre>

<hr>
<h2 id='bw_mrot_polysph'>Marginal rule-of-thumb bandwidth selection for polyspherical kernel
density estimator</h2><span id='topic+bw_mrot_polysph'></span>

<h3>Description</h3>

<p>Computes marginal (sphere by sphere) rule-of-thumb bandwidths
for the polyspherical kernel density estimator using a von Mises&ndash;Fisher
distribution as reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_mrot_polysph(X, d, kernel = 1, k = 10, upscale = FALSE, deriv = 0,
  kappa = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bw_mrot_polysph_+3A_x">X</code></td>
<td>
<p>a matrix of size <code>c(n, sum(d) + r)</code> with the sample.</p>
</td></tr>
<tr><td><code id="bw_mrot_polysph_+3A_d">d</code></td>
<td>
<p>vector of size <code>r</code> with dimensions.</p>
</td></tr>
<tr><td><code id="bw_mrot_polysph_+3A_kernel">kernel</code></td>
<td>
<p>kernel employed: <code>1</code> for von Mises&ndash;Fisher (default);
<code>2</code> for Epanechnikov; <code>3</code> for softplus.</p>
</td></tr>
<tr><td><code id="bw_mrot_polysph_+3A_k">k</code></td>
<td>
<p>softplus kernel parameter. Defaults to <code>10.0</code>.</p>
</td></tr>
<tr><td><code id="bw_mrot_polysph_+3A_upscale">upscale</code></td>
<td>
<p>rescale bandwidths to work on
<code class="reqn">\mathcal{S}^{d_1}\times\cdots\times \mathcal{S}^{d_r}</code> and for
derivative estimation?
Defaults to <code>FALSE</code>. If <code>upscale = 1</code>, the order <code>n</code> is
upscaled. If <code>upscale = 2</code>, then also the kernel constant is upscaled.</p>
</td></tr>
<tr><td><code id="bw_mrot_polysph_+3A_deriv">deriv</code></td>
<td>
<p>derivative order to perform the upscaling. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="bw_mrot_polysph_+3A_kappa">kappa</code></td>
<td>
<p>estimate of the concentration parameters. Computed if not
provided (default).</p>
</td></tr>
<tr><td><code id="bw_mrot_polysph_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="stats.html#topic+nlm">nlm</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of size <code>r</code> with the marginal optimal bandwidths.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
d &lt;- 1:2
kappa &lt;- rep(10, 2)
X &lt;- r_vmf_polysph(n = n, d = d, mu = r_unif_polysph(n = 1, d = d),
                   kappa = kappa)
bw_rot_polysph(X = X, d = d)$bw
bw_mrot_polysph(X = X, d = d)
</code></pre>

<hr>
<h2 id='bw_rot_polysph'>Rule-of-thumb bandwidth selection for polyspherical kernel
density estimator</h2><span id='topic+bw_rot_polysph'></span>

<h3>Description</h3>

<p>Computes the rule-of-thumb bandwidth for the polyspherical
kernel density estimator using a product of von Mises&ndash;Fisher distributions
as reference in the Asymptotic Mean Integrated Squared Error (AMISE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_rot_polysph(X, d, kernel = 1, kernel_type = c("prod", "sph")[1],
  bw0 = NULL, upscale = FALSE, deriv = 0, k = 10, kappa = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bw_rot_polysph_+3A_x">X</code></td>
<td>
<p>a matrix of size <code>c(n, sum(d) + r)</code> with the sample.</p>
</td></tr>
<tr><td><code id="bw_rot_polysph_+3A_d">d</code></td>
<td>
<p>vector of size <code>r</code> with dimensions.</p>
</td></tr>
<tr><td><code id="bw_rot_polysph_+3A_kernel">kernel</code></td>
<td>
<p>kernel employed: <code>1</code> for von Mises&ndash;Fisher (default);
<code>2</code> for Epanechnikov; <code>3</code> for softplus.</p>
</td></tr>
<tr><td><code id="bw_rot_polysph_+3A_kernel_type">kernel_type</code></td>
<td>
<p>type of kernel employed: <code>1</code> for product kernel
(default); <code>2</code> for spherically symmetric kernel.</p>
</td></tr>
<tr><td><code id="bw_rot_polysph_+3A_bw0">bw0</code></td>
<td>
<p>initial bandwidth for minimizing the CV loss. If <code>NULL</code>, it
is computed internally by magnifying the <code><a href="#topic+bw_mrot_polysph">bw_mrot_polysph</a></code>
bandwidths by 50%.</p>
</td></tr>
<tr><td><code id="bw_rot_polysph_+3A_upscale">upscale</code></td>
<td>
<p>rescale bandwidths to work on
<code class="reqn">\mathcal{S}^{d_1}\times\cdots\times \mathcal{S}^{d_r}</code> and for
derivative estimation?
Defaults to <code>FALSE</code>. If <code>upscale = 1</code>, the order <code>n</code> is
upscaled. If <code>upscale = 2</code>, then also the kernel constant is upscaled.</p>
</td></tr>
<tr><td><code id="bw_rot_polysph_+3A_deriv">deriv</code></td>
<td>
<p>derivative order to perform the upscaling. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="bw_rot_polysph_+3A_k">k</code></td>
<td>
<p>softplus kernel parameter. Defaults to <code>10.0</code>.</p>
</td></tr>
<tr><td><code id="bw_rot_polysph_+3A_kappa">kappa</code></td>
<td>
<p>estimate of the concentration parameters. Computed if not
provided (default).</p>
</td></tr>
<tr><td><code id="bw_rot_polysph_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="stats.html#topic+nlm">nlm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The selector assumes that the density curvature matrix
<code class="reqn">\boldsymbol{R}</code> of the unknown density is approximable by that of a
product of von Mises&ndash;Fisher densities,
<code class="reqn">\boldsymbol{R}(\boldsymbol{\kappa})</code>. The estimation of the
concentration parameters <code class="reqn">\boldsymbol{\kappa}</code> is done by maximum
likelihood.
</p>


<h3>Value</h3>

<p>A list with entries <code>bw</code> (optimal bandwidth) and <code>opt</code>,
the latter containing the output of <code><a href="stats.html#topic+nlm">nlm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
d &lt;- 1:2
kappa &lt;- rep(10, 2)
X &lt;- r_vmf_polysph(n = n, d = d, mu = r_unif_polysph(n = 1, d = d),
                   kappa = kappa)
bw_rot_polysph(X = X, d = d)$bw
</code></pre>

<hr>
<h2 id='clean_euler_ridge'>Clean ridge points coming from spurious fits</h2><span id='topic+clean_euler_ridge'></span>

<h3>Description</h3>

<p>Remove points from the ridge that are spurious. The cleaning is
done by removing end points in the Euler algorithm that did not converge,
do not have a negative second eigenvalue, or are in low-density regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_euler_ridge(e, X, p_out = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean_euler_ridge_+3A_e">e</code></td>
<td>
<p>outcome from <code><a href="#topic+euler_ridge">euler_ridge</a></code> or
<code><a href="#topic+parallel_euler_ridge">parallel_euler_ridge</a></code>.</p>
</td></tr>
<tr><td><code id="clean_euler_ridge_+3A_x">X</code></td>
<td>
<p>a matrix of size <code>c(n, sum(d) + r)</code> with the sample.</p>
</td></tr>
<tr><td><code id="clean_euler_ridge_+3A_p_out">p_out</code></td>
<td>
<p>proportion of outliers to remove. Defaults to <code>NULL</code> (no
cleaning).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the same structure as that returned by
<code><a href="#topic+euler_ridge">euler_ridge</a></code>, but with the spurious points. The removed points
are informed in the <code>removed</code> field.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Test on S^2 with some spurious end points

# Sample
r &lt;- 1
d &lt;- 2
n &lt;- 50
ind_dj &lt;- comp_ind_dj(d = d)
set.seed(987202226)
X &lt;- r_path_s2r(n = n, r = r, spiral = FALSE, Theta = cbind(c(1, 0, 0)),
                sigma = 0.2)[, , 1]
col_X &lt;- rep(gray(0), n)
col_X_alp &lt;- rep(gray(0, alpha = 0.25), n)

# Euler
h_rid &lt;- 0.5
h_eu &lt;- h_rid^2
N &lt;- 30
eps &lt;- 1e-6
X0 &lt;- r_unif_polysph(n = n, d = d)
Y &lt;- euler_ridge(x = X0, X = X, d = d, h = h_rid, h_euler = h_eu,
                 N = N, eps = eps, keep_paths = TRUE)
Y_removed &lt;- clean_euler_ridge(e = Y, X = X)$removed
col_X[Y_removed] &lt;- 2
col_X_alp[Y_removed] &lt;- 2

# Visualization
i &lt;- N # Between 1 and N
sc3 &lt;- scatterplot3d::scatterplot3d(Y$paths[, , 1], color = col_X_alp,
                                    pch = 19, xlim = c(-1, 1),
                                    ylim = c(-1, 1), zlim = c(-1, 1),
                                    xlab = "x", ylab = "y", zlab = "z")
sc3$points3d(rbind(Y$paths[, , i]), col = col_X, pch = 16, cex = 0.75)
for (k in seq_len(nrow(Y$paths))) {

  sc3$points3d(t(Y$paths[k, , ]), col = col_X_alp[k], type = "l")

}
</code></pre>

<hr>
<h2 id='comp_ind_dj'>Index of hyperspheres on a polysphere</h2><span id='topic+comp_ind_dj'></span>

<h3>Description</h3>

<p>Given Cartesian coordinates of polyspherical data, computes
the <code>0</code>-based indexes at which the Cartesian coordinates for each
hypersphere start and end.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_ind_dj(d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comp_ind_dj_+3A_d">d</code></td>
<td>
<p>vector of size <code>r</code> with dimensions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of size <code>sum(d) + 1</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example on (S^1)^3
d &lt;- c(1, 1, 1)
comp_ind_dj(d = d)
comp_ind_dj(d = d) + 1

# Example on S^1 x S^2
d &lt;- c(1, 2)
comp_ind_dj(d = d)
comp_ind_dj(d = d) + 1
</code></pre>

<hr>
<h2 id='curv_vmf_polysph'>Curvature of a polyspherical von Mises&ndash;Fisher density</h2><span id='topic+curv_vmf_polysph'></span>

<h3>Description</h3>

<p>Computes the curvature matrix
<code class="reqn">\boldsymbol{R}(\boldsymbol{\kappa})</code> of a product of von Mises&ndash;Fisher
densities on the polysphere. This curvature is used in the rule-of-thumb
selector <code><a href="#topic+bw_rot_polysph">bw_rot_polysph</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curv_vmf_polysph(kappa, d, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="curv_vmf_polysph_+3A_kappa">kappa</code></td>
<td>
<p>a vector of size <code>r</code> with the von Mises&ndash;Fisher
concentrations.</p>
</td></tr>
<tr><td><code id="curv_vmf_polysph_+3A_d">d</code></td>
<td>
<p>vector of size <code>r</code> with dimensions.</p>
</td></tr>
<tr><td><code id="curv_vmf_polysph_+3A_log">log</code></td>
<td>
<p>compute the (entrywise) logarithm of the curvature matrix?
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size <code>c(length(r), length(r))</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Curvature matrix
d &lt;- 2:4
kappa &lt;- 1:3
curv_vmf_polysph(kappa = kappa, d = d)
curv_vmf_polysph(kappa = kappa, d = d, log = TRUE)

# Equivalence on the sphere with DirStats::R_Psi_mixvmf
drop(curv_vmf_polysph(kappa = kappa[1], d = d[1]))
d[1]^2 * DirStats::R_Psi_mixvmf(q = d[1], mu = rbind(c(rep(0, d[1]), 1)),
                                kappa = kappa[1], p = 1)
</code></pre>

<hr>
<h2 id='d_unif_polysph'>Density of the uniform distribution on the polysphere</h2><span id='topic+d_unif_polysph'></span>

<h3>Description</h3>

<p>Computes the density of the uniform distribution on the
polysphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_unif_polysph(x, d, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="d_unif_polysph_+3A_x">x</code></td>
<td>
<p>a matrix of size <code>c(nx, sum(d) + r)</code> with the evaluation
points.</p>
</td></tr>
<tr><td><code id="d_unif_polysph_+3A_d">d</code></td>
<td>
<p>vector of size <code>r</code> with dimensions.</p>
</td></tr>
<tr><td><code id="d_unif_polysph_+3A_log">log</code></td>
<td>
<p>compute the logarithm of the density? Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of size <code>nx</code> with the evaluated density.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple check of integration on S^1 x S^2
d &lt;- c(1, 2)
x &lt;- r_unif_polysph(n = 1e4, d = d)
mean(1 / d_unif_polysph(x = x, d = d)) / prod(rotasym::w_p(p = d + 1))
</code></pre>

<hr>
<h2 id='d_vmf_polysph'>Density of the product of von Mises&ndash;Fisher distributions on the
polysphere</h2><span id='topic+d_vmf_polysph'></span>

<h3>Description</h3>

<p>Computes the density of the product of von Mises&ndash;Fisher
densities on the polysphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_vmf_polysph(x, d, mu, kappa, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="d_vmf_polysph_+3A_x">x</code></td>
<td>
<p>a matrix of size <code>c(nx, sum(d) + r)</code> with the evaluation
points.</p>
</td></tr>
<tr><td><code id="d_vmf_polysph_+3A_d">d</code></td>
<td>
<p>vector of size <code>r</code> with dimensions.</p>
</td></tr>
<tr><td><code id="d_vmf_polysph_+3A_mu">mu</code></td>
<td>
<p>a vector of size <code>sum(d) + r</code> with the concatenated von
Mises&ndash;Fisher means.</p>
</td></tr>
<tr><td><code id="d_vmf_polysph_+3A_kappa">kappa</code></td>
<td>
<p>a vector of size <code>r</code> with the von Mises&ndash;Fisher
concentrations.</p>
</td></tr>
<tr><td><code id="d_vmf_polysph_+3A_log">log</code></td>
<td>
<p>compute the logarithm of the density? Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of size <code>nx</code> with the evaluated density.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple check of integration on S^1 x S^2
d &lt;- c(1, 2)
mu &lt;- c(0, 1, 0, 1, 0)
kappa &lt;- c(1, 1)
x &lt;- r_vmf_polysph(n = 1e4, d = d, mu = mu, kappa = kappa)
mean(1 / d_vmf_polysph(x = x, d = d, mu = mu, kappa = kappa)) /
  prod(rotasym::w_p(p = d + 1))
</code></pre>

<hr>
<h2 id='dist_polysph'>Polyspherical distance</h2><span id='topic+dist_polysph'></span><span id='topic+dist_polysph_cross'></span><span id='topic+dist_polysph_matrix'></span>

<h3>Description</h3>

<p>Computation of the distance between points <code class="reqn">\boldsymbol{x}</code>
and <code class="reqn">\boldsymbol{y}</code> on the polysphere
<code class="reqn">\mathcal{S}^{d_1} \times \cdots \times \mathcal{S}^{d_r}</code>:
</p>
<p style="text-align: center;"><code class="reqn">\sqrt{\sum_{j=1}^r
d_{\mathcal{S}^{d_j}}(\boldsymbol{x}_j, \boldsymbol{y}_j)^2},</code>
</p>

<p>where <code class="reqn">d_{\mathcal{S}^{d_j}}(\boldsymbol{x}_j, \boldsymbol{y}_j)=
\cos^{-1}(\boldsymbol{x}_j' \boldsymbol{y}_j)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_polysph(x, y, ind_dj, norm_x = FALSE, norm_y = FALSE, std = TRUE)

dist_polysph_cross(x, y, ind_dj, norm_x = FALSE, norm_y = FALSE,
  std = TRUE)

dist_polysph_matrix(x, ind_dj, norm_x = FALSE, norm_y = FALSE,
  std = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_polysph_+3A_x">x</code></td>
<td>
<p>a matrix of size <code>c(n, sum(d) + r)</code>.</p>
</td></tr>
<tr><td><code id="dist_polysph_+3A_y">y</code></td>
<td>
<p>either a matrix of size <code>c(m, sum(d) + r)</code> or a vector of
length <code>sum(d) + r</code>.</p>
</td></tr>
<tr><td><code id="dist_polysph_+3A_ind_dj">ind_dj</code></td>
<td>
<p><code>0</code>-based index separating the blocks of spheres that
is computed with <code><a href="#topic+comp_ind_dj">comp_ind_dj</a></code>.</p>
</td></tr>
<tr><td><code id="dist_polysph_+3A_norm_x">norm_x</code>, <code id="dist_polysph_+3A_norm_y">norm_y</code></td>
<td>
<p>ensure a normalization of the data? Default to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="dist_polysph_+3A_std">std</code></td>
<td>
<p>standardize distance to <code class="reqn">[0,1]</code>? Uses that the maximum
distance is <code class="reqn">\sqrt{r}\pi</code>. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p><code>dist_polysph</code>: a vector of size <code>n</code> with the distances
between <code>x</code> and <code>y</code>.
</p>
</li>
<li><p><code>dist_polysph_matrix</code>: a matrix of size <code>c(n, n)</code> with the
pairwise distances of <code>x</code>.
</p>
</li>
<li><p><code>dist_polysph_cross</code>: a matrix of distances of size
<code>c(n, m)</code> with the cross distances between <code>x</code> and <code>y</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example on S^2 x S^3 x S^1
d &lt;- c(2, 3, 1)
ind_dj &lt;- comp_ind_dj(d)
n &lt;- 3
x &lt;- r_unif_polysph(n = n, d = d)
y &lt;- r_unif_polysph(n = n, d = d)

# Distances of x to y
dist_polysph(x = x, y = y, ind_dj = ind_dj, std = FALSE)
dist_polysph(x = x, y = y[1, , drop = FALSE], ind_dj = ind_dj, std = FALSE)

# Pairwise distance matrix of x
dist_polysph_matrix(x = x, ind_dj = ind_dj, std = FALSE)

# Cross distances between x and y
dist_polysph_cross(x = x, y = y, ind_dj = ind_dj, std = FALSE)
</code></pre>

<hr>
<h2 id='eff_kern'>Polyspherical kernel moments and efficiencies</h2><span id='topic+eff_kern'></span><span id='topic+b_d'></span><span id='topic+v_d'></span>

<h3>Description</h3>

<p>Computes moments of kernels on <code class="reqn">\mathcal{S}^{d_1} \times
\cdots \times \mathcal{S}^{d_r}</code> and efficiencies of kernels on
<code class="reqn">(\mathcal{S}^d)^r</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eff_kern(d, r, k = 10, kernel, kernel_type = c("prod", "sph")[1],
  kernel_ref = "2", kernel_ref_type = c("prod", "sph")[2], ...)

b_d(kernel, d, k = 10, kernel_type = c("prod", "sph")[1], ...)

v_d(kernel, d, k = 10, kernel_type = c("prod", "sph")[1], ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eff_kern_+3A_d">d</code></td>
<td>
<p>a scalar with the common dimension of each hypersphere
<code class="reqn">\mathcal{S}^d</code>.</p>
</td></tr>
<tr><td><code id="eff_kern_+3A_r">r</code></td>
<td>
<p>a scalar with the number of polyspheres of the same dimension.</p>
</td></tr>
<tr><td><code id="eff_kern_+3A_k">k</code></td>
<td>
<p>softplus kernel parameter. Defaults to <code>10.0</code>.</p>
</td></tr>
<tr><td><code id="eff_kern_+3A_kernel">kernel</code></td>
<td>
<p>kernel employed: <code>1</code> for von Mises&ndash;Fisher (default);
<code>2</code> for Epanechnikov; <code>3</code> for softplus.</p>
</td></tr>
<tr><td><code id="eff_kern_+3A_kernel_type">kernel_type</code></td>
<td>
<p>type of kernel. Must be either <code>"prod"</code> (product
kernel, default) or <code>"sph"</code> (spherically symmetric kernel).</p>
</td></tr>
<tr><td><code id="eff_kern_+3A_kernel_ref">kernel_ref</code></td>
<td>
<p>reference kernel to which compare the efficiency. Uses the
same codification as the <code>kernel</code>. Defaults to <code>"2"</code>.</p>
</td></tr>
<tr><td><code id="eff_kern_+3A_kernel_ref_type">kernel_ref_type</code></td>
<td>
<p>type of the reference kernel. Must be either
<code>"prod"</code> (product kernel) or <code>"sph"</code> (spherically symmetric kernel,
default).</p>
</td></tr>
<tr><td><code id="eff_kern_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="stats.html#topic+integrate">integrate</a></code>, such as
<code>upper</code>, <code>abs.tol</code>, <code>rel.tol</code>, etc.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p><code>b_d</code>: a vector with the first kernel moment on each hypersphere
(common if <code>kernel_type = "sph"</code>).
</p>
</li>
<li><p><code>v_d</code>: a vector with the second kernel moment if
<code>kernel_type = "prod"</code>, or a scalar if <code>kernel_type = "sph"</code>.
</p>
</li>
<li><p><code>eff_kern</code>: a scalar with the kernel efficiency.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Kernel moments
b_d(kernel = 2, d = c(2, 3), kernel_type = "prod")
v_d(kernel = 2, d = c(2, 3), kernel_type = "prod")
b_d(kernel = 2, d = c(2, 3), kernel_type = "sph")
v_d(kernel = 2, d = c(2, 3), kernel_type = "sph")

# Kernel efficiencies
eff_kern(d = 2, r = 1, kernel = "1")
eff_kern(d = 2, r = 1, kernel = "2")
eff_kern(d = 2, r = 1, k = 10, kernel = "3")
</code></pre>

<hr>
<h2 id='euler_ridge'>Euler algorithms for polyspherical density ridge estimation</h2><span id='topic+euler_ridge'></span><span id='topic+parallel_euler_ridge'></span><span id='topic+block_euler_ridge'></span>

<h3>Description</h3>

<p>Functions to perform density ridge estimation on the
polysphere <code class="reqn">\mathcal{S}^{d_1} \times \cdots \times \mathcal{S}^{d_r}</code>
through the Euler algorithm in standard, parallel, or block mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euler_ridge(x, X, d, h, h_euler = as.numeric(c()),
  weights = as.numeric(c()), wrt_unif = FALSE, normalized = TRUE,
  norm_x = FALSE, norm_X = FALSE, kernel = 1L, kernel_type = 1L,
  k = 10, N = 1000L, eps = 1e-05, keep_paths = FALSE,
  proj_alt = TRUE, fix_u1 = TRUE, sparse = FALSE, show_prog = TRUE,
  show_prog_j = FALSE)

parallel_euler_ridge(x, X, d, h, h_euler, N = 1000, eps = 1e-05,
  keep_paths = FALSE, cores = 1, ...)

block_euler_ridge(x, X, d, h, h_euler, ind_blocks, N = 1000, eps = 1e-05,
  keep_paths = FALSE, cores = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="euler_ridge_+3A_x">x</code></td>
<td>
<p>a matrix of size <code>c(nx, sum(d) + r)</code> with the starting points
for the Euler algorithm.</p>
</td></tr>
<tr><td><code id="euler_ridge_+3A_x">X</code></td>
<td>
<p>a matrix of size <code>c(n, sum(d) + r)</code> with the sample.</p>
</td></tr>
<tr><td><code id="euler_ridge_+3A_d">d</code></td>
<td>
<p>vector of size <code>r</code> with dimensions.</p>
</td></tr>
<tr><td><code id="euler_ridge_+3A_h">h</code></td>
<td>
<p>vector of size <code>r</code> with bandwidths.</p>
</td></tr>
<tr><td><code id="euler_ridge_+3A_h_euler">h_euler</code></td>
<td>
<p>vector of size <code>r</code> with the advance steps in the Euler
method. Set internally as <code>h</code> if not provided.</p>
</td></tr>
<tr><td><code id="euler_ridge_+3A_weights">weights</code></td>
<td>
<p>weights for each observation. If provided, a vector of size
<code>n</code> with the weights for multiplying each kernel. If not provided,
set internally to <code>rep(1 / n, n)</code>, which gives the standard estimator.</p>
</td></tr>
<tr><td><code id="euler_ridge_+3A_wrt_unif">wrt_unif</code></td>
<td>
<p>flag to return a density with respect to the uniform
measure. If <code>FALSE</code> (default), the density is with respect to the
Lebesgue measure.</p>
</td></tr>
<tr><td><code id="euler_ridge_+3A_normalized">normalized</code></td>
<td>
<p>flag to compute the normalizing constant of the kernel
and include it in the kernel density estimator. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="euler_ridge_+3A_norm_x">norm_x</code>, <code id="euler_ridge_+3A_norm_x">norm_X</code></td>
<td>
<p>ensure a normalization of the data? Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="euler_ridge_+3A_kernel">kernel</code></td>
<td>
<p>kernel employed: <code>1</code> for von Mises&ndash;Fisher (default);
<code>2</code> for Epanechnikov; <code>3</code> for softplus.</p>
</td></tr>
<tr><td><code id="euler_ridge_+3A_kernel_type">kernel_type</code></td>
<td>
<p>type of kernel employed: <code>1</code> for product kernel
(default); <code>2</code> for spherically symmetric kernel.</p>
</td></tr>
<tr><td><code id="euler_ridge_+3A_k">k</code></td>
<td>
<p>softplus kernel parameter. Defaults to <code>10.0</code>.</p>
</td></tr>
<tr><td><code id="euler_ridge_+3A_n">N</code></td>
<td>
<p>maximum number of Euler iterations. Defaults to <code>1e3</code>.</p>
</td></tr>
<tr><td><code id="euler_ridge_+3A_eps">eps</code></td>
<td>
<p>convergence tolerance. Defaults to <code>1e-5</code>.</p>
</td></tr>
<tr><td><code id="euler_ridge_+3A_keep_paths">keep_paths</code></td>
<td>
<p>keep the Euler paths to the ridge? Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="euler_ridge_+3A_proj_alt">proj_alt</code></td>
<td>
<p>alternative projection. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="euler_ridge_+3A_fix_u1">fix_u1</code></td>
<td>
<p>ensure the <code class="reqn">u_1</code> vector is different from <code class="reqn">x</code>?
Prevents the Euler algorithm to &quot;surf the ridge&quot;. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="euler_ridge_+3A_sparse">sparse</code></td>
<td>
<p>use a sparse eigendecomposition of the Hessian? Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="euler_ridge_+3A_show_prog">show_prog</code></td>
<td>
<p>display a progress bar for <code>x</code>? Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="euler_ridge_+3A_show_prog_j">show_prog_j</code></td>
<td>
<p>display a progress bar for <code>N</code>? Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="euler_ridge_+3A_cores">cores</code></td>
<td>
<p>cores to use. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="euler_ridge_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+euler_ridge">euler_ridge</a></code>.</p>
</td></tr>
<tr><td><code id="euler_ridge_+3A_ind_blocks">ind_blocks</code></td>
<td>
<p>indexes of the blocks, a vector or length <code>r</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>euler_ridge</code> is the main function to perform density ridge
estimation through the Euler algorithm from the starting values <code>x</code>
to initiate the ridge path. The function <code>euler_ridge_parallel</code>
parallelizes on the starting values <code>x</code>. The function
<code>euler_ridge_block</code> runs the Euler algorithm marginally in blocks
of hyperspheres, instead of jointly in the whole polysphere. This function
requires that all the dimensions are the same.
</p>


<h3>Value</h3>

<p>The three functions return a list with the following fields:
</p>
<table role = "presentation">
<tr><td><code>ridge_y</code></td>
<td>
<p>a matrix of size <code>c(nx, sum(d) + r)</code> with the end
points of Euler algorithm defining the estimated ridge.</p>
</td></tr>
<tr><td><code>lamb_norm_y</code></td>
<td>
<p>a matrix of size <code>c(nx, sum(d) + r)</code> with the
Hessian eigenvalues (largest to smallest) evaluated at end points.</p>
</td></tr>
<tr><td><code>log_dens_y</code></td>
<td>
<p>a column vector of size <code>c(nx, 1)</code> with the
logarithm of the density at end points.</p>
</td></tr>
<tr><td><code>paths</code></td>
<td>
<p>an array of size <code>c(nx, sum(d) + r, N + 1)</code> containing
the Euler paths.</p>
</td></tr>
<tr><td><code>start_x</code></td>
<td>
<p>a matrix of size <code>c(nx, sum(d) + r)</code> with the starting
points for the Euler algorithm.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>a column vector of size <code>c(nx, 1)</code> counting the iterations
required for each point.</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>
<p>a column vector of size <code>c(nx, 1)</code> with convergence flags.</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>vector <code>d</code>.</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>bandwidth used for the kernel density estimator.</p>
</td></tr>
<tr><td><code>error</code></td>
<td>
<p>a column vector of size <code>c(nx, 1)</code> indicating if errors
were found for each path.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Test on S^2 with a small circle trend

# Sample
r &lt;- 1
d &lt;- 2
n &lt;- 50
ind_dj &lt;- comp_ind_dj(d = d)
set.seed(987204452)
X &lt;- r_path_s2r(n = n, r = r, spiral = FALSE, Theta = cbind(c(1, 0, 0)),
                sigma = 0.35)[, , 1]
col_X_alp &lt;- viridis::viridis(n, alpha = 0.25)
col_X &lt;- viridis::viridis(n)

# Euler
h_rid &lt;- 0.5
h_eu &lt;- h_rid^2
N &lt;- 30
eps &lt;- 1e-6
Y &lt;- euler_ridge(x = X, X = X, d = d, h = h_rid, h_euler = h_eu,
                 N = N, eps = eps, keep_paths = TRUE)
Y

# Visualization
i &lt;- N # Between 1 and N
sc3 &lt;- scatterplot3d::scatterplot3d(Y$paths[, , 1], color = col_X_alp,
                                    pch = 19, xlim = c(-1, 1),
                                    ylim = c(-1, 1), zlim = c(-1, 1),
                                    xlab = "x", ylab = "y", zlab = "z")
sc3$points3d(rbind(Y$paths[, , i]), col = col_X, pch = 16, cex = 0.75)
for (k in seq_len(nrow(Y$paths))) {

  sc3$points3d(t(Y$paths[k, , ]), col = col_X_alp[k], type = "l")

}
</code></pre>

<hr>
<h2 id='grad_hess_kde_polysph'>Gradient and Hessian of the polyspherical kernel density estimator</h2><span id='topic+grad_hess_kde_polysph'></span>

<h3>Description</h3>

<p>Computes the gradient
<code class="reqn">\mathsf{D}\hat{f}(\boldsymbol{x};\boldsymbol{h})</code> and Hessian matrix
<code class="reqn">\mathsf{H}\hat{f}(\boldsymbol{x};\boldsymbol{h})</code> of the kernel density
estimator <code class="reqn">\hat{f}(\boldsymbol{x};\boldsymbol{h})</code> on the
polysphere <code class="reqn">\mathcal{S}^{d_1} \times \cdots \times \mathcal{S}^{d_r}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grad_hess_kde_polysph(x, X, d, h, weights = as.numeric(c()),
  projected = TRUE, proj_alt = TRUE, norm_grad_hess = FALSE,
  log = FALSE, wrt_unif = FALSE, normalized = TRUE, norm_x = FALSE,
  norm_X = FALSE, kernel = 1L, kernel_type = 1L, k = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grad_hess_kde_polysph_+3A_x">x</code></td>
<td>
<p>a matrix of size <code>c(nx, sum(d) + r)</code> with the evaluation
points.</p>
</td></tr>
<tr><td><code id="grad_hess_kde_polysph_+3A_x">X</code></td>
<td>
<p>a matrix of size <code>c(n, sum(d) + r)</code> with the sample.</p>
</td></tr>
<tr><td><code id="grad_hess_kde_polysph_+3A_d">d</code></td>
<td>
<p>vector of size <code>r</code> with dimensions.</p>
</td></tr>
<tr><td><code id="grad_hess_kde_polysph_+3A_h">h</code></td>
<td>
<p>vector of size <code>r</code> with bandwidths.</p>
</td></tr>
<tr><td><code id="grad_hess_kde_polysph_+3A_weights">weights</code></td>
<td>
<p>weights for each observation. If provided, a vector of size
<code>n</code> with the weights for multiplying each kernel. If not provided,
set internally to <code>rep(1 / n, n)</code>, which gives the standard estimator.</p>
</td></tr>
<tr><td><code id="grad_hess_kde_polysph_+3A_projected">projected</code></td>
<td>
<p>compute the <em>projected</em> gradient and Hessian that
accounts for the radial projection? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="grad_hess_kde_polysph_+3A_proj_alt">proj_alt</code></td>
<td>
<p>alternative projection. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="grad_hess_kde_polysph_+3A_norm_grad_hess">norm_grad_hess</code></td>
<td>
<p>normalize the gradient and Hessian dividing by the
kernel density estimator? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="grad_hess_kde_polysph_+3A_log">log</code></td>
<td>
<p>compute the logarithm of the density? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="grad_hess_kde_polysph_+3A_wrt_unif">wrt_unif</code></td>
<td>
<p>flag to return a density with respect to the uniform
measure. If <code>FALSE</code> (default), the density is with respect to the
Lebesgue measure.</p>
</td></tr>
<tr><td><code id="grad_hess_kde_polysph_+3A_normalized">normalized</code></td>
<td>
<p>flag to compute the normalizing constant of the kernel
and include it in the kernel density estimator. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="grad_hess_kde_polysph_+3A_norm_x">norm_x</code>, <code id="grad_hess_kde_polysph_+3A_norm_x">norm_X</code></td>
<td>
<p>ensure a normalization of the data? Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="grad_hess_kde_polysph_+3A_kernel">kernel</code></td>
<td>
<p>kernel employed: <code>1</code> for von Mises&ndash;Fisher (default);
<code>2</code> for Epanechnikov; <code>3</code> for softplus.</p>
</td></tr>
<tr><td><code id="grad_hess_kde_polysph_+3A_kernel_type">kernel_type</code></td>
<td>
<p>type of kernel employed: <code>1</code> for product kernel
(default); <code>2</code> for spherically symmetric kernel.</p>
</td></tr>
<tr><td><code id="grad_hess_kde_polysph_+3A_k">k</code></td>
<td>
<p>softplus kernel parameter. Defaults to <code>10.0</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>dens</code></td>
<td>
<p>a column vector of size <code>c(nx, 1)</code> with the kernel
density estimator evaluated at <code>x</code>.</p>
</td></tr>
<tr><td><code>grad</code></td>
<td>
<p>a matrix of size <code>c(nx, sum(d) + r)</code> with the gradient of
the kernel density estimator evaluated at <code>x</code>.</p>
</td></tr>
<tr><td><code>hess</code></td>
<td>
<p>an array of size <code>c(nx, sum(d) + r, sum(d) + r)</code> with the
Hessian matrix of the kernel density estimator evaluated at <code>x</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Simple check on (S^1)^2
n &lt;- 3
d &lt;- c(1, 1)
mu &lt;- c(0, 1, 0, 1)
kappa &lt;- c(5, 5)
h &lt;- c(0.2, 0.2)
X &lt;- r_vmf_polysph(n = n, d = d, mu = mu, kappa = kappa)
grh &lt;- grad_hess_kde_polysph(x = X, X = X, d = d, h = h)
str(grh)
grh
</code></pre>

<hr>
<h2 id='hom_test_polysph'>Homogeneity test for several polyspherical samples</h2><span id='topic+hom_test_polysph'></span>

<h3>Description</h3>

<p>Permutation tests for the equality of distributions of two or
<code class="reqn">k</code> samples of data on <code class="reqn">\mathcal{S}^{d_1} \times \cdots \times
\mathcal{S}^{d_r}</code>. The Jensen&ndash;Shannon distance is used to construct a test
statistic measuring the discrepancy between the <code class="reqn">k</code> kernel density
estimators. Tests based on the mean and scatter matrices are also available,
but for only two samples (<code class="reqn">k=2</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hom_test_polysph(X, d, labels, type = c("jsd", "mean", "scatter", "hd")[1],
  h = NULL, kernel = 1, kernel_type = 1, k = 10, B = 1000,
  M = 10000, plot_boot = FALSE, seed_jsd = NULL, cv_jsd = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hom_test_polysph_+3A_x">X</code></td>
<td>
<p>a matrix of size <code>c(n, sum(d) + r)</code> with the sample.</p>
</td></tr>
<tr><td><code id="hom_test_polysph_+3A_d">d</code></td>
<td>
<p>vector of size <code>r</code> with dimensions.</p>
</td></tr>
<tr><td><code id="hom_test_polysph_+3A_labels">labels</code></td>
<td>
<p>vector with <code>k</code> different levels indicating the group.</p>
</td></tr>
<tr><td><code id="hom_test_polysph_+3A_type">type</code></td>
<td>
<p>kind of test to be performed: <code>"jsd"</code> (default), a test
comparing the kernel density estimators for <code class="reqn">k</code> groups using the
Jensen&ndash;Shannon distance; <code>"mean"</code>, a simple test for the equality of
two means (non-omnibus for testing homogeneity); <code>"scatter"</code>, a simple
test for the equality of two scatter matrices; <code>"hd"</code>, a test comparing
the kernel density estimators for two groups using the Hellinger distance.</p>
</td></tr>
<tr><td><code id="hom_test_polysph_+3A_h">h</code></td>
<td>
<p>vector of size <code>r</code> with bandwidths.</p>
</td></tr>
<tr><td><code id="hom_test_polysph_+3A_kernel">kernel</code></td>
<td>
<p>kernel employed: <code>1</code> for von Mises&ndash;Fisher (default);
<code>2</code> for Epanechnikov; <code>3</code> for softplus.</p>
</td></tr>
<tr><td><code id="hom_test_polysph_+3A_kernel_type">kernel_type</code></td>
<td>
<p>type of kernel employed: <code>1</code> for product kernel
(default); <code>2</code> for spherically symmetric kernel.</p>
</td></tr>
<tr><td><code id="hom_test_polysph_+3A_k">k</code></td>
<td>
<p>softplus kernel parameter. Defaults to <code>10.0</code>.</p>
</td></tr>
<tr><td><code id="hom_test_polysph_+3A_b">B</code></td>
<td>
<p>number of permutations to use. Defaults to <code>1e3</code>.</p>
</td></tr>
<tr><td><code id="hom_test_polysph_+3A_m">M</code></td>
<td>
<p>number of Monte Carlo replicates to use when approximating the
Hellinger/Jensen&ndash;Shannon distance. Defaults to <code>1e4</code>.</p>
</td></tr>
<tr><td><code id="hom_test_polysph_+3A_plot_boot">plot_boot</code></td>
<td>
<p>flag to display a graphical output of the test decision.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="hom_test_polysph_+3A_seed_jsd">seed_jsd</code></td>
<td>
<p>seed for the Monte Carlo simulations used to estimate the
integrals in the Jensen&ndash;Shannon distance.</p>
</td></tr>
<tr><td><code id="hom_test_polysph_+3A_cv_jsd">cv_jsd</code></td>
<td>
<p>use cross-validation to approximate the Jensen&ndash;Shannon
distance? Does not require Monte Carlo. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only <code>type = "jsd"</code> is able to deal with <code class="reqn">k &gt; 2</code>.
</p>
<p>The <code>"jsd"</code> statistic is the Jensen&ndash;Shannon divergence. This statistic
is bounded in <code class="reqn">[0, 1]</code>. The <code>"mean"</code> statistic measures the maximum
(chordal) distance between the estimated group means. This statistic is
bounded in <code class="reqn">[0, 1]</code>. The <code>"scatter"</code> statistic measures the maximum
affine invariant Riemannian metric between the estimated scatter matrices.
The <code>"hd"</code> statistic computes a monotonic transformation of the
Hellinger distance, which is the Bhattacharyya divergence (or coefficient).
</p>


<h3>Value</h3>

<p>An object of class <code>"htest"</code> with the following fields:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>statistic_perm</code></td>
<td>
<p>the <code>B</code> permuted statistics.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>a table with the sample sizes per group.</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>bandwidths used.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>number of permutations.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the kind of test performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Two-sample case

# H0 holds
n &lt;- c(50, 100)
X1 &lt;- rotasym::r_vMF(n = n[1], mu = c(0, 0, 1), kappa = 1)
X2 &lt;- rotasym::r_vMF(n = n[2], mu = c(0, 0, 1), kappa = 1)
hom_test_polysph(X = rbind(X1, X2), labels = rep(1:2, times = n),
                 d = 2, type = "jsd", h = 0.5)

# H0 does not hold
X2 &lt;- rotasym::r_vMF(n = n[2], mu = c(0, 1, 0), kappa = 2)
hom_test_polysph(X = rbind(X1, X2), labels = rep(1:2, times = n),
                 d = 2, type = "jsd", h = 0.5)

## k-sample case

# H0 holds
n &lt;- c(50, 100, 50)
X1 &lt;- rotasym::r_vMF(n = n[1], mu = c(0, 0, 1), kappa = 1)
X2 &lt;- rotasym::r_vMF(n = n[2], mu = c(0, 0, 1), kappa = 1)
X3 &lt;- rotasym::r_vMF(n = n[3], mu = c(0, 0, 1), kappa = 1)
hom_test_polysph(X = rbind(X1, X2, X3), labels = rep(1:3, times = n),
                 d = 2, type = "jsd", h = 0.5)

# H0 does not hold
X3 &lt;- rotasym::r_vMF(n = n[3], mu = c(0, 1, 0), kappa = 2)
hom_test_polysph(X = rbind(X1, X2, X3), labels = rep(1:3, times = n),
                 d = 2, type = "jsd", h = 0.5)

</code></pre>

<hr>
<h2 id='index_ridge'>Index a ridge curve, creating the Smoothed and Indexed Estimated
Ridge (SIER)</h2><span id='topic+index_ridge'></span>

<h3>Description</h3>

<p>Indexing of an unordered collection of points defining the
estimated density ridge curve. The indexing is done by a multidimensional
scaling map to the real line, while the smoothing is done by local polynomial
regression for polyspherical-on-scalar regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index_ridge(endpoints, X, d, l_index = 1000, f_index = 2,
  probs_scores = seq(0, 1, l = 101), verbose = FALSE, type_bwd = c("1se",
  "min")[1], p = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="index_ridge_+3A_endpoints">endpoints</code></td>
<td>
<p>a matrix of size <code>c(nx, sum(d) + r)</code> with the end
points of the ridge algorithm to be indexed.</p>
</td></tr>
<tr><td><code id="index_ridge_+3A_x">X</code></td>
<td>
<p>a matrix of size <code>c(n, sum(d) + r)</code> with the sample.</p>
</td></tr>
<tr><td><code id="index_ridge_+3A_d">d</code></td>
<td>
<p>vector of size <code>r</code> with dimensions.</p>
</td></tr>
<tr><td><code id="index_ridge_+3A_l_index">l_index</code></td>
<td>
<p>length of the grid index used for finding projections.
Defaults to <code>1e3</code>.</p>
</td></tr>
<tr><td><code id="index_ridge_+3A_f_index">f_index</code></td>
<td>
<p>factor with the range of the grid for finding ridge
projections. Defaults to <code>2</code>, which is twice the range of MDS indexes.</p>
</td></tr>
<tr><td><code id="index_ridge_+3A_probs_scores">probs_scores</code></td>
<td>
<p>probabilities for indexing the ridge on the
<code>probs_scores</code>-quantiles of the scores. Defaults to
<code>seq(0, 1, l = 101)</code>.</p>
</td></tr>
<tr><td><code id="index_ridge_+3A_verbose">verbose</code></td>
<td>
<p>show diagnostic plots? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="index_ridge_+3A_type_bwd">type_bwd</code></td>
<td>
<p>type of cross-validation bandwidth for Nadaraya&ndash;Watson,
either <code>"min"</code> (minimizer of the cross-validation loss) or <code>"1se"</code>
(the &quot;one standard error rule&quot;, smoother). Defaults to <code>"1se"</code>.</p>
</td></tr>
<tr><td><code id="index_ridge_+3A_p">p</code></td>
<td>
<p>degree of local fit, either <code>0</code> or <code>1</code>. Defaults to
<code>0</code>.</p>
</td></tr>
<tr><td><code id="index_ridge_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+bw_cv_kre_polysph">bw_cv_kre_polysph</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Indexing is designed to work with collection of ridge points that
admit a linear ordering, so that mapping to the real line by multidimensional
scaling is adequate. The indexing will not work properly if the ridge points
define a closed curve.
</p>


<h3>Value</h3>

<p>A list with the following fields:
</p>
<table role = "presentation">
<tr><td><code>scores_X</code></td>
<td>
<p>a vector of size <code>n</code> with the SIER scores for <code>X</code>.</p>
</td></tr>
<tr><td><code>projs_X</code></td>
<td>
<p>a matrix of size <code>c(n, sum(d) + r)</code> with the
projections of <code>X</code> onto the SIER.</p>
</td></tr>
<tr><td><code>ord_X</code></td>
<td>
<p>a vector of size <code>n</code> with the ordering of <code>X</code> induced
by the SIER scores.</p>
</td></tr>
<tr><td><code>scores_grid</code></td>
<td>
<p>a vector of size <code>length(probs_scores)</code> with score
quantiles associated to the probabilities <code>probs_scores</code>.</p>
</td></tr>
<tr><td><code>ridge_grid</code></td>
<td>
<p>a vector of size <code>length(probs_scores)</code> with the
SIER evaluated at <code>scores_grid</code>.</p>
</td></tr>
<tr><td><code>mds_index</code></td>
<td>
<p>a vector of size <code>nx</code> with the multidimensional
scaling indexes.</p>
</td></tr>
<tr><td><code>ridge_fun</code></td>
<td>
<p>a function that parametrizes the SIER.</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>bandwidth used for the local polynomial regression.</p>
</td></tr>
<tr><td><code>probs_scores</code></td>
<td>
<p>object <code>probs_scores</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Test on (S^1)^2

# Sample
set.seed(132121)
r &lt;- 2
d &lt;- rep(1, r)
n &lt;- 200
ind_dj &lt;- comp_ind_dj(d = d)
Th &lt;- matrix(runif(n = n * (r - 1), min = -pi / 2, max = pi / 2),
             nrow = n, ncol = r - 1)
Th[, r - 1] &lt;- sort(Th[, r - 1])
Th &lt;- cbind(Th, sdetorus::toPiInt(
  pi + Th[, r - 1] + runif(n = n, min = -pi / 4, max = pi / 4)))
X &lt;- angles_to_torus(Th)
col_X_alp &lt;- viridis::viridis(n, alpha = 0.25)
col_X &lt;- viridis::viridis(n)

# Euler
h_rid &lt;- rep(0.75, r)
h_eu &lt;- h_rid^2
N &lt;- 200
eps &lt;- 1e-6
Y &lt;- euler_ridge(x = X, X = X, d = d, h = h_rid, h_euler = h_eu,
                 N = N, eps = eps, keep_paths = TRUE)

# Visualization
i &lt;- N # Between 1 and N
plot(rbind(torus_to_angles(Y$paths[, , 1])), col = col_X_alp, pch = 19,
     axes = FALSE, xlim = c(-pi, pi), ylim = c(-pi, pi),
     xlab = "", ylab = "")
points(rbind(torus_to_angles(Y$paths[, , i])), col = col_X, pch = 16,
       cex = 0.75)
sdetorus::torusAxis(1:2)
for (k in seq_len(nrow(Y$paths))) {

  xy &lt;- torus_to_angles(t(Y$paths[k, , ]))
  sdetorus::linesTorus(x = xy[, 1], y = xy[, 2], col = col_X_alp[k])

}

# SIER
ind_rid &lt;- index_ridge(endpoints = Y$ridge_y, X = X, d = d,
                       probs_scores = seq(0, 1, l = 50))
xy &lt;- torus_to_angles(ind_rid$ridge_grid)
sdetorus::linesTorus(x = xy[, 1], y = xy[, 2], col = 2, lwd = 2)
points(torus_to_angles(ind_rid$ridge_fun(quantile(ind_rid$scores_grid))),
       col = 4, pch = 19)

# Scores
plot(density(ind_rid$scores_X), type = "l", xlab = "Scores",
     ylab = "Density", main = "Scores density")
for (i in 1:n) rug(ind_rid$scores_X[i], col = col_X[i])
</code></pre>

<hr>
<h2 id='interp_polysph'>Interpolation on the polysphere</h2><span id='topic+interp_polysph'></span>

<h3>Description</h3>

<p>Creates a sequence of points on the polysphere linearly
interpolating between two points extrinsically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interp_polysph(x, y, ind_dj, N = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interp_polysph_+3A_x">x</code></td>
<td>
<p>a vector of size <code>sum(d) + r</code> with the begin point.</p>
</td></tr>
<tr><td><code id="interp_polysph_+3A_y">y</code></td>
<td>
<p>a vector of size <code>sum(d) + r</code> with the end point.</p>
</td></tr>
<tr><td><code id="interp_polysph_+3A_ind_dj">ind_dj</code></td>
<td>
<p><code>0</code>-based index separating the blocks of spheres that
is computed with <code><a href="#topic+comp_ind_dj">comp_ind_dj</a></code>.</p>
</td></tr>
<tr><td><code id="interp_polysph_+3A_n">N</code></td>
<td>
<p>number of points in the sequence. Defaults to <code>10</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size <code>c(N, sum(d) + r)</code> with the interpolation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>interp_polysph(x = c(1, 0), y = c(0, 1), ind_dj = comp_ind_dj(d = 1))
</code></pre>

<hr>
<h2 id='kde_polysph'>Polyspherical kernel density estimator</h2><span id='topic+kde_polysph'></span>

<h3>Description</h3>

<p>Computes the kernel density estimator for data on the
polysphere <code class="reqn">\mathcal{S}^{d_1} \times \cdots \times \mathcal{S}^{d_r}</code>.
Given a sample <code class="reqn">\boldsymbol{X}_1,\ldots,\boldsymbol{X}_n</code>, this
estimator is
</p>
<p style="text-align: center;"><code class="reqn">\hat{f}(\boldsymbol{x};\boldsymbol{h})=\sum_{i=1}^n
L_{\boldsymbol{h}}(\boldsymbol{x},\boldsymbol{X}_i)</code>
</p>

<p>for a kernel <code class="reqn">L</code> and a vector of bandwidths <code class="reqn">\boldsymbol{h}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kde_polysph(x, X, d, h, weights = as.numeric(c()), log = FALSE,
  wrt_unif = FALSE, normalized = TRUE, intrinsic = FALSE,
  norm_x = FALSE, norm_X = FALSE, kernel = 1L, kernel_type = 1L,
  k = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kde_polysph_+3A_x">x</code></td>
<td>
<p>a matrix of size <code>c(nx, sum(d) + r)</code> with the evaluation
points.</p>
</td></tr>
<tr><td><code id="kde_polysph_+3A_x">X</code></td>
<td>
<p>a matrix of size <code>c(n, sum(d) + r)</code> with the sample.</p>
</td></tr>
<tr><td><code id="kde_polysph_+3A_d">d</code></td>
<td>
<p>vector of size <code>r</code> with dimensions.</p>
</td></tr>
<tr><td><code id="kde_polysph_+3A_h">h</code></td>
<td>
<p>vector of size <code>r</code> with bandwidths.</p>
</td></tr>
<tr><td><code id="kde_polysph_+3A_weights">weights</code></td>
<td>
<p>weights for each observation. If provided, a vector of size
<code>n</code> with the weights for multiplying each kernel. If not provided,
set internally to <code>rep(1 / n, n)</code>, which gives the standard estimator.</p>
</td></tr>
<tr><td><code id="kde_polysph_+3A_log">log</code></td>
<td>
<p>compute the logarithm of the density? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="kde_polysph_+3A_wrt_unif">wrt_unif</code></td>
<td>
<p>flag to return a density with respect to the uniform
measure. If <code>FALSE</code> (default), the density is with respect to the
Lebesgue measure.</p>
</td></tr>
<tr><td><code id="kde_polysph_+3A_normalized">normalized</code></td>
<td>
<p>flag to compute the normalizing constant of the kernel
and include it in the kernel density estimator. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="kde_polysph_+3A_intrinsic">intrinsic</code></td>
<td>
<p>use the intrinsic distance, instead of the
extrinsic-chordal distance, in the kernel? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="kde_polysph_+3A_norm_x">norm_x</code>, <code id="kde_polysph_+3A_norm_x">norm_X</code></td>
<td>
<p>ensure a normalization of the data? Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="kde_polysph_+3A_kernel">kernel</code></td>
<td>
<p>kernel employed: <code>1</code> for von Mises&ndash;Fisher (default);
<code>2</code> for Epanechnikov; <code>3</code> for softplus.</p>
</td></tr>
<tr><td><code id="kde_polysph_+3A_kernel_type">kernel_type</code></td>
<td>
<p>type of kernel employed: <code>1</code> for product kernel
(default); <code>2</code> for spherically symmetric kernel.</p>
</td></tr>
<tr><td><code id="kde_polysph_+3A_k">k</code></td>
<td>
<p>softplus kernel parameter. Defaults to <code>10.0</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A column vector of size <code>c(nx, 1)</code> with the evaluation of
kernel density estimator.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple check on S^1 x S^2
n &lt;- 1e3
d &lt;- c(1, 2)
mu &lt;- c(0, 1, 0, 0, 1)
kappa &lt;- c(5, 5)
h &lt;- c(0.2, 0.2)
X &lt;- r_vmf_polysph(n = n, d = d, mu = mu, kappa = kappa)
kde_polysph(x = rbind(mu), X = X, d = d, h = h)
d_vmf_polysph(x = rbind(mu), d = d, mu = mu, kappa = kappa)
</code></pre>

<hr>
<h2 id='kernel'>Kernels on the hypersphere and their derivatives</h2><span id='topic+kernel'></span><span id='topic+L'></span><span id='topic+c_kern'></span><span id='topic+grad_L'></span><span id='topic+hess_L'></span>

<h3>Description</h3>

<p>An isotropic kernel <code class="reqn">L</code> on <code class="reqn">\mathcal{S}^d</code> and its
normalizing constant are such that <code class="reqn">\int_{\mathcal{S}^d} c(h, d, L)
L\left(\frac{1 - \boldsymbol{x}'\boldsymbol{y}}{h^2}\right)
\,\mathrm{d}\boldsymbol{x} = 1</code> (extrinsic-chordal distance) or
<code class="reqn">\int_{\mathcal{S}^d} c(h, d, L)
L\left(\frac{\cos^{-1}(\boldsymbol{x}'\boldsymbol{y})^2}{2h^2}\right)
\,\mathrm{d}\boldsymbol{x} = 1</code> (intrinsic distance).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L(t, kernel = "1", squared = FALSE, deriv = 0, k = 10,
  inc_sfp = TRUE)

c_kern(h, d, kernel = "1", kernel_type = "1", k = 10, log = FALSE,
  inc_sfp = TRUE, intrinsic = FALSE)

grad_L(x, y, h, kernel = 1, k = 10)

hess_L(x, y, h, kernel = 1, k = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kernel_+3A_t">t</code></td>
<td>
<p>vector with the evaluation points.</p>
</td></tr>
<tr><td><code id="kernel_+3A_kernel">kernel</code></td>
<td>
<p>kernel employed: <code>1</code> for von Mises&ndash;Fisher (default);
<code>2</code> for Epanechnikov; <code>3</code> for softplus.</p>
</td></tr>
<tr><td><code id="kernel_+3A_squared">squared</code></td>
<td>
<p>square the kernel? Only for <code>deriv = 0</code>. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="kernel_+3A_deriv">deriv</code></td>
<td>
<p>kernel derivative. Must be <code>0</code>, <code>1</code>, or <code>2</code>.
Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="kernel_+3A_k">k</code></td>
<td>
<p>softplus kernel parameter. Defaults to <code>10.0</code>.</p>
</td></tr>
<tr><td><code id="kernel_+3A_inc_sfp">inc_sfp</code></td>
<td>
<p>include <code>softplus(k)</code> in the constant? Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="kernel_+3A_h">h</code></td>
<td>
<p>vector of size <code>r</code> with bandwidths.</p>
</td></tr>
<tr><td><code id="kernel_+3A_d">d</code></td>
<td>
<p>vector of size <code>r</code> with dimensions.</p>
</td></tr>
<tr><td><code id="kernel_+3A_kernel_type">kernel_type</code></td>
<td>
<p>type of kernel employed: <code>1</code> for product kernel
(default); <code>2</code> for spherically symmetric kernel.</p>
</td></tr>
<tr><td><code id="kernel_+3A_log">log</code></td>
<td>
<p>compute the logarithm of the constant? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="kernel_+3A_intrinsic">intrinsic</code></td>
<td>
<p>consider the intrinsic distance? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="kernel_+3A_x">x</code></td>
<td>
<p>a matrix of size <code>c(nx, sum(d) + r)</code> with the evaluation
points.</p>
</td></tr>
<tr><td><code id="kernel_+3A_y">y</code></td>
<td>
<p>center of the kernel, a vector of size <code>sum(d) + r</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gradient and Hessian are computed for the functions
<code class="reqn">\boldsymbol{x} \mapsto
L\left(\frac{1 - \boldsymbol{x}'\boldsymbol{y}}{h^2}\right)</code>.
</p>


<h3>Value</h3>


<ul>
<li><p><code>L</code>: a vector with the kernel evaluated at <code>t</code>.
</p>
</li>
<li><p><code>grad_L</code>: a vector with the gradient evaluated at <code>x</code>.
</p>
</li>
<li><p><code>hess_L</code>: a matrix with the Hessian evaluated at <code>x</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Constants in terms of h
h_grid &lt;- seq(0.01, 4, l = 100)
r &lt;- 2
d &lt;- 2
dr &lt;- rep(d, r)
c_vmf &lt;- sapply(h_grid, function(hi)
  log(c_kern(h = rep(hi, r), d = dr, kernel = 1, kernel_type = 2)))
c_epa &lt;- sapply(h_grid, function(hi)
  log(c_kern(h = rep(hi, r), d = dr, kernel = 2, kernel_type = 2)))
c_sfp &lt;- sapply(h_grid, function(hi)
  log(c_kern(h = rep(hi, r), d = dr, kernel = 3, k = 1, kernel_type = 2)))
plot(h_grid, c_epa, type = "l", ylab = "Constant", xlab = "h", col = 2)
lines(h_grid, c_sfp, col = 3)
lines(h_grid, c_vmf, col = 1)
abline(v = sqrt(2), lty = 2, col = 2)

# Kernel and its derivatives
h &lt;- 0.5
x &lt;- c(sqrt(2), -sqrt(2), 0) / 2
y &lt;- c(-sqrt(2), sqrt(3), sqrt(3)) / 3
L(t = (1 - sum(x * y)) / h^2)
grad_L(x = x, y = y, h = h)
hess_L(x = x, y = y, h = h)
</code></pre>

<hr>
<h2 id='kre_polysph'>Local polynomial estimator for polyspherical-on-scalar regression</h2><span id='topic+kre_polysph'></span>

<h3>Description</h3>

<p>Computes a local constant (Nadaraya&ndash;Watson) or local linear
estimator with polyspherical response and scalar predictor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kre_polysph(x, X, Y, d, h, p = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kre_polysph_+3A_x">x</code></td>
<td>
<p>a vector of size <code>nx</code> with the evaluation points.</p>
</td></tr>
<tr><td><code id="kre_polysph_+3A_x">X</code></td>
<td>
<p>a vector of size <code>n</code> with the predictor sample.</p>
</td></tr>
<tr><td><code id="kre_polysph_+3A_y">Y</code></td>
<td>
<p>a matrix of size <code>c(n, sum(d) + r)</code> with the response sample
on the polysphere.</p>
</td></tr>
<tr><td><code id="kre_polysph_+3A_d">d</code></td>
<td>
<p>vector of size <code>r</code> with dimensions.</p>
</td></tr>
<tr><td><code id="kre_polysph_+3A_h">h</code></td>
<td>
<p>a positive scalar giving the bandwidth.</p>
</td></tr>
<tr><td><code id="kre_polysph_+3A_p">p</code></td>
<td>
<p>degree of local fit, either <code>0</code> or <code>1</code>. Defaults to
<code>0</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of size <code>nx</code> with the estimated regression curve
evaluated at <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_grid &lt;- seq(-0.25, 1.25, l = 200)
n &lt;- 50
X &lt;- seq(0, 1, l = n)
Y &lt;- r_path_s2r(n = n, r = 1, sigma = 0.1, spiral = TRUE)[, , 1]
h0 &lt;- bw_cv_kre_polysph(X = X, Y = Y, d = 2, p = 0, plot_cv = FALSE)$h_1se
sc3 &lt;- scatterplot3d::scatterplot3d(Y, pch = 16, xlim = c(-1, 1),
                                    ylim = c(-1, 1), zlim = c(-1, 1),
                                    xlab = "", ylab = "", zlab = "")
sc3$points3d(kre_polysph(x = x_grid, X = X, Y = Y, d = 2, h = h0, p = 0),
             pch = 16, type = "l", col = 2, lwd = 2)
sc3$points3d(kre_polysph(x = x_grid, X = X, Y = Y, d = 2, h = h0, p = 1),
             pch = 16, type = "l", col = 3, lwd = 2)
</code></pre>

<hr>
<h2 id='log_cv_kde_polysph'>Cross-validation for the polyspherical kernel density estimator</h2><span id='topic+log_cv_kde_polysph'></span>

<h3>Description</h3>

<p>Computes the logarithm of the cross-validated kernel density
estimator: <code class="reqn">\log \hat{f}_{-i}(\boldsymbol{X}_i;\boldsymbol{h})</code>,
<code class="reqn">i = 1, \ldots, n.</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_cv_kde_polysph(X, d, h, weights = as.numeric(c()), wrt_unif = FALSE,
  normalized = TRUE, intrinsic = FALSE, norm_X = FALSE, kernel = 1L,
  kernel_type = 1L, k = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_cv_kde_polysph_+3A_x">X</code></td>
<td>
<p>a matrix of size <code>c(n, sum(d) + r)</code> with the sample.</p>
</td></tr>
<tr><td><code id="log_cv_kde_polysph_+3A_d">d</code></td>
<td>
<p>vector of size <code>r</code> with dimensions.</p>
</td></tr>
<tr><td><code id="log_cv_kde_polysph_+3A_h">h</code></td>
<td>
<p>vector of size <code>r</code> with bandwidths.</p>
</td></tr>
<tr><td><code id="log_cv_kde_polysph_+3A_weights">weights</code></td>
<td>
<p>weights for each observation. If provided, a vector of size
<code>n</code> with the weights for multiplying each kernel. If not provided,
set internally to <code>rep(1 / n, n)</code>, which gives the standard estimator.</p>
</td></tr>
<tr><td><code id="log_cv_kde_polysph_+3A_wrt_unif">wrt_unif</code></td>
<td>
<p>flag to return a density with respect to the uniform
measure. If <code>FALSE</code> (default), the density is with respect to the
Lebesgue measure.</p>
</td></tr>
<tr><td><code id="log_cv_kde_polysph_+3A_normalized">normalized</code></td>
<td>
<p>flag to compute the normalizing constant of the kernel
and include it in the kernel density estimator. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="log_cv_kde_polysph_+3A_intrinsic">intrinsic</code></td>
<td>
<p>use the intrinsic distance, instead of the
extrinsic-chordal distance, in the kernel? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="log_cv_kde_polysph_+3A_norm_x">norm_X</code></td>
<td>
<p>ensure a normalization of the data? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="log_cv_kde_polysph_+3A_kernel">kernel</code></td>
<td>
<p>kernel employed: <code>1</code> for von Mises&ndash;Fisher (default);
<code>2</code> for Epanechnikov; <code>3</code> for softplus.</p>
</td></tr>
<tr><td><code id="log_cv_kde_polysph_+3A_kernel_type">kernel_type</code></td>
<td>
<p>type of kernel employed: <code>1</code> for product kernel
(default); <code>2</code> for spherically symmetric kernel.</p>
</td></tr>
<tr><td><code id="log_cv_kde_polysph_+3A_k">k</code></td>
<td>
<p>softplus kernel parameter. Defaults to <code>10.0</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A column vector of size <code>c(n, 1)</code> with the evaluation of the
logarithm of the cross-validated kernel density estimator.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple check on S^1 x S^2
n &lt;- 5
d &lt;- c(1, 2)
h &lt;- c(0.2, 0.2)
X &lt;- r_unif_polysph(n = n, d = d)
log_cv_kde_polysph(X = X, d = d, h = h)
kde_polysph(x = X[1, , drop = FALSE], X = X[-1, ], d = d, h = h, log = TRUE)
</code></pre>

<hr>
<h2 id='polylog_minus_exp_mu'>Polylogarithm function with negative argument</h2><span id='topic+polylog_minus_exp_mu'></span>

<h3>Description</h3>

<p>Computation of the polylogarithm <code class="reqn">\mathrm{Li}_s(-e^\mu)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polylog_minus_exp_mu(mu, s, upper = Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="polylog_minus_exp_mu_+3A_mu">mu</code></td>
<td>
<p>vector with exponents of the negative argument.</p>
</td></tr>
<tr><td><code id="polylog_minus_exp_mu_+3A_s">s</code></td>
<td>
<p>vector with indexes of the polylogarithm.</p>
</td></tr>
<tr><td><code id="polylog_minus_exp_mu_+3A_upper">upper</code></td>
<td>
<p>upper limit of integration. Defaults to <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="polylog_minus_exp_mu_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="stats.html#topic+integrate">integrate</a></code>, such as
<code>upper</code>, <code>abs.tol</code>, <code>rel.tol</code>, etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>s</code> is an integer, 1/2, 3/2, or 5/2, then routines from
the <a href="https://www.gnu.org/software/gsl/">GSL library</a> to compute
Fermi&ndash;Dirac integrals are called. Otherwise, numerical integration is used.
</p>


<h3>Value</h3>

<p>A vector of size <code>length(mu)</code> or <code>length(s)</code> with the
values of the polylogarithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>polylog_minus_exp_mu(mu = 1:5, s = 1)
polylog_minus_exp_mu(mu = 1, s = 1:5)
polylog_minus_exp_mu(mu = 1:5, s = 1:5)
</code></pre>

<hr>
<h2 id='proj_grad_kde_polysph'>Projected gradient of the polyspherical kernel density estimator</h2><span id='topic+proj_grad_kde_polysph'></span>

<h3>Description</h3>

<p>Computes the projected gradient
<code class="reqn">\mathsf{D}_{(p-1)}\hat{f}(\boldsymbol{x};\boldsymbol{h})</code> of the
kernel density estimator <code class="reqn">\hat{f}(\boldsymbol{x};\boldsymbol{h})</code> on the
polysphere <code class="reqn">\mathcal{S}^{d_1} \times \cdots \times \mathcal{S}^{d_r}</code>,
where <code class="reqn">p=\sum_{j=1}^r d_j+r</code> is the dimension of the ambient space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proj_grad_kde_polysph(x, X, d, h, weights = as.numeric(c()),
  wrt_unif = FALSE, normalized = TRUE, norm_x = FALSE, norm_X = FALSE,
  kernel = 1L, kernel_type = 1L, k = 10, proj_alt = TRUE,
  fix_u1 = TRUE, sparse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="proj_grad_kde_polysph_+3A_x">x</code></td>
<td>
<p>a matrix of size <code>c(nx, sum(d) + r)</code> with the evaluation
points.</p>
</td></tr>
<tr><td><code id="proj_grad_kde_polysph_+3A_x">X</code></td>
<td>
<p>a matrix of size <code>c(n, sum(d) + r)</code> with the sample.</p>
</td></tr>
<tr><td><code id="proj_grad_kde_polysph_+3A_d">d</code></td>
<td>
<p>vector of size <code>r</code> with dimensions.</p>
</td></tr>
<tr><td><code id="proj_grad_kde_polysph_+3A_h">h</code></td>
<td>
<p>vector of size <code>r</code> with bandwidths.</p>
</td></tr>
<tr><td><code id="proj_grad_kde_polysph_+3A_weights">weights</code></td>
<td>
<p>weights for each observation. If provided, a vector of size
<code>n</code> with the weights for multiplying each kernel. If not provided,
set internally to <code>rep(1 / n, n)</code>, which gives the standard estimator.</p>
</td></tr>
<tr><td><code id="proj_grad_kde_polysph_+3A_wrt_unif">wrt_unif</code></td>
<td>
<p>flag to return a density with respect to the uniform
measure. If <code>FALSE</code> (default), the density is with respect to the
Lebesgue measure.</p>
</td></tr>
<tr><td><code id="proj_grad_kde_polysph_+3A_normalized">normalized</code></td>
<td>
<p>flag to compute the normalizing constant of the kernel
and include it in the kernel density estimator. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="proj_grad_kde_polysph_+3A_norm_x">norm_x</code>, <code id="proj_grad_kde_polysph_+3A_norm_x">norm_X</code></td>
<td>
<p>ensure a normalization of the data? Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="proj_grad_kde_polysph_+3A_kernel">kernel</code></td>
<td>
<p>kernel employed: <code>1</code> for von Mises&ndash;Fisher (default);
<code>2</code> for Epanechnikov; <code>3</code> for softplus.</p>
</td></tr>
<tr><td><code id="proj_grad_kde_polysph_+3A_kernel_type">kernel_type</code></td>
<td>
<p>type of kernel employed: <code>1</code> for product kernel
(default); <code>2</code> for spherically symmetric kernel.</p>
</td></tr>
<tr><td><code id="proj_grad_kde_polysph_+3A_k">k</code></td>
<td>
<p>softplus kernel parameter. Defaults to <code>10.0</code>.</p>
</td></tr>
<tr><td><code id="proj_grad_kde_polysph_+3A_proj_alt">proj_alt</code></td>
<td>
<p>alternative projection. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="proj_grad_kde_polysph_+3A_fix_u1">fix_u1</code></td>
<td>
<p>ensure the <code class="reqn">u_1</code> vector is different from <code class="reqn">x</code>?
Prevents the Euler algorithm to &quot;surf the ridge&quot;. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="proj_grad_kde_polysph_+3A_sparse">sparse</code></td>
<td>
<p>use a sparse eigendecomposition of the Hessian? Defaults to
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>eta</code></td>
<td>
<p>a matrix of size <code>c(nx, sum(d) + r)</code> with the
projected gradient evaluated at <code>x</code>.</p>
</td></tr>
<tr><td><code>u1</code></td>
<td>
<p>a matrix of size <code>c(nx, sum(d) + r)</code> with the
first non-null Hessian eigenvector evaluated at <code>x</code>.</p>
</td></tr>
<tr><td><code>lamb_norm</code></td>
<td>
<p>a matrix of size <code>c(nx, sum(d) + r)</code> with the
Hessian eigenvalues (largest to smallest) evaluated at <code>x</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Simple check on (S^1)^2
n &lt;- 3
d &lt;- c(1, 1)
mu &lt;- c(0, 1, 0, 1)
kappa &lt;- c(5, 5)
h &lt;- c(0.2, 0.2)
X &lt;- r_vmf_polysph(n = n, d = d, mu = mu, kappa = kappa)
proj_grad_kde_polysph(x = X, X = X, d = d, h = h)
</code></pre>

<hr>
<h2 id='proj_polysph'>Projection onto the polysphere</h2><span id='topic+proj_polysph'></span>

<h3>Description</h3>

<p>Projects points on <code class="reqn">\mathbb{R}^{d_1 + \cdots + d_r + r}</code>
onto the polysphere <code class="reqn">\mathcal{S}^{d_1} \times \cdots \times
\mathcal{S}^{d_r}</code> by normalizing each block of <code class="reqn">d_j</code> coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proj_polysph(x, ind_dj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="proj_polysph_+3A_x">x</code></td>
<td>
<p>a matrix of size <code>c(n, sum(d) + r)</code>.</p>
</td></tr>
<tr><td><code id="proj_polysph_+3A_ind_dj">ind_dj</code></td>
<td>
<p><code>0</code>-based index separating the blocks of spheres that
is computed with <code><a href="#topic+comp_ind_dj">comp_ind_dj</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size <code>c(n, sum(d) + r)</code> with the projected points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example on (S^1)^2
d &lt;- c(1, 1)
x &lt;- rbind(c(2, 0, 1, 1))
proj_polysph(x, ind_dj = comp_ind_dj(d))
</code></pre>

<hr>
<h2 id='r_g_kern'>Sample from the angular kernel density</h2><span id='topic+r_g_kern'></span>

<h3>Description</h3>

<p>Simulation from the angular density function of an isotropic
kernel on the hypersphere <code class="reqn">\mathcal{S}^d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_g_kern(n, d, h, kernel = "1", k = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r_g_kern_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="r_g_kern_+3A_d">d</code></td>
<td>
<p>vector of size <code>r</code> with dimensions.</p>
</td></tr>
<tr><td><code id="r_g_kern_+3A_h">h</code></td>
<td>
<p>vector of size <code>r</code> with bandwidths.</p>
</td></tr>
<tr><td><code id="r_g_kern_+3A_kernel">kernel</code></td>
<td>
<p>kernel employed: <code>1</code> for von Mises&ndash;Fisher (default);
<code>2</code> for Epanechnikov; <code>3</code> for softplus.</p>
</td></tr>
<tr><td><code id="r_g_kern_+3A_k">k</code></td>
<td>
<p>softplus kernel parameter. Defaults to <code>10.0</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of size <code>n</code> with the sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hist(r_g_kern(n = 1e3, d = 2, h = 1, kernel = "1"), breaks = 30,
     probability = TRUE, main = "", xlim = c(-1, 1))
hist(r_g_kern(n = 1e3, d = 2, h = 1, kernel = "2"), breaks = 30,
     probability = TRUE, main = "", xlim = c(-1, 1))
hist(r_g_kern(n = 1e3, d = 2, h = 1, kernel = "3"), breaks = 30,
     probability = TRUE, main = "", xlim = c(-1, 1))
</code></pre>

<hr>
<h2 id='r_kde_polysph'>Sample from polyspherical kernel density estimator</h2><span id='topic+r_kde_polysph'></span>

<h3>Description</h3>

<p>Simulates from the distribution defined by a polyspherical
kernel density estimator on <code class="reqn">\mathcal{S}^{d_1} \times \ldots \times
\mathcal{S}^{d_r}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_kde_polysph(n, X, d, h, kernel = 1, kernel_type = 1, k = 10,
  norm_X = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r_kde_polysph_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="r_kde_polysph_+3A_x">X</code></td>
<td>
<p>a matrix of size <code>c(n, sum(d) + r)</code> with the sample.</p>
</td></tr>
<tr><td><code id="r_kde_polysph_+3A_d">d</code></td>
<td>
<p>vector of size <code>r</code> with dimensions.</p>
</td></tr>
<tr><td><code id="r_kde_polysph_+3A_h">h</code></td>
<td>
<p>vector of size <code>r</code> with bandwidths.</p>
</td></tr>
<tr><td><code id="r_kde_polysph_+3A_kernel">kernel</code></td>
<td>
<p>kernel employed: <code>1</code> for von Mises&ndash;Fisher (default);
<code>2</code> for Epanechnikov; <code>3</code> for softplus.</p>
</td></tr>
<tr><td><code id="r_kde_polysph_+3A_kernel_type">kernel_type</code></td>
<td>
<p>type of kernel employed: <code>1</code> for product kernel
(default); <code>2</code> for spherically symmetric kernel.</p>
</td></tr>
<tr><td><code id="r_kde_polysph_+3A_k">k</code></td>
<td>
<p>softplus kernel parameter. Defaults to <code>10.0</code>.</p>
</td></tr>
<tr><td><code id="r_kde_polysph_+3A_norm_x">norm_X</code></td>
<td>
<p>ensure a normalization of the data?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses <code><a href="#topic+r_kern_polysph">r_kern_polysph</a></code> to sample from the
considered kernel.
</p>


<h3>Value</h3>

<p>A matrix of size <code>c(n, sum(d) + r)</code> with the sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulated data on (S^1)^2
n &lt;- 50
samp &lt;- r_path_s1r(n = n, r = 2, k = c(1, 2), angles = TRUE)
plot(samp, xlim = c(-pi, pi), ylim = c(-pi, pi), col = rainbow(n),
     axes = FALSE, xlab = "", ylab = "", pch = 16, cex = 0.75)
points(torus_to_angles(r_kde_polysph(n = 10 * n, X = angles_to_torus(samp),
                                     d = c(1, 1), h = c(0.1, 0.1))),
       col = "black", pch = 16, cex = 0.2)
sdetorus::torusAxis()

# Simulated data on S^2
n &lt;- 50
samp &lt;- r_path_s2r(n = n, r = 1, sigma = 0.1, kappa = 5,
                   spiral = TRUE)[, , 1]
sc3d &lt;- scatterplot3d::scatterplot3d(
  samp, xlim = c(-1, 1), ylim = c(-1, 1), zlim = c(-1, 1),
  xlab = "", ylab = "", zlab = "", color = rainbow(n), pch = 16
)
xyz &lt;- r_kde_polysph(n = 10 * n, X = samp, d = 2, h = 0.1)
sc3d$points3d(xyz[, 1], xyz[, 2], xyz[, 3], col = "black", pch = 16,
              cex = 0.2)
</code></pre>

<hr>
<h2 id='r_kern_polysph'>Sample kernel-distributed polyspherical data</h2><span id='topic+r_kern_polysph'></span>

<h3>Description</h3>

<p>Simulates from the distribution defined by a kernel on the
polysphere <code class="reqn">\mathcal{S}^{d_1} \times \cdots \times \mathcal{S}^{d_r}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_kern_polysph(n, d, mu, h, kernel = 1, kernel_type = 1, k = 10,
  norm_mu = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r_kern_polysph_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="r_kern_polysph_+3A_d">d</code></td>
<td>
<p>vector of size <code>r</code> with dimensions.</p>
</td></tr>
<tr><td><code id="r_kern_polysph_+3A_mu">mu</code></td>
<td>
<p>a vector of size <code>sum(d) + r</code> with the concatenated means
that define the center of the kernel.</p>
</td></tr>
<tr><td><code id="r_kern_polysph_+3A_h">h</code></td>
<td>
<p>vector of size <code>r</code> with bandwidths.</p>
</td></tr>
<tr><td><code id="r_kern_polysph_+3A_kernel">kernel</code></td>
<td>
<p>kernel employed: <code>1</code> for von Mises&ndash;Fisher (default);
<code>2</code> for Epanechnikov; <code>3</code> for softplus.</p>
</td></tr>
<tr><td><code id="r_kern_polysph_+3A_kernel_type">kernel_type</code></td>
<td>
<p>type of kernel employed: <code>1</code> for product kernel
(default); <code>2</code> for spherically symmetric kernel.</p>
</td></tr>
<tr><td><code id="r_kern_polysph_+3A_k">k</code></td>
<td>
<p>softplus kernel parameter. Defaults to <code>10.0</code>.</p>
</td></tr>
<tr><td><code id="r_kern_polysph_+3A_norm_mu">norm_mu</code></td>
<td>
<p>ensure a normalization of <code>mu</code>? Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulation for non-von Mises&ndash;Fisher spherically symmetric kernels
is done by acceptance-rejection from a von Mises&ndash;Fisher proposal
distribution.
</p>


<h3>Value</h3>

<p>A matrix of size <code>c(n, sum(d) + r)</code> with the sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate kernels in (S^1)^2
n &lt;- 1e3
h &lt;- c(1, 1)
d &lt;- c(1, 1)
mu &lt;- rep(DirStats::to_cir(pi), 2)
samp_ker &lt;- function(kernel, kernel_type, col, main) {
  data &lt;- r_kern_polysph(n = n, d = d, mu = mu, h = h, kernel = kernel,
                         kernel_type = kernel_type)
  ang &lt;- cbind(DirStats::to_rad(data[, 1:2]),
               DirStats::to_rad(data[, 3:4]))
  plot(ang, xlim = c(0, 2 * pi), ylim = c(0, 2 * pi), pch = 16, cex = 0.25,
       col = col, xlab = expression(Theta[1]), ylab = expression(Theta[2]),
       main = main)
}
old_par &lt;- par(mfcol = c(2, 3))
samp_ker(kernel = 2, kernel_type = 2, col = 1, main = "Epa sph. symmetric")
samp_ker(kernel = 2, kernel_type = 1, col = 2, main = "Epa product")
samp_ker(kernel = 3, kernel_type = 2, col = 1, main = "Sfp sph. symmetric")
samp_ker(kernel = 3, kernel_type = 1, col = 2, main = "Sfp product")
samp_ker(kernel = 1, kernel_type = 2, col = 1, main = "vMF sph. symmetric")
samp_ker(kernel = 1, kernel_type = 1, col = 2, main = "vMF product")
par(old_par)

# Simulate kernels in (S^2)^2
n &lt;- 1e3
h &lt;- c(0.2, 0.6)
d &lt;- c(2, 2)
mu &lt;- c(c(0, 0, 1), c(0, -1, 0))
samp_ker &lt;- function(kernel, kernel_type, main) {
  data &lt;- r_kern_polysph(n = n, d = d, mu = mu, h = h, kernel = kernel,
                         kernel_type = kernel_type)
  scatterplot3d::scatterplot3d(rbind(data[, 1:3], data[, 4:6]),
                               xlim = c(-1, 1), ylim = c(-1, 1),
                               zlim = c(-1, 1), pch = 16, xlab = "",
                               ylab = "", zlab = "", cex.symbols = 0.5,
       color = rep(viridis::viridis(n)[rank(data[, 3])], 2), main = main)
}
old_par &lt;- par(mfcol = c(2, 3))
samp_ker(kernel = 2, kernel_type = 2, main = "Epa sph. symmetric")
samp_ker(kernel = 2, kernel_type = 1, main = "Epa product")
samp_ker(kernel = 3, kernel_type = 2, main = "Sfp sph. symmetric")
samp_ker(kernel = 3, kernel_type = 1, main = "Sfp product")
samp_ker(kernel = 1, kernel_type = 2, main = "vMF sph. symmetric")
samp_ker(kernel = 1, kernel_type = 1, main = "vMF product")
par(old_par)

# Plot simulated data
n &lt;- 1e3
h &lt;- c(1, 1)
d &lt;- c(2, 2)
samp_ker &lt;- function(kernel, kernel_type, col, main) {
  X &lt;- r_kern_polysph(n = n, d = d, mu = mu, h = h, kernel = kernel,
                      kernel_type = kernel_type)
  S &lt;- cbind((1 - X[, 1:3] %*% mu[1:3]) / h[1]^2,
             (1 - X[, 4:6] %*% mu[4:6]) / h[2]^2)
  plot(S, xlim = c(0, 2 / h[1]^2), ylim = c(0, 2 / h[2]^2), pch = 16,
       cex = 0.25, col = col, xlab = expression(t[1]),
       ylab = expression(t[2]), main = main)
  t_grid &lt;- seq(0, 2 / min(h)^2, l = 100)
  gr &lt;- as.matrix(expand.grid(t_grid, t_grid))
  if (kernel_type == "1") {

    dens &lt;- prod(c_kern(h = h, d = d, kernel = kernel, kernel_type = 1)) *
      L(gr[, 1], kernel = kernel) * L(gr[, 2], kernel = kernel)

  } else if (kernel_type == "2") {

    dens &lt;- c_kern(h = h, d = d, kernel = kernel, kernel_type = 2) *
      L(gr[, 1] + gr[, 2], kernel = kernel)

  }
  dens &lt;- matrix(dens, nrow = length(t_grid), ncol = length(t_grid))
  contour(t_grid, t_grid, dens, add = TRUE, col = col,
          levels = seq(0, 0.2, l = 41))

}
old_par &lt;- par(mfcol = c(2, 3))
samp_ker(kernel = 2, kernel_type = 2, col = 1, main = "Epa sph. symmetric")
samp_ker(kernel = 2, kernel_type = 1, col = 2, main = "Epa product")
samp_ker(kernel = 3, kernel_type = 2, col = 1, main = "Sfp sph. symmetric")
samp_ker(kernel = 3, kernel_type = 1, col = 2, main = "Sfp product")
samp_ker(kernel = 1, kernel_type = 2, col = 1, main = "vMF sph. symmetric")
samp_ker(kernel = 1, kernel_type = 1, col = 2, main = "vMF product")
par(old_par)

</code></pre>

<hr>
<h2 id='r_path_s1r'>Samplers of one-dimensional modes of variation for polyspherical data</h2><span id='topic+r_path_s1r'></span><span id='topic+r_path_s2r'></span>

<h3>Description</h3>

<p>Functions for sampling data on <code class="reqn">(\mathcal{S}^d)^r</code>, for
<code class="reqn">d=1,2</code>, using one-dimensional modes of variation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_path_s1r(n, r, alpha = runif(r, -pi, pi), k = sample(-2:2, size = r,
  replace = TRUE), sigma = 0.25, angles = FALSE)

r_path_s2r(n, r, t = 0, c = 1, Theta = t(rotasym::r_unif_sphere(n = r, p
  = 3)), kappa = 0, sigma = 0.25, spiral = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r_path_s1r_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="r_path_s1r_+3A_r">r</code></td>
<td>
<p>number of spheres in the polysphere <code class="reqn">(\mathcal{S}^d)^r</code>.</p>
</td></tr>
<tr><td><code id="r_path_s1r_+3A_alpha">alpha</code></td>
<td>
<p>a vector of size <code>r</code> valued in <code class="reqn">[-\pi,\pi)</code> with the
initial angles for the linear trend. Chosen at random by default.</p>
</td></tr>
<tr><td><code id="r_path_s1r_+3A_k">k</code></td>
<td>
<p>a vector of size <code>r</code> with the <b>integer</b> slopes defining
the angular linear trend. Chosen at random by default.</p>
</td></tr>
<tr><td><code id="r_path_s1r_+3A_sigma">sigma</code></td>
<td>
<p>standard deviation of the noise about the one-dimensional mode
of variation. Defaults to <code>0.25</code>.</p>
</td></tr>
<tr><td><code id="r_path_s1r_+3A_angles">angles</code></td>
<td>
<p>return angles in <code class="reqn">[-\pi, \pi)</code>? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="r_path_s1r_+3A_t">t</code></td>
<td>
<p>latitude, with respect to <code>Theta</code>, of the small circle.
Defaults to <code>0</code> (equator).</p>
</td></tr>
<tr><td><code id="r_path_s1r_+3A_c">c</code></td>
<td>
<p><a href="https://en.wikipedia.org/wiki/Cl%C3%A9lie">Clélie curve</a>
parameter, changing the spiral wrappings. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="r_path_s1r_+3A_theta">Theta</code></td>
<td>
<p>a matrix of size <code>c(3, r)</code> giving the north poles for
<code class="reqn">\mathcal{S}^2</code>. Useful for rotating the sample. Chosen at random by
default.</p>
</td></tr>
<tr><td><code id="r_path_s1r_+3A_kappa">kappa</code></td>
<td>
<p>concentration von Mises&ndash;Fisher parameter for longitudes in
small circles. Defaults to <code>0</code> (uniform).</p>
</td></tr>
<tr><td><code id="r_path_s1r_+3A_spiral">spiral</code></td>
<td>
<p>consider a spiral (or, more precisely, a
<a href="https://en.wikipedia.org/wiki/Cl%C3%A9lie">Clélie curve</a>) instead of
a small circle? Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of size <code>c(n, d, r)</code> with samples on <code class="reqn">(\mathcal{S}^d)^r</code>.
If <code>angles = TRUE</code> for <code>r_path_s1r</code>, then a matrix of size
<code>c(n ,r)</code> with angles is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Straight trends on (S^1)^2
n &lt;- 100
samp_1 &lt;- r_path_s1r(n = n, r = 2, k = c(1, 2), angles = TRUE)
plot(samp_1, xlim = c(-pi, pi), ylim = c(-pi, pi), col = rainbow(n),
     axes = FALSE, xlab = "", ylab = "", pch = 16)
sdetorus::torusAxis()

# Straight trends on (S^1)^3
n &lt;- 100
samp_2 &lt;- r_path_s1r(n = n, r = 3, angles = TRUE)
pairs(samp_2, xlim = c(-pi, pi), ylim = c(-pi, pi), col = rainbow(n),
      pch = 16)
sdetorus::torusAxis()
scatterplot3d::scatterplot3d(
  samp_2, xlim = c(-pi, pi), ylim = c(-pi, pi), zlim = c(-pi, pi),
  xlab = "", ylab = "", zlab = "", color = rainbow(n), pch = 16
)

# Small-circle trends on (S^2)^2
n &lt;- 100
samp_3 &lt;- r_path_s2r(n = n, r = 2, sigma = 0.1, kappa = 5)
old_par &lt;- par(mfrow = c(1, 2))
scatterplot3d::scatterplot3d(
  samp_3[, , 1], xlim = c(-1, 1), ylim = c(-1, 1), zlim = c(-1, 1),
  xlab = "", ylab = "", zlab = "", color = rainbow(n), pch = 16
)
scatterplot3d::scatterplot3d(
  samp_3[, , 2], xlim = c(-1, 1), ylim = c(-1, 1), zlim = c(-1, 1),
  xlab = "", ylab = "", zlab = "", color = rainbow(n), pch = 16
)
par(old_par)

# Spiral trends on (S^2)^2
n &lt;- 100
samp_4 &lt;- r_path_s2r(n = n, r = 2, c = 3, spiral = TRUE, sigma = 0.01)
old_par &lt;- par(mfrow = c(1, 2))
scatterplot3d::scatterplot3d(
  samp_4[, , 1], xlim = c(-1, 1), ylim = c(-1, 1), zlim = c(-1, 1),
  xlab = "", ylab = "", zlab = "", color = rainbow(n), pch = 16
)
scatterplot3d::scatterplot3d(
  samp_4[, , 2], xlim = c(-1, 1), ylim = c(-1, 1), zlim = c(-1, 1),
  xlab = "", ylab = "", zlab = "", color = rainbow(n), pch = 16
)
par(old_par)
</code></pre>

<hr>
<h2 id='r_unif_polysph'>Sample uniform polyspherical data</h2><span id='topic+r_unif_polysph'></span>

<h3>Description</h3>

<p>Simulates from a uniform distribution on the polysphere
<code class="reqn">\mathcal{S}^{d_1} \times \cdots \times \mathcal{S}^{d_r}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_unif_polysph(n, d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r_unif_polysph_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="r_unif_polysph_+3A_d">d</code></td>
<td>
<p>vector of size <code>r</code> with dimensions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size <code>c(n, sum(d) + r)</code> with the sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate uniform data on (S^1)^2
r_unif_polysph(n = 10, d = c(1, 1))
</code></pre>

<hr>
<h2 id='r_vmf_polysph'>Sample von Mises&ndash;Fisher distributed polyspherical data</h2><span id='topic+r_vmf_polysph'></span>

<h3>Description</h3>

<p>Simulates from a product of von Mises&ndash;Fisher distributions on
the polysphere <code class="reqn">\mathcal{S}^{d_1} \times \cdots \times
\mathcal{S}^{d_r}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_vmf_polysph(n, d, mu, kappa, norm_mu = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r_vmf_polysph_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="r_vmf_polysph_+3A_d">d</code></td>
<td>
<p>vector of size <code>r</code> with dimensions.</p>
</td></tr>
<tr><td><code id="r_vmf_polysph_+3A_mu">mu</code></td>
<td>
<p>a vector of size <code>sum(d) + r</code> with the concatenated von
Mises&ndash;Fisher means.</p>
</td></tr>
<tr><td><code id="r_vmf_polysph_+3A_kappa">kappa</code></td>
<td>
<p>a vector of size <code>r</code> with the von Mises&ndash;Fisher
concentrations.</p>
</td></tr>
<tr><td><code id="r_vmf_polysph_+3A_norm_mu">norm_mu</code></td>
<td>
<p>ensure a normalization of <code>mu</code>? Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size <code>c(n, sum(d) + r)</code> with the sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate vMF data on (S^1)^2
r_vmf_polysph(n = 10, d = c(1, 1), mu = c(1, 0, 0, 1), kappa = c(1, 1))
</code></pre>

<hr>
<h2 id='softplus'>Stable computation of the softplus function</h2><span id='topic+softplus'></span>

<h3>Description</h3>

<p>Computes the softplus function <code class="reqn">\log(1+e^{t})</code> in a
numerically stable way for large absolute values of <code class="reqn">t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>softplus(t)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="softplus_+3A_t">t</code></td>
<td>
<p>vector or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The softplus function evaluated at <code>t</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>curve(softplus(10 * (1 - (1 - x) / 0.1)), from = -1, to = 1)
</code></pre>

<hr>
<h2 id='view_srep'>s-rep viewer</h2><span id='topic+view_srep'></span>

<h3>Description</h3>

<p>Plots a skeletal representation (s-rep) object based on its
three-dimensional base, spokes, and boundary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view_srep(base, dirs, bdry, radii, show_base = TRUE, show_base_pt = TRUE,
  show_bdry = TRUE, show_bdry_pt = TRUE, show_seg = TRUE,
  col_base = "red", col_bndy = "blue", col_seg = "green",
  static = TRUE, texts = NULL, cex_base = ifelse(static, 0.5, 6),
  cex_bdry = ifelse(static, 1, 8), lwd_seg = ifelse(static, 1, 2),
  cex_texts = 1, alpha_base = 0.1, alpha_bdry = 0.15, r_texts = 1.25,
  alpha_ashape3d_base = NULL, alpha_ashape3d_bdry = NULL, lit = FALSE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="view_srep_+3A_base">base</code></td>
<td>
<p>base points, a matrix of size <code>c(nx, 3)</code>.</p>
</td></tr>
<tr><td><code id="view_srep_+3A_dirs">dirs</code></td>
<td>
<p>directions of spokes, a matrix of size <code>c(nx, 3)</code> with
unit vectors.</p>
</td></tr>
<tr><td><code id="view_srep_+3A_bdry">bdry</code></td>
<td>
<p>boundary points, a matrix of size <code>c(nx, 3)</code>.</p>
</td></tr>
<tr><td><code id="view_srep_+3A_radii">radii</code></td>
<td>
<p>radii of spokes, a vector of size <code>nx</code>.</p>
</td></tr>
<tr><td><code id="view_srep_+3A_show_base">show_base</code>, <code id="view_srep_+3A_show_base_pt">show_base_pt</code></td>
<td>
<p>show base and base grid? Default to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="view_srep_+3A_show_bdry">show_bdry</code>, <code id="view_srep_+3A_show_bdry_pt">show_bdry_pt</code></td>
<td>
<p>show boundary and boundary grid? Default to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="view_srep_+3A_show_seg">show_seg</code></td>
<td>
<p>show segments? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="view_srep_+3A_col_base">col_base</code>, <code id="view_srep_+3A_col_bndy">col_bndy</code>, <code id="view_srep_+3A_col_seg">col_seg</code></td>
<td>
<p>colors for the base, boundary, and segments.
Default to <code>"red"</code>, <code>"blue"</code>, and <code>"green"</code>, respectively.</p>
</td></tr>
<tr><td><code id="view_srep_+3A_static">static</code></td>
<td>
<p>use static (<code><a href="scatterplot3d.html#topic+scatterplot3d">scatterplot3d</a></code>) or
interactive (<code><a href="rgl.html#topic+plot3d">plot3d</a></code>) plot? Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="view_srep_+3A_texts">texts</code></td>
<td>
<p>add text labels? If given, it should be a vector of size
<code>nx</code> with the labels. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="view_srep_+3A_cex_base">cex_base</code>, <code id="view_srep_+3A_cex_bdry">cex_bdry</code></td>
<td>
<p>size of the base and boundary points.</p>
</td></tr>
<tr><td><code id="view_srep_+3A_lwd_seg">lwd_seg</code></td>
<td>
<p>width of the segments.</p>
</td></tr>
<tr><td><code id="view_srep_+3A_cex_texts">cex_texts</code></td>
<td>
<p>size of the text labels. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="view_srep_+3A_alpha_base">alpha_base</code>, <code id="view_srep_+3A_alpha_bdry">alpha_bdry</code></td>
<td>
<p>transparencies for base and boundary. Default to
<code>0.1</code> and <code>0.15</code>, respectively.</p>
</td></tr>
<tr><td><code id="view_srep_+3A_r_texts">r_texts</code></td>
<td>
<p>magnification of the radius to separate the text labels.
Defaults to <code>1.25</code>.</p>
</td></tr>
<tr><td><code id="view_srep_+3A_alpha_ashape3d_base">alpha_ashape3d_base</code>, <code id="view_srep_+3A_alpha_ashape3d_bdry">alpha_ashape3d_bdry</code></td>
<td>
<p>alpha parameters for
<code><a href="alphashape3d.html#topic+ashape3d">ashape3d</a></code>. Default to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="view_srep_+3A_lit">lit</code></td>
<td>
<p>lit parameter passed to <code><a href="rgl.html#topic+material3d">material3d</a></code>. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="view_srep_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="rgl.html#topic+plot3d">plot3d</a></code> or
<code><a href="scatterplot3d.html#topic+scatterplot3d">scatterplot3d</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Creates a static or interactive plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>base &lt;- r_unif_polysph(n = 50, d = 2)
dirs &lt;- base
radii &lt;- runif(nrow(base), min = 0.5, max = 1)
bdry &lt;- base + radii * dirs
view_srep(base = base, dirs = dirs, bdry = bdry, radii = radii,
          texts = 1:50, xlim = c(-2, 2), ylim = c(-2, 2), zlim = c(-2, 2))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
