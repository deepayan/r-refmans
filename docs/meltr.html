<!DOCTYPE html><html><head><title>Help for package meltr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {meltr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#callback'><p>Callback classes</p></a></li>
<li><a href='#clipboard'><p>Returns values from the clipboard</p></a></li>
<li><a href='#datasource'><p>Create a source object.</p></a></li>
<li><a href='#date_names'><p>Create or retrieve date names</p></a></li>
<li><a href='#locale'><p>Create locales</p></a></li>
<li><a href='#melt_delim'><p>Return melted data for each token in a delimited file (including csv &amp; tsv)</p></a></li>
<li><a href='#melt_delim_chunked'><p>Melt a delimited file by chunks</p></a></li>
<li><a href='#melt_fwf'><p>Return melted data for each token in a fixed width file</p></a></li>
<li><a href='#melt_table'><p>Return melted data for each token in a whitespace-separated file</p></a></li>
<li><a href='#meltr_example'><p>Get path to meltr example</p></a></li>
<li><a href='#problems'><p>Retrieve parsing problems</p></a></li>
<li><a href='#show_progress'><p>Determine whether progress bars should be shown</p></a></li>
<li><a href='#Tokenizers'><p>Tokenizers.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Read Non-Rectangular Text Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>The goal of 'meltr' is to provide a fast and friendly way to
    read non-rectangular data, such as ragged forms of csv (comma-separated
    values), tsv (tab-separated values), and fwf (fixed-width format) files.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-lib.github.io/meltr/">https://r-lib.github.io/meltr/</a>, <a href="https://github.com/r-lib/meltr">https://github.com/r-lib/meltr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-lib/meltr/issues">https://github.com/r-lib/meltr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, methods, R6, rlang, tibble</td>
</tr>
<tr>
<td>Suggests:</td>
<td>clipr, covr, crayon, curl, readr, testthat (&ge; 3.0.0), withr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>dplyr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-08 22:01:21 UTC; nacnudus</td>
</tr>
<tr>
<td>Author:</td>
<td>Hadley Wickham [aut],
  Duncan Garmonsway [aut, cre] (@nacnudus),
  Jim Hester <a href="https://orcid.org/0000-0002-2739-7082"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  RStudio [cph, fnd],
  https://github.com/mandreyel/ [cph] (mio library)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Duncan Garmonsway &lt;nacnudus@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-09 02:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='callback'>Callback classes</h2><span id='topic+callback'></span><span id='topic+ChunkCallback'></span><span id='topic+SideEffectChunkCallback'></span><span id='topic+DataFrameCallback'></span><span id='topic+ListCallback'></span><span id='topic+AccumulateCallback'></span>

<h3>Description</h3>

<p>These classes are used to define callback behaviors.
</p>


<h3>Details</h3>


<dl>
<dt>ChunkCallback</dt><dd><p>Callback interface definition, all callback functions should inherit from this class.</p>
</dd>
<dt>SideEffectChunkCallback</dt><dd><p>Callback function that is used only for side effects, no results are returned.</p>
</dd>
<dt>DataFrameCallback</dt><dd><p>Callback function that combines each result together at the end.</p>
</dd>
<dt>AccumulateCallBack</dt><dd>
<p>Callback function that accumulates a single result. Requires the parameter <code>acc</code> to specify
the initial value of the accumulator.  The parameter <code>acc</code> is <code>NULL</code> by default.
</p>
</dd>
</dl>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ChunkCallback-new"><code>ChunkCallback$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ChunkCallback-receive"><code>ChunkCallback$receive()</code></a>
</p>
</li>
<li> <p><a href="#method-ChunkCallback-continue"><code>ChunkCallback$continue()</code></a>
</p>
</li>
<li> <p><a href="#method-ChunkCallback-result"><code>ChunkCallback$result()</code></a>
</p>
</li>
<li> <p><a href="#method-ChunkCallback-finally"><code>ChunkCallback$finally()</code></a>
</p>
</li>
<li> <p><a href="#method-ChunkCallback-clone"><code>ChunkCallback$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ChunkCallback-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>ChunkCallback$new(callback)</pre></div>


<hr>
<a id="method-ChunkCallback-receive"></a>



<h4>Method <code>receive()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>ChunkCallback$receive(data, index)</pre></div>


<hr>
<a id="method-ChunkCallback-continue"></a>



<h4>Method <code>continue()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>ChunkCallback$continue()</pre></div>


<hr>
<a id="method-ChunkCallback-result"></a>



<h4>Method <code>result()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>ChunkCallback$result()</pre></div>


<hr>
<a id="method-ChunkCallback-finally"></a>



<h4>Method <code>finally()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>ChunkCallback$finally()</pre></div>


<hr>
<a id="method-ChunkCallback-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ChunkCallback$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Super class</h3>

<p><code><a href="#topic+ChunkCallback">meltr::ChunkCallback</a></code> -&gt; <code>SideEffectChunkCallback</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SideEffectChunkCallback-new"><code>SideEffectChunkCallback$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SideEffectChunkCallback-receive"><code>SideEffectChunkCallback$receive()</code></a>
</p>
</li>
<li> <p><a href="#method-SideEffectChunkCallback-continue"><code>SideEffectChunkCallback$continue()</code></a>
</p>
</li>
<li> <p><a href="#method-SideEffectChunkCallback-clone"><code>SideEffectChunkCallback$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="meltr" data-topic="ChunkCallback" data-id="finally"><a href='../../meltr/html/ChunkCallback.html#method-ChunkCallback-finally'><code>meltr::ChunkCallback$finally()</code></a></span></li>
<li><span class="pkg-link" data-pkg="meltr" data-topic="ChunkCallback" data-id="result"><a href='../../meltr/html/ChunkCallback.html#method-ChunkCallback-result'><code>meltr::ChunkCallback$result()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SideEffectChunkCallback-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>SideEffectChunkCallback$new(callback)</pre></div>


<hr>
<a id="method-SideEffectChunkCallback-receive"></a>



<h4>Method <code>receive()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>SideEffectChunkCallback$receive(data, index)</pre></div>


<hr>
<a id="method-SideEffectChunkCallback-continue"></a>



<h4>Method <code>continue()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>SideEffectChunkCallback$continue()</pre></div>


<hr>
<a id="method-SideEffectChunkCallback-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SideEffectChunkCallback$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Super class</h3>

<p><code><a href="#topic+ChunkCallback">meltr::ChunkCallback</a></code> -&gt; <code>DataFrameCallback</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DataFrameCallback-new"><code>DataFrameCallback$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DataFrameCallback-receive"><code>DataFrameCallback$receive()</code></a>
</p>
</li>
<li> <p><a href="#method-DataFrameCallback-result"><code>DataFrameCallback$result()</code></a>
</p>
</li>
<li> <p><a href="#method-DataFrameCallback-finally"><code>DataFrameCallback$finally()</code></a>
</p>
</li>
<li> <p><a href="#method-DataFrameCallback-clone"><code>DataFrameCallback$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="meltr" data-topic="ChunkCallback" data-id="continue"><a href='../../meltr/html/ChunkCallback.html#method-ChunkCallback-continue'><code>meltr::ChunkCallback$continue()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-DataFrameCallback-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>DataFrameCallback$new(callback)</pre></div>


<hr>
<a id="method-DataFrameCallback-receive"></a>



<h4>Method <code>receive()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>DataFrameCallback$receive(data, index)</pre></div>


<hr>
<a id="method-DataFrameCallback-result"></a>



<h4>Method <code>result()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>DataFrameCallback$result()</pre></div>


<hr>
<a id="method-DataFrameCallback-finally"></a>



<h4>Method <code>finally()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>DataFrameCallback$finally()</pre></div>


<hr>
<a id="method-DataFrameCallback-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataFrameCallback$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Super class</h3>

<p><code><a href="#topic+ChunkCallback">meltr::ChunkCallback</a></code> -&gt; <code>ListCallback</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ListCallback-new"><code>ListCallback$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ListCallback-receive"><code>ListCallback$receive()</code></a>
</p>
</li>
<li> <p><a href="#method-ListCallback-result"><code>ListCallback$result()</code></a>
</p>
</li>
<li> <p><a href="#method-ListCallback-finally"><code>ListCallback$finally()</code></a>
</p>
</li>
<li> <p><a href="#method-ListCallback-clone"><code>ListCallback$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="meltr" data-topic="ChunkCallback" data-id="continue"><a href='../../meltr/html/ChunkCallback.html#method-ChunkCallback-continue'><code>meltr::ChunkCallback$continue()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ListCallback-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>ListCallback$new(callback)</pre></div>


<hr>
<a id="method-ListCallback-receive"></a>



<h4>Method <code>receive()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>ListCallback$receive(data, index)</pre></div>


<hr>
<a id="method-ListCallback-result"></a>



<h4>Method <code>result()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>ListCallback$result()</pre></div>


<hr>
<a id="method-ListCallback-finally"></a>



<h4>Method <code>finally()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>ListCallback$finally()</pre></div>


<hr>
<a id="method-ListCallback-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ListCallback$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Super class</h3>

<p><code><a href="#topic+ChunkCallback">meltr::ChunkCallback</a></code> -&gt; <code>AccumulateCallback</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AccumulateCallback-new"><code>AccumulateCallback$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AccumulateCallback-receive"><code>AccumulateCallback$receive()</code></a>
</p>
</li>
<li> <p><a href="#method-AccumulateCallback-result"><code>AccumulateCallback$result()</code></a>
</p>
</li>
<li> <p><a href="#method-AccumulateCallback-clone"><code>AccumulateCallback$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="meltr" data-topic="ChunkCallback" data-id="continue"><a href='../../meltr/html/ChunkCallback.html#method-ChunkCallback-continue'><code>meltr::ChunkCallback$continue()</code></a></span></li>
<li><span class="pkg-link" data-pkg="meltr" data-topic="ChunkCallback" data-id="finally"><a href='../../meltr/html/ChunkCallback.html#method-ChunkCallback-finally'><code>meltr::ChunkCallback$finally()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-AccumulateCallback-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>AccumulateCallback$new(callback, acc = NULL)</pre></div>


<hr>
<a id="method-AccumulateCallback-receive"></a>



<h4>Method <code>receive()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>AccumulateCallback$receive(data, index)</pre></div>


<hr>
<a id="method-AccumulateCallback-result"></a>



<h4>Method <code>result()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>AccumulateCallback$result()</pre></div>


<hr>
<a id="method-AccumulateCallback-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AccumulateCallback$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other chunked: 
<code><a href="#topic+melt_delim_chunked">melt_delim_chunked</a>()</code>
</p>

<hr>
<h2 id='clipboard'>Returns values from the clipboard</h2><span id='topic+clipboard'></span>

<h3>Description</h3>

<p>This is useful in the <code><a href="readr.html#topic+read_delim">readr::read_delim()</a></code> functions to read from the clipboard.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clipboard()
</code></pre>


<h3>See Also</h3>

<p>readr::read_delim
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  clipboard()

## End(Not run)
</code></pre>

<hr>
<h2 id='datasource'>Create a source object.</h2><span id='topic+datasource'></span>

<h3>Description</h3>

<p>Create a source object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datasource(
  file,
  skip = 0,
  skip_empty_rows = FALSE,
  comment = "",
  skip_quote = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datasource_+3A_file">file</code></td>
<td>
<p>Either a path to a file, a connection, or literal data
(either a single string or a raw vector).
</p>
<p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will
be automatically uncompressed. Files starting with <code style="white-space: pre;">&#8288;http://&#8288;</code>,
<code style="white-space: pre;">&#8288;https://&#8288;</code>, <code style="white-space: pre;">&#8288;ftp://&#8288;</code>, or <code style="white-space: pre;">&#8288;ftps://&#8288;</code> will be automatically
downloaded. Remote gz files can also be automatically downloaded and
decompressed.
</p>
<p>Literal data is most useful for examples and tests. It must contain at
least one new line to be recognised as data (instead of a path) or be a
vector of greater than length 1.
</p>
<p>Using a value of <code><a href="#topic+clipboard">clipboard()</a></code> will read from the system clipboard.</p>
</td></tr>
<tr><td><code id="datasource_+3A_skip">skip</code></td>
<td>
<p>Number of lines to skip before reading data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A source object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Literal csv
datasource("a,b,c\n1,2,3")
datasource(charToRaw("a,b,c\n1,2,3"))

# Strings
datasource(meltr_example("mtcars.csv"))
## Not run: 
datasource("https://github.com/tidyverse/readr/raw/master/inst/extdata/mtcars.csv")

## End(Not run)

# Connection
con &lt;- rawConnection(charToRaw("abc\n123"))
datasource(con)
close(con)
</code></pre>

<hr>
<h2 id='date_names'>Create or retrieve date names</h2><span id='topic+date_names'></span><span id='topic+date_names_lang'></span><span id='topic+date_names_langs'></span>

<h3>Description</h3>

<p>When parsing dates, you often need to know how weekdays of the week and
months are represented as text. This pair of functions allows you to either
create your own, or retrieve from a standard list. The standard list is
derived from ICU (<a href="https://icu.unicode.org/">https://icu.unicode.org/</a>) via the stringi package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_names(mon, mon_ab = mon, day, day_ab = day, am_pm = c("AM", "PM"))

date_names_lang(language)

date_names_langs()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_names_+3A_mon">mon</code>, <code id="date_names_+3A_mon_ab">mon_ab</code></td>
<td>
<p>Full and abbreviated month names.</p>
</td></tr>
<tr><td><code id="date_names_+3A_day">day</code>, <code id="date_names_+3A_day_ab">day_ab</code></td>
<td>
<p>Full and abbreviated week day names. Starts with Sunday.</p>
</td></tr>
<tr><td><code id="date_names_+3A_am_pm">am_pm</code></td>
<td>
<p>Names used for AM and PM.</p>
</td></tr>
<tr><td><code id="date_names_+3A_language">language</code></td>
<td>
<p>A BCP 47 locale, made up of a language and a region,
e.g. <code>"en_US"</code> for American English. See <code>date_names_langs()</code>
for a complete list of available locales.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A date names object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>date_names(mon = LETTERS[1:12], day = letters[1:7])
date_names_lang("en")
date_names_lang("ko")
date_names_lang("fr")
</code></pre>

<hr>
<h2 id='locale'>Create locales</h2><span id='topic+locale'></span><span id='topic+default_locale'></span>

<h3>Description</h3>

<p>A locale object tries to capture all the defaults that can vary between
countries. You set the locale in once, and the details are automatically
passed on down to the columns parsers. The defaults have been chosen to
match R (i.e. US English) as closely as possible. See
<code>vignette("locales")</code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locale(
  date_names = "en",
  date_format = "%AD",
  time_format = "%AT",
  decimal_mark = ".",
  grouping_mark = ",",
  tz = "UTC",
  encoding = "UTF-8"
)

default_locale()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locale_+3A_date_names">date_names</code></td>
<td>
<p>Character representations of day and month names. Either
the language code as string (passed on to <code><a href="#topic+date_names_lang">date_names_lang()</a></code>)
or an object created by <code><a href="#topic+date_names">date_names()</a></code>.</p>
</td></tr>
<tr><td><code id="locale_+3A_date_format">date_format</code>, <code id="locale_+3A_time_format">time_format</code></td>
<td>
<p>Default date and time formats.</p>
</td></tr>
<tr><td><code id="locale_+3A_decimal_mark">decimal_mark</code>, <code id="locale_+3A_grouping_mark">grouping_mark</code></td>
<td>
<p>Symbols used to indicate the decimal
place, and to chunk larger numbers. Decimal mark can only be <code style="white-space: pre;">&#8288;,&#8288;</code> or
<code>.</code>.</p>
</td></tr>
<tr><td><code id="locale_+3A_tz">tz</code></td>
<td>
<p>Default tz. This is used both for input (if the time zone isn't
present in individual strings), and for output (to control the default
display). The default is to use &quot;UTC&quot;, a time zone that does not use
daylight savings time (DST) and hence is typically most useful for data.
The absence of time zones makes it approximately 50x faster to generate
UTC times than any other time zone.
</p>
<p>Use <code>""</code> to use the system default time zone, but beware that this
will not be reproducible across systems.
</p>
<p>For a complete list of possible time zones, see <code><a href="base.html#topic+OlsonNames">OlsonNames()</a></code>.
Americans, note that &quot;EST&quot; is a Canadian time zone that does not have
DST. It is <em>not</em> Eastern Standard Time. It's better to use
&quot;US/Eastern&quot;, &quot;US/Central&quot; etc.</p>
</td></tr>
<tr><td><code id="locale_+3A_encoding">encoding</code></td>
<td>
<p>Default encoding. This only affects how the file is
read - meltr always converts the output to UTF-8.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A locale object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>locale()
locale("fr")

# South American locale
locale("es", decimal_mark = ",")
</code></pre>

<hr>
<h2 id='melt_delim'>Return melted data for each token in a delimited file (including csv &amp; tsv)</h2><span id='topic+melt_delim'></span><span id='topic+melt_csv'></span><span id='topic+melt_csv2'></span><span id='topic+melt_tsv'></span>

<h3>Description</h3>

<p>For certain non-rectangular data formats, it can be useful to parse the data
into a melted format where each row represents a single token.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>melt_delim(
  file,
  delim,
  quote = "\"",
  escape_backslash = FALSE,
  escape_double = TRUE,
  locale = default_locale(),
  na = c("", "NA"),
  quoted_na = TRUE,
  comment = "",
  trim_ws = FALSE,
  skip = 0,
  n_max = Inf,
  progress = show_progress(),
  skip_empty_rows = FALSE
)

melt_csv(
  file,
  locale = default_locale(),
  na = c("", "NA"),
  quoted_na = TRUE,
  quote = "\"",
  comment = "",
  trim_ws = TRUE,
  skip = 0,
  n_max = Inf,
  progress = show_progress(),
  skip_empty_rows = FALSE
)

melt_csv2(
  file,
  locale = default_locale(),
  na = c("", "NA"),
  quoted_na = TRUE,
  quote = "\"",
  comment = "",
  trim_ws = TRUE,
  skip = 0,
  n_max = Inf,
  progress = show_progress(),
  skip_empty_rows = FALSE
)

melt_tsv(
  file,
  locale = default_locale(),
  na = c("", "NA"),
  quoted_na = TRUE,
  quote = "\"",
  comment = "",
  trim_ws = TRUE,
  skip = 0,
  n_max = Inf,
  progress = show_progress(),
  skip_empty_rows = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="melt_delim_+3A_file">file</code></td>
<td>
<p>Either a path to a file, a connection, or literal data
(either a single string or a raw vector).
</p>
<p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will
be automatically uncompressed. Files starting with <code style="white-space: pre;">&#8288;http://&#8288;</code>,
<code style="white-space: pre;">&#8288;https://&#8288;</code>, <code style="white-space: pre;">&#8288;ftp://&#8288;</code>, or <code style="white-space: pre;">&#8288;ftps://&#8288;</code> will be automatically
downloaded. Remote gz files can also be automatically downloaded and
decompressed.
</p>
<p>Literal data is most useful for examples and tests. To be recognised as
literal data, the input must be either wrapped with <code>I()</code>, be a string
containing at least one new line, or be a vector containing at least one
string with a new line.
</p>
<p>Using a value of <code><a href="readr.html#topic+clipboard">clipboard()</a></code> will read from the system clipboard.</p>
</td></tr>
<tr><td><code id="melt_delim_+3A_delim">delim</code></td>
<td>
<p>Single character used to separate fields within a record.</p>
</td></tr>
<tr><td><code id="melt_delim_+3A_quote">quote</code></td>
<td>
<p>Single character used to quote strings.</p>
</td></tr>
<tr><td><code id="melt_delim_+3A_escape_backslash">escape_backslash</code></td>
<td>
<p>Does the file use backslashes to escape special
characters? This is more general than <code>escape_double</code> as backslashes
can be used to escape the delimiter character, the quote character, or
to add special characters like <code style="white-space: pre;">&#8288;\\n&#8288;</code>.</p>
</td></tr>
<tr><td><code id="melt_delim_+3A_escape_double">escape_double</code></td>
<td>
<p>Does the file escape quotes by doubling them?
i.e. If this option is <code>TRUE</code>, the value <code style="white-space: pre;">&#8288;""""&#8288;</code> represents
a single quote, <code style="white-space: pre;">&#8288;\"&#8288;</code>.</p>
</td></tr>
<tr><td><code id="melt_delim_+3A_locale">locale</code></td>
<td>
<p>The locale controls defaults that vary from place to place.
The default locale is US-centric (like R), but you can use
<code><a href="readr.html#topic+locale">locale()</a></code> to create your own locale that controls things like
the default time zone, encoding, decimal mark, big mark, and day/month
names.</p>
</td></tr>
<tr><td><code id="melt_delim_+3A_na">na</code></td>
<td>
<p>Character vector of strings to interpret as missing values. Set this
option to <code>character()</code> to indicate no missing values.</p>
</td></tr>
<tr><td><code id="melt_delim_+3A_quoted_na">quoted_na</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Should missing values
inside quotes be treated as missing values (the default) or strings. This
parameter is soft deprecated as of readr 2.0.0.</p>
</td></tr>
<tr><td><code id="melt_delim_+3A_comment">comment</code></td>
<td>
<p>A string used to identify comments. Any text after the
comment characters will be silently ignored.</p>
</td></tr>
<tr><td><code id="melt_delim_+3A_trim_ws">trim_ws</code></td>
<td>
<p>Should leading and trailing whitespace (ASCII spaces and tabs) be trimmed from
each field before parsing it?</p>
</td></tr>
<tr><td><code id="melt_delim_+3A_skip">skip</code></td>
<td>
<p>Number of lines to skip before reading data. If <code>comment</code> is
supplied any commented lines are ignored <em>after</em> skipping.</p>
</td></tr>
<tr><td><code id="melt_delim_+3A_n_max">n_max</code></td>
<td>
<p>Maximum number of lines to read.</p>
</td></tr>
<tr><td><code id="melt_delim_+3A_progress">progress</code></td>
<td>
<p>Display a progress bar? By default it will only display
in an interactive session and not while knitting a document. The automatic
progress bar can be disabled by setting option <code>readr.show_progress</code> to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="melt_delim_+3A_skip_empty_rows">skip_empty_rows</code></td>
<td>
<p>Should blank rows be ignored altogether? i.e. If this
option is <code>TRUE</code> then blank rows will not be represented at all.  If it is
<code>FALSE</code> then they will be represented by <code>NA</code> values in all the columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>melt_csv()</code> and <code>melt_tsv()</code> are special cases of the general
<code>melt_delim()</code>. They're useful for reading the most common types of
flat file data, comma separated values and tab separated values,
respectively. <code>melt_csv2()</code> uses <code style="white-space: pre;">&#8288;;&#8288;</code> for the field separator and <code style="white-space: pre;">&#8288;,&#8288;</code> for the
decimal point. This is common in some European countries.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble()</a></code> of four columns:
</p>

<ul>
<li> <p><code>row</code>, the row that the token comes from in the original file
</p>
</li>
<li> <p><code>col</code>, the column that the token comes from in the original file
</p>
</li>
<li> <p><code>data_type</code>, the data type of the token, e.g. <code>"integer"</code>, <code>"character"</code>,
<code>"date"</code>, guessed in a similar way to the <code>guess_parser()</code> function.
</p>
</li>
<li> <p><code>value</code>, the token itself as a character string, unchanged from its
representation in the original file.
</p>
</li></ul>

<p>If there are parsing problems, a warning tells you
how many, and you can retrieve the details with <code><a href="#topic+problems">problems()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="readr.html#topic+read_delim">readr::read_delim()</a></code> for the conventional way to read rectangular data
from delimited files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Input sources -------------------------------------------------------------
# Read from a path
melt_csv(meltr_example("mtcars.csv"))
## Not run: 
melt_csv("https://github.com/tidyverse/readr/raw/master/inst/extdata/mtcars.csv")

## End(Not run)

# Or directly from a string (must contain a newline)
melt_csv("x,y\n1,2\n3,4")

# To import empty cells as 'empty' rather than `NA`
melt_csv("x,y\n,NA,\"\",''", na = "NA")

# File types ----------------------------------------------------------------
melt_csv("a,b\n1.0,2.0")
melt_csv2("a;b\n1,0;2,0")
melt_tsv("a\tb\n1.0\t2.0")
melt_delim("a|b\n1.0|2.0", delim = "|")
</code></pre>

<hr>
<h2 id='melt_delim_chunked'>Melt a delimited file by chunks</h2><span id='topic+melt_delim_chunked'></span><span id='topic+melt_csv_chunked'></span><span id='topic+melt_csv2_chunked'></span><span id='topic+melt_tsv_chunked'></span>

<h3>Description</h3>

<p>For certain non-rectangular data formats, it can be useful to parse the data
into a melted format where each row represents a single token.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>melt_delim_chunked(
  file,
  callback,
  chunk_size = 10000,
  delim,
  quote = "\"",
  escape_backslash = FALSE,
  escape_double = TRUE,
  locale = default_locale(),
  na = c("", "NA"),
  quoted_na = TRUE,
  comment = "",
  trim_ws = FALSE,
  skip = 0,
  progress = show_progress(),
  skip_empty_rows = FALSE
)

melt_csv_chunked(
  file,
  callback,
  chunk_size = 10000,
  locale = default_locale(),
  na = c("", "NA"),
  quoted_na = TRUE,
  quote = "\"",
  comment = "",
  trim_ws = TRUE,
  skip = 0,
  progress = show_progress(),
  skip_empty_rows = FALSE
)

melt_csv2_chunked(
  file,
  callback,
  chunk_size = 10000,
  locale = default_locale(),
  na = c("", "NA"),
  quoted_na = TRUE,
  quote = "\"",
  comment = "",
  trim_ws = TRUE,
  skip = 0,
  progress = show_progress(),
  skip_empty_rows = FALSE
)

melt_tsv_chunked(
  file,
  callback,
  chunk_size = 10000,
  locale = default_locale(),
  na = c("", "NA"),
  quoted_na = TRUE,
  quote = "\"",
  comment = "",
  trim_ws = TRUE,
  skip = 0,
  progress = show_progress(),
  skip_empty_rows = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="melt_delim_chunked_+3A_file">file</code></td>
<td>
<p>Either a path to a file, a connection, or literal data
(either a single string or a raw vector).
</p>
<p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will
be automatically uncompressed. Files starting with <code style="white-space: pre;">&#8288;http://&#8288;</code>,
<code style="white-space: pre;">&#8288;https://&#8288;</code>, <code style="white-space: pre;">&#8288;ftp://&#8288;</code>, or <code style="white-space: pre;">&#8288;ftps://&#8288;</code> will be automatically
downloaded. Remote gz files can also be automatically downloaded and
decompressed.
</p>
<p>Literal data is most useful for examples and tests. To be recognised as
literal data, the input must be either wrapped with <code>I()</code>, be a string
containing at least one new line, or be a vector containing at least one
string with a new line.
</p>
<p>Using a value of <code><a href="readr.html#topic+clipboard">clipboard()</a></code> will read from the system clipboard.</p>
</td></tr>
<tr><td><code id="melt_delim_chunked_+3A_callback">callback</code></td>
<td>
<p>A callback function to call on each chunk</p>
</td></tr>
<tr><td><code id="melt_delim_chunked_+3A_chunk_size">chunk_size</code></td>
<td>
<p>The number of rows to include in each chunk</p>
</td></tr>
<tr><td><code id="melt_delim_chunked_+3A_delim">delim</code></td>
<td>
<p>Single character used to separate fields within a record.</p>
</td></tr>
<tr><td><code id="melt_delim_chunked_+3A_quote">quote</code></td>
<td>
<p>Single character used to quote strings.</p>
</td></tr>
<tr><td><code id="melt_delim_chunked_+3A_escape_backslash">escape_backslash</code></td>
<td>
<p>Does the file use backslashes to escape special
characters? This is more general than <code>escape_double</code> as backslashes
can be used to escape the delimiter character, the quote character, or
to add special characters like <code style="white-space: pre;">&#8288;\\n&#8288;</code>.</p>
</td></tr>
<tr><td><code id="melt_delim_chunked_+3A_escape_double">escape_double</code></td>
<td>
<p>Does the file escape quotes by doubling them?
i.e. If this option is <code>TRUE</code>, the value <code style="white-space: pre;">&#8288;""""&#8288;</code> represents
a single quote, <code style="white-space: pre;">&#8288;\"&#8288;</code>.</p>
</td></tr>
<tr><td><code id="melt_delim_chunked_+3A_locale">locale</code></td>
<td>
<p>The locale controls defaults that vary from place to place.
The default locale is US-centric (like R), but you can use
<code><a href="readr.html#topic+locale">locale()</a></code> to create your own locale that controls things like
the default time zone, encoding, decimal mark, big mark, and day/month
names.</p>
</td></tr>
<tr><td><code id="melt_delim_chunked_+3A_na">na</code></td>
<td>
<p>Character vector of strings to interpret as missing values. Set this
option to <code>character()</code> to indicate no missing values.</p>
</td></tr>
<tr><td><code id="melt_delim_chunked_+3A_quoted_na">quoted_na</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Should missing values
inside quotes be treated as missing values (the default) or strings. This
parameter is soft deprecated as of readr 2.0.0.</p>
</td></tr>
<tr><td><code id="melt_delim_chunked_+3A_comment">comment</code></td>
<td>
<p>A string used to identify comments. Any text after the
comment characters will be silently ignored.</p>
</td></tr>
<tr><td><code id="melt_delim_chunked_+3A_trim_ws">trim_ws</code></td>
<td>
<p>Should leading and trailing whitespace (ASCII spaces and tabs) be trimmed from
each field before parsing it?</p>
</td></tr>
<tr><td><code id="melt_delim_chunked_+3A_skip">skip</code></td>
<td>
<p>Number of lines to skip before reading data. If <code>comment</code> is
supplied any commented lines are ignored <em>after</em> skipping.</p>
</td></tr>
<tr><td><code id="melt_delim_chunked_+3A_progress">progress</code></td>
<td>
<p>Display a progress bar? By default it will only display
in an interactive session and not while knitting a document. The automatic
progress bar can be disabled by setting option <code>readr.show_progress</code> to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="melt_delim_chunked_+3A_skip_empty_rows">skip_empty_rows</code></td>
<td>
<p>Should blank rows be ignored altogether? i.e. If this
option is <code>TRUE</code> then blank rows will not be represented at all.  If it is
<code>FALSE</code> then they will be represented by <code>NA</code> values in all the columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>melt_delim_chunked()</code> and the specialisations <code>melt_csv_chunked()</code>,
<code>melt_csv2_chunked()</code> and <code>melt_tsv_chunked()</code> read files by a chunk of rows
at a time, executing a given function on one chunk before reading the next.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble()</a></code> of four columns:
</p>

<ul>
<li> <p><code>row</code>, the row that the token comes from in the original file
</p>
</li>
<li> <p><code>col</code>, the column that the token comes from in the original file
</p>
</li>
<li> <p><code>data_type</code>, the data type of the token, e.g. <code>"integer"</code>, <code>"character"</code>,
<code>"date"</code>, guessed in a similar way to the <code>guess_parser()</code> function.
</p>
</li>
<li> <p><code>value</code>, the token itself as a character string, unchanged from its
representation in the original file.
</p>
</li></ul>

<p>If there are parsing problems, a warning tells you
how many, and you can retrieve the details with <code><a href="#topic+problems">problems()</a></code>.
</p>


<h3>See Also</h3>

<p>Other chunked: 
<code><a href="#topic+callback">callback</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Cars with 3 gears
f &lt;- function(x, pos) subset(x, data_type == "integer")
melt_csv_chunked(meltr_example("mtcars.csv"), DataFrameCallback$new(f), chunk_size = 5)
</code></pre>

<hr>
<h2 id='melt_fwf'>Return melted data for each token in a fixed width file</h2><span id='topic+melt_fwf'></span><span id='topic+fwf_empty'></span><span id='topic+fwf_widths'></span><span id='topic+fwf_positions'></span><span id='topic+fwf_cols'></span>

<h3>Description</h3>

<p>For certain non-rectangular data formats, it can be useful to parse the data
into a melted format where each row represents a single token.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>melt_fwf(
  file,
  col_positions,
  locale = default_locale(),
  na = c("", "NA"),
  comment = "",
  trim_ws = TRUE,
  skip = 0,
  n_max = Inf,
  progress = show_progress(),
  skip_empty_rows = FALSE
)

fwf_empty(
  file,
  skip = 0,
  skip_empty_rows = FALSE,
  col_names = NULL,
  comment = "",
  n = 100L
)

fwf_widths(widths, col_names = NULL)

fwf_positions(start, end = NULL, col_names = NULL)

fwf_cols(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="melt_fwf_+3A_file">file</code></td>
<td>
<p>Either a path to a file, a connection, or literal data
(either a single string or a raw vector).
</p>
<p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will
be automatically uncompressed. Files starting with <code style="white-space: pre;">&#8288;http://&#8288;</code>,
<code style="white-space: pre;">&#8288;https://&#8288;</code>, <code style="white-space: pre;">&#8288;ftp://&#8288;</code>, or <code style="white-space: pre;">&#8288;ftps://&#8288;</code> will be automatically
downloaded. Remote gz files can also be automatically downloaded and
decompressed.
</p>
<p>Literal data is most useful for examples and tests. To be recognised as
literal data, the input must be either wrapped with <code>I()</code>, be a string
containing at least one new line, or be a vector containing at least one
string with a new line.
</p>
<p>Using a value of <code><a href="readr.html#topic+clipboard">clipboard()</a></code> will read from the system clipboard.</p>
</td></tr>
<tr><td><code id="melt_fwf_+3A_col_positions">col_positions</code></td>
<td>
<p>Column positions, as created by <code><a href="#topic+fwf_empty">fwf_empty()</a></code>,
<code><a href="#topic+fwf_widths">fwf_widths()</a></code> or <code><a href="#topic+fwf_positions">fwf_positions()</a></code>. To read in only selected fields,
use <code><a href="#topic+fwf_positions">fwf_positions()</a></code>. If the width of the last column is variable (a
ragged fwf file), supply the last end position as NA.</p>
</td></tr>
<tr><td><code id="melt_fwf_+3A_locale">locale</code></td>
<td>
<p>The locale controls defaults that vary from place to place.
The default locale is US-centric (like R), but you can use
<code><a href="readr.html#topic+locale">locale()</a></code> to create your own locale that controls things like
the default time zone, encoding, decimal mark, big mark, and day/month
names.</p>
</td></tr>
<tr><td><code id="melt_fwf_+3A_na">na</code></td>
<td>
<p>Character vector of strings to interpret as missing values. Set this
option to <code>character()</code> to indicate no missing values.</p>
</td></tr>
<tr><td><code id="melt_fwf_+3A_comment">comment</code></td>
<td>
<p>A string used to identify comments. Any text after the
comment characters will be silently ignored.</p>
</td></tr>
<tr><td><code id="melt_fwf_+3A_trim_ws">trim_ws</code></td>
<td>
<p>Should leading and trailing whitespace (ASCII spaces and tabs) be trimmed from
each field before parsing it?</p>
</td></tr>
<tr><td><code id="melt_fwf_+3A_skip">skip</code></td>
<td>
<p>Number of lines to skip before reading data.</p>
</td></tr>
<tr><td><code id="melt_fwf_+3A_n_max">n_max</code></td>
<td>
<p>Maximum number of lines to read.</p>
</td></tr>
<tr><td><code id="melt_fwf_+3A_progress">progress</code></td>
<td>
<p>Display a progress bar? By default it will only display
in an interactive session and not while knitting a document. The automatic
progress bar can be disabled by setting option <code>readr.show_progress</code> to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="melt_fwf_+3A_skip_empty_rows">skip_empty_rows</code></td>
<td>
<p>Should blank rows be ignored altogether? i.e. If this
option is <code>TRUE</code> then blank rows will not be represented at all.  If it is
<code>FALSE</code> then they will be represented by <code>NA</code> values in all the columns.</p>
</td></tr>
<tr><td><code id="melt_fwf_+3A_col_names">col_names</code></td>
<td>
<p>Either NULL, or a character vector column names.</p>
</td></tr>
<tr><td><code id="melt_fwf_+3A_n">n</code></td>
<td>
<p>Number of lines the tokenizer will read to determine file structure. By default
it is set to 100.</p>
</td></tr>
<tr><td><code id="melt_fwf_+3A_widths">widths</code></td>
<td>
<p>Width of each field. Use NA as width of last field when
reading a ragged fwf file.</p>
</td></tr>
<tr><td><code id="melt_fwf_+3A_start">start</code>, <code id="melt_fwf_+3A_end">end</code></td>
<td>
<p>Starting and ending (inclusive) positions of each field.
Use NA as last end field when reading a ragged fwf file.</p>
</td></tr>
<tr><td><code id="melt_fwf_+3A_...">...</code></td>
<td>
<p>If the first element is a data frame,
then it must have all numeric columns and either one or two rows.
The column names are the variable names. The column values are the
variable widths if a length one vector, and if length two, variable start and end
positions. The elements of <code>...</code> are used to construct a data frame
with or or two rows as above.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>melt_fwf()</code> parses each token of a fixed width file into a single row, but
it still requires that each field is in the same in every row of the
source file.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble()</a></code> of four columns:
</p>

<ul>
<li> <p><code>row</code>, the row that the token comes from in the original file
</p>
</li>
<li> <p><code>col</code>, the column that the token comes from in the original file
</p>
</li>
<li> <p><code>data_type</code>, the data type of the token, e.g. <code>"integer"</code>, <code>"character"</code>,
<code>"date"</code>, guessed in a similar way to the <code>guess_parser()</code> function.
</p>
</li>
<li> <p><code>value</code>, the token itself as a character string, unchanged from its
representation in the original file.
</p>
</li></ul>

<p>If there are parsing problems, a warning tells you
how many, and you can retrieve the details with <code><a href="#topic+problems">problems()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+melt_table">melt_table()</a></code> to melt fixed width files where each
column is separated by whitespace, and <code><a href="#topic+melt_fwf">melt_fwf()</a></code> for the conventional
way to read rectangular data from fixed width files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fwf_sample &lt;- meltr_example("fwf-sample.txt")
writeLines(readLines(fwf_sample))

# You can specify column positions in several ways:
# 1. Guess based on position of empty columns
melt_fwf(fwf_sample, fwf_empty(fwf_sample, col_names = c("first", "last", "state", "ssn")))
# 2. A vector of field widths
melt_fwf(fwf_sample, fwf_widths(c(20, 10, 12), c("name", "state", "ssn")))
# 3. Paired vectors of start and end positions
melt_fwf(fwf_sample, fwf_positions(c(1, 30), c(10, 42), c("name", "ssn")))
# 4. Named arguments with start and end positions
melt_fwf(fwf_sample, fwf_cols(name = c(1, 10), ssn = c(30, 42)))
# 5. Named arguments with column widths
melt_fwf(fwf_sample, fwf_cols(name = 20, state = 10, ssn = 12))
</code></pre>

<hr>
<h2 id='melt_table'>Return melted data for each token in a whitespace-separated file</h2><span id='topic+melt_table'></span><span id='topic+melt_table2'></span>

<h3>Description</h3>

<p>For certain non-rectangular data formats, it can be useful to parse the data
into a melted format where each row represents a single token.
</p>
<p><code>melt_table()</code> and <code>melt_table2()</code> are designed to read the type of textual
data where each column is separated by one (or more) columns of space.
</p>
<p><code>melt_table2()</code> allows any number of whitespace characters between columns,
and the lines can be of different lengths.
</p>
<p><code>melt_table()</code> is more strict, each line must be the same length,
and each field is in the same position in every line. It first finds empty
columns and then parses like a fixed width file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>melt_table(
  file,
  locale = default_locale(),
  na = "NA",
  skip = 0,
  n_max = Inf,
  guess_max = min(n_max, 1000),
  progress = show_progress(),
  comment = "",
  skip_empty_rows = FALSE
)

melt_table2(
  file,
  locale = default_locale(),
  na = "NA",
  skip = 0,
  n_max = Inf,
  progress = show_progress(),
  comment = "",
  skip_empty_rows = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="melt_table_+3A_file">file</code></td>
<td>
<p>Either a path to a file, a connection, or literal data
(either a single string or a raw vector).
</p>
<p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will
be automatically uncompressed. Files starting with <code style="white-space: pre;">&#8288;http://&#8288;</code>,
<code style="white-space: pre;">&#8288;https://&#8288;</code>, <code style="white-space: pre;">&#8288;ftp://&#8288;</code>, or <code style="white-space: pre;">&#8288;ftps://&#8288;</code> will be automatically
downloaded. Remote gz files can also be automatically downloaded and
decompressed.
</p>
<p>Literal data is most useful for examples and tests. To be recognised as
literal data, the input must be either wrapped with <code>I()</code>, be a string
containing at least one new line, or be a vector containing at least one
string with a new line.
</p>
<p>Using a value of <code><a href="readr.html#topic+clipboard">clipboard()</a></code> will read from the system clipboard.</p>
</td></tr>
<tr><td><code id="melt_table_+3A_locale">locale</code></td>
<td>
<p>The locale controls defaults that vary from place to place.
The default locale is US-centric (like R), but you can use
<code><a href="readr.html#topic+locale">locale()</a></code> to create your own locale that controls things like
the default time zone, encoding, decimal mark, big mark, and day/month
names.</p>
</td></tr>
<tr><td><code id="melt_table_+3A_na">na</code></td>
<td>
<p>Character vector of strings to interpret as missing values. Set this
option to <code>character()</code> to indicate no missing values.</p>
</td></tr>
<tr><td><code id="melt_table_+3A_skip">skip</code></td>
<td>
<p>Number of lines to skip before reading data.</p>
</td></tr>
<tr><td><code id="melt_table_+3A_n_max">n_max</code></td>
<td>
<p>Maximum number of lines to read.</p>
</td></tr>
<tr><td><code id="melt_table_+3A_guess_max">guess_max</code></td>
<td>
<p>Maximum number of lines to use for guessing column types.
See <code>vignette("column-types", package = "readr")</code> for more details.</p>
</td></tr>
<tr><td><code id="melt_table_+3A_progress">progress</code></td>
<td>
<p>Display a progress bar? By default it will only display
in an interactive session and not while knitting a document. The automatic
progress bar can be disabled by setting option <code>readr.show_progress</code> to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="melt_table_+3A_comment">comment</code></td>
<td>
<p>A string used to identify comments. Any text after the
comment characters will be silently ignored.</p>
</td></tr>
<tr><td><code id="melt_table_+3A_skip_empty_rows">skip_empty_rows</code></td>
<td>
<p>Should blank rows be ignored altogether? i.e. If this
option is <code>TRUE</code> then blank rows will not be represented at all.  If it is
<code>FALSE</code> then they will be represented by <code>NA</code> values in all the columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble()</a></code> of four columns:
</p>

<ul>
<li> <p><code>row</code>, the row that the token comes from in the original file
</p>
</li>
<li> <p><code>col</code>, the column that the token comes from in the original file
</p>
</li>
<li> <p><code>data_type</code>, the data type of the token, e.g. <code>"integer"</code>, <code>"character"</code>,
<code>"date"</code>, guessed in a similar way to the <code>guess_parser()</code> function.
</p>
</li>
<li> <p><code>value</code>, the token itself as a character string, unchanged from its
representation in the original file.
</p>
</li></ul>

<p>If there are parsing problems, a warning tells you
how many, and you can retrieve the details with <code><a href="#topic+problems">problems()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+melt_fwf">melt_fwf()</a></code> to melt fixed width files where each column
is not separated by whitespace. <code>melt_fwf()</code> is also useful for reading
tabular data with non-standard formatting.  <code><a href="readr.html#topic+read_table">readr::read_table()</a></code> is the
conventional way to read tabular data from whitespace-separated files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># One corner from http://www.masseyratings.com/cf/compare.htm
massey &lt;- meltr_example("massey-rating.txt")
cat(readLines(massey))
melt_table(massey)

# Sample of 1978 fuel economy data from
# http://www.fueleconomy.gov/feg/epadata/78data.zip
epa &lt;- meltr_example("epa78.txt")
writeLines(readLines(epa))
melt_table(epa)
</code></pre>

<hr>
<h2 id='meltr_example'>Get path to meltr example</h2><span id='topic+meltr_example'></span>

<h3>Description</h3>

<p>meltr comes bundled with a number of sample files in its <code>inst/extdata</code>
directory. This function make them easy to access
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meltr_example(file = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meltr_example_+3A_file">file</code></td>
<td>
<p>Name of file. If <code>NULL</code>, the example files will be listed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A file path or a vector of file names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>meltr_example()
meltr_example("mtcars.csv")
</code></pre>

<hr>
<h2 id='problems'>Retrieve parsing problems</h2><span id='topic+problems'></span><span id='topic+stop_for_problems'></span>

<h3>Description</h3>

<p>Readr functions will only throw an error if parsing fails in an unrecoverable
way. However, there are lots of potential problems that you might want to
know about - these are stored in the <code>problems</code> attribute of the
output, which you can easily access with this function.
<code>stop_for_problems()</code> will throw an error if there are any parsing
problems: this is useful for automated scripts where you want to throw
an error as soon as you encounter a problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>problems(x = .Last.value)

stop_for_problems(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="problems_+3A_x">x</code></td>
<td>
<p>An data frame (from <code style="white-space: pre;">&#8288;read_*()&#8288;</code>) or a vector
(from <code style="white-space: pre;">&#8288;parse_*()&#8288;</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with one row for each problem and four columns:
</p>
<table>
<tr><td><code>row</code>, <code>col</code></td>
<td>
<p>Row and column of problem</p>
</td></tr>
<tr><td><code>expected</code></td>
<td>
<p>What readr expected to find</p>
</td></tr>
<tr><td><code>actual</code></td>
<td>
<p>What it actually got</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("readr")) {
x &lt;- readr::parse_integer(c("1X", "blah", "3"))
problems(x)

y &lt;- readr::parse_integer(c("1", "2", "3"))
problems(y)
}
</code></pre>

<hr>
<h2 id='show_progress'>Determine whether progress bars should be shown</h2><span id='topic+show_progress'></span>

<h3>Description</h3>

<p>Progress bars are shown <em>unless</em> one of the following is <code>TRUE</code>
</p>

<ul>
<li><p> The bar is explicitly disabled by setting <code>options(readr.show_progress = FALSE)</code>
</p>
</li>
<li><p> The code is run in a non-interactive session (<code>interactive()</code> is <code>FALSE</code>).
</p>
</li>
<li><p> The code is run in an RStudio notebook chunk.
</p>
</li>
<li><p> The code is run by knitr / rmarkdown.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>show_progress()
</code></pre>


<h3>Value</h3>

<p>A logical value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>show_progress()
</code></pre>

<hr>
<h2 id='Tokenizers'>Tokenizers.</h2><span id='topic+Tokenizers'></span><span id='topic+tokenizer_delim'></span><span id='topic+tokenizer_csv'></span><span id='topic+tokenizer_tsv'></span><span id='topic+tokenizer_line'></span><span id='topic+tokenizer_log'></span><span id='topic+tokenizer_fwf'></span><span id='topic+tokenizer_ws'></span>

<h3>Description</h3>

<p>Explicitly create tokenizer objects. Usually you will not call these
function, but will instead use one of the use friendly wrappers like
<code><a href="readr.html#topic+read_delim">readr::read_csv()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tokenizer_delim(
  delim,
  quote = "\"",
  na = "NA",
  quoted_na = TRUE,
  comment = "",
  trim_ws = TRUE,
  escape_double = TRUE,
  escape_backslash = FALSE,
  skip_empty_rows = TRUE
)

tokenizer_csv(
  na = "NA",
  quoted_na = TRUE,
  quote = "\"",
  comment = "",
  trim_ws = TRUE,
  skip_empty_rows = TRUE
)

tokenizer_tsv(
  na = "NA",
  quoted_na = TRUE,
  quote = "\"",
  comment = "",
  trim_ws = TRUE,
  skip_empty_rows = TRUE
)

tokenizer_line(na = character(), skip_empty_rows = TRUE)

tokenizer_log(trim_ws)

tokenizer_fwf(
  begin,
  end,
  na = "NA",
  comment = "",
  trim_ws = TRUE,
  skip_empty_rows = TRUE
)

tokenizer_ws(na = "NA", comment = "", skip_empty_rows = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tokenizers_+3A_delim">delim</code></td>
<td>
<p>Single character used to separate fields within a record.</p>
</td></tr>
<tr><td><code id="Tokenizers_+3A_quote">quote</code></td>
<td>
<p>Single character used to quote strings.</p>
</td></tr>
<tr><td><code id="Tokenizers_+3A_na">na</code></td>
<td>
<p>Character vector of strings to interpret as missing values. Set this
option to <code>character()</code> to indicate no missing values.</p>
</td></tr>
<tr><td><code id="Tokenizers_+3A_quoted_na">quoted_na</code></td>
<td>
<p>Should missing values inside quotes be treated as missing
values (the default) or strings.</p>
</td></tr>
<tr><td><code id="Tokenizers_+3A_comment">comment</code></td>
<td>
<p>A string used to identify comments. Any text after the
comment characters will be silently ignored.</p>
</td></tr>
<tr><td><code id="Tokenizers_+3A_trim_ws">trim_ws</code></td>
<td>
<p>Should leading and trailing whitespace (ASCII spaces and tabs) be trimmed from
each field before parsing it?</p>
</td></tr>
<tr><td><code id="Tokenizers_+3A_escape_double">escape_double</code></td>
<td>
<p>Does the file escape quotes by doubling them?
i.e. If this option is <code>TRUE</code>, the value <code style="white-space: pre;">&#8288;""""&#8288;</code> represents
a single quote, <code style="white-space: pre;">&#8288;\"&#8288;</code>.</p>
</td></tr>
<tr><td><code id="Tokenizers_+3A_escape_backslash">escape_backslash</code></td>
<td>
<p>Does the file use backslashes to escape special
characters? This is more general than <code>escape_double</code> as backslashes
can be used to escape the delimiter character, the quote character, or
to add special characters like <code style="white-space: pre;">&#8288;\\n&#8288;</code>.</p>
</td></tr>
<tr><td><code id="Tokenizers_+3A_skip_empty_rows">skip_empty_rows</code></td>
<td>
<p>Should blank rows be ignored altogether? i.e. If this
option is <code>TRUE</code> then blank rows will not be represented at all.  If it is
<code>FALSE</code> then they will be represented by <code>NA</code> values in all the columns.</p>
</td></tr>
<tr><td><code id="Tokenizers_+3A_begin">begin</code>, <code id="Tokenizers_+3A_end">end</code></td>
<td>
<p>Begin and end offsets for each file. These are C++
offsets so the first column is column zero, and the ranges are
[begin, end) (i.e inclusive-exclusive).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tokeenizer object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tokenizer_csv()
tokenizer_delim(",")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
