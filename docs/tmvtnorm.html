<!DOCTYPE html><html><head><title>Help for package tmvtnorm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tmvtnorm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dtmvnorm.marginal'><p>One-dimensional marginal density functions from a Truncated Multivariate Normal distribution</p></a></li>
<li><a href='#dtmvnorm.marginal2'>
<p>Bivariate marginal density functions from a Truncated Multivariate Normal distribution</p></a></li>
<li><a href='#dtmvt'><p>Truncated Multivariate Student t Density</p></a></li>
<li><a href='#gmm.tmvnorm'>
<p>GMM Estimation for the Truncated Multivariate Normal Distribution</p></a></li>
<li><a href='#mle.tmvnorm'>
<p>Maximum Likelihood Estimation for the Truncated Multivariate Normal Distribution</p></a></li>
<li><a href='#mtmvnorm'><p>Computation of Mean Vector and Covariance Matrix For Truncated Multivariate Normal Distribution</p></a></li>
<li><a href='#ptmvnorm'><p> Truncated Multivariate Normal Distribution</p></a></li>
<li><a href='#ptmvt'><p>Truncated Multivariate Student t Distribution</p></a></li>
<li><a href='#ptmvtnorm.marginal'><p>One-dimensional marginal CDF function for a Truncated Multivariate Normal and Student t distribution</p></a></li>
<li><a href='#qtmvnorm-marginal'><p> Quantiles of the Truncated Multivariate Normal Distribution in one dimension</p></a></li>
<li><a href='#rtmvnorm'><p>Sampling Random Numbers From The Truncated Multivariate Normal Distribution</p></a></li>
<li><a href='#rtmvnorm2'><p>Sampling Random Numbers From The Truncated Multivariate Normal Distribution With Linear Constraints</p></a></li>
<li><a href='#rtmvt'><p>Sampling Random Numbers From The Truncated Multivariate Student t Distribution</p></a></li>
<li><a href='#tmvnorm'><p>Truncated Multivariate Normal Density</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-05</td>
</tr>
<tr>
<td>Title:</td>
<td>Truncated Multivariate Normal and Student t Distribution</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, methods</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 1.9.0), mvtnorm, utils, Matrix, stats4, gmm</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lattice</td>
</tr>
<tr>
<td>Description:</td>
<td>Random number generation for the truncated multivariate normal and Student t distribution. 
  Computes probabilities, quantiles and densities, 
  including one-dimensional and bivariate marginal densities. Computes first and second moments (i.e. mean and covariance matrix) for the double-truncated multinormal case.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.r-project.org">https://www.r-project.org</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-05 08:47:20 UTC; stefan</td>
</tr>
<tr>
<td>Author:</td>
<td>Stefan Wilhelm [aut, cre],
  Manjunath B G [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stefan Wilhelm &lt;wilhelm@financial.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-05 16:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dtmvnorm.marginal'>One-dimensional marginal density functions from a Truncated Multivariate Normal distribution</h2><span id='topic+dtmvnorm.marginal'></span>

<h3>Description</h3>

<p>This function computes the one-dimensional marginal density function from a Truncated Multivariate Normal density function
using the algorithm given in Cartinhour (1990).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtmvnorm.marginal(xn, n=1, 
  mean= rep(0, nrow(sigma)), 
  sigma=diag(length(mean)), 
  lower=rep(-Inf, length = length(mean)), 
  upper=rep( Inf, length = length(mean)),
  log=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtmvnorm.marginal_+3A_xn">xn</code></td>
<td>
<p>Vector of quantiles to calculate the marginal density for.</p>
</td></tr>
<tr><td><code id="dtmvnorm.marginal_+3A_n">n</code></td>
<td>
<p>Index position (1..k) within the random vector x to calculate the one-dimensional marginal density for.</p>
</td></tr>
<tr><td><code id="dtmvnorm.marginal_+3A_mean">mean</code></td>
<td>
<p>Mean vector, default is <code>rep(0, length = nrow(sigma))</code>.</p>
</td></tr>
<tr><td><code id="dtmvnorm.marginal_+3A_sigma">sigma</code></td>
<td>
<p>Covariance matrix, default is <code>diag(length(mean))</code>.</p>
</td></tr>
<tr><td><code id="dtmvnorm.marginal_+3A_lower">lower</code></td>
<td>
<p>Vector of lower truncation points,\ 
default is <code>rep(-Inf, length = length(mean))</code>.</p>
</td></tr>
<tr><td><code id="dtmvnorm.marginal_+3A_upper">upper</code></td>
<td>
<p>Vector of upper truncation points,\ 
default is <code>rep( Inf, length = length(mean))</code>.</p>
</td></tr>
<tr><td><code id="dtmvnorm.marginal_+3A_log">log</code></td>
<td>
<p>Logical; if <code>TRUE</code>, densities d are given as log(d).</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>The one-dimensional marginal density <code class="reqn">f_i(x_i)</code> of <code class="reqn">x_i</code> is
</p>
<p style="text-align: center;"><code class="reqn">f_i(x_i) = \int_{a_1}^{b_1} \ldots \int_{a_{i-1}}^{b_{i-1}} \int_{a_{i+1}}^{b_{i+1}} \ldots \int_{a_k}^{b_k} f(x) dx_{-i}</code>
</p>

<p>Note that the one-dimensional marginal density is not truncated normal, but only conditional densities are truncated normal.
</p>


<h3>Author(s)</h3>

<p>Stefan Wilhelm &lt;Stefan.Wilhelm@financial.com&gt;</p>


<h3>References</h3>

<p>Cartinhour, J. (1990). One-dimensional marginal density functions of a truncated multivariate normal density function.
<em>Communications in Statistics - Theory and Methods</em>, <b>19</b>, 197&ndash;203
</p>
<p>Arnold et al. (1993). The Nontruncated Marginal of a Truncated Bivariate Normal Distribution.
<em>Psychometrika</em>, <b>58</b>, 471&ndash;488
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################
#
# Example 1: truncated bivariate normal
#
#############################################

# parameters of the bivariate normal distribution
sigma = matrix(c(1   , 0.95,
                 0.95, 1    ), 2, 2)
mu = c(0,0)

# sample from multivariate normal distribution
X = rmvnorm(5000, mu, sigma)

# tuncation in x2 with x2 &lt;= 0
X.trunc = X[X[,2]&lt;0,]

# plot the realisations before and after truncation
par(mfrow=c(2,2))
plot(X, col="gray", xlab=expression(x[1]), ylab=expression(x[2]), 
  main="realisations from a\n truncated bivariate normal distribution")
points(X.trunc)
abline(h=0, lty=2, col="gray")
#legend("topleft", col=c("gray", "black")

# marginal density for x1 from realisations
plot(density(X.trunc[,1]), main=expression("marginal density for "*x[1]))

# one-dimensional marginal density for x1 using the formula
x &lt;- seq(-5, 5, by=0.01)
fx &lt;- dtmvnorm.marginal(x, n=1, mean=mu, sigma=sigma, 
  lower=c(-Inf,-Inf), upper=c(Inf,0))
lines(x, fx, lwd=2, col="red")

# marginal density for x2
plot(density(X.trunc[,2]), main=expression("marginal density for "*x[2]))

# one-dimensional marginal density for x2 using the formula
x &lt;- seq(-5, 5, by=0.01)
fx &lt;- dtmvnorm.marginal(x, n=2, mean=mu, sigma=sigma, 
  lower=c(-Inf,-Inf), upper=c(Inf,0))
lines(x, fx, lwd=2, col="blue")

#############################################
#
# Example 2 : truncated trivariate normal
#
#############################################

# parameters of the trivariate normal distribution
sigma = outer(1:3,1:3,pmin)
mu    = c(0,0,0)

# sample from multivariate normal distribution
X     = rmvnorm(2000, mu, sigma)

# truncation in x2 and x3 : x2 &lt;= 0, x3 &lt;= 0
X.trunc = X[X[,2]&lt;=0 &amp; X[,3]&lt;=0,]

par(mfrow=c(2,3))
plot(X, col="gray", xlab=expression(x[1]), ylab=expression(x[2]), 
  main="realisations from a\n truncated trivariate normal distribution")
points(X.trunc, col="black")
abline(h=0, lty=2, col="gray")

plot(X[,2:3], col="gray", xlab=expression(x[2]), ylab=expression(x[3]), 
  main="realisations from a\n truncated trivariate normal distribution")
points(X.trunc[,2:3], col="black")
abline(h=0, lty=2, col="gray")
abline(v=0, lty=2, col="gray")

plot(X[,c(1,3)], col="gray", xlab=expression(x[1]), ylab=expression(x[3]), 
  main="realisations from a\n truncated trivariate normal distribution")
points(X.trunc[,c(1,3)], col="black")
abline(h=0, lty=2, col="gray")

# one-dimensional marginal density for x1 from realisations and formula
plot(density(X.trunc[,1]), main=expression("marginal density for "*x[1]))
x &lt;- seq(-5, 5, by=0.01)
fx &lt;- dtmvnorm.marginal(x, n=1, mean=mu, sigma=sigma, 
  lower=c(-Inf,-Inf,-Inf), upper=c(Inf,0,0))
lines(x, fx, lwd=2, col="red")

# one-dimensional marginal density for x2 from realisations and formula
plot(density(X.trunc[,2]), main=expression("marginal density for "*x[2]))
x &lt;- seq(-5, 5, by=0.01)
fx &lt;- dtmvnorm.marginal(x, n=2, mean=mu, sigma=sigma, 
  lower=c(-Inf,-Inf,-Inf), upper=c(Inf,0,0))
lines(x, fx, lwd=2, col="red")

# one-dimensional marginal density for x3 from realisations and formula
plot(density(X.trunc[,3]), main=expression("marginal density for "*x[3]))
x &lt;- seq(-5, 5, by=0.01)
fx &lt;- dtmvnorm.marginal(x, n=3, mean=mu, sigma=sigma, 
  lower=c(-Inf,-Inf,-Inf), upper=c(Inf,0,0))
lines(x, fx, lwd=2, col="red")
</code></pre>

<hr>
<h2 id='dtmvnorm.marginal2'>
Bivariate marginal density functions from a Truncated Multivariate Normal distribution
</h2><span id='topic+dtmvnorm.marginal2'></span>

<h3>Description</h3>

<p>This function computes the bivariate marginal density function <code class="reqn">f(x_q, x_r)</code> from a k-dimensional Truncated Multivariate Normal density function (k&gt;=2).
The bivariate marginal density is obtained by integrating out (k-2) dimensions as proposed by Tallis (1961).
This function is basically an extraction of the Leppard and Tallis (1989) Fortran code for moments calculation,
but extended to the double truncated case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtmvnorm.marginal2(xq, xr, q, r, 
 mean = rep(0, nrow(sigma)), 
 sigma = diag(length(mean)), 
 lower = rep(-Inf, length = length(mean)), 
 upper = rep(Inf, length = length(mean)),
 log = FALSE, pmvnorm.algorithm=GenzBretz())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtmvnorm.marginal2_+3A_xq">xq</code></td>
<td>
<p>Value <code class="reqn">x_q</code></p>
</td></tr>
<tr><td><code id="dtmvnorm.marginal2_+3A_xr">xr</code></td>
<td>
<p>Value <code class="reqn">x_r</code></p>
</td></tr>
<tr><td><code id="dtmvnorm.marginal2_+3A_q">q</code></td>
<td>
<p>Index position for <code class="reqn">x_q</code> within mean vector to calculate the bivariate marginal density for.</p>
</td></tr>
<tr><td><code id="dtmvnorm.marginal2_+3A_r">r</code></td>
<td>
<p>Index position for <code class="reqn">x_r</code> within mean vector to calculate the bivariate marginal density for.</p>
</td></tr>
<tr><td><code id="dtmvnorm.marginal2_+3A_mean">mean</code></td>
<td>
<p>Mean vector, default is <code>rep(0, length = nrow(sigma))</code>.</p>
</td></tr>
<tr><td><code id="dtmvnorm.marginal2_+3A_sigma">sigma</code></td>
<td>
<p>Covariance matrix, default is <code>diag(length(mean))</code>.</p>
</td></tr>
<tr><td><code id="dtmvnorm.marginal2_+3A_lower">lower</code></td>
<td>
<p>Vector of lower truncation points, 
default is <code>rep(-Inf, length = length(mean))</code>.</p>
</td></tr>
<tr><td><code id="dtmvnorm.marginal2_+3A_upper">upper</code></td>
<td>
<p>Vector of upper truncation points, 
default is <code>rep( Inf, length = length(mean))</code>.</p>
</td></tr>
<tr><td><code id="dtmvnorm.marginal2_+3A_log">log</code></td>
<td>
<p>Logical; if <code>TRUE</code>, densities d are given as log(d).</p>
</td></tr> 
<tr><td><code id="dtmvnorm.marginal2_+3A_pmvnorm.algorithm">pmvnorm.algorithm</code></td>
<td>
<p>Algorithm used for <code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bivariate marginal density function <code class="reqn">f(x_q, x_r)</code> for <code class="reqn">x \sim TN(\mu, \Sigma, a, b)</code> and <code class="reqn">q \ne r</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">F_{q,r}(x_q=c_q, x_r=c_r) = 
  \int^{b_1}_{a_1}...\int^{b_{q-1}}_{a_{q-1}}\int^{b_{q+1}}_{a_{q+1}}...\int^{b_{r-1}}_{a_{r-1}}\int^{b_{r+1}}_{a_{r+1}}...\int^{b_{k}}_{a_{k}} 
  \varphi{_{\alpha}}_{\Sigma}(x_s, c_q, c_r) dx_s</code>
</p>



<h3>Author(s)</h3>

<p>Stefan Wilhelm &lt;Stefan.Wilhelm@financial.com&gt;, Manjunath B G &lt;bgmanjunath@gmail.com&gt;</p>


<h3>References</h3>

<p>Tallis, G. M. (1961). The moment generating function of the truncated multinormal distribution. 
<em>Journal of the Royal Statistical Society, Series B</em>, <b>23</b>, 223&ndash;229
</p>
<p>Leppard, P. and Tallis, G. M. (1989). Evaluation of the Mean and Covariance of the Truncated Multinormal
<em>Applied Statistics</em>, <b>38</b>, 543&ndash;553
</p>
<p>Manjunath B G and Wilhelm, S. (2009). Moments Calculation For the Double Truncated Multivariate Normal Density. 
Working Paper. Available at SSRN: <a href="https://www.ssrn.com/abstract=1472153">https://www.ssrn.com/abstract=1472153</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  lower = c(-0.5, -1, -1)
  upper = c( 2.2,  2,  2)
  
  mean  = c(0,0,0)
  sigma = matrix(c(2.0, -0.6,  0.7, 
                  -0.6,  1.0, -0.2, 
                   0.7, -0.2,  1.0), 3, 3)
  
  # generate random samples from untruncated and truncated distribution
  Y = rmvnorm(10000, mean=mean, sigma=sigma)
  X = rtmvnorm(500,  mean=mean, sigma=sigma, lower=lower, upper=upper, 
      algorithm="gibbs")
    
  # compute bivariate marginal density of x1 and x2
  xq &lt;- seq(lower[1], upper[1], by=0.1)
  xr &lt;- seq(lower[2], upper[2], by=0.1)
  
  grid &lt;- matrix(NA, length(xq), length(xr))
  for (i in 1:length(xq))
  {
    for (j in 1:length(xr))
    {
      grid[i,j] = dtmvnorm.marginal2(xq=xq[i], xr=xr[j], 
        q=1, r=2, sigma=sigma, lower=lower, upper=upper)
    }
  }
  
  plot(Y[,1], Y[,2], xlim=c(-4, 4), ylim=c(-4, 4), 
     main=expression("bivariate marginal density ("*x[1]*","*x[2]*")"), 
     xlab=expression(x[1]), ylab=expression(x[2]), col="gray80")
  points(X[,1], X[,2], col="black")
  
  lines(x=c(lower[1], upper[1], upper[1], lower[1], lower[1]), 
        y=c(lower[2],lower[2],upper[2],upper[2],lower[2]), 
        lty=2, col="red")
  contour(xq, xr, grid, add=TRUE, nlevels = 8, col="red", lwd=2)
  
  # scatterplot matrices for untruncated and truncated points
  require(lattice)
  splom(Y)
  splom(X)
</code></pre>

<hr>
<h2 id='dtmvt'>Truncated Multivariate Student t Density</h2><span id='topic+dtmvt'></span>

<h3>Description</h3>

<p>This function provides the joint density function for the truncated multivariate Student t
distribution with mean vector equal to <code>mean</code>, covariance matrix
<code>sigma</code>, degrees of freedom parameter <code>df</code> and 
lower and upper truncation points <code>lower</code> and <code>upper</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtmvt(x, mean = rep(0, nrow(sigma)), sigma = diag(length(mean)), df = 1, 
lower = rep(-Inf, length = length(mean)), 
upper = rep(Inf, length = length(mean)), log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtmvt_+3A_x">x</code></td>
<td>
<p>Vector or matrix of quantiles. If <code>x</code> is a matrix, each row is taken to be a quantile.</p>
</td></tr>
<tr><td><code id="dtmvt_+3A_mean">mean</code></td>
<td>
<p>Mean vector, default is <code>rep(0, nrow(sigma))</code>.</p>
</td></tr>
<tr><td><code id="dtmvt_+3A_sigma">sigma</code></td>
<td>
<p>Covariance matrix, default is <code>diag(length(mean))</code>.</p>
</td></tr>
<tr><td><code id="dtmvt_+3A_df">df</code></td>
<td>
<p>degrees of freedom parameter</p>
</td></tr>
<tr><td><code id="dtmvt_+3A_lower">lower</code></td>
<td>
<p>Vector of lower truncation points, 
default is <code>rep(-Inf, length = length(mean))</code>.</p>
</td></tr>
<tr><td><code id="dtmvt_+3A_upper">upper</code></td>
<td>
<p>Vector of upper truncation points, 
default is <code>rep( Inf, length = length(mean))</code>.</p>
</td></tr>
<tr><td><code id="dtmvt_+3A_log">log</code></td>
<td>
<p>Logical; if <code>TRUE</code>, densities d are given as log(d).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Truncated Multivariate Student t Distribution is a conditional Multivariate Student t distribution 
subject to (linear) constraints <code class="reqn">a \le \bold{x} \le b</code>.
</p>
<p>The density of the <code class="reqn">p</code>-variate Multivariate Student t distribution with <code class="reqn">\nu</code> degrees of freedom is 
</p>
<p style="text-align: center;"><code class="reqn">
 f(\bold{x}) = \frac{\Gamma((\nu + p)/2)}{(\pi\nu)^{p/2} \Gamma(\nu/2) \|\Sigma\|^{1/2}}
               [ 1 + \frac{1}{\nu} (x - \mu)^T \Sigma^{-1} (x - \mu) ]^{- (\nu + p) / 2}
</code>
</p>

<p>The density of the truncated distribution <code class="reqn">f_{a,b}(x)</code> with constraints <code class="reqn">(a \le x \le b)</code> is accordingly
</p>
<p style="text-align: center;"><code class="reqn">
 f_{a,b}(x) = \frac{f(\bold{x})} {P(a \le x \le b)}
</code>
</p>



<h3>Value</h3>

<p>a numeric vector with density values
</p>


<h3>Author(s)</h3>

<p>Stefan Wilhelm <a href="mailto:wilhelm@financial.com">wilhelm@financial.com</a></p>


<h3>References</h3>

<p>Geweke, J. F. (1991) Efficient simulation from the multivariate normal and Student-t distributions 
subject to linear constraints and the evaluation of constraint probabilities.
<a href="https://www.researchgate.net/publication/2335219_Efficient_Simulation_from_the_Multivariate_Normal_and_Student-t_Distributions_Subject_to_Linear_Constraints_and_the_Evaluation_of_Constraint_Probabilities">https://www.researchgate.net/publication/2335219_Efficient_Simulation_from_the_Multivariate_Normal_and_Student-t_Distributions_Subject_to_Linear_Constraints_and_the_Evaluation_of_Constraint_Probabilities</a> 
</p>
<p>Samuel Kotz, Saralees Nadarajah (2004). Multivariate t Distributions and Their Applications. 
<em>Cambridge University Press</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ptmvt">ptmvt</a></code> and <code><a href="#topic+rtmvt">rtmvt</a></code> for probabilities and random number generation in the truncated case, 
see <code><a href="mvtnorm.html#topic+dmvt">dmvt</a></code>, <code><a href="mvtnorm.html#topic+rmvt">rmvt</a></code> and <code><a href="mvtnorm.html#topic+pmvt">pmvt</a></code> 
for the untruncated multi-t distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example

x1 &lt;- seq(-2, 3, by=0.1)
x2 &lt;- seq(-2, 3, by=0.1)

mean &lt;- c(0,0)
sigma &lt;- matrix(c(1, -0.5, -0.5, 1), 2, 2)
lower &lt;- c(-1,-1)


density &lt;- function(x)
{
	z=dtmvt(x, mean=mean, sigma=sigma, lower=lower)
	z
}

fgrid &lt;- function(x, y, f)
{
	z &lt;- matrix(nrow=length(x), ncol=length(y))
	for(m in 1:length(x)){
		for(n in 1:length(y)){
			z[m,n] &lt;- f(c(x[m], y[n]))
		}
	}
	z
}

# compute multivariate-t density d for grid
d &lt;- fgrid(x1, x2, function(x) dtmvt(x, mean=mean, sigma=sigma, lower=lower))

# compute multivariate normal density d for grid
d2 &lt;- fgrid(x1, x2, function(x) dtmvnorm(x, mean=mean, sigma=sigma, lower=lower))

# plot density as contourplot
contour(x1, x2, d, nlevels=5, main="Truncated Multivariate t Density", 
		xlab=expression(x[1]), ylab=expression(x[2]))

contour(x1, x2, d2, nlevels=5, add=TRUE, col="red")
abline(v=-1, lty=3, lwd=2)
abline(h=-1, lty=3, lwd=2)
</code></pre>

<hr>
<h2 id='gmm.tmvnorm'>
GMM Estimation for the Truncated Multivariate Normal Distribution
</h2><span id='topic+gmm.tmvnorm'></span>

<h3>Description</h3>

<p>Generalized Method of Moments (GMM) Estimation for the Truncated Multivariate Normal Distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmm.tmvnorm(X, 
  lower = rep(-Inf, length = ncol(X)), 
  upper = rep(+Inf, length = ncol(X)), 
  start = list(mu = rep(0, ncol(X)), sigma = diag(ncol(X))), 
  fixed = list(),
  method=c("ManjunathWilhelm","Lee"),
  cholesky = FALSE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmm.tmvnorm_+3A_x">X</code></td>
<td>
<p>Matrix of quantiles, each row is taken to be a quantile.</p>
</td></tr>
<tr><td><code id="gmm.tmvnorm_+3A_lower">lower</code></td>
<td>
<p>Vector of lower truncation points, 
default is <code>rep(-Inf, length = ncol(X))</code>.</p>
</td></tr>
<tr><td><code id="gmm.tmvnorm_+3A_upper">upper</code></td>
<td>
<p>Vector of upper truncation points, 
default is <code>rep( Inf, length = ncol(X))</code>.</p>
</td></tr>
<tr><td><code id="gmm.tmvnorm_+3A_start">start</code></td>
<td>
<p>Named list with elements <code>mu</code> (mean vector) and <code>sigma</code> (covariance matrix). Initial values for optimizer.</p>
</td></tr>
<tr><td><code id="gmm.tmvnorm_+3A_fixed">fixed</code></td>
<td>
<p>Named list. Parameter values to keep fixed during optimization.</p>
</td></tr>
<tr><td><code id="gmm.tmvnorm_+3A_method">method</code></td>
<td>
<p>Which set of moment conditions used, possible methods are &quot;ManjunathWilhelm&quot; (default) and &quot;Lee&quot;.</p>
</td></tr>
<tr><td><code id="gmm.tmvnorm_+3A_cholesky">cholesky</code></td>
<td>
<p>if TRUE, we use the Cholesky decomposition of <code>sigma</code> as parametrization</p>
</td></tr>
<tr><td><code id="gmm.tmvnorm_+3A_...">...</code></td>
<td>
<p>Further arguments to pass to <code><a href="gmm.html#topic+gmm">gmm</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method performs an estimation of the parameters <code>mean</code> and <code>sigma</code> of a truncated multinormal distribution
using the Generalized Method of Moments (GMM), 
when the truncation points <code>lower</code> and <code>upper</code> are known.
<code>gmm.tmvnorm()</code> is a wrapper for the general GMM method <code><a href="gmm.html#topic+gmm">gmm</a></code>,
so one does not have to specify the moment conditions.
</p>
<p><b>Manjunath/Wilhelm moment conditions</b><br />
Because the first and second moments can be computed thanks to the <code><a href="#topic+mtmvnorm">mtmvnorm</a></code>
function, we can set up a method-of-moments estimator by equating the sample moments
to their population counterparts. This way we have an exactly identified case.
</p>
<p><b>Lee (1979,1983) moment conditions</b><br />
The recursive moment conditions presented by Lee (1979,1983) are defined for <code class="reqn">l=0,1,2,\ldots</code>
as
</p>
<p style="text-align: center;"><code class="reqn">
  \sigma^{iT} E(x_i^l \textbf{x}) = \sigma^{iT} \mu E(x_i^l) + l E(x_i^{l-1}) + \frac{a_i^l F_i(a_i)}{F} - \frac{b_i^l F_i(b_i)}{F}
 </code>
</p>

<p>where <code class="reqn">E(x_i^l)</code> and <code class="reqn">E(x_i^l \textbf{x})</code> are the moments of <code class="reqn">x_i^l</code> and <code class="reqn">x_i^l \textbf{x}</code> 
respectively and <code class="reqn">F_i(c)/F</code> is the one-dimensional marginal density in variable <code class="reqn">i</code> as calculated by <code><a href="#topic+dtmvnorm.marginal">dtmvnorm.marginal</a></code>. 
<code class="reqn">\sigma^{iT}</code> is the <code class="reqn">i</code>-th column of the inverse covariance matrix <code class="reqn">\Sigma^{-1}</code>.
</p>
<p>This method returns an object of class <code>gmm</code>, for which various
diagnostic methods are available, like <code>profile()</code>, <code>confint()</code> etc. See examples.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="gmm.html#topic+gmm">gmm</a></code>
</p>


<h3>Author(s)</h3>

<p>Stefan Wilhelm <a href="mailto:wilhelm@financial.com">wilhelm@financial.com</a>
</p>


<h3>References</h3>

<p>Tallis, G. M. (1961). The moment generating function of the truncated multinormal distribution. 
<em>Journal of the Royal Statistical Society, Series B</em>, <b>23</b>, 223&ndash;229
</p>
<p>Lee, L.-F. (1979). On the first and second moments of the truncated multi-normal distribution and a simple estimator. 
<em>Economics Letters</em>, <b>3</b>, 165&ndash;169
</p>
<p>Lee, L.-F. (1983). The determination of moments of the doubly truncated multivariate normal Tobit model.
<em>Economics Letters</em>, <b>11</b>, 245&ndash;250
</p>
<p>Manjunath B G and Wilhelm, S. (2009). Moments Calculation For the Double Truncated Multivariate Normal Density. 
Working Paper. Available at SSRN: <a href="https://www.ssrn.com/abstract=1472153">https://www.ssrn.com/abstract=1472153</a>
</p>


<h3>See Also</h3>

<p><code><a href="gmm.html#topic+gmm">gmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(1.234)

# the actual parameters
lower &lt;- c(-1, -2)
upper &lt;- c(3, Inf)
mu    &lt;- c(0, 0)
sigma &lt;- matrix(c(1, 0.8,
                0.8, 2), 2, 2)
               
# generate random samples               
X &lt;- rtmvnorm(n=500, mu, sigma, lower, upper)

# estimate mean vector and covariance matrix sigma from random samples X
# with default start values
gmm.fit1 &lt;- gmm.tmvnorm(X, lower=lower, upper=upper)

# diagnostic output of the estimated parameters
summary(gmm.fit1)
vcov(gmm.fit1)

# confidence intervals
confint(gmm.fit1)

# choosing a different start value
gmm.fit2 &lt;- gmm.tmvnorm(X, lower=lower, upper=upper, 
  start=list(mu=c(0.1, 0.1), 
  sigma=matrix(c(1, 0.4, 0.4, 1.8),2,2)))
summary(gmm.fit2)

# GMM estimation with Lee (1983) moment conditions
gmm.fit3 &lt;- gmm.tmvnorm(X, lower=lower, upper=upper, method="Lee")
summary(gmm.fit3)
confint(gmm.fit3)

# MLE estimation for comparison
mle.fit1 &lt;- mle.tmvnorm(X, lower=lower, upper=upper)
confint(mle.fit1)

## End(Not run)
</code></pre>

<hr>
<h2 id='mle.tmvnorm'>
Maximum Likelihood Estimation for the Truncated Multivariate Normal Distribution
</h2><span id='topic+mle.tmvnorm'></span>

<h3>Description</h3>

<p>Maximum Likelihood Estimation for the Truncated Multivariate Normal Distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mle.tmvnorm(X, 
  lower = rep(-Inf, length = ncol(X)), 
  upper = rep(+Inf, length = ncol(X)), 
  start = list(mu = rep(0, ncol(X)), sigma = diag(ncol(X))), 
  fixed = list(), method = "BFGS", 
  cholesky = FALSE,
  lower.bounds = -Inf,
  upper.bounds = +Inf,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mle.tmvnorm_+3A_x">X</code></td>
<td>
<p>Matrix of quantiles, each row is taken to be a quantile.</p>
</td></tr>
<tr><td><code id="mle.tmvnorm_+3A_lower">lower</code></td>
<td>
<p>Vector of lower truncation points, 
default is <code>rep(-Inf, length = ncol(X))</code>.</p>
</td></tr>
<tr><td><code id="mle.tmvnorm_+3A_upper">upper</code></td>
<td>
<p>Vector of upper truncation points, 
default is <code>rep( Inf, length = ncol(X))</code>.</p>
</td></tr>
<tr><td><code id="mle.tmvnorm_+3A_start">start</code></td>
<td>
<p>Named list with elements <code>mu</code> (mean vector) and <code>sigma</code> (covariance matrix). Initial values for optimizer.</p>
</td></tr>
<tr><td><code id="mle.tmvnorm_+3A_fixed">fixed</code></td>
<td>
<p>Named list. Parameter values to keep fixed during optimization.</p>
</td></tr>
<tr><td><code id="mle.tmvnorm_+3A_method">method</code></td>
<td>
<p>Optimization method to use. See <code><a href="stats.html#topic+optim">optim</a></code></p>
</td></tr>
<tr><td><code id="mle.tmvnorm_+3A_cholesky">cholesky</code></td>
<td>
<p>if TRUE, we use the Cholesky decomposition of <code>sigma</code> as parametrization</p>
</td></tr>
<tr><td><code id="mle.tmvnorm_+3A_lower.bounds">lower.bounds</code></td>
<td>
<p>lower bounds/box constraints for method &quot;L-BFGS-B&quot;</p>
</td></tr>
<tr><td><code id="mle.tmvnorm_+3A_upper.bounds">upper.bounds</code></td>
<td>
<p>upper bounds/box constraints for method &quot;L-BFGS-B&quot;</p>
</td></tr>
<tr><td><code id="mle.tmvnorm_+3A_...">...</code></td>
<td>
<p>Further arguments to pass to <code><a href="stats.html#topic+optim">optim</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method performs a maximum likelihood estimation of the parameters <code>mean</code> and <code>sigma</code> of a truncated multinormal distribution, 
when the truncation points <code>lower</code> and <code>upper</code> are known.
<code>mle.tmvnorm()</code> is a wrapper for the general maximum likelihood method <code><a href="stats4.html#topic+mle">mle</a></code>,
so one does not have to specify the negative log-likelihood function.
</p>
<p>The log-likelihood function for a data matrix X (T x n) can be established straightforward as
</p>
<p style="text-align: center;"><code class="reqn">
\log L(X | \mu,\Sigma) = -T \log{\alpha(\mu,\Sigma)} + {-T/2} \log{\|\Sigma\|} -\frac{1}{2} \sum_{t=1}^{T}{(x_t-\mu)' \Sigma^{-1} (x_t-\mu)}
</code>
</p>

<p>As <code><a href="stats4.html#topic+mle">mle</a></code>, this method returns an object of class <code>mle</code>, for which various
diagnostic methods are available, like <code>profile()</code>, <code>confint()</code> etc. See examples.
</p>
<p>In order to adapt the estimation problem to <code><a href="stats4.html#topic+mle">mle</a></code>, the named parameters 
for mean vector elements are &quot;mu_i&quot; and the elements of the covariance matrix are &quot;sigma_ij&quot; for the lower triangular matrix elements, 
i.e. (j &lt;= i).
</p>


<h3>Value</h3>

<p>An object of class <code><a href="stats4.html#topic+mle-class">mle-class</a></code>
</p>


<h3>Author(s)</h3>

<p>Stefan Wilhelm <a href="mailto:wilhelm@financial.com">wilhelm@financial.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats4.html#topic+mle">mle</a></code> and <code><a href="stats4.html#topic+mle-class">mle-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(1.2345)

# the actual parameters
lower &lt;- c(-1,-1)
upper &lt;- c(1, 2)
mu    &lt;- c(0, 0)
sigma &lt;- matrix(c(1, 0.7,
               0.7, 2), 2, 2)
               
# generate random samples               
X &lt;- rtmvnorm(n=500, mu, sigma, lower, upper)
method &lt;- "BFGS"

# estimate mean vector and covariance matrix sigma from random samples X
# with default start values
mle.fit1 &lt;- mle.tmvnorm(X, lower=lower, upper=upper)

# diagnostic output of the estimated parameters
summary(mle.fit1)
logLik(mle.fit1)
vcov(mle.fit1)

# profiling the log likelihood and confidence intervals
mle.profile1 &lt;- profile(mle.fit1, X, method="BFGS", trace=TRUE)
confint(mle.profile1)

par(mfrow=c(3,2))
plot(mle.profile1)

# choosing a different start value
mle.fit2 &lt;- mle.tmvnorm(X, lower=lower, upper=upper, 
  start=list(mu=c(0.1, 0.1), 
  sigma=matrix(c(1, 0.4, 0.4, 1.8),2,2)))
summary(mle.fit2)

## End(Not run)
</code></pre>

<hr>
<h2 id='mtmvnorm'>Computation of Mean Vector and Covariance Matrix For Truncated Multivariate Normal Distribution</h2><span id='topic+mtmvnorm'></span><span id='topic+moments'></span>

<h3>Description</h3>

<p>Computation of the first two moments, i.e. mean vector and covariance matrix 
for the Truncated Multivariate Normal Distribution 
based on the works of Tallis (1961), Lee (1979) and Leppard and Tallis (1989),
but extended to the double-truncated case with general mean and general covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtmvnorm(mean = rep(0, nrow(sigma)), 
  sigma = diag(length(mean)), 
  lower = rep(-Inf, length = length(mean)), 
  upper = rep(Inf, length = length(mean)), 
  doComputeVariance=TRUE,
  pmvnorm.algorithm=GenzBretz())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mtmvnorm_+3A_mean">mean</code></td>
<td>
<p>Mean vector, default is <code>rep(0, length = ncol(x))</code>.</p>
</td></tr>
<tr><td><code id="mtmvnorm_+3A_sigma">sigma</code></td>
<td>
<p>Covariance matrix, default is <code>diag(ncol(x))</code>.</p>
</td></tr>
<tr><td><code id="mtmvnorm_+3A_lower">lower</code></td>
<td>
<p>Vector of lower truncation points,\ 
default is <code>rep(-Inf, length = length(mean))</code>.</p>
</td></tr>
<tr><td><code id="mtmvnorm_+3A_upper">upper</code></td>
<td>
<p>Vector of upper truncation points,\ 
default is <code>rep( Inf, length = length(mean))</code>.</p>
</td></tr>
<tr><td><code id="mtmvnorm_+3A_docomputevariance">doComputeVariance</code></td>
<td>
<p>flag whether to compute the variance for users who are interested only in the mean. 
Defaults to <code>TRUE</code> for backward compatibility.</p>
</td></tr>
<tr><td><code id="mtmvnorm_+3A_pmvnorm.algorithm">pmvnorm.algorithm</code></td>
<td>
<p>Algorithm used for <code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Details for the moment calculation under double truncation and the derivation of the formula
can be found in the Manjunath/Wilhelm (2009) working paper.
If only a subset of variables are truncated, we calculate the truncated moments only for these
and use the Johnson/Kotz formula for the remaining untruncated variables.
</p>


<h3>Value</h3>

<table>
<tr><td><code>tmean</code></td>
<td>
<p>Mean vector of truncated variables</p>
</td></tr>
<tr><td><code>tvar</code></td>
<td>
<p>Covariance matrix of truncated variables</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Wilhelm &lt;Stefan.Wilhelm@financial.com&gt;, Manjunath B G &lt;bgmanjunath@gmail.com&gt;</p>


<h3>References</h3>

<p>Tallis, G. M. (1961). The moment generating function of the truncated multinormal distribution. 
<em>Journal of the Royal Statistical Society, Series B</em>, <b>23</b>, 223&ndash;229
</p>
<p>Johnson, N./Kotz, S. (1970). Distributions in Statistics: Continuous Multivariate Distributions
<em>Wiley &amp; Sons</em>, pp. 70&ndash;73
</p>
<p>Lee, L.-F. (1979). On the first and second moments of the truncated multi-normal distribution and a simple estimator. 
<em>Economics Letters</em>, <b>3</b>, 165&ndash;169
</p>
<p>Leppard, P. and Tallis, G. M. (1989). Evaluation of the Mean and Covariance of the Truncated Multinormal.
<em>Applied Statistics</em>, <b>38</b>, 543&ndash;553
</p>
<p>Manjunath B G and Wilhelm, S. (2009). Moments Calculation For the Double Truncated Multivariate Normal Density. 
Working Paper. Available at SSRN: <a href="https://www.ssrn.com/abstract=1472153">https://www.ssrn.com/abstract=1472153</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  mu    &lt;- c(0.5, 0.5, 0.5)
  sigma &lt;- matrix(c(  1,  0.6, 0.3,
                    0.6,    1, 0.2,
                    0.3,  0.2,   2), 3, 3)
                    
  a  &lt;- c(-Inf, -Inf, -Inf)
  b  &lt;- c(1, 1, 1)

  # compute first and second moments
  mtmvnorm(mu, sigma, lower=a, upper=b)
  
  # compare with simulated results
  X &lt;- rtmvnorm(n=1000, mean=mu, sigma=sigma, lower=a, upper=b)
  colMeans(X)
  cov(X)
</code></pre>

<hr>
<h2 id='ptmvnorm'> Truncated Multivariate Normal Distribution </h2><span id='topic+ptmvnorm'></span>

<h3>Description</h3>

<p>Computes the distribution function of the truncated multivariate normal 
distribution for arbitrary limits and correlation matrices 
based on the <code>pmvnorm()</code> implementation of the algorithms by Genz and Bretz.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptmvnorm(lowerx, upperx, mean=rep(0, length(lowerx)), sigma, 
  lower = rep(-Inf, length = length(mean)), 
  upper = rep( Inf, length = length(mean)), 
  maxpts = 25000, abseps = 0.001, releps = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ptmvnorm_+3A_lowerx">lowerx</code></td>
<td>
<p> the vector of lower limits of length n.</p>
</td></tr>
<tr><td><code id="ptmvnorm_+3A_upperx">upperx</code></td>
<td>
<p> the vector of upper limits of length n.</p>
</td></tr>
<tr><td><code id="ptmvnorm_+3A_mean">mean</code></td>
<td>
<p> the mean vector of length n.</p>
</td></tr>
<tr><td><code id="ptmvnorm_+3A_sigma">sigma</code></td>
<td>
<p> the covariance matrix of dimension n. Either <code>corr</code> or
<code>sigma</code> can be specified. If <code>sigma</code> is given, the
problem is standardized. If neither <code>corr</code> nor
<code>sigma</code> is given, the identity matrix is used 
for <code>sigma</code>. </p>
</td></tr>
<tr><td><code id="ptmvnorm_+3A_lower">lower</code></td>
<td>
<p>Vector of lower truncation points,\ 
default is <code>rep(-Inf, length = length(mean))</code>.</p>
</td></tr>
<tr><td><code id="ptmvnorm_+3A_upper">upper</code></td>
<td>
<p>Vector of upper truncation points,\ 
default is <code>rep( Inf, length = length(mean))</code>.</p>
</td></tr>              
<tr><td><code id="ptmvnorm_+3A_maxpts">maxpts</code></td>
<td>
<p> maximum number of function values as integer. </p>
</td></tr>
<tr><td><code id="ptmvnorm_+3A_abseps">abseps</code></td>
<td>
<p> absolute error tolerance as double. </p>
</td></tr>
<tr><td><code id="ptmvnorm_+3A_releps">releps</code></td>
<td>
<p> relative error tolerance as double. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computation of truncated multivariate normal probabilities and densities is done using conditional probabilities 
from the standard/untruncated multivariate normal distribution. 
So we refer to the documentation of the <code>mvtnorm</code> package and the methodology is described in
Genz (1992, 1993) and Genz/Bretz (2009).
</p>
<p>For properties of the truncated multivariate normal distribution see for example Johnson/Kotz (1970)
and Horrace (2005).
</p>


<h3>Value</h3>

<p>The evaluated distribution function is returned with attributes
</p>
<table>
<tr><td><code>error</code></td>
<td>
<p>estimated absolute error and</p>
</td></tr>
<tr><td><code>msg</code></td>
<td>
<p>status messages.</p>
</td></tr>
</table>


<h3>References</h3>

 
<p>Genz, A. (1992). Numerical computation of multivariate normal probabilities.
<em>Journal of Computational and Graphical Statistics</em>, <b>1</b>, 141&ndash;150 
</p>
<p>Genz, A. (1993). Comparison of methods for the computation of multivariate
normal probabilities. <em>Computing Science and Statistics</em>, <b>25</b>,
400&ndash;405
</p>
<p>Genz, A. and Bretz, F. (2009). Computation of Multivariate Normal and t Probabilities. 
<em>Lecture Notes in Statistics</em>, Vol. <b>195</b>, Springer-Verlag, Heidelberg.
</p>
<p>Johnson, N./Kotz, S. (1970). Distributions in Statistics: Continuous Multivariate Distributions
<em>Wiley &amp; Sons</em>, pp. 70&ndash;73
</p>
<p>Horrace, W. (2005). Some Results on the Multivariate Truncated Normal Distribution. 
<em>Journal of Multivariate Analysis</em>, <b>94</b>, 209&ndash;221
</p>


<h3>Examples</h3>

<pre><code class='language-R'> sigma &lt;- matrix(c(5, 0.8, 0.8, 1), 2, 2)
 Fx &lt;- ptmvnorm(lowerx=c(-1,-1), upperx=c(0.5,0), mean=c(0,0), 
   sigma=sigma, lower=c(-1,-1), upper=c(1,1))
</code></pre>

<hr>
<h2 id='ptmvt'>Truncated Multivariate Student t Distribution</h2><span id='topic+ptmvt'></span>

<h3>Description</h3>

<p>Computes the distribution function of the truncated multivariate t 
distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptmvt(lowerx, upperx, mean = rep(0, length(lowerx)), sigma, df = 1, 
  lower = rep(-Inf, length = length(mean)), 
  upper = rep(Inf, length = length(mean)), maxpts = 25000, abseps = 0.001, 
  releps = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ptmvt_+3A_lowerx">lowerx</code></td>
<td>
<p> the vector of lower limits of length n.</p>
</td></tr>
<tr><td><code id="ptmvt_+3A_upperx">upperx</code></td>
<td>
<p> the vector of upper limits of length n.</p>
</td></tr>
<tr><td><code id="ptmvt_+3A_mean">mean</code></td>
<td>
<p> the mean vector of length n.</p>
</td></tr>
<tr><td><code id="ptmvt_+3A_sigma">sigma</code></td>
<td>
<p> the covariance matrix of dimension n. Either <code>corr</code> or
<code>sigma</code> can be specified. If <code>sigma</code> is given, the
problem is standardized. If neither <code>corr</code> nor
<code>sigma</code> is given, the identity matrix is used 
for <code>sigma</code>. </p>
</td></tr>
<tr><td><code id="ptmvt_+3A_df">df</code></td>
<td>
<p>Degrees of freedom parameter</p>
</td></tr>              
<tr><td><code id="ptmvt_+3A_lower">lower</code></td>
<td>
<p>Vector of lower truncation points, 
default is <code>rep(-Inf, length = length(mean))</code>.</p>
</td></tr>
<tr><td><code id="ptmvt_+3A_upper">upper</code></td>
<td>
<p>Vector of upper truncation points, 
default is <code>rep( Inf, length = length(mean))</code>.</p>
</td></tr>              
<tr><td><code id="ptmvt_+3A_maxpts">maxpts</code></td>
<td>
<p> maximum number of function values as integer. </p>
</td></tr>
<tr><td><code id="ptmvt_+3A_abseps">abseps</code></td>
<td>
<p> absolute error tolerance as double. </p>
</td></tr>
<tr><td><code id="ptmvt_+3A_releps">releps</code></td>
<td>
<p> relative error tolerance as double. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The evaluated distribution function is returned with attributes
</p>
<table>
<tr><td><code>error</code></td>
<td>
<p>estimated absolute error and</p>
</td></tr>
<tr><td><code>msg</code></td>
<td>
<p>status messages.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Wilhelm &lt;Stefan.Wilhelm@financial.com&gt;</p>


<h3>References</h3>

<p>Geweke, J. F. (1991) Efficient simulation from the multivariate normal and Student-t distributions 
subject to linear constraints and the evaluation of constraint probabilities.
<a href="https://www.researchgate.net/publication/2335219_Efficient_Simulation_from_the_Multivariate_Normal_and_Student-t_Distributions_Subject_to_Linear_Constraints_and_the_Evaluation_of_Constraint_Probabilities">https://www.researchgate.net/publication/2335219_Efficient_Simulation_from_the_Multivariate_Normal_and_Student-t_Distributions_Subject_to_Linear_Constraints_and_the_Evaluation_of_Constraint_Probabilities</a> 
</p>
<p>Samuel Kotz, Saralees Nadarajah (2004). Multivariate t Distributions and Their Applications. 
<em>Cambridge University Press</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sigma &lt;- matrix(c(5, 0.8, 0.8, 1), 2, 2)
Fx &lt;- ptmvt(lowerx=c(-1,-1), upperx=c(0.5,0), mean=c(0,0), sigma=sigma, df=3, 
  lower=c(-1,-1), upper=c(1,1))
</code></pre>

<hr>
<h2 id='ptmvtnorm.marginal'>One-dimensional marginal CDF function for a Truncated Multivariate Normal and Student t distribution</h2><span id='topic+ptmvnorm.marginal'></span><span id='topic+ptmvt.marginal'></span>

<h3>Description</h3>

<p>This function computes the one-dimensional marginal probability 
function from a Truncated Multivariate Normal and Student t density function
using integration in <code>pmvnorm()</code> and <code>pmvt()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptmvnorm.marginal(xn, 
    n = 1, 
    mean = rep(0, nrow(sigma)), 
    sigma = diag(length(mean)), 
    lower = rep(-Inf, length = length(mean)), 
    upper = rep(Inf, length = length(mean)))
ptmvt.marginal(xn, 
    n = 1, 
    mean = rep(0, nrow(sigma)), 
    sigma = diag(length(mean)), 
    df = 1, 
    lower = rep(-Inf, length = length(mean)), 
    upper = rep(Inf, length = length(mean)))    
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ptmvtnorm.marginal_+3A_xn">xn</code></td>
<td>
<p>Vector of quantiles to calculate the marginal probability for.</p>
</td></tr>
<tr><td><code id="ptmvtnorm.marginal_+3A_n">n</code></td>
<td>
<p>Index position (1..k) within the random vector xn to calculate the one-dimensional marginal probability for.</p>
</td></tr>
<tr><td><code id="ptmvtnorm.marginal_+3A_mean">mean</code></td>
<td>
<p> the mean vector of length k. </p>
</td></tr>
<tr><td><code id="ptmvtnorm.marginal_+3A_sigma">sigma</code></td>
<td>
<p> the covariance matrix of dimension k. Either <code>corr</code> or
<code>sigma</code> can be specified. If <code>sigma</code> is given, the
problem is standardized. If neither <code>corr</code> nor
<code>sigma</code> is given, the identity matrix is used
for <code>sigma</code>.</p>
</td></tr>
<tr><td><code id="ptmvtnorm.marginal_+3A_df">df</code></td>
<td>
<p>degrees of freedom parameter</p>
</td></tr>              
<tr><td><code id="ptmvtnorm.marginal_+3A_lower">lower</code></td>
<td>
<p>Vector of lower truncation points, 
default is <code>rep(-Inf, length = length(mean))</code>.</p>
</td></tr>
<tr><td><code id="ptmvtnorm.marginal_+3A_upper">upper</code></td>
<td>
<p>Vector of upper truncation points, 
default is <code>rep( Inf, length = length(mean))</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The one-dimensional marginal probability for index i is 
<code class="reqn">F_i(x_i) = P(X_i \le x_i)</code>
</p>
<p style="text-align: center;"><code class="reqn">F_i(x_i) = \int_{a_1}^{b_1} \ldots \int_{a_{i-1}}^{b_{i-1}} \int_{a_{i}}^{x_i} \int_{a_{i+1}}^{b_{i+1}} \ldots \int_{a_k}^{b_k} f(x) dx 
                 = \alpha^{-1} \Phi_k(a, u, \mu, \Sigma)</code>
</p>

<p>where <code class="reqn">u = (b_1,\ldots,b_{i-1},x_i,b_{i+1},\ldots,b_k)'</code> 
is the upper integration bound and <code class="reqn">\Phi_k</code> 
is the k-dimensional normal probability (i.e. functions <code>pmvnorm()</code> and <code>pmvt()</code> in R package <code>mvtnorm</code>).  
</p>


<h3>Value</h3>

<p>Returns a vector of the same length as xn with probabilities.
</p>


<h3>Author(s)</h3>

<p>Stefan Wilhelm &lt;Stefan.Wilhelm@financial.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1: Truncated multi-normal
lower &lt;- c(-1,-1,-1)
upper &lt;- c(1,1,1)
mean &lt;- c(0,0,0)
sigma &lt;- matrix(c(  1, 0.8, 0.2, 
                  0.8,   1, 0.1,
                  0.2, 0.1,   1), 3, 3)

X &lt;- rtmvnorm(n=1000, mean=c(0,0,0), sigma=sigma, lower=lower, upper=upper)

x &lt;- seq(-1, 1, by=0.01)
Fx &lt;- ptmvnorm.marginal(xn=x, n=1, mean=c(0,0,0), sigma=sigma, lower=lower, upper=upper) 

plot(ecdf(X[,1]), main="marginal CDF for truncated multi-normal")
lines(x, Fx, type="l", col="blue")

## Example 2: Truncated multi-t
X &lt;- rtmvt(n=1000, mean=c(0,0,0), sigma=sigma, df=2, lower=lower, upper=upper)

x &lt;- seq(-1, 1, by=0.01)
Fx &lt;- ptmvt.marginal(xn=x, n=1, mean=c(0,0,0), sigma=sigma, lower=lower, upper=upper) 

plot(ecdf(X[,1]), main="marginal CDF for truncated multi-t")
lines(x, Fx, type="l", col="blue")
</code></pre>

<hr>
<h2 id='qtmvnorm-marginal'> Quantiles of the Truncated Multivariate Normal Distribution in one dimension</h2><span id='topic+qtmvnorm.marginal'></span>

<h3>Description</h3>

<p>Computes the equicoordinate quantile function of the truncated multivariate normal
distribution for arbitrary correlation matrices
based on an inversion of the algorithms by Genz and Bretz.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qtmvnorm.marginal(p, 
        interval = c(-10, 10), 
        tail = c("lower.tail","upper.tail","both.tails"), 
        n=1, 
		mean=rep(0, nrow(sigma)), 
		sigma=diag(length(mean)), 
		lower=rep(-Inf, length = length(mean)), 
		upper=rep( Inf, length = length(mean)),
		...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qtmvnorm-marginal_+3A_p">p</code></td>
<td>
<p> probability.</p>
</td></tr>
<tr><td><code id="qtmvnorm-marginal_+3A_interval">interval</code></td>
<td>
<p> a vector containing the end-points of the interval to be
searched by <code><a href="stats.html#topic+uniroot">uniroot</a></code>.</p>
</td></tr>
<tr><td><code id="qtmvnorm-marginal_+3A_tail">tail</code></td>
<td>
<p> specifies which quantiles should be computed.
<code>lower.tail</code> gives the quantile <code class="reqn">x</code> for which 
<code class="reqn">P[X \le x] = p</code>, <code>upper.tail</code> gives <code class="reqn">x</code> with 
<code class="reqn">P[X &gt; x] = p</code> and 
<code>both.tails</code> leads to <code class="reqn">x</code> 
with <code class="reqn">P[-x \le X \le x] = p</code> </p>
</td></tr>
<tr><td><code id="qtmvnorm-marginal_+3A_n">n</code></td>
<td>
<p> index (1..n) to calculate marginal quantile for</p>
</td></tr>            
<tr><td><code id="qtmvnorm-marginal_+3A_mean">mean</code></td>
<td>
<p> the mean vector of length n. </p>
</td></tr>
<tr><td><code id="qtmvnorm-marginal_+3A_sigma">sigma</code></td>
<td>
<p> the covariance matrix of dimension n. Either <code>corr</code> or
<code>sigma</code> can be specified. If <code>sigma</code> is given, the
problem is standardized. If neither <code>corr</code> nor
<code>sigma</code> is given, the identity matrix is used
for <code>sigma</code>. </p>
</td></tr>
<tr><td><code id="qtmvnorm-marginal_+3A_lower">lower</code></td>
<td>
<p>Vector of lower truncation points,\ 
default is <code>rep(-Inf, length = length(mean))</code>.</p>
</td></tr>
<tr><td><code id="qtmvnorm-marginal_+3A_upper">upper</code></td>
<td>
<p>Vector of upper truncation points,\ 
default is <code>rep( Inf, length = length(mean))</code>.</p>
</td></tr>              
<tr><td><code id="qtmvnorm-marginal_+3A_...">...</code></td>
<td>
<p> additional parameters to be passed to
<code><a href="stats.html#topic+uniroot">uniroot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only equicoordinate quantiles are computed, i.e., the quantiles in each
dimension coincide. Currently, the distribution function is inverted by 
using the <code><a href="stats.html#topic+uniroot">uniroot</a></code> function which may result in limited accuracy of the 
quantiles. 
</p>


<h3>Value</h3>

<p>A list with four components: <code>quantile</code> and <code>f.quantile</code> 
give the location of the quantile and the value of the function
evaluated at that point. <code>iter</code> and <code>estim.prec</code> give the number 
of iterations used and an approximate estimated precision from
<code><a href="stats.html#topic+uniroot">uniroot</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ptmvnorm">ptmvnorm</a></code>, <code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># finite dimensional distribution of the Geometric Brownian Motion log-returns 
# with truncation

# volatility p.a.
sigma=0.4

# risk free rate
r = 0.05

# n=3 points in time
T &lt;- c(0.5, 0.7, 1)

# covariance matrix of Geometric Brownian Motion returns
Sigma = sigma^2*outer(T,T,pmin)

# mean vector of the Geometric Brownian Motion returns
mu    = (r - sigma^2/2) * T

# lower truncation vector a (a&lt;=x&lt;=b)
a = rep(-Inf, 3)

# upper truncation vector b (a&lt;=x&lt;=b)
b = c(0, 0, Inf)

# quantile of the t_1 returns
qtmvnorm.marginal(p=0.95, interval = c(-10, 10), tail = "lower.tail", n=1, 
  mean  = mu, sigma = Sigma, lower=a, upper=b)
</code></pre>

<hr>
<h2 id='rtmvnorm'>Sampling Random Numbers From The Truncated Multivariate Normal Distribution</h2><span id='topic+rtmvnorm'></span><span id='topic+rtmvnorm.sparseMatrix'></span>

<h3>Description</h3>

<p>This function generates random numbers
from the truncated multivariate normal
distribution with mean equal to <code>mean</code> and covariance matrix
<code>sigma</code> (or alternatively precision matrix <code>H</code>), 
lower and upper truncation points <code>lower</code> and <code>upper</code>
with either rejection sampling or Gibbs sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtmvnorm(n, mean = rep(0, nrow(sigma)), 
  sigma = diag(length(mean)),
  lower=rep(-Inf, length = length(mean)), 
  upper=rep( Inf, length = length(mean)),
  D = diag(length(mean)),
  H = NULL, 
  algorithm=c("rejection", "gibbs", "gibbsR"),
  ...)
  
rtmvnorm.sparseMatrix(n, mean = rep(0, nrow(H)), 
    H = sparseMatrix(i=1:length(mean), j=1:length(mean), x=1),
    lower = rep(-Inf, length = length(mean)), 
    upper = rep( Inf, length = length(mean)),
    ...)  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtmvnorm_+3A_n">n</code></td>
<td>
<p>Number of random points to be sampled. Must be an integer <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="rtmvnorm_+3A_mean">mean</code></td>
<td>
<p>Mean vector, default is <code>rep(0, length = ncol(x))</code>.</p>
</td></tr>
<tr><td><code id="rtmvnorm_+3A_sigma">sigma</code></td>
<td>
<p>Covariance matrix, default is <code>diag(ncol(x))</code>.</p>
</td></tr>
<tr><td><code id="rtmvnorm_+3A_lower">lower</code></td>
<td>
<p>Vector of lower truncation points, 
default is <code>rep(-Inf, length = length(mean))</code>.</p>
</td></tr>
<tr><td><code id="rtmvnorm_+3A_upper">upper</code></td>
<td>
<p>Vector of upper truncation points, 
default is <code>rep( Inf, length = length(mean))</code>.</p>
</td></tr>
<tr><td><code id="rtmvnorm_+3A_d">D</code></td>
<td>
<p>Matrix for linear constraints, defaults to diagonal matrix.</p>
</td></tr>
<tr><td><code id="rtmvnorm_+3A_h">H</code></td>
<td>
<p>Precision matrix, default is <code>NULL</code>.</p>
</td></tr>              
<tr><td><code id="rtmvnorm_+3A_algorithm">algorithm</code></td>
<td>
<p>Method used, possible methods are rejection sampling (&quot;rejection&quot;, default), 
the Fortan Gibbs sampler (&quot;gibbs&quot;) 
and the old Gibbs sampler implementation in R (&quot;gibbsR&quot;).</p>
</td></tr>
<tr><td><code id="rtmvnorm_+3A_...">...</code></td>
<td>
<p>additional parameters for Gibbs sampling, given to the internal method <code>rtmvnorm.gibbs()</code>, 
such as <code>burn.in.samples</code>, <code>start.value</code> and <code>thinning</code>, see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generation of random numbers from a truncated multivariate normal distribution is done 
using either rejection sampling or Gibbs sampling.
</p>
<p><b>Rejection sampling</b><br />
Rejection sampling is done from the standard multivariate normal distribution. 
So we use the function <code><a href="mvtnorm.html#topic+rmvnorm">rmvnorm</a></code> of the <span class="pkg">mvtnorm</span> package to generate
proposals which are either accepted if they are inside the support region or rejected.
In order to speed up the generation of N samples from the truncated distribution, 
we first calculate the acceptance rate alpha from the truncation points and then generate N/alpha samples iteratively 
until we have got N samples. This typically does not take more than 2-3 iterations.
Rejection sampling may be very inefficient when the support region is small (i.e. in higher dimensions) 
which results in very low acceptance rates alpha. In this case the Gibbs sampler is preferable.
</p>
<p><b>Gibbs sampling</b><br />
The Gibbs sampler samples from univariate conditional distributions, 
so all samples can be accepted except for a burn-in period. 
The number of burn-in samples to be discarded can be specified, as well as a start value of the chain.
If no start value is given, we determine a start value from the support region
using either lower bound or upper bound if they are finite, or 0 otherwise.
</p>
<p>The Gibbs sampler has been reimplemented in Fortran 90 for performance reasons (<code>algorithm="gibbs"</code>). 
The old R implementation is still accessible through <code>algorithm="gibbsR"</code>.
</p>
<p>The arguments to be passed along with <code>algorithm="gibbs"</code> or <code>algorithm="gibbsR"</code> are:
</p>

<dl>
<dt><code>burn.in.samples</code></dt><dd><p>number of samples in Gibbs sampling to be discarded as burn-in phase, must be non-negative.</p>
</dd>
<dt><code>start.value</code></dt><dd><p>Start value (vector of length <code>length(mean)</code>) for the MCMC chain. If one is specified,
it must lie inside the support region (<code class="reqn">lower &lt;= start.value &lt;= upper</code>).
If none is specified, 
the start value is taken componentwise as the finite lower or upper boundaries respectively, 
or zero if both boundaries are infinite. Defaults to NULL.</p>
</dd>
<dt><code>thinning</code></dt><dd><p>Thinning factor for reducing autocorrelation of random points in Gibbs sampling. Must be an integer &gt;= 1. 
We create a Markov chain of length <code>(n*thinning)</code> and take only those
samples <code>j=1:(n*thinning)</code> where <code>j %% thinning == 0</code>  
Defaults to 1 (no thinning of the chain).</p>
</dd>
</dl>

<p><b>Sampling with linear constraints</b><br />
We extended the method to also simulate from a multivariate normal distribution
subject to general linear constraints  <code class="reqn">lower &lt;= D x &lt;= upper</code>. 
For general D, both rejection sampling or Gibbs sampling according to Geweke (1991)
are available.
</p>
<p><b>Gibbs sampler and the use of the precision matrix H</b><br />
Why is it important to have a random sampler that works with the precision matrix?
Especially in Bayesian and spatial statistics, there are a number of high-dimensional 
applications where the precision matrix <code>H</code> is readily available, 
but is sometimes nearly singular and cannot be easily inverted to sigma.
Additionally, it turns out that the Gibbs sampler formulas are much simpler
in terms of the precision matrix than in terms of the covariance matrix. 
See the details of the Gibbs sampler implementation in the package vignette or for example Geweke (2005), pp.171-172.
(Thanks to Miguel Godinho de Matos from Carnegie Mellon University for pointing me to this.)
Therefore, we now provide an interface for the direct use of the precision matrix <code>H</code>
in <code>rtmvnorm()</code>.
</p>
<p><b>Gibbs sampler with sparse precision matrix H</b><br />
The size of the covariance matrix <code>sigma</code> or precision matrix <code>H</code> 
- if expressed as a dense <code><a href="base.html#topic+matrix">matrix</a></code> - grows quadratic with the number of dimensions d.
For high-dimensional problems (such as d &gt; 5000), 
it is no longer efficient and appropriate to work with dense matrix representations, 
as one quickly runs into memory problems.<br /> 
It is interesting to note that in many applications the precision matrix, 
which holds the conditional dependencies, will be sparse, whereas the covariance matrix 
will be dense. 
Hence, expressing H as a sparse matrix will significantly reduce the amount of memory to store this matrix 
and allows much larger problems to be handled. 
In the current version of the package, the precision matrix (not <code>sigma</code> since it will be dense in most cases)
can be passed to <code>rtmvnorm.sparseMatrix()</code> as a <code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code> from the <code>Matrix</code> package.
See the examples section below for a usage example.
</p>


<h3>Warning</h3>

<p>A word of caution is needed for useRs that are not familiar with Markov Chain Monte Carlo methods like Gibbs sampling:
</p>
<p>Rejection sampling is exact in the sense that we are sampling directly from the target distribution 
and the random samples generated are independent. So it is clearly the default
method.
</p>
<p>Markov Chain Monte Carlo methods are only approximate methods, which may suffer from several problems:
</p>

<ul>
<li><p>Poor mixing
</p>
</li>
<li><p>Convergence problems
</p>
</li>
<li><p>Correlation among samples
</p>
</li></ul>

<p>Diagnostic checks for Markov Chain Monte Carlo 
include trace plots, CUSUM plots and autocorrelation plots like <code><a href="stats.html#topic+acf">acf</a></code>. For
a survey see for instance Cowles (1996).
</p>
<p>That is, consecutive samples generated from <code>rtmvnorm(..., algorithm=c("gibbs", "gibbsR"))</code> are correlated (see also example 3 below).
One way of reducing the autocorrelation among the random samples is &quot;thinning&quot; the Markov chain, that is
recording only a subset/subsequence of the chain. For example, one could record only every 100th sample,
which clearly reduces the autocorrelation and &quot;increases the independence&quot;. 
But thinning comes at the cost of higher computation times, since the chain has to run much longer.
We refer to autocorrelation plots in order to determine optimal thinning.
</p>


<h3>Author(s)</h3>

<p>Stefan Wilhelm &lt;Stefan.Wilhelm@financial.com&gt;, Manjunath B G &lt;bgmanjunath@gmail.com&gt;</p>


<h3>References</h3>

<p>Alan Genz, Frank Bretz, Tetsuhisa Miwa, Xuefei Mi, Friedrich Leisch, Fabian Scheipl, Torsten Hothorn (2009). mvtnorm:
Multivariate Normal and t Distributions. R package version 0.9-7. URL <a href="https://CRAN.R-project.org/package=mvtnorm">https://CRAN.R-project.org/package=mvtnorm</a> 
</p>
<p>Johnson, N./Kotz, S. (1970). Distributions in Statistics: Continuous Multivariate Distributions
<em>Wiley &amp; Sons</em>, pp. 70&ndash;73
</p>
<p>Horrace, W. (2005). Some Results on the Multivariate Truncated Normal Distribution. 
<em>Journal of Multivariate Analysis</em>, <b>94</b>, 209&ndash;221
</p>
<p>Jayesh H. Kotecha and Petar M. Djuric (1999). Gibbs Sampling Approach For Generation of Truncated Multivariate Gaussian Random Variables
<em>IEEE Computer Society</em>, 1757&ndash;1760
</p>
<p>Cowles, M. and Carlin, B. (1996). Markov Chain Monte Carlo Convergence Diagnostics: A Comparative Review
<em>Journal of the American Statistical Association</em>, <b>91</b>, 883&ndash;904
</p>
<p>Geweke, J. F. (1991). Effcient Simulation from the Multivariate Normal and Student-t Distributions 
Subject to Linear Constraints 
<em>Computer Science and Statistics. Proceedings of the 23rd Symposium on the Interface. Seattle Washington, April 21-24, 1991</em>, 571&ndash;578
</p>
<p>Geweke, J. F. (2005). Contemporary Bayesian Econometrics and Statistics, <em>Wiley &amp; Sons</em>, pp.171&ndash;172
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ptmvnorm">ptmvnorm</a></code>, <code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code>, <code><a href="mvtnorm.html#topic+rmvnorm">rmvnorm</a></code>, <code><a href="mvtnorm.html#topic+dmvnorm">dmvnorm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>################################################################################
#
# Example 1: 
# rejection sampling in 2 dimensions       
#
################################################################################

sigma &lt;- matrix(c(4,2,2,3), ncol=2)
x &lt;- rtmvnorm(n=500, mean=c(1,2), sigma=sigma, upper=c(1,0))
plot(x, main="samples from truncated bivariate normal distribution",
  xlim=c(-6,6), ylim=c(-6,6), 
  xlab=expression(x[1]), ylab=expression(x[2]))
abline(v=1, lty=3, lwd=2, col="gray")
abline(h=0, lty=3, lwd=2, col="gray")

################################################################################
#
# Example 2: 
# Gibbs sampler for 4 dimensions
#
################################################################################

C &lt;- matrix(0.8, 4, 4)
diag(C) &lt;- rep(1, 4)
lower &lt;- rep(-4, 4)
upper &lt;- rep(-1, 4)

# acceptance rate alpha
alpha &lt;- pmvnorm(lower=lower, upper=upper, mean=rep(0,4), sigma=C)
alpha

# Gibbs sampler
X1 &lt;- rtmvnorm(n=20000, mean = rep(0,4), sigma=C, lower=lower, upper=upper, 
  algorithm="gibbs", burn.in.samples=100)
# Rejection sampling
X2 &lt;- rtmvnorm(n=5000, mean = rep(0,4), sigma=C, lower=lower, upper=upper)

colMeans(X1)
colMeans(X2)

plot(density(X1[,1], from=lower[1], to=upper[1]), col="red", lwd=2, 
     main="Kernel density estimates from random samples 
     generated by Gibbs vs. Rejection sampling")
lines(density(X2[,1], from=lower[1], to=upper[1]), col="blue", lwd=2)
legend("topleft",legend=c("Gibbs Sampling","Rejection Sampling"), 
  col=c("red","blue"), lwd=2, bty="n")

################################################################################
#
# Example 3: 
# Autocorrelation plot for Gibbs sampler
# with and without thinning
#
################################################################################

sigma &lt;- matrix(c(4,2,2,3), ncol=2)
X1 &lt;- rtmvnorm(n=10000, mean=c(1,2), sigma=sigma, upper=c(1,0), 
  algorithm="rejection")
acf(X1)
# no autocorrelation among random points

X2 &lt;- rtmvnorm(n=10000, mean=c(1,2), sigma=sigma, upper=c(1,0), 
  algorithm="gibbs")
acf(X2)
# exhibits autocorrelation among random points

X3 &lt;- rtmvnorm(n=10000, mean=c(1,2), sigma=sigma, upper=c(1,0), 
  algorithm="gibbs", thinning=2)
acf(X3)
# reduced autocorrelation among random points

plot(density(X1[,1], to=1))
lines(density(X2[,1], to=1), col="blue")
lines(density(X3[,1], to=1), col="red")

################################################################################
#
# Example 4: Univariate case
#
################################################################################

X &lt;- rtmvnorm(100, mean=0, sigma=1, lower=-1, upper=1)

################################################################################
#
# Example 5: Linear Constraints
#
################################################################################

mean  &lt;- c(0, 0)
sigma &lt;- matrix(c(10, 0,
                   0, 1), 2, 2)

# Linear Constraints
#
# a1 &lt;= x1 + x2 &lt;= b2
# a2 &lt;= x1 - x2 &lt;= b2
#
# [ a1 ] &lt;= [ 1   1 ] [ x1 ] &lt;= [b1]
# [ a2 ]    [ 1  -1 ] [ x2 ]    [b2]
a     &lt;- c(-2, -2)
b     &lt;- c( 2,  2)
D     &lt;- matrix(c(1, 1,
                  1, -1), 2, 2)                   

X &lt;- rtmvnorm(n=10000, mean, sigma, lower=a, upper=b, D=D, algorithm="gibbsR")
plot(X, main="Gibbs sampling for multivariate normal 
              with linear constraints according to Geweke (1991)")

# mark linear constraints as lines
for (i in 1:nrow(D)) {
  abline(a=a[i]/D[i, 2], b=-D[i,1]/D[i, 2], col="red")
  abline(a=b[i]/D[i, 2], b=-D[i,1]/D[i, 2], col="red")
}
                          
################################################################################
#
# Example 6: Using precision matrix H rather than sigma
#
################################################################################

lower &lt;- c(-1, -1)
upper &lt;- c(1, 1)
mean &lt;- c(0.5, 0.5)
sigma &lt;- matrix(c(1, 0.8, 0.8, 1), 2, 2)
H &lt;- solve(sigma)
D &lt;- matrix(c(1, 1, 1, -1), 2, 2)
X &lt;- rtmvnorm(n=1000, mean=mean, H=H, lower=lower, upper=upper, D=D, algorithm="gibbs")
plot(X, main="Gibbs sampling with precision matrix and linear constraints")

################################################################################
#
# Example 7: Using sparse precision matrix H in high dimensions
#
################################################################################

## Not run: 
d &lt;- 1000
I_d &lt;- sparseMatrix(i=1:d, j=1:d, x=1)
W &lt;- sparseMatrix(i=c(1:d, 1:(d-1)), j=c(1:d, (2:d)), x=0.5)
H &lt;- t(I_d - 0.5 * W) 
lower &lt;- rep(0, d)
upper &lt;- rep(2, d)

# Gibbs sampler generates n=100 draws in d=1000 dimensions
X &lt;- rtmvnorm.sparseMatrix(n=100, mean = rep(0,d), H=H, lower=lower, upper=upper,
  burn.in.samples=100)
colMeans(X)  
cov(X)

## End(Not run)
</code></pre>

<hr>
<h2 id='rtmvnorm2'>Sampling Random Numbers From The Truncated Multivariate Normal Distribution With Linear Constraints</h2><span id='topic+rtmvnorm2'></span>

<h3>Description</h3>

<p>This function generates random numbers from the truncated multivariate normal
distribution with mean equal to <code>mean</code> and covariance matrix
<code>sigma</code> and general linear constraints 
</p>
<p style="text-align: center;"><code class="reqn">lower \le D x \le upper</code>
</p>
 
<p>with either rejection sampling or Gibbs sampling. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtmvnorm2(n, mean = rep(0, nrow(sigma)), 
  sigma = diag(length(mean)), 
  lower = rep(-Inf, length = length(mean)), 
  upper = rep(Inf, length = length(mean)), 
  D = diag(length(mean)), 
  algorithm = c("gibbs", "gibbsR", "rejection"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtmvnorm2_+3A_n">n</code></td>
<td>
<p>Number of random points to be sampled. Must be an integer <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="rtmvnorm2_+3A_mean">mean</code></td>
<td>
<p>Mean vector (d x 1), default is <code>rep(0, length = ncol(x))</code>.</p>
</td></tr>
<tr><td><code id="rtmvnorm2_+3A_sigma">sigma</code></td>
<td>
<p>Covariance matrix (d x d), default is <code>diag(ncol(x))</code>.</p>
</td></tr>
<tr><td><code id="rtmvnorm2_+3A_lower">lower</code></td>
<td>
<p>Vector of lower truncation points (r x 1), 
default is <code>rep( Inf, length = length(mean))</code>.</p>
</td></tr>
<tr><td><code id="rtmvnorm2_+3A_upper">upper</code></td>
<td>
<p>Vector of upper truncation points (r x 1), 
default is <code>rep( Inf, length = length(mean))</code>.</p>
</td></tr>
<tr><td><code id="rtmvnorm2_+3A_d">D</code></td>
<td>
<p>Matrix for linear constraints (r x d), defaults to diagonal matrix (d x d), i.e. r = d.</p>
</td></tr>
<tr><td><code id="rtmvnorm2_+3A_algorithm">algorithm</code></td>
<td>
<p>Method used, possible methods are the Fortan Gibbs sampler (&quot;gibbs&quot;, default), 
the Gibbs sampler implementation in R (&quot;gibbsR&quot;) and
rejection sampling (&quot;rejection&quot;)</p>
</td></tr>
<tr><td><code id="rtmvnorm2_+3A_...">...</code></td>
<td>
<p>additional parameters for Gibbs sampling, given to the internal method <code>rtmvnorm.gibbs()</code>, 
such as <code>burn.in.samples</code>, <code>start.value</code> and <code>thinning</code>, see details in <code><a href="#topic+rtmvnorm">rtmvnorm</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method allows for <code class="reqn">r &gt; d</code> linear constraints, whereas <code><a href="#topic+rtmvnorm">rtmvnorm</a></code>
requires a full-rank matrix D <code class="reqn">(d \times d)</code> and can only handle <code class="reqn">r \le d</code> constraints at the moment.
The lower and upper bounds <code>lower</code> and <code>upper</code> are <code class="reqn">(r \times 1)</code>, 
the matrix <code>D</code> is <code class="reqn">(r \times d)</code> and x is <code class="reqn">(d \times 1)</code>. 
The default case is <code class="reqn">r = d</code> and <code class="reqn">D = I_d</code>.
</p>


<h3>Warning</h3>

<p>This method will be merged with <code><a href="#topic+rtmvnorm">rtmvnorm</a></code> in one of the next releases.</p>


<h3>Author(s)</h3>

<p>Stefan Wilhelm
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rtmvnorm">rtmvnorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
################################################################################
#
# Example 5a: Number of linear constraints r &gt; dimension d
#
################################################################################

# general linear restrictions a &lt;= Dx &lt;= b with x (d x 1); D (r x d); a,b (r x 1)

# Dimension d=2, r=3 linear constraints
#
# a1 &lt;=    x1 + x2 &lt;= b2
# a2 &lt;=    x1 - x2 &lt;= b2
# a3 &lt;= 0.5x1 - x2 &lt;= b3
#
# [ a1 ] &lt;= [ 1     1 ] [ x1 ] &lt;= [b1]
# [ a2 ]    [ 1    -1 ] [ x2 ]    [b2]
# [ a3 ]    [ 0.5  -1 ]           [b3]

D &lt;- matrix(
      c(  1,  1,
          1, -1,
        0.5, -1), 3, 2, byrow=TRUE)
a &lt;- c(0, 0, 0)
b &lt;- c(1, 1, 1)

# mark linear constraints as lines
plot(NA, xlim=c(-0.5, 1.5), ylim=c(-1,1))
for (i in 1:3) {
  abline(a=a[i]/D[i, 2], b=-D[i,1]/D[i, 2], col="red")
  abline(a=b[i]/D[i, 2], b=-D[i,1]/D[i, 2], col="red")
}

### Gibbs sampling for general linear constraints a &lt;= Dx &lt;= b
mean &lt;- c(0, 0)
sigma &lt;- matrix(c(1.0, 0.2, 
                  0.2, 1.0), 2, 2)
x0 &lt;- c(0.5, 0.2) # Gibbs sampler start value                  
X &lt;- rtmvnorm2(n=1000, mean, sigma, lower=a, upper=b, D, start.value=x0)

# show random points within simplex
points(X, pch=20, col="black")

## End(Not run)
</code></pre>

<hr>
<h2 id='rtmvt'>Sampling Random Numbers From The Truncated Multivariate Student t Distribution</h2><span id='topic+rtmvt'></span>

<h3>Description</h3>

<p>This function generates random numbers
from the truncated multivariate Student-t
distribution with mean equal to <code>mean</code> and covariance matrix
<code>sigma</code>, lower and upper truncation points <code>lower</code> and <code>upper</code>
with either rejection sampling or Gibbs sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtmvt(n, mean = rep(0, nrow(sigma)), sigma = diag(length(mean)), df = 1, 
  lower = rep(-Inf, length = length(mean)), 
  upper = rep(Inf, length = length(mean)),
  algorithm=c("rejection", "gibbs"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtmvt_+3A_n">n</code></td>
<td>
<p>Number of random points to be sampled. Must be an integer &gt;= 1.</p>
</td></tr>
<tr><td><code id="rtmvt_+3A_mean">mean</code></td>
<td>
<p>Mean vector, default is <code>rep(0, length = ncol(x))</code>.</p>
</td></tr>
<tr><td><code id="rtmvt_+3A_sigma">sigma</code></td>
<td>
<p>Covariance matrix, default is <code>diag(ncol(x))</code>.</p>
</td></tr>
<tr><td><code id="rtmvt_+3A_df">df</code></td>
<td>
<p>Degrees of freedom parameter (positive, may be non-integer)</p>
</td></tr>
<tr><td><code id="rtmvt_+3A_lower">lower</code></td>
<td>
<p>Vector of lower truncation points,\ 
default is <code>rep(-Inf, length = length(mean))</code>.</p>
</td></tr>
<tr><td><code id="rtmvt_+3A_upper">upper</code></td>
<td>
<p>Vector of upper truncation points,\ 
default is <code>rep( Inf, length = length(mean))</code>.</p>
</td></tr>
<tr><td><code id="rtmvt_+3A_algorithm">algorithm</code></td>
<td>
<p>Method used, possible methods are rejection sampling (&quot;rejection&quot;, default) and 
the R Gibbs sampler (&quot;gibbs&quot;).</p>
</td></tr>             
<tr><td><code id="rtmvt_+3A_...">...</code></td>
<td>
<p>additional parameters for Gibbs sampling, given to the internal method <code>rtmvt.gibbs()</code>, 
such as <code>burn.in.samples</code>, <code>start.value</code> and <code>thinning</code>, see details</p>
</td></tr>             
</table>


<h3>Details</h3>

<p>We sample <code class="reqn">x \sim T(\mu, \Sigma, df)</code> subject to the rectangular truncation <code class="reqn">lower \le x \le upper</code>.
Currently, two random number generation methods are implemented: rejection sampling and the Gibbs Sampler.
</p>
<p>For rejection sampling <code>algorithm="rejection"</code>, we sample from <code><a href="mvtnorm.html#topic+rmvt">rmvt</a></code>
and retain only samples inside the support region. The acceptance probability
will be calculated with <code><a href="mvtnorm.html#topic+pmvt">pmvt</a></code>. <code><a href="mvtnorm.html#topic+pmvt">pmvt</a></code> does only accept
integer degrees of freedom <code>df</code>. For non-integer <code>df</code>, <code>algorithm="rejection"</code>
will throw an error, so please use <code>algorithm="gibbs"</code> instead.  
</p>
<p>The arguments to be passed along with <code>algorithm="gibbs"</code> are:
</p>

<dl>
<dt><code>burn.in.samples</code></dt><dd><p>number of samples in Gibbs sampling to be discarded as burn-in phase, must be non-negative.</p>
</dd>
<dt><code>start.value</code></dt><dd><p>Start value (vector of length <code>length(mean)</code>) for the MCMC chain. If one is specified,
it must lie inside the support region (<code class="reqn">lower \le start.value \le upper</code>).
If none is specified, 
the start value is taken componentwise as the finite lower or upper boundaries respectively, 
or zero if both boundaries are infinite. Defaults to NULL.</p>
</dd>
<dt><code>thinning</code></dt><dd><p>Thinning factor for reducing autocorrelation of random points in Gibbs sampling. Must be an integer <code class="reqn">\ge 1</code>. 
We create a Markov chain of length <code>(n*thinning)</code> and take only those
samples <code>j=1:(n*thinning)</code> where <code>j %% thinning == 0</code>  
Defaults to 1 (no thinning of the chain).</p>
</dd>
</dl>



<h3>Warning</h3>

<p>The same warnings for the Gibbs sampler apply as for the method <code><a href="#topic+rtmvnorm">rtmvnorm</a></code>.
</p>


<h3>Author(s)</h3>

<p>Stefan Wilhelm &lt;Stefan.Wilhelm@financial.com&gt;, Manjunath B G &lt;bgmanjunath@gmail.com&gt;</p>


<h3>References</h3>

<p>Geweke, John F. (1991) Efficient Simulation from the Multivariate Normal and Student-t Distributions
Subject to Linear Constraints.
<em>Computer Science and Statistics. Proceedings of the 23rd Symposium on the Interface. Seattle Washington, April 21-24, 1991</em>, pp. 571&ndash;578
An earlier version of this paper is available at <a href="https://www.researchgate.net/publication/2335219_Efficient_Simulation_from_the_Multivariate_Normal_and_Student-t_Distributions_Subject_to_Linear_Constraints_and_the_Evaluation_of_Constraint_Probabilities">https://www.researchgate.net/publication/2335219_Efficient_Simulation_from_the_Multivariate_Normal_and_Student-t_Distributions_Subject_to_Linear_Constraints_and_the_Evaluation_of_Constraint_Probabilities</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###########################################################
#
# Example 1
#
###########################################################	

# Draw from multi-t distribution without truncation
X1 &lt;- rtmvt(n=10000, mean=rep(0, 2), df=2)
X2 &lt;- rtmvt(n=10000, mean=rep(0, 2), df=2, lower=c(-1,-1), upper=c(1,1))

###########################################################
#
# Example 2
#
###########################################################	

df = 2
mu = c(1,1,1)
sigma = matrix(c(  1, 0.5, 0.5,
                 0.5,   1, 0.5,
                 0.5, 0.5,   1), 3, 3)
lower = c(-2,-2,-2)
upper = c(2, 2, 2)

# Rejection sampling
X1 &lt;- rtmvt(n=10000, mu, sigma, df, lower, upper)

# Gibbs sampling without thinning
X2 &lt;- rtmvt(n=10000, mu, sigma, df, lower, upper, 
  algorithm="gibbs")

# Gibbs sampling with thinning
X3 &lt;- rtmvt(n=10000, mu, sigma, df, lower, upper, 
  algorithm="gibbs", thinning=2)	
   
plot(density(X1[,1], from=lower[1], to=upper[1]), col="red", lwd=2,
  main="Gibbs vs. Rejection")
lines(density(X2[,1], from=lower[1], to=upper[1]), col="blue", lwd=2)
legend("topleft",legend=c("Rejection Sampling","Gibbs Sampling"), 
  col=c("red","blue"), lwd=2)

acf(X1)  # no autocorrelation in Rejection sampling
acf(X2)  # strong autocorrelation of Gibbs samples
acf(X3)  # reduced autocorrelation of Gibbs samples after thinning	
</code></pre>

<hr>
<h2 id='tmvnorm'>Truncated Multivariate Normal Density</h2><span id='topic+dtmvnorm'></span>

<h3>Description</h3>

<p>This function provides the joint density function for the truncated multivariate normal
distribution with mean equal to <code>mean</code> and covariance matrix
<code>sigma</code>, lower and upper truncation points <code>lower</code> and <code>upper</code>.
For convenience, it furthermore serves as a wrapper function for the one-dimensional and bivariate marginal densities 
<code>dtmvnorm.marginal()</code> and <code>dtmvnorm.marginal2()</code> respectively when invoked with the <code>margin</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtmvnorm(x, mean = rep(0, nrow(sigma)), 
  sigma = diag(length(mean)), 
  lower=rep(-Inf, length = length(mean)), 
  upper=rep( Inf, length = length(mean)),
  log=FALSE, 
  margin=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tmvnorm_+3A_x">x</code></td>
<td>
<p>Vector or matrix of quantiles. If <code>x</code> is a matrix, each row is taken to be a quantile.</p>
</td></tr>
<tr><td><code id="tmvnorm_+3A_mean">mean</code></td>
<td>
<p>Mean vector, default is <code>rep(0, nrow(sigma))</code>.</p>
</td></tr>
<tr><td><code id="tmvnorm_+3A_sigma">sigma</code></td>
<td>
<p>Covariance matrix, default is <code>diag(length(mean))</code>.</p>
</td></tr>
<tr><td><code id="tmvnorm_+3A_lower">lower</code></td>
<td>
<p>Vector of lower truncation points, 
default is <code>rep(-Inf, length = length(mean))</code>.</p>
</td></tr>
<tr><td><code id="tmvnorm_+3A_upper">upper</code></td>
<td>
<p>Vector of upper truncation points, 
default is <code>rep( Inf, length = length(mean))</code>.</p>
</td></tr>
<tr><td><code id="tmvnorm_+3A_log">log</code></td>
<td>
<p>Logical; if <code>TRUE</code>, densities d are given as log(d).</p>
</td></tr>
<tr><td><code id="tmvnorm_+3A_margin">margin</code></td>
<td>
<p>if <code>NULL</code> then the joint density is computed (the default), 
if <code>MARGIN=1</code> then the one-dimensional marginal density in variate <code>q</code> (<code>q = 1..length(mean)</code>) is returned, 
if <code>MARGIN=c(q,r)</code> then the bivariate marginal density in variates <code>q</code> and <code>r</code> 
for <code>q,r = 1..length(mean)</code> and <code class="reqn">q \ne r</code> is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computation of truncated multivariate normal probabilities and densities is done using conditional probabilities 
from the standard/untruncated multivariate normal distribution. 
So we refer to the documentation of the mvtnorm package and the methodology is described in
Genz (1992, 1993).
</p>


<h3>Author(s)</h3>

<p>Stefan Wilhelm &lt;Stefan.Wilhelm@financial.com&gt;</p>


<h3>References</h3>

 
<p>Genz, A. (1992). Numerical computation of multivariate normal probabilities.
<em>Journal of Computational and Graphical Statistics</em>, <b>1</b>, 141&ndash;150 
</p>
<p>Genz, A. (1993). Comparison of methods for the computation of multivariate
normal probabilities. <em>Computing Science and Statistics</em>, <b>25</b>,
400&ndash;405
</p>
<p>Johnson, N./Kotz, S. (1970). Distributions in Statistics: Continuous Multivariate Distributions
<em>Wiley &amp; Sons</em>, pp. 70&ndash;73
</p>
<p>Horrace, W. (2005). Some Results on the Multivariate Truncated Normal Distribution. 
<em>Journal of Multivariate Analysis</em>, <b>94</b>, 209&ndash;221
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ptmvnorm">ptmvnorm</a></code>, <code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code>, <code><a href="mvtnorm.html#topic+rmvnorm">rmvnorm</a></code>, <code><a href="mvtnorm.html#topic+dmvnorm">dmvnorm</a></code>,
<code><a href="#topic+dtmvnorm.marginal">dtmvnorm.marginal</a></code> and <code><a href="#topic+dtmvnorm.marginal2">dtmvnorm.marginal2</a></code> for marginal density functions</p>


<h3>Examples</h3>

<pre><code class='language-R'>dtmvnorm(x=c(0,0), mean=c(1,1), upper=c(0,0))

###########################################
#
# Example 1: 
# truncated multivariate normal density        
#
############################################

x1&lt;-seq(-2, 3, by=0.1)
x2&lt;-seq(-2, 3, by=0.1)

density&lt;-function(x)
{
  sigma=matrix(c(1, -0.5, -0.5, 1), 2, 2)
  z=dtmvnorm(x, mean=c(0,0), sigma=sigma, lower=c(-1,-1))
  z
}

fgrid &lt;- function(x, y, f)
{
    z &lt;- matrix(nrow=length(x), ncol=length(y))
    for(m in 1:length(x)){
        for(n in 1:length(y)){
            z[m,n] &lt;- f(c(x[m], y[n]))
        }
    }
    z
}

# compute density d for grid
d=fgrid(x1, x2, density)

# plot density as contourplot
contour(x1, x2, d, nlevels=5, main="Truncated Multivariate Normal Density", 
  xlab=expression(x[1]), ylab=expression(x[2]))
abline(v=-1, lty=3, lwd=2)
abline(h=-1, lty=3, lwd=2)

###########################################
#
# Example 2: 
# generation of random numbers
# from a truncated multivariate normal distribution        
#
############################################

sigma &lt;- matrix(c(4,2,2,3), ncol=2)
x &lt;- rtmvnorm(n=500, mean=c(1,2), sigma=sigma, upper=c(1,0))
plot(x, main="samples from truncated bivariate normal distribution",
  xlim=c(-6,6), ylim=c(-6,6), 
  xlab=expression(x[1]), ylab=expression(x[2]))
abline(v=1, lty=3, lwd=2, col="gray")
abline(h=0, lty=3, lwd=2, col="gray")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
