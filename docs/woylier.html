<!DOCTYPE html><html><head><title>Help for package woylier</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {woylier}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_path'><p>Overlay paths of interpolation on the sphere</p></a></li>
<li><a href='#angle2'><p>Compute the angle between 2d vectors 360 degrees</p></a></li>
<li><a href='#calculate_angles'><p>Calculate angles of required rotations to map Wz to Wa</p></a></li>
<li><a href='#construct_moving_frame'><p>Reconstruct interpolated frames using pre-projection</p></a></li>
<li><a href='#construct_preframe'><p>Construct preprojected frames</p></a></li>
<li><a href='#generate_space_view'><p>Generate the background sphere or torus</p></a></li>
<li><a href='#givens_full_path'><p>Construct full interpolated frames</p></a></li>
<li><a href='#givens_info'><p>Calculate information needed for Givens interpolation</p></a></li>
<li><a href='#givens_path'><p>Interpolation format for tourr</p></a></li>
<li><a href='#givens_rotation'><p>It implements series of Givens rotations that maps Wa to Wz</p></a></li>
<li><a href='#givens_step_fraction'><p>Step along a Givens interpolated path by fraction of path length.</p></a></li>
<li><a href='#grand_tour_givens'><p>Create a grand tour with Givens interpolation</p></a></li>
<li><a href='#guided_tour_givens'><p>Create a guided tour with Givens interpolation</p></a></li>
<li><a href='#new_givens_path'><p>Path needed for tour with Givens interpolation</p></a></li>
<li><a href='#planned_tour_givens'><p>A planned tour path using frame-to-frame interpolation.</p></a></li>
<li><a href='#preprojection'><p>Build a d-dimensional pre-projection space by orthonormalizing Fz with regard to Fa</p></a></li>
<li><a href='#row_rot'><p>Takes i and k-th row of a matrix and rotate matrix by theta angle (requires matrix a to be 2*q matrix)</p></a></li>
<li><a href='#sine_curve measurements'><p>Simulated 6D data with a sine curve</p></a></li>
<li><a href='#woylier-package'><p>woylier: Alternative Tour Frame Interpolation Method</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Alternative Tour Frame Interpolation Method</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.5</td>
</tr>
<tr>
<td>Description:</td>
<td>This method generates a tour path by interpolating between d-D frames in p-D using Givens rotations. The algorithm arises from the problem of zeroing elements of a matrix. This interpolation method is useful for showing specific d-D frames in the tour, as opposed to d-D planes, as done by the geodesic interpolation. It is useful for projection pursuit indexes which are not s invariant. See Buja et al (2005) &lt;<a href="https://doi.org/10.1016%2FS0169-7161%2804%2924014-7">doi:10.1016/S0169-7161(04)24014-7</a>&gt;. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>tourr, geozoo, dplyr, tibble</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, purrr, ggplot2, ash, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-17 11:59:46 UTC; zoljargal</td>
</tr>
<tr>
<td>Author:</td>
<td>Zola Batsaikan <a href="https://orcid.org/0009-0005-0055-1448"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Dianne Cook <a href="https://orcid.org/0000-0002-3813-7155"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Ursula Laa <a href="https://orcid.org/0000-0002-0249-6439"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zola Batsaikan &lt;zoljargal11@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-18 15:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_path'>Overlay paths of interpolation on the sphere</h2><span id='topic+add_path'></span>

<h3>Description</h3>

<p>Overlay paths of interpolation on the sphere
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_path(proj_space, path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_path_+3A_proj_space">proj_space</code></td>
<td>
<p>n number of points on the surface of sphere</p>
</td></tr>
<tr><td><code id="add_path_+3A_path">path</code></td>
<td>
<p>interpolated path</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with interpolated path and points on sphere surface
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 4
base1 &lt;- tourr::basis_random(p, d=1)
base2 &lt;- tourr::basis_random(p, d=1)
path &lt;- givens_full_path(base1, base2, nsteps=10)
sp &lt;- generate_space_view(p=p)
sp_path &lt;- add_path(sp, path)

  tourr::animate_xy(sp_path[,1:4], col=sp_path$type)

</code></pre>

<hr>
<h2 id='angle2'>Compute the angle between 2d vectors 360 degrees</h2><span id='topic+angle2'></span>

<h3>Description</h3>

<p>Compute the angle between 2d vectors 360 degrees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angle2(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angle2_+3A_x">x</code></td>
<td>
<p>vector with length 2</p>
</td></tr>
<tr><td><code id="angle2_+3A_y">y</code></td>
<td>
<p>vector with length 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>angle in radians
</p>

<hr>
<h2 id='calculate_angles'>Calculate angles of required rotations to map Wz to Wa</h2><span id='topic+calculate_angles'></span>

<h3>Description</h3>

<p>Calculate angles of required rotations to map Wz to Wa
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_angles(Wa, Wz)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_angles_+3A_wa">Wa</code></td>
<td>
<p>starting preprojected frame</p>
</td></tr>
<tr><td><code id="calculate_angles_+3A_wz">Wz</code></td>
<td>
<p>target preprojected frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list of angles
</p>

<hr>
<h2 id='construct_moving_frame'>Reconstruct interpolated frames using pre-projection</h2><span id='topic+construct_moving_frame'></span>

<h3>Description</h3>

<p>Reconstruct interpolated frames using pre-projection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_moving_frame(Wt, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_moving_frame_+3A_wt">Wt</code></td>
<td>
<p>A givens path by stepfraction</p>
</td></tr>
<tr><td><code id="construct_moving_frame_+3A_b">B</code></td>
<td>
<p>pre-projection px2d matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A frame of on the step of interpolation
</p>

<hr>
<h2 id='construct_preframe'>Construct preprojected frames</h2><span id='topic+construct_preframe'></span>

<h3>Description</h3>

<p>Construct preprojected frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_preframe(Fr, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_preframe_+3A_fr">Fr</code></td>
<td>
<p>Orthonormal frame</p>
</td></tr>
<tr><td><code id="construct_preframe_+3A_b">B</code></td>
<td>
<p>pre-projection px2d matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Preprojected 2dxd frame on preprojection space (first dxd entry of this matrix is identity matrix by construction)
</p>

<hr>
<h2 id='generate_space_view'>Generate the background sphere or torus</h2><span id='topic+generate_space_view'></span>

<h3>Description</h3>

<p>Generate the background sphere or torus
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_space_view(n = 1000, p = 3, d = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_space_view_+3A_n">n</code></td>
<td>
<p>number of points on the sphere</p>
</td></tr>
<tr><td><code id="generate_space_view_+3A_p">p</code></td>
<td>
<p>dimension of data</p>
</td></tr>
<tr><td><code id="generate_space_view_+3A_d">d</code></td>
<td>
<p>dimension of projection</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n number of points on the surface of sphere
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 4
sp &lt;- generate_space_view(p=p)
</code></pre>

<hr>
<h2 id='givens_full_path'>Construct full interpolated frames</h2><span id='topic+givens_full_path'></span>

<h3>Description</h3>

<p>Construct full interpolated frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>givens_full_path(Fa, Fz, nsteps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="givens_full_path_+3A_fa">Fa</code></td>
<td>
<p>starting pxd frame</p>
</td></tr>
<tr><td><code id="givens_full_path_+3A_fz">Fz</code></td>
<td>
<p>target pxd frame</p>
</td></tr>
<tr><td><code id="givens_full_path_+3A_nsteps">nsteps</code></td>
<td>
<p>number of steps of interpolation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array with nsteps matrix. Each matrix is interpolated frame in between starting and target frames.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 4
base1 &lt;- tourr::orthonormalise(tourr::basis_random(p, d=1))
base2 &lt;- tourr::orthonormalise(tourr::basis_random(p, d=1))
path &lt;- givens_full_path(base1, base2, nsteps=10)
</code></pre>

<hr>
<h2 id='givens_info'>Calculate information needed for Givens interpolation</h2><span id='topic+givens_info'></span>

<h3>Description</h3>

<p>The methodology is outlined in
<a href="http://www-stat.wharton.upenn.edu/~buja/PAPERS/paper-dyn-proj-algs.pdf">http://www-stat.wharton.upenn.edu/~buja/PAPERS/paper-dyn-proj-algs.pdf</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>givens_info(Fa, Fz)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="givens_info_+3A_fa">Fa</code></td>
<td>
<p>starting frame, will be orthonormalized if necessary</p>
</td></tr>
<tr><td><code id="givens_info_+3A_fz">Fz</code></td>
<td>
<p>target frame, will be orthonormalized if necessary</p>
</td></tr>
</table>

<hr>
<h2 id='givens_path'>Interpolation format for tourr</h2><span id='topic+givens_path'></span>

<h3>Description</h3>

<p>Generates the interpolation in the form needed for
tourr, modelled on geodesic_path()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>givens_path(current, target, frozen = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="givens_path_+3A_current">current</code></td>
<td>
<p>starting frame</p>
</td></tr>
<tr><td><code id="givens_path_+3A_target">target</code></td>
<td>
<p>target frame</p>
</td></tr>
<tr><td><code id="givens_path_+3A_frozen">frozen</code></td>
<td>
<p>indicator whether some dimensions fixed</p>
</td></tr>
<tr><td><code id="givens_path_+3A_...">...</code></td>
<td>
<p>arguments sent to later functions</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>interpolate</code></td>
<td>
<p>A function with single parameter in [0, 1] that
returns an interpolated frame between the current and future frames.
0 gives the current plane, 1 gives the new target frame in plane of
current frame.</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>The distance, in radians, between the current and target
frames.</p>
</td></tr>
<tr><td><code>Fa</code></td>
<td>
<p>The current frame.</p>
</td></tr>
<tr><td><code>Fz</code></td>
<td>
<p>The new target frame.</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>The principle angles between the current and target frames.</p>
</td></tr>
<tr><td><code>Ga</code></td>
<td>
<p>The current plane.</p>
</td></tr>
<tr><td><code>Gz</code></td>
<td>
<p>The target plane.</p>
</td></tr>
</table>

<hr>
<h2 id='givens_rotation'>It implements series of Givens rotations that maps Wa to Wz</h2><span id='topic+givens_rotation'></span>

<h3>Description</h3>

<p>It implements series of Givens rotations that maps Wa to Wz
</p>


<h3>Usage</h3>

<pre><code class='language-R'>givens_rotation(Wa, angles, stepfraction)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="givens_rotation_+3A_wa">Wa</code></td>
<td>
<p>starting preprojected frame</p>
</td></tr>
<tr><td><code id="givens_rotation_+3A_angles">angles</code></td>
<td>
<p>angles of required rotations to map Wz to Wa</p>
</td></tr>
<tr><td><code id="givens_rotation_+3A_stepfraction">stepfraction</code></td>
<td>
<p>for the interpolation of rotations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Givens path by stepfraction in pre-projected space
</p>

<hr>
<h2 id='givens_step_fraction'>Step along a Givens interpolated path by fraction of path length.</h2><span id='topic+givens_step_fraction'></span>

<h3>Description</h3>

<p>Step along a Givens interpolated path by fraction of path length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>givens_step_fraction(interp, fraction)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="givens_step_fraction_+3A_interp">interp</code></td>
<td>
<p>interpolated path</p>
</td></tr>
<tr><td><code id="givens_step_fraction_+3A_fraction">fraction</code></td>
<td>
<p>fraction of distance between start and end frames</p>
</td></tr>
</table>

<hr>
<h2 id='grand_tour_givens'>Create a grand tour with Givens interpolation</h2><span id='topic+grand_tour_givens'></span>

<h3>Description</h3>

<p>Create a grand tour with Givens interpolation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grand_tour_givens(d = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grand_tour_givens_+3A_d">d</code></td>
<td>
<p>dimension of projection</p>
</td></tr>
<tr><td><code id="grand_tour_givens_+3A_...">...</code></td>
<td>
<p>additional parameters to pass through</p>
</td></tr>
</table>


<h3>Value</h3>

<p>creates grand tour
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sine_curve)
tourr::animate(sine_curve, grand_tour_givens(), tourr::display_xy())
</code></pre>

<hr>
<h2 id='guided_tour_givens'>Create a guided tour with Givens interpolation</h2><span id='topic+guided_tour_givens'></span>

<h3>Description</h3>

<p>Create a guided tour with Givens interpolation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guided_tour_givens(
  index_f,
  d = 2,
  alpha = 0.5,
  cooling = 0.99,
  max.tries = 25,
  max.i = Inf,
  optim = "search_geodesic",
  n_sample = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guided_tour_givens_+3A_index_f">index_f</code></td>
<td>
<p>the index function to optimize.</p>
</td></tr>
<tr><td><code id="guided_tour_givens_+3A_d">d</code></td>
<td>
<p>target dimensionality</p>
</td></tr>
<tr><td><code id="guided_tour_givens_+3A_alpha">alpha</code></td>
<td>
<p>the initial size of the search window, in radians</p>
</td></tr>
<tr><td><code id="guided_tour_givens_+3A_cooling">cooling</code></td>
<td>
<p>the amount the size of the search window should be adjusted
by after each step</p>
</td></tr>
<tr><td><code id="guided_tour_givens_+3A_max.tries">max.tries</code></td>
<td>
<p>the maximum number of unsuccessful attempts to find
a better projection before giving up</p>
</td></tr>
<tr><td><code id="guided_tour_givens_+3A_max.i">max.i</code></td>
<td>
<p>the maximum index value, stop search if a larger value is found</p>
</td></tr>
<tr><td><code id="guided_tour_givens_+3A_optim">optim</code></td>
<td>
<p>character indicating the search strategy to use: <code>search_geodesic</code>, <code>search_better</code>,
<code>search_better_random</code>, <code>search_polish</code>. Default is <code>search_geodesic</code>.</p>
</td></tr>
<tr><td><code id="guided_tour_givens_+3A_n_sample">n_sample</code></td>
<td>
<p>number of samples to generate if <code>search_f</code> is <code>search_polish</code></p>
</td></tr>
<tr><td><code id="guided_tour_givens_+3A_...">...</code></td>
<td>
<p>arguments sent to the search_f</p>
</td></tr>
</table>


<h3>Value</h3>

<p>creates guided tour
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sine_curve)
tourr::animate_xy(sine_curve, guided_tour_givens(tourr::splines2d()), sphere=FALSE)
</code></pre>

<hr>
<h2 id='new_givens_path'>Path needed for tour with Givens interpolation</h2><span id='topic+new_givens_path'></span>

<h3>Description</h3>

<p>Path needed for tour with Givens interpolation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_givens_path(name, generator, frozen = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_givens_path_+3A_name">name</code></td>
<td>
<p>name to give tour path</p>
</td></tr>
<tr><td><code id="new_givens_path_+3A_frozen">frozen</code></td>
<td>
<p>matrix giving frozen variables, as described in
<code>freeze</code></p>
</td></tr>
<tr><td><code id="new_givens_path_+3A_generate">generate</code></td>
<td>
<p>basis generator function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>creates path for Givens interpolation
</p>

<hr>
<h2 id='planned_tour_givens'>A planned tour path using frame-to-frame interpolation.</h2><span id='topic+planned_tour_givens'></span>

<h3>Description</h3>

<p>The planned tour takes you from one basis to the next in a
set order.  Once you have visited all the planned bases, you either stop
or start from the beginning once more (if <code>cycle = TRUE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>planned_tour_givens(basis_set, cycle = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="planned_tour_givens_+3A_basis_set">basis_set</code></td>
<td>
<p>the set of bases as a list of projection matrices
or a 3d array</p>
</td></tr>
<tr><td><code id="planned_tour_givens_+3A_cycle">cycle</code></td>
<td>
<p>cycle through continuously (<code>TRUE</code>) or stop after
first pass (<code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually, you will not call this function directly, but will pass it to
a method that works with tour paths like <code><a href="gridSVG.html#topic+animate">animate</a></code>,
<code><a href="tourr.html#topic+save_history">save_history</a></code> or <code><a href="rmarkdown.html#topic+render">render</a></code>.
</p>


<h3>Value</h3>

<p>creates planned tour path
</p>


<h3>See Also</h3>

<p>The <code><a href="tourr.html#topic+little_tour">little_tour</a></code>, a special type of planned tour
which cycles between all axis parallel projections.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tourr)
twod &lt;- save_history(flea[, 1:3], max = 5)
str(twod)
animate_xy(flea[, 1:3], planned_tour_givens(twod))
animate_xy(flea[, 1:3], planned_tour_givens(twod, TRUE))

oned &lt;- save_history(flea[, 1:6], grand_tour(1), max = 3)
animate_dist(flea[, 1:6], planned_tour_givens(oned))
</code></pre>

<hr>
<h2 id='preprojection'>Build a d-dimensional pre-projection space by orthonormalizing Fz with regard to Fa</h2><span id='topic+preprojection'></span>

<h3>Description</h3>

<p>Build a d-dimensional pre-projection space by orthonormalizing Fz with regard to Fa
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preprojection(Fa, Fz)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preprojection_+3A_fa">Fa</code></td>
<td>
<p>starting pxd frame</p>
</td></tr>
<tr><td><code id="preprojection_+3A_fz">Fz</code></td>
<td>
<p>ending pxd frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>B pre-projection px2d matrix
</p>

<hr>
<h2 id='row_rot'>Takes i and k-th row of a matrix and rotate matrix by theta angle (requires matrix a to be 2*q matrix)</h2><span id='topic+row_rot'></span>

<h3>Description</h3>

<p>Takes i and k-th row of a matrix and rotate matrix by theta angle (requires matrix a to be 2*q matrix)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_rot(a, i, k, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="row_rot_+3A_a">a</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="row_rot_+3A_i">i</code></td>
<td>
<p>row</p>
</td></tr>
<tr><td><code id="row_rot_+3A_k">k</code></td>
<td>
<p>row that we want to zero the element</p>
</td></tr>
<tr><td><code id="row_rot_+3A_theta">theta</code></td>
<td>
<p>angle between them</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rotated matrix a
</p>
<p>refer to Algorithm 5.1.6 of Matrix computation (Golub, Van)
</p>

<hr>
<h2 id='sine_curve+20measurements'>Simulated 6D data with a sine curve</h2><span id='topic+sine_curve+20measurements'></span><span id='topic+sine_curve'></span>

<h3>Description</h3>

<p>The data has 6 columns, labelled V1-V6,
where the sine curve is in V5, V6. The
other columns are normal samples.
</p>


<h3>Format</h3>

<p>A 500x6 data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(woylier)
data(sine_curve)
plot(sine_curve$V5, sine_curve$V6)
</code></pre>

<hr>
<h2 id='woylier-package'>woylier: Alternative Tour Frame Interpolation Method</h2><span id='topic+woylier'></span><span id='topic+woylier-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>This method generates a tour path by interpolating between d-D frames in p-D using Givens rotations. The algorithm arises from the problem of zeroing elements of a matrix. This interpolation method is useful for showing specific d-D frames in the tour, as opposed to d-D planes, as done by the geodesic interpolation. It is useful for projection pursuit indexes which are not s invariant. See Buja et al (2005) <a href="https://doi.org/10.1016/S0169-7161%2804%2924014-7">doi:10.1016/S0169-7161(04)24014-7</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Zola Batsaikan <a href="mailto:zoljargal11@gmail.com">zoljargal11@gmail.com</a> (<a href="https://orcid.org/0009-0005-0055-1448">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Dianne Cook <a href="mailto:dicook@monash.edu">dicook@monash.edu</a> (<a href="https://orcid.org/0000-0002-3813-7155">ORCID</a>) [contributor]
</p>
</li>
<li><p> Ursula Laa <a href="mailto:ursula.laa@boku.ac.at">ursula.laa@boku.ac.at</a> (<a href="https://orcid.org/0000-0002-0249-6439">ORCID</a>) [contributor]
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
