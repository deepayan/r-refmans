<!DOCTYPE html><html lang="en"><head><title>Help for package effectplots</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {effectplots}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.ale'><p>Barebone Accumulated Local Effects (ALE)</p></a></li>
<li><a href='#.pd'><p>Barebone Partial Dependence</p></a></li>
<li><a href='#ale'><p>Accumulated Local Effects (ALE)</p></a></li>
<li><a href='#average_observed'><p>Average Observed</p></a></li>
<li><a href='#average_predicted'><p>Average Predictions</p></a></li>
<li><a href='#bias'><p>Bias / Average Residuals</p></a></li>
<li><a href='#effect_importance'><p>Variable Importance</p></a></li>
<li><a href='#fcut'><p>Fast cut()</p></a></li>
<li><a href='#feature_effects'><p>Feature Effects</p></a></li>
<li><a href='#partial_dependence'><p>Partial Dependence</p></a></li>
<li><a href='#plot.EffectData'><p>Plots &quot;EffectData&quot; Object</p></a></li>
<li><a href='#update.EffectData'><p>Update &quot;EffectData&quot; Object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Effect Plots</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Description:</td>
<td>High-performance implementation of various effect plots
    useful for regression and probabilistic classification tasks.  The
    package includes partial dependence plots (Friedman, 2021,
    &lt;<a href="https://doi.org/10.1214%2Faos%2F1013203451">doi:10.1214/aos/1013203451</a>&gt;), accumulated local effect plots and
    M-plots (both from Apley and Zhu, 2016, &lt;<a href="https://doi.org/10.1111%2Frssb.12377">doi:10.1111/rssb.12377</a>&gt;), as
    well as plots that describe the statistical associations between model
    response and features.  It supports visualizations with either
    'ggplot2' or 'plotly', and is compatible with most models, including
    'Tidymodels', models wrapped in 'DALEX' explainers, or models with
    case weights.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>collapse, ggplot2, grDevices, labeling, patchwork, plotly,
Rcpp, scales, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mayer79/effectplots">https://github.com/mayer79/effectplots</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mayer79/effectplots/issues">https://github.com/mayer79/effectplots/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Enhances:</td>
<td>h2o</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-09 09:27:54 UTC; mayer</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Mayer [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Mayer &lt;mayermichael79@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-09 09:40:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='.ale'>Barebone Accumulated Local Effects (ALE)</h2><span id='topic+.ale'></span>

<h3>Description</h3>

<p>This is a barebone implementation of Apley's ALE.
Per bin, the local effect <code class="reqn">D_j</code> is calculated, and then accumulated over bins.
<code class="reqn">D_j</code> equals the difference between the partial dependence at the
lower and upper bin breaks using only observations within bin.
To plot the values, we can make a line plot of the resulting vector against
upper bin breaks. Alternatively, the vector can be extended
from the left by the value 0, and then plotted against <em>all</em> breaks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.ale(
  object,
  v,
  data,
  breaks,
  right = TRUE,
  pred_fun = stats::predict,
  trafo = NULL,
  which_pred = NULL,
  bin_size = 200L,
  w = NULL,
  g = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".ale_+3A_object">object</code></td>
<td>
<p>Fitted model.</p>
</td></tr>
<tr><td><code id=".ale_+3A_v">v</code></td>
<td>
<p>Variable name in <code>data</code> to calculate ALE.</p>
</td></tr>
<tr><td><code id=".ale_+3A_data">data</code></td>
<td>
<p>Matrix or data.frame.</p>
</td></tr>
<tr><td><code id=".ale_+3A_breaks">breaks</code></td>
<td>
<p>Bin breaks.</p>
</td></tr>
<tr><td><code id=".ale_+3A_right">right</code></td>
<td>
<p>Should bins be right-closed?
The default is <code>TRUE</code>. (No effect if <code>g</code> is provided.)</p>
</td></tr>
<tr><td><code id=".ale_+3A_pred_fun">pred_fun</code></td>
<td>
<p>Prediction function, by default <code>stats::predict</code>.
The function takes three arguments (names irrelevant): <code>object</code>, <code>data</code>, and <code>...</code>.</p>
</td></tr>
<tr><td><code id=".ale_+3A_trafo">trafo</code></td>
<td>
<p>How should predictions be transformed?
A function or <code>NULL</code> (default). Examples are <code>log</code> (to switch to link scale)
or <code>exp</code> (to switch from link scale to the original scale).
Applied after <code>which_pred</code>.</p>
</td></tr>
<tr><td><code id=".ale_+3A_which_pred">which_pred</code></td>
<td>
<p>If the predictions are multivariate: which column to pick
(integer or column name). By default <code>NULL</code> (picks last column). Applied before
<code>trafo</code>.</p>
</td></tr>
<tr><td><code id=".ale_+3A_bin_size">bin_size</code></td>
<td>
<p>Maximal number of observations used per bin. If there are more
observations in a bin, <code>bin_size</code> indices are randomly sampled. The default is 200.</p>
</td></tr>
<tr><td><code id=".ale_+3A_w">w</code></td>
<td>
<p>Optional vector with case weights.</p>
</td></tr>
<tr><td><code id=".ale_+3A_g">g</code></td>
<td>
<p>For internal use. The result of <code>as.factor(findInterval(...))</code>.
By default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id=".ale_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>pred_fun()</code>, e.g., <code>type = "response"</code> in
a <code>glm()</code> or (typically) <code>prob = TRUE</code> in classification models.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector representing one ALE per bin.
</p>


<h3>References</h3>

<p>Apley, Daniel W., and Jingyu Zhu. 2020. <em>Visualizing the Effects of Predictor Variables in Black Box Supervised Learning Models.</em>
Journal of the Royal Statistical Society Series B: Statistical Methodology,
82 (4): 1059–1086. doi:10.1111/rssb.12377.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+partial_dependence">partial_dependence()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
v &lt;- "Sepal.Width"
.ale(fit, v, data = iris, breaks = seq(2, 4, length.out = 5))
</code></pre>

<hr>
<h2 id='.pd'>Barebone Partial Dependence</h2><span id='topic+.pd'></span>

<h3>Description</h3>

<p>This is a barebone implementation of Friedman's partial dependence
intended for developers. To get more information on partial dependence, see
<code><a href="#topic+partial_dependence">partial_dependence()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.pd(
  object,
  v,
  data,
  grid,
  pred_fun = stats::predict,
  trafo = NULL,
  which_pred = NULL,
  w = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".pd_+3A_object">object</code></td>
<td>
<p>Fitted model.</p>
</td></tr>
<tr><td><code id=".pd_+3A_v">v</code></td>
<td>
<p>Variable name in <code>data</code> to calculate partial dependence.</p>
</td></tr>
<tr><td><code id=".pd_+3A_data">data</code></td>
<td>
<p>Matrix or data.frame.</p>
</td></tr>
<tr><td><code id=".pd_+3A_grid">grid</code></td>
<td>
<p>Vector or factor of values to calculate partial dependence for.</p>
</td></tr>
<tr><td><code id=".pd_+3A_pred_fun">pred_fun</code></td>
<td>
<p>Prediction function, by default <code>stats::predict</code>.
The function takes three arguments (names irrelevant): <code>object</code>, <code>data</code>, and <code>...</code>.</p>
</td></tr>
<tr><td><code id=".pd_+3A_trafo">trafo</code></td>
<td>
<p>How should predictions be transformed?
A function or <code>NULL</code> (default). Examples are <code>log</code> (to switch to link scale)
or <code>exp</code> (to switch from link scale to the original scale).
Applied after <code>which_pred</code>.</p>
</td></tr>
<tr><td><code id=".pd_+3A_which_pred">which_pred</code></td>
<td>
<p>If the predictions are multivariate: which column to pick
(integer or column name). By default <code>NULL</code> (picks last column). Applied before
<code>trafo</code>.</p>
</td></tr>
<tr><td><code id=".pd_+3A_w">w</code></td>
<td>
<p>Optional vector with case weights.</p>
</td></tr>
<tr><td><code id=".pd_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>pred_fun()</code>, e.g., <code>type = "response"</code> in
a <code>glm()</code> or (typically) <code>prob = TRUE</code> in classification models.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of partial dependence values in the same order as <code>grid</code>.
</p>


<h3>References</h3>

<p>Friedman, Jerome H. 2001, <em>Greedy Function Approximation: A Gradient Boosting Machine.</em>
Annals of Statistics 29 (5): 1189-1232. doi:10.1214/aos/1013203451.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+partial_dependence">partial_dependence()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
.pd(fit, "Sepal.Width", data = iris, grid = hist(iris$Sepal.Width)$mids)
.pd(fit, "Species", data = iris, grid = levels(iris$Species))
</code></pre>

<hr>
<h2 id='ale'>Accumulated Local Effects (ALE)</h2><span id='topic+ale'></span><span id='topic+ale.default'></span><span id='topic+ale.ranger'></span><span id='topic+ale.explainer'></span><span id='topic+ale.H2OModel'></span>

<h3>Description</h3>

<p>Calculates ALE for one or multiple continuous features specified by <code>X</code>.
</p>
<p>The concept of ALE was introduced in Apley et al. (2020) as an alternative to
partial dependence (PD). The Ceteris Paribus clause behind PD is a blessing and
a curse at the same time:
</p>

<ul>
<li><p> Blessing: The interpretation is easy and similar to what we know from linear
regression  (just averaging out interaction effects).
</p>
</li>
<li><p> Curse: The model is applied to very unlikely or even impossible feature
combinations, especially with strongly dependent features.
</p>
</li></ul>

<p>ALE fixes the curse as follows: Per bin, the local effect is calculated as the
partial dependence difference between lower and upper bin break, using only
observations falling into this bin. This is repeated for all bins,
and the values are <em>accumulated</em>.
</p>
<p>ALE values are plotted against right bin breaks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ale(object, ...)

## Default S3 method:
ale(
  object,
  v,
  data,
  pred_fun = stats::predict,
  trafo = NULL,
  which_pred = NULL,
  w = NULL,
  breaks = "Sturges",
  right = TRUE,
  discrete_m = 13L,
  outlier_iqr = 2,
  ale_n = 50000L,
  ale_bin_size = 200L,
  seed = NULL,
  ...
)

## S3 method for class 'ranger'
ale(
  object,
  v,
  data,
  pred_fun = NULL,
  trafo = NULL,
  which_pred = NULL,
  w = NULL,
  breaks = "Sturges",
  right = TRUE,
  discrete_m = 13L,
  outlier_iqr = 2,
  ale_n = 50000L,
  ale_bin_size = 200L,
  seed = NULL,
  ...
)

## S3 method for class 'explainer'
ale(
  object,
  v = colnames(data),
  data = object$data,
  pred_fun = object$predict_function,
  trafo = NULL,
  which_pred = NULL,
  w = object$weights,
  breaks = "Sturges",
  right = TRUE,
  discrete_m = 13L,
  outlier_iqr = 2,
  ale_n = 50000L,
  ale_bin_size = 200L,
  seed = NULL,
  ...
)

## S3 method for class 'H2OModel'
ale(
  object,
  data,
  v = object@parameters$x,
  pred_fun = NULL,
  trafo = NULL,
  which_pred = NULL,
  w = object@parameters$weights_column$column_name,
  breaks = "Sturges",
  right = TRUE,
  discrete_m = 13L,
  outlier_iqr = 2,
  ale_n = 50000L,
  ale_bin_size = 200L,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ale_+3A_object">object</code></td>
<td>
<p>Fitted model.</p>
</td></tr>
<tr><td><code id="ale_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>pred_fun()</code>, e.g., <code>type = "response"</code> in
a <code>glm()</code> or (typically) <code>prob = TRUE</code> in classification models.</p>
</td></tr>
<tr><td><code id="ale_+3A_v">v</code></td>
<td>
<p>Variable names to calculate statistics for.</p>
</td></tr>
<tr><td><code id="ale_+3A_data">data</code></td>
<td>
<p>Matrix or data.frame.</p>
</td></tr>
<tr><td><code id="ale_+3A_pred_fun">pred_fun</code></td>
<td>
<p>Prediction function, by default <code>stats::predict</code>.
The function takes three arguments (names irrelevant): <code>object</code>, <code>data</code>, and <code>...</code>.</p>
</td></tr>
<tr><td><code id="ale_+3A_trafo">trafo</code></td>
<td>
<p>How should predictions be transformed?
A function or <code>NULL</code> (default). Examples are <code>log</code> (to switch to link scale)
or <code>exp</code> (to switch from link scale to the original scale).
Applied after <code>which_pred</code>.</p>
</td></tr>
<tr><td><code id="ale_+3A_which_pred">which_pred</code></td>
<td>
<p>If the predictions are multivariate: which column to pick
(integer or column name). By default <code>NULL</code> (picks last column). Applied before
<code>trafo</code>.</p>
</td></tr>
<tr><td><code id="ale_+3A_w">w</code></td>
<td>
<p>Optional vector with case weights. Can also be a column name in <code>data</code>.
Having observations with non-positive weight is equivalent to excluding them.</p>
</td></tr>
<tr><td><code id="ale_+3A_breaks">breaks</code></td>
<td>
<p>An integer, vector, or &quot;Sturges&quot; (the default) used to determine
bin breaks of continuous features. Values outside the total bin range are placed
in the outmost bins. To allow varying values of <code>breaks</code> across features,
<code>breaks</code> can be a list of the same length as <code>v</code>, or a <em>named</em> list with breaks
for certain variables.</p>
</td></tr>
<tr><td><code id="ale_+3A_right">right</code></td>
<td>
<p>Should bins be right-closed? The default is <code>TRUE</code>.
Vectorized over <code>v</code>. Only relevant for continuous features.</p>
</td></tr>
<tr><td><code id="ale_+3A_discrete_m">discrete_m</code></td>
<td>
<p>Numeric features with up to this number of unique values are
treated as discrete and are therefore dropped from the calculations.</p>
</td></tr>
<tr><td><code id="ale_+3A_outlier_iqr">outlier_iqr</code></td>
<td>
<p>If <code>breaks</code> is an integer or &quot;Sturges&quot;, the breaks of a continuous
feature are calculated without taking into account feature values outside
quartiles +- <code>outlier_iqr</code> * IQR (where &lt;= 9997 values are used to calculate the
quartiles). To let the breaks cover the full data range, set <code>outlier_iqr</code> to
0 or <code>Inf</code>. Vectorized over <code>v</code>.</p>
</td></tr>
<tr><td><code id="ale_+3A_ale_n">ale_n</code></td>
<td>
<p>Size of the data used for calculating ALE.
The default is 50000. For larger <code>data</code> (and <code>w</code>), <code>ale_n</code> rows are randomly
sampled. Each variable specified by <code>v</code> uses the same sample.
Set to 0 to omit ALE calculations.</p>
</td></tr>
<tr><td><code id="ale_+3A_ale_bin_size">ale_bin_size</code></td>
<td>
<p>Maximal number of observations used per bin for ALE calculations.
If there are more observations in a bin, <code>ale_bin_size</code> indices are
randomly sampled. The default is 200. Applied after sampling regarding <code>ale_n</code>.</p>
</td></tr>
<tr><td><code id="ale_+3A_seed">seed</code></td>
<td>
<p>Optional integer random seed used for:
</p>

<ul>
<li> <p><em>ALE:</em> select background data if <code>n &gt; ale_n</code>, and for bins &gt; <code>ale_bin_size</code>.
</p>
</li>
<li> <p><em>Calculating breaks:</em> The bin range is determined without values outside
quartiles +- 2 IQR using a sample of &lt;= 9997 observations to calculate quartiles.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is a convenience wrapper around <code><a href="#topic+feature_effects">feature_effects()</a></code>, which calls
the barebone implementation <code><a href="#topic+.ale">.ale()</a></code> to calculate ALE.
</p>


<h3>Value</h3>

<p>A list (of class &quot;EffectData&quot;) with a data.frame per feature having columns:
</p>

<ul>
<li> <p><code>bin_mid</code>: Bin mid points. In the plots, the bars are centered around these.
</p>
</li>
<li> <p><code>bin_width</code>: Absolute width of the bin. In the plots, these equal the bar widths.
</p>
</li>
<li> <p><code>bin_mean</code>: For continuous features, the (possibly weighted) average feature
value within bin. For discrete features equivalent to <code>bin_mid</code>.
</p>
</li>
<li> <p><code>N</code>: The number of observations within bin.
</p>
</li>
<li> <p><code>weight</code>: The weight sum within bin. When <code>w = NULL</code>, equivalent to <code>N</code>.
</p>
</li>
<li><p> Different statistics, depending on the function call.
</p>
</li></ul>

<p>Use single bracket subsetting to select part of the output. Note that each
data.frame contains an attribute &quot;discrete&quot; with the information whether the
feature is discrete or continuous. This attribute might be lost when you manually
modify the data.frames.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>ale(default)</code>: Default method.
</p>
</li>
<li> <p><code>ale(ranger)</code>: Method for ranger models.
</p>
</li>
<li> <p><code>ale(explainer)</code>: Method for DALEX explainers
</p>
</li>
<li> <p><code>ale(H2OModel)</code>: Method for H2O models
</p>
</li></ul>


<h3>References</h3>

<p>Apley, Daniel W., and Jingyu Zhu. 2020. <em>Visualizing the Effects of Predictor Variables in Black Box Supervised Learning Models.</em>
Journal of the Royal Statistical Society Series B: Statistical Methodology,
82 (4): 1059–1086. doi:10.1111/rssb.12377.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+feature_effects">feature_effects()</a></code>, <code><a href="#topic+.ale">.ale()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
M &lt;- ale(fit, v = "Petal.Length", data = iris)
M |&gt; plot()

M2 &lt;- ale(fit, v = colnames(iris)[-1], data = iris, breaks = 5)
plot(M2, share_y = "all")  # Only continuous variables shown
</code></pre>

<hr>
<h2 id='average_observed'>Average Observed</h2><span id='topic+average_observed'></span>

<h3>Description</h3>

<p>Calculates average observed response over the values of one or multiple
variables specified by <code>X</code>. This describes the statistical association between the
response <code>y</code> and potential model features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>average_observed(
  X,
  y,
  w = NULL,
  x_name = "x",
  breaks = "Sturges",
  right = TRUE,
  discrete_m = 13L,
  outlier_iqr = 2,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="average_observed_+3A_x">X</code></td>
<td>
<p>A vector, matrix, or data.frame with features.</p>
</td></tr>
<tr><td><code id="average_observed_+3A_y">y</code></td>
<td>
<p>A numeric vector representing observed response values.</p>
</td></tr>
<tr><td><code id="average_observed_+3A_w">w</code></td>
<td>
<p>An optional numeric vector of weights. Having observations with
non-positive weight is equivalent to excluding them.</p>
</td></tr>
<tr><td><code id="average_observed_+3A_x_name">x_name</code></td>
<td>
<p>If <code>X</code> is a vector: what is the name of the variable? By default &quot;x&quot;.</p>
</td></tr>
<tr><td><code id="average_observed_+3A_breaks">breaks</code></td>
<td>
<p>An integer, vector, or &quot;Sturges&quot; (the default) used to determine
bin breaks of continuous features. Values outside the total bin range are placed
in the outmost bins. To allow varying values of <code>breaks</code> across features,
<code>breaks</code> can be a list of the same length as <code>v</code>, or a <em>named</em> list with breaks
for certain variables.</p>
</td></tr>
<tr><td><code id="average_observed_+3A_right">right</code></td>
<td>
<p>Should bins be right-closed? The default is <code>TRUE</code>.
Vectorized over <code>v</code>. Only relevant for continuous features.</p>
</td></tr>
<tr><td><code id="average_observed_+3A_discrete_m">discrete_m</code></td>
<td>
<p>Numeric features with up to this number of unique values should not
be binned but rather treated as discrete. The default is 13. Vectorized over <code>v</code>.</p>
</td></tr>
<tr><td><code id="average_observed_+3A_outlier_iqr">outlier_iqr</code></td>
<td>
<p>If <code>breaks</code> is an integer or &quot;Sturges&quot;, the breaks of a continuous
feature are calculated without taking into account feature values outside
quartiles +- <code>outlier_iqr</code> * IQR (where &lt;= 9997 values are used to calculate the
quartiles). To let the breaks cover the full data range, set <code>outlier_iqr</code> to
0 or <code>Inf</code>. Vectorized over <code>v</code>.</p>
</td></tr>
<tr><td><code id="average_observed_+3A_seed">seed</code></td>
<td>
<p>Optional integer random seed used for calculating breaks:
The bin range is determined without values outside quartiles +- 2 IQR
using a sample of &lt;= 9997 observations to calculate quartiles.</p>
</td></tr>
<tr><td><code id="average_observed_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is a convenience wrapper around <code><a href="#topic+feature_effects">feature_effects()</a></code>.
</p>


<h3>Value</h3>

<p>A list (of class &quot;EffectData&quot;) with a data.frame per feature having columns:
</p>

<ul>
<li> <p><code>bin_mid</code>: Bin mid points. In the plots, the bars are centered around these.
</p>
</li>
<li> <p><code>bin_width</code>: Absolute width of the bin. In the plots, these equal the bar widths.
</p>
</li>
<li> <p><code>bin_mean</code>: For continuous features, the (possibly weighted) average feature
value within bin. For discrete features equivalent to <code>bin_mid</code>.
</p>
</li>
<li> <p><code>N</code>: The number of observations within bin.
</p>
</li>
<li> <p><code>weight</code>: The weight sum within bin. When <code>w = NULL</code>, equivalent to <code>N</code>.
</p>
</li>
<li><p> Different statistics, depending on the function call.
</p>
</li></ul>

<p>Use single bracket subsetting to select part of the output. Note that each
data.frame contains an attribute &quot;discrete&quot; with the information whether the
feature is discrete or continuous. This attribute might be lost when you manually
modify the data.frames.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+feature_effects">feature_effects()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- average_observed(iris$Species, y = iris$Sepal.Length)
M
M |&gt; plot()

# Or multiple potential features X
average_observed(iris[2:5], y = iris[, 1], breaks = 5) |&gt;
  plot()
</code></pre>

<hr>
<h2 id='average_predicted'>Average Predictions</h2><span id='topic+average_predicted'></span>

<h3>Description</h3>

<p>Calculates average predictions over the values of one or multiple features specified
by <code>X</code>. Shows the combined effect of a feature and other (correlated) features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>average_predicted(
  X,
  pred,
  w = NULL,
  x_name = "x",
  breaks = "Sturges",
  right = TRUE,
  discrete_m = 13L,
  outlier_iqr = 2,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="average_predicted_+3A_x">X</code></td>
<td>
<p>A vector, matrix, or data.frame with features.</p>
</td></tr>
<tr><td><code id="average_predicted_+3A_pred">pred</code></td>
<td>
<p>A numeric vector of predictions.</p>
</td></tr>
<tr><td><code id="average_predicted_+3A_w">w</code></td>
<td>
<p>An optional numeric vector of weights. Having observations with
non-positive weight is equivalent to excluding them.</p>
</td></tr>
<tr><td><code id="average_predicted_+3A_x_name">x_name</code></td>
<td>
<p>If <code>X</code> is a vector: what is the name of the variable? By default &quot;x&quot;.</p>
</td></tr>
<tr><td><code id="average_predicted_+3A_breaks">breaks</code></td>
<td>
<p>An integer, vector, or &quot;Sturges&quot; (the default) used to determine
bin breaks of continuous features. Values outside the total bin range are placed
in the outmost bins. To allow varying values of <code>breaks</code> across features,
<code>breaks</code> can be a list of the same length as <code>v</code>, or a <em>named</em> list with breaks
for certain variables.</p>
</td></tr>
<tr><td><code id="average_predicted_+3A_right">right</code></td>
<td>
<p>Should bins be right-closed? The default is <code>TRUE</code>.
Vectorized over <code>v</code>. Only relevant for continuous features.</p>
</td></tr>
<tr><td><code id="average_predicted_+3A_discrete_m">discrete_m</code></td>
<td>
<p>Numeric features with up to this number of unique values should not
be binned but rather treated as discrete. The default is 13. Vectorized over <code>v</code>.</p>
</td></tr>
<tr><td><code id="average_predicted_+3A_outlier_iqr">outlier_iqr</code></td>
<td>
<p>If <code>breaks</code> is an integer or &quot;Sturges&quot;, the breaks of a continuous
feature are calculated without taking into account feature values outside
quartiles +- <code>outlier_iqr</code> * IQR (where &lt;= 9997 values are used to calculate the
quartiles). To let the breaks cover the full data range, set <code>outlier_iqr</code> to
0 or <code>Inf</code>. Vectorized over <code>v</code>.</p>
</td></tr>
<tr><td><code id="average_predicted_+3A_seed">seed</code></td>
<td>
<p>Optional integer random seed used for calculating breaks:
The bin range is determined without values outside quartiles +- 2 IQR
using a sample of &lt;= 9997 observations to calculate quartiles.</p>
</td></tr>
<tr><td><code id="average_predicted_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is a convenience wrapper around <code><a href="#topic+feature_effects">feature_effects()</a></code>.
</p>


<h3>Value</h3>

<p>A list (of class &quot;EffectData&quot;) with a data.frame per feature having columns:
</p>

<ul>
<li> <p><code>bin_mid</code>: Bin mid points. In the plots, the bars are centered around these.
</p>
</li>
<li> <p><code>bin_width</code>: Absolute width of the bin. In the plots, these equal the bar widths.
</p>
</li>
<li> <p><code>bin_mean</code>: For continuous features, the (possibly weighted) average feature
value within bin. For discrete features equivalent to <code>bin_mid</code>.
</p>
</li>
<li> <p><code>N</code>: The number of observations within bin.
</p>
</li>
<li> <p><code>weight</code>: The weight sum within bin. When <code>w = NULL</code>, equivalent to <code>N</code>.
</p>
</li>
<li><p> Different statistics, depending on the function call.
</p>
</li></ul>

<p>Use single bracket subsetting to select part of the output. Note that each
data.frame contains an attribute &quot;discrete&quot; with the information whether the
feature is discrete or continuous. This attribute might be lost when you manually
modify the data.frames.
</p>


<h3>References</h3>

<p>Apley, Daniel W., and Jingyu Zhu. 2016. <em>Visualizing the Effects of Predictor Variables in Black Box Supervised Learning Models.</em>
Journal of the Royal Statistical Society Series B: Statistical Methodology,
82 (4): 1059–1086. doi:10.1111/rssb.12377.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+feature_effects">feature_effects()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
M &lt;- average_predicted(iris[2:5], pred = predict(fit, iris), breaks = 5)
M
M |&gt; plot()
</code></pre>

<hr>
<h2 id='bias'>Bias / Average Residuals</h2><span id='topic+bias'></span>

<h3>Description</h3>

<p>Calculates average residuals (= bias) over the values of one or multiple
features specified by <code>X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bias(
  X,
  resid,
  w = NULL,
  x_name = "x",
  breaks = "Sturges",
  right = TRUE,
  discrete_m = 13L,
  outlier_iqr = 2,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bias_+3A_x">X</code></td>
<td>
<p>A vector, matrix, or data.frame with features.</p>
</td></tr>
<tr><td><code id="bias_+3A_resid">resid</code></td>
<td>
<p>A numeric vector of residuals, i.e., y - pred.</p>
</td></tr>
<tr><td><code id="bias_+3A_w">w</code></td>
<td>
<p>An optional numeric vector of weights. Having observations with
non-positive weight is equivalent to excluding them.</p>
</td></tr>
<tr><td><code id="bias_+3A_x_name">x_name</code></td>
<td>
<p>If <code>X</code> is a vector: what is the name of the variable? By default &quot;x&quot;.</p>
</td></tr>
<tr><td><code id="bias_+3A_breaks">breaks</code></td>
<td>
<p>An integer, vector, or &quot;Sturges&quot; (the default) used to determine
bin breaks of continuous features. Values outside the total bin range are placed
in the outmost bins. To allow varying values of <code>breaks</code> across features,
<code>breaks</code> can be a list of the same length as <code>v</code>, or a <em>named</em> list with breaks
for certain variables.</p>
</td></tr>
<tr><td><code id="bias_+3A_right">right</code></td>
<td>
<p>Should bins be right-closed? The default is <code>TRUE</code>.
Vectorized over <code>v</code>. Only relevant for continuous features.</p>
</td></tr>
<tr><td><code id="bias_+3A_discrete_m">discrete_m</code></td>
<td>
<p>Numeric features with up to this number of unique values should not
be binned but rather treated as discrete. The default is 13. Vectorized over <code>v</code>.</p>
</td></tr>
<tr><td><code id="bias_+3A_outlier_iqr">outlier_iqr</code></td>
<td>
<p>If <code>breaks</code> is an integer or &quot;Sturges&quot;, the breaks of a continuous
feature are calculated without taking into account feature values outside
quartiles +- <code>outlier_iqr</code> * IQR (where &lt;= 9997 values are used to calculate the
quartiles). To let the breaks cover the full data range, set <code>outlier_iqr</code> to
0 or <code>Inf</code>. Vectorized over <code>v</code>.</p>
</td></tr>
<tr><td><code id="bias_+3A_seed">seed</code></td>
<td>
<p>Optional integer random seed used for calculating breaks:
The bin range is determined without values outside quartiles +- 2 IQR
using a sample of &lt;= 9997 observations to calculate quartiles.</p>
</td></tr>
<tr><td><code id="bias_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is a convenience wrapper around <code><a href="#topic+feature_effects">feature_effects()</a></code>.
</p>


<h3>Value</h3>

<p>A list (of class &quot;EffectData&quot;) with a data.frame per feature having columns:
</p>

<ul>
<li> <p><code>bin_mid</code>: Bin mid points. In the plots, the bars are centered around these.
</p>
</li>
<li> <p><code>bin_width</code>: Absolute width of the bin. In the plots, these equal the bar widths.
</p>
</li>
<li> <p><code>bin_mean</code>: For continuous features, the (possibly weighted) average feature
value within bin. For discrete features equivalent to <code>bin_mid</code>.
</p>
</li>
<li> <p><code>N</code>: The number of observations within bin.
</p>
</li>
<li> <p><code>weight</code>: The weight sum within bin. When <code>w = NULL</code>, equivalent to <code>N</code>.
</p>
</li>
<li><p> Different statistics, depending on the function call.
</p>
</li></ul>

<p>Use single bracket subsetting to select part of the output. Note that each
data.frame contains an attribute &quot;discrete&quot; with the information whether the
feature is discrete or continuous. This attribute might be lost when you manually
modify the data.frames.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+feature_effects">feature_effects()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
M &lt;- bias(iris[2:5], resid = fit$residuals, breaks = 5)
M |&gt; update(sort_by = "resid_mean") |&gt; plot(share_y = "all")
</code></pre>

<hr>
<h2 id='effect_importance'>Variable Importance</h2><span id='topic+effect_importance'></span>

<h3>Description</h3>

<p>Extracts from an &quot;EffectData&quot; object a simple variable importance measure, namely
the (bin size weighted) variance of the partial dependence values, or of any other
calculated statistic (e.g., &quot;pred_mean&quot; or &quot;y_mean&quot;). It can be used via
<code>update.EffectData(, sort_by = "pd")</code> to sort the variables in decreasing importance.
Note that this measure captures only the main effect strength.
If the importance is calculated with respect to &quot;pd&quot;, it is closely related
to the suggestion of Greenwell et al. (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effect_importance(x, by = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="effect_importance_+3A_x">x</code></td>
<td>
<p>Object of class &quot;EffectData&quot;.</p>
</td></tr>
<tr><td><code id="effect_importance_+3A_by">by</code></td>
<td>
<p>The statistic used to calculate the variance for.
One of 'pd', 'pred_mean', 'y_mean', 'resid_mean', or 'ale' (if available).
The default is <code>NULL</code>, which picks the first available statistic from above list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of importance values of the same length as <code>x</code>.
</p>


<h3>References</h3>

<p>Greenwell, Brandon M., Bradley C. Boehmke, and Andrew J. McCarthy. 2018.
<em>A Simple and Effective Model-Based Variable Importance Measure.</em>
arXiv preprint. <a href="https://arxiv.org/abs/1805.04755">https://arxiv.org/abs/1805.04755</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+update.EffectData">update.EffectData()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
M &lt;- feature_effects(fit, v = colnames(iris)[-1], data = iris)
effect_importance(M)
</code></pre>

<hr>
<h2 id='fcut'>Fast cut()</h2><span id='topic+fcut'></span>

<h3>Description</h3>

<p>Bins a numeric vector <code>x</code> into bins specified by <code>breaks</code>.
Values outside the range of <code>breaks</code> will be placed in the lowest or highest bin.
Set <code>labels = FALSE</code> to return integer codes only, and <code>explicit_na = TRUE</code> for
maximal synergy with the &quot;collapse&quot; package.
Uses the logic of <code>spatstat.utils::fastFindInterval()</code> for equi-length bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fcut(x, breaks, labels = NULL, right = TRUE, explicit_na = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fcut_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="fcut_+3A_breaks">breaks</code></td>
<td>
<p>A monotonically increasing numeric vector of breaks.</p>
</td></tr>
<tr><td><code id="fcut_+3A_labels">labels</code></td>
<td>
<p>A character vector of length <code>length(breaks) - 1</code> with bin labels.
By default (<code>NULL</code>), the levels <code>c("1", "2", ...)</code> are used. Set to <code>FALSE</code>
to return raw integer codes.</p>
</td></tr>
<tr><td><code id="fcut_+3A_right">right</code></td>
<td>
<p>Right closed bins (<code>TRUE</code>, default) or not?</p>
</td></tr>
<tr><td><code id="fcut_+3A_explicit_na">explicit_na</code></td>
<td>
<p>If <code>TRUE</code>, missing values are encoded by the bin value
<code>length(breaks)</code>, having <code>NA</code> as corresponding factor level. The factor will get
the additional class &quot;na.included&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Binned version of <code>x</code>. Either a factor, or integer codes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(NA, 1:10)
fcut(x, breaks = c(3, 5, 7))
fcut(x, breaks = c(3, 5, 7), right = FALSE)
fcut(x, breaks = c(3, 5, 7), labels = FALSE)

</code></pre>

<hr>
<h2 id='feature_effects'>Feature Effects</h2><span id='topic+feature_effects'></span><span id='topic+feature_effects.default'></span><span id='topic+feature_effects.ranger'></span><span id='topic+feature_effects.explainer'></span><span id='topic+feature_effects.H2OModel'></span>

<h3>Description</h3>

<p>This is the main function of the package. By default, it calculates
the following statistics per feature X over values/bins:
</p>

<ul>
<li><p> &quot;y_mean&quot;: Average observed <code>y</code> values. Used to assess descriptive associations
between response and features.
</p>
</li>
<li><p> &quot;pred_mean&quot;: Average predictions. Corresponds to &quot;M Plots&quot; (from  &quot;marginal&quot;)
in Apley (2020). Shows the combined effect of X and other (correlated) features.
The difference to average observed y values shows model bias.
</p>
</li>
<li><p> &quot;resid_mean&quot;: Average residuals. Calculated when
both <code>y</code> and predictions are available. Useful to study model bias.
</p>
</li>
<li><p> &quot;pd&quot;: Partial dependence (Friedman, 2001): See <code><a href="#topic+partial_dependence">partial_dependence()</a></code>.
Evaluated at bin averages, not at bin midpoints.
</p>
</li>
<li><p> &quot;ale&quot;: Accumulated local effects (Apley, 2020): See <code><a href="#topic+ale">ale()</a></code>.
Only for continuous features.
</p>
</li></ul>

<p>Additionally, corresponding counts/weights are calculated, and
standard deviations of observed y and residuals.
</p>
<p>Numeric features with more than <code>discrete_m = 13</code> disjoint values are binned via
<code>breaks</code>. If <code>breaks</code> is a single integer or &quot;Sturges&quot;, the total bin range is
calculated without values outside +-2 IQR from the quartiles.
Values outside the bin range are placed in the outermost bins. Note that
at most 9997 observations are used to calculate quartiles and IQR.
</p>
<p>All averages and standard deviation are weighted by optional weights <code>w</code>.
</p>
<p>If you need only one specific statistic, you can use the simplified APIs of
</p>

<ul>
<li> <p><code><a href="#topic+average_observed">average_observed()</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+average_predicted">average_predicted()</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+bias">bias()</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+partial_dependence">partial_dependence()</a></code>, and
</p>
</li>
<li> <p><code><a href="#topic+ale">ale()</a></code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>feature_effects(object, ...)

## Default S3 method:
feature_effects(
  object,
  v,
  data,
  y = NULL,
  pred = NULL,
  pred_fun = stats::predict,
  trafo = NULL,
  which_pred = NULL,
  w = NULL,
  breaks = "Sturges",
  right = TRUE,
  discrete_m = 13L,
  outlier_iqr = 2,
  calc_pred = TRUE,
  pd_n = 500L,
  ale_n = 50000L,
  ale_bin_size = 200L,
  seed = NULL,
  ...
)

## S3 method for class 'ranger'
feature_effects(
  object,
  v,
  data,
  y = NULL,
  pred = NULL,
  pred_fun = NULL,
  trafo = NULL,
  which_pred = NULL,
  w = NULL,
  breaks = "Sturges",
  right = TRUE,
  discrete_m = 13L,
  outlier_iqr = 2,
  calc_pred = TRUE,
  pd_n = 500L,
  ale_n = 50000L,
  ale_bin_size = 200L,
  ...
)

## S3 method for class 'explainer'
feature_effects(
  object,
  v = colnames(data),
  data = object$data,
  y = object$y,
  pred = NULL,
  pred_fun = object$predict_function,
  trafo = NULL,
  which_pred = NULL,
  w = object$weights,
  breaks = "Sturges",
  right = TRUE,
  discrete_m = 13L,
  outlier_iqr = 2,
  calc_pred = TRUE,
  pd_n = 500L,
  ale_n = 50000L,
  ale_bin_size = 200L,
  ...
)

## S3 method for class 'H2OModel'
feature_effects(
  object,
  data,
  v = object@parameters$x,
  y = NULL,
  pred = NULL,
  pred_fun = NULL,
  trafo = NULL,
  which_pred = NULL,
  w = object@parameters$weights_column$column_name,
  breaks = "Sturges",
  right = TRUE,
  discrete_m = 13L,
  outlier_iqr = 2,
  calc_pred = TRUE,
  pd_n = 500L,
  ale_n = 50000L,
  ale_bin_size = 200L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feature_effects_+3A_object">object</code></td>
<td>
<p>Fitted model.</p>
</td></tr>
<tr><td><code id="feature_effects_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>pred_fun()</code>, e.g., <code>type = "response"</code> in
a <code>glm()</code> or (typically) <code>prob = TRUE</code> in classification models.</p>
</td></tr>
<tr><td><code id="feature_effects_+3A_v">v</code></td>
<td>
<p>Variable names to calculate statistics for.</p>
</td></tr>
<tr><td><code id="feature_effects_+3A_data">data</code></td>
<td>
<p>Matrix or data.frame.</p>
</td></tr>
<tr><td><code id="feature_effects_+3A_y">y</code></td>
<td>
<p>Numeric vector with observed values of the response.
Can also be a column name in <code>data</code>. Omitted if <code>NULL</code> (default).</p>
</td></tr>
<tr><td><code id="feature_effects_+3A_pred">pred</code></td>
<td>
<p>Pre-computed predictions (as from <code style="white-space: pre;">&#8288;predict()/pred_fun()). If &#8288;</code>NULL<code style="white-space: pre;">&#8288;, it is calculated as &#8288;</code>pred_fun(object, data, ...)'.</p>
</td></tr>
<tr><td><code id="feature_effects_+3A_pred_fun">pred_fun</code></td>
<td>
<p>Prediction function, by default <code>stats::predict</code>.
The function takes three arguments (names irrelevant): <code>object</code>, <code>data</code>, and <code>...</code>.</p>
</td></tr>
<tr><td><code id="feature_effects_+3A_trafo">trafo</code></td>
<td>
<p>How should predictions be transformed?
A function or <code>NULL</code> (default). Examples are <code>log</code> (to switch to link scale)
or <code>exp</code> (to switch from link scale to the original scale).
Applied after <code>which_pred</code>.</p>
</td></tr>
<tr><td><code id="feature_effects_+3A_which_pred">which_pred</code></td>
<td>
<p>If the predictions are multivariate: which column to pick
(integer or column name). By default <code>NULL</code> (picks last column). Applied before
<code>trafo</code>.</p>
</td></tr>
<tr><td><code id="feature_effects_+3A_w">w</code></td>
<td>
<p>Optional vector with case weights. Can also be a column name in <code>data</code>.
Having observations with non-positive weight is equivalent to excluding them.</p>
</td></tr>
<tr><td><code id="feature_effects_+3A_breaks">breaks</code></td>
<td>
<p>An integer, vector, or &quot;Sturges&quot; (the default) used to determine
bin breaks of continuous features. Values outside the total bin range are placed
in the outmost bins. To allow varying values of <code>breaks</code> across features,
<code>breaks</code> can be a list of the same length as <code>v</code>, or a <em>named</em> list with breaks
for certain variables.</p>
</td></tr>
<tr><td><code id="feature_effects_+3A_right">right</code></td>
<td>
<p>Should bins be right-closed? The default is <code>TRUE</code>.
Vectorized over <code>v</code>. Only relevant for continuous features.</p>
</td></tr>
<tr><td><code id="feature_effects_+3A_discrete_m">discrete_m</code></td>
<td>
<p>Numeric features with up to this number of unique values should not
be binned but rather treated as discrete. The default is 13. Vectorized over <code>v</code>.</p>
</td></tr>
<tr><td><code id="feature_effects_+3A_outlier_iqr">outlier_iqr</code></td>
<td>
<p>If <code>breaks</code> is an integer or &quot;Sturges&quot;, the breaks of a continuous
feature are calculated without taking into account feature values outside
quartiles +- <code>outlier_iqr</code> * IQR (where &lt;= 9997 values are used to calculate the
quartiles). To let the breaks cover the full data range, set <code>outlier_iqr</code> to
0 or <code>Inf</code>. Vectorized over <code>v</code>.</p>
</td></tr>
<tr><td><code id="feature_effects_+3A_calc_pred">calc_pred</code></td>
<td>
<p>Should predictions be calculated? Default is <code>TRUE</code>. Only relevant
if <code>pred = NULL</code>.</p>
</td></tr>
<tr><td><code id="feature_effects_+3A_pd_n">pd_n</code></td>
<td>
<p>Size of the data used for calculating partial dependence.
The default is 500. For larger <code>data</code> (and <code>w</code>), <code>pd_n</code> rows are randomly sampled.
Each variable specified by <code>v</code> uses the same sample.
Set to 0 to omit PD calculations.</p>
</td></tr>
<tr><td><code id="feature_effects_+3A_ale_n">ale_n</code></td>
<td>
<p>Size of the data used for calculating ALE.
The default is 50000. For larger <code>data</code> (and <code>w</code>), <code>ale_n</code> rows are randomly
sampled. Each variable specified by <code>v</code> uses the same sample.
Set to 0 to omit ALE calculations.</p>
</td></tr>
<tr><td><code id="feature_effects_+3A_ale_bin_size">ale_bin_size</code></td>
<td>
<p>Maximal number of observations used per bin for ALE calculations.
If there are more observations in a bin, <code>ale_bin_size</code> indices are
randomly sampled. The default is 200. Applied after sampling regarding <code>ale_n</code>.</p>
</td></tr>
<tr><td><code id="feature_effects_+3A_seed">seed</code></td>
<td>
<p>Optional integer random seed used for:
</p>

<ul>
<li> <p><em>Partial dependence:</em> select background data if <code>n &gt; pd_n</code>.
</p>
</li>
<li> <p><em>ALE:</em> select background data if <code>n &gt; ale_n</code>, and for bins &gt; <code>ale_bin_size</code>.
</p>
</li>
<li> <p><em>Calculating breaks:</em> The bin range is determined without values outside
quartiles +- 2 IQR using a sample of &lt;= 9997 observations to calculate quartiles.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list (of class &quot;EffectData&quot;) with a data.frame per feature having columns:
</p>

<ul>
<li> <p><code>bin_mid</code>: Bin mid points. In the plots, the bars are centered around these.
</p>
</li>
<li> <p><code>bin_width</code>: Absolute width of the bin. In the plots, these equal the bar widths.
</p>
</li>
<li> <p><code>bin_mean</code>: For continuous features, the (possibly weighted) average feature
value within bin. For discrete features equivalent to <code>bin_mid</code>.
</p>
</li>
<li> <p><code>N</code>: The number of observations within bin.
</p>
</li>
<li> <p><code>weight</code>: The weight sum within bin. When <code>w = NULL</code>, equivalent to <code>N</code>.
</p>
</li>
<li><p> Different statistics, depending on the function call.
</p>
</li></ul>

<p>Use single bracket subsetting to select part of the output. Note that each
data.frame contains an attribute &quot;discrete&quot; with the information whether the
feature is discrete or continuous. This attribute might be lost when you manually
modify the data.frames.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>feature_effects(default)</code>: Default method.
</p>
</li>
<li> <p><code>feature_effects(ranger)</code>: Method for ranger models.
</p>
</li>
<li> <p><code>feature_effects(explainer)</code>: Method for DALEX explainer.
</p>
</li>
<li> <p><code>feature_effects(H2OModel)</code>: Method for H2O models.
</p>
</li></ul>


<h3>References</h3>


<ol>
<li><p> Molnar, Christoph. 2019. <em>Interpretable Machine Learning: A Guide for Making Black Box Models Explainable</em>.
<a href="https://christophm.github.io/interpretable-ml-book/">https://christophm.github.io/interpretable-ml-book/</a>.
</p>
</li>
<li><p> Friedman, Jerome H. 2001, <em>Greedy Function Approximation: A Gradient Boosting Machine.</em>
Annals of Statistics 29 (5): 1189-1232. doi:10.1214/aos/1013203451.3.
</p>
</li>
<li><p> Apley, Daniel W., and Jingyu Zhu. 2016. <em>Visualizing the Effects of Predictor Variables in Black Box Supervised Learning Models.</em>
Journal of the Royal Statistical Society Series B: Statistical Methodology,
82 (4): 1059–1086. doi:10.1111/rssb.12377.
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+plot.EffectData">plot.EffectData()</a></code>, <code><a href="#topic+update.EffectData">update.EffectData()</a></code>, <code><a href="#topic+partial_dependence">partial_dependence()</a></code>,
<code><a href="#topic+ale">ale()</a></code>, <a href="#topic+average_observed">average_observed</a>, <code><a href="#topic+average_predicted">average_predicted()</a></code>, <code><a href="#topic+bias">bias()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
xvars &lt;- colnames(iris)[2:5]
M &lt;- feature_effects(fit, v = xvars, data = iris, y = "Sepal.Length", breaks = 5)
M
M |&gt;
  update(sort = "pd") |&gt;
  plot(share_y = "all")
</code></pre>

<hr>
<h2 id='partial_dependence'>Partial Dependence</h2><span id='topic+partial_dependence'></span><span id='topic+partial_dependence.default'></span><span id='topic+partial_dependence.ranger'></span><span id='topic+partial_dependence.explainer'></span><span id='topic+partial_dependence.H2OModel'></span>

<h3>Description</h3>

<p>Calculates PD for one or multiple features.
</p>
<p>PD was introduced by Friedman (2001) to study the (main) effects
of a ML model. PD of a model f and variable <code>X</code> at a certain value g
is derived by replacing the <code>X</code> values in a reference <code>data</code> by g,
and then calculating the average prediction of f over this modified data.
This is done for different g  to see how the average prediction of f changes in <code>X</code>,
keeping all other feature values constant (Ceteris Paribus).
</p>
<p>This function is a convenience wrapper around <code><a href="#topic+feature_effects">feature_effects()</a></code>, which calls
the barebone implementation <code><a href="#topic+.pd">.pd()</a></code> to calculate PD.
As grid points, it uses the arithmetic mean of <code>X</code> per bin (specified by <code>breaks</code>),
and eventually weighted by <code>w</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partial_dependence(object, ...)

## Default S3 method:
partial_dependence(
  object,
  v,
  data,
  pred_fun = stats::predict,
  trafo = NULL,
  which_pred = NULL,
  w = NULL,
  breaks = "Sturges",
  right = TRUE,
  discrete_m = 13L,
  outlier_iqr = 2,
  pd_n = 500L,
  seed = NULL,
  ...
)

## S3 method for class 'ranger'
partial_dependence(
  object,
  v,
  data,
  pred_fun = NULL,
  trafo = NULL,
  which_pred = NULL,
  w = NULL,
  breaks = "Sturges",
  right = TRUE,
  discrete_m = 13L,
  outlier_iqr = 2,
  pd_n = 500L,
  seed = NULL,
  ...
)

## S3 method for class 'explainer'
partial_dependence(
  object,
  v = colnames(data),
  data = object$data,
  pred_fun = object$predict_function,
  trafo = NULL,
  which_pred = NULL,
  w = object$weights,
  breaks = "Sturges",
  right = TRUE,
  discrete_m = 13L,
  outlier_iqr = 2,
  pd_n = 500L,
  seed = NULL,
  ...
)

## S3 method for class 'H2OModel'
partial_dependence(
  object,
  data,
  v = object@parameters$x,
  pred_fun = NULL,
  trafo = NULL,
  which_pred = NULL,
  w = object@parameters$weights_column$column_name,
  breaks = "Sturges",
  right = TRUE,
  discrete_m = 13L,
  outlier_iqr = 2,
  pd_n = 500L,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="partial_dependence_+3A_object">object</code></td>
<td>
<p>Fitted model.</p>
</td></tr>
<tr><td><code id="partial_dependence_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>pred_fun()</code>, e.g., <code>type = "response"</code> in
a <code>glm()</code> or (typically) <code>prob = TRUE</code> in classification models.</p>
</td></tr>
<tr><td><code id="partial_dependence_+3A_v">v</code></td>
<td>
<p>Variable names to calculate statistics for.</p>
</td></tr>
<tr><td><code id="partial_dependence_+3A_data">data</code></td>
<td>
<p>Matrix or data.frame.</p>
</td></tr>
<tr><td><code id="partial_dependence_+3A_pred_fun">pred_fun</code></td>
<td>
<p>Prediction function, by default <code>stats::predict</code>.
The function takes three arguments (names irrelevant): <code>object</code>, <code>data</code>, and <code>...</code>.</p>
</td></tr>
<tr><td><code id="partial_dependence_+3A_trafo">trafo</code></td>
<td>
<p>How should predictions be transformed?
A function or <code>NULL</code> (default). Examples are <code>log</code> (to switch to link scale)
or <code>exp</code> (to switch from link scale to the original scale).
Applied after <code>which_pred</code>.</p>
</td></tr>
<tr><td><code id="partial_dependence_+3A_which_pred">which_pred</code></td>
<td>
<p>If the predictions are multivariate: which column to pick
(integer or column name). By default <code>NULL</code> (picks last column). Applied before
<code>trafo</code>.</p>
</td></tr>
<tr><td><code id="partial_dependence_+3A_w">w</code></td>
<td>
<p>Optional vector with case weights. Can also be a column name in <code>data</code>.
Having observations with non-positive weight is equivalent to excluding them.</p>
</td></tr>
<tr><td><code id="partial_dependence_+3A_breaks">breaks</code></td>
<td>
<p>An integer, vector, or &quot;Sturges&quot; (the default) used to determine
bin breaks of continuous features. Values outside the total bin range are placed
in the outmost bins. To allow varying values of <code>breaks</code> across features,
<code>breaks</code> can be a list of the same length as <code>v</code>, or a <em>named</em> list with breaks
for certain variables.</p>
</td></tr>
<tr><td><code id="partial_dependence_+3A_right">right</code></td>
<td>
<p>Should bins be right-closed? The default is <code>TRUE</code>.
Vectorized over <code>v</code>. Only relevant for continuous features.</p>
</td></tr>
<tr><td><code id="partial_dependence_+3A_discrete_m">discrete_m</code></td>
<td>
<p>Numeric features with up to this number of unique values should not
be binned but rather treated as discrete. The default is 13. Vectorized over <code>v</code>.</p>
</td></tr>
<tr><td><code id="partial_dependence_+3A_outlier_iqr">outlier_iqr</code></td>
<td>
<p>If <code>breaks</code> is an integer or &quot;Sturges&quot;, the breaks of a continuous
feature are calculated without taking into account feature values outside
quartiles +- <code>outlier_iqr</code> * IQR (where &lt;= 9997 values are used to calculate the
quartiles). To let the breaks cover the full data range, set <code>outlier_iqr</code> to
0 or <code>Inf</code>. Vectorized over <code>v</code>.</p>
</td></tr>
<tr><td><code id="partial_dependence_+3A_pd_n">pd_n</code></td>
<td>
<p>Size of the data used for calculating partial dependence.
The default is 500. For larger <code>data</code> (and <code>w</code>), <code>pd_n</code> rows are randomly sampled.
Each variable specified by <code>v</code> uses the same sample.
Set to 0 to omit PD calculations.</p>
</td></tr>
<tr><td><code id="partial_dependence_+3A_seed">seed</code></td>
<td>
<p>Optional integer random seed used for:
</p>

<ul>
<li> <p><em>Partial dependence:</em> select background data if <code>n &gt; pd_n</code>.
</p>
</li>
<li> <p><em>Calculating breaks:</em> The bin range is determined without values outside
quartiles +- 2 IQR using a sample of &lt;= 9997 observations to calculate quartiles.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list (of class &quot;EffectData&quot;) with a data.frame per feature having columns:
</p>

<ul>
<li> <p><code>bin_mid</code>: Bin mid points. In the plots, the bars are centered around these.
</p>
</li>
<li> <p><code>bin_width</code>: Absolute width of the bin. In the plots, these equal the bar widths.
</p>
</li>
<li> <p><code>bin_mean</code>: For continuous features, the (possibly weighted) average feature
value within bin. For discrete features equivalent to <code>bin_mid</code>.
</p>
</li>
<li> <p><code>N</code>: The number of observations within bin.
</p>
</li>
<li> <p><code>weight</code>: The weight sum within bin. When <code>w = NULL</code>, equivalent to <code>N</code>.
</p>
</li>
<li><p> Different statistics, depending on the function call.
</p>
</li></ul>

<p>Use single bracket subsetting to select part of the output. Note that each
data.frame contains an attribute &quot;discrete&quot; with the information whether the
feature is discrete or continuous. This attribute might be lost when you manually
modify the data.frames.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>partial_dependence(default)</code>: Default method.
</p>
</li>
<li> <p><code>partial_dependence(ranger)</code>: Method for ranger models.
</p>
</li>
<li> <p><code>partial_dependence(explainer)</code>: Method for DALEX explainers.
</p>
</li>
<li> <p><code>partial_dependence(H2OModel)</code>: Method for H2O models.
</p>
</li></ul>


<h3>References</h3>

<p>Friedman, Jerome H. 2001, <em>Greedy Function Approximation: A Gradient Boosting Machine.</em>
Annals of Statistics 29 (5): 1189-1232. doi:10.1214/aos/1013203451.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+feature_effects">feature_effects()</a></code>, <code><a href="#topic+.pd">.pd()</a></code>, <code><a href="#topic+ale">ale()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
M &lt;- partial_dependence(fit, v = "Species", data = iris)
M |&gt; plot()

M2 &lt;- partial_dependence(fit, v = colnames(iris)[-1], data = iris)
plot(M2, share_y = "all")
</code></pre>

<hr>
<h2 id='plot.EffectData'>Plots &quot;EffectData&quot; Object</h2><span id='topic+plot.EffectData'></span>

<h3>Description</h3>

<p>Versatile plot function for an &quot;EffectData&quot; object. By default, all calculated
statistics (except &quot;resid_mean&quot;) are shown. To select certain statistics,
use the <code>stats</code> argument. Set <code>plotly = TRUE</code> for interactive plots. Note that
all statistics are plotted at bin means, except for ALE
(shown at right bin breaks).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'EffectData'
plot(
  x,
  stats = NULL,
  ncol = grDevices::n2mfrow(length(x))[2L],
  byrow = TRUE,
  share_y = c("no", "all", "rows", "cols"),
  ylim = NULL,
  discrete_lines = TRUE,
  continuous_points = FALSE,
  title = "",
  subplot_titles = TRUE,
  ylab = NULL,
  legend_labels = NULL,
  interval = c("no", "ci", "ciw", "sd"),
  ci_level = 0.95,
  colors = getOption("effectplots.colors"),
  fill = getOption("effectplots.fill"),
  alpha = 1,
  bar_height = 1,
  bar_width = 1,
  bar_measure = c("weight", "N"),
  wrap_x = 10,
  rotate_x = 0,
  plotly = getOption("effectplots.plotly"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.EffectData_+3A_x">x</code></td>
<td>
<p>An object of class &quot;EffectData&quot;.</p>
</td></tr>
<tr><td><code id="plot.EffectData_+3A_stats">stats</code></td>
<td>
<p>Vector of statistics to show. The default <code>NULL</code> equals either
<code>c("y_mean", "pred_mean", "pd", "ale")</code>, or <code>"resid_mean"</code>
(when <code>x</code> results from <code><a href="#topic+bias">bias()</a></code>). Only <em>available</em> statistics are shown.
Additionally, this argument controls the order used to plot the lines.</p>
</td></tr>
<tr><td><code id="plot.EffectData_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns of the plot layout, by default
<code>grDevices::n2mfrow(length(x))[2L]</code>. Only relevant for multiple plots.</p>
</td></tr>
<tr><td><code id="plot.EffectData_+3A_byrow">byrow</code></td>
<td>
<p>Should plots be placed by row? Default is <code>TRUE</code>.
Only for multiple plots.</p>
</td></tr>
<tr><td><code id="plot.EffectData_+3A_share_y">share_y</code></td>
<td>
<p>Should y axis be shared across subplots? The default is &quot;no&quot;.
Other choices are &quot;all&quot;, &quot;rows&quot;, and &quot;cols&quot;. Note that this currently does not
take into account error bars/ribbons.
Has no effect if <code>ylim</code> is passed. Only for multiple plots.</p>
</td></tr>
<tr><td><code id="plot.EffectData_+3A_ylim">ylim</code></td>
<td>
<p>A vector of length 2 with manual y axis limits, or a list thereof.</p>
</td></tr>
<tr><td><code id="plot.EffectData_+3A_discrete_lines">discrete_lines</code></td>
<td>
<p>Show lines for discrete features. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.EffectData_+3A_continuous_points">continuous_points</code></td>
<td>
<p>Show points for continuous features. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.EffectData_+3A_title">title</code></td>
<td>
<p>Overall plot title, by default <code>""</code> (no title).</p>
</td></tr>
<tr><td><code id="plot.EffectData_+3A_subplot_titles">subplot_titles</code></td>
<td>
<p>Should variable names be shown as subplot titles?
Default is <code>TRUE</code>. Only for multiple plots.</p>
</td></tr>
<tr><td><code id="plot.EffectData_+3A_ylab">ylab</code></td>
<td>
<p>Label of the y axis. The default <code>NULL</code> automatically derives
a reasonable name.</p>
</td></tr>
<tr><td><code id="plot.EffectData_+3A_legend_labels">legend_labels</code></td>
<td>
<p>Vector of legend labels in the same order as the
statistics plotted, or <code>NULL</code> (default).</p>
</td></tr>
<tr><td><code id="plot.EffectData_+3A_interval">interval</code></td>
<td>
<p>What intervals should be shown for observed y and residuals? One of
</p>

<ul>
<li><p> &quot;no&quot; (default),
</p>
</li>
<li><p> &quot;ci&quot;: Z confidence intervals using sqrt(N) as standard error of the mean,
</p>
</li>
<li><p> &quot;ciw&quot;: Like &quot;ci&quot;, but using sqrt(weight) as standard error of the mean, or
</p>
</li>
<li><p> &quot;sd&quot;: standard deviations.
Ribbons for continuous features, and error bars otherwise.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.EffectData_+3A_ci_level">ci_level</code></td>
<td>
<p>The nominal level of the Z confidence intervals (only when
<code>error</code> equals &quot;ci&quot; or &quot;ciw&quot;). The default is 0.95.</p>
</td></tr>
<tr><td><code id="plot.EffectData_+3A_colors">colors</code></td>
<td>
<p>Vector of line/point colors of sufficient length.
By default, a color blind friendly palette from &quot;ggthemes&quot;.
To change globally, set <code style="white-space: pre;">&#8288;options(effectplots.colors = new colors)&#8288;</code>.</p>
</td></tr>
<tr><td><code id="plot.EffectData_+3A_fill">fill</code></td>
<td>
<p>Fill color of bars. The default equals &quot;lightgrey&quot;.
To change globally, set <code style="white-space: pre;">&#8288;options(effectplots.fill = new color)&#8288;</code>.</p>
</td></tr>
<tr><td><code id="plot.EffectData_+3A_alpha">alpha</code></td>
<td>
<p>Alpha transparency of lines and points. Default is 1.</p>
</td></tr>
<tr><td><code id="plot.EffectData_+3A_bar_height">bar_height</code></td>
<td>
<p>Relative bar height (default 1). Set to 0 for no bars.</p>
</td></tr>
<tr><td><code id="plot.EffectData_+3A_bar_width">bar_width</code></td>
<td>
<p>Bar width multiplier (for discrete features). By default 1.</p>
</td></tr>
<tr><td><code id="plot.EffectData_+3A_bar_measure">bar_measure</code></td>
<td>
<p>What should bars represent? Either &quot;weight&quot; (default) or &quot;N&quot;.</p>
</td></tr>
<tr><td><code id="plot.EffectData_+3A_wrap_x">wrap_x</code></td>
<td>
<p>Should categorical x axis labels be wrapped after this length?
The default is 10. Set to 0 for no wrapping. Vectorized over <code>x</code>.
Only for &quot;ggplot2&quot; backend.</p>
</td></tr>
<tr><td><code id="plot.EffectData_+3A_rotate_x">rotate_x</code></td>
<td>
<p>Should categorical xaxis labels be rotated by this angle?
The default is 0 (no rotation). Vectorized over <code>x</code>. Only for &quot;ggplot2&quot; backend.</p>
</td></tr>
<tr><td><code id="plot.EffectData_+3A_plotly">plotly</code></td>
<td>
<p>Should 'plotly' be used? The default is <code>FALSE</code> ('ggplot2' with
'patchwork'). Use <code>options(effectplots.plotly = TRUE)</code> to change globally.</p>
</td></tr>
<tr><td><code id="plot.EffectData_+3A_...">...</code></td>
<td>
<p>Passed to <code>patchwork::plot_layout()</code> or <code>plotly::subplot()</code>. Typically
not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If a single plot, an object of class  &quot;ggplot&quot; or &quot;plotly&quot;.
Otherwise, an object of class &quot;patchwork&quot;, or a &quot;plotly&quot; subplot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+feature_effects">feature_effects()</a></code>, <code><a href="#topic+average_observed">average_observed()</a></code>, <code><a href="#topic+average_predicted">average_predicted()</a></code>,
<code><a href="#topic+partial_dependence">partial_dependence()</a></code>, <code><a href="#topic+bias">bias()</a></code>, <code><a href="#topic+ale">ale()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
xvars &lt;- colnames(iris)[-1]
M &lt;- feature_effects(fit, v = xvars, data = iris, y = "Sepal.Length", breaks = 5)
plot(M, share_y = "all")
plot(M, stats = c("pd", "ale"), legend_labels = c("PD", "ALE"))
plot(M, stats = "resid_mean", share_y = "all", interval = "ci")
</code></pre>

<hr>
<h2 id='update.EffectData'>Update &quot;EffectData&quot; Object</h2><span id='topic+update.EffectData'></span>

<h3>Description</h3>

<p>Updates an &quot;EffectData&quot; object by
</p>

<ul>
<li><p> turning discrete values to factor (especially useful with the next option),
</p>
</li>
<li><p> collapsing levels of categorical variables with many levels,
</p>
</li>
<li><p> dropping empty bins,
</p>
</li>
<li><p> dropping small bins,
</p>
</li>
<li><p> dropping bins with missing name, or
</p>
</li>
<li><p> sorting the variables by their importance, see <code><a href="#topic+effect_importance">effect_importance()</a></code>-
</p>
</li></ul>

<p>Except for <code>sort_by</code>, all arguments are vectorized, i.e., you can
pass a vector or list of the same length as <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'EffectData'
update(
  object,
  sort_by = c("no", "pd", "pred_mean", "y_mean", "resid_mean", "ale"),
  to_factor = FALSE,
  collapse_m = 15L,
  collapse_by = c("weight", "N"),
  drop_empty = FALSE,
  drop_below_n = 0,
  drop_below_weight = 0,
  na.rm = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.EffectData_+3A_object">object</code></td>
<td>
<p>Object of class &quot;EffectData&quot;.</p>
</td></tr>
<tr><td><code id="update.EffectData_+3A_sort_by">sort_by</code></td>
<td>
<p>By which statistic (&quot;pd&quot;, &quot;pred_mean&quot;, &quot;y_mean&quot;, &quot;resid_mean&quot;, &quot;ale&quot;)
should the results be sorted? The default is &quot;no&quot; (no sorting). Calculated
after all other update steps, e.g., after collapsing or dropping rare levels.</p>
</td></tr>
<tr><td><code id="update.EffectData_+3A_to_factor">to_factor</code></td>
<td>
<p>Should discrete features be treated as factors?
In combination with <code>collapse_m</code>, this can be used to collapse rare values of
discrete numeric features.</p>
</td></tr>
<tr><td><code id="update.EffectData_+3A_collapse_m">collapse_m</code></td>
<td>
<p>If a factor or character feature has more than <code>collapse_m</code> levels,
rare levels are collapsed into a new level &quot;other p&quot;. Standard deviations are
collapsed via root of the weighted average variances. The default is 15.
Set to <code>Inf</code> for no collapsing.</p>
</td></tr>
<tr><td><code id="update.EffectData_+3A_collapse_by">collapse_by</code></td>
<td>
<p>How to determine &quot;rare&quot; levels in <code>collapse_m</code>?
Either &quot;weight&quot; (default) or &quot;N&quot;. Only matters in situations with case weights <code>w</code>.</p>
</td></tr>
<tr><td><code id="update.EffectData_+3A_drop_empty">drop_empty</code></td>
<td>
<p>Drop empty bins. Equivalent to <code>drop_below_n = 1</code>.
The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="update.EffectData_+3A_drop_below_n">drop_below_n</code></td>
<td>
<p>Drop bins with N below this value. Applied after collapsing.
The default is 0.</p>
</td></tr>
<tr><td><code id="update.EffectData_+3A_drop_below_weight">drop_below_weight</code></td>
<td>
<p>Drop bins with weight below this value. Applied after
collapsing. The default is 0.</p>
</td></tr>
<tr><td><code id="update.EffectData_+3A_na.rm">na.rm</code></td>
<td>
<p>Should missing bin centers be dropped? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="update.EffectData_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified object of class &quot;EffectData&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+feature_effects">feature_effects()</a></code>, <code><a href="#topic+average_observed">average_observed()</a></code>, <code><a href="#topic+average_predicted">average_predicted()</a></code>,
<code><a href="#topic+partial_dependence">partial_dependence()</a></code>, <code><a href="#topic+ale">ale()</a></code>, <code><a href="#topic+bias">bias()</a></code>, <code><a href="#topic+effect_importance">effect_importance()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Length ~ ., data = iris)
xvars &lt;- colnames(iris)[-1]
feature_effects(fit, v = xvars, data = iris, y = "Sepal.Length", breaks = 5) |&gt;
  update(sort = "pd", collapse_m = 2) |&gt;
  plot()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
