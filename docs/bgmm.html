<!DOCTYPE html><html><head><title>Help for package bgmm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bgmm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bgmm-package'>
<p>Belief-Based Gaussian Mixture Modeling</p></a></li>
<li><a href='#CellCycle'><p>Data for clustering of 384 cell cycle genes into five clusters</p>
corresponding to cell cycle phases</a></li>
<li><a href='#chooseModels'>
<p>Selecting a subset of fitted models</p></a></li>
<li><a href='#crossval'>
<p>k-fold cross-validation for the specified model</p></a></li>
<li><a href='#DEprobs'>
<p>Signed probabilities of differential expression</p></a></li>
<li><a href='#genotypes'>
<p>Fluorescence signals corresponding to a given allele for 333 SNPs</p></a></li>
<li><a href='#getModelStructure'>
<p>Model structure</p></a></li>
<li><a href='#init.model.params'>
<p>Initiation of model parameters</p></a></li>
<li><a href='#miRNA'><p>miRNA transfection data for miR1 and miR124 target genes</p></a></li>
<li><a href='#mModel'>
<p>Fitting Gaussian Mixture Model</p></a></li>
<li><a href='#mModelList'>
<p>Fitting Gaussian mixture model or collection of models</p></a></li>
<li><a href='#plot.mModel'>
<p>Plotting a Graphical Visualization of a Gaussian Model or a List of Models</p></a></li>
<li><a href='#plot.mModelList'>
<p>Plotting a graphical visualization of a model or a list of models</p></a></li>
<li><a href='#plotGIC'>
<p>Plotting GIC scores</p></a></li>
<li><a href='#predict.mModel'>
<p>Predictions for fitted Gaussian component model</p></a></li>
<li><a href='#simulateData'>
<p>Dataset generation</p></a></li>
<li><a href='#Ste12'><p>Ste12 knockout data under pheromone treatment versus wild type;</p>
Examples of Ste12 targets; Binding p-values of Ste12 to those targets.</a></li>
<li><a href='#Supplementary functions'>
<p>Set of supplementary functions for bgmm package</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Gaussian Mixture Modeling Algorithms and the Belief-Based
Mixture Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.8.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-10-10</td>
</tr>
<tr>
<td>Author:</td>
<td>Przemyslaw Biecek \&amp; Ewa Szczurek</td>
</tr>
<tr>
<td>Description:</td>
<td>Two partially supervised mixture modeling methods: 
        soft-label and belief-based modeling are implemented.
        For completeness, we equipped the package also with the
        functionality of unsupervised, semi- and fully supervised
        mixture modeling.  The package can be applied also to selection
        of the best-fitting from a set of models with different
        component numbers or constraints on their structures.
        For detailed introduction see:
        Przemyslaw Biecek, Ewa Szczurek, Martin Vingron, Jerzy
        Tiuryn (2012), The R Package bgmm: Mixture Modeling with
        Uncertain Knowledge, Journal of Statistical Software 
        &lt;<a href="https://doi.org/10.18637%2Fjss.v047.i03">doi:10.18637/jss.v047.i03</a>&gt;.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Przemyslaw Biecek &lt;Przemyslaw.Biecek@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.0), mvtnorm, car, lattice, combinat</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://bgmm.molgen.mpg.de/">http://bgmm.molgen.mpg.de/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-10 16:22:29 UTC; pbiecek</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-10 17:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bgmm-package'>
Belief-Based Gaussian Mixture Modeling
</h2><span id='topic+bgmm-package'></span><span id='topic+bgmm'></span>

<h3>Description</h3>

<p>This package implements partially supervised mixture modeling methods: soft-label and belief-based modeling, the semi-supervised methods and for completeness also unsupervised and fully supervised methods for mixture modeling. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> bgmm</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.8</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2017-02-22</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>For short overview see the webpage http://bgmm.molgen.mpg.de/rapBGMM/.
</p>


<h3>Author(s)</h3>

<p>Przemyslaw Biecek \&amp; Ewa Szczurek
</p>
<p>Maintainer: Przemyslaw Biecek &lt;P.Biecek@mimuw.edu.pl&gt;
</p>


<h3>References</h3>

<p>Przemyslaw Biecek, Ewa Szczurek, Martin Vingron, Jerzy Tiuryn (2012), The R Package bgmm: Mixture Modeling with Uncertain Knowledge, Journal of Statistical Software.
</p>


<h3>See Also</h3>

<p>Package for unsupervised learning of Gaussian mixture model <code>link{mclust}</code>, 
methods for supervised learning <code>link{MASS::lda()}</code>, <code>link{MASS::qda()}</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Do not run
## It could take more than one minute
#demo(bgmm)
</code></pre>

<hr>
<h2 id='CellCycle'>Data for clustering of 384 cell cycle genes into five clusters
corresponding to cell cycle phases</h2><span id='topic+CellCycle'></span><span id='topic+CellCycleData'></span><span id='topic+CellCycleBeliefs'></span><span id='topic+CellCycleCenters'></span><span id='topic+CellCycleClass'></span>

<h3>Description</h3>

<p>Time course expression data for 384 cell cycle genes (Cho et al.,
1998). Literature examples of genes that should, and of genes that should not
peak at each time point are given. For each cycle phase, there is a
characteristic binary profile, stating when the phase occurs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(CellCycle)</code></pre>


<h3>Format</h3>

<p>CellCycleData list: 17x384
CellCycleBeliefs list:  17x (35x2)
CellCycleCenters matrix: 5x17
CellCycleClass vector: 384
</p>


<h3>Details</h3>

<p><code>CellCycleData</code>: A list, where each entry corresponds to one
time-point. A given time point entry contains a vector with expression
ratios for 384 cell cycle genes measured in this time point.
<code>CellCycleBeliefs</code>: A list, where each entry corresponds to one
time-point. A given time point entry gives the certainty
(belief/plausibility) for each out of 35 example genes. Out of the
genes, seven are known to peak in this time point and the remaining
28 are known to peak in other cycle phases. 
<code>CellCycleCenters</code>: A matrix, where the columns are the 17
time-points and the rows to the five cell phase clusters. A given
entry in the matrix is equal to 1 if the genes from the cluster
should peak in the time point, and 0 otherwise.
<code>CellCycleClass</code>:Gives the true cluster for each gene. Each
cluster corresponds to a cell cycle phase.
</p>


<h3>Author(s)</h3>

<p>Ewa Szczurek
</p>


<h3>References</h3>

<p>Cho, R., Campbell, M., Winzeler, E., Steinmetz, L., Conway, A.,
Wodicka, L., Wolfsberg, T., Gabrielian, A., Landsman, D., Lockhart,
D., and Davis, R. (1998). A genome-wide transcriptional analysis of
the mitotic cell cycle. Molecular Cell, 2(1), 65&ndash;73.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+miRNA">miRNA</a></code>,<code><a href="#topic+Ste12">Ste12</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(bgmm)
data(CellCycle)
print(CellCycleData)
print(CellCycleBeliefs)
print(CellCycleCenters)
print(CellCycleClass)
</code></pre>

<hr>
<h2 id='chooseModels'>
Selecting a subset of fitted models
</h2><span id='topic+chooseModels'></span><span id='topic+chooseOptimal'></span>

<h3>Description</h3>

<p>The function chooseModels extracts a sublist of models that match constraints on the number of components or on the model structure. The function chooseOptimal returns the model which is the best according the given model selection criteria. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chooseModels(models, kList = NULL, struct = NULL)

chooseOptimal(models, penalty=2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chooseModels_+3A_models">models</code></td>
<td>
<p>an object of the class <code><a href="#topic+mModelList">mModelList</a></code> which represents a list of fitted models.</p>
</td></tr>
<tr><td><code id="chooseModels_+3A_klist">kList</code></td>
<td>
<p>a vector which specifies the requested numbers of Gaussian components (constraints on the number of components). </p>
</td></tr>
<tr><td><code id="chooseModels_+3A_struct">struct</code></td>
<td>
<p>a vector which specifies four letter abbreviations of names of the requested model structures (constraints on the model structure). </p>
</td></tr>
<tr><td><code id="chooseModels_+3A_penalty">penalty</code></td>
<td>
<p>a penalty parameter in the GIC criteria. This parameter can be a single number or a string, either &quot;BIC&quot; or &quot;AIC&quot;.   </p>
</td></tr>
<tr><td><code id="chooseModels_+3A_...">...</code></td>
<td>
<p>other arguments that will be passed to the getGIC function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function chooseModels() extracts a sublist of models from the <code>models</code> argument.
The returned sublist is also an object of the class <code><a href="#topic+mModelList">mModelList</a></code> and is composed of models that simultaneously satisfy the restrictions of the number of Gaussian components defined by <code>kList</code> and restrictions of the model structure defined by <code>struct</code>.
If the argument <code>kList</code> is set to NULL then no restrictions of the number of components are applied, same with the argument <code>struct</code>.
</p>
<p>The function chooseOptimal() returns an object of the class <code><a href="#topic+mModel">mModel</a></code> which is the single model that has the best (smallest) GIC score.
</p>


<h3>Value</h3>

<p>An object of the class <code><a href="#topic+mModelList">mModelList</a></code> or <code><a href="#topic+mModel">mModel</a></code>.
</p>


<h3>Author(s)</h3>

<p>Przemyslaw Biecek
</p>


<h3>References</h3>

<p>Przemyslaw Biecek, Ewa Szczurek, Martin Vingron, Jerzy Tiuryn (2012), The R Package bgmm: Mixture Modeling with Uncertain Knowledge, Journal of Statistical Software.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> simulated = simulateData(d=2, k=3, n=100, m=50, cov="0", within="E", n.labels=2)
 
 models3 = beliefList(X=simulated$X, knowns=simulated$knowns, B=simulated$B,
               kList=2:4, mean="D", within="D")
 plotGIC(models3, penalty="BIC")

## Do not run
## It could take more than one minute
# simulated = simulateData(d=2, k=3, n=300, m=60, cov="0", within="E", n.labels=2)
# 
# models3 = beliefList(X=simulated$X, knowns=simulated$knowns, B=simulated$B,
#               kList=2:7, mean="D")
# plotGIC(models3, penalty="BIC")
#
# models4 = chooseModels(models3, kList=2:5, struct=c("DDDD","DDED","DDE0"))
# plot(models4)
# plotGIC(models4, penalty="BIC")
#
# model4 = chooseOptimal(models3, "BIC")
# plot(model4)
</code></pre>

<hr>
<h2 id='crossval'>
k-fold cross-validation for the specified model
</h2><span id='topic+crossval'></span>

<h3>Description</h3>

<p>The function <code>crossval()</code> performes k-fold cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossval(model = NULL, X = NULL, knowns = NULL, class = NULL, 
    k = length(unique(class)), B = NULL, P = NULL, model.structure = getModelStructure(), 
    ..., folds = 2, fun = belief) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossval_+3A_model">model</code></td>
<td>
<p>an object of the class <code>mModel</code>.
</p>
</td></tr>
<tr><td><code id="crossval_+3A_x">X</code></td>
<td>
<p>a data.frame with unknown realizations. If not supplied <code>X</code> is extracted from the <code>model</code> argument.
</p>
</td></tr>
<tr><td><code id="crossval_+3A_knowns">knowns</code></td>
<td>
<p>a data.frame with labeled realizations. If not supplied <code>knowns</code> is extracted from the <code>model</code> argument.
</p>
</td></tr>
<tr><td><code id="crossval_+3A_class">class</code>, <code id="crossval_+3A_b">B</code>, <code id="crossval_+3A_p">P</code></td>
<td>
<p>a vector of classes, beliefs and plausibilities. If not supplied they will be extracted from the <code>model</code> argument.
</p>
</td></tr>
<tr><td><code id="crossval_+3A_fun">fun</code></td>
<td>
<p>function that will be used for modeling, one of <code>supervised</code>, <code>unsupervised</code>, <code>belief</code>, <code>soft</code>, <code>semisupervised</code>.
</p>
</td></tr>
<tr><td><code id="crossval_+3A_model.structure">model.structure</code>, <code id="crossval_+3A_k">k</code>, <code id="crossval_+3A_...">...</code></td>
<td>
<p>arguments that will be passed to <code>fun</code> function,  
</p>
</td></tr>
<tr><td><code id="crossval_+3A_folds">folds</code></td>
<td>
<p>number of folds in k-fold cross validation. Cannot be grated that number of labeled samples.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>crossval()</code> divides the dataset into <code>k</code> equal subsets, the number of labeled cases versus number of unlabeled cases is keep as close to constant as possible (the subset are generated with stratification). 
Then each subset is used as test set against a train set build from all remaining sets. In total <code>k</code> new models are estimated thus this procedure is time consuming.
</p>
<p>For each model the error is calculated as average absolute differences between the distribution of estimated posteriors and distribution of beliefs/plausibilities for labeled cases.
</p>


<h3>Value</h3>

<p>The list with three vectors: errors calculated as mean absolute differences between estimated posteriors and initial beliefs for known cases, indexes of folds for both labeled and unlabeled cases. </p>


<h3>Author(s)</h3>

<p>Przemyslaw Biecek
</p>


<h3>References</h3>

<p>Przemyslaw Biecek, Ewa Szczurek, Martin Vingron, Jerzy Tiuryn (2012), The R Package bgmm: Mixture Modeling with Uncertain Knowledge, Journal of Statistical Software.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>                
 set.seed(1313)
 simulated = simulateData(d=2, k=3, n=300, m=60, cov="0", within="E", n.labels=2)
 amodel = belief(X=simulated$X, knowns=simulated$knowns, B=simulated$B, k=4)
 str(crossval(model=amodel, folds=6))

 amodel = supervised(knowns=rbind(simulated$X, simulated$knowns), class=simulated$Ytrue)
 str(crossval(model=amodel, folds=6, fun=supervised))
</code></pre>

<hr>
<h2 id='DEprobs'>
Signed probabilities of differential expression
</h2><span id='topic+DEprobs'></span>

<h3>Description</h3>

<p>The <code>DEprobs</code> function is an application of mixture modeling to differential gene expression analysis. The function takes as input a two- or three-component model of one-dimensional gene expression data. The data is assumed to represent log fold change expression values and be negative when the corresponding genes are down-regulated. The function calculates probabilities of differential expression for the data and gives them a sign according to the sign of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DEprobs(model, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DEprobs_+3A_model">model</code></td>
<td>
<p>an object of the class <code>mModel</code>,   </p>
</td></tr>
<tr><td><code id="DEprobs_+3A_verbose">verbose</code></td>
<td>
<p>indicates whether log messeges should be prited out.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the input <code>model</code>, the function identifies the component which corresponds to the differentially expressed genes as the one which looks differential according to the posterior probabilities. 
</p>
<p>For input models with two Gaussian components the differential component should be the one with a broader range (encompassing the other), or the one with higher deviation from 0 (we assume the data are centered around 0).
</p>
<p>For input models with three Gaussian components there are two differential components: one corresponding to the down-regulated genes, and one corresponding to the up-regulated genes. Those components are identified as the ones with the lowest and the highest mean, respectively.
</p>
<p>For <code>verbose=TRUE</code> the index of the differential component is printed out. 
</p>


<h3>Value</h3>

<p>An list with the following elements:
</p>
<table>
<tr><td><code>diff.p.X</code></td>
<td>
<p>a vector with the calculated signed differential expression probabilities for the unlabeled observations in the dataset <code>model$X</code>.</p>
</td></tr>
<tr><td><code>diff.p.knowns</code></td>
<td>
<p> a vector with the calculated signed differential expression probabilities for the unlabeled observations in the dataset <code>model$knowns</code>. For <code>model$knowns=NULL</code> <code>diff.p.knowns</code> is also NULL(null).</p>
</td></tr>
<tr><td><code>diff.c</code></td>
<td>
<p>the index (or two indexes, in case of a three-component input model) of the identified differential component.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Przemyslaw Biecek
</p>


<h3>References</h3>

<p>Przemyslaw Biecek, Ewa Szczurek, Martin Vingron, Jerzy Tiuryn (2012), The R Package bgmm: Mixture Modeling with Uncertain Knowledge, Journal of Statistical Software.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Ste12)
X = Ste12Data[ match(names(Ste12Data), rownames(Ste12Beliefs), nomatch = 0) ==0 ]
knowns = Ste12Data[rownames(Ste12Beliefs)]
model = belief(X=X, knowns=knowns, B=Ste12Beliefs)
dep=DEprobs(model)
str(dep)
</code></pre>

<hr>
<h2 id='genotypes'>
Fluorescence signals corresponding to a given allele for 333 SNPs
</h2><span id='topic+genotypes'></span>

<h3>Description</h3>

<p>The genotypes dataset describes 333 SNPs. Each SNP is characterized by the presence of one of its two possible alleles (or the presence of both of them). Therefore, the SNPs can be divided into three types. The first type corresponds to the SNPs with the first possible allele, the second type with the second allele, and the third with both alleles. The presence of the alleles is measured experimentally with fluorescence intensities. The dataset contains the intensities in the slots <code>X</code> and <code>knowns</code>. 
</p>
<p>15 SNPs in the dataset are given their correct type. These 'known' SNPs can be used as the input for the semi-, partially and fully superised modeling methods. They were selected by taking at random five SNPs per each type.  Their intensities are contained in the slot <code>knowns</code>. Their belief/plausibility values (given in the slot <code>B</code>) of the most probable type (the slot <code>labels</code>) are set to 0.95, and of the other two types are equal 0.025. 
The remaining 318 SNPs are kept unlabeled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(genotypes)</code></pre>


<h3>Format</h3>

<p>X       : a matrix with 318 rows (unlabeled SNPs) and 2 columns (alleles)
knowns  : a matrix with 15 rows (known SNPs) and 2 columns (alleles)
B       : a matrix with 15 rows (known SNPs) and 3 columns (types)
labels  : a vector of length 15 (types of the known SNPs)
</p>


<h3>Details</h3>

<p>The rows of both the slots <code>X</code> and <code>knowns</code>  correspond to the SNPs. For each SNP, the values in the columns represent the intensities of the fluorescence signal corresponding to the alleles of the SNP. The slot  <code>B</code> corresponds to the belief matrix while  <code>labels</code> contains the true types for the labeled SNPs.
</p>


<h3>References</h3>

<p>Takitoh, S.  Fujii, S.  Mase, Y.  Takasaki, J.  Yamazaki, T.  Ohnishi, Y.  Yanagisawa, M.  Nakamura, Y.  Kamatani, N., Accurate automated clustering of two-dimensional data for single-nucleotide polymorphism genotyping by a combination of clustering methods: evaluation by large-scale real data, Bioinformatics (2007) Vol. 23, 408&ndash;413.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(bgmm)
data(gnotypes)
</code></pre>

<hr>
<h2 id='getModelStructure'>
Model structure 
</h2><span id='topic+getModelStructure'></span>

<h3>Description</h3>

<p>This function creates an object which describes constraints over the model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getModelStructure(mean = "D", between = "D", within = "D", cov = "D")
</code></pre>


<h3>Arguments</h3>

<p>Each argument is a single character, by default  equal &quot;D&quot; (Different). If argument is set to &quot;E&quot; (or &quot;0&quot; for the argument <code>cov</code>) then the given parameter is constrained.  By default all arguments are set to &quot;D&quot;.
</p>
<table>
<tr><td><code id="getModelStructure_+3A_mean">mean</code></td>
<td>
<p><code>mean</code>=&quot;E&quot; forces equality of the means between the components,</p>
</td></tr>
<tr><td><code id="getModelStructure_+3A_between">between</code></td>
<td>
<p><code>between</code>=&quot;E&quot; forces equality of the covariance matrices among the components, </p>
</td></tr>
<tr><td><code id="getModelStructure_+3A_within">within</code></td>
<td>
<p><code>within</code>=&quot;E&quot; forces equality of variances within each covariance matrix i to some constant vi and equality of covariances to some constant wi</p>
</td></tr>
<tr><td><code id="getModelStructure_+3A_cov">cov</code></td>
<td>
<p><code>cov</code>=&quot;0&quot; forces equality of covariances within each covariance matrix i to &quot;0&quot;,</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of four elements specifying the constraints on 1) relations between the component means, 2) relations between the covariance matrices of the model components, 3) relations within each covariance matrix and 4) the covariances within each matrix. By default, the function returns an unconstrained structure.
</p>


<h3>Author(s)</h3>

<p>Ewa Szczurek
</p>


<h3>References</h3>

<p>Przemyslaw Biecek, Ewa Szczurek, Martin Vingron, Jerzy Tiuryn (2012), The R Package bgmm: Mixture Modeling with Uncertain Knowledge, Journal of Statistical Software.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> getModelStructure()
 getModelStructure(mean="E")
</code></pre>

<hr>
<h2 id='init.model.params'>
Initiation of model parameters 
</h2><span id='topic+init.model.params'></span><span id='topic+init.model.params.knowns'></span>

<h3>Description</h3>

<p>Methods for the initiation of model parameters for the EM algorithm. Two initiation procedures are implemented. The first procedure is available by setting the argument <code>method='knowns'</code>. It takes into account only labeled observations and is thus suitable for datasets with a high percentage of labeled cases. The second is available by setting <code>method='all'</code> and does not take the labeling into account. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init.model.params(X = NULL, knowns = NULL, class = NULL, 
    k = length(unique(class)), method = "all", B = P, P = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init.model.params_+3A_x">X</code></td>
<td>
<p>a <code>data.frame</code> with the unlabeled observations, its rows correspond to the observations while the columns correspond to variables/data dimensions.</p>
</td></tr>
<tr><td><code id="init.model.params_+3A_knowns">knowns</code></td>
<td>
<p>a <code>data.frame</code> with the labeled observations, rows correspond to the observations while the columns correspond to variables/data dimensions.</p>
</td></tr>
<tr><td><code id="init.model.params_+3A_b">B</code></td>
<td>
<p>a beliefs matrix with the distribution of beliefs for the labeled observations. If not specified and the argument <code>P</code> is given, the beliefs matrix is set to the value of <code>P</code>.</p>
</td></tr>   
<tr><td><code id="init.model.params_+3A_p">P</code></td>
<td>
<p>a matrix of plausibilities, specified only for the labeled observations. The function assumes that the remaining observations are unlabeled and gives them
uniformly distributed plausibilities by default. If not specified and the argument <code>B</code> is given, the plausibilities matrix is set to the value of <code>B</code>.</p>
</td></tr>
<tr><td><code id="init.model.params_+3A_class">class</code></td>
<td>
<p><code>class</code> is a vector of labels for the known observations. If not specified, it is derived from eithter the argument <code>B</code> or <code>P</code> with the use of the MAP rule.</p>
</td></tr>
<tr><td><code id="init.model.params_+3A_k">k</code></td>
<td>
<p>the desired number of model components. </p>
</td></tr>
<tr><td><code id="init.model.params_+3A_method">method</code></td>
<td>
<p>a method for parameter initialization, one of following <code>c("knowns","all")</code>, see the section Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>method='knowns'</code>, the initialization is based only on the labeled observations. i.e. those observations which have certain or probable components assigned. The initial model parameters
for each component are estimated in one step from the observations that are assigned to this component (as in fully supervised learning).
</p>
<p>If <code>method='all'</code> (default), the initialization is based on all observations. In this case, to obtain the initial set of model components, we start by clustering the data using the k-means algorithm (repeated 10 times to get stable results). The only exception is for one dimensional data. In such a case the clusters are identified by dividing the data into <code>k</code> equal subsets of observations, where the subsets are separated by empirical quantiles c(1/2k, 3/2k, 5/2k, ..., (2k-1)/2k). After this initial clustering each cluster is linked to one model component and initial values for the model parameters are derived from the clustered observations. 
</p>
<p>For the partially and semi-supervised methods, correspondence of labels from the initial clustering algorithm and labels for the observations in the <code>knowns</code> dataset rises a  technical problem. The cluster corresponding to component <code>y</code> should be as close as possible to the set of labeled observations with label <code>y</code>. 
</p>
<p>Note that for the unsupervised modeling this problem is irrelevant and any cluster may be used to initialize any component.
</p>
<p>To mach the cluster labels with the labels of model components a greedy heuristic is used. The heuristic calculates weighted distances between all possible pairs of cluster centers and sets of observations grouped by their labels. 
In each step, the pair with a minimal distance is chosen (the pair: a group of observations with a common label and a cluster, for which the center of the group is the closest to the center of the cluster). For the chosen pair, the cluster is labeled with the same label as the group of observations. 
Then, this pair is removed and the heuristic repeats for the reduced set of pairs. 
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>pi</code></td>
<td>
<p> a vector of length <code>k</code> with the initial values for the mixing proportions.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p> a matrix with the means' vectors with the initial values for <code>k</code> components.</p>
</td></tr>
<tr><td><code>cvar</code></td>
<td>
<p> a three-dimensional matrix with the covariance matrices with the initial values for <code>k</code> components.</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Przemyslaw Biecek
</p>


<h3>References</h3>

<p>Przemyslaw Biecek, Ewa Szczurek, Martin Vingron, Jerzy Tiuryn (2012), The R Package bgmm: Mixture Modeling with Uncertain Knowledge, Journal of Statistical Software.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(genotypes)
 initial.params = init.model.params(X=genotypes$X, knowns=genotypes$knowns,
									 class = genotypes$labels)
 str(initial.params)
</code></pre>

<hr>
<h2 id='miRNA'>miRNA transfection data for miR1 and miR124 target genes</h2><span id='topic+miRNA'></span><span id='topic+miR1Data'></span><span id='topic+miR124Data'></span><span id='topic+miRNABeliefs'></span><span id='topic+miRNAClass'></span>

<h3>Description</h3>

<p>miRNA transfection data (Lim et al., 2005) and knowledge from computational
miRNA target predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(miRNA)</code></pre>


<h3>Format</h3>

<p>miR1Data vector: 117, 
miR124Data vector: 117, 
miRNABeliefs matrix of example certainty:  26 x 2, 
miRNAClass vector:  117
</p>


<h3>Details</h3>

<p><code>miR1Data</code> Log2 expression ratios of miR1 transfection versus
wild type, for 117 genes.
<code>miR124Data</code> Log2 expression ratios of miR124 transfection versus
wild type, for 117 genes.
<code>miRNABeliefs</code> Gives the certainty (belief/plausibility) for
each out of 26 example miRNA targets to belong to their cluster.
<code>miRNAClass</code> Gives the true cluster for each gene. Cluster 1
corresponds to the experimentally verified targets of miR1. Cluster 2
corresponds to the targets of miR124.
</p>


<h3>Author(s)</h3>

<p>Ewa Szczurek
</p>


<h3>References</h3>

<p>Lim, L. P., Lau, N. C., Garrett-Engele, P., Grimson, A., Schelter, J. M., Castle, J., Bartel,
D. P., Linsley, P. S., and Johnson, J. M. (2005). Microarray analysis shows that some
microRNAs downregulate large numbers of target mRNAs. Nature, 433(7027).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ste12">Ste12</a></code>,<code><a href="#topic+CellCycle">CellCycle</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(bgmm)
data(miRNA)
print(miR1Data)
print(miR124Data)
print(miRNABeliefs)
print(miRNAClass)
</code></pre>

<hr>
<h2 id='mModel'>
Fitting Gaussian Mixture Model 
</h2><span id='topic+mModel'></span><span id='topic+belief'></span><span id='topic+soft'></span><span id='topic+semisupervised'></span><span id='topic+supervised'></span><span id='topic+unsupervised'></span>

<h3>Description</h3>

<p>These functions fit different variants of Gaussian mixture models. These variants 
differ in the fraction of knowledge utilized into the the fitting procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>belief(X, knowns, B = NULL, k = ifelse(!is.null(B), ncol(B), 
    ifelse(!is.null(P), ncol(P), length(unique(class)))), P = NULL, 
    class = map(B), init.params = init.model.params(X, knowns, 
        B = B, P = P, class = class, k = k), model.structure = getModelStructure(), 
    stop.likelihood.change = 10^-5, stop.max.nsteps = 100, trace = FALSE, 
    b.min = 0.025, 
    all.possible.permutations=FALSE, pca.dim.reduction = NA)
    
soft(X, knowns, P = NULL, k = ifelse(!is.null(P), ncol(P), 
    ifelse(!is.null(B), ncol(B), length(unique(class)))), B = NULL, 
    class = NULL, init.params = init.model.params(X, knowns, 
        class = class, B = P, k = k), 
    model.structure = getModelStructure(), stop.likelihood.change = 10^-5, 
    stop.max.nsteps = 100, trace = FALSE, b.min = 0.025, 
	all.possible.permutations=FALSE, pca.dim.reduction = NA, ...)    
    
semisupervised(X, knowns, class = NULL, k = ifelse(!is.null(class), 
    length(unique(class)), ifelse(!is.null(B), ncol(B), ncol(P))), 
    B = NULL, P = NULL, ..., init.params = NULL,
	all.possible.permutations=FALSE, pca.dim.reduction = NA)    
    
supervised(knowns, class = NULL, k = length(unique(class)), B = NULL, P = NULL, 
    model.structure = getModelStructure(), ...)

unsupervised(X, k, init.params=init.model.params(X, knowns=NULL, k=k), 
      model.structure=getModelStructure(), stop.likelihood.change=10^-5, 
      stop.max.nsteps=100, trace=FALSE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mModel_+3A_x">X</code></td>
<td>
<p>a data.frame with the unlabeled observations. The rows correspond to the observations while the columns to variables/dimensions of the data. </p>
</td></tr>
<tr><td><code id="mModel_+3A_knowns">knowns</code></td>
<td>
<p>a data.frame with the labeled observations. The rows correspond to the observations while the columns to variables/dimensions of the data. </p>
</td></tr>
<tr><td><code id="mModel_+3A_b">B</code></td>
<td>
<p>a beliefs matrix which specifies the distribution of beliefs for the labeled observations. The number of rows in B should equal the number of rows in the  data.frame <code>knowns</code>. It is assumed that both the observations in <code>B</code> and in <code>knowns</code> are given in the same order. Columns correspond to the model components. If matrix B is provided, the number of columns has to be less or equal <code>k</code>. Internally, the matrix <code>B</code> is completed to <code>k</code> columns.  </p>
</td></tr>
<tr><td><code id="mModel_+3A_p">P</code></td>
<td>
<p>a  matrix of plausibilities, i.e., weights of the prior probabilities for the labeled observations. If matrix <code>P</code> is provided, the number of columns has to be less or equal <code>k</code>. The came conditions as for <code>B</code> apply. </p>
</td></tr>
<tr><td><code id="mModel_+3A_class">class</code></td>
<td>
<p>a vector of classes/labels for the labeled observations. The number of its unique values has to be less or equal <code>k</code>. </p>
</td></tr>
<tr><td><code id="mModel_+3A_k">k</code></td>
<td>
<p>a number of components, by default equal to the number of columns of <code>B</code>. </p>
</td></tr>
<tr><td><code id="mModel_+3A_init.params">init.params</code></td>
<td>
<p>initial values for the estimates of the model parameters (means, variances and mixing proportions), by default derived with the
use of the <code><a href="#topic+init.model.params">init.model.params</a></code> function. </p>
</td></tr>
<tr><td><code id="mModel_+3A_stop.likelihood.change">stop.likelihood.change</code>, <code id="mModel_+3A_stop.max.nsteps">stop.max.nsteps</code></td>
<td>
<p> the parameters for the EM algorithms defining the stop criteria, i.e., the minimum required improvement of loglikelihood and the maximum number of steps. </p>
</td></tr>
<tr><td><code id="mModel_+3A_trace">trace</code></td>
<td>
<p>if <code>trace=TRUE</code> the loglikelihoods for every step of EM algorithm are printed out.   </p>
</td></tr>
<tr><td><code id="mModel_+3A_model.structure">model.structure</code></td>
<td>
<p>an object returned by the <code><a href="#topic+getModelStructure">getModelStructure</a></code> function, which specifies constraints for the parameters of the model to be fitted. </p>
</td></tr>
<tr><td><code id="mModel_+3A_b.min">b.min</code></td>
<td>
<p>this argument is passed to the <code><a href="#topic+init.model.params">init.model.params</a></code> function.  </p>
</td></tr>
<tr><td><code id="mModel_+3A_...">...</code></td>
<td>
<p>these arguments will be passed tothe <code><a href="#topic+init.model.params">init.model.params</a></code> function.   </p>
</td></tr>
<tr><td><code id="mModel_+3A_all.possible.permutations">all.possible.permutations</code></td>
<td>
<p>If equal <code>TRUE</code>, all possible initial parameters' permutations of components are considered. Since there is kList! permutations,  model fitting is repeated kList! times. As a result, only the model with the highest likelihood is returned.</p>
</td></tr>
<tr><td><code id="mModel_+3A_pca.dim.reduction">pca.dim.reduction</code></td>
<td>
<p>Since the fitting for high dimensional space is numerically a bad idea an attempt to PCA will be performed if <code>pca.dim.reduction !- FALSE</code>. If equal <code>NA</code> then the target dimension is data driven, if it's a number then this will be the target dimension.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the <code>belief()</code> function, if the argument <code>B</code> is not provided, it is
by default initialized from the argument <code>P</code>. If the argument <code>P</code> is not
provided, <code>B</code> is derived from the <code>class</code> argument with the use of the function <code>get.simple.beliefs()</code> 
which assigns <code>1-(k-1)*b.min</code> to the component given by <code>class</code>  and 
<code>b.min</code> to all remaining components.
</p>
<p>In the <code>soft()</code> function, if the argument <code>P</code> is not provided, it is
by default initialized from the argument <code>B</code>. If the argument <code>B</code> is not
provided, <code>P</code> is derived from the <code>class</code> argument as in the <code>belief()</code>
function.
</p>
<p>In the <code>supervised()</code> function,  if the argument <code>class</code> is not provided,
it is by default initialized from argument <code>B</code> or <code>P</code>, taking the label of each
observation as its most believed or plausible component (by the MAP rule).
</p>
<p>The number of columns in the beliefs matrix <code>B</code> or in the matrix of
plausibilities <code>P</code> may be smaller than the number of model components
defined by the argument <code>k</code>.  Such situation corresponds to the scenario
when the user does not know any examples for some   component. In other words, this component is not used as a label for
any observation, and thus can be omitted from the beliefs matrix. An
equivalent would be to include a column for this component and fill it
with beliefs/plausibilities equal 0.
</p>
<p>Slots in the returned object are listed in section Value.
The returned object differs slighty with respect to the used function. Namely, the <code>belief()</code> function returns an object with the slot <code>B</code>. The function <code>soft()</code> returns an object with a slot <code>P</code>, while the functions <code>supervised()</code> and <code>semisupervised()</code> return objects with a slot <code>class</code> instead. 
</p>
<p>The object returned by the function <code>supervised()</code> does not have the slot <code>X</code>.
</p>


<h3>Value</h3>

<p>An object of the class <code>mModel</code>, with the following slots:
</p>
<table>
<tr><td><code>pi</code></td>
<td>
<p> a vector with the fitted mixing proportions</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p> a matrix with the means' vectors, fitted for all components</p>
</td></tr>
<tr><td><code>cvar</code></td>
<td>
<p> a three-dimensional matrix with the covariance matrices, fitted for all components</p>
</td></tr> 
<tr><td><code>X</code></td>
<td>
<p> the unlabeled observations</p>
</td></tr>
<tr><td><code>knowns</code></td>
<td>
<p>the labeled observations</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>the beliefs matrix</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p> the number of all observations</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p> the number of the unlabeled observations</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>the number of fitted model components</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>the data dimension</p>
</td></tr>
<tr><td><code>likelihood</code></td>
<td>
<p>the log-likelihood of the fitted model</p>
</td></tr>
<tr><td><code>n.steps</code></td>
<td>
<p>the number of steps performed by the EM algorithm</p>
</td></tr>
<tr><td><code>model.structure</code></td>
<td>
<p>the set of constraints kept during the fitting process.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Przemyslaw Biecek
</p>


<h3>References</h3>

<p>Przemyslaw Biecek, Ewa Szczurek, Martin Vingron, Jerzy Tiuryn (2012), The R Package bgmm: Mixture Modeling with Uncertain Knowledge, Journal of Statistical Software.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(genotypes)

modelSupervised = supervised(knowns=genotypes$knowns, 
            class=genotypes$labels)
plot(modelSupervised)

modelSemiSupervised = semisupervised(X=genotypes$X, 
            knowns=genotypes$knowns, class = genotypes$labels)
plot(modelSemiSupervised)

modelBelief = belief(X=genotypes$X, 
            knowns=genotypes$knowns, B=genotypes$B)
plot(modelBelief)

modelSoft = soft(X=genotypes$X, 
            knowns=genotypes$knowns, P=genotypes$B)
plot(modelSoft)

modelUnSupervised = unsupervised(X=genotypes$X, k=3)
plot(modelUnSupervised)
</code></pre>

<hr>
<h2 id='mModelList'>
Fitting Gaussian mixture model or collection of models
</h2><span id='topic+mModelList'></span><span id='topic+beliefList'></span><span id='topic+softList'></span><span id='topic+semisupervisedList'></span><span id='topic+supervisedList'></span><span id='topic+unsupervisedList'></span>

<h3>Description</h3>

<p>These functions fit collection of models of one particular variant/class. 
Models to be fitted may differ in the requested number of Gaussian components or in the requested model structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mModelList(X, knowns, B = NULL, P = NULL, class = NULL, kList = ncol(B), 
    init.params = NULL, stop.likelihood.change = 10^-5, stop.max.nsteps = 100, 
    trace = FALSE, mean = c("D", "E"), between = c("D", "E"), within = c("D", 
        "E"), cov = c("D", "0"), funct = belief, all.possible.permutations = FALSE, ...)
        
beliefList(..., funct=belief)

softList(..., funct=soft)

semisupervisedList(..., funct=semisupervised)

unsupervisedList(X, kList = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mModelList_+3A_x">X</code></td>
<td>
<p>a data.frame with the unlabeled observations. The rows correspond to the observations while the columns to variables/dimensions of the data. </p>
</td></tr>
<tr><td><code id="mModelList_+3A_knowns">knowns</code></td>
<td>
<p>a data.frame with the labeled observations. The rows correspond to the observations while the columns to variables/dimensions of the data.  </p>
</td></tr>
<tr><td><code id="mModelList_+3A_b">B</code></td>
<td>
<p>a beliefs matrix which specifies the distribution of beliefs for the labeled observations. The number of rows in B should equal the number of rows in the  data.frame <code>knowns</code>. It is assumed that both the observations in <code>B</code> and in <code>knowns</code> are given in the same order. Columns correspond to the model components. If matrix B is provided, the number of columns has to be less or equal <code>k</code>. Internally, the matrix <code>B</code> is completed to <code>k</code> columns. </p>
</td></tr>
<tr><td><code id="mModelList_+3A_p">P</code></td>
<td>
<p>a  matrix of plausibilities, i.e., weights of the prior probabilities for the labeled observations. If matrix <code>P</code> is provided, the number of columns has to be less or equal <code>k</code>. The came conditions as for <code>B</code> apply.</p>
</td></tr>
<tr><td><code id="mModelList_+3A_class">class</code></td>
<td>
<p>a vector of classes/labels for the labeled observations. The number of its unique values has to be less or equal <code>min(kList)</code>. </p>
</td></tr>
<tr><td><code id="mModelList_+3A_klist">kList</code></td>
<td>
<p>a vector or a list with numbers of Gaussian components to fit. By default it is one number equal to the number of columns of <code>B</code>. </p>
</td></tr>
<tr><td><code id="mModelList_+3A_init.params">init.params</code></td>
<td>
<p>initial values for the estimates of the model parameters (means, variances and mixing proportions). The initial parameters are internally passed to the <code>funct</code> function. </p>
</td></tr>
<tr><td><code id="mModelList_+3A_stop.likelihood.change">stop.likelihood.change</code>, <code id="mModelList_+3A_stop.max.nsteps">stop.max.nsteps</code>, <code id="mModelList_+3A_trace">trace</code></td>
<td>
<p>the parameters for the EM  algorithm. Internally, these parameters are passed to the <code>funct</code> function.  </p>
</td></tr>
<tr><td><code id="mModelList_+3A_mean">mean</code>, <code id="mModelList_+3A_between">between</code>, <code id="mModelList_+3A_within">within</code>, <code id="mModelList_+3A_cov">cov</code></td>
<td>
<p>four vectors which define the model structures for models to be fitted. For example, if <code>mean="E"</code>, only models with constrained means are considered (means of Gaussian components are forced to be equal). On the other hand if <code>mean=c("E", "D")</code>, both models with constrained means and models without constraint on the means are fitted. </p>
</td></tr>
<tr><td><code id="mModelList_+3A_funct">funct</code></td>
<td>
<p>a function which fits a variant of Gaussian mixture model, one of the: <code>belief</code>, <code>soft</code>, <code>semisupervised</code> or <code>unsupervised</code> functions.  </p>
</td></tr>
<tr><td><code id="mModelList_+3A_...">...</code></td>
<td>
<p>arguments that are passed to function <code>funct</code>.  </p>
</td></tr>
<tr><td><code id="mModelList_+3A_all.possible.permutations">all.possible.permutations</code></td>
<td>
<p>If equal <code>TRUE</code>, all possible initial parameters' permutations of components are considered. Since there is kList! permutations,  model fitting is repeated kList! times. As a result only the model with the highest likelihood is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arguments <code>kList</code>, as well as <code>mean</code>, <code>between</code>, <code>within</code>, and <code>cov</code> define the list of models to be fitted. All combinations of specified model sizes and model structures are considered. List of fitted models is returned as a result. 
</p>
<p>The argument  <code>funct</code> defines which variant of Gaussian mixture models should be used for model fitting. One can use the wrappers <code>beliefList()</code>, <code>softList()</code>, <code>semisupervisedList()</code>, <code>unsupervisedList()</code> which call the <code>mModelList()</code> function and have a prespecified argument <code>funct</code>.
</p>


<h3>Value</h3>

<p>An object of the class mModelList, with the following slots:
</p>
<table>
<tr><td><code>models</code></td>
<td>
<p> a list of models, each of the class <code><a href="#topic+mModel">mModel</a></code></p>
</td></tr>
<tr><td><code>loglikelihoods</code></td>
<td>
<p> a vector with log likelihoods of the models from list <code>models</code></p>
</td></tr>
<tr><td><code>names</code></td>
<td>
<p> a vector with names of the models from list <code>models</code></p>
</td></tr> 
<tr><td><code>params</code></td>
<td>
<p> a vector with the number of parameters of models from list <code>models</code></p>
</td></tr>
<tr><td><code>kList</code></td>
<td>
<p>equals the input argument <code>kList</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Przemyslaw Biecek
</p>


<h3>References</h3>

<p>Przemyslaw Biecek, Ewa Szczurek, Martin Vingron, Jerzy Tiuryn (2012), The R Package bgmm: Mixture Modeling with Uncertain Knowledge, Journal of Statistical Software.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mModel">mModel</a></code>, <code><a href="#topic+getModelStructure">getModelStructure</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> simulated = simulateData(d=2, k=3, n=100, m=60, cov="0", within="E", n.labels=2)
 
 models1=mModelList(X=simulated$X, knowns=simulated$knowns, B=simulated$B, 
             kList=3:4, mean=c("D","E"), between="D", within="D", 
             cov="0", funct=belief)

 plot(models1)
 plotGIC(models1, penalty="BIC")

## Do not run
## It could take more than one minute
# simulated = simulateData(d=2, k=3, n=300, m=60, cov="0", within="E", n.labels=2)
# 
# models1=mModelList(X=simulated$X, knowns=simulated$knowns, B=simulated$B, 
#             kList=3, mean=c("D","E"), between=c("D","E"), within=c("D","E"), 
#             cov=c("D","0"), funct=belief)
# plot(models1)
# plotGIC(models1, penalty="BIC")
# 
# models2 = beliefList(X=simulated$X, knowns=simulated$knowns, B=simulated$B,
#                kList=2:7, mean="D", between="D", within="E", cov="0")
# plot(models2)
# plotGIC(models2, penalty="BIC")
# 
# models3 = beliefList(X=simulated$X, knowns=simulated$knowns, B=simulated$B,
#               kList=2:7, mean="D")
# plotGIC(models3, penalty="BIC")
</code></pre>

<hr>
<h2 id='plot.mModel'>
Plotting a Graphical Visualization of a Gaussian Model or a List of Models
</h2><span id='topic+plot.mModel'></span>

<h3>Description</h3>

<p>The generic function <code>plot</code> is used to visualize the data set and Gaussian model components fitted to this data. On the resulting plot the observations without labels are presented with  black points, whereas the labeled observations are marked by different colors and different symbols. 
The fitted Gaussian components are represented by ellipses into the two-dimensional case and by densities in the one dimensional case.
If data has more than two dimensions thus graphs are presented on the subspace generated by first two PCA components. Note that the estimation is done in higher dimension and the reduction to 2D is done only for illustration. 
That gives different results than data reduction prior to modeling process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mModel'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mModel_+3A_x">x</code></td>
<td>
<p>an object of the class <code>mModel</code>.
</p>
</td></tr>
<tr><td><code id="plot.mModel_+3A_...">...</code></td>
<td>
<p>graphical arguments that are passed to the underlying <code>plot()</code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For one dimensional data the width of the density corresponds to standard deviation of the fitted Gaussian component. Fitted means are marked by vertical dashed lines.
</p>
<p>For two dimensional data ellipses represents covariances for the corresponding model components.   
</p>
<p>For more dimensional points and ellipses are projected into 2D subspace spanned by first two PCA components.
</p>


<h3>Author(s)</h3>

<p>Przemyslaw Biecek
</p>


<h3>References</h3>

<p>Przemyslaw Biecek, Ewa Szczurek, Martin Vingron, Jerzy Tiuryn (2012), The R Package bgmm: Mixture Modeling with Uncertain Knowledge, Journal of Statistical Software.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(genotypes)
 modelSupervised = supervised(knowns=genotypes$knowns, class=genotypes$labels)
 plot(modelSupervised)

 # semi-supervised modeling
 modelSemiSupervised = semisupervised(X=genotypes$X, knowns=genotypes$knowns,
                           class = genotypes$labels)
 plot(modelSemiSupervised)

 # belief-based modeling
 modelBelief = belief(X=genotypes$X, knowns=genotypes$knowns, B=genotypes$B)
 plot(modelBelief)

 # soft-label modeling
 modelSoft = soft(X=genotypes$X, knowns=genotypes$knowns, P=genotypes$B)
 plot(modelSoft)

 # unsupervised modeling
 modelUnSupervised = unsupervised(X=genotypes$X, k=3)
 plot(modelUnSupervised)
</code></pre>

<hr>
<h2 id='plot.mModelList'>
Plotting a graphical visualization of a model or a list of models
</h2><span id='topic+plot.mModelList'></span>

<h3>Description</h3>

<p>The function <code>plot.mModelList()</code> creates a grid of panels and then plots a set of input fitted models in the consecutive panels. The <code>plot.mModel()</code> function is used to plot each single model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mModelList'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mModelList_+3A_x">x</code></td>
<td>
<p>an object of the class <code>mModelList</code>.  </p>
</td></tr>
<tr><td><code id="plot.mModelList_+3A_...">...</code></td>
<td>
<p>graphical arguments that are passed to underlying <code>plot()</code> function.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>x</code> is a list of models. If these models differ both by component numbers and by the model structures, 
in the resulting grid of panels columns correspond to the different model structures while rows correspond to the different component numbers. 
</p>
<p>If considered models differ only by component numbers or only by the model structures, the grid of panels is as close to square as possible and consecutive panels contain consecutive models from the list of models <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Przemyslaw Biecek
</p>


<h3>References</h3>

<p>Przemyslaw Biecek, Ewa Szczurek, Martin Vingron, Jerzy Tiuryn (2012), The R Package bgmm: Mixture Modeling with Uncertain Knowledge, Journal of Statistical Software.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.mModel">plot.mModel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> simulated = simulateData(d=2, k=3, n=100, m=60, cov="0", within="E", n.labels=2)
 models1=mModelList(X=simulated$X, knowns=simulated$knowns, B=simulated$B, 
             kList=3:4, mean=c("D","E"), between="D", within="D", 
             cov="0", funct=belief)
 plot(models1)

## Do not run
## It could take more than one minute
# simulated = simulateData(d=2, k=3, n=300, m=60, cov="0", within="E", n.labels=2)
# 
# models1=mModelList(X=simulated$X, knowns=simulated$knowns, B=simulated$B, 
#             kList=3, mean=c("D","E"), between=c("D","E"), within=c("D","E"), 
#             cov=c("D","0"), funct=belief)
# plot(models1)
#
# models2 = beliefList(X=simulated$X, knowns=simulated$knowns, B=simulated$B,
#                kList=2:7, mean="D", between="D", within="E", cov="0")
# plot(models2)
# 
# models3 = beliefList(X=simulated$X, knowns=simulated$knowns, B=simulated$B,
#               kList=2:7, mean="D")
# plot(models3)
</code></pre>

<hr>
<h2 id='plotGIC'>
Plotting GIC scores 
</h2><span id='topic+plotGIC'></span><span id='topic+getGIC'></span><span id='topic+getDF'></span>

<h3>Description</h3>

<p>The function <code>plotGIC()</code> plots the GIC scores for an input collection of models. The function <code>getGIC()</code> extracts GIC for given model and penalty function. The function <code>getDF()</code> extracts the number of degree of freedom for model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGIC(models, penalty = 2, plot.it = TRUE, ...)

getGIC(model, p = 2, whichobs="unlabeled")

getDF(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGIC_+3A_models">models</code></td>
<td>
<p>an object of the class <code>mModelList</code> or a matrix of GIC scores.
</p>
</td></tr>
<tr><td><code id="plotGIC_+3A_model">model</code></td>
<td>
<p>an object of the class <code>mModel</code>.
</p>
</td></tr>
<tr><td><code id="plotGIC_+3A_penalty">penalty</code></td>
<td>
<p>a penalty for the GIC criteria. This parameter can be a single number or a string, on of the &quot;BIC&quot;, &quot;AIC&quot;, &quot;AIC3&quot;, &quot;AIC4&quot;, &quot;AICc&quot;, &quot;AICu&quot;, &quot;CAIC&quot;, &quot;BIC&quot;, &quot;MDL&quot;, &quot;CLC&quot;, &quot;ICL-BIC&quot;, &quot;AWE&quot;.     
</p>
</td></tr>
<tr><td><code id="plotGIC_+3A_p">p</code></td>
<td>
<p>same as <code>penalty</code>,  
</p>
</td></tr>
<tr><td><code id="plotGIC_+3A_whichobs">whichobs</code></td>
<td>
<p>one of &quot;unlabeled&quot;, &quot;labeled&quot;, &quot;all&quot;. This parameter specify which observations should be used in the likelihood and gic score calculation,  
</p>
</td></tr>
<tr><td><code id="plotGIC_+3A_plot.it">plot.it</code></td>
<td>
<p>a logical value, if <code>TRUE</code> then the chart with the GIC scores will be plotted.
</p>
</td></tr>
<tr><td><code id="plotGIC_+3A_...">...</code></td>
<td>
<p>other arguments that will be passed to the getGIC function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>plotGIC()</code> calculates the GIC scores for each model from the <code>models</code> list and, given <code>plot.it=TRUE</code>, plots a dotchart with the calculated GIC scores. 
</p>
<p>As a result the function <code>plotGIC()</code> returns a matrix with the calculated GIC scores. This matrix or its submatrix can be used in next call of the <code>plotGIC()</code> function as <code>models</code> argument. The columns of the  matrix correspond to different component numbers of the models, while the rows correspond to their structures. The structures are coded with four-letter strings. The letters refer, in order from left to right: first, the relation between the means' vectors of the components, which can either be equal (letter &quot;E&quot;) or unconstrained (&quot;D&quot;). Second, the relation between covariance matrices, which can all either be equal (&quot;E&quot;), or unconstrained (&quot;D&quot;). Third, the relation between the data vector components (corresponding to data dimensions) within each covariance matrix, i.e. each covariance matrix can either have all variances equal to some constant and all covariances equal to some constant (&quot;E&quot;) or can be unconstrained (&quot;D&quot;). Fourth, the covariances in each covariance matrix, which can either all be forced to equal 0 (&quot;0&quot;) or be unconstrained (&quot;D&quot;).
</p>
<p>The best model, i.e. model with the smallest GIC score is marked with a star on the plotted chart. 
</p>


<h3>Value</h3>

<p>The matrix with GIC scores calculated for the list of models specified by the <code>models</code> argument. </p>


<h3>Author(s)</h3>

<p>Przemyslaw Biecek
</p>


<h3>References</h3>

<p>Przemyslaw Biecek, Ewa Szczurek, Martin Vingron, Jerzy Tiuryn (2012), The R Package bgmm: Mixture Modeling with Uncertain Knowledge, Journal of Statistical Software.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> simulated = simulateData(d=2, k=3, n=100, m=60, cov="0", within="E", n.labels=2)
 models1   = mModelList(X=simulated$X, knowns=simulated$knowns, B=simulated$B, 
             kList=3:4, mean=c("D","E"), between="D", within="D", 
             cov="0", funct=belief)
 plotGIC(models1, penalty="BIC")

## Do not run
## It could take more than one minute
# simulated = simulateData(d=2, k=3, n=300, m=60, cov="0", within="E", n.labels=2)
# 
# models1=mModelList(X=simulated$X, knowns=simulated$knowns, B=simulated$B, 
#             kList=3, mean=c("D","E"), between=c("D","E"), within=c("D","E"), 
#             cov=c("D","0"), funct=belief)
# plotGIC(models1, penalty="BIC")
# 
# models2 = beliefList(X=simulated$X, knowns=simulated$knowns, B=simulated$B,
#                kList=2:7, mean="D", between="D", within="E", cov="0")
# plotGIC(models2, penalty="BIC")
# 
# models3 = beliefList(X=simulated$X, knowns=simulated$knowns, B=simulated$B,
#               kList=2:7, mean="D")
# plotGIC(models3, penalty="BIC")
</code></pre>

<hr>
<h2 id='predict.mModel'>
Predictions for fitted Gaussian component model
</h2><span id='topic+predict.mModel'></span>

<h3>Description</h3>

<p>For every row in the matrix <code>X</code> the posterior probability of belonging to class <code>i</code> is calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mModel'
predict(object, X, knowns = NULL, B = NULL, P = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.mModel_+3A_object">object</code></td>
<td>
<p>an object of the class <code>mModel</code>,   </p>
</td></tr>
<tr><td><code id="predict.mModel_+3A_x">X</code></td>
<td>
<p>a <code>matrix</code> or <code>data.frame</code> in which number of columns is equal to <code>object$d</code>.   </p>
</td></tr>
<tr><td><code id="predict.mModel_+3A_knowns">knowns</code></td>
<td>
<p>a <code>data.frame</code> or <code>matrix</code> with the labeled observations. If the argument <code>knowns</code> is specified then eighter <code>B</code> or <code>P</code> need to be specified. </p>
</td></tr>
<tr><td><code id="predict.mModel_+3A_p">P</code></td>
<td>
<p>a matrix with plausibilities for object <code>knowns</code>. </p>
</td></tr>
<tr><td><code id="predict.mModel_+3A_b">B</code></td>
<td>
<p>a matrix with beliefs for object <code>knowns</code>. </p>
</td></tr>
<tr><td><code id="predict.mModel_+3A_...">...</code></td>
<td>
<p>all other arguments will be neglected.   </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrix tij of posterior probabilities is calculated as normalized products of priors pi's and density of model components in values specified by rows of the matrix <code>X</code>.
</p>
<p>If arguments <code>knowns</code> and <code>B</code> are specified then the priors's for objects in <code>knowns</code> are replaced by belief matrix <code>B</code>.
If arguments <code>knowns</code> and <code>P</code> are specified then the priors's for objects in <code>knowns</code> are multiplied by plausibility matrix <code>P</code>.
</p>


<h3>Value</h3>

<p>An list with the following elements:
</p>
<table>
<tr><td><code>tij.X</code>, <code>tij.knowns</code></td>
<td>
<p>the matrix tij.X is a matrix with number of rows equal to number of rows in the matrix <code>X</code> and the number of columns equal to the number of components in model  defined by argument <code>object</code>. Values in this matrix are posterior probabilities that observation i belongs to component j. The slot <code>tij.knowns</code> is equal to <code>NULL</code> if neither <code>B</code> nor <code>P</code> are specified, otherwise it is a matrix with number of rows equal to number of rows in the matrix <code>knowns</code> and contains posterior probabilities for observarions with specified belief or plausibilities matrix</p>
</td></tr>
<tr><td><code>class.X</code>, <code>class.knowns</code></td>
<td>
<p>vactors of labels/classes obtained with the MAP rule. The vector <code>class.X</code> corresponds to observations in <code>X</code> while the vector <code>class.knowns</code> corresponds to observations in <code>knowns</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Przemyslaw Biecek, Ewa Szczurek, Martin Vingron, Jerzy Tiuryn (2012), The R Package bgmm: Mixture Modeling with Uncertain Knowledge, Journal of Statistical Software.
</p>


<h3>References</h3>

<p>http://bgmm.molgen.mpg.de
</p>


<h3>See Also</h3>

<p><code><a href="#topic+belief">belief</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> data(genotypes)

 modelSoft = soft(X=genotypes$X, knowns=genotypes$knowns, P=genotypes$B)

 preds = predict(modelSoft, X = genotypes$X)
 str(preds)
</code></pre>

<hr>
<h2 id='simulateData'>
Dataset generation
</h2><span id='topic+simulateData'></span>

<h3>Description</h3>

<p>The function <code>simulateData</code> generates an artificial dataset from a mixture of Gaussian components with a given set of parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> simulateData(d = 2, k = 4, n = 100, m = 10, mu = NULL, cvar = NULL, 
    s.pi = rep(1/k, k), b.min = 0.02, mean = "D", between = "D", 
    within = "D", cov = "D", n.labels = k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateData_+3A_d">d</code></td>
<td>
<p>the dimension of the data set,  </p>
</td></tr>
<tr><td><code id="simulateData_+3A_k">k</code></td>
<td>
<p>the number of the model components,  </p>
</td></tr>
<tr><td><code id="simulateData_+3A_n">n</code></td>
<td>
<p>the total number of observations, both labeled and unlabeled,  </p>
</td></tr>
<tr><td><code id="simulateData_+3A_mu">mu</code></td>
<td>
<p>a matrix with <code>k</code> rows and <code>d</code> columns, which defines the means' vectors for the corresponding model components. If not specified, by default its values are generated from a normal distribution N(0,49),  </p>
</td></tr>
<tr><td><code id="simulateData_+3A_cvar">cvar</code></td>
<td>
<p>a three-dimensional array with the dimensions (<code>k</code>, <code>d</code>, <code>d</code>). If not specified, each covariance matrix is generated in three steps: first, 2*<code>d</code> samples from a <code>d</code>-dimensional normal distribution N(0, Id) are generated. Next, a covariance matrix d x d for these samples is calculated. Finally, the resulting sample covariance matrix is scaled by a factor generated from an exponential distribution  Exp(1),  </p>
</td></tr>
<tr><td><code id="simulateData_+3A_s.pi">s.pi</code></td>
<td>
<p> a vector of <code>k</code> probabilities, i.e. the mixing proportions of the model. The mixing proportions specify a multinomial distribution over the components, from which the numbers of observations in each cluster are generated. By default a uniform distribution is used.  </p>
</td></tr>
<tr><td><code id="simulateData_+3A_mean">mean</code>, <code id="simulateData_+3A_between">between</code>, <code id="simulateData_+3A_within">within</code>, <code id="simulateData_+3A_cov">cov</code></td>
<td>
<p>constraints on the model structure. By default all are equal to &quot;D&quot;. If other values are set, the parameters <code>mu</code> and <code>cvar</code> are adjusted to match the specified constraints,  </p>
</td></tr>
<tr><td><code id="simulateData_+3A_m">m</code></td>
<td>
<p>the number of the observations, for which the beliefs are to be calculated,  </p>
</td></tr>
<tr><td><code id="simulateData_+3A_b.min">b.min</code></td>
<td>
<p> the belief that an observation does not belong to a component. Formally, the belief bij for the observation i to belong to component j is equal <code>b.min</code> if i is not generated from component j. Thus, the belief that i belongs to its true component is set to <code>1-b.min*(n.labels-1)</code>, and <code>b.min</code> is constrained that <code>b.min</code>$&lt;1/$<code>n.labels</code>. By default <code>b.min=0.02</code>,  </p>
</td></tr>
<tr><td><code id="simulateData_+3A_n.labels">n.labels</code></td>
<td>
<p>the number of components used as labels, defining the number of columns in the resulting beliefs matrix. By default <code>n.labels</code> equals <code>k</code>, but the user can specify a smaller number. Using this argument the user can define a scenario in which the data are generated from a mixture of three components, but only two of them are used as labels in the beliefs matrix (applied in the example below).  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An list with the following elements:
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>the matrix of size n-m rows and d columns with generated values of unlabeled observations,</p>
</td></tr>
<tr><td><code>knowns</code></td>
<td>
<p>the matrix of size m rows and d columns with generated values of labeled observations,</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>the belief matrix of the size m rows and k columns derived for knowns matrix,</p>
</td></tr>
<tr><td><code>model.params</code></td>
<td>
<p>the list of model parameters,</p>
</td></tr>
<tr><td><code>Ytrue</code></td>
<td>
<p>indexes of the true Gaussian components from which each observation was generated. Lables for knowns go first.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Przemyslaw Biecek
</p>


<h3>References</h3>

<p>Przemyslaw Biecek, Ewa Szczurek, Martin Vingron, Jerzy Tiuryn (2012), The R Package bgmm: Mixture Modeling with Uncertain Knowledge, Journal of Statistical Software.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> simulated = simulateData(d=2, k=3, n=300, m=60, cov="0", within="E", n.labels=2)
 model = belief(X = simulated$X, knowns = simulated$knowns, B=simulated$B)
 plot(model)

 simulated = simulateData(d=1, k=2, n=300, m=60, n.labels=2)
 model = belief(X = simulated$X, knowns = simulated$knowns, B=simulated$B)
 plot(model)
</code></pre>

<hr>
<h2 id='Ste12'>Ste12 knockout data under pheromone treatment versus wild type;
Examples of Ste12 targets; Binding p-values of Ste12 to those targets.</h2><span id='topic+Ste12Data'></span><span id='topic+Ste12'></span><span id='topic+Ste12Beliefs'></span><span id='topic+Ste12Binding'></span>

<h3>Description</h3>

<p>Ste12 knockout expression data (Roberts et al., 2002) and knowledge from a Ste12 binding  experiment (Harbison et al., 2004) used for identifying Ste12 target genes under pheromone treatment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Ste12)</code></pre>


<h3>Format</h3>

<p>Ste12Data vector: 601
Ste12Beliefs matrix of example certainty:  42 x 2
Ste12Binding vector: 42
</p>


<h3>Details</h3>

<p><code>Ste12Data</code> Log2 expression ratios of Ste12 knockout versus
wild type, both under 50nM alpha-factor treatment for 30min. This
data is for 601 genes that had more than 1.5 fold change in expression
after pheromone  treatment versus wild type.
<code>Ste12Beliefs</code>: Gives the certainty (belief/plausibility) for
each out of 42 example Ste12 targets to belong to their cluster.
<code>Ste12Beliefs</code>: Gives the certainty (belief/plausibility) for
each out of 42 example Ste12 targets to belong to their cluster. The
42 examples were chosen to meet two criteria: (1) Had a binding
p-value &lt;0.0001 (see <code>Ste12Binding</code>), and (2) Had a 2-fold change in response to pheromone treatment (versus wild-type)
<code>Ste12Binding</code>: Gives the binding p-value for each example Ste12 target (see <code>Ste12Belief</code>).
</p>


<h3>Author(s)</h3>

<p>Ewa Szczurek
</p>


<h3>References</h3>

<p>Roberts, C. J., Nelson, B., Marton, M. J., Stoughton, R., Meyer, M. R., Bennett, H. A.,
He, Y. D., Dai, H., Walker, W. L., Hughes, T. R., Tyers, M., Boone, C., and Friend,
S. H. (2000). Signaling and Circuitry of Multiple MAPK Pathways Revealed by a
Matrix of Global Gene Expression Profiles. Science, 287(5454), 873&ndash;880.
</p>
<p>Harbison, C. T., Gordon, D. B., Lee, T. I., Rinaldi, N. J., Macisaac, K. D., Danford,
T. W., Hannett, N. M., Tagne, J.-B., Reynolds, D. B., Yoo, J., Jennings, E. G., Zeitlinger,
J., Pokholok, D. K., Kellis, M., Rolfe, P. A., Takusagawa, K. T., Lander, E. S.,
Gifford, D. K., Fraenkel, E., and Young, R. A. (2004). Transcriptional regulatory
code of a eukaryotic genome. Nature, 431(7004), 99&ndash;104.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+miRNA">miRNA</a></code>,<code><a href="#topic+CellCycle">CellCycle</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    data("Ste12")
    print(Ste12Data)
    print(Ste12Beliefs)
    print(Ste12Binding)
</code></pre>

<hr>
<h2 id='Supplementary+20functions'>
Set of supplementary functions for bgmm package
</h2><span id='topic+determinant.numeric'></span><span id='topic+map'></span><span id='topic+loglikelihood.mModel'></span>

<h3>Description</h3>

<p>Set of supplementary functions for <code>bgmm</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'numeric'
determinant(x, logarithm = TRUE, ...)
 
 map(B) 
 
 loglikelihood.mModel(model, X) 
 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Supplementary+2B20functions_+3A_x">x</code></td>
<td>
<p>a single number.</p>
</td></tr>
<tr><td><code id="Supplementary+2B20functions_+3A_x">X</code></td>
<td>
<p>a data.frame with the unlabeled observations, the rows correspond to the observations and the columns to the dimensions of the data.</p>
</td></tr>
<tr><td><code id="Supplementary+2B20functions_+3A_b">B</code></td>
<td>
<p>a beliefs matrix with the distribution of beliefs for the labeled observations. </p>
</td></tr>
<tr><td><code id="Supplementary+2B20functions_+3A_model">model</code></td>
<td>
<p>an object of the class mModel.</p>
</td></tr>
<tr><td><code id="Supplementary+2B20functions_+3A_logarithm">logarithm</code>, <code id="Supplementary+2B20functions_+3A_...">...</code></td>
<td>
<p>these arguments are ignored. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Przemyslaw Biecek
</p>


<h3>References</h3>

<p>Przemyslaw Biecek, Ewa Szczurek, Martin Vingron, Jerzy Tiuryn (2012), The R Package bgmm: Mixture Modeling with Uncertain Knowledge, Journal of Statistical Software.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(genotypes)

map(genotypes$B)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
