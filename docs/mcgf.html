<!DOCTYPE html><html lang="en"><head><title>Help for package mcgf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mcgf}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#..cor_sep'><p>Calculate correlation for separable model</p></a></li>
<li><a href='#..cor_stat'><p>Calculate correlation for the general stationary model</p></a></li>
<li><a href='#.cor_cauchy'><p>Calculate Cauchy correlation</p></a></li>
<li><a href='#.cor_exp'><p>Calculate exponential correlation</p></a></li>
<li><a href='#.cor_fs'><p>Calculate correlation for fully symmetric model</p></a></li>
<li><a href='#.cor_lagr_askey'><p>Calculate Lagrangian correlation of the Askey form</p></a></li>
<li><a href='#.cor_lagr_exp'><p>Calculate Lagrangian correlation of the exponential form</p></a></li>
<li><a href='#.cor_lagr_tri'><p>Calculate Lagrangian correlation of the triangular form</p></a></li>
<li><a href='#.cor_sep'><p>Calculate correlation for separable model</p></a></li>
<li><a href='#.cor_stat'><p>Calculate general stationary correlation.</p></a></li>
<li><a href='#.find_dists'><p>Calculate (signed) distances between coordinates</p></a></li>
<li><a href='#.find_dists_new'><p>Calculate (signed) distances between coordinates</p></a></li>
<li><a href='#.mcgf_rs_sim'><p>Simulate regime-switching Markov chain Gaussian field</p></a></li>
<li><a href='#.mcgf_sim'><p>Simulate Markov chain Gaussian field</p></a></li>
<li><a href='#acf_rs'><p>Calculate regime-switching auto-correlation</p></a></li>
<li><a href='#acfs'><p>Generic function for calculating autocorrelation</p></a></li>
<li><a href='#acfs.mcgf'><p>Extract, calculate, or assign mean auto-correlations for an <code>mcgf</code> or</p>
<code>mcgf_rs</code> object</a></li>
<li><a href='#add_base'><p>Generic function for adding a base model</p></a></li>
<li><a href='#add_base.mcgf'><p>Add base model outputted from <code>fit_base()</code> to an <code>mcgf</code> object.</p></a></li>
<li><a href='#add_base.mcgf_rs'><p>Add base model outputted from <code>fit_base()</code> to an <code>mcgf_rs</code> object.</p></a></li>
<li><a href='#add_lagr'><p>Generic function for adding a Lagrangian model</p></a></li>
<li><a href='#add_lagr.mcgf'><p>Add lagr model outputted from <code>fit_lagr()</code> to a <code>mcgf</code> object.</p></a></li>
<li><a href='#add_lagr.mcgf_rs'><p>Add lagr model outputted from <code>fit_lagr()</code> to a <code>mcgf_rs</code> object.</p></a></li>
<li><a href='#add_nugget'><p>Adjust for nugget effect for correlations</p></a></li>
<li><a href='#ccf_rs'><p>Calculate regime-switching cross-correlation</p></a></li>
<li><a href='#ccfs'><p>Generic function for calculating cross-correlation</p></a></li>
<li><a href='#ccfs.mcgf'><p>Extract, calculate, or assign cross-correlations for an <code>mcgf</code> or <code>mcgf_rs</code></p>
object</a></li>
<li><a href='#ccov'><p>Generic functions for calculating joint covariance/correlation matrix for mcgf</p>
objects</a></li>
<li><a href='#ccov.mcgf'><p>Covariance/correlation for joint distribution of an <code>mcgf</code> object</p></a></li>
<li><a href='#ccov.mcgf_rs'><p>Covariance/correlation for joint distribution of an <code>mcgf_rs</code>object</p></a></li>
<li><a href='#check_dist'><p>Check if valid distance</p></a></li>
<li><a href='#check_dist_sign'><p>Check if valid signed distance</p></a></li>
<li><a href='#check_dists'><p>Check if valid dists attribute for an <code>mcgf</code> object</p></a></li>
<li><a href='#check_length'><p>Check if valid input length</p></a></li>
<li><a href='#check_length_ls'><p>Check if valid input length</p></a></li>
<li><a href='#cor_cauchy'><p>Calculate Cauchy correlation</p></a></li>
<li><a href='#cor_exp'><p>Calculate exponential correlation</p></a></li>
<li><a href='#cor_fs'><p>Calculate correlation for fully symmetric model</p></a></li>
<li><a href='#cor_lagr_askey'><p>Calculate Lagrangian correlation of the Askey form</p></a></li>
<li><a href='#cor_lagr_exp'><p>Calculate Lagrangian correlation of the exponential form</p></a></li>
<li><a href='#cor_lagr_tri'><p>Calculate Lagrangian correlation of the triangular form</p></a></li>
<li><a href='#cor_sep'><p>Calculate correlation for separable model</p></a></li>
<li><a href='#cor_stat'><p>Calculate general stationary correlation.</p></a></li>
<li><a href='#cor_stat_rs'><p>Calculate general stationary correlation.</p></a></li>
<li><a href='#cor2cov'><p>Convert correlation to covariance</p></a></li>
<li><a href='#cov_joint'><p>Covariance for joint distribution</p></a></li>
<li><a href='#dists'><p>Generic function for calculating distance matrices</p></a></li>
<li><a href='#dists.mcgf'><p>Calculating distance matrices for an <code>mcgf</code> object</p></a></li>
<li><a href='#estimate'><p>Optimization for wls method</p></a></li>
<li><a href='#find_dists'><p>Calculate (signed) distances between coordinates</p></a></li>
<li><a href='#find_dists_new'><p>Calculate (signed) distances between coordinates</p></a></li>
<li><a href='#fit_base'><p>Fit correlation base models</p></a></li>
<li><a href='#fit_base.mcgf'><p>Parameter estimation for symmetric correlation functions for an <code>mcgf</code></p>
object.</a></li>
<li><a href='#fit_base.mcgf_rs'><p>Parameter estimation for symmetric correlation functions for an <code>mcgf_rs</code></p>
object.</a></li>
<li><a href='#fit_lagr'><p>Fit correlation Lagrangian models</p></a></li>
<li><a href='#fit_lagr.mcgf'><p>Parameter estimation for Lagrangian correlation functions for an <code>mcgf</code></p>
object.</a></li>
<li><a href='#fit_lagr.mcgf_rs'><p>Parameter estimation for Lagrangian correlation functions for an <code>mcgf_rs</code></p>
object.</a></li>
<li><a href='#is_numeric_scalar'><p>Check if numeric scalar</p></a></li>
<li><a href='#is.mcgf'><p>Check if an object is an <code>mcgf</code> object.</p></a></li>
<li><a href='#is.mcgf_rs'><p>Check if an object is an <code>mcgf_rs</code> object..</p></a></li>
<li><a href='#krige'><p>Generic function for computing kriging forecasts</p></a></li>
<li><a href='#krige_new'><p>Generic function for computing kriging forecasts for new locations</p></a></li>
<li><a href='#krige_new.mcgf'><p>Obtain kriging forecasts for new locations for an <code>mcgf</code> object.</p></a></li>
<li><a href='#krige_new.mcgf_rs'><p>Obtain kriging forecasts for new locations for an <code>mcgf_rs</code> object.</p></a></li>
<li><a href='#krige.mcgf'><p>Obtain kriging forecasts for an <code>mcgf</code> object.</p></a></li>
<li><a href='#krige.mcgf_rs'><p>Obtain kriging forecasts for an <code>mcgf_rs</code> object.</p></a></li>
<li><a href='#mat_inv'><p>Find inverse of a symmetric positive definite matrix</p></a></li>
<li><a href='#mcgf'><p>Create mcgf object</p></a></li>
<li><a href='#mcgf_rs'><p>Create mcgf_rs object</p></a></li>
<li><a href='#mcgf_rs_sim'><p>Simulate regime-switching Markov chain Gaussian field</p></a></li>
<li><a href='#mcgf_sim'><p>Simulate Markov chain Gaussian field</p></a></li>
<li><a href='#model'><p>Generic function for displaying fitted models for <code>mcgf</code> objects</p></a></li>
<li><a href='#model.mcgf'><p>Display fitted models for an <code>mcgf</code> or <code>mcgf_rs</code> object</p></a></li>
<li><a href='#new_mcgf'><p>Create an mcgf object</p></a></li>
<li><a href='#new_mcgf_rs'><p>Create an mcgf_rs object</p></a></li>
<li><a href='#obj_mle'><p>Title</p></a></li>
<li><a href='#obj_wls'><p>Compute the objective for wls method</p></a></li>
<li><a href='#print.mcgf'><p>Print an <code>mcgf</code> object.</p></a></li>
<li><a href='#rdists'><p>Generate random distance matrices</p></a></li>
<li><a href='#sd_rs'><p>Calculate standard deviation for each location under each regime.</p></a></li>
<li><a href='#sds'><p>Generic function for standard deviations for each column</p></a></li>
<li><a href='#sds.mcgf'><p>Extract, calculate, or assign standard deviations for an <code>mcgf</code> or</p>
<code>mcgf_rs</code> object.</a></li>
<li><a href='#sim1'><p>Simulated Markov chain Gaussian field</p></a></li>
<li><a href='#sim2'><p>Simulated regime-switching Markov chain Gaussian field</p></a></li>
<li><a href='#sim3'><p>Simulated regime-switching Markov chain Gaussian field</p></a></li>
<li><a href='#to_ar'><p>Convert to array</p></a></li>
<li><a href='#validate_mcgf'><p>Validate an mcgf object</p></a></li>
<li><a href='#validate_mcgf_rs'><p>Validate an mcgf_rs object</p></a></li>
<li><a href='#wind'><p>Ireland wind data, 1961-1978</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Markov Chain Gaussian Fields Simulation and Parameter Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulating and estimating (regime-switching) Markov chain Gaussian 
    fields with covariance functions of the Gneiting class (Gneiting 2002) 
    &lt;<a href="https://doi.org/10.1198%2F016214502760047113">doi:10.1198/016214502760047113</a>&gt;. It supports parameter estimation by 
    weighted least squares and maximum likelihood methods, and produces Kriging 
    forecasts and intervals for existing and new locations.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), doParallel (&ge; 1.0.17), foreach (&ge;
1.5.2), parallel (&ge; 4.3.1), knitr, rmarkdown, lubridate,
dplyr, Rsolnp</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, sp</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tianxia-jia/mcgf">https://github.com/tianxia-jia/mcgf</a>,
<a href="https://tianxia-jia.github.io/mcgf/">https://tianxia-jia.github.io/mcgf/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tianxia-jia/mcgf/issues">https://github.com/tianxia-jia/mcgf/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-28 23:16:56 UTC; tylar</td>
</tr>
<tr>
<td>Author:</td>
<td>Tianxia Jia <a href="https://orcid.org/0000-0001-5430-5019"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tianxia Jia &lt;tianxia.jia@ucalgary.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-29 06:40:17 UTC</td>
</tr>
</table>
<hr>
<h2 id='..cor_sep'>Calculate correlation for separable model</h2><span id='topic+..cor_sep'></span>

<h3>Description</h3>

<p>Calculate correlation for separable model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>..cor_sep(nugget, c, gamma = 1/2, a, alpha, h, u)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="..cor_sep_+3A_nugget">nugget</code></td>
<td>
<p>The nugget effect <code class="reqn">\in[0, 1]</code>.</p>
</td></tr>
<tr><td><code id="..cor_sep_+3A_c">c</code></td>
<td>
<p>Scale parameter of <code>cor_exp</code>, <code class="reqn">c&gt;0</code>.</p>
</td></tr>
<tr><td><code id="..cor_sep_+3A_gamma">gamma</code></td>
<td>
<p>Smooth parameter of <code>cor_exp</code>, <code class="reqn">\gamma\in(0, 1/2]</code>.</p>
</td></tr>
<tr><td><code id="..cor_sep_+3A_a">a</code></td>
<td>
<p>Scale parameter of <code>cor_cauchy</code>, <code class="reqn">a&gt;0</code>.</p>
</td></tr>
<tr><td><code id="..cor_sep_+3A_alpha">alpha</code></td>
<td>
<p>Smooth parameter of <code>cor_cauchy</code>, <code class="reqn">\alpha\in(0, 1]</code>.</p>
</td></tr>
<tr><td><code id="..cor_sep_+3A_h">h</code></td>
<td>
<p>Euclidean distance matrix or array.</p>
</td></tr>
<tr><td><code id="..cor_sep_+3A_u">u</code></td>
<td>
<p>Time lag, same dimension as <code>h</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a special case of <code><a href="#topic+.cor_fs">.cor_fs()</a></code>. It is used inside
<code><a href="#topic+fit_base">fit_base()</a></code>.
</p>


<h3>Value</h3>

<p>Correlations for separable model.
</p>

<hr>
<h2 id='..cor_stat'>Calculate correlation for the general stationary model</h2><span id='topic+..cor_stat'></span>

<h3>Description</h3>

<p>Calculate correlation for the general stationary model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>..cor_stat(cor_base, lagrangian, lambda, v1, v2, k = 2, h1, h2, u)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="..cor_stat_+3A_cor_base">cor_base</code></td>
<td>
<p>An array of base cross-correlation matrices.</p>
</td></tr>
<tr><td><code id="..cor_stat_+3A_lagrangian">lagrangian</code></td>
<td>
<p>Lagrangian model, <code>none</code>, <code>lagr_tri</code>, or <code>lagr_askey</code>.</p>
</td></tr>
<tr><td><code id="..cor_stat_+3A_lambda">lambda</code></td>
<td>
<p>Weight of the Lagrangian term, <code class="reqn">\lambda\in[0, 1]</code>.</p>
</td></tr>
<tr><td><code id="..cor_stat_+3A_v1">v1</code></td>
<td>
<p>Prevailing wind, u-component.</p>
</td></tr>
<tr><td><code id="..cor_stat_+3A_v2">v2</code></td>
<td>
<p>Prevailing wind, v-component.</p>
</td></tr>
<tr><td><code id="..cor_stat_+3A_k">k</code></td>
<td>
<p>Scale parameter of <code class="reqn">\|\boldsymbol v\|</code>, <code class="reqn">k&gt;0</code>. Default is 2.</p>
</td></tr>
<tr><td><code id="..cor_stat_+3A_h1">h1</code></td>
<td>
<p>Horizontal distance matrix or array.</p>
</td></tr>
<tr><td><code id="..cor_stat_+3A_h2">h2</code></td>
<td>
<p>Vertical distance matrix or array, same dimension as <code>h1</code>.</p>
</td></tr>
<tr><td><code id="..cor_stat_+3A_u">u</code></td>
<td>
<p>Time lag, same dimension as <code>h1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a special case of <code><a href="#topic+.cor_stat">.cor_stat()</a></code>. It is used inside
<code><a href="#topic+fit_lagr">fit_lagr()</a></code>.
</p>


<h3>Value</h3>

<p>Correlations for the general stationary model.
</p>

<hr>
<h2 id='.cor_cauchy'>Calculate Cauchy correlation</h2><span id='topic+.cor_cauchy'></span>

<h3>Description</h3>

<p>Calculate Cauchy correlation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cor_cauchy(x, a, alpha, nu = 1, nugget = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".cor_cauchy_+3A_x">x</code></td>
<td>
<p>A numeric vector, matrix, or array.</p>
</td></tr>
<tr><td><code id=".cor_cauchy_+3A_a">a</code></td>
<td>
<p>Smooth parameter, <code class="reqn">a&gt;0</code>.</p>
</td></tr>
<tr><td><code id=".cor_cauchy_+3A_alpha">alpha</code></td>
<td>
<p>Scale parameter, <code class="reqn">\alpha\in(0, 1]</code>.</p>
</td></tr>
<tr><td><code id=".cor_cauchy_+3A_nu">nu</code></td>
<td>
<p>Power parameter, <code class="reqn">\nu&gt;0</code>. Default is 1.</p>
</td></tr>
<tr><td><code id=".cor_cauchy_+3A_nugget">nugget</code></td>
<td>
<p>The nugget effect <code class="reqn">\in[0, 1]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Cauchy correlation function with scale parameter <code class="reqn">a</code> and
smooth parameter <code class="reqn">\alpha</code> has the form
</p>
<p style="text-align: center;"><code class="reqn">C(x)=(1-\text{nugget})(a|x|^{2\alpha} + 1)^{-\nu}+\text{nugget}\cdot
\delta_{x=0},</code>
</p>
<p> where <code class="reqn">\delta_{x=0}</code> is 1 when <code class="reqn">x=0</code> and 0 otherwise.
</p>


<h3>Value</h3>

<p>Correlations of the same dimension as <code>x</code>.
</p>


<h3>References</h3>

<p>Gneiting, T., and Schlather, M. (2004). Stochastic Models That Separate
Fractal Dimension and the Hurst Effect. SIAM Review, 46(2), 269–282.
</p>

<hr>
<h2 id='.cor_exp'>Calculate exponential correlation</h2><span id='topic+.cor_exp'></span>

<h3>Description</h3>

<p>Calculate exponential correlation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cor_exp(x, c, gamma = 1/2, nugget = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".cor_exp_+3A_x">x</code></td>
<td>
<p>A numeric vector, matrix, or array.</p>
</td></tr>
<tr><td><code id=".cor_exp_+3A_c">c</code></td>
<td>
<p>Smooth parameter, <code class="reqn">c&gt;0</code>.</p>
</td></tr>
<tr><td><code id=".cor_exp_+3A_gamma">gamma</code></td>
<td>
<p>Scale parameter, <code class="reqn">\gamma\in(0, 1/2]</code>. Default is 1/2.</p>
</td></tr>
<tr><td><code id=".cor_exp_+3A_nugget">nugget</code></td>
<td>
<p>The nugget effect <code class="reqn">\in[0, 1]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The exponential correlation function with scale parameter <code class="reqn">c</code>
and smooth parameter <code class="reqn">\gamma</code> has the form
</p>
<p style="text-align: center;"><code class="reqn">C(x)=(1-\text{nugget})\exp(-c|x|^{2\gamma})+\text{nugget}\cdot
\delta_{x=0},</code>
</p>
<p> where <code class="reqn">\delta_{x=0}</code> is 1 when <code class="reqn">x=0</code> and 0 otherwise.
</p>


<h3>Value</h3>

<p>Correlations of the same dimension as <code>x</code>.
</p>


<h3>References</h3>

<p>Diggle, P. J., Tawn, J. A., &amp; Moyeed, R. A. (1998). Model-Based
Geostatistics. Journal of the Royal Statistical Society. Series C (Applied
Statistics), 47(3), 299–350.
</p>

<hr>
<h2 id='.cor_fs'>Calculate correlation for fully symmetric model</h2><span id='topic+.cor_fs'></span>

<h3>Description</h3>

<p>Calculate correlation for fully symmetric model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cor_fs(nugget, c, gamma = 1/2, a, alpha, beta = 0, h, u)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".cor_fs_+3A_nugget">nugget</code></td>
<td>
<p>The nugget effect <code class="reqn">\in[0, 1]</code>.</p>
</td></tr>
<tr><td><code id=".cor_fs_+3A_c">c</code></td>
<td>
<p>Scale parameter of <code>cor_exp</code>, <code class="reqn">c&gt;0</code>.</p>
</td></tr>
<tr><td><code id=".cor_fs_+3A_gamma">gamma</code></td>
<td>
<p>Smooth parameter of <code>cor_exp</code>, <code class="reqn">\gamma\in(0, 1/2]</code>.</p>
</td></tr>
<tr><td><code id=".cor_fs_+3A_a">a</code></td>
<td>
<p>Scale parameter of <code>cor_cauchy</code>, <code class="reqn">a&gt;0</code>.</p>
</td></tr>
<tr><td><code id=".cor_fs_+3A_alpha">alpha</code></td>
<td>
<p>Smooth parameter of <code>cor_cauchy</code>, <code class="reqn">\alpha\in(0, 1]</code>.</p>
</td></tr>
<tr><td><code id=".cor_fs_+3A_beta">beta</code></td>
<td>
<p>Interaction parameter, <code class="reqn">\beta\in[0, 1]</code>.</p>
</td></tr>
<tr><td><code id=".cor_fs_+3A_h">h</code></td>
<td>
<p>Euclidean distance matrix or array.</p>
</td></tr>
<tr><td><code id=".cor_fs_+3A_u">u</code></td>
<td>
<p>Time lag, same dimension as <code>h</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fully symmetric correlation function with interaction parameter
<code class="reqn">\beta</code> has the form
</p>
<p style="text-align: center;"><code class="reqn">C(\mathbf{h}, u)=\dfrac{1}{(a|u|^{2\alpha} + 1)}
\left((1-\text{nugget})\exp\left(\dfrac{-c\|\mathbf{h}\|^{2\gamma}}
{(a|u|^{2\alpha}+1)^{\beta\gamma}}\right)+
\text{nugget}\cdot \delta_{\mathbf{h}=\boldsymbol 0}\right),</code>
</p>

<p>where <code class="reqn">\|\cdot\|</code> is the Euclidean distance, and <code class="reqn">\delta_{x=0}</code> is 1
when <code class="reqn">x=0</code> and 0 otherwise. Here <code class="reqn">\mathbf{h}\in\mathbb{R}^2</code> and
<code class="reqn">u\in\mathbb{R}</code>. By default <code>beta = 0</code> and it reduces to the separable
model.
</p>


<h3>Value</h3>

<p>Correlations of the same dimension as <code>h</code> and <code>u</code>.
</p>


<h3>References</h3>

<p>Gneiting, T. (2002). Nonseparable, Stationary Covariance Functions for
Space–Time Data, Journal of the American Statistical Association, 97:458,
590-600.
</p>

<hr>
<h2 id='.cor_lagr_askey'>Calculate Lagrangian correlation of the Askey form</h2><span id='topic+.cor_lagr_askey'></span>

<h3>Description</h3>

<p>Calculate Lagrangian correlation of the Askey form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cor_lagr_askey(v1, v2, k = 2, h1, h2, u)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".cor_lagr_askey_+3A_v1">v1</code></td>
<td>
<p>Prevailing wind, u-component.</p>
</td></tr>
<tr><td><code id=".cor_lagr_askey_+3A_v2">v2</code></td>
<td>
<p>Prevailing wind, v-component.</p>
</td></tr>
<tr><td><code id=".cor_lagr_askey_+3A_k">k</code></td>
<td>
<p>Scale parameter of <code class="reqn">\|\boldsymbol v\|</code>, <code class="reqn">k&gt;0</code>. Default is 2.</p>
</td></tr>
<tr><td><code id=".cor_lagr_askey_+3A_h1">h1</code></td>
<td>
<p>Horizontal distance matrix or array.</p>
</td></tr>
<tr><td><code id=".cor_lagr_askey_+3A_h2">h2</code></td>
<td>
<p>Vertical distance matrix or array, same dimension as <code>h1</code>.</p>
</td></tr>
<tr><td><code id=".cor_lagr_askey_+3A_u">u</code></td>
<td>
<p>Time lag, same dimension as <code>h1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Lagrangian correlation function of the Askey form with parameters
<code class="reqn">\boldsymbol v = (v_1, v_2)^\top\in\mathbb{R}^2</code> has the form
</p>
<p style="text-align: center;"><code class="reqn">C(\mathbf{h}, u)=\left(1-\dfrac{1}{k\|\boldsymbol v\|}
\left\|\mathbf{h}-u\boldsymbol v\right\|\right)^{3/2}_+,</code>
</p>

<p>where <code class="reqn">\|\cdot\|</code> is the Euclidean distance, <code class="reqn">x_+=\max(x,0),
\mathbf{h} = (\mathrm{h}_1, \mathrm{h}_2)^\top\in\mathbb{R}^2</code>,
and <code class="reqn">k &gt; 0</code> is the scale parameter controlling the magnitude of
asymmetry in correlation.
</p>


<h3>Value</h3>

<p>Correlations of the same dimension as <code>h1</code>.
</p>


<h3>References</h3>

<p>Askey, R. (1973). Radial characteristic functions, Tech. Report No. 1262,
Math. Research Center, University of Wisconsin-Madison.
</p>

<hr>
<h2 id='.cor_lagr_exp'>Calculate Lagrangian correlation of the exponential form</h2><span id='topic+.cor_lagr_exp'></span>

<h3>Description</h3>

<p>Calculate Lagrangian correlation of the exponential form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cor_lagr_exp(v1, v2, k = 2, h1, h2, u)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".cor_lagr_exp_+3A_v1">v1</code></td>
<td>
<p>Prevailing wind, u-component.</p>
</td></tr>
<tr><td><code id=".cor_lagr_exp_+3A_v2">v2</code></td>
<td>
<p>Prevailing wind, v-component.</p>
</td></tr>
<tr><td><code id=".cor_lagr_exp_+3A_k">k</code></td>
<td>
<p>Scale parameter of <code class="reqn">\|\boldsymbol v\|</code>, <code class="reqn">k&gt;0</code>. Default is 2.</p>
</td></tr>
<tr><td><code id=".cor_lagr_exp_+3A_h1">h1</code></td>
<td>
<p>Horizontal distance matrix or array.</p>
</td></tr>
<tr><td><code id=".cor_lagr_exp_+3A_h2">h2</code></td>
<td>
<p>Vertical distance matrix or array, same dimension as <code>h1</code>.</p>
</td></tr>
<tr><td><code id=".cor_lagr_exp_+3A_u">u</code></td>
<td>
<p>Time lag, same dimension as <code>h1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Lagrangian correlation function of the exponential form with parameters
<code class="reqn">\boldsymbol v = (v_1, v_2)^\top\in\mathbb{R}^2</code> has the form
</p>
<p style="text-align: center;"><code class="reqn">C(\mathbf{h}, u)=\exp\left(-\dfrac{1}{k\|\boldsymbol v\|}
\left\|\mathbf{h}-u\boldsymbol v\right\|\right),</code>
</p>

<p>where <code class="reqn">\|\cdot\|</code> is the Euclidean distance,
<code class="reqn">\mathbf{h} = (\mathrm{h}_1, \mathrm{h}_2)^\top\in\mathbb{R}^2</code>,
and <code class="reqn">k &gt; 0</code> is the scale parameter controlling the magnitude of
asymmetry in correlation.
</p>


<h3>Value</h3>

<p>Correlations of the same dimension as <code>h1</code>.
</p>


<h3>References</h3>

<p>Diggle, P. J., Tawn, J. A., &amp; Moyeed, R. A. (1998). Model-Based
Geostatistics. Journal of the Royal Statistical Society. Series C (Applied
Statistics), 47(3), 299–350.
</p>

<hr>
<h2 id='.cor_lagr_tri'>Calculate Lagrangian correlation of the triangular form</h2><span id='topic+.cor_lagr_tri'></span>

<h3>Description</h3>

<p>Calculate Lagrangian correlation of the triangular form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cor_lagr_tri(v1, v2, k = 2, h1, h2, u)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".cor_lagr_tri_+3A_v1">v1</code></td>
<td>
<p>Prevailing wind, u-component.</p>
</td></tr>
<tr><td><code id=".cor_lagr_tri_+3A_v2">v2</code></td>
<td>
<p>Prevailing wind, v-component.</p>
</td></tr>
<tr><td><code id=".cor_lagr_tri_+3A_k">k</code></td>
<td>
<p>Scale parameter of <code class="reqn">\|\boldsymbol v\|</code>, <code class="reqn">k&gt;0</code>. Default is 2.</p>
</td></tr>
<tr><td><code id=".cor_lagr_tri_+3A_h1">h1</code></td>
<td>
<p>Horizontal distance matrix or array.</p>
</td></tr>
<tr><td><code id=".cor_lagr_tri_+3A_h2">h2</code></td>
<td>
<p>Vertical distance matrix or array, same dimension as <code>h1</code>.</p>
</td></tr>
<tr><td><code id=".cor_lagr_tri_+3A_u">u</code></td>
<td>
<p>Time lag, same dimension as <code>h1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Lagrangian correlation function of the triangular form with parameters
<code class="reqn">\boldsymbol v = (v_1, v_2)^\top\in\mathbb{R}^2</code> has the form
</p>
<p style="text-align: center;"><code class="reqn">C(\mathbf{h}, u)=\left(1-\dfrac{1}{k\|\boldsymbol v\|}
\left|\dfrac{\mathbf{h}^\top\boldsymbol v}{\|\boldsymbol v\|}-
u\|\boldsymbol v\|\right|\right)_+,</code>
</p>

<p>where <code class="reqn">\|\cdot\|</code> is the Euclidean distance, <code class="reqn">x_+=\max(x,0),
\mathbf{h} = (\mathrm{h}_1, \mathrm{h}_2)^\top\in\mathbb{R}^2</code>,
and <code class="reqn">k &gt; 0</code> is the scale parameter controlling the magnitude of
asymmetry in correlation.
</p>


<h3>Value</h3>

<p>Correlations of the same dimension as <code>h1</code>.
</p>

<hr>
<h2 id='.cor_sep'>Calculate correlation for separable model</h2><span id='topic+.cor_sep'></span>

<h3>Description</h3>

<p>Calculate correlation for separable model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cor_sep(spatial, temporal, par_s, par_t)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".cor_sep_+3A_spatial">spatial</code></td>
<td>
<p>Pure spatial model, <code>exp</code> or <code>cauchy</code> for now.</p>
</td></tr>
<tr><td><code id=".cor_sep_+3A_temporal">temporal</code></td>
<td>
<p>Pure temporal model, <code>exp</code> or <code>cauchy</code> for now.</p>
</td></tr>
<tr><td><code id=".cor_sep_+3A_par_s">par_s</code></td>
<td>
<p>Parameters for the pure spatial model. Nugget effect supported.</p>
</td></tr>
<tr><td><code id=".cor_sep_+3A_par_t">par_t</code></td>
<td>
<p>Parameters for the pure temporal model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The separable model is the product of a pure temporal model, <code class="reqn">C_T(u)</code>,
and a pure spatial model, <code class="reqn">C_S(\mathbf{h})</code>. It is of the form
</p>
<p style="text-align: center;"><code class="reqn">C(\mathbf{h}, u)=C_{T}(u)
\left[(1-\text{nugget})C_{S}(\mathbf{h})+\text{nugget}
\delta_{\mathbf{h}=0}\right],</code>
</p>

<p>where <code class="reqn">\delta_{x=0}</code> is 1 when <code class="reqn">x=0</code> and 0 otherwise. Here
<code class="reqn">\mathbf{h}\in\mathbb{R}^2</code> and <code class="reqn">u\in\mathbb{R}</code>. Now only
exponential and Cauchy correlation models are available.
</p>


<h3>Value</h3>

<p>Correlations for separable model.
</p>


<h3>References</h3>

<p>Gneiting, T. (2002). Nonseparable, Stationary Covariance Functions for
Space–Time Data, Journal of the American Statistical Association, 97:458,
590-600.
</p>

<hr>
<h2 id='.cor_stat'>Calculate general stationary correlation.</h2><span id='topic+.cor_stat'></span>

<h3>Description</h3>

<p>Calculate general stationary correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cor_stat(base, lagrangian, par_base, par_lagr, lambda, base_fixed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".cor_stat_+3A_base">base</code></td>
<td>
<p>Base model, <code>sep</code> or <code>fs</code> for now. Or correlation matrix/array.</p>
</td></tr>
<tr><td><code id=".cor_stat_+3A_lagrangian">lagrangian</code></td>
<td>
<p>Lagrangian model, <code>none</code>, <code>lagr_tri</code>, or <code>lagr_askey</code>.</p>
</td></tr>
<tr><td><code id=".cor_stat_+3A_par_base">par_base</code></td>
<td>
<p>Parameters for the base model (symmetric), used only when
<code>base_fixed = FALSE</code>.</p>
</td></tr>
<tr><td><code id=".cor_stat_+3A_par_lagr">par_lagr</code></td>
<td>
<p>Parameters for the Lagrangian model. Used only when
<code>lagrangian</code> is not <code>none</code>.</p>
</td></tr>
<tr><td><code id=".cor_stat_+3A_lambda">lambda</code></td>
<td>
<p>Weight of the Lagrangian term, <code class="reqn">\lambda\in[0, 1]</code>.</p>
</td></tr>
<tr><td><code id=".cor_stat_+3A_base_fixed">base_fixed</code></td>
<td>
<p>Logical; if TRUE, <code>base</code> is the correlation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The general station model, a convex combination of a base model
and a Lagrangian model, has the form
</p>
<p style="text-align: center;"><code class="reqn">C(\mathbf{h}, u)=(1-\lambda)C_{\text{Base}}(\mathbf{h}, u)+
\lambda C_{\text{Lagr}}(\mathbf{h}, u),</code>
</p>

<p>where <code class="reqn">\lambda</code> is the weight of the Lagrangian term.
</p>
<p>If <code>base_fixed = TRUE</code>, the correlation is of the form
</p>
<p style="text-align: center;"><code class="reqn">C(\mathbf{h}, u)=(1-\lambda)C_{\text{Base}}+
\lambda C_{\text{Lagr}}(\mathbf{h}, u),</code>
</p>

<p>where <code>base</code> is a correlation matrix/array and <code>par_base</code> and <code>h</code> are not
used.
</p>
<p>When <code>lagrangian = "none"</code>, <code>lambda</code> must be 0.
</p>


<h3>Value</h3>

<p>Correlations for the general stationary model. Same dimension of
<code>base</code> if <code>base_fixed = FALSE</code>.
</p>


<h3>References</h3>

<p>Gneiting, T., Genton, M., &amp; Guttorp, P. (2006). Geostatistical Space-Time
Models, Stationarity, Separability, and Full Symmetry. In C&amp;H/CRC
Monographs on Statistics &amp; Applied Probability (pp. 151–175).
Chapman and Hall/CRC.
</p>

<hr>
<h2 id='.find_dists'>Calculate (signed) distances between coordinates</h2><span id='topic+.find_dists'></span>

<h3>Description</h3>

<p>Calculate (signed) distances between coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.find_dists(
  grid,
  names = NULL,
  longlat = TRUE,
  origin = 1L,
  return_grid = FALSE,
  lon_ref,
  lat_ref
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".find_dists_+3A_grid">grid</code></td>
<td>
<p>A matrix of 2D points, first column x/longitude, second column
y/latitude.</p>
</td></tr>
<tr><td><code id=".find_dists_+3A_names">names</code></td>
<td>
<p>Names of locations.</p>
</td></tr>
<tr><td><code id=".find_dists_+3A_longlat">longlat</code></td>
<td>
<p>Logical, if TURE Great Circle (WGS84 ellipsoid) distance;
if FALSE, Euclidean distance.</p>
</td></tr>
<tr><td><code id=".find_dists_+3A_origin">origin</code></td>
<td>
<p>Optional; used when <code>longlat</code> is TRUE. An integer index
indicating the reference location which will be used as the origin.</p>
</td></tr>
<tr><td><code id=".find_dists_+3A_return_grid">return_grid</code></td>
<td>
<p>Logical; used when <code>longlat</code> is TRUE. If TRUE the mapped
coordinates on a 2D plane is returned.</p>
</td></tr>
<tr><td><code id=".find_dists_+3A_lon_ref">lon_ref</code></td>
<td>
<p>Reference longitude when computing the longitudinal distances.
Default is the mean of longitudes in <code>grid</code>.</p>
</td></tr>
<tr><td><code id=".find_dists_+3A_lat_ref">lat_ref</code></td>
<td>
<p>Reference latitude when computing the latitudinal distances.
Default is the mean of latitudes in <code>grid</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of signed distances.
</p>

<hr>
<h2 id='.find_dists_new'>Calculate (signed) distances between coordinates</h2><span id='topic+.find_dists_new'></span>

<h3>Description</h3>

<p>Calculate (signed) distances between coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.find_dists_new(
  grid,
  grid_new,
  names = NULL,
  names_new = NULL,
  longlat = TRUE,
  origin = 1L,
  return_grid = FALSE,
  lon_ref,
  lat_ref
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".find_dists_new_+3A_grid">grid</code></td>
<td>
<p>A matrix of 2D points, first column x/longitude, second column
y/latitude.</p>
</td></tr>
<tr><td><code id=".find_dists_new_+3A_grid_new">grid_new</code></td>
<td>
<p>A matrix of 2D points, first column x/longitude, second column
y/latitude.</p>
</td></tr>
<tr><td><code id=".find_dists_new_+3A_names">names</code></td>
<td>
<p>Names of locations.</p>
</td></tr>
<tr><td><code id=".find_dists_new_+3A_names_new">names_new</code></td>
<td>
<p>Names of new locations.</p>
</td></tr>
<tr><td><code id=".find_dists_new_+3A_longlat">longlat</code></td>
<td>
<p>Logical, if TURE Great Circle (WGS84 ellipsoid) distance;
if FALSE, Euclidean distance.</p>
</td></tr>
<tr><td><code id=".find_dists_new_+3A_origin">origin</code></td>
<td>
<p>Optional; used when <code>longlat</code> is TRUE. An integer index
indicating the reference location which will be used as the origin.</p>
</td></tr>
<tr><td><code id=".find_dists_new_+3A_return_grid">return_grid</code></td>
<td>
<p>Logical; used when <code>longlat</code> is TRUE. If TRUE the mapped
coordinates on a 2D plane is returned.</p>
</td></tr>
<tr><td><code id=".find_dists_new_+3A_lon_ref">lon_ref</code></td>
<td>
<p>Reference longitude when computing the longitudinal distances.
Default is the mean of longitudes in <code>grid</code>.</p>
</td></tr>
<tr><td><code id=".find_dists_new_+3A_lat_ref">lat_ref</code></td>
<td>
<p>Reference latitude when computing the latitudinal distances.
Default is the mean of latitudes in <code>grid</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of signed distances between the new locations and the old grid.
</p>

<hr>
<h2 id='.mcgf_rs_sim'>Simulate regime-switching Markov chain Gaussian field</h2><span id='topic+.mcgf_rs_sim'></span>

<h3>Description</h3>

<p>Simulate regime-switching Markov chain Gaussian field
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.mcgf_rs_sim(
  N,
  label,
  base_ls,
  lagrangian_ls,
  par_base_ls,
  par_lagr_ls,
  lambda_ls,
  dists_ls,
  sd_ls,
  lag_ls,
  scale_time = 1,
  init = 0,
  mu_c_ls,
  mu_p_ls,
  return_all = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".mcgf_rs_sim_+3A_n">N</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id=".mcgf_rs_sim_+3A_label">label</code></td>
<td>
<p>Vector of regime labels of the same length as <code>N</code>.</p>
</td></tr>
<tr><td><code id=".mcgf_rs_sim_+3A_base_ls">base_ls</code></td>
<td>
<p>List of base model, <code>sep</code> or <code>fs</code> for now.</p>
</td></tr>
<tr><td><code id=".mcgf_rs_sim_+3A_lagrangian_ls">lagrangian_ls</code></td>
<td>
<p>List of Lagrangian model, &quot;none&quot; or <code>lagr_tri</code> for now.</p>
</td></tr>
<tr><td><code id=".mcgf_rs_sim_+3A_par_base_ls">par_base_ls</code></td>
<td>
<p>List of parameters for the base model.</p>
</td></tr>
<tr><td><code id=".mcgf_rs_sim_+3A_par_lagr_ls">par_lagr_ls</code></td>
<td>
<p>List of parameters for the Lagrangian model.</p>
</td></tr>
<tr><td><code id=".mcgf_rs_sim_+3A_lambda_ls">lambda_ls</code></td>
<td>
<p>List of weight of the Lagrangian term,
<code class="reqn">\lambda\in[0, 1]</code>.</p>
</td></tr>
<tr><td><code id=".mcgf_rs_sim_+3A_dists_ls">dists_ls</code></td>
<td>
<p>List of distance matrices or arrays.</p>
</td></tr>
<tr><td><code id=".mcgf_rs_sim_+3A_sd_ls">sd_ls</code></td>
<td>
<p>List of standard deviation for each location.</p>
</td></tr>
<tr><td><code id=".mcgf_rs_sim_+3A_lag_ls">lag_ls</code></td>
<td>
<p>List of time lags.</p>
</td></tr>
<tr><td><code id=".mcgf_rs_sim_+3A_scale_time">scale_time</code></td>
<td>
<p>Scale of time unit, default is 1. Elements in <code>lag_ls</code> are
divided by <code>scale_time</code>.</p>
</td></tr>
<tr><td><code id=".mcgf_rs_sim_+3A_init">init</code></td>
<td>
<p>Initial samples, default is 0.</p>
</td></tr>
<tr><td><code id=".mcgf_rs_sim_+3A_mu_c_ls">mu_c_ls</code>, <code id=".mcgf_rs_sim_+3A_mu_p_ls">mu_p_ls</code></td>
<td>
<p>List of means of current and past.</p>
</td></tr>
<tr><td><code id=".mcgf_rs_sim_+3A_return_all">return_all</code></td>
<td>
<p>Logical; if TRUE the joint covariance matrix, arrays of
distances and time lag are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simulated regime-switching Markov chain Gaussian field with
user-specified covariance structures. The simulation is done by kriging.
The output data is in space-wide format. Each element in <code>dists_ls</code> must
contain <code>h</code> for symmetric models, and <code>h1</code> and <code>h2</code> for general stationary
models. <code>init</code> can be a scalar or a vector of appropriate size.
List elements in <code>sd_ls</code>, <code>mu_c_ls</code>, and <code>mu_p_ls</code> must be vectors of
appropriate sizes.
</p>

<hr>
<h2 id='.mcgf_sim'>Simulate Markov chain Gaussian field</h2><span id='topic+.mcgf_sim'></span>

<h3>Description</h3>

<p>Simulate Markov chain Gaussian field
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.mcgf_sim(
  N,
  base,
  lagrangian,
  par_base,
  par_lagr,
  lambda,
  dists,
  sd,
  lag,
  scale_time = 1,
  horizon = 1,
  init = 0,
  mu_c,
  mu_p,
  return_all = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".mcgf_sim_+3A_n">N</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id=".mcgf_sim_+3A_base">base</code></td>
<td>
<p>Base model, <code>sep</code> or <code>fs</code> for now.</p>
</td></tr>
<tr><td><code id=".mcgf_sim_+3A_lagrangian">lagrangian</code></td>
<td>
<p>Lagrangian model, &quot;none&quot; or <code>lagr_tri</code> for now.</p>
</td></tr>
<tr><td><code id=".mcgf_sim_+3A_par_base">par_base</code></td>
<td>
<p>Parameters for the base model (symmetric).</p>
</td></tr>
<tr><td><code id=".mcgf_sim_+3A_par_lagr">par_lagr</code></td>
<td>
<p>Parameters for the Lagrangian model.</p>
</td></tr>
<tr><td><code id=".mcgf_sim_+3A_lambda">lambda</code></td>
<td>
<p>Weight of the Lagrangian term, <code class="reqn">\lambda\in[0, 1]</code>.</p>
</td></tr>
<tr><td><code id=".mcgf_sim_+3A_dists">dists</code></td>
<td>
<p>Distance matrices or arrays.</p>
</td></tr>
<tr><td><code id=".mcgf_sim_+3A_sd">sd</code></td>
<td>
<p>Standard deviation for each location.</p>
</td></tr>
<tr><td><code id=".mcgf_sim_+3A_lag">lag</code></td>
<td>
<p>Time lag.</p>
</td></tr>
<tr><td><code id=".mcgf_sim_+3A_scale_time">scale_time</code></td>
<td>
<p>Scale of time unit, default is 1. <code>lag</code> is divided by
<code>scale_time</code>.</p>
</td></tr>
<tr><td><code id=".mcgf_sim_+3A_horizon">horizon</code></td>
<td>
<p>Forecast horizon, default is 1.</p>
</td></tr>
<tr><td><code id=".mcgf_sim_+3A_init">init</code></td>
<td>
<p>Initial samples, default is 0.</p>
</td></tr>
<tr><td><code id=".mcgf_sim_+3A_mu_c">mu_c</code>, <code id=".mcgf_sim_+3A_mu_p">mu_p</code></td>
<td>
<p>Means of current and past.</p>
</td></tr>
<tr><td><code id=".mcgf_sim_+3A_return_all">return_all</code></td>
<td>
<p>Logical; if TRUE the joint covariance matrix, arrays of
distances and time lag are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simulated Markov chain Gaussian field with user-specified covariance
structure. The simulation is done by kriging. The output data is in
space-wide format. <code>dists</code> must contain <code>h</code> for symmetric models, and <code>h1</code>
and <code>h2</code> for general stationary models. <code>horizon</code> controls forecasting
horizon. <code>sd</code>, <code>mu_c</code>, <code>mu_p</code>, and <code>init</code> must be vectors of appropriate
sizes.
</p>

<hr>
<h2 id='acf_rs'>Calculate regime-switching auto-correlation</h2><span id='topic+acf_rs'></span>

<h3>Description</h3>

<p>Calculate regime-switching auto-correlation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acf_rs(x, label, lag_max, demean = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acf_rs_+3A_x">x</code></td>
<td>
<p>A univariate numeric time series.</p>
</td></tr>
<tr><td><code id="acf_rs_+3A_label">label</code></td>
<td>
<p>A factor of regime labels.</p>
</td></tr>
<tr><td><code id="acf_rs_+3A_lag_max">lag_max</code></td>
<td>
<p>Maximum lag at which to calculate the acf.</p>
</td></tr>
<tr><td><code id="acf_rs_+3A_demean">demean</code></td>
<td>
<p>Logical. Should the covariances be about the sample means?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mean auto-correlations for each group in <code>label</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- rnorm(100)
label &lt;- sample(1:2, 100, replace = TRUE)
acf_rs(x, label = factor(label), lag_max = 3)
</code></pre>

<hr>
<h2 id='acfs'>Generic function for calculating autocorrelation</h2><span id='topic+acfs'></span>

<h3>Description</h3>

<p>Generic function for calculating autocorrelation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acfs(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acfs_+3A_x">x</code></td>
<td>
<p>An <strong>R</strong> object.</p>
</td></tr>
<tr><td><code id="acfs_+3A_...">...</code></td>
<td>
<p>Additional parameters or attributes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Refer to <code><a href="#topic+acfs.mcgf">acfs.mcgf()</a></code> and <code><a href="#topic+acfs.mcgf_rs">acfs.mcgf_rs()</a></code> for more details.
</p>


<h3>Value</h3>

<p>A vector of mean auto-correlations for <code>mcgf</code> objects, or that plus
a list of regime-switching mean auto-correlations for <code>mcgf_rs</code> objects.
</p>

<hr>
<h2 id='acfs.mcgf'>Extract, calculate, or assign mean auto-correlations for an <code>mcgf</code> or
<code>mcgf_rs</code> object</h2><span id='topic+acfs.mcgf'></span><span id='topic+acfs.mcgf_rs'></span><span id='topic+acfs+3C-'></span><span id='topic+add_acfs'></span>

<h3>Description</h3>

<p>Extract, calculate, or assign mean auto-correlations for an <code>mcgf</code> or
<code>mcgf_rs</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcgf'
acfs(x, lag_max, replace = FALSE, ...)

## S3 method for class 'mcgf_rs'
acfs(x, lag_max, replace = FALSE, ...)

acfs(x) &lt;- value

add_acfs(x, lag_max, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acfs.mcgf_+3A_x">x</code></td>
<td>
<p>An <code>mcgf</code> or <code>mcgf_rs</code> object.</p>
</td></tr>
<tr><td><code id="acfs.mcgf_+3A_lag_max">lag_max</code></td>
<td>
<p>Maximum lag at which to calculate the acf.</p>
</td></tr>
<tr><td><code id="acfs.mcgf_+3A_replace">replace</code></td>
<td>
<p>Logical; if TRUE, <code>acfs</code> are recalculated.</p>
</td></tr>
<tr><td><code id="acfs.mcgf_+3A_...">...</code></td>
<td>
<p>Additional parameters or attributes.</p>
</td></tr>
<tr><td><code id="acfs.mcgf_+3A_value">value</code></td>
<td>
<p>A Vector of mean of auto-correlations for time lags starting
from 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>mcgf</code> objects, <code><a href="#topic+acfs">acfs()</a></code> computes mean auto-correlations for each time
lag across locations. The output is a vector of acfs.
</p>
<p>For <code>mcgf_rs</code> objects, <code><a href="#topic+acfs">acfs()</a></code> computes regime-switching mean
auto-correlations for each time lag across locations. The output is a list of
vectors of acfs, where each vector in the list corresponds to the acfs for
a regime.
</p>
<p><code><a href="#topic+acfs+3C-">acfs&lt;-</a></code> assigns <code>acfs</code> to <code>x</code>.
</p>
<p><code><a href="#topic+add_acfs">add_acfs()</a></code> adds <code>acfs</code> to <code>x</code>.
</p>


<h3>Value</h3>

<p><code><a href="#topic+acfs">acfs()</a></code> returns (regime-switching) mean auto-correlations.
<code><a href="#topic+add_acfs">add_acfs()</a></code> returns the same object with additional attributes of
(regime-switching) mean auto-correlations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate acfs for 'sim1'
data(sim1)
sim1_mcgf &lt;- mcgf(sim1$data, dists = sim1$dists)
acfs(sim1_mcgf, lag_max = 5)

# Add acfs to 'sim1_mcgf'
sim1_mcgf &lt;- add_acfs(sim1_mcgf, lag_max = 5)
print(sim1_mcgf, "acfs")

# Calculate acfs for 'sim2'
data(sim2)
sim2_mcgf &lt;- mcgf_rs(sim2$data, dists = sim2$dists, label = sim2$label)
acfs(sim2_mcgf, lag_max = 5)

# Add acfs to 'sim2_mcgf'
sim2_mcgf &lt;- add_acfs(sim2_mcgf, lag_max = 5)
print(sim2_mcgf, "acfs")
</code></pre>

<hr>
<h2 id='add_base'>Generic function for adding a base model</h2><span id='topic+add_base'></span>

<h3>Description</h3>

<p>Generic function for adding a base model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_base(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_base_+3A_x">x</code></td>
<td>
<p>An <strong>R</strong> object.</p>
</td></tr>
<tr><td><code id="add_base_+3A_...">...</code></td>
<td>
<p>Additional parameters or attributes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Refer to <code><a href="#topic+add_base.mcgf">add_base.mcgf()</a></code> and <code><a href="#topic+add_base.mcgf_rs">add_base.mcgf_rs()</a></code> for more details.
</p>


<h3>Value</h3>

<p><code>x</code> with the newly added base model.
</p>

<hr>
<h2 id='add_base.mcgf'>Add base model outputted from <code><a href="#topic+fit_base">fit_base()</a></code> to an <code>mcgf</code> object.</h2><span id='topic+add_base.mcgf'></span><span id='topic+base+3C-'></span>

<h3>Description</h3>

<p>Add base model outputted from <code><a href="#topic+fit_base">fit_base()</a></code> to an <code>mcgf</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcgf'
add_base(x, fit_base, fit_s, fit_t, sep = FALSE, old = FALSE, ...)

base(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_base.mcgf_+3A_x">x</code></td>
<td>
<p>An <code>mcgf</code> object.</p>
</td></tr>
<tr><td><code id="add_base.mcgf_+3A_fit_base">fit_base</code></td>
<td>
<p>Output from the <code><a href="#topic+fit_base">fit_base()</a></code> function.</p>
</td></tr>
<tr><td><code id="add_base.mcgf_+3A_fit_s">fit_s</code></td>
<td>
<p>Pure spatial model outputted from the <code><a href="#topic+fit_base">fit_base()</a></code> function.
Used only when <code>sep = TRUE</code>.</p>
</td></tr>
<tr><td><code id="add_base.mcgf_+3A_fit_t">fit_t</code></td>
<td>
<p>Pure temporal model outputted from the <code><a href="#topic+fit_base">fit_base()</a></code> function.
Used only when <code>sep = TRUE</code>.</p>
</td></tr>
<tr><td><code id="add_base.mcgf_+3A_sep">sep</code></td>
<td>
<p>Logical; TRUE if spatial and temporal models are fitted
separately.</p>
</td></tr>
<tr><td><code id="add_base.mcgf_+3A_old">old</code></td>
<td>
<p>Logical; TRUE if the old base model needs to be kept.</p>
</td></tr>
<tr><td><code id="add_base.mcgf_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not in use.</p>
</td></tr>
<tr><td><code id="add_base.mcgf_+3A_value">value</code></td>
<td>
<p>A list containing the base model as well as its parameters. It
must contains the same output as <code><a href="#topic+add_base.mcgf">add_base.mcgf()</a></code> or
<code><a href="#topic+add_base.mcgf_rs">add_base.mcgf_rs()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After fitting the base model by <code><a href="#topic+fit_base">fit_base()</a></code>, the results can be added to
<code>x</code> by <code><a href="#topic+add_base">add_base()</a></code>. To supply the base model directly, use <code><a href="#topic+base+3C-">base&lt;-</a></code> to
add the base model; the value must contain <code>model</code>, <code>par_base</code>, <code>cor_base</code>,
<code>lag</code>, and <code>horizon</code>.
</p>


<h3>Value</h3>

<p><code>x</code> with newly added attributes of the base model.
</p>


<h3>See Also</h3>

<p>Other functions on fitting an mcgf: 
<code><a href="#topic+add_lagr.mcgf">add_lagr.mcgf</a>()</code>,
<code><a href="#topic+fit_base.mcgf">fit_base.mcgf</a>()</code>,
<code><a href="#topic+fit_lagr.mcgf">fit_lagr.mcgf</a>()</code>,
<code><a href="#topic+krige.mcgf">krige.mcgf</a>()</code>,
<code><a href="#topic+krige_new.mcgf">krige_new.mcgf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim1)
sim1_mcgf &lt;- mcgf(sim1$data, dists = sim1$dists)
sim1_mcgf &lt;- add_acfs(sim1_mcgf, lag_max = 5)
sim1_mcgf &lt;- add_ccfs(sim1_mcgf, lag_max = 5)

# Fit a pure spatial model
fit_spatial &lt;- fit_base(
    sim1_mcgf,
    model = "spatial",
    lag = 5,
    par_init = c(c = 0.001, gamma = 0.5),
    par_fixed = c(nugget = 0)
)
# Fit a pure temporal model
fit_temporal &lt;- fit_base(
    sim1_mcgf,
    model = "temporal",
    lag = 5,
    par_init = c(a = 0.3, alpha = 0.5)
)

# Store the fitted models to 'sim1_mcgf'
sim1_mcgf &lt;-
    add_base(sim1_mcgf,
        fit_s = fit_spatial,
        fit_t = fit_temporal,
        sep = TRUE
    )

# Fit a separable model
fit_sep &lt;- fit_base(
    sim1_mcgf,
    model = "sep",
    lag = 5,
    par_init = c(
        c = 0.001,
        gamma = 0.5,
        a = 0.3,
        alpha = 0.5
    ),
    par_fixed = c(nugget = 0)
)
# Store the newly fitted model, and keep the old fit
sim1_mcgf &lt;- add_base(sim1_mcgf, fit_base = fit_sep, old = TRUE)
model(sim1_mcgf, model = "base", old = TRUE)
</code></pre>

<hr>
<h2 id='add_base.mcgf_rs'>Add base model outputted from <code><a href="#topic+fit_base">fit_base()</a></code> to an <code>mcgf_rs</code> object.</h2><span id='topic+add_base.mcgf_rs'></span>

<h3>Description</h3>

<p>Add base model outputted from <code><a href="#topic+fit_base">fit_base()</a></code> to an <code>mcgf_rs</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcgf_rs'
add_base(x, fit_base_ls, fit_s_ls, fit_t_ls, sep = FALSE, old = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_base.mcgf_rs_+3A_x">x</code></td>
<td>
<p>An mcgf_rs' object.</p>
</td></tr>
<tr><td><code id="add_base.mcgf_rs_+3A_fit_base_ls">fit_base_ls</code></td>
<td>
<p>Output from the <code><a href="#topic+fit_base">fit_base()</a></code> function.</p>
</td></tr>
<tr><td><code id="add_base.mcgf_rs_+3A_fit_s_ls">fit_s_ls</code></td>
<td>
<p>Pure spatial model outputted from the <code><a href="#topic+fit_base">fit_base()</a></code> function.
Used only when <code>sep = TRUE</code>.</p>
</td></tr>
<tr><td><code id="add_base.mcgf_rs_+3A_fit_t_ls">fit_t_ls</code></td>
<td>
<p>Pure temporal model outputted from the <code><a href="#topic+fit_base">fit_base()</a></code>
function. Used only when <code>sep = TRUE</code>.</p>
</td></tr>
<tr><td><code id="add_base.mcgf_rs_+3A_sep">sep</code></td>
<td>
<p>Logical; TRUE if spatial and temporal models are fitted
separately.</p>
</td></tr>
<tr><td><code id="add_base.mcgf_rs_+3A_old">old</code></td>
<td>
<p>Logical; TRUE if the old base model needs to be kept. The lag and
horizon of the new model are assumed to be the same as that of the old model.</p>
</td></tr>
<tr><td><code id="add_base.mcgf_rs_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not in use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After fitting the base model by <code><a href="#topic+fit_base">fit_base()</a></code>, the results can be added to
<code>x</code> by <code><a href="#topic+add_base">add_base()</a></code>. To supply the base model directly, use <code><a href="#topic+base+3C-">base&lt;-</a></code> to
add the base model; the value must contain the same output as
<code><a href="#topic+add_base.mcgf">add_base.mcgf()</a></code> or <code><a href="#topic+add_base.mcgf_rs">add_base.mcgf_rs()</a></code>.
</p>


<h3>Value</h3>

<p><code>x</code> with newly added attributes of the base model.
</p>


<h3>See Also</h3>

<p>Other functions on fitting an mcgf_rs: 
<code><a href="#topic+add_lagr.mcgf_rs">add_lagr.mcgf_rs</a>()</code>,
<code><a href="#topic+fit_base.mcgf_rs">fit_base.mcgf_rs</a>()</code>,
<code><a href="#topic+fit_lagr.mcgf_rs">fit_lagr.mcgf_rs</a>()</code>,
<code><a href="#topic+krige.mcgf_rs">krige.mcgf_rs</a>()</code>,
<code><a href="#topic+krige_new.mcgf_rs">krige_new.mcgf_rs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim2)
sim2_mcgf &lt;- mcgf_rs(sim2$data, dists = sim2$dists, label = sim2$label)
sim2_mcgf &lt;- add_acfs(sim2_mcgf, lag_max = 5)
sim2_mcgf &lt;- add_ccfs(sim2_mcgf, lag_max = 5)

# Fit a regime-switching pure spatial model
fit_spatial &lt;-
    fit_base(
        sim2_mcgf,
        lag_ls = 5,
        model_ls = "spatial",
        par_init_ls = list(c(c = 0.00005, gamma = 0.5)),
        par_fixed_ls = list(c(nugget = 0))
    )

# Fit a regime-switching pure temporal model
fit_temporal &lt;-
    fit_base(
        sim2_mcgf,
        lag_ls = 5,
        model_ls = "temporal",
        par_init_ls = list(
            list(a = 0.8, alpha = 0.8),
            list(a = 0.1, alpha = 0.1)
        )
    )

# Store the fitted models to 'sim2_mcgf'
sim2_mcgf &lt;- add_base(sim2_mcgf,
    fit_s_ls = fit_spatial,
    fit_t_ls = fit_temporal,
    sep = TRUE
)

# Fit a regime-switching separable model
fit_sep &lt;- fit_base(
    sim2_mcgf,
    lag_ls = 5,
    model_ls = "sep",
    par_init_ls = list(list(
        c = 0.00005,
        gamma = 0.5,
        a = 0.5,
        alpha = 0.5
    )),
    par_fixed_ls = list(c(nugget = 0))
)

# Store the newly fitted model, and keep the old fit
sim2_mcgf &lt;- add_base(sim2_mcgf, fit_base_ls = fit_sep, old = TRUE)
model(sim2_mcgf, model = "base", old = TRUE)
</code></pre>

<hr>
<h2 id='add_lagr'>Generic function for adding a Lagrangian model</h2><span id='topic+add_lagr'></span>

<h3>Description</h3>

<p>Generic function for adding a Lagrangian model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_lagr(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_lagr_+3A_x">x</code></td>
<td>
<p>An <strong>R</strong> object.</p>
</td></tr>
<tr><td><code id="add_lagr_+3A_...">...</code></td>
<td>
<p>Additional parameters or attributes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Refer to <code><a href="#topic+add_lagr.mcgf">add_lagr.mcgf()</a></code> and <code><a href="#topic+add_lagr.mcgf_rs">add_lagr.mcgf_rs()</a></code> for more details.
</p>


<h3>Value</h3>

<p><code>x</code> with the newly added Lagrangian model.
</p>

<hr>
<h2 id='add_lagr.mcgf'>Add lagr model outputted from <code><a href="#topic+fit_lagr">fit_lagr()</a></code> to a <code>mcgf</code> object.</h2><span id='topic+add_lagr.mcgf'></span><span id='topic+lagr+3C-'></span>

<h3>Description</h3>

<p>Add lagr model outputted from <code><a href="#topic+fit_lagr">fit_lagr()</a></code> to a <code>mcgf</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcgf'
add_lagr(x, fit_lagr, ...)

lagr(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_lagr.mcgf_+3A_x">x</code></td>
<td>
<p>An <code>mcgf</code> object.</p>
</td></tr>
<tr><td><code id="add_lagr.mcgf_+3A_fit_lagr">fit_lagr</code></td>
<td>
<p>Output from the <code><a href="#topic+fit_lagr">fit_lagr()</a></code> function.</p>
</td></tr>
<tr><td><code id="add_lagr.mcgf_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not in use.</p>
</td></tr>
<tr><td><code id="add_lagr.mcgf_+3A_value">value</code></td>
<td>
<p>A list containing the lagr model as well as its parameters. It
must contains <code>model</code>, <code>par_lagr</code>, and <code>cor_lagr</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> with newly added attributes of the Lagrangian model.
</p>


<h3>See Also</h3>

<p>Other functions on fitting an mcgf: 
<code><a href="#topic+add_base.mcgf">add_base.mcgf</a>()</code>,
<code><a href="#topic+fit_base.mcgf">fit_base.mcgf</a>()</code>,
<code><a href="#topic+fit_lagr.mcgf">fit_lagr.mcgf</a>()</code>,
<code><a href="#topic+krige.mcgf">krige.mcgf</a>()</code>,
<code><a href="#topic+krige_new.mcgf">krige_new.mcgf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim1)
sim1_mcgf &lt;- mcgf(sim1$data, dists = sim1$dists)
sim1_mcgf &lt;- add_acfs(sim1_mcgf, lag_max = 5)
sim1_mcgf &lt;- add_ccfs(sim1_mcgf, lag_max = 5)

# Fit a separable model and store it to 'sim1_mcgf'
fit_sep &lt;- fit_base(
    sim1_mcgf,
    model = "sep",
    lag = 5,
    par_init = c(
        c = 0.001,
        gamma = 0.5,
        a = 0.3,
        alpha = 0.5
    ),
    par_fixed = c(nugget = 0)
)
sim1_mcgf &lt;- add_base(sim1_mcgf, fit_base = fit_sep)

# Fit a Lagrangian model
fit_lagr &lt;- fit_lagr(
    sim1_mcgf,
    model = "lagr_tri",
    par_init = c(v1 = 300, v2 = 300, lambda = 0.15),
    par_fixed = c(k = 2)
)

# Store the fitted Lagrangian model to 'sim1_mcgf'
sim1_mcgf &lt;- add_lagr(sim1_mcgf, fit_lagr = fit_lagr)
model(sim1_mcgf, old = TRUE)
</code></pre>

<hr>
<h2 id='add_lagr.mcgf_rs'>Add lagr model outputted from <code><a href="#topic+fit_lagr">fit_lagr()</a></code> to a <code>mcgf_rs</code> object.</h2><span id='topic+add_lagr.mcgf_rs'></span>

<h3>Description</h3>

<p>Add lagr model outputted from <code><a href="#topic+fit_lagr">fit_lagr()</a></code> to a <code>mcgf_rs</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcgf_rs'
add_lagr(x, fit_lagr_ls, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_lagr.mcgf_rs_+3A_x">x</code></td>
<td>
<p>An <code>mcgf_rs</code> object.</p>
</td></tr>
<tr><td><code id="add_lagr.mcgf_rs_+3A_fit_lagr_ls">fit_lagr_ls</code></td>
<td>
<p>Output from the <code><a href="#topic+fit_lagr">fit_lagr()</a></code> function.</p>
</td></tr>
<tr><td><code id="add_lagr.mcgf_rs_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not in use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After fitting the Lagrangian model by <code><a href="#topic+fit_lagr">fit_lagr()</a></code>, the results can be
added to <code>x</code> by <code><a href="#topic+add_base">add_base()</a></code>. To supply the Lagrangian model directly,
use <code><a href="#topic+lagr+3C-">lagr&lt;-</a></code> to add the Lagrangian model; the value must contain the same
output as <code><a href="#topic+add_lagr.mcgf">add_lagr.mcgf()</a></code> or <code><a href="#topic+add_lagr.mcgf_rs">add_lagr.mcgf_rs()</a></code>.
</p>


<h3>Value</h3>

<p><code>x</code> with newly added attributes of the Lagrangian model.
</p>


<h3>See Also</h3>

<p>Other functions on fitting an mcgf_rs: 
<code><a href="#topic+add_base.mcgf_rs">add_base.mcgf_rs</a>()</code>,
<code><a href="#topic+fit_base.mcgf_rs">fit_base.mcgf_rs</a>()</code>,
<code><a href="#topic+fit_lagr.mcgf_rs">fit_lagr.mcgf_rs</a>()</code>,
<code><a href="#topic+krige.mcgf_rs">krige.mcgf_rs</a>()</code>,
<code><a href="#topic+krige_new.mcgf_rs">krige_new.mcgf_rs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim3)
sim3_mcgf &lt;- mcgf_rs(sim3$data, dists = sim3$dists, label = sim3$label)
sim3_mcgf &lt;- add_acfs(sim3_mcgf, lag_max = 5)
sim3_mcgf &lt;- add_ccfs(sim3_mcgf, lag_max = 5)

# Fit a fully symmetric model with known variables
fit_fs &lt;- fit_base(
    sim3_mcgf,
    lag_ls = 5,
    model_ls = "fs",
    rs = FALSE,
    par_init_ls = list(list(beta = 0)),
    par_fixed_ls = list(list(
        nugget = 0,
        c = 0.05,
        gamma = 0.5,
        a = 0.5,
        alpha = 0.2
    ))
)

# Set beta to 0 to fit a separable model with known variables
fit_fs[[1]]$fit$par &lt;- 0

# Store the fitted separable model to 'sim3_mcgf'
sim3_mcgf &lt;- add_base(sim3_mcgf, fit_base_ls = fit_fs)

# Fit a regime-switching Lagrangian model.
fit_lagr_rs &lt;- fit_lagr(
    sim3_mcgf,
    model_ls = list("lagr_tri"),
    par_init_ls = list(
        list(v1 = -50, v2 = 50),
        list(v1 = 100, v2 = 100)
    ),
    par_fixed_ls = list(list(lambda = 0.2, k = 2))
)

# Store the fitted Lagrangian model to 'sim3_mcgf'
sim3_mcgf &lt;- add_lagr(sim3_mcgf, fit_lagr_ls = fit_lagr_rs)
model(sim3_mcgf)
</code></pre>

<hr>
<h2 id='add_nugget'>Adjust for nugget effect for correlations</h2><span id='topic+add_nugget'></span><span id='topic+set_nugget'></span>

<h3>Description</h3>

<p>Adjust for nugget effect for correlations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_nugget(x, nugget)

set_nugget(x, nugget, set_to)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_nugget_+3A_x">x</code></td>
<td>
<p>A correlation matrix or 3-d array.</p>
</td></tr>
<tr><td><code id="add_nugget_+3A_nugget">nugget</code></td>
<td>
<p>A scalar nugget effect.</p>
</td></tr>
<tr><td><code id="add_nugget_+3A_set_to">set_to</code></td>
<td>
<p>A correlation matrix or 3-d array of the same dimension as <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To adjust spatial nugget effect, enery entry of <code>x</code> is first multipled by
by <code class="reqn">(1-\text{nugget})</code>; Then <code>add_nugget</code> adds <code>nugget</code> to the diagonals
(or the diagonals of each matrix slice) of <code>x</code>, and <code>set_nugget</code> set the
diagonals (or the diagonals of each matrix slice) to the corresponding
diagonals of <code>set_to</code>.
</p>


<h3>Value</h3>

<p>Correlations of the same dimension as <code>x</code>.
</p>

<hr>
<h2 id='ccf_rs'>Calculate regime-switching cross-correlation</h2><span id='topic+ccf_rs'></span>

<h3>Description</h3>

<p>Calculate regime-switching cross-correlation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ccf_rs(x, y, label, lag_max)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ccf_rs_+3A_x">x</code>, <code id="ccf_rs_+3A_y">y</code></td>
<td>
<p>A univariate numeric time series.</p>
</td></tr>
<tr><td><code id="ccf_rs_+3A_label">label</code></td>
<td>
<p>A factor of regime labels.</p>
</td></tr>
<tr><td><code id="ccf_rs_+3A_lag_max">lag_max</code></td>
<td>
<p>Maximum lag at which to calculate the ccf.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Cross-correlations for each group in <code>label</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- rnorm(100)
y &lt;- rnorm(100)
label &lt;- sample(1:2, 100, replace = TRUE)
ccf_rs(x, y, label = factor(label), lag_max = 3)
</code></pre>

<hr>
<h2 id='ccfs'>Generic function for calculating cross-correlation</h2><span id='topic+ccfs'></span>

<h3>Description</h3>

<p>Generic function for calculating cross-correlation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ccfs(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ccfs_+3A_x">x</code></td>
<td>
<p>An <strong>R</strong> object.</p>
</td></tr>
<tr><td><code id="ccfs_+3A_...">...</code></td>
<td>
<p>Additional parameters or attributes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Refer to <code><a href="#topic+ccfs.mcgf">ccfs.mcgf()</a></code> and <code><a href="#topic+ccfs.mcgf_rs">ccfs.mcgf_rs()</a></code> for more details.
</p>


<h3>Value</h3>

<p>An array of cross-correlations for <code>mcgf</code> objects, or that plus
a list of regime-switching cross-correlations for <code>mcgf_rs</code> objects.
</p>

<hr>
<h2 id='ccfs.mcgf'>Extract, calculate, or assign cross-correlations for an <code>mcgf</code> or <code>mcgf_rs</code>
object</h2><span id='topic+ccfs.mcgf'></span><span id='topic+ccfs.mcgf_rs'></span><span id='topic+ccfs+3C-'></span><span id='topic+add_ccfs'></span>

<h3>Description</h3>

<p>Extract, calculate, or assign cross-correlations for an <code>mcgf</code> or <code>mcgf_rs</code>
object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcgf'
ccfs(x, lag_max, ncores = 1, replace = FALSE, ...)

## S3 method for class 'mcgf_rs'
ccfs(x, lag_max, ncores = 1, replace = FALSE, ...)

ccfs(x) &lt;- value

add_ccfs(x, lag_max, ncores = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ccfs.mcgf_+3A_x">x</code></td>
<td>
<p>An <code>mcgf</code> or <code>mcgf_rs</code> object.</p>
</td></tr>
<tr><td><code id="ccfs.mcgf_+3A_lag_max">lag_max</code></td>
<td>
<p>Maximum lag at which to calculate the ccfs.</p>
</td></tr>
<tr><td><code id="ccfs.mcgf_+3A_ncores">ncores</code></td>
<td>
<p>Number of cpu cores used for computing. The <code>doParallel</code>
package is required when <code>ncores</code> &gt; 1.</p>
</td></tr>
<tr><td><code id="ccfs.mcgf_+3A_replace">replace</code></td>
<td>
<p>Logical; if TRUE, <code>acfs</code> are recalculated.</p>
</td></tr>
<tr><td><code id="ccfs.mcgf_+3A_...">...</code></td>
<td>
<p>Additional parameters or attributes. Not in use.</p>
</td></tr>
<tr><td><code id="ccfs.mcgf_+3A_value">value</code></td>
<td>
<p>Cross-correlations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>mcgf</code> objects, <code><a href="#topic+ccfs">ccfs()</a></code> computes cross-correlations for each time
lag. The output is an array of matrices where each matrix corresponds to the
cross-correlation for a time lag.
</p>
<p>For <code>mcgf_rs</code> objects, <code><a href="#topic+ccfs">ccfs()</a></code> computes regime-switching
cross-correlations for each time lag. The output is a list of array of
matrices where each array in the list corresponds to the cross-correlation
for a regime.
</p>
<p><code><a href="#topic+ccfs+3C-">ccfs&lt;-</a></code> assigns <code>ccfs</code> to <code>x</code>.
</p>
<p><code><a href="#topic+add_ccfs">add_ccfs()</a></code> adds <code>ccfs</code> and <code>sds</code> to <code>x</code>.
</p>


<h3>Value</h3>

<p><code><a href="#topic+ccfs">ccfs()</a></code> returns (regime-switching) cross-correlations.
<code><a href="#topic+add_ccfs">add_ccfs()</a></code> returns the same object with additional attributes of
(regime-switching) cross-correlations and (regime-switching) empirical
standard deviations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate ccfs for 'sim1'
data(sim1)
sim1_mcgf &lt;- mcgf(sim1$data, dists = sim1$dists)
ccfs(sim1_mcgf, lag_max = 5)

# To use multiple cores, use the `ncores` argument
ccfs(sim1_mcgf, lag_max = 5, ncores = 2)

# Add ccfs and sds to 'sim1_mcgf'
sim1_mcgf &lt;- add_ccfs(sim1_mcgf, lag_max = 5)
print(sim1_mcgf, "ccfs")
print(sim1_mcgf, "sds")

# Calculate ccfs for 'sim2'
data(sim2)
sim2_mcgf &lt;- mcgf_rs(sim2$data, dists = sim2$dists, label = sim2$label)
ccfs(sim2_mcgf, lag_max = 5)

# Add ccfs and sds to 'sim2_mcgf'
sim2_mcgf &lt;- add_ccfs(sim2_mcgf, lag_max = 5)
print(sim2_mcgf, "ccfs")
print(sim2_mcgf, "sds")
</code></pre>

<hr>
<h2 id='ccov'>Generic functions for calculating joint covariance/correlation matrix for mcgf
objects</h2><span id='topic+ccov'></span>

<h3>Description</h3>

<p>Generic functions for calculating joint covariance/correlation matrix for mcgf
objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ccov(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ccov_+3A_x">x</code></td>
<td>
<p>An <strong>R</strong> object.</p>
</td></tr>
<tr><td><code id="ccov_+3A_...">...</code></td>
<td>
<p>Additional parameters or attributes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Refer to <code><a href="#topic+ccov.mcgf">ccov.mcgf()</a></code> and <code><a href="#topic+ccov.mcgf_rs">ccov.mcgf_rs()</a></code> for more details.
</p>


<h3>Value</h3>

<p>Joint correlation/covariance matrix.
</p>

<hr>
<h2 id='ccov.mcgf'>Covariance/correlation for joint distribution of an <code>mcgf</code> object</h2><span id='topic+ccov.mcgf'></span>

<h3>Description</h3>

<p>Covariance/correlation for joint distribution of an <code>mcgf</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcgf'
ccov(x, model = c("all", "base", "empirical"), cor = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ccov.mcgf_+3A_x">x</code></td>
<td>
<p>An <code>mcgf</code> object.</p>
</td></tr>
<tr><td><code id="ccov.mcgf_+3A_model">model</code></td>
<td>
<p>Which model to use. One of <code>all</code>, <code>base</code>, and <code>empirical</code>.</p>
</td></tr>
<tr><td><code id="ccov.mcgf_+3A_cor">cor</code></td>
<td>
<p>Logical; if TRUE, correlation is outputted.</p>
</td></tr>
<tr><td><code id="ccov.mcgf_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not in use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Joint covariance/correlation matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim1)
sim1_mcgf &lt;- mcgf(sim1$data, dists = sim1$dists)
sim1_mcgf &lt;- add_acfs(sim1_mcgf, lag_max = 5)
sim1_mcgf &lt;- add_ccfs(sim1_mcgf, lag_max = 5)

# Fit a separable model and store it to 'sim1_mcgf'
fit_sep &lt;- fit_base(
    sim1_mcgf,
    model = "sep",
    lag = 5,
    par_init = c(
        c = 0.001,
        gamma = 0.5,
        a = 0.3,
        alpha = 0.5
    ),
    par_fixed = c(nugget = 0)
)
sim1_mcgf &lt;- add_base(sim1_mcgf, fit_base = fit_sep)

ccov(sim1_mcgf, model = "base")
</code></pre>

<hr>
<h2 id='ccov.mcgf_rs'>Covariance/correlation for joint distribution of an <code>mcgf_rs</code>object</h2><span id='topic+ccov.mcgf_rs'></span>

<h3>Description</h3>

<p>Covariance/correlation for joint distribution of an <code>mcgf_rs</code>object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcgf_rs'
ccov(x, model = c("all", "base", "empirical"), cor = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ccov.mcgf_rs_+3A_x">x</code></td>
<td>
<p>An <code>mcgf</code> object.</p>
</td></tr>
<tr><td><code id="ccov.mcgf_rs_+3A_model">model</code></td>
<td>
<p>Which model to use. One of <code>all</code>, <code>base</code>, and <code>empirical</code>.</p>
</td></tr>
<tr><td><code id="ccov.mcgf_rs_+3A_cor">cor</code></td>
<td>
<p>Logical; if TRUE, correlation is returned</p>
</td></tr>
<tr><td><code id="ccov.mcgf_rs_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not in use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of joint covariance/correlation matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim2)
sim2_mcgf &lt;- mcgf_rs(sim2$data, dists = sim2$dists, label = sim2$label)
sim2_mcgf &lt;- add_acfs(sim2_mcgf, lag_max = 5)
sim2_mcgf &lt;- add_ccfs(sim2_mcgf, lag_max = 5)

# Fit a regime-switching separable model
fit_sep &lt;- fit_base(
    sim2_mcgf,
    lag_ls = 5,
    model_ls = "sep",
    par_init_ls = list(list(
        c = 0.000001,
        gamma = 0.5,
        a = 0.5,
        alpha = 0.5
    )),
    par_fixed_ls = list(c(nugget = 0))
)
sim2_mcgf &lt;- add_base(sim2_mcgf, fit_base_ls = fit_sep)

ccov(sim2_mcgf, model = "base")
</code></pre>

<hr>
<h2 id='check_dist'>Check if valid distance</h2><span id='topic+check_dist'></span>

<h3>Description</h3>

<p>Check if valid distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dist(x, name = "x", check_sym = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_dist_+3A_x">x</code></td>
<td>
<p>Distance matrix or array.</p>
</td></tr>
<tr><td><code id="check_dist_+3A_name">name</code></td>
<td>
<p>Name of <code>x</code> for displaying errors.</p>
</td></tr>
<tr><td><code id="check_dist_+3A_check_sym">check_sym</code></td>
<td>
<p>Logical; if TRUE each matrix (slice) must be symmetric.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Check if <code>x</code> is a valid distance vector, matrix or array. It errors if any
elements in <code>x</code> is negative, or if <code>x</code> is not a symmetric matrix or an
array of symmetric matrices.
</p>


<h3>Value</h3>

<p>NULL.
</p>

<hr>
<h2 id='check_dist_sign'>Check if valid signed distance</h2><span id='topic+check_dist_sign'></span>

<h3>Description</h3>

<p>Check if valid signed distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dist_sign(x, name, check_sym = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_dist_sign_+3A_x">x</code></td>
<td>
<p>Distance matrix or array.</p>
</td></tr>
<tr><td><code id="check_dist_sign_+3A_name">name</code></td>
<td>
<p>Name of <code>x</code> for displaying errors.</p>
</td></tr>
<tr><td><code id="check_dist_sign_+3A_check_sym">check_sym</code></td>
<td>
<p>Logical; if TRUE each matrix (slice) must be symmetric.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Check if <code>x</code> is a valid signed distance vector, matrix or array. It errors
if <code>x</code> in absolute value is not a symmetric matrix or an array of
symmetric matrices.
</p>


<h3>Value</h3>

<p>NULL.
</p>

<hr>
<h2 id='check_dists'>Check if valid dists attribute for an <code>mcgf</code> object</h2><span id='topic+check_dists'></span>

<h3>Description</h3>

<p>Check if valid dists attribute for an <code>mcgf</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dists(dists, n_var, names, name_dists = "dists")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_dists_+3A_dists">dists</code></td>
<td>
<p>List of scaler or vector</p>
</td></tr>
<tr><td><code id="check_dists_+3A_n_var">n_var</code></td>
<td>
<p>Scaler, number of variables.</p>
</td></tr>
<tr><td><code id="check_dists_+3A_names">names</code></td>
<td>
<p>column and row names of matrices in <code>dists</code>.</p>
</td></tr>
<tr><td><code id="check_dists_+3A_name_dists">name_dists</code></td>
<td>
<p>name_dists of <code>dists</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Check if <code>dists</code> is a valid dists attribute for an <code>mcgf</code> object. It errors
if 1) <code>dists</code> does not contain <code>h1</code> or <code>h2</code>, 2) if their dimensions do not
match, 3) if it contains elements other than <code>h</code>, <code>h1</code> or <code>h2</code>. <code>h</code> will be
computed if it is not given.
</p>


<h3>Value</h3>

<p><code>dists</code>.
</p>

<hr>
<h2 id='check_length'>Check if valid input length</h2><span id='topic+check_length'></span>

<h3>Description</h3>

<p>Check if valid input length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_length(x, length, name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_length_+3A_x">x</code></td>
<td>
<p>Scaler or vector</p>
</td></tr>
<tr><td><code id="check_length_+3A_length">length</code></td>
<td>
<p>Length of <code>x</code>.</p>
</td></tr>
<tr><td><code id="check_length_+3A_name">name</code></td>
<td>
<p>Name of <code>x</code> for displaying errors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Check if <code>x</code> has approprate length. If length of <code>x</code> is 1 then <code>x</code> is
replicated to match <code>length</code>. If length of <code>x</code> is neither 1 or <code>length</code> then
an error is signaled.
</p>


<h3>Value</h3>

<p><code>x</code>.
</p>

<hr>
<h2 id='check_length_ls'>Check if valid input length</h2><span id='topic+check_length_ls'></span>

<h3>Description</h3>

<p>Check if valid input length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_length_ls(x_ls, length, name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_length_ls_+3A_x_ls">x_ls</code></td>
<td>
<p>List of scaler or vector</p>
</td></tr>
<tr><td><code id="check_length_ls_+3A_length">length</code></td>
<td>
<p>List of length of <code>x_ls</code>.</p>
</td></tr>
<tr><td><code id="check_length_ls_+3A_name">name</code></td>
<td>
<p>Name of <code>x</code> for displaying errors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Check if elements in <code>x_ls</code> have approprate length. If length of any elements
in <code>x_ls</code> is 1 then they are replicated to match <code>length</code>. If length of any
elements is neither 1 or <code>length</code> then an error is signaled.
</p>


<h3>Value</h3>

<p><code>x_ls</code>.
</p>

<hr>
<h2 id='cor_cauchy'>Calculate Cauchy correlation</h2><span id='topic+cor_cauchy'></span>

<h3>Description</h3>

<p>Calculate Cauchy correlation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_cauchy(x, a, alpha, nu = 1, nugget = 0, is.dist = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cor_cauchy_+3A_x">x</code></td>
<td>
<p>A numeric vector, matrix, or array.</p>
</td></tr>
<tr><td><code id="cor_cauchy_+3A_a">a</code></td>
<td>
<p>Smooth parameter, <code class="reqn">a&gt;0</code>.</p>
</td></tr>
<tr><td><code id="cor_cauchy_+3A_alpha">alpha</code></td>
<td>
<p>Scale parameter, <code class="reqn">\alpha\in(0, 1]</code>.</p>
</td></tr>
<tr><td><code id="cor_cauchy_+3A_nu">nu</code></td>
<td>
<p>Power parameter, <code class="reqn">\nu&gt;0</code>. Default is 1.</p>
</td></tr>
<tr><td><code id="cor_cauchy_+3A_nugget">nugget</code></td>
<td>
<p>The nugget effect <code class="reqn">\in[0, 1]</code>.</p>
</td></tr>
<tr><td><code id="cor_cauchy_+3A_is.dist">is.dist</code></td>
<td>
<p>Logical; if TRUE, <code>x</code> is a distance matrix or an array of
distance matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Cauchy correlation function with scale parameter <code class="reqn">a</code> and
smooth parameter <code class="reqn">\alpha</code> has the form
</p>
<p style="text-align: center;"><code class="reqn">C(x)=(1-\text{nugget})(a|x|^{2\alpha} + 1)^{-\nu}+\text{nugget}\cdot
\delta_{x=0},</code>
</p>
<p> where <code class="reqn">\delta_{x=0}</code> is 1 when <code class="reqn">x=0</code> and 0 otherwise.
</p>


<h3>Value</h3>

<p>Correlations of the same dimension as <code>x</code>.
</p>


<h3>References</h3>

<p>Gneiting, T., and Schlather, M. (2004). Stochastic Models That Separate
Fractal Dimension and the Hurst Effect. SIAM Review, 46(2), 269–282.
</p>


<h3>See Also</h3>

<p>Other correlation functions: 
<code><a href="#topic+cor_exp">cor_exp</a>()</code>,
<code><a href="#topic+cor_fs">cor_fs</a>()</code>,
<code><a href="#topic+cor_lagr_askey">cor_lagr_askey</a>()</code>,
<code><a href="#topic+cor_lagr_exp">cor_lagr_exp</a>()</code>,
<code><a href="#topic+cor_lagr_tri">cor_lagr_tri</a>()</code>,
<code><a href="#topic+cor_sep">cor_sep</a>()</code>,
<code><a href="#topic+cor_stat">cor_stat</a>()</code>,
<code><a href="#topic+cor_stat_rs">cor_stat_rs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(0, 5, 5, 0), nrow = 2)
cor_cauchy(x, a = 1, alpha = 0.5)

x &lt;- matrix(c(0, 5, 5, 0), nrow = 2)
cor_cauchy(x, a = 1, alpha = 0.5, nugget = 0.3, is.dist = TRUE)

</code></pre>

<hr>
<h2 id='cor_exp'>Calculate exponential correlation</h2><span id='topic+cor_exp'></span>

<h3>Description</h3>

<p>Calculate exponential correlation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_exp(x, c, gamma = 1/2, nugget = 0, is.dist = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cor_exp_+3A_x">x</code></td>
<td>
<p>A numeric vector, matrix, or array.</p>
</td></tr>
<tr><td><code id="cor_exp_+3A_c">c</code></td>
<td>
<p>Smooth parameter, <code class="reqn">c&gt;0</code>.</p>
</td></tr>
<tr><td><code id="cor_exp_+3A_gamma">gamma</code></td>
<td>
<p>Scale parameter, <code class="reqn">\gamma\in(0, 1/2]</code>. Default is 1/2.</p>
</td></tr>
<tr><td><code id="cor_exp_+3A_nugget">nugget</code></td>
<td>
<p>The nugget effect <code class="reqn">\in[0, 1]</code>.</p>
</td></tr>
<tr><td><code id="cor_exp_+3A_is.dist">is.dist</code></td>
<td>
<p>Logical; if TRUE, <code>x</code> is a distance matrix or an array of
distance matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The exponential correlation function with scale parameter <code class="reqn">c</code>
and smooth parameter <code class="reqn">\gamma</code> has the form
</p>
<p style="text-align: center;"><code class="reqn">C(x)=(1-\text{nugget})\exp(-c|x|^{2\gamma})+\text{nugget}\cdot
\delta_{x=0},</code>
</p>
<p> where <code class="reqn">\delta_{x=0}</code> is 1 when <code class="reqn">x=0</code> and 0 otherwise.
</p>


<h3>Value</h3>

<p>Correlations of the same dimension as <code>x</code>.
</p>


<h3>References</h3>

<p>Diggle, P. J., Tawn, J. A., &amp; Moyeed, R. A. (1998). Model-Based
Geostatistics. Journal of the Royal Statistical Society. Series C (Applied
Statistics), 47(3), 299–350.
</p>


<h3>See Also</h3>

<p>Other correlation functions: 
<code><a href="#topic+cor_cauchy">cor_cauchy</a>()</code>,
<code><a href="#topic+cor_fs">cor_fs</a>()</code>,
<code><a href="#topic+cor_lagr_askey">cor_lagr_askey</a>()</code>,
<code><a href="#topic+cor_lagr_exp">cor_lagr_exp</a>()</code>,
<code><a href="#topic+cor_lagr_tri">cor_lagr_tri</a>()</code>,
<code><a href="#topic+cor_sep">cor_sep</a>()</code>,
<code><a href="#topic+cor_stat">cor_stat</a>()</code>,
<code><a href="#topic+cor_stat_rs">cor_stat_rs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(0, 5, 5, 0), nrow = 2)
cor_exp(x, c = 0.01, gamma = 0.5)

x &lt;- matrix(c(0, 5, 5, 0), nrow = 2)
cor_exp(x, c = 0.01, gamma = 0.5, nugget = 0.3, is.dist = TRUE)

</code></pre>

<hr>
<h2 id='cor_fs'>Calculate correlation for fully symmetric model</h2><span id='topic+cor_fs'></span>

<h3>Description</h3>

<p>Calculate correlation for fully symmetric model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_fs(nugget = 0, c, gamma = 1/2, a, alpha, beta = 0, h, u)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cor_fs_+3A_nugget">nugget</code></td>
<td>
<p>The nugget effect <code class="reqn">\in[0, 1]</code>.</p>
</td></tr>
<tr><td><code id="cor_fs_+3A_c">c</code></td>
<td>
<p>Scale parameter of <code>cor_exp</code>, <code class="reqn">c&gt;0</code>.</p>
</td></tr>
<tr><td><code id="cor_fs_+3A_gamma">gamma</code></td>
<td>
<p>Smooth parameter of <code>cor_exp</code>, <code class="reqn">\gamma\in(0, 1/2]</code>.</p>
</td></tr>
<tr><td><code id="cor_fs_+3A_a">a</code></td>
<td>
<p>Scale parameter of <code>cor_cauchy</code>, <code class="reqn">a&gt;0</code>.</p>
</td></tr>
<tr><td><code id="cor_fs_+3A_alpha">alpha</code></td>
<td>
<p>Smooth parameter of <code>cor_cauchy</code>, <code class="reqn">\alpha\in(0, 1]</code>.</p>
</td></tr>
<tr><td><code id="cor_fs_+3A_beta">beta</code></td>
<td>
<p>Interaction parameter, <code class="reqn">\beta\in[0, 1]</code>.</p>
</td></tr>
<tr><td><code id="cor_fs_+3A_h">h</code></td>
<td>
<p>Euclidean distance matrix or array.</p>
</td></tr>
<tr><td><code id="cor_fs_+3A_u">u</code></td>
<td>
<p>Time lag, same dimension as <code>h</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fully symmetric correlation function with interaction parameter
<code class="reqn">\beta</code> has the form
</p>
<p style="text-align: center;"><code class="reqn">C(\mathbf{h}, u)=\dfrac{1}{(a|u|^{2\alpha} + 1)}
\left((1-\text{nugget})\exp\left(\dfrac{-c\|\mathbf{h}\|^{2\gamma}}
{(a|u|^{2\alpha}+1)^{\beta\gamma}}\right)+
\text{nugget}\cdot \delta_{\mathbf{h}=\boldsymbol 0}\right),</code>
</p>

<p>where <code class="reqn">\|\cdot\|</code> is the Euclidean distance, and <code class="reqn">\delta_{x=0}</code> is 1
when <code class="reqn">x=0</code> and 0 otherwise. Here <code class="reqn">\mathbf{h}\in\mathbb{R}^2</code> and
<code class="reqn">u\in\mathbb{R}</code>. By default <code>beta = 0</code> and it reduces to the separable
model.
</p>


<h3>Value</h3>

<p>Correlations of the same dimension as <code>h</code> and <code>u</code>.
</p>


<h3>References</h3>

<p>Gneiting, T. (2002). Nonseparable, Stationary Covariance Functions for
Space–Time Data, Journal of the American Statistical Association, 97:458,
590-600.
</p>


<h3>See Also</h3>

<p>Other correlation functions: 
<code><a href="#topic+cor_cauchy">cor_cauchy</a>()</code>,
<code><a href="#topic+cor_exp">cor_exp</a>()</code>,
<code><a href="#topic+cor_lagr_askey">cor_lagr_askey</a>()</code>,
<code><a href="#topic+cor_lagr_exp">cor_lagr_exp</a>()</code>,
<code><a href="#topic+cor_lagr_tri">cor_lagr_tri</a>()</code>,
<code><a href="#topic+cor_sep">cor_sep</a>()</code>,
<code><a href="#topic+cor_stat">cor_stat</a>()</code>,
<code><a href="#topic+cor_stat_rs">cor_stat_rs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h &lt;- matrix(c(0, 5, 5, 0), nrow = 2)
u &lt;- matrix(0, nrow = 2, ncol = 2)
cor_fs(c = 0.01, gamma = 0.5, a = 1, alpha = 0.5, beta = 0.5, h = h, u = u)

h &lt;- array(c(0, 5, 5, 0), dim = c(2, 2, 3))
u &lt;- array(rep(0:2, each = 4), dim = c(2, 2, 3))
cor_fs(c = 0.01, gamma = 0.5, a = 1, alpha = 0.5, beta = 0.5, h = h, u = u)

</code></pre>

<hr>
<h2 id='cor_lagr_askey'>Calculate Lagrangian correlation of the Askey form</h2><span id='topic+cor_lagr_askey'></span>

<h3>Description</h3>

<p>Calculate Lagrangian correlation of the Askey form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_lagr_askey(v1, v2, k = 2, h1, h2, u)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cor_lagr_askey_+3A_v1">v1</code></td>
<td>
<p>Prevailing wind, u-component.</p>
</td></tr>
<tr><td><code id="cor_lagr_askey_+3A_v2">v2</code></td>
<td>
<p>Prevailing wind, v-component.</p>
</td></tr>
<tr><td><code id="cor_lagr_askey_+3A_k">k</code></td>
<td>
<p>Scale parameter of <code class="reqn">\|\boldsymbol v\|</code>, <code class="reqn">k&gt;0</code>. Default is 2.</p>
</td></tr>
<tr><td><code id="cor_lagr_askey_+3A_h1">h1</code></td>
<td>
<p>Horizontal distance matrix or array.</p>
</td></tr>
<tr><td><code id="cor_lagr_askey_+3A_h2">h2</code></td>
<td>
<p>Vertical distance matrix or array, same dimension as <code>h1</code>.</p>
</td></tr>
<tr><td><code id="cor_lagr_askey_+3A_u">u</code></td>
<td>
<p>Time lag, same dimension as <code>h1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Lagrangian correlation function of the Askey form with parameters
<code class="reqn">\boldsymbol v = (v_1, v_2)^\top\in\mathbb{R}^2</code> has the form
</p>
<p style="text-align: center;"><code class="reqn">C(\mathbf{h}, u)=\left(1-\dfrac{1}{k\|\boldsymbol v\|}
\left\|\mathbf{h}-u\boldsymbol v\right\|\right)^{3/2}_+,</code>
</p>

<p>where <code class="reqn">\|\cdot\|</code> is the Euclidean distance, <code class="reqn">x_+=\max(x,0),
\mathbf{h} = (\mathrm{h}_1, \mathrm{h}_2)^\top\in\mathbb{R}^2</code>,
and <code class="reqn">k &gt; 0</code> is the scale parameter controlling the magnitude of
asymmetry in correlation.
</p>


<h3>Value</h3>

<p>Correlations of the same dimension as <code>h1</code>.
</p>


<h3>References</h3>

<p>Askey, R. (1973). Radial characteristic functions, Tech. Report No. 1262,
Math. Research Center, University of Wisconsin-Madison.
</p>


<h3>See Also</h3>

<p>Other correlation functions: 
<code><a href="#topic+cor_cauchy">cor_cauchy</a>()</code>,
<code><a href="#topic+cor_exp">cor_exp</a>()</code>,
<code><a href="#topic+cor_fs">cor_fs</a>()</code>,
<code><a href="#topic+cor_lagr_exp">cor_lagr_exp</a>()</code>,
<code><a href="#topic+cor_lagr_tri">cor_lagr_tri</a>()</code>,
<code><a href="#topic+cor_sep">cor_sep</a>()</code>,
<code><a href="#topic+cor_stat">cor_stat</a>()</code>,
<code><a href="#topic+cor_stat_rs">cor_stat_rs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h1 &lt;- matrix(c(0, -5, 5, 0), nrow = 2)
h2 &lt;- matrix(c(0, -8, 8, 0), nrow = 2)
u &lt;- matrix(0.1, nrow = 2, ncol = 2)
cor_lagr_askey(v1 = 5, v2 = 10, h1 = h1, h2 = h2, u = u)

h1 &lt;- array(c(0, -10, 10, 0), dim = c(2, 2, 3))
h2 &lt;- array(c(0, -10, 10, 0), dim = c(2, 2, 3))
u &lt;- array(rep(-c(1, 2, 3), each = 4), dim = c(2, 2, 3))
cor_lagr_askey(v1 = 10, v2 = 10, h1 = h1, h2 = h2, u = u)

</code></pre>

<hr>
<h2 id='cor_lagr_exp'>Calculate Lagrangian correlation of the exponential form</h2><span id='topic+cor_lagr_exp'></span>

<h3>Description</h3>

<p>Calculate Lagrangian correlation of the exponential form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_lagr_exp(v1, v2, k = 2, h1, h2, u)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cor_lagr_exp_+3A_v1">v1</code></td>
<td>
<p>Prevailing wind, u-component.</p>
</td></tr>
<tr><td><code id="cor_lagr_exp_+3A_v2">v2</code></td>
<td>
<p>Prevailing wind, v-component.</p>
</td></tr>
<tr><td><code id="cor_lagr_exp_+3A_k">k</code></td>
<td>
<p>Scale parameter of <code class="reqn">\|\boldsymbol v\|</code>, <code class="reqn">k&gt;0</code>. Default is 2.</p>
</td></tr>
<tr><td><code id="cor_lagr_exp_+3A_h1">h1</code></td>
<td>
<p>Horizontal distance matrix or array.</p>
</td></tr>
<tr><td><code id="cor_lagr_exp_+3A_h2">h2</code></td>
<td>
<p>Vertical distance matrix or array, same dimension as <code>h1</code>.</p>
</td></tr>
<tr><td><code id="cor_lagr_exp_+3A_u">u</code></td>
<td>
<p>Time lag, same dimension as <code>h1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Lagrangian correlation function of the exponential form with parameters
<code class="reqn">\boldsymbol v = (v_1, v_2)^\top\in\mathbb{R}^2</code> has the form
</p>
<p style="text-align: center;"><code class="reqn">C(\mathbf{h}, u)=\exp\left(-\dfrac{1}{k\|\boldsymbol v\|}
\left\|\mathbf{h}-u\boldsymbol v\right\|\right),</code>
</p>

<p>where <code class="reqn">\|\cdot\|</code> is the Euclidean distance,
<code class="reqn">\mathbf{h} = (\mathrm{h}_1, \mathrm{h}_2)^\top\in\mathbb{R}^2</code>,
and <code class="reqn">k &gt; 0</code> is the scale parameter controlling the magnitude of
asymmetry in correlation.
</p>


<h3>Value</h3>

<p>Correlations of the same dimension as <code>h1</code>.
</p>


<h3>References</h3>

<p>Diggle, P. J., Tawn, J. A., &amp; Moyeed, R. A. (1998). Model-Based
Geostatistics. Journal of the Royal Statistical Society. Series C (Applied
Statistics), 47(3), 299–350.
</p>


<h3>See Also</h3>

<p>Other correlation functions: 
<code><a href="#topic+cor_cauchy">cor_cauchy</a>()</code>,
<code><a href="#topic+cor_exp">cor_exp</a>()</code>,
<code><a href="#topic+cor_fs">cor_fs</a>()</code>,
<code><a href="#topic+cor_lagr_askey">cor_lagr_askey</a>()</code>,
<code><a href="#topic+cor_lagr_tri">cor_lagr_tri</a>()</code>,
<code><a href="#topic+cor_sep">cor_sep</a>()</code>,
<code><a href="#topic+cor_stat">cor_stat</a>()</code>,
<code><a href="#topic+cor_stat_rs">cor_stat_rs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h1 &lt;- matrix(c(0, -5, 5, 0), nrow = 2)
h2 &lt;- matrix(c(0, -8, 8, 0), nrow = 2)
u &lt;- matrix(0.1, nrow = 2, ncol = 2)
cor_lagr_exp(v1 = 5, v2 = 10, h1 = h1, h2 = h2, u = u)

h1 &lt;- array(c(0, -10, 10, 0), dim = c(2, 2, 3))
h2 &lt;- array(c(0, -10, 10, 0), dim = c(2, 2, 3))
u &lt;- array(rep(-c(1, 2, 3), each = 4), dim = c(2, 2, 3))
cor_lagr_exp(v1 = 10, v2 = 10, h1 = h1, h2 = h2, u = u)

</code></pre>

<hr>
<h2 id='cor_lagr_tri'>Calculate Lagrangian correlation of the triangular form</h2><span id='topic+cor_lagr_tri'></span>

<h3>Description</h3>

<p>Calculate Lagrangian correlation of the triangular form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_lagr_tri(v1, v2, k = 2, h1, h2, u)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cor_lagr_tri_+3A_v1">v1</code></td>
<td>
<p>Prevailing wind, u-component.</p>
</td></tr>
<tr><td><code id="cor_lagr_tri_+3A_v2">v2</code></td>
<td>
<p>Prevailing wind, v-component.</p>
</td></tr>
<tr><td><code id="cor_lagr_tri_+3A_k">k</code></td>
<td>
<p>Scale parameter of <code class="reqn">\|\boldsymbol v\|</code>, <code class="reqn">k&gt;0</code>. Default is 2.</p>
</td></tr>
<tr><td><code id="cor_lagr_tri_+3A_h1">h1</code></td>
<td>
<p>Horizontal distance matrix or array.</p>
</td></tr>
<tr><td><code id="cor_lagr_tri_+3A_h2">h2</code></td>
<td>
<p>Vertical distance matrix or array, same dimension as <code>h1</code>.</p>
</td></tr>
<tr><td><code id="cor_lagr_tri_+3A_u">u</code></td>
<td>
<p>Time lag, same dimension as <code>h1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Lagrangian correlation function of the triangular form with parameters
<code class="reqn">\boldsymbol v = (v_1, v_2)^\top\in\mathbb{R}^2</code> has the form
</p>
<p style="text-align: center;"><code class="reqn">C(\mathbf{h}, u)=\left(1-\dfrac{1}{k\|\boldsymbol v\|}
\left|\dfrac{\mathbf{h}^\top\boldsymbol v}{\|\boldsymbol v\|}-
u\|\boldsymbol v\|\right|\right)_+,</code>
</p>

<p>where <code class="reqn">\|\cdot\|</code> is the Euclidean distance, <code class="reqn">x_+=\max(x,0),
\mathbf{h} = (\mathrm{h}_1, \mathrm{h}_2)^\top\in\mathbb{R}^2</code>,
and <code class="reqn">k &gt; 0</code> is the scale parameter controlling the magnitude of
asymmetry in correlation.
</p>


<h3>Value</h3>

<p>Correlations of the same dimension as <code>h1</code>.
</p>


<h3>See Also</h3>

<p>Other correlation functions: 
<code><a href="#topic+cor_cauchy">cor_cauchy</a>()</code>,
<code><a href="#topic+cor_exp">cor_exp</a>()</code>,
<code><a href="#topic+cor_fs">cor_fs</a>()</code>,
<code><a href="#topic+cor_lagr_askey">cor_lagr_askey</a>()</code>,
<code><a href="#topic+cor_lagr_exp">cor_lagr_exp</a>()</code>,
<code><a href="#topic+cor_sep">cor_sep</a>()</code>,
<code><a href="#topic+cor_stat">cor_stat</a>()</code>,
<code><a href="#topic+cor_stat_rs">cor_stat_rs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h1 &lt;- matrix(c(0, -5, 5, 0), nrow = 2)
h2 &lt;- matrix(c(0, -8, 8, 0), nrow = 2)
u &lt;- matrix(0.1, nrow = 2, ncol = 2)
cor_lagr_tri(v1 = 5, v2 = 10, h1 = h1, h2 = h2, u = u)

h1 &lt;- array(c(0, -10, 10, 0), dim = c(2, 2, 3))
h2 &lt;- array(c(0, -10, 10, 0), dim = c(2, 2, 3))
u &lt;- array(rep(-c(1, 2, 3), each = 4), dim = c(2, 2, 3))
cor_lagr_tri(v1 = 10, v2 = 10, h1 = h1, h2 = h2, u = u)

</code></pre>

<hr>
<h2 id='cor_sep'>Calculate correlation for separable model</h2><span id='topic+cor_sep'></span>

<h3>Description</h3>

<p>Calculate correlation for separable model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_sep(
  spatial = c("exp", "cauchy"),
  temporal = c("exp", "cauchy"),
  par_s,
  par_t,
  h,
  u
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cor_sep_+3A_spatial">spatial</code></td>
<td>
<p>Pure spatial model, <code>exp</code> or <code>cauchy</code> for now.</p>
</td></tr>
<tr><td><code id="cor_sep_+3A_temporal">temporal</code></td>
<td>
<p>Pure temporal model, <code>exp</code> or <code>cauchy</code> for now.</p>
</td></tr>
<tr><td><code id="cor_sep_+3A_par_s">par_s</code></td>
<td>
<p>Parameters for the pure spatial model. Nugget effect supported.</p>
</td></tr>
<tr><td><code id="cor_sep_+3A_par_t">par_t</code></td>
<td>
<p>Parameters for the pure temporal model.</p>
</td></tr>
<tr><td><code id="cor_sep_+3A_h">h</code></td>
<td>
<p>Euclidean distance matrix or array.</p>
</td></tr>
<tr><td><code id="cor_sep_+3A_u">u</code></td>
<td>
<p>Time lag, same dimension as <code>h</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The separable model is the product of a pure temporal model, <code class="reqn">C_T(u)</code>,
and a pure spatial model, <code class="reqn">C_S(\mathbf{h})</code>. It is of the form
</p>
<p style="text-align: center;"><code class="reqn">C(\mathbf{h}, u)=C_{T}(u)
\left[(1-\text{nugget})C_{S}(\mathbf{h})+\text{nugget}
\delta_{\mathbf{h}=0}\right],</code>
</p>

<p>where <code class="reqn">\delta_{x=0}</code> is 1 when <code class="reqn">x=0</code> and 0 otherwise. Here
<code class="reqn">\mathbf{h}\in\mathbb{R}^2</code> and <code class="reqn">u\in\mathbb{R}</code>. Now only
exponential and Cauchy correlation models are available.
</p>


<h3>Value</h3>

<p>Correlations of the same dimension as <code>h</code> and <code>u</code>.
</p>


<h3>References</h3>

<p>Gneiting, T. (2002). Nonseparable, Stationary Covariance Functions for
Space–Time Data, Journal of the American Statistical Association, 97:458,
590-600.
</p>


<h3>See Also</h3>

<p>Other correlation functions: 
<code><a href="#topic+cor_cauchy">cor_cauchy</a>()</code>,
<code><a href="#topic+cor_exp">cor_exp</a>()</code>,
<code><a href="#topic+cor_fs">cor_fs</a>()</code>,
<code><a href="#topic+cor_lagr_askey">cor_lagr_askey</a>()</code>,
<code><a href="#topic+cor_lagr_exp">cor_lagr_exp</a>()</code>,
<code><a href="#topic+cor_lagr_tri">cor_lagr_tri</a>()</code>,
<code><a href="#topic+cor_stat">cor_stat</a>()</code>,
<code><a href="#topic+cor_stat_rs">cor_stat_rs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h &lt;- matrix(c(0, 5, 5, 0), nrow = 2)
par_s &lt;- list(nugget = 0.5, c = 0.01, gamma = 0.5)
u &lt;- matrix(0, nrow = 2, ncol = 2)
par_t &lt;- list(a = 1, alpha = 0.5)
cor_sep(
    spatial = "exp", temporal = "cauchy", par_s = par_s, par_t = par_t,
    h = h, u = u
)

h &lt;- array(c(0, 5, 5, 0), dim = c(2, 2, 3))
par_s &lt;- list(nugget = 0.5, c = 0.01, gamma = 0.5)
u &lt;- array(rep(0:2, each = 4), dim = c(2, 2, 3))
par_t &lt;- list(a = 1, alpha = 0.5)
cor_sep(
    spatial = "exp", temporal = "cauchy", par_s = par_s, par_t = par_t,
    h = h, u = u
)

</code></pre>

<hr>
<h2 id='cor_stat'>Calculate general stationary correlation.</h2><span id='topic+cor_stat'></span>

<h3>Description</h3>

<p>Calculate general stationary correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_stat(
  base = c("sep", "fs"),
  lagrangian = c("none", "lagr_tri", "lagr_askey"),
  par_base,
  par_lagr,
  lambda,
  h,
  h1,
  h2,
  u,
  base_fixed = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cor_stat_+3A_base">base</code></td>
<td>
<p>Base model, <code>sep</code> or <code>fs</code> for now. Or correlation matrix/array.</p>
</td></tr>
<tr><td><code id="cor_stat_+3A_lagrangian">lagrangian</code></td>
<td>
<p>Lagrangian model, <code>none</code>, <code>lagr_tri</code>, or <code>lagr_askey</code>.</p>
</td></tr>
<tr><td><code id="cor_stat_+3A_par_base">par_base</code></td>
<td>
<p>Parameters for the base model (symmetric), used only when
<code>base_fixed = FALSE</code>.</p>
</td></tr>
<tr><td><code id="cor_stat_+3A_par_lagr">par_lagr</code></td>
<td>
<p>Parameters for the Lagrangian model. Used only when
<code>lagrangian</code> is not <code>none</code>.</p>
</td></tr>
<tr><td><code id="cor_stat_+3A_lambda">lambda</code></td>
<td>
<p>Weight of the Lagrangian term, <code class="reqn">\lambda\in[0, 1]</code>.</p>
</td></tr>
<tr><td><code id="cor_stat_+3A_h">h</code></td>
<td>
<p>Euclidean distance matrix or array, used only when
<code>base_fixed = FALSE</code>.</p>
</td></tr>
<tr><td><code id="cor_stat_+3A_h1">h1</code></td>
<td>
<p>Horizontal distance matrix or array, same dimension as <code>h</code>. Used
only when <code>lagrangian</code> is not <code>none</code>.</p>
</td></tr>
<tr><td><code id="cor_stat_+3A_h2">h2</code></td>
<td>
<p>Vertical distance matrix or array, same dimension as <code>h</code>. Used
only when <code>lagrangian</code> is not <code>none</code>.</p>
</td></tr>
<tr><td><code id="cor_stat_+3A_u">u</code></td>
<td>
<p>Time lag, same dimension as <code>h</code>.</p>
</td></tr>
<tr><td><code id="cor_stat_+3A_base_fixed">base_fixed</code></td>
<td>
<p>Logical; if TRUE, <code>base</code> is the correlation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The general station model, a convex combination of a base model
and a Lagrangian model, has the form
</p>
<p style="text-align: center;"><code class="reqn">C(\mathbf{h}, u)=(1-\lambda)C_{\text{Base}}(\mathbf{h}, u)+
\lambda C_{\text{Lagr}}(\mathbf{h}, u),</code>
</p>

<p>where <code class="reqn">\lambda</code> is the weight of the Lagrangian term.
</p>
<p>If <code>base_fixed = TRUE</code>, the correlation is of the form
</p>
<p style="text-align: center;"><code class="reqn">C(\mathbf{h}, u)=(1-\lambda)C_{\text{Base}}+
\lambda C_{\text{Lagr}}(\mathbf{h}, u),</code>
</p>

<p>where <code>base</code> is a correlation matrix/array and <code>par_base</code> and <code>h</code> are not
used.
</p>
<p>When <code>lagrangian = "none"</code>, <code>lambda</code> must be 0.
</p>


<h3>Value</h3>

<p>Correlations for the general stationary model. Same dimension of
<code>base</code> if <code>base_fixed = FALSE</code>.
</p>


<h3>See Also</h3>

<p>Other correlation functions: 
<code><a href="#topic+cor_cauchy">cor_cauchy</a>()</code>,
<code><a href="#topic+cor_exp">cor_exp</a>()</code>,
<code><a href="#topic+cor_fs">cor_fs</a>()</code>,
<code><a href="#topic+cor_lagr_askey">cor_lagr_askey</a>()</code>,
<code><a href="#topic+cor_lagr_exp">cor_lagr_exp</a>()</code>,
<code><a href="#topic+cor_lagr_tri">cor_lagr_tri</a>()</code>,
<code><a href="#topic+cor_sep">cor_sep</a>()</code>,
<code><a href="#topic+cor_stat_rs">cor_stat_rs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par_s &lt;- list(nugget = 0.5, c = 0.01, gamma = 0.5)
par_t &lt;- list(a = 1, alpha = 0.5)
par_base &lt;- list(par_s = par_s, par_t = par_t)
par_lagr &lt;- list(v1 = 5, v2 = 10)
h1 &lt;- matrix(c(0, 5, -5, 0), nrow = 2)
h2 &lt;- matrix(c(0, 8, -8, 0), nrow = 2)
h &lt;- sqrt(h1^2 + h2^2)
u &lt;- matrix(0.1, nrow = 2, ncol = 2)
cor_stat(
    base = "sep", lagrangian = "lagr_tri", par_base = par_base,
    par_lagr = par_lagr, lambda = 0.8, h = h, h1 = h1, h2 = h2, u = u
)

h1 &lt;- array(c(0, 5, -5, 0), dim = c(2, 2, 3))
h2 &lt;- array(c(0, 8, -8, 0), dim = c(2, 2, 3))
h &lt;- sqrt(h1^2 + h2^2)
u &lt;- array(rep(c(0.1, 0.2, 0.3), each = 4), dim = c(2, 2, 3))
fit_base &lt;- cor_fs(
    nugget = 0.5, c = 0.01, gamma = 0.5, a = 1, alpha = 0.5,
    beta = 0.0, h = h, u = u
)
par_lagr &lt;- list(v1 = 5, v2 = 10)
cor_stat(
    base = fit_base, lagrangian = "lagr_askey", par_lagr = par_lagr,
    h1 = h1, h2 = h2, u = u, lambda = 0.8, base_fixed = TRUE
)

</code></pre>

<hr>
<h2 id='cor_stat_rs'>Calculate general stationary correlation.</h2><span id='topic+cor_stat_rs'></span>

<h3>Description</h3>

<p>Calculate general stationary correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_stat_rs(
  n_regime,
  base_ls,
  lagrangian_ls,
  par_base_ls,
  par_lagr_ls,
  lambda_ls,
  h_ls,
  h1_ls,
  h2_ls,
  u_ls,
  base_fixed = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cor_stat_rs_+3A_n_regime">n_regime</code></td>
<td>
<p>Integer, number of regimes.</p>
</td></tr>
<tr><td><code id="cor_stat_rs_+3A_base_ls">base_ls</code></td>
<td>
<p>List of base model, <code>sep</code> or <code>fs</code> for now. Or list of
correlation matrices/arrays.</p>
</td></tr>
<tr><td><code id="cor_stat_rs_+3A_lagrangian_ls">lagrangian_ls</code></td>
<td>
<p>List of Lagrangian model, <code>lagr_tri</code> or <code>lagr_askey</code>
for now.</p>
</td></tr>
<tr><td><code id="cor_stat_rs_+3A_par_base_ls">par_base_ls</code></td>
<td>
<p>List of parameters for the base model, used only when
<code>base_fixed = FALSE</code>.</p>
</td></tr>
<tr><td><code id="cor_stat_rs_+3A_par_lagr_ls">par_lagr_ls</code></td>
<td>
<p>List of parameters for the Lagrangian model.  Used only
when <code>lagrangian_ls</code> is not <code>none</code>.</p>
</td></tr>
<tr><td><code id="cor_stat_rs_+3A_lambda_ls">lambda_ls</code></td>
<td>
<p>List of weight of the Lagrangian term,
<code class="reqn">\lambda\in[0, 1]</code>.</p>
</td></tr>
<tr><td><code id="cor_stat_rs_+3A_h_ls">h_ls</code></td>
<td>
<p>List of Euclidean distance matrix or array,
used only when <code>base_fixed = FALSE</code>.</p>
</td></tr>
<tr><td><code id="cor_stat_rs_+3A_h1_ls">h1_ls</code></td>
<td>
<p>List of horizontal distance matrix or array, same dimension as
<code>h_ls</code>. Used only when <code>lagrangian_ls</code> is not <code>none</code>.</p>
</td></tr>
<tr><td><code id="cor_stat_rs_+3A_h2_ls">h2_ls</code></td>
<td>
<p>List of vertical distance matrix or array, same dimension as
<code>h_ls</code>. Used only when <code>lagrangian_ls</code> is not <code>none</code>.</p>
</td></tr>
<tr><td><code id="cor_stat_rs_+3A_u_ls">u_ls</code></td>
<td>
<p>List of time lag, same dimension as <code>h_ls</code>.</p>
</td></tr>
<tr><td><code id="cor_stat_rs_+3A_base_fixed">base_fixed</code></td>
<td>
<p>Logical; if TRUE, <code>base_ls</code> is the list of correlation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It gives a list of general stationary correlation for <code>n_regime</code>
regimes. See <a href="#topic+cor_stat">cor_stat</a> for the model details. Model parameters are lists of
length 1 or <code>n_regime</code>. When length is 1, same values are used for all
regimes. If <code>base_fixed = TRUE</code>, the base is a list of correlation and
<code>par_base_ls</code> and <code>h_ls</code> are not used.
</p>


<h3>Value</h3>

<p>Correlations for the general stationary model. Same dimension of
<code>base_ls</code> if <code>base_fixed = TRUE</code>.
</p>


<h3>See Also</h3>

<p>Other correlation functions: 
<code><a href="#topic+cor_cauchy">cor_cauchy</a>()</code>,
<code><a href="#topic+cor_exp">cor_exp</a>()</code>,
<code><a href="#topic+cor_fs">cor_fs</a>()</code>,
<code><a href="#topic+cor_lagr_askey">cor_lagr_askey</a>()</code>,
<code><a href="#topic+cor_lagr_exp">cor_lagr_exp</a>()</code>,
<code><a href="#topic+cor_lagr_tri">cor_lagr_tri</a>()</code>,
<code><a href="#topic+cor_sep">cor_sep</a>()</code>,
<code><a href="#topic+cor_stat">cor_stat</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fit general stationary model with sep base.
par_s &lt;- list(nugget = 0.5, c = 0.01, gamma = 0.5)
par_t &lt;- list(a = 1, alpha = 0.5)
par_base &lt;- list(par_s = par_s, par_t = par_t)
h1 &lt;- array(c(0, 5, -5, 0), dim = c(2, 2, 3))
h2 &lt;- array(c(0, 8, -8, 0), dim = c(2, 2, 3))
h &lt;- sqrt(h1^2 + h2^2)
u &lt;- array(rep(c(1, 2, 3), each = 4), dim = c(2, 2, 3))
cor_stat_rs(
    n_regime = 2,
    base_ls = list("sep"),
    lagrangian_ls = list("none", "lagr_tri"),
    par_base_ls = list(par_base),
    par_lagr_ls = list(NULL, list(v1 = 10, v2 = 20)),
    lambda_ls = list(0, 0.2),
    h_ls = list(h),
    h1_ls = list(NULL, h1),
    h2_ls = list(NULL, h2),
    u_ls = list(u, u + 1)
)

# Fit general stationary model given fs as the base model.
h1 &lt;- array(c(0, 5, -5, 0), dim = c(2, 2, 3))
h2 &lt;- array(c(0, 8, -8, 0), dim = c(2, 2, 3))
h &lt;- sqrt(h1^2 + h2^2)
u &lt;- array(rep(c(0.1, 0.2, 0.3), each = 4), dim = c(2, 2, 3))
fit_base &lt;- cor_fs(
    nugget = 0.5, c = 0.01, gamma = 0.5, a = 1, alpha = 0.5,
    beta = 0.0, h = h, u = u
)
par_lagr &lt;- list(v1 = 5, v2 = 10)
cor_stat_rs(
    n_regime = 2,
    par_lagr_ls = list(par_lagr),
    h1_ls = list(h1),
    h2_ls = list(h2),
    u_ls = list(u, u + 1),
    lambda_ls = list(0, 0.8),
    base_ls = list(fit_base),
    lagrangian = list("lagr_tri", "lagr_askey"),
    base_fixed = TRUE
)

</code></pre>

<hr>
<h2 id='cor2cov'>Convert correlation to covariance</h2><span id='topic+cor2cov'></span><span id='topic+cor2cov_ar'></span>

<h3>Description</h3>

<p>Convert correlation to covariance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor2cov(V, sd, empirical = FALSE)

cor2cov_ar(V, sd, empirical = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cor2cov_+3A_v">V</code></td>
<td>
<p>A correlation matrix, usually positive semi-definite.</p>
</td></tr>
<tr><td><code id="cor2cov_+3A_sd">sd</code></td>
<td>
<p>A vector of standard deviations.</p>
</td></tr>
<tr><td><code id="cor2cov_+3A_empirical">empirical</code></td>
<td>
<p>Logical; TRUE if V is empirical correlation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cor2cov</code> converts a matrix. <code>cor2cov_ar</code> converts an 3-D array.
</p>


<h3>Value</h3>

<p>A correlation matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>V &lt;- matrix(c(1, 0.5, 0.5, 1), ncol = 2)
sd &lt;- 1:2
cor2cov(V, sd)

V_ar &lt;- array(c(1, 0.5, 0.5, 1), dim = c(2, 2, 2))
cor2cov_ar(V_ar, sd)
</code></pre>

<hr>
<h2 id='cov_joint'>Covariance for joint distribution</h2><span id='topic+cov_joint'></span><span id='topic+cov_par'></span>

<h3>Description</h3>

<p>Covariance for joint distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_joint(cov)

cov_par(cov, horizon = 1, n_var, joint = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cov_joint_+3A_cov">cov</code></td>
<td>
<p>Array of covariance matrices.</p>
</td></tr>
<tr><td><code id="cov_joint_+3A_horizon">horizon</code></td>
<td>
<p>Forecast horizon, default is 1.</p>
</td></tr>
<tr><td><code id="cov_joint_+3A_n_var">n_var</code></td>
<td>
<p>Number of locations.</p>
</td></tr>
<tr><td><code id="cov_joint_+3A_joint">joint</code></td>
<td>
<p>Logical; True if <code>cov</code> is the joint covariance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The covariance matrix of the joint distribution has the block toeplitz
structure. Input <code>cov</code> is assumed to be an array of cross-covariance matrices
where the <code class="reqn">i</code>th matrix slice correspond to the <code class="reqn">(i-1)</code>th time lag.
For example, <code>cov[, , 1]</code> is the cross-covariance matrix for time lag 0. All
matrices in <code>cov</code> are used to construct the joint covariance matrix.
</p>
<p><code>cov_par</code> gives weights and covariance matrix for the current values..
</p>


<h3>Value</h3>

<p>The joint covariance matrix for the joint distribution of the current
values and the past values for a Markov chain Gaussian field.
</p>

<hr>
<h2 id='dists'>Generic function for calculating distance matrices</h2><span id='topic+dists'></span>

<h3>Description</h3>

<p>Generic function for calculating distance matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dists(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dists_+3A_x">x</code></td>
<td>
<p>An <strong>R</strong> object.</p>
</td></tr>
<tr><td><code id="dists_+3A_...">...</code></td>
<td>
<p>Additional parameters or attributes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of signed distance matrices: <code>h</code> (Euclidean), <code>h1</code>
(horizontal), and <code>h2</code> (vertical) with the same dimensions.
</p>

<hr>
<h2 id='dists.mcgf'>Calculating distance matrices for an <code>mcgf</code> object</h2><span id='topic+dists.mcgf'></span><span id='topic++60dists+3C-+60'></span><span id='topic+dists+3C-'></span>

<h3>Description</h3>

<p>Calculating distance matrices for an <code>mcgf</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcgf'
dists(x, return_grid = FALSE, ...)

dists(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dists.mcgf_+3A_x">x</code></td>
<td>
<p>An <code>mcgf</code> object.</p>
</td></tr>
<tr><td><code id="dists.mcgf_+3A_return_grid">return_grid</code></td>
<td>
<p>Logical; used when <code>locations</code> in <code>x</code> are longitudes and
latitudes.</p>
</td></tr>
<tr><td><code id="dists.mcgf_+3A_...">...</code></td>
<td>
<p>Additional parameters or attributes.</p>
</td></tr>
<tr><td><code id="dists.mcgf_+3A_value">value</code></td>
<td>
<p>List of signed distance matrices, outputted from <code><a href="#topic+dists">dists()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>dists</code> attribute is available in <code>x</code>, it will be printed. Otherwise
<code>dists</code> will be calculated based on the <code>locations</code> attribute.
</p>


<h3>Value</h3>

<p>A list of signed distance matrices: <code>h</code> (Euclidean), <code>h1</code>
(horizontal), and <code>h2</code> (vertical).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- cbind(S1 = 1:5, S2 = 4:8, S3 = 5:9)
lon &lt;- c(110, 120, 130)
lat &lt;- c(50, 55, 60)
locations &lt;- cbind(lon, lat)

# if locations are longitudes and latitudes
obj &lt;- mcgf(data = data, locations = locations)
obj
dists(obj)
dists(obj) &lt;- dists(obj)
obj

# if locations are just coordinates in a 2D plane:
obj &lt;- mcgf(data = data, locations = locations, longlat = FALSE)
obj

# calculate distances
dists(obj)

# add distances to the `mcgf` object
dists(obj) &lt;- dists(obj)
obj
</code></pre>

<hr>
<h2 id='estimate'>Optimization for wls method</h2><span id='topic+estimate'></span>

<h3>Description</h3>

<p>Optimization for wls method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate(par_init, method, optim_fn, cor_fn, par_fixed, lower, upper, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_+3A_par_init">par_init</code></td>
<td>
<p>Initial values for parameters to be optimized.</p>
</td></tr>
<tr><td><code id="estimate_+3A_method">method</code></td>
<td>
<p>Parameter estimation method. &quot;wls&quot; or &quot;mle&quot;.</p>
</td></tr>
<tr><td><code id="estimate_+3A_optim_fn">optim_fn</code></td>
<td>
<p>Optimization function.</p>
</td></tr>
<tr><td><code id="estimate_+3A_cor_fn">cor_fn</code></td>
<td>
<p>Correlation function.</p>
</td></tr>
<tr><td><code id="estimate_+3A_par_fixed">par_fixed</code></td>
<td>
<p>Fixed parameters of <code>cor_fn</code>.</p>
</td></tr>
<tr><td><code id="estimate_+3A_lower">lower</code></td>
<td>
<p>Lower bound.</p>
</td></tr>
<tr><td><code id="estimate_+3A_upper">upper</code></td>
<td>
<p>Upper bound.</p>
</td></tr>
<tr><td><code id="estimate_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>optim_fn</code>, <code>obj_wls</code> or <code>obj_mle</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list outputted from optimization functions of <code>optim_fn</code>.
</p>

<hr>
<h2 id='find_dists'>Calculate (signed) distances between coordinates</h2><span id='topic+find_dists'></span>

<h3>Description</h3>

<p>Calculate (signed) distances between coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_dists(locations, longlat = TRUE, origin = 1L, return_grid = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_dists_+3A_locations">locations</code></td>
<td>
<p>A matrix or data.frame of 2D points, the first column is
x/longitude, and the second column is y/latitude.</p>
</td></tr>
<tr><td><code id="find_dists_+3A_longlat">longlat</code></td>
<td>
<p>Logical, if TURE Great Circle (WGS84 ellipsoid) distance;
if FALSE, Euclidean distance.</p>
</td></tr>
<tr><td><code id="find_dists_+3A_origin">origin</code></td>
<td>
<p>Optional; used when <code>longlat</code> is TRUE. An integer index
indicating the reference location which will be used as the origin.</p>
</td></tr>
<tr><td><code id="find_dists_+3A_return_grid">return_grid</code></td>
<td>
<p>Logical; used when <code>longlat</code> is TRUE. If TRUE the mapped
coordinates on a 2D plane is returned.</p>
</td></tr>
<tr><td><code id="find_dists_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to <code><a href="#topic+.find_dists">.find_dists()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>locations</code> must be a matrix or data.frame containing 2 columns,
first column x/longitude, and second column y/latitude. The row names of
<code>locations</code> are used as the names of the locations.
</p>
<p>If <code>longlat</code> is TRUE, the original coordinates are mapped to a 2D Euclidean
plane given the reference location. First, the Great Circle (WGS84 ellipsoid)
signed distance matrices are calculated, where the original latitudes are
replaced by the the mean of them to find the signed longitudinal
distances and the original longitudes are replaced by the the mean of them
to find the signed latitudinal distances. Then given the index of a
reference location <code>origin</code>, a new set of coordinates in a 2D plane is
generated where the coordinates are determined by the signed distances
between the locations and the reference location. Finally distance matrices
of the new coordinates are outputted.
</p>


<h3>Value</h3>

<p>A list of distance matrices. If <code>return_grid</code> is TRUE, a list
consists of a list of distance matrices, the mapped 2D grid, and the origin
is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lon &lt;- c(110, 120, 130)
lat &lt;- c(50, 55, 60)
locations &lt;- cbind(lon, lat)
rownames(locations) &lt;- paste("Site", 1:3)
find_dists(locations)
</code></pre>

<hr>
<h2 id='find_dists_new'>Calculate (signed) distances between coordinates</h2><span id='topic+find_dists_new'></span>

<h3>Description</h3>

<p>Calculate (signed) distances between coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_dists_new(
  locations,
  locations_new,
  longlat = TRUE,
  origin = 1L,
  return_grid = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_dists_new_+3A_locations">locations</code></td>
<td>
<p>A matrix or data.frame of 2D points, the first column is
x/longitude, and the second column is y/latitude.</p>
</td></tr>
<tr><td><code id="find_dists_new_+3A_locations_new">locations_new</code></td>
<td>
<p>A matrix or data.frame of 2D points, the first column is
x/longitude, and the second column is y/latitude.</p>
</td></tr>
<tr><td><code id="find_dists_new_+3A_longlat">longlat</code></td>
<td>
<p>Logical, if TURE Great Circle (WGS84 ellipsoid) distance;
if FALSE, Euclidean distance.</p>
</td></tr>
<tr><td><code id="find_dists_new_+3A_origin">origin</code></td>
<td>
<p>Optional; used when <code>longlat</code> is TRUE. An integer index
indicating the reference location from <code>locations</code> which will be used as
the origin. Same <code>origin</code> from <code>find_dists</code> must be used to ensure
consistancy between outputs from <code>find_dists</code> and <code>find_dists_new</code>.</p>
</td></tr>
<tr><td><code id="find_dists_new_+3A_return_grid">return_grid</code></td>
<td>
<p>Logical; used when <code>longlat</code> is TRUE. If TRUE the mapped
coordinates on a 2D plane for all locations is returned.</p>
</td></tr>
<tr><td><code id="find_dists_new_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to <code><a href="#topic+.find_dists_new">.find_dists_new()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>locations</code> and <code>locations_new</code> must be matrices or data.frames containing
2 columns, first column x/longitude, and second column y/latitude. The row
names of <code>locations</code> and <code>locations_new</code> are used as the names of the
locations.
</p>
<p>If <code>longlat</code> is TRUE, the original coordinates are mapped to a 2D Euclidean
plane given the reference location from <code>locations</code>. First, the Great Circle
(WGS84 ellipsoid) signed distance matrices are calculated, where the original
latitudes are replaced by the the mean of latitudes in <code>locations</code> to find
the signed longitudinal distances and the original longitudes are replaced by
the the mean of longitudes in <code>locations</code> to find the signed latitudinal
distances. Then given the index of a reference location <code>origin</code>, a new set
of coordinates in a 2D plane is generated where the coordinates are
determined by the signed distances between the locations and the reference
location. Finally distance matrices of the new coordinates for all stations
are outputted.
</p>


<h3>Value</h3>

<p>A list of distance matrices for all locations. If <code>return_grid</code> is
TRUE, a list consists of a list of distance matrices for all locations,
the mapped 2D grid for all locations, and the origin is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lon &lt;- c(110, 120, 130)
lat &lt;- c(50, 55, 60)
locations &lt;- cbind(lon, lat)
rownames(locations) &lt;- paste("Site", 1:3)
find_dists(locations)

locations_new &lt;- c(115, 55)
find_dists_new(locations, locations_new)
</code></pre>

<hr>
<h2 id='fit_base'>Fit correlation base models</h2><span id='topic+fit_base'></span>

<h3>Description</h3>

<p>Fit correlation base models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_base(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_base_+3A_x">x</code></td>
<td>
<p>An <strong>R</strong> object.</p>
</td></tr>
<tr><td><code id="fit_base_+3A_...">...</code></td>
<td>
<p>Additional parameters or attributes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Refer to <code><a href="#topic+fit_base.mcgf">fit_base.mcgf()</a></code> and <code><a href="#topic+fit_base.mcgf_rs">fit_base.mcgf_rs()</a></code> for more details.
</p>


<h3>Value</h3>

<p>A vector of estimated parameters.
</p>

<hr>
<h2 id='fit_base.mcgf'>Parameter estimation for symmetric correlation functions for an <code>mcgf</code>
object.</h2><span id='topic+fit_base.mcgf'></span>

<h3>Description</h3>

<p>Parameter estimation for symmetric correlation functions for an <code>mcgf</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcgf'
fit_base(
  x,
  lag,
  horizon = 1,
  model = c("spatial", "temporal", "sep", "fs", "none"),
  method = c("wls", "mle"),
  optim_fn = c("nlminb", "optim", "other"),
  par_fixed = NULL,
  par_init,
  lower = NULL,
  upper = NULL,
  other_optim_fn = NULL,
  dists_base = NULL,
  scale_time = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_base.mcgf_+3A_x">x</code></td>
<td>
<p>An <code>mcgf</code> object containing attributes <code>dists</code>, <code>acfs</code>, <code>ccfs</code>, and
<code>sds</code>.</p>
</td></tr>
<tr><td><code id="fit_base.mcgf_+3A_lag">lag</code></td>
<td>
<p>Integer time lag.</p>
</td></tr>
<tr><td><code id="fit_base.mcgf_+3A_horizon">horizon</code></td>
<td>
<p>Integer forecast horizon.</p>
</td></tr>
<tr><td><code id="fit_base.mcgf_+3A_model">model</code></td>
<td>
<p>Base model, one of <code>spatial</code>, <code>temporal</code>, <code>sep</code>, <code>fs</code>, <code>none</code>.
Only <code>sep</code> and <code>fs</code> are supported when <code>method = mle</code>. If <code>none</code>, NULLs are
returned.</p>
</td></tr>
<tr><td><code id="fit_base.mcgf_+3A_method">method</code></td>
<td>
<p>Parameter estimation methods, weighted least square (<code>wls</code>) or
maximum likelihood estimation (<code>mle</code>).</p>
</td></tr>
<tr><td><code id="fit_base.mcgf_+3A_optim_fn">optim_fn</code></td>
<td>
<p>Optimization functions, one of <code>nlminb</code>, <code>optim</code>, <code>other</code>.
When <code>optim_fn = other</code>, supply <code>other_optim_fn</code>.</p>
</td></tr>
<tr><td><code id="fit_base.mcgf_+3A_par_fixed">par_fixed</code></td>
<td>
<p>Fixed parameters.</p>
</td></tr>
<tr><td><code id="fit_base.mcgf_+3A_par_init">par_init</code></td>
<td>
<p>Initial values for parameters to be optimized.</p>
</td></tr>
<tr><td><code id="fit_base.mcgf_+3A_lower">lower</code></td>
<td>
<p>Optional; lower bounds of parameters.</p>
</td></tr>
<tr><td><code id="fit_base.mcgf_+3A_upper">upper</code></td>
<td>
<p>Optional: upper bounds of parameters.</p>
</td></tr>
<tr><td><code id="fit_base.mcgf_+3A_other_optim_fn">other_optim_fn</code></td>
<td>
<p>Optional, other optimization functions. The first two
arguments must be initial values for the parameters and a function to be
minimized respectively (same as that of <code>optim</code> and <code>nlminb</code>).</p>
</td></tr>
<tr><td><code id="fit_base.mcgf_+3A_dists_base">dists_base</code></td>
<td>
<p>List of distance matrices. If NULL, <code>dists(x)</code> is used.
Must be a matrix or an array of distance matrices.</p>
</td></tr>
<tr><td><code id="fit_base.mcgf_+3A_scale_time">scale_time</code></td>
<td>
<p>Scale of time unit, default is 1. <code>lag</code> is divided by
<code>scale_time</code> for parameter estimation.</p>
</td></tr>
<tr><td><code id="fit_base.mcgf_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>optim_fn</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits the separable and fully symmetric models using weighted
least squares and maximum likelihood estimation. Optimization functions such
as <code>nlminb</code> and <code>optim</code> are supported. Other functions are also supported by
setting <code>optim_fn = "other"</code> and supplying <code>other_optim_fn</code>. <code>lower</code> and
<code>upper</code> are lower and upper bounds of parameters in <code>par_init</code> and default
bounds are used if they are not specified.
</p>
<p>Note that both <code>wls</code> and <code>mle</code> are heuristic approaches when <code>x</code> contains
observations from a subset of the discrete spatial domain, though estimation
results are close to that using the full spatial domain for large sample
sizes.
</p>


<h3>Value</h3>

<p>A list containing outputs from optimization functions of <code>optim_fn</code>.
</p>


<h3>See Also</h3>

<p>Other functions on fitting an mcgf: 
<code><a href="#topic+add_base.mcgf">add_base.mcgf</a>()</code>,
<code><a href="#topic+add_lagr.mcgf">add_lagr.mcgf</a>()</code>,
<code><a href="#topic+fit_lagr.mcgf">fit_lagr.mcgf</a>()</code>,
<code><a href="#topic+krige.mcgf">krige.mcgf</a>()</code>,
<code><a href="#topic+krige_new.mcgf">krige_new.mcgf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim1)
sim1_mcgf &lt;- mcgf(sim1$data, dists = sim1$dists)
sim1_mcgf &lt;- add_acfs(sim1_mcgf, lag_max = 5)
sim1_mcgf &lt;- add_ccfs(sim1_mcgf, lag_max = 5)

# Fit a pure spatial model
fit_spatial &lt;- fit_base(
    sim1_mcgf,
    model = "spatial",
    lag = 5,
    par_init = c(c = 0.001, gamma = 0.5),
    par_fixed = c(nugget = 0)
)
fit_spatial$fit

# Fit a pure temporal model
fit_temporal &lt;- fit_base(
    sim1_mcgf,
    model = "temporal",
    lag = 5,
    par_init = c(a = 0.3, alpha = 0.5)
)
fit_temporal$fit

# Fit a separable model
fit_sep &lt;- fit_base(
    sim1_mcgf,
    model = "sep",
    lag = 5,
    par_init = c(
        c = 0.001,
        gamma = 0.5,
        a = 0.3,
        alpha = 0.5
    ),
    par_fixed = c(nugget = 0)
)
fit_sep$fit
</code></pre>

<hr>
<h2 id='fit_base.mcgf_rs'>Parameter estimation for symmetric correlation functions for an <code>mcgf_rs</code>
object.</h2><span id='topic+fit_base.mcgf_rs'></span>

<h3>Description</h3>

<p>Parameter estimation for symmetric correlation functions for an <code>mcgf_rs</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcgf_rs'
fit_base(
  x,
  lag_ls,
  horizon = 1,
  model_ls,
  method_ls = "wls",
  optim_fn_ls = "nlminb",
  par_fixed_ls = list(NULL),
  par_init_ls,
  lower_ls = list(NULL),
  upper_ls = list(NULL),
  other_optim_fn_ls = list(NULL),
  dists_base_ls = list(NULL),
  scale_time = 1,
  rs = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_base.mcgf_rs_+3A_x">x</code></td>
<td>
<p>An <code>mcgf_rs</code> object containing attributes <code>dists</code>, <code>acfs</code>, <code>ccfs</code>,
and <code>sds</code>.</p>
</td></tr>
<tr><td><code id="fit_base.mcgf_rs_+3A_lag_ls">lag_ls</code></td>
<td>
<p>List of integer time lags.</p>
</td></tr>
<tr><td><code id="fit_base.mcgf_rs_+3A_horizon">horizon</code></td>
<td>
<p>Integer forecast horizon.</p>
</td></tr>
<tr><td><code id="fit_base.mcgf_rs_+3A_model_ls">model_ls</code></td>
<td>
<p>List of base models, each element must be one of <code>spatial</code>,
<code>temporal</code>, <code>sep</code>, <code>fs</code>. Only <code>sep</code> and <code>fs</code> are supported when <code>mle</code> is used
in <code>model_ls</code>.</p>
</td></tr>
<tr><td><code id="fit_base.mcgf_rs_+3A_method_ls">method_ls</code></td>
<td>
<p>List of parameter estimation methods, weighted least square
(<code>wls</code>) or maximum likelihood estimation (<code>mle</code>).</p>
</td></tr>
<tr><td><code id="fit_base.mcgf_rs_+3A_optim_fn_ls">optim_fn_ls</code></td>
<td>
<p>List of optimization functions, each element must be one
of <code>nlminb</code>, <code>optim</code>, <code>other</code>. When use <code>other</code>, supply <code>other_optim_fn_ls</code>.</p>
</td></tr>
<tr><td><code id="fit_base.mcgf_rs_+3A_par_fixed_ls">par_fixed_ls</code></td>
<td>
<p>List of fixed parameters.</p>
</td></tr>
<tr><td><code id="fit_base.mcgf_rs_+3A_par_init_ls">par_init_ls</code></td>
<td>
<p>List of initial values for parameters to be optimized.</p>
</td></tr>
<tr><td><code id="fit_base.mcgf_rs_+3A_lower_ls">lower_ls</code></td>
<td>
<p>Optional; list of lower bounds of parameters.</p>
</td></tr>
<tr><td><code id="fit_base.mcgf_rs_+3A_upper_ls">upper_ls</code></td>
<td>
<p>Optional: list of upper bounds of parameters.</p>
</td></tr>
<tr><td><code id="fit_base.mcgf_rs_+3A_other_optim_fn_ls">other_optim_fn_ls</code></td>
<td>
<p>Optional, list of other optimization functions. The
first two arguments must be initial values for the parameters and a function
to be minimized respectively (same as that of <code>optim</code> and <code>nlminb</code>).</p>
</td></tr>
<tr><td><code id="fit_base.mcgf_rs_+3A_dists_base_ls">dists_base_ls</code></td>
<td>
<p>List of lists of distance matrices. If NULL, <code>dists(x)</code>
is used. Each element must be a matrix or an array of distance matrices.</p>
</td></tr>
<tr><td><code id="fit_base.mcgf_rs_+3A_scale_time">scale_time</code></td>
<td>
<p>Scale of time unit, default is 1. <code>lag</code> is divided by
<code>scale_time</code> for parameter estimation.</p>
</td></tr>
<tr><td><code id="fit_base.mcgf_rs_+3A_rs">rs</code></td>
<td>
<p>Logical; if TRUE <code>x</code> is treated as a regime-switching, FALSE if the
parameters need to be estimated in a non-regime-switching setting.</p>
</td></tr>
<tr><td><code id="fit_base.mcgf_rs_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to all <code>optim_fn_ls</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions is the regime-switching variant of <code><a href="#topic+fit_base.mcgf">fit_base.mcgf()</a></code>.
Arguments are in lists. The length of arguments that end in <code style="white-space: pre;">&#8288;_ls&#8288;</code> must be 1
or the same as the number of regimes in <code>x</code>. If the length of an argument is
1, then it is set the same for all regimes. Refer to <code><a href="#topic+fit_base.mcgf">fit_base.mcgf()</a></code> for
more details of the arguments.
</p>
<p>Note that both <code>wls</code> and <code>mle</code> are heuristic approaches when <code>x</code> contains
observations from a subset of the discrete spatial domain, though estimation
results are close to that using the full spatial domain for large sample
sizes.
</p>


<h3>Value</h3>

<p>A list containing outputs from optimization functions of <code>optim_fn</code>
for each regime.
</p>


<h3>See Also</h3>

<p>Other functions on fitting an mcgf_rs: 
<code><a href="#topic+add_base.mcgf_rs">add_base.mcgf_rs</a>()</code>,
<code><a href="#topic+add_lagr.mcgf_rs">add_lagr.mcgf_rs</a>()</code>,
<code><a href="#topic+fit_lagr.mcgf_rs">fit_lagr.mcgf_rs</a>()</code>,
<code><a href="#topic+krige.mcgf_rs">krige.mcgf_rs</a>()</code>,
<code><a href="#topic+krige_new.mcgf_rs">krige_new.mcgf_rs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim2)
sim2_mcgf &lt;- mcgf_rs(sim2$data, dists = sim2$dists, label = sim2$label)
sim2_mcgf &lt;- add_acfs(sim2_mcgf, lag_max = 5)
sim2_mcgf &lt;- add_ccfs(sim2_mcgf, lag_max = 5)

# Fit a regime-switching pure spatial model
fit_spatial &lt;-
    fit_base(
        sim2_mcgf,
        lag_ls = 5,
        model_ls = "spatial",
        par_init_ls = list(c(c = 0.00005, gamma = 0.5)),
        par_fixed_ls = list(c(nugget = 0))
    )
lapply(fit_spatial[1:2], function(x) x$fit)

# Fit a regime-switching pure temporal model
fit_temporal &lt;-
    fit_base(
        sim2_mcgf,
        lag_ls = 5,
        model_ls = "temporal",
        par_init_ls = list(
            list(a = 0.8, alpha = 0.8),
            list(a = 0.1, alpha = 0.1)
        )
    )
lapply(fit_temporal[1:2], function(x) x$fit)

# Fit a regime-switching separable model
fit_sep &lt;- fit_base(
    sim2_mcgf,
    lag_ls = 5,
    model_ls = "sep",
    par_init_ls = list(list(
        c = 0.00005,
        gamma = 0.5,
        a = 0.5,
        alpha = 0.5
    )),
    par_fixed_ls = list(c(nugget = 0))
)
lapply(fit_sep[1:2], function(x) x$fit)
</code></pre>

<hr>
<h2 id='fit_lagr'>Fit correlation Lagrangian models</h2><span id='topic+fit_lagr'></span>

<h3>Description</h3>

<p>Fit correlation Lagrangian models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_lagr(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_lagr_+3A_x">x</code></td>
<td>
<p>An <strong>R</strong> object.</p>
</td></tr>
<tr><td><code id="fit_lagr_+3A_...">...</code></td>
<td>
<p>Additional parameters or attributes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Refer to <code><a href="#topic+fit_lagr.mcgf">fit_lagr.mcgf()</a></code> and <code><a href="#topic+fit_lagr.mcgf_rs">fit_lagr.mcgf_rs()</a></code> for more details.
</p>


<h3>Value</h3>

<p>A vector of estimated parameters.
</p>

<hr>
<h2 id='fit_lagr.mcgf'>Parameter estimation for Lagrangian correlation functions for an <code>mcgf</code>
object.</h2><span id='topic+fit_lagr.mcgf'></span>

<h3>Description</h3>

<p>Parameter estimation for Lagrangian correlation functions for an <code>mcgf</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcgf'
fit_lagr(
  x,
  model = c("lagr_tri", "lagr_askey", "lagr_exp", "none"),
  method = c("wls", "mle"),
  optim_fn = c("nlminb", "optim", "other"),
  par_fixed = NULL,
  par_init,
  lower = NULL,
  upper = NULL,
  other_optim_fn = NULL,
  dists_base = FALSE,
  dists_lagr = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_lagr.mcgf_+3A_x">x</code></td>
<td>
<p>An <code>mcgf</code> object containing attributes <code>dists</code>, <code>acfs</code>, <code>ccfs</code>, and
<code>sds</code>. <code>x</code> must have been passed to <code>add_base()</code> or <code style="white-space: pre;">&#8288;base&lt;-&#8288;</code></p>
</td></tr>
<tr><td><code id="fit_lagr.mcgf_+3A_model">model</code></td>
<td>
<p>Base model, one of <code>lagr_tri</code>, <code>lagr_askey</code>, <code>lagr_exp</code>, or
<code>none</code>.
If <code>none</code>, NULLs are returned.</p>
</td></tr>
<tr><td><code id="fit_lagr.mcgf_+3A_method">method</code></td>
<td>
<p>Parameter estimation methods, weighted least square (<code>wls</code>) or
maximum likelihood estimation (<code>mle</code>).</p>
</td></tr>
<tr><td><code id="fit_lagr.mcgf_+3A_optim_fn">optim_fn</code></td>
<td>
<p>Optimization functions, one of <code>nlminb</code>, <code>optim</code>, <code>other</code>.
When <code>optim_fn = other</code>, supply <code>other_optim_fn</code>.</p>
</td></tr>
<tr><td><code id="fit_lagr.mcgf_+3A_par_fixed">par_fixed</code></td>
<td>
<p>Fixed parameters.</p>
</td></tr>
<tr><td><code id="fit_lagr.mcgf_+3A_par_init">par_init</code></td>
<td>
<p>Initial values for parameters to be optimized.</p>
</td></tr>
<tr><td><code id="fit_lagr.mcgf_+3A_lower">lower</code></td>
<td>
<p>Optional; lower bounds of parameters lambda, v1, v2, and k.</p>
</td></tr>
<tr><td><code id="fit_lagr.mcgf_+3A_upper">upper</code></td>
<td>
<p>Optional: upper bounds of parameters lambda, v1, v2, and k.</p>
</td></tr>
<tr><td><code id="fit_lagr.mcgf_+3A_other_optim_fn">other_optim_fn</code></td>
<td>
<p>Optional, other optimization functions. The first two
arguments must be initial values for the parameters and a function to be
minimized respectively (same as that of <code>optim</code> and <code>nlminb</code>).</p>
</td></tr>
<tr><td><code id="fit_lagr.mcgf_+3A_dists_base">dists_base</code></td>
<td>
<p>Logical; if TRUE <code>dists_base</code> from the base model is used
as the distance.</p>
</td></tr>
<tr><td><code id="fit_lagr.mcgf_+3A_dists_lagr">dists_lagr</code></td>
<td>
<p>List of distance matrices/arrays. Used when <code>dists_base</code> is
FALSE. If NULL, <code>dists(x)</code> is used.</p>
</td></tr>
<tr><td><code id="fit_lagr.mcgf_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>optim_fn</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits the Lagrangian models using weighted least squares and
maximum likelihood estimation. The base model must be fitted first using
<code>add_base()</code> or <code style="white-space: pre;">&#8288;base&lt;-&#8288;</code>. Optimization functions such as <code>nlminb</code> and <code>optim</code>
are supported. Other functions are also supported by setting
<code>optim_fn = "other"</code> and supplying <code>other_optim_fn</code>. <code>lower</code> and <code>upper</code> are
lower and upper bounds of parameters in <code>par_init</code> and default bounds are
used if they are not specified.
</p>
<p>Note that both <code>wls</code> and <code>mle</code> are heuristic approaches when <code>x</code> contains
observations from a subset of the discrete spatial domain, though estimation
results are close to that using the full spatial domain for large sample
sizes.
</p>
<p>Since parameters for the base model and the Lagrangian model are estimated
sequentially, more accurate estimation may be obtained if the full model is
fitted all at once.
</p>


<h3>Value</h3>

<p>A list containing outputs from optimization functions of <code>optim_fn</code>.
</p>


<h3>See Also</h3>

<p>Other functions on fitting an mcgf: 
<code><a href="#topic+add_base.mcgf">add_base.mcgf</a>()</code>,
<code><a href="#topic+add_lagr.mcgf">add_lagr.mcgf</a>()</code>,
<code><a href="#topic+fit_base.mcgf">fit_base.mcgf</a>()</code>,
<code><a href="#topic+krige.mcgf">krige.mcgf</a>()</code>,
<code><a href="#topic+krige_new.mcgf">krige_new.mcgf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim1)
sim1_mcgf &lt;- mcgf(sim1$data, dists = sim1$dists)
sim1_mcgf &lt;- add_acfs(sim1_mcgf, lag_max = 5)
sim1_mcgf &lt;- add_ccfs(sim1_mcgf, lag_max = 5)

# Fit a separable model and store it to 'sim1_mcgf'
fit_sep &lt;- fit_base(
    sim1_mcgf,
    model = "sep",
    lag = 5,
    par_init = c(
        c = 0.001,
        gamma = 0.5,
        a = 0.3,
        alpha = 0.5
    ),
    par_fixed = c(nugget = 0)
)
sim1_mcgf &lt;- add_base(sim1_mcgf, fit_base = fit_sep)

# Fit a Lagrangian model
fit_lagr &lt;- fit_lagr(
    sim1_mcgf,
    model = "lagr_tri",
    par_init = c(v1 = 300, v2 = 300, lambda = 0.15),
    par_fixed = c(k = 2)
)
fit_lagr$fit
</code></pre>

<hr>
<h2 id='fit_lagr.mcgf_rs'>Parameter estimation for Lagrangian correlation functions for an <code>mcgf_rs</code>
object.</h2><span id='topic+fit_lagr.mcgf_rs'></span>

<h3>Description</h3>

<p>Parameter estimation for Lagrangian correlation functions for an <code>mcgf_rs</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcgf_rs'
fit_lagr(
  x,
  model_ls,
  method_ls = "wls",
  optim_fn_ls = "nlminb",
  par_fixed_ls = list(NULL),
  par_init_ls,
  lower_ls = list(NULL),
  upper_ls = list(NULL),
  other_optim_fn_ls = list(NULL),
  dists_base_ls,
  dists_lagr_ls = list(NULL),
  rs = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_lagr.mcgf_rs_+3A_x">x</code></td>
<td>
<p>An <code>mcgf_rs</code> object containing attributes <code>dists</code>, <code>acfs</code>, <code>ccfs</code>,
and <code>sds</code>. <code>x</code> must have been passed to <code>add_base()</code> or <code style="white-space: pre;">&#8288;base&lt;-&#8288;</code></p>
</td></tr>
<tr><td><code id="fit_lagr.mcgf_rs_+3A_model_ls">model_ls</code></td>
<td>
<p>List of base models, each element must be one of <code>lagr_tri</code>,
<code>lagr_askey</code>, <code>lagr_exp</code>, or <code>none</code>. If <code>none</code>, NULLs are returned.</p>
</td></tr>
<tr><td><code id="fit_lagr.mcgf_rs_+3A_method_ls">method_ls</code></td>
<td>
<p>List of parameter estimation methods, weighted least square
(<code>wls</code>) or maximum likelihood estimation (<code>mle</code>).</p>
</td></tr>
<tr><td><code id="fit_lagr.mcgf_rs_+3A_optim_fn_ls">optim_fn_ls</code></td>
<td>
<p>List of optimization functions, each element must be one
of <code>nlminb</code>, <code>optim</code>, <code>other</code>. When use <code>other</code>, supply <code>other_optim_fn_ls</code></p>
</td></tr>
<tr><td><code id="fit_lagr.mcgf_rs_+3A_par_fixed_ls">par_fixed_ls</code></td>
<td>
<p>List of fixed parameters.</p>
</td></tr>
<tr><td><code id="fit_lagr.mcgf_rs_+3A_par_init_ls">par_init_ls</code></td>
<td>
<p>List of initial values for parameters to be optimized.</p>
</td></tr>
<tr><td><code id="fit_lagr.mcgf_rs_+3A_lower_ls">lower_ls</code></td>
<td>
<p>Optional; list of lower bounds of parameters.</p>
</td></tr>
<tr><td><code id="fit_lagr.mcgf_rs_+3A_upper_ls">upper_ls</code></td>
<td>
<p>Optional: list of upper bounds of parameters.</p>
</td></tr>
<tr><td><code id="fit_lagr.mcgf_rs_+3A_other_optim_fn_ls">other_optim_fn_ls</code></td>
<td>
<p>Optional, list of other optimization functions. The
first two arguments must be initial values for the parameters and a function
to be minimized respectively (same as that of <code>optim</code> and <code>nlminb</code>).</p>
</td></tr>
<tr><td><code id="fit_lagr.mcgf_rs_+3A_dists_base_ls">dists_base_ls</code></td>
<td>
<p>List of lists of distance matrices. If NULL, <code>dists(x)</code>
is used. Each element must be a matrix or an array of distance matrices.</p>
</td></tr>
<tr><td><code id="fit_lagr.mcgf_rs_+3A_dists_lagr_ls">dists_lagr_ls</code></td>
<td>
<p>List of distance matrices/arrays. Used when
<code>dists_base</code> is FALSE. If NULL, <code>dists(x)</code> is used.</p>
</td></tr>
<tr><td><code id="fit_lagr.mcgf_rs_+3A_rs">rs</code></td>
<td>
<p>Logical; if TRUE <code>x</code> is treated as a regime-switching, FALSE if the
parameters need to be estimated in a non-regime-switching setting.</p>
</td></tr>
<tr><td><code id="fit_lagr.mcgf_rs_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>optim_fn</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions is the regime-switching variant of <code><a href="#topic+fit_lagr.mcgf">fit_lagr.mcgf()</a></code>.
Arguments are in lists. The length of arguments that end in <code style="white-space: pre;">&#8288;_ls&#8288;</code> must be 1
or the same as the number of regimes in <code>x</code>. If the length of an argument is
1, then it is set the same for all regimes. Refer to <code><a href="#topic+fit_lagr.mcgf">fit_lagr.mcgf()</a></code> for
more details of the arguments.
</p>
<p>Note that both <code>wls</code> and <code>mle</code> are heuristic approaches when <code>x</code> contains
observations from a subset of the discrete spatial domain, though estimation
results are close to that using the full spatial domain for large sample
sizes.
</p>
<p>Since parameters for the base model and the Lagrangian model are estimated
sequentially, more accurate estimation may be obtained if the full model is
fitted all at once.
</p>


<h3>Value</h3>

<p>A list containing outputs from optimization functions of <code>optim_fn</code>.
</p>


<h3>See Also</h3>

<p>Other functions on fitting an mcgf_rs: 
<code><a href="#topic+add_base.mcgf_rs">add_base.mcgf_rs</a>()</code>,
<code><a href="#topic+add_lagr.mcgf_rs">add_lagr.mcgf_rs</a>()</code>,
<code><a href="#topic+fit_base.mcgf_rs">fit_base.mcgf_rs</a>()</code>,
<code><a href="#topic+krige.mcgf_rs">krige.mcgf_rs</a>()</code>,
<code><a href="#topic+krige_new.mcgf_rs">krige_new.mcgf_rs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim3)
sim3_mcgf &lt;- mcgf_rs(sim3$data, dists = sim3$dists, label = sim3$label)
sim3_mcgf &lt;- add_acfs(sim3_mcgf, lag_max = 5)
sim3_mcgf &lt;- add_ccfs(sim3_mcgf, lag_max = 5)

# Fit a fully symmetric model with known variables
fit_fs &lt;- fit_base(
    sim3_mcgf,
    lag_ls = 5,
    model_ls = "fs",
    rs = FALSE,
    par_init_ls = list(list(beta = 0)),
    par_fixed_ls = list(list(
        nugget = 0,
        c = 0.05,
        gamma = 0.5,
        a = 0.5,
        alpha = 0.2
    ))
)

# Set beta to 0 to fit a separable model with known variables
fit_fs[[1]]$fit$par &lt;- 0

# Store the fitted separable model to 'sim3_mcgf'
sim3_mcgf &lt;- add_base(sim3_mcgf, fit_base_ls = fit_fs)

# Fit a regime-switching Lagrangian model.
fit_lagr_rs &lt;- fit_lagr(
    sim3_mcgf,
    model_ls = list("lagr_tri"),
    par_init_ls = list(
        list(v1 = -50, v2 = 50),
        list(v1 = 100, v2 = 100)
    ),
    par_fixed_ls = list(list(lambda = 0.2, k = 2))
)
lapply(fit_lagr_rs[1:2], function(x) x$fit)
</code></pre>

<hr>
<h2 id='is_numeric_scalar'>Check if numeric scalar</h2><span id='topic+is_numeric_scalar'></span>

<h3>Description</h3>

<p>Check if numeric scalar
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_numeric_scalar(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_numeric_scalar_+3A_x">x</code></td>
<td>
<p>Input</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Check if <code>x</code> is a numeric scalar.
</p>


<h3>Value</h3>

<p>Logical.
</p>

<hr>
<h2 id='is.mcgf'>Check if an object is an <code>mcgf</code> object.</h2><span id='topic+is.mcgf'></span>

<h3>Description</h3>

<p>Check if an object is an <code>mcgf</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.mcgf(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.mcgf_+3A_x">x</code></td>
<td>
<p>An Object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical; TRUE if <code>x</code> is of the <code>mcgf</code> class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim1)
is.mcgf(sim1)

sim1_mcgf &lt;- mcgf(sim1$data, dists = sim1$dists)
is.mcgf(sim1_mcgf)
</code></pre>

<hr>
<h2 id='is.mcgf_rs'>Check if an object is an <code>mcgf_rs</code> object..</h2><span id='topic+is.mcgf_rs'></span><span id='topic+as.mcgf_rs'></span>

<h3>Description</h3>

<p>Check if an object is an <code>mcgf_rs</code> object..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.mcgf_rs(x)

as.mcgf_rs(x, label, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.mcgf_rs_+3A_x">x</code></td>
<td>
<p>An Object.</p>
</td></tr>
<tr><td><code id="is.mcgf_rs_+3A_label">label</code></td>
<td>
<p>A vector of regime labels. Its length must be the same as
the number rows in <code>data</code>.</p>
</td></tr>
<tr><td><code id="is.mcgf_rs_+3A_ncores">ncores</code></td>
<td>
<p>Number of cpu cores used for computing in <code style="white-space: pre;">&#8288;[ccfs()]&#8288;</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is.mcgf_rs</code> returns a logical valud; TRUE if <code>x</code> is of the <code>mcgf_rs</code>
class. <code>as.mcgf_rs</code> coerces an <code>mcgf</code> object to an <code>mcgf_rs</code> object by adding
regime labels. Fitted base or Lagrangian models in <code>x</code> are kept.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim2)
is.mcgf_rs(sim2)

sim2_mcgf &lt;- mcgf(sim2$data, dists = sim2$dists)
is.mcgf_rs(sim2_mcgf)

sim2_mcgf &lt;- mcgf_rs(sim2$data, dists = sim2$dists, label = sim2$label)
is.mcgf_rs(sim2_mcgf)
data(sim2)
sim2_mcgf &lt;- mcgf(sim2$data, dists = sim2$dists)
sim2_mcgf &lt;- as.mcgf_rs(sim2_mcgf, label = sim2$label)
</code></pre>

<hr>
<h2 id='krige'>Generic function for computing kriging forecasts</h2><span id='topic+krige'></span>

<h3>Description</h3>

<p>Generic function for computing kriging forecasts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>krige(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="krige_+3A_x">x</code></td>
<td>
<p>An <strong>R</strong> object.</p>
</td></tr>
<tr><td><code id="krige_+3A_...">...</code></td>
<td>
<p>Additional parameters or attributes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Refer to <code><a href="#topic+krige.mcgf">krige.mcgf()</a></code> and <code><a href="#topic+krige.mcgf_rs">krige.mcgf_rs()</a></code> for more details.
</p>


<h3>Value</h3>

<p>Kriging results of <code>x</code>.
</p>

<hr>
<h2 id='krige_new'>Generic function for computing kriging forecasts for new locations</h2><span id='topic+krige_new'></span>

<h3>Description</h3>

<p>Generic function for computing kriging forecasts for new locations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>krige_new(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="krige_new_+3A_x">x</code></td>
<td>
<p>An <strong>R</strong> object.</p>
</td></tr>
<tr><td><code id="krige_new_+3A_...">...</code></td>
<td>
<p>Additional parameters or attributes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Refer to <code><a href="#topic+krige_new.mcgf">krige_new.mcgf()</a></code> and <code><a href="#topic+krige_new.mcgf_rs">krige_new.mcgf_rs()</a></code> for more details.
</p>


<h3>Value</h3>

<p>Kriging results of <code>x</code>.
</p>

<hr>
<h2 id='krige_new.mcgf'>Obtain kriging forecasts for new locations for an <code>mcgf</code> object.</h2><span id='topic+krige_new.mcgf'></span>

<h3>Description</h3>

<p>Obtain kriging forecasts for new locations for an <code>mcgf</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcgf'
krige_new(
  x,
  newdata = NULL,
  locations_new = NULL,
  dists_new = NULL,
  newdata_new = NULL,
  sds_new = 1,
  model = c("all", "base"),
  interval = FALSE,
  level = 0.95,
  dists_new_base,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="krige_new.mcgf_+3A_x">x</code></td>
<td>
<p>An <code>mcgf</code> object.</p>
</td></tr>
<tr><td><code id="krige_new.mcgf_+3A_newdata">newdata</code></td>
<td>
<p>A data.frame with the same column names as <code>x</code>. If <code>newdata</code>
is missing the forecasts at the original data points are returned.</p>
</td></tr>
<tr><td><code id="krige_new.mcgf_+3A_locations_new">locations_new</code></td>
<td>
<p>A matrix of data.frame of 2D points of new locations,
first column longitude, second column latitude, both in decimal degrees.
Supply only if <code>x</code> contains <code>locations</code>. Required when <code>dists_new</code> is not
supplied.</p>
</td></tr>
<tr><td><code id="krige_new.mcgf_+3A_dists_new">dists_new</code></td>
<td>
<p>List of signed distance matrices (vectors) with names <code>h</code>,
<code>h1</code>, and 'h2' for all locations, with new locations in the end. Each
matrix must have the same number of columns. Required when <code>locations_new</code> is
not supplied.</p>
</td></tr>
<tr><td><code id="krige_new.mcgf_+3A_newdata_new">newdata_new</code></td>
<td>
<p>Optional; a data.frame with the same number of rows as
<code>newdata</code>. It contains the data of the new locations.</p>
</td></tr>
<tr><td><code id="krige_new.mcgf_+3A_sds_new">sds_new</code></td>
<td>
<p>The standard deviations of the new locations. Default is 1.</p>
</td></tr>
<tr><td><code id="krige_new.mcgf_+3A_model">model</code></td>
<td>
<p>Which model to use. One of <code>all</code> or <code>base</code>.</p>
</td></tr>
<tr><td><code id="krige_new.mcgf_+3A_interval">interval</code></td>
<td>
<p>Logical; if TRUE, prediction intervals are computed.</p>
</td></tr>
<tr><td><code id="krige_new.mcgf_+3A_level">level</code></td>
<td>
<p>A numeric scalar between 0 and 1 giving the confidence level for
the intervals (if any) to be calculated. Used when <code>interval = TRUE</code>.</p>
</td></tr>
<tr><td><code id="krige_new.mcgf_+3A_dists_new_base">dists_new_base</code></td>
<td>
<p>Optional; a distance array for all locations for the
base model, with new locations in the end. Used for the base model.</p>
</td></tr>
<tr><td><code id="krige_new.mcgf_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not in use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It produces simple kriging forecasts for a zero-mean mcgf for new locations
given their coordinates or relative distances. It supports kriging for the
<code>base</code> model and the <code>all</code> model which is the general stationary model with
the base and Lagrangian model from <code>x</code>.
</p>
<p>Users can either supply the coordinates via <code>locations_new</code>, or a list of
distance for all locations via <code>dists_new</code>, with new locations at the
end. <code>dists_new</code> will be used to calculate the new covariance matrices.
When <code>locations_new</code> is used, make sure <code>x</code> contains the attribute
<code>locations</code> of the coordinates of the old locations. When <code>dists_new</code> is
used, it should be a list of signed distance matrices of the same dimension,
where each row corresponds to the relative distances between a new location
and old locations in the same order as they appear in <code>x</code>.
</p>
<p>If data for the new locations are available, use <code>newdata_new</code> to include
them and they will be used to calculate the kriging forecasts for the new
locations; otherwise only data of the old locations will be used via
<code>newdata</code>.
</p>
<p>When <code>interval = TRUE</code>, confidence interval for each forecasts and each
horizon is given. Note that it does not compute confidence regions.
</p>


<h3>Value</h3>

<p>A list of kriging forecasts (and prediction intervals) for all
locations.
</p>


<h3>See Also</h3>

<p>Other functions on fitting an mcgf: 
<code><a href="#topic+add_base.mcgf">add_base.mcgf</a>()</code>,
<code><a href="#topic+add_lagr.mcgf">add_lagr.mcgf</a>()</code>,
<code><a href="#topic+fit_base.mcgf">fit_base.mcgf</a>()</code>,
<code><a href="#topic+fit_lagr.mcgf">fit_lagr.mcgf</a>()</code>,
<code><a href="#topic+krige.mcgf">krige.mcgf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim1)
sim1_mcgf &lt;- mcgf(sim1$data, locations = sim1$locations)
sim1_mcgf &lt;- add_acfs(sim1_mcgf, lag_max = 5)
sim1_mcgf &lt;- add_ccfs(sim1_mcgf, lag_max = 5)

# Fit a separable model and store it to 'sim1_mcgf'
fit_sep &lt;- fit_base(
    sim1_mcgf,
    model = "sep",
    lag = 5,
    par_init = c(
        c = 0.001,
        gamma = 0.5,
        a = 0.3,
        alpha = 0.5
    ),
    par_fixed = c(nugget = 0)
)
sim1_mcgf &lt;- add_base(sim1_mcgf, fit_base = fit_sep)

# Fit a Lagrangian model
fit_lagr &lt;- fit_lagr(
    sim1_mcgf,
    model = "lagr_tri",
    par_init = c(v1 = 300, v2 = 300, lambda = 0.15),
    par_fixed = c(k = 2)
)

# Store the fitted Lagrangian model to 'sim1_mcgf'
sim1_mcgf &lt;- add_lagr(sim1_mcgf, fit_lagr = fit_lagr)

# Calculate the simple kriging predictions and intervals for all locations
locations_new &lt;- rbind(c(-110, 55), c(-109, 54))
sim1_krige &lt;- krige_new(sim1_mcgf,
    locations_new = locations_new,
    interval = TRUE
)
</code></pre>

<hr>
<h2 id='krige_new.mcgf_rs'>Obtain kriging forecasts for new locations for an <code>mcgf_rs</code> object.</h2><span id='topic+krige_new.mcgf_rs'></span>

<h3>Description</h3>

<p>Obtain kriging forecasts for new locations for an <code>mcgf_rs</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcgf_rs'
krige_new(
  x,
  newdata = NULL,
  locations_new = NULL,
  dists_new_ls = NULL,
  newdata_new = NULL,
  sds_new_ls = 1,
  newlabel,
  soft = FALSE,
  prob,
  dists_new_base,
  model = c("all", "base"),
  interval = FALSE,
  level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="krige_new.mcgf_rs_+3A_x">x</code></td>
<td>
<p>An <code>mcgf_rs</code> object.</p>
</td></tr>
<tr><td><code id="krige_new.mcgf_rs_+3A_newdata">newdata</code></td>
<td>
<p>A data.frame with the same column names as <code>x</code>. If <code>newdata</code>
is missing the forecasts at the original data points are returned.</p>
</td></tr>
<tr><td><code id="krige_new.mcgf_rs_+3A_locations_new">locations_new</code></td>
<td>
<p>A matrix of data.frame of 2D points of new locations,
first column longitude, second column latitude, both in decimal degrees.
Supply only if <code>x</code> contains <code>locations</code>. Required when <code>dists_new_ls</code> is not
supplied.</p>
</td></tr>
<tr><td><code id="krige_new.mcgf_rs_+3A_dists_new_ls">dists_new_ls</code></td>
<td>
<p>List of signed distance matrices (vectors) with names <code>h</code>,
<code>h1</code>, and 'h2' for all locations(and for each regime), with new locations
in the end. Each matrix must have the same number of columns. Required when
<code>locations_new</code> is not supplied.</p>
</td></tr>
<tr><td><code id="krige_new.mcgf_rs_+3A_newdata_new">newdata_new</code></td>
<td>
<p>Optional; a data.frame with the same number of rows as
<code>newdata</code>. It contains the data of the new locations.</p>
</td></tr>
<tr><td><code id="krige_new.mcgf_rs_+3A_sds_new_ls">sds_new_ls</code></td>
<td>
<p>List of the standard deviations of the new locations for
each regime. Format must be the same as the output from <code><a href="#topic+sds.mcgf_rs">sds.mcgf_rs()</a></code>.
Default is 1 for all regimes.</p>
</td></tr>
<tr><td><code id="krige_new.mcgf_rs_+3A_newlabel">newlabel</code></td>
<td>
<p>A vector of new regime labels.</p>
</td></tr>
<tr><td><code id="krige_new.mcgf_rs_+3A_soft">soft</code></td>
<td>
<p>Logical; if true, soft forecasts (and bounds) are produced.</p>
</td></tr>
<tr><td><code id="krige_new.mcgf_rs_+3A_prob">prob</code></td>
<td>
<p>Matrix with simplex rows. Number of columns must be the same as
unique labels in <code>x</code>.</p>
</td></tr>
<tr><td><code id="krige_new.mcgf_rs_+3A_dists_new_base">dists_new_base</code></td>
<td>
<p>Optional, list of distance matrices for the base
model. Used when the base model is non-regime switching. Default is <code>h</code> from
the first list of <code>dists_new_ls</code>.</p>
</td></tr>
<tr><td><code id="krige_new.mcgf_rs_+3A_model">model</code></td>
<td>
<p>Which model to use. One of <code>all</code>, <code>base</code>, or <code>empirical</code>.</p>
</td></tr>
<tr><td><code id="krige_new.mcgf_rs_+3A_interval">interval</code></td>
<td>
<p>Logical; if TRUE, prediction intervals are computed.</p>
</td></tr>
<tr><td><code id="krige_new.mcgf_rs_+3A_level">level</code></td>
<td>
<p>A numeric scalar between 0 and 1 giving the confidence level for
the intervals (if any) to be calculated. Used when <code>interval = TRUE</code></p>
</td></tr>
<tr><td><code id="krige_new.mcgf_rs_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It produces simple kriging forecasts for a zero-mean mcgf for new locations
given theri coordinates or relative distances. It supports kriging for the
<code>base</code> model and the <code>all</code> model which is the general stationary model with
the base and Lagrangian model from <code>x</code>.
</p>
<p>Users can either supply the coordinates via <code>locations_new</code>, or a list of
distance for all locations via <code>dists_new_ls</code>, with new locations at the
end. <code>dists_new_ls</code> will be used to calculate the new covariance matrices.
When <code>locations_new</code> is used, make sure <code>x</code> contains the attribute
<code>locations</code> of the coordinates of the old locations. When <code>dists_new_ls</code> is
used, it should be a list of a list of signed distance matrices of the same
dimension, where each row corresponds to the relative distances between a new
location and old locations in the same order as they appear in <code>x</code>. If only
one list is provided, it will be used for all regimes.
</p>
<p>When <code>soft = TRUE</code>, <code>prob</code> will be used to compute the soft forecasts
(weighted forecasts). The number of columns must match the number of unique
levels in <code>x</code>. The column order must be the same as the order of regimes as
in <code>levels(attr(x, "label", exact = TRUE))</code>. If not all regimes are seen in
<code>newlabel</code>, then only relevant columns in <code>prob</code> are used.
</p>
<p>When <code>interval = TRUE</code>, confidence interval for each forecasts and each
horizon is given. Note that it does not compute confidence regions.
</p>


<h3>Value</h3>

<p>A list of kriging forecasts (and prediction intervals) for all
locations.
</p>


<h3>See Also</h3>

<p>Other functions on fitting an mcgf_rs: 
<code><a href="#topic+add_base.mcgf_rs">add_base.mcgf_rs</a>()</code>,
<code><a href="#topic+add_lagr.mcgf_rs">add_lagr.mcgf_rs</a>()</code>,
<code><a href="#topic+fit_base.mcgf_rs">fit_base.mcgf_rs</a>()</code>,
<code><a href="#topic+fit_lagr.mcgf_rs">fit_lagr.mcgf_rs</a>()</code>,
<code><a href="#topic+krige.mcgf_rs">krige.mcgf_rs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim2)
sim2_mcgf &lt;- mcgf_rs(sim2$data,
    locations = sim2$locations,
    label = sim2$label
)
sim2_mcgf &lt;- add_acfs(sim2_mcgf, lag_max = 5)
sim2_mcgf &lt;- add_ccfs(sim2_mcgf, lag_max = 5)

# Fit a regime-switching separable model
fit_sep &lt;- fit_base(
    sim2_mcgf,
    lag_ls = 5,
    model_ls = "sep",
    par_init_ls = list(list(
        c = 0.00005,
        gamma = 0.5,
        a = 0.5,
        alpha = 0.5
    )),
    par_fixed_ls = list(c(nugget = 0))
)

# Store the fitted separable models to 'sim2_mcgf'
sim2_mcgf &lt;- add_base(sim2_mcgf, fit_base_ls = fit_sep)

# Calculate the simple kriging predictions and intervals for all locations
locations_new &lt;- rbind(c(-110, 55), c(-109, 54))
sim2_krige &lt;- krige_new(sim2_mcgf,
    locations_new = locations_new,
    model = "base", interval = TRUE
)
</code></pre>

<hr>
<h2 id='krige.mcgf'>Obtain kriging forecasts for an <code>mcgf</code> object.</h2><span id='topic+krige.mcgf'></span>

<h3>Description</h3>

<p>Obtain kriging forecasts for an <code>mcgf</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcgf'
krige(
  x,
  newdata = NULL,
  model = c("all", "base", "empirical"),
  interval = FALSE,
  level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="krige.mcgf_+3A_x">x</code></td>
<td>
<p>An <code>mcgf</code> object.</p>
</td></tr>
<tr><td><code id="krige.mcgf_+3A_newdata">newdata</code></td>
<td>
<p>A data.frame with the same column names as <code>x</code>. If <code>newdata</code>
is missing the forecasts at the original data points are returned.</p>
</td></tr>
<tr><td><code id="krige.mcgf_+3A_model">model</code></td>
<td>
<p>Which model to use. One of <code>all</code>, <code>base</code>, or <code>empirical</code>.</p>
</td></tr>
<tr><td><code id="krige.mcgf_+3A_interval">interval</code></td>
<td>
<p>Logical; if TRUE, prediction intervals are computed.</p>
</td></tr>
<tr><td><code id="krige.mcgf_+3A_level">level</code></td>
<td>
<p>A numeric scalar between 0 and 1 giving the confidence level for
the intervals (if any) to be calculated. Used when <code>interval = TRUE</code></p>
</td></tr>
<tr><td><code id="krige.mcgf_+3A_...">...</code></td>
<td>
<p>Additional arguments. Give <code>lag</code> and <code>horizon</code> if they are not
defined in <code>x</code> for the <code>empirical</code> model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It produces simple kriging forecasts for a zero-mean mcgf. It supports
kriging for the <code>empirical</code> model, the <code>base</code> model, and the <code>all</code> model
which is the general stationary model with the base and Lagrangian model
from <code>x</code>.
</p>
<p>When <code>interval = TRUE</code>, confidence interval for each forecasts and each
horizon is given. Note that it does not compute confidence regions.
</p>


<h3>Value</h3>

<p>A list of kriging forecasts (and prediction intervals).
</p>


<h3>See Also</h3>

<p>Other functions on fitting an mcgf: 
<code><a href="#topic+add_base.mcgf">add_base.mcgf</a>()</code>,
<code><a href="#topic+add_lagr.mcgf">add_lagr.mcgf</a>()</code>,
<code><a href="#topic+fit_base.mcgf">fit_base.mcgf</a>()</code>,
<code><a href="#topic+fit_lagr.mcgf">fit_lagr.mcgf</a>()</code>,
<code><a href="#topic+krige_new.mcgf">krige_new.mcgf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim1)
sim1_mcgf &lt;- mcgf(sim1$data, dists = sim1$dists)
sim1_mcgf &lt;- add_acfs(sim1_mcgf, lag_max = 5)
sim1_mcgf &lt;- add_ccfs(sim1_mcgf, lag_max = 5)

# Fit a separable model and store it to 'sim1_mcgf'
fit_sep &lt;- fit_base(
    sim1_mcgf,
    model = "sep",
    lag = 5,
    par_init = c(
        c = 0.001,
        gamma = 0.5,
        a = 0.3,
        alpha = 0.5
    ),
    par_fixed = c(nugget = 0)
)
sim1_mcgf &lt;- add_base(sim1_mcgf, fit_base = fit_sep)

# Fit a Lagrangian model
fit_lagr &lt;- fit_lagr(
    sim1_mcgf,
    model = "lagr_tri",
    par_init = c(v1 = 300, v2 = 300, lambda = 0.15),
    par_fixed = c(k = 2)
)

# Store the fitted Lagrangian model to 'sim1_mcgf'
sim1_mcgf &lt;- add_lagr(sim1_mcgf, fit_lagr = fit_lagr)

# Calculate the simple kriging predictions and intervals
sim1_krige &lt;- krige(sim1_mcgf, interval = TRUE)

# Calculate RMSE for each location
rmse &lt;- sqrt(colMeans((sim1_mcgf - sim1_krige$fit)^2, na.rm = TRUE))
rmse

# Calculate MAE for each location
mae &lt;- colMeans(abs(sim1_mcgf - sim1_krige$fit), na.rm = TRUE)
mae

# Calculate POPI for each location
popi &lt;- colMeans(
    sim1_mcgf &lt; sim1_krige$lower | sim1_mcgf &gt; sim1_krige$upper,
    na.rm = TRUE
)
popi
</code></pre>

<hr>
<h2 id='krige.mcgf_rs'>Obtain kriging forecasts for an <code>mcgf_rs</code> object.</h2><span id='topic+krige.mcgf_rs'></span>

<h3>Description</h3>

<p>Obtain kriging forecasts for an <code>mcgf_rs</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcgf_rs'
krige(
  x,
  newdata = NULL,
  newlabel = NULL,
  soft = FALSE,
  prob,
  model = c("all", "base", "empirical"),
  interval = FALSE,
  level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="krige.mcgf_rs_+3A_x">x</code></td>
<td>
<p>An <code>mcgf_rs</code> object.</p>
</td></tr>
<tr><td><code id="krige.mcgf_rs_+3A_newdata">newdata</code></td>
<td>
<p>A data.frame with the same column names as <code>x</code>. If <code>newdata</code>
is missing the forecasts at the original data points are returned.</p>
</td></tr>
<tr><td><code id="krige.mcgf_rs_+3A_newlabel">newlabel</code></td>
<td>
<p>A vector of new regime labels.</p>
</td></tr>
<tr><td><code id="krige.mcgf_rs_+3A_soft">soft</code></td>
<td>
<p>Logical; if true, soft forecasts (and bounds) are produced.</p>
</td></tr>
<tr><td><code id="krige.mcgf_rs_+3A_prob">prob</code></td>
<td>
<p>Matrix with simplex rows. Number of columns must be the same as
unique labels in <code>x</code>.</p>
</td></tr>
<tr><td><code id="krige.mcgf_rs_+3A_model">model</code></td>
<td>
<p>Which model to use. One of <code>all</code>, <code>base</code>, or <code>empirical</code>.</p>
</td></tr>
<tr><td><code id="krige.mcgf_rs_+3A_interval">interval</code></td>
<td>
<p>Logical; if TRUE, prediction intervals are computed.</p>
</td></tr>
<tr><td><code id="krige.mcgf_rs_+3A_level">level</code></td>
<td>
<p>A numeric scalar between 0 and 1 giving the confidence level for
the intervals (if any) to be calculated. Used when <code>interval = TRUE</code></p>
</td></tr>
<tr><td><code id="krige.mcgf_rs_+3A_...">...</code></td>
<td>
<p>Additional arguments. Give <code>lag</code> and <code>horizon</code> if they are not
defined in <code>x</code> for the <code>empirical</code> model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It produces simple kriging forecasts for a zero-mean mcgf. It supports
kriging for the <code>empirical</code> model, the <code>base</code> model, and the <code>all</code> model
which is the general stationary model with the base and Lagrangian model
from <code>x</code>.
</p>
<p>When <code>soft = TRUE</code>, <code>prob</code> will be used to compute the soft forecasts
(weighted forecasts). The number of columns must match the number of unique
levels in <code>x</code>. The column order must be the same as the order of regimes as
in <code>levels(attr(x, "label", exact = TRUE))</code>. If not all regimes are seen in
<code>newlabel</code>, then only relevant columns in <code>prob</code> are used.
</p>
<p>When <code>interval = TRUE</code>, confidence interval for each forecasts and each
horizon is given. Note that it does not compute confidence regions.
</p>


<h3>Value</h3>

<p>A list of kriging forecasts (and prediction intervals).
</p>


<h3>See Also</h3>

<p>Other functions on fitting an mcgf_rs: 
<code><a href="#topic+add_base.mcgf_rs">add_base.mcgf_rs</a>()</code>,
<code><a href="#topic+add_lagr.mcgf_rs">add_lagr.mcgf_rs</a>()</code>,
<code><a href="#topic+fit_base.mcgf_rs">fit_base.mcgf_rs</a>()</code>,
<code><a href="#topic+fit_lagr.mcgf_rs">fit_lagr.mcgf_rs</a>()</code>,
<code><a href="#topic+krige_new.mcgf_rs">krige_new.mcgf_rs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim2)
sim2_mcgf &lt;- mcgf_rs(sim2$data, dists = sim2$dists, label = sim2$label)
sim2_mcgf &lt;- add_acfs(sim2_mcgf, lag_max = 5)
sim2_mcgf &lt;- add_ccfs(sim2_mcgf, lag_max = 5)

# Fit a regime-switching separable model
fit_sep &lt;- fit_base(
    sim2_mcgf,
    lag_ls = 5,
    model_ls = "sep",
    par_init_ls = list(list(
        c = 0.00005,
        gamma = 0.5,
        a = 0.5,
        alpha = 0.5
    )),
    par_fixed_ls = list(c(nugget = 0))
)

# Store the fitted separable models to 'sim2_mcgf'
sim2_mcgf &lt;- add_base(sim2_mcgf, fit_base_ls = fit_sep)

# Calculate the simple kriging predictions and intervals
sim2_krige &lt;- krige(sim2_mcgf, model = "base", interval = TRUE)

# Calculate RMSE for each location
rmse &lt;- sqrt(colMeans((sim2_mcgf - sim2_krige$fit)^2, na.rm = TRUE))
rmse

# Calculate MAE for each location
mae &lt;- colMeans(abs(sim2_mcgf - sim2_krige$fit), na.rm = TRUE)
mae

# Calculate POPI for each location
popi &lt;- colMeans(
    sim2_mcgf &lt; sim2_krige$lower | sim2_mcgf &gt; sim2_krige$upper,
    na.rm = TRUE
)
popi
</code></pre>

<hr>
<h2 id='mat_inv'>Find inverse of a symmetric positive definite matrix</h2><span id='topic+mat_inv'></span>

<h3>Description</h3>

<p>Find inverse of a symmetric positive definite matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat_inv(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mat_inv_+3A_x">x</code></td>
<td>
<p>A symmetric and positive definite matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Inverse of x.
</p>

<hr>
<h2 id='mcgf'>Create mcgf object</h2><span id='topic+mcgf'></span>

<h3>Description</h3>

<p>Create mcgf object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcgf(data, locations, dists, time, longlat = TRUE, origin = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcgf_+3A_data">data</code></td>
<td>
<p>Time series data set in space-wide format.</p>
</td></tr>
<tr><td><code id="mcgf_+3A_locations">locations</code></td>
<td>
<p>A matrix of data.frame of 2D points, first column
x/longitude, second column y/latitude. Required when <code>dists</code> is not supplied.
If longitudes and latitudes are provided, they are mapped to a 2D Euclidean.
See <code><a href="#topic+find_dists">find_dists()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="mcgf_+3A_dists">dists</code></td>
<td>
<p>List of signed distance matrices on a 2D Euclidean Plane.
Required when <code>locations</code> is not supplied.</p>
</td></tr>
<tr><td><code id="mcgf_+3A_time">time</code></td>
<td>
<p>Optional, a vector of equally spaced time stamps.</p>
</td></tr>
<tr><td><code id="mcgf_+3A_longlat">longlat</code></td>
<td>
<p>Logical, if TURE <code>locations</code> contains longitudes and
latitudes.</p>
</td></tr>
<tr><td><code id="mcgf_+3A_origin">origin</code></td>
<td>
<p>Optional; used when <code>longlat</code> is TRUE. An integer index
indicating the reference location which well be used as the origin.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An <code>mcgf</code> object extends the S3 class <code>data.frame</code>.
</p>
<p>For inputs, <code>data</code> must be in space-wide format where rows correspond to
different time stamps and columns refer to spatial locations. Supply either
<code>locations</code> or <code>dists</code>. <code>locations</code> is a matrix or data.frame of 2D points
with first column x/longitude and second column y/latitude. By default it is
treated as a matrix of Earth's coordinates in decimal degrees. Number of rows
in <code>locations</code> must be the same as the number of columns of <code>data</code>. <code>dists</code>
must be a list of signed distance matrices with names <code>h1</code>, <code>h2</code>, and <code>h</code>.
If <code>h</code> is not given, it will be calculated as the Euclidean distance of <code>h1</code>
and <code>h2</code>. <code>time</code> is a vector of equally spaced time stamps. If it is not
supplied then <code>data</code> is assumed to be temporally equally spaced.
</p>
<p>An <code>mcgf</code> object extends the S3 class <code>data.frame</code>, all methods remain valid
to the <code>data</code> part of the object.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>mcgf</code>. As it inherits and extends the
<code>data.frame</code> class, all methods remain valid to the <code>data</code> part of the
object. Additional attributes may be assigned and extracted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- cbind(S1 = 1:5, S2 = 4:8, S3 = 5:9)
lon &lt;- c(110, 120, 130)
lat &lt;- c(50, 55, 60)
locations &lt;- cbind(lon, lat)
obj &lt;- mcgf(data, locations = locations)
print(obj, "locations")
</code></pre>

<hr>
<h2 id='mcgf_rs'>Create mcgf_rs object</h2><span id='topic+mcgf_rs'></span>

<h3>Description</h3>

<p>Create mcgf_rs object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcgf_rs(data, locations, dists, label, time, longlat = TRUE, origin = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcgf_rs_+3A_data">data</code></td>
<td>
<p>Time series data set in space-wide format.</p>
</td></tr>
<tr><td><code id="mcgf_rs_+3A_locations">locations</code></td>
<td>
<p>A matrix of data.frame of 2D points, first column
longitude, second column latitude, both in decimal degrees. Required when
<code>dists</code> is not supplied.</p>
</td></tr>
<tr><td><code id="mcgf_rs_+3A_dists">dists</code></td>
<td>
<p>List of signed distance matrices. Required when <code>locations</code> is
not supplied.</p>
</td></tr>
<tr><td><code id="mcgf_rs_+3A_label">label</code></td>
<td>
<p>A vector of regime labels. Its length must be the same as
the number rows in <code>data</code>.</p>
</td></tr>
<tr><td><code id="mcgf_rs_+3A_time">time</code></td>
<td>
<p>Optional, a vector of equally spaced time stamps.</p>
</td></tr>
<tr><td><code id="mcgf_rs_+3A_longlat">longlat</code></td>
<td>
<p>Logical, if TURE <code>locations</code> contains longitudes and
latitudes.</p>
</td></tr>
<tr><td><code id="mcgf_rs_+3A_origin">origin</code></td>
<td>
<p>Optional; used when <code>longlat</code> is TRUE. An integer index
indicating the reference location which well be used as the origin.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An <code>mcgf_rs</code> object extends the S3 classes <code>mcgf</code> and <code>data.frame</code>.
</p>
<p>For inputs, <code>data</code> must be in space-wide format where rows correspond to
different time stamps and columns refer to spatial locations. Supply either
<code>locations</code> or <code>dists</code>. <code>locations</code> is a matrix or data.frame of 2D points
with first column x/longitude and second column y/latitude. By default it is
treated as a matrix of Earth's coordinates in decimal degrees. Number of rows
in <code>locations</code> must be the same as the number of columns of <code>data</code>. <code>dists</code>
must be a list of signed distance matrices with names <code>h1</code>, <code>h2</code>, and <code>h</code>.
If <code>h</code> is not given, it will be calculated as the Euclidean distance of <code>h1</code>
and <code>h2</code>. <code>time</code> is a vector of equally spaced time stamps. If it is not
supplied then <code>data</code> is assumed to be temporally equally spaced. <code>label</code> must
be a vector containing regime labels, and its length must be the same as the
number of rows in <code>x</code>.
</p>
<p>An <code>mcgf_rs</code> object extends the S3 classes <code>mcgf</code> and <code>data.frame</code>, all
methods remain valid to the <code>data</code> part of the object.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>mcgf_rs</code>. As it inherits and extends the
<code>mcgf</code> and then the<code>data.frame</code> class, all methods remain valid to the
<code>data</code> part of the object. Additional attributes may be assigned and
extracted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- cbind(S1 = 1:5, S2 = 4:8, S3 = 5:9)
lon &lt;- c(110, 120, 130)
lat &lt;- c(50, 55, 60)
locations &lt;- cbind(lon, lat)
label &lt;- c(1, 1, 2, 2, 2)
obj &lt;- mcgf_rs(data, locations = locations, label = label)
print(obj, "locations")
print(obj, "label")
</code></pre>

<hr>
<h2 id='mcgf_rs_sim'>Simulate regime-switching Markov chain Gaussian field</h2><span id='topic+mcgf_rs_sim'></span>

<h3>Description</h3>

<p>Simulate regime-switching Markov chain Gaussian field
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcgf_rs_sim(
  N,
  label,
  base_ls,
  lagrangian_ls,
  par_base_ls,
  par_lagr_ls,
  lambda_ls,
  dists_ls,
  sd_ls,
  lag_ls,
  scale_time = 1,
  init = 0,
  mu_c_ls = list(0),
  mu_p_ls = list(0),
  return_all = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcgf_rs_sim_+3A_n">N</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="mcgf_rs_sim_+3A_label">label</code></td>
<td>
<p>Vector of regime labels of the same length as <code>N</code>.</p>
</td></tr>
<tr><td><code id="mcgf_rs_sim_+3A_base_ls">base_ls</code></td>
<td>
<p>List of base model, <code>sep</code> or <code>fs</code> for now.</p>
</td></tr>
<tr><td><code id="mcgf_rs_sim_+3A_lagrangian_ls">lagrangian_ls</code></td>
<td>
<p>List of Lagrangian model, &quot;none&quot; or <code>lagr_tri</code> for now.</p>
</td></tr>
<tr><td><code id="mcgf_rs_sim_+3A_par_base_ls">par_base_ls</code></td>
<td>
<p>List of parameters for the base model.</p>
</td></tr>
<tr><td><code id="mcgf_rs_sim_+3A_par_lagr_ls">par_lagr_ls</code></td>
<td>
<p>List of parameters for the Lagrangian model.</p>
</td></tr>
<tr><td><code id="mcgf_rs_sim_+3A_lambda_ls">lambda_ls</code></td>
<td>
<p>List of weight of the Lagrangian term,
<code class="reqn">\lambda\in[0, 1]</code>.</p>
</td></tr>
<tr><td><code id="mcgf_rs_sim_+3A_dists_ls">dists_ls</code></td>
<td>
<p>List of distance matrices or arrays.</p>
</td></tr>
<tr><td><code id="mcgf_rs_sim_+3A_sd_ls">sd_ls</code></td>
<td>
<p>List of standard deviation for each location.</p>
</td></tr>
<tr><td><code id="mcgf_rs_sim_+3A_lag_ls">lag_ls</code></td>
<td>
<p>List of time lags.</p>
</td></tr>
<tr><td><code id="mcgf_rs_sim_+3A_scale_time">scale_time</code></td>
<td>
<p>Scale of time unit, default is 1. Elements in <code>lag_ls</code> are
divided by <code>scale_time</code>.</p>
</td></tr>
<tr><td><code id="mcgf_rs_sim_+3A_init">init</code></td>
<td>
<p>Initial samples, default is 0.</p>
</td></tr>
<tr><td><code id="mcgf_rs_sim_+3A_mu_c_ls">mu_c_ls</code>, <code id="mcgf_rs_sim_+3A_mu_p_ls">mu_p_ls</code></td>
<td>
<p>List of means of current and past.</p>
</td></tr>
<tr><td><code id="mcgf_rs_sim_+3A_return_all">return_all</code></td>
<td>
<p>Logical; if TRUE the joint covariance matrix, arrays of
distances and time lag are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simulated regime-switching Markov chain Gaussian field with
user-specified covariance structures. The simulation is done by kriging.
The output data is in space-wide format. Each element in <code>dists_ls</code> must
contain <code>h</code> for symmetric models, and <code>h1</code> and <code>h2</code> for general stationary
models. <code>init</code> can be a scalar or a vector of appropriate size.
List elements in <code>sd_ls</code>, <code>mu_c_ls</code>, and <code>mu_p_ls</code> must be vectors of
appropriate sizes.
</p>


<h3>See Also</h3>

<p>Other simulations of Markov chain Gaussian fields: 
<code><a href="#topic+mcgf_sim">mcgf_sim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par_s &lt;- list(nugget = 0.5, c = 0.01, gamma = 0.5)
par_t &lt;- list(a = 1, alpha = 0.5)
par_base &lt;- list(par_s = par_s, par_t = par_t)
par_lagr &lt;- list(v1 = 5, v2 = 10)
h1 &lt;- matrix(c(0, 5, -5, 0), nrow = 2)
h2 &lt;- matrix(c(0, 8, -8, 0), nrow = 2)
h &lt;- sqrt(h1^2 + h2^2)
dists &lt;- list(h = h, h1 = h1, h2 = h2)

set.seed(123)
label &lt;- sample(1:2, 1000, replace = TRUE)
X &lt;- mcgf_rs_sim(
    N = 1000,
    label = label,
    base_ls = list("sep"),
    lagrangian_ls = list("none", "lagr_tri"),
    lambda_ls = list(0, 0.5),
    par_base_ls = list(par_base),
    par_lagr_ls = list(NULL, par_lagr),
    dists_ls = list(dists, dists)
)
# plot.ts(X[, -1])

</code></pre>

<hr>
<h2 id='mcgf_sim'>Simulate Markov chain Gaussian field</h2><span id='topic+mcgf_sim'></span>

<h3>Description</h3>

<p>Simulate Markov chain Gaussian field
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcgf_sim(
  N,
  base = c("sep", "fs"),
  lagrangian = c("none", "lagr_tri", "lagr_askey"),
  par_base,
  par_lagr,
  lambda,
  dists,
  sd = 1,
  lag = 1,
  scale_time = 1,
  horizon = 1,
  init = 0,
  mu_c = 0,
  mu_p = 0,
  return_all = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcgf_sim_+3A_n">N</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="mcgf_sim_+3A_base">base</code></td>
<td>
<p>Base model, <code>sep</code> or <code>fs</code> for now.</p>
</td></tr>
<tr><td><code id="mcgf_sim_+3A_lagrangian">lagrangian</code></td>
<td>
<p>Lagrangian model, &quot;none&quot; or <code>lagr_tri</code> for now.</p>
</td></tr>
<tr><td><code id="mcgf_sim_+3A_par_base">par_base</code></td>
<td>
<p>Parameters for the base model (symmetric).</p>
</td></tr>
<tr><td><code id="mcgf_sim_+3A_par_lagr">par_lagr</code></td>
<td>
<p>Parameters for the Lagrangian model.</p>
</td></tr>
<tr><td><code id="mcgf_sim_+3A_lambda">lambda</code></td>
<td>
<p>Weight of the Lagrangian term, <code class="reqn">\lambda\in[0, 1]</code>.</p>
</td></tr>
<tr><td><code id="mcgf_sim_+3A_dists">dists</code></td>
<td>
<p>Distance matrices or arrays.</p>
</td></tr>
<tr><td><code id="mcgf_sim_+3A_sd">sd</code></td>
<td>
<p>Standard deviation for each location.</p>
</td></tr>
<tr><td><code id="mcgf_sim_+3A_lag">lag</code></td>
<td>
<p>Time lag.</p>
</td></tr>
<tr><td><code id="mcgf_sim_+3A_scale_time">scale_time</code></td>
<td>
<p>Scale of time unit, default is 1. <code>lag</code> is divided by
<code>scale_time</code>.</p>
</td></tr>
<tr><td><code id="mcgf_sim_+3A_horizon">horizon</code></td>
<td>
<p>Forecast horizon, default is 1.</p>
</td></tr>
<tr><td><code id="mcgf_sim_+3A_init">init</code></td>
<td>
<p>Initial samples, default is 0.</p>
</td></tr>
<tr><td><code id="mcgf_sim_+3A_mu_c">mu_c</code>, <code id="mcgf_sim_+3A_mu_p">mu_p</code></td>
<td>
<p>Means of current and past.</p>
</td></tr>
<tr><td><code id="mcgf_sim_+3A_return_all">return_all</code></td>
<td>
<p>Logical; if TRUE the joint covariance matrix, arrays of
distances and time lag are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simulated Markov chain Gaussian field with user-specified covariance
structure. The simulation is done by kriging. The output data is in
space-wide format. <code>dists</code> must contain <code>h</code> for symmetric models, and <code>h1</code>
and <code>h2</code> for general stationary models. <code>horizon</code> controls forecasting
horizon. <code>sd</code>, <code>mu_c</code>, <code>mu_p</code>, and <code>init</code> must be vectors of appropriate
sizes.
</p>


<h3>See Also</h3>

<p>Other simulations of Markov chain Gaussian fields: 
<code><a href="#topic+mcgf_rs_sim">mcgf_rs_sim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par_s &lt;- list(nugget = 0.5, c = 0.01, gamma = 0.5)
par_t &lt;- list(a = 1, alpha = 0.5)
par_base &lt;- list(par_s = par_s, par_t = par_t)
par_lagr &lt;- list(v1 = 5, v2 = 10)
h1 &lt;- matrix(c(0, 5, -5, 0), nrow = 2)
h2 &lt;- matrix(c(0, 8, -8, 0), nrow = 2)
h &lt;- sqrt(h1^2 + h2^2)
dists &lt;- list(h = h, h1 = h1, h2 = h2)

set.seed(123)
X &lt;- mcgf_sim(
    N = 1000, base = "sep", lagrangian = "lagr_tri", lambda = 0.5,
    par_base = par_base, par_lagr = par_lagr, dists = dists
)
plot.ts(X)

</code></pre>

<hr>
<h2 id='model'>Generic function for displaying fitted models for <code>mcgf</code> objects</h2><span id='topic+model'></span>

<h3>Description</h3>

<p>Generic function for displaying fitted models for <code>mcgf</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model_+3A_x">x</code></td>
<td>
<p>An <strong>R</strong> object.</p>
</td></tr>
<tr><td><code id="model_+3A_...">...</code></td>
<td>
<p>Additional parameters or attributes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Refer to <code><a href="#topic+model.mcgf">model.mcgf()</a></code> and <code><a href="#topic+model.mcgf_rs">model.mcgf_rs()</a></code> for more details.
</p>


<h3>Value</h3>

<p>Details of the fitted models.
</p>

<hr>
<h2 id='model.mcgf'>Display fitted models for an <code>mcgf</code> or <code>mcgf_rs</code> object</h2><span id='topic+model.mcgf'></span><span id='topic+model.mcgf_rs'></span>

<h3>Description</h3>

<p>Display fitted models for an <code>mcgf</code> or <code>mcgf_rs</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcgf'
model(
  x,
  model = c("all", "base", "lagrangian"),
  old = FALSE,
  print_model = TRUE,
  ...
)

## S3 method for class 'mcgf_rs'
model(
  x,
  model = c("all", "base", "lagrangian"),
  old = FALSE,
  print_model = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model.mcgf_+3A_x">x</code></td>
<td>
<p>An mcgf object.</p>
</td></tr>
<tr><td><code id="model.mcgf_+3A_model">model</code></td>
<td>
<p>Which model to display.</p>
</td></tr>
<tr><td><code id="model.mcgf_+3A_old">old</code></td>
<td>
<p>Logical; TRUE if the old model needs to be printed.</p>
</td></tr>
<tr><td><code id="model.mcgf_+3A_print_model">print_model</code></td>
<td>
<p>Logical; TRUE if time lag and forecast horizon need to be
printed.</p>
</td></tr>
<tr><td><code id="model.mcgf_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not in use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>mcgf</code> and <code>mcgf_rs</code> objects, <code><a href="#topic+model">model()</a></code> displays the fitted models and
their parameters. When <code>old = TRUE</code>, the old model is printed as well. Note
that the old model is not used for parameter estimation or for kriging.
</p>


<h3>Value</h3>

<p>None (invisible <code>NULL</code>).
</p>

<hr>
<h2 id='new_mcgf'>Create an mcgf object</h2><span id='topic+new_mcgf'></span>

<h3>Description</h3>

<p>Create an mcgf object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_mcgf(data, locations, dists, time, longlat = TRUE, origin = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_mcgf_+3A_data">data</code></td>
<td>
<p>Time series data set in space-wide format.</p>
</td></tr>
<tr><td><code id="new_mcgf_+3A_locations">locations</code></td>
<td>
<p>A matrix of data.frame of 2D points, first column
x/longitude, second column y/latitude. Required when <code>dists</code> is not supplied.
If longitudes and latitudes are provided, they are mapped to a 2D Euclidean.
See <code><a href="#topic+find_dists">find_dists()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="new_mcgf_+3A_dists">dists</code></td>
<td>
<p>List of signed distance matrices on a 2D Euclidean Plane.
Required when <code>locations</code> is not supplied.</p>
</td></tr>
<tr><td><code id="new_mcgf_+3A_time">time</code></td>
<td>
<p>Optional, a vector of equally spaced time stamps.</p>
</td></tr>
<tr><td><code id="new_mcgf_+3A_longlat">longlat</code></td>
<td>
<p>Logical, if TURE <code>locations</code> contains longitudes and
latitudes.</p>
</td></tr>
<tr><td><code id="new_mcgf_+3A_origin">origin</code></td>
<td>
<p>Optional; used when <code>longlat</code> is TRUE. An integer index
indicating the reference location which well be used as the origin.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class <code>mcgf</code>. As it inherits and extends the
<code>data.frame</code> class, all methods remain valid to the <code>data</code> part of the
object. Additional attributes may be assigned and extracted.
</p>

<hr>
<h2 id='new_mcgf_rs'>Create an mcgf_rs object</h2><span id='topic+new_mcgf_rs'></span>

<h3>Description</h3>

<p>Create an mcgf_rs object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_mcgf_rs(x, label)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_mcgf_rs_+3A_x">x</code></td>
<td>
<p>An mcgf object.</p>
</td></tr>
<tr><td><code id="new_mcgf_rs_+3A_label">label</code></td>
<td>
<p>A vector of regime labels. Its length must be the same as
the number rows in <code>data</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class <code>mcgf_rs</code>. As it inherits and extends the
<code>mcgf</code> and then the<code>data.frame</code> class, all methods remain valid to the
<code>data</code> part of the object. Additional attributes may be assigned and
extracted.
</p>

<hr>
<h2 id='obj_mle'>Title</h2><span id='topic+obj_mle'></span>

<h3>Description</h3>

<p>Title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obj_mle(par, cor_fn, x, lag, par_fixed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obj_mle_+3A_par">par</code></td>
<td>
<p>Parameters of <code>cor_fn</code>.</p>
</td></tr>
<tr><td><code id="obj_mle_+3A_cor_fn">cor_fn</code></td>
<td>
<p>Correlation function</p>
</td></tr>
<tr><td><code id="obj_mle_+3A_x">x</code></td>
<td>
<p>An <code>mcgf</code> or <code>mcgf_rs</code> object</p>
</td></tr>
<tr><td><code id="obj_mle_+3A_lag">lag</code></td>
<td>
<p>Time lag.</p>
</td></tr>
<tr><td><code id="obj_mle_+3A_par_fixed">par_fixed</code></td>
<td>
<p>Fixed parameters of <code>cor_fn</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The objective of maximum likelihood: the additive inverse of
log-likelihood.
</p>

<hr>
<h2 id='obj_wls'>Compute the objective for wls method</h2><span id='topic+obj_wls'></span>

<h3>Description</h3>

<p>Compute the objective for wls method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obj_wls(par, cor_fn, cor_emp, par_fixed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obj_wls_+3A_par">par</code></td>
<td>
<p>Parameters of <code>cor_fn</code>.</p>
</td></tr>
<tr><td><code id="obj_wls_+3A_cor_fn">cor_fn</code></td>
<td>
<p>Correlation function.</p>
</td></tr>
<tr><td><code id="obj_wls_+3A_cor_emp">cor_emp</code></td>
<td>
<p>Empirical correlations.</p>
</td></tr>
<tr><td><code id="obj_wls_+3A_par_fixed">par_fixed</code></td>
<td>
<p>Fixed parameters of <code>cor_fn</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The objective of weighted least squares.
</p>

<hr>
<h2 id='print.mcgf'>Print an <code>mcgf</code> object.</h2><span id='topic+print.mcgf'></span>

<h3>Description</h3>

<p>Print an <code>mcgf</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcgf'
print(x, attr = ".Data", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.mcgf_+3A_x">x</code></td>
<td>
<p>An <code>mcgf</code> object.</p>
</td></tr>
<tr><td><code id="print.mcgf_+3A_attr">attr</code></td>
<td>
<p>Attribute to be printed.</p>
</td></tr>
<tr><td><code id="print.mcgf_+3A_...">...</code></td>
<td>
<p>Optional arguments to print methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim1)
sim1_mcgf &lt;- mcgf(sim1$data, dists = sim1$dists)
print(sim1_mcgf, "dists")
</code></pre>

<hr>
<h2 id='rdists'>Generate random distance matrices</h2><span id='topic+rdists'></span>

<h3>Description</h3>

<p>Generate random distance matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdists(N, names, scale = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rdists_+3A_n">N</code></td>
<td>
<p>Number of locations.</p>
</td></tr>
<tr><td><code id="rdists_+3A_names">names</code></td>
<td>
<p>Names of locations.</p>
</td></tr>
<tr><td><code id="rdists_+3A_scale">scale</code></td>
<td>
<p>Scale of the distance matrices. Default is 100.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates random distance matrices using <code>rnorm</code>. <code>scale</code>
controls the scale of the distance matrices.
</p>


<h3>Value</h3>

<p>List of signed distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
rdists(3)
rdists(3, scale = 1)
rdists(3, names = LETTERS[1:3])
</code></pre>

<hr>
<h2 id='sd_rs'>Calculate standard deviation for each location under each regime.</h2><span id='topic+sd_rs'></span>

<h3>Description</h3>

<p>Calculate standard deviation for each location under each regime.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_rs(x, label)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sd_rs_+3A_x">x</code></td>
<td>
<p>A <code>data.frame</code> or <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="sd_rs_+3A_label">label</code></td>
<td>
<p>A vector of regime labels. Its length must be the same as
the number rows in <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of standard deviations for each regime.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- matrix(rnorm(200), nrow = 100)
label &lt;- sample(1:2, 100, replace = TRUE)
sd_rs(x, label = factor(label))
</code></pre>

<hr>
<h2 id='sds'>Generic function for standard deviations for each column</h2><span id='topic+sds'></span>

<h3>Description</h3>

<p>Generic function for standard deviations for each column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sds(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sds_+3A_x">x</code></td>
<td>
<p>An <strong>R</strong> object.</p>
</td></tr>
<tr><td><code id="sds_+3A_...">...</code></td>
<td>
<p>Additional parameters or attributes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Refer to <code><a href="#topic+sds.mcgf">sds.mcgf()</a></code> and <code><a href="#topic+sds.mcgf_rs">sds.mcgf_rs()</a></code> for more details.
</p>


<h3>Value</h3>

<p>A vector of standard deviations for <code>mcgf</code> objects, or that plus
a list of regime-switching standard deviations for <code>mcgf_rs</code> objects.
</p>

<hr>
<h2 id='sds.mcgf'>Extract, calculate, or assign standard deviations for an <code>mcgf</code> or
<code>mcgf_rs</code> object.</h2><span id='topic+sds.mcgf'></span><span id='topic+sds.mcgf_rs'></span><span id='topic+sds+3C-'></span>

<h3>Description</h3>

<p>Extract, calculate, or assign standard deviations for an <code>mcgf</code> or
<code>mcgf_rs</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcgf'
sds(x, ...)

## S3 method for class 'mcgf_rs'
sds(x, replace = FALSE, ...)

sds(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sds.mcgf_+3A_x">x</code></td>
<td>
<p>An <code>mcgf</code> or <code>mcgf_rs</code> object.</p>
</td></tr>
<tr><td><code id="sds.mcgf_+3A_...">...</code></td>
<td>
<p>Additional parameters or attributes. Not in use.</p>
</td></tr>
<tr><td><code id="sds.mcgf_+3A_replace">replace</code></td>
<td>
<p>Logical; if TRUE, <code>sds</code> are recalculated.</p>
</td></tr>
<tr><td><code id="sds.mcgf_+3A_value">value</code></td>
<td>
<p>A vector (or list of vectors) of standard deviations for all
stations (under each regime and combined).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>mcgf</code> objects, <code><a href="#topic+sds">sds()</a></code> extracts or computes the empirical standard
deviations. The output is a vector of sds.
</p>
<p>For <code>mcgf_rs</code> objects, <code><a href="#topic+sds">sds()</a></code> extracts or computes the regime-switching
empirical standard deviations. The output is a list of vectors of sds. Each
element in the list corresponds to the sds for a regime.
</p>
<p><code><a href="#topic+sds+3C-">sds&lt;-</a></code> assigns <code>sds</code> to <code>x</code>. Use <code><a href="#topic+add_ccfs">add_ccfs()</a></code> to add both <code>ccfs</code> and
<code>sds</code> to <code>x</code>.
</p>


<h3>Value</h3>

<p><code><a href="#topic+sds">sds()</a></code> returns empirical (regime-switching) standard deviations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim1)
sim1_mcgf &lt;- mcgf(sim1$data, dists = sim1$dists)
sds(sim1_mcgf)

data(sim2)
sim2_mcgf &lt;- mcgf_rs(sim2$data, dists = sim2$dists, label = sim2$label)
sds(sim2_mcgf)
data(sim1)
sim1_mcgf &lt;- mcgf(sim1$data, dists = sim1$dists)
sim1_sds &lt;- sds(sim1_mcgf)
sds(sim1_mcgf) &lt;- sim1_sds

data(sim2)
sim2_mcgf &lt;- mcgf_rs(sim2$data, dists = sim2$dists, label = sim2$label)
sim2_sds &lt;- sds(sim2_mcgf)
sds(sim2_mcgf) &lt;- sim2_sds
</code></pre>

<hr>
<h2 id='sim1'>Simulated Markov chain Gaussian field</h2><span id='topic+sim1'></span>

<h3>Description</h3>

<p>Simulated MCGF for 10 locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim1
</code></pre>


<h3>Format</h3>

<p><code>sim1</code>: a list containing a data.frame with 1000 rows and 10 columns
and a list of distances
</p>


<h3>Details</h3>

<p><code>sim1</code> contains a simulated MCGF for 10 locations. It is simulated with a
separable base model and a triangular Lagrangian model. The true parameters
for the base model are: <code class="reqn">\text{nugget} = 0, c = 0.001, \gamma = 0.5,
a = 0.5, \alpha = 0.8</code>, and those for the Lagrangian model are:
<code class="reqn">v1 = 200, v2 = 200, k = 2, \lambda = 0.2</code>
</p>


<h3>See Also</h3>

<p>Other (simulated) datasets: 
<code><a href="#topic+sim2">sim2</a></code>,
<code><a href="#topic+sim3">sim3</a></code>,
<code><a href="#topic+wind">wind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Code used to generate `sim1`

library(mcgf)
set.seed(123)
x &lt;- stats::rnorm(10, -110)
y &lt;- stats::rnorm(10, 50)
locations &lt;- cbind(x, y)
h &lt;- find_dists(locations, longlat = TRUE)

N &lt;- 1000
lag &lt;- 5

par_base &lt;- list(
    par_s = list(nugget = 0, c = 0.001, gamma = 0.5),
    par_t = list(a = 0.5, alpha = 0.8)
)
par_lagr &lt;- list(v1 = 200, v2 = 200, k = 2)

sim1 &lt;- mcgf_sim(
    N = N, base = "sep", lagrangian = "lagr_tri",
    par_base = par_base, par_lagr = par_lagr, lambda = 0.2,
    dists = h, lag = lag
)
sim1 &lt;- sim1[-c(1:(lag + 1)), ]
rownames(sim1) &lt;- 1:nrow(sim1)

sim1 &lt;- list(data = sim1, locations = locations, dists = h)

</code></pre>

<hr>
<h2 id='sim2'>Simulated regime-switching Markov chain Gaussian field</h2><span id='topic+sim2'></span>

<h3>Description</h3>

<p>Simulated RS-MCGF for 10 locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim2
</code></pre>


<h3>Format</h3>

<p><code>sim2</code>: a list containing a data.frame with 1000 rows and 10 columns,
a list of distances, and a vector of regime labels.
</p>


<h3>Details</h3>

<p><code>sim2</code> contains a simulated RS-MCGF for 10 locations. It is simulated with
a regime-switching separable base model. The true parameters for the base
model are: </p>
<p style="text-align: center;"><code class="reqn">\text{Regime 1}: \text{nugget} = 0, c = 0.01, \gamma = 0.5,
a = 0.5, \alpha = 0.2,</code>
</p>

<p style="text-align: center;"><code class="reqn">\text{Regime 2}: \text{nugget} = 0, c = 0.04, \gamma = 0.5, a = 0.3,
\alpha = 0.9.</code>
</p>



<h3>See Also</h3>

<p>Other (simulated) datasets: 
<code><a href="#topic+sim1">sim1</a></code>,
<code><a href="#topic+sim3">sim3</a></code>,
<code><a href="#topic+wind">wind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Code used to generate `sim2`

library(mcgf)
set.seed(123)
x &lt;- stats::rnorm(10, -110)
y &lt;- stats::rnorm(10, 50)
locations &lt;- cbind(x, y)
h &lt;- find_dists(locations, longlat = TRUE)

# simulate regimes
K &lt;- 2
N &lt;- 1000
lag &lt;- 5

tran_mat &lt;- matrix(rnorm(K^2, mean = 0.06 / (K - 1), sd = 0.01), nrow = K)
diag(tran_mat) &lt;- rnorm(K, mean = 0.94, sd = 0.1)
tran_mat &lt;- sweep(abs(tran_mat), 1, rowSums(tran_mat), `/`)
tran_mat
#            [,1]       [,2]
# [1,] 0.94635675 0.05364325
# [2,] 0.06973429 0.93026571

regime &lt;- rep(NA, N)
regime[1] &lt;- 1

for (n in 2:(N)) {
    regime[n] &lt;- sample(1:K, 1, prob = tran_mat[regime[n - 1], ])
}
table(regime)
# regime
#   1   2
# 567 433

# simulate RS MCGF
par_base1 &lt;- list(
    par_s = list(nugget = 0, c = 0.001, gamma = 0.5),
    par_t = list(a = 0.5, alpha = 0.2)
)

par_base2 &lt;- list(
    par_s = list(nugget = 0, c = 0.004, gamma = 0.5),
    par_t = list(a = 0.3, alpha = 0.9)
)

sim2 &lt;- mcgf_rs_sim(
    N = N, label = regime,
    base_ls = list("sep"), lagrangian_ls = list("none"),
    par_base_ls = list(par_base1, par_base2),
    lambda_ls = list(0.1, 0.3),
    lag_ls = list(lag, lag),
    dists_ls = list(h, h)
)
sim2 &lt;- sim2[-c(1:(lag + 1)), ]
rownames(sim2) &lt;- 1:nrow(sim2)

sim2 &lt;- list(
    data = sim2[, -1], locations = locations, dists = h,
    label = sim2[, 1]
)

</code></pre>

<hr>
<h2 id='sim3'>Simulated regime-switching Markov chain Gaussian field</h2><span id='topic+sim3'></span>

<h3>Description</h3>

<p>Simulated RS-MCGF for 20 locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim3
</code></pre>


<h3>Format</h3>

<p><code>sim3</code>: a list containing a data.frame with 5000 rows and 20 columns
and a list of locations.
</p>


<h3>Details</h3>

<p><code>sim3</code> contains a simulated RS-MCGF for 20 locations. It is simulated with
the same base model and a regime-switching Lagrangian model. The true
parameters for the base model are: <code class="reqn">\text{nugget} = 0, c = 0.05,
\gamma = 0.5, a = 0.5, \alpha = 0.2</code>, and the true parameters for the
Lagrangian model are
</p>
<p style="text-align: center;"><code class="reqn">\text{Regime 1}: \lambda = 0.2, v_1 = -100, v_2 = 100, k = 2,</code>
</p>

<p style="text-align: center;"><code class="reqn">\text{Regime 1}: \lambda = 0.2, v_1 = 200, v_2 = 200, k = 2.</code>
</p>

<p>For parameter estimation, the base model is assumed known and is used to
estimate the regime-switching prevailing winds.
</p>


<h3>See Also</h3>

<p>Other (simulated) datasets: 
<code><a href="#topic+sim1">sim1</a></code>,
<code><a href="#topic+sim2">sim2</a></code>,
<code><a href="#topic+wind">wind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Code used to generate `sim3`

library(mcgf)
set.seed(123)
x &lt;- stats::rnorm(10, -110)
y &lt;- stats::rnorm(10, 50)
locations &lt;- cbind(x, y)
h &lt;- find_dists(locations, longlat = TRUE)

# simulate regimes
K &lt;- 2
N &lt;- 1000
lag &lt;- 5

tran_mat &lt;- matrix(rnorm(K^2, mean = 0.06 / (K - 1), sd = 0.01), nrow = K)
diag(tran_mat) &lt;- rnorm(K, mean = 0.94, sd = 0.1)
tran_mat &lt;- sweep(abs(tran_mat), 1, rowSums(tran_mat), `/`)
tran_mat
# [,1]       [,2]
# [1,] 0.94635675 0.05364325
# [2,] 0.06973429 0.93026571

regime &lt;- rep(NA, N)
regime[1] &lt;- 1

for (n in 2:(N)) {
    regime[n] &lt;- sample(1:K, 1, prob = tran_mat[regime[n - 1], ])
}
table(regime)
# regime
#   1   2
# 567 433

# simulate RS MCGF
par_base &lt;- list(
    par_s = list(nugget = 0, c = 0.05, gamma = 0.5),
    par_t = list(a = 0.5, alpha = 0.2)
)

par_lagr1 &lt;- list(v1 = -100, v2 = 100, k = 2)
par_lagr2 &lt;- list(v1 = 200, v2 = 200, k = 2)

sim3 &lt;- mcgf_rs_sim(
    N = N, label = regime,
    base_ls = list("sep"), lagrangian_ls = list("lagr_tri"),
    par_base_ls = list(par_base),
    par_lagr_ls = list(par_lagr1, par_lagr2),
    lambda_ls = list(0.2, 0.2),
    lag_ls = list(lag, lag),
    dists_ls = list(h, h)
)
sim3 &lt;- sim3[-c(1:(lag + 1)), ]
rownames(sim3) &lt;- 1:nrow(sim3)

sim3 &lt;- list(
    data = sim3[, -1], locations = locations, dists = h,
    label = sim3[, 1]
)

</code></pre>

<hr>
<h2 id='to_ar'>Convert to array</h2><span id='topic+to_ar'></span>

<h3>Description</h3>

<p>Convert to array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_ar(h, lag_max, u = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to_ar_+3A_h">h</code></td>
<td>
<p>Distance matrix.</p>
</td></tr>
<tr><td><code id="to_ar_+3A_lag_max">lag_max</code></td>
<td>
<p>Maximum time lag.</p>
</td></tr>
<tr><td><code id="to_ar_+3A_u">u</code></td>
<td>
<p>Logical; TRUE if u_ar needs to be outputted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of arrays of h and u.
</p>

<hr>
<h2 id='validate_mcgf'>Validate an mcgf object</h2><span id='topic+validate_mcgf'></span>

<h3>Description</h3>

<p>Validate an mcgf object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_mcgf(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_mcgf_+3A_x">x</code></td>
<td>
<p>An mcgf object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It validates an <code>mcgf</code> object by checking if <code>dists</code> contains valid
distance matrics/arrays.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>mcgf</code>.
</p>

<hr>
<h2 id='validate_mcgf_rs'>Validate an mcgf_rs object</h2><span id='topic+validate_mcgf_rs'></span>

<h3>Description</h3>

<p>Validate an mcgf_rs object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_mcgf_rs(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_mcgf_rs_+3A_x">x</code></td>
<td>
<p>An mcgf_rs object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It validates an <code>mcgf_rs</code> object by checking if <code>label</code> is of the matching
length.
</p>


<h3>Value</h3>

<p>An S3 object of class <code>mcgf_rs</code>.
</p>

<hr>
<h2 id='wind'>Ireland wind data, 1961-1978</h2><span id='topic+wind'></span>

<h3>Description</h3>

<p>Daily average wind speeds for 1961-1978 at 11 synoptic meteorological
stations in the Republic of Ireland (Haslett and raftery 1989). Wind speeds
are in m/s. De-trended data sets are also provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wind
</code></pre>


<h3>Format</h3>

<p><code>wind</code>: a list containing a data.frame with 6574 rows and 12 columns,
and a list of locations.
</p>


<h3>Details</h3>

<p>The data were obtained from the <strong>gstat</strong> package, and were modified so that
the first column is the time stamps. Locations of the 11 stations are given
in <code>wind_loc</code>. <code>wind_train</code> and <code>wind_test</code> contain de-trended and
square-root transformed train (1961-1970) and test (1971-1978) data sets.
See Gneiting et al. (2006) for de-trending details. <code>wind_trend</code> contains
the estimated annual trend and station-wise mean from the training dataset.
</p>


<h3>References</h3>

<p>Haslett, J. and Raftery, A. E. (1989). Space-time Modelling with Long-memory
Dependence: Assessing Ireland's Wind Power Resource (with Discussion).
Applied Statistics 38, 1-50.
</p>
<p>Gneiting, T., Genton, M., &amp; Guttorp, P. (2006). Geostatistical Space-Time
Models, Stationarity, Separability, and Full Symmetry. In C&amp;H/CRC
Monographs on Statistics &amp; Applied Probability (pp. 151–175).
Chapman and Hall/CRC.
</p>


<h3>See Also</h3>

<p>Other (simulated) datasets: 
<code><a href="#topic+sim1">sim1</a></code>,
<code><a href="#topic+sim2">sim2</a></code>,
<code><a href="#topic+sim3">sim3</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
