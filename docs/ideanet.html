<!DOCTYPE html><html lang="en"><head><title>Help for package ideanet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ideanet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#comm_detect'><p>Community Detection Across Multiple Routines (<code>comm_detect</code>)</p></a></li>
<li><a href='#ego_homophily'><p>Measuring Homophily in Ego Networks (<code>ego_homophily</code>)</p></a></li>
<li><a href='#ego_netwrite'><p>Ego Network Cleaning and Measure Calculation (<code>ego_netwrite</code>)</p></a></li>
<li><a href='#ego_reshape'><p>Reshaping Egocentric Data (<code>ego_reshape</code>)</p></a></li>
<li><a href='#ei_index'><p>Krackhardt and Stern’s E-I Index (<code>ei_index</code>)</p></a></li>
<li><a href='#euclidean_distance'><p>Euclidean Distance (<code>euclidean_distance</code>)</p></a></li>
<li><a href='#fauxmesa_edges'><p>Goodreau's Faux Mesa High School (Edgelist)</p></a></li>
<li><a href='#fauxmesa_nodes'><p>Goodreau's Faux Mesa High School (Nodelist)</p></a></li>
<li><a href='#florentine_edges'><p>Edgelist of marriage alliances and business relationships between Florentine families during the Italian Renaissance</p></a></li>
<li><a href='#florentine_nodes'><p>Nodelist of marriage alliances and business relationships between Florentine families during the Italian Renaissance</p></a></li>
<li><a href='#h_index'><p>H-Index (<code>h_index</code>)</p></a></li>
<li><a href='#hightech'><p>Multiplex Network of Relationships Between Managers of a High-Tech Company</p></a></li>
<li><a href='#ideanetViz'><p>Interactive GUI for Working with Sociocentric Networks (<code>ideanetViz</code>)</p></a></li>
<li><a href='#iqv'><p>Agresti's Index of Qualitative Variation (<code>iqv</code>)</p></a></li>
<li><a href='#marvel'><p>Character Relations in Marvel Comics</p></a></li>
<li><a href='#nc_merge'><p>Merging Network Canvas CSV Files (<code>nc_merge</code>)</p></a></li>
<li><a href='#nc_read'><p>Reading and Reshaping Network Canvas Data (<code>nc_read</code>)</p></a></li>
<li><a href='#netread'><p>Reading Network Data Files and Initial Cleaning (<code>netread</code>)</p></a></li>
<li><a href='#netwrite'><p>Network Cleaning and Variable Calculation (<code>netwrite</code>)</p></a></li>
<li><a href='#ngq_aa'><p>Ego Networks Elicited from the &quot;Important Matters&quot; Name Generator Question (Alter-Alter Edgelist)</p></a></li>
<li><a href='#ngq_alters'><p>Ego Networks Elicited from the &quot;Important Matters&quot; Name Generator Question (Alter List)</p></a></li>
<li><a href='#ngq_egos'><p>Ego Networks Elicited from the &quot;Important Matters&quot; Name Generator Question (Nodelist)</p></a></li>
<li><a href='#pearson_phi'><p>Pearson's Phi (<code>pearson_phi</code>)</p></a></li>
<li><a href='#qap_run'><p>Quadratic Assignment Procedure (<code>qap_run</code>).</p></a></li>
<li><a href='#qap_setup'><p>Individual to Dyadic variable transformation (<code>qap_setup</code>).</p></a></li>
<li><a href='#role_analysis'><p>Positional (Role) Analysis in Networks (<code>role_analysis</code>)</p></a></li>
<li><a href='#triad'><p>A Small Network Containing all Triads and Motifs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Integrating Data Exchange and Analysis for Networks ('ideanet')</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-12-06</td>
</tr>
<tr>
<td>Description:</td>
<td>A suite of convenient tools for social network analysis geared toward students, entry-level users, and non-expert practitioners. ‘ideanet’ features unique functions for the processing and measurement of sociocentric and egocentric network data. These functions automatically generate node- and system-level measures commonly used in the analysis of these types of networks. Outputs from these functions maximize the ability of novice users to employ network measurements in further analyses while making all users less prone to common data analytic errors. Additionally, ‘ideanet’ features an R Shiny graphic user interface that allows novices to explore network data with minimal need for coding.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tom Wolff &lt;tom.wolff@northwestern.edu&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>CliquePercolation, cluster, colorspace, concorR, cowplot,
data.table, dplyr, forcats, ggplot2, grDevices, gridGraphics,
igraph, intergraph, jsonlite, linkcomm, magrittr, Matrix,
methods, moments, network, readxl, rlang, RSpectra, shiny, sna,
stringr, tibble, tidyr, tidyselect</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DT, devtools, egor, ergm, shinythemes, shinyWidgets, knitr,
rmarkdown, shinycssloaders, visNetwork</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-11 18:25:01 UTC; wms1212</td>
</tr>
<tr>
<td>Author:</td>
<td>Tom Wolff <a href="https://orcid.org/0000-0002-4884-251X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Jonathan Howard Morgan
    <a href="https://orcid.org/0000-0001-5181-9903"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Gabriel Varela <a href="https://orcid.org/0000-0003-2800-1577"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Kieran Lele [aut],
  Ethan Bhojani [aut],
  Emily Heraty [aut],
  Dana Pasquale <a href="https://orcid.org/0000-0001-6686-7844"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Peter Mucha <a href="https://orcid.org/0000-0002-0648-7230"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  James Moody <a href="https://orcid.org/0000-0002-3311-4173"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-13 09:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling 'rhs(lhs)'.
</p>

<hr>
<h2 id='comm_detect'>Community Detection Across Multiple Routines (<code>comm_detect</code>)</h2><span id='topic+comm_detect'></span>

<h3>Description</h3>

<p>The <code>comm_detect</code> function runs a set of several commonly-used community detection routines on a network and provides community assignments from these routines. Need to mention that only supports undirected nets and that for some routines the median community value is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm_detect(g, modres = 1, slow_routines = FALSE, shiny = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comm_detect_+3A_g">g</code></td>
<td>
<p>An igraph object. If the igraph object contains a directed network, the function will treat the network as undirected before running community detection routines.</p>
</td></tr>
<tr><td><code id="comm_detect_+3A_modres">modres</code></td>
<td>
<p>A modularity resolution parameter used when performing community detection using the Leiden method.</p>
</td></tr>
<tr><td><code id="comm_detect_+3A_slow_routines">slow_routines</code></td>
<td>
<p>A logical indicating whether time-intensive community detection routines should be performed on larger networks. Edge betweenness, leading eigenvector, link communities, and stochastic blockmodeling each take a very long time to identify communities in networks consisting of more than a few thousand nodes. By default, <code>comm_detect</code> will skip performing these routines on networks with more than 5,000 nodes and inform the user that it is doing so.</p>
</td></tr>
<tr><td><code id="comm_detect_+3A_shiny">shiny</code></td>
<td>
<p>An argument indicating whether the output from the <code>comm_detect</code> function will be fed into the IDEANet visualization app.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>comm_detect</code> returns a list contianing three data frames. <code>comm_members</code> indicates each node's assigned community membership from each community detection routine. <code>comm_summaries</code> indicates the number of communities inferred from each routine as well as the modularity score arising from community assignments. <code>comp_scores</code> contains a matrix indicating the similarity of community assignments between each pair of community detection routines, measured using adjusted rand scores. A fourth element in the list, <code>plots</code>, contains a series of network visualizations in which nodes are colored by their assigned community memberships from each routine. If <code>shiny == FALSE</code>, this function will display these visualizations in the user's plot window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Run netwrite
nw_fauxmesa &lt;- netwrite(nodelist = fauxmesa_nodes,
                      node_id = "id",
                      i_elements = fauxmesa_edges$from,
                      j_elements = fauxmesa_edges$to,
                      directed = TRUE,
                      net_name = "faux_mesa",
                      output = "graph")

# Run comm_detect
faux_communities &lt;- comm_detect(g = nw_fauxmesa$faux_mesa)
</code></pre>

<hr>
<h2 id='ego_homophily'>Measuring Homophily in Ego Networks (<code>ego_homophily</code>)</h2><span id='topic+ego_homophily'></span>

<h3>Description</h3>

<p>The <code>ego_homophily</code> function identifies how similar ego is from their alters on a given attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ego_homophily(
  ego_id,
  ego_measure,
  alter_ego,
  alter_measure,
  prefix = NULL,
  suffix = NULL,
  prop = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ego_homophily_+3A_ego_id">ego_id</code></td>
<td>
<p>A vector of unique ego identifiers located in an ego dataframe. If using data objects created by <code><a href="#topic+ego_netwrite">ego_netwrite</a></code>, this should be the data frame entitled <code>egos</code>.</p>
</td></tr>
<tr><td><code id="ego_homophily_+3A_ego_measure">ego_measure</code></td>
<td>
<p>A vector of attributes corresponding to each ego.</p>
</td></tr>
<tr><td><code id="ego_homophily_+3A_alter_ego">alter_ego</code></td>
<td>
<p>A vector of ego identifiers located in an alter dataframe. If using data objects created by <code><a href="#topic+ego_netwrite">ego_netwrite</a></code>, this should be the data frame entitled <code>alters</code>.</p>
</td></tr>
<tr><td><code id="ego_homophily_+3A_alter_measure">alter_measure</code></td>
<td>
<p>A vector of attributes corresponding to each alter</p>
</td></tr>
<tr><td><code id="ego_homophily_+3A_prefix">prefix</code></td>
<td>
<p>A character value indicating the desired prefix for the calculated homophily measure.</p>
</td></tr>
<tr><td><code id="ego_homophily_+3A_suffix">suffix</code></td>
<td>
<p>A character value indicating the desired suffix for the calculated homophily measure.</p>
</td></tr>
<tr><td><code id="ego_homophily_+3A_prop">prop</code></td>
<td>
<p>A logical value indicating whether homophily should be represented as a count or as a proportion.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ego_homophily</code> returns a dataframe of vectors that include the ego identifier and the number or proportion of alters with the same selected attribute
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Run `ego_netwrite`
ngq_nw &lt;- ego_netwrite(egos = ngq_egos,
                      ego_id = ngq_egos$ego_id,

                      alters = ngq_alters,
                      alter_id = ngq_alters$alter_id,
                      alter_ego = ngq_alters$ego_id,

                      max_alters = 10,
                      alter_alter = ngq_aa,
                      aa_ego = ngq_aa$ego_id,
                      i_elements = ngq_aa$alter1,
                      j_elements = ngq_aa$alter2,
                      directed = FALSE)


# Homophily as a Count
race_homophily_count &lt;- ego_homophily(ego_id = ngq_nw$egos$ego_id,
                                     ego_measure = ngq_nw$egos$race,
                                     alter_ego = ngq_nw$alters$ego_id,
                                     alter_measure = ngq_nw$alters$race,
                                     suffix = "race")

race_homophily_count

# Homophily as a Proportion
race_homophily_prop &lt;- ego_homophily(ego_id = ngq_nw$egos$ego_id,
                                    ego_measure = ngq_nw$egos$race,
                                    alter_ego = ngq_nw$alters$ego_id,
                                    alter_measure = ngq_nw$alters$race,
                                    prop = TRUE,
                                    suffix = "race")
race_homophily_prop
</code></pre>

<hr>
<h2 id='ego_netwrite'>Ego Network Cleaning and Measure Calculation (<code>ego_netwrite</code>)</h2><span id='topic+ego_netwrite'></span>

<h3>Description</h3>

<p>The <code>ego_netwrite</code> function reads in data pertaining to ego networks and processes them into a set of standardized outputs, including measures commonly calculated for ego networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ego_netwrite(
  egos,
  ego_id,
  alters = NULL,
  alter_id = NULL,
  alter_ego = NULL,
  alter_types = NULL,
  max_alters = Inf,
  alter_alter = NULL,
  aa_ego = NULL,
  i_elements = NULL,
  j_elements = NULL,
  directed = FALSE,
  aa_type = NULL,
  missing_code = 99999,
  na.rm = FALSE,
  egor = FALSE,
  egor_design = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ego_netwrite_+3A_egos">egos</code></td>
<td>
<p>A data frame containing measures of ego attributes.</p>
</td></tr>
<tr><td><code id="ego_netwrite_+3A_ego_id">ego_id</code></td>
<td>
<p>A vector of unique identifiers corresponding to each ego, or a single character value indicating the name of the column in <code>egos</code> containing ego identifiers.</p>
</td></tr>
<tr><td><code id="ego_netwrite_+3A_alters">alters</code></td>
<td>
<p>A data frame containing measures of alter attributes.</p>
</td></tr>
<tr><td><code id="ego_netwrite_+3A_alter_id">alter_id</code></td>
<td>
<p>A vector of identifiers indicating which alter is associated with a given row in <code>alters</code>, or a single character value indicating the name of the column in <code>alters</code> containing alter identifiers.</p>
</td></tr>
<tr><td><code id="ego_netwrite_+3A_alter_ego">alter_ego</code></td>
<td>
<p>A vector of identifiers indicating which ego is associated with a given alter, or a single character value indicating the name of the column in <code>alters</code> containing ego identifiers.</p>
</td></tr>
<tr><td><code id="ego_netwrite_+3A_alter_types">alter_types</code></td>
<td>
<p>A character vector indicating the columns in <code>alters</code> that indicate whether a given alter has certain types of relations with ego. These columns should all contain binary measures indicating whether alter has a particular type of relation with ego.</p>
</td></tr>
<tr><td><code id="ego_netwrite_+3A_max_alters">max_alters</code></td>
<td>
<p>A numeric value indicating the maximum number of alters an ego in the dataset could have nominated</p>
</td></tr>
<tr><td><code id="ego_netwrite_+3A_alter_alter">alter_alter</code></td>
<td>
<p>A data frame containing an edgelist indicating ties between alters in each ego's network. This edgelist is optional, but <code>ego_netwrite</code> will not provide certain measures without it.</p>
</td></tr>
<tr><td><code id="ego_netwrite_+3A_aa_ego">aa_ego</code></td>
<td>
<p>A vector of identifiers indicating which ego is associated with a given tie between alters, or a single character indicating the name of the column in <code>alter_alter</code> containing ego identifiers.</p>
</td></tr>
<tr><td><code id="ego_netwrite_+3A_i_elements">i_elements</code></td>
<td>
<p>A vector of identifiers indicating which alter is on one end of an alter-alter tie, or a single character indicating the name of the column in <code>alter_alter</code> containing these identifiers.</p>
</td></tr>
<tr><td><code id="ego_netwrite_+3A_j_elements">j_elements</code></td>
<td>
<p>A vector of identifiers indicating which alter is on the other end of an alter-alter tie, or a single character indicating the name of the column in <code>alter_alter</code> containing these identifiers.</p>
</td></tr>
<tr><td><code id="ego_netwrite_+3A_directed">directed</code></td>
<td>
<p>A logical value indicating whether network ties are directed or undirected.</p>
</td></tr>
<tr><td><code id="ego_netwrite_+3A_aa_type">aa_type</code></td>
<td>
<p>A numeric or character vector indicating the types of relationships represented in the alter edgelist, or a single character value indicating the name of the column in <code>alter_alter</code> containing relationship type. If <code>alter_type</code> is specified, <code>ego_netwrite</code> will treat the data as a set of multi-relational networks and produce additional outputs reflecting the different types of ties occurring in each ego network.</p>
</td></tr>
<tr><td><code id="ego_netwrite_+3A_missing_code">missing_code</code></td>
<td>
<p>A numeric value indicating &quot;missing&quot; values in the alter-alter edgelist.</p>
</td></tr>
<tr><td><code id="ego_netwrite_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical value indicating whether <code>NA</code> values should be excluded when calculating continuous measures.</p>
</td></tr>
<tr><td><code id="ego_netwrite_+3A_egor">egor</code></td>
<td>
<p>A logical value indicating whether output should include an <code>egor</code> object, which is often useful for visualizaton and for simulation larger networks from egocentric data.</p>
</td></tr>
<tr><td><code id="ego_netwrite_+3A_egor_design">egor_design</code></td>
<td>
<p>If creating an <code>egor</code> object, a list of arguments to <code><a href="srvyr.html#topic+as_survey_design">srvyr::as_survey_design</a></code> specifying the sampling design for egos. This argument corresponds to <code>ego_design</code> in <code><a href="egor.html#topic+egor">egor::egor</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ego_netwrite</code> returns a list containing several output objects. Users may find it easier to access and work with outputs by applying <a href="base.html#topic+list2env">list2env</a> to this list, which will separate outputs and store them in the R Global Environment. Note, however, that this risks overwriting existing objects in the Global Environment should those objects share names with objects in <code>netwrite</code>'s output. Outputs include a data frame containing measures of ego attributes, another data frame containing measures of alter attributes and network position, a third containing the alter-alter edgelist (when applicable), a fourth containing summary measures for each individual ego network, and a fifth providing summary measures for the overall dataset. Additionally, <code>ego_netwrite</code> returns a list of <code>igraph</code> objects constructed for each individual ego network, as well as an <code>egor</code> object for the overall dataset if desired.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simple Processing, Ignoring Ego-Alter or Alter-Alter Relation Types
ngq_nw &lt;- ego_netwrite(egos = ngq_egos,
                       ego_id = ngq_egos$ego_id,

                       alters = ngq_alters,
                       alter_id = ngq_alters$alter_id,
                       alter_ego = ngq_alters$ego_id,

                       max_alters = 10,
                       alter_alter = ngq_aa,
                       aa_ego = ngq_aa$ego_id,
                       i_elements = ngq_aa$alter1,
                       j_elements = ngq_aa$alter2,
                       directed = FALSE)


# View summaries of individual ego networks
head(ngq_nw$summaries)

# View summary of overall dataset
head(ngq_nw$overall_summary)

# View sociogram of fourth ego network
plot(ngq_nw$igraph_objects[[4]]$igraph_ego)


# For advanced applications involving multiple relationship types
# and `egor` object creation, please consult the `ego_netwrite` vignette
vignette("ego_netwrite", package = "ideanet")
</code></pre>

<hr>
<h2 id='ego_reshape'>Reshaping Egocentric Data (<code>ego_reshape</code>)</h2><span id='topic+ego_reshape'></span>

<h3>Description</h3>

<p>The <code>ego_reshape</code> function reshapes egocentric network data stored in a single wide dataset into three dataframes optimized for use with <code><a href="#topic+ego_netwrite">ego_netwrite</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ego_reshape(
  data,
  ego_id,
  ego_vars,
  alters,
  alter_vars,
  alter_alter,
  aa_vars = NULL,
  directed = NULL,
  loops = NULL,
  missing_code = 99999,
  output_name = "ego_long"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ego_reshape_+3A_data">data</code></td>
<td>
<p>A data frame containing egocentric network data in a wide format.</p>
</td></tr>
<tr><td><code id="ego_reshape_+3A_ego_id">ego_id</code></td>
<td>
<p>A character value indicating the name of the column in <code>data</code> containing ego identifiers, or a numeric value indicating the position of the column containing ego identifiers.</p>
</td></tr>
<tr><td><code id="ego_reshape_+3A_ego_vars">ego_vars</code></td>
<td>
<p>A character vector indicating the names of the columns in <code>data</code> containing ego-level measures, or a numeric vector indicating the positions of the columns containing ego-level measures.</p>
</td></tr>
<tr><td><code id="ego_reshape_+3A_alters">alters</code></td>
<td>
<p>A character vector indicating the names of the columns in <code>data</code> containing ego-alter ties, or a numeric vector indicating the positions of the columns containing ego-alter ties.</p>
</td></tr>
<tr><td><code id="ego_reshape_+3A_alter_vars">alter_vars</code></td>
<td>
<p>A character vector indicating the names of the columns in <code>data</code> containing alter-level measures, or a numeric vector indicating the positions of the columns containing alter-level measures. Variables are assumed to be ordered such that each consecutive set of columns represent a single alter-level variable, and that columns within this set are ordered such that the first column represents the value associated with the alter represented by the first column specified in <code>alters</code>, the second column in the set is associated with the alter represented by the second column in <code>alters</code>, and so on. If a certain variable was collected for only the first <code>n</code> alters in a survey instrument, we recommend creating placeholder columns in which all values are coded <code>NA</code>.</p>
</td></tr>
<tr><td><code id="ego_reshape_+3A_alter_alter">alter_alter</code></td>
<td>
<p>A character vector indicating the names of the columns in <code>data</code> that indicate the presence of alter-alter ties, or a numeric vector indicating the positions of the columns indicating alter-alter ties. These columns should be ordered such that their values appear as they would were one to move left-to-right, top-to-bottom in an adjacency matrix. For example, the value of column 1 should usually indicate whether a tie exists between alter 1 and alter 2, the value of column 2 should indicate the presence of a tie between alter 1 and alter 3, the value of column 3 should indicate the presence of a tie between alter 1 and alter 4, and so on. The number of columns needed to represent the full set of possible ties between alters may vary depending on a) whether ties in the network are directed or undirected, and b) whether it is possible for alters to be tied to themselves. If users do not specify these conditions using the <code>directed</code> and <code>loops</code> arguments, respectively, This function uses the number of columns specified in <code>alters</code> to detect the presenece of directed ties and self-loops in the network.</p>
</td></tr>
<tr><td><code id="ego_reshape_+3A_aa_vars">aa_vars</code></td>
<td>
<p>A character vector indicating the names of the columns in <code>data</code> representing edge-level characteristics of alter-alter ties. Columns should be ordered in a similar fashion as with <code>alter_vars</code> where consecutive sets of <code>n</code> columns represent a single variable and columns within these sets are ordered in the same way as their corresponding edge indicator columns are ordered in <code>alter_alter</code>.</p>
</td></tr>
<tr><td><code id="ego_reshape_+3A_directed">directed</code></td>
<td>
<p>A logical value indicating whether alter-alter ties are directed or undirected.</p>
</td></tr>
<tr><td><code id="ego_reshape_+3A_loops">loops</code></td>
<td>
<p>A logical value indicating whether alter-alter ties contain self-loops (alters can be tied to themselves).</p>
</td></tr>
<tr><td><code id="ego_reshape_+3A_missing_code">missing_code</code></td>
<td>
<p>A numeric value indicating &quot;missing&quot; values in the alter-alter edgelist.</p>
</td></tr>
<tr><td><code id="ego_reshape_+3A_output_name">output_name</code></td>
<td>
<p>A character value indicating the name or prefix that should be given to output objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing three data frames: an ego list, an ego-alter edgelist, and an alter-alter edgelist. These dataframes are optimized for use with <code><a href="#topic+ego_netwrite">ego_netwrite</a></code>.
</p>

<hr>
<h2 id='ei_index'>Krackhardt and Stern’s E-I Index (<code>ei_index</code>)</h2><span id='topic+ei_index'></span>

<h3>Description</h3>

<p>Linear transformation of the proportion homophilous measure (Krackhardt and Stern 1988; Perry et al. 2018)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ei_index(
  ego_id,
  ego_measure,
  alter_ego,
  alter_measure,
  prefix = NULL,
  suffix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ei_index_+3A_ego_id">ego_id</code></td>
<td>
<p>A vector of unique ego identifiers located in an ego dataframe. If using data objects created by <code><a href="#topic+ego_netwrite">ego_netwrite</a></code>, this should be the data frame entitled <code>egos</code>.</p>
</td></tr>
<tr><td><code id="ei_index_+3A_ego_measure">ego_measure</code></td>
<td>
<p>A vector of attributes corresponding to each ego</p>
</td></tr>
<tr><td><code id="ei_index_+3A_alter_ego">alter_ego</code></td>
<td>
<p>A vector of ego identifiers located in an alter dataframe. If using data objects created by <code><a href="#topic+ego_netwrite">ego_netwrite</a></code>, this should be the data frame entitled <code>alters</code>.</p>
</td></tr>
<tr><td><code id="ei_index_+3A_alter_measure">alter_measure</code></td>
<td>
<p>A vector of attributes corresponding to each alter</p>
</td></tr>
<tr><td><code id="ei_index_+3A_prefix">prefix</code></td>
<td>
<p>A character value indicating the desired prefix for the calculated E-I measure</p>
</td></tr>
<tr><td><code id="ei_index_+3A_suffix">suffix</code></td>
<td>
<p>A character value indicating the desired suffix for the calculated E-I measure</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ei_index</code> returns a dataframe of vectors that include the ego identifier and the ei-index value for the selected attribute
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Run `ego_netwrite`
ngq_nw &lt;- ego_netwrite(egos = ngq_egos,
                      ego_id = ngq_egos$ego_id,

                      alters = ngq_alters,
                      alter_id = ngq_alters$alter_id,
                      alter_ego = ngq_alters$ego_id,

                      max_alters = 10,
                      alter_alter = ngq_aa,
                      aa_ego = ngq_aa$ego_id,
                      i_elements = ngq_aa$alter1,
                      j_elements = ngq_aa$alter2,
                      directed = FALSE)


# Calculate E-I Index for Race
race_ei &lt;- ei_index(ego_id = ngq_nw$egos$ego_id, ego_measure = ngq_nw$egos$race,
                   alter_ego = ngq_nw$alters$ego_id, alter_measure = ngq_nw$alters$race,
                   prefix = "race")

race_ei
</code></pre>

<hr>
<h2 id='euclidean_distance'>Euclidean Distance (<code>euclidean_distance</code>)</h2><span id='topic+euclidean_distance'></span>

<h3>Description</h3>

<p>Typical difference between between ego and their alters for a given continuous attribute (Perry et al. 2018)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euclidean_distance(
  ego_id,
  ego_measure,
  alter_ego,
  alter_measure,
  prefix = NULL,
  suffix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="euclidean_distance_+3A_ego_id">ego_id</code></td>
<td>
<p>A vector of unique ego identifiers located in an ego dataframe. If using data objects created by <code><a href="#topic+ego_netwrite">ego_netwrite</a></code>, this should be the data frame entitled <code>egos</code>.</p>
</td></tr>
<tr><td><code id="euclidean_distance_+3A_ego_measure">ego_measure</code></td>
<td>
<p>A vector of attributes corresponding to each ego.</p>
</td></tr>
<tr><td><code id="euclidean_distance_+3A_alter_ego">alter_ego</code></td>
<td>
<p>A vector of ego identifiers located in an alter dataframe. If using data objects created by <code><a href="#topic+ego_netwrite">ego_netwrite</a></code>, this should be the data frame entitled <code>alters</code>.</p>
</td></tr>
<tr><td><code id="euclidean_distance_+3A_alter_measure">alter_measure</code></td>
<td>
<p>A vector of attributes corresponding to each alter.</p>
</td></tr>
<tr><td><code id="euclidean_distance_+3A_prefix">prefix</code></td>
<td>
<p>A character value indicating the desired prefix for the calculated homophily measure.</p>
</td></tr>
<tr><td><code id="euclidean_distance_+3A_suffix">suffix</code></td>
<td>
<p>A character value indicating the desired suffix for the calculated homophily measure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>euclidean_distance</code> returns a dataframe of vectors that include the ego identifier and euclidean distance for the desired continuous attribute
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Run `ego_netwrite`
ngq_nw &lt;- ego_netwrite(egos = ngq_egos,
                      ego_id = ngq_egos$ego_id,

                      alters = ngq_alters,
                      alter_id = ngq_alters$alter_id,
                      alter_ego = ngq_alters$ego_id,

                      max_alters = 10,
                      alter_alter = ngq_aa,
                      aa_ego = ngq_aa$ego_id,
                      i_elements = ngq_aa$alter1,
                      j_elements = ngq_aa$alter2,
                      directed = FALSE)


# Calculate Euclidean Distance
pol_euc &lt;- euclidean_distance(ego_id = ngq_nw$egos$ego_id, ego_measure = ngq_nw$egos$pol,
                             alter_ego = ngq_nw$alters$ego_id, alter_measure = ngq_nw$alters$pol,
                             prefix = "pol")
pol_euc
</code></pre>

<hr>
<h2 id='fauxmesa_edges'>Goodreau's Faux Mesa High School (Edgelist)</h2><span id='topic+fauxmesa_edges'></span>

<h3>Description</h3>

<p>This data set (originally found in as a <code>network</code> object in the <code>ergm</code> package)
represents a simulation of an in-school friendship network. The network is named &quot;Faux Mesa High&quot; because the school
community on which it is based is in the rural western US, with a student body that is largely Hispanic and Native American.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fauxmesa_edges
</code></pre>


<h3>Format</h3>

<p>A data frame with 203 rows and 2 columns:
</p>

<dl>
<dt>from</dt><dd><p>Outgoing node</p>
</dd>
<dt>to</dt><dd><p>Receiving node</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p>The data set is based upon a model fit to data from one school
community from the AddHealth Study, Wave I (Resnick et al., 1997). It was
constructed as follows:
</p>
<p>A vector representing the sex of each student in the school was randomly
re-ordered.  The same was done with the students' response to questions on
race and grade.  These three attribute vectors were permuted independently.
Missing values for each were randomly assigned with weights determined by
the size of the attribute classes in the school.
</p>
<p>The following <code>ergm</code> formula was used to fit a model to the
original data:
</p>
<pre> ~ edges + nodefactor("Grade") + nodefactor("Race") +
nodefactor("Sex") + nodematch("Grade",diff=TRUE) +
nodematch("Race",diff=TRUE) + nodematch("Sex",diff=FALSE) +
gwdegree(1.0,fixed=TRUE) + gwesp(1.0,fixed=TRUE) + gwdsp(1.0,fixed=TRUE) </pre>
<p>The resulting model fit was then applied to a network with actors possessing
the permuted attributes and with the same number of edges as in the original
data.
</p>
<p>The processes for handling missing data and defining the race attribute are
described in Hunter, Goodreau &amp; Handcock (2008).
</p>

<hr>
<h2 id='fauxmesa_nodes'>Goodreau's Faux Mesa High School (Nodelist)</h2><span id='topic+fauxmesa_nodes'></span>

<h3>Description</h3>

<p>This data set (originally found in as a <code>network</code> object in the <code>ergm</code> package)
represents a simulation of an in-school friendship network. The network is named &quot;Faux Mesa High&quot; because the school
community on which it is based is in the rural western US, with a student body that is largely Hispanic and Native American.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fauxmesa_nodes
</code></pre>


<h3>Format</h3>

<p>A data frame with 205 rows and 4 columns:
</p>

<dl>
<dt>id</dt><dd><p>Node ID</p>
</dd>
<dt>grade</dt><dd><p>Student grade year</p>
</dd>
<dt>race</dt><dd><p>Student race</p>
</dd>
<dt>sex</dt><dd><p>Student sex</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p>The data set is based upon a model fit to data from one school
community from the AddHealth Study, Wave I (Resnick et al., 1997). It was
constructed as follows:
</p>
<p>A vector representing the sex of each student in the school was randomly
re-ordered.  The same was done with the students' response to questions on
race and grade.  These three attribute vectors were permuted independently.
Missing values for each were randomly assigned with weights determined by
the size of the attribute classes in the school.
</p>
<p>The following <code>ergm</code> formula was used to fit a model to the
original data:
</p>
<pre> ~ edges + nodefactor("Grade") + nodefactor("Race") +
nodefactor("Sex") + nodematch("Grade",diff=TRUE) +
nodematch("Race",diff=TRUE) + nodematch("Sex",diff=FALSE) +
gwdegree(1.0,fixed=TRUE) + gwesp(1.0,fixed=TRUE) + gwdsp(1.0,fixed=TRUE) </pre>
<p>The resulting model fit was then applied to a network with actors possessing
the permuted attributes and with the same number of edges as in the original
data.
</p>
<p>The processes for handling missing data and defining the race attribute are
described in Hunter, Goodreau &amp; Handcock (2008).
</p>

<hr>
<h2 id='florentine_edges'>Edgelist of marriage alliances and business relationships between Florentine families during the Italian Renaissance</h2><span id='topic+florentine_edges'></span>

<h3>Description</h3>

<p>Breiger &amp; Pattison (1986), in their discussion of local role analysis, use a subset of data on
the social relations among Renaissance Florentine families collected by John Padgett
from historical documents. The two relations are business ties (recorded financial ties such as loans,
credits and joint partnerships) and marriage alliances. This dataset has since become a standard for illustrating
role analysis methods and working with networks featuring multiple types of relations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>florentine_edges
</code></pre>


<h3>Format</h3>

<p>A data frame with 35 rows and 4 columns:
</p>

<dl>
<dt>source</dt><dd><p>Outgoing node</p>
</dd>
<dt>target</dt><dd><p>Receiving node</p>
</dd>
<dt>weight</dt><dd><p>A placeholder variable for tie/edge weights, set to 1</p>
</dd>
<dt>type</dt><dd><p>Relation type</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p>John Padgett (<a href="http://www.casos.cs.cmu.edu/computational_tools/datasets/external/padgett/index2.html">Website</a>)
</p>


<h3>References</h3>

<p>Ronald L. Breiger and Philippa E Pattison. 1986. &quot;Cumulated social roles: The duality of persons and their algebras.&quot; <em>Social Networks</em> 8(13):215-256.
</p>

<hr>
<h2 id='florentine_nodes'>Nodelist of marriage alliances and business relationships between Florentine families during the Italian Renaissance</h2><span id='topic+florentine_nodes'></span>

<h3>Description</h3>

<p>Breiger &amp; Pattison (1986), in their discussion of local role analysis, use a subset of data on
the social relations among Renaissance Florentine families collected by John Padgett
from historical documents. The two relations are business ties (recorded financial ties such as loans,
credits and joint partnerships) and marriage alliances. This dataset has since become a standard for illustrating
role analysis methods and working with networks featuring multiple types of relations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>florentine_nodes
</code></pre>


<h3>Format</h3>

<p>A data frame with 16 rows and 2 columns:
</p>

<dl>
<dt>id</dt><dd><p>Unique node ID number</p>
</dd>
<dt>family</dt><dd><p>Name of family corresponding to node</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p>John Padgett (<a href="http://www.casos.cs.cmu.edu/computational_tools/datasets/external/padgett/index2.html">Website</a>)
</p>


<h3>References</h3>

<p>Ronald L. Breiger and Philippa E Pattison. 1986. &quot;Cumulated social roles: The duality of persons and their algebras.&quot; <em>Social Networks</em> 8(13):215-256.
</p>

<hr>
<h2 id='h_index'>H-Index (<code>h_index</code>)</h2><span id='topic+h_index'></span>

<h3>Description</h3>

<p>Measure of ego network diversity for categorical attributes (Perry et al. 2018)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_index(ego_id, measure, prefix = NULL, suffix = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="h_index_+3A_ego_id">ego_id</code></td>
<td>
<p>A vector of ego identifiers located in an alter dataframe. If using data objects created by <code><a href="#topic+ego_netwrite">ego_netwrite</a></code>, this should be the data frame entitled <code>alters</code>.</p>
</td></tr>
<tr><td><code id="h_index_+3A_measure">measure</code></td>
<td>
<p>A vector of alter attributes for a given categorical measure.</p>
</td></tr>
<tr><td><code id="h_index_+3A_prefix">prefix</code></td>
<td>
<p>A character value indicating the desired prefix for the calculated homophily measure.</p>
</td></tr>
<tr><td><code id="h_index_+3A_suffix">suffix</code></td>
<td>
<p>A character value indicating the desired suffix for the calculated homophily measure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>h_index</code> returns a dataframe of vectors that include the ego identifier and h-index of diversity for the desired categorical attribute.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Run `ego_netwrite`
ngq_nw &lt;- ego_netwrite(egos = ngq_egos,
                      ego_id = ngq_egos$ego_id,

                      alters = ngq_alters,
                      alter_id = ngq_alters$alter_id,
                      alter_ego = ngq_alters$ego_id,

                      max_alters = 10,
                      alter_alter = ngq_aa,
                      aa_ego = ngq_aa$ego_id,
                      i_elements = ngq_aa$alter1,
                      j_elements = ngq_aa$alter2,
                      directed = FALSE)


# Get H-index for race
race_hindex &lt;- h_index(ego_id = ngq_nw$alters$ego_id,
                      measure = ngq_nw$alters$race,
                      prefix = "race")

race_hindex
</code></pre>

<hr>
<h2 id='hightech'>Multiplex Network of Relationships Between Managers of a High-Tech Company</h2><span id='topic+hightech'></span>

<h3>Description</h3>

<p>A network of a small hi-tech computer firm that sold, installed, and maintained computer
systems, represented as an edgelist. Relationships in the network can take on three modes:
1 represents advice relationships, 2 represents friendship relationships, and
3 represents chain of command (e.g., &quot;reporting-to&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hightech
</code></pre>


<h3>Format</h3>

<p>A data frame with 312 rows and 4 columns:
</p>

<dl>
<dt>node</dt><dd><p>Outgoing node</p>
</dd>
<dt>target</dt><dd><p>Receiving node</p>
</dd>
<dt>weight</dt><dd><p>A placeholder variable for tie/edge weights, set to 1</p>
</dd>
<dt>layer</dt><dd><p>Relation type</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p>Carnegie Mellon University (<a href="http://casos.cs.cmu.edu/computational_tools/datasets/external/Hi-tech/index2.html">Website</a>)
</p>


<h3>References</h3>

<p>David Krackhardt. 1987. &quot;Cognitive social structures&quot;. <em>Social Networks</em> 9(2):104-134. https://doi.org/10.1016/0378-8733(87)90009-8
</p>

<hr>
<h2 id='ideanetViz'>Interactive GUI for Working with Sociocentric Networks (<code>ideanetViz</code>)</h2><span id='topic+ideanetViz'></span>

<h3>Description</h3>

<p><code>ideanetViz</code> is a Shiny app that presents the output of <code>ideanet</code>'s workflow for sociocentric data (i.e. <code><a href="#topic+netwrite">netwrite</a></code>) in a clear and accessible GUI. This GUI is convenient for users with limited R experience and is useful for classrooms, workshops, and other educational spaces. It is also useful for experienced users interested in quick exploration of network data. Moreover, <code>ideanetViz</code> streamlines customization of network visualizations and provides quick access into <code>ideanet</code>'s more advanced analytic tools for sociocentric networks.
</p>
<p><code>ideanetViz</code>'s design is centered around a series of tabs lining the top of the app, which are ordered according to a typical workflow for acquiring, processing, exploring, and modeling data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ideanetViz()
</code></pre>


<h3>Value</h3>

<p>Launches an external window in which users can interact with the <code>ideanetViz</code> GUI. At different points in working with the GUI, users have the option to export generated data as CSV files and visualizations as image files.
</p>

<hr>
<h2 id='iqv'>Agresti's Index of Qualitative Variation (<code>iqv</code>)</h2><span id='topic+iqv'></span>

<h3>Description</h3>

<p>A normalized value of the h-index for measuring the diversity of an ego's network for categorical attributes (Perry et al. 2018)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iqv(ego_id, measure, prefix = NULL, suffix = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iqv_+3A_ego_id">ego_id</code></td>
<td>
<p>A vector of ego identifiers located in an alter dataframe. If using data objects created by <code>ego_netwrite</code>, this should be the data frame entitled <code>alters</code>.</p>
</td></tr>
<tr><td><code id="iqv_+3A_measure">measure</code></td>
<td>
<p>A vector of alter attributes for a given categorical measure.</p>
</td></tr>
<tr><td><code id="iqv_+3A_prefix">prefix</code></td>
<td>
<p>A character value indicating the desired prefix for the calculated homophily measure.</p>
</td></tr>
<tr><td><code id="iqv_+3A_suffix">suffix</code></td>
<td>
<p>A character value indicating the desired suffix for the calculated homophily measure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>iqv</code> returns a dataframe of vectors that include the ego identifier and iqv value of diversity for the desired categorical attribute.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Run `ego_netwrite`
ngq_nw &lt;- ego_netwrite(egos = ngq_egos,
                      ego_id = ngq_egos$ego_id,

                      alters = ngq_alters,
                      alter_id = ngq_alters$alter_id,
                      alter_ego = ngq_alters$ego_id,

                      max_alters = 10,
                      alter_alter = ngq_aa,
                      aa_ego = ngq_aa$ego_id,
                      i_elements = ngq_aa$alter1,
                      j_elements = ngq_aa$alter2,
                      directed = FALSE)


# Get IQV for sex
sex_iqv &lt;- iqv(ego_id = ngq_nw$alters$ego_id,
              measure = ngq_nw$alters$sex,
              prefix = "sex")

sex_iqv
</code></pre>

<hr>
<h2 id='marvel'>Character Relations in Marvel Comics</h2><span id='topic+marvel'></span>

<h3>Description</h3>

<p>A network, represented as edgelist, containing weighted edges between Marvel Comics characters.
Edge weights were calculated based on how many times two characters' names appeared within 15 words
of one another in a comic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marvel
</code></pre>


<h3>Format</h3>

<p>A data frame with 9891 rows and 3 columns:
</p>

<dl>
<dt>Source</dt><dd><p>Outgoing node</p>
</dd>
<dt>Target</dt><dd><p>Receiving node</p>
</dd>
<dt>Weight</dt><dd><p>Edge weight</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p>Melanie Walsh (<a href="https://github.com/melaniewalsh/sample-social-network-datasets/tree/master/sample-datasets/marvel">Github</a>),
adapted from data originally compiled by Cesc Rosselló, Ricardo Alberich,
and Joe Miro from Russ Chappell (<a href="https://www.chronologyproject.com">Website</a>)
</p>

<hr>
<h2 id='nc_merge'>Merging Network Canvas CSV Files (<code>nc_merge</code>)</h2><span id='topic+nc_merge'></span>

<h3>Description</h3>

<p>The <code>nc_merge</code> function combines CSV files exported from <a href="https://networkcanvas.com/">Network Canvas</a>, a popular tool for egocentric data capture. It is designed to address issues that may be encountered by <code>nc_read</code> when Network Canvas exports separate CSV files for individual responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nc_merge(path, export_path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nc_merge_+3A_path">path</code></td>
<td>
<p>A character value indicating the directory in which Network Canvas CSVs are located. <code>nc_read</code> will read in all CSV files located in this directory and process them.</p>
</td></tr>
<tr><td><code id="nc_merge_+3A_export_path">export_path</code></td>
<td>
<p>A character value indicating the directory to which merged CSV files should be exported. This should not be the same directory as <code>path</code>, and this function will return an error if it detects that <code>path</code> and <code>export_path</code> are equivalent.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>nc_merge</code> always writes two CSV files to the directory specified in <code>export_path</code>: an ego list and an alters list. If CSV files containing alter-alter ties are detected, it also writes a third merged CSV of these ties.
</p>

<hr>
<h2 id='nc_read'>Reading and Reshaping Network Canvas Data (<code>nc_read</code>)</h2><span id='topic+nc_read'></span>

<h3>Description</h3>

<p>The <code>nc_read</code> function reads in and processes CSV files produced by <a href="https://networkcanvas.com/">Network Canvas</a>, a popular tool for egocentric data capture. <code>nc_read</code> produces three dataframes optimized for use with <code><a href="#topic+ego_netwrite">ego_netwrite</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nc_read(path, protocol = NULL, cat.to.factor = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nc_read_+3A_path">path</code></td>
<td>
<p>A character value indicating the directory in which Network Canvas CSVs are located. <code>nc_read</code> will read in all CSV files located in this directory and process them.</p>
</td></tr>
<tr><td><code id="nc_read_+3A_protocol">protocol</code></td>
<td>
<p>A character value indicating the pathname of the Network Canvas protocol file corresponding to the data being read. Reading in the protocol is optional but recommended for accurate encoding of categorical variables.</p>
</td></tr>
<tr><td><code id="nc_read_+3A_cat.to.factor">cat.to.factor</code></td>
<td>
<p>A logical value indicating whether categorical variables, originally stored as a series of TRUE/FALSE columns, should be converted into a single factor column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>nc_read</code> returns a list containing three items: an ego list, an ego-alter edgelist, and an alter-alter edgelist. If multiple edge types exist for ego-alter and/or alter-alter ties, edgelists for each type of tie will be stored as individual data frames as elements in a list. All data frames are optimized for use with <code><a href="#topic+ego_netwrite">ego_netwrite</a></code>.  <br /> <br />
Note that in the <code>alters</code> data frame(s), column <code>node_type</code> reflects the &quot;node type&quot; assigned to a given alter as specified in a Network Canvas protocol. Values in <code>node_type</code> are not necessarily those which should be fed into the <code>alter_types</code> argument in <code><a href="#topic+ego_netwrite">ego_netwrite</a></code>.
</p>

<hr>
<h2 id='netread'>Reading Network Data Files and Initial Cleaning (<code>netread</code>)</h2><span id='topic+netread'></span>

<h3>Description</h3>

<p>The <code>netread</code> function reads in various files storing relational data converts them into edgelists that ensure their compatibility with other <code>ideanet</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netread(
  path = NULL,
  filetype = NULL,
  sheet = NULL,
  nodelist = NULL,
  node_sheet = NULL,
  object = NULL,
  col_names = TRUE,
  row_names = FALSE,
  format = NULL,
  net_name = "network",
  missing_code = 99999,
  i_elements = NULL,
  j_elements = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="netread_+3A_path">path</code></td>
<td>
<p>A character value indicating the path of the file which the data are to be read from. If <code>netread</code> is converting <code>igraph</code> or <code>network</code> objects, no file path is needed.</p>
</td></tr>
<tr><td><code id="netread_+3A_filetype">filetype</code></td>
<td>
<p>A character value indicating the type of file being read. Valid arguments are <code>"csv"</code>, <code>"excel"</code> (.xls, .xlsx), <code>"igraph"</code> (for <code>igraph</code> objects), <code>"network"</code> or <code>"sna"</code> (for <code>network</code> objects), <code>"pajek"</code> (for Pajek files), and <code>"ucinet"</code> (for UCINet files).</p>
</td></tr>
<tr><td><code id="netread_+3A_sheet">sheet</code></td>
<td>
<p>If reading in an Excel file with multiple sheets, a character value indicating the name of the sheet on which the core relational data are stored.</p>
</td></tr>
<tr><td><code id="netread_+3A_nodelist">nodelist</code></td>
<td>
<p>If the relational data being read have a corresponding file for node-level information, a character value indicating the path of the file which this data are to be read from.</p>
</td></tr>
<tr><td><code id="netread_+3A_node_sheet">node_sheet</code></td>
<td>
<p>If reading in an Excel file with multiple sheets, a character value indicating the name of the sheet on which the node-level information is store.</p>
</td></tr>
<tr><td><code id="netread_+3A_object">object</code></td>
<td>
<p>If converting an <code>igraph</code> or <code>network</code> object, the object to be converted.</p>
</td></tr>
<tr><td><code id="netread_+3A_col_names">col_names</code></td>
<td>
<p>For reading CSV and Excel files, a logical value indicating whether the first row in the file serves as the file's header and contains the names of each column.</p>
</td></tr>
<tr><td><code id="netread_+3A_row_names">row_names</code></td>
<td>
<p>For reading CSV and Excel files, a logical value indicating whether the first column in the file contains ID values for each row and should not be treated as part of the core data.</p>
</td></tr>
<tr><td><code id="netread_+3A_format">format</code></td>
<td>
<p>For reading CSV and Excel files, a character value indicating the format in which relational data are structured in the file. Valid arguments include <code>"edgelist"</code>, <code>"adjacency_matrix"</code>, and <code>"adjacency_list"</code>.</p>
</td></tr>
<tr><td><code id="netread_+3A_net_name">net_name</code></td>
<td>
<p>A character value indicating the name of the network being read from the file(s). This name will be used as a prefix for both outputs created by <code>netread</code>.</p>
</td></tr>
<tr><td><code id="netread_+3A_missing_code">missing_code</code></td>
<td>
<p>A numeric value indicating &quot;missing&quot; values in the data being read. Such &quot;missing&quot; values are sometimes included to identify the presence of isolated nodes in an edgelist when a corresponding nodelist is unavailable.</p>
</td></tr>
<tr><td><code id="netread_+3A_i_elements">i_elements</code></td>
<td>
<p>If <code>format</code> is set to <code>edgelist</code>, a character value indicating the name of the column containing the sender of ties in the edgelist. If not specified, <code>netread</code> assumes the first column of the data represents tie senders.</p>
</td></tr>
<tr><td><code id="netread_+3A_j_elements">j_elements</code></td>
<td>
<p>If <code>format</code> is set to <code>edgelist</code>, a character value indicating the name of the column containing the receiver of ties in the edgelist. If not specified, <code>netread</code> assumes the second column of the data represents tie receivers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing an edgelist and a nodelist, both of which are formatted to be compatible with the <code><a href="#topic+netwrite">netwrite</a></code> function.
</p>

<hr>
<h2 id='netwrite'>Network Cleaning and Variable Calculation (<code>netwrite</code>)</h2><span id='topic+netwrite'></span>

<h3>Description</h3>

<p>The <code>netwrite</code> function reads in relational data of several formats and processes them into a set of standardized outputs. These outputs include sets of commonly calculated measures at the individual node and network-wide levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netwrite(
  data_type = c("edgelist"),
  adjacency_matrix = FALSE,
  adjacency_list = FALSE,
  nodelist = FALSE,
  node_id = NULL,
  i_elements = FALSE,
  j_elements = FALSE,
  fix_nodelist = TRUE,
  weights = NULL,
  type = NULL,
  remove_loops = FALSE,
  missing_code = 99999,
  weight_type = "frequency",
  directed = FALSE,
  net_name = "network",
  shiny = FALSE,
  output = c("graph", "largest_bi_component", "largest_component", "node_measure_plot",
    "nodelist", "edgelist", "system_level_measures", "system_measure_plot"),
  message = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="netwrite_+3A_data_type">data_type</code></td>
<td>
<p>A character value indicating the type of relational data being entered into <code>netwrite</code>. Available options are <code>edgelist</code>, <code>adjacency_matrix</code>, and <code>adjacency_list</code>.</p>
</td></tr>
<tr><td><code id="netwrite_+3A_adjacency_matrix">adjacency_matrix</code></td>
<td>
<p>If <code>data_type</code> is set to <code>adjacency_matrix</code>, a matrix object containing the adjacency matrix for the network being processed.</p>
</td></tr>
<tr><td><code id="netwrite_+3A_adjacency_list">adjacency_list</code></td>
<td>
<p>If <code>data_type</code> is set to <code>adjacency_list</code>, a data frame containing the adjacency list for the network being processed.</p>
</td></tr>
<tr><td><code id="netwrite_+3A_nodelist">nodelist</code></td>
<td>
<p>Either a vector of values indicating unique node/vertex IDs, or a data frame including all information about nodes in the network. If the latter, a value for <code>node_id</code> must be specified.</p>
</td></tr>
<tr><td><code id="netwrite_+3A_node_id">node_id</code></td>
<td>
<p>If a data frame is entered for the <code>nodelist</code> arugment, <code>node_id</code> should be a character value indicating the name of the column in the node-level data frame containing unique node identifiers.</p>
</td></tr>
<tr><td><code id="netwrite_+3A_i_elements">i_elements</code></td>
<td>
<p>If <code>data_type</code> is set to <code>"edgelist"</code>, a numeric or character vector indicating the sender of ties in the edgelist.</p>
</td></tr>
<tr><td><code id="netwrite_+3A_j_elements">j_elements</code></td>
<td>
<p>If <code>data_type</code> is set to <code>"edgelist"</code>, a numeric or character vector indicating the receiver of ties in the edgelist.</p>
</td></tr>
<tr><td><code id="netwrite_+3A_fix_nodelist">fix_nodelist</code></td>
<td>
<p>If <code>data_type</code> is set to <code>"edgelist"</code> and user inputs a vector or data frame into <code>nodelist</code>, a logical value indicating whether to include node IDs that do not appear in the nodelist but do appear in the edgelist in the nodelist used when processing network data. By default, <code>fix_nodelist</code> is set to <code>FALSE</code> to identify potential inconsistencies between the nodelist and edgelist to the user.</p>
</td></tr>
<tr><td><code id="netwrite_+3A_weights">weights</code></td>
<td>
<p>A numeric vector indicating the weight of ties in the edgelist. <code>netwrite</code> requires that all edge weights be positive values.</p>
</td></tr>
<tr><td><code id="netwrite_+3A_type">type</code></td>
<td>
<p>A numeric or character vector indicating the types of relationships represented in the edgelist. If <code>type</code> contains this vector, <code>netwrite</code> will treat the data as a multi-relational network and produce additional outputs reflecting the different types of ties occurring in the network.</p>
</td></tr>
<tr><td><code id="netwrite_+3A_remove_loops">remove_loops</code></td>
<td>
<p>A logical value indicating whether &quot;self-loops&quot; (ties directed toward oneself) should be considered valid ties in the network being processed.</p>
</td></tr>
<tr><td><code id="netwrite_+3A_missing_code">missing_code</code></td>
<td>
<p>A numeric value indicating &quot;missing&quot; values in an edgelist. Such &quot;missing&quot; values are sometimes included to identify the presence of isolated nodes in an edgelist when a corresponding nodelist is unavailable.</p>
</td></tr>
<tr><td><code id="netwrite_+3A_weight_type">weight_type</code></td>
<td>
<p>A character value indicating whether edge weights should be treated as frequencies or distances. Available options are <code>"frequency"</code>, indicating that higher values represent stronger ties, and <code>"distance"</code>, indicating that higher values represent weaker ties. Note: some underlying functions assume that edges represent distances. If <code>weight_type</code> is set to <code>"frequency"</code>, these functions will use the reciprocal of <code>weights</code> as distance values in calculation.</p>
</td></tr>
<tr><td><code id="netwrite_+3A_directed">directed</code></td>
<td>
<p>A logical value indicating whether edges should be treated as a directed or undirected when constructing the network.</p>
</td></tr>
<tr><td><code id="netwrite_+3A_net_name">net_name</code></td>
<td>
<p>A character value indicating the name to which network/igraph objects should be given.</p>
</td></tr>
<tr><td><code id="netwrite_+3A_shiny">shiny</code></td>
<td>
<p>A logical value indicating whether <code>netwrite</code> is being used in conjunction with IDEANet's Shiny-based visualization app. <code>shiny</code> should also be set to <code>TRUE</code> when using <code>ideanet</code> in an R Markdown file that users expect to knit into a document.</p>
</td></tr>
<tr><td><code id="netwrite_+3A_output">output</code></td>
<td>
<p>A character vector indicating the kinds of objects <code>netwrite</code> should assign to the global environment. <code>netwrite</code> produces several outputs that may not all be necessary to a user's needs. Users can specify which outputs they specifically want in order to minimize the number of objects appearing in the global environment. Potential outputs include igraph object(s) (<code>"graph"</code>), subgraph(s) of only nodes that appear in the largest component and/or bicomponent of the network (<code>"largest_component"</code>, <code>"largest_bi_component"</code>), data frame(s) containing node-level measures (<code>"node_measure_plot"</code>), a processed edgelist of the network (<code>"edgelist"</code>), a data frame indicating network-level summaries (<code>"system_level_measures"</code>), and summary visualizations for node- and network-level measures (<code>"node_measure_plot"</code>, <code>"system_measure_plot"</code>).</p>
</td></tr>
<tr><td><code id="netwrite_+3A_message">message</code></td>
<td>
<p>A logical value indicating whether warning messages should be displayed in the R console during processing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>netwrite</code> returns a list containing several output objects. Users may find it easier to access and work with outputs by applying <a href="base.html#topic+list2env">list2env</a> to this list, which will separate outputs and store them in the R Global Environment. Note, however, that this risks overwriting existing objects in the Global Environment should those objects share names with objects in <code>netwrite</code>'s output. Depending on the values assigned to the <code>output</code> argument, <code>netwrite</code> will produce any or all of the following:
</p>
<p>If <code>output</code> contains <code>graph</code>, <code>netwrite</code> will return an igraph object of the network represented in the original data.
If a vector is entered into the <code>type</code> argument, <code>netwrite</code> also produces a list containing igraph objects for each unique relation type as well as the overall network. These output objects are named according to the value specified in the <code>net_name</code> argument.
</p>
<p>If <code>output</code> contains <code>"nodelist"</code>, <code>netwrite</code> will return a dataframe containing individual-level information for each node in the network. This dataframe contains a set of frequently used node-level measures for each node in the network. If a vector is entered into the <code>type</code> argument, <code>netwrite</code> will produce these node-level measures for each unique relation type.
</p>
<p>If <code>output</code> contains <code>"edgelist"</code>, <code>netwrite</code> will return a formatted edgelist for the network represented in the original data. If a vector is entered into the <code>type</code> argument, <code>netwrite</code> also produces a list containing edgelists for each unique relation type as well as the overall network.
</p>
<p>If <code>output</code> contains <code>"system_level_measures"</code>, <code>netwrite</code> will return a data frame providing network-level summary information.
</p>
<p>If <code>output</code> contains <code>"node_measure_plot"</code>, <code>netwrite</code> will return a plot summarizing the distribution of frequently used node-level measures across all nodes in the network. If a vector is entered into the <code>type</code> argument, <code>netwrite</code> also produces a list containing node-level summary plots for each unique relation type as well as the overall network.
</p>
<p>If <code>output</code> contains <code>"system_measure_plot"</code>, <code>netwrite</code> will return a plot summarizing the distribution of frequently used network-level measures. If a vector is entered into the <code>type</code> argument, <code>netwrite</code> also produces a list containing network-level summary plots for each unique relation type as well as the overall network.
</p>
<p>If <code>output</code> contains <code>"largest_bi_component"</code>, <code>netwrite</code> will return an igraph object of the largest bicomponent in the network represented in the original data. If a vector is entered into the <code>type</code> argument, <code>netwrite</code> also produces a list containing the largest bicomponent for each unique relation type as well as the overall network.
</p>
<p>If <code>output</code> contains <code>"largest_bi_component"</code>, <code>netwrite</code> will return an igraph object of the largest main component in the network represented in the original data. If a vector is entered into the <code>type</code> argument, <code>netwrite</code> also produces a list containing the largest main component for each unique relation type as well as the overall network.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use netwrite on an edgelist
nw_fauxmesa &lt;- netwrite(nodelist = fauxmesa_nodes,
                      node_id = "id",
                      i_elements = fauxmesa_edges$from,
                      j_elements = fauxmesa_edges$to,
                      directed = TRUE,
                      net_name = "faux_mesa")

### Inspect updated edgelist
head(nw_fauxmesa$edgelist)

### Inspect data frame of node-level measures
head(nw_fauxmesa$node_measures)

### Inspect system-level summary
head(nw_fauxmesa$system_level_measures)

### Plot sociogram of network
plot(nw_fauxmesa$faux_mesa)

### View node-level summary visualization
nw_fauxmesa$node_measure_plot

### View system-level summary visualization
nw_fauxmesa$system_measure_plot



# Run netwrite on an adjacency matrix

nw_triad &lt;- netwrite(data_type = "adjacency_matrix",
                     adjacency_matrix = triad,
                     directed = TRUE,
                     net_name = "triad_igraph")
</code></pre>

<hr>
<h2 id='ngq_aa'>Ego Networks Elicited from the &quot;Important Matters&quot; Name Generator Question (Alter-Alter Edgelist)</h2><span id='topic+ngq_aa'></span>

<h3>Description</h3>

<p>This dataset contains a simplified subset of 20 ego networks elicited using the &quot;important matters&quot; name generator question (NGQ),
which is frequently used to capture an individual's close personal ties. These networks were collected as part
of an experiment illustrating how networks generated by this question may vary depending on the topics covered in
preceding survey items. Networks were collected using an online survey deployed via Amazon Mechanical Turk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ngq_aa
</code></pre>


<h3>Format</h3>

<p>A data frame with 123 rows and 5 columns:
</p>

<dl>
<dt>ego_id</dt><dd><p>Unique identifier for ego providing network</p>
</dd>
<dt>alter1</dt><dd><p>Within-network unique identifier for Alter 1 in alter-alter edgelist.</p>
</dd>
<dt>alter2</dt><dd><p>Within-network unique identifier for Alter 2 in alter-alter edgelist.</p>
</dd>
<dt>type</dt><dd><p>A character indicating the type of relationship that Alter 1 and Alter 2 have with one another. Note that each dyad-type combination has its own unique row in this dataset, so more than one row may correspond to a single dyad if the dyad involves multiple types of relationships.</p>
</dd>
<dt>freqtalk</dt><dd><p>A numeric indicating how frequently ego believes Alter 1 and Alter 2 talk with one another. <code>1</code> indicates &quot;Never,&quot; <code>2</code> &quot;Less than once a month,&quot; <code>3</code> &quot;1-3 times a month,&quot; <code>4</code> &quot;1-3 times a week,&quot; <code>5</code> &quot;Daily or almost daily.&quot;</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p>Original Data, Collected by Danielle Montagne, Joseph Quinn, Liann Tucker, and Tom Wolff.
</p>

<hr>
<h2 id='ngq_alters'>Ego Networks Elicited from the &quot;Important Matters&quot; Name Generator Question (Alter List)</h2><span id='topic+ngq_alters'></span>

<h3>Description</h3>

<p>This dataset contains a simplifed subset of 20 ego networks elicited using the &quot;important matters&quot; name generator question (NGQ),
which is frequently used to capture an individual's close personal ties. These networks were collected as part
of an experiment illustrating how networks generated by this question may vary depending on the topics covered in
preceding survey items. Networks were collected using an online survey deployed via Amazon Mechanical Turk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ngq_alters
</code></pre>


<h3>Format</h3>

<p>A data frame with 67 rows and 14 columns:
</p>

<dl>
<dt>ego_id</dt><dd><p>Unique identifier for ego providing network</p>
</dd>
<dt>alter_id</dt><dd><p>Within-network unique identifier for person nominated by ego (alter).</p>
</dd>
<dt>sex</dt><dd><p>A numeric indicating alter's sex as reported by ego. <code>1</code> indicates male, <code>2</code> female.</p>
</dd>
<dt>race</dt><dd><p>A character indicating a simplified characterization of alter's race/ethnicity as reported by ego. Values include <code>"White"</code>, <code>"Black"</code>, and <code>"Other"</code>.</p>
</dd>
<dt>black</dt><dd><p>A logical indicating ego's perception of alter as &quot;Black&quot; or &quot;African-American.&quot;</p>
</dd>
<dt>white</dt><dd><p>A logical indicating ego's perception of alter as &quot;White.&quot;</p>
</dd>
<dt>other_race</dt><dd><p>A logical indicating ego's perception of alter as belonging to a racial/ethnic group other than &quot;Black,&quot; &quot;African-American,&quot; or &quot;White.&quot;</p>
</dd>
<dt>pol</dt><dd><p>A numeric indicating political orientation on a seven-point scale, as perceived by ego. <code>1</code> indicates &quot;Extremely Liberal,&quot; <code>4</code> &quot;Moderate,&quot; and <code>7</code> &quot;Extremely Conservative.&quot;</p>
</dd>
<dt>family</dt><dd><p>A logical indicating alter as ego's family member.</p>
</dd>
<dt>friend</dt><dd><p>A logical indicating alter as ego's friend.</p>
</dd>
<dt>other_rel</dt><dd><p>A logical indicating alter as have a relationship to ego other than one of the types of relationships listed above.</p>
</dd>
<dt>face</dt><dd><p>A numeric indicating how frequently ego and alter interact in person. <code>1</code> indicates &quot;Never,&quot; <code>2</code> &quot;Less than once a month,&quot; <code>3</code> &quot;1-3 times a month,&quot; <code>4</code> &quot;1-3 times a week,&quot; <code>5</code> &quot;Daily or almost daily.&quot;</p>
</dd>
<dt>phone</dt><dd><p>A numeric indicating how frequently ego and alter talk on the phone or via video chat. <code>1</code> indicates &quot;Never,&quot; <code>2</code> &quot;Less than once a month,&quot; <code>3</code> &quot;1-3 times a month,&quot; <code>4</code> &quot;1-3 times a week,&quot; <code>5</code> &quot;Daily or almost daily.&quot;</p>
</dd>
<dt>text</dt><dd><p>A numeric indicating how frequently ego and alter interact via electronic messaging (e.g. texting, email, social media). <code>1</code> indicates &quot;Never,&quot; <code>2</code> &quot;Less than once a month,&quot; <code>3</code> &quot;1-3 times a month,&quot; <code>4</code> &quot;1-3 times a week,&quot; <code>5</code> &quot;Daily or almost daily.&quot;</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p>Original Data, Collected by Danielle Montagne, Joseph Quinn, Liann Tucker, and Tom Wolff.
</p>

<hr>
<h2 id='ngq_egos'>Ego Networks Elicited from the &quot;Important Matters&quot; Name Generator Question (Nodelist)</h2><span id='topic+ngq_egos'></span>

<h3>Description</h3>

<p>This dataset contains a simplified subset of 20 ego networks elicited using the &quot;important matters&quot; name generator question (NGQ),
which is frequently used to capture an individual's close personal ties. These networks were collected as part
of an experiment illustrating how networks generated by this question may vary depending on the topics covered in
preceding survey items. Networks were collected using an online survey deployed via Amazon Mechanical Turk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ngq_egos
</code></pre>


<h3>Format</h3>

<p>A data frame with 20 rows and 9 columns:
</p>

<dl>
<dt>ego_id</dt><dd><p>Unique identifier for ego providing network</p>
</dd>
<dt>age</dt><dd><p>A numeric indicating ego's self-reported age</p>
</dd>
<dt>sex</dt><dd><p>A numeric indicating ego's self-reported sex. <code>1</code> indicates male, <code>2</code> female.</p>
</dd>
<dt>race</dt><dd><p>A character indicating a simplification of ego's self-reported race/ethnicity. Values include <code>"White"</code>, <code>"Black"</code>, and <code>"Other"</code>.</p>
</dd>
<dt>black</dt><dd><p>A logical indicating ego's self-identification as &quot;Black&quot; or &quot;African-American.&quot;</p>
</dd>
<dt>white</dt><dd><p>A logical indicating ego's self-identification as &quot;White.&quot;</p>
</dd>
<dt>other_race</dt><dd><p>A logical indicating ego's self-identification with a race or ethnicity other than &quot;Black,&quot; &quot;African-American,&quot; or &quot;White.&quot;</p>
</dd>
<dt>edu</dt><dd><p>A numeric indicating ego's highest level of educational attainment. <code>1</code> indicates less than a high school diploma, <code>4</code> indicates a high school diploma or GED, <code>5</code> some college, <code>6</code> a college degree, and <code>7</code> a graduate or professional degree.</p>
</dd>
<dt>pol</dt><dd><p>A numeric indicating ego's self-identified political orientation on a seven-point scale. <code>1</code> indicates &quot;Extremely Liberal,&quot; <code>4</code> &quot;Moderate,&quot; and <code>7</code> &quot;Extremely Conservative.&quot;</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p>Original Data, Collected by Danielle Montagne, Joseph Quinn, Liann Tucker, and Tom Wolff.
</p>

<hr>
<h2 id='pearson_phi'>Pearson's Phi (<code>pearson_phi</code>)</h2><span id='topic+pearson_phi'></span>

<h3>Description</h3>

<p>The <code>pearson_phi</code> function identifies the underlying homophilous preference of ego based on the distribution of alter attributes in the population (Perry et al. 2018)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pearson_phi(
  ego_id,
  ego_measure,
  alter_ego,
  alter_measure,
  prefix = NULL,
  suffix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pearson_phi_+3A_ego_id">ego_id</code></td>
<td>
<p>A vector of unique ego identifiers located in an ego dataframe. If using data objects created by <code>ego_netwrite</code>, this should be the data frame entitled <code>egos</code>.</p>
</td></tr>
<tr><td><code id="pearson_phi_+3A_ego_measure">ego_measure</code></td>
<td>
<p>A vector of attributes corresponding to each ego.</p>
</td></tr>
<tr><td><code id="pearson_phi_+3A_alter_ego">alter_ego</code></td>
<td>
<p>A vector of ego identifiers located in an alter dataframe. If using data objects created by <code>ego_netwrite</code>, this should be the data frame entitled <code>alters</code>.</p>
</td></tr>
<tr><td><code id="pearson_phi_+3A_alter_measure">alter_measure</code></td>
<td>
<p>A vector of attributes corresponding to each alter</p>
</td></tr>
<tr><td><code id="pearson_phi_+3A_prefix">prefix</code></td>
<td>
<p>A character value indicating the desired prefix for the calculated homophily measure.</p>
</td></tr>
<tr><td><code id="pearson_phi_+3A_suffix">suffix</code></td>
<td>
<p>A character value indicating the desired suffix for the calculated homophily measure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>pearson_phi</code> returns a dataframe of vectors that include the ego identifier and phi value of homophilous preference.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Run `ego_netwrite`
ngq_nw &lt;- ego_netwrite(egos = ngq_egos,
                      ego_id = ngq_egos$ego_id,

                      alters = ngq_alters,
                      alter_id = ngq_alters$alter_id,
                      alter_ego = ngq_alters$ego_id,

                      max_alters = 10,
                      alter_alter = ngq_aa,
                      aa_ego = ngq_aa$ego_id,
                      i_elements = ngq_aa$alter1,
                      j_elements = ngq_aa$alter2,
                      directed = FALSE)


race_pphi &lt;- pearson_phi(ego_id = ngq_nw$egos$ego_id, ego_measure = ngq_nw$egos$race,
                        alter_ego = ngq_nw$alters$ego_id, alter_measure = ngq_nw$alters$race,
                        suffix = "race")

race_pphi
</code></pre>

<hr>
<h2 id='qap_run'>Quadratic Assignment Procedure (<code>qap_run</code>).</h2><span id='topic+qap_run'></span>

<h3>Description</h3>

<p>The <code>qap_run</code> function is a wrapper around <code>sna</code>'s Quadratic Assignment Procedure models <code><a href="sna.html#topic+netlm">sna::netlm</a></code> and <code><a href="sna.html#topic+netlogit">sna::netlogit</a></code>. It expects a networks objects containing dependent and independent variables of interest. It is required to use the output from <code><a href="#topic+qap_setup">qap_setup</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qap_run(
  net,
  dependent = NULL,
  variables,
  directed = FALSE,
  family = "linear",
  reps = 500
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qap_run_+3A_net">net</code></td>
<td>
<p>An <code>igraph</code> or <code>network</code> object.</p>
</td></tr>
<tr><td><code id="qap_run_+3A_dependent">dependent</code></td>
<td>
<p>A string naming the dependent variable of interest. By default, the probability of a tie. Can also be the output of <code><a href="#topic+qap_setup">qap_setup</a></code> using prefixes &quot;same_&quot;, &quot;diff_&quot; or &quot;abs_diff_&quot;.</p>
</td></tr>
<tr><td><code id="qap_run_+3A_variables">variables</code></td>
<td>
<p>A vector of strings naming the independent variables of interest. Must be the output of <code><a href="#topic+qap_setup">qap_setup</a></code> using prefixes &quot;same_&quot;, &quot;diff_&quot; and &quot;abs_diff_&quot;, or suffixes &quot;_ego&quot; and &quot;_alter&quot;.</p>
</td></tr>
<tr><td><code id="qap_run_+3A_directed">directed</code></td>
<td>
<p>A logical statement identifying if the network should be treated as directed. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="qap_run_+3A_family">family</code></td>
<td>
<p>A string identifying the functional form. Options are <code>"linear"</code> and <code>"binomial"</code>. Defauts to <code>"linear"</code>.</p>
</td></tr>
<tr><td><code id="qap_run_+3A_reps">reps</code></td>
<td>
<p>A numeric value indicating the number of draws. Defaults to 500.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'qap_run' returns a list of elements that include:
</p>
<p>- <code>covs_df</code>, a data frame containing term labels, estimates, standard errors and p-values
</p>
<p>- <code>mods_df</code>, a data frame containing model-level information including the number of observations, AIC and BIC statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
flor &lt;- netwrite(nodelist = florentine_nodes,
                 node_id = "id",
                 i_elements = florentine_edges$source,
                 j_elements = florentine_edges$target,
                 type = florentine_edges$type,
                 directed = FALSE,
                 net_name = "florentine_graph")

flor_setup &lt;- qap_setup(flor$florentine_graph,
                        variables = c("total_degree"),
                        methods = c("difference"))

flor_qap &lt;- qap_run(flor_setup$graph,
                    variables = c("diff_total_degree"))

# Inspect results
flor_qap$covs_df
</code></pre>

<hr>
<h2 id='qap_setup'>Individual to Dyadic variable transformation (<code>qap_setup</code>).</h2><span id='topic+qap_setup'></span>

<h3>Description</h3>

<p>The <code>qap_setup</code> function transform an individual level attributes into dyadic comparisons following a set of methods. Output can be used to compute QAP measurements using sister functions in <code>ideanet</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qap_setup(
  net,
  variables = NULL,
  methods = NULL,
  directed = FALSE,
  additional_vars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qap_setup_+3A_net">net</code></td>
<td>
<p>An <code>igraph</code> or <code>network</code> object.</p>
</td></tr>
<tr><td><code id="qap_setup_+3A_variables">variables</code></td>
<td>
<p>A vector of strings naming attributes to be transformed from individual-level to dyadic-level.</p>
</td></tr>
<tr><td><code id="qap_setup_+3A_methods">methods</code></td>
<td>
<p>A vector of strings naming methods to be applied to the <code>variables</code> vector. The <code>methods</code> vector must be the same length as the <code>variables</code> vector. Methods are applied in order (e.g, first method is applied to the first named attribute in <code>variables</code>). Possible methods are &quot;reduced_category&quot;, &quot;multi_category&quot;, &quot;both&quot;, and &quot;difference&quot;. For more information about methods, consult the included vignette.</p>
</td></tr>
<tr><td><code id="qap_setup_+3A_directed">directed</code></td>
<td>
<p>A logical statement identifying if the network should be treated as directed. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="qap_setup_+3A_additional_vars">additional_vars</code></td>
<td>
<p>A data frame containing additional individual-level variables not contained in the primary network input. Additional dataframe must contain an <code>id</code> or <code>label</code> variables which matches network exactly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>qap_setup</code> returns a list of elements that include:
</p>
<p>- <code>graph</code>, an updated <code>igraph</code> object containing the newly constructed dyadic variables and additional individual-level variables.
</p>
<p>- <code>nodes</code>, a nodelist reflecting additional variables if included.
</p>
<p>- <code>edges</code>, a nodelist reflecting new dyadic variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

flor &lt;- netwrite(nodelist = florentine_nodes,
                 node_id = "id",
                 i_elements = florentine_edges$source,
                 j_elements = florentine_edges$target,
                 type = florentine_edges$type,
                 directed = FALSE,
                 net_name = "florentine_graph")

flor_setup &lt;- qap_setup(flor$florentine_graph,
                        variables = c("total_degree"),
                        methods = c("difference"))
</code></pre>

<hr>
<h2 id='role_analysis'>Positional (Role) Analysis in Networks (<code>role_analysis</code>)</h2><span id='topic+role_analysis'></span>

<h3>Description</h3>

<p>The <code>role_analysis</code> function takes networks processed by the <code><a href="#topic+netwrite">netwrite</a></code> function and performs positional analysis on them. Positional analysis methods allows users to infer distinct &quot;roles&quot; in networks from patterns in network activity. <code>role_analysis</code> currently supports the identification of roles using two methods: hierarchical clustering (cite) and convergence of correlations (CONCOR, Breiger 1975).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>role_analysis(
  graph,
  nodes,
  directed = NA,
  method = "cluster",
  min_partitions = NA,
  max_partitions = NA,
  min_partition_size = NA,
  backbone = 0.9,
  viz = FALSE,
  fast_triad = NULL,
  retain_variables = FALSE,
  cluster_summaries = FALSE,
  dendro_names = FALSE,
  self_ties = FALSE,
  cutoff = 0.999,
  max_iter = 50
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="role_analysis_+3A_graph">graph</code></td>
<td>
<p>An igraph object or a list of igraph objects produced as output from <code><a href="#topic+netwrite">netwrite</a></code>.</p>
</td></tr>
<tr><td><code id="role_analysis_+3A_nodes">nodes</code></td>
<td>
<p>A data frame containing individual-level network measures for each node in the network. Ideally, the <code>node_measures</code> data frame produced by <code><a href="#topic+netwrite">netwrite</a></code> should be assigned to this argument.</p>
</td></tr>
<tr><td><code id="role_analysis_+3A_directed">directed</code></td>
<td>
<p>A logical value indicating whether network edges should be treated as directed.</p>
</td></tr>
<tr><td><code id="role_analysis_+3A_method">method</code></td>
<td>
<p>A character value indicating the method used for positional analysis. Valid arguments are currently <code>"cluster"</code> for hierarchical clustering and <code>"concor"</code> for CONCOR.</p>
</td></tr>
<tr><td><code id="role_analysis_+3A_min_partitions">min_partitions</code></td>
<td>
<p>A numeric value indicating the number of minimum number of clusters or partitions to assign to nodes in the network. When using hierarchical clustering, this value reflects the minimum number of clusters produced by analysis. When using CONCOR, this value reflects the minimum number of partitions produced in analysis, such that a value of 1 results in a partitioning of two groups, a value of 2 results in four groups, and so on.</p>
</td></tr>
<tr><td><code id="role_analysis_+3A_max_partitions">max_partitions</code></td>
<td>
<p>A numeric value indicating the number of maximum number of clusters or partitions to assign to nodes in the network. When using hierarchical clustering, this value reflects the maximum number of clusters produced by analysis. When using CONCOR, this value reflects the maximum number of partitions produced in analysis, such that a value of 1 results in a partitioning of two groups, a value of 2 results in four groups, and so on.</p>
</td></tr>
<tr><td><code id="role_analysis_+3A_min_partition_size">min_partition_size</code></td>
<td>
<p>A numeric value indicating the minimum number of nodes required for inclusion in a cluster. If an inferred cluster or partition contains fewer nodes than the number assigned to <code>min_partition_size</code>, nodes in this cluster/partition will be labeled as members of a parent cluster/partition.</p>
</td></tr>
<tr><td><code id="role_analysis_+3A_backbone">backbone</code></td>
<td>
<p>A numeric value ranging from 0-1 indicating which edges in the similarity/correlation matrix should be kept when calculating modularity of cluster/partition assignments. When calculating optimal modularity, it helps to backbone the similarity/correlation matrix according to the nth percentile. Larger networks benefit from higher <code>backbone</code> values, while lower values generally benefit smaller networks.</p>
</td></tr>
<tr><td><code id="role_analysis_+3A_viz">viz</code></td>
<td>
<p>A logical value indicating whether to produce summary visualizations of the positional analysis.</p>
</td></tr>
<tr><td><code id="role_analysis_+3A_fast_triad">fast_triad</code></td>
<td>
<p>(Hierarchical clustering method only.) A logical value indicating whether to use a faster method for counting individual nodes' positions in different types of triads. This faster method may lead to memory issues and should be avoided when working with larger networks.</p>
</td></tr>
<tr><td><code id="role_analysis_+3A_retain_variables">retain_variables</code></td>
<td>
<p>(Hierarchical clustering method only.) A logical value indicating whether output should include a data frame of all node-level measures used in hierarchical clustering.</p>
</td></tr>
<tr><td><code id="role_analysis_+3A_cluster_summaries">cluster_summaries</code></td>
<td>
<p>(Hierarchical clustering method only.) A logical value indicating whether output should includde a data frame containing by-cluster mean values of variables used in hierarchical clustering.</p>
</td></tr>
<tr><td><code id="role_analysis_+3A_dendro_names">dendro_names</code></td>
<td>
<p>(Hierarchical clustering method only.) A logical value indicating whether the cluster dendrogram visualization should display node labels rather than ID numbers.</p>
</td></tr>
<tr><td><code id="role_analysis_+3A_self_ties">self_ties</code></td>
<td>
<p>(CONCOR only.) A logical value indicting whether to include self-loops (ties directed toward oneself) in CONCOR calculation.</p>
</td></tr>
<tr><td><code id="role_analysis_+3A_cutoff">cutoff</code></td>
<td>
<p>(CONCOR only.) A numeric value ranging from 0 to 1 that indicates the correlation cutoff for detecting convergence in CONCOR calculation.</p>
</td></tr>
<tr><td><code id="role_analysis_+3A_max_iter">max_iter</code></td>
<td>
<p>(CONCOR only.) A numeric value indicating the maximum number of iteractions allowed for CONCOR calculattion.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>role_analysis</code> returns a list of outputs that users can access to help interpret results. This contents of this list varies somewhat depending on the method being used for positional analysis.
</p>
<p>When hierarchical clustering is used, the list contains the following:
<code>cluster_assignments</code> is a data frame indicating each node's membership within inferred clusters at each level of partitioning.
<code>cluster_sociogram</code> contains a visualization of the network wherein nodes are colored by their membership within clusters at the optimal level of partitioning.
<code>cluster_dendrogram</code> is a visualization of the dendrogram produced from clustering nodes. Red boxes on the visualization indicate nodes' cluster memberships at the optimal level of partitioning.
<code>cluster_modularity</code> is a visualization of the modularity scores of the matrix of similarity scores between nodes for each level of partitioning. This visualization helps identify the optimal level of partitioning inferred by the <code>role_analysis</code> function.
<code>cluster_summaries_cent</code> contains one or more visualization representing how clusters inferred at the optimal level of partitioning differ from one another on several important node-level measures.
<code>cluster_summaries_triad</code> contains one or more visualization representing how clusters inferred at the optimal level of partitioning differ from one another on in terms of their positions within certain kinds of triads in the network.
<code>cluster_relations_heatmaps</code> is a list object containing several heatmap visualizations representing the extent to which nodes in one inferred cluster are connected to nodes in another cluster.
<code>cluster_relations_sociogram</code> contains a network visualization representing the extent to which nodes in clusters inferred at the optimal level of partitioning are tied to one another. Nodes in this visualization represent inferred clusters in the aggregate.
</p>
<p>When CONCOR is used, this list contains the following:
<code>concor_assignments</code> is a data frame indicating each node's membership within inferred blocks at each level of partitioning.
<code>concor_sociogram</code> contains a visualization of the network wherein nodes are colored by their membership within blocks at the optimal level of partitioning.
<code>concor_block_tree</code> is a visualization representing how smaller blocks are derived from larger blocks at each level of partitioning using CONCOR.
<code>concor_modularity</code> is a visualization of the modularity scores of the matrix of similarity scores between nodes for each level of partitioning. This visualization helps identify the optimal level of partitioning inferred by the <code>role_analysis</code> function.
<code>concor_relations_heatmaps</code> is a list object containing several heatmap visualizations representing the extent to which nodes in one inferred block are connected to nodes in another block.
<code>concor_relations_sociogram</code> contains a network visualization representing the extent to which nodes in blocks inferred at the optimal level of partitioning are tied to one another. Nodes in this visualization represent inferred blocks in the aggregate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>flor &lt;- netwrite(nodelist = florentine_nodes,
                 node_id = "id",
                 i_elements = florentine_edges$source,
                 j_elements = florentine_edges$target,
                 type = florentine_edges$type,
                 directed = FALSE,
                 net_name = "florentine")

# Clustering method
flor_cluster &lt;- role_analysis(graph = flor$igraph_list,
                              nodes = flor$node_measures,
                              directed = FALSE,
                              method = "cluster",
                              min_partitions = 2,
                              max_partitions = 8,
                              viz = TRUE)

### View cluster dendrogram
flor_cluster$cluster_dendrogram

### View modularity summary plot
flor_cluster$cluster_modularity

### View cluster assignments
head(flor_cluster$cluster_assignments)

### View centrality summary plot for aggregate network
flor_cluster$cluster_summaries_cent$summary_graph
### View cenrality summary plot for network of relation `business`
flor_cluster$cluster_summaries_cent$business

### View triad position summary plot for network of relation `marriage`
flor_cluster$cluster_summaries_triad$marriage


# CONCOR method
flor_concor &lt;- role_analysis(graph = flor$igraph_list,
                             nodes = flor$node_measures,
                             directed = FALSE,
                             method = "concor",
                             min_partitions = 1,
                             max_partitions = 4,
                             viz = TRUE)

### View CONCOR tree
flor_concor$concor_block_tree

### View modularity summary plot
flor_concor$concor_modularity

### View cluster assignments
head(flor_concor$concor_assignments)

### View chi-squared heatmaps of relations between blocks
flor_concor$concor_relations_heatmaps$chisq
</code></pre>

<hr>
<h2 id='triad'>A Small Network Containing all Triads and Motifs</h2><span id='topic+triad'></span>

<h3>Description</h3>

<p>An adjacency matrix representing a network of 9 nodes, the ties between which form all possible
triads and 3-node motifs that can appear in a directed network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triad
</code></pre>


<h3>Format</h3>

<p>A matrix with 9 rows and 9 columns
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
